[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_TREES 100000\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int L, N;\n    scanf(\"%d %d\", &L, &N);\n    \n    int trees[MAX_TREES];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &trees[i]);\n    }\n    \n    qsort(trees, N, sizeof(int), compare);\n    \n    long long max_distance = 0;\n    bool burnt[MAX_TREES] = {false};\n    int current_pos = 0;\n    \n    for (int i = 0; i < N; i++) {\n        int best_clockwise = -1;\n        int best_counter_clockwise = -1;\n        long long best_clockwise_dist = 0;\n        long long best_counter_dist = 0;\n        \n        for (int j = 0; j < N; j++) {\n            if (!burnt[j]) {\n                long long clockwise_dist = (trees[j] >= current_pos) ? \n                    trees[j] - current_pos : \n                    L - current_pos + trees[j];\n                \n                long long counter_dist = (trees[j] <= current_pos) ? \n                    current_pos - trees[j] : \n                    current_pos + L - trees[j];\n                \n                if (best_clockwise == -1 || clockwise_dist < best_clockwise_dist) {\n                    best_clockwise = j;\n                    best_clockwise_dist = clockwise_dist;\n                }\n                \n                if (best_counter_clockwise == -1 || counter_dist < best_counter_dist) {\n                    best_counter_clockwise = j;\n                    best_counter_dist = counter_dist;\n                }\n            }\n        }\n        \n        if (best_clockwise_dist <= best_counter_dist) {\n            max_distance += best_clockwise_dist;\n            current_pos = trees[best_clockwise];\n            burnt[best_clockwise] = true;\n        } else {\n            max_distance += best_counter_dist;\n            current_pos = trees[best_counter_clockwise];\n            burnt[best_counter_clockwise] = true;\n        }\n    }\n    \n    printf(\"%lld\\n\", max_distance);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:59:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int *)a - *(int *)b);\n}\n\nint main() {\n    int L, N;\n    scanf(\"%d %d\", &L, &N);\n    int *X = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n    qsort(X, N, sizeof(int), compare);\n\n    long long *prefix = (long long *)malloc((N + 1) * sizeof(long long));\n    prefix[0] = 0;\n    for (int i = 1; i <= N; i++) {\n        prefix[i] = prefix[i - 1] + X[i - 1];\n    }\n\n    long long *suffix = (long long *)malloc((N + 1) * sizeof(long long));\n    suffix[N] = 0;\n    for (int i = N - 1; i >= 0; i--) {\n        suffix[i] = suffix[i + 1] + (L - X[i]);\n    }\n\n    long long max = 0;\n    for (int k = 1; k <= N; k++) {\n        int m = N - k;\n        long long dist;\n        if (k > m) {\n            dist = 2 * (prefix[k] - prefix[k - m - 1]) + 2 * suffix[k] - X[k - 1] - (L - X[k - 1]);\n        } else if (k < m) {\n            dist = 2 * (prefix[k]) + 2 * (suffix[k] - suffix[k + m]) - X[k - 1] - (L - X[k + m - 1]);\n        } else {\n            dist = 2 * (prefix[k]) + 2 * (suffix[k]) - X[k - 1] - (L - X[k - 1]);\n        }\n        if (dist > max) {\n            max = dist;\n        }\n    }\n    printf(\"%lld\\n\", max);\n    free(X);\n    free(prefix);\n    free(suffix);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:59:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int L, N;\n    cin >> L >> N;\n    vector<int> X(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> X[i];\n    }\n\n    vector<long long> left_sum(N + 1, 0), right_sum(N + 1, 0);\n    for (int i = 0; i < N; ++i) {\n        left_sum[i + 1] = left_sum[i] + X[i];\n    }\n    for (int i = N - 1; i >= 0; --i) {\n        right_sum[i] = right_sum[i + 1] + (L - X[i]);\n    }\n\n    long long max_distance = 0;\n    for (int k = 0; k <= N; ++k) {\n        int m = N - k;\n        if (k > m) {\n            long long distance = 2 * (left_sum[k] - left_sum[k - m]) + 2 * (right_sum[k - m + 1] - right_sum[k + 1]) - X[k - 1];\n            max_distance = max(max_distance, distance);\n        } else if (k < m) {\n            long long distance = 2 * (left_sum[k] - left_sum[0]) + 2 * (right_sum[k + 1] - right_sum[k + 1 + k]) - (L - X[k]);\n            max_distance = max(max_distance, distance);\n        } else {\n            long long distance = 2 * (left_sum[k] - left_sum[0]) + 2 * (right_sum[k + 1] - right_sum[N]) - max(X[k - 1], L - X[k]);\n            max_distance = max(max_distance, distance);\n        }\n    }\n\n    cout << max_distance << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:59:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int L = sc.nextInt();\n        int N = sc.nextInt();\n        int[] X = new int[N];\n        for (int i = 0; i < N; i++) {\n            X[i] = sc.nextInt();\n        }\n\n        long[] clockwisePrefix = new long[N + 1];\n        long[] counterClockwisePrefix = new long[N + 1];\n        for (int i = 0; i < N; i++) {\n            clockwisePrefix[i + 1] = clockwisePrefix[i] + X[i];\n        }\n        for (int i = 0; i < N; i++) {\n            counterClockwisePrefix[i + 1] = counterClockwisePrefix[i] + (L - X[N - 1 - i]);\n        }\n\n        long maxDistance = 0;\n        for (int k = 1; k <= N; k++) {\n            int c = k;\n            int m = N - k;\n            if (m >= c) {\n                long distance = 2 * (clockwisePrefix[c] + counterClockwisePrefix[c]) - X[c - 1];\n                maxDistance = Math.max(maxDistance, distance);\n            } else {\n                long distance = 2 * (clockwisePrefix[c] + counterClockwisePrefix[m]) - (L - X[N - m]);\n                maxDistance = Math.max(maxDistance, distance);\n            }\n            if (c >= m) {\n                long distance = 2 * (clockwisePrefix[m] + counterClockwisePrefix[m]) - (L - X[N - m]);\n                maxDistance = Math.max(maxDistance, distance);\n            } else {\n                long distance = 2 * (clockwisePrefix[c] + counterClockwisePrefix[m]) - X[c - 1];\n                maxDistance = Math.max(maxDistance, distance);\n            }\n        }\n        System.out.println(maxDistance);\n    }\n}",
    "timestamp": "2025-08-05 23:00:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TakahashiLake {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int L = sc.nextInt();\n        int N = sc.nextInt();\n        \n        int[] trees = new int[N];\n        for (int i = 0; i < N; i++) {\n            trees[i] = sc.nextInt();\n        }\n        \n        System.out.println(solve(L, N, trees));\n    }\n    \n    static long solve(int L, int N, int[] trees) {\n        Arrays.sort(trees);\n        long maxDistance = 0;\n        \n        for (int clockwise = 0; clockwise < 2; clockwise++) {\n            long distance = 0;\n            boolean[] burnt = new boolean[N];\n            int current = 0;\n            \n            for (int i = 0; i < N; i++) {\n                int nextTree = findNextTree(L, trees, burnt, current, clockwise == 1);\n                \n                if (nextTree == -1) break;\n                \n                int treeIndex = Arrays.binarySearch(trees, nextTree);\n                \n                distance += calculateDistance(L, current, nextTree, clockwise == 1);\n                current = nextTree;\n                burnt[treeIndex] = true;\n            }\n            \n            maxDistance = Math.max(maxDistance, distance);\n        }\n        \n        return maxDistance;\n    }\n    \n    static int findNextTree(int L, int[] trees, boolean[] burnt, int current, boolean clockwise) {\n        int result = -1;\n        int minDist = Integer.MAX_VALUE;\n        \n        for (int i = 0; i < trees.length; i++) {\n            if (!burnt[i]) {\n                int dist = calculateDistance(L, current, trees[i], clockwise);\n                if (dist < minDist) {\n                    minDist = dist;\n                    result = trees[i];\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    static int calculateDistance(int L, int from, int to, boolean clockwise) {\n        if (clockwise) {\n            return from > to ? from - to : L - to + from;\n        } else {\n            return to > from ? to - from : L - from + to;\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:00:19"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int L, N;\n    cin >> L >> N;\n    \n    vector<int> trees(N);\n    for (int i = 0; i < N; i++) {\n        cin >> trees[i];\n    }\n    \n    sort(trees.begin(), trees.end());\n    \n    long long max_distance = 0;\n    int current_pos = 0;\n    \n    // Try both clockwise and counter-clockwise\n    for (int direction = 0; direction < 2; direction++) {\n        vector<bool> burnt(N, false);\n        current_pos = 0;\n        long long total_distance = 0;\n        \n        while (true) {\n            int next_tree = -1;\n            \n            if (direction == 0) {  // Counter-clockwise\n                for (int i = 0; i < N; i++) {\n                    if (!burnt[i] && trees[i] > current_pos) {\n                        next_tree = i;\n                        break;\n                    }\n                }\n                \n                if (next_tree == -1) {\n                    for (int i = 0; i < N; i++) {\n                        if (!burnt[i]) {\n                            next_tree = i;\n                            break;\n                        }\n                    }\n                }\n            } else {  // Clockwise\n                for (int i = N - 1; i >= 0; i--) {\n                    if (!burnt[i] && trees[i] < current_pos) {\n                        next_tree = i;\n                        break;\n                    }\n                }\n                \n                if (next_tree == -1) {\n                    for (int i = N - 1; i >= 0; i--) {\n                        if (!burnt[i]) {\n                            next_tree = i;\n                            break;\n                        }\n                    }\n                }\n            }\n            \n            if (next_tree == -1) break;\n            \n            int distance;\n            if (direction == 0) {  // Counter-clockwise\n                distance = (trees[next_tree] - current_pos + L) % L;\n            } else {  // Clockwise\n                distance = (current_pos - trees[next_tree] + L) % L;\n            }\n            \n            total_distance += distance;\n            current_pos = trees[next_tree];\n            burnt[next_tree] = true;\n        }\n        \n        max_distance = max(max_distance, total_distance);\n    }\n    \n    cout << max_distance << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:00:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def longest_walk(L, N, trees):\n    trees.sort()\n    max_distance = 0\n    \n    for start in range(N):\n        distance_cw = (trees[start] + L - trees[start - 1]) % L\n        \n        for i in range(1, N):\n            j = (start + i) % N\n            distance_cw += (trees[j] - trees[start + i - 1]) % L\n            \n        distance_ccw = (trees[start] + L - trees[start - 1]) % L\n        \n        for i in range(1, N):\n            j = (start - i) % N\n            distance_ccw += (trees[j] - trees[start - i + 1]) % L\n\n        max_distance = max(max_distance, distance_cw, distance_ccw)\n    \n    return max_distance\n\n# Example usage:\nL = 10\nN = 3\ntrees = [3, 6, 9]\nprint(longest_walk(L, N, trees))",
    "timestamp": "2025-08-13 13:14:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class TakahashiLake {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Read the perimeter and number of trees\n        int L = scanner.nextInt();\n        int N = scanner.nextInt();\n        \n        // Read the coordinates of the trees\n        int[] trees = new int[N];\n        for (int i = 0; i < N; i++) {\n            trees[i] = scanner.nextInt();\n        }\n        \n        scanner.close();\n        \n        // Sort the tree coordinates\n        Arrays.sort(trees);\n        \n        long clockwiseDistance = 0;\n        long counterClockwiseDistance = 0;\n        \n        // Compute the clockwise distance\n        for (int i = 0; i < N; i++) {\n            if (i == 0) {\n                clockwiseDistance += trees[i];\n            } else {\n                clockwiseDistance += trees[i] - trees[i - 1];\n            }\n        }\n        \n        // If we return to the residence clockwisely\n        clockwiseDistance += L - trees[N - 1];\n        \n        // Compute the counter-clockwise distance\n        for (int i = N - 1; i >= 0; i--) {\n            if (i == N - 1) {\n                counterClockwiseDistance += L - trees[i];\n            } else {\n                counterClockwiseDistance += trees[i + 1] - trees[i];\n            }\n        }\n        \n        // If we return to the residence counter-clockwisely\n        counterClockwiseDistance += trees[0];\n        \n        // Find the maximum distance\n        long maxDistance = Math.max(clockwiseDistance, counterClockwiseDistance);\n        \n        System.out.println(maxDistance);\n    }\n}",
    "timestamp": "2025-08-13 13:14:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint compare(const void *a, const void *b) {\n    return (*(int *)a) - (*(int *)b);\n}\n\nint main() {\n    int N, L;\n    scanf(\"%d %d\", &N, &L);\n    int X[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &X[i]);\n    }\n\n    qsort(X, N, sizeof(int), compare);\n\n    int max_distance = 0;\n    int clockwise_distance = 0;\n    int counter_clockwise_distance = 0;\n\n    for (int i = 0; i < N; i++) {\n        clockwise_distance += (i == 0) ? X[i] : X[i] - X[i - 1];\n        int remaining = (i == N - 1) ? (L - X[i]) : (X[i + 1] - X[i]);\n\n        max_distance = ((2 * clockwise_distance + remaining) > max_distance) ?\n                       (2 * clockwise_distance + remaining) : max_distance;\n    }\n\n    for (int i = N - 1; i >= 0; i--) {\n        counter_clockwise_distance += (i == N - 1) ? (L - X[i]) : (X[i + 1] - X[i]);\n        int remaining = (i == 0) ? X[i] : (X[i] - X[i - 1]);\n\n        max_distance = ((2 * counter_clockwise_distance + remaining) > max_distance) ?\n                       (2 * counter_clockwise_distance + remaining) : max_distance;\n    }\n\n    printf(\"%d\\n\", max_distance);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:14:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int L, N;\n    cin >> L >> N;\n\n    vector<int> X(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> X[i];\n    }\n\n    sort(X.begin(), X.end());\n\n    // Calculate clockwise and counter-clockwise distances\n    int clockwiseDistance = X[N - 1]; // End of clockwise path is the furthermost tree\n    int counterClockwiseDistance = L - X[0]; // Start of counter-clockwise path is the nearest tree\n\n    vector<int> clockwiseWalks(N);\n    vector<int> counterClockwiseWalks(N);\n\n    for (int i = 1; i < N; ++i) {\n        clockwiseWalks[i] = X[i] - X[i - 1];\n        counterClockwiseWalks[i] = L - (X[i] - X[i - 1]);\n    }\n\n    int maxClockwise = clockwiseDistance;\n    int maxCounterClockwise = counterClockwiseDistance;\n\n    int cumulativeClockwise = clockwiseDistance;\n    int cumulativeCounterClockwise = counterClockwiseDistance;\n\n    for (int i = N - 1; i > 0; --i) {\n        cumulativeClockwise += (L - clockwiseWalks[i]);\n        cumulativeCounterClockwise += counterClockwiseWalks[i];\n\n        maxClockwise = max(maxClockwise, cumulativeClockwise);\n        maxCounterClockwise = max(maxCounterClockwise, cumulativeCounterClockwise);\n    }\n\n    cout << max(maxClockwise, maxCounterClockwise) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 13:14:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(L, N, X):\n    X.sort()\n    max_dist = 0\n    visited = [False] * N\n\n    for start_dir in range(2):\n        total_dist = 0\n        curr_pos = 0\n        unburnt_trees = set(range(N))\n\n        while unburnt_trees:\n            if start_dir == 0:  # Counter-clockwise\n                next_tree = min((x for x in X if not visited[X.index(x)]), default=None)\n                if next_tree is None:\n                    break\n                dist = (next_tree - curr_pos + L) % L\n                total_dist += dist\n                curr_pos = next_tree\n                visited[X.index(next_tree)] = True\n                unburnt_trees.remove(X.index(next_tree))\n            else:  # Clockwise\n                next_tree = max((x for x in X if not visited[X.index(x)]), default=None)\n                if next_tree is None:\n                    break\n                dist = (curr_pos - next_tree + L) % L\n                total_dist += dist\n                curr_pos = next_tree\n                visited[X.index(next_tree)] = True\n                unburnt_trees.remove(X.index(next_tree))\n\n        max_dist = max(max_dist, total_dist)\n        visited = [False] * N\n\n    return max_dist\n\n# Input handling\nL, N = map(int, input().split())\nX = list(map(int, input().split()))\nprint(solve(L, N, X))",
    "timestamp": "2025-08-13 13:14:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    L, N = map(int, sys.stdin.readline().split())\n    X = [int(sys.stdin.readline()) for _ in range(N)]\n    \n    # Precompute prefix and suffix sums\n    prefix = [0] * (N + 1)\n    for i in range(N):\n        prefix[i+1] = prefix[i] + X[i]\n    \n    suffix = [0] * (N + 1)\n    for i in range(N-1, -1, -1):\n        suffix[i] = suffix[i+1] + (L - X[i])\n    \n    max_dist = 0\n    \n    # Check all possible k: number of trees burned in one direction before switching\n    for k in range(1, N+1):\n        # Case 1: start with clockwise (right)\n        if k <= N - k:\n            dist = 2 * (prefix[k] + suffix[N - k + 1])\n        else:\n            dist = 2 * (prefix[k] + suffix[N - k + 1]) - X[N - k]\n        max_dist = max(max_dist, dist)\n        \n        # Case 2: start with counter-clockwise (left)\n        if k <= N - k:\n            dist = 2 * (suffix[N - k + 1] + prefix[k]) - (L - X[N - k])\n        else:\n            dist = 2 * (suffix[N - k + 1] + prefix[k]) - (L - X[N - k]) - X[(2 * k - N) - 1]\n        max_dist = max(max_dist, dist)\n    \n    print(max_dist)\n\nsolve()",
    "timestamp": "2025-08-13 13:15:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function longestWalk(L, N, treeCoordinates) {\n    treeCoordinates.sort((a, b) => a - b);\n    let clockwiseDistance = 0;\n    let counterClockwiseDistance = 0;\n\n    // Calculate clockwise distance\n    for (let i = 1; i < N; i++) {\n        clockwiseDistance += treeCoordinates[i] - treeCoordinates[i - 1];\n    }\n    clockwiseDistance += (L - treeCoordinates[N - 1]) + treeCoordinates[0];\n\n    // Calculate counter-clockwise distance\n    for (let i = N - 1; i > 0; i--) {\n        counterClockwiseDistance += treeCoordinates[i] - treeCoordinates[i - 1];\n    }\n    counterClockwiseDistance += treeCoordinates[N - 1] + (L - treeCoordinates[0]);\n\n    return Math.max(clockwiseDistance, counterClockwiseDistance);\n}",
    "timestamp": "2025-08-13 13:15:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(L, N, X) {\n    X.sort((a, b) => a - b);\n    let totalDistance = 0;\n    let currentPos = 0;\n    const burnt = new Array(N).fill(false);\n    let treesLeft = N;\n\n    while (treesLeft > 0) {\n        let bestClockwise = -1;\n        let bestCounterClockwise = -1;\n        let clockwiseDistance = Infinity;\n        let counterClockwiseDistance = Infinity;\n\n        for (let i = 0; i < N; i++) {\n            if (!burnt[i]) {\n                let clockwiseDist = (L + X[i] - currentPos) % L;\n                let counterClockwiseDist = (L + currentPos - X[i]) % L;\n\n                if (clockwiseDist < clockwiseDistance) {\n                    bestClockwise = i;\n                    clockwiseDistance = clockwiseDist;\n                }\n\n                if (counterClockwiseDist < counterClockwiseDistance) {\n                    bestCounterClockwise = i;\n                    counterClockwiseDistance = counterClockwiseDist;\n                }\n            }\n        }\n\n        if (clockwiseDistance <= counterClockwiseDistance) {\n            totalDistance += clockwiseDistance;\n            currentPos = X[bestClockwise];\n            burnt[bestClockwise] = true;\n        } else {\n            totalDistance += counterClockwiseDistance;\n            currentPos = X[bestCounterClockwise];\n            burnt[bestCounterClockwise] = true;\n        }\n\n        treesLeft--;\n    }\n\n    return totalDistance;\n}",
    "timestamp": "2025-08-13 13:15:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [L, N] = input[0].split(' ').map(Number);\n    const X = input.slice(1, N + 1).map(Number);\n    \n    const prefixSum = new Array(N + 1).fill(0);\n    const suffixSum = new Array(N + 1).fill(0);\n    \n    for (let i = 0; i < N; i++) {\n        prefixSum[i + 1] = prefixSum[i] + X[i];\n    }\n    \n    for (let i = N - 1; i >= 0; i--) {\n        suffixSum[i] = suffixSum[i + 1] + (L - X[i]);\n    }\n    \n    let maxDistance = 0;\n    \n    for (let k = 0; k <= N; k++) {\n        const m = N - k;\n        if (k >= m) {\n            const a = k - m;\n            const distance = 2 * (prefixSum[k] - prefixSum[a] + suffixSum[k]) - X[k - 1];\n            maxDistance = Math.max(maxDistance, distance);\n        }\n        if (k >= m + 1) {\n            const a = k - m - 1;\n            const distance = 2 * (prefixSum[k] - prefixSum[a] + suffixSum[k]) - (L - X[k - 1]);\n            maxDistance = Math.max(maxDistance, distance);\n        }\n        if (m >= k) {\n            const b = k + m;\n            const distance = 2 * (prefixSum[k] + suffixSum[k] - suffixSum[b]) - (L - X[k]);\n            maxDistance = Math.max(maxDistance, distance);\n        }\n        if (m >= k + 1) {\n            const b = k + m + 1;\n            const distance = 2 * (prefixSum[k] + suffixSum[k] - suffixSum[b]) - X[k];\n            maxDistance = Math.max(maxDistance, distance);\n        }\n    }\n    \n    console.log(maxDistance);\n}\n\nsolve();",
    "timestamp": "2025-08-13 13:15:26"
  }
]