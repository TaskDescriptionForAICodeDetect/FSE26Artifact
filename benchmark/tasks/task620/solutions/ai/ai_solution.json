[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_VERTICES 1000\n\n// Structure to represent an edge\ntypedef struct {\n    int src;\n    int dest;\n    int weight;\n} Edge;\n\n// Structure to represent a graph\ntypedef struct {\n    int V, E;\n    Edge* edges;\n} Graph;\n\n// Disjoint Set Union data structure\nint parent[MAX_VERTICES];\nint rank[MAX_VERTICES];\n\n// Function to initialize disjoint set\nvoid makeSet(int n) {\n    for (int i = 0; i < n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n\n// Find operation with path compression\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\n// Union operation by rank\nvoid unionSet(int x, int y) {\n    int xroot = find(x);\n    int yroot = find(y);\n\n    if (xroot == yroot)\n        return;\n\n    if (rank[xroot] < rank[yroot])\n        parent[xroot] = yroot;\n    else if (rank[xroot] > rank[yroot])\n        parent[yroot] = xroot;\n    else {\n        parent[yroot] = xroot;\n        rank[xroot]++;\n    }\n}\n\n// Comparison function for sorting edges\nint compareEdges(const void* a, const void* b) {\n    Edge* edge1 = (Edge*)a;\n    Edge* edge2 = (Edge*)b;\n    return edge1->weight - edge2->weight;\n}\n\n// Kruskal's algorithm to find Minimum Spanning Tree\nint kruskalMST(Graph* graph) {\n    int V = graph->V;\n    int E = graph->E;\n    int mstWeight = 0;\n\n    // Sort edges in non-decreasing order of weights\n    qsort(graph->edges, E, sizeof(Edge), compareEdges);\n\n    // Initialize disjoint set\n    makeSet(V);\n\n    // Process edges in sorted order\n    for (int i = 0; i < E; i++) {\n        int x = find(graph->edges[i].src);\n        int y = find(graph->edges[i].dest);\n\n        if (x != y) {\n            mstWeight += graph->edges[i].weight;\n            unionSet(x, y);\n        }\n    }\n\n    return mstWeight;\n}\n\nint main() {\n    Graph graph;\n    scanf(\"%d %d\", &graph.V, &graph.E);\n\n    graph.edges = malloc(graph.E * sizeof(Edge));\n\n    for (int i = 0; i < graph.E; i++) {\n        scanf(\"%d %d %d\", &graph.edges[i].src, &graph.edges[i].dest, &graph.edges[i].weight);\n    }\n\n    int minimumSpanningTreeWeight = kruskalMST(&graph);\n    printf(\"%d\\n\", minimumSpanningTreeWeight);\n\n    free(graph.edges);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:20:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int u, v, weight;\n} Edge;\n\nint compare(const void *a, const void *b) {\n    Edge *edgeA = (Edge *)a;\n    Edge *edgeB = (Edge *)b;\n    return edgeA->weight - edgeB->weight;\n}\n\nint find(int parent[], int i) {\n    if (parent[i] != i) {\n        parent[i] = find(parent, parent[i]);\n    }\n    return parent[i];\n}\n\nvoid unionSets(int parent[], int rank[], int x, int y) {\n    int xroot = find(parent, x);\n    int yroot = find(parent, y);\n\n    if (rank[xroot] < rank[yroot]) {\n        parent[xroot] = yroot;\n    } else if (rank[xroot] > rank[yroot]) {\n        parent[yroot] = xroot;\n    } else {\n        parent[yroot] = xroot;\n        rank[xroot]++;\n    }\n}\n\nint kruskalMST(Edge edges[], int V, int E) {\n    qsort(edges, E, sizeof(Edge), compare);\n\n    int *parent = (int *)malloc(V * sizeof(int));\n    int *rank = (int *)calloc(V, sizeof(int));\n\n    for (int i = 0; i < V; i++) {\n        parent[i] = i;\n    }\n\n    int mstWeight = 0;\n    int edgeCount = 0;\n\n    for (int i = 0; i < E && edgeCount < V - 1; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int weight = edges[i].weight;\n\n        int setU = find(parent, u);\n        int setV = find(parent, v);\n\n        if (setU != setV) {\n            mstWeight += weight;\n            unionSets(parent, rank, setU, setV);\n            edgeCount++;\n        }\n    }\n\n    free(parent);\n    free(rank);\n\n    return mstWeight;\n}\n\nint main() {\n    int V, E;\n    scanf(\"%d %d\", &V, &E);\n\n    Edge *edges = (Edge *)malloc(E * sizeof(Edge));\n    for (int i = 0; i < E; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].weight);\n    }\n\n    int mstWeight = kruskalMST(edges, V, E);\n    printf(\"%d\\n\", mstWeight);\n\n    free(edges);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:20:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int u, v, weight;\n    bool operator<(Edge const& other) {\n        return weight < other.weight;\n    }\n};\n\nvector<int> parent, rank_;\n\nvoid make_set(int v) {\n    parent[v] = v;\n    rank_[v] = 0;\n}\n\nint find_set(int v) {\n    if (v == parent[v])\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\n\nvoid union_sets(int a, int b) {\n    a = find_set(a);\n    b = find_set(b);\n    if (a != b) {\n        if (rank_[a] < rank_[b])\n            swap(a, b);\n        parent[b] = a;\n        if (rank_[a] == rank_[b])\n            rank_[a]++;\n    }\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<Edge> edges(m);\n    for (int i = 0; i < m; i++) {\n        cin >> edges[i].u >> edges[i].v >> edges[i].weight;\n    }\n\n    sort(edges.begin(), edges.end());\n\n    parent.resize(n);\n    rank_.resize(n);\n    for (int i = 0; i < n; i++)\n        make_set(i);\n\n    int total_weight = 0;\n    for (Edge e : edges) {\n        if (find_set(e.u) != find_set(e.v)) {\n            total_weight += e.weight;\n            union_sets(e.u, e.v);\n        }\n    }\n\n    cout << total_weight << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:20:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Edge implements Comparable<Edge> {\n    int src, dest, weight;\n\n    public Edge(int src, int dest, int weight) {\n        this.src = src;\n        this.dest = dest;\n        this.weight = weight;\n    }\n\n    @Override\n    public int compareTo(Edge other) {\n        return this.weight - other.weight;\n    }\n}\n\nclass UnionFind {\n    private int[] parent;\n    private int[] rank;\n\n    public UnionFind(int size) {\n        parent = new int[size];\n        rank = new int[size];\n        for (int i = 0; i < size; i++) {\n            parent[i] = i;\n        }\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    public void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n}\n\npublic class Solution {\n    public static int minimumSpanningTreeSum(List<Edge> edges, int vertices) {\n        Collections.sort(edges);\n        UnionFind uf = new UnionFind(vertices);\n        int sum = 0;\n        int edgesAdded = 0;\n\n        for (Edge edge : edges) {\n            if (edgesAdded == vertices - 1) break;\n            int rootSrc = uf.find(edge.src);\n            int rootDest = uf.find(edge.dest);\n            if (rootSrc != rootDest) {\n                uf.union(rootSrc, rootDest);\n                sum += edge.weight;\n                edgesAdded++;\n            }\n        }\n\n        return sum;\n    }\n}",
    "timestamp": "2025-08-05 22:21:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    static class Edge {\n        int src, dest, weight;\n        \n        Edge(int src, int dest, int weight) {\n            this.src = src;\n            this.dest = dest;\n            this.weight = weight;\n        }\n    }\n    \n    static class DisjointSet {\n        int[] parent, rank;\n        \n        DisjointSet(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            \n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX == rootY) return;\n            \n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n    \n    public static int minimumSpanningTree(int n, List<Edge> edges) {\n        Collections.sort(edges, (a, b) -> a.weight - b.weight);\n        \n        DisjointSet ds = new DisjointSet(n);\n        int mstWeight = 0;\n        \n        for (Edge edge : edges) {\n            if (ds.find(edge.src) != ds.find(edge.dest)) {\n                ds.union(edge.src, edge.dest);\n                mstWeight += edge.weight;\n            }\n        }\n        \n        return mstWeight;\n    }\n}",
    "timestamp": "2025-08-05 22:21:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass DisjointSet {\nprivate:\n    vector<int> parent, rank;\n\npublic:\n    DisjointSet(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++)\n            parent[i] = i;\n    }\n\n    int find(int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    void unionSets(int x, int y) {\n        int xroot = find(x);\n        int yroot = find(y);\n\n        if (xroot == yroot)\n            return;\n\n        if (rank[xroot] < rank[yroot])\n            parent[xroot] = yroot;\n        else if (rank[xroot] > rank[yroot])\n            parent[yroot] = xroot;\n        else {\n            parent[yroot] = xroot;\n            rank[xroot]++;\n        }\n    }\n};\n\nint kruskalMST(int n, vector<vector<int>>& edges) {\n    sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[2] < b[2];\n    });\n\n    DisjointSet ds(n);\n    int mstWeight = 0;\n\n    for (const auto& edge : edges) {\n        int u = edge[0], v = edge[1], weight = edge[2];\n        \n        if (ds.find(u) != ds.find(v)) {\n            ds.unionSets(u, v);\n            mstWeight += weight;\n        }\n    }\n\n    return mstWeight;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<vector<int>> edges(m);\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        edges[i] = {u-1, v-1, w};\n    }\n\n    cout << kruskalMST(n, edges) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:21:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, u):\n        if self.parent[u] != u:\n            self.parent[u] = self.find(self.parent[u])\n        return self.parent[u]\n\n    def union(self, u, v):\n        rootU = self.find(u)\n        rootV = self.find(v)\n        if rootU != rootV:\n            if self.rank[rootU] > self.rank[rootV]:\n                self.parent[rootV] = rootU\n            elif self.rank[rootU] < self.rank[rootV]:\n                self.parent[rootU] = rootV\n            else:\n                self.parent[rootV] = rootU\n                self.rank[rootU] += 1\n            return True\n        return False\n\ndef minimum_spanning_tree_weight(V, edges):\n    uf = UnionFind(V)\n    edges.sort(key=lambda x: x[2])\n    mst_weight = 0\n    for u, v, weight in edges:\n        if uf.union(u, v):\n            mst_weight += weight\n    return mst_weight\n\n# Example usage\nV = 4  # number of vertices\nedges = [\n    (0, 1, 10),\n    (0, 2, 6),\n    (0, 3, 5),\n    (1, 3, 15),\n    (2, 3, 4)\n]\n\nprint(minimum_spanning_tree_weight(V, edges))  # Output: 19",
    "timestamp": "2025-08-13 10:06:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MSTSum {\n    static class Edge implements Comparable<Edge> {\n        int src, dest, weight;\n\n        Edge(int src, int dest, int weight) {\n            this.src = src;\n            this.dest = dest;\n            this.weight = weight;\n        }\n\n        @Override\n        public int compareTo(Edge other) {\n            return Integer.compare(this.weight, other.weight);\n        }\n    }\n\n    static class UnionFind {\n        private final int[] parent, rank;\n\n        UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n\n        int find(int node) {\n            if (parent[node] != node) {\n                parent[node] = find(parent[node]);\n            }\n            return parent[node];\n        }\n\n        void union(int u, int v) {\n            int rootU = find(u);\n            int rootV = find(v);\n            if (rootU != rootV) {\n                if (rank[rootU] < rank[rootV]) {\n                    parent[rootU] = rootV;\n                } else if (rank[rootU] > rank[rootV]) {\n                    parent[rootV] = rootU;\n                } else {\n                    parent[rootV] = rootU;\n                    rank[rootU]++;\n                }\n            }\n        }\n    }\n\n    public static int kruskalMST(int V, List<Edge> edges) {\n        Collections.sort(edges);\n        UnionFind uf = new UnionFind(V);\n\n        int mstWeight = 0;\n        for (Edge edge : edges) {\n            if (uf.find(edge.src) != uf.find(edge.dest)) {\n                uf.union(edge.src, edge.dest);\n                mstWeight += edge.weight;\n            }\n        }\n        return mstWeight;\n    }\n\n    public static void main(String[] args) {\n        List<Edge> edges = new ArrayList<>();\n        edges.add(new Edge(0, 1, 10));\n        edges.add(new Edge(0, 2, 6));\n        edges.add(new Edge(0, 3, 5));\n        edges.add(new Edge(1, 3, 15));\n        edges.add(new Edge(2, 3, 4));\n\n        int V = 4; // Number of vertices\n        int minimumSpanningTreeWeight = kruskalMST(V, edges);\n        System.out.println(\"Sum of weights of Minimum Spanning Tree: \" + minimumSpanningTreeWeight);\n    }\n}",
    "timestamp": "2025-08-13 10:06:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define INF 1000000\n\ntypedef struct {\n    int src, dest, weight;\n} Edge;\n\ntypedef struct {\n    int V, E;\n    Edge* edge;\n} Graph;\n\nGraph* createGraph(int V, int E) {\n    Graph* graph = (Graph*)malloc(sizeof(Graph));\n    graph->V = V;\n    graph->E = E;\n    graph->edge = (Edge*)malloc(E * sizeof(Edge));\n    return graph;\n}\n\nint find(int parent[], int i) {\n    if (parent[i] != i) {\n        parent[i] = find(parent, parent[i]);\n    }\n    return parent[i];\n}\n\nvoid Union(int parent[], int rank[], int x, int y) {\n    int rootX = find(parent, x);\n    int rootY = find(parent, y);\n    \n    if (rank[rootX] < rank[rootY]) {\n        parent[rootX] = rootY;\n    } else if (rank[rootX] > rank[rootY]) {\n        parent[rootY] = rootX;\n    } else {\n        parent[rootY] = rootX;\n        rank[rootX]++;\n    }\n}\n\nint compareEdges(const void* a, const void* b) {\n    Edge* edgeA = (Edge*)a;\n    Edge* edgeB = (Edge*)b;\n    return edgeA->weight - edgeB->weight;\n}\n\nint kruskalMST(Graph* graph) {\n    Edge result[graph->V]; \n    int e = 0; \n    int i = 0; \n    qsort(graph->edge, graph->E, sizeof(graph->edge[0]), compareEdges);\n    \n    int* parent = (int*)malloc(graph->V * sizeof(int));\n    int* rank = (int*)malloc(graph->V * sizeof(int));\n\n    for (int v = 0; v < graph->V; ++v) {\n        parent[v] = v;\n        rank[v] = 0;\n    }\n\n    while (e < graph->V - 1 && i < graph->E) {\n        Edge next_edge = graph->edge[i++];\n        int x = find(parent, next_edge.src);\n        int y = find(parent, next_edge.dest);\n\n        if (x != y) {\n            result[e++] = next_edge;\n            Union(parent, rank, x, y);\n        }\n    }\n    \n    int sumWeight = 0;\n    for (i = 0; i < e; ++i)\n        sumWeight += result[i].weight;\n    \n    free(parent);\n    free(rank);\n    \n    return sumWeight;\n}\n\nint main() {\n    int V = 4; \n    int E = 5;\n    Graph* graph = createGraph(V, E);\n\n    graph->edge[0].src = 0;\n    graph->edge[0].dest = 1;\n    graph->edge[0].weight = 10;\n\n    graph->edge[1].src = 0;\n    graph->edge[1].dest = 2;\n    graph->edge[1].weight = 6;\n\n    graph->edge[2].src = 0;\n    graph->edge[2].dest = 3;\n    graph->edge[2].weight = 5;\n\n    graph->edge[3].src = 1;\n    graph->edge[3].dest = 3;\n    graph->edge[3].weight = 15;\n\n    graph->edge[4].src = 2;\n    graph->edge[4].dest = 3;\n    graph->edge[4].weight = 4;\n\n    printf(\"Sum of weights of Minimum Spanning Tree: %d\\n\", kruskalMST(graph));\n\n    free(graph->edge);\n    free(graph);\n    return 0;\n}",
    "timestamp": "2025-08-13 10:07:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return False\n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n        return True\n\ndef kruskal_mst_weight(n, edges):\n    edges.sort(key=lambda x: x[2])\n    uf = UnionFind(n)\n    mst_weight = 0\n\n    for u, v, w in edges:\n        if uf.union(u, v):\n            mst_weight += w\n\n    return mst_weight",
    "timestamp": "2025-08-13 10:07:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef minimum_spanning_tree_weight(vertices, edges):\n    graph = {v: [] for v in vertices}\n    for u, v, weight in edges:\n        graph[u].append((weight, v))\n        graph[v].append((weight, u))\n    \n    min_heap = []\n    visited = set()\n    start_vertex = vertices[0]\n    visited.add(start_vertex)\n    for edge in graph[start_vertex]:\n        heapq.heappush(min_heap, edge)\n    \n    total_weight = 0\n    \n    while min_heap and len(visited) < len(vertices):\n        weight, u = heapq.heappop(min_heap)\n        if u not in visited:\n            visited.add(u)\n            total_weight += weight\n            for edge in graph[u]:\n                if edge[1] not in visited:\n                    heapq.heappush(min_heap, edge)\n    \n    return total_weight",
    "timestamp": "2025-08-13 10:07:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> Edge; // Pair of (weight, vertex)\ntypedef vector<vector<Edge>> Graph;\n\nint findMSTSum(const Graph &graph, int V) {\n    vector<bool> inMST(V, false);\n    priority_queue<Edge, vector<Edge>, greater<Edge>> pq; // Min-heap for edges\n    \n    pq.push({0, 0}); // Starting with vertex 0 and weight 0\n    int mstSum = 0;\n    \n    while (!pq.empty()) {\n        auto [weight, vertex] = pq.top();\n        pq.pop();\n        \n        if (inMST[vertex]) continue;\n        \n        inMST[vertex] = true;\n        mstSum += weight;\n        \n        for (const auto &[nextWeight, nextVertex] : graph[vertex]) {\n            if (!inMST[nextVertex]) {\n                pq.push({nextWeight, nextVertex});\n            }\n        }\n    }\n    \n    return mstSum;\n}\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n    \n    Graph graph(V);\n    \n    for (int i = 0; i < E; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        graph[u].push_back({w, v});\n        graph[v].push_back({w, u});\n    }\n    \n    cout << findMSTSum(graph, V) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:57:19"
  }
]