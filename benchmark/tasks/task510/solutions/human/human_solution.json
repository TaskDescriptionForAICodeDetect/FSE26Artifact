[
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct RollingHash {\n    typedef long long int_type;\n    typedef pair<int_type,int_type> hash_type;\n\n    int_type base1;\n    int_type base2;\n    int_type mod1;\n    int_type mod2;\n    vector<int_type> hash1;\n    vector<int_type> hash2;\n    vector<int_type> pow1;\n    vector<int_type> pow2;\n\n    RollingHash() : base1(1009), base2(1007), mod1(1000000007), mod2(1000000009) {}\n\n    void init(const string &s) {\n        int n = s.size();\n\n        hash1.assign(n+1,0);\n        hash2.assign(n+1,0);\n        pow1.assign(n+1,1);\n        pow2.assign(n+1,1);\n\n        for(int i=0;i<n;i++) {\n            hash1[i+1] = (hash1[i]+s[i]) * base1 % mod1;\n            hash2[i+1] = (hash2[i]+s[i]) * base2 % mod2;\n            pow1[i+1] = pow1[i] * base1 % mod1;\n            pow2[i+1] = pow2[i] * base2 % mod2;\n        }\n    }\n\n    hash_type get(int l,int r) {\n        int_type t1 = ((hash1[r] - hash1[l] * pow1[r-l]) % mod1 + mod1) % mod1;\n        int_type t2 = ((hash2[r] - hash2[l] * pow2[r-l]) % mod2 + mod2) % mod2;\n        return make_pair(t1, t2);\n    }\n\n    RollingHash::hash_type concat(hash_type h1, hash_type h2, int h2_len) {\n        return make_pair((h1.fr*pow1[h2_len]+h2.fr)%mod1, (h1.sc*pow2[h2_len]+h2.sc)%mod2);\n    }\n\n};\n\nchar in[1000006];\nint main() {\n    scanf(\"%s\",in);\n    string s=string(in);\n    int n=s.size();\n    RollingHash rh;\n    rh.init(s);\n    string ans=\"mitomerarenaiWA\";\n    string A,B;\n    P ansP=P(INF,INF);;\n    rep(i,n) if(i) {\n        int t=n-i*3;\n        //printf(\"[debug] %d %d\\n\",i,t);\n        if(t%2!=0) continue;\n        if(t==0) continue;\n        t/=2;\n        if(rh.get(0,i)==rh.get(i+t,2*i+t)&&rh.get(i+t,2*i+t)==rh.get(2*i+2*t,3*i+2*t)) {\n            if(rh.get(i,i+t)==rh.get(2*i+t,2*i+2*t)) {\n                //printf(\"[debug] %d %d\\n\",i,t);\n                ans=\"Love Nico!\";\n                if(ansP.fr+ansP.sc>i+t) {\n                    ansP=P(i,t);\n                }\n            }\n        }\n    }\n\n    if(ans==\"mitomerarenaiWA\") cout<<ans<<endl;\n    else {\n        //cout<<ansP.fr<<\", \"<<ansP.sc<<endl;\n        cout<<\"Love \";\n        cout<<s.substr(0,ansP.fr);\n        cout<<s.substr(ansP.fr,ansP.sc);\n        cout<<\"!\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid z_algorithm(string& S,vector<int>& res)\n{\n    int sz = (int)S.size();\n    res.resize(sz);\n    int c = 0;\n    for(int i = 1; i < sz; i++){\n        if(i+res[i-c] < c+res[c]){\n            res[i] = res[i-c];\n        }else{\n            int j = max(0, c+res[c]-i);\n            while (i+j < sz && S[j] == S[i+j]) ++j;\n            res[i] = j;\n        }\n    }\n    res[0] = sz;\n}\n\nint main(){\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<int> a,b;\n    z_algorithm(s,a);\n    reverse(s.begin(),s.end());\n    z_algorithm(s,b);\n    reverse(s.begin(),s.end());\n    int ma = -1;\n    for(int i=n/3-2;i<n/2+2;i++){\n        if(a[i]==n-i&&b[i]==n-i&&n-2*i>0&&(n-3*(n-2*i))/2>0){\n            ma = max(ma,n-2*i);\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     cout << a[i] << \" \";\n    // }\n    // cout << endl;\n    // for(int i=0;i<n;i++){\n    //     cout << b[i] << \" \";\n    // }\n    // cout << endl;\n    \n    if(ma==-1){\n        cout << \"mitomerarenaiWA\" << endl;\n    }else{\n        int x = ma;\n        int y = (n-3*ma)/2;\n        cout << x << \" \" << y << endl;\n        cout << \"Love \" << s.substr(0,x+y) <<\"!\" << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP;\n  vector< int > rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size() - 1);\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i]] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    if(k < 0) return (0);\n    return (LCP[k]);\n  }\n\n  int size() const\n  {\n    return (LCP.size() + 1);\n  }\n};\n\nstruct StaticSegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  StaticSegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    };\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(min(a, b), max(a, b), 0, 0, sz));\n  }\n};\n\n\nint main()\n{\n  string S;\n  cin >> S;\n  SuffixArray sa;\n  sa.Build_SA(S);\n  LongestCommonPrefixArray lcp;\n  lcp.Build_LCP(sa);\n  StaticSegmentTree tree(lcp.size());\n  for(int i = 0; i < lcp.size()-1; i++) {\n    tree.set(i, lcp[i]);\n  }\n  tree.build();\n\n  int ret = INF;\n  for(int A = 1; A < S.size(); A++) {\n    int B = (int) S.size() - A * 3;\n    if(B <= 0) break;\n    if(B & 1) continue;\n    B /= 2;\n    if(tree.rmq(lcp.rank[0], lcp.rank[A + B]) >= A &&\n       tree.rmq(lcp.rank[0], lcp.rank[A + B + A + B]) >= A &&\n       tree.rmq(lcp.rank[A], lcp.rank[A + B + A]) >= B) {\n      ret = min(ret, A + B);\n    }\n  }\n\n  if(ret >= INF) {\n    cout << \"mitomerarenaiWA\" << endl;\n  } else {\n    cout << \"Love \" << S.substr(0, ret) << \"!\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <string>\n\n#define fprintf(...) void(0)\n\ntemplate <intmax_t X=9436884629, intmax_t MOD=1000000007>\nclass RollingHash {\n  std::vector<intmax_t> hash;\n  intmax_t offset(size_t len) const {\n    intmax_t res=1;\n    for (intmax_t dbl=X%MOD; len; len>>=1) {\n      if (len & 1) res = res*dbl % MOD;\n      dbl = dbl*dbl % MOD;\n    }\n    return res;\n  }\n\npublic:\n  RollingHash(const std::string &s): hash(s.length()+1) {\n    for (size_t i=0; i<s.length(); ++i)\n      hash[i+1] = (hash[i]*X+s[i]) % MOD;\n  }\n\n  intmax_t operator ()(size_t i, size_t j) const {\n    // s[i..j-1]\n    assert(i < j);\n    intmax_t res=hash[j];\n    res = (res - offset(j-i)*hash[i]) % MOD;\n    if (res < 0) res += MOD;\n    return res;\n  }\n};\n\nusing RHash=RollingHash<100>;\n\nint main() {\n  char buf[1234567];\n  scanf(\"%s\", buf);\n  std::string s=std::move(buf);\n  RHash rh(s);\n\n  uintmax_t aa=s.length(), bb=s.length();\n  for (size_t i=1; i<s.length(); ++i) {\n    size_t al=i;\n    fprintf(stderr, \"al: %zu\\n\", al);\n    if (al*3 >= s.length()) continue;\n    if ((s.length()-al*3) % 2 > 0) continue;\n    size_t bl=(s.length()-al*3)/2;\n    fprintf(stderr, \"bl: %zu\\n\", bl);\n    assert(al+bl+al+bl+al == s.length());\n\n    intmax_t ah1=rh(0, al);\n    intmax_t bh1=rh(al, al+bl);\n    intmax_t ah2=rh(al+bl, al+bl+al);\n    intmax_t bh2=rh(al+bl+al, al+bl+al+bl);\n    intmax_t ah3=rh(al+bl+al+bl, al+bl+al+bl+al);\n\n    fprintf(stderr, \"%zu/%zu, %jd %jd %jd %jd %jd\\n\",\n            al, bl, ah1, bh1, ah2, bh2, ah3);\n\n    if (!(ah1 == ah2 && ah2 == ah3 && bh1 == bh2)) continue;\n\n    if (aa*bb > uintmax_t(al)*bl) {\n      assert(al && bl);\n      aa = al;\n      bb = bl;\n    }\n  }\n\n  if (aa == s.length()) {\n    assert(bb == s.length());\n    printf(\"mitomerarenaiWA\\n\");\n  } else {\n    printf(\"Love %s%s!\\n\", s.substr(0, aa).c_str(), s.substr(aa, bb).c_str());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ninline double distance(double y1, double x1, double y2, double x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, 1, 0, -1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\n\n// 部分文字列のhash値を計算\nclass SubstringHash {\n    const int N;\n    vector<unsigned long long> powb;\n    vector<unsigned long long> shash;\n    const unsigned long long b = 1000000007;\n\npublic:\n    SubstringHash(string s) : N(s.size()) {\n        this->powb.resize(s.size() + 10);\n        this->shash.resize(s.size() + 10);\n        powb[0] = 1;\n        FOR(i, 0, s.size()) {\n            powb[i + 1] = powb[i] * b;\n            shash[i + 1] = shash[i] * b + s[i];\n        }\n    }\n\n    // s[left, right)のhash値\n    unsigned long long hash(int left, int right) {\n        assert(0 <= left and 0 <= right and left <= right and right <= N);\n\n        return shash[right] - shash[left] * powb[right - left];\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    string S;\n    cin >> S;\n    int N = S.size();\n\n    SubstringHash sh(S);\n\n    int ans_a_size = 1000000, ans_b_size = 1000000;\n    FOR(i, 1, N) {\n        int a_size = i;\n        int n = N - a_size * 3;\n        if (n < 2 or n % 2 != 0) {\n            continue;\n        }\n        int b_size = n / 2;\n\n        ULL a1 = sh.hash(0, a_size);\n        ULL b1 = sh.hash(a_size, a_size + b_size);\n        ULL a2 = sh.hash(a_size + b_size, a_size + b_size + a_size);\n        ULL b2 = sh.hash(a_size + b_size + a_size, a_size + b_size + a_size + b_size);\n        ULL a3 = sh.hash(a_size + b_size + a_size + b_size, N);\n\n        if (a1 == a2 and a2 == a3 and b1 == b2) {\n            if (a_size + b_size < ans_a_size + ans_b_size) {\n                ans_a_size = a_size;\n                ans_b_size = b_size;\n            }\n        }\n    }\n\n    if (ans_a_size != 1000000 and ans_b_size != 1000000) {\n        string A = S.substr(0, ans_a_size);\n        string B = S.substr(ans_a_size, ans_b_size);\n        print(\"Love \" + A + B + \"!\");\n    }\n    else {\n        print(\"mitomerarenaiWA\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP;\n  vector< int > rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size() - 1);\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i]] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    if(k < 0) return (0);\n    return (LCP[k]);\n  }\n\n  int size() const\n  {\n    return (LCP.size() + 1);\n  }\n};\n\nstruct StaticSegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  StaticSegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    };\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n};\n\n\nint main()\n{\n  string S;\n  cin >> S;\n  SuffixArray sa;\n  sa.Build_SA(S);\n  LongestCommonPrefixArray lcp;\n  lcp.Build_LCP(sa);\n  StaticSegmentTree tree(lcp.size());\n  for(int i = 0; i < lcp.size(); i++) {\n    tree.set(i, lcp[i - 1]);\n  }\n  tree.build();\n\n  int ret = INF;\n  for(int A = 1; A < S.size(); A++) {\n    int B = (int) S.size() - A * 3;\n    if(B <= 0) break;\n    if(B & 1) continue;\n    B /= 2;\n    if(tree.rmq(lcp.rank[0], lcp.rank[A + B]) >= A &&\n       tree.rmq(lcp.rank[0], lcp.rank[A + B + A + B]) >= A &&\n       tree.rmq(lcp.rank[A], lcp.rank[A + B + A]) >= B) {\n      ret = min(ret, A + B);\n    }\n  }\n\n  if(ret >= INF) {\n    cout << \"mitomerarenaiWA\" << endl;\n  } else {\n    cout << \"Love \" << S.substr(0, ret) << \"!\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct RollingHash {\n    typedef long long int_type;\n    typedef pair<int_type,int_type> hash_type;\n\n    int_type base1;\n    int_type base2;\n    int_type mod1;\n    int_type mod2;\n    vector<int_type> hash1;\n    vector<int_type> hash2;\n    vector<int_type> pow1;\n    vector<int_type> pow2;\n\n    RollingHash() : base1(1009), base2(1007), mod1(1000000007), mod2(1000000009) {}\n\n    void init(const string &s) {\n        int n = s.size();\n\n        hash1.assign(n+1,0);\n        hash2.assign(n+1,0);\n        pow1.assign(n+1,1);\n        pow2.assign(n+1,1);\n\n        for(int i=0;i<n;i++) {\n            hash1[i+1] = (hash1[i]+s[i]) * base1 % mod1;\n            hash2[i+1] = (hash2[i]+s[i]) * base2 % mod2;\n            pow1[i+1] = pow1[i] * base1 % mod1;\n            pow2[i+1] = pow2[i] * base2 % mod2;\n        }\n    }\n\n    hash_type get(int l,int r) {\n        int_type t1 = ((hash1[r] - hash1[l] * pow1[r-l]) % mod1 + mod1) % mod1;\n        int_type t2 = ((hash2[r] - hash2[l] * pow2[r-l]) % mod2 + mod2) % mod2;\n        return make_pair(t1, t2);\n    }\n\n    RollingHash::hash_type concat(hash_type h1, hash_type h2, int h2_len) {\n        return make_pair((h1.fr*pow1[h2_len]+h2.fr)%mod1, (h1.sc*pow2[h2_len]+h2.sc)%mod2);\n    }\n\n};\n\nchar in[1000006];\nint main() {\n    scanf(\"%s\",in);\n    string s=string(in);\n    int n=s.size();\n    RollingHash rh;\n    rh.init(s);\n    string ans=\"mitomerarenaiWA\";\n    string A,B;\n    P ansP=P(INF,INF);;\n    rep(i,n) if(i) {\n        int t=n-i*3;\n        //printf(\"[debug] %d %d\\n\",i,t);\n        if(t%2!=0) continue;\n        if(t==0) continue;\n        t/=2;\n        if(rh.get(0,i)==rh.get(i+t,2*i+t)&&rh.get(i+t,2*i+t)==rh.get(2*i+2*t,3*i+2*t)) {\n            if(rh.get(i,i+t)==rh.get(2*i+t,2*i+2*t)) {\n                //printf(\"[debug] %d %d\\n\",i,t);\n                ans=\"Love Nico!\";\n                if(ansP.fr+ansP.sc>i+t) {\n                    if(0<=t&&t<n) ansP=P(i,t);\n                }\n            }\n        }\n    }\n\n    if(ans==\"mitomerarenaiWA\") cout<<ans<<endl;\n    else {\n        //cout<<ansP.fr<<\", \"<<ansP.sc<<endl;\n        cout<<\"Love \";\n        cout<<s.substr(0,ansP.fr);\n        cout<<s.substr(ansP.fr,ansP.sc);\n        cout<<\"!\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid z_algorithm(string& S,vector<int>& res)\n{\n    int sz = (int)S.size();\n    res.resize(sz);\n    int c = 0;\n    for(int i = 1; i < sz; i++){\n        if(i+res[i-c] < c+res[c]){\n            res[i] = res[i-c];\n        }else{\n            int j = max(0, c+res[c]-i);\n            while (i+j < sz && S[j] == S[i+j]) ++j;\n            res[i] = j;\n        }\n    }\n    res[0] = sz;\n}\n\nint main(){\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<int> a,b;\n    z_algorithm(s,a);\n    reverse(s.begin(),s.end());\n    z_algorithm(s,b);\n    reverse(s.begin(),s.end());\n    int ma = -1;\n    for(int i=n/3-2;i<n/2+2;i++){\n        if(a[i]==n-i&&b[i]==n-i&&n-2*i>0&&(n-3*(n-2*i))/2>0){\n            ma = max(ma,n-2*i);\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     cout << a[i] << \" \";\n    // }\n    // cout << endl;\n    // for(int i=0;i<n;i++){\n    //     cout << b[i] << \" \";\n    // }\n    // cout << endl;\n    \n    if(ma==-1){\n        cout << \"mitomerarenaiWA\" << endl;\n    }else{\n        int x = ma;\n        int y = (n-3*ma)/2;\n        cout << \"Love \" << s.substr(0,x+y) <<\"!\" << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nconst int INF = (int)1e18;\nstruct RMQ {\n\tvector<int> data;\n\tint N;\n\tRMQ(int size) {\n\t\tN = 1;\n\t\twhile(N < size) N *= 2;\n\t\tdata.assign(2*N - 1, INF);\n\t}\n\tvoid update(int k, int a) {\n\t\tk += N - 1;\n\t\tdata[k] = a;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1)/2;\n\t\t\tdata[k] = min(data[2*k + 1], data[2*k + 2]);\n\t\t}\n\t}\n\tint minimum(int a, int b) {\n\t\treturn minimum_sub(a, b, 0, 0, N);\n\t}\n\tint minimum_sub(int a, int b, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <= b) return data[k];\n\n\t\treturn min(minimum_sub(a, b, 2*k + 1, l, (l + r)/2),\n\t\t\t\tminimum_sub(a, b, 2*k + 2, (l + r)/2, r));\n\t}\n};\n\nstruct SuffixArray {\n  int n, k;\n  vector<int> sa, rsa, lcp, rank, tmp;\n  SuffixArray(const string &S) : n(S.size()), sa(S.size() + 1), rsa(S.size() + 1), lcp(S.size() + 1), rank(S.size() + 1), tmp(S.size() + 1) {\n    {\n      auto compare_sa = [&](int i, int j) -> bool {\n          if(rank[i] != rank[j]) return rank[i] < rank[j];\n          else {\n            int ri = i + k <= n ? rank[i + k] : -1;\n            int rj = j + k <= n ? rank[j + k] : -1;\n            return ri < rj;\n          }\n      };\n      for(int i = 0; i <= n; ++i) {\n        sa[i] = i;\n        rank[i] = i < n ? S[i] : -1;\n      }\n      for(k = 1; k <= n; k *= 2) {\n        sort(sa.begin(), sa.begin() + n + 1, compare_sa);\n        tmp[sa[0]] = 0;\n        for(int i = 1; i <= n; i++) {\n          tmp[sa[i]] = tmp[sa[i - 1]] + (compare_sa(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        for(int i = 0; i <= n; i++) {\n          rank[i] = tmp[i];\n        }\n      }\n    }\n    {\n      for(int i = 0; i <= n; i++) rank[sa[i]] = i;\n      int h = 0;\n      lcp[0] = 0;\n      for(int i = 0; i < n; i++) {\n        int j = sa[rank[i] - 1];\n        if(h > 0) h--;\n        for(; j + h < n && i + h < n; h++) {\n          if(S[j + h] != S[i + h]) break;\n        }\n        lcp[rank[i] - 1] = h;\n      }\n    }\n    {\n      for(int i = 0; i <= n; ++i) {\n        rsa[sa[i]] = i;\n      }\n    }\n  }\n};\n\nchar CS[1000001];\n\nsigned main() {\n  scanf(\"%s\", CS);\n  string S(CS);\n  int N = S.size();\n  SuffixArray SA(S);\n  RMQ rmq(N + 1);\n  REP(i,N+1) {\n    rmq.update(i,SA.lcp[i]);\n  }\n  int ansA = INF, ansB = INF;\n  REP(i,N/2) {\n    int LA = i + 1;\n    int LB = (N - 3 * LA) / 2;\n    if(LB < 1) break;\n    int l, r;\n\n    l = SA.rsa[0], r = SA.rsa[N - i - 1];\n    if(l > r) swap(l, r);\n    int lcpA = rmq.minimum(l, r);\n\n    l = SA.rsa[LA], r = SA.rsa[LA + LB + LA];\n    if(l > r) swap(l, r);\n    int lcpB = rmq.minimum(l, r);\n    // DEBUG(LA);\n    // DEBUG(lcpA);\n    // DEBUG(LB);\n    // DEBUG(lcpB);\n    if(lcpA >= LA && lcpB >= LB) {\n      if(LA + LB < ansA + ansB) {\n        ansA = LA;\n        ansB = LB;\n      }\n    }\n  }\n  if(ansA == INF && ansB == INF) {\n    cout << \"mitomerarenaiWA\" << endl;\n  }\n  else {\n    cout << \"Love \" << S.substr(0, ansA) << S.substr(ansA, ansB) << \"!\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nconst int INF = (int)1e18;\nstruct RMQ {\n\tvector<int> data;\n\tint N;\n\tRMQ(int size) {\n\t\tN = 1;\n\t\twhile(N < size) N *= 2;\n\t\tdata.assign(2*N - 1, INF);\n\t}\n\tvoid update(int k, int a) {\n\t\tk += N - 1;\n\t\tdata[k] = a;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1)/2;\n\t\t\tdata[k] = min(data[2*k + 1], data[2*k + 2]);\n\t\t}\n\t}\n\tint minimum(int a, int b) {\n\t\treturn minimum_sub(a, b, 0, 0, N);\n\t}\n\tint minimum_sub(int a, int b, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <= b) return data[k];\n\n\t\treturn min(minimum_sub(a, b, 2*k + 1, l, (l + r)/2),\n\t\t\t\tminimum_sub(a, b, 2*k + 2, (l + r)/2, r));\n\t}\n};\n\ntypedef char Alpha;\ntypedef int Index;\ntypedef std::pair<Index, Index> Interval;\n\ntemplate<typename AlphaT>\nstatic void sa_is_countingAlphabets(const AlphaT *str, Index n, int AlphaSize, std::vector<Index> &bucketOffsets, bool b = false) {\n\tif(b || (int)bucketOffsets.size() / 2 >= AlphaSize) {\n\t\tstd::vector<Index>::iterator alphabetCounts =\n\t\t\tb ? bucketOffsets.begin() : bucketOffsets.begin() + AlphaSize;\n\t\tstd::fill(alphabetCounts, alphabetCounts + AlphaSize, 0);\n\t\tfor(Index i = 0; i < n; i ++)\n\t\t\talphabetCounts[(int)str[i]] ++;\n\t}\n}\n\ntemplate<typename AlphaT>\nstatic void sa_is_getBucketOffsets(const AlphaT *str, Index n, bool dir, int AlphaSize, std::vector<Index> &bucketOffsets) {\n\t//AlphaSize?????§????????´?????????bucketOffset?±????????????????alphabet?????°???????????¢??????????°?????????????\n\t//AlphaSize????°?????????´?????????bucketOffset???alphabetCounts??¨??\\?????´?????????????????¨????????????\n\tstd::vector<Index>::iterator alphabetCounts;\n\tif((int)bucketOffsets.size() / 2 < AlphaSize) {\n\t\tsa_is_countingAlphabets(str, n, AlphaSize, bucketOffsets, true);\n\t\talphabetCounts = bucketOffsets.begin();\n\t}else alphabetCounts = bucketOffsets.begin() + AlphaSize;\n\tIndex cumsum = 1;\t//'$'??????\n\tif(dir) {\n\t\tfor(int i = 0; i < AlphaSize; i ++) {\n\t\t\tcumsum += alphabetCounts[i];\n\t\t\tbucketOffsets[i] = cumsum;\n\t\t}\n\t}else {\n\t\tfor(int i = 0; i < AlphaSize; i ++) {\n\t\t\tIndex x = alphabetCounts[i];\n\t\t\tbucketOffsets[i] = cumsum;\n\t\t\tcumsum += x;\n\t\t}\n\t}\n}\n\n\ntemplate<typename AlphaT>\nstatic void sa_is_inducedSort(const AlphaT *str, Index n, int AlphaSize, const std::vector<bool> &types, Index *sa, std::vector<Index> &bucketOffsets) {\n\tsa_is_getBucketOffsets(str, n, false, AlphaSize, bucketOffsets);\n\tfor(Index i = 0; i < n; i ++) {\n\t\tIndex j = sa[i] - 1;\n\t\tif(j >= 0 && !types[j]) sa[bucketOffsets[(int)str[j]] ++] = j;\n\t}\n\n\tsa_is_getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);\n\tfor(Index i = n; i >= 1; i --) {\n\t\tIndex j = sa[i] - 1;\n\t\tif(j >= 0 && types[j]) sa[-- bucketOffsets[(int)str[j]]] = j;\n\t}\n}\n\n//str???[0,n)???????????§???????????????????????????sa???[0,n]?????????\ntemplate<typename AlphaT>\nstatic void sa_is_rec(const AlphaT *str, Index n, int AlphaSize, Index *sa, std::vector<Index> &bucketOffsets) {\n\tstd::vector<bool> types(n+1);\n\ttypes[n-1] = 0; types[n] = 1;\n\tfor(Index i = n-2; i >= 0; i --)\n\t\ttypes[i] = str[i] < str[i+1] || (str[i] == str[i+1] && types[i+1]);\n\n\tsa_is_countingAlphabets(str, n, AlphaSize, bucketOffsets);\n\tsa_is_getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);\n\tstd::fill(sa, sa + n + 1, -1);\n\tfor(Index i = 1; i < n; i ++)\n\t\tif(types[i] && !types[i-1]) sa[-- bucketOffsets[(int)str[i]]] = i;\n\tsa[0] = n;\n\tsa_is_inducedSort(str, n, AlphaSize, types, sa, bucketOffsets);\n\n\tIndex n1 = 0;\n\tfor(Index i = 0; i <= n; i ++) {\n\t\tIndex j = sa[i];\n\t\tif(j > 0 && types[j] && !types[j-1]) sa[n1 ++] = j;\n\t}\n\n\t//LMS substrings????????????????????????sa[0..n1-1]??????????????????????????????\n\t//?????¢???????????????sa???????????????????????????????????¨?????????\n\t//?????????????????§pos???????????§??´??°????????????????????¨?????????????????????\n\t//????????§LMS substring?????£?¶????????????????????????¨???LMS substring?????°???n/2??\\?????§???????????¨????????¨??????????????¨???1??????????????§??????\n\tIndex *buffer = sa + n1;\n\tstd::fill(buffer, sa + n + 1, -1);\n\tIndex uniqueLMSCount = 0, prevPos = -1;\n\tassert(sa[0] == n);\n\tbuffer[sa[0] / 2] = uniqueLMSCount ++;\t//'$'\n\tfor(Index i = 1; i < n1; i ++) {\n\t\tIndex pos = sa[i]; bool diff = false;\n\t\tif(prevPos == -1) diff = true;\n\t\telse for(Index j = pos, k = prevPos; ; j ++, k ++) {\n\t\t\t\tif(str[j] != str[k] || types[j] != types[k]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(j != pos && ((types[j] && !types[j-1]) || (types[k] && !types[k-1])))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tif(diff) {\n\t\t\tuniqueLMSCount ++;\n\t\t\tprevPos = pos;\n\t\t}\n\t\tbuffer[pos / 2] = uniqueLMSCount - 1;\n\t}\n\tfor(Index i = n, j = n; i >= n1; i --)\n\t\tif(sa[i] >= 0) sa[j --] = sa[i];\n\n\tIndex *sa1 = sa, *s1 = sa + n + 1 - n1;\n\tif(uniqueLMSCount == n1)\n\t\tfor(Index i = 0; i < n1; i ++) sa1[s1[i]] = i;\n\telse\n\t\tsa_is_rec<Index>(s1, n1 - 1, uniqueLMSCount, sa1, bucketOffsets);\n\n\tsa_is_countingAlphabets(str, n, AlphaSize, bucketOffsets);\n\tsa_is_getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);\n\tfor(Index i = 1, j = 0; i <= n; i ++)\n\t\tif(types[i] && !types[i-1]) s1[j ++] = i;\n\tfor(Index i = 0; i < n1; i ++) sa1[i] = s1[sa1[i]];\n\tstd::fill(sa + n1, sa + n + 1, -1);\n\tfor(Index i = n1-1; i >= 1; i --) {\n\t\tIndex j = sa[i]; sa[i] = -1;\n\t\tsa[-- bucketOffsets[(int)str[j]]] = j;\n\t}\n\tsa_is_inducedSort(str, n, AlphaSize, types, sa, bucketOffsets);\n}\n\n//suffixArray???(n+1)????????????\nstatic void buildSuffixArray(const Alpha *str, Index n, int AlphaSize, Index *suffixArray) {\n\tif(n == 0) suffixArray[0] = 0;\n\telse {\n\t\t//I = sizeof(Index) * CHAR_BITS ??¨??????\n\t\t//suffixArray + bucketOffsets + types + ??¢??°?????????????????°\n\t\t//= n*I + max(AlphaSize, n/2)*I + 2*n + O(log n) bits\n\t\t//I = 4 * 32??§AlphaSize??????????°?????????¨????????¨:\n\t\t//(6+1/16) * n + O(log n) bytes\n\t\tstd::vector<Index> bucketOffsets(std::max(AlphaSize, (n+1) / 2) + 1);\n\t\tsa_is_rec<Alpha>(str, n, AlphaSize, &suffixArray[0], bucketOffsets);\n\t}\n}\n\nstatic void buildSuffixArray(const Alpha *str, Index n, Index *suffixArray) {\n\tAlpha maxElem = *std::max_element(str, str + n);\n\tassert(maxElem+0 < std::numeric_limits<int>::max());\n\tbuildSuffixArray(str, n, (int)maxElem+1, suffixArray);\n}\n\n\nstruct SuffixArray {\n  int n;\n  vector<int> rsa, lcp, rank;\n  SuffixArray(const string &S, const int *sa) : n(S.size()), rsa(S.size() + 1), lcp(S.size() + 1), rank(S.size() + 1) {\n    {\n      for(int i = 0; i <= n; i++) rank[sa[i]] = i;\n      int h = 0;\n      lcp[0] = 0;\n      for(int i = 0; i < n; i++) {\n        int j = sa[rank[i] - 1];\n        if(h > 0) h--;\n        for(; j + h < n && i + h < n; h++) {\n          if(S[j + h] != S[i + h]) break;\n        }\n        lcp[rank[i] - 1] = h;\n      }\n    }\n    {\n      for(int i = 0; i <= n; ++i) {\n        rsa[sa[i]] = i;\n      }\n    }\n  }\n};\n\nchar CS[1000001];\nint SA[1000001];\n\nsigned main() {\n  scanf(\"%s\", CS);\n  string S(CS);\n  int N = S.size();\n  buildSuffixArray(CS, N, SA);\n  SuffixArray LCP(S, SA);\n  RMQ rmq(N + 1);\n  REP(i,N+1) {\n    rmq.update(i,LCP.lcp[i]);\n  }\n  int ansA = INF, ansB = INF;\n  REP(i,N/2) {\n    int LA = i + 1;\n    int LB = (N - 3 * LA) / 2;\n    if(LB < 1) break;\n    int l, r;\n\n    l = LCP.rsa[0], r = LCP.rsa[N - i - 1];\n    if(l > r) swap(l, r);\n    int lcpA = rmq.minimum(l, r);\n\n    l = LCP.rsa[LA], r = LCP.rsa[LA + LB + LA];\n    if(l > r) swap(l, r);\n    int lcpB = rmq.minimum(l, r);\n    // DEBUG(LA);\n    // DEBUG(lcpA);\n    // DEBUG(LB);\n    // DEBUG(lcpB);\n    if(lcpA >= LA && lcpB >= LB) {\n      if(LA + LB < ansA + ansB) {\n        ansA = LA;\n        ansB = LB;\n      }\n    }\n  }\n  if(ansA == INF && ansB == INF) {\n    cout << \"mitomerarenaiWA\" << endl;\n  }\n  else {\n    cout << \"Love \" << S.substr(0, ansA) << S.substr(ansA, ansB) << \"!\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nclass RollingHash\n{\nprivate:\n    static const int X[], Y[], M[];\n    deque<char> dq;\n    long long xp[3];\n    long long hash[3];\npublic:\n    RollingHash(){\n        for(int i=0; i<3; ++i){\n            xp[i] = 1;\n            hash[i] = 0;\n        }\n    }\n    void push_back(char c){\n        dq.push_back(c);\n        for(int i=0; i<3; ++i){\n            hash[i] *= X[i];\n            hash[i] += c;\n            hash[i] %= M[i];\n            xp[i] *= X[i];\n            xp[i] %= M[i];\n        }\n    }\n    void pop_back(){\n        for(int i=0; i<3; ++i){\n            hash[i] += M[i] - dq.back();\n            hash[i] *= Y[i];\n            hash[i] %= M[i];\n            xp[i] *= Y[i];\n            xp[i] %= M[i];\n        }\n        dq.pop_back();\n    }\n    void push_front(char c){\n        dq.push_front(c);\n        for(int i=0; i<3; ++i){\n            hash[i] += c * xp[i];\n            hash[i] %= M[i];\n            xp[i] *= X[i];\n            xp[i] %= M[i];\n        }\n    }\n    void pop_front(){\n        for(int i=0; i<3; ++i){\n            xp[i] *= Y[i];\n            xp[i] %= M[i];\n            hash[i] -= dq.front() * xp[i];\n            hash[i] %= M[i];\n            if(hash[i] < 0)\n                hash[i] += M[i];\n        }\n        dq.pop_front();\n    }\n    bool operator==(const RollingHash& rh){\n        for(int i=0; i<3; ++i){\n            if(hash[i] != rh.hash[i])\n                return false;\n        }\n        return true;\n    }\n    bool operator!=(const RollingHash& rh){\n        return !(*this == rh);\n    }\n};\nconst int RollingHash::X[] = {2000000011, 2000000033, 2000000063}; // 素数\nconst int RollingHash::Y[] = {1447368484, 1178571481, 1277777841}; // X * Y == 1 (mod M)\nconst int RollingHash::M[] = {2000000087, 2000000089, 2000000099}; // 合同式の法（素数）\n\nstring solve(const string& s)\n{\n    int n = s.size();\n    if(n < 5 || n == 6)\n        return \"\";\n\n    vector<int> v(6);\n    v[0] = 0;\n    v[2] = (n + 3) / 3;\n    v[4] = v[2] * 2;\n    v[1] = n - v[4];\n    v[3] = v[2] + v[1];\n    v[5] = n;\n\n    vector<RollingHash> rh(5);\n    for(int i=0; i<5; ++i){\n        for(int j=v[i]; j<v[i+1]; ++j){\n            rh[i].push_back(s[j]);\n        }\n    }\n\n    vector<int> d = {0, -2, 1, -1, 2, 0};\n    for(;;){\n        bool ok = true;\n        for(int i=0; i<3; ++i){\n            if(rh[i] != rh[i+2])\n                ok = false;\n        }\n        if(ok)\n            return s.substr(0, v[2]);\n        if(v[1] < 2)\n            return \"\";\n\n        for(int i=1; i<5; ++i){\n            if(d[i] > 0){\n                for(int j=0; j<d[i]; ++j){\n                    rh[i-1].push_back(s[v[i]]);\n                    rh[i].pop_front();\n                    ++ v[i];\n                }\n            }\n            else{\n                for(int j=0; j<-d[i]; ++j){\n                    rh[i-1].pop_back();\n                    rh[i].push_front(s[v[i]-1]);\n                    -- v[i];\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    string s;\n    cin >> s;\n\n    string ans = solve(s);\n    if(ans == \"\")\n        cout << \"mitomerarenaiWA\" << endl;\n    else\n        cout << \"Love \" << ans << '!' << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nvoid z_algorithm(string& S,vector<int>& res)\n{\n    int sz = (int)S.size();\n    res.resize(sz);\n    int c = 0;\n    for(int i = 1; i < sz; i++){\n        if(i+res[i-c] < c+res[c]){\n            res[i] = res[i-c];\n        }else{\n            int j = max(0, c+res[c]-i);\n            while (i+j < sz && S[j] == S[i+j]) ++j;\n            res[i] = j;\n        }\n    }\n    res[0] = sz;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<int> a,b;\n    z_algorithm(s,a);\n    reverse(s.begin(),s.end());\n    z_algorithm(s,b);\n    int ma = -1;\n    for(int i=n/3-2;i<n/2+2;i++){\n        if(i<0||i>=n)continue;\n        int tmp = n-2*i;\n        if(a[i]==n-i&&b[i]==n-i&&tmp>0&&(n-3*(tmp))/2>0){\n            ma = max(ma,tmp);\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     cout << a[i] << \" \";\n    // }\n    // cout << endl;\n    // for(int i=0;i<n;i++){\n    //     cout << b[i] << \" \";\n    // }\n    // cout << endl;\n    \n    if(ma==-1){\n        cout << \"mitomerarenaiWA\" << endl;\n    }else{\n        int x = ma;\n        int y = (n-3*ma)/2;\n        printf(\"Love \");\n        for(int i=0;i<x+y;i++){\n            printf(\"%c\",s[n-i-1]);\n        }\n        printf(\"!\\n\");\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "char s[1<<20];m[1<<20],n;main(t){t=--*m;for(gets(s);s[n];m[++n]=++t)for(;~t&&s[t]-s[n];t=m[t]);t=n-t;printf(t*2<n?\"Love %.*s!\\n\":\"mitomerarenaiWA\\n\",t*=n/3/t+1,s);}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nvoid z_algorithm(string& S,vector<int>& res)\n{\n    int sz = (int)S.size();\n    res.resize(sz);\n    int c = 0;\n    for(int i = 1; i < sz; i++){\n        if(i+res[i-c] < c+res[c]){\n            res[i] = res[i-c];\n        }else{\n            int j = max(0, c+res[c]-i);\n            while (i+j < sz && S[j] == S[i+j]) ++j;\n            res[i] = j;\n        }\n    }\n    res[0] = sz;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<int> a,b;\n    z_algorithm(s,a);\n    reverse(s.begin(),s.end());\n    z_algorithm(s,b);\n    reverse(s.begin(),s.end());\n    int ma = -1;\n    for(int i=n/3-2;i<n/2+2;i++){\n        if(i<0||i>=n)continue;\n        if(a[i]==n-i&&b[i]==n-i&&n-2*i>0&&(n-3*(n-2*i))/2>0){\n            ma = max(ma,n-2*i);\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     cout << a[i] << \" \";\n    // }\n    // cout << endl;\n    // for(int i=0;i<n;i++){\n    //     cout << b[i] << \" \";\n    // }\n    // cout << endl;\n    \n    if(ma==-1){\n        cout << \"mitomerarenaiWA\" << endl;\n    }else{\n        int x = ma;\n        int y = (n-3*ma)/2;\n        printf(\"Love \");\n        for(int i=0;i<x+y;i++){\n            printf(\"%c\",s[i]);\n        }\n        printf(\"!\\n\");\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nclass RollingHash\n{\nprivate:\n    static const int X[], Y[], M[];\n    deque<char> dq;\n    long long xp[3];\n    long long hash[3];\npublic:\n    RollingHash(){\n        for(int i=0; i<3; ++i){\n            xp[i] = 1;\n            hash[i] = 0;\n        }\n    }\n    void push_back(char c){\n        dq.push_back(c);\n        for(int i=0; i<3; ++i){\n            hash[i] *= X[i];\n            hash[i] += c;\n            hash[i] %= M[i];\n            xp[i] *= X[i];\n            xp[i] %= M[i];\n        }\n    }\n    void pop_back(){\n        for(int i=0; i<3; ++i){\n            hash[i] += M[i] - dq.back();\n            hash[i] *= Y[i];\n            hash[i] %= M[i];\n            xp[i] *= Y[i];\n            xp[i] %= M[i];\n        }\n        dq.pop_back();\n    }\n    void push_front(char c){\n        dq.push_front(c);\n        for(int i=0; i<3; ++i){\n            hash[i] += c * xp[i];\n            hash[i] %= M[i];\n            xp[i] *= X[i];\n            xp[i] %= M[i];\n        }\n    }\n    void pop_front(){\n        for(int i=0; i<3; ++i){\n            xp[i] *= Y[i];\n            xp[i] %= M[i];\n            hash[i] -= dq.front() * xp[i];\n            hash[i] %= M[i];\n            if(hash[i] < 0)\n                hash[i] += M[i];\n        }\n        dq.pop_front();\n    }\n    bool operator==(const RollingHash& rh){\n        for(int i=0; i<3; ++i){\n            if(hash[i] != rh.hash[i])\n                return false;\n        }\n        return true;\n    }\n    bool operator!=(const RollingHash& rh){\n        return !(*this == rh);\n    }\n};\nconst int RollingHash::X[] = {2000000011, 2000000033, 2000000063}; // 素数\nconst int RollingHash::Y[] = {1447368484, 1178571481, 1277777841}; // X * Y == 1 (mod M)\nconst int RollingHash::M[] = {2000000087, 2000000089, 2000000099}; // 合同式の法（素数）\n\nstring solve(const string& s)\n{\n    int n = s.size();\n    if(n < 5)\n        return \"\";\n\n    vector<int> v(6);\n    v[0] = 0;\n    v[2] = (n + 3) / 3;\n    v[4] = v[2] * 2;\n    v[1] = n - v[4];\n    v[3] = v[2] + v[1];\n    v[5] = n;\n    if(v[1] < 2)\n        return \"\";\n\n    vector<RollingHash> rh(5);\n    for(int i=0; i<5; ++i){\n        for(int j=v[i]; j<v[i+1]; ++j){\n            rh[i].push_back(s[j]);\n        }\n    }\n\n    vector<int> d = {0, -2, 1, -1, 2, 0};\n    for(;;){\n        bool ok = true;\n        for(int i=0; i<3; ++i){\n            if(rh[i] != rh[i+2])\n                ok = false;\n        }\n        if(ok)\n            return s.substr(0, v[2]);\n        if(v[1] < 2)\n            return \"\";\n\n        for(int i=1; i<5; ++i){\n            if(d[i] > 0){\n                for(int j=0; j<d[i]; ++j){\n                    rh[i-1].push_back(s[v[i]]);\n                    rh[i].pop_front();\n                    ++ v[i];\n                }\n            }\n            else{\n                for(int j=0; j<-d[i]; ++j){\n                    rh[i-1].pop_back();\n                    rh[i].push_front(s[v[i]-1]);\n                    -- v[i];\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    string s;\n    cin >> s;\n\n    string ans = solve(s);\n    if(ans == \"\")\n        cout << \"mitomerarenaiWA\" << endl;\n    else\n        cout << \"Love \" << ans << '!' << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nvoid z_algorithm(string& S,vector<int>& A)\n{\n    int sz = (int)S.size();\n    A.resize(sz);\n    A[0] = S.size();\n    int i = 1, j = 0;\n    while (i < S.size()) {\n    while (i+j < S.size() && S[j] == S[i+j]) ++j;\n    A[i] = j;\n    if (j == 0) { ++i; continue;}\n    int k = 1;\n        while (i+k < S.size() && k+A[k] < j) A[i+k] = A[k], ++k;\n    i += k; j -= k;\n}\n\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<int> a,b;\n    z_algorithm(s,a);\n    \n    reverse(s.begin(),s.end());\n    z_algorithm(s,b);\n    int ma = -1;\n    for(int i=n/3-2;i<n/2+2;i++){\n        if(i<=0||i>=n)continue;\n        int tmp = n-2*i;\n        if(a[i]==n-i&&b[i]==n-i&&tmp>0&&(n-3*(tmp))/2>0&&(n-3*(tmp))%2==0){\n            ma = max(ma,tmp);\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     cout << a[i] << \" \";\n    // }\n    // cout << endl;\n    // for(int i=0;i<n;i++){\n    //     cout << b[i] << \" \";\n    // }\n    // cout << endl;\n    \n    if(ma==-1){\n        cout << \"mitomerarenaiWA\" << endl;\n    }else{\n        int x = ma;\n        int y = (n-3*ma)/2;\n        printf(\"Love \");\n        for(int i=0;i<x+y;i++){\n            printf(\"%c\",s[n-i-1]);\n        }\n        printf(\"!\\n\");\n        //cout << x << \" \" << y << \" \" << n << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_RollingHash\n#define ___Class_RollingHash\n\n#include <string>\n#include <vector>\n\ntemplate <int mod, int base = 257>\nclass RollingHash {\nprivate:\n\tstd::string str;\n\tstd::vector<int> sum;\npublic:\n\tRollingHash() : str(\"\"), sum(std::vector<int>(1, 0)) {};\n\tRollingHash(const std::string &s) : str(s) {\n\t\tsum.resize(str.size() + 1);\n\t\tfor (int i = 0; i < str.size(); i++) sum[i + 1] = (1LL * sum[i] * base + s[i]) % mod;\n\t}\n\tstatic inline int modpow(int a, int b) {\n\t\tint ret = 1; a %= mod;\n\t\twhile (b) {\n\t\t\tif (b & 1) ret = 1LL * ret * a % mod;\n\t\t\ta = 1LL * a * a % mod;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tstd::string get() { return str; }\n\tint gethash(int l, int r) {\n\t\treturn (sum[r] - 1LL * sum[l] * modpow(base, r - l) % mod + mod) % mod;\n\t}\n};\n\n#endif\n\n#include <string>\n#include <iostream>\nusing namespace std;\nstring s;\nint main() {\n\tcin >> s;\n\tint n = s.size();\n\tRollingHash<998244353> Q(s);\n\tbool flag = false;\n\tfor (int i = (n + 2) / 3 - 1; i >= 1 && !flag; i--) {\n\t\tif ((n - 3 * i) % 2 == 1) continue;\n\t\tint r = (n - 3 * i) / 2, p1 = i, p2 = i + r, p3 = 2 * i + r, p4 = 2 * i + 2 * r;\n\t\tint z1 = Q.gethash(0, p1);\n\t\tint z2 = Q.gethash(p2, p3);\n\t\tint z3 = Q.gethash(p4, n);\n\t\tint z4 = Q.gethash(p1, p2);\n\t\tint z5 = Q.gethash(p3, p4);\n\t\tif (z1 == z2 && z1 == z3 && z4 == z5) {\n\t\t\tcout << \"Love \" << s.substr(0, p2) << \"!\" << endl;\n\t\t\tflag = true;\n\t\t}\n\t}\n\tif (!flag) cout << \"mitomerarenaiWA\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct RollingHash{\n    static const int MD = 3;\n    static const vector<ll> hash_base, hash_mod;\n\n    int n;\n    vector<ll> hs[MD], pw[MD];\n\n    RollingHash(){}\n    RollingHash(const string &s){\n        n = s.size();\n        rep(i,MD){\n            hs[i].assign(n+1,0);\n            pw[i].assign(n+1,0);\n            hs[i][0] = 0;\n            pw[i][0] = 1;\n            rep(j,n){\n                pw[i][j+1] = pw[i][j]*hash_base[i] % hash_mod[i];\n                hs[i][j+1] = (hs[i][j]*hash_base[i]+s[j]) % hash_mod[i];\n            }\n        }\n    }\n\n    // 1-index\n    ll hash_value(int l, int r, int i){\n        return ((hs[i][r] - hs[i][l]*pw[i][r-l])%hash_mod[i]+hash_mod[i])%hash_mod[i];\n    }\n\n    bool match(int l1, int r1, int l2, int r2){\n        bool ret = true;\n        rep(i,MD) ret &= (hash_value(l1-1,r1,i) == hash_value(l2-1,r2,i));\n        return ret;\n    }\n\n    vector<ll> calc(int l, int r){\n        vector<ll> ret(MD);\n        rep(i,MD) ret[i]=hash_value(l-1,r,i);\n        return ret;\n    }\n};\nconst vector<ll> RollingHash::hash_base{1009,1021,1013};\nconst vector<ll> RollingHash::hash_mod{1000000009,1000000007,1000000021};\n\nint main()\n{\n    string s;\n    cin >>s;\n\n    int S = s.size();\n    RollingHash h(s);\n\n    int aa = 0;\n    for(int a=1; a<S; ++a)\n    {\n        int b = S-3*a;\n        if(b<=0) continue;\n        if(b%2==1) continue;\n\n        b/=2;\n        bool valid = true;\n\n        if(h.calc(1,a)!=h.calc(a+b+1,a+b+a)) valid = false;\n        if(h.calc(a+b+1,a+b+a)!=h.calc(2*(a+b)+1,2*(a+b)+a)) valid = false;\n        if(h.calc(a+1,a+b)!=h.calc(2*a+b+1,2*a+b+b)) valid = false;\n\n        if(valid) aa = a;\n    }\n\n    if(aa==0) cout << \"mitomerarenaiWA\" << endl;\n    else\n    {\n        int l = aa + (S-3*aa)/2;\n        cout << \"Love \" << s.substr(0,l) << \"!\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n//Roling Hash\n//RollingHash RH(s,base) base:[2,m)?????±??°\n//RH.set(s,base): vector???????§???????????????????????????§????????????????????????????????????\n//RH.get(l,r): [l,r)??????????????\\ O(1)\n//1000000007, 1000000009, 1000000021\ntemplate<long long MOD>\nclass RollingHash {\npublic:\n\tint n;\n\tlong long base;\n\tvector<long long> pow, hash;\n\tRollingHash() {}\n\tRollingHash(const string &s, long long base_ = 10007) { set(s, base_); }\n\tvoid set(const string &s, long long base_ = 10007) {\n\t\tn = s.size();\n\t\tbase = base_;\n\t\tcalc(s.c_str());\n\t}\n\tlong long get(int x)const { return hash[x]; }\n\tlong long get(int l, int r)const { return (get(r) - get(l)*pow[r - l] % MOD + MOD) % MOD; }\n\tvoid calc(const char *s) {\n\t\tpow.resize(n + 1);\n\t\tpow[0] = 1;\n\t\thash.resize(n + 1);\n\t\thash[0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpow[i + 1] = pow[i] * base%MOD;\n\t\t\thash[i + 1] = (s[i] + hash[i] * base) % MOD;\n\t\t}\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s; cin >> s;\n\tRollingHash<MOD> RH(s);\n\tfor (int a = (s.size() - 2) / 3, b; a >= 1; a--) {\n\t\tb = (s.size() - a * 3) / 2;\n\t\tif (3 * a + 2 * b != s.size())continue;\n\t\tif (RH.get(0, a) == RH.get(a + b, a + b + a)\n\t\t\t&& RH.get(0, a) == RH.get(a + b + a + b, a + b + a + b + a)\n\t\t\t&& RH.get(a, a + b) == RH.get(a + b + a, a + b + a + b)) {\n\t\t\tcout << \"Love \" << s.substr(0, a) << s.substr(a, b) << \"!\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"mitomerarenaiWA\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef vector<ull> vll;\n\nconst ull BASE = 1e9+7;\n\n//Rolling Hash\nvll acc_h, power;\n\nvoid init_roll(string &s, int n){\n  acc_h.resize(n+1,0);\n  power.resize(n+1,1);\n  for(int i=1;i<=n;i++){\n    power[i] = power[i-1] * BASE;\n    acc_h[i] = acc_h[i-1] * BASE + s[i-1];\n  }\n}\n\null rolling_hash(string &s, int l, int r){\n  return acc_h[r] - acc_h[l] * power[r-l];\n}\n\nint main(){\n  string s;\n  cin >> s;\n  int n = s.size();\n  init_roll(s,n);\n\n  string res = \"mitomerarenaiWA\";\n  for(int a=n/3;a>0;a--){\n    if( (n-3*a)%2 )continue;\n    int b = (n-3*a)/2;\n    if(b<=0)continue;\n\n    ull A1 = rolling_hash(s,0,a);\n    ull B1 = rolling_hash(s,a,a+b);\n    ull A2 = rolling_hash(s,a+b,2*a+b);\n    ull B2 = rolling_hash(s,2*a+b,2*a+2*b);\n    ull A3 = rolling_hash(s,2*a+2*b,3*a+2*b);\n\n    if(A1 == A2 && A2 == A3 && B1 == B2){\n      res = \"Love \" + s.substr(0,a+b) + \"!\";\n      break;\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nvoid z_algorithm(string& S,vector<int>& res)\n{\n    int sz = (int)S.size();\n    res.resize(sz);\n    int c = 0;\n    for(int i = 1; i < sz; i++){\n        if(i+res[i-c] < c+res[c]){\n            res[i] = res[i-c];\n        }else{\n            int j = max(0, c+res[c]-i);\n            while (i+j < sz && S[j] == S[i+j]) ++j;\n            res[i] = j;\n        }\n    }\n    res[0] = sz;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<int> a,b;\n    z_algorithm(s,a);\n    reverse(s.begin(),s.end());\n    z_algorithm(s,b);\n    int ma = -1;\n    for(int i=n/3-2;i<n/2+2;i++){\n        if(i<=0||i>=n)continue;\n        int tmp = n-2*i;\n        if(a[i]==n-i&&b[i]==n-i&&tmp>0&&(n-3*(tmp))/2>0&&(n-3*(tmp))%2==0){\n            ma = max(ma,tmp);\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     cout << a[i] << \" \";\n    // }\n    // cout << endl;\n    // for(int i=0;i<n;i++){\n    //     cout << b[i] << \" \";\n    // }\n    // cout << endl;\n    \n    if(ma==-1){\n        cout << \"mitomerarenaiWA\" << endl;\n    }else{\n        int x = ma;\n        int y = (n-3*ma)/2;\n        printf(\"Love \");\n        for(int i=0;i<x+y;i++){\n            printf(\"%c\",s[n-i-1]);\n        }\n        printf(\"!\\n\");\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nint main() {\n\tstring st; cin >> st;\n\tRollingHash rh;\n\trh.init(st);\n\tpair<int, int>ans=make_pair(0,0);\n\tfor (int a = st.size() / 3; a > 0; --a) {\n\t\tif ((st.size() - a * 3) % 2)continue;\n\t\telse {\n\t\t\tint b = (st.size() - a * 3) / 2;\n\t\t\tha h0 = rh.hash(0, a - 1);\n\t\t\tha h1 = rh.hash(a, a + b - 1);\n\t\t\tha h2 = rh.hash(a + b, 2 * a + b - 1);\n\t\t\tha h3 = rh.hash(2 * a + b, 2 * a + 2 * b-1);\n\t\t\tha h4 = rh.hash(2 * a + 2 * b, 3 * a + 2 * b - 1);\n\t\t\tif (h0 == h2&&h2 == h4&&h1 == h3) {\n\t\t\t\tans = make_pair(a, b);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (ans.first) {\n\t\tcout << \"Love \" << st.substr(0, ans.first) << st.substr(ans.first, ans.second) << \"!\" << endl;\n\t}\n\telse {\n\t\tcout << \"mitomerarenaiWA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <string>\n\n#define fprintf(...) void(0)\n\ntemplate <intmax_t X=9436884629, intmax_t MOD=1000000007>\nclass RollingHash {\n  std::vector<intmax_t> hash;\n  intmax_t offset(size_t len) const {\n    intmax_t res=1;\n    for (intmax_t dbl=X%MOD; len; len>>=1) {\n      if (len & 1) res = res*dbl % MOD;\n      dbl = dbl*dbl % MOD;\n    }\n    return res;\n  }\n\npublic:\n  RollingHash(const std::string &s): hash(s.length()+1) {\n    for (size_t i=0; i<s.length(); ++i)\n      hash[i+1] = (hash[i]*X+s[i]) % MOD;\n  }\n\n  intmax_t operator ()(size_t i, size_t j) const {\n    // s[i..j-1]\n    assert(i < j);\n    intmax_t res=hash[j];\n    res = (res - offset(j-i)*hash[i]) % MOD;\n    if (res < 0) res += MOD;\n    return res;\n  }\n};\n\nusing RHash=RollingHash<>;\n\nint main() {\n  char buf[1234567];\n  scanf(\"%s\", buf);\n  std::string s=std::move(buf);\n  RHash rh(s);\n\n  uintmax_t aa=s.length(), bb=s.length();\n  for (size_t i=1; i<s.length(); ++i) {\n    size_t al=i;\n    fprintf(stderr, \"al: %zu\\n\", al);\n    if (al*3 >= s.length()) continue;\n    if ((s.length()-al*3) % 2 > 0) continue;\n    size_t bl=(s.length()-al*3)/2;\n    fprintf(stderr, \"bl: %zu\\n\", bl);\n    assert(al+bl+al+bl+al == s.length());\n\n    intmax_t ah1=rh(0, al);\n    intmax_t bh1=rh(al, al+bl);\n    intmax_t ah2=rh(al+bl, al+bl+al);\n    intmax_t bh2=rh(al+bl+al, al+bl+al+bl);\n    intmax_t ah3=rh(al+bl+al+bl, al+bl+al+bl+al);\n\n    fprintf(stderr, \"%zu/%zu, %jd %jd %jd %jd %jd\\n\",\n            al, bl, ah1, bh1, ah2, bh2, ah3);\n\n    if (!(ah1 == ah2 && ah2 == ah3 && bh1 == bh2)) continue;\n\n    if (aa*bb > uintmax_t(al)*bl) {\n      assert(al && bl);\n      aa = al;\n      bb = bl;\n    }\n  }\n\n  if (aa == s.length()) {\n    assert(bb == s.length());\n    printf(\"mitomerarenaiWA\\n\");\n  } else {\n    printf(\"Love %s%s!\\n\", s.substr(0, aa).c_str(), s.substr(aa, bb).c_str());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef vector<int> vi;\n\nint n,k;\nvi r;\n\nbool compare_sa(int i, int j){\n  if(r[i]!=r[j])return r[i]<r[j];\n  int ri = i+k<=n ? r[i+k] : -1;\n  int rj = j+k<=n ? r[j+k] : -1;\n  return ri<rj;\n}\n\nvoid construct_sa(string &s, vi &sa){\n  n = s.size();\n  r.resize(n+1);\n  vi tmp(n+1);\n\n  sa.resize(n+1);\n\n  rep(i,n+1){\n    sa[i] = i;\n    r[i] = i<n ? s[i] : -1;\n  }\n\n  for(k=1;k<=n;k*=2){\n    sort(sa.begin(),sa.end(),compare_sa);\n\n    tmp[sa[0]] = 0;\n    for(int i=1;i<=n;i++){\n      tmp[sa[i]] = tmp[sa[i-1]] + (compare_sa(sa[i-1],sa[i]) ? 1 : 0);\n    }\n    rep(i,n+1)r[i] = tmp[i];\n  }\n}\n\nvoid construct_lcp(string &s, vi &sa, vi &lcp){\n  lcp.resize(n+1);\n  rep(i,n+1)r[sa[i]] = i;\n\n  int h = 0;\n  lcp[0] = 0;\n  rep(i,n){\n    int j = sa[r[i]-1];\n\n    if(h>0)h--;\n    for(;j+h<n && i+h<n;h++){\n      if(s[j+h] != s[i+h])break;\n    }\n    lcp[r[i]-1] = h;\n  }\n}\n\nclass SegmentTree{\n  int n;\n  vi node;\npublic:\n  SegmentTree(vi a){\n    int n_ = a.size();\n    n = 1;\n    while(n<n_)n*=2;\n    node.resize(2*n-1, 1e9);\n    rep(i,n_)node[n-1+i] = a[i];\n    for(int i=n-2;i>=0;i--)node[i] = min(node[2*i+1], node[2*i+2]);\n  }\n\n  int rmq(int a, int b, int k=0, int l=0, int r=0){\n    if(l>=r)r = n;\n    if(r<=a || b<=l)return 1e9;\n    if(a<=l && r<=b)return node[k];\n    int vl = rmq(a,b,2*k+1,l,(l+r)/2);\n    int vr = rmq(a,b,2*k+2,(l+r)/2,r);\n    return min(vl,vr);\n  }\n};\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  string s;\n  cin >> s;\n\n  vi sa,lcp,inv_sa(s.size()+1);\n  construct_sa(s,sa);\n  rep(i,s.size()+1){\n    inv_sa[sa[i]] = i;\n  }\n\n  construct_lcp(s,sa,lcp);\n  SegmentTree st(lcp);\n\n  string res = \"mitomerarenaiWA\";\n  for(int a=n/3;a>0;a--){\n    if( (n-3*a)%2 )continue;\n    int b = (n-3*a)/2;\n    if(b<=0)continue;\n\n    int p1 = 0, p2 = a, p3 = a+b, p4 = 2*a+b, p5 = 2*a+2*b;\n\n    int A = 1e9, B = 1e9;\n    A = min(A, st.rmq(inv_sa[p1],inv_sa[p3]));\n    A = min(A, st.rmq(inv_sa[p3],inv_sa[p5]));\n    B = min(B, st.rmq(inv_sa[p2],inv_sa[p4]));\n\n    if(A>=a && B>=b){\n      res = \"Love \" + s.substr(0,a+b) + \"!\";\n      break;\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nclass SuffixArray{\n    void create_begin_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        int sum=0;\n        for(int i=0;i<bucket.size();i++){bucket[i]+=sum;swap(sum,bucket[i]);}\n    }\n\n    void create_end_bucket(vector<int>&v,vector<int>&bucket){\n        fill(bucket.begin(),bucket.end(),0);\n        for(int i=0;i<v.size();i++)bucket[v[i]]++;\n        for(int i=1;i<bucket.size();i++)bucket[i]+=bucket[i-1];\n    }\n\n    void induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_begin_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(sa[i]>0&&is_l[sa[i]-1])sa[bucket[v[sa[i]-1]]++]=sa[i]-1;\n    }\n\n    void invert_induced_sort(vector<int>&v,vector<int>&sa,int mv,vector<int>&bucket,vector<int>&is_l){\n        create_end_bucket(v,bucket);\n        for(int i=v.size()-1;i>=0;i--)if(sa[i]>0&&!is_l[sa[i]-1])sa[--bucket[v[sa[i]-1]]]=sa[i]-1;\n    }\n\n    vector<int>sa_is(vector<int>v,int mv){\n        if(v.size()==1)return vector<int>(1,0);\n\n        vector<int>is_l(v.size());\n        vector<int>bucket(mv+1);\n        vector<int>sa(v.size(),-1);\n        auto is_lms=[&](int x)->bool{return x>0&&is_l[x-1]&&!is_l[x];};\n\n        is_l[v.size()-1]=0;\n        for(int i=v.size()-2;i>=0;i--)is_l[i]=v[i]>v[i+1]||(v[i]==v[i+1]&&is_l[i+1]);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<v.size();i++)if(is_lms(i))sa[--bucket[v[i]]]=i;\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n\n        int cur=0;\n        vector<int>order(v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))order[i]=cur++;\n\n        vector<int>next_v(cur);\n        cur=-1;\n        int prev=-1;\n        for(int i=0;i<v.size();i++){\n            if(!is_lms(sa[i]))continue;\n            bool diff=false;\n            for(int d=0;d<v.size();d++){\n                if(prev==-1||v[sa[i]+d]!=v[prev+d]||is_l[sa[i]+d]!=is_l[prev+d]){\n                    diff=true;\n                    break;\n                }\n                else if(d>0&&is_lms(sa[i]+d))break;\n            }\n            if(diff){cur++;prev=sa[i];}\n            next_v[order[sa[i]]]=cur;\n        }\n\n        vector<int>re_order(next_v.size());\n        for(int i=0;i<v.size();i++)if(is_lms(i))re_order[order[i]]=i;\n        vector<int>next_sa=sa_is(next_v,cur);\n        create_end_bucket(v,bucket);\n        for(int i=0;i<sa.size();i++)sa[i]=-1;\n        for(int i=next_sa.size()-1;i>=0;i--)sa[--bucket[v[re_order[next_sa[i]]]]]=re_order[next_sa[i]];\n        induced_sort(v,sa,mv,bucket,is_l);\n        invert_induced_sort(v,sa,mv,bucket,is_l);\n        return sa;\n    }\n\n    void sa_is(string &s){\n        vector<int>v(s.size()+1);\n        for(int i=0;i<s.size();i++)v[i]=s[i];\n        sa=sa_is(v,*max_element(v.begin(),v.end()));\n    }\n\n    void construct_lcp(){\n        lcp.resize(s.size());\n        rank.resize(s.size()+1);\n        int n=s.size();\n        for(int i=0;i<=n;i++)rank[sa[i]]=i;\n        int h=0;\n        lcp[0]=0;\n        for(int i=0;i<n;i++){\n            int j=sa[rank[i]-1];\n\n            if(h>0)h--;\n            for(;j+h<n&&i+h<n;h++){\n                if(s[j+h]!=s[i+h])break;\n            }\n            lcp[rank[i]-1]=h;\n        }\n    }\n\n    struct segtree{\n        int N;\n        vector<int>dat;\n        void init(vector<int> &v){\n            for(N=1;N<v.size();N<<=1);\n            dat.resize(N*2,1001001001);\n            for(int i=0;i<v.size();i++)dat[i+N-1]=v[i];\n            for(int i=N-2;i>=0;i--)dat[i]=min(dat[i*2+1],dat[i*2+2]);\n        }\n        int get_min(int a,int b,int k,int l,int r){\n            if(r<=a||b<=l)return 1001001001;\n            if(a<=l&&r<=b)return dat[k];\n            return min(get_min(a,b,k*2+1,l,(l+r)/2),get_min(a,b,k*2+2,(l+r)/2,r));\n        }\n        int get_min(int a,int b){return get_min(a,b,0,0,N);}\n    };\n    class sparse_table{\n        vector<vector<int> >st;\n    public:\n        void init(vector<int>vec){\n            int b;\n            for(b=0;(1<<b)<vec.size();b++);\n            st.assign(b,vector<int>(1<<b));\n            for(int i=0;i<vec.size();i++)st[0][i]=vec[i];\n\n            for(int i=1;i<b;i++){\n                for(int j=0;j+(1<<i)<=(1<<b);j++){\n                    st[i][j]=min(st[i-1][j],st[i-1][j+(1<<(i-1))]);\n                }\n            }\n        }\n        int get_min(int l,int r){\n            assert(l<r);\n            int b=32-__builtin_clz(r-l)-1;\n            return min(st[b][l],st[b][r-(1<<b)]);\n        }\n        sparse_table(){}\n        sparse_table(vector<int>vec){init(vec);}\n    };\npublic:\n    segtree st;\n    string s;\n    vector<int>sa,lcp,rank;\n    void init(string &t){\n        s=t;\n        sa_is(s);\n        construct_lcp();\n        st.init(lcp);\n    }\n    SuffixArray(string &t){init(t);}\n    SuffixArray(){}\n\n    bool contain(string &t){\n        int lb=0,ub=s.size();\n        while(ub-lb>1){\n            int mid=(lb+ub)/2;\n            if(s.compare(sa[mid],t.size(),t)<0)lb=mid;\n            else ub=mid;\n        }\n        return s.compare(sa[ub],t.size(),t)==0;\n    }\n\n    int get_lcp(int i,int j){\n        assert(i!=j);\n        if(rank[i]>rank[j])swap(i,j);\n        return st.get_min(rank[i],rank[j]);\n    }\n    int operator[](const int idx)const{\n        return sa[idx];\n    }\n};\n\nsigned main(){\n    cin.tie();ios_base::sync_with_stdio(0);\n\n    string S;\n    cin>>S;\n    SuffixArray SA(S);\n    for(int i=2;i*2<S.size();i++){\n        if(S.size()-i*2>=i)continue;\n        if(SA.get_lcp(0,i)<i)continue;\n        if(SA.get_lcp(0,i*2)!=S.size()-i*2)continue;\n        cout<<\"Love \"<<S.substr(0,i)<<\"!\"<<endl;\n        return 0;\n    }\n\n    cout<<\"mitomerarenaiWA\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n//Roling Hash\n//RollingHash RH(s,base) base:[2,MOD)?????±??°\n//RH.set(s,base): vector???????§???????????????????????????§????????????????????????????????????\n//RH.get(l,r): [l,r)??????????????\\ O(1)\n//1000000007, 1000000009, 1000000021\ntemplate<long long MOD>\nclass RollingHash {\npublic:\n\tint n;\n\tlong long base;\n\tvector<long long> pow, hash;\n\tRollingHash() {}\n\tRollingHash(const string &s, long long base_ = 10007) { set(s, base_); }\n\tvoid set(const string &s, long long base_ = 10007) {\n\t\tn = s.size();\n\t\tbase = base_;\n\t\tcalc(s.c_str());\n\t}\n\tlong long get(int x)const { return hash[x]; }\n\tlong long get(int l, int r)const { return (get(r) - get(l)*pow[r - l] % MOD + MOD) % MOD; }\n\tvoid calc(const char *s) {\n\t\tpow.resize(n + 1);\n\t\tpow[0] = 1;\n\t\thash.resize(n + 1);\n\t\thash[0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpow[i + 1] = pow[i] * base % MOD;\n\t\t\thash[i + 1] = (s[i] + hash[i] * base) % MOD;\n\t\t}\n\t}\n};\n\nsigned main() {\n\tstring s; cin >> s;\n\tRollingHash<MOD> RH(s);\n\tfor (int a = (s.size() - 2) / 3, b; a >= 1; a--) {\n\t\tb = (s.size() - a * 3) / 2;\n\t\tif (3 * a + 2 * b != s.size())continue;\n\t\tif (RH.get(0, a) == RH.get(a + b, a + b + a)\n\t\t\t&& RH.get(0, a) == RH.get(a + b + a + b, a + b + a + b + a)\n\t\t\t&& RH.get(a, a + b) == RH.get(a + b + a, a + b + a + b)) {\n\t\t\tcout << \"Love \" << s.substr(0, a + b) << \"!\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"mitomerarenaiWA\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n//Roling Hash\n//RollingHash RH(s,base) base:[2,MOD)?????±??°\n//RH.set(s,base): vector???????§???????????????????????????§????????????????????????????????????\n//RH.get(l,r): [l,r)??????????????\\ O(1)\n//1000000007, 1000000009, 1000000021\ntemplate<long long MOD>\nclass RollingHash {\npublic:\n\tint n;\n\tlong long base;\n\tvector<long long> pow, hash;\n\tRollingHash() {}\n\tRollingHash(const string &s, long long base_ = 10007) { init(s, base_); }\n\tvoid init(const string &s, long long base_ = 10007) {\n\t\tn = s.size();\n\t\tbase = base_;\n\t\tcalc(s.c_str());\n\t}\n\tlong long get(int x)const { return hash[x]; }\n\tlong long get(int l, int r)const { return (get(r) - get(l)*pow[r - l] % MOD + MOD) % MOD; }\n\tvoid calc(const char *s) {\n\t\tpow.resize(n + 1);\n\t\tpow[0] = 1;\n\t\thash.resize(n + 1);\n\t\thash[0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpow[i + 1] = pow[i] * base % MOD;\n\t\t\thash[i + 1] = (s[i] + hash[i] * base) % MOD;\n\t\t}\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s; cin >> s;\n\tRollingHash<1000000007> RH(s);\n\tint ans = s.size();\n\tfor (int a = (s.size() - 2) / 3, b; a >= 1; a--) {\n\t\tb = (s.size() - a * 3) / 2;\n\t\tif (3 * a + 2 * b != s.size())continue;\n\t\tauto A1 = RH.get(0, a);\n\t\tauto B1 = RH.get(a, a + b);\n\t\tauto A2 = RH.get(a + b, a + b + a);\n\t\tauto B2 = RH.get(a + b + a, a + b + a + b);\n\t\tauto A3 = RH.get(a + b + a + b, a + b + a + b + a);\n\t\tif (A1 == A2&&A2 == A3&&B1 == B2) {\n\t\t\tchmin(ans, a + b);\n\t\t}\n\t}\n\tif (ans != s.size())cout << \"Love \" << s.substr(0, ans) << '!';\n\telse cout << \"mitomerarenaiWA\";\n\tcout << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nclass RollingHash\n{\nprivate:\n    static const int X[], Y[], M[];\n    deque<char> dq;\n    long long xp[3];\n    long long hash[3];\npublic:\n    RollingHash(){\n        for(int i=0; i<3; ++i){\n            xp[i] = 1;\n            hash[i] = 0;\n        }\n    }\n    void push_back(char c){\n        dq.push_back(c);\n        for(int i=0; i<3; ++i){\n            hash[i] *= X[i];\n            hash[i] += c;\n            hash[i] %= M[i];\n            xp[i] *= X[i];\n            xp[i] %= M[i];\n        }\n    }\n    void pop_back(){\n        for(int i=0; i<3; ++i){\n            hash[i] += M[i] - dq.back();\n            hash[i] *= Y[i];\n            hash[i] %= M[i];\n            xp[i] *= Y[i];\n            xp[i] %= M[i];\n        }\n        dq.pop_back();\n    }\n    void push_front(char c){\n        dq.push_front(c);\n        for(int i=0; i<3; ++i){\n            hash[i] += c * xp[i];\n            hash[i] %= M[i];\n            xp[i] *= X[i];\n            xp[i] %= M[i];\n        }\n    }\n    void pop_front(){\n        for(int i=0; i<3; ++i){\n            xp[i] *= Y[i];\n            xp[i] %= M[i];\n            hash[i] -= dq.front() * xp[i];\n            hash[i] %= M[i];\n            if(hash[i] < 0)\n                hash[i] += M[i];\n        }\n        dq.pop_front();\n    }\n    bool operator==(const RollingHash& rh){\n        for(int i=0; i<3; ++i){\n            if(hash[i] != rh.hash[i])\n                return false;\n        }\n        return true;\n    }\n    bool operator!=(const RollingHash& rh){\n        return !(*this == rh);\n    }\n};\nconst int RollingHash::X[] = {2000000011, 2000000033, 2000000063}; // 素数\nconst int RollingHash::Y[] = {1447368484, 1178571481, 1277777841}; // X * Y == 1 (mod M)\nconst int RollingHash::M[] = {2000000087, 2000000089, 2000000099}; // 合同式の法（素数）\n\nint main()\n{\n    string s;\n    cin >> s;\n    int n = s.size();\n\n    vector<int> v(6);\n    v[0] = 0;\n    v[2] = (n + 3) / 3;\n    v[4] = v[2] * 2;\n    v[1] = n - v[4];\n    v[3] = v[2] + v[1];\n    v[5] = n;\n    vector<int> d = {0, -2, 1, -1, 2, 0};\n\n    vector<RollingHash> rh(5);\n    for(int i=0; i<5; ++i){\n        for(int j=v[i]; j<v[i+1]; ++j){\n            rh[i].push_back(s[j]);\n        }\n    }\n\n    for(;;){\n        bool ok = true;\n        for(int i=0; i<3; ++i){\n            if(rh[i] != rh[i+2])\n                ok = false;\n        }\n        if(ok){\n            cout << \"Love \" << s.substr(0, v[2]) << '!' << endl;\n            return 0;\n        }\n\n        if(v[1] < 2)\n            break;\n\n        for(int i=1; i<5; ++i){\n            if(d[i] > 0){\n                for(int j=0; j<d[i]; ++j){\n                    rh[i-1].push_back(s[v[i]]);\n                    rh[i].pop_front();\n                    ++ v[i];\n                }\n            }\n            else{\n                for(int j=0; j<-d[i]; ++j){\n                    rh[i-1].pop_back();\n                    rh[i].push_front(s[v[i]-1]);\n                    -- v[i];\n                }\n            }\n        }\n    }\n\n    cout << \"mitomerarenaiWA\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nclass RollingHash\n{\nprivate:\n    static const int X[], Y[], M[];\n    deque<char> dq;\n    long long xp[3];\n    long long hash[3];\npublic:\n    RollingHash(){\n        for(int i=0; i<3; ++i){\n            xp[i] = 1;\n            hash[i] = 0;\n        }\n    }\n    void push_back(char c){\n        dq.push_back(c);\n        for(int i=0; i<3; ++i){\n            hash[i] *= X[i];\n            hash[i] += c;\n            hash[i] %= M[i];\n            xp[i] *= X[i];\n            xp[i] %= M[i];\n        }\n    }\n    void pop_back(){\n        for(int i=0; i<3; ++i){\n            hash[i] += M[i] - dq.back();\n            hash[i] *= Y[i];\n            hash[i] %= M[i];\n            xp[i] *= Y[i];\n            xp[i] %= M[i];\n        }\n        dq.pop_back();\n    }\n    void push_front(char c){\n        dq.push_front(c);\n        for(int i=0; i<3; ++i){\n            hash[i] += c * xp[i];\n            hash[i] %= M[i];\n            xp[i] *= X[i];\n            xp[i] %= M[i];\n        }\n    }\n    void pop_front(){\n        for(int i=0; i<3; ++i){\n            xp[i] *= Y[i];\n            xp[i] %= M[i];\n            hash[i] -= dq.front() * xp[i];\n            hash[i] %= M[i];\n            if(hash[i] < 0)\n                hash[i] += M[i];\n        }\n        dq.pop_front();\n    }\n    int size(){\n        return dq.size();\n    }\n    bool operator==(const RollingHash& rh){\n        for(int i=0; i<3; ++i){\n            if(hash[i] != rh.hash[i])\n                return false;\n        }\n        return true;\n    }\n    bool operator!=(const RollingHash& rh){\n        return !(*this == rh);\n    }\n};\nconst int RollingHash::X[] = {1685440109, 1389328937, 1813126193}; // 素数\nconst int RollingHash::Y[] = {1835226359, 1406652555,  643336582}; // X * Y == 1 (mod M)\nconst int RollingHash::M[] = {2000000087, 2000000089, 2000000099}; // 合同式の法（素数）\n\nstring solve(const string& s)\n{\n    int n = s.size();\n    if(n < 5 || n == 6)\n        return \"\";\n\n    vector<int> v(6);\n    v[0] = 0;\n    v[2] = (n + 3) / 3;\n    v[4] = v[2] * 2;\n    v[1] = n - v[4];\n    v[3] = v[2] + v[1];\n    v[5] = n;\n\n    vector<RollingHash> rh(5);\n    for(int i=0; i<5; ++i){\n        for(int j=v[i]; j<v[i+1]; ++j){\n            rh[i].push_back(s[j]);\n        }\n    }\n\n    vector<int> d = {0, -2, 1, -1, 2, 0};\n    for(;;){\n        bool ok = true;\n        for(int i=0; i<3; ++i){\n            if(rh[i] != rh[i+2])\n                ok = false;\n        }\n        if(ok)\n            return s.substr(0, v[2]);\n        if(v[1] < 3)\n            return \"\";\n\n        for(int i=1; i<5; ++i){\n            if(d[i] > 0){\n                for(int j=0; j<d[i]; ++j){\n                    rh[i-1].push_back(s[v[i]]);\n                    rh[i].pop_front();\n                    ++ v[i];\n                }\n            }\n            else{\n                for(int j=0; j<-d[i]; ++j){\n                    rh[i-1].pop_back();\n                    rh[i].push_front(s[v[i]-1]);\n                    -- v[i];\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    string s;\n    cin >> s;\n\n    string ans = solve(s);\n    if(ans == \"\")\n        cout << \"mitomerarenaiWA\" << endl;\n    else\n        cout << \"Love \" << ans << '!' << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nにっこにっこにー♪\nあなたのハートににこにこにー♪\n笑顔届ける矢澤にこにこー♪\nにこにーって覚えてラブにこー♪\n\n\n*/\n#include<stdio.h>\n#include<string.h>\ntypedef unsigned long long ull;\nconst ull B = 1e9+7;\nchar s[1111111];\nint len;\null a[1111111];\null h[1111111];\null Bh[1111111];\nint main(void) {\n    int res = -1;\n     int i,al,bl;\n  scanf(\"%s\", s);\n  len = strlen(s);\n  Bh[0] = 1;\n \n   for (i = 0; i < len; i++) {\n     h[i+1] = h[i]*B + s[i];\n     Bh[i+1] = Bh[i]*B;\n   }\n \n   for (i = 1; i*3 < len; i++) {\n     if ((len - i*3)%2 != 0 || len - i*3 <= 0) continue;\n     al = i;\n     bl = (len - i*3)/2;\n     if (h[al] == h[al+bl + al]-h[al+bl]*Bh[al] &&\n         h[al+bl + al]-h[al+bl]*Bh[al] == h[al*2+bl*2+al]-h[al*2+bl*2]*Bh[al] &&\n         h[al+bl]-h[al]*Bh[bl] == h[al*2+bl + bl]-h[al*2+bl]*Bh[bl]) {\n       if (res == -1 || res > al+bl) {\n         res = al+bl;\n       }\n     }\n      }\n \n      if (res < 0) {\n        puts(\"mitomerarenaiWA\");\n      } else {\n        printf(\"Love \");\n        for (int i = 0; i < res; i++) {\n          printf(\"%c\", s[i]);\n        }\n        puts(\"!\");\n      }\n      return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int sz = 1000010;\n\nchar s[sz];\nint mp[sz];\n\nint main(){\n\tfgets(s, sz, stdin);\n\tint n = strlen(s) - 1;\n\t\n\tmp[0] = -1;\n\tint t = -1;\n\tfor(int i = 0; i < n; ++i){\n\t\twhile(t >= 0 && s[t] != s[i]){\n\t\t\tt = mp[t];\n\t\t}\n\t\tmp[i + 1] = ++t;\n\t}\n\t\n\tt = n;\n\twhile(t * 2 > n){\n\t\tint p = n - t;\n\t\tif(p * 3 > n){\n\t\t\tprintf(\"Love %.*s!\\n\", p, s);\n\t\t\treturn 0;\n\t\t}\n\t\tt = mp[t];\n\t}\n\tputs(\"mitomerarenaiWA\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define SIZE 1000000\n#define NUM1 1000000007\n#define NUM2 99999883\n\nstruct Info{\n\tull hash_1,hash_2;\n};\n\nint T_length;\nchar T[SIZE+1];\null HASH[SIZE+1][2],P[SIZE+1][2];\n\nInfo calcHash(int left,int right){\n\n\tInfo ret;\n\n\tint length = right-left+1;\n\n\tret.hash_1 = HASH[right+1][0]-HASH[left][0]*P[length][0];\n\tret.hash_2 = HASH[right+1][1]-HASH[left][1]*P[length][1];\n\n\treturn ret;\n}\n\nbool IS_SAME(Info left,Info right){\n\tif(left.hash_1 == right.hash_1 && left.hash_2 == right.hash_2)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nint main(){\n\n\tscanf(\"%s\",T);\n\tfor(T_length = 0; T[T_length] != '\\0'; T_length++);\n\n\tHASH[0][0] = 0;\n\tHASH[0][1] = 0;\n\tP[0][0] = 1;\n\tP[0][1] = 1;\n\n\t//Tのハッシュ値を求める\n\tfor(int i = 1; i <= T_length; i++){\n\t\tHASH[i][0] = T[i-1] + HASH[i-1][0]*NUM1;\n\t\tHASH[i][1] = T[i-1] + HASH[i-1][1]*NUM2;\n\n\t\tP[i][0] = P[i-1][0]*NUM1;\n\t\tP[i][1] = P[i-1][1]*NUM2;\n\t}\n\n\tint start_length = BIG_NUM;\n\tfor(int length = T_length/3;length >= 0; length--){\n\t\tif(length*3+2 > T_length)continue;\n\t\tif((T_length-(3*length))%2 == 1)continue;\n\t\tstart_length = length;\n\t\tbreak;\n\t}\n\n\tif(start_length == BIG_NUM){\n\t\tprintf(\"mitomerarenaiWA\\n\");\n\t\treturn 0;\n\t}\n\n\tInfo H_1,H_2,H_3,H_4,H_5;\n\n\tint B_length;\n\n\tfor(int A_length = start_length; A_length >= 1; A_length--){\n\t\tif((T_length-(3*A_length))%2 == 1)continue;\n\t\tB_length = (T_length-(3*A_length))/2;\n\n\t\tH_1 = calcHash(0,A_length-1);\n\t\tH_2 = calcHash(A_length,T_length-2*A_length-B_length-1);\n\t\tH_3 = calcHash(T_length-2*A_length-B_length,T_length-A_length-B_length-1);\n\t\tH_4 = calcHash(T_length-A_length-B_length,T_length-A_length-1);\n\t\tH_5 = calcHash(T_length-A_length,T_length-1);\n\n\n\t\tif(IS_SAME(H_1,H_3) == true && IS_SAME(H_1,H_5) == true && IS_SAME(H_2,H_4) == true){\n\t\t\tprintf(\"Love \");\n\t\t\tfor(int i = 0; i < T_length-2*A_length-B_length; i++){\n\t\t\t\tprintf(\"%c\",T[i]);\n\t\t\t}\n\t\t\tprintf(\"!\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tprintf(\"mitomerarenaiWA\\n\");\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP;\n  vector< int > rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size() - 1);\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i]] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    if(k < 0) return (0);\n    return (LCP[k]);\n  }\n\n  int size() const\n  {\n    return (LCP.size() + 1);\n  }\n};\n\nstruct StaticSegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  StaticSegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    };\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(min(a, b), max(a, b), 0, 0, sz));\n  }\n};\n\n\nint main()\n{\n  string S;\n  cin >> S;\n  SuffixArray sa;\n  sa.Build_SA(S);\n  LongestCommonPrefixArray lcp;\n  lcp.Build_LCP(sa);\n  StaticSegmentTree tree(S.size());\n  for(int i = 0; i < S.size(); i++) {\n    tree.set(i, lcp[i]);\n  }\n  tree.build();\n\n  int ret = INF;\n  for(int A = 1; A < S.size(); A++) {\n    int B = (int) S.size() - A * 3;\n    if(B <= 0) break;\n    if(B & 1) continue;\n    B /= 2;\n    if(tree.rmq(lcp.rank[0], lcp.rank[A + B]) >= A &&\n       tree.rmq(lcp.rank[0], lcp.rank[A + B + A + B]) >= A &&\n       tree.rmq(lcp.rank[A], lcp.rank[A + B + A]) >= B) {\n      ret = min(ret, A + B);\n    }\n  }\n\n  if(ret >= INF) {\n    cout << \"mitomerarenaiWA\" << endl;\n  } else {\n    cout << \"Love \" << S.substr(0, ret) << \"!\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing hash_t = unsigned long long;\n\nstruct rolloing_hash {\n    int n, b;\n    vector<hash_t> pow, hash;\n    \n    rolloing_hash() {}\n    \n    rolloing_hash(const string &s, hash_t b_ = 10007) {\n        set(s, b_);\n    }\n    \n    void set(const string &s, hash_t b_ = 10007) {\n        n = s.size();\n        b = b_;\n        calc_pow();\n        calc_hash(s.c_str());\n    }\n\n    void calc_pow() {\n        pow.resize(n + 1); pow[0] = 1;\n        for (int i = 0; i < n; i++) {\n            pow[i + 1] = pow[i] * b;\n        }\n    }\n    \n    void calc_hash(const char *s) {\n        hash.resize(n + 1);\n        hash[0] = 0;\n        for (int i = 0; i < n; i++) {\n            hash[i + 1] = s[i] + hash[i] * b;\n        }\n    }\n    \n    hash_t get(int i) const {\n        return hash[i]; \n    }\n    \n    hash_t get(int i, int j) const {\n        return get(j) - get(i) * pow[j - i];\n    }\n};\n\nusing RH = rolloing_hash;\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.size();\n    int a = n % 2 == 0 ? 2 : 1;\n    int b = n % 2 == 0 ? n / 2 - 1 : n / 2;\n    int c = b + a;\n    int d = n - a;\n    RH rh(s);\n    int ans = n;\n    while (a < b) {\n        hash_t A = rh.get(0, a);\n        if (rh.get(b, c) == A && rh.get(d, n) == A && rh.get(a, b) == rh.get(c, d)) {\n            ans = min(ans, b);\n        }\n        a += 2;\n        b -= 1;\n        c += 1;\n        d -= 2;\n    }\n    if (ans != n) {\n        cout << \"Love \" << s.substr(0, ans) << '!';\n    } else {\n        cout << \"mitomerarenaiWA\";\n    }\n    cout << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n\nstruct RollingHash{\n  using ull = unsigned long long;\n  vector<ull> hash,p;\n  RollingHash(){}\n  RollingHash(const string &s,ull B=1000000007LL){\n    int n=s.size();\n    hash.assign(n+1,0);\n    p.assign(n+1,1);\n    for(int i=0;i<n;i++){\n      hash[i+1]=hash[i]*B+s[i];\n      p[i+1]=p[i]*B;\n    }\n  }\n  //S[l, r)\n  ull find(int l,int r){\n    return hash[r]-hash[l]*p[r-l];\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  string s;\n  cin>>s;\n  int n=s.size();\n  int ans=n+1;\n\n  RollingHash rh(s);\n  for(int a=1;a*3<n;a++){\n    if((n-a*3)&1) continue;\n    int b=(n-a*3)/2;\n    using ull = RollingHash::ull;\n    ull u=rh.find(0,a);\n    ull v=rh.find(a,a+b);\n    ull w=rh.find(a+b,a+b+a);\n    ull x=rh.find(a+b+a,a+b+a+b);\n    ull y=rh.find(a+b+a+b,a+b+a+b+a);\n    if(u==w&&w==y&&v==x) chmin(ans,a+b);\n  }\n\n  if(ans<=n) cout<<\"Love \"<<s.substr(0,ans)<<\"!\"<<endl;\n  else cout<<\"mitomerarenaiWA\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nvoid z_algorithm(string& S,vector<int>& res)\n{\n    int sz = (int)S.size();\n    res.resize(sz);\n    int c = 0;\n    for(int i = 1; i < sz; i++){\n        if(i+res[i-c] < c+res[c]){\n            res[i] = res[i-c];\n        }else{\n            int j = max(0, c+res[c]-i);\n            while (i+j < sz && S[j] == S[i+j]) ++j;\n            res[i] = j;\n        }\n    }\n    res[0] = sz;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<int> a,b;\n    z_algorithm(s,a);\n    reverse(s.begin(),s.end());\n    z_algorithm(s,b);\n    reverse(s.begin(),s.end());\n    int ma = -1;\n    for(int i=n/3-2;i<n/2+2;i++){\n        if(i<0||i>n)continue;\n        if(a[i]==n-i&&b[i]==n-i&&n-2*i>0&&(n-3*(n-2*i))/2>0){\n            ma = max(ma,n-2*i);\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     cout << a[i] << \" \";\n    // }\n    // cout << endl;\n    // for(int i=0;i<n;i++){\n    //     cout << b[i] << \" \";\n    // }\n    // cout << endl;\n    \n    if(ma==-1){\n        cout << \"mitomerarenaiWA\" << endl;\n    }else{\n        int x = ma;\n        int y = (n-3*ma)/2;\n        printf(\"Love \");\n        for(int i=0;i<x+y;i++){\n            printf(\"%c\",s[i]);\n        }\n        printf(\"!\\n\");\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1000001\nusing ull = unsigned long long;\n\nconst ull b = 1000000007ULL;\n\nvector<ull> rolling_hash(char* S, int N, vector<ull>& p)\n{\n    vector<ull> h(N + 1);\n    for (int i = 0; i < N; i++) {\n        h[i + 1] = h[i] * b + S[i];\n        p[i + 1] = p[i] * b;\n    }\n    return h;\n}\n\nint main()\n{\n    char S[MAX];\n    scanf(\"%s\", S);\n    \n    int N = strlen(S);\n    vector<ull> p(N + 1);\n    p[0] = 1;\n    \n    auto h = rolling_hash(S, N, p);    \n    \n    int mini = MAX;\n    for (int i = 0; i < N; i++) {\n        int A = i + 1;\n        int B = (N - 3 * A) / 2;\n\n        if (B <= 0) break;\n        if ((N - 3 * A) % 2 != 0) continue;\n\n        auto A1 = h[A] - h[0] * p[A];\n        auto B1 = h[A + B] - h[A] * p[B];\n        auto A2 = h[A * 2 + B] - h[A + B] * p[A];\n        auto B2 = h[2 * (A + B)] - h[A * 2 + B] * p[B];\n        auto A3 = h[N] - h[2 * (A + B)] * p[A];\n\n        if (A1 == A2 && A2 == A3 && B1 == B2) {\n            mini = min(mini, A + B);\n        }\n    }    \n    \n    if (mini == MAX) {\n        printf(\"mitomerarenaiWA\\n\");\n    } else {\n        printf(\"Love \");\n        for (int i = 0; i < mini; i++) {\n            printf(\"%c\", S[i]);\n        }\n        printf(\"!\\n\");\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct RollingHash {\n    typedef long long int_type;\n    typedef pair<int_type,int_type> hash_type;\n\n    int_type base1;\n    int_type base2;\n    int_type mod1;\n    int_type mod2;\n    vector<int_type> hash1;\n    vector<int_type> hash2;\n    vector<int_type> pow1;\n    vector<int_type> pow2;\n\n    RollingHash() : base1(1009), base2(1007), mod1(1000000007), mod2(1000000009) {}\n\n    void init(const string &s) {\n        int n = s.size();\n\n        hash1.assign(n+1,0);\n        hash2.assign(n+1,0);\n        pow1.assign(n+1,1);\n        pow2.assign(n+1,1);\n\n        for(int i=0;i<n;i++) {\n            hash1[i+1] = (hash1[i]+s[i]) * base1 % mod1;\n            hash2[i+1] = (hash2[i]+s[i]) * base2 % mod2;\n            pow1[i+1] = pow1[i] * base1 % mod1;\n            pow2[i+1] = pow2[i] * base2 % mod2;\n        }\n    }\n\n    hash_type get(int l,int r) {\n        int_type t1 = ((hash1[r] - hash1[l] * pow1[r-l]) % mod1 + mod1) % mod1;\n        int_type t2 = ((hash2[r] - hash2[l] * pow2[r-l]) % mod2 + mod2) % mod2;\n        return make_pair(t1, t2);\n    }\n\n    RollingHash::hash_type concat(hash_type h1, hash_type h2, int h2_len) {\n        return make_pair((h1.fr*pow1[h2_len]+h2.fr)%mod1, (h1.sc*pow2[h2_len]+h2.sc)%mod2);\n    }\n\n};\n\nchar in[1000006];\nint main() {\n    scanf(\"%s\",in);\n    string s=string(in);\n    int n=s.size();\n    RollingHash rh;\n    rh.init(s);\n    string ans=\"mitomerarenaiWA\";\n    string A,B;\n    P ansP=P(INF,INF);;\n    rep(i,n+1) if(i) {\n        int t=n-i*3;\n        if(t%2!=0) continue;\n        t/=2;\n        if(rh.get(0,i)==rh.get(i+t,2*i+t)&&rh.get(i+t,2*i+t)==rh.get(2*i+2*t,3*i+2*t)) {\n            if(rh.get(i,i+t)==rh.get(2*i+t,2*i+2*t)) {\n                //printf(\"[debug] %d %d\\n\",i,t);\n                ans=\"Love Nico!\";\n                if(ansP.fr+ansP.sc>i+t) {\n                    ansP=P(i,t);\n                }\n            }\n        }\n    }\n\n    if(ans==\"mitomerarenaiWA\") cout<<ans<<endl;\n    else {\n        //cout<<ansP.fr<<\", \"<<ansP.sc<<endl;\n        cout<<\"Love \";\n        cout<<s.substr(0,ansP.fr);\n        cout<<s.substr(ansP.fr,ansP.sc);\n        cout<<\"!\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\ntypedef unsigned long long ull;\nconst ull B = 1e9+7;\nchar s[1111111];\nint len;\null a[1111111];\null h[1111111];\null Bh[1111111];\nint main(void) {\n    int res = -1;\n     int i,al,bl;\n  scanf(\"%s\", s);\n  len = strlen(s);\n  Bh[0] = 1;\n  \n   for (i = 0; i < len; i++) {\n     h[i+1] = h[i]*B + s[i];\n     Bh[i+1] = Bh[i]*B;\n   }\n  \n   for (i = 1; i*3 < len; i++) {\n     if ((len - i*3)%2 != 0 || len - i*3 <= 0) continue;\n     al = i;\n     bl = (len - i*3)/2;\n     if (h[al] == h[al+bl + al]-h[al+bl]*Bh[al] &&\n         h[al+bl + al]-h[al+bl]*Bh[al] == h[al*2+bl*2+al]-h[al*2+bl*2]*Bh[al] &&\n         h[al+bl]-h[al]*Bh[bl] == h[al*2+bl + bl]-h[al*2+bl]*Bh[bl]) {\n       if (res == -1 || res > al+bl) {\n         res = al+bl;\n       }\n     }\n      }\n  \n      if (res < 0) {\n        puts(\"mitomerarenaiWA\");\n      } else {\n        printf(\"Love \");\n        for (int i = 0; i < res; i++) {\n          printf(\"%c\", s[i]);\n        }\n        puts(\"!\");\n      }\n      return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n//Roling Hash\n//RollingHash RH(s,base) base:[2,MOD)?????±??°\n//RH.set(s,base): vector???????§???????????????????????????§????????????????????????????????????\n//RH.get(l,r): [l,r)??????????????\\ O(1)\n//1000000007, 1000000009, 1000000021\ntemplate<long long MOD>\nclass RollingHash {\npublic:\n\tint n;\n\tlong long base;\n\tvector<long long> pow, hash;\n\tRollingHash() {}\n\tRollingHash(const string &s, long long base_ = 10007) { init(s, base_); }\n\tvoid init(const string &s, long long base_ = 10007) {\n\t\tn = s.size();\n\t\tbase = base_;\n\t\tcalc(s.c_str());\n\t}\n\tlong long get(int x)const { return hash[x]; }\n\tlong long get(int l, int r)const { return (get(r) - get(l)*pow[r - l] % MOD + MOD) % MOD; }\n\tvoid calc(const char *s) {\n\t\tpow.resize(n + 1);\n\t\tpow[0] = 1;\n\t\thash.resize(n + 1);\n\t\thash[0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpow[i + 1] = pow[i] * base % MOD;\n\t\t\thash[i + 1] = (s[i] + hash[i] * base) % MOD;\n\t\t}\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s; cin >> s;\n\tRollingHash<1000000007> RH(s);\n\tint ans = s.size();\n\tint n = s.size();\n\tfor (int a = (n - 2) / 3, b; a >= 1; a--) {\n\t\tb = (n - a * 3) / 2;\n\t\tif (3 * a + 2 * b != n)continue;\n\t\tauto A1 = RH.get(0, a);\n\t\tauto B1 = RH.get(a, a + b);\n\t\tauto A2 = RH.get(a + b, a + b + a);\n\t\tauto B2 = RH.get(a + b + a, a + b + a + b);\n\t\tauto A3 = RH.get(a + b + a + b, a + b + a + b + a);\n\t\tif (A1 == A2&&A2 == A3&&B1 == B2) {\n\t\t\tchmin(ans, a + b);\n\t\t}\n\t}\n\tif (ans != n)cout << \"Love \" << s.substr(0, ans) << '!';\n\telse cout << \"mitomerarenaiWA\";\n\tcout << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nconstexpr long long to_int64(char x) {\n  return (long long)x;\n}\n \ntemplate<class T> struct RollingHash {\n   \n  const array<int, 3> mods = {{int(1e9+7), int(1e9+9), int(1234567891)}};\n  const array<int, 3> Ks = {{1007, 1009, 1013}};\n  const int ModsSize = mods.size();\n \n  vector<T> S;\n  vector<vector<long long>> hash;\n  vector<vector<long long>> pow_table;\n \n  void construct() {\n    hash.resize(ModsSize);\n    int n = S.size();\n    rep(i, ModsSize) hash[i].resize(n+1);\n    rep(i, ModsSize) {\n      for(int j=n-1; j>=0; j--) {\n        hash[i][j] = hash[i][j+1] * Ks[i];\n        hash[i][j] += to_int64(S[j]);\n        hash[i][j] %= mods[i];\n      }\n    }\n \n    pow_table.resize(ModsSize);\n    rep(i, ModsSize) pow_table[i].resize(n+1);\n \n    rep(i, ModsSize) {\n      pow_table[i][0] = 1;\n      REP(j, 1, n+1) {\n        pow_table[i][j] = (pow_table[i][j-1] * Ks[i]) % mods[i];\n      }\n    }\n  }\n \n  RollingHash(vector<T> const& S) {\n    this->S = S;\n    construct();\n  }\n \n  RollingHash(string const& S) {\n    int n = S.size();\n    rep(i, n) { this->S.push_back(S[i]); }\n    construct();\n  }\n \n  long long get_hash(int t, int start, int end) const {\n    auto r = hash[t][start] - hash[t][end] * pow_table[t][end - start];\n    r %= mods[t];\n    if(r < 0) { r += mods[t]; }\n    return r;\n  }\n \n  // テ」ツδ湘」ツδε」ツつキテ」ツδ・テ・ツ?、テ」ツ?古・ツ?ィテ」ツ?ヲテ」ツ?ョMODテ」ツ?ァテ、ツクツ?ィツ?エテ」ツ?凖」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ?凝」ツつ津・ツ按、テ・ツョツ堙」ツ?凖」ツつ?\n  bool same(int a_start, int a_end, int b_start, int b_end) const { // not verified\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != get_hash(i, b_start, b_end)) { return false; }\n    }\n    return true;\n  }\n \n  // テ、ツサツ姪」ツ?ョテヲツ鳴?・ツュツ療・ツ按療」ツ?ョテゥツδィテ・ツ按?ヲツ鳴?・ツュツ療・ツ按療」ツ?ィテ」ツ?ョテ、ツクツ?ィツ?エテ・ツ按、テ・ツョツ堙」ツつ津」ツ?凖」ツつ?\n  bool same(int a_start, int a_end, int b_start, int b_end, shared_ptr<RollingHash<T>> const& rh) const {\n    if(rh == nullptr) { return same(a_start, a_end, b_start, b_end); }\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != rh->get_hash(i, b_start, b_end)) { return false; }\n    }\n    return true;\n  }\n \n  // ティツセツ榲ヲツ崢クテゥツ??・ツ、ツァテ・ツーツ湘・ツ按、テ・ツョツ?\n  bool compare(int a_start, int a_end, int b_start, int b_end, shared_ptr<RollingHash<T>> rh = nullptr) const {  // not verified\n    int a_len = a_end - a_start;\n    int b_len = b_end - b_start;\n \n    int len = min(a_len, b_len);\n    int max_len = len + 1;\n    int min_len = 0;\n \n    // テ」ツ?ゥテ」ツ?禿」ツ?セテ」ツ?ァテ、ツクツ?ィツ?エテ」ツ?凖」ツつ凝」ツ?凝」ツつ津、ツコツ古・ツ按?ヲツ篠「テァツエツ「テ」ツ?ァティツェツソテ」ツ?ケテ」ツつ?\n    while(min_len + 1 < max_len) {\n      int next_len = (min_len + max_len) / 2;\n      if(same(a_start, a_start + next_len, b_start, b_start + next_len, rh)) {\n        min_len = next_len;\n      }\n      else {\n        max_len = next_len;\n      }\n    }\n \n    if(a_start + min_len == a_end) {\n      if(b_start + min_len == b_end) { return 0; }\n      else { return -1; }\n    }\n    else {\n      if(b_start + min_len == b_end) { return 1; }\n      else { return S[a_start + min_len] == S[b_start + min_len]; }\n    }\n \n  }\n \n};\n\nint main() {\n\n  string S; cin >> S;\n  int N = S.size();\n\n  RollingHash<char> rh(S);\n\n  REP(Asize, 1, N - Asize) {\n    int centAidx, Bsize;\n\n    if(N <= 3 * Asize) continue;\n    if((N - 3 * Asize) % 2) continue;\n\n    if(!rh.same(0, Asize, N - Asize, N)) continue;\n    centAidx = (N - 3 * Asize) / 2 + Asize;\n    Bsize = centAidx - Asize;\n    if(!rh.same(0, Asize, Asize + Bsize, centAidx + Asize)) continue;\n    if(!rh.same(Asize, Asize + Bsize, Asize * 2 + Bsize, N - Asize)) continue;\n    cout << \"Love \" << string(S.begin(), S.begin() + Asize) << string(S.begin() + Asize, S.begin() + Asize + Bsize) << \"!\" << endl;\n    exit(0);\n  }\n  \n  cout << \"mitomerarenaiWA\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1000001\nusing ull = unsigned long long;\n\nconst ull b = 1000000007ULL;\n\nvector<ull> rolling_hash(char* S, int N, vector<ull>& p)\n{\n    vector<ull> h(N + 1);\n    for (int i = 0; i < N; i++) {\n        h[i + 1] = h[i] * b + S[i];\n        p[i + 1] = p[i] * b;\n    }\n    return h;\n}\n\nint main()\n{\n    char S[MAX];\n    scanf(\"%s\", S);\n    \n    int N = strlen(S);\n    vector<ull> p(N + 1);\n    p[0] = 1;\n    \n    bool found = 0;\n    auto h = rolling_hash(S, N, p);\n    for (int i = 0; i < N; i++) {\n        int A = i + 1;\n        int B = (N - 3 * A) / 2;\n\n        if (B <= 0) continue;\n        if ((N - 3 * A) % 2 != 0) continue;\n\n        auto A1 = h[A] - h[0] * p[A];\n        auto B1 = h[A + B] - h[A] * p[B];\n        auto A2 = h[A * 2 + B] - h[A + B] * p[A];\n        auto B2 = h[2 * (A + B)] - h[A * 2 + B] * p[B];\n        auto A3 = h[N] - h[2 * (A + B)] * p[A];\n\n        if (A1 == A2 && A2 == A3 && B1 == B2) {\n            found = 1;\n            printf(\"Love \");\n            for (int j = 0; j < A + B; j++) {\n                printf(\"%c\", S[j]);\n            }\n            printf(\"!\\n\");\n            break;\n        }\n    }\n\n    if (!found) {\n        printf(\"mitomerarenaiWA\\n\");\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nvoid z_algorithm(string& S,vector<int>& res)\n{\n    int sz = (int)S.size();\n    res.resize(sz);\n    int c = 0;\n    for(int i = 1; i < sz; i++){\n        if(i+res[i-c] < c+res[c]){\n            res[i] = res[i-c];\n        }else{\n            int j = max(0, c+res[c]-i);\n            while (i+j < sz && S[j] == S[i+j]) ++j;\n            res[i] = j;\n        }\n    }\n    res[0] = sz;\n}\n\nint main(){\n    string s;\n    getline(cin,s);\n    int n = s.size();\n    vector<int> a,b;\n    z_algorithm(s,a);\n    reverse(s.begin(),s.end());\n    z_algorithm(s,b);\n    reverse(s.begin(),s.end());\n    int ma = -1;\n    for(int i=n/3-2;i<n/2+2;i++){\n        if(a[i]==n-i&&b[i]==n-i&&n-2*i>0&&(n-3*(n-2*i))/2>0){\n            ma = max(ma,n-2*i);\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     cout << a[i] << \" \";\n    // }\n    // cout << endl;\n    // for(int i=0;i<n;i++){\n    //     cout << b[i] << \" \";\n    // }\n    // cout << endl;\n    \n    if(ma==-1){\n        cout << \"mitomerarenaiWA\" << endl;\n    }else{\n        int x = ma;\n        int y = (n-3*ma)/2;\n        cout << \"Love \" << s.substr(0,x+y) <<\"!\" << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nchar buf[2000000];\nint main() {\n\tscanf(\"%s\", buf);\n\tstring s = buf;\n\tstring k;\n\tfor (int i = 0; i < s.size(); i++) {\n\t\tk += s[i];\n\t\tstring t = k + k;\n\t\tif (t.size() >= s.size())break;\n\t\tif (t == s.substr(0, t.size()) && (int)t.find(s.substr(k.size())) == 0) {\n\t\t\tprintf(\"Love %s!\\n\", k.c_str()); return 0;\n\t\t}\n\t}\n\tputs(\"mitomerarenaiWA\");\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n//Roling Hash\n//RollingHash RH(s,base) base:[2,MOD)?????±??°\n//RH.set(s,base): vector???????§???????????????????????????§????????????????????????????????????\n//RH.get(l,r): [l,r)??????????????\\ O(1)\n//1000000007, 1000000009, 1000000021\ntemplate<long long MOD>\nclass RollingHash {\npublic:\n\tint n;\n\tlong long base;\n\tvector<long long> pow, hash;\n\tRollingHash() {}\n\tRollingHash(const string &s, long long base_ = 10007) { init(s, base_); }\n\tvoid init(const string &s, long long base_ = 10007) {\n\t\tn = s.size();\n\t\tbase = base_;\n\t\tcalc(s.c_str());\n\t}\n\tlong long get(int x)const { return hash[x]; }\n\tlong long get(int l, int r)const { return (get(r) - get(l)*pow[r - l] % MOD + MOD) % MOD; }\n\tvoid calc(const char *s) {\n\t\tpow.resize(n + 1);\n\t\tpow[0] = 1;\n\t\thash.resize(n + 1);\n\t\thash[0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpow[i + 1] = pow[i] * base % MOD;\n\t\t\thash[i + 1] = (s[i] + hash[i] * base) % MOD;\n\t\t}\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s; cin >> s;\n\tRollingHash<1000000007> RH(s);\n\tint ans = s.size();\n\tfor (int a = (s.size() - 2) / 3, b; a >= 1; a--) {\n\t\tb = (s.size() - a * 3) / 2;\n\t\tif (3 * a + 2 * b != s.size())continue;\n\t\tauto A1 = RH.get(0, a);\n\t\tauto B1 = RH.get(a, a + b);\n\t\tauto A2 = RH.get(a + b, a + b + a);\n\t\tauto B2 = RH.get(a + b + a, a + b + a + b);\n\t\tauto A3 = RH.get(a + b + a + b, a + b + a + b + a);\n\t\tif (A1 == A2&&A2 == A3&&B1 == B2) {\n\t\t\tchmin(ans, a + b);\n\t\t}\n\t}\n\tif (ans != s.size())cout << \"Love \" << s.substr(0, ans) << \"!\";\n\telse cout << \"mitomerarenaiWA\";\n\tcout << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nconstexpr long long to_int64(char x) {\n  return (long long)x;\n}\n \ntemplate<class T> struct RollingHash {\n   \n  const array<int, 3> mods = {{int(1e9+7), int(1e9+9), int(1234567891)}};\n  const array<int, 3> Ks = {{1007, 1009, 1013}};\n  const int ModsSize = mods.size();\n \n  vector<T> S;\n  vector<vector<long long>> hash;\n  vector<vector<long long>> pow_table;\n \n  void construct() {\n    hash.resize(ModsSize);\n    int n = S.size();\n    rep(i, ModsSize) hash[i].resize(n+1);\n    rep(i, ModsSize) {\n      for(int j=n-1; j>=0; j--) {\n        hash[i][j] = hash[i][j+1] * Ks[i];\n        hash[i][j] += to_int64(S[j]);\n        hash[i][j] %= mods[i];\n      }\n    }\n \n    pow_table.resize(ModsSize);\n    rep(i, ModsSize) pow_table[i].resize(n+1);\n \n    rep(i, ModsSize) {\n      pow_table[i][0] = 1;\n      REP(j, 1, n+1) {\n        pow_table[i][j] = (pow_table[i][j-1] * Ks[i]) % mods[i];\n      }\n    }\n  }\n \n  RollingHash(vector<T> const& S) {\n    this->S = S;\n    construct();\n  }\n \n  RollingHash(string const& S) {\n    int n = S.size();\n    rep(i, n) { this->S.push_back(S[i]); }\n    construct();\n  }\n \n  long long get_hash(int t, int start, int end) const {\n    auto r = hash[t][start] - hash[t][end] * pow_table[t][end - start];\n    r %= mods[t];\n    if(r < 0) { r += mods[t]; }\n    return r;\n  }\n \n  // テ」ツδ湘」ツδε」ツつキテ」ツδ・テ・ツ?、テ」ツ?古・ツ?ィテ」ツ?ヲテ」ツ?ョMODテ」ツ?ァテ、ツクツ?ィツ?エテ」ツ?凖」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ?凝」ツつ津・ツ按、テ・ツョツ堙」ツ?凖」ツつ?\n  bool same(int a_start, int a_end, int b_start, int b_end) const { // not verified\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != get_hash(i, b_start, b_end)) { return false; }\n    }\n    return true;\n  }\n \n  // テ、ツサツ姪」ツ?ョテヲツ鳴?・ツュツ療・ツ按療」ツ?ョテゥツδィテ・ツ按?ヲツ鳴?・ツュツ療・ツ按療」ツ?ィテ」ツ?ョテ、ツクツ?ィツ?エテ・ツ按、テ・ツョツ堙」ツつ津」ツ?凖」ツつ?\n  bool same(int a_start, int a_end, int b_start, int b_end, shared_ptr<RollingHash<T>> const& rh) const {\n    if(rh == nullptr) { return same(a_start, a_end, b_start, b_end); }\n    int const len = a_end - a_start;\n    if(len != b_end - b_start) { return false; }\n    rep(i, ModsSize) {\n      if(get_hash(i, a_start, a_end) != rh->get_hash(i, b_start, b_end)) { return false; }\n    }\n    return true;\n  }\n \n  // ティツセツ榲ヲツ崢クテゥツ??・ツ、ツァテ・ツーツ湘・ツ按、テ・ツョツ?\n  bool compare(int a_start, int a_end, int b_start, int b_end, shared_ptr<RollingHash<T>> rh = nullptr) const {  // not verified\n    int a_len = a_end - a_start;\n    int b_len = b_end - b_start;\n \n    int len = min(a_len, b_len);\n    int max_len = len + 1;\n    int min_len = 0;\n \n    // テ」ツ?ゥテ」ツ?禿」ツ?セテ」ツ?ァテ、ツクツ?ィツ?エテ」ツ?凖」ツつ凝」ツ?凝」ツつ津、ツコツ古・ツ按?ヲツ篠「テァツエツ「テ」ツ?ァティツェツソテ」ツ?ケテ」ツつ?\n    while(min_len + 1 < max_len) {\n      int next_len = (min_len + max_len) / 2;\n      if(same(a_start, a_start + next_len, b_start, b_start + next_len, rh)) {\n        min_len = next_len;\n      }\n      else {\n        max_len = next_len;\n      }\n    }\n \n    if(a_start + min_len == a_end) {\n      if(b_start + min_len == b_end) { return 0; }\n      else { return -1; }\n    }\n    else {\n      if(b_start + min_len == b_end) { return 1; }\n      else { return S[a_start + min_len] == S[b_start + min_len]; }\n    }\n \n  }\n \n};\n\nchar s[1000010];\n\nint main() {\n\n  scanf(\"%s\", s);\n  string S = s;\n\n  bool ok = 0;\n\n  int N = S.size();\n\n  RollingHash<char> rh(S);\n\n  string ans;\n\n  REP(Asize, 1, N - Asize) {\n    int centAidx, Bsize;\n\n    if(N <= 3 * Asize) continue;\n    if((N - 3 * Asize) % 2) continue;\n    centAidx = (N - 3 * Asize) / 2 + Asize;\n    Bsize = centAidx - Asize;\n\n    if(3 * Asize + 2 * Bsize != N) continue;\n    if(!rh.same(0, Asize, N - Asize, N)) continue;    \n    if(!rh.same(0, Asize, Asize + Bsize, centAidx + Asize)) continue;\n    if(!rh.same(Asize, Asize + Bsize, Asize * 2 + Bsize, (Asize + Bsize) * 2)) continue;\n    ans = \"Love \" + string(S.begin(), S.begin() + Asize) + string(S.begin() + Asize, S.begin() + Asize + Bsize) + \"!\";\n    ok = 1;\n    break;\n  }\n  \n  if(!ok) {\n    cout << \"mitomerarenaiWA\" << endl;\n  }\n  else {\n    for(int Asize = N - 1; Asize >= 1; Asize --) {\n      int centAidx, Bsize;\n\n      if(N <= 3 * Asize) continue;\n      if((N - 3 * Asize) % 2) continue;\n      centAidx = (N - 3 * Asize) / 2 + Asize;\n      Bsize = centAidx - Asize;\n      if(3 * Asize + 2 * Bsize != N) continue;\n      if(!rh.same(0, Asize, N - Asize, N)) continue;    \n      if(!rh.same(0, Asize, Asize + Bsize, centAidx + Asize)) continue;\n      if(!rh.same(Asize, Asize + Bsize, Asize * 2 + Bsize, (Asize + Bsize) * 2)) continue;\n      string cand = \"Love \" + string(S.begin(), S.begin() + Asize) + string(S.begin() + Asize, S.begin() + Asize + Bsize) + \"!\";\n      if(cand.size() < ans.size()) {\n        ans = cand;\n      }\n      break;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing hash_t = unsigned long long;\n\ntemplate<hash_t MOD>\nstruct rolloing_hash {\n    int n, b;\n    vector<hash_t> pow, hash;\n    \n    rolloing_hash() {}\n    \n    rolloing_hash(const string &s, hash_t b_ = 100) {\n        set(s, b_);\n    }\n    \n    void set(const string &s, hash_t b_ = 100) {\n        n = s.size();\n        b = b_;\n        calc_pow();\n        calc_hash(s.c_str());\n    }\n\n    void calc_pow() {\n        pow.resize(n + 1); pow[0] = 1;\n        for (int i = 0; i < n; i++) {\n            pow[i + 1] = (1LL * pow[i] * b) % MOD;\n        }\n    }\n    \n    void calc_hash(const char *s) {\n        hash.resize(n + 1);\n        hash[0] = 0;\n        for (int i = 0; i < n; i++) {\n            hash[i + 1] = (s[i] + 1LL * hash[i] * b) % MOD;\n        }\n    }\n    \n    hash_t get(int i) const {\n        return hash[i]; \n    }\n    \n    hash_t get(int i, int j) const {\n        return (get(j) - (get(i) * pow[j - i] % MOD) + MOD) % MOD;\n    }\n};\n\nusing RH = rolloing_hash<1000000007>;\n\nint main() {\n    string s;\n    \n    while (cin >> s) {\n        int n = s.size();\n        int a = n % 2 == 0 ? 2 : 1;\n        int b = n % 2 == 0 ? n / 2 - 1 : n / 2;\n        int c = b + a;\n        int d = n - a;\n        RH rh(s);\n        int ans = n;\n        while (a < b) {\n            hash_t A = rh.get(0, a);\n            if (rh.get(b, c) == A && rh.get(d, n) == A && rh.get(a, b) == rh.get(c, d)) {\n                ans = min(ans, b);\n            }\n            a += 2;\n            b -= 1;\n            c += 1;\n            d -= 2;\n        }\n        if (ans != n) {\n            cout << \"Love \" << s.substr(0, ans) << '!';\n        } else {\n            cout << \"mitomerarenaiWA\";\n        }\n        cout << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nvoid z_algorithm(string& S,vector<int>& res)\n{\n    int sz = (int)S.size();\n    res.resize(sz);\n    int c = 0;\n    for(int i = 1; i < sz; i++){\n        if(i+res[i-c] < c+res[c]){\n            res[i] = res[i-c];\n        }else{\n            int j = max(0, c+res[c]-i);\n            while (i+j < sz && S[j] == S[i+j]) ++j;\n            res[i] = j;\n        }\n    }\n    res[0] = sz;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = s.size();\n    if(n>500000){\n        cout << \"MURI\" << endl;\n        return 0;\n    }\n    vector<int> a,b;\n    z_algorithm(s,a);\n    reverse(s.begin(),s.end());\n    z_algorithm(s,b);\n    int ma = -1;\n    for(int i=n/3-2;i<n/2+2;i++){\n        if(i<=0||i>=n)continue;\n        int tmp = n-2*i;\n        if(a[i]==n-i&&b[i]==n-i&&tmp>0&&(n-3*(tmp))/2>0){\n            ma = max(ma,tmp);\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     cout << a[i] << \" \";\n    // }\n    // cout << endl;\n    // for(int i=0;i<n;i++){\n    //     cout << b[i] << \" \";\n    // }\n    // cout << endl;\n    \n    if(ma==-1){\n        cout << \"mitomerarenaiWA\" << endl;\n    }else{\n        int x = ma;\n        int y = (n-3*ma)/2;\n        printf(\"Love \");\n        for(int i=0;i<x+y;i++){\n            printf(\"%c\",s[n-i-1]);\n        }\n        printf(\"!\\n\");\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(x,y,z) for(int x=y;x<=z;x++)\n#define FORD(x,y,z) for(int x=y;x>=z;x--)\n#define MSET(x,y) memset(x,y,sizeof(x))\n#define FOR(x,y) for(__typeof(y.begin()) x=y.begin();x!=y.end();x++)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define SZ size()\n#define M 1000005\nvoid RI(){}\ntemplate<typename... T>\nvoid RI( int& head, T&... tail ) {\n    scanf(\"%d\",&head);\n    RI(tail...);\n}\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long LLU;\nint n,a1,a2;\nLLU pre[M],pw[M];\nchar in[M];\nLLU get_hash(int l,int r)\n{\n\tLLU re = pre[r];\n\tif(l>1) re -= pre[l-1]*pw[r-l+1];\n\treturn re;\n}\nint main()\n{\n\tscanf(\"%s\", in+1);\n\tn = strlen(in+1);\n\n\t//\n\tpre[1] = in[1];\n\tREP(i,2,n) pre[i] = pre[i-1]*131 + in[i];\n\n\tpw[0] = 1;\n\tREP(i,1,n) pw[i]=pw[i-1]*131;\n\t\n\ta1 = a2 = 0;\n\t//\n\tREP(i,1,n/3)\n\t{\n\t\tint j = n-3*i;\n\t\tif(j%2) continue;\n\t\tj = j/2;\n\t\tif(i*3 + j*2 != n) continue;\n\n\t\tLLU h1,h2,h3,h4,h5;\n\t\th1 = get_hash(1,i);\n\t\th2 = get_hash(i+1,i+j);\n\t\th3 = get_hash(i+j+1, i+i+j);\n\t\th4 = get_hash(i+i+j+1, 2*(i+j));\n\t\th5 = get_hash(2*(i+j)+1, n);\n\n\t\tif(h1==h3 && h3==h5 && h2==h4)\n\t\t{\n\t\t\tif(a1==0)\n\t\t\t{\n\t\t\t\ta1=i;\n\t\t\t\ta2=j;\n\t\t\t}\n\t\t\telse if((a1+a2) > i+j)\n\t\t\t{\n\t\t\t\ta1 = i;\n\t\t\t\ta2 = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(a1==0) puts(\"mitomerarenaiWA\");\n\telse\n\t{\n\t\tprintf(\"Love \");\n\t\tREP(i,1,a1+a2) putchar(in[i]);\n\t\tputs(\"!\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct RollingHash {\n    typedef long long int_type;\n    typedef pair<int_type,int_type> hash_type;\n\n    int_type base1;\n    int_type base2;\n    int_type mod1;\n    int_type mod2;\n    vector<int_type> hash1;\n    vector<int_type> hash2;\n    vector<int_type> pow1;\n    vector<int_type> pow2;\n\n    RollingHash() : base1(1009), base2(1007), mod1(1000000007), mod2(1000000009) {}\n\n    void init(const string &s) {\n        int n = s.size();\n\n        hash1.assign(n+1,0);\n        hash2.assign(n+1,0);\n        pow1.assign(n+1,1);\n        pow2.assign(n+1,1);\n\n        for(int i=0;i<n;i++) {\n            hash1[i+1] = (hash1[i]+s[i]) * base1 % mod1;\n            hash2[i+1] = (hash2[i]+s[i]) * base2 % mod2;\n            pow1[i+1] = pow1[i] * base1 % mod1;\n            pow2[i+1] = pow2[i] * base2 % mod2;\n        }\n    }\n\n    hash_type get(int l,int r) {\n        int_type t1 = ((hash1[r] - hash1[l] * pow1[r-l]) % mod1 + mod1) % mod1;\n        int_type t2 = ((hash2[r] - hash2[l] * pow2[r-l]) % mod2 + mod2) % mod2;\n        return make_pair(t1, t2);\n    }\n\n    RollingHash::hash_type concat(hash_type h1, hash_type h2, int h2_len) {\n        return make_pair((h1.fr*pow1[h2_len]+h2.fr)%mod1, (h1.sc*pow2[h2_len]+h2.sc)%mod2);\n    }\n\n};\n\nchar in[1000006];\nint main() {\n    scanf(\"%s\",in);\n    string s=string(in);\n    int n=s.size();\n    RollingHash rh;\n    rh.init(s);\n    string ans=\"mitomerarenaiWA\";\n    string A,B;\n    P ansP=P(INF,INF);;\n    rep(i,n) if(i) {\n        int t=n-i*3;\n        if(t%2!=0) continue;\n        t/=2;\n        if(rh.get(0,i)==rh.get(i+t,2*i+t)&&rh.get(i+t,2*i+t)==rh.get(2*i+2*t,3*i+2*t)) {\n            if(rh.get(i,i+t)==rh.get(2*i+t,2*i+2*t)) {\n                //printf(\"[debug] %d %d\\n\",i,t);\n                ans=\"Love Nico!\";\n                if(ansP.fr+ansP.sc>i+t) {\n                    ansP=P(i,t);\n                }\n            }\n        }\n    }\n\n    if(ans==\"mitomerarenaiWA\") cout<<ans<<endl;\n    else {\n        //cout<<ansP.fr<<\", \"<<ansP.sc<<endl;\n        cout<<\"Love \";\n        cout<<s.substr(0,ansP.fr);\n        cout<<s.substr(ansP.fr,ansP.sc);\n        cout<<\"!\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstring solve(string s){\n  int i, j;\n  string res = \"mitomerarenaiWA\", a1, a2, a3, b1, b2;\n  for(i = 1;;++i)if(s.size() % 2 == i % 2){\n    if(i + i + i >= s.size())break;\n    j = s.size() - i - i - i; j >>= 1;\n    a1 = s.substr(0, i);\n    b1 = s.substr(i, j);\n    a2 = s.substr(i + j, i);\n    b2 = s.substr(i + j + i, j);\n    a3 = s.substr(i + j + i + j, i);\n    if(a1 == a2 && a2 == a3 && b1 == b2)res = a1 + b1;\n  }\n  return res;\n}\n\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    string s; cin >> s;\n    cout << \"Love \" << solve(s) << \"!\" << endl;\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<ull> vul;\ntypedef complex<double> P;\n#define REP(i,n) for(int i=0;i<n;++i)\n#define REPR(i,n) for(int i=1;i<n;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) REP(i,v.size())cout<<#v<<\"[\"<<i<<\"]: \"<<v[i]<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n// suffix-array????????????????????????????????????????????????\n\nstring s;\nint len;\n\nconst ull B = 100000007;\nvul sh(1000001);\nvul bs(1000001);\n// arihon P.333\n\nvoid makeHash(){\n  bs[0] = 1;\n  REPR(i,len+1)bs[i]=bs[i-1]*B;\n  sh[0] = 0;\n  REPR(i,len+1)sh[i]=sh[i-1]*B+s[i-1];\n}\n\null getHash(int left,int right){\n  if(left == 0)return sh[right];\n  return sh[right]-sh[left]*bs[right-left];\n}\n\nbool equal(int from, int tlen, int to){\n  // ??????????????°???????????\\??????\n  ull ah = getHash(from,from+tlen);\n  ull bh = getHash(to,  to+tlen  );\n  return ah==bh;\n}\n\nbool check(int lena, int lenb){\n  // if(lena<=0 || lenb<=0)return false;\n\n  // A in center\n  if( !equal(0,lena,lena+lenb) )return false;\n  if( !equal(0,lena,2*(lena+lenb)))return false;\n\n  // B\n  if( !equal(lena,lenb,2*lena+lenb)) return false;\n  return true;\n}\n\nint main(){\n  cin>>s;\n  len = s.size();\n  makeHash();\n\n  int minlenab = len;\n  string WA = \"mitomerarenaiWA\";\n  int result = len;\n  // ABABA -> 3*A+2*B\n  REPR(lena,len/3+1){\n    if((len-(lena*3))%2!=0)continue;\n    int lenb = (len-(lena*3))/2;\n    if(lena<=0 || lenb<=0)continue;\n    if(lena+lenb>minlenab)continue;\n\n    if(check(lena,lenb)){\n      minlenab = lena+lenb;\n      result = lena+lenb;\n    }\n    // bool ok = true;\n    // REP(_,2)REP(i,lena){\n    //   if(s[i]!=s[(lena+lenb)*(_+1)+i])ok=false;\n    //   if(!ok)break;\n    // }\n    // REP(i,lenb){\n    //   if(s[lena+i]!=s[lena*2+lenb+i])ok=false;\n    //   if(!ok)break;\n    // }\n    // if(ok){\n    //   minlenab = lena+lenb;\n    //   result = lena+lenb;\n    // }\n  }\n  if(result==len)cout<<WA<<endl;\n  else cout<<\"Love \"<<s.substr(0,result)<<\"!\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nint main() {\n\tstring st; cin >> st;\n\tRollingHash rh;\n\trh.init(st);\n\tpair<int, int>ans=make_pair(0,0);\n\tfor (int a = st.size() / 3; a > 0; --a) {\n\t\tif ((st.size() - a * 3) % 2)continue;\n\t\telse {\n\t\t\tint b = (st.size() - a * 3) / 2;\n\t\t\tif (b) {\n\t\t\t\tha h0 = rh.hash(0, a - 1);\n\t\t\t\tha h1 = rh.hash(a, a + b - 1);\n\t\t\t\tha h2 = rh.hash(a + b, 2 * a + b - 1);\n\t\t\t\tha h3 = rh.hash(2 * a + b, 2 * a + 2 * b - 1);\n\t\t\t\tha h4 = rh.hash(2 * a + 2 * b, 3 * a + 2 * b - 1);\n\t\t\t\tif (h0 == h2&&h2 == h4&&h1 == h3) {\n\t\t\t\t\tans = make_pair(a, b);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tif (ans.first) {\n\t\tassert(ans.second);\n\t\tcout << \"Love \" << st.substr(0, ans.first) << st.substr(ans.first, ans.second) << \"!\" << endl;\n\t}\n\telse {\n\t\tcout << \"mitomerarenaiWA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(x,y,z) for(int x=y;x<=z;x++)\n#define FORD(x,y,z) for(int x=y;x>=z;x--)\n#define MSET(x,y) memset(x,y,sizeof(x))\n#define FOR(x,y) for(__typeof(y.begin()) x=y.begin();x!=y.end();x++)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define SZ size()\n#define M 1000005\nvoid RI(){}\ntemplate<typename... T>\nvoid RI( int& head, T&... tail ) {\n    scanf(\"%d\",&head);\n    RI(tail...);\n}\nusing namespace std;\ntypedef long long LL;\nint n,a1,a2;\nLL pre[2][M],pw[2][M], MOD[2]={1000000007, 1000000009};\nchar in[M];\npair<LL,LL> get_hash(int l,int r)\n{\n\tLL re[2] = { pre[0][r], pre[1][r] };\n\tif(l>1)\n\t{\n\t\tREP(i,0,1)\n\t\t{\n\t\t\tre[i] -= pre[i][l-1] * pw[i][r-l+1];\n\t\t\tre[i] %= MOD[i];\n\t\t\tre[i] = (re[i]+MOD[i]) % MOD[i];\n\t\t}\n\t}\n\treturn MP(re[0], re[1]);\n}\nint main()\n{\n\tscanf(\"%s\", in+1);\n\tn = strlen(in+1);\n\n\t//\n\t\n\tREP(j,0,1)\n\t{\n\t\tpre[j][1] = in[1];\n\t\tREP(i,2,n) pre[j][i] = (pre[j][i-1]*131 + in[i]) % MOD[j];\n\n\t\tpw[j][0] = 1;\n\t\tREP(i,1,n) pw[j][i] = (pw[j][i-1]*131) % MOD[j];\n\t}\n\n\ta1 = a2 = 0;\n\t//\n\tREP(i,1,n/3)\n\t{\n\t\tint j = n-3*i;\n\t\tif(j%2) continue;\n\t\tj = j/2;\n\t\tif(i*3 + j*2 != n) continue;\n\n\t\tpair<LL,LL> h1,h2,h3,h4,h5;\n\t\th1 = get_hash(1,i);\n\t\th2 = get_hash(i+1,i+j);\n\t\th3 = get_hash(i+j+1, i+i+j);\n\t\th4 = get_hash(i+i+j+1, 2*(i+j));\n\t\th5 = get_hash(2*(i+j)+1, n);\n\n\t\tif(h1==h3 && h3==h5 && h2==h4)\n\t\t{\n\t\t\tif(a1==0)\n\t\t\t{\n\t\t\t\ta1=i;\n\t\t\t\ta2=j;\n\t\t\t}\n\t\t\telse if((a1+a2) > i+j)\n\t\t\t{\n\t\t\t\ta1 = i;\n\t\t\t\ta2 = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(a1==0) puts(\"mitomerarenaiWA\");\n\telse\n\t{\n\t\tprintf(\"Love \");\n\t\tREP(i,1,a1+a2) putchar(in[i]);\n\t\tputs(\"!\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP;\n  vector< int > rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size() - 1);\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i]] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    if(k < 0) return (0);\n    return (LCP[k]);\n  }\n\n  int size() const\n  {\n    return (LCP.size() + 1);\n  }\n};\n\nstruct StaticSegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  StaticSegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    };\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n};\n\n\nint main()\n{\n  string S;\n  cin >> S;\n  SuffixArray sa;\n  sa.Build_SA(S);\n  LongestCommonPrefixArray lcp;\n  lcp.Build_LCP(sa);\n  StaticSegmentTree tree(lcp.size());\n  for(int i = 0; i < lcp.size(); i++) {\n    tree.set(i, lcp[i - 1]);\n  }\n  tree.build();\n\n  int ret = INF;\n  for(int A = 1; A < S.size(); A++) {\n    int B = (int) S.size() - A * 3;\n    if(B <= 0) break;\n    if(B & 1) continue;\n    B /= 2;\n    if(tree.rmq(lcp.rank[0], lcp.rank[A + B] + 1) >= A &&\n       tree.rmq(lcp.rank[0], lcp.rank[A + B + A + B] + 1) >= A &&\n       tree.rmq(lcp.rank[A], lcp.rank[A + B + A] + 1) >= B) {\n      ret = min(ret, A + B);\n    }\n  }\n\n  if(ret >= INF) {\n    cout << \"mitomerarenaiWA\" << endl;\n  } else {\n    cout << \"Love \" << S.substr(0, ret) << \"!\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar s[1000001];\nvector<int> a_kouho;\nint main()\n{\n  scanf(\"%s\", s);\n  int sn = strlen(s);\n\n  char ast = s[0], aen = s[sn - 1];\n  for(int i = 0; i < sn; i++)\n    if(s[i] == ast)\n      a_kouho.push_back(i);\n  for(int aki = 1; aki < a_kouho.size() - 1; aki++)\n  {\n    int aa = a_kouho[aki];\n    if(aa * 2 >= sn || s[aa * 2] != ast || aa * 3 < sn)\n      continue;\n    for(int i = 0; i < aa; i++)\n    {\n      if(s[i] != s[i + aa])\n        goto ng;\n      if(i + aa * 2 < sn && s[i] != s[i + aa * 2])\n        goto ng;\n    }\n    printf(\"Love \");\n    for(int i = 0; i < aa; i++)\n      printf(\"%c\", s[i]);\n    printf(\"!\\n\");\n    return 0;\nng:;\n  }\n  printf(\"mitomerarenaiWA\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <string>\n\n#define fprintf(...) void(0)\n\ntemplate <intmax_t X=943681729, intmax_t MOD=1000000007>\nclass RollingHash {\n  std::vector<intmax_t> hash;\n  intmax_t offset(size_t len) const {\n    intmax_t res=1;\n    for (intmax_t dbl=X%MOD; len; len>>=1) {\n      if (len & 1) res = res*dbl % MOD;\n      dbl = dbl*dbl % MOD;\n    }\n    return res;\n  }\n\npublic:\n  RollingHash(const std::string &s): hash(s.length()+1) {\n    for (size_t i=0; i<s.length(); ++i)\n      hash[i+1] = (hash[i]*X+s[i]) % MOD;\n  }\n\n  intmax_t operator ()(size_t i, size_t j) const {\n    // s[i..j-1]\n    assert(i < j);\n    intmax_t res=hash[j];\n    res = (res - offset(j-i)*hash[i]) % MOD;\n    if (res < 0) res += MOD;\n    return res;\n  }\n};\n\nusing RHash=RollingHash<>;\n\nint main() {\n  char buf[1234567];\n  scanf(\"%s\", buf);\n  std::string s=std::move(buf);\n  RHash rh(s);\n\n  uintmax_t aa=s.length(), bb=s.length();\n  for (size_t i=1; i<s.length(); ++i) {\n    size_t al=i;\n    fprintf(stderr, \"al: %zu\\n\", al);\n    if (al*3 >= s.length()) continue;\n    if ((s.length()-al*3) % 2 > 0) continue;\n    size_t bl=(s.length()-al*3)/2;\n    fprintf(stderr, \"bl: %zu\\n\", bl);\n    assert(al+bl+al+bl+al == s.length());\n\n    intmax_t ah1=rh(0, al);\n    intmax_t bh1=rh(al, al+bl);\n    intmax_t ah2=rh(al+bl, al+bl+al);\n    intmax_t bh2=rh(al+bl+al, al+bl+al+bl);\n    intmax_t ah3=rh(al+bl+al+bl, al+bl+al+bl+al);\n\n    fprintf(stderr, \"%zu/%zu, %jd %jd %jd %jd %jd\\n\",\n            al, bl, ah1, bh1, ah2, bh2, ah3);\n\n    if (!(ah1 == ah2 && ah2 == ah3 && bh1 == bh2)) continue;\n\n    if (aa*bb > uintmax_t(al)*bl) {\n      assert(al && bl);\n      aa = al;\n      bb = bl;\n    }\n  }\n\n  if (aa == s.length()) {\n    assert(bb == s.length());\n    printf(\"mitomerarenaiWA\\n\");\n  } else {\n    printf(\"Love %s%s!\\n\", s.substr(0, aa).c_str(), s.substr(aa, bb).c_str());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> // cout, endl, cin\n#include <string> // string, to_string, stoi\n#include <vector> // vector\n#include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound\n#include <utility> // pair, make_pair\n#include <tuple> // tuple, make_tuple\n#include <cstdint> // int64_t, int*_t\n#include <cstdio> // printf\n#include <map> // map\n#include <queue> // queue, priority_queue\n#include <set> // set\n#include <stack> // stack\n#include <deque> // deque\n#include <unordered_map> // unordered_map\n#include <unordered_set> // unordered_set\n#include <bitset> // bitset\n#include <cctype> // isupper, islower, isdigit, toupper, tolower\n#include <iomanip> // setprecision\n#define enld '\\n'\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"Ofast\")\nconstexpr ll INF = 1e18;\nconstexpr int inf = 1e9;\nconstexpr ll mod = 1000000007;\nconstexpr ll mod2 = 998244353;\nconst double PI = 3.1415926535897932384626433832795028841971;\nconst int dx[8] = {1, 0, -1, 0,1,1,-1,-1};\nconst int dy[8] = {0, 1, 0, -1,1,-1,1,-1};\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n// ---------------------------------------------------------------------------\n\nvector<int> Z_algorithm(string S){\n    int c=0,n=S.size();\n    vector<int> Z(n,0);\n    for(int i=1; i<n; i++){\n        int l = i-c;\n        if(i+Z[l] < c+Z[c]){\n            Z[i] = Z[l];\n        }else{\n            int j = max(0, c+Z[c]-i);\n            while(i+j<n && S[j]==S[i+j]) j++;\n            Z[i] = j;\n            c = i;\n        }\n    }\n    Z[0] = n;\n    return Z;\n}\n\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string S;\n    cin >> S;\n    vector<int> Z = Z_algorithm(S);\n    int N = S.size();\n    // ABを入れる\n    string ans = \"-\";\n    for(int i=N-1; i>=1; i--){\n        // 後ろがAになるか判定\n        if(Z[i] == N-i){\n            // Bの文字列の長さ\n            // これB*2の長さ\n            int B = (i-1)-Z[i]+1-Z[i];\n            if(B <= 0) continue;\n            if(B%2 == 0){\n                // Bの長さ\n                B /= 2;\n                if(Z[Z[i]+B] >= Z[i]+B){\n                    // 条件満たす\n                    // cout << i << \" \" << Z[i]+B << \"\\n\";\n                    if(ans == \"-\"){\n                        ans = S.substr(0,Z[i]+B);\n                    }else{\n                        if(ans.size() > Z[i]+B){\n                            ans = S.substr(0,Z[i]+B);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(ans == \"-\"){\n        cout << \"mitomerarenaiWA\" << \"\\n\";\n    }else{\n        cout << \"Love \" << ans << \"!\" << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct RollingHash {\n    const int base = 10007;\n    static const int M = 2;\n    const vector<int> mod = {999999937, 1000000007};\n    vector<long long> hash[M], power[M];\n    RollingHash(const string &s, int base = 9973) : base(base) {\n        int n = s.size();\n        for (int iter = 0; iter < M; ++iter) {\n            hash[iter].assign(n + 1, 0);\n            power[iter].assign(n + 1, 1);\n            for (int i = 0; i < n; ++i) {\n                hash[iter][i + 1] = (hash[iter][i] * base + s[i]) % mod[iter];\n                power[iter][i + 1] = power[iter][i] * base % mod[iter];\n            }\n        }\n    }\n    long long get(int l, int r, int id = 0) {   // [l, r)\n        long long ret = hash[id][r] - hash[id][l] * power[id][r-l] % mod[id];\n        return (ret < 0 ? ret + mod[id] : ret);\n    }\n};\n\nint main() {\n    string s;\n    while (cin >> s) {\n        RollingHash rh(s);\n        int n = s.size();\n        int ans = n;\n        int a = n % 2 == 0 ? 2 : 1;\n        int b = n % 2 == 0 ? n / 2 - 1 : n / 2;\n        int c = b + a;\n        int d = n - a;\n        while (a < b) {\n            long long A = rh.get(0, a);\n            if (rh.get(b, c) == A && rh.get(d, n) == A && rh.get(a, b) == rh.get(c, d)) {\n                ans = min(ans, b);\n            }\n            a += 2; b -= 1; c += 1; d -= 2;\n        }\n        if (ans != n) {\n            cout << \"Love \" << s.substr(0, ans) << '!' << endl;\n        } else {\n            cout << \"mitomerarenaiWA\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n  \n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n  \ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n  \ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n    return os<<'('<<p.first<<','<<p.second<<')';\n}\n  \ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n    print_tuple<Cdr...>(os,t);\n    os<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n    print_tuple<Args...>(os<<'(',t);\n    return os<<')';\n}\n  \ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n    os<<'[';\n    for(auto i=begin(c);i!=end(c);++i)\n        os<<(i==begin(c)?\"\":\" \")<<*i;\n    return os<<']';\n}\n  \nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n  \ntemplate<typename C>\nvoid RadixSort(const vi& src,vi& dst,const C& s,int ofs,int n,int asize)\n{\n    vi hist(asize+1);\n    rep(i,n) hist[s[ofs+src[i]]]++;\n    rep(i,asize) hist[i+1]+=hist[i];\n    per(i,n) dst[--hist[s[ofs+src[i]]]]=src[i];\n}\n  \nbool Less(int a1,int a2,int b1,int b2)\n{\n    return a1!=b1?a1<b1:a2<b2;\n}\nbool Less(int a1,int a2,int a3,int b1,int b2,int b3)\n{\n    return a1!=b1?a1<b1:Less(a2,a3,b2,b3);\n}\n  \n// s[0..n-1]: 入力文字列．末尾に'\\0'が3つ必要(s[n]=s[n+1]=s[n+2]=0)．\n// sa[0..n-1]: 接尾辞配列．\n// asize: アルファベットサイズ，s[i] \\in [1,asize]\ntemplate<typename C>\nvoid KaerkkaeinenSanders(const C& s,vi& sa,int asize)\n{\n    int n=sa.size();\n    int n0=(n+2)/3,n1=(n+1)/3,n2=n/3,n02=n0+n2;\n    vi s12(n02+3),sa12(n02);\n      \n    for(int i=0,j=0;i<n+(n0-n1);i++)\n        if(i%3) s12[j++]=i;\n    RadixSort(s12,sa12,s,2,n02,asize);\n    RadixSort(sa12,s12,s,1,n02,asize);\n    RadixSort(s12,sa12,s,0,n02,asize);\n      \n    int name=0,x=-1,y=-1,z=-1;\n    rep(i,n02){\n        int j=sa12[i];\n        if(s[j]!=x || s[j+1]!=y || s[j+2]!=z)\n            x=s[j],y=s[j+1],z=s[j+2],name++;\n        if(j%3==1) s12[j/3]=name;\n        else       s12[n0+j/3]=name;\n    }\n      \n    if(name==n02) // unique\n        rep(i,n02) sa12[s12[i]-1]=i;\n    else{\n        KaerkkaeinenSanders(s12,sa12,name);\n        rep(i,n02) s12[sa12[i]]=i+1;\n    }\n      \n    vi s0(n0),sa0(n0);\n    for(int i=0,j=0;i<n02;i++)\n        if(sa12[i]<n0) s0[j++]=3*sa12[i];\n    RadixSort(s0,sa0,s,0,n0,asize);\n      \n    int i=0,j=n0-n1,k=0;\n    while(i<n0 && j<n02){\n        int p=sa0[i],q=sa12[j]<n0?sa12[j]*3+1:(sa12[j]-n0)*3+2;\n        if(sa12[j]<n0?\n            Less(s[p],s12[p/3],s[q],s12[n0+sa12[j]]):\n            Less(s[p],s[p+1],s12[n0+p/3],s[q],s[q+1],s12[sa12[j]+1-n0]))\n            sa[k++]=p,i++;\n        else\n            sa[k++]=q,j++;\n    }\n    for(;i<n0;k++,i++)\n        sa[k]=sa0[i];\n    for(;j<n02;k++,j++)\n        sa[k]=sa12[j]<n0?sa12[j]*3+1:(sa12[j]-n0)*3+2;\n}\nvoid KaerkkaeinenSanders(const string& s,vi& sa)\n{\n    KaerkkaeinenSanders<string>(s+string(3,0),sa,127);\n}\nvoid KaerkkaeinenSanders(const char* s,vi& sa)\n{\n    KaerkkaeinenSanders<string>(s+string(3,0),sa,127);\n}\n  \n// s[0..n-1] (s[n]=0), sa[0..n-1]\n// lcp[0..n-1] (lcp[i]:s[sa[i-1]..]とs[sa[i]..]のLCP.lcp[0]=0)\ntemplate<typename C>\nvoid LCP(const C& s,const vi& sa,vi& lcp)\n{\n    int n=sa.size();\n    vi rank(n);\n    rep(i,n) rank[sa[i]]=i;\n    for(int i=0,h=0;i<n;i++){\n        if(h>0) h--;\n        if(rank[i]>0)\n            for(int j=sa[rank[i]-1];;h++)\n                if(s[j+h]!=s[i+h]) break;\n        lcp[rank[i]]=h;\n    }\n}\n  \nint NextPow2(int x)\n{\n    x--;\n    for(int i=1;i<32;i*=2) x|=x>>i;\n    return x+1;\n}\nconst int I=INF;\nint F(int a,int b){return min(a,b);}\n  \nstruct SegmentTree{\n    int size;\n    vi data;\n    SegmentTree(int n):size(NextPow2(n)),data(size*2,I){}\n    SegmentTree(const vi& a):size(NextPow2(a.size())),data(size*2,I){\n        copy(all(a),begin(data)+size);\n        peri(i,1,size) data[i]=F(data[i*2],data[i*2+1]);\n    }\n    int Get(int i){\n        return data[size+i];\n    }\n    void Update(int i,int x){\n        data[size+i]=x;\n        for(i+=size;i/=2;) data[i]=F(data[i*2],data[i*2+1]);\n    }\n    int Query(int a,int b,int i,int l,int r){\n        if(b<=l || r<=a) return I;\n        if(a<=l && r<=b) return data[i];\n        return F(Query(a,b,i*2,l,(l+r)/2),Query(a,b,i*2+1,(l+r)/2,r));\n    }\n    int Query(int a,int b){\n        return Query(a,b,1,0,size);\n    }\n};\n  \nint main()\n{\n    for(string s;getline(cin,s) && s!=\"#\";){\n        int n=s.size();\n        vi sa(n),lcp(n);\n        KaerkkaeinenSanders(s,sa);\n        LCP(s,sa,lcp);\n          \n        vi rank(n);\n        rep(i,n) rank[sa[i]]=i;\n          \n        SegmentTree st(lcp);\n        string res;\n        for(int i=1;i<=n;i++){\n            int alen=n-2*i,blen=i-alen;\n            if(alen<=0 || blen<=0) continue;\n            int a1=0,a2=i,a3=2*i;\n            int b1=alen,b2=alen+i;\n            vi ra={rank[0],rank[i],rank[2*i]}; sort(all(ra));\n            vi rb={rank[alen],rank[alen+i]}; sort(all(rb));\n            if(st.Query(ra[0]+1,ra[1]+1)>=alen && st.Query(ra[1]+1,ra[2]+1)>=alen && st.Query(rb[0]+1,rb[1]+1)>=blen){\n                res=s.substr(0,i);\n                break;\n            }\n        }\n        if(res.empty())\n            cout<<\"mitomerarenaiWA\"<<endl;\n        else\n            cout<<\"Love \"<<res<<\"!\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_RollingHash\n#define ___Class_RollingHash\n\n#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\ntemplate <long long mod, long long base = 257>\nclass RollingHash {\nprivate:\n\tstd::string str;\n\tstd::vector<long long> sum;\npublic:\n\tRollingHash() : str(\"\"), sum(std::vector<long long>(1, 0)) {};\n\tRollingHash(const std::string &s) : str(s) {\n\t\tsum.resize(str.size() + 1);\n\t\tfor (int i = 0; i < str.size(); i++) sum[i + 1] = (1LL * sum[i] * base + s[i]) % mod;\n\t}\n\tstatic inline long long modpow(long long a, long long b) {\n\t\tlong long ret = 1; a %= mod;\n\t\twhile (b) {\n\t\t\tif (b & 1) ret = 1LL * ret * a % mod;\n\t\t\ta = 1LL * a * a % mod;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tstd::string get() { return str; }\n\tlong long gethash(int l, int r) {\n\t\treturn (sum[r] - sum[l] * modpow(base, r - l) % mod + mod) % mod;\n\t}\n};\n\n#endif\n\nconst int MOD = 2016112121;\nstring T;\n\nint main() {\n\tcin >> T; RollingHash<MOD> S(T); bool flag = false;\n\tfor (int i = T.size() / 3; i >= 1; i--) {\n\t\tint G = (T.size() - i * 3); if (G % 2 == 1 || G <= 0)continue;\n\t\tG /= 2;\n\t\tlong long p1 = S.gethash(0, i);\n\t\tlong long p2 = S.gethash(i, i + G);\n\t\tlong long p3 = S.gethash(i + G, i * 2 + G);\n\t\tlong long p4 = S.gethash(i * 2 + G, i * 2 + G * 2);\n\t\tlong long p5 = S.gethash(i * 2 + G * 2, i * 3 + G * 2);\n\t\tif (flag == false) {\n\t\t\tif (p1 == p3 && p3 == p5) {\n\t\t\t\tif (p2 == p4) {\n\t\t\t\t\tcout << \"Love \" << T.substr(0, i + G) << \"!\" << endl; flag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (flag == false)cout << \"mitomerarenaiWA\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nconst ull B = 100000007;\n\null hash[3000010];\null po[3000010];\n\n\nint main(){\n    \n    string s; cin >> s;\n    int n = (int)s.size();\n    \n    hash[0] = 0;\n    po[0] = 1;\n\n    for(int i = 1; i <= n; i++){\n        po[i] = po[i - 1] * B;\n        hash[i] = hash[i - 1] * B + (ull)(s[i - 1] - 'a' + 1);\n    }\n\n    \n\n    for(int i = (n - 2) / 3; i >= 0; i--){\n        if((n - 3 * i) % 2 == 1) continue;\n\n        int j = ((n - 3 * i) / 2);\n        //cout << i << \" \" << j << endl;\n        ull H1 = hash[i] - hash[0] * po[i];\n        ull H2 = hash[i + j] - hash[i] * po[j];\n        ull H3 = hash[2 * i + j] - hash[i + j] * po[i];\n        ull H4 = hash[2 * i + 2 * j] - hash[2 * i + j] * po[j];\n        ull H5 = hash[n] - hash[2 * i + 2 * j] * po[n - (2 * i + 2 * j)];\n\n        \n        if(H1 == H3 && H3 == H5 && H2 == H4){\n            string A = s.substr(0, i);\n            string B = s.substr(i, j);\n            cout << \"Love \" << A + B << \"!\" << endl;\n            return 0;\n        }\n    }\n\n    cout << \"mitomerarenaiWA\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\nint BASE = 131;\nint MOD = 3037000493;\n\nint powMod(int x, int y) {\n  int res = 1;\n  for(; y > 0; y >>= 1, (x *= x) %= MOD) {\n    if(y & 1) (res *= x) %= MOD;\n  }\n  return res;\n}\n\nint subMod(int x, int y) {\n  x %= MOD; y %= MOD;\n  if(x < 0) x += MOD;\n  if(y < 0) y += MOD;\n  int res = x - y;\n  if(res < 0) res += MOD;\n  return res % MOD;\n}\n\nint partial(const vector<int> &hashary, int i, int j) {\n  // cerr << \"(\" << i << \",\" << j << \") = \";\n  int sub = hashary[i] * powMod(BASE, j - i);\n  sub %= MOD;\n  if(sub < 0) sub += MOD;\n  // cerr << hashary[j] << \" - \" << sub << \" = \" << subMod(hashary[j], sub) << endl;\n  return subMod(hashary[j], sub);\n}\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  string S; cin >> S;\n  vector<int> hashary(S.size() + 1, 0);\n  REP(i,S.size()) {\n    hashary[i + 1] = (hashary[i] * BASE + S[i]) % MOD;\n  }\n\n  bool flag = false;\n  string strA, strB;\n  REP(i,S.size()) {\n    int A = i + 1;\n    if(((int)S.size() - 3 * A) % 2 != 0) continue;\n    int B = ((int)S.size() - 3 * A) / 2;\n    if(B < 1) continue;\n    // DEBUG(A);\n    // DEBUG(B);\n    if(partial(hashary, 0, A) == partial(hashary, A + B, A + B + A)\n        && partial(hashary, 0, A) == partial(hashary, A + B + A + B, A + B + A + B + A)\n        && partial(hashary, A, A + B) == partial(hashary, A + B + A, A + B + A + B)) {\n      if(flag == false) {\n        flag = true;\n        strA = S.substr(0, A);\n        strB = S.substr(A, B);\n      }\n      else {\n        if(strA.size() + strB.size() > A + B) {\n          strA = S.substr(0, A);\n          strB = S.substr(A, B);\n        }\n      }\n    }\n  }\n  if(!flag) {\n    cout << \"mitomerarenaiWA\" << endl;\n  }\n  else {\n    cout << \"Love \" << strA << strB << \"!\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing hash_t = unsigned long long;\n\ntemplate<hash_t MOD>\nstruct rolloing_hash {\n    int n, b;\n    vector<hash_t> pow, hash;\n    \n    rolloing_hash() {}\n    \n    rolloing_hash(const string &s, hash_t b_ = 100) {\n        set(s, b_);\n    }\n    \n    void set(const string &s, hash_t b_ = 100) {\n        n = s.size();\n        b = b_;\n        calc_pow();\n        calc_hash(s.c_str());\n    }\n\n    void calc_pow() {\n        pow.resize(n + 1); pow[0] = 1;\n        for (int i = 0; i < n; i++) {\n            pow[i + 1] = (1LL * pow[i] * b) % MOD;\n        }\n    }\n    \n    void calc_hash(const char *s) {\n        hash.resize(n + 1);\n        hash[0] = 0;\n        for (int i = 0; i < n; i++) {\n            hash[i + 1] = (s[i] + 1LL * hash[i] * b) % MOD;\n        }\n    }\n    \n    hash_t get(int i) const {\n        return hash[i]; \n    }\n    \n    hash_t get(int i, int j) const {\n        return (get(j) - (get(i) * pow[j - i] % MOD) + MOD) % MOD;\n    }\n};\n\nusing RH = rolloing_hash<1000000007>;\n\nint main() {\n    string s;\n    \n    while (cin >> s) {\n        int n = s.size();\n        int a = n % 2 == 0 ? 2 : 1;\n        int b = n % 2 == 0 ? n / 2 - 1 : n / 2;\n        int c = n % 2 == 0 ? b + 2 : b + 1;\n        int d = n - a;\n        RH rh(s);\n        int ans = -1;\n        while (a < b) {\n            hash_t A = rh.get(0, a);\n            if (rh.get(b, c) == A && rh.get(d, n) == A && rh.get(a, b) == rh.get(c, d)) {\n                ans = b;\n                break;\n            }\n            a += 2;\n            b -= 1;\n            c += 1;\n            d -= 2;\n        }\n        if (ans != -1) {\n            cout << \"Love \" << s.substr(0, ans) << '!';\n        } else {\n            cout << \"mitomerarenaiWA\";\n        }\n        cout << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing hash_t = unsigned long long;\nconst hash_t b = 10007;\n\nstruct rolloing_hash {\n    int n;\n    vector<hash_t> pow, hash;\n    \n    rolloing_hash() {}\n    \n    rolloing_hash(const string &s) {\n        set(s);\n    }\n    \n    void set(const string &s) {\n        n = s.size();\n        calc_pow();\n        calc_hash(s.c_str());\n    }\n\n    void calc_pow() {\n        pow.resize(n + 1); pow[0] = 1;\n        for (int i = 0; i < n; i++) {\n            pow[i + 1] = pow[i] * b;\n        }\n    }\n    \n    void calc_hash(const char *s) {\n        hash.resize(n + 1);\n        hash[0] = 0;\n        for (int i = 0; i < n; i++) {\n            hash[i + 1] = s[i] + hash[i] * b;\n        }\n    }\n    \n    hash_t get(int i) const {\n        return hash[i]; \n    }\n    \n    hash_t get(int i, int j) const {\n        return get(j) - get(i) * pow[j - i];\n    }\n};\n\nusing RH = rolloing_hash;\n\nint main() {\n    string s;\n    cin >> s;\n    int n = s.size();\n    int a = n % 2 == 0 ? 2 : 1;\n    int b = n % 2 == 0 ? n / 2 - 1 : n / 2;\n    int c = b + a;\n    int d = n - a;\n    RH rh(s);\n    int ans = n;\n    while (a < b) {\n        hash_t A = rh.get(0, a);\n        if (rh.get(b, c) == A && rh.get(d, n) == A && rh.get(a, b) == rh.get(c, d)) {\n            ans = min(ans, b);\n        }\n        a += 2;\n        b -= 1;\n        c += 1;\n        d -= 2;\n    }\n    if (ans != n) {\n        cout << \"Love \" << s.substr(0, ans) << '!';\n    } else {\n        cout << \"mitomerarenaiWA\";\n    }\n    cout << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP;\n  vector< int > rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size() - 1);\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i]] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    if(k < 0) return (0);\n    return (LCP[k]);\n  }\n\n  int size() const\n  {\n    return (LCP.size() + 1);\n  }\n};\n\nstruct StaticSegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  StaticSegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    };\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(a, b, 0, 0, sz));\n  }\n};\n\n\nint main()\n{\n  string S;\n  cin >> S;\n  SuffixArray sa;\n  sa.Build_SA(S);\n  LongestCommonPrefixArray lcp;\n  lcp.Build_LCP(sa);\n  StaticSegmentTree tree(lcp.size());\n  for(int i = 0; i < lcp.size(); i++) {\n    tree.set(i, lcp[i - 1]);\n\n    //cout << lcp[i - 1] << \" \" << S.substr(sa[i]) << endl;\n  }\n  tree.build();\n\n  int ret = INF;\n  for(int A = 1; A < S.size(); A++) {\n    int B = (int) S.size() - A * 3;\n    if(B <= 0) break;\n    if(B & 1) continue;\n    B /= 2;\n    if(tree.rmq(lcp.rank[0] + 1, lcp.rank[A + B] + 1) >= A &&\n       tree.rmq(lcp.rank[0] + 1, lcp.rank[A + B + A + B] + 1) >= A &&\n       tree.rmq(lcp.rank[A] + 1, lcp.rank[A + B + A] + 1) >= B) {\n      ret = min(ret, A + B);\n    }\n  }\n\n  if(ret >= INF) {\n    cout << \"mitomerarenaiWA\" << endl;\n  } else {\n    cout << \"Love \" << S.substr(0, ret) << \"!\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <string>\n\n#define fprintf(...) void(0)\n\ntemplate <intmax_t X=943681729, intmax_t MOD=1000000007>\nclass RollingHash {\n  std::vector<intmax_t> hash;\n  intmax_t offset(size_t len) const {\n    intmax_t res=1;\n    for (intmax_t dbl=X%MOD; len; len>>=1) {\n      if (len & 1) res = res*dbl % MOD;\n      dbl = dbl*dbl % MOD;\n    }\n    return res;\n  }\n\npublic:\n  RollingHash(const std::string &s): hash(s.length()+1) {\n    for (size_t i=0; i<s.length(); ++i)\n      hash[i+1] = (hash[i]*X+s[i]) % MOD;\n  }\n\n  intmax_t operator ()(size_t i, size_t j) const {\n    // s[i..j-1]\n    assert(i < j);\n    intmax_t res=hash[j];\n    res = (res - offset(j-i)*hash[i]) % MOD;\n    if (res < 0) res += MOD;\n    return res;\n  }\n};\n\nusing RHash=RollingHash<>;\n\nint main() {\n  char buf[1234567];\n  scanf(\"%s\", buf);\n  std::string s=std::move(buf);\n  RHash rh(s);\n\n  uintmax_t aa=s.length(), bb=s.length();\n  for (size_t i=1; i<s.length(); ++i) {\n    size_t al=i;\n    fprintf(stderr, \"al: %zu\\n\", al);\n    if (al*3 >= s.length())\n      continue;\n    if ((s.length()-al*3) % 2 > 0) continue;\n    size_t bl=(s.length()-al*3)/2;\n    fprintf(stderr, \"bl: %zu\\n\", bl);\n    assert(al+bl+al+bl+al == s.length());\n\n    intmax_t ah1=rh(0, al);\n    intmax_t bh1=rh(al, al+bl);\n    intmax_t ah2=rh(al+bl, al+bl+al);\n    intmax_t bh2=rh(al+bl+al, al+bl+al+bl);\n    intmax_t ah3=rh(al+bl+al+bl, al+bl+al+bl+al);\n\n    fprintf(stderr, \"%zu/%zu, %jd %jd %jd %jd %jd\\n\",\n            al, bl, ah1, bh1, ah2, bh2, ah3);\n\n    if (!(ah1 == ah2 && ah2 == ah3 && bh1 == bh2)) continue;\n\n    if (aa+bb > al+bl) {\n      assert(al && bl);\n      aa = al;\n      bb = bl;\n    }\n  }\n\n  if (aa == s.length()) {\n    assert(bb == s.length());\n    printf(\"mitomerarenaiWA\\n\");\n  } else {\n    assert(aa < s.length() && bb < s.length());\n    printf(\"Love %s%s!\\n\", s.substr(0, aa).c_str(), s.substr(aa, bb).c_str());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nvoid z_algorithm(string& S,vector<int>& res)\n{\n    int sz = (int)S.size();\n    res.resize(sz);\n    int c = 0;\n    for(int i = 1; i < sz; i++){\n        if(i+res[i-c] < c+res[c]){\n            res[i] = res[i-c];\n        }else{\n            int j = max(0, c+res[c]-i);\n            while (i+j < sz && S[j] == S[i+j]) ++j;\n            res[i] = j;\n        }\n    }\n    res[0] = sz;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = s.size();\n    if(n>900000) cout << \"MURI\" << endl;return 0;\n    vector<int> a,b;\n    z_algorithm(s,a);\n    reverse(s.begin(),s.end());\n    z_algorithm(s,b);\n    int ma = -1;\n    for(int i=n/3-2;i<n/2+2;i++){\n        if(i<=0||i>=n)continue;\n        int tmp = n-2*i;\n        if(a[i]==n-i&&b[i]==n-i&&tmp>0&&(n-3*(tmp))/2>0){\n            ma = max(ma,tmp);\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     cout << a[i] << \" \";\n    // }\n    // cout << endl;\n    // for(int i=0;i<n;i++){\n    //     cout << b[i] << \" \";\n    // }\n    // cout << endl;\n    \n    if(ma==-1){\n        cout << \"mitomerarenaiWA\" << endl;\n    }else{\n        int x = ma;\n        int y = (n-3*ma)/2;\n        printf(\"Love \");\n        for(int i=0;i<x+y;i++){\n            printf(\"%c\",s[n-i-1]);\n        }\n        printf(\"!\\n\");\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nclass RollingHash\n{\nprivate:\n    static const int X[], Y[], M[];\n    deque<char> dq;\n    long long xp[3];\n    long long hash[3];\npublic:\n    RollingHash(){\n        for(int i=0; i<3; ++i){\n            xp[i] = 1;\n            hash[i] = 0;\n        }\n    }\n    void push_back(char c){\n        dq.push_back(c);\n        for(int i=0; i<3; ++i){\n            hash[i] *= X[i];\n            hash[i] += c;\n            hash[i] %= M[i];\n            xp[i] *= X[i];\n            xp[i] %= M[i];\n        }\n    }\n    void pop_back(){\n        for(int i=0; i<3; ++i){\n            hash[i] += M[i] - dq.back();\n            hash[i] *= Y[i];\n            hash[i] %= M[i];\n            xp[i] *= Y[i];\n            xp[i] %= M[i];\n        }\n        dq.pop_back();\n    }\n    void push_front(char c){\n        dq.push_front(c);\n        for(int i=0; i<3; ++i){\n            hash[i] += c * xp[i];\n            hash[i] %= M[i];\n            xp[i] *= X[i];\n            xp[i] %= M[i];\n        }\n    }\n    void pop_front(){\n        for(int i=0; i<3; ++i){\n            xp[i] *= Y[i];\n            xp[i] %= M[i];\n            hash[i] -= dq.front() * xp[i];\n            hash[i] %= M[i];\n            if(hash[i] < 0)\n                hash[i] += M[i];\n        }\n        dq.pop_front();\n    }\n    bool operator==(const RollingHash& rh){\n        for(int i=0; i<3; ++i){\n            if(hash[i] != rh.hash[i])\n                return false;\n        }\n        return true;\n    }\n    bool operator!=(const RollingHash& rh){\n        return !(*this == rh);\n    }\n};\nconst int RollingHash::X[] = {2000000011, 2000000033, 2000000063}; // 素数\nconst int RollingHash::Y[] = {1447368484, 1178571481, 1277777841}; // X * Y == 1 (mod M)\nconst int RollingHash::M[] = {2000000087, 2000000089, 2000000099}; // 合同式の法（素数）\n\nstring solve(const string& s)\n{\n    int n = s.size();\n    if(n < 5)\n        return \"\";\n\n    vector<int> v(6);\n    v[0] = 0;\n    v[2] = (n + 3) / 3;\n    v[4] = v[2] * 2;\n    v[1] = n - v[4];\n    v[3] = v[2] + v[1];\n    v[5] = n;\n    vector<int> d = {0, -2, 1, -1, 2, 0};\n\n    vector<RollingHash> rh(5);\n    for(int i=0; i<5; ++i){\n        for(int j=v[i]; j<v[i+1]; ++j){\n            rh[i].push_back(s[j]);\n        }\n    }\n\n    for(;;){\n        bool ok = true;\n        for(int i=0; i<3; ++i){\n            if(rh[i] != rh[i+2])\n                ok = false;\n        }\n        if(ok)\n            return s.substr(0, v[2]);\n\n        if(v[1] < 2)\n            break;\n\n        for(int i=1; i<5; ++i){\n            if(d[i] > 0){\n                for(int j=0; j<d[i]; ++j){\n                    rh[i-1].push_back(s[v[i]]);\n                    rh[i].pop_front();\n                    ++ v[i];\n                }\n            }\n            else{\n                for(int j=0; j<-d[i]; ++j){\n                    rh[i-1].pop_back();\n                    rh[i].push_front(s[v[i]-1]);\n                    -- v[i];\n                }\n            }\n        }\n    }\n\n    return \"\";\n}\n\nint main()\n{\n    string s;\n    cin >> s;\n\n    string ans = solve(s);\n    if(ans == \"\")\n        cout << \"mitomerareniWA\" << endl;\n    else\n        cout << \"Love \" << ans << '!' << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nint main() {\n\tstring st; cin >> st;\n\tRollingHash rh;\n\trh.init(st);\n\tpair<int, int>ans=make_pair(0,0);\n\tfor (int a = st.size() / 3; a >= 0; --a) {\n\t\tif ((st.size() - a * 3) % 2)continue;\n\t\telse {\n\t\t\tint b = (st.size() - a * 3) / 2;\n\t\t\tha h0 = rh.hash(0, a - 1);\n\t\t\tha h1 = rh.hash(a, a + b - 1);\n\t\t\tha h2 = rh.hash(a + b, 2 * a + b - 1);\n\t\t\tha h3 = rh.hash(2 * a + b, 2 * a + 2 * b-1);\n\t\t\tha h4 = rh.hash(2 * a + 2 * b, 3 * a + 2 * b - 1);\n\t\t\tif (h0 == h2&&h2 == h4&&h1 == h3) {\n\t\t\t\tans = make_pair(a, b);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (ans.first) {\n\t\tcout << \"Love \" << st.substr(0, ans.first) << st.substr(ans.first, ans.second) << \"!\" << endl;\n\t}\n\telse {\n\t\tcout << \"mitomerarenaiWA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct RollingHash {\n    typedef long long int_type;\n    typedef pair<int_type,int_type> hash_type;\n\n    int_type base1;\n    int_type base2;\n    int_type mod1;\n    int_type mod2;\n    vector<int_type> hash1;\n    vector<int_type> hash2;\n    vector<int_type> pow1;\n    vector<int_type> pow2;\n\n    RollingHash() : base1(1009), base2(1007), mod1(1000000007), mod2(1000000009) {}\n\n    void init(const string &s) {\n        int n = s.size();\n\n        hash1.assign(n+1,0);\n        hash2.assign(n+1,0);\n        pow1.assign(n+1,1);\n        pow2.assign(n+1,1);\n\n        for(int i=0;i<n;i++) {\n            hash1[i+1] = (hash1[i]+s[i]) * base1 % mod1;\n            hash2[i+1] = (hash2[i]+s[i]) * base2 % mod2;\n            pow1[i+1] = pow1[i] * base1 % mod1;\n            pow2[i+1] = pow2[i] * base2 % mod2;\n        }\n    }\n\n    hash_type get(int l,int r) {\n        int_type t1 = ((hash1[r] - hash1[l] * pow1[r-l]) % mod1 + mod1) % mod1;\n        int_type t2 = ((hash2[r] - hash2[l] * pow2[r-l]) % mod2 + mod2) % mod2;\n        return make_pair(t1, t2);\n    }\n\n    RollingHash::hash_type concat(hash_type h1, hash_type h2, int h2_len) {\n        return make_pair((h1.fr*pow1[h2_len]+h2.fr)%mod1, (h1.sc*pow2[h2_len]+h2.sc)%mod2);\n    }\n\n};\n\nchar in[1000006];\nint main() {\n    scanf(\"%s\",in);\n    string s=string(in);\n    int n=s.size();\n    RollingHash rh;\n    rh.init(s);\n    string ans=\"mitomerarenaiWA\";\n    string A,B;\n    P ansP=P(INF,INF);;\n    rep(i,n) if(i) {\n        int t=n-i*3;\n        //printf(\"[debug] %d %d\\n\",i,t);\n        if(t%2!=0) continue;\n        if(t==0) continue;\n        if(t<0) continue;\n        if(t>=n) continue;\n        t/=2;\n        if(rh.get(0,i)==rh.get(i+t,2*i+t)&&rh.get(i+t,2*i+t)==rh.get(2*i+2*t,3*i+2*t)) {\n            if(rh.get(i,i+t)==rh.get(2*i+t,2*i+2*t)) {\n                //printf(\"[debug] %d %d\\n\",i,t);\n                ans=\"Love Nico!\";\n                if(ansP.fr+ansP.sc>i+t) {\n                    ansP=P(i,t);\n                }\n            }\n        }\n    }\n\n    if(ans==\"mitomerarenaiWA\") cout<<ans<<endl;\n    else {\n        //cout<<ansP.fr<<\", \"<<ansP.sc<<endl;\n        cout<<\"Love \";\n        cout<<s.substr(0,ansP.fr);\n        cout<<s.substr(ansP.fr,ansP.sc);\n        cout<<\"!\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n//Roling Hash\n//RollingHash RH(s,base) base:[2,MOD)?????±??°\n//RH.set(s,base): vector???????§???????????????????????????§????????????????????????????????????\n//RH.get(l,r): [l,r)??????????????\\ O(1)\n//1000000007, 1000000009, 1000000021\ntemplate<long long MOD>\nclass RollingHash {\npublic:\n\tint n;\n\tlong long base;\n\tvector<long long> pow, hash;\n\tRollingHash() {}\n\tRollingHash(const string &s, long long base_ = 10007) { set(s, base_); }\n\tvoid set(const string &s, long long base_ = 10007) {\n\t\tn = s.size();\n\t\tbase = base_;\n\t\tcalc(s.c_str());\n\t}\n\tlong long get(int x)const { return hash[x]; }\n\tlong long get(int l, int r)const { return (get(r) - get(l)*pow[r - l] % MOD + MOD) % MOD; }\n\tvoid calc(const char *s) {\n\t\tpow.resize(n + 1);\n\t\tpow[0] = 1;\n\t\thash.resize(n + 1);\n\t\thash[0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpow[i + 1] = pow[i] * base % MOD;\n\t\t\thash[i + 1] = (s[i] + hash[i] * base) % MOD;\n\t\t}\n\t}\n};\n\nusing RH = RollingHash<1000000007>;\n\nint main() {\n\tstring s;\n\n\twhile (cin >> s) {\n\t\tint n = s.size();\n\t\tint a = n % 2 == 0 ? 2 : 1;\n\t\tint b = n % 2 == 0 ? n / 2 - 1 : n / 2;\n\t\tint c = b + a;\n\t\tint d = n - a;\n\t\tRH rh(s);\n\t\tint ans = n;\n\t\twhile (a < b) {\n\t\t\tint A = rh.get(0, a);\n\t\t\tif (rh.get(b, c) == A && rh.get(d, n) == A && rh.get(a, b) == rh.get(c, d)) {\n\t\t\t\tans = min(ans, b);\n\t\t\t}\n\t\t\ta += 2;\n\t\t\tb -= 1;\n\t\t\tc += 1;\n\t\t\td -= 2;\n\t\t}\n\t\tif (ans != n) {\n\t\t\tcout << \"Love \" << s.substr(0, ans) << '!';\n\t\t}\n\t\telse {\n\t\t\tcout << \"mitomerarenaiWA\";\n\t\t}\n\t\tcout << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\ntemplate<typename C>\nvoid RadixSort(const vi& src,vi& dst,const C& s,int ofs,int n,int asize)\n{\n\tvi hist(asize+1);\n\trep(i,n) hist[s[ofs+src[i]]]++;\n\trep(i,asize) hist[i+1]+=hist[i];\n\tper(i,n) dst[--hist[s[ofs+src[i]]]]=src[i];\n}\n\nbool Less(int a1,int a2,int b1,int b2)\n{\n\treturn a1!=b1?a1<b1:a2<b2;\n}\nbool Less(int a1,int a2,int a3,int b1,int b2,int b3)\n{\n\treturn a1!=b1?a1<b1:Less(a2,a3,b2,b3);\n}\n\n// s[0..n-1]: 入力文字列．末尾に'\\0'が3つ必要(s[n]=s[n+1]=s[n+2]=0)．\n// sa[0..n-1]: 接尾辞配列．\n// asize: アルファベットサイズ，s[i] \\in [1,asize]\ntemplate<typename C>\nvoid KaerkkaeinenSanders(const C& s,vi& sa,int asize)\n{\n\tint n=sa.size();\n\tint n0=(n+2)/3,n1=(n+1)/3,n2=n/3,n02=n0+n2;\n\tvi s12(n02+3),sa12(n02);\n\t\n\tfor(int i=0,j=0;i<n+(n0-n1);i++)\n\t\tif(i%3) s12[j++]=i;\n\tRadixSort(s12,sa12,s,2,n02,asize);\n\tRadixSort(sa12,s12,s,1,n02,asize);\n\tRadixSort(s12,sa12,s,0,n02,asize);\n\t\n\tint name=0,x=-1,y=-1,z=-1;\n\trep(i,n02){\n\t\tint j=sa12[i];\n\t\tif(s[j]!=x || s[j+1]!=y || s[j+2]!=z)\n\t\t\tx=s[j],y=s[j+1],z=s[j+2],name++;\n\t\tif(j%3==1) s12[j/3]=name;\n\t\telse       s12[n0+j/3]=name;\n\t}\n\t\n\tif(name==n02) // unique\n\t\trep(i,n02) sa12[s12[i]-1]=i;\n\telse{\n\t\tKaerkkaeinenSanders(s12,sa12,name);\n\t\trep(i,n02) s12[sa12[i]]=i+1;\n\t}\n\t\n\tvi s0(n0),sa0(n0);\n\tfor(int i=0,j=0;i<n02;i++)\n\t\tif(sa12[i]<n0) s0[j++]=3*sa12[i];\n\tRadixSort(s0,sa0,s,0,n0,asize);\n\t\n\tint i=0,j=n0-n1,k=0;\n\twhile(i<n0 && j<n02){\n\t\tint p=sa0[i],q=sa12[j]<n0?sa12[j]*3+1:(sa12[j]-n0)*3+2;\n\t\tif(sa12[j]<n0?\n\t\t\tLess(s[p],s12[p/3],s[q],s12[n0+sa12[j]]):\n\t\t\tLess(s[p],s[p+1],s12[n0+p/3],s[q],s[q+1],s12[sa12[j]+1-n0]))\n\t\t\tsa[k++]=p,i++;\n\t\telse\n\t\t\tsa[k++]=q,j++;\n\t}\n\tfor(;i<n0;k++,i++)\n\t\tsa[k]=sa0[i];\n\tfor(;j<n02;k++,j++)\n\t\tsa[k]=sa12[j]<n0?sa12[j]*3+1:(sa12[j]-n0)*3+2;\n}\nvoid KaerkkaeinenSanders(const string& s,vi& sa)\n{\n\tKaerkkaeinenSanders<string>(s+string(3,0),sa,127);\n}\nvoid KaerkkaeinenSanders(const char* s,vi& sa)\n{\n\tKaerkkaeinenSanders<string>(s+string(3,0),sa,127);\n}\n\n// s[0..n-1] (s[n]=0), sa[0..n-1]\n// lcp[0..n-1] (lcp[i]:s[sa[i-1]..]とs[sa[i]..]のLCP.lcp[0]=0)\ntemplate<typename C>\nvoid LCP(const C& s,const vi& sa,vi& lcp)\n{\n\tint n=sa.size();\n\tvi rank(n);\n\trep(i,n) rank[sa[i]]=i;\n\tfor(int i=0,h=0;i<n;i++){\n\t\tif(h>0) h--;\n\t\tif(rank[i]>0)\n\t\t\tfor(int j=sa[rank[i]-1];;h++)\n\t\t\t\tif(s[j+h]!=s[i+h]) break;\n\t\tlcp[rank[i]]=h;\n\t}\n}\n\nint NextPow2(int x)\n{\n\tx--;\n\tfor(int i=1;i<32;i*=2) x|=x>>i;\n\treturn x+1;\n}\nconst int I=INF;\nint F(int a,int b){return min(a,b);}\n\nstruct SegmentTree{\n\tint size;\n\tvi data;\n\tSegmentTree(int n):size(NextPow2(n)),data(size*2,I){}\n\tSegmentTree(const vi& a):size(NextPow2(a.size())),data(size*2,I){\n\t\tcopy(all(a),begin(data)+size);\n\t\tperi(i,1,size) data[i]=F(data[i*2],data[i*2+1]);\n\t}\n\tint Get(int i){\n\t\treturn data[size+i];\n\t}\n\tvoid Update(int i,int x){\n\t\tdata[size+i]=x;\n\t\tfor(i+=size;i/=2;) data[i]=F(data[i*2],data[i*2+1]);\n\t}\n\tint Query(int a,int b,int i,int l,int r){\n\t\tif(b<=l || r<=a) return I;\n\t\tif(a<=l && r<=b) return data[i];\n\t\treturn F(Query(a,b,i*2,l,(l+r)/2),Query(a,b,i*2+1,(l+r)/2,r));\n\t}\n\tint Query(int a,int b){\n\t\treturn Query(a,b,1,0,size);\n\t}\n};\n\nint main()\n{\n\tfor(string s;getline(cin,s) && s!=\"#\";){\n        int n=s.size();\n        vi sa(n),lcp(n);\n        KaerkkaeinenSanders(s,sa);\n        LCP(s,sa,lcp);\n        \n        vi rank(n);\n        rep(i,n) rank[sa[i]]=i;\n        \n        SegmentTree st(lcp);\n        string res;\n        for(int i=1;i<=n;i++){\n            if(3*i<=n || s.size()<=2*i) continue;\n            int alen=n-2*i,blen=i-alen;\n            int a1=0,a2=i,a3=2*i;\n            int b1=alen,b2=alen+i;\n            vi ra={rank[0],rank[i],rank[2*i]}; sort(all(ra));\n            vi rb={rank[alen],rank[alen+i]}; sort(all(rb));\n            if(st.Query(ra[0]+1,ra[1])>=alen && st.Query(ra[1]+1,ra[2])>=alen && st.Query(rb[0]+1,rb[1])>=blen){\n                res=s.substr(0,i);\n                break;\n            }\n        }\n        if(res.empty())\n            cout<<\"mitomerarenaiWA\"<<endl;\n        else\n            cout<<\"Love \"<<res<<\"!\"<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"random\"\n#include \"string\"\n#include \"bitset\"\n#include \"algorithm\"\n#include \"map\"\n#include \"queue\"\n#include \"list\"\n#include \"set\"\n#include \"climits\"\n#include \"iomanip\"\n#include \"stack\"\n#include \"functional\"\n\nusing namespace std;\nusing ll = long long int;\nusing PII = pair<ll, ll>;\n\n#define FOR(i, b, n) for(ll (i)=(a); (i)<(n); ++(i))\n#define REP(i, n) FOR(a, 0, n)\n\nstruct rollingHash {\n\tll mo[2] = { 1000000009, 998244353 };\n\tll base[2] = { 1009, 1007 };\n\tvector<ll> hash[2], power[2];\n\n\trollingHash() {}\n\trollingHash(string s) {\n\t\thash[0].resize(s.size() + 1); hash[1].resize(s.size() + 1);\n\t\tpower[0].resize(s.size() + 1); power[1].resize(s.size() + 1);\n\t\tinit(s);\n\t}\n\n\tinline ll mul(ll a, ll b, ll md) const {\n\t\treturn a * b % md;\n\t}\n\n\tvoid init(string s) {\n\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\tpower[i][0] = 1;\n\t\t\tfor (int j = 1; j < s.size(); ++j) power[i][j] = mul(power[i][j - 1], base[i], mo[i]);\n\t\t}\n\t\tfor (int i = 0; i < 2; ++i) for (int j = 0; j < s.size(); ++j) {\n\t\t\thash[i][j + 1] = (hash[i][j] + mul(power[i][j], s[j] - 'A' + 1, mo[i])) % mo[i];\n\t\t}\n\t}\n\n\tbool equal(int l1, int r1, int l2, int r2) {\n\t\tfor (ll i = 0; i < 2; ++i) {\n\t\t\tll a = (hash[i][r1] - hash[i][l1] + mo[i]) % mo[i];\n\t\t\tll b = (hash[i][r2] - hash[i][l2] + mo[i]) % mo[i];\n\t\t\tif (mul(a, power[i][l2 - l1], mo[i]) != b) return false;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nvector<ll> Zalgo(string s) {\n\tvector<ll> v(s.size());\n\tv[0] = s.size();\n\tint i = 1, j = 0;\n\twhile (i < s.size()) {\n\t\twhile (i + j < s.size() && s[j] == s[i + j]) ++j;\n\t\tv[i] = j;\n\t\tif (j == 0) { ++i; continue; }\n\t\tint k = 1;\n\t\twhile (i + k < s.size() && k + v[k] < j) v[i + k] = v[k], ++k;\n\t\ti += k, j -= k;\n\t}\n\treturn v;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tstring s;\n\tcin >> s;\n\n\tconst ll INF = 1LL << 30;\n\tll ans = INF;\n\t// rollingHash hash(s);\n\tauto v = Zalgo(s);\n\tfor (ll i = 1; i <= s.size(); ++i) {\n\t\tll len = (ll)s.size() - i * 3;\n\t\tif (len <= 0 || len % 2) continue;\n\t\tlen /= 2;\n\t\tll idx1 = i - 1, idx2 = i + len - 1, idx3 = 2 * i + len - 1, idx4 = 2 * i + 2 * len - 1;\n\t\tif (v[i + len] == 2*i + len && v[2 * i + 2 * len] == i) {\n\t\t\tans = min(ans, i + len);\n\t\t}\n\t\t//if (hash.equal(0, idx1, idx2 + 1, idx3) && hash.equal(idx2 + 1, idx3, idx4 + 1, s.size() - 1) && hash.equal(idx1 + 1, idx2, idx3 + 1, idx4)) {\n\t\t//\tif (ans > i + len) {\n\t\t//\t\tans = i + len;\n\t\t//\t}\n\t\t//}\n\t}\n\n\tif (ans == INF) cout << \"mitomerarenaiWA\" << endl;\n\telse cout << \"Love \" << s.substr(0, ans) << \"!\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nconst int INF = (int)1e18;\nstruct RMQ {\n\tvector<int> data;\n\tint N;\n\tRMQ(int size) {\n\t\tN = 1;\n\t\twhile(N < size) N *= 2;\n\t\tdata.assign(2*N - 1, INF);\n\t}\n\tvoid update(int k, int a) {\n\t\tk += N - 1;\n\t\tdata[k] = a;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1)/2;\n\t\t\tdata[k] = min(data[2*k + 1], data[2*k + 2]);\n\t\t}\n\t}\n\tint minimum(int a, int b) {\n\t\treturn minimum_sub(a, b, 0, 0, N);\n\t}\n\tint minimum_sub(int a, int b, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <= b) return data[k];\n\n\t\treturn min(minimum_sub(a, b, 2*k + 1, l, (l + r)/2),\n\t\t\t\tminimum_sub(a, b, 2*k + 2, (l + r)/2, r));\n\t}\n};\n\nstruct SuffixArray {\n  int n, k;\n  vector<int> sa, rsa, lcp, rank, tmp;\n  SuffixArray(const string &S) : n(S.size()), sa(S.size() + 1), rsa(S.size() + 1), lcp(S.size() + 1), rank(S.size() + 1), tmp(S.size() + 1) {\n    {\n      auto compare_sa = [&](int i, int j) -> bool {\n          if(rank[i] != rank[j]) return rank[i] < rank[j];\n          else {\n            int ri = i + k <= n ? rank[i + k] : -1;\n            int rj = j + k <= n ? rank[j + k] : -1;\n            return ri < rj;\n          }\n      };\n      for(int i = 0; i <= n; ++i) {\n        sa[i] = i;\n        rank[i] = i < n ? S[i] : -1;\n      }\n      for(k = 1; k <= n; k *= 2) {\n        sort(sa.begin(), sa.begin() + n + 1, compare_sa);\n        tmp[sa[0]] = 0;\n        for(int i = 1; i <= n; i++) {\n          tmp[sa[i]] = tmp[sa[i - 1]] + (compare_sa(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        for(int i = 0; i <= n; i++) {\n          rank[i] = tmp[i];\n        }\n      }\n    }\n    {\n      for(int i = 0; i <= n; i++) rank[sa[i]] = i;\n      int h = 0;\n      lcp[0] = 0;\n      for(int i = 0; i < n; i++) {\n        int j = sa[rank[i] - 1];\n        if(h > 0) h--;\n        for(; j + h < n && i + h < n; h++) {\n          if(S[j + h] != S[i + h]) break;\n        }\n        lcp[rank[i] - 1] = h;\n      }\n    }\n    {\n      for(int i = 0; i <= n; ++i) {\n        rsa[sa[i]] = i;\n      }\n    }\n  }\n};\n\nsigned main() {\n  ios::sync_with_stdio(false);\n  string S; cin >> S;\n  int N = S.size();\n  SuffixArray SA(S);\n  RMQ rmq(N + 1);\n  REP(i,N+1) {\n    rmq.update(i,SA.lcp[i]);\n  }\n  int ansA = INF, ansB = INF;\n  REP(i,N/2) {\n    int LA = i + 1;\n    int LB = (N - 3 * LA) / 2;\n    if(LB < 1) break;\n    int l, r;\n\n    l = SA.rsa[0], r = SA.rsa[N - i - 1];\n    if(l > r) swap(l, r);\n    int lcpA = rmq.minimum(l, r);\n\n    l = SA.rsa[LA], r = SA.rsa[LA + LB + LA];\n    if(l > r) swap(l, r);\n    int lcpB = rmq.minimum(l, r);\n    // DEBUG(LA);\n    // DEBUG(lcpA);\n    // DEBUG(LB);\n    // DEBUG(lcpB);\n    if(lcpA >= LA && lcpB >= LB) {\n      if(LA + LB < ansA + ansB) {\n        ansA = LA;\n        ansB = LB;\n      }\n    }\n  }\n  if(ansA == INF && ansB == INF) {\n    cout << \"mitomerarenaiWA\" << endl;\n  }\n  else {\n  cout << \"Love \" << S.substr(0, ansA) << S.substr(ansA, ansB) << \"!\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(x,y,z) for(int x=y;x<=z;x++)\n#define FORD(x,y,z) for(int x=y;x>=z;x--)\n#define MSET(x,y) memset(x,y,sizeof(x))\n#define FOR(x,y) for(__typeof(y.begin()) x=y.begin();x!=y.end();x++)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define SZ size()\n#define M 1000005\nvoid RI(){}\ntemplate<typename... T>\nvoid RI( int& head, T&... tail ) {\n    scanf(\"%d\",&head);\n    RI(tail...);\n}\nusing namespace std;\ntypedef long long LL;\nint n,a1,a2;\nLL pre[2][M],pw[2][M], MOD[2]={1000000007, 1000000009};\nchar in[M];\npair<LL,LL> get_hash(int l,int r)\n{\n\tLL re[2] = { pre[0][r], pre[1][r] };\n\tif(l>1)\n\t{\n\t\tREP(i,0,1)\n\t\t{\n\t\t\tre[i] -= pre[i][l-1] * pw[i][r-l+1];\n\t\t\tre[i] %= MOD[i];\n\t\t\tre[i] = (re[i]+MOD[i]) % MOD[i];\n\t\t}\n\t}\n\treturn MP(re[0], re[1]);\n}\nint main()\n{\n\tscanf(\"%s\", in+1);\n\tn = strlen(in+1);\n\n\t//\n\t\n\tREP(j,0,1)\n\t{\n\t\tpre[j][1] = in[1];\n\t\tREP(i,2,n) pre[j][i] = (pre[j][i-1]*131 + in[i]) % MOD[j];\n\n\t\tpw[j][0] = 1;\n\t\tREP(i,1,n) pw[j][i] = (pw[j][i-1]*131) % MOD[j];\n\t}\n\n\ta1 = a2 = 0;\n\t//\n\tREP(i,1,n/3)\n\t{\n\t\tint j = n-3*i;\n\t\tif(j%2) continue;\n\t\tj = j/2;\n\t\tif(i*3 + j*2 != n) continue;\n\t\tif(j==0) continue;\n\n\t\tpair<LL,LL> h1,h2,h3,h4,h5;\n\t\th1 = get_hash(1,i);\n\t\th2 = get_hash(i+1,i+j);\n\t\th3 = get_hash(i+j+1, i+i+j);\n\t\th4 = get_hash(i+i+j+1, 2*(i+j));\n\t\th5 = get_hash(2*(i+j)+1, n);\n\n\t\tif(h1==h3 && h3==h5 && h2==h4)\n\t\t{\n\t\t\tif(a1==0)\n\t\t\t{\n\t\t\t\ta1=i;\n\t\t\t\ta2=j;\n\t\t\t}\n\t\t\telse if((a1+a2) > i+j)\n\t\t\t{\n\t\t\t\ta1 = i;\n\t\t\t\ta2 = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(a1==0) puts(\"mitomerarenaiWA\");\n\telse\n\t{\n\t\tprintf(\"Love \");\n\t\tREP(i,1,a1+a2) putchar(in[i]);\n\t\tputs(\"!\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nvoid z_algorithm(string& S,vector<int>& res)\n{\n    int sz = (int)S.size();\n    res.resize(sz);\n    int c = 0;\n    for(int i = 1; i < sz; i++){\n        if(i+res[i-c] < c+res[c]){\n            res[i] = res[i-c];\n        }else{\n            int j = max(0, c+res[c]-i);\n            while (i+j < sz && S[j] == S[i+j]) ++j;\n            res[i] = j;\n        }\n    }\n    res[0] = sz;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = s.size();\n    if(n>500000){\n        cout << \"MURI\" << endl\n        return 0;\n    }\n    vector<int> a,b;\n    z_algorithm(s,a);\n    reverse(s.begin(),s.end());\n    z_algorithm(s,b);\n    int ma = -1;\n    for(int i=n/3-2;i<n/2+2;i++){\n        if(i<=0||i>=n)continue;\n        int tmp = n-2*i;\n        if(a[i]==n-i&&b[i]==n-i&&tmp>0&&(n-3*(tmp))/2>0){\n            ma = max(ma,tmp);\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     cout << a[i] << \" \";\n    // }\n    // cout << endl;\n    // for(int i=0;i<n;i++){\n    //     cout << b[i] << \" \";\n    // }\n    // cout << endl;\n    \n    if(ma==-1){\n        cout << \"mitomerarenaiWA\" << endl;\n    }else{\n        int x = ma;\n        int y = (n-3*ma)/2;\n        printf(\"Love \");\n        for(int i=0;i<x+y;i++){\n            printf(\"%c\",s[n-i-1]);\n        }\n        printf(\"!\\n\");\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n//const ull B1 = 100000007;\nconst ull B = 11451419191;\n\null Hash_table[3000010];\null po[3000010];\n\n\nint main(){\n    \n    string s; cin >> s;\n    int n = (int)s.size();\n    \n    Hash_table[0] = 0;\n    po[0] = 1;\n\n    for(int i = 1; i <= n; i++){\n        po[i] = po[i - 1] * B;\n        Hash_table[i] = Hash_table[i - 1] * B + (ull)(s[i - 1] - 'a' + 1);\n    }\n\n    \n    ull len = B;\n    ull len_i, len_j;\n\n    for(ull i = 1; i <= (ull)((n - 2) / 3); i++){\n        //cout << i << endl;\n        if((n - 3 * i) % 2 == 1) continue;\n        ull j = ((n - 3 * i) / 2);\n        if(3*i + 2*j != (ull)n) continue;\n\n        //cout << i << \" \" << j << endl;\n        ull H1 = Hash_table[i] - Hash_table[0] * po[i];\n        ull H2 = Hash_table[i + j] - Hash_table[i] * po[j];\n        ull H3 = Hash_table[2 * i + j] - Hash_table[i + j] * po[i];\n        ull H4 = Hash_table[2 * i + 2 * j] - Hash_table[2 * i + j] * po[j];\n        ull H5 = Hash_table[n] - Hash_table[2 * i + 2 * j] * po[n - (2 * i + 2 * j)];\n\n        \n        if(H1 == H3 && H3 == H5 && H2 == H4){\n            //string A = s.substr(0, i);\n            //string B = s.substr(i, j);\n            //cout << \"Love \" << A + B << \"!\" << endl;\n            //return 0;\n            \n            if(len > i + j){\n                len_i = i;\n                len_j = j;\n                len = i + j;\n            }\n        }\n    }\n\n    \n\n    if(len == B) cout << \"mitomerarenaiWA\" << endl;\n    else{\n        string A = s.substr(0, (int)len_i);\n        string B = s.substr((int)len_i, (int)(len_j));\n        //cout << A << \" \" << B << endl;\n        cout << \"Love \" << A + B << \"!\" << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nclass RollingHash\n{\nprivate:\n    static const int X[], Y[], M[];\n    deque<char> dq;\n    long long xp[3];\n    long long hash[3];\npublic:\n    RollingHash(){\n        for(int i=0; i<3; ++i){\n            xp[i] = 1;\n            hash[i] = 0;\n        }\n    }\n    void push_back(char c){\n        dq.push_back(c);\n        for(int i=0; i<3; ++i){\n            hash[i] *= X[i];\n            hash[i] += c;\n            hash[i] %= M[i];\n            xp[i] *= X[i];\n            xp[i] %= M[i];\n        }\n    }\n    void pop_back(){\n        for(int i=0; i<3; ++i){\n            hash[i] += M[i] - dq.back();\n            hash[i] *= Y[i];\n            hash[i] %= M[i];\n            xp[i] *= Y[i];\n            xp[i] %= M[i];\n        }\n        dq.pop_back();\n    }\n    void push_front(char c){\n        dq.push_front(c);\n        for(int i=0; i<3; ++i){\n            hash[i] += c * xp[i];\n            hash[i] %= M[i];\n            xp[i] *= X[i];\n            xp[i] %= M[i];\n        }\n    }\n    void pop_front(){\n        for(int i=0; i<3; ++i){\n            xp[i] *= Y[i];\n            xp[i] %= M[i];\n            hash[i] -= dq.front() * xp[i];\n            hash[i] %= M[i];\n            if(hash[i] < 0)\n                hash[i] += M[i];\n        }\n        dq.pop_front();\n    }\n    bool operator==(const RollingHash& rh){\n        for(int i=0; i<3; ++i){\n            if(hash[i] != rh.hash[i])\n                return false;\n        }\n        return true;\n    }\n    bool operator!=(const RollingHash& rh){\n        return !(*this == rh);\n    }\n};\nconst int RollingHash::X[] = {2000000011, 2000000033, 2000000063}; // 素数\nconst int RollingHash::Y[] = {1447368484, 1178571481, 1277777841}; // X * Y == 1 (mod M)\nconst int RollingHash::M[] = {2000000087, 2000000089, 2000000099}; // 合同式の法（素数）\n\nstring solve(const string& s)\n{\n    int n = s.size();\n    if(n < 5)\n        return \"\";\n\n    vector<int> v(6);\n    v[0] = 0;\n    v[2] = (n + 3) / 3;\n    v[4] = v[2] * 2;\n    v[1] = n - v[4];\n    v[3] = v[2] + v[1];\n    v[5] = n;\n    if(v[1] == 0)\n        return \"\";\n\n    vector<RollingHash> rh(5);\n    for(int i=0; i<5; ++i){\n        for(int j=v[i]; j<v[i+1]; ++j){\n            rh[i].push_back(s[j]);\n        }\n    }\n\n    vector<int> d = {0, -2, 1, -1, 2, 0};\n    for(;;){\n        bool ok = true;\n        for(int i=0; i<3; ++i){\n            if(rh[i] != rh[i+2])\n                ok = false;\n        }\n        if(ok)\n            return s.substr(0, v[2]);\n        if(v[1] < 2)\n            return \"\";\n\n        for(int i=1; i<5; ++i){\n            if(d[i] > 0){\n                for(int j=0; j<d[i]; ++j){\n                    rh[i-1].push_back(s[v[i]]);\n                    rh[i].pop_front();\n                    ++ v[i];\n                }\n            }\n            else{\n                for(int j=0; j<-d[i]; ++j){\n                    rh[i-1].pop_back();\n                    rh[i].push_front(s[v[i]-1]);\n                    -- v[i];\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    string s;\n    cin >> s;\n\n    string ans = solve(s);\n    if(ans == \"\")\n        cout << \"mitomerarenaiWA\" << endl;\n    else\n        cout << \"Love \" << ans << '!' << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\nint INF = INT_MAX / 2;\ndouble EPS = 1e-10;\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n\tif (b == 0) {\n\t\tx = (a >= 0) ? 1 : -1;\n\t\ty = 0;\n\t\treturn abs(a);\n\t}\n\telse {\n\t\tll res = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t\treturn res;\n\t}\n}\n\nll mod_inverse(ll a, ll m) {\n\tll x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\n\nll f(vector<ll>& a, vector<ll>& unko, int l, int r) {\n\treturn ((a[r] - a[l]) * unko[l] % MOD + MOD) % MOD;\n}\n\nint main() {\n\tstring s; cin >> s;\n\tint n = s.length();\n\tvector<ll> a(n + 1), unko(n + 1);\n\tll z = 1; unko[0] = 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tchar c = s[i];\n\t\tint x;\n\t\tif (c >= 'A' && c <= 'Z') x = 1 + c - 'A';\n\t\tif (c >= 'a' && c <= 'z') x = 27 + c - 'a';\n\t\ta[i + 1] = (a[i] + z * x) % MOD;\n\t\tz = z * 83 % MOD;\n\t\tunko[i + 1] = mod_inverse(z, MOD);\n\t}\n\tint len, ans = -1;\n\tfor (len = 2; len * 2 + 1 <= n; len++) {\n\t\tint _len = n - len * 2;\n\t\tif (1 <= _len && _len <= len - 1);\n\t\telse continue;\n\t\tif (f(a, unko, 0, len) == f(a, unko, len, len * 2) && f(a, unko, 0, _len) == f(a, unko, len * 2, n)) {\n\t\t\tans = len;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ans == -1) cout << \"mitomerarenaiWA\" << endl;\n\telse cout << \"Love \" << s.substr(0, ans) << '!' << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nconst int INF = (int)1e18;\nstruct RMQ {\n\tvector<int> data;\n\tint N;\n\tRMQ(int size) {\n\t\tN = 1;\n\t\twhile(N < size) N *= 2;\n\t\tdata.assign(2*N - 1, INF);\n\t}\n\tvoid update(int k, int a) {\n\t\tk += N - 1;\n\t\tdata[k] = a;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1)/2;\n\t\t\tdata[k] = min(data[2*k + 1], data[2*k + 2]);\n\t\t}\n\t}\n\tint minimum(int a, int b) {\n\t\treturn minimum_sub(a, b, 0, 0, N);\n\t}\n\tint minimum_sub(int a, int b, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <= b) return data[k];\n\n\t\treturn min(minimum_sub(a, b, 2*k + 1, l, (l + r)/2),\n\t\t\t\tminimum_sub(a, b, 2*k + 2, (l + r)/2, r));\n\t}\n};\n\nstruct SuffixArray {\n  int n, k;\n  vector<int> sa, rsa, lcp, rank, tmp;\n  SuffixArray(const string &S) : n(S.size()), sa(S.size() + 1), rsa(S.size() + 1), lcp(S.size() + 1), rank(S.size() + 1), tmp(S.size() + 1) {\n    {\n      auto compare_sa = [&](int i, int j) -> bool {\n          if(rank[i] != rank[j]) return rank[i] < rank[j];\n          else {\n            int ri = i + k <= n ? rank[i + k] : -1;\n            int rj = j + k <= n ? rank[j + k] : -1;\n            return ri < rj;\n          }\n      };\n      for(int i = 0; i <= n; ++i) {\n        sa[i] = i;\n        rank[i] = i < n ? S[i] : -1;\n      }\n      for(k = 1; k <= n; k *= 2) {\n        sort(sa.begin(), sa.begin() + n + 1, compare_sa);\n        tmp[sa[0]] = 0;\n        for(int i = 1; i <= n; i++) {\n          tmp[sa[i]] = tmp[sa[i - 1]] + (compare_sa(sa[i - 1], sa[i]) ? 1 : 0);\n        }\n        for(int i = 0; i <= n; i++) {\n          rank[i] = tmp[i];\n        }\n      }\n    }\n    {\n      for(int i = 0; i <= n; i++) rank[sa[i]] = i;\n      int h = 0;\n      lcp[0] = 0;\n      for(int i = 0; i < n; i++) {\n        int j = sa[rank[i] - 1];\n        if(h > 0) h--;\n        for(; j + h < n && i + h < n; h++) {\n          if(S[j + h] != S[i + h]) break;\n        }\n        lcp[rank[i] - 1] = h;\n      }\n    }\n    {\n      for(int i = 0; i <= n; ++i) {\n        rsa[sa[i]] = i;\n      }\n    }\n  }\n};\n\nchar CS[1000001];\n\nsigned main() {\n  scanf(\"%s\", CS);\n  string S(CS);\n  int N = S.size();\n  SuffixArray SA(S);\n  RMQ rmq(N + 1);\n  REP(i,N+1) {\n    rmq.update(i,SA.lcp[i]);\n  }\n  int ansA = INF, ansB = INF;\n  REP(i,N/2) {\n    int LA = i + 1;\n    int LB = (N - 3 * LA) / 2;\n    if(LB < 1) break;\n    int l, r;\n\n    l = SA.rsa[0], r = SA.rsa[N - i - 1];\n    if(l > r) swap(l, r);\n    int lcpA = rmq.minimum(l, r);\n\n    l = SA.rsa[LA], r = SA.rsa[LA + LB + LA];\n    if(l > r) swap(l, r);\n    int lcpB = rmq.minimum(l, r);\n    // DEBUG(LA);\n    // DEBUG(lcpA);\n    // DEBUG(LB);\n    // DEBUG(lcpB);\n    if(lcpA >= LA && lcpB >= LB) {\n      if(LA + LB < ansA + ansB) {\n        ansA = LA;\n        ansB = LB;\n      }\n    }\n  }\n  if(ansA == INF && ansB == INF) {\n    cout << \"mitomerarenaiWA\" << endl;\n  }\n  else {\n    cout << \"Love \" << S.substr(0, ansA) << S.substr(ansA, ansB) << \"!\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nclass RollingHash\n{\nprivate:\n    static const int X[], Y[], M[];\n    deque<char> dq;\n    long long xp[3];\n    long long hash[3];\npublic:\n    RollingHash(){\n        for(int i=0; i<3; ++i){\n            xp[i] = 1;\n            hash[i] = 0;\n        }\n    }\n    void push_back(char c){\n        dq.push_back(c);\n        for(int i=0; i<3; ++i){\n            hash[i] *= X[i];\n            hash[i] += c;\n            hash[i] %= M[i];\n            xp[i] *= X[i];\n            xp[i] %= M[i];\n        }\n    }\n    void pop_back(){\n        for(int i=0; i<3; ++i){\n            hash[i] += M[i] - dq.back();\n            hash[i] *= Y[i];\n            hash[i] %= M[i];\n            xp[i] *= Y[i];\n            xp[i] %= M[i];\n        }\n        dq.pop_back();\n    }\n    void push_front(char c){\n        dq.push_front(c);\n        for(int i=0; i<3; ++i){\n            hash[i] += c * xp[i];\n            hash[i] %= M[i];\n            xp[i] *= X[i];\n            xp[i] %= M[i];\n        }\n    }\n    void pop_front(){\n        for(int i=0; i<3; ++i){\n            xp[i] *= Y[i];\n            xp[i] %= M[i];\n            hash[i] -= dq.front() * xp[i];\n            hash[i] %= M[i];\n            if(hash[i] < 0)\n                hash[i] += M[i];\n        }\n        dq.pop_front();\n    }\n    bool operator==(const RollingHash& rh){\n        for(int i=0; i<3; ++i){\n            if(hash[i] != rh.hash[i])\n                return false;\n        }\n        return true;\n    }\n    bool operator!=(const RollingHash& rh){\n        return !(*this == rh);\n    }\n};\nconst int RollingHash::X[] = {1685440109, 1389328937, 1813126193}; // 素数\nconst int RollingHash::Y[] = {1835226359, 1406652555,  643336582}; // X * Y == 1 (mod M)\nconst int RollingHash::M[] = {2000000087, 2000000089, 2000000099}; // 合同式の法（素数）\n\nstring solve(const string& s)\n{\n    int n = s.size();\n    if(n < 5 || n == 6)\n        return \"\";\n\n    vector<int> v(6);\n    v[0] = 0;\n    v[2] = (n + 3) / 3;\n    v[4] = v[2] * 2;\n    v[1] = n - v[4];\n    v[3] = v[2] + v[1];\n    v[5] = n;\n\n    vector<RollingHash> rh(5);\n    for(int i=0; i<5; ++i){\n        for(int j=v[i]; j<v[i+1]; ++j){\n            rh[i].push_back(s[j]);\n        }\n    }\n\n    vector<int> d = {0, -2, 1, -1, 2, 0};\n    for(;;){\n        bool ok = true;\n        for(int i=0; i<3; ++i){\n            if(rh[i] != rh[i+2])\n                ok = false;\n        }\n        if(ok)\n            return s.substr(0, v[2]);\n        if(v[1] < 2)\n            return \"\";\n\n        for(int i=1; i<5; ++i){\n            if(d[i] > 0){\n                for(int j=0; j<d[i]; ++j){\n                    rh[i-1].push_back(s[v[i]]);\n                    rh[i].pop_front();\n                    ++ v[i];\n                }\n            }\n            else{\n                for(int j=0; j<-d[i]; ++j){\n                    rh[i-1].pop_back();\n                    rh[i].push_front(s[v[i]-1]);\n                    -- v[i];\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    string s;\n    cin >> s;\n\n    string ans = solve(s);\n    if(ans == \"\")\n        cout << \"mitomerarenaiWA\" << endl;\n    else\n        cout << \"Love \" << ans << '!' << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nclass RollingHash\n{\nprivate:\n    static const int X[], Y[], M[];\n    deque<char> dq;\n    long long xp[3];\n    long long hash[3];\npublic:\n    RollingHash(){\n        for(int i=0; i<3; ++i){\n            xp[i] = 1;\n            hash[i] = 0;\n        }\n    }\n    void push_back(char c){\n        dq.push_back(c);\n        for(int i=0; i<3; ++i){\n            hash[i] *= X[i];\n            hash[i] += c;\n            hash[i] %= M[i];\n            xp[i] *= X[i];\n            xp[i] %= M[i];\n        }\n    }\n    void pop_back(){\n        for(int i=0; i<3; ++i){\n            hash[i] += M[i] - dq.back();\n            hash[i] *= Y[i];\n            hash[i] %= M[i];\n            xp[i] *= Y[i];\n            xp[i] %= M[i];\n        }\n        dq.pop_back();\n    }\n    void push_front(char c){\n        dq.push_front(c);\n        for(int i=0; i<3; ++i){\n            hash[i] += c * xp[i];\n            hash[i] %= M[i];\n            xp[i] *= X[i];\n            xp[i] %= M[i];\n        }\n    }\n    void pop_front(){\n        for(int i=0; i<3; ++i){\n            xp[i] *= Y[i];\n            xp[i] %= M[i];\n            hash[i] -= dq.front() * xp[i];\n            hash[i] %= M[i];\n            if(hash[i] < 0)\n                hash[i] += M[i];\n        }\n        dq.pop_front();\n    }\n    bool operator==(const RollingHash& rh){\n        for(int i=0; i<3; ++i){\n            if(hash[i] != rh.hash[i])\n                return false;\n        }\n        return true;\n    }\n    bool operator!=(const RollingHash& rh){\n        return !(*this == rh);\n    }\n};\nconst int RollingHash::X[] = {2000000011, 2000000033, 2000000063}; // 素数\nconst int RollingHash::Y[] = {1447368484, 1178571481, 1277777841}; // X * Y == 1 (mod M)\nconst int RollingHash::M[] = {2000000087, 2000000089, 2000000099}; // 合同式の法（素数）\n\nint main()\n{\n    string s;\n    cin >> s;\n    int n = s.size();\n\n    vector<int> v(6);\n    v[0] = 0;\n    v[2] = (n + 3) / 3;\n    v[4] = v[2] * 2;\n    v[1] = n - v[4];\n    v[3] = v[2] + v[1];\n    v[5] = n;\n    vector<int> d = {0, -2, 1, -1, 2, 0};\n\n    vector<RollingHash> rh(5);\n    for(int i=0; i<5; ++i){\n        for(int j=v[i]; j<v[i+1]; ++j){\n            rh[i].push_back(s[j]);\n        }\n    }\n\n    while(v[4] < n){\n        bool ok = true;\n        for(int i=0; i<3; ++i){\n            if(rh[i] != rh[i+2])\n                ok = false;\n        }\n        if(ok){\n            cout << \"Love \" << s.substr(0, v[2]) << '!' << endl;\n            return 0;\n        }\n\n        for(int i=1; i<5; ++i){\n            if(d[i] > 0){\n                for(int j=0; j<d[i]; ++j){\n                    rh[i-1].push_back(s[v[i]]);\n                    rh[i].pop_front();\n                    ++ v[i];\n                }\n            }\n            else{\n                for(int j=0; j<-d[i]; ++j){\n                    rh[i-1].pop_back();\n                    rh[i].push_front(s[v[i]-1]);\n                    -- v[i];\n                }\n            }\n        }\n    }\n\n    cout << \"mitomerarenaiWA\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\n//const ull B1 = 100000007;\nconst ull B = 11451419191;\n\null Hash_table[3000010];\null po[3000010];\n\n\nint main(){\n    \n    string s; cin >> s;\n    int n = (int)s.size();\n    \n    Hash_table[0] = 0;\n    po[0] = 1;\n\n    for(int i = 1; i <= n; i++){\n        po[i] = po[i - 1] * B;\n        Hash_table[i] = Hash_table[i - 1] * B + (ull)(s[i - 1] - 'a' + 1);\n    }\n\n    \n\n    for(int i = (n - 2) / 3; i >= 0; i--){\n        if((n - 3 * i) % 2 == 1) continue;\n\n        int j = ((n - 3 * i) / 2);\n        //cout << i << \" \" << j << endl;\n        ull H1 = Hash_table[i] - Hash_table[0] * po[i];\n        ull H2 = Hash_table[i + j] - Hash_table[i] * po[j];\n        ull H3 = Hash_table[2 * i + j] - Hash_table[i + j] * po[i];\n        ull H4 = Hash_table[2 * i + 2 * j] - Hash_table[2 * i + j] * po[j];\n        ull H5 = Hash_table[n] - Hash_table[2 * i + 2 * j] * po[n - (2 * i + 2 * j)];\n\n        \n        if(H1 == H3 && H3 == H5 && H2 == H4){\n            string A = s.substr(0, i);\n            string B = s.substr(i, j);\n            cout << \"Love \" << A + B << \"!\" << endl;\n            return 0;\n        }\n    }\n\n    cout << \"mitomerarenaiWA\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1000001\nusing ull = unsigned long long;\n\nconst ull b = 1000000007ULL;\n\nvector<ull> rolling_hash(char* S, int N, vector<ull>& p)\n{\n    vector<ull> h(N + 1);\n    for (int i = 0; i < N; i++) {\n        h[i + 1] = h[i] * b + S[i];\n        p[i + 1] = p[i] * b;\n    }\n    return h;\n}\n\nint main()\n{\n    char S[MAX];\n    scanf(\"%s\", S);\n    \n    int N = strlen(S);\n    vector<ull> p(N + 1);\n    p[0] = 1;\n    \n    bool found = 0;\n    auto h = rolling_hash(S, N, p);    \n    \n    vector<int> v;\n    for (int i = 0; i < N; i++) {\n        int A = i + 1;\n        int B = (N - 3 * A) / 2;\n\n        if (B <= 0) continue;\n        if ((N - 3 * A) % 2 != 0) continue;\n\n        auto A1 = h[A] - h[0] * p[A];\n        auto B1 = h[A + B] - h[A] * p[B];\n        auto A2 = h[A * 2 + B] - h[A + B] * p[A];\n        auto B2 = h[2 * (A + B)] - h[A * 2 + B] * p[B];\n        auto A3 = h[N] - h[2 * (A + B)] * p[A];\n\n        if (A1 == A2 && A2 == A3 && B1 == B2) {\n            found = 1;\n            v.emplace_back(A + B);\n        }\n    }\n    \n    if (!found) {\n        printf(\"mitomerarenaiWA\\n\");\n    } else {\n        printf(\"Love \");\n        int size = *min_element(v.begin(), v.end());\n        for (int i = 0; i < size; i++) {\n            printf(\"%c\", S[i]);\n        }\n        printf(\"!\\n\");\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nvoid z_algorithm(string& S,vector<int>& res)\n{\n    int sz = (int)S.size();\n    res.resize(sz);\n    int c = 0;\n    for(int i = 1; i < sz; i++){\n        if(i+res[i-c] < c+res[c]){\n            res[i] = res[i-c];\n        }else{\n            int j = max(0, c+res[c]-i);\n            while (i+j < sz && S[j] == S[i+j]) ++j;\n            res[i] = j;\n        }\n    }\n    res[0] = sz;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<int> a,b;\n    z_algorithm(s,a);\n    reverse(s.begin(),s.end());\n    z_algorithm(s,b);\n    int ma = -1;\n    for(int i=n/3-2;i<n/2+2;i++){\n        if(i<=0||i>=n)continue;\n        int tmp = n-2*i;\n        if(a[i]==n-i&&b[i]==n-i&&tmp>0&&(n-3*(tmp))/2>0){\n            ma = max(ma,tmp);\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     cout << a[i] << \" \";\n    // }\n    // cout << endl;\n    // for(int i=0;i<n;i++){\n    //     cout << b[i] << \" \";\n    // }\n    // cout << endl;\n    \n    if(ma==-1){\n        cout << \"mitomerarenaiWA\" << endl;\n    }else{\n        int x = ma;\n        int y = (n-3*ma)/2;\n        if(x+y>450000){\n            cout << \"a\" << endl;\n            return 0;\n        }\n        printf(\"Love \");\n        for(int i=0;i<x+y;i++){\n            printf(\"%c\",s[n-i-1]);\n        }\n        printf(\"!\\n\");\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing lint = long long int;\nlong long int INF = 1001001001001001LL;\nint inf = 1000000007;\nlong long int MOD = 1000000007LL;\ndouble PI = 3.1415926535897932;\n\ntemplate<typename T1,typename T2>inline void chmin(T1 &a,const T2 &b){if(a>b) a=b;}\ntemplate<typename T1,typename T2>inline void chmax(T1 &a,const T2 &b){if(a<b) a=b;}\n\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n\ntemplate< unsigned mod >\nstruct RollingHash {\n  vector< unsigned > hashed, power;\n\n  inline unsigned mul(unsigned a, unsigned b) const {\n    unsigned long long x = (unsigned long long) a * b;\n    unsigned xh = (unsigned) (x >> 32), xl = (unsigned) x, d, m;\n    asm(\"divl %4; \\n\\t\" : \"=a\" (d), \"=d\" (m) : \"d\" (xh), \"a\" (xl), \"r\" (mod));\n    return m;\n  }\n\n  RollingHash(const string &s, unsigned base = 10007) {\n    int sz = (int) s.size();\n    hashed.assign(sz + 1, 0);\n    power.assign(sz + 1, 0);\n    power[0] = 1;\n    for(int i = 0; i < sz; i++) {\n      power[i + 1] = mul(power[i], base);\n      hashed[i + 1] = mul(hashed[i], base) + s[i];\n      if(hashed[i + 1] >= mod) hashed[i + 1] -= mod;\n    }\n  }\n\n  unsigned get(int l, int r) const {\n    unsigned ret = hashed[r] + mod - mul(hashed[l], power[r - l]);\n    if(ret >= mod) ret -= mod;\n    return ret;\n  }\n\n  unsigned connect(unsigned h1, int h2, int h2len) const {\n    unsigned ret = mul(h1, power[h2len]) + h2;\n    if(ret >= mod) ret -= mod;\n    return ret;\n  }\n\n  int LCP(const RollingHash< mod > &b, int l1, int r1, int l2, int r2) {\n    int len = min(r1 - l1, r2 - l2);\n    int low = -1, high = len + 1;\n    while(high - low > 1) {\n      int mid = (low + high) / 2;\n      if(get(l1, l1 + mid) == b.get(l2, l2 + mid)) low = mid;\n      else high = mid;\n    }\n    return (low);\n  }\n};\n\nusing RH = RollingHash< 1000000007 >;\n\n\nint main() {\n  \n  string s; cin >> s;\n  int n = s.size();\n  string ans = \"\";\n  int val = inf;\n\n\n  RH rh(s);\n  for (int A = 1; A <= n; A++) {\n    int rest = n - 3 * A;\n    if (rest <= 0) continue;\n    if (rest % 2 != 0) continue;\n    int B = rest / 2;\n\n    if (rh.get(0, A) == rh.get(A + B, A + B + A) \n        and rh.get(0, A) == rh.get(2 * A + 2 * B, 2 * A + 2 * B + A) \n        and rh.get(A, A + B) == rh.get(2 * A + B, 2 * A + B + B)) {\n\n      string a = s.substr(0, A);\n      string b = s.substr(A, B);\n      if (A + B < val) {\n        ans = \"Love \" + a + b + \"!\";\n        val = A + B;\n      }\n    }\n  }\n\n\n  if (ans == \"\") {\n    cout << \"mitomerarenaiWA\" << endl;\n  } else {\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include<string>\nusing namespace std;\n\nint n,m;\nvector<int> c;\nint dp[50001][20];\nvoid sortt(){\n\tsort(c.begin(),c.end());\n\tfor(int i=1;i<1000000;++i){\n\n\t\treverse(c.begin(),c.end());\n\t}\n}\n\nvoid ume(){\n\n\tfor(int i=0;i<20;++i){\n\t\tdp[0][i]=0;\n\t\tfor(int j=1;j<50001;++j){\n\t\t\tdp[j][i]=100000;\n\t\t}\n\t}\n}\nvoid toku(){\n\tfor(int i=1;i<n+1;++i){//??????\n\t\tfor(int j=0;j<m;++j){//?????¨???????????????\n\t\t\tif(i-c[j]>=0){\n\t\t\t\tdp[i][j]=dp[i-c[j]][j]+1;\n\t\t\t}\n\t\t\tif(j!=0){\n\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i][j-1]);\n\t\t\t}\n\n\t\t}\n\t}\n}\n\n\nint main(){\n\t\n\t////cin>>n>>m;\n\t//m=20;\n\t//n=30000;\n\t//\n\t//for(int i=0;i<m;++i){\n\t//\t/*int a;\n\t//\tcin>>a;*/\n\t//\tint aaa[]={1,2,5,11,24,33,1010,9102,3421,432,789,446,400,9432,2873,504,88,21,5843,3333};\n\t//\tvector<int> aa(aaa,aaa+20);\n\t//\tc=aa;\n\n\n\t//}\n\t//sortt();\n\t//ume();\n\t//toku();\n\n\t//\n\n\t//cout<<dp[n][m-1]<<endl;\n\n\n\n\n\tstring s;\n\tcin>>s;\n\tint s_s=s.size();\n\tfor(int i=s_s-1;i>=1;--i){\n\t\tstring A=s.substr(0,i);\n\t\tint a_s=A.size();\n\n\t\tif((s.size()-3*i)%2){\n\t\t\tcontinue;\n\t\t}else{\n\t\t\t\n\t\t\tstring B=s.substr(i,(s.size()-3*i)/2);\n\t\t\tint b_s=B.size();\n\t\t\tif(A==s.substr(a_s+b_s,a_s)&&B==s.substr(a_s*2+b_s,b_s)&&A==s.substr(a_s*2+b_s*2,a_s)){\n\t\t\t\tcout<<\"Love \"<<A<<B<<\"!\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}else{\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"mitomerarenaiWA\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// Rolling Hash\n// Verified: AOJ 2444 (Substring)\n\nstruct RollingHash {\npublic:\n    long long base_1, base_2, mod_1, mod_2;\n    vector<long long> hash1, hash2, pow1, pow2;\n\n    // init (constructor)\n    RollingHash(string s) : base_1(1013), base_2(1007),\n        mod_1(1000000007), mod_2(1000000009),\n        hash1(s.length()+1,0), hash2(s.length()+1,0),\n        pow1(s.length()+1,1), pow2(s.length()+1,1) {\n            for(int i=0; i<s.length(); i++) {\n                hash1[i+1] = (hash1[i]+s[i]) * base_1 % mod_1;\n                hash2[i+1] = (hash2[i]+s[i]) * base_2 % mod_2;\n                pow1[i+1] = pow1[i] * base_1 % mod_1;\n                pow2[i+1] = pow2[i] * base_2 % mod_2;\n            }\n        }\n\n    // calc str[l,r) hash (0-indexed)\n    // if get(i1,j1) == get(i2,j2) -> identical string\n    pair<long long, long long> get(int l, int r) {\n        long long t1 = ((hash1[r] - hash1[l] * pow1[r-l]) % mod_1 + mod_1) % mod_1;\n        long long t2 = ((hash2[r] - hash2[l] * pow2[r-l]) % mod_2 + mod_2) % mod_2;\n        return make_pair(t1, t2);\n    }\n};\n\nsigned main() {\n    string s; cin >> s;\n    RollingHash RH(s);\n    int mi = INF;\n    repq(i,1,s.length() / 3) {\n        if(s.length() - i*3 < 2 || (s.length() - i*3) % 2) continue;\n        int j = (s.length() - i*3) / 2;\n        // printf(\"valid: i = %lld, j = %lld\\n\", i, j);\n        pii a = RH.get(0,i);\n        pii b = RH.get(i,i+j);\n        pii c = RH.get(i+j, 2*i+j);\n        pii d = RH.get(2*i+j, 2*i+2*j);\n        pii e = RH.get(2*i+2*j, 3*i+2*j);\n\n        if(a == c && c == e && e == a && b == d) {\n            // cout << i+j << endl;\n            mi = min(mi, i+j);\n        }\n    }\n    if(mi == INF) cout << \"mitomerarenaiWA\" << endl;\n    else cout << \"Love \" << s.substr(0,mi) << \"!\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int sz = 1000010;\n\nchar s[sz];\nint mp[sz];\n\nint main(){\n\tfgets(s, sz, stdin);\n\tint n = strlen(s) - 1;\n\t\n\tmp[0] = -1;\n\tint t = -1;\n\tfor(int i = 0; i < n; ++i){\n\t\twhile(t >= 0 && s[t] != s[i]){\n\t\t\tt = mp[t];\n\t\t}\n\t\tmp[i + 1] = ++t;\n\t}\n\t\n\tint p = n - mp[n];\n\tif(p > 0){\n\t\tp *= n / (3 * p) + 1;\n\t\tif(p * 2 < n){\n\t\t\tprintf(\"Love %.*s!\\n\", p, s);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"mitomerarenaiWA\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\ntemplate<ll MOD>\nstruct rolloing_hash {\n    int n;\n    ll b;\n    vector<ll> pow, hash;\n\n    rolloing_hash() {}\n\n    rolloing_hash(const string &s, ll b_ = 10007) {\n        set(s, b_);\n    }\n\n    void set(const string &s, ll b_ = 10007) {\n        n = s.size();\n        b = b_;\n        calc_pow();\n        calc_hash(s.c_str());\n    }\n\n    void calc_pow() {\n        pow.resize(n + 1); pow[0] = 1;\n        for (int i = 0; i < n; ++i) {\n            pow[i + 1] = pow[i] * b % MOD;\n        }\n    }\n\n    void calc_hash(const char *s) {\n        hash.resize(n + 1);\n        hash[0] = 0;\n        for (int i = 0; i < n; ++i) {\n            hash[i + 1] = (s[i] + hash[i] * b) % MOD;\n        }\n    }\n\n    ll get(int i) const {\n        return hash[i];\n    }\n\n    ll get(int i, int j) const {\n        return (get(j) - get(i) * pow[j - i] % MOD + MOD) % MOD;\n    }\n};\n\n// 1000000007, 1000000009, 1000000021, ...\nusing RH = rolloing_hash<1000000007>;\n\nint main() {\n    string s;\n\n    while (cin >> s) {\n        int n = s.size();\n        int a = n % 2 == 0 ? 2 : 1;\n        int b = n % 2 == 0 ? n / 2 - 1 : n / 2;\n        int c = b + a;\n        int d = n - a;\n        RH rh(s);\n        int ans = n;\n        while (a < b) {\n            int A = rh.get(0, a);\n            if (rh.get(b, c) == A && rh.get(d, n) == A && rh.get(a, b) == rh.get(c, d)) {\n                ans = min(ans, b);\n            }\n            a += 2;\n            b -= 1;\n            c += 1;\n            d -= 2;\n        }\n        if (ans != n) {\n            cout << \"Love \" << s.substr(0, ans) << '!';\n        } else {\n            cout << \"mitomerarenaiWA\";\n        }\n        cout << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_RollingHash\n#define ___Class_RollingHash\n\n#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\ntemplate <long long mod, long long base = 257>\nclass RollingHash {\nprivate:\n\tstd::string str;\n\tstd::vector<long long> sum;\npublic:\n\tRollingHash() : str(\"\"), sum(std::vector<long long>(1, 0)) {};\n\tRollingHash(const std::string &s) : str(s) {\n\t\tsum.resize(str.size() + 1);\n\t\tfor (int i = 0; i < str.size(); i++) sum[i + 1] = (1LL * sum[i] * base + s[i]) % mod;\n\t}\n\tstatic inline long long modpow(long long a, long long b) {\n\t\tlong long ret = 1; a %= mod;\n\t\twhile (b) {\n\t\t\tif (b & 1) ret = 1LL * ret * a % mod;\n\t\t\ta = 1LL * a * a % mod;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tstd::string get() { return str; }\n\tlong long gethash(int l, int r) {\n\t\treturn (sum[r] - sum[l] * modpow(base, r - l) % mod + mod) % mod;\n\t}\n};\n\n#endif\n\nconst int MOD = 2016112121;\nstring T;\n\nint main() {\n\tcin >> T; RollingHash<MOD> S(T); bool flag = false;\n\tfor (int i = 1; i <= T.size() / 3; i++) {\n\t\tint G = (T.size() - i * 3); if (G % 2 == 1 || G <= 0)continue;\n\t\tG /= 2;\n\t\tlong long p1 = S.gethash(0, i);\n\t\tlong long p2 = S.gethash(i, i + G);\n\t\tlong long p3 = S.gethash(i + G, i * 2 + G);\n\t\tlong long p4 = S.gethash(i * 2 + G, i * 2 + G * 2);\n\t\tlong long p5 = S.gethash(i * 2 + G * 2, i * 3 + G * 2);\n\t\tif (p1 == p3 && p3 == p5) {\n\t\t\tif (p2 == p4) {\n\t\t\t\tcout << \"Love \" << T.substr(0, i + G) << \"!\" << endl; flag = true;\n\t\t\t}\n\t\t}\n\t}\n\tif (flag == false)cout << \"mitomerarenaiWA\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP;\n  vector< int > rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size() - 1);\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i]] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    if(k < 0) return (0);\n    return (LCP[k]);\n  }\n\n  int size() const\n  {\n    return (LCP.size() + 1);\n  }\n};\n\nstruct StaticSegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  StaticSegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    };\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(min(a, b), max(a, b), 0, 0, sz));\n  }\n};\n\n\nint main()\n{\n  string S;\n  cin >> S;\n  SuffixArray sa;\n  sa.Build_SA(S);\n  LongestCommonPrefixArray lcp;\n  lcp.Build_LCP(sa);\n  StaticSegmentTree tree(lcp.size() - 1);\n  for(int i = 0; i < lcp.size() - 1; i++) {\n    tree.set(i, lcp[i]);\n  }\n  tree.build();\n\n  int ret = INF;\n  for(int A = 1; A < S.size(); A++) {\n    int B = (int) S.size() - A * 3;\n    if(B <= 0) break;\n    if(B & 1) continue;\n    B /= 2;\n    if(tree.rmq(lcp.rank[0], lcp.rank[A + B]) >= A &&\n       tree.rmq(lcp.rank[0], lcp.rank[A + B + A + B]) >= A &&\n       tree.rmq(lcp.rank[A], lcp.rank[A + B + A]) >= B) {\n      ret = min(ret, A + B);\n    }\n  }\n\n  if(ret >= INF) {\n    cout << \"mitomerarenaiWA\" << endl;\n  } else {\n    cout << \"Love \" << S.substr(0, ret) << \"!\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nvoid z_algorithm(string& S,vector<int>& res)\n{\n    int sz = (int)S.size();\n    res.resize(sz);\n    int c = 0;\n    for(int i = 1; i < sz; i++){\n        if(i+res[i-c] < c+res[c]){\n            res[i] = res[i-c];\n        }else{\n            int j = max(0, c+res[c]-i);\n            while (i+j < sz && S[j] == S[i+j]) ++j;\n            res[i] = j;\n        }\n    }\n    res[0] = sz;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = s.size();\n    if(n>500000) cout << \"MURI\" << endl;return 0;\n    vector<int> a,b;\n    z_algorithm(s,a);\n    reverse(s.begin(),s.end());\n    z_algorithm(s,b);\n    int ma = -1;\n    for(int i=n/3-2;i<n/2+2;i++){\n        if(i<=0||i>=n)continue;\n        int tmp = n-2*i;\n        if(a[i]==n-i&&b[i]==n-i&&tmp>0&&(n-3*(tmp))/2>0){\n            ma = max(ma,tmp);\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     cout << a[i] << \" \";\n    // }\n    // cout << endl;\n    // for(int i=0;i<n;i++){\n    //     cout << b[i] << \" \";\n    // }\n    // cout << endl;\n    \n    if(ma==-1){\n        cout << \"mitomerarenaiWA\" << endl;\n    }else{\n        int x = ma;\n        int y = (n-3*ma)/2;\n        printf(\"Love \");\n        for(int i=0;i<x+y;i++){\n            printf(\"%c\",s[n-i-1]);\n        }\n        printf(\"!\\n\");\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar s[1000001];\nvector<int> a_kouho;\nint main()\n{\n  scanf(\"%s\", s);\n  int sn = strlen(s);\n\n  char ast = s[0], aen = s[sn - 1];\n  for(int i = 0; i < sn; i++)\n    if(s[i] == ast)\n      a_kouho.push_back(i);\n  for(int aki = 1; aki < a_kouho.size() - 1; aki++)\n  {\n    int aa = a_kouho[aki];\n    if(aa * 2 >= sn || s[aa * 2] != ast || aa * 3 <= sn)\n      continue;\n    for(int i = 0; i < aa; i++)\n    {\n      if(s[i] != s[i + aa])\n        goto ng;\n      if(i + aa * 2 < sn && s[i] != s[i + aa * 2])\n        goto ng;\n    }\n    printf(\"Love \");\n    for(int i = 0; i < aa; i++)\n      printf(\"%c\", s[i]);\n    printf(\"!\\n\");\n    return 0;\nng:;\n  }\n  printf(\"mitomerarenaiWA\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(x,y,z) for(int x=y;x<=z;x++)\n#define FORD(x,y,z) for(int x=y;x>=z;x--)\n#define MSET(x,y) memset(x,y,sizeof(x))\n#define FOR(x,y) for(__typeof(y.begin()) x=y.begin();x!=y.end();x++)\n#define F first\n#define S second\n#define MP make_pair\n#define PB push_back\n#define SZ size()\n#define M 1000005\nvoid RI(){}\ntemplate<typename... T>\nvoid RI( int& head, T&... tail ) {\n    scanf(\"%d\",&head);\n    RI(tail...);\n}\nusing namespace std;\ntypedef long long LL;\nint n,a1,a2;\nLL pre[2][M],pw[2][M], MOD[2]={1000000007, 1000000009};\nchar in[M];\npair<LL,LL> get_hash(int l,int r)\n{\n\tLL re[2] = { pre[0][r], pre[1][r] };\n\tif(l>1)\n\t{\n\t\tREP(i,0,1)\n\t\t{\n\t\t\tre[i] -= pre[i][l-1] * pw[i][r-l+1];\n\t\t\tre[i] %= MOD[i];\n\t\t\tre[i] = (re[i]+MOD[i]) % MOD[i];\n\t\t}\n\t}\n\treturn MP(re[0], re[1]);\n}\nint main()\n{\n\tscanf(\"%s\", in+1);\n\tn = strlen(in+1);\n\n\t//\n\t\n\tREP(j,0,1)\n\t{\n\t\tpre[j][1] = in[1];\n\t\tREP(i,2,n) pre[j][i] = (pre[j][i-1]*131 + in[i]) % MOD[j];\n\n\t\tpw[j][0] = 1;\n\t\tREP(i,1,n) pw[j][i] = (pw[j][i-1]*131) % MOD[j];\n\t}\n\n\ta1 = a2 = 0;\n\t//\n\tREP(i,1,n/3)\n\t{\n\t\tint j = n-3*i;\n\t\tif(j%2) continue;\n\t\tj = j/2;\n\t\tif(i*3 + j*2 != n) continue;\n\n\t\tpair<LL,LL> h1,h2,h3,h4,h5;\n\t\th1 = get_hash(1,i);\n\t\th2 = get_hash(i+1,i+j);\n\t\th3 = get_hash(i+j+1, i+i+j);\n\t\th4 = get_hash(i+i+j+1, 2*(i+j));\n\t\th5 = get_hash(2*(i+j)+1, n);\n\n\t\tif(i==2 && j==2)\n\t\t{\n\t\t\tprintf(\"%I64u %I64u\\n\",h1.F,h1.S);\n\t\t\tprintf(\"%I64u %I64u\\n\",h3.F,h3.S);\n\t\t\tprintf(\"%I64u %I64u\\n\",h5.F,h5.S);\n\t\t}\n\n\t\tif(h1==h3 && h3==h5 && h2==h4)\n\t\t{\n\t\t\tif(a1==0)\n\t\t\t{\n\t\t\t\ta1=i;\n\t\t\t\ta2=j;\n\t\t\t}\n\t\t\telse if((a1+a2) > i+j)\n\t\t\t{\n\t\t\t\ta1 = i;\n\t\t\t\ta2 = j;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(a1==0) puts(\"mitomerarenaiWA\");\n\telse\n\t{\n\t\tprintf(\"Love \");\n\t\tREP(i,1,a1+a2) putchar(in[i]);\n\t\tputs(\"!\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_RollingHash\n#define ___Class_RollingHash\n\n#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\ntemplate <long long mod, long long base = 257>\nclass RollingHash {\nprivate:\n\tstd::string str;\n\tstd::vector<long long> sum;\npublic:\n\tRollingHash() : str(\"\"), sum(std::vector<long long>(1, 0)) {};\n\tRollingHash(const std::string &s) : str(s) {\n\t\tsum.resize(str.size() + 1);\n\t\tfor (int i = 0; i < str.size(); i++) sum[i + 1] = (1LL * sum[i] * base + s[i]) % mod;\n\t}\n\tstatic inline long long modpow(long long a, long long b) {\n\t\tlong long ret = 1; a %= mod;\n\t\twhile (b) {\n\t\t\tif (b & 1) ret = 1LL * ret * a % mod;\n\t\t\ta = 1LL * a * a % mod;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tstd::string get() { return str; }\n\tlong long gethash(int l, int r) {\n\t\treturn (sum[r] - sum[l] * modpow(base, r - l) % mod + mod) % mod;\n\t}\n};\n\n#endif\n\nconst int MOD = 2016112121;\nstring T;\n\nint main() {\n\tcin >> T; RollingHash<MOD> S(T); bool flag = false;\n\tfor (int i = 1; i <= T.size() / 3; i++) {\n\t\tint G = (T.size() - i * 3); if (G % 2 == 1 || G <= 0)continue;\n\t\tG /= 2;\n\t\tlong long p1 = S.gethash(0, i);\n\t\tlong long p2 = S.gethash(i, i + G);\n\t\tlong long p3 = S.gethash(i + G, i * 2 + G);\n\t\tlong long p4 = S.gethash(i * 2 + G, i * 2 + G * 2);\n\t\tlong long p5 = S.gethash(i * 2 + G * 2, i * 3 + G * 2);\n\t\tif (flag == false) {\n\t\t\tif (p1 == p3 && p3 == p5) {\n\t\t\t\tif (p2 == p4) {\n\t\t\t\t\tcout << \"Love \" << T.substr(0, i + G) << \"!\" << endl; flag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (flag == false)cout << \"mitomerarenaiWA\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n//Roling Hash\n//RollingHash RH(s,base) base:[2,MOD)?????±??°\n//RH.set(s,base): vector???????§???????????????????????????§????????????????????????????????????\n//RH.get(l,r): [l,r)??????????????\\ O(1)\n//1000000007, 1000000009, 1000000021\ntemplate<long long MOD>\nclass RollingHash {\npublic:\n\tint n;\n\tlong long base;\n\tvector<long long> pow, hash;\n\tRollingHash() {}\n\tRollingHash(const string &s, long long base_ = 10007) { init(s, base_); }\n\tvoid init(const string &s, long long base_ = 10007) {\n\t\tn = s.size();\n\t\tbase = base_;\n\t\tcalc(s.c_str());\n\t}\n\tlong long get(int x)const { return hash[x]; }\n\tlong long get(int l, int r)const { return (get(r) - get(l)*pow[r - l] % MOD + MOD) % MOD; }\n\tvoid calc(const char *s) {\n\t\tpow.resize(n + 1);\n\t\tpow[0] = 1;\n\t\thash.resize(n + 1);\n\t\thash[0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpow[i + 1] = pow[i] * base % MOD;\n\t\t\thash[i + 1] = (s[i] + hash[i] * base) % MOD;\n\t\t}\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s; cin >> s;\n\tRollingHash<1000000007> RH(s);\n\tfor (int a = (s.size() - 2) / 3, b; a >= 1; a--) {\n\t\tb = (s.size() - a * 3) / 2;\n\t\tif (3 * a + 2 * b != s.size())continue;\n\t\tauto A1 = RH.get(0, a);\n\t\tauto B1 = RH.get(a, a + b);\n\t\tauto A2 = RH.get(a + b, a + b + a);\n\t\tauto B2 = RH.get(a + b + a, a + b + a + b);\n\t\tauto A3 = RH.get(a + b + a + b, a + b + a + b + a);\n\t\tif (A1 == A2&&A2 == A3&&B1 == B2) {\n\t\t\tcout << \"Love \" << s.substr(0, a + b) << \"!\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"mitomerarenaiWA\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar s[1000001];\nvector<int> a_kouho;\nint main()\n{\n  scanf(\"%s\", s);\n  int sn = strlen(s);\n\n  char ast = s[0], aen = s[sn - 1];\n  for(int i = sn / 3; i <= sn / 2; i++)\n    if(s[i] == ast)\n      a_kouho.push_back(i);\n  for(int aki = 0; aki < a_kouho.size(); aki++)\n  {\n    int aa = a_kouho[aki];\n    if(aa * 2 >= sn || s[aa * 2] != ast || aa * 3 <= sn)\n      continue;\n    for(int i = 0; i < aa; i++)\n    {\n      if(s[i] != s[i + aa])\n        goto ng;\n      if(i + aa * 2 < sn && s[i] != s[i + aa * 2])\n        goto ng;\n    }\n    printf(\"Love \");\n    for(int i = 0; i < aa; i++)\n      printf(\"%c\", s[i]);\n    printf(\"!\\n\");\n    return 0;\nng:;\n  }\n  printf(\"mitomerarenaiWA\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\nusing ll = long long int;\nusing ha = pair<ll, ll>;\nstruct RollingHash {\n\tstatic const ll mul0 = 10009, mul1 = 10007;\n\tstatic const ll add0 = 1000010007, add1 = 1003333331;\n\tsize_t len;\n\t//vector<ll> hash_, hash2_;\n\tvector<ha>hash_;\n\t//static vector<ll> pmo_, pmo2_;\n\tstatic vector<ha>pmo_;\n\tvoid init(const vector<ll>& s) {\n\t\tlen = s.size();\n\t\thash_.resize(len + 1);\n\t\thash_[0] = make_pair(0, 0);\n\n\t\tif (pmo_.empty()) {\n\t\t\tpmo_.push_back(make_pair(1, 1));\n\t\t}\n\t\twhile (pmo_.size() <= len) {\n\t\t\tpmo_.push_back(make_pair(pmo_.back().first*mul0, pmo_.back().second*mul1));\n\t\t}\n\t\tfor (unsigned int i = 0; i < len; ++i) {\n\t\t\thash_[i + 1] = make_pair((hash_[i].first * mul0 + s[i]), (hash_[i].second*mul1 + s[i]));\n\t\t}\n\t\treturn;\n\t}\n\tvoid init(const string& s) {\n\t\tvector<ll>v;\n\t\tfor (char c : s) {\n\t\t\tv.push_back(c);\n\t\t}\n\t\tinit(v);\n\t}\n\tha hash(const int l, const int r)const { // s[l..r]\n\t\treturn make_pair(hash_[r + 1].first - hash_[l].first * pmo_[r + 1 - l].first,\n\t\t\thash_[r + 1].second - hash_[l].second * pmo_[r + 1 - l].second);\n\t}\n\tha  hash()const { // s[all]\n\t\treturn hash(0, len - 1);\n\t}\n\n\t//hash????????????\n\tstatic ha concat(const ha L, const ha R, const int RLength) { // hash(L+R) \n\t\treturn make_pair((R.first + L.first*pmo_[RLength].first), (R.second + L.second*pmo_[RLength].second));\n\t}\n\n\t//index????????????from??????to????????????????????????????????\\????????????\n\tha get_changed_hash(const int index, const ll from, const ll to)const {\n\t\tconst ha p(hash());\n\t\treturn make_pair(\n\t\t\tp.first + (to - from) * pmo_[len - index - 1].first,\n\t\t\tp.second + (to - from) * pmo_[len - index - 1].second);\n\t}\n};\nvector<ha> RollingHash::pmo_;\n\nint main() {\n\tstring st; cin >> st;\n\tRollingHash rh;\n\trh.init(st);\n\tpair<int, int>ans=make_pair(0,0);\n\tfor (int a = st.size() / 3; a > 0; --a) {\n\t\tif ((st.size() - a * 3) % 2)continue;\n\t\telse {\n\t\t\tint b = (st.size() - a * 3) / 2;\n\t\t\tha h0 = rh.hash(0, a - 1);\n\t\t\tha h1 = rh.hash(a, a + b - 1);\n\t\t\tha h2 = rh.hash(a + b, 2 * a + b - 1);\n\t\t\tha h3 = rh.hash(2 * a + b, 2 * a + 2 * b-1);\n\t\t\tha h4 = rh.hash(2 * a + 2 * b, 3 * a + 2 * b - 1);\n\t\t\tif (h0 == h2&&h2 == h4&&h1 == h3) {\n\t\t\t\tans = make_pair(a, b);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (ans.first) {\n\t\tassert(ans.second);\n\t\tcout << \"Love \" << st.substr(0, ans.first) << st.substr(ans.first, ans.second) << \"!\" << endl;\n\t}\n\telse {\n\t\tcout << \"mitomerarenaiWA\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\n#define REP(i,n) for(int i=0;i<n;++i)\n#define REPR(i,n) for(int i=1;i<n;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) REP(i,v.size())cout<<#v<<\"[\"<<i<<\"]: \"<<v[i]<<endl\n#define ALL(a) (a).begin(),(a).end()\n\nint main(){\n  string s;\n  cin>>s;\n  int len = s.size();\n  int minlenab = len;\n  string result = \"mitomerarenaiWA\";\n  // ABABA -> 3*A+2*B\n  REPR(lena,len/3+1){\n    if((len-(lena*3))%2!=0)continue;\n    int lenb = (len-(lena*3))/2;\n    if(lena==0 || lenb==0)continue;\n    if(lena+lenb>minlenab)continue;\n    bool ok = true;\n    REP(_,2)REP(i,lena){\n      if(s[i]!=s[(lena+lenb)*(_+1)+i])ok=false;\n      if(!ok)break;\n    }\n    REP(i,lenb){\n      if(s[lena+i]!=s[lena*2+lenb+i])ok=false;\n      if(!ok)break;\n    }\n    if(ok){\n      minlenab = lena+lenb;\n      result = s.substr(0,lena+lenb);\n    }\n  }\n  if(result!=\"mitomerarenaiWA\")cout<<\"Love \";\n  cout<<result;\n  if(result!=\"mitomerarenaiWA\")cout<<\"!\";\n  cout<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int sz = 1000010;\nchar s[sz];\n\nint main(){\n\tfgets(s, sz, stdin);\n\tint n = strlen(s) - 1;\n\tfor(int i = n / 3 + 1; i * 2 < n; ++i){\n\t\tif(!memcmp(s, s + i, n - i)){\n\t\t\ts[i] = '\\0';\n\t\t\tfputs(\"Love \", stdout);\n\t\t\tfputs(s, stdout);\n\t\t\tputs(\"!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"mitomerarenaiWA\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nvoid z_algorithm(string& S,vector<int>& res)\n{\n    int sz = (int)S.size();\n    res.resize(sz);\n    int c = 0;\n    for(int i = 1; i < sz; i++){\n        if(i+res[i-c] < c+res[c]){\n            res[i] = res[i-c];\n        }else{\n            int j = max(0, c+res[c]-i);\n            while (i+j < sz && S[j] == S[i+j]) ++j;\n            res[i] = j;\n        }\n    }\n    res[0] = sz;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = s.size();\n    if(n>900000){\n        cout << \"MURI\" << endl;\n        return 0;\n    }\n    vector<int> a,b;\n    z_algorithm(s,a);\n    reverse(s.begin(),s.end());\n    z_algorithm(s,b);\n    int ma = -1;\n    for(int i=n/3-2;i<n/2+2;i++){\n        if(i<=0||i>=n)continue;\n        int tmp = n-2*i;\n        if(a[i]==n-i&&b[i]==n-i&&tmp>0&&(n-3*(tmp))/2>0){\n            ma = max(ma,tmp);\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     cout << a[i] << \" \";\n    // }\n    // cout << endl;\n    // for(int i=0;i<n;i++){\n    //     cout << b[i] << \" \";\n    // }\n    // cout << endl;\n    \n    if(ma==-1){\n        cout << \"mitomerarenaiWA\" << endl;\n    }else{\n        int x = ma;\n        int y = (n-3*ma)/2;\n        printf(\"Love \");\n        for(int i=0;i<x+y;i++){\n            printf(\"%c\",s[n-i-1]);\n        }\n        printf(\"!\\n\");\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstring solve(string s){\n  int i, j;\n  string a1, a2, a3, b1, b2;\n  for(i = 0;;++i)if(i + i + i >= s.size())break;\n  for(;i >= 0;--i)if(s.size() % 2 == i % 2){\n    j = s.size() - i - i - i; j >>= 1;\n    a1 = s.substr(0, i);\n    b1 = s.substr(i, j);\n    a2 = s.substr(i + j, i);\n    b2 = s.substr(i + j + i, j);\n    a3 = s.substr(i + j + i + j, i);\n    if(a1 == a2 && a2 == a3 && b1 == b2)return \"Love \" + a1 + b1 + \"!\";\n  }\n  return \"mitomerarenaiWA\";\n}\n\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    string s; cin >> s;\n    cout << solve(s) << endl;\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_RollingHash\n#define ___Class_RollingHash\n\n#include <string>\n#include <vector>\n\ntemplate <int mod, int base = 257>\nclass RollingHash {\nprivate:\n\tstd::string str;\n\tstd::vector<int> sum;\npublic:\n\tRollingHash() : str(\"\"), sum(std::vector<int>(1, 0)) {};\n\tRollingHash(const std::string &s) : str(s) {\n\t\tsum.resize(str.size() + 1);\n\t\tfor (int i = 0; i < str.size(); i++) sum[i + 1] = (1LL * sum[i] * base + s[i]) % mod;\n\t}\n\tstatic inline int modpow(int a, int b) {\n\t\tint ret = 1; a %= mod;\n\t\twhile (b) {\n\t\t\tif (b & 1) ret = 1LL * ret * a % mod;\n\t\t\ta = 1LL * a * a % mod;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ret;\n\t}\n\tstd::string get() { return str; }\n\tint gethash(int l, int r) {\n\t\treturn (sum[r] - 1LL * sum[l] * modpow(base, r - l) % mod + mod) % mod;\n\t}\n};\n\n#endif\n\n#include <string>\n#include <iostream>\nusing namespace std;\nstring s;\nint main() {\n\tcin >> s;\n\tint n = s.size();\n\tRollingHash<998244353> Q(s);\n\tbool flag = false;\n\tfor (int i = n / 3; i >= 1 && !flag; i--) {\n\t\tif ((n - 3 * i) % 2 == 1) continue;\n\t\tint r = (n - 3 * i) / 2, p1 = i, p2 = i + r, p3 = 2 * i + r, p4 = 2 * i + 2 * r;\n\t\tint z1 = Q.gethash(0, p1);\n\t\tint z2 = Q.gethash(p2, p3);\n\t\tint z3 = Q.gethash(p4, n);\n\t\tint z4 = Q.gethash(p1, p2);\n\t\tint z5 = Q.gethash(p3, p4);\n\t\tif (z1 == z2 && z1 == z3 && z4 == z5) {\n\t\t\tcout << \"Love \" << s.substr(0, p2) << \"!\" << endl;\n\t\t\tflag = true;\n\t\t}\n\t}\n\tif (!flag) cout << \"mitomerarenaiWA\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar s[1000001];\nvector<int> a_kouho;\nint main()\n{\n  scanf(\"%s\", s);\n  int sn = strlen(s);\n\n  char ast = s[0], aen = s[sn - 1];\n  for(int i = sn / 3 + 1; i <= sn / 2; i++)\n    if(s[i] == ast)\n      a_kouho.push_back(i);\n  for(int aki = 0; aki < a_kouho.size(); aki++)\n  {\n    int aa = a_kouho[aki];\n    for(int i = 0; i < aa; i++)\n    {\n      if(s[i] != s[i + aa])\n        goto ng;\n      if(i + aa * 2 < sn && s[i] != s[i + aa * 2])\n        goto ng;\n    }\n    printf(\"Love \");\n    for(int i = 0; i < aa; i++)\n      printf(\"%c\", s[i]);\n    printf(\"!\\n\");\n    return 0;\nng:;\n  }\n  printf(\"mitomerarenaiWA\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1000001\nusing ull = unsigned long long;\nusing P = tuple<int, int, int>;\n\nconst ull b = 1000000007ULL;\n\nvector<ull> rolling_hash(char* S, int N, vector<ull>& p)\n{\n    vector<ull> h(N + 1);\n    for (int i = 0; i < N; i++) {\n        h[i + 1] = h[i] * b + S[i];\n        p[i + 1] = p[i] * b;\n    }\n    return h;\n}\n\nint main()\n{\n    char S[MAX];\n    scanf(\"%s\", S);\n    \n    int N = strlen(S);\n    vector<ull> p(N + 1);\n    p[0] = 1;\n    \n    bool found = 0;\n    auto h = rolling_hash(S, N, p);    \n    \n    vector<P> v;\n    for (int i = 0; i < N; i++) {\n        int A = i + 1;\n        int B = (N - 3 * A) / 2;\n\n        if (B <= 0) continue;\n        if ((N - 3 * A) % 2 != 0) continue;\n\n        auto A1 = h[A] - h[0] * p[A];\n        auto B1 = h[A + B] - h[A] * p[B];\n        auto A2 = h[A * 2 + B] - h[A + B] * p[A];\n        auto B2 = h[2 * (A + B)] - h[A * 2 + B] * p[B];\n        auto A3 = h[N] - h[2 * (A + B)] * p[A];\n\n        if (A1 == A2 && A2 == A3 && B1 == B2) {\n            found = 1;\n            v.emplace_back(A + B, A, B);\n        }\n    }\n\n    sort(v.begin(), v.end());\n    \n    if (!found) {\n        printf(\"mitomerarenaiWA\\n\");\n    } else {\n        printf(\"Love \");\n        int size = get<0>(v[0]);\n        for (int i = 0; i < size; i++) {\n            printf(\"%c\", S[i]);\n        }\n        printf(\"!\\n\");\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nchar s[1000001];\nvector<int> a_kouho;\nint main()\n{\n  scanf(\"%s\", s);\n  int sn = strlen(s);\n\n  char ast = s[0], aen = s[sn - 1];\n  for(int i = sn / 3; i <= sn / 2; i++)\n    if(s[i] == ast)\n      a_kouho.push_back(i);\n  for(int aki = 0; aki < a_kouho.size(); aki++)\n  {\n    int aa = a_kouho[aki];\n    if(aa * 2 >= sn || s[aa * 2] != ast || aa * 3 < sn)\n      continue;\n    for(int i = 0; i < aa; i++)\n    {\n      if(s[i] != s[i + aa])\n        goto ng;\n      if(i + aa * 2 < sn && s[i] != s[i + aa * 2])\n        goto ng;\n    }\n    printf(\"Love \");\n    for(int i = 0; i < aa; i++)\n      printf(\"%c\", s[i]);\n    printf(\"!\\n\");\n    return 0;\nng:;\n  }\n  printf(\"mitomerarenaiWA\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nconst ull B = 100000007;\n\null Hash_table[3000010];\null po[3000010];\n\n\nint main(){\n    \n    string s; cin >> s;\n    int n = (int)s.size();\n    \n    Hash_table[0] = 0;\n    po[0] = 1;\n\n    for(int i = 1; i <= n; i++){\n        po[i] = po[i - 1] * B;\n        Hash_table[i] = Hash_table[i - 1] * B + (ull)(s[i - 1] - 'a' + 1);\n    }\n\n    \n\n    for(int i = (n - 2) / 3; i >= 0; i--){\n        if((n - 3 * i) % 2 == 1) continue;\n\n        int j = ((n - 3 * i) / 2);\n        //cout << i << \" \" << j << endl;\n        ull H1 = Hash_table[i] - Hash_table[0] * po[i];\n        ull H2 = Hash_table[i + j] - Hash_table[i] * po[j];\n        ull H3 = Hash_table[2 * i + j] - Hash_table[i + j] * po[i];\n        ull H4 = Hash_table[2 * i + 2 * j] - Hash_table[2 * i + j] * po[j];\n        ull H5 = Hash_table[n] - Hash_table[2 * i + 2 * j] * po[n - (2 * i + 2 * j)];\n\n        \n        if(H1 == H3 && H3 == H5 && H2 == H4){\n            string A = s.substr(0, i);\n            string B = s.substr(i, j);\n            cout << \"Love \" << A + B << \"!\" << endl;\n            return 0;\n        }\n    }\n\n    cout << \"mitomerarenaiWA\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tString s = sc.next();\n\t\tint N = s.length();\n\t\tRollingHash rh = new RollingHash();\n\t\trh.init(s);\n\t\tint ans = Integer.MAX_VALUE;\n\t\tString res = \"mitomerarenaiWA\";\n\t\tint l = 0;\n\t\tint r = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint t = N - (i + 1) * 3;\n\t\t\tif (t > 0 && t % 2 == 0) {\n\t\t\t\tint A = i + 1;\n\t\t\t\tint B = t / 2;\n\t\t\t\tlong a1 = rh.getHash2(0, A - 1);\n\t\t\t\tlong b1 = rh.getHash2(A, A + B - 1);\n\t\t\t\tlong a2 = rh.getHash2(A + B, A + B + A - 1);\n\t\t\t\tlong b2 = rh.getHash2(A + B + A, A + B + A + B - 1);\n\t\t\t\tlong a3 = rh.getHash2(A + B + A + B, N - 1);\n\t\t\t\tif (a1 == a2 && a2 == a3 && b1 == b2) {\n\t\t\t\t\tans = Math.min(ans, i + t);\n\t\t\t\t\tl = A;\n\t\t\t\t\tr = B;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (l != 0 && r != 0) res = \"Love \" + s.substring(0, l) + s.substring(l, l + r) + \"!\";\n\t\tSystem.out.println(res);\n\t}\n\n\tpublic class RollingHash {\n\n\t\tString S;\n\t\tint N, l, r;\n\n\t\tlong B1 = 1007;\n\t\tlong B2 = 1009;\n\t\tlong H1 = 1000000007;\n\t\tlong H2 = 1000000009;\n\n\t\tlong[] Base1, Base2;\n\t\tlong[] Hash1, Hash2;\n\n\t\tvoid init(String s) {\n\t\t\tS = s;\n\t\t\tN = s.length();\n\t\t\tl = 0;\n\t\t\tr = s.length() - 1;\n\t\t\tBase1 = new long[N + 1];\n\t\t\tBase2 = new long[N + 1];\n\t\t\tHash1 = new long[N];\n\t\t\tHash2 = new long[N];\n\n\t\t\tBase1[0] = Base2[0] = 1;\n\t\t\tHash1[0] = Hash2[0] = s.charAt(0);\n\t\t\tfor (int i = 1; i <= N; i++) Base1[i] = (Base1[i - 1] * B1) % H1;\n\t\t\tfor (int i = 1; i <= N; i++) Base2[i] = (Base2[i - 1] * B2) % H2;\n\t\t\tfor (int i = 1; i < N; i++) Hash1[i] = (Hash1[i - 1] * B1 + s.charAt(i)) % H1;\n\t\t\tfor (int i = 1; i < N; i++) Hash2[i] = (Hash2[i - 1] * B2 + s.charAt(i)) % H2;\n\t\t}\n\n\t\t/*\n\t\t * S(this)???T??????????????????(?????¬??????RollingHash)\n\t\t */\n\t\tboolean contain1(String T) {\n\t\t\tint sl = S.length();\n\t\t\tint tl = T.length();\n\t\t\tif (tl > sl) return false;\n\n\t\t\tlong b = 1;\n\t\t\tfor (int i = 0; i < tl; i++) b = (b * B1) % H1;\n\n\t\t\tlong sh = 0;\n\t\t\tlong th = 0;\n\t\t\tfor (int i = 0; i < tl; i++) sh = (sh * B1 + (S.charAt(i))) % H1;\n\t\t\tfor (int i = 0; i < tl; i++) th = (th * B1 + (T.charAt(i))) % H1;\n\n\t\t\tfor (int i = 0; i + tl <= sl; i++) {\n\t\t\t\tif (sh == th) return true;\n\t\t\t\tif (i + tl < sl) sh = sh * B1 - (S.charAt(i)) * b + (S.charAt(i + tl));\n\t\t\t\tsh = (sh + H1) % H1;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean contain2(String T) {\n\t\t\tint sl = N;\n\t\t\tint tl = T.length();\n\t\t\tif (tl > sl) return false;\n\n\t\t\tlong th = 0;\n\t\t\tfor (int i = 0; i < tl; i++) th = (th * B1 + (T.charAt(i))) % H1;\n\n\t\t\tr = tl - 1;\n\t\t\tl = 0;\n\t\t\tfor (; r < N; r++, l++) {\n\t\t\t\tif (getHash1() == th) return true;\n\t\t\t}\n\t\t\tl = 0;\n\t\t\tr = S.length() - 1;\n\t\t\treturn false;\n\t\t}\n\n\t\tlong getHash1() {\n\t\t\tlong res = Hash1[r] - ((l == 0) ? 0 : Hash1[l - 1] * Base1[r - l + 1]);\n\t\t\tif (res < 0) res = (res + ((-res / H1) + 1) * H1) % H1;\n\t\t\treturn res;\n\t\t}\n\n\t\tlong getHash1(int l, int r) {\n\t\t\tlong res = Hash1[r] - ((l == 0) ? 0 : Hash1[l - 1] * Base1[r - l + 1]);\n\t\t\tif (res < 0) res = (res + ((-res / H1) + 1) * H1) % H1;\n\t\t\treturn res;\n\t\t}\n\n\t\tlong getHash2() {\n\t\t\tlong res = Hash2[r] - ((l == 0) ? 0 : Hash2[l - 1] * Base2[r - l + 1]);\n\t\t\tif (res < 0) res = (res + ((-res / H2) + 1) * H2) % H2;\n\t\t\treturn res;\n\t\t}\n\n\t\tlong getHash2(int l, int r) {\n\t\t\tlong res = Hash2[r] - ((l == 0) ? 0 : Hash2[l - 1] * Base2[r - l + 1]);\n\t\t\tif (res < 0) res = (res + ((-res / H2) + 1) * H2) % H2;\n\t\t\treturn res;\n\t\t}\n\n\t\tvoid show() {\n\t\t\tSystem.out.println(\"---------show---------\");\n\t\t\tSystem.out.println(\"String = \" + S.substring(l, r + 1));\n\t\t\tSystem.out.println(\"l = \" + l + \" r = \" + r);\n\t\t\tSystem.out.println(\"Hash1 = \" + getHash1() + \" Hash2 = \" + getHash2());\n\t\t\tSystem.out.println(\"----------------------\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (k <= a[i])\n\tint lower_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k <= a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\t// find minimum i (k < a[i])\n\tint upper_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k < a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tlong gcd(long a, long b) {\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\n\t}\n\n\tlong lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1000001\nusing ull = unsigned long long;\n\nconst ull b = 1000000007ULL;\n\nvector<ull> rolling_hash(char* S, int N, vector<ull>& p)\n{\n    vector<ull> h(N + 1);\n    for (int i = 0; i < N; i++) {\n        h[i + 1] = h[i] * b + S[i];\n        p[i + 1] = p[i] * b;\n    }\n    return h;\n}\n\nint main()\n{\n    char S[MAX];\n    scanf(\"%s\", S);\n    \n    int N = strlen(S);\n    vector<ull> p(N + 1);\n    p[0] = 1;\n    \n    auto h = rolling_hash(S, N, p);    \n    \n    int mini = MAX;\n    for (int i = 0; i < N; i++) {\n        int A = i + 1;\n        int B = (N - 3 * A) / 2;\n\n        if (B <= 0) continue;\n        if ((N - 3 * A) % 2 != 0) continue;\n\n        auto A1 = h[A] - h[0] * p[A];\n        auto B1 = h[A + B] - h[A] * p[B];\n        auto A2 = h[A * 2 + B] - h[A + B] * p[A];\n        auto B2 = h[2 * (A + B)] - h[A * 2 + B] * p[B];\n        auto A3 = h[N] - h[2 * (A + B)] * p[A];\n\n        if (A1 == A2 && A2 == A3 && B1 == B2) {\n            mini = min(mini, A + B);\n        }\n    }    \n    \n    if (mini == MAX) {\n        printf(\"mitomerarenaiWA\\n\");\n    } else {\n        printf(\"Love \");\n        for (int i = 0; i < mini; i++) {\n            printf(\"%c\", S[i]);\n        }\n        printf(\"!\\n\");\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> // cout, endl, cin\n#include <string> // string, to_string, stoi\n#include <vector> // vector\n#include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound\n#include <utility> // pair, make_pair\n#include <tuple> // tuple, make_tuple\n#include <cstdint> // int64_t, int*_t\n#include <cstdio> // printf\n#include <map> // map\n#include <queue> // queue, priority_queue\n#include <set> // set\n#include <stack> // stack\n#include <deque> // deque\n#include <unordered_map> // unordered_map\n#include <unordered_set> // unordered_set\n#include <bitset> // bitset\n#include <cctype> // isupper, islower, isdigit, toupper, tolower\n#include <iomanip> // setprecision\n#define enld '\\n'\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"Ofast\")\nconstexpr ll INF = 1e18;\nconstexpr int inf = 1e9;\nconstexpr ll mod = 1000000007;\nconstexpr ll mod2 = 998244353;\nconst double PI = 3.1415926535897932384626433832795028841971;\nconst int dx[8] = {1, 0, -1, 0,1,1,-1,-1};\nconst int dy[8] = {0, 1, 0, -1,1,-1,1,-1};\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n// ---------------------------------------------------------------------------\n\nvector<int> Z_algorithm(string S){\n    int c=0,n=S.size();\n    vector<int> Z(n,0);\n    for(int i=1; i<n; i++){\n        int l = i-c;\n        if(i+Z[l] < c+Z[c]){\n            Z[i] = Z[l];\n        }else{\n            int j = max(0, c+Z[c]-i);\n            while(i+j<n && S[j]==S[i+j]) j++;\n            Z[i] = j;\n            c = i;\n        }\n    }\n    Z[0] = n;\n    return Z;\n}\n\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    string S;\n    cin >> S;\n    vector<int> Z = Z_algorithm(S);\n    int N = S.size();\n    // ABを入れる\n    string ans = \"-\";\n    for(int i=N-1; i>=1; i--){\n        // 後ろがAになるか判定\n        if(Z[i] == N-i){\n            // Bの文字列の長さ\n            // これB*2の長さ\n            int B = (i-1)-Z[i]+1-Z[i];\n            if(B <= 0) continue;\n            if(B%2 == 0){\n                // Bの長さ\n                B /= 2;\n                if(Z[Z[i]+B] >= Z[i]+B){\n                    // 条件満たす\n                    // cout << i << \" \" << Z[i]+B << \"\\n\";\n                    if(ans == \"-\"){\n                        ans = S.substr(0,Z[i]+B);\n                    }else{\n                        if(ans.size() > Z[i]+B){\n                            ans = S.substr(0,Z[i]+B);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(ans == \"-\"){\n        cout << \"mitomerarenaiWA\" << \"\\n\";\n    }else{\n        cout << \"Love \" << ans << \"!\" << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nvoid z_algorithm(string& S,vector<int>& res)\n{\n    int sz = (int)S.size();\n    res.resize(sz);\n    int c = 0;\n    for(int i = 1; i < sz; i++){\n        if(i+res[i-c] < c+res[c]){\n            res[i] = res[i-c];\n        }else{\n            int j = max(0, c+res[c]-i);\n            while (i+j < sz && S[j] == S[i+j]) ++j;\n            res[i] = j;\n        }\n    }\n    res[0] = sz;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    int n = s.size();\n    vector<int> a,b;\n    z_algorithm(s,a);\n    reverse(s.begin(),s.end());\n    z_algorithm(s,b);\n    int ma = -1;\n    for(int i=n/3-2;i<n/2+2;i++){\n        if(i<=0||i>=n)continue;\n        int tmp = n-2*i;\n        if(a[i]==n-i&&b[i]==n-i&&tmp>0&&(n-3*(tmp))/2>0){\n            ma = max(ma,tmp);\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     cout << a[i] << \" \";\n    // }\n    // cout << endl;\n    // for(int i=0;i<n;i++){\n    //     cout << b[i] << \" \";\n    // }\n    // cout << endl;\n    \n    if(ma==-1){\n        cout << \"mitomerarenaiWA\" << endl;\n    }else{\n        int x = ma;\n        int y = (n-3*ma)/2;\n        if(x+y>300000){\n            cout << \"a\" << endl;\n            return 0;\n        }\n        printf(\"Love \");\n        for(int i=0;i<x+y;i++){\n            printf(\"%c\",s[n-i-1]);\n        }\n        printf(\"!\\n\");\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\nconst ull B = 1e9+7;\nchar s[1111111];\nint len;\null a[1111111];\null h[1111111];\null Bh[1111111];\n\nint main(void) {\n  scanf(\"%s\", s);\n  len = strlen(s);\n\n  Bh[0] = 1;\n  for (int i = 0; i < len; i++) {\n    h[i+1] = h[i]*B + s[i];\n    Bh[i+1] = Bh[i]*B;\n  }\n\n  /*\n  for (int i = 0; i < len; i++) {\n    printf(\"%c %20llu\\n\", s[i], h[i+2]-h[i]*B*B);\n  }\n  */\n\n  int res = -1;\n  for (int i = 1; i*3 < len; i++) {\n    if ((len - i*3)%2 != 0 || len - i*3 <= 0) continue;\n    int al = i;\n    int bl = (len - i*3)/2;\n    // printf(\"%d %d\\n\", al, bl);\n    // printf(\"%llu [%d, %d]=%llu\\n\", h[al], al+bl, al+bl + al, h[al+bl + al]-h[al+bl]*Bh[al]);\n    if (h[al] == h[al+bl + al]-h[al+bl]*Bh[al] &&\n        h[al+bl + al]-h[al+bl]*Bh[al] == h[al*2+bl*2+al]-h[al*2+bl*2]*Bh[al] &&\n        h[al+bl]-h[al]*Bh[bl] == h[al*2+bl + bl]-h[al*2+bl]*Bh[bl]) {\n      if (res == -1 || res > al+bl) {\n        res = al+bl;\n      }\n      /*\n      for (int i = 0; i < al+bl; i++) {\n        printf(\"%c\", s[i]);\n      }\n      puts(\"\");\n      */\n    }\n  }\n\n  if (res < 0) {\n    puts(\"mitomerarenaiWA\");\n  } else {\n    printf(\"Love \");\n    for (int i = 0; i < res; i++) {\n      printf(\"%c\", s[i]);\n    }\n    puts(\"!\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n \ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n \ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n    return os<<'('<<p.first<<','<<p.second<<')';\n}\n \ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n    print_tuple<Cdr...>(os,t);\n    os<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n    print_tuple<Args...>(os<<'(',t);\n    return os<<')';\n}\n \ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n    os<<'[';\n    for(auto i=begin(c);i!=end(c);++i)\n        os<<(i==begin(c)?\"\":\" \")<<*i;\n    return os<<']';\n}\n \nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n \ntemplate<typename C>\nvoid RadixSort(const vi& src,vi& dst,const C& s,int ofs,int n,int asize)\n{\n    vi hist(asize+1);\n    rep(i,n) hist[s[ofs+src[i]]]++;\n    rep(i,asize) hist[i+1]+=hist[i];\n    per(i,n) dst[--hist[s[ofs+src[i]]]]=src[i];\n}\n \nbool Less(int a1,int a2,int b1,int b2)\n{\n    return a1!=b1?a1<b1:a2<b2;\n}\nbool Less(int a1,int a2,int a3,int b1,int b2,int b3)\n{\n    return a1!=b1?a1<b1:Less(a2,a3,b2,b3);\n}\n \n// s[0..n-1]: 入力文字列．末尾に'\\0'が3つ必要(s[n]=s[n+1]=s[n+2]=0)．\n// sa[0..n-1]: 接尾辞配列．\n// asize: アルファベットサイズ，s[i] \\in [1,asize]\ntemplate<typename C>\nvoid KaerkkaeinenSanders(const C& s,vi& sa,int asize)\n{\n    int n=sa.size();\n    int n0=(n+2)/3,n1=(n+1)/3,n2=n/3,n02=n0+n2;\n    vi s12(n02+3),sa12(n02);\n     \n    for(int i=0,j=0;i<n+(n0-n1);i++)\n        if(i%3) s12[j++]=i;\n    RadixSort(s12,sa12,s,2,n02,asize);\n    RadixSort(sa12,s12,s,1,n02,asize);\n    RadixSort(s12,sa12,s,0,n02,asize);\n     \n    int name=0,x=-1,y=-1,z=-1;\n    rep(i,n02){\n        int j=sa12[i];\n        if(s[j]!=x || s[j+1]!=y || s[j+2]!=z)\n            x=s[j],y=s[j+1],z=s[j+2],name++;\n        if(j%3==1) s12[j/3]=name;\n        else       s12[n0+j/3]=name;\n    }\n     \n    if(name==n02) // unique\n        rep(i,n02) sa12[s12[i]-1]=i;\n    else{\n        KaerkkaeinenSanders(s12,sa12,name);\n        rep(i,n02) s12[sa12[i]]=i+1;\n    }\n     \n    vi s0(n0),sa0(n0);\n    for(int i=0,j=0;i<n02;i++)\n        if(sa12[i]<n0) s0[j++]=3*sa12[i];\n    RadixSort(s0,sa0,s,0,n0,asize);\n     \n    int i=0,j=n0-n1,k=0;\n    while(i<n0 && j<n02){\n        int p=sa0[i],q=sa12[j]<n0?sa12[j]*3+1:(sa12[j]-n0)*3+2;\n        if(sa12[j]<n0?\n            Less(s[p],s12[p/3],s[q],s12[n0+sa12[j]]):\n            Less(s[p],s[p+1],s12[n0+p/3],s[q],s[q+1],s12[sa12[j]+1-n0]))\n            sa[k++]=p,i++;\n        else\n            sa[k++]=q,j++;\n    }\n    for(;i<n0;k++,i++)\n        sa[k]=sa0[i];\n    for(;j<n02;k++,j++)\n        sa[k]=sa12[j]<n0?sa12[j]*3+1:(sa12[j]-n0)*3+2;\n}\nvoid KaerkkaeinenSanders(const string& s,vi& sa)\n{\n    KaerkkaeinenSanders<string>(s+string(3,0),sa,127);\n}\nvoid KaerkkaeinenSanders(const char* s,vi& sa)\n{\n    KaerkkaeinenSanders<string>(s+string(3,0),sa,127);\n}\n \n// s[0..n-1] (s[n]=0), sa[0..n-1]\n// lcp[0..n-1] (lcp[i]:s[sa[i-1]..]とs[sa[i]..]のLCP.lcp[0]=0)\ntemplate<typename C>\nvoid LCP(const C& s,const vi& sa,vi& lcp)\n{\n    int n=sa.size();\n    vi rank(n);\n    rep(i,n) rank[sa[i]]=i;\n    for(int i=0,h=0;i<n;i++){\n        if(h>0) h--;\n        if(rank[i]>0)\n            for(int j=sa[rank[i]-1];;h++)\n                if(s[j+h]!=s[i+h]) break;\n        lcp[rank[i]]=h;\n    }\n}\n \nint NextPow2(int x)\n{\n    x--;\n    for(int i=1;i<32;i*=2) x|=x>>i;\n    return x+1;\n}\nconst int I=INF;\nint F(int a,int b){return min(a,b);}\n \nstruct SegmentTree{\n    int size;\n    vi data;\n    SegmentTree(int n):size(NextPow2(n)),data(size*2,I){}\n    SegmentTree(const vi& a):size(NextPow2(a.size())),data(size*2,I){\n        copy(all(a),begin(data)+size);\n        peri(i,1,size) data[i]=F(data[i*2],data[i*2+1]);\n    }\n    int Get(int i){\n        return data[size+i];\n    }\n    void Update(int i,int x){\n        data[size+i]=x;\n        for(i+=size;i/=2;) data[i]=F(data[i*2],data[i*2+1]);\n    }\n    int Query(int a,int b,int i,int l,int r){\n        if(b<=l || r<=a) return I;\n        if(a<=l && r<=b) return data[i];\n        return F(Query(a,b,i*2,l,(l+r)/2),Query(a,b,i*2+1,(l+r)/2,r));\n    }\n    int Query(int a,int b){\n        return Query(a,b,1,0,size);\n    }\n};\n \nint main()\n{\n    for(string s;getline(cin,s) && s!=\"#\";){\n        int n=s.size();\n        vi sa(n),lcp(n);\n        KaerkkaeinenSanders(s,sa);\n        LCP(s,sa,lcp);\n         \n        vi rank(n);\n        rep(i,n) rank[sa[i]]=i;\n         \n        SegmentTree st(lcp);\n        string res;\n        for(int i=1;i<=n;i++){\n            int alen=n-2*i,blen=i-alen;\n            if(alen<=0 || blen<=0) continue;\n            int a1=0,a2=i,a3=2*i;\n            int b1=alen,b2=alen+i;\n            vi ra={rank[0],rank[i],rank[2*i]}; sort(all(ra));\n            vi rb={rank[alen],rank[alen+i]}; sort(all(rb));\n            if(st.Query(ra[0]+1,ra[1])>=alen && st.Query(ra[1]+1,ra[2])>=alen && st.Query(rb[0]+1,rb[1])>=blen){\n                res=s.substr(0,i);\n                break;\n            }\n        }\n        if(res.empty())\n            cout<<\"mitomerarenaiWA\"<<endl;\n        else\n            cout<<\"Love \"<<res<<\"!\"<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP;\n  vector< int > rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size() - 1);\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i]] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    if(k < 0) return (0);\n    return (LCP[k]);\n  }\n\n  int size() const\n  {\n    return (LCP.size() + 1);\n  }\n};\n\nstruct StaticSegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  StaticSegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    };\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(min(a, b), max(a, b), 0, 0, sz));\n  }\n};\n\n\nint main()\n{\n  string S;\n  cin >> S;\n  SuffixArray sa;\n  sa.Build_SA(S);\n  LongestCommonPrefixArray lcp;\n  lcp.Build_LCP(sa);\n  StaticSegmentTree tree(lcp.size());\n  for(int i = 0; i < S.size(); i++) {\n    tree.set(i, lcp[i]);\n  }\n  tree.build();\n\n  int ret = INF;\n  for(int A = 1; A < S.size(); A++) {\n    int B = (int) S.size() - A * 3;\n    if(B <= 0) break;\n    if(B & 1) continue;\n    B /= 2;\n    if(tree.rmq(lcp.rank[0], lcp.rank[A + B]) >= A &&\n       tree.rmq(lcp.rank[0], lcp.rank[A + B + A + B]) >= A &&\n       tree.rmq(lcp.rank[A], lcp.rank[A + B + A]) >= B) {\n      ret = min(ret, A + B);\n    }\n  }\n\n  if(ret >= INF) {\n    cout << \"mitomerarenaiWA\" << endl;\n  } else {\n    cout << \"Love \" << S.substr(0, ret) << \"!\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long Hash;\n\nHash w[1001000];\nHash h[1001000];\nHash inv[1001000];\n\n\nHash bpow(Hash a,Hash b){\n\treturn b?bpow(a*a,b/2)*(b&1?a:1):1;\n}\nHash sub(int a,int b){\n\tif( a == 0 ) return h[b-1];\n\treturn (h[b-1] - h[a-1]) * inv[a];\n}\nint main(){\n\tw[0] = 1;\n\tfor(int i = 1 ; i < 1001000 ; i++) w[i] = w[i-1] * 8999;\n\tinv[0] = 1;\n\tinv[1] = bpow(8999,(1ull<<63)-1);\n\tfor(int i = 2 ; i < 1001000 ; i++) inv[i] = inv[i-1] * inv[1];\n\tstring s;\n\tcin >> s;\n\tint n = s.size();\n\tfor(int i = 0 ; i < n ; i++)\n\t\th[i] = (i?h[i-1]:0) + s[i] * w[i];\n\t\n\tfor(int i = 1 ; i <= n ; i++){\n\t\tif( n / i == 2 && n % i != 0 ){\n\t\t\tint A = n % i;\n\t\t\tint B = i - A;\n\t\t\tif( sub(0,A) == sub(A+B,A+B+A) && sub(0,A) == sub(2*(A+B),2*(A+B)+A) ){\n\t\t\t\tif( sub(A,A+B) == sub(A+B+A,A+B+A+B) ){\n\t\t\t\t\tcout << \"Love \" << s.substr(0,i) << \"!\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tcout << \"mitomerarenaiWA\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct SuffixArray\n{\n  vector< int > SA;\n  string s;\n\n  void Build_SA(const string &str)\n  {\n    s = str;\n    SA.resize(s.size());\n    iota(begin(SA), end(SA), 0);\n    sort(begin(SA), end(SA), [&](const int &a, const int &b)\n    {\n      if(s[a] == s[b]) return (a > b);\n      return (s[a] < s[b]);\n    });\n    vector< int > classes(s.size()), c(s.size()), cnt(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      c[i] = s[i];\n    }\n    for(int len = 1; len < s.size(); len <<= 1) {\n      for(int i = 0; i < s.size(); i++) {\n        if(i > 0 && c[SA[i - 1]] == c[SA[i]] && SA[i - 1] + len < s.size() && c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {\n          classes[SA[i]] = classes[SA[i - 1]];\n        } else {\n          classes[SA[i]] = i;\n        }\n      }\n      iota(begin(cnt), end(cnt), 0);\n      copy(begin(SA), end(SA), begin(c));\n      for(int i = 0; i < s.size(); i++) {\n        int s1 = c[i] - len;\n        if(s1 >= 0) SA[cnt[classes[s1]]++] = s1;\n      }\n      classes.swap(c);\n    }\n  }\n\n  int operator[](int k) const\n  {\n    return (SA[k]);\n  }\n\n  int size() const\n  {\n    return (s.size());\n  }\n\n  bool lt_substr(string &t, int si = 0, int ti = 0)\n  {\n    int sn = s.size(), tn = t.size();\n    while(si < sn && ti < tn) {\n      if(s[si] < t[ti]) return (true);\n      if(s[si] > t[ti]) return (false);\n      ++si, ++ti;\n    }\n    return (si >= sn && ti < tn);\n  }\n\n  int lower_bound(string &t)\n  {\n    int low = -1, high = SA.size();\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    return (high);\n  }\n\n  pair< int, int > lower_upper_bound(string &t)\n  {\n    int idx = lower_bound(t);\n    int low = idx - 1, high = SA.size();\n    t.back()++;\n    while(high - low > 1) {\n      int mid = (low + high) >> 1;\n      if(lt_substr(t, SA[mid])) low = mid;\n      else high = mid;\n    }\n    t.back()--;\n    return (make_pair(idx, high));\n  }\n};\n\nstruct LongestCommonPrefixArray\n{\n  vector< int > LCP;\n  vector< int > rank;\n\n  void Build_LCP(SuffixArray &SA)\n  {\n    string &s = SA.s;\n    rank.resize(s.size());\n    for(int i = 0; i < s.size(); i++) {\n      rank[SA[i]] = i;\n    }\n    LCP.resize(s.size() - 1);\n    for(int i = 0, h = 0; i < s.size(); i++) {\n      if(rank[i] + 1 < s.size()) {\n        for(int j = SA[rank[i] + 1]; max(i, j) + h < s.length() && s[i + h] == s[j + h]; ++h);\n        LCP[rank[i]] = h;\n        if(h > 0) --h;\n      }\n    }\n  }\n\n  int operator[](int k) const\n  {\n    if(k < 0) return (0);\n    return (LCP[k]);\n  }\n\n  int size() const\n  {\n    return (LCP.size() + 1);\n  }\n};\n\nstruct StaticSegmentTree\n{\n  vector< int > seg;\n  int sz;\n\n  StaticSegmentTree(int n)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz - 1, INF);\n  }\n\n  void set(int k, int x)\n  {\n    seg[k + sz - 1] = x;\n  }\n\n  void build()\n  {\n    for(int k = sz - 2; k >= 0; k--) {\n      seg[k] = min(seg[2 * k + 1], seg[2 * k + 2]);\n    };\n  }\n\n  int rmq(int a, int b, int k, int l, int r)\n  {\n    if(a >= r || b <= l) return (INF);\n    if(a <= l && r <= b) return (seg[k]);\n    return (min(rmq(a, b, 2 * k + 1, l, (l + r) >> 1),\n                rmq(a, b, 2 * k + 2, (l + r) >> 1, r)));\n  }\n\n  int rmq(int a, int b)\n  {\n    return (rmq(min(a, b), max(a, b), 0, 0, sz));\n  }\n};\n\n\nint main()\n{\n  string S;\n  cin >> S;\n  SuffixArray sa;\n  sa.Build_SA(S);\n  LongestCommonPrefixArray lcp;\n  lcp.Build_LCP(sa);\n  StaticSegmentTree tree(S.size());\n  for(int i = 0; i < lcp.size(); i++) {\n    tree.set(i, lcp[i - 1]);\n\n    // cout << lcp[i - 1] << \" \" << S.substr(sa[i]) << endl;\n  }\n  tree.build();\n\n  int ret = INF;\n  for(int A = 1; A < S.size(); A++) {\n    int B = (int) S.size() - A * 3;\n    if(B <= 0) break;\n    if(B & 1) continue;\n    B /= 2;\n    if(tree.rmq(lcp.rank[0] + 1, lcp.rank[A + B] + 1) >= A &&\n       tree.rmq(lcp.rank[0] + 1, lcp.rank[A + B + A + B] + 1) >= A &&\n       tree.rmq(lcp.rank[A] + 1, lcp.rank[A + B + A] + 1) >= B) {\n      ret = min(ret, A + B);\n    }\n  }\n\n  if(ret >= INF) {\n    cout << \"mitomerarenaiWA\" << endl;\n  } else {\n    cout << \"Love \" << S.substr(0, ret) << \"!\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define DEBUG(x) cerr << #x << \" = \" << x << endl\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nconst int INF = (int)1e18;\nstruct RMQ {\n\tvector<int> data;\n\tint N;\n\tRMQ(int size) {\n\t\tN = 1;\n\t\twhile(N < size) N *= 2;\n\t\tdata.assign(2*N - 1, INF);\n\t}\n\tvoid update(int k, int a) {\n\t\tk += N - 1;\n\t\tdata[k] = a;\n\t\twhile(k > 0) {\n\t\t\tk = (k - 1)/2;\n\t\t\tdata[k] = min(data[2*k + 1], data[2*k + 2]);\n\t\t}\n\t}\n\tint minimum(int a, int b) {\n\t\treturn minimum_sub(a, b, 0, 0, N);\n\t}\n\tint minimum_sub(int a, int b, int k, int l, int r) {\n\t\tif(r <= a || b <= l) return INF;\n\t\tif(a <= l && r <= b) return data[k];\n\n\t\treturn min(minimum_sub(a, b, 2*k + 1, l, (l + r)/2),\n\t\t\t\tminimum_sub(a, b, 2*k + 2, (l + r)/2, r));\n\t}\n};\n\ntypedef char Alpha;\ntypedef int Index;\ntypedef std::pair<Index, Index> Interval;\n\ntemplate<typename AlphaT>\nstatic void sa_is_countingAlphabets(const AlphaT *str, Index n, int AlphaSize, std::vector<Index> &bucketOffsets, bool b = false) {\n\tif(b || (int)bucketOffsets.size() / 2 >= AlphaSize) {\n\t\tstd::vector<Index>::iterator alphabetCounts =\n\t\t\tb ? bucketOffsets.begin() : bucketOffsets.begin() + AlphaSize;\n\t\tstd::fill(alphabetCounts, alphabetCounts + AlphaSize, 0);\n\t\tfor(Index i = 0; i < n; i ++)\n\t\t\talphabetCounts[(int)str[i]] ++;\n\t}\n}\n\ntemplate<typename AlphaT>\nstatic void sa_is_getBucketOffsets(const AlphaT *str, Index n, bool dir, int AlphaSize, std::vector<Index> &bucketOffsets) {\n\t//AlphaSize?????§????????´?????????bucketOffset?±????????????????alphabet?????°???????????¢??????????°?????????????\n\t//AlphaSize????°?????????´?????????bucketOffset???alphabetCounts??¨??\\?????´?????????????????¨????????????\n\tstd::vector<Index>::iterator alphabetCounts;\n\tif((int)bucketOffsets.size() / 2 < AlphaSize) {\n\t\tsa_is_countingAlphabets(str, n, AlphaSize, bucketOffsets, true);\n\t\talphabetCounts = bucketOffsets.begin();\n\t}else alphabetCounts = bucketOffsets.begin() + AlphaSize;\n\tIndex cumsum = 1;\t//'$'??????\n\tif(dir) {\n\t\tfor(int i = 0; i < AlphaSize; i ++) {\n\t\t\tcumsum += alphabetCounts[i];\n\t\t\tbucketOffsets[i] = cumsum;\n\t\t}\n\t}else {\n\t\tfor(int i = 0; i < AlphaSize; i ++) {\n\t\t\tIndex x = alphabetCounts[i];\n\t\t\tbucketOffsets[i] = cumsum;\n\t\t\tcumsum += x;\n\t\t}\n\t}\n}\n\n\ntemplate<typename AlphaT>\nstatic void sa_is_inducedSort(const AlphaT *str, Index n, int AlphaSize, const std::vector<bool> &types, Index *sa, std::vector<Index> &bucketOffsets) {\n\tsa_is_getBucketOffsets(str, n, false, AlphaSize, bucketOffsets);\n\tfor(Index i = 0; i < n; i ++) {\n\t\tIndex j = sa[i] - 1;\n\t\tif(j >= 0 && !types[j]) sa[bucketOffsets[(int)str[j]] ++] = j;\n\t}\n\n\tsa_is_getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);\n\tfor(Index i = n; i >= 1; i --) {\n\t\tIndex j = sa[i] - 1;\n\t\tif(j >= 0 && types[j]) sa[-- bucketOffsets[(int)str[j]]] = j;\n\t}\n}\n\n//str???[0,n)???????????§???????????????????????????sa???[0,n]?????????\ntemplate<typename AlphaT>\nstatic void sa_is_rec(const AlphaT *str, Index n, int AlphaSize, Index *sa, std::vector<Index> &bucketOffsets) {\n\tstd::vector<bool> types(n+1);\n\ttypes[n-1] = 0; types[n] = 1;\n\tfor(Index i = n-2; i >= 0; i --)\n\t\ttypes[i] = str[i] < str[i+1] || (str[i] == str[i+1] && types[i+1]);\n\n\tsa_is_countingAlphabets(str, n, AlphaSize, bucketOffsets);\n\tsa_is_getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);\n\tstd::fill(sa, sa + n + 1, -1);\n\tfor(Index i = 1; i < n; i ++)\n\t\tif(types[i] && !types[i-1]) sa[-- bucketOffsets[(int)str[i]]] = i;\n\tsa[0] = n;\n\tsa_is_inducedSort(str, n, AlphaSize, types, sa, bucketOffsets);\n\n\tIndex n1 = 0;\n\tfor(Index i = 0; i <= n; i ++) {\n\t\tIndex j = sa[i];\n\t\tif(j > 0 && types[j] && !types[j-1]) sa[n1 ++] = j;\n\t}\n\n\t//LMS substrings????????????????????????sa[0..n1-1]??????????????????????????????\n\t//?????¢???????????????sa???????????????????????????????????¨?????????\n\t//?????????????????§pos???????????§??´??°????????????????????¨?????????????????????\n\t//????????§LMS substring?????£?¶????????????????????????¨???LMS substring?????°???n/2??\\?????§???????????¨????????¨??????????????¨???1??????????????§??????\n\tIndex *buffer = sa + n1;\n\tstd::fill(buffer, sa + n + 1, -1);\n\tIndex uniqueLMSCount = 0, prevPos = -1;\n\tassert(sa[0] == n);\n\tbuffer[sa[0] / 2] = uniqueLMSCount ++;\t//'$'\n\tfor(Index i = 1; i < n1; i ++) {\n\t\tIndex pos = sa[i]; bool diff = false;\n\t\tif(prevPos == -1) diff = true;\n\t\telse for(Index j = pos, k = prevPos; ; j ++, k ++) {\n\t\t\t\tif(str[j] != str[k] || types[j] != types[k]) {\n\t\t\t\t\tdiff = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}else if(j != pos && ((types[j] && !types[j-1]) || (types[k] && !types[k-1])))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tif(diff) {\n\t\t\tuniqueLMSCount ++;\n\t\t\tprevPos = pos;\n\t\t}\n\t\tbuffer[pos / 2] = uniqueLMSCount - 1;\n\t}\n\tfor(Index i = n, j = n; i >= n1; i --)\n\t\tif(sa[i] >= 0) sa[j --] = sa[i];\n\n\tIndex *sa1 = sa, *s1 = sa + n + 1 - n1;\n\tif(uniqueLMSCount == n1)\n\t\tfor(Index i = 0; i < n1; i ++) sa1[s1[i]] = i;\n\telse\n\t\tsa_is_rec<Index>(s1, n1 - 1, uniqueLMSCount, sa1, bucketOffsets);\n\n\tsa_is_countingAlphabets(str, n, AlphaSize, bucketOffsets);\n\tsa_is_getBucketOffsets(str, n, true, AlphaSize, bucketOffsets);\n\tfor(Index i = 1, j = 0; i <= n; i ++)\n\t\tif(types[i] && !types[i-1]) s1[j ++] = i;\n\tfor(Index i = 0; i < n1; i ++) sa1[i] = s1[sa1[i]];\n\tstd::fill(sa + n1, sa + n + 1, -1);\n\tfor(Index i = n1-1; i >= 1; i --) {\n\t\tIndex j = sa[i]; sa[i] = -1;\n\t\tsa[-- bucketOffsets[(int)str[j]]] = j;\n\t}\n\tsa_is_inducedSort(str, n, AlphaSize, types, sa, bucketOffsets);\n}\n\n//suffixArray???(n+1)????????????\nstatic void buildSuffixArray(const Alpha *str, Index n, int AlphaSize, Index *suffixArray) {\n\tif(n == 0) suffixArray[0] = 0;\n\telse {\n\t\t//I = sizeof(Index) * CHAR_BITS ??¨??????\n\t\t//suffixArray + bucketOffsets + types + ??¢??°?????????????????°\n\t\t//= n*I + max(AlphaSize, n/2)*I + 2*n + O(log n) bits\n\t\t//I = 4 * 32??§AlphaSize??????????°?????????¨????????¨:\n\t\t//(6+1/16) * n + O(log n) bytes\n\t\tstd::vector<Index> bucketOffsets(std::max(AlphaSize, (n+1) / 2) + 1);\n\t\tsa_is_rec<Alpha>(str, n, AlphaSize, &suffixArray[0], bucketOffsets);\n\t}\n}\n\nstatic void buildSuffixArray(const Alpha *str, Index n, Index *suffixArray) {\n\tAlpha maxElem = *std::max_element(str, str + n);\n\tassert(maxElem+0 < std::numeric_limits<int>::max());\n\tbuildSuffixArray(str, n, (int)maxElem+1, suffixArray);\n}\n\n\nstruct SuffixArray {\n  int n;\n  vector<int> rsa, lcp, rank;\n  SuffixArray(const string &S, const int *sa) : n(S.size()), rsa(S.size() + 1), lcp(S.size() + 1), rank(S.size() + 1) {\n    {\n      for(int i = 0; i <= n; i++) rank[sa[i]] = i;\n      int h = 0;\n      lcp[0] = 0;\n      for(int i = 0; i < n; i++) {\n        int j = sa[rank[i] - 1];\n        if(h > 0) h--;\n        for(; j + h < n && i + h < n; h++) {\n          if(S[j + h] != S[i + h]) break;\n        }\n        lcp[rank[i] - 1] = h;\n      }\n    }\n    {\n      for(int i = 0; i <= n; ++i) {\n        rsa[sa[i]] = i;\n      }\n    }\n  }\n};\n\nchar CS[1000001];\nint SA[1000001];\n\nsigned main() {\n  scanf(\"%s\", CS);\n  string S(CS);\n  int N = S.size();\n  buildSuffixArray(CS, N, SA);\n  SuffixArray LCP(S, SA);\n  RMQ rmq(N + 1);\n  REP(i,N+1) {\n    rmq.update(i,LCP.lcp[i]);\n  }\n  int ansA = INF, ansB = INF;\n  REP(i,N/2) {\n    int LA = i + 1;\n    int LB = (N - 3 * LA) / 2;\n    if(LB < 1) break;\n    int l, r;\n\n    l = LCP.rsa[0], r = LCP.rsa[N - i - 1];\n    if(l > r) swap(l, r);\n    int lcpA = rmq.minimum(l, r);\n\n    l = LCP.rsa[LA], r = LCP.rsa[LA + LB + LA];\n    if(l > r) swap(l, r);\n    int lcpB = rmq.minimum(l, r);\n    // DEBUG(LA);\n    // DEBUG(lcpA);\n    // DEBUG(LB);\n    // DEBUG(lcpB);\n    if(lcpA == INF || lcpB == INF) continue;\n    if(lcpA >= LA && lcpB >= LB) {\n      if(LA + LB < ansA + ansB) {\n        ansA = LA;\n        ansB = LB;\n      }\n    }\n  }\n  if(ansA == INF && ansB == INF) {\n    cout << \"mitomerarenaiWA\" << endl;\n  }\n  else {\n    cout << \"Love \" << S.substr(0, ansA) << S.substr(ansA, ansB) << \"!\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nclass RollingHash{\nprivate:\n    int M = 1e9+7;\n    int base = 1213;\n    string str;\n    int n;\n    vector<int> pow,sum;\n\n    void build(){\n        n = str.size();\n        sum = pow = vector<int> (n+1);\n        sum[0] = 0;\n        pow[0] = 1;\n        for(int i = 0; i < n; i++){\n            sum[i+1] = (str[i] + sum[i] * base) % M;\n            pow[i+1] = pow[i] * base % M;\n        }\n    }\n\n\npublic:\n    RollingHash(){}\n    RollingHash(string in){\n        str = in;\n        build();\n    }\n    RollingHash(string in, int p, int mod){\n        M = mod;\n        base = p;\n        str = in;\n        build();\n    }\n\n    int calc(int l, int r){//[l,r)のハッシュ値を計算\n        int len = r - l;\n        int ret = sum[r] + M;\n        ret -= sum[l] * pow[len] % M;\n        return ret % M;\n    }\n\n};\n\n\n\n\nsigned main(void) {\n    char in[2000000];\n    scanf(\"%s\",in);\n    string s = string(in);\n    RollingHash rh(s);\n    int n = s.size();\n    int ans = INF;\n    loop(a,1,n){\n        if(a*3 >= n)continue;\n        int b = (n - a * 3)/2;\n        if(a*3 + 2*b != n)continue;\n        //A = [0,a), [a+b,2*a+b), [2*a+2*b,n)\n        //B = [a,a+b), [2*a+b,2*a+2*b)\n        bool c = true;\n        if(rh.calc(0,a) != rh.calc(a+b,2*a+b)) c = false;\n        if(rh.calc(0,a) != rh.calc(2*a+2*b,n)) c = false;\n        if(rh.calc(a,a+b) != rh.calc(2*a+b,2*a+2*b)) c = false;\n        if(c && a+b < ans)ans = a+b;\n    }\n    if(ans == INF){\n        cout << \"mitomerarenaiWA\" << endl;\n    }else{\n        cout << \"Love \";\n        rep(i,ans)printf(\"%c\",in[i]);\n        cout << \"!\" << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstring solve(string s){\n  int i, j;\n  bool is = false;\n  string res = \"mitomerarenaiWA\", a1, a2, a3, b1, b2;\n  for(i = 1;;++i)if(s.size() % 2 == i % 2){\n    if(i + i + i >= s.size())break;\n    j = s.size() - i - i - i; j >>= 1;\n    a1 = s.substr(0, i);\n    b1 = s.substr(i, j);\n    a2 = s.substr(i + j, i);\n    b2 = s.substr(i + j + i, j);\n    a3 = s.substr(i + j + i + j, i);\n    if(a1 == a2 && a2 == a3 && b1 == b2){\n      res = a1 + b1;\n      is = true;\n    }\n  }\n  if(is)return \"Love \" + res + \"!\";\n  return res;\n}\n\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    string s; cin >> s;\n    cout << solve(s) << endl;\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n//Roling Hash\n//RollingHash RH(s,base) base:[2,MOD)?????±??°\n//RH.set(s,base): vector???????§???????????????????????????§????????????????????????????????????\n//RH.get(l,r): [l,r)??????????????\\ O(1)\n//1000000007, 1000000009, 1000000021\ntemplate<long long MOD>\nclass RollingHash {\npublic:\n\tint n;\n\tlong long base;\n\tvector<long long> pow, hash;\n\tRollingHash() {}\n\tRollingHash(const string &s, long long base_ = 10007) { init(s, base_); }\n\tvoid init(const string &s, long long base_ = 10007) {\n\t\tn = s.size();\n\t\tbase = base_;\n\t\tcalc(s.c_str());\n\t}\n\tlong long get(int x)const { return hash[x]; }\n\tlong long get(int l, int r)const { return (get(r) - get(l)*pow[r - l] % MOD + MOD) % MOD; }\n\tvoid calc(const char *s) {\n\t\tpow.resize(n + 1);\n\t\tpow[0] = 1;\n\t\thash.resize(n + 1);\n\t\thash[0] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpow[i + 1] = pow[i] * base % MOD;\n\t\t\thash[i + 1] = (s[i] + hash[i] * base) % MOD;\n\t\t}\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tstring s; cin >> s;\n\tRollingHash<1000000007> RH(s);\n\tint n = s.size(); //???????????¨Runtime Error\n\tfor (int a = (n - 2) / 3, b; a >= 1; a--) {\n\t\tb = (n - a * 3) / 2;\n\t\tif (3 * a + 2 * b != n)continue;\n\t\tif (RH.get(0, a) == RH.get(a + b, a + b + a)\n\t\t\t&& RH.get(0, a) == RH.get(a + b + a + b, a + b + a + b + a)\n\t\t\t&& RH.get(a, a + b) == RH.get(a + b + a, a + b + a + b)) {\n\t\t\tcout << \"Love \" << s.substr(0, a + b) << \"!\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout << \"mitomerarenaiWA\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nvoid z_algorithm(string& S,vector<int>& res)\n{\n    int sz = (int)S.size();\n    res.resize(sz);\n    int c = 0;\n    for(int i = 1; i < sz; i++){\n        if(i+res[i-c] < c+res[c]){\n            res[i] = res[i-c];\n        }else{\n            int j = max(0, c+res[c]-i);\n            while (i+j < sz && S[j] == S[i+j]) ++j;\n            res[i] = j;\n        }\n    }\n    res[0] = sz;\n}\n\nint main(){\n    string s;\n    getline(cin,s);\n    int n = s.size();\n    vector<int> a,b;\n    z_algorithm(s,a);\n    reverse(s.begin(),s.end());\n    z_algorithm(s,b);\n    reverse(s.begin(),s.end());\n    int ma = -1;\n    for(int i=n/3-2;i<n/2+2;i++){\n        if(i<0||i>n)continue;\n        if(a[i]==n-i&&b[i]==n-i&&n-2*i>0&&(n-3*(n-2*i))/2>0){\n            ma = max(ma,n-2*i);\n        }\n    }\n    // for(int i=0;i<n;i++){\n    //     cout << a[i] << \" \";\n    // }\n    // cout << endl;\n    // for(int i=0;i<n;i++){\n    //     cout << b[i] << \" \";\n    // }\n    // cout << endl;\n    \n    if(ma==-1){\n        cout << \"mitomerarenaiWA\" << endl;\n    }else{\n        int x = ma;\n        int y = (n-3*ma)/2;\n        printf(\"Love \");\n        for(int i=0;i<x+y;i++){\n            printf(\"%c\",s[i]);\n        }\n        printf(\"!\\n\");\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 1000001\nusing ull = unsigned long long;\nusing P = tuple<int, int, int>;\n\nconst ull b = 1000000007ULL;\n\nvector<ull> rolling_hash(char* S, int N, vector<ull>& p)\n{\n    vector<ull> h(N + 1);\n    for (int i = 0; i < N; i++) {\n        h[i + 1] = h[i] * b + S[i];\n        p[i + 1] = p[i] * b;\n    }\n    return h;\n}\n\nint main()\n{\n    char S[MAX];\n    scanf(\"%s\", S);\n    \n    int N = strlen(S);\n    vector<ull> p(N + 1);\n    p[0] = 1;\n    \n    bool found = 0;\n    auto h = rolling_hash(S, N, p);    \n    \n    vector<P> v;\n    for (int i = 0; i < N; i++) {\n        int A = i + 1;\n        int B = (N - 3 * A) / 2;\n\n        if (B <= 0) continue;\n        if ((N - 3 * A) % 2 != 0) continue;\n\n        auto A1 = h[A] - h[0] * p[A];\n        auto B1 = h[A + B] - h[A] * p[B];\n        auto A2 = h[A * 2 + B] - h[A + B] * p[A];\n        auto B2 = h[2 * (A + B)] - h[A * 2 + B] * p[B];\n        auto A3 = h[N] - h[2 * (A + B)] * p[A];\n\n        if (A1 == A2 && A2 == A3 && B1 == B2) {\n            found = 1;\n            v.emplace_back(A + B, A, B);\n        }\n    }\n\n    sort(v.begin(), v.end());\n    \n    if (!found) {\n        printf(\"mitomerarenaiWA\\n\");\n    } else {\n        printf(\"Love \");\n        int size = get<0>(v[0]);\n        for (int i = 0; i < size; i++) {\n            printf(\"%c\", S[i]);\n        }\n        printf(\"!\\n\");\n    }        \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std::literals::string_literals;\nusing i64 = std::int_fast64_t;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\nusing std::cin;\n\ntemplate<typename T>\nstd::vector<T> make_v(size_t a){return std::vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n#include <vector>\n#include <string>\n\nclass rolling_hash {\npublic:\n\tusing u64 = std::uint_fast64_t;\n\tusing size_type = std::uint_fast32_t;\n\n\tstatic constexpr u64 MOD = (1uL << 61) - 1;\n\tstatic constexpr u64 base = 20200213;\n\n\tstd::string str;\n\tstd::vector<u64> hash_, pow;\n\nprivate:\n\tstatic constexpr u64 mask30 = (1ul << 30) - 1;\n\tstatic constexpr u64 mask31 = (1ul << 31) - 1;\n\n\tu64 mul(u64 a, u64 b) const {\n\t\tu64 au = a >> 31;\n\t\tu64 ad = a & mask31;\n\t\tu64 bu = b >> 31;\n\t\tu64 bd = b & mask31;\n\t\tu64 mid = ad * bu + au * bd;\n\t\tu64 midu = mid >> 30;\n\t\tu64 midd = mid & mask30;\n\t\treturn apply(au * bu * 2 + midu + (midd << 31) + ad * bd);\n\t}\n\tu64 apply(u64 val) const {\n\t\tval = (val & MOD) + (val >> 61);\n\t\tif(val >= MOD) val -= MOD;\n\t\treturn val;\n\t}\n\tsize_type xorshift(size_type x) const {\n\t\tx ^= x << 13;\n\t\tx ^= x >> 17;\n\t\tx ^= x << 5;\n\t\treturn x;\n\t}\n\npublic:\n\trolling_hash(const rolling_hash &) = default;\n\trolling_hash(rolling_hash&&) = default;\n\n\trolling_hash() : str() {};\n\trolling_hash(const std::string & str) : str(str) {\n\t\thash_.resize(str.size() + 1, 0);\n\t\tpow.resize(str.size() + 1, 1);\n\t\tfor(size_type i = 0; i < str.size(); i++) {\n\t\t\thash_[i + 1] = mul(hash_[i], base) + xorshift(str[i] + 1);\n\t\t\tpow[i + 1] = mul(pow[i], base);\n\t\t\tif(hash_[i + 1] >= MOD) hash_[i + 1] -= MOD;\n\t\t}\n\t}\n\n\tu64 hash() const { return hash_.back(); }\n\tu64 hash(size_type l, size_type r) const {\n\t\tu64 ret = MOD + hash_[r] - mul(hash_[l], pow[r - l]);\n\t\treturn ret < MOD ? ret : ret - MOD;\n\t}\n\t\n\tsize_type size() const { return str.size(); }\n};\n\nint main() {\n\tstd::string s; cin >> s;\n\n\trolling_hash hash(s);\n\tfor(int i = (int)s.size(); i > 0; i--) {\n\t\tint A = i;\n\t\tint B = (int)s.size() - 3 * A;\n\t\tif(A <= 0 or B <= 0 or B & 1) continue; B /= 2;\n\n\t\ti64 X = hash.hash(0, A);\n\t\ti64 Y = hash.hash(A, A + B);\n\t\tif(X != hash.hash(A + B, A + B + A)) continue;\n\t\tif(Y != hash.hash(A + B + A, A + B + A + B)) continue;\n\t\tif(X != hash.hash(A + B + A + B, A + B + A + B + A)) continue;\n\n\t\tprintf(\"Love %s!\\n\", s.substr(0, A + B).c_str());\n\t\treturn 0;\n\t}\n\tprintf(\"mitomerarenaiWA\\n\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nclass RollingHash\n{\nprivate:\n    static const int X[], Y[], M[];\n    deque<char> dq;\n    long long xp[3];\n    long long hash[3];\npublic:\n    RollingHash(){\n        for(int i=0; i<3; ++i){\n            xp[i] = 1;\n            hash[i] = 0;\n        }\n    }\n    void push_back(char c){\n        dq.push_back(c);\n        for(int i=0; i<3; ++i){\n            hash[i] *= X[i];\n            hash[i] += c;\n            hash[i] %= M[i];\n            xp[i] *= X[i];\n            xp[i] %= M[i];\n        }\n    }\n    void pop_back(){\n        for(int i=0; i<3; ++i){\n            hash[i] += M[i] - dq.back();\n            hash[i] *= Y[i];\n            hash[i] %= M[i];\n            xp[i] *= Y[i];\n            xp[i] %= M[i];\n        }\n        dq.pop_back();\n    }\n    void push_front(char c){\n        dq.push_front(c);\n        for(int i=0; i<3; ++i){\n            hash[i] += c * xp[i];\n            hash[i] %= M[i];\n            xp[i] *= X[i];\n            xp[i] %= M[i];\n        }\n    }\n    void pop_front(){\n        for(int i=0; i<3; ++i){\n            xp[i] *= Y[i];\n            xp[i] %= M[i];\n            hash[i] -= dq.front() * xp[i];\n            hash[i] %= M[i];\n            if(hash[i] < 0)\n                hash[i] += M[i];\n        }\n        dq.pop_front();\n    }\n    bool operator==(const RollingHash& rh){\n        for(int i=0; i<3; ++i){\n            if(hash[i] != rh.hash[i])\n                return false;\n        }\n        return true;\n    }\n    bool operator!=(const RollingHash& rh){\n        return !(*this == rh);\n    }\n};\nconst int RollingHash::X[] = {2000000011, 2000000033, 2000000063}; // 素数\nconst int RollingHash::Y[] = {1447368484, 1178571481, 1277777841}; // X * Y == 1 (mod M)\nconst int RollingHash::M[] = {2000000087, 2000000089, 2000000099}; // 合同式の法（素数）\n\nstring solve(const string& s)\n{\n    int n = s.size();\n    if(n < 5)\n        return \"\";\n\n    vector<int> v(6);\n    v[0] = 0;\n    v[2] = (n + 3) / 3;\n    v[4] = v[2] * 2;\n    v[1] = n - v[4];\n    v[3] = v[2] + v[1];\n    v[5] = n;\n    vector<int> d = {0, -2, 1, -1, 2, 0};\n\n    vector<RollingHash> rh(5);\n    for(int i=0; i<5; ++i){\n        for(int j=v[i]; j<v[i+1]; ++j){\n            rh[i].push_back(s[j]);\n        }\n    }\n\n    for(;;){\n        bool ok = true;\n        for(int i=0; i<3; ++i){\n            if(rh[i] != rh[i+2])\n                ok = false;\n        }\n        if(ok)\n            return s.substr(0, v[2]);\n\n        if(v[1] < 2)\n            break;\n\n        for(int i=1; i<5; ++i){\n            if(d[i] > 0){\n                for(int j=0; j<d[i]; ++j){\n                    rh[i-1].push_back(s[v[i]]);\n                    rh[i].pop_front();\n                    ++ v[i];\n                }\n            }\n            else{\n                for(int j=0; j<-d[i]; ++j){\n                    rh[i-1].pop_back();\n                    rh[i].push_front(s[v[i]-1]);\n                    -- v[i];\n                }\n            }\n        }\n    }\n\n    return \"\";\n}\n\nint main()\n{\n    string s;\n    cin >> s;\n\n    string ans = solve(s);\n    if(ans == \"\")\n        cout << \"mitomerareniWA\" << endl;\n    else\n        cout << \"Love \" << ans << '!' << endl;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2763: Miko Mi String\n// 2017.10.9 bal4u@uu\n\n#include <stdio.h>\n\nchar s[1000005];\nint a[1000005];\n\nint main()\n{\n\tint n, i, j, w;\n\tchar *p;\n\n\tscanf(\"%s\", s);\n\ta[0] = -1, j = -1;\n\tfor (p = s, i = 0; *p; i++, p++) {\n\t\twhile (j >= 0 && *p != s[j]) j = a[j];\n\t\ta[i+1] = ++j;\n\t}\n\tn = i;\n\t\n\tj = n - a[n];\n\tw = j * (n / (3 * j) + 1);\n\tif (w > 0 && w * 2 < n) { s[w] = 0; printf(\"Love %s!\\n\", s); }\n\telse puts(\"mitomerarenaiWA\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\ntypedef unsigned long long ull;\nconst ull B = 1e9+7;\nchar s[1111111];\nint len;\null a[1111111];\null h[1111111];\null Bh[1111111];\nint main(void) {\n\tint res = -1;\n\t int i,al,bl;\n  scanf(\"%s\", s);\n  len = strlen(s);\n  Bh[0] = 1;\n\n   for (i = 0; i < len; i++) {\n     h[i+1] = h[i]*B + s[i];\n     Bh[i+1] = Bh[i]*B;\n   }\n\n   for (i = 1; i*3 < len; i++) {\n     if ((len - i*3)%2 != 0 || len - i*3 <= 0) continue;\n     al = i;\n     bl = (len - i*3)/2;\n     if (h[al] == h[al+bl + al]-h[al+bl]*Bh[al] &&\n         h[al+bl + al]-h[al+bl]*Bh[al] == h[al*2+bl*2+al]-h[al*2+bl*2]*Bh[al] &&\n         h[al+bl]-h[al]*Bh[bl] == h[al*2+bl + bl]-h[al*2+bl]*Bh[bl]) {\n       if (res == -1 || res > al+bl) {\n         res = al+bl;\n       }\n     }\n      }\n\n      if (res < 0) {\n        puts(\"mitomerarenaiWA\");\n      } else {\n        printf(\"Love \");\n        for (int i = 0; i < res; i++) {\n          printf(\"%c\", s[i]);\n        }\n        puts(\"!\");\n      }\n      return 0;\n}"
  },
  {
    "language": "C",
    "code": "char s[1<<20];m[1<<20],n,t;main(){for(gets(s);s[n];m[++n]=--t)for(;t&&s[~t]-s[n];t=m[~t]);t-=~n;n=!printf(t*2<n?\"Love %.*s!\\n\":\"mitomerarenaiWA\\n\",t*=n/3/t+1,s);}"
  },
  {
    "language": "C",
    "code": "char s[1<<20];m[1<<20],n,t;main(){for(gets(s);s[n];m[++n]=--t)for(;t&&s[~t]-s[n];t=m[~t]);t-=~n;n=!printf(t*2<n?\"Love %.*s!\\n\":\"mitomerarenaiWA\\n\",t*=n/3/t+1,s);}"
  },
  {
    "language": "C",
    "code": "/*\nC language 162bytes\n\nchar s[1<<20];m[1<<20],n,t;main(){for(gets(s);s[n];m[++n]=--t)for(;t&&s[~t]-s[n];t=m[~t]);t-=~n;n=!printf(t*2<n?\"Love %.*s!\\n\":\"mitomerarenaiWA\\n\",t*=n/3/t+1,s);}\n*/\n\n\n#include <stdio.h>\n#include <string.h>\n\nchar s[1000010];\nint mp[1000010];\n\nint main(){\n\tint i, n, t, p, q = 0;\n\n\tfgets(s, sizeof(s), stdin);\n\tn = strlen(s) - 1;\n\n\tmp[0] = -1;\n\tt = -1;\n\tfor(i = 0; i < n; ++i){\n\t\twhile(t >= 0 && s[t] != s[i]){\n\t\t\tt = mp[t];\n\t\t}\n\t\tmp[i + 1] = ++t;\n\t}\n\t\n\tp = n - mp[n];\n\tif(p > 0){\n\t\tq = p * (n / (3 * p) + 1);\n\t\tif(q * 2 >= n){\n\t\t\tq = 0;\n\t\t}\n\t}\n\n\tif(q != 0){\n\t\tprintf(\"Love %.*s!\\n\", q, s);\n\t}\n\telse{\n\t\tputs(\"mitomerarenaiWA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "char s[1<<20];m[1<<20]={1},n;main(t){for(gets(s);s[n];m[++n]=--t)for(;t<1&&s[-t]-s[n];t=m[-t]);t+=n;n=!printf(t*2<n?\"Love %.*s!\\n\":\"mitomerarenaiWA\\n\",t*=n/3/t+1,s);}"
  },
  {
    "language": "C",
    "code": "char s[1<<20];m[1<<20],n,t;main(){for(gets(s);s[n];m[++n]=--t)for(;t&&s[~t]-s[n];t=m[~t]);n=!printf(t*2<n?\"Love %.*s!\\n\":\"mitomerarenaiWA\\n\",(t-=~n)+n/3/t*t,s);}"
  },
  {
    "language": "C",
    "code": "har s[1<<20];m[1<<20],n,t;main(){for(gets(s);s[n];m[++n]=--t)for(;t&&s[~t]-s[n];t=m[~t]);n=!printf(t*2<n?\"Love %.*s!\\n\":\"mitomerarenaiWA\\n\",(t-=~n)+n/3/t*t,s);}"
  },
  {
    "language": "C",
    "code": "/*\nC language 162bytes\n\nchar s[1<<20];m[1<<20],n,t;main(){for(gets(s);s[n];m[++n]=--t)for(;t&&s[~t]-s[n];t=m[~t]);t-=~n;n=!printf(t*2<n?\"Love %.*s!\\n\":\"mitomerarenaiWA\\n\",t*=n/3/t+1,s);}\n*/\n\n\n#include <stdio.h>\n#include <string.h>\n\nchar s[1000010];\nint mp[1000010];\n\nint main(){\n\tint i, n, t, p, q = 0;\n\n\tfgets(s, sizeof(s), stdin);\n\tn = strlen(s) - 1;\n\n\tmp[0] = -1;\n\tt = -1;\n\tfor(i = 0; i < n; ++i){\n\t\twhile(t >= 0 && s[t] != s[i]){\n\t\t\tt = mp[t];\n\t\t}\n\t\tmp[i + 1] = ++t;\n\t}\n\t\n\tp = n - mp[n];\n\tq = p * (n / (3 * p) + 1);\n\tif(q * 2 >= n){\n\t\tq = 0;\n\t}\n\n\tif(q != 0){\n\t\tprintf(\"Love %.*s!\\n\", q, s);\n\t}\n\telse{\n\t\tputs(\"mitomerarenaiWA\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "char s[1<<20];m[1<<20],n;main(t){t=--*m;for(gets(s);s[n];m[++n]=++t)for(;~t&&s[t]-s[n];t=m[t]);t=n-t;printf(t*2<n?\"Love %.*s!\\n\":\"mitomerarenaiWA\\n\",t*=n/3/t+1,s);}"
  },
  {
    "language": "C",
    "code": "char s[1<<20];m[1<<20],n;main(t){t=--*m;for(gets(s);s[n];m[++n]=++t)for(;~t&&s[t]-s[n];t=m[t]);t=n-t;n=!printf(t*2<n?\"Love %.*s!\\n\":\"mitomerarenaiWA\\n\",t*=n/3/t+1,s);}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tString s = sc.next();\n\t\tint N = s.length();\n\t\tRollingHash rh = new RollingHash();\n\t\trh.init(s);\n\t\tint ans = Integer.MAX_VALUE;\n\t\tString res = \"mitomerarenaiWA\";\n\t\tint l = 0;\n\t\tint r = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint t = N - (i + 1) * 3;\n\t\t\tif (t > 0 && t % 2 == 0) {\n\t\t\t\tint A = i + 1;\n\t\t\t\tint B = t / 2;\n\t\t\t\tlong a1 = rh.getHash2(0, A - 1);\n\t\t\t\tlong b1 = rh.getHash2(A, A + B - 1);\n\t\t\t\tlong a2 = rh.getHash2(A + B, A + B + A - 1);\n\t\t\t\tlong b2 = rh.getHash2(A + B + A, A + B + A + B - 1);\n\t\t\t\tlong a3 = rh.getHash2(A + B + A + B, N - 1);\n\t\t\t\tif (a1 == a2 && a2 == a3 && b1 == b2) {\n\t\t\t\t\tans = Math.min(ans, i + t);\n\t\t\t\t\tl = A;\n\t\t\t\t\tr = B;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (l != 0 && r != 0) res = \"Love \" + s.substring(0, l) + s.substring(l, l + r) + \"!\";\n\t\tSystem.out.println(res);\n\t}\n\n\tpublic class RollingHash {\n\n\t\tString S;\n\t\tint N, l, r;\n\n\t\tlong B1 = 1007;\n\t\tlong B2 = 1009;\n\t\tlong H1 = 1000000007;\n\t\tlong H2 = 1000000009;\n\n\t\tlong[] Base1, Base2;\n\t\tlong[] Hash1, Hash2;\n\n\t\tvoid init(String s) {\n\t\t\tS = s;\n\t\t\tN = s.length();\n\t\t\tl = 0;\n\t\t\tr = s.length() - 1;\n\t\t\tBase1 = new long[N + 1];\n\t\t\tBase2 = new long[N + 1];\n\t\t\tHash1 = new long[N];\n\t\t\tHash2 = new long[N];\n\n\t\t\tBase1[0] = Base2[0] = 1;\n\t\t\tHash1[0] = Hash2[0] = s.charAt(0);\n\t\t\tfor (int i = 1; i <= N; i++) Base1[i] = (Base1[i - 1] * B1) % H1;\n\t\t\tfor (int i = 1; i <= N; i++) Base2[i] = (Base2[i - 1] * B2) % H2;\n\t\t\tfor (int i = 1; i < N; i++) Hash1[i] = (Hash1[i - 1] * B1 + s.charAt(i)) % H1;\n\t\t\tfor (int i = 1; i < N; i++) Hash2[i] = (Hash2[i - 1] * B2 + s.charAt(i)) % H2;\n\t\t}\n\n\t\t/*\n\t\t * S(this)???T??????????????????(?????¬??????RollingHash)\n\t\t */\n\t\tboolean contain1(String T) {\n\t\t\tint sl = S.length();\n\t\t\tint tl = T.length();\n\t\t\tif (tl > sl) return false;\n\n\t\t\tlong b = 1;\n\t\t\tfor (int i = 0; i < tl; i++) b = (b * B1) % H1;\n\n\t\t\tlong sh = 0;\n\t\t\tlong th = 0;\n\t\t\tfor (int i = 0; i < tl; i++) sh = (sh * B1 + (S.charAt(i))) % H1;\n\t\t\tfor (int i = 0; i < tl; i++) th = (th * B1 + (T.charAt(i))) % H1;\n\n\t\t\tfor (int i = 0; i + tl <= sl; i++) {\n\t\t\t\tif (sh == th) return true;\n\t\t\t\tif (i + tl < sl) sh = sh * B1 - (S.charAt(i)) * b + (S.charAt(i + tl));\n\t\t\t\tsh = (sh + H1) % H1;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean contain2(String T) {\n\t\t\tint sl = N;\n\t\t\tint tl = T.length();\n\t\t\tif (tl > sl) return false;\n\n\t\t\tlong th = 0;\n\t\t\tfor (int i = 0; i < tl; i++) th = (th * B1 + (T.charAt(i))) % H1;\n\n\t\t\tr = tl - 1;\n\t\t\tl = 0;\n\t\t\tfor (; r < N; r++, l++) {\n\t\t\t\tif (getHash1() == th) return true;\n\t\t\t}\n\t\t\tl = 0;\n\t\t\tr = S.length() - 1;\n\t\t\treturn false;\n\t\t}\n\n\t\tlong getHash1() {\n\t\t\tlong res = Hash1[r] - ((l == 0) ? 0 : Hash1[l - 1] * Base1[r - l + 1]);\n\t\t\tif (res < 0) res = (res + ((-res / H1) + 1) * H1) % H1;\n\t\t\treturn res;\n\t\t}\n\n\t\tlong getHash1(int l, int r) {\n\t\t\tlong res = Hash1[r] - ((l == 0) ? 0 : Hash1[l - 1] * Base1[r - l + 1]);\n\t\t\tif (res < 0) res = (res + ((-res / H1) + 1) * H1) % H1;\n\t\t\treturn res;\n\t\t}\n\n\t\tlong getHash2() {\n\t\t\tlong res = Hash2[r] - ((l == 0) ? 0 : Hash2[l - 1] * Base2[r - l + 1]);\n\t\t\tif (res < 0) res = (res + ((-res / H2) + 1) * H2) % H2;\n\t\t\treturn res;\n\t\t}\n\n\t\tlong getHash2(int l, int r) {\n\t\t\tlong res = Hash2[r] - ((l == 0) ? 0 : Hash2[l - 1] * Base2[r - l + 1]);\n\t\t\tif (res < 0) res = (res + ((-res / H2) + 1) * H2) % H2;\n\t\t\treturn res;\n\t\t}\n\n\t\tvoid show() {\n\t\t\tSystem.out.println(\"---------show---------\");\n\t\t\tSystem.out.println(\"String = \" + S.substring(l, r + 1));\n\t\t\tSystem.out.println(\"l = \" + l + \" r = \" + r);\n\t\t\tSystem.out.println(\"Hash1 = \" + getHash1() + \" Hash2 = \" + getHash2());\n\t\t\tSystem.out.println(\"----------------------\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (k <= a[i])\n\tint lower_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k <= a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\t// find minimum i (k < a[i])\n\tint upper_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k < a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tlong gcd(long a, long b) {\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\n\t}\n\n\tlong lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\nimport vol_024.AOJ_2444.RollingHash;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tString s = sc.next();\n\t\tint N = s.length();\n\t\tRollingHash rh = new RollingHash();\n\t\trh.init(s);\n\t\tint ans = Integer.MAX_VALUE;\n\t\tString res = \"\";\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint t = N - (i + 1) * 3;\n\t\t\tif (t > 0 && t % 2 == 0) {\n\t\t\t\tint A = i + 1;\n\t\t\t\tint B = t / 2;\n\t\t\t\tlong a1, a2, a3, b1, b2;\n\t\t\t\ta1 = a2 = a3 = b1 = b2 = 0;\n\t\t\t\trh.l = 0;\n\t\t\t\trh.r = A - 1;\n\t\t\t\ta1 = rh.getHash1();\n\t\t\t\trh.l = A;\n\t\t\t\trh.r = A + B - 1;\n\t\t\t\tb1 = rh.getHash1();\n\t\t\t\trh.l = A + B;\n\t\t\t\trh.r = A + B + A - 1;\n\t\t\t\ta2 = rh.getHash1();\n\t\t\t\trh.l = A + B + A;\n\t\t\t\trh.r = A + B + A + B - 1;\n\t\t\t\tb2 = rh.getHash1();\n\t\t\t\trh.l = A + B + A + B;\n\t\t\t\trh.r = A + B + A + B + A - 1;\n\t\t\t\ta3 = rh.getHash1();\n\t\t\t\tif (a1 == a2 && a2 == a3 && b1 == b2) {\n\t\t\t\t\tans = Math.min(ans, i + t);\n\t\t\t\t\tres = s.substring(0, A) + s.substring(A, A + B);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res.isEmpty() ? \"mitomerarenaiWA\" : \"Love \" + res + \"!\");\n\t}\n\n\tpublic class RollingHash {\n\n\t\tString S;\n\t\tint N, l, r;\n\n\t\tlong B1 = 1007;\n\t\tlong B2 = 1009;\n\t\tlong H1 = 1000000007;\n\t\tlong H2 = 1000000009;\n\n\t\tlong[] Base1, Base2;\n\t\tlong[] Hash1, Hash2;\n\n\t\tvoid init(String s) {\n\t\t\tS = s;\n\t\t\tN = s.length();\n\t\t\tl = 0;\n\t\t\tr = s.length() - 1;\n\t\t\tBase1 = new long[N + 1];\n\t\t\tBase2 = new long[N + 1];\n\t\t\tHash1 = new long[N];\n\t\t\tHash2 = new long[N];\n\n\t\t\tBase1[0] = Base2[0] = 1;\n\t\t\tHash1[0] = Hash2[0] = s.charAt(0);\n\t\t\tfor (int i = 1; i <= N; i++)\n\t\t\t\tBase1[i] = (Base1[i - 1] * B1) % H1;\n\t\t\tfor (int i = 1; i <= N; i++)\n\t\t\t\tBase2[i] = (Base2[i - 1] * B2) % H2;\n\t\t\tfor (int i = 1; i < N; i++)\n\t\t\t\tHash1[i] = (Hash1[i - 1] * B1 + s.charAt(i)) % H1;\n\t\t\tfor (int i = 1; i < N; i++)\n\t\t\t\tHash2[i] = (Hash2[i - 1] * B2 + s.charAt(i)) % H2;\n\t\t}\n\n\t\t/*\n\t\t * S(this)???T??????????????????(?????¬??????RollingHash)\n\t\t */\n\t\tboolean contain1(String T) {\n\t\t\tint sl = S.length();\n\t\t\tint tl = T.length();\n\t\t\tif (tl > sl)\n\t\t\t\treturn false;\n\n\t\t\tlong b = 1;\n\t\t\tfor (int i = 0; i < tl; i++)\n\t\t\t\tb = (b * B1) % H1;\n\n\t\t\tlong sh = 0;\n\t\t\tlong th = 0;\n\t\t\tfor (int i = 0; i < tl; i++)\n\t\t\t\tsh = (sh * B1 + (S.charAt(i))) % H1;\n\t\t\tfor (int i = 0; i < tl; i++)\n\t\t\t\tth = (th * B1 + (T.charAt(i))) % H1;\n\n\t\t\tfor (int i = 0; i + tl <= sl; i++) {\n\t\t\t\tif (sh == th)\n\t\t\t\t\treturn true;\n\t\t\t\tif (i + tl < sl)\n\t\t\t\t\tsh = sh * B1 - (S.charAt(i)) * b + (S.charAt(i + tl));\n\t\t\t\tsh = (sh + H1) % H1;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean contain2(String T) {\n\t\t\tint sl = N;\n\t\t\tint tl = T.length();\n\t\t\tif (tl > sl)\n\t\t\t\treturn false;\n\n\t\t\tlong th = 0;\n\t\t\tfor (int i = 0; i < tl; i++)\n\t\t\t\tth = (th * B1 + (T.charAt(i))) % H1;\n\n\t\t\tr = tl - 1;\n\t\t\tl = 0;\n\t\t\tfor (; r < N; r++, l++) {\n\t\t\t\tif (getHash1() == th)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tl = 0;\n\t\t\tr = S.length();\n\t\t\treturn false;\n\t\t}\n\n\t\tlong getHash1() {\n\t\t\tlong res = Hash1[r] - ((l == 0) ? 0 : Hash1[l - 1] * Base1[r - l + 1]);\n\t\t\tif (res < 0)\n\t\t\t\tres = (res + ((-res / H1) + 1) * H1) % H1;\n\t\t\treturn res;\n\t\t}\n\n\t\tlong getHash2() {\n\t\t\tlong res = Hash2[r] - ((l == 0) ? 0 : Hash2[l - 1] * Base2[r - l + 1]);\n\t\t\tif (res < 0)\n\t\t\t\tres = (res + ((-res / H2) + 1) * H2) % H2;\n\t\t\treturn res;\n\t\t}\n\n\t\tvoid show() {\n\t\t\tSystem.out.println(\"---------show---------\");\n\t\t\tSystem.out.println(\"String = \" + S.substring(l, r + 1));\n\t\t\tSystem.out.println(\"l = \" + l + \" r = \" + r);\n\t\t\tSystem.out.println(\"Hash1 = \" + getHash1() + \" Hash2 = \" + getHash2());\n\t\t\tSystem.out.println(\"----------------------\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (k <= a[i])\n\tint lower_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k <= a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\t// find minimum i (k < a[i])\n\tint upper_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k < a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tlong gcd(long a, long b) {\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\n\t}\n\n\tlong lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tString s = sc.next();\n\t\tint N = s.length();\n\t\tRollingHash rh = new RollingHash();\n\t\trh.init(s);\n\t\tint ans = Integer.MAX_VALUE;\n\t\tString res = \"\";\n\t\tint l = 0;\n\t\tint r = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint t = N - (i + 1) * 3;\n\t\t\tif (t > 0 && t % 2 == 0) {\n\t\t\t\tint A = i + 1;\n\t\t\t\tint B = t / 2;\n\t\t\t\tlong a1, a2, a3, b1, b2;\n\t\t\t\ta1 = a2 = a3 = b1 = b2 = 0;\n\t\t\t\trh.l = 0;\n\t\t\t\trh.r = A - 1;\n\t\t\t\ta1 = rh.getHash1();\n\t\t\t\trh.l = A;\n\t\t\t\trh.r = A + B - 1;\n\t\t\t\tb1 = rh.getHash1();\n\t\t\t\trh.l = A + B;\n\t\t\t\trh.r = A + B + A - 1;\n\t\t\t\ta2 = rh.getHash1();\n\t\t\t\trh.l = A + B + A;\n\t\t\t\trh.r = A + B + A + B - 1;\n\t\t\t\tb2 = rh.getHash1();\n\t\t\t\trh.l = A + B + A + B;\n\t\t\t\trh.r = A + B + A + B + A - 1;\n\t\t\t\ta3 = rh.getHash1();\n\t\t\t\tif (a1 == a2 && a2 == a3 && b1 == b2) {\n\t\t\t\t\tans = Math.min(ans, i + t);\n\t\t\t\t\tl = A;\n\t\t\t\t\tr = B;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(l != 0 && r != 0) res = s.substring(0, l) + s.substring(l, l + r);\n\t\tSystem.out.println(res.isEmpty() ? \"mitomerarenaiWA\" : \"Love \" + res + \"!\");\n\t}\n\n\tpublic class RollingHash {\n\n\t\tString S;\n\t\tint N, l, r;\n\n\t\tlong B1 = 1007;\n\t\tlong B2 = 1009;\n\t\tlong H1 = 1000000007;\n\t\tlong H2 = 1000000009;\n\n\t\tlong[] Base1, Base2;\n\t\tlong[] Hash1, Hash2;\n\n\t\tvoid init(String s) {\n\t\t\tS = s;\n\t\t\tN = s.length();\n\t\t\tl = 0;\n\t\t\tr = s.length() - 1;\n\t\t\tBase1 = new long[N + 1];\n\t\t\tBase2 = new long[N + 1];\n\t\t\tHash1 = new long[N];\n\t\t\tHash2 = new long[N];\n\n\t\t\tBase1[0] = Base2[0] = 1;\n\t\t\tHash1[0] = Hash2[0] = s.charAt(0);\n\t\t\tfor (int i = 1; i <= N; i++)\n\t\t\t\tBase1[i] = (Base1[i - 1] * B1) % H1;\n\t\t\tfor (int i = 1; i <= N; i++)\n\t\t\t\tBase2[i] = (Base2[i - 1] * B2) % H2;\n\t\t\tfor (int i = 1; i < N; i++)\n\t\t\t\tHash1[i] = (Hash1[i - 1] * B1 + s.charAt(i)) % H1;\n\t\t\tfor (int i = 1; i < N; i++)\n\t\t\t\tHash2[i] = (Hash2[i - 1] * B2 + s.charAt(i)) % H2;\n\t\t}\n\n\t\t/*\n\t\t * S(this)???T??????????????????(?????¬??????RollingHash)\n\t\t */\n\t\tboolean contain1(String T) {\n\t\t\tint sl = S.length();\n\t\t\tint tl = T.length();\n\t\t\tif (tl > sl)\n\t\t\t\treturn false;\n\n\t\t\tlong b = 1;\n\t\t\tfor (int i = 0; i < tl; i++)\n\t\t\t\tb = (b * B1) % H1;\n\n\t\t\tlong sh = 0;\n\t\t\tlong th = 0;\n\t\t\tfor (int i = 0; i < tl; i++)\n\t\t\t\tsh = (sh * B1 + (S.charAt(i))) % H1;\n\t\t\tfor (int i = 0; i < tl; i++)\n\t\t\t\tth = (th * B1 + (T.charAt(i))) % H1;\n\n\t\t\tfor (int i = 0; i + tl <= sl; i++) {\n\t\t\t\tif (sh == th)\n\t\t\t\t\treturn true;\n\t\t\t\tif (i + tl < sl)\n\t\t\t\t\tsh = sh * B1 - (S.charAt(i)) * b + (S.charAt(i + tl));\n\t\t\t\tsh = (sh + H1) % H1;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean contain2(String T) {\n\t\t\tint sl = N;\n\t\t\tint tl = T.length();\n\t\t\tif (tl > sl)\n\t\t\t\treturn false;\n\n\t\t\tlong th = 0;\n\t\t\tfor (int i = 0; i < tl; i++)\n\t\t\t\tth = (th * B1 + (T.charAt(i))) % H1;\n\n\t\t\tr = tl - 1;\n\t\t\tl = 0;\n\t\t\tfor (; r < N; r++, l++) {\n\t\t\t\tif (getHash1() == th)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tl = 0;\n\t\t\tr = S.length();\n\t\t\treturn false;\n\t\t}\n\n\t\tlong getHash1() {\n\t\t\tlong res = Hash1[r] - ((l == 0) ? 0 : Hash1[l - 1] * Base1[r - l + 1]);\n\t\t\tif (res < 0)\n\t\t\t\tres = (res + ((-res / H1) + 1) * H1) % H1;\n\t\t\treturn res;\n\t\t}\n\n\t\tlong getHash2() {\n\t\t\tlong res = Hash2[r] - ((l == 0) ? 0 : Hash2[l - 1] * Base2[r - l + 1]);\n\t\t\tif (res < 0)\n\t\t\t\tres = (res + ((-res / H2) + 1) * H2) % H2;\n\t\t\treturn res;\n\t\t}\n\n\t\tvoid show() {\n\t\t\tSystem.out.println(\"---------show---------\");\n\t\t\tSystem.out.println(\"String = \" + S.substring(l, r + 1));\n\t\t\tSystem.out.println(\"l = \" + l + \" r = \" + r);\n\t\t\tSystem.out.println(\"Hash1 = \" + getHash1() + \" Hash2 = \" + getHash2());\n\t\t\tSystem.out.println(\"----------------------\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (k <= a[i])\n\tint lower_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k <= a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\t// find minimum i (k < a[i])\n\tint upper_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k < a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tlong gcd(long a, long b) {\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\n\t}\n\n\tlong lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tlong start = System.currentTimeMillis();\n\tlong fin = System.currentTimeMillis();\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\n\tvoid run() {\n\t\tString s = sc.next();\n\t\tint N = s.length();\n\t\tRollingHash rh = new RollingHash();\n\t\trh.init(s);\n\t\tint ans = Integer.MAX_VALUE;\n\t\tString res = \"\";\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint t = N - (i + 1) * 3;\n\t\t\tif (t > 0 && t % 2 == 0) {\n\t\t\t\tint A = i + 1;\n\t\t\t\tint B = t / 2;\n\t\t\t\tlong a1, a2, a3, b1, b2;\n\t\t\t\ta1 = a2 = a3 = b1 = b2 = 0;\n\t\t\t\trh.l = 0;\n\t\t\t\trh.r = A - 1;\n\t\t\t\ta1 = rh.getHash1();\n\t\t\t\trh.l = A;\n\t\t\t\trh.r = A + B - 1;\n\t\t\t\tb1 = rh.getHash1();\n\t\t\t\trh.l = A + B;\n\t\t\t\trh.r = A + B + A - 1;\n\t\t\t\ta2 = rh.getHash1();\n\t\t\t\trh.l = A + B + A;\n\t\t\t\trh.r = A + B + A + B - 1;\n\t\t\t\tb2 = rh.getHash1();\n\t\t\t\trh.l = A + B + A + B;\n\t\t\t\trh.r = A + B + A + B + A - 1;\n\t\t\t\ta3 = rh.getHash1();\n\t\t\t\tif (a1 == a2 && a2 == a3 && b1 == b2) {\n\t\t\t\t\tans = Math.min(ans, i + t);\n\t\t\t\t\tres = s.substring(0, A) + s.substring(A, A + B);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res.isEmpty() ? \"mitomerarenaiWA\" : \"Love \" + res + \"!\");\n\t}\n\n\tpublic class RollingHash {\n\n\t\tString S;\n\t\tint N, l, r;\n\n\t\tlong B1 = 1007;\n\t\tlong B2 = 1009;\n\t\tlong H1 = 1000000007;\n\t\tlong H2 = 1000000009;\n\n\t\tlong[] Base1, Base2;\n\t\tlong[] Hash1, Hash2;\n\n\t\tvoid init(String s) {\n\t\t\tS = s;\n\t\t\tN = s.length();\n\t\t\tl = 0;\n\t\t\tr = s.length() - 1;\n\t\t\tBase1 = new long[N + 1];\n\t\t\tBase2 = new long[N + 1];\n\t\t\tHash1 = new long[N];\n\t\t\tHash2 = new long[N];\n\n\t\t\tBase1[0] = Base2[0] = 1;\n\t\t\tHash1[0] = Hash2[0] = s.charAt(0);\n\t\t\tfor (int i = 1; i <= N; i++)\n\t\t\t\tBase1[i] = (Base1[i - 1] * B1) % H1;\n\t\t\tfor (int i = 1; i <= N; i++)\n\t\t\t\tBase2[i] = (Base2[i - 1] * B2) % H2;\n\t\t\tfor (int i = 1; i < N; i++)\n\t\t\t\tHash1[i] = (Hash1[i - 1] * B1 + s.charAt(i)) % H1;\n\t\t\tfor (int i = 1; i < N; i++)\n\t\t\t\tHash2[i] = (Hash2[i - 1] * B2 + s.charAt(i)) % H2;\n\t\t}\n\n\t\t/*\n\t\t * S(this)???T??????????????????(?????¬??????RollingHash)\n\t\t */\n\t\tboolean contain1(String T) {\n\t\t\tint sl = S.length();\n\t\t\tint tl = T.length();\n\t\t\tif (tl > sl)\n\t\t\t\treturn false;\n\n\t\t\tlong b = 1;\n\t\t\tfor (int i = 0; i < tl; i++)\n\t\t\t\tb = (b * B1) % H1;\n\n\t\t\tlong sh = 0;\n\t\t\tlong th = 0;\n\t\t\tfor (int i = 0; i < tl; i++)\n\t\t\t\tsh = (sh * B1 + (S.charAt(i))) % H1;\n\t\t\tfor (int i = 0; i < tl; i++)\n\t\t\t\tth = (th * B1 + (T.charAt(i))) % H1;\n\n\t\t\tfor (int i = 0; i + tl <= sl; i++) {\n\t\t\t\tif (sh == th)\n\t\t\t\t\treturn true;\n\t\t\t\tif (i + tl < sl)\n\t\t\t\t\tsh = sh * B1 - (S.charAt(i)) * b + (S.charAt(i + tl));\n\t\t\t\tsh = (sh + H1) % H1;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean contain2(String T) {\n\t\t\tint sl = N;\n\t\t\tint tl = T.length();\n\t\t\tif (tl > sl)\n\t\t\t\treturn false;\n\n\t\t\tlong th = 0;\n\t\t\tfor (int i = 0; i < tl; i++)\n\t\t\t\tth = (th * B1 + (T.charAt(i))) % H1;\n\n\t\t\tr = tl - 1;\n\t\t\tl = 0;\n\t\t\tfor (; r < N; r++, l++) {\n\t\t\t\tif (getHash1() == th)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tl = 0;\n\t\t\tr = S.length();\n\t\t\treturn false;\n\t\t}\n\n\t\tlong getHash1() {\n\t\t\tlong res = Hash1[r] - ((l == 0) ? 0 : Hash1[l - 1] * Base1[r - l + 1]);\n\t\t\tif (res < 0)\n\t\t\t\tres = (res + ((-res / H1) + 1) * H1) % H1;\n\t\t\treturn res;\n\t\t}\n\n\t\tlong getHash2() {\n\t\t\tlong res = Hash2[r] - ((l == 0) ? 0 : Hash2[l - 1] * Base2[r - l + 1]);\n\t\t\tif (res < 0)\n\t\t\t\tres = (res + ((-res / H2) + 1) * H2) % H2;\n\t\t\treturn res;\n\t\t}\n\n\t\tvoid show() {\n\t\t\tSystem.out.println(\"---------show---------\");\n\t\t\tSystem.out.println(\"String = \" + S.substring(l, r + 1));\n\t\t\tSystem.out.println(\"l = \" + l + \" r = \" + r);\n\t\t\tSystem.out.println(\"Hash1 = \" + getHash1() + \" Hash2 = \" + getHash2());\n\t\t\tSystem.out.println(\"----------------------\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (k <= a[i])\n\tint lower_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k <= a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\t// find minimum i (k < a[i])\n\tint upper_bound(int a[], int k) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (k < a[mid])\n\t\t\t\tr = mid;\n\t\t\telse\n\t\t\t\tl = mid;\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tlong gcd(long a, long b) {\n\t\treturn a % b == 0 ? b : gcd(b, a % b);\n\t}\n\n\tlong lcm(long a, long b) {\n\t\treturn a * b / gcd(a, b);\n\t}\n\n\tboolean palindrome(String s) {\n\t\tfor (int i = 0; i < s.length() / 2; i++) {\n\t\t\tif (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tchar[][] nextCharField(int n, int m) {\n\t\t\tchar[][] in = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tin[i][j] = s.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "s = gets.chomp\nr = \"\"\n\nfor i in 1..s.size\n  next if 3 * i >= s.size || (s.size - 3 * i) % 2 != 0\n  \n  t = s[0...i]\n  u = s[i...i+(s.size-3*i)/2]\n  \n  m = s.scan(/^#{t}#{u}#{t}#{u}#{t}$/)\n  unless m.empty? then\n    _s = t + u\n    r = _s if r.size < _s.size\n  end\nend\n\nif r.empty? then\n  puts \"mitomerarenaiWA\"\nelse\n  puts \"Love #{r}!\"\nend"
  },
  {
    "language": "Ruby",
    "code": "s = gets.chomp\nr = nil\n\nfor i in 1..s.size\n  next if 3 * i >= s.size || (s.size - 3 * i) % 2 != 0\n  \n  t = s[0...i]\n  u = s[i...i+(s.size-3*i)/2]\n  \n  m = s.scan(/^#{t}#{u}#{t}#{u}#{t}$/)\n  unless m.empty? then\n    _s = t + u\n    r = _s if !r || _s.size < r.size \n  end\nend\n\nif r then\n  puts \"Love #{r}!\"\nelse\n  puts \"mitomerarenaiWA\"\nend"
  },
  {
    "language": "Python",
    "code": "s = input()\nlength = len(s)\nBASE = 100\nMOD1 = 1000000007\nMOD2 = 2147483647\nacc1 = 0\nacc2 = 0\nhlst1 = [0]\nhlst2 = [0]\nfor c in s:\n  i = ord(c)\n  acc1 = (acc1 * BASE + i) % MOD1\n  acc2 = (acc2 * BASE + i) % MOD2\n  hlst1.append(acc1)\n  hlst2.append(acc2)\n\ndef calc_hash(left, right, xlen):\n  return ((hlst1[right] - hlst1[left] * pow(BASE, xlen, MOD1)) % MOD1,\n          (hlst2[right] - hlst2[left] * pow(BASE, xlen, MOD2)) % MOD2)\n\nfor i in range(length // 3, -1, -1):\n  if (length - (i + 1) * 3) % 2:continue\n  alen = i + 1\n  blen = (length - (i + 1) * 3) // 2\n  if blen <= 0:continue\n  ha1 = calc_hash(0, alen, alen)\n  ha2 = calc_hash(alen + blen, blen + alen * 2, alen)\n  if ha1 != ha2:continue\n  ha3 = calc_hash(blen * 2 + alen * 2, blen * 2 + alen * 3, alen)\n  if ha1 != ha3:continue\n  hb1 = calc_hash(alen, alen + blen, blen)\n  hb2 = calc_hash(blen + alen * 2, blen * 2 + alen * 2, blen)\n  if hb1 != hb2:continue\n  print(\"Love {}!\".format(s[:i + 1 + blen]))\n  break\nelse:\n  print(\"mitomerarenaiWA\")\n\n"
  }
]