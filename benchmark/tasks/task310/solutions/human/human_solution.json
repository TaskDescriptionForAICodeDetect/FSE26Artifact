[
  {
    "language": "Scala",
    "code": "object Main extends App {\n\n  import scala.io.StdIn._\n  import scala.math._\n  solve\n  def solve: Unit = {\n    val n = readLine.trim.toInt\n    if (n == 0) return\n    println(solveExpression(List.tabulate(n){_ ⇒ readLine.trim}))\n    solve\n  }\n  def solveExpression(expression: List[String]): Long = {\n    def solveDepth(expression: List[String], depth: Int, result: List[Long] = Nil): (List[Long], List[String]) = {\n      expression match {\n        case h::t if h.isDepthN(depth) ⇒\n          h.asDepthN(depth) match{\n            case n if n.isDigit ⇒ solveDepth(t, depth, n.asDigit::result)\n            case o ⇒\n              val (numbers, rest) = solveDepth(t, depth + 1)\n              o match {\n                case '+' ⇒ solveDepth(rest, depth, numbers.sum::result)\n                case '*' ⇒ solveDepth(rest, depth, numbers.product::result)\n                case _ ⇒ ???\n              }\n          }\n        case _ ⇒ (result, expression)\n      }\n    }\n    solveDepth(expression, 0)._1.head\n  }\n  implicit class Token(str: String){\n    def isDepthN(n: Int): Boolean = if (n == 0) str(n) != '.'\n    else str.indices.contains(n - 1) && str(n - 1) == '.' && str(n) != '.'\n    def asDepthN(n: Int): Char = str(n)\n\n  }\n\n  @inline\n  def lowerBound[T](array: Array[T], target: T)(implicit ord: Ordering[T]): Int = {\n    var left = 0\n    var right = array.length\n    while (left < right){\n      val mid = (left + right) / 2\n      if (ord.compare(array(mid), target) < 0){\n        left = mid + 1\n      }else {\n        right = mid\n      }\n    }\n    right\n  }\n  @inline\n  def upperBound[T](array: Array[T], target: T)(implicit ord: Ordering[T]): Int = {\n    var left = 0\n    var right = array.length\n    while (left < right){\n      val mid = (left + right) / 2\n      if (ord.compare(array(mid), target) <= 0){\n        left = mid + 1\n      }else {\n        right = mid\n      }\n    }\n    right\n  }\n  implicit class Extension[T](val value :T){\n    def also(func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n    def let[R](func: T ⇒ R): R = func(value)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <map>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n  \nconst ll MOD=1e9+7;\nconst ll INF=1e18;\n  \nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\n \nint d[100][100];\nint sum[100];\n \nint main(){\n    int n;\n \n    while(1){\n \n        cin >> n;\n        if(n == 0)break;\n        char tmp[100];\n        for(int i = 0;i < n;i++){\n            cin >> tmp;\n            sum[i] = 0;\n            for(int j = 0;j < strlen(tmp);j++){\n                if(tmp[j] == '.'){\n                    d[i][j] = -1;\n                    sum[i] = j+1;\n                }else if(tmp[j] == '+'){\n                    d[i][j] = -2;\n                    break;\n                }else if(tmp[j] == '*'){\n                    d[i][j] = -3;\n                    break;\n                }else{\n                    d[i][j] = tmp[j] - '0';\n                }\n            }\n        }\n        while(n != 1){\n            /*\n            cout << \"+++++\" << endl;\n            for(int i = 0;i < n;i++){\n                for(int j = 0;j < sum[i]+1;j++){\n                    cout << d[i][j] ;\n                }\n                cout << endl;\n            }\n*/\n \n            int maxlen = 0,o = -1;\n            for(int i = 0;i < n;i++){\n                if(sum[i] > maxlen){\n                    o = i;\n                    maxlen = sum[i];\n                }\n            }\n            int count = 1,ans = d[o][maxlen];\n            for(int i = o+1;i < n;i++){\n                if(maxlen == sum[i]){\n                    count++;\n                    if(d[o-1][maxlen-1] == -2){\n                        ans += d[i][maxlen];\n                    }else{\n                        ans *= d[i][maxlen];\n                    }\n                }else{\n                    break;\n                }\n            }\n            d[o-1][maxlen-1] = ans;\n            for(int i = o + count;i < n;i++){\n                for(int j = 0;j <= sum[i];j++){\n                    d[i-count][j] = d[i][j];\n                }\n            }\n            for(int i = o+count;i < n;i++) sum[i-count] = sum[i];\n            n -= count;\n        }\n        cout << d[0][0] << endl;\n \n \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int to_i(const string& s) {\n        istringstream is(s);\n        int n; is >> n;\n        return n;\n    }\n\n\n    int N;\n    vector<string> S;\n    bool input() {\n        cin >> N;\n        if (N == 0) return false;\n        S.clear(); S.resize(N); cin >> S;\n        return true;\n    }\n\n    int level(const string& s) {\n        for (int i = 0; i < int(s.size()); i++) if (s[i] != '.') return i;\n        assert(false);\n    }\n\n    int calc(char op, int a, int b) {\n        //cerr << a << \" \" << op << \" \" << b << endl;\n        switch (op) {\n            case '+': return a + b;\n            case '*': return a * b;\n            default: assert(false);\n        } \n    }\n\n    int dfs(int& j) {\n        const string& s = S[j];\n        int l = level(s);\n        if (isdigit(s[l])) {\n            j++;\n            return to_i(s.substr(l, s.size() - l));\n        } else {\n            char op = s[l];\n            int ans = (op == '+' ? 0 : 1);\n            j++;\n            while (j < N && level(S[j]) > l) {\n                ans = calc(op, ans, dfs(j));\n            }\n            return ans;\n        }\n    }\n\n    void solve() {\n        int j = 0;\n        cout << dfs(j) << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint eval(int& i,vector<string>& S){\n    string s = S[i];\n    i++;\n    if(isdigit(s[s.size()-1])){\n        return s[s.size()-1] - '0';\n    }\n    char op = s[s.size()-1];\n    int res = (op == '*' ? 1 : 0);\n    while(i < S.size()){\n        if(s.size() >= S[i].size())break;\n        if(op == '*'){\n            res *= eval(i,S);\n        }else{\n            res += eval(i,S);\n        }\n    }\n    return res;\n}\n\nint solve(int n){\n    int i = 0;\n    vector<string> s(n);\n    for(auto &x:s)cin >> x;\n    return eval(i,s);\n}\n\nint main(){\n    int n;\n    while(true){\n        cin >> n;\n        if(!n)return 0;\n        cout << solve(n) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main(void) {\n    while (1) {\n\n        int n;\n        cin >> n;\n        if (n == 0) break;\n\n        string formula[n];\n        int formulalen[n];\n        for (int i = 0; i < n; ++i) {\n            cin >> formula[i];\n            formulalen[i] = formula[i].length();\n        }\n\n        while (1) {\n\n            if (formulalen[0] == 1 && formula[0] != \"+\" && formula[0] != \"*\") { // 終了条件\n                cout << formula[0] << endl;\n                break;\n            }\n\n            int maxlen = 0;\n            for (int i = 0; i < n; ++i) {\n                maxlen = max(maxlen, formulalen[i]);\n            }\n\n            bool opefind = false;\n            long long result = 0;\n            string ope;\n            int pos = 0;\n            int maxcnt = 0;\n            for (int i = 0; i < n; ++i) {\n                if (formulalen[i] == maxlen) {\n                    if (!opefind) {\n                        ope = formula[i - 1].substr(formulalen[i - 1] - 1, 1);\n                        result = stoi(formula[i].substr(formulalen[i] - 1));\n                        opefind = true;\n                        pos = i - 1;\n                        maxcnt += 1;\n                    } else {\n                        if (ope == \"+\") {\n                            result += stoi(formula[i].substr(formulalen[i] - 1));\n                        } else if (ope == \"*\") {\n                            result *= stoi(formula[i].substr(formulalen[i] - 1));\n                        }\n                        maxcnt += 1;\n                    }\n                    if (i + 1 != n) {\n                        if (formulalen[i + 1] != maxlen) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            string replaceformula = \"\";\n            for (int i = 0; i < maxlen - 2; ++i) {\n                replaceformula += \".\";\n            }\n            replaceformula += to_string(result);\n\n            n -= maxcnt;\n            formula[pos] = replaceformula;\n            for (int i = pos + 1; i < n; ++i) {\n                formula[i] = formula[i + maxcnt];\n                formulalen[i] = formulalen[i + maxcnt];\n            }\n\n//            printf(\"%d %d\\n\", pos + 1, maxcnt);\n//            for (int i = 0; i < n; ++i) {\n//                cout << formula[i] << \" \" << formulalen[i] << endl;\n//            }\n        }\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nvoid solve() {\n    int n;\n\twhile(cin >> n) {\n        if(n == 0) break;\n        stack<P> st;\n        if(n == 1) {\n            int num; cin >> num;\n            cout << num << endl;\n            continue;\n        }\n        rep(i, n) {\n            string t; cin >> t;\n            int sz = (int)t.size();\n            while(st.size() >= sz) {\n                P p = st.top(); st.pop();\n                P q = st.top(); st.pop();\n                if(q.fr == 1) {\n                    q.sc += p.sc;\n                    st.push(q);\n                } else {\n                    q.sc *= p.sc;\n                    st.push(q);\n                }\n            }\n            if(t[sz - 1] == '+') {\n                st.push(make_pair(1, 0));\n            } else if(t[sz - 1] == '*') {\n                st.push(make_pair(2, 1));\n            } else {\n                int num = t[sz - 1] - '0';\n                // while(st.size() >= sz) {\n                //     P p = st.top(); st.pop();\n                //     P q = st.top(); st.pop();\n                //     if(q.fr == 1) {\n                //         q.sc += p.sc;\n                //         st.push(q);\n                //     } else {\n                //         q.sc *= p.sc;\n                //         st.push(q);\n                //     }\n                // }\n                P q = st.top(); st.pop();\n                if(q.fr == 1) {\n                    q.sc += num;\n                    st.push(q);\n                } else {\n                    q.sc *= num;\n                    st.push(q);\n                }\n            }\n        }\n\n        while(st.size() >= 2) {\n            P p = st.top(); st.pop();\n            P q = st.top(); st.pop();\n            if(q.fr == 1) {\n                q.sc += p.sc;\n                st.push(q);\n            } else {\n                q.sc *= p.sc;\n                st.push(q);\n            }\n        }\n\n        cout << st.top().sc << endl;\n    }\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct data {\n  string s;\n  int rank;\n};\nint n, id = 0;\nvector<data> v;\n\nint solve();\nvoid setrank();\n\nint main() {\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    v.resize(n);\n    for(int i = 0; i < n; ++i) cin >> v[i].s;\n    setrank();\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nint solve() {\n  if(v[id].s[v[id].rank] >= '0' &&\n     v[id].s[v[id].rank] <= '9')\n    return v[id].s[v[id].rank] - '0';\n  int ans = 0, nrank = v[id].rank;\n  bool ch = v[id].s[v[id].rank] == '*';\n  if(ch) ans = 1;\n  ++id;\n  while(v[id].rank > nrank) {\n    if(ch)\n      ans *= solve();\n    else\n      ans += solve();\n    if(++id >= n) return ans;\n  }\n  --id;\n  return ans;\n}\n\nvoid setrank() {\n  for(int i = 0; i < n; ++i) {\n    v[i].rank = 0;\n    while(v[i].s[v[i].rank] == '.') ++v[i].rank;\n  }\n  id = 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i, n ,N) for(int i = (n); i < (N); i++)\n#define p(s) cout<<(s)<<endl\n#define p2(a, b) cout<<(a)<<\" \"<<(b)<<endl\nusing namespace std;\ntypedef long long ll;\n\nint n;\nint main(){\n\twhile(cin >> n && n){\n\t\tif(n==1){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tp(a);\n\t\t\tcontinue;\n\t\t}\n\t\tstack<int> op_num;\n\t\tint ans=0;\n\t\tint intend_level = 1;\n\t\tREP(i,0,n){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tint now_len = s.size();\n\t\t\tif(intend_level <= now_len){\n\t\t\t\tchar c = s.back();\n\t\t\t\tif(c=='+' || c=='*') intend_level++;\n\t\t\t\top_num.push(c - '0');\n\t\t\t}else{\n\t\t\t\tvector<int> vt;\n\t\t\t\twhile(intend_level > now_len){\n\t\t\t\t\tint c = op_num.top();\n\t\t\t\t\top_num.pop();\n\t\t\t\t\tif(c!='+'-'0' && c!='*'-'0'){\n\t\t\t\t\t\tvt.push_back(c);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint sum = vt.back();\n\t\t\t\t\t\tvt.pop_back();\n\t\t\t\t\t\tintend_level--;\n\t\t\t\t\t\tif(c=='+'-'0'){\n\t\t\t\t\t\t\tfor(auto v: vt){\n\t\t\t\t\t\t\t\tsum += v;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfor(auto v: vt){\n\t\t\t\t\t\t\t\tsum *= v;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tans = sum;\n\t\t\t\t\t\top_num.push(sum);\n\t\t\t\t\t\tvt.clear();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchar c = s.back();\n\t\t\t\tif(c=='+' || c=='*') intend_level++;\n\t\t\t\top_num.push(c - '0');\n\t\t\t}\n\n\t\t}\n\t\tvector<int> vt;\n\t\twhile(intend_level > 1){\n\t\t\tint c = op_num.top();\n\t\t\top_num.pop();\n\t\t\tif(c!='+'-'0' && c!='*'-'0'){\n\t\t\t\tvt.push_back(c);\n\t\t\t}else{\n\t\t\t\tint sum = vt.back();\n\t\t\t\tvt.pop_back();\n\t\t\t\tintend_level--;\n\t\t\t\tif(c=='+'-'0'){\n\t\t\t\t\tfor(auto v: vt){\n\t\t\t\t\t\tsum += v;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tfor(auto v: vt){\n\t\t\t\t\t\tsum *= v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tans = sum;\n\t\t\t\top_num.push(sum);\n\t\t\t\tvt.clear();\n\t\t\t}\n\t\t}\n\t\tp(ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <sstream>\n\nusing namespace std;\n\nint main(void) {\n    while (1) {\n\n        int n;\n        cin >> n;\n        if (n == 0) break;\n\n        string formula[n];\n        int formulalen[n];\n        for (int i = 0; i < n; ++i) {\n            cin >> formula[i];\n            formulalen[i] = formula[i].length();\n        }\n\n        while (1) {\n\n            if (formulalen[0] == 1 && formula[0] != \"+\" && formula[0] != \"*\") { // 終了条件\n                cout << formula[0] << endl;\n                break;\n            }\n\n            int maxlen = 0;\n            for (int i = 0; i < n; ++i) {\n                maxlen = max(maxlen, formulalen[i]);\n            }\n\n            bool opefind = false;\n            long long result = 0;\n            string ope;\n            int pos = 0;\n            int maxcnt = 0;\n            for (int i = 0; i < n; ++i) {\n                if (formulalen[i] == maxlen) {\n                    if (!opefind) {\n                        ope = formula[i - 1].substr(formulalen[i - 1] - 1, 1);\n//                        result = stoi(formula[i].substr(formulalen[i] - 1));\n                        stringstream ss1;\n                        ss1 << formula[i].substr(formulalen[i] - 1);\n                        ss1 >> result;\n//                        cout << result << \" \";\n                        opefind = true;\n                        pos = i - 1;\n                        maxcnt += 1;\n                    } else {\n                        if (ope == \"+\") {\n//                            result += stoi(formula[i].substr(formulalen[i] - 1));\n                            int plus;\n                            stringstream ss2;\n                            ss2 << formula[i].substr(formulalen[i] - 1);\n                            ss2 >> plus;\n//                            cout << plus << \" \";\n                            result += plus;\n                        } else if (ope == \"*\") {\n//                            result *= stoi(formula[i].substr(formulalen[i] - 1));\n                            int mul;\n                            stringstream ss3;\n//                            cout << formula[i].substr(formulalen[i] - 1) << endl;\n                            ss3 << formula[i].substr(formulalen[i] - 1);\n                            ss3 >> mul;\n//                            cout << mul << endl;\n                            result *= mul;\n                        }\n                        maxcnt += 1;\n                    }\n                    if (i + 1 != n) {\n                        if (formulalen[i + 1] != maxlen) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            string replaceformula = \"\";\n            for (int i = 0; i < maxlen - 2; ++i) {\n                replaceformula += \".\";\n            }\n            stringstream ss4;\n            ss4 << result;\n//            replaceformula += to_string(result);\n            replaceformula += ss4.str();\n\n            n -= maxcnt;\n            formula[pos] = replaceformula;\n            for (int i = pos + 1; i < n; ++i) {\n                formula[i] = formula[i + maxcnt];\n                formulalen[i] = formulalen[i + maxcnt];\n            }\n\n//            printf(\"%d %d\\n\", pos + 1, maxcnt);\n//            for (int i = 0; i < n; ++i) {\n//                cout << formula[i] << \" \" << formulalen[i] << endl;\n//            }\n        }\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,N) for(int i=0;i<N;++i)\n\nint main(){\n    while(true){\n        int n;\n        cin>>n;\n        if(n==0){\n            break;\n        }\n        int lv=0;//深さレベル\n        vector<int> mode(0);//0:plane, 1:sum, 2:prod\n        vector<vector<int>> args(1,vector<int>());\n        //int ans=0;\n        REP(i,n){\n            string s;\n            cin>>s;\n            int dots=0;\n            //cout<<s<<endl;\n            while(s[dots]=='.'){\n                //cout<<\"hoge\";\n                dots++;\n            }\n            char c=s[dots];//本体\n            //cout<<(c=='+')<<endl;\n            //計算が走る\n            while(lv>dots){\n                if(mode.back()==1){\n                    int a=0;\n                    //cout<<\"sum \";\n                    REP(j, args.back().size()){\n                        a += args.back()[j];\n                        //cout<<args.back()[j]<<\" \";\n                    }\n                    args.pop_back();\n                    args.back().push_back(a);\n                } else if(mode.back()==2){\n                    int a=1;\n                    //cout<<\"prod \";\n                    REP(j, args.back().size()){\n                        //cout<<args.back()[j]<<\" \";\n                        a *= args.back()[j];\n                    }\n                    args.pop_back();\n                    args.back().push_back(a);\n                }\n                //cout<<endl;\n                mode.pop_back();\n                lv--;\n            }\n            //lv==dots\n            if(c=='+'){\n                //cout<<\"hoge\";\n                lv++;\n                mode.push_back(1);\n                args.push_back(vector<int>());\n            } else if(c=='*'){\n                lv++;\n                mode.push_back(2);\n                args.push_back(vector<int>());\n            } else {\n                int a= c-'0';\n                args.back().push_back(a);\n            }\n        }\n        while(lv>0){\n            if(mode.back()==1){\n                int a=0;\n                //cout<<\"sum \";\n                REP(j, args.back().size()){\n                    a += args.back()[j];\n                    //cout<<args.back()[j]<<\" \";\n                }\n                args.pop_back();\n                args.back().push_back(a);\n            } else if(mode.back()==2){\n                int a=1;\n                //cout<<\"prod \";\n                REP(j, args.back().size()){\n                    //cout<<args.back()[j]<<\" \";\n                    a *= args.back()[j];\n                }\n                args.pop_back();\n                args.back().push_back(a);\n            }\n            //cout<<endl;\n            mode.pop_back();\n            lv--;\n        }\n        cout<<args.back()[0]<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <utility>\n\nusing namespace std;\n\nint N;\n\ntypedef pair<int,char> T;\n\nvector<T> input;\n\nint eval(int s){\n    if (isdigit(input[s].second)) return input[s].second-'0';\n\n    char op=input[s].second;\n\n    int init;\n    if (op=='+'){\n        init=0;\n        for(int i=s+1;i<input.size();i++){\n            // printf(\"init=%d\\n\",init);\n            if (input[i].first<=input[s].first) break;\n            if (input[i].first==input[s].first+1) init+=eval(i); \n        }\n    }else{\n        init=1;\n        for(int i=s+1;i<input.size();i++){\n            // printf(\"init=%d\\n\",init);\n            if (input[i].first<=input[s].first) break;\n            if (input[i].first==input[s].first+1) init*=eval(i); \n        }\n    }\n\n    return init;\n}\n\nint main(){\n\n    while(true){\n        cin>>N;\n        if (!N) break;\n        string buf;\n        input.clear();\n        for(int i=0;i<N;i++) {\n            cin>>buf;\n            int level=buf.size()-1;\n            char v=buf[level];\n            input.push_back(T(level,v));\n        }\n\n        // for(auto i:input) printf(\"%d %c\\n\",i.first,i.second);\n\n        printf(\"%d\\n\",eval(0));\n    }\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    stack<string> st;\n    string e;\n    int d = 0;\n    for(int i = 0; i < n; ++i){\n      cin >> e;\n      int l = e.length();\n      e = e[l-1];\n      while(l < d){\n\tvector<int> t;\n\tstring s = st.top();\n\twhile(s.length() > 1 || (s >= \"0\" && s <= \"9\")){\n\t  t.push_back(stoi(s));\n\t  st.pop();\n\t  s = st.top();\n\t}\n\tstring o = \"\";\n\tif(!st.empty()){\n\t  o = st.top();\n\t  st.pop();\n\t}\n\tif(o == \"\"){\n\t  if(t.size() > 1){\n\t    cout << \"Error\" << endl;\n\t  }else{\n\t    cout << t[0] << endl;\n\t  }\n\t}else{\n\t  if(o == \"+\"){\n\t    int ret = 0;\n\t    for(int i = 0; i < t.size(); ++i){\n\t      ret += t[i];\n\t    }\n\t    st.push(to_string(ret));\n\t    --d;\n\t  }else if(o == \"*\"){\n\t    int ret = 1;\n\t    for(int i = 0; i < t.size(); ++i){\n\t      ret *= t[i];\n\t    }\n\t    st.push(to_string(ret));\n\t    --d;\n\t  }\n\t}\n      }\n      st.push(e);\n      d = l;\n    }\n\n    stack<int> st2;\n    while(!st.empty()){\n      string e = st.top();\n      st.pop();\n      if(e == \"+\"){\n\tint k = 0;\n\twhile(!st2.empty()){\n\t  int l = st2.top();\n\t  k += l;\n\t  st2.pop();\n\t}\n\tst.push(to_string(k));\n      }else if(e == \"*\"){\n\tint k = 1;\n\twhile(!st2.empty()){\n\t  int l = st2.top();\n\t  k *= l;\n\t  st2.pop();\n\t}\n\tst.push(to_string(k));\n      }else{\n\tst2.push(stoi(e));\n      }\n      if(st.empty()){\n\tcout << st2.top() << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nstring s[100];\nint cur;\nint dfs(int d){\n    int ret;\n    if(isdigit(s[cur][d])) return s[cur++][d]-'0';\n    else{\n        if(s[cur][d]=='+'){\n            ret=0;\n            ++cur;\n            while(s[cur].size()>=d+2)ret+=dfs(d+1);\n        }\n        else if(s[cur][d]=='*'){\n            ret=1;\n            ++cur;\n            while(s[cur].size()>=d+2)ret*=dfs(d+1);\n        }\n    }\n    return ret;\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        cur=0;\n        rep(i,n) s[i].clear();\n        rep(i,n) cin>>s[i];\n        cout<<dfs(0)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <climits>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\n\nstruct Edge {\n    int to, cost, nm;\n    Edge(int to, int cost, int nm): to(to), cost(cost), nm(nm) {}\n};\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<Edge>> AdjList;\nAdjList graph;\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nconst int INF = 100000000;\n\nll GCD(ll a, ll b){\n    if(a < b) swap(a, b);\n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\nbool cmp(const pii& a, const pii& b){\n    if(a.first == b.first){\n        return a.second < b.second;\n    }\n    return a.first < b.first;\n}\n\n\nint N, M;\nint arr[100010];\n\n\nint main() {\n\n    int n;\n    //cout << fixed << setprecision(2);\n\n    while(cin >> n) {\n        if (n == 0) break;\n\n        stack<pair<char, int>> st;\n        stack<pair<int, int>> st2;\n        vector<pair<string, int>> v;\n        int prev_len = -1;\n\n        for(int i=0; i<n; ++i){\n            string s; cin >> s;\n            v.push_back(make_pair(s, (int)s.size()));\n        }\n        for (int i = 0; i < n; ++i) {\n            string s = v[i].first;\n\n            int len = s.size();\n            char c = s[len-1];\n            if(i){\n                if(v[i].second < v[i-1].second){\n\n                    while(1) {\n                        char c2 = st.top().first;\n                        int len2 = st.top().second;\n\n                        if (len > len2) break;\n\n                        st.pop();\n                        int t = st2.top().first;\n                        st2.pop();\n                        while(st2.size() && st2.top().second == len2 + 1){\n                            if(c2== '*'){\n                                t = t * st2.top().first;\n                            }else if( c2 == '+'){\n                                t = t + st2.top().first;\n                            }\n                            st2.pop();\n                        }\n\n                        st2.push(make_pair(t, len2));\n                    }\n\n                }\n            }\n\n            if(c == '*' || c == '+'){\n                st.push(make_pair(c, len));\n            }else if(c >= '0' && c <= '9'){\n                st2.push(make_pair(c-'0', len));\n            }\n        }\n\n        while(st.size()){\n            char c = st.top().first;\n            int len = st.top().second;\n\n            st.pop();\n            int t = st2.top().first;\n            st2.pop();\n            while(st2.size()!=0 && st2.top().second == len+1){\n                if(c == '*'){\n                    t = t * st2.top().first;\n                }else if(c == '+'){\n                    t = t + st2.top().first;\n                }\n                st2.pop();\n            }\n            st2.push(make_pair(t, len));\n        }\n\n        cout << st2.top().first << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#include<stack>\n#define INF 2147483647\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<string>vs(n);\n    for(int i=0;i<n;i++)cin>>vs[i];\n    vector<pair<int,int> >sp;\n    vector<pair<int,char> >sta;\n    for(int i=0;i<n;i++){\n      string str=vs[i];\n      if(!sta.empty()&&(str.size()!=(sta[sta.size()-1].F+1))){\n\tif(sta[sta.size()-1].S=='+'){\n\t  int sum=0;\n\t  while(sp[sp.size()-1].S==sta[sta.size()-1].F+1){\n\t    int num=sp[sp.size()-1].F;\n\t    sp.pop_back();\n\t    sum+=num;\n\t  }\n\t  //cout<<sum<<endl;\n\t  sp.pb(mp(sum,sta[sta.size()-1].F));\n\t  sta.pop_back();\n\t}else if(sta[sta.size()-1].S=='*'){\n\t  int sum=1;\n\t  while(sp[sp.size()-1].S==sta[sta.size()-1].F+1){\n\t    int num=sp[sp.size()-1].F;\n\t    sp.pop_back();\n\t    sum*=num;\n\t  }\n\t  //cout<<sum<<endl;\n\t  sp.pb(mp(sum,sta[sta.size()-1].F));\n\t  sta.pop_back();\n\t}\n\ti--;\n      }else if(str[str.size()-1]=='+'){\n\tsta.pb(mp(str.size(),'+'));\n      }else if(str[str.size()-1]=='*'){\n\tsta.pb(mp(str.size(),'*'));\n      }else{\n\tif((sta.empty())||(str.size()==(sta[sta.size()-1].F+1))){\n\t  char ccc=str[str.size()-1];\n\t  int nnn=ccc-'0';\n\t  sp.pb(mp(nnn,str.size()));\n\t}\n      }\n    }\n    while(sta.size()!=1){\n      if(sta[sta.size()-1].S=='+'){\n\tint sum=0;\n\twhile(sp[sp.size()-1].S==sta[sta.size()-1].F+1){\n\t  int num=sp[sp.size()-1].F;\n\t  sp.pop_back();\n\t  sum+=num;\n\t}\n\tsp.pb(mp(sum,sta[sta.size()-1].F));\n\tsta.pop_back();\n      }else if(sta[sta.size()-1].S=='*'){\n\tint sum=1;\n\twhile(sp[sp.size()-1].S==sta[sta.size()-1].F+1){\n\t  int num=sp[sp.size()-1].F;\n\t  sp.pop_back();\n\t  sum*=num;\n\t}\n\tsp.pb(mp(sum,sta[sta.size()-1].F));\n\tsta.pop_back();\n      }\n    }\n    int ans=0;\n    if(sta[0].S=='+'){\n      for(int i=0;i<sp.size();i++){\n\tans+=sp[i].F;\n\t//cout<<sp[i].F<<endl;\n      }\n    }else{\n      ans=1;\n      for(int i=0;i<sp.size();i++){\n\tans*=sp[i].F;\n\t//cout<<sp[i].F<<endl;\n      }\n    }\n    //cout<<sta.size()<<\" \"<<sp.size()<<endl;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define FOR(i,n,m) for(ll i=n; i<(ll)m;i++)\n#define FORr(i,n,m) for(ll i=n; i>=(ll)m; i--)\n#define FORm(i,m) for(auto i=m.begin();i!=m.end();i++)\n#define VEC2(x,a,b) vector<vector<ll>> x = vector<vector<ll>>(a,vector<ll>(b,0))\n#define sortAl(v) sort(v.begin(),v.end())\n#define sortAlr(v) sort(v.begin(),v.end()); reverse(v.begin(),v.end())\n#define cinv(v,n,m) FOR(i,n,m) cin>>v.at(i)\n#define coutv(v,n,m) FOR(i,n,m) cout<<v.at(i) <<\" \"; cout<<endl\n#define cout(n) cout<<fixed<<setprecision(n)\n\nll p;\nll n;\nchar c[100];\nvector<string> v(200);\n\nll solve(ll k){\n\n  ll res=0;\n  if(0<=v[p][k]-'0' && v[p][k]-'0'<=9) return v[p][k]-'0';\n  else if(v[p][k]=='+'){\n    //cout<<\"plus\"<<endl;\n    res=0;\n    p++;\n    k++;\n    //cout<<n<<\" \"<<p<<endl;\n    while( v[p][k]=='.' ||v[p][k]=='+' ||v[p][k]=='*' ||(0<=v[p][k]-'0' && v[p][k]-'0'<=9 ) ){\n      res+=solve(k);\n      p++;\n    }\n  }\n  else if(v[p][k]=='*'){\n    //cout<<\"mult\"<<endl;\n    res=1;\n    p++;\n    k++;\n    while( v[p][k]=='.' ||v[p][k]=='+' ||v[p][k]=='*' ||(0<=v[p][k]-'0' && v[p][k]-'0'<=9 ) ){\n      res*=solve(k);\n      p++;\n    }\n  }\n  p--;\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin>>n;\n  while(n>0){\n    vector<string> s(200);\n    v=s;\n    FOR(i,0,n){\n      cin>>v[i];\n    }\n    p=0;\n    cout<<solve(0)<<endl;\n    cin>>n;\n  }\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,k,n) for(int i=(int)(k);i<(int)(n);i++)\n\n#define vi vector<int>\n#define pb push_back\n\nint mul(int depth);\n\nchar s[50][100];\nint n;\nint g;\n\nint plu(int depth){\n    int res = 0;\n    while(true){\n        g++;\n        if(s[g][depth] != '.'){\n            g--;\n            return res;\n        }else if(s[g][depth+1] == '+'){\n            res += plu(depth+1);\n        }else if(s[g][depth+1] == '*'){\n            res += mul(depth+1);\n        }else{\n            res += (s[g][depth+1]-'0');\n        }\n        if(g>n) break;\n    }\n}\n\nint mul(int depth){\n    int res = 1;\n    while(true){\n        g++;\n\n        if(s[g][depth] != '.'){\n            g--;\n            return res;\n        }else if(s[g][depth+1] == '+'){\n            res *= plu(depth+1);\n        }else if(s[g][depth+1] == '*'){\n            res *= mul(depth+1);\n        }else{\n            res *= (s[g][depth+1]-'0');\n        }\n        if(g>n) break;\n    }\n}\n\nint main(){\n//    ifstream in(\"c_in.txt\");\n//    cin.rdbuf(in.rdbuf());\n    while(cin >> n,n){\n        rep(i,50)rep(j,100) s[i][j] = ' ';\n        g = 0;\n        rep(i,n) {\n            string ss;\n            cin >> ss;\n            ss.copy(s[i],ss.size());\n        }\n\n        int ans;\n        if(s[0][0]=='+'){\n            ans = plu(0);\n        }else if(s[0][0]=='*'){\n            ans = mul(0);\n        }else{\n            ans = (s[0][0] - '0');\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint Solve(int n, const vector<string> &op) {\n    // + := -1, - := -2, * := -3\n    vector<pair<int, int>> cur(n, make_pair<int, int>(0, 0));\n    for (int i = 0; i < n; ++i) {\n        cur[i].first = op[i].size() - 1;\n        if (op[i].back() == '+')\n            cur[i].second = -1;\n        else if (op[i].back() == '*')\n            cur[i].second = -2;\n        else\n            cur[i].second = (int)(op[i].back() - '0');\n    }\n\n    while (cur.size() != 1) {\n        int h = -1, src = -1, dst = -1;\n\n        for (size_t i = 0; i < cur.size(); ++i)\n            if (h < cur[i].first)\n                h = cur[i].first;\n        for (size_t i = 0; i < cur.size(); ++i) {\n            if (src == -1 && cur[i].first == h)\n                src = i;\n            else if (cur[i].first == h)\n                dst = i;\n            else if (dst != -1 && cur[i].first < h)\n                break;\n        }\n\n        int res = 0;\n        if (cur[src - 1].second == -1) { // +\n            for (int i = src; i <= dst; ++i)\n                res += cur[i].second;\n            cur[src - 1].second = res;\n        }\n        else if (cur[src - 1].second == -2) { // *\n            res = cur[src].second;\n            for (int i = src + 1; i <= dst; ++i)\n                res *= cur[i].second;\n            cur[src - 1].second = res;\n        }\n\n        cur.erase(cur.begin() + src, cur.begin() + dst + 1);\n    }\n\n    return cur[0].second;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n\n    while (cin >> n, n) {\n        vector<string> op(n);\n        for (int i = 0; i < n; ++i)\n            cin >> op[i];\n\n        cout << Solve(n, op) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<string> v(n);\n        for (auto & i : v) {\n            cin >> i;\n        }\n        if(n == 1){\n            cout << v.front() << \"\\n\";\n            continue;\n        }\n        stack<int> s;\n        for (int i = 0; i < n; ++i) {\n            int m = (int)v[i].size()-1;\n            while(s.size() > 2*m) {\n                s.pop();\n                int x = s.top(); s.pop();\n                int y = s.top(); s.pop();\n                int z = s.top(); s.pop();\n                if(y == -1) x += z;\n                else x *= z;\n                s.emplace(x);\n                s.emplace(y);\n            }\n            if(v[i].back() == '+') s.push(0), s.push(-1);\n            else if(v[i].back() == '*') s.push(1), s.push(-2);\n            else {\n                int x = v[i].back()-'0';\n                int y = s.top(); s.pop();\n                int z = s.top(); s.pop();\n                if(y == -1) x += z;\n                else x *= z;\n                s.emplace(x);\n                s.emplace(y);\n            }\n        }\n        while(s.size() > 2) {\n            s.pop();\n            int x = s.top(); s.pop();\n            int y = s.top(); s.pop();\n            int z = s.top(); s.pop();\n            if(y == -1) x += z;\n            else x *= z;\n            s.emplace(x);\n            s.emplace(y);\n        }\n        s.pop();\n        cout << s.top() << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nstring s[100];\nint cur;\nint dfs(int d){\n    int ret;\n    if(isdigit(s[cur][d])) return s[cur++][d]-'0';\n    else{\n        if(s[cur][d]=='+'){\n            ret=0;\n            ++cur;\n            while(s[cur].size()==d+2)ret+=dfs(d+1);\n        }\n        else if(s[cur][d]=='*'){\n            ret=1;\n            ++cur;\n            while(s[cur].size()==d+2)ret*=dfs(d+1);\n        }\n    }\n    return ret;\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        cur=0;\n        rep(i,100) s[i].clear();\n        rep(i,n) cin>>s[i];\n        cout<<dfs(0)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int n; cin >> n;\n    if (!n) break;\n    V<string> s(n); for (auto&& e : s) cin >> e;\n    reverse(begin(s), end(s));\n    V< pair<int, int> > v;\n    for (const auto& e : s) {\n      if (isdigit(e.back())) {\n        v.emplace_back(e.back() - '0', e.size());\n      } else {\n        if (e.back() == '+') {\n          int s = 0;\n          while (!v.empty() and v.back().second > (int)e.size()) {\n            s += v.back().first;\n            v.pop_back();\n          }\n          v.emplace_back(s, e.size());\n        } else {\n          int s = 1;\n          while (!v.empty() and v.back().second > (int)e.size()) {\n            s *= v.back().first;\n            v.pop_back();\n          }\n          v.emplace_back(s, e.size());\n        }\n      }\n    }\n    cout << v.back().first << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<fstream>\nusing namespace std;\nint num;\nint fin;\nbool f = false;\nstring tmp ;\nint saiki_mul(int);\nint saiki_plus(int len) {\n\tfin++;\n\tstring str;\n\tcin >> str;\n\tif(fin==num) {\n\t\tif (str.size() < len) {\n\t\t\ttmp = str;\n\t\t}\n\t\treturn str[str.size() - 1] - '0';\n\t}\n\telse if (str.size() < len) {\n\t\ttmp = str;\n\t\treturn 0;\n\t}\n\telse {\n\t\tint i;\n\t\tif (str[str.size() - 1] == '+') {\n\t\t\ti= saiki_plus(len + 1);\n\t\t}\n\t\telse if (str[str.size() - 1] == '*') {\n\t\t\ti= saiki_mul(len + 1);\n\t\t}\n\t\telse {\n\t\t\ti = (str[str.size() - 1] - '0') + saiki_plus(len);\n\t\t}\n\t\tif (tmp.size() == len) {\n\t\t\tif (tmp[tmp.size() - 1] == '+') {\n\t\t\t\ttmp = \"\";\n\t\t\t\treturn i+saiki_plus(len + 1);\n\t\t\t}\n\t\t\telse if (tmp[tmp.size() - 1] == '*') {\n\t\t\t\ttmp = \"\";\n\t\t\t\treturn i+saiki_mul(len + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ti += (int)(tmp[tmp.size() - 1] - '0');\n\t\t\t\ttmp = \"\";\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t}\n}\n\nint saiki_mul(int len) {\n\tfin++;\n\tstring str;\n\tcin >> str;\n\tif(fin == num){\n\t\tif (str.size() < len) {\n\t\t\ttmp = str;\n\t\t\treturn 1;\n\t\t}\n\t\treturn str[str.size() - 1] - '0';\n\t}\n\telse if (str.size() < len) {\n\t\ttmp = str;\n\t\treturn 1;\n\t}\n\telse {\n\t\tint i;\n\t\tif (str[str.size() - 1] == '+') {\n\t\t\ti= saiki_plus(len + 1);\n\t\t}\n\t\telse if (str[str.size() - 1] == '*') {\n\t\t\ti= saiki_mul(len + 1);\n\t\t}\n\t\telse {\n\t\t\ti= (str[str.size() - 1] - '0') * saiki_mul(len);\n\t\t}\n\t\tif (tmp.size() == len) {\n\t\t\tif (tmp[tmp.size() - 1] == '+') {\n\t\t\t\ttmp = \"\";\n\t\t\t\treturn i+saiki_plus(len + 1);\n\t\t\t}\n\t\t\telse if (tmp[tmp.size() - 1] == '*') {\n\t\t\t\ttmp = \"\";\n\t\t\t\treturn i+saiki_mul(len + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ti *= (int)(tmp[tmp.size() - 1] - '0');\n\t\t\t\ttmp = \"\";\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t}\n}\n\n\nint main() {\n\tstring s;\n\twhile (cin >> num &&num != 0) {\n\t\tcin >> s;\n\t\tfin = 1;\n\t\tif (num == 1)cout << s << endl;\n\t\telse if (s == \"+\") {\n\t\t\tint i = saiki_plus(2);\n\t\t\tif (tmp != \"\") {\n\t\t\t\tcout << i + (int)(tmp[tmp.size() - 1]-'0') << endl;\n\t\t\t\ttmp = \"\";\n\t\t\t}\n\t\t\telse\n\t\t\t\tcout << i << endl;\n\t\t}\n\t\telse {\n\t\t\tint i = saiki_mul(2);\n\t\t\tif (tmp != \"\") {\n\t\t\t\tcout << i*(int)(tmp[tmp.size() - 1]-'0') << endl;\n\t\t\t\ttmp = \"\";\n\t\t\t}\n\t\t\telse\n\t\t\t\tcout << i << endl;\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\nconst long long int MOD = 1000000007;\nconst int INF = 1000000000;\n\nint n;\nchar ope[15];\nll val[15];\n\nvoid solve(){\n    string str;\n    rep(i,15) ope[i] = '_';\n    rep(i,15) val[i] = 0;\n    ope[0] = '+';\n    val[0] = 0;\n    if(n == 1){\n        cin >> str;\n        cout << str << endl;\n        return;\n    }\n    rep(i,n){\n        cin >> str;\n        for(int j = 14; j >= str.size(); j--){\n            if(j <= 1) break;\n            if(ope[j-1] == '_') continue;\n            if(ope[j-2] == '+'){\n                val[j-2] += val[j-1];\n            } else{\n                val[j-2] *= val[j-1];\n            }\n            ope[j-1] = '_';\n        }\n        int j;\n        for(j = 0; j < str.size(); j++){\n            if(str[j] != '.') break;\n        }\n        if('0' <= str[j] && str[j] <= '9'){\n            if(ope[j-1] == '+'){\n                val[j-1] += str[j]-'0';\n            } else{\n                val[j-1] *= (str[j]-'0');\n            }\n        } else{\n            ope[j] = str[j];\n            if(ope[j] == '+') val[j] = 0;\n            else val[j] = 1;\n        }\n    }\n    for(int j = 14;; j--){\n        if(j <= 1) break;\n        if(ope[j-1] == '_') continue;\n        if(ope[j-2] == '+'){\n            val[j-2] += val[j-1];\n        } else{\n            val[j-2] *= val[j-1];\n        }\n        ope[j-1] = '_';\n    }\n    cout << val[0] << endl;\n}\n\nint main(){\n    while(cin >> n){\n        if(n == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\n\nvector<pair<int, char>> expr;\nint idx = 0;\n\nint calc() {\n    int ret;\n    int depth = expr[idx].first;\n    char op = expr[idx].second;\n    idx++;\n\n    if (op == '+') ret = 0;\n    else if (op == '*') ret = 1;\n    else ret = op - '0';\n\n    while (idx < expr.size() && expr[idx].first == depth + 1) {\n        int val;\n        if (expr[idx].second == '+' || expr[idx].second == '*') {\n            val = calc();\n        } else {\n            val = expr[idx++].second - '0';\n        }\n\n        if (op == '+') {\n            ret += val;\n        } else if (op == '*') {\n            ret *= val;\n        }\n    }\n    return ret;\n}\n\nvoid solve(int n) {\n    idx = 0;\n    expr.clear();\n    for (int i = 0; i < n; i++) {\n        string s; cin >> s;\n        int depth = s.size() - 1;\n        char c = s[s.size() - 1];\n        expr.push_back({depth, c});\n    }\n    cout << calc() << endl;\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        solve(n);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <cassert>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < n; i++)\nint n;\nvector<string>a;\nint dfs(int now, int depth, bool flag){\n    int res = 0;\n    if(flag)res = 1;\n    for(int i = now; i < n and depth < a[i].size(); i++){\n        int t = 0;\n//        cout << i << \" \" << depth << \" \" <<  a[i][depth]<< endl;\n        if(isdigit(a[i][depth]))t = a[i][depth]-'0';\n        else if(a[i][depth] == '+')t = dfs(i+1,depth+1,false);\n        else if(a[i][depth] == '*')t = dfs(i+1,depth+1,true);\n        else continue;\n        if(flag)res *= t;\n        else res += t;\n    }\n//    cout << now << \" \" << depth << \" \" << res << endl;\n    return res;\n}\nint main(){\n    while(cin >> n and n > 0){\n        a.resize(n);\n        rep(i,n)cin >> a[i];\n        cout << dfs(0,0,0) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <functional>\n\n#define REP(i,a,b) for(int i=int(a);i<int(b);i++)\n\nusing namespace std;\n\ntypedef long long int lli;\n\nint main () {\n    int n;\n    while (cin >> n, n) {\n        vector<string> v(n);\n        REP (i, 0, n) cin >> v[i];\n        function<int(int&,int)> c = [&](int &index, int depth) -> int {\n            char clast = v[index][v[index].size() - 1];\n            if (clast == '+') {\n                int res = 0;\n                while (index + 1 < (int)v.size() && (int)v[index + 1].size() > depth) {\n                    res += c(++index, depth + 1);\n                }\n                return res;\n            } else if (clast == '*') {\n                int res = 1;\n                while (index + 1 < (int)v.size() && (int)v[index + 1].size() > depth) {\n                    res *= c(++index, depth + 1);\n                }\n                return res;\n            } else {\n                return clast - '0';\n            }\n        };\n        int dummy = 0;\n        cout << c(dummy, v[dummy].size()) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nint n;\nvector<string> s;\n\nint dfs(int &i, int lev) {\n    if (isdigit(s[i][lev])) {\n        return s[i++][lev] - '0';\n    } else if (s[i][lev] == '+') {\n        ++i;\n        int res = 0;\n        while (i < n && s[i].size() == lev + 2) {\n            res += dfs(i, lev + 1);\n        }\n        return res;\n    } else {\n        ++i;\n        int res = 1;\n        while (i < n && s[i].size() == lev + 2) {\n            res *= dfs(i, lev + 1);\n        }\n        return res;\n    }\n}\n\nvoid _main() {\n    while (cin >> n, n) {\n        s.resize(n);\n        REP (i, n) cin >> s[i];\n        int i = 0;\n        cout << dfs(i, 0) << endl;\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n    _main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mux_n = 2000;\n\nenum _operator{\n    _plus,\n    multiply,\n    none\n};\n\nint main() {\n\n    while(1){\n\n        int n;\n\n        cin >> n;\n\n        if(n==0) break;\n\n        string input[n];\n\n        vector<vector<long long int> > level_num;\n        vector<_operator> level_ope;\n\n        level_num.resize(mux_n);\n\n\n        for(int i=0; i<mux_n; i++){\n            level_ope.push_back(none);\n        }\n\n        int max_level = 0;\n\n        for(int i=0; i<n; i++){\n            cin >> input[i];\n            for(int j=0; j<input[i].size(); j++){\n                if(input[i][j] == '+'){\n                    level_ope[j] = _plus;\n                }\n                else if(input[i][j] == '*'){\n                    level_ope[j] = multiply;\n                }\n                else if(input[i][j] != '.'){\n                    stringstream ss;\n                    ss << input[i][j];\n                    int input_num;\n                    ss >> input_num;\n                    level_num[j].push_back(input_num);\n                }\n                max_level = max(max_level,j);\n            }\n        }\n\n        long long int ans = 0;\n        int now_level = max_level;\n\n        while(now_level){\n            if(level_ope[now_level-1] != none){\n                long long int sum;\n                if(level_ope[now_level-1] == _plus){\n                    sum = 0;\n                    for(int i=0; i<level_num[now_level].size(); i++){\n                        sum += level_num[now_level][i];\n                    }\n                }\n                else if(level_ope[now_level-1] == multiply){\n                    sum = 1;\n                    for(int i=0; i<level_num[now_level].size(); i++){\n                        sum *= level_num[now_level][i];\n                    }\n                }\n                if(now_level == 1) {\n                    ans = sum;\n                }\n                else{\n                    level_num[now_level-1].push_back(sum);\n                }\n            }\n            /*else if(level_num[now_level].size() == 1){\n                if(now_level == 1) {\n                    ans = level_num[now_level][0];\n                }\n                else{\n                    level_num[now_level-1].push_back(level_num[now_level][0]);\n                }\n            }*/\n            now_level--;\n        }\n\n        if(n == 1){\n            ans = level_num[0][0];\n        }\n\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=n-1; i>=0; i--)\n\nusing namespace std;\n\n\nint main(){\n\tfor(;;){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tvector<string> es;\n\t\t\n\t\trep(i, n){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tes.push_back(s);\n\t\t}\n\t\tstack<int> s;\n\t\tint lv = 0;\n\t\trrep(i, n){\n\t\t\tint l = 0;\n\t\t\tfor(;es[i][l] == '.'; ++l);\n\t\t\tfor(;lv<l; lv++) s.push(-1);\n\n\t\t\tif(es[i][l] == '+'){\n\t\t\t\tint v = 0;\n\t\t\t\tfor(; !s.empty(); ){\n\t\t\t\t\tif(s.top() == -1){\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tv += s.top(); s.pop();\n\t\t\t\t}\n\t\t\t\ts.push(v);\n\t\t\t}else if(es[i][l] == '*'){\n\t\t\t\tint v = 1;\n\t\t\t\tfor(; !s.empty(); ){\n\t\t\t\t\tif(s.top() == -1){\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tv *= s.top(); s.pop();\n\t\t\t\t}\n\t\t\t\ts.push(v);\n\t\t\t} else {\n\t\t\t\ts.push(es[i][l] - '0');\n\t\t\t}\n\t\t\tlv = l;\n\t\t}\n\t\t//cerr << \"# \" << s.size() << endl;\n\t\tcout << s.top() << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<climits>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nvoid solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        st.push(make_pair(th, l-1));\n    }\n}\nint main(){\n    int ca=0;\n    while(cin>>n,n){\n        while(ope.size())ope.pop();\n        while(st.size())st.pop();\n        if(ca++>5)return -1;\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    solve(level);\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        solve(0);\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nint add(vector<string>::iterator &itr);\nint mlt(vector<string>::iterator &itr);\n\nint main(){\n    while(true){\n        int n; cin >> n;\n        if( n == 0)break;\n        vector<string> s(n);\n        for(int i = 0; i < n; i++){\n            cin >> s[i];\n        }\n        int ans = 0;\n        for(vector<string>::iterator itr = s.begin(); itr != s.end(); ++itr){\n            if((itr->back()) == '+'){\n                ans += add(itr);\n            }\n            else if((itr->back()) == '*'){\n                ans += mlt(itr);\n            }\n            else{\n                ans += itr->back() - '0';\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\nint add(vector<string>::iterator &itr){\n    int c = itr->size()+1;\n    int ret = 0;\n    ++itr;\n    while((int)(itr->size()) == c){\n        if(itr->back() == '+'){\n            ret += add(itr);\n        }\n        else if((itr->back()) == '*'){\n            ret += mlt(itr);\n        }\n        else{\n            ret += itr->back() -'0';\n        }\n        ++itr;\n    }\n        \n    --itr;\n    return ret;\n}\n\nint mlt(vector<string>::iterator &itr){\n    int c = itr->size();\n    int ret = 1;\n    ++itr;\n    while((int)(itr->size()) == c+1){\n        if(itr->back() == '+'){\n            ret *= add(itr);\n        }\n        else if((char)(itr->back()) == '*'){\n            ret *= mlt(itr);\n        }\n        else{\n            ret *= itr->back() - '0';\n        }\n        ++itr;\n    }\n    --itr;\n    return ret;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<set>\n#include<map>\n#define INF 999999\n#define EPS 1.0e-6\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint n;\n\n//-1:+ 1:*\n\nint main()\n{\n\twhile (cin >> n) {\n\n\t\tif (n == 0)return 0;\n\n\t\tvector<int>v[15];\n\t\tint en[15];\n\t\tfor (int i = 0; i < 15; i++) {\n\t\t\ten[i] = 0;\n\t\t}\n\n\n\t\tstring a;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> a;\n\n\t\t\tint l = a.length() - 1;\n\t\t\tif (a[l] == '+')en[l] = -1;\n\t\t\telse if (a[l] == '*')en[l] = 1;\n\t\t\telse {\n\t\t\t\tv[l].push_back((int)(a[l] - '0'));\n\t\t\t}\n\n\t\t}\n\n\t\tfor (int i = 14; i >= 1; i--) {\n\t\t\tif (!v[i].empty()) {\n\t\t\t\tif (en[i - 1] == -1) {\n\t\t\t\t\tint num = 0;\n\t\t\t\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\t\t\t\tnum += v[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tv[i - 1].push_back(num);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint num = 1;\n\t\t\t\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\t\t\t\tnum *= v[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tv[i - 1].push_back(num);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << v[0][0] << endl;\n\t}\n\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n#include \"../dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define rep(i,n) for(ll i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(ll i=(a),i##_cond=(b);i<i##_cond;++i)\n#define ROF(i,a,b) for(ll i=(a)-1,i##_cond=(b);i>=i##_cond;--i)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend() //sortで大きい順\n#define UNIQUE(v) v.erase(unique(all(v)),v.end())\n#define SUM(a) accumulate(all(a),0)\n#define sz(x) ((ll)(x).size())\n#define pb push_back\n#define fst first\n#define snd second\n#define mp make_pair\n\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<ll,ll> pii;\n\nconst ll inf = 1ll<<62;\nconst ll mod = 1e9+7;\n\nint main(){\n#define int ll\n  map<string,function<string(string,string)>> op;\n  auto add = [](string s, string t){\n    return to_string(stoi(s) + stoi(t));\n  };\n  op[\"+\"] = add;\n  auto mul = [](string s, string t){\n    return to_string(stoi(s) * stoi(t));\n  };\n  op[\"*\"] = mul;\n\n  map<string,string> e;\n  e[\"+\"] = \"0\";\n  e[\"*\"] = \"1\";\n  \n  while(1){\n    int n; cin >> n; if(n == 0) break;\n\n    vs in(n);\n    vi level(n);\n    int maxlevel = -1;\n    rep(i,n){\n      cin >> in[i];\n      level[i] = sz(in[i]) - 1;\n      maxlevel = max(maxlevel, level[i]);\n      in[i] = in[i][level[i]];\n    }\n    dump(in);\n    ROF(k,maxlevel,0){\n      /*\n      cout << k << endl;\n      cout << sz(in) << endl;\n      cout << sz(level) << endl;\n      */\n      ROF(i,sz(in),0){\n\tif(level[i] == k and op.count(in[i]) == 1){\n\t  string ope = in[i];\n\t  in[i] = e[in[i]];\n\t  int j = i+1;\n\t  while(1){\n\t    if(j == sz(in) or level[j] != k+1) break;\n\t    in[i] = op[ope](in[i], in[j]);\n\t    in.erase(in.begin() + j);\n\t    level.erase(level.begin() + j);\n\t  }\n\t  dump(in);\n\t}\n      }\n    }\n    cout << in[0] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\n\nint dfs(vector<string> s) {\n\n    char op = s[0][0];\n    int ans;\n    if (op == '+') {\n        ans = 0;\n        auto s_ = s;\n        s_.erase(s_.begin());\n        for (auto& i : s_)\n            i = string(i.begin() + 1, i.end());\n        vector<string> tmp;\n        for (auto i : s_) {\n            if ('0' <= i[0] && i[0] <= '9') {\n                if (tmp.size() > 0) ans += dfs(tmp);\n                ans += (int)(i[0] - '0');\n                tmp.resize(0);\n            } else if (i[0] == '*' || i[0] == '+') {\n                if (tmp.size() > 0) ans += dfs(tmp);\n                tmp.resize(0);\n                tmp.push_back(i);\n            } else {\n                tmp.push_back(i);\n            }\n        }\n        if (tmp.size() > 0)\n            ans += dfs(tmp);\n    }\n    else if (op == '*') {\n        ans = 1;\n        auto s_ = s;\n        s_.erase(s_.begin());\n        for (auto& i : s_)\n            i = string(i.begin() + 1, i.end());\n        vector<string> tmp;\n        for (auto i : s_) {\n            if ('0' <= i[0] && i[0] <= '9') {\n                if (tmp.size() > 0) ans *= dfs(tmp);\n                ans *= (int)(i[0] - '0');\n                tmp.resize(0);\n            } else if (i[0] == '+' || i[0] == '*') {\n                if (tmp.size() > 0) ans *= dfs(tmp);\n                tmp.resize(0);\n                tmp.push_back(i);\n            } else {\n                tmp.push_back(i);\n            }\n        }\n        if (tmp.size() > 0)\n            ans *= dfs(tmp);\n    }\n    else {\n        ans = (int)(op - '0');\n    }\n\n    return ans;\n}\n\nvoid solve() {\n    vector<string> v(N);\n    for (auto& i : v) cin >> i;\n\n    cout << dfs(v) << endl;\n}\n\nint main() {\n    while (cin >> N, N) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint i, n, val[50], depth[50];\n\nint func(){\n\tint ans, now;\n\n\tif(isdigit(val[i])){\n\t\treturn val[i++] - '0';\n\t}\n\n\tnow = i++;\n\tans = 1;\n\tif(val[now] == '+'){\n\t\twhile(depth[now] == depth[i]-1){\n\t\t\tans += func();\n\t\t}\n\t\tans--;\n\t} else{\n\t\twhile(depth[now] == depth[i]-1){\n\t\t\tans *= func();\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(void){\n\tint  ans;\n\tchar tmp[50];\n\n\twhile(1){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%s\", tmp);\n\t\t\tdepth[i] = strlen(tmp)-1;\n\t\t\tval[i] = tmp[depth[i]];\n\t\t}\n\n\t\ti = 0;\n\t\tans = func();\n\t\tprintf(\"%d\\n\", ans);\n\t}//endwhile\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint n;\nchar buff[17][10];\n\nint calc(int line) {\n\tchar c;\n\tint level, val, arg;\n\tlevel = strlen(buff[line]) - 1;\n\tc = buff[line][level];\n\tswitch(c){\n\tcase'*':\n\t\tline++;\n\t\tval = 1;\n\t\twhile (1){\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval *= arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tcase'+':\n\t\tline++;\n\t\tval = 0;\n\t\twhile (1) {\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval += arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tdefault:\n\t\treturn c;;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%s\", buff[i][0]);\n\t\t\tprintf(\"%d\\n\", calc(0));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nwhile True:\n    n = input()\n    lst = []\n    if n == 0:\n        break\n    if n == 1:\n        num = input()\n        print num\n        continue\n    for loop in range(n):\n        S = raw_input()\n        lst.append((len(S), S[-1]))\n    if lst[0][1] == '+':\n        lst.append((0, '0'))\n    else:\n        lst.append((0, '1'))\n    n += 1\n    \n    c_lst = [0 for i in range(1000)]\n    v_lst = [0 for i in range(1000)]\n\n    rank = 1\n    for i in range(n):\n        r = lst[i][0]\n        c = lst[i][1]\n        while r < rank:\n            if c_lst[rank - 1] == '+':\n                v_lst[rank - 1] += v_lst[rank]\n            else:\n                v_lst[rank - 1] *= v_lst[rank]\n            rank -= 1\n        if c == '+':\n            r += 1\n            c_lst[r] = '+'\n            v_lst[r] = 0\n            rank += 1\n            continue\n        elif c == '*':\n            r += 1\n            c_lst[r] = '*'\n            v_lst[r] = 1\n            rank += 1\n            continue\n        if c_lst[r] == '+':\n            v_lst[r] += int(c)\n        else:\n            v_lst[r] *= int(c)\n    print v_lst[2]\n    \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<climits>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nvoid solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        st.push(make_pair(th, l-1));\n    }\n}\nint main(){\n    while(cin>>n,n){\n        if(ope.size())return -1;\n        if(st.size())return -1;\n        while(ope.size())ope.pop();\n        while(st.size())st.pop();\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    solve(level);\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        solve(0);\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint n;\nchar buff[17][10];\n\nint calc(int line) {\n\tchar c;\n\tint level, val, arg;\n\tlevel = strlen(buff[line]) - 1;\n\tc = buff[line][level];\n\tswitch(c){\n\tcase'*':\n\t\tline++;\n\t\tval = 1;\n\t\twhile (1){\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval *= arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tcase'+':\n\t\tline++;\n\t\tval = 0;\n\t\twhile (1) {\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval += arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tdefault:\n\t\treturn c;\n\t\tbreak;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)return 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%s\", buff[i][0]);\n\t\t\tprintf(\"%d\\n\", calc(0));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstring s[100];\npair<int, char> p[100];\nint n;\nint add(int&, int);\nint mul(int&, int);\n\nint add(int& idx, int par) {\n  // cout << idx << \" \" << p[idx].second << \" add\" << endl;\n  int ret = 0;\n  while(idx < n) {\n    // cout << idx << \" \" << p[idx].first << \" \" << p[idx-1].first << endl;\n    if(p[idx].first <= par) {\n      break;\n    } else if(p[idx].second == '+') {\n      idx++;\n      ret += add(idx, p[idx-1].first);\n    } else if(p[idx].second == '*') {\n      idx++;\n      ret += mul(idx, p[idx-1].first);\n    } else {\n      ret += p[idx].second - '0';\n      idx++;\n    }\n    // cout << idx << \" \" << ret << \" add\" << endl;\n  }\n  return ret;\n}\n\nint mul(int &idx, int par) {\n  // cout << idx << \" \" << p[idx].second << \" mul\" << endl;\n  int ret = 1;\n  while(idx < n) {\n    // cout << idx << \" \" << p[idx].first << \" \" << p[idx-1].first << endl;\n    if(p[idx].first <= par) {\n      break;\n    } else if(p[idx].second == '+') {\n      idx++;\n      ret *= add(idx, p[idx-1].first);\n    } else if(p[idx].second == '*') {\n      idx++;\n      ret *= mul(idx, p[idx-1].first);\n    } else {\n      ret *= p[idx].second - '0';\n      idx++;\n    }\n    // cout << idx << \" \" << ret << \" mul\" << endl;\n  }\n  return ret;\n}\n\nsigned main(void)\n{\n  while(true) {\n    cin >> n;\n    if(!n) break;\n    REP(i, n) cin >> s[i];\n\n    REP(i, n) p[i].first = 0;\n    REP(i, n) {\n      REP(j, s[i].size()) {\n        if(s[i][j] == '.') p[i].first++;\n        else p[i].second = s[i][j];\n      }\n    }\n    if(n == 1) {\n      cout << p[0].second << endl;\n      continue;\n    }\n\n    int ret;\n    if(p[0].second == '+') {\n      int st = 1;\n      ret = add(st, 0);\n    } else {\n      int st = 1;\n      ret = mul(st, 0);\n    }\n\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define RFOR(i,k,n) for (int (i)=(n)-1; (i)>=(k); --(i))\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define pb push_back\n#define mp make_pair\n#define all(v) begin(v), end(v)\n#define fst first\n#define snd second\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\nusing namespace std;\n\nint main(){\n    int n;\n    vector<string> s;\n    while(cin>>n && n){\n        s.resize(n);\n        REP(i,n){\n            cin >> s[i];\n        }\n        queue<pair<char,int> > Qa;\n        queue<char> Qb;\n        int lv,lvmax = 0;\n        RREP(i,n){\n            lv = s[i].length() - 1;\n            lvmax = max(lvmax, lv);\n            char c = s[i][lv];\n            if(c == '+' || c == '*'){\n                lv++;\n            }\n            Qa.push(mp(c,lv));\n        }\n        while(!Qa.empty() && lvmax >= 0){\n            int size = Qa.size();\n            REP(i,size){\n                auto p = Qa.front();\n                Qa.pop();\n                if(p.snd >= lvmax){\n                    Qb.push(p.fst);\n                }\n                else{\n                    Qa.push(p);\n                }\n            }\n            lvmax--;\n        }\n        REP(i,Qb.size()){\n            Qb.push(Qb.front());\n            Qb.pop();\n        }\n        stack <int> S;\n        while(!Qb.empty()){\n            if(Qb.front() == '+'){\n                int sum = 0;\n                while(!S.empty()){\n                    sum += (S.top());\n                    S.pop();\n                }\n                S.push(sum);\n            }\n            else if(Qb.front() == '*'){\n                int pro = 1;\n                while(!S.empty()){\n                    pro *= (S.top());\n                    S.pop();\n                }\n                S.push(pro);\n            }\n            else{\n                S.push(Qb.front() - '0');\n            }\n            Qb.pop();\n        }\n        cout << S.top() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint N;\n//n??????, dep:depth, o:operator< 0:= +, 1:= *>, str \"\nint calc(int& n,int dep, char o,vector<string>& str) {\n\tint ret;\n\tif (o == '+') ret = 0;\n\telse ret = 1;\n\t\n\tfor (;n < N;) {\n\t\tif (str[n].length() != dep + 1) { break; }\n\t\tif (str[n][dep] >= '0' && str[n][dep] <= '9') {\n\t\t\tif (o == '+') { ret += str[n][dep] - '0'; n++; }\n\t\t\telse { ret *= str[n][dep] - '0';n++; }\n\t\t}\n\t\telse {\n\t\t\tn++;\n\t\t\tcout << str[n - 1][dep] << endl;\n\t\t\tif (o == '+') { ret += calc(n, dep + 1, str[n-1][dep], str); }\n\t\t\telse { ret *= calc(n, dep + 1, str[n - 1][dep], str); }\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (cin >> N, N) {\n\t\tvector<string> str(N);\n\t\tfor (int i = 0; i < N;i++)cin >> str[i];\n\t\tint n = 0;\n\t\tcout << calc(n, 0, '+', str) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<climits>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nvoid solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        st.push(make_pair(th, l-1));\n    }\n}\nint main(){\n    int ca=0;\n    while(cin>>n,n){\n        while(ope.size())ope.pop();\n        while(st.size())st.pop();\n        if(ca++>85)return -1;\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    solve(level);\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        solve(0);\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint n;\nstring s[10];\nint calc(int a, int b, bool m) {\n\tint res = m;\n\tfor (int i = b; i < n; i++) {\n\t\tif (s[i].size() <= a)break;\n\t\tif ('0' <= s[i][a] && s[i][a] <= '9') {\n\t\t\tif (m)res *= s[i][a] - '0';\n\t\t\telse res += s[i][a] - '0';\n\t\t}\n\t\tif (s[i][a] == '*') {\n\t\t\tif (m)res *= calc(a + 1, i + 1, 1);\n\t\t\telse res += calc(a + 1, i + 1, 1);\n\t\t}\n\t\tif (s[i][a] == '+') {\n\t\t\tif (m)res *= calc(a + 1, i + 1, 0);\n\t\t\telse res += calc(a + 1, i + 1, 0);\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\twhile (scanf(\"%d\", &n), n) {\n\t\trep(i, n)cin >> s[i];\n\t\tprintf(\"%d\\n\", calc(0, 0, 0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\n\nvoid Push(stack<long long> &st, long long val) {\n    int op = st.top(); st.pop();\n    long long back = st.top(); st.pop();\n    if (op == -1) back += val;\n    else back *= val;\n    st.push(back);\n    st.push(op);\n}\n\nvoid Pop(stack<long long> &st) {\n    st.pop();\n    long long val = st.top(); st.pop();\n    int op = st.top(); st.pop();\n    long long back = st.top(); st.pop();\n    if (op == -1) back += val;\n    else back *= val;\n    st.push(back);\n    st.push(op);\n}\n\nvoid print(stack<long long> st) {\n    while (!st.empty()) {\n        cout << st.top() << \", \";\n        st.pop();\n    }\n    cout << endl;\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\tif (n == 0) break;\n        if (n == 1) {\n            int num; cin >> num;\n            cout << num << endl;\n        }\n        else {\n            stack<long long> st;\n            for (int _ = 0; _ < n; ++_) {\n                string str; cin >> str;\n                int s = (int)str.size() - 1;\n\n                while (st.size() > s * 2) Pop(st);\n                if (str.back() == '+') st.push(0), st.push(-1);\n                else if (str.back() == '*') st.push(1), st.push(-2);\n                else Push(st, str.back() - '0');\n                \n                //print(st);\n            }\n            while (st.size() > 2) Pop(st);\n            st.pop();\n            cout << st.top() << endl;\n        }\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main() {\n  int n;\n  while ( cin >> n, n ) {\n    int ans = 0;\n    vector<P> dat(n);    \n    for ( int i = 0; i < n; i++ ) {      \n      string s;\n      cin >> s;\n      dat[i].first = (int)s.size()-1;\n      if ( s[s.size()-1] == '+' ) dat[i].second = -1;\n      else if ( s[s.size()-1] == '*' ) dat[i].second = -2;\n      else dat[i].second = s[s.size()-1]-'0';      \n    }\n\n    while ( 1 ) {      \n      /*for ( int i = 0; i < dat.size(); i++ ) {\n\tif ( i ) cout << \" \";\n\tcout << dat[i].first << \" \" << dat[i].second;\n      }\n      cout << endl << endl;;*/\n      if ( dat.size() == 1 ) break;\n      for ( int i = 0; i < dat.size(); i++ ) {\n\tif ( dat[i].second >= 0 ) continue;\n\tint c = dat[i].second;\n\tint d = dat[i].first;\t\n\tint sum;\n\tint cnt = 2;\n\tbool flag = false;\n\tif ( dat[i+1].second >= 0 && dat[i+2].second >= 0 && dat[i+1].first == dat[i+2].first ) {\n\t  flag = true;\n\t  //cout << 'a' << endl;\t    \t \n\t  sum = dat[i+1].second;\n\t  cnt = 2;\n\t  for ( int j = i+2; j < dat.size(); j++ ) {\n\t    //cout << sum << endl;\n\t    if ( dat[j].second < 0 ) break;\n\t    if ( dat[j].first != dat[i+1].first ) break; \n\t    if ( c == -1 ) {\n\t      sum += dat[j].second;\n\t    } else {\n\t      sum *= dat[j].second;\n\t    }\n\t    cnt++;\n\t  }\n\t}\t\n\tif ( flag ) {\n\t  //cout << i << \" \" << sum << \" \" << cnt << endl;\n\t  int tmp = dat[i].first;\n\t  for ( int j = i; j < i+cnt; j++ ) dat.erase(dat.begin()+i);\n\t  dat.insert(dat.begin()+i, P(tmp, sum));\n\t  break;\n\t}\n      }\n      if ( dat.size() == 1 ) break;\n    }\n\n    //cout << \"end\" << endl;\n    cout << dat[0].second << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nint line;\nvector<string> S;\nenum Operator { add, mul };\n\nint cnt(string s){\n    int ret=0;\n    for(auto c:s){\n        if(c=='.') ret++;\n        else break;\n    }\n    return ret;\n}\n\nint dfs(int depth){\n    string s=S[line];\n    if(isdigit(s[depth])){\n        return s[depth]-'0';\n    }else{\n        int ret;\n        if(s[depth]=='+'){\n            ret=0;\n            while(cnt(S[line+1])==depth+1){\n                line++;\n                ret+=dfs(depth+1);\n            }\n        }else if(s[depth]=='*'){\n            ret=1;\n            while(cnt(S[line+1])==depth+1){\n                line++;\n                ret*=dfs(depth+1);\n            }\n        }else{\n            cout<<\"error\"<<endl;\n            exit(1);\n        }\n        return ret;\n    }\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        S.clear();\n        line=0;\n        for(int i=0;i<n;i++){\n            string s;\n            cin>>s;\n            S.push_back(s);\n        }\n        cout<<dfs(0)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define enld '\\n'\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"Ofast\")\nconstexpr ll INF = 1e18;\nconstexpr int inf = 1e9;\nconstexpr double INFD = 1e100;\nconstexpr ll mod = 1000000007;\nconstexpr ll mod2 = 998244353;\nconst double PI = 3.1415926535897932384626433832795028841971;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n// ios::sync_with_stdio(false);\n// cin.tie(nullptr);\n// ---------------------------------------------------------------------------\nint N;\nvector<string> S;\n\nint dfs(int v,int w,char ope='_'){\n    int res = 0;\n    if(ope == '_'){\n        res = dfs(1,1,S[0][0]);\n    }else if(ope == '*'){\n        res = 1;\n        while(v < N){\n            if(S[v].size() <= w){\n                return res;\n            }\n            if(S[v][w] == '.'){\n                v++;\n                continue;\n            }\n            if(S[v][w] == '*'){\n                res *= dfs(v+1,w+1,'*');\n            }else if(S[v][w] == '+'){\n                res *= dfs(v+1,w+1,'+');\n            }else{\n                res *= S[v][w]-'0';\n            }\n            v++;\n        }\n    }else{\n        res = 0;\n        while(v < N){\n            if(S[v].size() <= w){\n                return res;\n            }\n            if(S[v][w] == '.'){\n                v++;\n                continue;\n            }\n            if(S[v][w] == '*'){\n                res += dfs(v+1,w+1,'*');\n            }else if(S[v][w] == '+'){\n                res += dfs(v+1,w+1,'+');\n            }else{\n                res += S[v][w] - '0';\n            }\n            v++;\n        }\n    }\n    return res;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    while(cin >> N){\n        if(N == 0) break;\n        S.resize(N);\n        for(int i=0; i<N; i++){\n            cin >> S[i];\n        }\n        if(N == 1){\n            cout << S[0] << enld;\n            continue;\n        }\n        cout << dfs(0,0) << enld;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi acos(-1.0)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint calc(vector<string> s, int &i){\n\tint depth = s[i].length(), n = s.size();\n\tchar c = s[i][depth-1];\n\tif (c == '+'){\n\t\tint res = 0;\n\t\ti++;\n\t\twhile (s[i].length() == depth+1 && i < n){\n\t\t\tres += calc(s, i);\n\t\t}\n\t\treturn res;\n\t}else if (c == '*'){\n\t\tint res = 1;\n\t\ti++;\n\t\twhile (s[i].length() == depth+1 && i < n){\n\t\t\tres *= calc(s, i);\n\t\t}\n\t\treturn res;\n\t}else{\n\t\ti++;\n\t\treturn c - '0';\n\t}\n}\n\nint main(){\n\tint n;\n\twhile (cin >> n && n){\n\t\tvector<string> s(n);\n\t\tREP(i,n) cin >> s[i];\n\t\tint i = 0;\n\t\tcout << calc(s, i) << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n\nusing namespace std;\nusing P = pair<char, int>;\n\nvector<P> v;\n\nconst int tokadd = -1;\nconst int tokmul = -2;\nconst int toklvl = -3;\n\nint tokenize(char c) {\n    int n = c - '0';\n    if (n >= 0 && n <= 9) return n;\n    if (c == '+') return tokadd;\n    if (c == '*') return tokmul;\n    return toklvl;\n}\n\nint i = 0;\n\nint compute() {\n    int level = v[i].first;\n    int token = v[i].second;\n    //cout << string(level * 2, ' ') << \"now in \" << i << \" lvl = \" << level << \" tok = \" << token << endl;\n    int val = token;\n    if (val < 0) {\n        val = token == tokadd ? 0 : 1;\n        i++;\n        while (v[i].first == level + 1 && v.size() > i) {\n            if (token == tokadd) {\n                val += compute();\n            } else {\n                val *= compute();\n            }\n            i++;\n        }\n        i--;\n    }\n    //cout << string(level * 2, ' ') << \"val = \" << val <<  endl;\n    return val;\n}\n\nint add() {\n    return 0;\n}\n\nint main() {\n    while(1) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n        v.clear();\n        string s;\n        for (int i = 0; i < n; ++ i) {\n            cin >> s;\n            int level = s.size() - 1;\n            P vi = make_pair(level, tokenize(s[s.size() - 1]));\n            v.push_back(vi);\n        }\n        i = 0;\n        cout << compute() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(idx,a,b) for(int idx=(a);idx<(b);idx++)\n#define rrep(idx,a,b) for(int idx=(b)-1;idx>=(a);idx--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nvector<string> v;\nint idx = 0;\nint solve() {\n\tchar b = v[idx].back();\n\tif (b == '+') {\n\t\tint ret = 0;\n\t\tint i = idx;\n\t\tidx++;\n\t\twhile (v[i].size() < v[idx].size()) {\n\t\t\tret += solve();\n\t\t\tidx++;\n\t\t}\n\t\tidx--;\n\t\treturn ret;\n\t}\n\telse if (b == '*') {\n\t\tint ret = 1;\n\t\tint i = idx;\n\t\tidx++;\n\t\twhile (v[i].size() < v[idx].size()) {\n\t\t\tret *= solve();\n\t\t\tidx++;\n\t\t}\n\t\tidx--;\n\t\treturn ret;\n\t}\n\telse {\n\t\treturn b - '0';\n\t}\n}\n\nsigned main() {\n\tfor (string s; cin >> s;) v.emplace_back(s);\n\tv.emplace_back(\"0\");\n\tcout << solve() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<sstream>\nusing namespace std;\ntypedef long long ll;\nstring i2s(ll x){\n  if(x==0) return \"0\";\n  string y;\n  ll k=1;\n  while(x>=k) k*=10;\n  k/=10;\n  for(ll i=k;i>0;i/=10){\n    y+=(x/i)%10+'0';\n  }\n  return y;\n}\nll s2i(string x){\n  for(ll i=0;i<x.size();i++) if(x[i]=='.') x[i]=' ';\n  stringstream ss(x);\n  ll y;\n  ss >> y;\n  return y;\n}\nint main(){\n  //cout << i2s(100) << endl;\n  ll n;\n  \n  while(cin>>n,n){\n    string buf;\n    vector<string> v;\n    vector<ll> d;\n    ll i,j,k;\n    for(i=0;i<n;i++){\n      cin >> buf;\n      j=0;\n      while(buf[j]=='.') j++;\n      v.push_back(buf);\n      d.push_back(j);\n    }\n    while(v.size()!=1){\n      //for(i=0;i<v.size();i++) cout << v[i] << endl;\n      //cout << endl;\n      //cout << v.size() << endl;\n      k=1;\n      for(i=0;i<v.size();i++){\n        if(d[k]<d[i]) k=i;\n      }\n      //cout << k << \":\" << v[k-1][v[k-1].size()-1] << endl;\n      if(v[k-1][v[k-1].size()-1]=='+'){\n        i=0;j=0;\n        while(1) {\n          if(d[k]!=d[k+i]) break;\n          //j*=(v[k+i][v[k+i].size()-1]-'0');\n          j+=s2i(v[k+i]);\n          i++;\n          if(k+i==d.size()) break;\n        }\n        //cout << i << \":\" << j << endl;\n        v[k-1]=v[k-1].substr(0,v[k-1].size()-1);\n        v[k-1]+=i2s(j);\n        v.erase(v.begin()+k,v.begin()+k+i);\n        d.erase(d.begin()+k,d.begin()+k+i);\n      }\n      if(v[k-1][v[k-1].size()-1]=='*'){\n        i=0;j=1;\n        while(1) {\n          if(d[k]!=d[k+i]) break;\n          //j*=(v[k+i][v[k+i].size()-1]-'0');\n          j*=s2i(v[k+i]);\n          i++;\n          if(k+i==d.size()) break;\n        }\n        //cout << i << endl;\n        v[k-1]=v[k-1].substr(0,v[k-1].size()-1);\n        v[k-1]+=i2s(j);\n        v.erase(v.begin()+k,v.begin()+k+i);\n        d.erase(d.begin()+k,d.begin()+k+i);\n      }\n        \n    }\n    cout << v[0] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\ntypedef vector<pair<int,string> > vpis;\nint parse(const vpis &v,int l,int r){\n\tif(v[l].second!=\"+\"&&v[l].second!=\"*\")return strtol(v[l].second.c_str(),NULL,10);\n\tint unit=v[l].second==\"+\"?0:1;\n\tfor(int i=l+1;i<r;){\n\t\tint j=i+1;\n\t\tif(v[i].second==\"+\"||v[i].second==\"*\"){\n\t\t\tfor(;v[j].first>v[i].first;j++);\n\t\t}\n\t\tint n=parse(v,i,j);\n\t\ti=j;\n\t\tif(v[l].second==\"+\")unit+=n;\n\t\telse unit*=n;\n\t}\n\treturn unit;\n}\nint main(){\n\tint N;\n\tstring s;\n\tfor(;cin>>N,N;){\n\t\tvpis v(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>s;\n\t\t\tint idx=0;\n\t\t\tfor(;s[idx]=='.';idx++);\n\t\t\tv[i]=make_pair(idx,s.substr(idx));\n\t\t}\n\t\tprintf(\"%d\\n\",parse(v,0,N));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> a;\nint dfs(int depth,int index,bool plus){\n  int ans;\n  if(plus){\n    ans = 0;\n    for(int i = index+1;i < a.size();i++){\n      if(a[i].size() <= depth)return ans;\n      else if(a[i][depth] == '.')continue;\n      else if(a[i][depth] == '+')\n        ans += dfs(depth+1,i,true);\n      else if(a[i][depth] == '*'){\n        ans += dfs(depth+1,i,false);\n      }else{\n          ans += a[i][depth] - '0';\n      }\n    }\n  }else{\n    ans = 1;\n    for(int i = index+1;i < a.size();i++){\n      if(a[i].size() <= depth)return ans;\n      else if(a[i][depth] == '.')continue;\n      else if(a[i][depth] == '+')\n        ans *= dfs(depth+1,i,true);\n      else if(a[i][depth] == '*'){\n        ans *= dfs(depth+1,i,false);\n      }else{\n          ans *= a[i][depth] - '0';\n      }\n    }\n  }\n  return ans;\n}\n\nint main(){\n  int n;\n  while(cin >> n,n){\n    a.resize(n);\n    for(int i = 0;i<n;i++){\n      cin >> a[i];\n    }\n    if(n == 1)cout << a[0] << endl;\n    else cout << dfs(1,0,a[0][0] == '+') << endl;\n    a.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,k,n) for(int i=(int)(k);i<(int)(n);i++)\n\n#define vi vector<int>\n#define pb push_back\n\nint mul(int depth);\n\nchar s[50][100];\nint n;\nint g;\n\nint plu(int depth){\n    int res = 0;\n    while(true){\n        g++;\n        if(s[g][depth] != '.'){\n            g--;\n            return res;\n        }else if(s[g][depth+1] == '+'){\n            res += plu(depth+1);\n        }else if(s[g][depth+1] == '*'){\n            res += mul(depth+1);\n        }else{\n            res += (s[g][depth+1]-'0');\n        }\n        if(g>n) break;\n    }\n}\n\nint mul(int depth){\n    int res = 1;\n    while(true){\n        g++;\n\n        if(s[g][depth] != '.'){\n            g--;\n            return res;\n        }else if(s[g][depth+1] == '+'){\n            res *= plu(depth+1);\n        }else if(s[g][depth+1] == '*'){\n            res *= mul(depth+1);\n        }else{\n            res *= (s[g][depth+1]-'0');\n        }\n        if(g>n) break;\n    }\n}\n\nint main(){\n//    ifstream in(\"c_in.txt\");\n//    cin.rdbuf(in.rdbuf());\n    while(cin >> n,n){\n        rep(i,50)rep(j,100) s[i][j] = ' ';\n        g = 0;\n        rep(i,n) {\n            string ss;\n            cin >> ss;\n            ss.copy(s[i],ss.size());\n        }\n\n        int ans;\n        if(s[0][0]=='+'){\n            ans = plu(0);\n        }else if(s[0][0]=='*'){\n            ans = mul(0);\n        }else{\n            ans = (s[0][0] - '0');\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst long long LINF = 1e18;\n#define dump(x)  cout << 'x' << ' = ' << (x) << ` `;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define REPR(i,n) for(int i=n;i>=0;i--)\n#define FOREACH(x,a) for(auto& (x) : (a) )\ntypedef long long ll;\nusing namespace std;\n\ntypedef struct Edge{\n    int to, cost;\n} Edge;\n\n\ntypedef pair<int, int> P;\nint n;\nvector<string> in;\nvector<P> nums;\nvector<vector<Edge>> g;\n\nvoid print(vector<Edge> &x) {\n    int n = x.size();\n    cout << \"{\";\n    REP(i,n) {\n        if (i != n-1) cout << x[i].to << \" \";\n        else cout << x[i].to;\n    }\n    cout<< \"}\" << endl;\n}\n\nint calc(int id, int sign) {\n    // cout << \"id = \" << id << endl;\n    // print(g[id]);\n    if (g[id].size() == 0) {\n        return (int)(in[id].back()-'0');\n    }\n    int ret = 0;\n    if (sign == 11) ret = 1;\n    for (auto &&e: g[id]) {\n        if (sign == 10) {\n            ret += calc(e.to, e.cost);\n        }\n        else if (sign == 11) {\n            ret *= calc(e.to, e.cost);\n        }\n    }\n    return ret;\n}\n\n// + = 10, * = 11\n\nint main(int argc, char const *argv[]) {\n    vector<int> ans;\n    while (cin >> n, n) {\n        in.resize(n);\n        g.resize(n);\n        REP(i,n) cin >> in[i];\n        REP(i,n) {\n            int cnt = in[i].size();\n            if (in[i].back() != '+' && in[i].back() != '*') continue;\n            for (int j = i+1; j < n; ++j) {\n                if (in[j].size()-cnt == 1) {\n                    Edge e;\n                    e.to = j;\n                    if (in[j].back() == '+') e.cost = 10;\n                    else if (in[j].back() == '*') e.cost = 11;\n                    else e.cost = in[j].back()-'0';\n                    g[i].push_back(e);\n                }\n                else if (in[j].size() == cnt) break;\n            }\n        }\n        int x;\n        if (in[0][0] == '+') x = 10;\n        else if (in[0][0] == '*') x = 11;\n        else x = (int)in[0][0]-'0';\n        cout << (calc(0, x)) << endl;\n        in.clear();\n        g.clear();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool isnum(string s) { return '0' <= s[0] && s[0] <= '9'; }\nint toi(string s) { return s[0]-'0'; }\nint calc(string op, int a, int b) { return (op == \"+\") ? a + b : a * b; }\n\nint parse(vector<string> vs) {\n    if (isnum(vs[0])) return toi(vs[0]);\n\n    for (int i=1; i<(int)vs.size(); ++i) {\n        vs[i] = vs[i].substr(1);\n    }\n    int res = (vs[0] == \"+\" ? 0 : 1);\n    int k = 1;\n    while (k < (int)vs.size()) {\n        if (isnum(vs[k])) {\n            res = calc(vs[0], res, toi(vs[k++]));\n         } else {\n            vector<string> t(1, vs[k++]);\n            while (k < (int)vs.size() && vs[k][0] == '.') {\n                t.push_back(vs[k++]);\n            }\n            res = calc(vs[0], res, parse(t));\n        }\n    }\n    return res;\n}\n\nint main() {\n    int n;\n    while (cin >> n) {\n        if (!n) break;\n        vector<string> vs(n);\n        for (int i=0; i<n; ++i) {\n            cin >> vs[i];\n        }\n        cout << parse(vs) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define mp make_pair\nint cs(string s){int a=0;rep(i,s.size())if(s[i]=='.')a++;return a;}\nsigned main(){\n    int n;\n    while(cin>>n,n){\n        using pci =  pair<int,char>;\n        vector<pci>v;\n        rep(i,n){\n            string s; cin>>s;\n            int val=cs(s);\n            v.push_back(mp(val,s.back()));\n        }\n        map<int,char>opt;\n        sort(all(v));\n        vector<pci>rec;\n        rep(i,v.size())\n        if('0'>v[i].second||'9'<v[i].second)opt[v[i].first+1]=v[i].second;\n        else rec.push_back(v[i]);\n        sort(all(rec),greater<pci>());\n        int now=0;\n        int temp=0;\n        rep(i,rec.size()){\n            if(now!=rec[i].first || i==0){\n                now=rec[i].first;\n                if(opt[rec[i].first]=='*'&&temp)temp*=rec[i].second-'0';\n                else temp+=rec[i].second-'0';\n            }else{\n                int rank=rec[i].first;\n                if(opt[rank]=='*')temp*=rec[i].second-'0';\n                if(opt[rank]=='+')temp+=rec[i].second-'0';\n            }\n        }\n        cout<<temp<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<vector>\n#include<iostream>\nusing namespace std;\ntypedef long long ll;\n\nll n, d[1000000], e[1000000]; // e: 0+ 1*\nstring s;\n\nint main() {\n  while (scanf(\"%lld\", &n), n) {\n    d[0] = 0, e[0] = 0;\n    ll mx = 0;\n    for (ll i = 0; i < n; i++) {\n      cin >> s;\n      ll sz = s.size()-1;\n      while (mx != sz) {\n        if (e[mx-1]) d[mx-1] *= d[mx];\n        else d[mx-1] += d[mx];\n        mx--;\n      }\n      if (s[sz] == '+') mx++, e[mx] = 0, d[mx] = 0;\n      else if (s[sz] == '*') mx++, e[mx] = 1, d[mx] = 1;\n      else {\n        if (e[mx]) d[mx] *= s[sz] - '0';\n        else d[mx] += s[sz] - '0';\n      }\n    }\n    while (mx != 0) {\n      if (e[mx-1]) d[mx-1] *= d[mx];\n      else d[mx-1] += d[mx];\n      mx--;\n    }\n    printf(\"%lld\\n\", d[0]);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\tstring s;\n\twhile (cin >> n, n) {\n\t\tvector<int> st, ope, cnt;\n\t\tcnt.push_back(0);\n\t\tint tmp = 0;\n\t\twhile (n--) {\n\t\t\tcin >> s;\n\t\t\tfor (int i = 0; i < tmp - (int)s.size(); i++) {\n\t\t\t\tint val = ope.back() ? 0 : 1;\n\t\t\t\twhile (cnt.back()--) {\n\t\t\t\t\tint sb = st.back();\n\t\t\t\t\tval = ope.back() ? val + sb : val * sb;\n\t\t\t\t\tst.pop_back();\n\t\t\t\t}\n\t\t\t\tst.push_back(val);\n\t\t\t\tcnt.pop_back();\n\t\t\t\tope.pop_back();\n\t\t\t}\n\t\t\tif (isdigit(s.back())) {\n\t\t\t\tst.push_back(s.back() - '0');\n\t\t\t\tcnt.back()++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcnt.back()++;\n\t\t\t\tope.push_back(s.back() == '+' ? 1 : 0);\n\t\t\t\tcnt.push_back(0);\n\t\t\t}\n\t\t\ttmp = s.size();\n\t\t}\n\t\twhile (!ope.empty()) {\n\t\t\tint val = ope.back() ? 0 : 1;\n\t\t\twhile (cnt.back()--) {\n\t\t\t\tint sb = st.back();\n\t\t\t\tval = ope.back() ? val + sb : val * sb;\n\t\t\t\tst.pop_back();\n\t\t\t}\n\t\t\tst.push_back(val);\n\t\t\tcnt.pop_back();\n\t\t\tope.pop_back();\n\t\t}\n\t\tcout << st.back() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define all(a) a.begin(),a.end()\n\nint solve(vector<string> &s,int n,int &y,int x){\n    if(isdigit(s[y][x])) return s[y++][x] - '0';\n    char op = s[y][x];\n    ++y,++x;\n    vector<int> term;\n    while(y < n && (int)s[y].size() > x){\n        term.push_back(solve(s,n,y,x));\n    }\n    if(op == '+') return accumulate(all(term),0);\n    else return accumulate(all(term),1,multiplies<int>());\n}\n\nint main(void){\n    int n;\n    while(cin>>n,n){\n        vector<string> s(n);\n        rep(i,n) cin>>s[i];\n        int y = 0;\n        cout<<solve(s,n,y,0)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\ntypedef pair<int, char> P;\n\npair<int, char> parse(string s) {\n    pair<int, char> ret(0, '.');\n    string::const_iterator pt = s.begin();\n    while (*pt == '.') {\n        pt++;\n        ret.first++;\n    }\n    ret.second = *pt;\n\n    return ret;\n}\n\nint expression(vector<P> vp, int &pt, int level = 0) {\n    if (isdigit(vp[pt].second)) {\n        return vp[pt++].second - '0';\n    } else if (vp[pt].second == '+') {\n        int ret = 0;\n        pt++;\n        while (pt < vp.size() && level < vp[pt].first) {\n            ret += expression(vp, pt, level + 1);\n        }\n        return ret;\n    } else {\n        int ret = 1;\n        pt++;\n        while (pt < vp.size() && level < vp[pt].first) {\n            ret *= expression(vp, pt, level + 1);\n        }\n        return ret;\n    }\n}\n\nbool solve() {\n    int n;\n    cin >> n;\n    if (n == 0) return false;\n    vector<P> lines;\n\n    rep(i, 0, n) {\n        string s;\n        cin >> s;\n        lines.push_back(parse(s));\n    }\n    int pt = 0;\n    int ans = expression(lines, pt);\n    cout << ans << endl;\n    return true;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (solve()) {\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nconst ll INF=1LL<<60;\nconst int inf=1<<30;\nconst int mod=1e9+7;\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while(cin >> n){\n        if(n==0){\n            return 0;\n        }\n        if(n==1){\n            int a;cin >> a;\n            cout << a << endl;\n            continue;\n        }\n        vector<bool> b(n);\n        vector<int> c(n+1,-1);\n        vector<int> d(n);\n        for(int i=0;i<n;i++){\n            string s;cin >> s;\n            d[i]=s.size();\n            if(i&&d[i]<d[i-1]){\n                for(int i=n-1;i>=s.size();i--){\n                    if(c[i]!=-1){\n                        if(b[i-1]){\n                            c[i-1]*=c[i];\n                        }\n                        else{\n                            c[i-1]+=c[i];\n                        }\n                        c[i]=-1;\n                    }\n                }\n            }\n            if(s[s.size()-1]=='+'){\n                b[s.size()]=false;\n                c[s.size()]=0;\n            }\n            else if(s[s.size()-1]=='*'){\n                b[s.size()]=true;\n                c[s.size()]=1;\n            }\n            else{\n                int p=s[s.size()-1]-'0';\n                if(b[s.size()-1]){\n                    c[s.size()-1]*=p;\n                }\n                else{\n                    c[s.size()-1]+=p;\n                }\n            }\n        }\n        for(int i=n-1;i>=2;i--){\n            if(c[i]!=-1){\n                if(b[i-1]){\n                    c[i-1]*=c[i];\n                }\n                else{\n                    c[i-1]+=c[i];\n                }\n                c[i]=-1;\n            }\n        }\n        cout << c[1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nstring s[100];\nint dfs(int d,int k){\n  bool e=0;\n  int res=0;\n  if(s[d][k]=='+')d++,k++;\n  if(s[d][k]=='*')e=1,d++,k++,res=1;\n  for(int i=d;i<n&&k<s[i].size();i++){\n    if(s[i][k]=='.')continue;\n    int a=s[i][k]-'0';\n    if(s[i][k]=='+'||s[i][k]=='*')a=dfs(i,k);\n    if(e)res*=a;\n    else res+=a;\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>s[i];\n    cout<<dfs(0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <cstdio>\nusing namespace std;\ntypedef long long int ll;\n\nvector<string> v;\n\nll solve(int x){\n    int n=v[x].size();\n    ll res=0;\n    if(v[x][n-1]=='+'){\n        x++;\n        while(x<v.size()&&n+1<=v[x].size()){\n            if(v[x].size()==n+1){\n                res+=solve(x);\n            }\n            x++;\n        }\n    }\n    else if(v[x][n-1]=='*'){\n        res=1; x++;\n        while(x<v.size()&&n+1<=v[x].size()){\n            if(v[x].size()==n+1){\n                res*=solve(x);\n            }\n            x++;\n        }\n    }\n    else{\n        res=v[x][n-1]-'0';\n    }\n    return res;\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n;\n    while(cin >> n,n){\n        v.clear();\n        for(int i=0;i<n;i++){\n            string s; cin >> s;\n            v.push_back(s);\n        }\n        cout << solve(0) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <vector>\n\nint dots_num(std::string s) {\n    int num = 0;\n    int loop = 0;\n    while (s[loop] == '.') {\n        ++num; \n        ++loop;\n    }\n    return num;\n}\n\nint value_num(char c) {\n    int ret;\n    if (c == '+') {\n        ret = -1; \n    } else if (c == '*') {\n        ret = -2;\n    } else {\n        ret = (int) c - 48;\n    }\n    return ret;\n}\n\nvoid dfs(int n) {\n    std::string s;\n    std::stack<std::pair<int, int> > st;\n    st.push(std::make_pair(0, 0));\n    int dots;\n    int value;\n    int start_dots;\n    std::vector<int> enzan(2);\n    std::pair<int, int> p;\n\n    for (int i = 0; i < n; i++) {\n        std::cin >> s;\n        dots = dots_num(s);\n        value = value_num(s[dots]);\n\n\n        while (1) {\n            if (st.top().first <= dots) {\n                break; \n            }\n            start_dots = st.top().first;\n            enzan[0] = 0;\n            enzan[1] = 1;\n            while (1) {\n                if (start_dots > st.top().first) {\n                    break;\n                }\n                enzan[0] += st.top().second;\n                enzan[1] *= st.top().second;\n                st.pop();\n            }\n            if (st.top().second == -1) {\n                p = std::make_pair(st.top().first, enzan[0]);\n                st.pop();\n                st.push(p);\n            } else if(st.top().second == -2) {\n                p = std::make_pair(st.top().first, enzan[1]);\n                st.pop();\n                st.push(p);\n            }\n        }\n        st.push(std::make_pair(dots, value));\n    }\n\n    while (1) {\n        if (st.top().first == 0) {\n            break; \n        }\n        start_dots = st.top().first;\n        enzan[0] = 0;\n        enzan[1] = 1;\n        while (1) {\n            if (start_dots > st.top().first) {\n                break;\n            }\n            enzan[0] += st.top().second;\n            enzan[1] *= st.top().second;\n            st.pop();\n        }\n\n        if (st.top().second == -1) {\n            p = std::make_pair(st.top().first, enzan[0]);\n            st.pop();\n            st.push(p);\n        } else if(st.top().second == -2) {\n            p = std::make_pair(st.top().first, enzan[1]);\n            st.pop();\n            st.push(p);\n        }\n    }\n\n    std::cout << st.top().second << std::endl;\n    return;\n}\n\nint main(void) {\n    int n;\n\n    while (1) {\n        std::cin >> n;\n        if (n == 0) {\n            break;\n        }\n        dfs(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\ntypedef vector<pair<int,string> > vpis;\nint parse(const vpis &v,int l,int r){\n\tif(v[l].second!=\"+\"&&v[l].second!=\"*\")return strtol(v[l].second.c_str(),NULL,10);\n\tint unit=v[l].second==\"+\"?0:1;\n\tfor(int i=l+1;i<r;){\n\t\tint j=i+1;\n\t\tif(v[i].second==\"+\"||v[i].second==\"*\"){\n\t\t\tfor(;j<v.size()&&v[j].first>v[i].first;j++);\n\t\t}\n\t\tint n=parse(v,i,j);\n\t\ti=j;\n\t\tif(v[l].second==\"+\")unit+=n;\n\t\telse unit*=n;\n\t}\n\treturn unit;\n}\nint main(){\n\tint N;\n\tstring s;\n\tfor(;cin>>N,N;){\n\t\tvpis v(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>s;\n\t\t\tint idx=0;\n\t\t\tfor(;s[idx]=='.';idx++);\n\t\t\tv[i]=make_pair(idx,s.substr(idx));\n\t\t}\n\t\tprintf(\"%d\\n\",parse(v,0,N));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF = 1e9;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nint p; \nvector<string> S;\nint N;\n\nint solve(int level)\n{\n\n    if (isdigit(S[p][level])) {\n        return (S[p++][level] - '0');\n    }\n\n    while (true) {\n        // DUMP2(p, level);\n        if (p < N && S[p].size() < level) break;\n        if (S[p][level] == '+') {\n            p++; // skip '+'\n            int tmp = 0;\n            while (true) {\n                if (p >= N || S[p].size() <= level+1) break;\n                tmp += solve(level+1);\n            }\n            return tmp;\n        } else if (S[p][level] == '*') {\n            p++; // skip '*'\n            int tmp = 1;\n            while (true) {\n                if (p >= N || S[p].size() <= level+1) break;\n                tmp *= solve(level+1);\n            }\n            return tmp;\n        }\n    }\n\n    return -1;\n}\n\nint main()\n{\n    while (cin >> N, N) {\n        p = 0;\n        S.resize(N);\n        rep(i, N) cin >> S[i];\n        cout << solve(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e12;\nconst int inf = 1e9;\ntypedef long long ll;\ntypedef pair<ll,int> P;\ntypedef set<int> S;\nstring s[100];\nint n;\nint rec(int i){\n    int cnt=s[i].size();\n    if(s[i][cnt-1]>='0' && s[i][cnt-1]<='9') return s[i][cnt-1]-'0';\n    else if(s[i][cnt-1]=='+'){\n        int res=0,j=i+1;\n        while(s[j].size()>=cnt+1 && j<n ){\n            if(s[j].size()==cnt+1) res+=rec(j);\n            //cout<<res<<endl;\n\n            j++;\n        }\n        return res;\n    }\n    else{\n        int res=1,j=i+1;\n        while(s[j].size()>=cnt+1 && j<n){\n            if(s[j].size()==cnt+1) res*=rec(j);\n            j++;\n        }\n        return res;\n    }\n}\nint main(){\n    while(1){\n        cin>>n;\n        //for(int i=0;i<100;i++) s[i].clear();\n        if(n==0) break;\n        for(int i=0;i<n;i++) cin>>s[i];\n        cout<<rec(0)<<endl;\n    }\n    //cout<<rec(0)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<n; ++i)\n#define rep(i,n) reps(i,0,n)\n\npair<int, int> calc(vector<pair<char, int>>& exp, int h, int lv)\n{\n    char c = exp[h].first;\n    vector<int> v;\n    \n    if(isdigit(c)){\n        return {h+1, c-'0'};\n    }\n    \n    for(h++; h<exp.size() && exp[h].second > lv; ){\n        auto ret = calc(exp, h, lv+1);\n        v.push_back(ret.second);\n        h = ret.first;\n    }\n    \n    int ans;\n    \n    if(c == '+'){\n        ans = 0;\n        for(int x : v) ans += x;\n    }\n    else{\n        ans = 1;\n        for(int x : v) ans *= x;\n    }\n    \n    return {h, ans};\n}\n\nvoid solve(int n)\n{\n    vector<pair<char, int>> exp(n);\n    \n    rep(i, n){\n        string s;\n        cin >> s;\n        exp[i].first  = s[s.size()-1];\n        exp[i].second = s.size() - 1;\n    }\n    \n    cout << calc(exp, 0, 0).second << endl;\n}\n\nint main()\n{\n    int n;\n    \n    while(cin >> n, n){\n        solve(n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<climits>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nvoid solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        st.push(make_pair(th, l-1));\n    }\n}\nint main(){\n    int ca=0;\n    while(cin>>n,n){\n        while(ope.size())ope.pop();\n        while(st.size())st.pop();\n        if(ca++>185)return -1;\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    solve(level);\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        solve(0);\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <vector>\n\nint dots_num(std::string s); \nint value_num(char c); \nvoid inner_loop(std::stack<std::pair<int, int> > &st); \nvoid dfs(int n); \n\n\nint main(void) {\n    int n;\n\n    while (1) {\n        std::cin >> n;\n        if (n == 0) {\n            break;\n        }\n        dfs(n);\n    }\n    return 0;\n}\n\nint dots_num(std::string s) {\n    int num = 0;\n    int loop = 0;\n    while (s[loop] == '.') {\n        ++num; \n        ++loop;\n    }\n    return num;\n}\n\nint value_num(char c) {\n    int ret;\n    if (c == '+') {\n        ret = -1; \n    } else if (c == '*') {\n        ret = -2;\n    } else {\n        ret = (int) c - 48;\n    }\n    return ret;\n}\n\nvoid inner_loop(std::stack<std::pair<int, int> > &st) {\n    int start_dots;\n    std::vector<int> enzan(2);\n    start_dots = st.top().first;\n    std::pair<int, int> p;\n\n    enzan[0] = 0;\n    enzan[1] = 1;\n    while (1) {\n        if (start_dots > st.top().first) {\n            break;\n        }\n        enzan[0] += st.top().second;\n        enzan[1] *= st.top().second;\n        st.pop();\n    }\n    if (st.top().second == -1) {\n        p = std::make_pair(st.top().first, enzan[0]);\n        st.pop();\n        st.push(p);\n    } else if(st.top().second == -2) {\n        p = std::make_pair(st.top().first, enzan[1]);\n        st.pop();\n        st.push(p);\n    }\n    return;\n}\n\nvoid dfs(int n) {\n    std::string s;\n    std::stack<std::pair<int, int> > st;\n    st.push(std::make_pair(0, 0));\n    int dots;\n    int value;\n\n    for (int i = 0; i < n; i++) {\n        std::cin >> s;\n        dots = dots_num(s);\n        value = value_num(s[dots]);\n\n\n        while (1) {\n            if (st.top().first <= dots) {\n                break; \n            }\n            inner_loop(st); \n        }\n        st.push(std::make_pair(dots, value));\n    }\n\n    while (1) {\n        if (st.top().first == 0) {\n            break; \n        }\n        inner_loop(st); \n    }\n\n    std::cout << st.top().second << std::endl;\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<string> expr;\n\nint formula(int &p,int dep){\n    if(p>=expr.size()) return -1;\n    if(expr[p].size()-1<dep){\n        return -1;\n    }\n    if(isdigit(expr[p][dep])){\n        int res=expr[p][dep]-'0';\n        p++;\n        return res;\n    }\n    char op=expr[p][dep];\n    p++;\n    int res=(op=='+' ? 0 : 1);\n    while(p<expr.size()){\n        int rhs=formula(p,dep+1);\n        if(rhs==-1) break;\n        if(op=='+') res+=rhs;\n        else res*=rhs;\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        expr.clear();\n        expr.resize(n);\n        for(int i=0;i<n;i++) cin>>expr[i];\n        int p=0;\n        int res=formula(p,0);\n        cout<<res<<endl;\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint N;\nint dfs(int& i, int lv, VS& vs){\n  if(vs[i][lv] == '+'){\n\tint res = 0;\n\t++i;\n\twhile(i<N && vs[i][lv] == '.')\n\t  res += dfs(i, lv+1, vs);\n\treturn res;\n  }\n  else if(vs[i][lv] == '*'){\n\tint res = 1;\n\t++i;\n\twhile(i<N && vs[i][lv] == '.')\n\t  res *= dfs(i, lv+1, vs);\n\treturn res;\n  }\n\n  return vs[i++][lv] - '0';\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N,N){\n\tVS str(N);\n\tREP(i,N) cin >> str[i];\n\tint i = 0;\n\tcout << dfs(i, 0, str) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <set>\n#include <stdio.h>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nbool solve() {\n  int n;\n  cin >> n;\n  if (n == 0)\n    return false;\n  vector<string> s(n);\n  for (int i = 0; i < n; i++)\n    cin >> s[i];\n  reverse(s.begin(), s.end());\n  vector<long long> v;\n  int indent = 0;\n  for (int i = 0; i < n; i++) {\n    int ind = 0;\n    for (; s[i][ind] == '.'; ind++)\n      ;\n    if (indent < ind) {\n      for (int j = 0; j < ind - indent; j++)\n        v.push_back(-1);\n      indent = ind;\n    }\n    if (s[i][ind] == '+' || s[i][ind] == '*') {\n      long long ret = (s[i][ind] == '+') ? 0 : 1;\n      while (v[v.size() - 1] >= 0) {\n        if (s[i][ind] == '+') {\n          ret += v[v.size() - 1];\n        } else {\n          ret *= v[v.size() - 1];\n        }\n        v.pop_back();\n      }\n      v.pop_back();\n      v.push_back(ret);\n    } else {\n      v.push_back(s[i][ind] - '0');\n    }\n  }\n  cout << v[0] << endl;\n  return true;\n}\n\nint main() {\n  while (solve())\n    ;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint N;\nvector<tuple<char, int>> v;\nint idx;\n\nint solve(int depth) {\n  int d; char c; tie(d, c) = v[idx];\n  if(isdigit(c)) {\n    idx++;\n    return c - '0';\n  } else {\n    idx++;\n    int n1 = solve(depth + 1);\n    if(c == '+') {\n      while(1) {\n\tint d2; char c2; tie(d2, c2) = v[idx];\n\tif(d2 < depth + 1) break;\n\tn1 += solve(depth + 1);\n      }\n    }\n    else if(c == '-') {\n      while(1) {\n\tint d2; char c2; tie(d2, c2) = v[idx];\n\tif(d2 < depth + 1) break;\n\tn1 -= solve(depth + 1);\n      }\n    }\n    else if(c == '*') {\n      while(1) {\n\tint d2; char c2; tie(d2, c2) = v[idx];\n\tif(d2 < depth + 1) break;\n\tn1 *= solve(depth + 1);\n      }\n    }\n    else assert(0);\n    return n1;\n  }\n}\n\nint main() {\n  \n  while(cin >> N && N) {\n    v.clear();\n    rep(i, N) {\n      char c; cin >> c;\n      int depth = 0;\n      while(c == '.') {\n\tdepth ++;\n\tcin >> c;\n      }\n      \n      v.push_back(make_tuple(depth, c));\n    }\n    \n    idx = 0;\n    cout << solve(0) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nstring s[10];\nint dfs(int d,int k){\n  bool e=0;\n  int res=0;\n  if(s[d][k]=='+')d++,k++;\n  if(s[d][k]=='*')e=1,d++,k++,res=1;\n  for(int i=d;i<n&&k<s[i].size();i++){\n    int a=s[i][k]-'0';\n    if(s[i][k]=='.')continue;\n    if(s[i][k]=='+'||s[i][k]=='*')a=dfs(i,k);\n    if(e)res*=a;\n    else res+=a;\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>s[i];\n    cout<<dfs(0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<stack>\n\nusing namespace std;\n\nint n;\nvector<string> d;\nstack<int> stk;\n\nint solve(int level,int i,char op) {\n\t//serch\n\tint kazu = 0;\n\twhile (1) {\n\t\tif (d[i].size() - 1 < level)break;\n\n\t\tif (d[i][level] >= '0' && d[i][level] <= '9') {\n\t\t\tstk.push(d[i][level]-48);\n\t\t\tkazu++;\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ti=solve(level+1,i+1, d[i][level]);\n\t\t\tkazu++;\n\t\t}\n\n\t\tif (i == n)break;\n\t}\n\n\tint sum=0;\n\tfor (int j = 0; j < kazu; j++) {\n\t\tint t = stk.top();\n\t\tstk.pop();\n\t\t//cout << t << endl;\n\n\t\tif (j == 0) {\n\t\t\tsum += t;\n\t\t\tcontinue;\n\t\t}\n\n\t\telse {\n\t\t\tif (op == '*')sum *= t;\n\t\t\telse if (op == '+')sum += t;\n\t\t}\n\t}\n\tstk.push(sum);\n\treturn i;\n}\n\nint main() {\n\t\n\twhile (1) {\n\t\td.clear();\n\t\tif (!stk.empty())stk.pop();\n\n\t\tcin >> n;\n\n\t\tif (n == 0)break;\n\n\t\tif (n == 1) {\n\t\t\tint f;\n\t\t\tcin >> f;\n\t\t\tcout << f << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\td.push_back(str);\n\t\t}\n\n\t\tsolve(1, 1, d[0][0]);\n\t\t/*if (stk.size() != 1)cout << \"err\" << endl;\n\t\telse cout << stk.top() << endl;*/\n\t\tcout << stk.top() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nint n;\nstd::vector< std::string > ss;\n\ninline int getDots(std::string s) {\n    return s.rfind('.', s.length() - 1);\n}\n\nstd::pair<long long, int> calc(int depth, int i) {\n    int num = getDots(ss[i]) + 1;\n    if(depth > num) {\n        return {-1, i};\n    }\n\n    char c = ss[i][num];\n    if(c >= '0' && c <= '9') {\n        return {(long long)(c - '0'), i+1};\n    }\n\n    long long ans = (c == '+' ? 0 : 1);\n    int j = i + 1;\n    while(j < n) {\n        auto res = calc(depth + 1, j);\n        if(res.first == -1) {\n            break;\n        }\n        if(c == '+') {\n            ans += res.first;\n        } else {\n            ans *= res.first;\n        }\n        j = res.second;\n    }\n    return {ans, j};\n}\n\nint main() {\n    ss.resize(100);\n    while(std::cin >> n, n != 0) {\n        for(int i=0; i<n; ++i) {\n            std::cin >> ss[i];\n        }\n        std::cout << calc(0, 0).first << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \nint N;\nstring S[100];\n  \nint rec(int& idx, int depth)\n{\n  if(isdigit(S[idx][depth])) {\n    return(S[idx++][depth] - '0');\n  } else if(S[idx++][depth] == '+') {\n    int ret = 0;\n    while(S[idx].size() > depth + 1) ret += rec(idx, depth + 1);\n    return(ret);\n  } else {\n    int ret = 1;\n    while(S[idx].size() > depth + 1) ret *= rec(idx, depth + 1);\n    return(ret);\n  }\n}\n  \nint main()\n{\n  while(cin >> N, N) {\n    for(int i = 0; i < N; i++) cin >> S[i];\n    S[N] = \"\";\n    int idx = 0;\n    cout << rec(idx, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s[100];\nint n,j,i;\nint dfs(int p){\n  int res=0,o=s[j].size();\n  if(isdigit(s[j][p]))return s[j][p]-'0';\n  if(s[j][p]=='+')\n    while(s[j+1].size()>o)j++,res+=dfs(p+1);\n  else{\n    res=1;\n    while(s[j+1].size()>o)j++,res*=dfs(p+1);\n  }\n  return res;\n}\nint main(){\n  while(cin>>n,n){\n    for(j=i=0;i<n;i++)cin>>s[i];\n    cout<<dfs(0)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint n;\nchar buff[17][10];\n\nint calc(int line) {\n\tchar c;\n\tint level, val, arg;\n\tlevel = strlen(buff[line]) - 1;\n\tc = buff[line][level];\n\tswitch(c){\n\tcase'*':\n\t\tline++;\n\t\tval = 1;\n\t\twhile (1){\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval *= arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tcase'+':\n\t\tline++;\n\t\tval = 0;\n\t\twhile (1) {\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval += arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tdefault:\n\t\treturn c;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%s\", buff[i][0]);\n\t\t\tprintf(\"%d\\n\", calc(0));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<climits>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nvoid solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        st.push(make_pair(th, l-1));\n    }\n}\nint main(){\n    while(cin>>n,n){\n        if(ope.size())return -1;\n        while(ope.size())ope.pop();\n        while(st.size())st.pop();\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    solve(level);\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        solve(0);\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include <stack>\nusing namespace std;\nstruct P {\n\tint lev, num;\n};\n\nint n;\nstring s[50];\n\nint main() {\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (!n)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> s[i];\n\t\t}\n\n\t\tstack<char> cs;\n\t\tstack<P> ns;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t//cout << \"i:\" << i << endl;\n\t\t\tif (i != n && (s[i][s[i].length() - 1] == '+' || s[i][s[i].length() - 1] == '*')) {//演算子だったら\n\t\t\t\tif (cs.size() == s[i].length()-1) {//見ているレベルだったら\n\t\t\t\t\tcs.push(s[i][s[i].length() - 1]);\n\t\t\t\t}\n\t\t\t\telse {//見ているレベルより下だったら\n\n\t\t\t\t\t//現在のレベルの計算を行う。\n\t\t\t\t\tint calc;\n\t\t\t\t\tchar ope = cs.top();\n\t\t\t\t\tif (ope == '+')calc = 0;\n\t\t\t\t\telse calc = 1;\n\n\t\t\t\t\twhile (!ns.empty()) {\n\t\t\t\t\t\t//cout << \"c\" << endl;\n\t\t\t\t\t\tP p = ns.top();\n\t\t\t\t\t\tif (p.lev < cs.size())break;\n\t\t\t\t\t\tns.pop();\n\n\t\t\t\t\t\tif (ope == '+') {\n\t\t\t\t\t\t\tcalc += p.num;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcalc *= p.num;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcs.pop();\n\t\t\t\t\tns.push(P{ (int)cs.size(), calc });\n\t\t\t\t\ti--;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {//数値だったら\n\t\t\t\t//cout << \"a\" << endl;\n\t\t\t\tif (i != n && cs.size() == s[i].length() - 1) {//見ているレベルだったら\n\t\t\t\t\tns.push(P{(int)cs.size(), (int)(s[i][s[i].length() - 1]-'0') });\n\t\t\t\t}\n\t\t\t\telse {//見ているレベル以下だったら\n\t\t\t\t\t//cout << \"b\" << endl;\n\t\t\t\t\t//演算子がない場合は計算しない\n\t\t\t\t\tif (!cs.size())break;\n\n\t\t\t\t\t//現在のレベルの計算を行う。\n\t\t\t\t\tint calc;\n\t\t\t\t\tchar ope = cs.top();\n\t\t\t\t\tif (ope == '+')calc = 0;\n\t\t\t\t\telse calc = 1;\n\n\t\t\t\t\twhile(!ns.empty()) {\n\t\t\t\t\t\t//cout << \"c\" << endl;\n\t\t\t\t\t\tP p = ns.top();\n\t\t\t\t\t\tif (p.lev < cs.size())break;\n\t\t\t\t\t\tns.pop();\n\n\t\t\t\t\t\tif (ope == '+') {\n\t\t\t\t\t\t\tcalc += p.num;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcalc *= p.num;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcs.pop();\n\t\t\t\t\tns.push(P{(int)cs.size(), calc});\n\t\t\t\t\ti--;\n\t\t\t\t\tif (ns.size() == 1)i++;\n\t\t\t\t\t//cout << \"d\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (ns.top()).num << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "1\n9\n4\n+\n.1\n.2\n.3\n9\n+\n.0\n.+\n..*\n...1\n...*\n....1\n....2\n..0\n10\n+\n.+\n..6\n..2\n.+\n..1\n..*\n...7\n...6\n.3\n0\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<climits>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nvoid solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        st.push(make_pair(th, l-1));\n    }\n}\nint main(){\n    int ca=0;\n    while(cin>>n,n){\n        while(ope.size())ope.pop();\n        while(st.size())st.pop();\n        if(ca++>35)return -1;\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    solve(level);\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        solve(0);\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = long long int;\nusing ui64 = unsigned long long int;\n\n////////\n\nusing pic = pair<int,char>;\n#define mp make_pair\nusing psic = pair<stack<int>,char >;\n\npic parse(string &s){\n    return make_pair(s.length()-1,s[s.length()-1]);\n}\n\nvoid calc(deque<psic> &q, int lv){\n    while(q.size() > lv){\n        psic p = q.back();\n        \n        q.pop_back();\n        // cerr << q.size() << \" \" << p.second << endl;\n        if(p.second == '+'){\n            int ret = 0;\n            while(!p.first.empty()){\n                ret += p.first.top();\n                p.first.pop();\n            }\n            q.back().first.push(ret);\n        }\n        else if(p.second == '*'){\n            int ret = 1;\n            while(!p.first.empty()){\n                ret *= p.first.top();\n                p.first.pop();\n            }\n            q.back().first.push(ret);\n        }else assert(false);\n    }\n}\n\nint solve(deque<psic> &q){\n    calc(q,1);\n    psic p = q[0];\n    if(p.second == '+'){\n        int ret = 0;\n        while(!p.first.empty()){\n            ret += p.first.top();\n            p.first.pop();\n        }\n        return ret;\n    }\n    else if(p.second == '*'){\n        int ret = 1;\n        while(!p.first.empty()){\n            ret *= p.first.top();\n            p.first.pop();\n        }\n        return ret;\n    }else assert(false);\n}\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        int curlv = 0;\n        deque< psic > q;\n        q.push_back(mp(stack<int>(),'+'));\n\n        for(int i=0;i<n;i++){\n            string s;\n            cin >> s;\n            \n            pic ps = parse(s);\n            cerr << ps.first << \" \" << ps.second << endl;\n            if(ps.first < curlv){\n                calc(q,ps.first + 1);\n                curlv = ps.first;\n                if(ps.second == '+' || ps.second == '*'){\n                    psic ne;\n                    ne.second = ps.second;\n                    q.push_back(ne);\n                    curlv++;\n                } \n                else{\n                    q.back().first.push(((int)(ps.second-'0')));\n                }\n            }\n            else if(ps.first == curlv){\n                if(ps.second == '+' || ps.second == '*'){\n                    psic ne;\n                    ne.second = ps.second;\n                    q.push_back(ne);\n                    curlv++;\n                } \n                else{\n                    q.back().first.push(((int)(ps.second-'0')));\n                }\n            }else assert(false);\n        }\n        cout << solve(q) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#include<cctype>\n#include<queue>\n#include<deque>\n#include<regex>\n#include<stack>\n#include<stdio.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<iomanip>\n\n#define rep(i, n) for(int i=0;i<n;i++)\n\ntypedef int long long ll;\nusing namespace std;\ntypedef pair<int, int> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nconst ll MOD = 1e9 + 7;\nstatic const int MAX = 100;\nstatic const int INF = (1 << 23);\nchar changec(int c){\n    char a=char('0'+c);\n    return a;\n}\nint change(char c){\n    return int(c-'0');\n}\nbool check(int c){\n    if(c!=-1&&c!=-2)return true;\n    else return false;\n}\nvector<pair<int,int>> zyun(vector<pair<int,int>> v,int tens){\n  vector<pair<int,int>> ret;\n  int i=0;\n  while(i<v.size()){\n      //cout<<i<<endl;\n\n      if(!check(v[i].second)&&v[i].first==tens-1){//vが演算子である\n\n         if(i+1<v.size()&&check(v[i+1].second)&&v[i+1].first==tens){\n             int ii=i+1;int pu=1;int c=0;\n             while(true){\n                 if(ii>=v.size()||v[ii].first!=tens||!check(v[ii].second)){break;}\n                 else{\n                     c++;\n                     if(v[i].second==-2){\n                         pu+=v[ii].second;\n                         if(ii==i+1)pu-=1;\n                     }\n                     else{pu*=v[ii].second;}\n                     ii++;\n                 }\n             }\n\n             if(c>=2){\n                 ret.push_back({tens-1,pu});\n                 i=ii;\n             }else{\n                 ret.push_back(v[i]);\n                 i++;\n             }\n\n         }else{\n             ret.push_back(v[i]);\n             i++;\n         }\n      }else{\n          ret.push_back({v[i].first,v[i].second});\n          i++;\n      }\n\n\n\n  }\n    return ret;\n\n}\nint main() {\n    int n;\n    while(true) {\n        cin >> n;\n        if(n==0)break;\n        vector<pair<int,int>> v;\n        rep(i,n){\n            string s;\n            cin>>s;\n            int ten=0;\n            while(true){\n                if(s[ten]!='.')break;\n                ten++;\n            }\n            char c=s[s.size()-1];\n            if(c=='*'){\n                v.push_back({ten, -1});\n            }else if(c=='+'){\n                v.push_back({ten, -2});\n            }else {\n                v.push_back({ten, change(s[s.size() - 1])});\n            }\n        }\n        int k=0;\n\n//        rep(i,v.size()){\n//            cout<<v[i].first<<v[i].second<<endl;\n//        }\n//        cout<<endl;\nfor(int i=15;i>=1;i--){\n\n        //while(v.size()!=1){\n            v=zyun(v,i);\n//            if(k<2){\n//                rep(i,v.size()){\n//                    cout<<v[i].first<<v[i].second<<endl;\n//                }\n//                k++;\n//            }\n        }\n\n\n        cout<<v[0].second<<endl;\n    }\n\n\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <string>\n#include <cctype>\n\nint calc(const std::vector<std::string> &s, size_t &idx, size_t indent=0) {\n    if (!(idx < s.size() && indent < s[idx].length()))\n        return -1;\n\n    if (isdigit(s[idx][indent]))\n        return s[idx++][indent] - '0';\n\n    if (s[idx][indent] == '*') {\n        int res=1;\n        ++idx;\n        while (idx < s.size()) {\n            if (indent+2 == s[idx].length()) {\n                int tmp=calc(s, idx, indent+1);\n                if (tmp < 0) break;\n\n                res *= tmp;\n            } else {\n                break;\n            }\n        }\n\n        return res;\n    }\n\n    if (s[idx][indent] == '+') {\n        int res=0;\n        ++idx;\n        while (idx < s.size()) {\n            if (indent+2 == s[idx].length()) {\n                int tmp=calc(s, idx, indent+1);\n                if (tmp < 0) break;\n\n                res += tmp;\n            } else {\n                break;\n            }\n        }\n\n        return res;\n    }\n\n    return -2;\n}\n\nint solve_testcase() {\n    size_t n;\n    scanf(\"%zu\", &n);\n\n    if (n == 0)\n        return 1;\n\n    std::vector<std::string> s(n);\n    for (size_t i=0; i<n; ++i) {\n        char buf[1024];  // enough?\n        scanf(\"%s\", buf);\n        s[i] = buf;\n    }\n\n    size_t idx=0;\n    printf(\"%d\\n\", calc(s, idx));\n    return 0;\n}\n\nint main() {\n    while (!solve_testcase()) {}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\n#define pb push_back\n#define ll long long\nusing namespace std;\nvector<string> a;\nint n,l;\n\nint calc(int v){\n  char c=a[l][v];\n  char cc;\n  int r;\n  l++;v++;\n  //cout<<\":\"<<c<<endl;\n  if(l<n&&(a[l][v]=='+'||a[l][v]=='*')) r=calc(v);\n  else{\n    if(c=='*') r=1;\n    else if(c=='+') r=0;\n    else r=c-'0';\n  }\n  if(l>=n) return r;\n  if(c=='+'){\n    while(a[l].size()==v+1){\n      cc=a[l][v];\n      //cout<<cc<<endl;\n      if(l+1<n&&(cc=='+'||cc=='*')) r+=calc(v);\n      else {r+=cc-'0';l++;}\n      \n    }\n  }\n  else if(c=='*'){\n    while(a[l].size()==v+1){\n      cc=a[l][v];\n      if(l+1<n&&(cc=='+'||cc=='*')) r*=calc(v);\n      else {r*=cc-'0';l++;}\n      \n    }\n  }\n  //cout<<r<<endl;\n  return r;\n}\n\nint main(){\n  int i;\n  while(cin >> n,n){\n    string s;\n    a.clear();\n    for(i=0;i<n;i++){\n      cin >> s;\n      a.pb(s);\n    }\n    l=0;\n    cout << calc(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=3005,INF=1<<29;\ntypedef string::const_iterator State;\nvector<string> S(MAX);\n\nint expr(int &when,int depth){\n    \n    if(S[when][depth]=='+'){\n        int ret=0;\n        for(;;){\n            when++;\n            if(when==S.size()||S[when].size()<=depth+1){\n                when--;\n                break;\n            }\n            ret+=expr(when,depth+1);\n        }\n        \n        return ret;\n    }else if(S[when][depth]=='*'){\n        int ret=1;\n        for(;;){\n            when++;\n            if(when==S.size()||S[when].size()<=depth+1){\n                when--;\n                break;\n            }\n            ret*=expr(when,depth+1);\n        }\n        \n        return ret;\n    }else{\n        return int(S[when][depth]-'0');\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N;cin>>N;\n        if(N==0) break;\n        S.resize(N);\n        for(int i=0;i<N;i++){\n            cin>>S[i];\n        }\n        int a=0;\n        cout<<expr(a,0)<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nint n;\nvs v;\n\nint solve(int r, int c)\n{\n\tif (v[r][c] == '+')\n\t{\n\t\tint res = 0;\n\t\tint p = r + 1;\n\t\twhile (p < n && v[p][c] == '.')\n\t\t{\n\t\t\tif (v[p][c + 1] != '.')\n\t\t\t{\n\t\t\t\tres += solve(p, c + 1);\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\treturn res;\n\t}\n\telse if(v[r][c] == '*')\n\t{\n\t\tint res = 1;\n\t\tint p = r + 1;\n\t\twhile (p < n && v[p][c] == '.')\n\t\t{\n\t\t\tif (v[p][c + 1] != '.')\n\t\t\t{\n\t\t\t\tres *= solve(p, c + 1);\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\treturn res;\n\t}\n\telse if(isdigit(v[r][c]))\n\t{\n\t\treturn v[r][c] - '0';\n\t}\n\telse assert(false);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> n, n)\n\t{\n\t\tv.resize(n); cin >> v;\n\t\tcout << solve(0, 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define debug(x) cerr<<#x<<\": \"<<x<<endl\n\n\ntypedef long long ll;\n\nll solve(vector<string> &s,int n,int &y,int x){\n    if(isdigit(s[y][x])) return s[y][x] - '0';\n    if(s[y][x] == '+'){\n        ll term = 0;\n        while(y+1 < n && (int)s[y+1].size() > x+1){\n            y++;\n            term += solve(s,n,y,x+1);\n        }\n        return term;\n    }else{\n        ll term = 1;\n        while(y+1 < n && (int)s[y+1].size() > x+1){\n            y++;\n            term *= solve(s,n,y,x+1);\n        }\n        return term;\n    }\n}\n\nint main(void){\n    int n;\n    while(cin>>n,n){\n        vector<string> s(n);\n        rep(i,n) cin>>s[i];\n        int y = 0;\n        cout<<solve(s,n,y,0)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\ntemplate<class T> void vin(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n}\n\nstring s[101];\nint j=0;\n\nint solve( int p) {\n    int res = 0, sz=s[j].size();\n    if (isdigit(s[j][p])) return s[j][p]-'0';\n    if (s[j][p] == '+') {\n        while (s[j+1].size() >sz) {\n            j++;\n            res += solve(p+1);\n        }\n    }\n    else {\n        res = 1;\n        while (s[j+1].size() > sz) {\n            j++;\n            res *= solve(p+1);\n        }\n    }\n    return res;\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        rep(i, 100) s[i]=\"\";\n        rep(i, n) cin >> s[i];\n        j=0;\n        cout << solve(0) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mux_n = 2000;\n\nenum _operator{\n    _plus,\n    multiply,\n    none\n};\n\nint main() {\n\n    while(1){\n\n        int n;\n\n        cin >> n;\n\n        if(n==0) break;\n\n        string input[n];\n\n        vector<vector<long long int> > level_num;\n        vector<_operator> level_ope;\n\n        level_num.resize(mux_n);\n\n\n        for(int i=0; i<mux_n; i++){\n            level_ope.push_back(none);\n        }\n\n        int max_level = 0;\n\n        for(int i=0; i<n; i++){\n            cin >> input[i];\n            for(int j=0; j<input[i].size(); j++){\n                if(input[i][j] == '+'){\n                    level_ope[j] = _plus;\n                }\n                else if(input[i][j] == '*'){\n                    level_ope[j] = multiply;\n                }\n                else if(input[i][j] != '.'){\n                    stringstream ss;\n                    ss << input[i][j];\n                    int input_num;\n                    ss >> input_num;\n                    level_num[j].push_back(input_num);\n                }\n                max_level = max(max_level,j);\n            }\n        }\n\n        long long int ans = 0;\n        int now_level = max_level;\n\n        while(now_level){\n            if(level_ope[now_level-1] != none){\n                int sum;\n                if(level_ope[now_level-1] == _plus){\n                    sum = 0;\n                    for(int i=0; i<level_num[now_level].size(); i++){\n                        sum += level_num[now_level][i];\n                    }\n                }\n                else if(level_ope[now_level-1] == multiply){\n                    sum = 1;\n                    for(int i=0; i<level_num[now_level].size(); i++){\n                        sum *= level_num[now_level][i];\n                    }\n                }\n                if(now_level == 1) {\n                    ans = sum;\n                }\n                else{\n                    level_num[now_level-1].push_back(sum);\n                }\n            }\n            /*else if(level_num[now_level].size() == 1){\n                if(now_level == 1) {\n                    ans = level_num[now_level][0];\n                }\n                else{\n                    level_num[now_level-1].push_back(level_num[now_level][0]);\n                }\n            }*/\n            now_level--;\n        }\n\n        if(n == 1){\n            ans = level_num[0][0];\n        }\n\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint depth[1000], num[1000], T[1000], n; string S[1000];\nint main() {\n\twhile (true) {\n\t\tcin >> n; if (n == 0)break;\n\t\tfor (int i = 0; i < 999; i++) num[i] = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> S[i]; depth[i] = S[i].size() - 1;\n\t\t\tchar F = S[i][S[i].size() - 1];\n\t\t\tif (F == '+') { T[i] = 1; }\n\t\t\telse if (F == '*') { T[i] = 2; }\n\t\t\telse { num[i] = F - '0'; T[i] = 0; }\n\t\t}\n\t\tfor (int i = 9; i >= 0; i--) {\n\t\t\tint J = -1, sum = 1;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (depth[j] == i) {\n\t\t\t\t\tif (J != -1) {\n\t\t\t\t\t\tif (T[J] >= 1)num[J] = sum;\n\t\t\t\t\t}\n\t\t\t\t\tif (T[j] == 1) { sum = 0; J = j; }\n\t\t\t\t\tif (T[j] == 2) { sum = 1; J = j; }\n\t\t\t\t}\n\t\t\t\tif (depth[j] == i + 1) {\n\t\t\t\t\tif (T[J] == 1)sum += num[j];\n\t\t\t\t\tif (T[J] == 2)sum *= num[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (J >= 0) { num[J] = sum; }\n\t\t}\n\t\tcout << num[0] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\n    while(1){\n        int n; cin >> n;\n        if(!n) break;\n\n        vector<string> s(n);\n        for(int i = 0; i < n; i++) cin >> s[i];\n\n        int d = 0;\n        for(int i = 0; i < n; i++){\n            d = max(d, (int)s[i].size() - 1);\n        }\n\n        //cout << max_d << endl;\n\n        while(d > 0){\n\n            int state = 0;                  //0 := 何もしない  1 := 足し算をする  2 := 掛け算をする\n            int idx;\n            int res;\n            //d-1を見ていく\n            \n            for(int i = 0; i < n; i++){\n                \n                if(state == 0){\n                    if((int)s[i].size() < d) continue;\n                    else if(s[i][d - 1] == '+'){\n                        state = 1;\n                        idx = i;\n                        res = 0;\n                    }else if(s[i][d - 1] == '*'){\n                        state = 2;\n                        idx = i;\n                        res = 1;\n                    }\n                }else{\n\n                    if((int)s[i].size() < d){\n                        s[idx][d - 1] = (char)(res + '0');\n                        state = 0;\n                    }else if(s[i][d - 1] == '.'){\n                        //計算する\n                        if(s[i][d] == '.') continue;\n\n                        if(state == 1) res += (int)(s[i][d] - '0');\n                        else res *= (int)(s[i][d] - '0');\n                    }else if(s[i][d - 1] == '+'){\n                        s[idx][d - 1] = (char)(res + '0');\n                        state = 1;\n                        idx = i;\n                        res = 0;\n                    }else if(s[i][d - 1] == '*'){\n                        s[idx][d - 1] = (char)(res + '0');\n                        state = 2;\n                        idx = i;\n                        res = 1;\n                    }\n\n                }\n            }\n\n            if(state != 0){\n                s[idx][d - 1] = (char)(res + '0');\n                state = 0;\n            }\n            d--;\n        }\n\n        /*for(int i = 0; i < n; i++){\n            cout << s[i] << endl;\n        }*/\n\n        cout << (int)(s[0][0] - '0') << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<stack>\n#include<vector>\nusing namespace std;\nint dfs(int x,vector<string> s,int n,int k,int m){\nint res=0;\nif(n==1)res=1;\n//cout<<n+1<<endl;\nfor(int i=x;i<m&&k<s[i].size();i++){\nif(s[i][k]=='.')continue;\n\nint a=s[i][k]-'0';\n\nif(s[i][k]=='+')a=dfs(i+1,s,0,k+1,m);\nelse if(s[i][k]=='*')a=dfs(i+1,s,1,k+1,m);\nif(n==1){\n\tres*=a;\n}else{\n\tres+=a;\n}\n\n}\n//cout<<res<<endl;\nreturn res;\n}\nint main(void){\n\tint n;\n\twhile(1){\ncin>>n;\nif(n==0)break;\n\nvector<string> s(n);\nfor(int i=0;i<n;i++){\n\tcin>>s[i];\n//a.push(s);\n}\ncout<<dfs(0,s,0,0,n)<<endl;;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstdio>\n#include <cassert>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> pii;\nusing pll = pair<ll, ll>;\nusing pii = pair<short, short>;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<(a);i++)\n#define rep1(i,a) for(int i=1;i<=(a);i++)\n#pragma warning(disable:4996)\n//#define INF 1000000000000000.0\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<char> op{ '+' };\n\t\tvector<int> num{ 0 };\n\t\tint nest = 0;\n\t\trep(i, n) {\n\t\t\tstring buf;\n\t\t\tcin >> buf;\n\t\t\tint next=count(ALL(buf), '.');\n\t\t\twhile (nest > next) {\n\t\t\t\tif(op[nest-1]=='+')num[nest-1] += num[nest];\n\t\t\t\telse num[nest - 1] *= num[nest];\n\t\t\t\tnest--;\n\t\t\t\tnum.pop_back();\n\t\t\t\top.pop_back();\n\t\t\t}\n\t\t\tif (buf[next] == '+') {\n\t\t\t\top.push_back('+');\n\t\t\t\tnum.push_back(0);\n\t\t\t}\n\t\t\telse if (buf[next] == '*') {\n\t\t\t\top.push_back('*');\n\t\t\t\tnum.push_back(1);\n\t\t\t}\n\t\t\telse if (op[next] == '+')num[next] += buf[next] - '0';\n\t\t\telse num[next] *= buf[next] - '0';\n\t\t\tnest = next;\n\t\t}\n\t\twhile (nest > 0) {\n\t\t\tif (op[nest - 1] == '+')num[nest - 1] += num[nest];\n\t\t\telse num[nest - 1] *= num[nest];\n\t\t\tnest--;\n\t\t\tnum.pop_back();\n\t\t}\n\t\tcout << num[0] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint N;\nvector<tuple<char, int>> v;\nint idx;\n\nint solve(int depth) {\n  int d; char c; tie(d, c) = v[idx];\n  if(isdigit(c)) {\n    idx++;\n    return c - '0';\n  } else {\n    idx++;\n    if(c == '+') {\n      int n1 = solve(depth + 1);\n      while(1) {\n\tint d2; char c2; tie(d2, c2) = v[idx];\n\tif(d2 < depth + 1) break;\n\tn1 += solve(depth + 1);\n      }\n      return n1;\n    }\n    else if(c == '-') {\n      int n1 = solve(depth + 1);\n      while(1) {\n\tint d2; char c2; tie(d2, c2) = v[idx];\n\tif(d2 < depth + 1) break;\n\tn1 -= solve(depth + 1);\n      }\n      return n1;\n    }\n    else if(c == '*') {\n      int n1 = solve(depth + 1);\n      while(1) {\n\tint d2; char c2; tie(d2, c2) = v[idx];\n\tif(d2 < depth + 1) break;\n\tn1 *= solve(depth + 1);\n      }\n      return n1;\n    }\n    else assert(0);\n  }\n}\n\nint main() {\n  \n  while(cin >> N && N) {\n    v.clear();\n    rep(i, N) {\n      char c; cin >> c;\n      int depth = 0;\n      while(c == '.') {\n\tdepth ++;\n\tcin >> c;\n      }\n      \n      v.push_back(make_tuple(depth, c));\n    }\n    \n    idx = 0;\n    cout << solve(0) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <cctype>\nusing namespace std;\ntypedef long long ll;\n\nint cal(vector<string>&str, vector<int>&level, int n, int max){\n    int lev= level[n];\n    if(str[n][lev]>='0' && str[n][lev] <= '9'){\n        return str[n][lev]-'0';\n    }\n    if(str[n][lev]=='+'){\n        int ans=0;\n        for(int i=n+1; i<max; i++){\n            if(level[i]<=level[n]) break;\n            else if(level[i]==level[n]+1){\n                ans += cal(str, level, i, max);\n            }\n        }\n        return ans;\n    }\n    if(str[n][lev]=='*'){\n        int ans=1;\n        for(int i=n+1; i<max; i++){\n            if(level[i]<=level[n]) break;\n            else if(level[i]==level[n]+1){\n                ans *= cal(str, level, i, max);\n            }\n        }\n        return ans;\n    }\n    //return -1;\n    \n}\n\nint main()\n{\n    int n;\n    cin>>n;\n    while(n)\n    {\n        vector<string>w(n);\n        vector<int>l(n,0);\n        for(int i=0;i<n;i++)\n        { cin>>w[i];\n            for(int j=0;w[i][j]=='.';j++)\n                l[i]++;\n        }\n        cout<<cal(w,l,0,n)<<endl;\n        cin>>n;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <vector>\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define RFOR(i,k,n) for (int (i)=(n)-1; (i)>=(k); --(i))\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define mp make_pair\n#define fst first\n#define snd second\nusing namespace std;\n\nint main(){\n    int n;\n    vector<string> s;\n    while(cin>>n && n){\n        s.resize(n);\n        REP(i,n){\n            cin >> s[i];\n        }\n        queue<pair<int,int> > Q;\n        int lv,lvmax = 0;\n        RREP(i,n){\n            lv = s[i].length() - 1;\n            lvmax = max(lvmax, lv);\n            char c = s[i][lv];\n            int num;\n            if(c >= '0' && c <= '9'){\n                num = c - '0';\n            }\n            if(c == '+' || c == '*'){\n                num = -c; // ???????????¨??´??°????????????????????????????????°????????´\n                lv++;\n            }\n            Q.push(mp(num,lv));\n        }\n        Q.push(mp(-1,0)); // ????????????????????§?????\\???????????????????????????????????????????¨?????????\\????????????\n\n        RFOR(i,1,lvmax+1){\n            while(Q.front().fst != -1){\n                if(Q.front().snd == i){ // ????????±????±???????????????£????????¨??¨????????????????¨????\n                    stack <int> S;\n                    while(Q.front().snd == i){ // ???????????????????¨????????¨????\n                        if(Q.front().fst + '+' == 0){\n                            int sum = 0;\n                            while(!S.empty()){\n                                sum += S.top();\n                                S.pop();\n                            }\n                            S.push(sum);\n                            Q.pop();\n                            break;\n                        }\n                        else if(Q.front().fst + '*' == 0){\n                            int pro = 1;\n                            while(!S.empty()){\n                                pro *= S.top();\n                                S.pop();\n                            }\n                            S.push(pro);\n                            Q.pop();\n                            break;\n                        }\n                        else{\n                            S.push(Q.front().fst);\n                            Q.pop();\n                        }\n                    }\n                    Q.push(mp(S.top(),i-1)); // ????±????????????????????¨????\n                }\n                else { // ???????????°??????\n                   Q.push(Q.front());\n                   Q.pop();\n                }\n            }\n            Q.push(Q.front());\n            Q.pop();\n        }\n            cout << Q.front().fst << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nvector< pair<int, char> > v;\nint ind = 0;\n\nint calc(int level){\n  if(isdigit(v[ind].second)) {\n    //cout<<\"num: \"<<v[ind].second - '0'<<\" :level>\"<<level<<endl;\n    return (v[ind].second - '0');\n  }\n  vector<int> tv;\n  char op = v[ind].second;\n  while(ind < v.size()-1){\n    ind++;\n    if(v[ind].first == level+1) tv.push_back(calc(level+1));\n    else{\n      ind--;\n      break;\n    }\n  }\n  int ret;\n  if(op == '*') ret = 1;\n  else ret = 0;\n  REP(i,0,tv.size()){\n    if(op == '*') ret *= tv[i];\n    else ret += tv[i];\n  }\n  //cout<<\"ret> \"<<ret<<endl;\n  return ret;\n}\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if(n == 0) break;\n    string s;\n    int level = 0;\n\n    v.erase(v.begin(), v.end());\n    REP(i,0,n){\n      cin>>s;\n      int tmp = 0;\n      char c;\n      REP(j,0,s.size()){\n        if(s[j] == '.') tmp++;\n        if(j == (s.size()-1)) c = s[j];\n      }\n      v.push_back(make_pair(tmp, c));\n    }\n    ind = 0;\n    cout<<calc(0)<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<stdio.h>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for( int i=(a);i>=(b);i--)\n#define LFOR(i, a, b) for( long long int i=(a);i<=(b);i++)\n#define LRFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n#define MAXI 7500000\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\n\nint main(void) {\n\t\n\twhile (1) {\n\t\tint n;\n\t\tint sa;\n\t\tstack< pair<int, char> > sta;\n\t\tpair<int, char > now;\n\n\t\tcin >> n;\n\t\t\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tvector<string> s(n);\n\t\tFOR(i, 0, n - 1) {\n\t\t\tcin >> s[i];\n\t\t}\n\t\t\n\t\tif (s[0][0] >= '0'&&s[0][0] <= '9') {\n\t\t\tsta.push(make_pair(s[0][0] - '0', 'o'));\n\t\t}\n\t\telse {\n\t\t\tsta.push(make_pair(-1, s[0][0]));\n\t\t}\n\t\t//cout << \"a\" << endl;\n\t\tFOR(i, 1, n-1) {\n\t\t\tif (s[i - 1].size() <= s[i].size()) {\n\t\t\t\tif (s[i][s[i].size()-1] >= '0'&&s[i][s[i].size()-1] <= '9') {\n\t\t\t\t\tsta.push(make_pair(s[i][s[i].size()-1] - '0', 'o'));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsta.push(make_pair(-1, s[i][s[i].size()-1]));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsa = s[i - 1].size() - s[i].size();\n\t\t\t\tFOR(j, 1, sa) {\n\t\t\t\t\tint a[100] = {};\n\t\t\t\t\tint pos = 1;\n\t\t\t\t\tint count = 0;\n\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\tnow = sta.top();\n\t\t\t\t\t\tsta.pop();\n\t\t\t\t\t\tif (now.first == -1) {\n\t\t\t\t\t\t\tif (now.second == '*') {\n\t\t\t\t\t\t\t\tcount = 1;\n\t\t\t\t\t\t\t\tFOR(k, 1, pos - 1) {\n\t\t\t\t\t\t\t\t\tcount *= a[k];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\t\t\tFOR(k, 1, pos - 1) {\n\t\t\t\t\t\t\t\t\tcount += a[k];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsta.push(make_pair(count, 'o'));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ta[pos] = now.first;\n\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (s[i][s[i].size() - 1] >= '0'&&s[i][s[i].size() - 1] <= '9') {\n\t\t\t\t\tsta.push(make_pair(s[i][s[i].size() - 1] - '0', 'o'));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsta.push(make_pair(-1, s[i][s[i].size() - 1]));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\tFOR(j, 1, s[n-1].size()-1) {\n\t\t\tint a[100] = {};\n\t\t\tint pos = 1;\n\t\t\tint count = 0;\n\n\t\t\twhile (1) {\n\t\t\t\tnow = sta.top();\n\t\t\t\tsta.pop();\n\t\t\t\tif (now.first == -1) {\n\t\t\t\t\tif (now.second == '*') {\n\t\t\t\t\t\tcount = 1;\n\t\t\t\t\t\tFOR(k, 1, pos - 1) {\n\t\t\t\t\t\t\tcount *= a[k];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcount = 0;\n\t\t\t\t\t\tFOR(k, 1, pos - 1) {\n\t\t\t\t\t\t\tcount += a[k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsta.push(make_pair(count, 'o'));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ta[pos] = now.first;\n\t\t\t\t\tpos++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tnow = sta.top();\n\t\tcout << now.first << endl;\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint solve(vector<string> fi,int ind){\n  if(fi.size()==1) return fi[0][ind]-'0';\n  vector<int> sons;\n  REP(i,fi.size()) if(fi[i].size()==ind+2) sons.push_back(i);\n  sons.push_back(fi.size());\n  bool mult=fi[0][ind]=='*';\n  int ans;\n  if(mult) ans=1;\n  else ans=0;\n  REP(i,sons.size()-1){\n    int tmp=solve(vector<string>(fi.begin()+sons[i],fi.begin()+sons[i+1]),ind+1);;\n    if(mult) ans*=tmp;\n    else ans+=tmp;\n  }\n  return ans;\n\n\n}\nint main(void)\n{\n  for(;;){\n    int n;\n    cin >> n;\n    if(!n) return 0;\n    vector<string> fi(n);\n    REP(i,n) cin >> fi[i];\n    cout << solve(fi,0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#define imul '*'\n#define iadd '+'\nusing namespace std;\nvector<string> lines;\nint main()\n{\n\tint n;\n\tios::sync_with_stdio(false);\n\twhile (cin >> n)\n\t{\n\t\tvector<char> operators;\n\t\tstring tmp;\n\t\tint tmpresult[1000] = { 0 };\n\t\tint num, i = 0;\n\t\tif (n == 0)break;\n\t\tif (n == 1)\n\t\t{\n\t\t\tcin >> num;\n\t\t\tcout << num << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcin >> tmp;\n\t\toperators.push_back(tmp[0]);\n\t\tif (tmp[0] == iadd)\n\t\t\ttmpresult[1] = 0;\n\t\telse\n\t\t\ttmpresult[1] = 1;\n\t\ti = n - 1;\n\t\twhile (i--)\n\t\t{\n\t\t\tcin >> tmp;\n\t\t\tint j = 0;\n\t\t\twhile (tmp[j] == '.')j++;\n\t\t\tint curlevel = j;\n\t\t\twhile (operators.size() > curlevel)\n\t\t\t{\n\t\t\t\toperators.pop_back();\n\t\t\t\tif (operators.back() == iadd)\n\t\t\t\t\ttmpresult[operators.size()] += tmpresult[operators.size() + 1];\n\t\t\t\telse\n\t\t\t\t\ttmpresult[operators.size()] *= tmpresult[operators.size() + 1];\n\t\t\t}\n\t\t\tif (tmp[curlevel] == iadd)\n\t\t\t{\n\t\t\t\toperators.push_back(iadd);\n\t\t\t\ttmpresult[curlevel + 1] = 0;\n\t\t\t}\n\t\t\telse if (tmp[curlevel] == imul)\n\t\t\t{\n\t\t\t\toperators.push_back(imul);\n\t\t\t\ttmpresult[curlevel + 1] = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (operators.back() == imul)\n\t\t\t\t\ttmpresult[curlevel] *= tmp[curlevel] - '0';\n\t\t\t\telse\n\t\t\t\t\ttmpresult[curlevel] += tmp[curlevel] - '0';\n\t\t\t}\n\t\t\t//for (int i = 0; i < 10; i++)\n\t\t\t//{\n\t\t\t//\tcout << tmpresult[i] << \"  \";\n\t\t\t//}\n\t\t\t//cout << endl;\n\t\t}\n\t\twhile (!operators.empty())\n\t\t{\n\t\t\tif (operators.back() == imul)\n\t\t\t\ttmpresult[operators.size() - 1] *= tmpresult[operators.size()];\n\t\t\telse\n\t\t\t\ttmpresult[operators.size() - 1] += tmpresult[operators.size()];\n\t\t\toperators.pop_back();\n\t\t}\n\t\tcout << tmpresult[1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,l[1000],a[1000],b[1000],c[1000];\nchar s[1000][1000];\nvector<int> v[1000];\nint main(){\n\tscanf(\"%d\",&n);\nwhile(n){\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\" %s\",s[i]);\n\t\tl[i]=strlen(s[i])-1;\n\t\tif(s[i][l[i]]=='+')\n\t\t\tb[i]=1;\n\t\telse if(s[i][l[i]]=='*')\n\t\t\tb[i]=2;\n\t\telse{\n\t\t\tb[i]=0;\n\t\t\ta[i]=s[i][l[i]]-'0';\n\t\t}\n\t}\n\tl[n]=0;\n\tfor(int i=0;i<=100;i++)\n\tv[i].clear();\n\tfor(int i=0;i<n;i++){\n\t\tif(b[i]==0){\n\t\t\tif(l[i]==l[i+1])\n\t\t\t\tv[l[i]].push_back(a[i]);\n\t\t\telse{\n\t\t\t\tv[l[i]].push_back(a[i]);\n\n\t\t\t\tfor(int j=l[i];j>l[i+1];j--){\n\t\t\t\t\t//for(auto k: v[j])\tprintf(\"%d \",k);printf(\"!!i%d\\n\",c[j]);\n\t\t\t\t\tint t=c[j]-1;\n\t\t\t\t\tfor(auto k:v[j])\n\t\t\t\t\t\tif(c[j]==1)\n\t\t\t\t\t\t\tt+=k;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tt*=k;\n\t\t\t\t\t//printf(\"%d %d\\n\",t,j);\n\t\t\t\t\tv[j-1].push_back(t);\n\t\t\t\t\tv[j].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tc[l[i]+1]=b[i];\n\t\t}\n\t}\n\tprintf(\"%d\\n\",v[0][0]);\n\tscanf(\"%d\",&n);\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint N;\nvector<tuple<char, int>> v;\nint idx;\n\nint solve(int depth) {\n  int d; char c; tie(d, c) = v[idx];\n  assert(d == depth);\n  if(isdigit(c)) {\n    idx++;\n    return c - '0';\n  } else {\n    idx++;\n    if(c == '+') {\n      int n1 = solve(depth + 1);\n      while(idx < N) {\n\tint d2; char c2; tie(d2, c2) = v[idx];\n\tif(d2 < depth + 1) break;\n\tn1 += solve(depth + 1);\n      }\n      return n1;\n    }\n    else if(c == '-') {\n      int n1 = solve(depth + 1);\n      while(idx < N) {\n\tint d2; char c2; tie(d2, c2) = v[idx];\n\tif(d2 < depth + 1) break;\n\tn1 -= solve(depth + 1);\n      }\n      return n1;\n    }\n    else if(c == '*') {\n      int n1 = solve(depth + 1);\n      while(idx < N) {\n\tint d2; char c2; tie(d2, c2) = v[idx];\n\tif(d2 < depth + 1) break;\n\tn1 *= solve(depth + 1);\n      }\n      return n1;\n    }\n    else assert(0);\n  }\n}\n\nint main() {\n  \n  while(cin >> N && N) {\n    v.clear();\n    rep(i, N) {\n      char c; cin >> c;\n      int depth = 0;\n      while(c == '.') {\n\tdepth ++;\n\tcin >> c;\n      }\n      \n      v.push_back(make_tuple(depth, c));\n    }\n    \n    idx = 0;\n    cout << solve(0) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint n;\nstring s[100];\nint parent[100];\nvector<int> child[100];\n\nint dfs(int v) {\n\tchar op = s[v][s[v].length() - 1];\n\t\n\tif ('0' <= op && op <= '9') return (int)(op - '0');\n\t\n\tint ret = (op == '*');\n\tfor (int i = 0; i < child[v].size(); i++) {\n\t\tif (op == '*') ret *= dfs(child[v][i]);\n\t\telse ret += dfs(child[v][i]);\n\t}\n\treturn ret;\n}\n\nint main() {\n\twhile (cin >> n) {\n\t\tif (!n) break;\n\t\t\n\t\tint i, j;\n\t\t\n\t\tfor (i = 0; i < n; i++) cin >> s[i];\n\t\tfor (i = 0; i < n; i++) child[i].clear();\n\t\t\n\t\t//s[i]???s[parent[i]]????¢????????????§??????\n\t\t//s[i]???s[child[i][hoge]]??????????????§??????\n\t\tparent[0] = 0;\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tfor (j = i; j >= 0; j--) {\n\t\t\t\tif (s[i].length() == s[j].length() + 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparent[i] = j;\n\t\t\tchild[j].push_back(i);\n\t\t}\n\t\t\n\t\t//??°??????????????§?¨??????????\n\t\tcout << dfs(0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n\n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nstring s[1024];\n\nint rec(int a,int b,int c){\n\tint res=0;\n\tif(c)res=1;\n\tfor(int i=a;i<n&&b<s[i].size();i++){\n\t\tif(s[i][b]=='.')continue;\n\t\tint x=s[i][b]-'0';\n\t\tif(s[i][b]=='*')x=rec(i+1,b+1,1);\n\t\tif(s[i][b]=='+')x=rec(i+1,b+1,0);\n\t\tif(c)res*=x;\n\t\telse res+=x;\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tREP(i,n)cin>>s[i];\n\t\tcout<<rec(0,0,0)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nint solve_testcase() {\n    int N; scanf(\"%d\", &N);\n    if(N == 0) return 1;\n\n    vector<string> vs(N);\n    for(int i=0; i<N; i++) cin >> vs[i];\n\n    int line = 0;\n    auto parse = [&](auto &&self) -> ll {\n        if(vs[line].back() == '*' or vs[line].back() == '+') {\n            int depth = vs[line].size(); char op = vs[line++].back();\n            ll res = (op == '*' ? 1 : 0);\n            while(line < N and vs[line].size() == depth + 1) {\n                ll num = self(self);\n                if(op == '*') res *= num;\n                if(op == '+') res += num;\n            }\n            return res;            \n        }\n        else {\n            return vs[line++].back() - '0';\n        }\n    };\n    ll ans = parse(parse);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nint number(char c)\n{\n    if (c == '*')\n    {\n        return -1;\n    }\n    else if (c == '+')\n    {\n        return -2;\n    }\n    else\n    {\n        return c - '0';\n    }\n}\n\npair<int,int> parse(string s){\n    int cnt = 0;\n    char c;\n    for (int i = 0; i < s.size(); i++)\n    {\n        if(s[i] =='.')cnt++;\n        else{\n            c = s[i];\n        }\n    }\n    return make_pair(number(c),cnt);\n}\n\nint calc(int op,vector<int> nums){\n    if(op==-1){\n        int ret = 1;\n        for(int x:nums){\n            ret *= x;\n        }\n        return ret;\n    }\n    else\n    {\n        int ret = 0;\n        for(int x:nums){\n            ret += x;\n        }\n        return ret;\n    }\n}\n\n\n\nint main(){\n    int N;\n    while(cin >> N,N){\n        vector<string> s(N);\n        for (int i = 0; i < N; i++)            \n        {\n            cin >> s[i];\n        }\n        vector<pair<int,int>> p(N);\n        for(int i=0;i<N;i++)p[i] = parse(s[i]);\n        p.push_back(make_pair(-INF, 0));\n        stack<pair<int, int>> st;\n        int level = 0;\n        for (int i = 0; i <= N; i++)\n        {\n            while(level>p[i].second){\n                vector<int> nums;\n                int c;\n                while (1)\n                {\n                    auto x = st.top();\n                    st.pop();\n                    c = x.first;\n                    int l = x.second;\n                    if(c<0)break;\n                    else\n                        nums.push_back(c);\n                }\n                int num = calc(c,nums);\n                // cerr << \"nums---\" << endl;\n                // for (int x : nums)\n                //     cerr << x << endl;\n                // cerr << \"----\" << endl;\n                // cerr << num << endl;\n                st.push(make_pair(num, level));\n                level--;\n            }\n            if(p[i].first!=-INF)st.push(p[i]);\n            level = p[i].second;\n        }\n        int pp = st.top().first;\n        cout << pp << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include <stack>\nusing namespace std;\nstruct P {\n\tint lev, num;\n};\n\nint n;\nstring s[20];\n\nint main() {\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (!n)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> s[i];\n\t\t}\n\n\t\tstack<char> cs;\n\t\tstack<P> ns;\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t//cout << \"i:\" << i << endl;\n\t\t\tif (i != n && (s[i][s[i].length() - 1] == '+' || s[i][s[i].length() - 1] == '*')) {//演算子だったら\n\t\t\t\tif (cs.size() == s[i].length()-1) {//見ているレベルだったら\n\t\t\t\t\tcs.push(s[i][s[i].length() - 1]);\n\t\t\t\t}\n\t\t\t\telse {//見ているレベルより下だったら\n\n\t\t\t\t\t//現在のレベルの計算を行う。\n\t\t\t\t\tint calc;\n\t\t\t\t\tchar ope = cs.top();\n\t\t\t\t\tif (ope == '+')calc = 0;\n\t\t\t\t\telse calc = 1;\n\n\t\t\t\t\twhile (!ns.empty()) {\n\t\t\t\t\t\t//cout << \"c\" << endl;\n\t\t\t\t\t\tP p = ns.top();\n\t\t\t\t\t\tif (p.lev < cs.size())break;\n\t\t\t\t\t\tns.pop();\n\n\t\t\t\t\t\tif (ope == '+') {\n\t\t\t\t\t\t\tcalc += p.num;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcalc *= p.num;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcs.pop();\n\t\t\t\t\tns.push(P{ (int)cs.size(), calc });\n\t\t\t\t\ti--;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {//数値だったら\n\t\t\t\t//cout << \"a\" << endl;\n\t\t\t\tif (i != n && cs.size() == s[i].length() - 1) {//見ているレベルだったら\n\t\t\t\t\tns.push(P{(int)cs.size(), (int)(s[i][s[i].length() - 1]-'0') });\n\t\t\t\t}\n\t\t\t\telse {//見ているレベル以下だったら\n\t\t\t\t\t//cout << \"b\" << endl;\n\t\t\t\t\t//演算子がない場合は計算しない\n\t\t\t\t\tif (!cs.size())break;\n\n\t\t\t\t\t//現在のレベルの計算を行う。\n\t\t\t\t\tint calc;\n\t\t\t\t\tchar ope = cs.top();\n\t\t\t\t\tif (ope == '+')calc = 0;\n\t\t\t\t\telse calc = 1;\n\n\t\t\t\t\twhile(!ns.empty()) {\n\t\t\t\t\t\t//cout << \"c\" << endl;\n\t\t\t\t\t\tP p = ns.top();\n\t\t\t\t\t\tif (p.lev < cs.size())break;\n\t\t\t\t\t\tns.pop();\n\n\t\t\t\t\t\tif (ope == '+') {\n\t\t\t\t\t\t\tcalc += p.num;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcalc *= p.num;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcs.pop();\n\t\t\t\t\tns.push(P{(int)cs.size(), calc});\n\t\t\t\t\ti--;\n\t\t\t\t\tif (ns.size() == 1)i++;\n\t\t\t\t\t//cout << \"d\" << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << (ns.top()).num << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 0;i < n;i++)\n#define repb(i, n) for(int i = n;i >= 0;i--)\n#define reps(i, m, n) for(int i = m;i < n;i++)\n#define repsb(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\n#define INF 999999999999999999\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<llong, llong> LP;\ntypedef pair<int, P> PP;\ntypedef pair<llong, LP> LPP;\ntypedef long long ll;\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\nusing namespace std;\nstring s[100];\nint cal(int &index,int d){\n\n  if(isdigit(s[index][d]))  return(s[index++][d]-'0');\n\n  else if(s[index++][d]=='+'){\n    int t=0;\n    while ((int)s[index].size()>d+1){\n      t+=cal(index,d+1);\n    }\n    return t;\n  }\n  else{\n    int t=1;\n    while ((int)s[index].size()>d+1) {\n      t*=cal(index,d+1);\n    }\n    return t;\n  }\n\n  }\nint main(int argc, char const *argv[]) {\n  int n;\n  \twhile(1){\n  \t\tcin>>n;\n  \t\tif(n==0)\tbreak;\n  \t\trep(i,n){\n  \t\t\tcin>>s[i];\n  \t\t}\n      s[n]=\"\";\n      int index=0;\n      cout<<cal(index,0)<<endl;\n    }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi acos(-1.0)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint calc(vector<string> s, int &i){\n\tint depth = s[i].length(), n = s.size();\n\tchar c = s[i][depth-1];\n\tif (c == '+'){\n\t\tint res = 0;\n\t\ti++;\n\t\twhile (s[i].length() == depth+1 && i < n){\n\t\t\tres += calc(s, i);\n\t\t}\n\t\treturn res;\n\t}else if (c == '*'){\n\t\tint res = 1;\n\t\ti++;\n\t\twhile (s[i].length() == depth+1 && i < n){\n\t\t\tres *= calc(s, i);\n\t\t}\n\t\treturn res;\n\t}else{\n\t\ti++;\n\t\treturn c - '0';\n\t}\n}\n\nint main(){\n\tint n;\n\tifstream ifs(\"in.txt\");\n\twhile (ifs >> n && n){\n\t\tvector<string> s(n);\n\t\tREP(i,n) ifs >> s[i];\n\t\tint i = 0;\n\t\tcout << calc(s, i) << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1 ; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1 ; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 1e9+100;\nconst bool debug = 0;\n/***************************************/\n\nint N;\nint level[30];\nint num[30]; // 0~9, 10:+, 11:*\n\nll solve(int p, int ope) { // 0:+, 1:*\t\n\tvector<ll> v;\n\tFOR(i, p, N) {\n\t\tif (level[p] > level[i]) break;\n\t\tif (level[i] == level[p]) {\n\t\t\tif (num[i] >= 10) v.push_back(solve(i + 1, num[i] == 11));\n\t\t\telse v.push_back(num[i]);\n\t\t}\n\t}\n\t\n\tll res = ope == 1;\n\tREP(i, v.size()) {\n\t\tif (ope) res *= v[i];\n\t\telse res += v[i];\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> N, N) {\n\t\tREP(i, N) {\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tlevel[i] = str.size() - 1;\n\t\t\tif (str.back() == '+') num[i] = 10;\n\t\t\telse if (str.back() == '*') num[i] = 11;\n\t\t\telse num[i] = str.back() - '0';\n\t\t}\n\t\tif (debug) printf(\"@ \");\n\t\tcout << solve(0, 0) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint n;\nchar buff[17][10];\n\nint calc(int line) {\n\tchar c;\n\tint level, val, arg;\n\tlevel = strlen(buff[line]) - 1;\n\tc = buff[line][level];\n\tswitch(c){\n\tcase'*':\n\t\tline++;\n\t\tval = 1;\n\t\twhile (1){\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval *= arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tcase'+':\n\t\tline++;\n\t\tval = 0;\n\t\twhile (1) {\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval += arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tdefault:\n\t\tif (line >= n)break;\n\t\treturn c;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%s\", buff[i][0]);\n\t\t\tprintf(\"%d\\n\", calc(0));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nstring s[100];\nint dfs(int d,int k){\n  bool e=0;\n  int res=0;\n  if(s[d][k]=='+')d++,k++;\n  if(s[d][k]=='*')e=1,d++,k++,res=1;\n  for(int i=d;i<n&&k<s[i].size();i++){\n    int a=s[i][k]-'0';\n    if(s[i][k]=='.')continue;\n    if(s[i][k]=='+'||s[i][k]=='*')a=dfs(i,k);\n    if(e)res*=a;\n    else res+=a;\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>s[i];\n    cout<<dfs(0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<stack>\n#include<vector>\nusing namespace std;\n\nint calc(vector<string>& S, int l, int r, int depth) {\n    if (S[l][S[l].size() - 1] >= '0' && S[l][S[l].size() - 1] <= '9') {\n        return S[l][S[l].size() - 1] - '0';\n    }\n    char op = S[l][S[l].size() - 1];\n    vector<int> idx;\n    for (int i = l + 1; i < r; i++) {\n        if (S[i].size() == depth + 1) {\n            idx.push_back(i);\n        }\n    }\n    idx.push_back(r);\n    int res = op == '+' ? 0 : 1;\n    for (int i = 0; i < idx.size() - 1; i++) {\n        if (op == '+') res += calc(S, idx[i], idx[i + 1], depth + 1);\n        else res *= calc(S, idx[i], idx[i + 1], depth + 1);\n    }\n    return res;\n}\n\nvoid solve(int n) {\n    vector<string> s(n);\n    for (int i = 0; i < n; i++) cin >> s[i];\n    cout << calc(s, 0, n, 1) << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n        solve(N);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nstring s[30];\nint dfs(int d,int k){\n  bool e=0;\n  int res=0;\n  if(s[d][k]=='+')d++,k++;\n  if(s[d][k]=='*')e=1,d++,k++,res=1;\n  bool f=0;\n  for(int i=d;i<n&&k<s[i].size();i++){\n    if(s[i][k]=='.')continue;\n    f=1;\n    int a=s[i][k]-'0';\n    if(s[i][k]=='+'||s[i][k]=='*')a=dfs(i,k);\n    if(e)res*=a;\n    else res+=a;\n  }\n  assert(f);\n  return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>s[i];\n    cout<<dfs(0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main() {\n  int n;\n  while ( cin >> n, n ) {\n    int ans = 0;\n    int ma = 0;\n    vector<P> dat(n);    \n    for ( int i = 0; i < n; i++ ) {      \n      string s;\n      cin >> s;\n      dat[i].first = (int)s.size()-1;\n      if ( s[s.size()-1] == '+' ) dat[i].second = -1;\n      else if ( s[s.size()-1] == '*' ) dat[i].second = -2;\n      else dat[i].second = s[s.size()-1]-'0';\n      ma = max(ma, (int)s.size()-1);      \n    }\n\n    while ( 1 ) {      \n      /*for ( int i = 0; i < dat.size(); i++ ) {\n\tif ( i ) cout << \" \";\n\tcout << dat[i].first << \" \" << dat[i].second;\n      }\n      cout << endl << endl;;*/\n      if ( dat.size() == 1 ) break;\n      bool flag = false;\n      for ( int i = 0; i < dat.size()-2; i++ ) {\n\tif ( dat[i].second >= 0 ) continue;\n\tif ( dat[i].first != ma ) continue;\t\n\tint c = dat[i].second;\n\tint d = dat[i].first;\t\n\tint sum;\n\tint cnt = 2;\t\n\tif ( d != dat[i+1].first-1 ) continue;\n\tif ( dat[i+1].second >= 0 && dat[i+2].second >= 0 && dat[i+1].first == dat[i+2].first ) {\n\t  flag = true;\n\t  //cout << 'a' << endl;\t    \t \n\t  sum = dat[i+1].second;\n\t  cnt = 2;\n\t  for ( int j = i+2; j < dat.size(); j++ ) {\n\t    //cout << sum << endl;\n\t    if ( dat[j].second < 0 ) break;\n\t    if ( dat[j].first != dat[i+1].first ) break; \n\t    if ( c == -1 ) {\n\t      sum += dat[j].second;\n\t    } else {\n\t      sum *= dat[j].second;\n\t    }\n\t    cnt++;\n\t  }\n\t}\t\n\tif ( flag ) {\n\t  //cout << i << \" \" << sum << \" \" << cnt << endl;\n\t  int tmp = dat[i].first;\n\t  for ( int j = i; j < i+cnt; j++ ) dat.erase(dat.begin()+i);\n\t  dat.insert(dat.begin()+i, P(tmp, sum));\t  \n\t  break;\n\t}\n      }\n      if ( !flag ) {\n\tma--;\n      }\n\t\t    \n      if ( dat.size() == 1 ) break;\n    }\n\n    //cout << \"end\" << endl;\n    cout << dat[0].second << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring str[101];\nint n,idx=0;\n\nint cal(char ch,int a,int b){\n  if(ch=='*') return a*b;\n  return a+b;\n}\n\nint get_cnt(string a){\n  int res=0;\n  while(a[res]=='.')res++;\n  return res;\n}\n\nint dfs(){\n  int cnt=get_cnt(str[idx]);\n  char ch=str[idx][cnt];\n  int res =(ch=='*');\n  if(ch!='*'&&ch!='+')return str[idx++][cnt]-'0';\n  idx++,cnt++;\n  while(idx<n){\n    if(get_cnt(str[idx])>=cnt) res = cal(ch,res,dfs());\n    else break;\n  }\n  return res;\n}\n\nint main(){\n\n  while(cin>>n,n){\n    for(int i=0;i<n;i++) cin>>str[i];\n    idx=0;\n    cout <<dfs()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint n;\nvector<string> s;\n\nint get(int line){\n    int res = 0;\n    int i = 0;\n    while(s[line][i++] == '.') res++;\n    return res;\n}\n\nint calc(int& line,int depth){\n    if(s[line][depth] == '+'){\n        int ret = 0;\n        line++;\n        while(line < n and get(line) == depth+1){\n            ret += calc(line,depth+1);\n        }\n        return ret;\n    }else if(s[line][depth] == '*'){\n        int ret = 1;\n        line++;\n        while(line < n and get(line) == depth+1){\n            ret *= calc(line,depth+1);\n        }\n        return ret;\n    }else{\n        return s[line++][depth] - '0';\n    }\n}\n\nvoid solve(){\n    int line = 0;\n    int ans = calc(line,0);\n    cout << ans << endl;\n}\n\nint main(){\n    while(1){\n        cin >> n;\n        if(!n) break;\n        s.resize(n);\n        rep(i,n){\n            cin >> s[i];\n        }\n        solve();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n\nusing namespace std;\n\n\nint add(vector<string>::iterator &itr);\nint mlt(vector<string>::iterator &itr);\n\nint main(){\n    while(true){\n        int n; cin >> n;\n        if( n == 0)break;\n        vector<string> s(n);\n        for(int i = 0; i < n; i++){\n            cin >> s[i];\n        }\n        int ans = 0;\n        for(auto itr = s.begin(); itr != s.end(); ++itr){\n            if(itr->back() == '+'){\n                ans += add(itr);\n            }\n            else if(itr->back() == '*'){\n                ans += mlt(itr);\n            }\n            else{\n                ans += itr->back() - '0';\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\nint add(vector<string>::iterator &itr){\n    int c = itr->size()+1;\n    int ret = 0;\n    ++itr;\n    while(itr->size() == c){\n        if(itr->back() == '+'){\n            ret += add(itr);\n        }\n        else if(itr->back() == '*'){\n            ret += mlt(itr);\n        }\n        else{\n            ret += itr->back() -'0';\n        }\n        ++itr;\n    }\n        \n    --itr;\n    return ret;\n}\n\nint mlt(vector<string>::iterator &itr){\n    int c = itr->size();\n    int ret = 1;\n    ++itr;\n    while(itr->size() == c+1){\n        if(itr->back() == '+'){\n            ret *= add(itr);\n        }\n        else if(itr->back() == '*'){\n            ret *= mlt(itr);\n        }\n        else{\n            ret *= itr->back() - '0';\n        }\n        ++itr;\n    }\n    --itr;\n    return ret;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<S<<endl\n#define ck(n,a,b) (a<=(n)&&(n)<=b)\n#define F first\n#define S second\nusing namespace std;\nint opCalc(char op,int left,int right){\n\tint ret;\n\tif(op=='+'){\n\t\tret=left+right;\n\t}else if(op=='*'){\n\t\tret=left*right;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tstring s[20];\n\t\tvector<pair<int,int>> vt;\n\t\tint maxj=0;\n\t\tREP(i,0,n){\n\t\t\tcin>>s[i];\n\t\t\tREP(j,0,(int)s[i].size()){\n\t\t\t\tif(s[i][j]=='.') continue;\n\t\t\t\tvt.push_back({j,s[i][j]-'0'});\n\t\t\t\tmaxj=max(maxj,j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint ans=vt[0].S;\n\t\t\tfor(int j=maxj-1;j>=0;j--){\n\t\t\t\tfor(int i=0;i<(int)vt.size()-2;i++){\n\t\t\t\t\tif((vt[i].S+'0'!=(int)'+'&&vt[i].S+'0'!=(int)'*')||vt[i].F!=j)\tcontinue;\n\t\t\t\t\tbool flag=false;\n\t\t\t\t\twhile(vt[i].F+1==vt[i+1].F&&vt.size()>1&&i+1<vt.size()){\n\t\t\t\t\t\tif(!flag) {\n\t\t\t\t\t\t\tans=opCalc((char)vt[i].S+'0',vt[i+1].S,vt[i+2].S);\n\t\t\t\t\t\t\tvt.erase(vt.begin()+i+2);\n\t\t\t\t\t\t\tflag=true;\n\t\t\t\t\t\t}else\tans=opCalc((char)vt[i].S+'0',vt[i+1].S,ans);\n\t\t\t\t\t\tvt.erase(vt.begin()+i+1);\n\t\t\t\t\t}\n\n\t\t\t\t\tvt[i]={vt[i].F,ans};\n\t\t\t\t}\n\t\t\t}\n\t\t\tp(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define mp make_pair\n#define pb push_back\n#define rep(i,n) for(int i=0;i<n;i++)\n#define repn(i,n) for(int i=1;i<=n;i++)\ntypedef long long ll;\n\nvector<string>vec;\nll rec(vector<string>vec){\n    if('0' <= vec[0][0] && vec[0][0] <= '9') return vec[0][0]-'0';\n    bool type = (vec[0][0] == '+');\n    vector<ll>vecv;\n    for(int i=1;i<vec.size();i++){\n        string s = vec[i];\n        reverse(s.begin(),s.end());\n        s.pop_back();\n        reverse(s.begin(),s.end());\n        if('0'<=s[0] && s[0] <= '9'){\n            vecv.pb(s[0]-'0');\n        }\n        else{\n            vector<string>V; V.pb(s);\n            i++;\n            while(i<vec.size()){\n                string s = vec[i];\n                reverse(s.begin(),s.end());\n                s.pop_back();\n                reverse(s.begin(),s.end());\n                if(s[0] == '.') V.pb(s);\n                else{\n                    vecv.pb(rec(V));\n                    i--; goto nxt;\n                }\n                i++;\n            }\n            vecv.pb(rec(V)); nxt:;\n        }\n    }\n    if(type){\n        ll ans = 0; rep(i,vecv.size()) ans += vecv[i]; return ans;\n    }\n    else{\n        ll ans = 1; rep(i,vecv.size()) ans *= vecv[i]; return ans;\n    }\n}\nint main(){\n    while(1)\n    {\n        int n; cin>>n; if(n == 0) return 0;\n        vec.clear();\n        rep(i,n){\n            string x; cin >> x; vec.pb(x);\n        }\n        ll val = rec(vec); cout << val << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main(void) {\n    while (1) {\n\n        int n;\n        cin >> n;\n        if (n == 0) break;\n\n        string formula[n];\n        for (int i = 0; i < n; ++i) {\n            cin >> formula[i];\n        }\n\n        while (1) {\n\n            if (formula[0].length() == 1 && formula[0] != \"+\" && formula[0] != \"*\") { // 終了条件\n                cout << formula[0] << endl;\n                break;\n            }\n\n            int maxlen = 0;\n            for (int i = 0; i < n; ++i) {\n                maxlen = max(maxlen, (int) (formula[i].length()));\n            }\n\n            bool opefind = false;\n            long long result = 0;\n            string ope;\n            int pos;\n            int maxcnt = 0;\n            for (int i = 0; i < n; ++i) {\n                if (formula[i].length() == maxlen) {\n                    if (!opefind) {\n                        ope = formula[i - 1].substr(formula[i - 1].length() - 1, 1);\n                        result = (long long) (stoi(formula[i].substr(formula[i].length() - 1, 1)));\n                        opefind = true;\n                        pos = i - 1;\n                        maxcnt += 1;\n                    } else {\n                        if (ope == \"+\") {\n                            result += (long long) (stoi(formula[i].substr(formula[i].length() - 1, 1)));\n                        } else if (ope == \"*\") {\n                            result *= (long long) (stoi(formula[i].substr(formula[i].length() - 1, 1)));\n                        }\n                        maxcnt += 1;\n                    }\n                    if (i + 1 != n) {\n                        if (formula[i + 1].length() != maxlen) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            string replaceformula = \"\";\n            for (int i = 0; i < maxlen - 2; ++i) {\n                replaceformula += \".\";\n            }\n            replaceformula += to_string(result);\n\n            n -= maxcnt;\n            formula[pos] = replaceformula;\n            for (int i = pos + 1; i < n; ++i) {\n                formula[i] = formula[i + maxcnt];\n            }\n\n        }\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n#define REP(i,x,n) for(int i = x; i < n; i++)\n\nint n, id;\nstring s[1000];\nchar c[1000];\nint depth[1000];\n\nint f(int d) {\n\tif (isdigit(c[id])) {\n\t\tint ret = c[id] - '0';\n\t\tid++;\n\t\treturn ret;\n\t}\n\tif (c[id] == '+') {\n\t\tid++;\n\t\tint ret = 0;\n\t\twhile (id < n && depth[id] == d + 1) {\n\t\t\tret += f(d + 1);\n\t\t}\n\t\treturn ret;\n\t}\n\tid++;\n\tint ret = 1;\n\twhile (id < n && depth[id] == d + 1) {\n\t\tret *= f(d + 1);\n\t}\n\treturn ret;\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> s[i];\n\t\t\tdepth[i] = s[i].size() - 1;\n\t\t\tc[i] = s[i].back();\n\t\t}\n\t\tid = 0;\n\t\tcout << f(0) << endl;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi acos(-1.0)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint calc(vector<string> s, int &i){\n\tint depth = s[i].length(), n = s.size();\n\tchar c = s[i][depth-1];\n\tif (c == '+'){\n\t\tint res = 0;\n\t\twhile (s[++i].length() == depth+1 && i < n){\n\t\t\tres += calc(s, i);\n\t\t}\n\t\ti--;\n\t\treturn res;\n\t}else if (c == '*'){\n\t\tint res = 1;\n\t\twhile (s[++i].length() == depth+1 && i < n){\n\t\t\tres *= calc(s, i);\n\t\t}\n\t\ti--;\n\t\treturn res;\n\t}else{\n\t\treturn c - '0';\n\t}\n}\n\nint main(){\n\tint n;\n\twhile (cin >> n && n){\n\t\tvector<string> s(n);\n\t\tREP(i,n) cin >> s[i];\n\t\tint i = 0;\n\t\tcout << calc(s, i) << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nint main()\n{\n    while (true) {\n        int N;\n        cin >> N;\n        if (N == 0) { break; }\n        if (N == 1) {\n            cin >> N;\n            cout << N << endl;\n            continue;\n        }\n        using P = pair<char, ll>;\n        auto f = [](const P& p, const ll n) { return P{p.first, p.first == '+' ? p.second + n : p.second * n}; };\n        auto conv = [](const P& p1, const P& p2) { return P{p1.first, p1.first == '+' ? p1.second + p2.second : p1.second * p2.second}; };\n        stack<P> st;\n        for (int i = 0, l = 0; i < N; i++) {\n            string s;\n            cin >> s;\n            for (l = 0; l < s.size() and s[l] == '.'; l++) {}\n            for (; l < st.size();) {\n                const auto e1 = st.top();\n                st.pop();\n                const auto e2 = st.top();\n                st.pop();\n                st.emplace(conv(e2, e1));\n            }\n            if (isdigit(s[l])) {\n                const auto e = st.top();\n                st.pop();\n                st.emplace(f(e, stoll(s.substr(l, s.size() - l))));\n            } else {\n                st.push({s[l], s[l] == '+' ? 0LL : 1LL});\n            }\n        }\n        for (; st.size() > 1;) {\n            const auto e1 = st.top();\n            st.pop();\n            const auto e2 = st.top();\n            st.pop();\n            st.push(conv(e2, e1));\n        }\n        cout << st.top().second << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  static auto add = [](int a, int b) { return a + b; };\n  static auto mul = [](int a, int b) { return a * b; };\n  int n;\n  while (cin >> n, n) {\n    vector<string> a(n);\n    for (auto& e : a) {\n      cin >> e;\n    }\n    a.push_back(\"0\");\n    vector<pair<function<int(int, int)>, int>> v{make_pair(add, 0)};\n    for (auto e : a) {\n      while (e.size() - 1 < v.size() - 1) {\n        (v.rbegin() + 1)->second = (v.rbegin() + 1)->first((v.rbegin() + 1)->second, v.rbegin()->second);\n        v.pop_back();\n      }\n      char c = *e.rbegin();\n      if (c == '+') {\n        v.push_back(make_pair(add, 0));\n      } else if (c == '*') {\n        v.push_back(make_pair(mul, 1));\n      } else {\n        v.rbegin()->second = v.rbegin()->first(v.rbegin()->second, c - '0');\n      }\n    }\n    cout << v.back().second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint func()\n{\n  int N;\n  cin >> N;\n  if( N == 0 ) return -1;\n\n  int v[10] = { 0 };\n  char m[10] = { 0 };\n\n  for( int i = 0; i < N; ++i ){\n    string S;\n    cin >> S;\n\n    int cnt = 0, len = S.length();\n\n    for( int j = 0; j < len; ++j ){\n      switch( S[j] ){\n        case '.': ++cnt; break;\n        case '+': case '*': m[cnt] = S[j]; break;\n        default: if( cnt == 0 ){\n                  cout << S[j]-'0' << endl;\n                  return 0;\n                 } else if( m[cnt-1] == '+' ){ v[cnt-1] += (S[j]-'0');\n                 } else if( m[cnt-1] == '*' ){\n                     if( v[cnt-1] == 0 ) v[cnt-1] = 1;\n                     v[cnt-1] *= (S[j]-'0');\n                 }\n                 //cout << \": \" << v[0] << endl;\n                 break;\n        }\n      }\n    }\n\n    int ans = v[0];\n    for( int i = 0; m[i+1] != 0; ++i ){\n      //if( i == 0 ){\n        //if( m[i] == '+' ) ans = v[0] + v[1];\n        //else ans = v[0] * v[1];\n      //} else {\n        if( m[i] == '+' ) ans += v[i+1];\n        else ans *= v[i+1];\n      //}\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\nint main()\n{\n  while( func() != -1 ) ;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define DBG(X) cout<<\" \"<<#X<<\" : \"<<X<<endl\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\n\nstruct Input\n{\n\tint n;char c;char str[1024];string s;ll l;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\nint calcLv(const string& s){\n\trep(i, s.size()) if(s[i] != '.') return i;\n\treturn -1;\n}\n\nbool f[110];\n\n\nint calc(int p, const vector<string> &s){\n\tint lv = calcLv(s[p]);\n\tf[p] = true;\n\tif(s[p][lv] >= '0' && s[p][lv] <= '9') return s[p][lv] - '0';\n\tif(s[p][lv] == '+'){\n\t\tint np = p, ret = 0;\n\t\twhile(calcLv(s[++np]) > lv){\n\t\t\tif(!f[np]) ret += calc(np, s);\n\t\t}\n\t\t//printf(\" (%d, %d)\\n\", lv, ret);\n\t\treturn ret;\n\t}\n\telse{\n\t\tint np = p, ret = 1;\n\t\twhile(calcLv(s[++np]) > lv){\n\t\t\tif(!f[np]) ret *= calc(np, s);\n\t\t}\n\t\t//printf(\" (%d, %d)\\n\", lv, ret);\n\t\treturn ret;\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint n = in.nextInt();\n\t\tif(n == 0) break;\n\t\tvector<string> s(n + 1);\n\t\trep(i, n) s[i] = in.next();\n\t\tif(n == 1){\n\t\t\tcout<<s[0]<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i ,110) f[i] = false;\n\t\t\n\t\tcout<<calc(0, s)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint n;\nstd::vector< std::string > ss;\n\ninline int getDots(std::string s) {\n    return s.rfind('.', s.length() - 1);\n}\n\nstd::pair<long long, int> calc(int depth, int i) {\n    int num = getDots(ss[i]) + 1;\n    if(depth > num) {\n        return {-1, i};\n    }\n\n    char c = ss[i][num];\n    if(c >= '0' && c <= '9') {\n        return {(long long)(c - '0'), i+1};\n    }\n\n    long long ans = (c == '+' ? 0 : 1);\n    int j = i + 1;\n    while(true) {\n        auto res = calc(depth + 1, j);\n        if(res.first == -1) {\n            break;\n        }\n        if(c == '+') {\n            ans += res.first;\n        } else {\n            ans *= res.first;\n        }\n        j = res.second;\n    }\n    return {ans, j};\n}\n\nint main() {\n    while(std::cin >> n, n != 0) {\n        if(ss.size() < n) {\n            ss.resize(n);\n        }\n        for(int i=0; i<n; ++i) {\n            std::cin >> ss[i];\n        }\n        std::cout << calc(0, 0).first << std::endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstatic const int INF = 1e9 + 7;\n\ntemplate<typename T>\nusing Vec = vector<T>;\n\ntemplate<typename T, typename T2>\nusing P = pair<T, T2>;\n\ntemplate<typename... Args>\nusing Tup = tuple<Args...>;\n\ntemplate<typename T>\nusing qp = priority_queue<T, Vec<T>, greater<T> >;\n\ntemplate<typename T>\nusing pq = priority_queue<T>;\n\nusing llong = long long;\nusing ullong = unsigned long long;\nusing uint = unsigned int;\n\nVec<string> infos;\n\nenum struct info {\n  add,\n  mul\n};\n\nstack<info> s;\nint now;\nint dfs()\n{\n  if(now == infos.size()){\n    switch (s.top()) {\n    case info::add:\n      return 0;\n    case info::mul:\n      return 1;\n    }\n  }\n  int res = (s.top() == info::mul);\n  auto d = s.top();\n  while (now < infos.size() && s.size() <= infos[now].size()) {\n    auto c = infos[now].back();\n    switch (c) {\n    case '+':\n      s.push(info::add);\n      switch (d) {\n      case info::add:\n        now++;\n        res += dfs();\n        break;\n      default:\n        now++;\n        res *= dfs();\n      }\n      break;\n    case '*':\n      s.push(info::mul);\n      now++;\n      switch (d) {\n      case info::add:\n        res += dfs();\n        break;\n      default:\n        res *= dfs();\n      }\n      break;\n    default:\n      now++;\n      switch (d) {\n      case info::add:\n        res += c - '0';\n        break;\n      default:\n        res *= c - '0';\n      }\n    }\n  }\n  s.pop();\n  return res;\n}\n\nvoid hawawa()\n{\n  int n;\n  while (cin >> n && n) {\n    infos.resize(n);\n    for (auto&& i : infos) {\n      cin >> i;\n    }\n    s.push(info::add);\n    now = 0;\n    cout << dfs() << \"\\n\";\n    while (s.size()) s.pop();\n  }\n}\n\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  hawawa();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nvector<int>ns;\nvector<int>nums;\nint a;\nint getans(const int s) {\n\t\n\tif (nums[a] == -1) {\n\t\tint ans = 0;\n\t\ta++;\n\t\tans += getans(s + 1);\n\t\twhile (1) {\n\t\t\tif (a+1 == ns.size())break;\n\t\t\tif (ns[a+1] != s + 1)break;\n\t\t\ta++;\n\t\t\tans += getans(s + 1);\n\t\t}\n\t\treturn ans;\n\t}\n\telse if (nums[a] == -2) {\n\t\tint ans = 1;\n\t\ta++;\n\t\tans *= getans(s + 1);\n\t\twhile (1) {\n\t\t\tif (a+1 == ns.size())break;\n\t\t\tif (ns[a+1] != s + 1)break;\n\t\t\ta++;\n\t\t\tans *= getans(s + 1);\n\t\t}\n\t\treturn ans;\n\t}\n\telse {\n\t\tint ans = nums[a];\n\t\treturn ans;\n\t}\n}\nint main() {\n\twhile (1) {\n\t\ta = 0;\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tns.clear();\n\t\tnums.clear();\n\t\tns.resize(N);\n\t\tnums.resize(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tint n = st.find_first_not_of('.');\n\t\t\tns[i] = n;\n\t\t\tif (st.substr(n) == \"+\")nums[i] = -1;\n\t\t\telse if (st.substr(n) == \"*\")nums[i] = -2;\n\t\t\telse nums[i] = stoi(st.substr(n));\n\n\t\t}\n\t\tint ans=getans(0);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF = 1e9;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nint p; \nvector<string> S;\nint N;\n\nint solve(int level)\n{\n\n    if (isdigit(S[p][level])) {\n        return (S[p++][level] - '0');\n    }\n\n    while (true) {\n        // DUMP2(p, level);\n        if (p < N && S[p].size() < level) break;\n        if (S[p][level] == '+') {\n            p++; // skip '+'\n            int tmp = 0;\n            while (true) {\n                if (p >= N || S[p].size() <= level+1) break;\n                tmp += solve(level+1);\n            }\n            return tmp;\n        } else if (S[p][level] == '*') {\n            p++; // skip '*'\n            int tmp = 1;\n            while (true) {\n                if (p >= N || S[p].size() <= level+1) break;\n                tmp *= solve(level+1);\n            }\n            return tmp;\n        }\n    }\n\n    return -1;\n}\n\nint main()\n{\n    while (cin >> N, N) {\n        p = 0;\n        S.resize(N);\n        rep(i, N) cin >> S[i];\n        cout << solve(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <typeinfo>\n\n#define REP(i,n) for(int i=0; i<n; i++)\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\nusing namespace std;\n\nstring eq[50];\nint n, j;\n\n\nint calc(int l, int po){\n\t//printf(\"calc(%d, %d)\\n\",l, j);\n\tint ans, num;\n\tbool op;\n\tchar c;\n\t\n\tj = po;\n\t\n\tif (eq[j][l]=='+') op = true;\n\telse op = false;\n\t\n\tans = op ? 0 : 1;\n\t\n\tj++;\n\twhile(1){\n\t\tif (eq[j].length()<=l+1 || j>=n){\n\t\t\tj--;\n\t\t\tbreak;\n\t\t}\n\t\tc = eq[j][eq[j].length()-1];\n\t\tif (c=='+' || c=='*'){\n\t\t\tnum = calc(l+1, j);\n\t\t}else{\n\t\t\tnum = c-'0';\n\t\t}\n\t\tans = op ? ans+num : ans*num;\n\t\t//debug(j);\n\t\t//debug(ans);\n\t\tj++;\n\t}\n\t//printf(\"calc(%d, %d) = %d\\n\", l, po, ans);\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\t//cout << \"-------\" << endl;\n\t\tj = 0;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\tREP(i,n){\n\t\t\tcin >> eq[i];\n\t\t}\n\t\tif (n<=1){\n\t\t\tcout << eq[0] << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << calc(0,0) << endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint main(){\n  int a,m[42]={},i,j,s,sum,h;\n  char b[12];\n  while(1){\n    scanf(\"%d\",&a);\n    if(a==0)break;\n    for(i=0;i<a;i++){\n      scanf(\"%s\",b);\n      for(j=0;j<12;j++){\n\tif(b[j]=='\\0'){\n\t  m[i]=j;\n\t  break;\n\t}\n      }\n    }\n    s=-1;\n    while(1){\n      s++;\n      sum=0;\n      h=s;\n      while(sum<5){\n\tsum+=m[h];\n\th++;\n      }\n      if(sum>5)continue;\n      while(sum<12){\n\tsum+=m[h];\n\th++;\n      }\n      if(sum>12)continue;\n      while(sum<17){\n\tsum+=m[h];\n\th++;\n      }\n      if(sum>17)continue;\n      while(sum<24){\n\tsum+=m[h];\n\th++;\n      }\n      if(sum>24)continue;\n      while(sum<31){\n\tsum+=m[h];\n\th++;\n      }\n      if(sum>31)continue;\n      if(sum==31)break;\n    }\n    printf(\"%d\\n\",s+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nll n;\n\nll dfs(ll line,ll level,vector<string> form){\n  dbg(line); dbg(level);\n  if(isdigit(form[line][level]))return (ll)(form[line][level]-'0');\n  char op=form[line][level];\n  ll res=(op=='*'?1:0);\n  repl(i,line+1,n){\n    if(form[i][level]!='.')break;\n    if(form[i][level+1]=='.')continue;\n    ll tmp=dfs(i,level+1,form);\n    res=(op=='*'?res*tmp:res+tmp);\n  }\n  return res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vector<string> form;\n    rep(i,n){\n      string s;\n      cin>>s;\n      form.pb(s);\n    }\n    cout<<dfs(0,0,form)<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n\nint main()\n{\n    while (true)\n    {\n    \tint n;\n    \tcin >> n;\n    \tif (n == 0) break;\n    \tstring s;\n    \tint ans = 0;\n    \tstack<pair<char, int>> operate;\n    \toperate.push(make_pair('+', 0));\n    \tfor (int i = 0;i < n;++ i) {\n    \t\tcin >> s;\n    \t\twhile (operate.size() > s.size()) {\n    \t\t\tint tmp = operate.top().second;\n    \t\t\toperate.pop();\n    \t\t\tif (operate.top().first == '+') operate.top().second += tmp;\n    \t\t\telse operate.top().second *= tmp;\n    \t\t}\n    \t\tif ('0' <= s[s.size() - 1] && s[s.size() - 1] <= '9') {\n    \t\t\tif (operate.top().first == '+') operate.top().second += s[s.size() - 1] - '0';\n    \t\t\telse operate.top().second *= s[s.size() - 1] - '0';\n    \t\t} else if (s[s.size() - 1] == '+') operate.push(make_pair('+', 0));\n    \t\telse operate.push(make_pair('*', 1));\n    \t}\n    \twhile (operate.size() > 1) {\n\t\t\tint tmp = operate.top().second;\n\t\t\toperate.pop();\n\t\t\tif (operate.top().first == '+') operate.top().second += tmp;\n\t\t\telse operate.top().second *= tmp;\n    \t}\n    \tcout << operate.top().second << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<climits>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nvoid solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        st.push(make_pair(th, l-1));\n    }\n}\nint main(){\n    int ca=0;\n    while(cin>>n,n){\n        while(ope.size())ope.pop();\n        while(st.size())st.pop();\n        if(ca++>110)return -1;\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    solve(level);\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        solve(0);\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\n\nint p;\n\nll expr(vector<string> const& v, int d, vector<int> const& cnt) {\n    ll res = 0;\n    if(v[p][d] == '*') {\n        res = 1;\n        p++;\n        while(p < v.size() && cnt[p] == d+1) {\n            res *= expr(v, d+1, cnt);\n        }\n        if(p < v.size()) {\n            p--;\n        }\n    } else if(v[p][d] == '+') {\n        p++;\n        while(p < v.size() && cnt[p] == d+1) {\n            res += expr(v, d+1, cnt);\n        }\n        if(p < v.size()) {\n            p--;\n        }\n    } else {\n        res = v[p][d] - '0';\n    }\n    p++;\n    return res;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        p = 0;\n        vector<string> v(n);\n        vector<int> d(n);\n        for(int i=0; i<n; ++i) {\n            cin >> v[i];\n            int cnt = 0;\n            for(int j=0; j<v[i].size(); ++j) {\n                if(v[i][j] == '.') {\n                    cnt++;\n                } else {\n                    break;\n                }\n            }\n            d[i] = cnt;\n        }\n        cout << expr(v, 0, d) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\n// opeの単位元\nint gen(char ope) {\n    if (ope == '+') return 0;\n    else return 1; // '*'\n}\n\nint operate(char ope, int x, int y) {\n    if (ope == '+') return x + y;\n    else return x * y;\n}\n\n// topの演算子を消す\nvoid ope_sub(stack<char> &ope_sta, stack<int> &num_sta) {\n    ope_sta.pop();\n    if (ope_sta.empty()) return;\n    int x = num_sta.top(); num_sta.pop();\n    int y = num_sta.top(); num_sta.pop();\n    num_sta.push(operate(ope_sta.top(), x, y));\n}\n\n// topに演算子を追加\nvoid ope_add(char ope, stack<char> &ope_sta, stack<int> &num_sta) {\n    ope_sta.push(ope);\n    num_sta.push(gen(ope));\n}\n\n\nvoid operate(int x, stack<char> &ope_sta, stack<int> &num_sta) {\n    char ope = ope_sta.top();\n    int y = num_sta.top(); num_sta.pop();\n    num_sta.push(operate(ope, y, x));\n}\n\nint main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        if (n == 1) {\n            int x; cin >> x;\n            cout << x << endl;\n            continue;\n        }\n        stack<char> ope_sta;\n        stack<int> num_sta;\n        for (int i = 0; i < n; i++) {\n            string s; cin >> s;\n            while (ope_sta.size() > s.size() - 1) {\n                ope_sub(ope_sta, num_sta);\n            }\n            if (s[s.size() - 1] == '+' || s[s.size() - 1] == '*') {\n                ope_add(s[s.size() - 1], ope_sta, num_sta);\n            }\n            else {\n                int x = s[s.size() - 1] - '0';\n                operate(x, ope_sta, num_sta);\n            }\n        }\n        while (ope_sta.size()) {\n            ope_sub(ope_sta, num_sta);\n        }\n        cout << num_sta.top() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\n \nint n;\nstring s[1024];\n \nint rec(int a,int b,int c){\n    int res=0;\n    if(c) res=1;\n    for(int i=a; i<n&&b<s[i].size(); i++){\n        if(s[i][b]=='.')continue;\n        int x=s[i][b]-'0';\n        if(s[i][b]=='*') x=rec(i+1,b+1,1);\n        if(s[i][b]=='+') x=rec(i+1,b+1,0);\n        if(c)res*=x;\n        else res+=x;\n    }\n    return res;\n}\n \nint main(){\n    while(1){\n        cin>>n;\n        if(n==0)break;\n        REP(i,n)cin>>s[i];\n        cout<<rec(0,0,0)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        string S[100];\n        for(int i = 1; i <= n; i++) cin >> S[i];\n        vector<int> query[100];\n        for(int i = n; i >= 1; i--) {\n            int depth = S[i].size() - 1;\n            if(S[i].back() <= '9' && S[i].back() >= '0') {\n                query[depth].push_back((int)(S[i].back() - '0'));\n                continue;\n            }\n            if(S[i].back() == '*') {\n                int now = 1;\n                for(int j = 0; j < query[depth+1].size(); j++) {\n                    now *= query[depth+1][j];\n                }\n                query[depth].push_back(now);\n                query[depth+1].clear();\n            }\n            if(S[i].back() == '+') {\n                int now = 0;\n                for(int j = 0; j < query[depth+1].size(); j++) {\n                    now += query[depth+1][j];\n                }\n                query[depth].push_back(now);\n                query[depth+1].clear();\n            }\n        }\n        cout << query[0][0] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(long long i=0;i<n;i++)\n#define REP1(i,n) for(long long i=1;i<=n;i++)\n#define REP2D(i,j,h,w) for(long long i=0;i<h;i++) for(long long j=0;j<w;j++)\n#define REP2D1(i,j,h,w) for(long long i=1;i<=h;i++) for(long long j=1;j<=w;j++)\n#define PER(i,n) for(long long i=((n)-1);i>=0;i--)\n#define PER1(i,n) for(long long i=(n);i>0;i--)\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define FORE(i,a,b) for(long long i=(a);i<=(b);i++)\n#define ITE(arr) for(auto ite=(arr).begin();ite!=(arr).end();++ite)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define YNPRT(b) cout<<((b)?\"Yes\":\"No\")<<endl\n#define REV(arr) reverse(ALL(arr))\n#define PRT(a) cout<<a<<endl;\n#define PRTLST(arr,num) REP(_i,num) cout<<_i<<\" - \"<<arr[_i]<<endl;\n#define PRTLST2(arr2,d1,d2) REP(_i,d1) REP(_j,d2) cout<<_i<<\",\"<<_j<<\" : \"<<arr2[_i][_j]<<endl;\n#define PRTLST2D(arr2,d1,d2) do{cout<<\"L\\t\";REP(_i,d2) cout<<_i<<\"\\t\"; cout<<endl; REP(_i,d1){cout<<_i<<\"\\t\";REP(_j,d2){cout<<arr2[_i][_j]<<\"\\t\";}cout<<endl;}}while(0);\n#define fst first\n#define scd second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int INF_INT = 2147483647;\nconst ll INF_LL = 9223372036854775807LL;\nconst ull INF_ULL = 18446744073709551615Ull;\nconst ll P = 92540646808111039LL;\nconst int Move[4][2] = {-1,0,1,0,0,1,0,-1};\nconst int Move_[8][2] = {-1,-1,-1,0,-1,1,0,-1,0,1,1,-1,1,0,1,1};\n\n//---------------------\n#define MAXN 100000\n//---------------------\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& v) {ITE(v) os << *ite << \" \";return os;}\n\ntypedef ll (*oprfunc)(ll a,ll b);\n\nstruct Dataopr{\n    Dataopr(ll l,oprfunc f,ll n){\n        level=l;func=f;num=n;\n    }\n    ll level=-1;\n    oprfunc func=nullptr;\n    ll num=-1;\n};\n\nll n,ret;\nvector<string> data;\nvector<Dataopr> oprdata;\nstack<Dataopr> oprstack;\n\n\nll getlevel(const string& target){\n    ll ret=0;\n    ITE(target){\n        if(*ite!='.') break;\n        ret++;\n    }\n    return ret;\n}\n\nll plusfunc(ll a,ll b){return a+b;}\nll multfunc(ll a,ll b){return a*b;}\n\noprfunc getopr(const string& target){\n    ITE(target){\n        if(*ite!='.') {\n            if(*ite=='+') return plusfunc;\n            if(*ite=='*') return multfunc;\n            return nullptr;\n        }\n    }\n    return nullptr;\n}\n\nll getnum(const string& target){\n    ITE(target){\n        if(*ite!='.') {\n            return *ite-'0';\n        }\n    }\n    return -1;\n}\n\n\nbool init(){\n    // Initializing\n    data.clear();\n    oprdata.clear();\n    while(!oprstack.empty()) oprstack.pop();\n    // Assignment\n    cin>>n;\n    if(n<=0) return false;\n    REP(i,n){\n        string curs;\n        cin>>curs;\n        data.push_back(curs);\n    }\n\n    ITE(data){\n        oprdata.push_back(Dataopr(getlevel(*ite),getopr(*ite),getnum(*ite)));\n    }\n    oprdata.push_back(Dataopr(0,nullptr,-1));\n    return true;\n}\n\nvoid subsolve(ll targetlevel){\n   if(oprstack.empty()) return;\n    Dataopr curdata=oprstack.top();\n    vector<ll> numlist;\n    while(curdata.level>=targetlevel){\n        oprstack.pop();\n        if(curdata.func){\n            ll curret=(curdata.func==plusfunc)?0:1;\n            REP(i,numlist.size()){\n                curret=curdata.func(curret,numlist[i]);\n            }\n            numlist.clear();\n            if(oprstack.size()) oprstack.push(Dataopr(oprstack.top().level,nullptr,curret));\n            else {oprstack.push(Dataopr(0,nullptr,curret));return;}\n            //cout<<curdata.level<<\" \"<<targetlevel<<endl;\n            if(curdata.level==targetlevel) return;\n        }else numlist.push_back(curdata.num);\n        curdata=oprstack.top();\n    }\n}\n\nvoid solve(){\n    ll lastlevel=0;\n    if(oprdata.size()==1) {ret=oprdata[0].num; return ;}\n    //if(oprdata[0].func==plusfunc) ret=0; else ret=1;\n\n    ITE(oprdata){\n        if(ite->level<lastlevel){\n            subsolve(ite->level);\n        }\n        lastlevel=ite->level;\n        if(ite->func){\n            oprstack.push(*ite);\n            continue;\n        }\n        oprstack.push(*ite);\n    }\n    Dataopr last(0,nullptr,0);\n    //subsolve(curlevel,last);\n    oprstack.pop();\n    ret=oprstack.top().num;\n}\n\nint main(){\n    while(init()){\n        solve();\n        cout<<ret<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nvector<string> s;\nll pos = 0;\n\nll cal(int n, int t) {\n\tll res = 0;\n\tswitch(t) {\n\t\tcase 0:\n\t\t{\n\t\t\twhile(pos < s.size()) {\n\t\t\t\tll cnt = 0;\n\t\t\t\tREP(i, s[pos].size()) {\n\t\t\t\t\tif(s[pos][i] == '.') ++cnt;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tif(cnt == n) {\n\t\t\t\t\tif(s[pos][n] == '+') {\n\t\t\t\t\t\t++pos;\n\t\t\t\t\t\tres += cal(n + 1, 0);\n\t\t\t\t\t} else if(s[pos][n] == '*') {\n\t\t\t\t\t\t++pos;\n\t\t\t\t\t\tres += cal(n + 1, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres += stoi(s[pos].substr(n, s[pos].size() - n));\n\t\t\t\t\t\t++pos;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\t++res;\n\t\t\twhile(pos < s.size()) {\n\t\t\t\tll cnt = 0;\n\t\t\t\tREP(i, s[pos].size()) {\n\t\t\t\t\tif(s[pos][i] == '.') ++cnt;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tif(cnt == n) {\n\t\t\t\t\tif(s[pos][n] == '+') {\n\t\t\t\t\t\t++pos;\n\t\t\t\t\t\tres *= cal(n + 1, 0);\n\t\t\t\t\t} else if(s[pos][n] == '*') {\n\t\t\t\t\t\t++pos;\n\t\t\t\t\t\tres *= cal(n + 1, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres *= stoi(s[pos].substr(n, s[pos].size() - n));\n\t\t\t\t\t\t++pos;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n\treturn res;\n}\n\nint main(void) {\n\twhile(true) {\n\t\tpos = 0;\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\ts.resize(n);\n\t\tREP(i, n) cin>>s[i];\n\t\tif(n == 1) {\n\t\t\tcout<<s[0]<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(s[0] == \"+\") {\n\t\t\t++pos;\n\t\t\tcout<<cal(1, 0)<<endl;;\n\t\t}\n\t\tif(s[0] == \"*\") {\n\t\t\t++pos;\n\t\t\tcout<<cal(1, 1)<<endl;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nvector<string>v;\nint bfs(int x) {\n\tint len = v[x].length(); int res = 0;\n\tif (v[x][len - 1] == '+') {\n\t\tx++;\n\t\twhile (x < (int)v.size() && len+1 <= (int)v[x].length()) {\n\t\t\tif (v[x].length() == len+1) {\n\t\t\t\tres += bfs(x);\n\t\t\t}\n\t\t\tx++;\n\t\t}\n\t}\n\telse if (v[x][len - 1] == '*') {\n\t\tres = 1; x++;\n\t\twhile (x < (int)v.size() && len + 1 <= (int)v[x].length()) {\n\t\t\tif (v[x].length() == len + 1) {\n\t\t\t\tres *= bfs(x);\n\t\t\t}\n\t\t\tx++;\n\t\t}\n\t}\n\telse {\n\t\tres = v[x][len - 1]-'0';\n\t}\n\treturn res;\n}\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tv.clear();\n\t\tstring t;\n\t\trep(i, n) {\n\t\t\tcin >> t;\n\t\t\tv.push_back(t);\n\t\t}\n\t    cout << bfs(0) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define endl \"\\n\"\n#define rep(i, a, b) for (auto i = (a); i < (b); ++i)\n#define rrep(i, a, b) for (auto i = (a); i > (b); --i)\n\nvoid sol(int &n)\n{\n  vector<string> v(n);\n  int IsOp[100];\n  int num[100];\n  rep(i, 0, n)\n  {\n    cin >> v[i];\n    if (v[i].back() == '*' || v[i].back() == '+')\n    {\n      IsOp[i] = (v[i].back() == '+' ? 1 : 2);\n    }\n    else\n    {\n      IsOp[i] = 0;\n      num[i] = v[i].back() - '0';\n    }\n  }\n  vector<int> res[100];\n  rrep(i, n - 1, -1)\n  {\n    int tmp = 0;\n    if (IsOp[i] == 1)\n    {\n      rep(j, 0, (int)res[i].size())\n      {\n        tmp += res[i][j];\n      }\n    }\n    else if (IsOp[i] == 2)\n    {\n      tmp = 1;\n      rep(j, 0, (int)res[i].size())\n      {\n        tmp *= res[i][j];\n      }\n    }\n    else\n      tmp = num[i];\n    if (i == 0)\n    {\n      cout << tmp << endl;\n      return;\n    }\n    rrep(j, i - 1, -1)\n    {\n      if (v[i].size() - 1 == v[j].size())\n      {\n        res[j].push_back(tmp);\n        break;\n      }\n    }\n  }\n}\n\nint n;\n\nint main()\n{\n  while (cin >> n, n)\n  {\n    sol(n);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(ll i = ll(a); i < ll(b); i++)\n#define rer(i, a, b) for(ll i = ll(a) - 1; i >= ll(b); i--)\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sc second\n#define fr first\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\nusing namespace std;\nclass ParseError {};\ntypedef long long int ll;\ntypedef pair <int, int> P;\n\nvector<string> v;\nint n;\nint getlevel(string s){\n    rep(i,0,s.length()){\n        if(s[i]!='.') return i;\n    }\n    return 0;\n}\nchar get(string s){\n    return s[getlevel(s)]=='+'||s[getlevel(s)]=='*';\n}\nll solve(char c, int &x, int level) {\n    ll ret;\n    if(c=='*'){\n        ret=1;\n        while(x<=n-1&&getlevel(v[x])>level){\n            if(get(v[x])){\n                if(v[x][getlevel(v[x])]=='+') ret*=solve('+', ++x ,level+1);\n                else ret*=solve('*', ++x,level+1);\n            }\n            else{\n                ret*=v[x][getlevel(v[x])]-'0';\n                x++;\n            }\n        }\n        return ret;\n    }\n    else{\n        ret=0;\n        while(x<=n-1&&getlevel(v[x])>level){\n            if(get(v[x])){\n                if(v[x][getlevel(v[x])]=='+') ret+=solve('+', ++x,level+1);\n                else ret+=solve('*',++x,level+1);\n            }\n            else{\n                ret+=v[x][getlevel(v[x])]-'0';\n                x++;\n            }\n        }\n        return ret;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    for(;;){\n        cin>>n;\n        if(!n) return 0;\n        v.clear();\n        v.resize(n);\n        rep(i,0,n) cin>>v[i];\n        int x=1, level=0;\n        if(n==1) cout<<v[0]<<\"\\n\";\n        else{\n            if(v[0]==\"*\") cout<< solve('*', x, level) <<\"\\n\";\n            else cout<<solve('+',x,level)<<\"\\n\";\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint n,num;\nvector<string> s;\n\nint solve(int c, int a, int b)\n{\n    if(c == 0){\n        return a+b;\n    }else{\n        return a*b;\n    }\n}\n\nint dfs(int d,int id)\n{\n    int res = id;\n    while(num < n){\n        if(isdigit(s[num].back())){\n            if((int)s[num].size()-1 < d){\n                return res;\n            }\n            res = solve(id,res,(s[num].back()-'0'));\n            num++;\n        }else{\n            if((int)s[num].size()-1 < d){\n                return res;\n            }\n            int flag = (s[num].back()=='*');\n            num++;\n            int ans = dfs(d+1,flag);\n            res = solve(id,res,ans);\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        s.resize(n);\n        rep(i,n){\n            cin >> s[i];\n        }\n        num = 0;\n        cout << dfs(0,0) << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<climits>\nusing namespace std;\n\nchar o[200];\nint d[200],n,j;\nstring s;\nint x(int _){\n    if(o[j]>='0'&&o[j]<='9')return o[j++]-'0';\n    int k=j,r;\n    o[j++]=='*'?r=1:r=0;\n    while(d[k]+1==d[j])\n        if(o[k]=='*')r*=x(j);\n        else r+=x(j);\n    return r;\n}\nint main(){\n    while(cin>>n,n){\n        d[n]=0;\n        for(int i=0;i<n;i++){\n            cin>>s;\n            o[i]=s[s.length()-1];\n            d[i]=s.length();\n        }\n        j=0;\n        cout<<x(0)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nstring s[11];\nint dfs(int d,int k){\n  bool e=0;\n  int res=0;\n  if(s[d][k]=='+')d++,k++;\n  if(s[d][k]=='*')e=1,d++,k++,res=1;\n  for(int i=d;i<n&&k<s[i].size();i++){\n    int a=s[i][k]-'0';\n    if(s[i][k]=='.')continue;\n    if(s[i][k]=='+'||s[i][k]=='*')a=dfs(i,k);\n    if(e)res*=a;\n    else res+=a;\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>s[i];\n    cout<<dfs(0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//tempa\n//#pragma GCC optimize (\"-O3\")\n#ifdef _DEBUG\n#include<cassert>\n#include \"bits_stdc++.h\"\n#else\n#include <bits/stdc++.h>\n#endif\n\n#define t_T template<class T>\n\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(3);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\n#define over4(o1, o2, o3, o4, name, ...) name\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec vector\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\nusing vi = vector<ll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\n\n//#define V vector\n#define vvt0(t) vector<vector<t>>\n#define vvt1(t, a) vector<vector<t>>a\n#define vvt2(t, a, b) vector<vector<t>>a(b)\n#define vvt3(t, a, b, c) vector<vector<t>> a(b,vector<t>(c))\n#define vvt4(t, a, b, c, d) vector<vector<t>> a(b,vector<t>(c,d))\n\n#define vvi(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) over4(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n\n\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\n\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\n\nt_T T MAX() { return numeric_limits<T>::max(); }\nt_T T MIN() { return numeric_limits<T>::min(); }\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nt_T T INF() { return MAX<T>() / 2; }\ntemplate<> signed INF() { return inf; }\ntemplate<> ll INF() { return linf; }\ntemplate<> double INF() { return (double) linf * linf; }\n\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n/*@formatter:off*/\ninline void sort(string &a) { sort(all(a)); }\nt_T inline void sort(vector<T> &a) { sort(all(a)); };\nt_T inline void rsort(vector<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U> inline void sortp(vector<U> &a, vector<U> &b) {    vp c;    int n = sz(a);    assert(n == sz(b));    rep(i, n)c.eb(a[i], b[i]);    sort(c);    rep(i, n) {        a[i] = c[i].first;        b[i] = c[i].second;;    }};//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class U> inline void rsortp(vector<U> &a, vector<U> &b) {    vp c;    int n = sz(a);    assert(n == sz(b));    rep(i, n)c.eb(a[i], b[i]);    rsort(c);    rep(i, n) {        a[i] = c[i].first;        b[i] = c[i].second;    }};\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {xx = vall;}\ntemplate<typename V, typename T>\nvoid fill(vector<V> &vecc, const T vall) {for (auto &&vx: vecc) fill(vx, vall);}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {T x;cin >> x;return (x);}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\ntemplate<typename W, typename H> void resize(W &vec_, const H head) { vec_.resize(head); }\ntemplate<typename W, typename H, typename ... T> void resize(W &vec_, const H &head, const T ... tail) {vec_.resize(head);for (auto &v: vec_)resize(v, tail...);}\n\n\nstring sin() { return _in<string>(); }\nll lin() { return _in<ll>(); }\nt_T void na(vector<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i];}\n#define dna(a, n) vi a; na(a, n);/*nを複数使うと n==in()の時バグる事に注意*/\n#define dnad(a, n) vi a; nad(a, n);\nt_T void nad(vector<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, ll n) {a.resize(n);b.resize(n);rep(i, n)cin >> a[i] >> b[i];}\n#define dna2(a, b, n) vi a,b; na2(a,b,n);\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {a.resize(n);b.resize(n);c.resize(n);rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n#define dnt(S, h, w) vvi(S,h,w);nt(S,h,w);\n#define dntc(S, h, w) vvc(S,h,w);nt(S,h,w);\n#define dnts(S, h, w) vvs(S,h,w);nt(S,h,w);\n\n//デバッグ\n#define sp << \" \" <<\nconstexpr int DEB_LEN =20;\nconstexpr int DEB_LEN_H =12;\nstring deb_tos(const int &v) { if (abs(v) == inf || abs(v) == linf)return \"e\"; else return to_string(v); }\ntemplate<class T> string deb_tos(const T &a) {stringstream ss;ss << a;return ss.str();}\ntemplate<class T> string deb_tos(const vector<T> &a, ll W = inf) {    stringstream ss;    if (W == inf)W = min(sz(a), DEB_LEN);    if (sz(a) == 0)return ss.str();    rep(i, W) {        ss << deb_tos(a[i]);        if (typeid(a[i]) == typeid(P)) { ss << endl; } else { ss << \" \"; }    }    return ss.str();}\ntemplate<class T> string deb_tos(const vector<vector<T> > &a, vi H, vi W, int key = -1) {    stringstream ss;    ss << endl;    vi lens(sz(W));    fora(h, H) {        rep(wi, sz(W)) {            lens[wi] = max(lens[wi], sz(deb_tos(a[h][W[wi]])) + 1);            lens[wi] = max(lens[wi], sz(deb_tos(W[wi])) + 1);        }    }    if (key == -1)ss << \" *|\"; else ss << \" \" << key << \"|\";    int wi = 0;    fora(w, W) {        ss << std::right << std::setw(lens[wi]) << w;        wi++;    }    ss << \"\" << endl;    rep(i, sz(W))rep(_, lens[i]) ss << \"_\";    rep(i, 3)ss << \"_\";    ss << \"\" << endl;    fora(h, H) {        ss << std::right << std::setw(2) << h << \"|\";        int wi = 0;        fora(w, W) {            ss << std::right << std::setw(lens[wi]) << deb_tos(a[h][w]);            wi++;        }        ss << \"\" << endl;    }    return ss.str();}\ntemplate<class T> string deb_tos(const vector<vector<T> > &a, ll H = inf, ll W = inf, int key = -1) {    H = (H != inf) ? H : min({H, sz(a), DEB_LEN_H});    W = min({W, sz(a[0]), DEB_LEN_H});    vi hs, ws;    rep(h, H) { hs.push_back(h); }    rep(w, W) { ws.push_back(w); }    return deb_tos(a, hs, ws, key);}\ntemplate<class T> string deb_tos(const vector<vector<vector<T> > > &a, ll H = inf) {    stringstream ss;    if (H == inf)H = DEB_LEN_H;    H = min(H, sz(a));    rep(i, H) {        ss << endl;        ss << deb_tos(a[i], inf, inf, i);    }    return ss.str();}\ntemplate<class T, size_t A> string deb_tos(T (&a)[A]) { return deb_tos(vector<T>(begin(a), end(a))); }\ntemplate<class T, size_t A, size_t B> string deb_tos(T (&a)[A][B]) { return deb_tos(vector<vector<T> >(begin(a), end(a))); }\ntemplate<class T, size_t A, size_t B, size_t C> string deb_tos(T (&a)[A][B][C]) { return deb_tos(vector<vector<vector<T> > >(begin(a), end(a))); }\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<deb_tos(x) << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<deb_tos(x)<<\", \"<< debugName(y)<<\" = \"<<deb_tos(y)<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<deb_tos(x)  << \", \" <<  debugName(y)<<\" = \"<<deb_tos(y) <<\", \" debugName(z)<<\" = \"<<deb_tos(z) <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<deb_tos(x) <<\", \" <<   debugName(y)<<\" = \"<<deb_tos(y) <<\", \" <<  debugName(z)<<\" = \"<<deb_tos(z) <<\", \" <<  debugName(a)<<\" = \"<<deb_tos(a)<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<deb_tos(x) <<\", \" <<   debugName(y)<<\" = \"<<deb_tos(y) <<\", \" <<  debugName(z)<<\" = \"<<deb_tos(z) <<\", \" <<  debugName(a)<<\" = \"<<deb_tos(a)<<\", \" <<  debugName(b)<<\" = \"<<deb_tos(b)<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#ifdef _DEBUG\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#else\n#define deb(...) ;\n#endif\n\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll gcd(vi b) {ll res = b[0];for (auto &&v :b)res = gcd(v, res);return res;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    return res;}\ntemplate<class T> auto rev(const T &v, int i) {return v[sz(v) - 1 - i];}\nt_T vector<T> rev(vector<T> &a) {    auto b = a;    reverse(all(b));    return b;}\nstr rev(str &a) {str s = a;reverse(all(s));return s;}\nll ceil(ll a, ll b) {if (b == 0) {cerr<<\"ceil\"<<endl;exit(1);return -1;} else return (a + b - 1) / b;}\nll sqrt(ll a) {    if (a < 0) {        cerr<<\"sqrt\"<<endl;        exit(1);    }    ll res = (ll) std::sqrt(a);    while (res * res < a)res++;    return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {    vi res;    double lim = std::sqrt(v);    rep(i, 1, lim+1){        if (v % i == 0) {            res.pb(i);            if (i != v / i)res.pb(v / i);        }    }    return res;}\nvb isPrime;\nvi primes;\n\nvoid setPrime() {    int len = 4010101;    isPrime.resize(4010101);    fill(isPrime, true);    isPrime[0] = isPrime[1] = false;    for (int i = 2; i <= sqrt(len) + 5; ++i) {        if (!isPrime[i])continue;        for (int j = 2; i * j < len; ++j) {            isPrime[i * j] = false;        }    }    rep(i, len)if (isPrime[i])primes.pb(i);}\n\nvi factorization(int v) {    int tv = v;    vi res;    if (isPrime.size() == 0)setPrime();    for (auto &&p :primes) {        if (v % p == 0)res.push_back(p);        while (v % p == 0) {            v /= p;        }        if (v == 1 || p * p > tv)break;    }    if (v > 1)res.pb(v);    return res;}\ninline bool inside(int h, int w, int H, int W) { return h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { return l <= v && v < r; }\n\n\nt_T vector<T> ruiv(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\n//imoは0-indexed\n//ruiは1-indexed\nt_T vector<T> imo(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n\n#define ins inside\nll u0(ll a) { return a < 0 ? 0 : a; }\nt_T vector<T> u(const vector<T> &a) {\n    vector<T> ret = a;fora(v, ret)v = u0(v);return ret;}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\ntemplate<class T, class U> pair<T,U> operator+(const pair<T,U> &a, const pair<T,U> & b) {return pair<T,U>(a.fi+b.fi,a.se+b.se);}\n\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\nvoid POSSIBLE(bool a) {\n    if (a)cout << \"POSSIBLE\" << endl;\n    else cout << \"IMPOSSIBLE\" << endl;\n    exit(0);\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {\n    a.push_back(v);\n    return a;\n}\ntemplate<class T> vector<T>& operator+=(vector<T> & a,const vector<T> & b){\n    rep(i, sz(b))a += b[i];\n    return a;\n}\nt_T T sum(vector<T> &v, int s = 0, int t = inf) {    T ret = 0;    rep(i, s, min(sz(v), t))ret += v[i];    return ret;}\nvoid mod(int &a, int m) { a = (a % m + m) % m; }\ntemplate<class F> inline int mgr(int ok, int ng, F f) {\n#define _mgrbody int mid = (ok + ng) / 2; if (f(mid))ok = mid; else ng = mid;\n    if (ok < ng)while (ng - ok > 1) { _mgrbody } else while (ok - ng > 1) { _mgrbody }\n    return ok;\n}\n\ntemplate<class F> inline int mgr(int ok, int ng, int second, F f) {\n#define _mgrbody2 int mid = (ok + ng) / 2; if (f(mid, second))ok = mid; else ng = mid;\n    if (ok < ng) while (ng - ok > 1) { _mgrbody2 } else while (ok - ng > 1) { _mgrbody2 }\n    return ok;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &m) {    rep(i, sz(m)){os << m[i];if(i < sz(m)-1)os<<\" \";}   return os;}\nostream &operator<<(ostream &os, vector<char> &m) {rep(i, sz(m)){os << m[i];}   return os;}\ntemplate<typename T> ostream &operator<<(ostream &os, vector<vector<T>> &m) {rep(i, sz(m)){os << m[i]; if(i < sz(m)-1)os << endl;}   return os;}\nconstexpr bool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {m /= (ll) pow(sinsuu, keta);return m % sinsuu;}\nll bit(int n) { return (1LL << (n)); }\nll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\nint mask(int n) { return (1ll << n) - 1; }\n#define bcou __builtin_popcountll\ntemplate<class T, class U> inline bool chma(T &a, const U &b) {if (a < b) {a = b;return true;}return false;}\ntemplate<class U> inline bool chma(const U &b) { return chma(ma, b); }\ntemplate<class T, class U> inline bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\ntemplate<class U> inline bool chmi(const U &b) { return chmi(mi, b); }\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\nint max(vi &a) {    int res = a[0];    fora(v, a) {        res = max(res, v);    }    return res;}\nint min(vi &a) {    int res = a[0];    fora(v, a) {        res = min(res, v);    }    return res;}\ntemplate<typename T> class fixed_point        : T {public:    explicit constexpr fixed_point(T &&t) noexcept: T(std::forward<T>(t)) {}    template<typename... Args> constexpr decltype(auto) operator()(Args &&... args) const { return T::operator()(*this, std::forward<Args>(args)...); }};template<typename T> static inline constexpr decltype(auto) fix(T &&t) noexcept { return fixed_point<T>{std::forward<T>(t)}; }\nconstexpr ll h4[] = {1, -1, 0, 0};\nconstexpr ll w4[] = {0, 0, -1, 1};\nconstexpr ll h8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll w8[] = {1, 0, -1, 0, 1, -1, 1, -1};\nint mei_inc(int h, int w, int H, int W, int i) {while (++i < 4) { if (inside(h + h4[i], w + w4[i], H, W))return i; }return i;}\n#define mei(nh, nw, h, w) for (int i = mei_inc(h, w, H, W, -1), nh = i<4? h + h4[i] : 0, nw = i<4? w + w4[i] : 0; i < 4; i=mei_inc(h,w,H,W,i), nh = h+h4[i], nw = w+w4[i])\nint mei_inc8(int h, int w, int H, int W, int i) {    while (++i < 8) {        if (inside(h + h8[i], w + w8[i], H, W))return i;    }    return i;}\n#define mei8(nh, nw, h, w) for (int i = mei_inc8(h, w, H, W, -1), nh = i<8? h + h8[i] : 0, nw = i<8? w + w8[i] : 0; i < 8; i=mei_inc8(h,w,H,W,i), nh = h+h8[i], nw = w+w8[i])\nint mei_incv(int h, int w, int H, int W, int i, vp &p) {    while (++i < sz(p)) { if (inside(h + p[i].fi, w + p[i].se, H, W))return i; }    return i;}\n#define meiv(nh, nw, h, w, p) for (int i = mei_incv(h, w, H, W, -1, p), nh = i<sz(p)? h + p[i].fi : 0, nw = i<sz(p)? w + p[i].se : 0; i < sz(p); i=mei_incv(h,w,H,W,i,p), nh = h+p[i].fi, nw = w+p[i].se)\nvi compress(vi &A) {    vi B = A;    sort(B);    unique(B);    vi inds(sz(B));    rep(i, sz(A)) {        int ind = lower_bound(all(B), A[i]) - B.begin();        inds[ind] = A[i];        A[i] = ind;    }    return inds;}\nvi compress(vi &A, umapi& map){    vi i_v = compress(A);    rep(i, sz(i_v)){        map[i_v[i]] = i;    }    return i_v;}\n\nt_T void out2(T head) {    cout << head;}\ntemplate<class T, class... U> void out2(T head, U ... tail) {    cout << head << \" \";      out2(tail...);}\ntemplate<class T, class... U> void out(T head, U ... tail) {    cout << head << \" \";        out2(tail...);    cout << \"\" << endl;}\nt_T void out(T head) {    cout << head << endl; }\nvoid out() { cout << \"\" << endl; }\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define upperIndex(a, v) (uppereturnbound(all(a),v)-a.begin())\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...)); }\n#define vni(name, ...) auto name = make_v<ll>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n#define vn(type, name, ...) auto name = make_v<type>(__VA_ARGS__)\n#define VEC vector\n\n/*@formatter:on*/\nint N, M, H, W;\nvi A, B, C;\n\n\nvoid solve() {\n    while (in(N), N) {\n        //level, str\n        vector<pair<int, string>> S;\n        rep(i, N) {\n            str s;\n            in(s);\n            auto it_l = find_if(all(s), [&](char c) { return c != '.'; });\n            int lev = it_l - s.begin();\n            str r = s.substr(lev);\n            S += mp(lev, r);\n        }\n        auto is_op = [&](str &s) {\n            return (s[0] == '+' || s[0] == '*');\n        };\n        int loop=0;\n        fora(s, S){\n            deb(s.fi, s.se);\n        }\n        while (1) {\n            if (sz(S) == 1)break;\n            int max_olev = 0;\n            fora(p, S) {\n                if (is_op(p.se))chma(max_olev, p.fi);\n            }\n            rep(i, sz(S)) {\n                int olev = S[i].fi;\n                str s = S[i].se;\n                if (is_op(s) && olev == max_olev) {\n                    vi A;\n                    int r = sz(S);\n                    rep(j, i + 1, sz(S)) {\n                        if ((S[j].fi) != olev+1) {\n                            r = j;\n                            break;\n                        }\n                        A += stoi(S[j].se);\n                    }\n                    int res;\n                    if (s[0] == '+') {\n                        res = 0;\n                        fora(a, A)res += a;\n                    } else {\n                        res = 1;\n                        fora(a, A)res *= a;\n                    }\n                    S.erase(S.begin() + i, S.begin() + r);\n                    S.insert(S.begin() + i, mp(olev, tos(res)));\n                    break;\n                }\n            }\n        }\n        out(stoi(S[0].se));\n    }\n}\n\nsigned main() {\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\n\nll n;\nvector<string> s;\n\nll dfs(ll& i, ll d){\n  char e = s[i][s[i].size()-1];\n  // cerr << e << endl;\n  i++;\n  if(e >= '0' && e <= '9') return (e-'0');\n  else{\n    ll ret;\n    if(e == '+'){\n      ret = 0;\n      while(i < n && s[i].size() == d+1){\n        ret += dfs(i, d+1);\n      }\n    }else if(e == '*'){\n      ret = 1;\n      while(i < n && s[i].size() == d+1){\n        ret *= dfs(i, d+1);\n      }\n    }\n    // cerr << i << \" \" << ret << endl;\n    return ret;\n  }\n}\n\nint main(){\n  while(cin >> n){\n    if(n == 0) return 0;\n    s = vector<string>(n);\n    for(ll i = 0;i < n;i++){\n      cin >> s[i];\n    }\n    ll i = 0;\n    cout << dfs(i, 1) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\ntypedef vector<int> Vint;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nint stk[10][10], head[10];\nvector<string> s;\n\nint dots(string a){\n  int res = 0;\n  for(int i = 0;i < a.size();++i)if(a[i] != '.')return i;\n  return 0;\n}\n\nsigned main(void){\n  int i, j, k;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    rep(i, 10){\n      rep(j, 10)stk[i][j] = 0;\n      head[i] = 0;\n    }\n\n    int(n); if(!n)break;\n    s.resize(n); scn(n, s);\n\n    for(i = n - 1;i >= 0;--i){\n      int d = dots(s[i]);\n      if(s[i][d] == '+'){\n        int sum = 0;\n        rep(j, head[d + 1])sum += stk[d + 1][j];\n        head[d + 1] = 0;\n        stk[d][head[d]++] = sum;\n      }else if(s[i][d] == '*'){\n        int pr = 1;\n        rep(j, head[d + 1])pr *= stk[d + 1][j];\n        head[d + 1] = 0;\n        stk[d][head[d]++] = pr;\n      }else{\n        stk[d][head[d]++] = (int)(s[i][d] - '0');\n      }\n    }\n    pri(stk[0][0]);\n\n\n//*/\n    s.clear();\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nll n;\n\nll dfs(ll line,ll level,vector<string> form){\n  //dbg(line); dbg(level);\n  if(isdigit(form[line][level]))return (ll)(form[line][level]-'0');\n  char op=form[line][level];\n  ll res=(op=='*'?1:0);\n  repl(i,line+1,n){\n    if(form[i].length()<level||form[i][level]!='.')break;\n    if(form[i][level+1]=='.')continue;\n    ll tmp=dfs(i,level+1,form);\n    res=(op=='*'?res*tmp:res+tmp);\n  }\n  return res;\n}\n\nint main(){\n\t//cin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vector<string> form;\n    rep(i,n){\n      string s;\n      cin>>s;\n      form.pb(s);\n    }\n    cout<<dfs(0,0,form)<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <sstream>\n\nusing namespace std;\n\nint main(void) {\n    while (1) {\n\n        int n;\n        cin >> n;\n        if (n == 0) break;\n\n        string formula[n];\n        int formulalen[n];\n        for (int i = 0; i < n; ++i) {\n            cin >> formula[i];\n            formulalen[i] = formula[i].length();\n        }\n\n        while (1) {\n\n            if (formulalen[0] == 1 && formula[0] != \"+\" && formula[0] != \"*\") { // 終了条件\n                cout << formula[0] << endl;\n                break;\n            }\n\n            int maxlen = 0;\n            for (int i = 0; i < n; ++i) {\n                maxlen = max(maxlen, formulalen[i]);\n            }\n\n            bool opefind = false;\n            long long result = 0;\n            string ope;\n            int pos = 0;\n            int maxcnt = 0;\n            for (int i = 0; i < n; ++i) {\n                if (formulalen[i] == maxlen) {\n                    if (!opefind) {\n                        ope = formula[i - 1].substr(formulalen[i - 1] - 1, 1);\n//                        result = stoi(formula[i].substr(formulalen[i] - 1));\n                        stringstream ss1;\n                        ss1 << formula[i].substr(formulalen[i] - 1);\n                        ss1 >> result;\n//                        cout << result << \" \";\n                        opefind = true;\n                        pos = i - 1;\n                        maxcnt += 1;\n                    } else {\n                        if (ope == \"+\") {\n//                            result += stoi(formula[i].substr(formulalen[i] - 1));\n                            int plus;\n                            stringstream ss2;\n                            ss2 << formula[i].substr(formulalen[i] - 1);\n                            ss2 >> plus;\n//                            cout << plus << \" \";\n                            result += plus;\n                        } else if (ope == \"*\") {\n//                            result *= stoi(formula[i].substr(formulalen[i] - 1));\n                            int mul;\n                            stringstream ss3;\n//                            cout << formula[i].substr(formulalen[i] - 1) << endl;\n                            ss3 << formula[i].substr(formulalen[i] - 1);\n                            ss3 >> mul;\n//                            cout << mul << endl;\n                            result *= mul;\n                        }\n                        maxcnt += 1;\n                    }\n                    if (i + 1 != n) {\n                        if (formulalen[i + 1] != maxlen) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            string replaceformula = \"\";\n            for (int i = 0; i < maxlen - 2; ++i) {\n                replaceformula += \".\";\n            }\n            replaceformula += to_string(result);\n\n            n -= maxcnt;\n            formula[pos] = replaceformula;\n            for (int i = pos + 1; i < n; ++i) {\n                formula[i] = formula[i + maxcnt];\n                formulalen[i] = formulalen[i + maxcnt];\n            }\n\n//            printf(\"%d %d\\n\", pos + 1, maxcnt);\n//            for (int i = 0; i < n; ++i) {\n//                cout << formula[i] << \" \" << formulalen[i] << endl;\n//            }\n        }\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,m,n) for(int i=m;i<n;i++)\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tcin >> n;\n\t\tif( !n ) break;\n\n\t\tvector<string> v(n+1);\n\t\tfor(int i = 0 ; i < n ; i++ ){\n\t\t\tcin >> v[i];\n\t\t}\n\t\tv[n] = \"\";\n\t\t\n\t\tif( n == 1 )\n\t\t\tcout << v[0] << endl;\n\t\telse{\n\t\t\tstack<bool> st;\n\t\t\tstack<long> stN;\n\t\t\tst.push(0);\n\t\t\tstN.push(0);\n\t\t\tint len = 1;\n\t\t\trep(i,0,n){\n\t\t\t\tstring s = v[i];\n\t\t\t\tchar c = s[s.size()-1];\n\t\t\t\t//cout << \"stN:\" << stN.top() << \" st:\" << st.top() << \" s:\" << s << \" len:\" << len << \"size\" << st.size() << endl;\n\t\t\t\tif( s.size() < len ){\n\t\t\t\t\trep(i,0,len-s.size()){\n\t\t\t\t\t\tint num = stN.top();\n\t\t\t\t\t\tstN.pop();\n\t\t\t\t\t\tst.pop();\n\t\t\t\t\t\tif(st.top()) num *= stN.top();\n\t\t\t\t\t\telse num += stN.top();\n\t\t\t\t\t\tstN.pop();\n\t\t\t\t\t\tstN.push(num);\n\t\t\t\t\t}\n\t\t\t\t\tlen = s.size();\n\t\t\t\t}\n\t\t\t\tif( c == '+' ){\n\t\t\t\t\tstN.push(0);\n\t\t\t\t\tst.push(0);\n\t\t\t\t\tlen++;\n\t\t\t\t}\n\t\t\t\telse if( c == '*'){\n\t\t\t\t\tstN.push(1);\n\t\t\t\t\tst.push(1);\n\t\t\t\t\tlen++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint num = stN.top();\n\t\t\t\t\tstN.pop();\n\t\t\t\t\tif( st.top() ) num *= c - '0';\n\t\t\t\t\telse num += c - '0';\n\t\t\t\t\tstN.push(num);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile( st.size() > 1 ){\n\t\t\t\tint num = stN.top();\n\t\t\t\tstN.pop();\n\t\t\t\tst.pop();\n\t\t\t\tif(st.top()) num *= stN.top();\n\t\t\t\telse num += stN.top();\n\t\t\t\tstN.pop();\n\t\t\t\tstN.push(num);\n\t\t\t}\n\n\t\t\tcout << stN.top() << endl;\n\t\t}\t\n\n\n\n\n\n\n\n\t}\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \";\n        a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\nint eval(const vector<string>& s, int &i, int depth) {\n    int ret;\n    if (s[i][depth] == '*') {\n        ret = 1;\n        ++i;\n        while (i < s.size()) {\n            int valid = 1;\n            REP(j, depth+1) {\n                if (j >= s[i].size() or s[i][j] != '.') valid = 0;\n            }\n            if (!valid) break;\n            ret *= eval(s, i, depth + 1);\n        }\n        return ret;\n    }\n    else if (s[i][depth] == '+') {\n        ret = 0;\n        ++i;\n        while (i < s.size()) {\n            int valid = 1;\n            REP(j, depth+1) {\n                if (j >= s[i].size() or s[i][j] != '.') valid = 0;\n            }\n            if (!valid) break;\n            ret += eval(s, i, depth + 1);\n        }\n        return ret;\n    }\n    else {\n        ret = s[i][depth] - '0';\n        ++i;\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int n; cin >> n;\n        if (n == 0) break;\n\n        vector<string> S(n);\n        REP(i, n) cin >> S[i];\n\n        int i = 0;\n        int ans = eval(S, i, 0);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<int, lint> pil;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod*mod;\nconstexpr int MAX = 200010;\n\nint n;\nstring s[100];\n\nint expr(int &i){\n    char c = s[i][s[i].size()-1];\n    if(isdigit(c)){\n        ++i;\n        return c - '0';\n    }\n    else if(c == '+'){\n        int ret = 0, level = s[i].size();\n        ++i;\n        while(i < n && s[i].size() == level + 1){\n            ret += expr(i);\n        }\n        return ret;\n    }\n    else{\n        int ret = 1, level = s[i].size();\n        ++i;\n        while(i < n && s[i].size() == level + 1){\n            ret *= expr(i);\n        }\n        return ret;\n    }\n}\n\nint main(){\n    while(scanf(\"%d\", &n) && n){\n        rep(i, n) cin >> s[i];\n        int idx = 0;\n        printf(\"%d\\n\", expr(idx));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint big=2.19e17+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nbool solve(void){\n\tint n;cin>>n;\n\tif(n==0){return false;}\n\tvector<pair<char,llint>>sta;\n\tsta.pub(mp('+',0LL));\n\twhile(n--){\n\t\tstring s;cin>>s;\n\t\tint t=s.size()-1;\n\t\twhile(sta.size()>t+1){\n\t\t\tllint su=sta.back().sec;\n\t\t\tsta.pob();\n\t\t\tif(sta.back().fir=='+'){sta.back().sec+=su;}\n\t\t\telse{sta.back().sec*=su;}\n\t\t}\n\t\tif('0'<=s[t]&&s[t]<='9'){\n\t\t\tllint su=s[t]-'0';\n\t\t\tif(sta.back().fir=='+'){sta.back().sec+=su;}\n\t\t\telse{sta.back().sec*=su;}\n\t\t}else{\n\t\t\tif(s[t]=='+'){sta.pub(mp('+',0LL));}\n\t\t\telse{sta.pub(mp('*',1LL));}\n\t\t}\n\t}\n\twhile(sta.size()>1){\n\t\tllint su=sta.back().sec;\n\t\tsta.pob();\n\t\tif(sta.back().fir=='+'){sta.back().sec+=su;}\n\t\telse{sta.back().sec*=su;}\n\t}\n\tcout<<sta.back().sec<<endl;\n\treturn true;\n}\nint main(void){\n\twhile(solve()){}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nenum _operator{\n    _plus,\n    multiply,\n    none\n};\n\nint main() {\n\n    while(1){\n\n        int n;\n\n        cin >> n;\n\n        if(n==0) break;\n\n        string input[n];\n\n        vector<vector<int> > level_num;\n        vector<_operator> level_ope;\n\n        level_num.resize(9); //式が9個までだからと雑に初期化その1\n\n\n        for(int i=0; i<9; i++){\n            level_ope.push_back(none);\n        }\n\n\n        for(int i=0; i<n; i++){\n            cin >> input[i];\n            for(int j=0; j<input[i].size(); j++){\n                if(input[i][j] == '+'){\n                    level_ope[j] = _plus;\n                }\n                else if(input[i][j] == '*'){\n                    level_ope[j] = multiply;\n                }\n                else if(input[i][j] != '.'){\n                    stringstream ss;\n                    ss << input[i][j];\n                    int input_num;\n                    ss >> input_num;\n                    level_num[j].push_back(input_num);\n                }\n            }\n        }\n\n        int ans = 0;\n        int now_level = 8;\n\n        while(now_level){\n            if(level_ope[now_level-1] != none){\n                int sum;\n                if(level_ope[now_level-1] == _plus){\n                    sum = 0;\n                    for(int i=0; i<level_num[now_level].size(); i++){\n                        sum += level_num[now_level][i];\n                    }\n                }\n                else if(level_ope[now_level-1] == multiply){\n                    sum = 1;\n                    for(int i=0; i<level_num[now_level].size(); i++){\n                        sum *= level_num[now_level][i];\n                    }\n                }\n                if(now_level == 1) {\n                    ans = sum;\n                }\n                else{\n                    level_num[now_level-1].push_back(sum);\n                }\n            }\n            now_level--;\n        }\n\n        if(n == 1){\n            ans = level_num[0][0];\n        }\n\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int MUL = -202020;\nconstexpr int ADD = -292929;\nusing ex = pair<int, long>;\nconstexpr ex INVALID = ex(-1, -1);\n\nint isOperatorChar(char c) {\n  if (c == '+') return ADD;\n  if (c == '*') return MUL;\n  return 0;\n}\n\nbool isOperator(int o) {\n  return o == ADD || o == MUL;\n}\n\nbool isNumber(char c) {\n  return c >= '0' && c <= '9';\n}\n\nex getOrderExp(string s) {\n  int cnt = 0;\n  for (auto c: s) {\n    if (c == '.') cnt++;\n    else if (isOperatorChar(c)) {\n      return ex(cnt + 1, isOperatorChar(c));\n    } else {\n      return ex(cnt, c - '0');\n    };\n  }\n  return ex(-1, -1);\n}\n\nvoid debugExp(vector<ex> &v) {\n  for (auto &w: v) {\n    cerr << \"order: \" << w.first << \"\\t\" << w.second << endl;\n  }\n}\n\nint getLargestOrder(vector<ex> &v) {\n  int ret = 0;\n  for (auto &w: v) {\n    ret = max(ret, w.first);\n  }\n  return ret;\n}\n\nvoid solve(int n) {\n  vector<ex> v;\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    v.push_back(getOrderExp(s));\n  }\n\n  while (1) {\n    int order = getLargestOrder(v);\n    cerr << \"current order: \" << order << endl;\n    debugExp(v);\n    if (order == 0) break;\n    vector<ex> lower;\n    vector<ex> higher;\n    for (auto &w: v) {\n      if (w.first != order || isOperator(w.second)) {\n        if (higher.size()) {\n          if (higher.front().second == ADD) {\n            long ret = 0;\n            for (int i = 1; i < higher.size(); i++) {\n              ret += higher[i].second;\n            }\n            lower.push_back(ex(order - 1, ret));\n            cerr << \"reducing: ret=\" << ret << endl;\n          } else if (higher.front().second == MUL) {\n            long ret = 1;\n            for (int i = 1; i < higher.size(); i++) {\n              ret *= higher[i].second;\n            }\n            lower.push_back(ex(order - 1, ret));\n            cerr << \"reducing: ret=\" << ret << endl;\n          }\n          higher.clear();\n        }\n        if (w.first != order) {\n          lower.push_back(w);\n        } else {\n          higher.push_back(w);\n        }\n      } else {\n        higher.push_back(w);\n      }\n    }\n    if (higher.size()) {\n      if (higher.front().second == ADD) {\n        long ret = 0;\n        for (int i = 1; i < higher.size(); i++) {\n          ret += higher[i].second;\n        }\n        lower.push_back(ex(order - 1, ret));\n        cerr << \"reducing: ret=\" << ret << endl;\n      } else if (higher.front().second == MUL) {\n        long ret = 1;\n        for (int i = 1; i < higher.size(); i++) {\n          ret *= higher[i].second;\n        }\n        lower.push_back(ex(order - 1, ret));\n        cerr << \"reducing: ret=\" << ret << endl;\n      }\n    }\n    v = vector<ex>(lower);\n  }\n  cout << v.front().second << endl;\n}\n\nint main() {\n  long n;\n  while (1) {\n    cin >> n;\n    if (n) {\n      solve(n);\n    } else {\n      return 0;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\n#define pb push_back\n#define ll long long\nusing namespace std;\nvector<string> a;\nint n,l;\n\nint calc(int v){\n  char c=a[l][v];\n  char cc;\n  int r;\n  l++;v++;\n  //cout<<\":\"<<c<<endl;\n  if(l<n&&(a[l][v]=='+'||a[l][v]=='*')) r=calc(v);\n  else{\n    if(c=='*') r=1;\n    else if(c=='+') r=0;\n    else r=c-'0';\n  }\n  if(l>=n) return r;\n  if(c=='+'){\n    while(a[l].size()==v+1){\n      cc=a[l][v];\n      //cout<<cc<<endl;\n      if(l<n&&(cc=='+'||cc=='*')) r+=calc(v);\n      else {r+=cc-'0';l++;}\n      \n    }\n  }\n  else if(c=='*'){\n    while(a[l].size()==v+1){\n      cc=a[l][v];\n      if(l<n&&(cc=='+'||cc=='*')) r*=calc(v);\n      else {r*=cc-'0';l++;}\n      \n    }\n  }\n  //cout<<r<<endl;\n  return r;\n}\n\nint main(){\n  int i;\n  while(cin >> n,n){\n    string s;\n    a.clear();\n    for(i=0;i<n;i++){\n      cin >> s;\n      a.pb(s);\n    }\n    l=0;\n    cout << calc(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1 ; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1 ; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst ll INF = 1e9+100;\nconst bool debug = 0;\n/***************************************/\n\nint N;\nint level[30];\nint num[30]; // 0~9, 10:+, 11:*\n\nll solve(int p, int ope) { // 0:+, 1:*\t\n\tvector<ll> v;\n\tFOR(i, p, N) {\n\t\tif (level[p] > level[i]) break;\n\t\tif (level[i] == level[p]) {\n\t\t\tif (num[i] >= 10) v.push_back(solve(i + 1, num[i] == 11));\n\t\t\telse v.push_back(num[i]);\n\t\t}\n\t}\n\t\n\tll res = ope == 1;\n\tREP(i, v.size()) {\n\t\tif (ope) res *= v[i];\n\t\telse res += v[i];\n\t}\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> N, N) {\n\t\tREP(i, N) {\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tlevel[i] = str.size() - 1;\n\t\t\tif (str.back() == '+') num[i] = 10;\n\t\t\telse if (str.back() == '*') num[i] = 11;\n\t\t\telse num[i] = str.back() - '0';\n\t\t}\n\t\tif (debug) printf(\"@ \");\n\t\tcout << solve(0, 0) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<sstream>\nusing namespace std;\ntypedef long long ll;\nstring i2s(ll x){\n  if(x==0) return \"0\";\n  string y;\n  ll k=1;\n  while(x>=k) k*=10;\n  k/=10;\n  for(ll i=k;i>0;i/=10){\n    y+=(x/i)%10+'0';\n  }\n  return y;\n}\nll s2i(string x){\n  for(ll i=0;i<x.size();i++) if(x[i]=='.') x[i]=' ';\n  stringstream ss(x);\n  ll y;\n  ss >> y;\n  return y;\n}\nint main(){\n  //cout << i2s(100) << endl;\n  ll n;\n\n  while(cin>>n,n){\n    string buf;\n    vector<string> v;\n    vector<ll> d;\n    ll i,j,k;\n    for(i=0;i<n;i++){\n      cin >> buf;\n      j=0;\n      while(buf[j]=='.') j++;\n      v.push_back(buf);\n      d.push_back(j);\n    }\n    while(v.size()!=1){\n      //for(i=0;i<v.size();i++) cout << v[i] << endl;\n      //cout << endl;\n      //cout << v.size() << endl;\n      k=1;\n      for(i=0;i<v.size();i++){\n        if(d[k]<d[i]) k=i;\n      }\n      //cout << k << \":\" << v[k-1][v[k-1].size()-1] << endl;\n      if(v[k-1][v[k-1].size()-1]=='+'){\n        i=0;j=0;\n        while(1) {\n          if(d[k]!=d[k+i]) break;\n          //j*=(v[k+i][v[k+i].size()-1]-'0');\n          j+=s2i(v[k+i]);\n          i++;\n          if(k+i==d.size()) break;\n        }\n        //cout << i << \":\" << j << endl;\n        v[k-1]=v[k-1].substr(0,v[k-1].size()-1);\n        v[k-1]+=i2s(j);\n        v.erase(v.begin()+k,v.begin()+k+i);\n        d.erase(d.begin()+k,d.begin()+k+i);\n      }\n      if(v[k-1][v[k-1].size()-1]=='*'){\n        i=0;j=1;\n        while(1) {\n          if(d[k]!=d[k+i]) break;\n          //j*=(v[k+i][v[k+i].size()-1]-'0');\n          j*=s2i(v[k+i]);\n          i++;\n          if(k+i==d.size()) break;\n        }\n        //cout << i << endl;\n        v[k-1]=v[k-1].substr(0,v[k-1].size()-1);\n        v[k-1]+=i2s(j);\n        v.erase(v.begin()+k,v.begin()+k+i);\n        d.erase(d.begin()+k,d.begin()+k+i);\n      }\n      \n    }\n    cout << v[0] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define llong long long\n\nusing namespace std;\nusing strs = vector<string>;\nint mlt(int &idx, int d);\nint add(int &idx, int d);\nint inum(int &idx, int d);\nstrs str;\n\nint mlt(int &idx, int d){\n\tint ret = 1;\n\tfor(; idx < str.size() && d < str[idx].size(); idx++){\n\t\tif(str[idx][d] == '*'){\n\t\t\tret *= mlt(++idx, d+1);\n\t\t\t--idx;\n\t\t}\n\t\telse if(str[idx][d] == '+'){\n\t\t\tret *= add(++idx, d+1);\n\t\t\t--idx;\n\t\t}\n\t\telse if(isdigit(str[idx][d])){\n\t\t\tret *= inum(idx, d);\n\t\t}\n\t\telse{\n\t\t\tcout << idx << \":\" << d << endl;\n\t\t\tassert(0);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint add(int &idx, int d){\n\tint ret = 0;\n\tfor(; idx < str.size() && d < str[idx].size(); idx++){\n//\t\tcerr << idx << \":\" << str[idx][d] << \" \";\n\t\tif(str[idx][d] == '*'){\n\t\t\tret += mlt(++idx, d+1);\n\t\t\t--idx;\n\t\t}\n\t\telse if(str[idx][d] == '+'){\n\t\t\tret += add(++idx, d+1);\n\t\t\t--idx;\n\t\t}\n\t\telse if(isdigit(str[idx][d])){\n\t\t\tret += inum(idx, d);\n\t\t}\n\t\telse{\n\t\t\tcout << idx << \":\" << d << endl;\n\t\t\tassert(0);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint inum(int &idx, int d){\n//\tcerr << idx << \":\" << d << endl;\n//\tcerr << str[idx].substr(d) << endl;\n\treturn stoi(str[idx].substr(d));\n}\n\nsigned main(){\n\twhile(true){\n\t\tint n; cin >> n;\n\t\tif(n == 0)break;\n\t\tstr = strs(n);\n\t\tfor(auto &e : str)cin >> e;\n\t\tint idx = 0;\n\t\tcout << add(idx, 0) << endl;\n//\t\tcerr << \"\\n\\n\" << endl;\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdlib>\n#include<stdio.h>\n#include<time.h>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<map>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF 1000000000\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint qx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nint qy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n\nvector<string> s;\nll pos = 0;\n\nll cal(int n, int t) {\n\tll res = 0;\n\tswitch(t) {\n\t\tcase 0:\n\t\t{\n\t\t\twhile(pos < s.size()) {\n\t\t\t\tll cnt = 0;\n\t\t\t\tREP(i, s[pos].size()) {\n\t\t\t\t\tif(s[pos][i] == '.') ++cnt;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tif(cnt == n) {\n\t\t\t\t\tif(s[pos][n] == '+') {\n\t\t\t\t\t\t++pos;\n\t\t\t\t\t\tres += cal(n + 1, 0);\n\t\t\t\t\t} else if(s[pos][n] == '*') {\n\t\t\t\t\t\t++pos;\n\t\t\t\t\t\tres += cal(n + 1, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres += stoi(s[pos].substr(n, s[pos].size() - n));\n\t\t\t\t\t\t++pos;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t{\n\t\t\t++res;\n\t\t\twhile(pos < s.size()) {\n\t\t\t\tll cnt = 0;\n\t\t\t\tREP(i, s[pos].size()) {\n\t\t\t\t\tif(s[pos][i] == '.') ++cnt;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tif(cnt == n) {\n\t\t\t\t\tif(s[pos][n] == '+') {\n\t\t\t\t\t\t++pos;\n\t\t\t\t\t\tres *= cal(n + 1, 0);\n\t\t\t\t\t} else if(s[pos][n] == '*') {\n\t\t\t\t\t\t++pos;\n\t\t\t\t\t\tres *= cal(n + 1, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres *= stoi(s[pos].substr(n, s[pos].size() - n));\n\t\t\t\t\t\t++pos;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n\treturn res;\n}\n\nint main(void) {\n\twhile(true) {\n\t\tpos = 0;\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\ts.resize(n);\n\t\tREP(i, n) cin>>s[i];\n\t\tif(n == 1) {\n\t\t\tcout<<s[0]<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif(s[0] == \"+\") {\n\t\t\t++pos;\n\t\t\tcout<<cal(1, 0)<<endl;;\n\t\t}\n\t\tif(s[0] == \"*\") {\n\t\t\t++pos;\n\t\t\tcout<<cal(1, 1)<<endl;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint N;\nstring S[100];\n \nint rec(int& idx, int depth)\n{\n  if(isdigit(S[idx][depth])) {\n    return(S[idx++][depth] - '0');\n  } else if(S[idx++][depth] == '+') {\n    int ret = 0;\n    while(S[idx].size() > depth + 1) ret += rec(idx, depth + 1);\n    return(ret);\n  } else {\n    int ret = 1;\n    while(S[idx].size() > depth + 1) ret *= rec(idx, depth + 1);\n    return(ret);\n  }\n}\n \nint main()\n{\n  while(cin >> N, N) {\n    for(int i = 0; i < N; i++) cin >> S[i];\n    S[N] = \"\";\n    int idx = 0;\n    cout << rec(idx, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\nstruct CLASSNUM{\n  char op;\n  vector<int> num;\n};\n\nint main(){\n  int n,j,sum;\n  string str;\n  CLASSNUM classNum[9];\n  while(true){\n    cin >> n;\n    if(n == 0) break;\n    for(int i = 0; i < n; i++){\n      cin >> str;\n\n      j = 0;\n      while(str[j] == '.'){\n        j++;\n      }\n\n      if(j!=0) str = str.substr(j,1);\n\n      if(str == \"+\") classNum[j].op = '+';\n      else if(str == \"*\")classNum[j].op = '*';\n      else{\n        classNum[j].num.push_back(atoi(str.c_str()));\n      }\n    }\n    for(int i=8; i >= 1; i--){\n      if(classNum[i].num.size() == 0) continue;\n      else{\n        if(classNum[i].num.size() >= 1 && classNum[i-1].op == '+') {\n          sum = 0;\n          for(int k = 0; k < classNum[i].num.size(); k++){\n            sum += classNum[i].num[k];\n          }\n          classNum[i-1].num.push_back(sum);\n        }\n        else if(classNum[i].num.size() >= 1 && classNum[i-1].op == '*') {\n          sum = 1;\n          for(int k = 0; k < classNum[i].num.size(); k++){\n            sum *= classNum[i].num[k];\n          }\n          classNum[i-1].num.push_back(sum);\n        }\n      }\n    }\n    cout << classNum[0].num[0] << endl;\n    for(int i = 0; i < 8; i++) classNum[i].num.clear();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\nstruct P{\n\tint num, lev;\n};\n\nint n;\nstring s[30];\n\nint main() {\n\n\twhile (true) {\n\n\t\tcin >> n;\n\t\tif (!n)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> s[i];\n\t\t}\n\n\t\tstack<char> ch;\n\t\tstack<P> num;\n\t\tfor (int i = 0; i <= n; i++) {\n\n\t\t\t//cout << \"i:\" << i << endl;\n\t\t\tif (n == i && ch.size() == 0)break;\n\n\t\t\tif (ch.size() >= s[i].size() || n == i) {//レベルが低かったら\n\t\t\t\t//cout << \"a\" << endl;\n\t\t\t\tint x;\n\n\t\t\t\tchar ope = ch.top();\n\t\t\t\tif (ope == '+')x = 0;\n\t\t\t\telse x = 1;\n\n\t\t\t\twhile (!num.empty()) {\n\t\t\t\t\tP p = num.top();\n\t\t\t\t\tif (p.lev < ch.size())break;\n\t\t\t\t\tnum.pop();\n\n\t\t\t\t\tif (ope == '+') {\n\t\t\t\t\t\tx += p.num;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tx *= p.num;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tch.pop();\n\t\t\t\tnum.push(P{ x, (int)ch.size() });\n\t\t\t\ti--;\n\t\t\t\t//cout << \"  x:\" << x << endl;\n\t\t\t}\n\t\t\telse {//同じか高い場合\n\t\t\t\t//cout << \"b\" << endl;\n\t\t\t\tif (s[i][s[i].size() - 1] == '+' || s[i][s[i].size() - 1] == '*') {//演算子の場合\n\t\t\t\t\tch.push(s[i][s[i].size() - 1]);\n\t\t\t\t}\n\t\t\t\telse {//数値の場合\n\t\t\t\t\tnum.push(P{ (int)(s[i][s[i].size() - 1] - '0'), (int)ch.size() });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << num.top().num << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define LAST(vec) vec[vec.size() - 1]\nstring get_line() {\n  string line;\n  cin >> line;\n  return line;\n}\n// 整数: 一桁\nint main() {\n  while (true) {\n    auto line_num = stoi(get_line());\n    if (line_num == 0) return 0;\n    if (line_num == 1) {\n      cout << stoi(get_line()) << endl;\n      continue;\n    }\n    vector<int> stack;\n    vector<bool> is_adds;\n    auto calc = [&](int num) {\n      if (LAST(is_adds)) {\n        LAST(stack) += num;\n      } else {\n        LAST(stack) *= num;\n      }\n    };\n    auto reduction = [&](int n) {\n      REP(j, n) {\n        auto num = LAST(stack);\n        is_adds.pop_back();\n        stack.pop_back();\n        calc(num);\n      }\n    };\n\n    REP(i, line_num) {\n      auto line = get_line();\n      auto level = line.size() - 1;\n      // リダクション\n      if (level < stack.size()) {\n        auto n = stack.size() - level;\n        reduction(n);\n      }\n      // パース\n      auto chr = line[line.size() - 1];\n      if (chr == '+') {\n        stack.push_back(0);\n        is_adds.push_back(true);\n      } else if (chr == '*') {\n        stack.push_back(1);\n        is_adds.push_back(false);\n      } else {\n        calc(chr - '0');\n      }\n    }\n    if (stack.size() > 1) {\n      reduction(stack.size() - 1);\n    }\n    cout << LAST(stack) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<complex>\n#include<string>\n#include<cstring>\n\nusing namespace std;\n#define rep2(x,from,to) for(int x=(from);(x)<(to);(x)++)\n#define rep(x,to) rep2(x,0,to)\n#define INF 100000000\n#define all(x) x.begin(),x.end()\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nint now;\nint owari;\nint nowb;\nstring s;\nvector<string> array;\nvector<int> bo;\nvector<int> num;\nint flag[100000];//0???????????? 1?¶???? 2?????????\nint atai[100000];\nint n;\nint main()\n{\n\twhile(1)\n\t{\n\t\trep(i,100000)\n\t\t{\n\t\t\tflag[i]=0;\n\t\t\tatai[i]=0;\n\t\t\tnow=0;\n\t\t\tnowb=0;\n\t\t\towari=0;\n\t\t}\n\t\tnum.clear();\n\t\tbo.clear();\n\t\tarray.clear();\n\t\tnow=0;\n\t\tcin>>n;\n\t\trep(i,n)\n\t\t{\n\t\t\tcin>>s;\n\t\t\tarray.push_back(s);\n\t\t}\n\t\tif(n==0)break;\n\t\tif(n==1)\n\t\t{\n\t\t\tcout<<array[0]<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,n)\n\t\t{\n\t\t\tbo.push_back(array[i].size()-1);\n\t\t\tif('0'<=array[i][bo[i]]&&array[i][bo[i]]<='9')\n\t\t\t{\n\t\t\t\tnum.push_back((int)(array[i][bo[i]]-'0'));\n\t\t\t}\n\t\t\telse if(array[i][bo[i]]=='+')\n\t\t\t{\n\t\t\t\tnum.push_back(-1);\n\t\t\t}\n\t\t\telse if(array[i][bo[i]]=='*')\n\t\t\t{\n\t\t\t\tnum.push_back(-2);\n\t\t\t}\n\t\t}\n\t\tnow=0;\n\t\twhile(1)\n\t\t{\n\t\t\tif(now==n)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(num[now]==-1)\n\t\t\t{\n\t\t\t\tflag[bo[now]]=-1;\n\t\t\t}\n\t\t\telse if(num[now]==-2)\n\t\t\t{\n\t\t\t\tflag[bo[now]]=-2;\n\t\t\t\tatai[bo[now]+1]=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(flag[bo[now]-1]==-1)\n\t\t\t\t{\n\t\t\t\t\tatai[bo[now]]+=num[now];\n\t\t\t\t}\n\t\t\t\telse if(flag[bo[now]-1]==-2)\n\t\t\t\t{\n\t\t\t\t\tatai[bo[now]]*=num[now];\n\t\t\t\t}\n\t\t\t\telse cout<<\"error\"<<endl;\n\t\t\t\tif(now==n-1||(now!=n-1&&bo[now]>bo[now+1]))\n\t\t\t\t{\n\t\t\t\t\tif(now==n-1)\n\t\t\t\t\t{\n\t\t\t\t\t\towari=1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\towari=bo[now+1];\n\t\t\t\t\t}\n\t\t\t\t\tnowb=bo[now];\n\t\t\t\t\twhile(1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(nowb==owari)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(flag[nowb-2]==-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tatai[nowb-1]+=atai[nowb];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(flag[nowb-2]==-2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tatai[nowb-1]*=atai[nowb];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse cout<<\"error1\"<<endl;\n\t\t\t\t\t\tatai[nowb]=0;\n\t\t\t\t\t\tflag[nowb]=0;\n\t\t\t\t\t\tnowb--;\n\t\t\t\t\t\tif(nowb==owari)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tnow++;\n\t\t}\n\t\tcout<<atai[1]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nstring s[20];\n\nll calc(int p, int q) {\n  bool add = false;\n  if ('0' <= s[p][s[p].length() - 1] && s[p][s[p].length() - 1] <= '9') {\n    return s[p][s[p].length() - 1] - '0';\n  } else if (s[p][s[p].length() - 1] == '+') {\n    add = true;\n  }\n\n  ll ans = ((add) ? 0 : 1);\n  repl(i, p + 1, q) {\n    if ('0' <= s[i][s[i].length() - 1] && s[i][s[i].length() - 1] <= '9') {\n      if (add) ans += (s[i][s[i].length() - 1] - '0');\n      else ans *= (s[i][s[i].length() - 1] - '0');\n    } else {\n      int j = i++;\n      while(i < q && s[j].length() < s[i].length()) i++;\n      if (add) ans += calc(j, i);\n      else ans *= calc(j, i);\n      i--;\n    }\n  }\n\n  return ans;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n;\n\n  while(cin >> n, n) {\n    rep(i, n) cin >> s[i];\n    print(calc(0, n));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nvector<string> form;\n\nint dfs(int line,int level){\n  if(isdigit(form[line][level]))return (int)form[line][level]-'0';\n  char op=form[line][level];\n  int res=(op=='*'?1:0);\n  repl(i,line+1,n){\n    if(form[i][level]!='.')break;\n    if(form[i][level+1]=='.')continue;\n    int tmp=dfs(i,level+1);\n    res=(op=='*'?res*tmp:res+tmp);\n  }\n  return res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    form.clear();\n    rep(i,n){\n      string s;\n      cin>>s;\n      form.pb(s);\n    }\n    cout<<dfs(0,0)<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\nint n, c;\nstring s[1000];\nint d[1000];\n\nint f(int depth) {\n\tif(isdigit(s[c][0])) {\n\t\tint ret = s[c][0] - '0';\n\t\tc++;\n\t\treturn ret;\n\t}\n\n\tif(s[c] == \"+\") {\n\t\tc++;\n\t\tint ret = 0;\n\t\twhile(c < n && d[c] == depth + 1) ret += f(depth + 1);\n\t\treturn ret;\n\t}\n\telse {\n\t\tc++;\n\t\tint ret = 1;\n\t\twhile(c < n && d[c] == depth + 1) ret *= f(depth + 1);\n\t\treturn ret;\n\t}\n\tassert(false);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n, n) {\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> s[i];\n\t\t\td[i] = count(s[i].begin(), s[i].end(), '.');\n\t\t\tint len = s[i].size();\n\t\t\ts[i] = s[i].substr(d[i], len - d[i]);\n\t\t}\n\t\tc = 0;\n\t\tcout << f(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<string> S;\nint cur;\n\nint dfs(int depth){\n    char c = S[cur][depth];\n    if(isdigit(c)){\n        cur++;\n        return c - '0';\n    }\n    if(c == '+'){\n        int s = 0;\n        cur++;\n        while(cur < N && S[cur][depth] == '.'){\n            s += dfs(depth+1);\n        }\n        return s;\n    }\n    if(c == '*'){\n        int p = 1;\n        cur++;\n        while(cur < N && S[cur][depth] == '.'){\n            p *= dfs(depth+1);\n        }\n        return p;\n    }\n    \n    return -1;\n}\n\nint main(){\n    while(cin >> N, N){\n        S.resize(N);\n        for(auto &s: S)\n            cin >> s;\n        \n        cur = 0;\n        cout << dfs(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <vector>\n#include <map>\n#include <stack>\n#include <bitset>\nusing namespace std;\n\nvector <string> form;\nint p;\nint Calculate(int nest){\n\tchar op;\n\tint result;\n\tif (form[p][nest] == '+'){ result = 0; op = '+'; }\n\telse if (form[p][nest] == '*'){ result = 1; op = '*'; }\n\telse result = form[p][nest] - '0';\n\tp++;\n\twhile (1){\n\t\tif (p >= form.size()) break;\n\t\tif (nest >= form[p].size()) break;\n\t\tif (form[p][nest] != '.') break;\n\t\tif ('0' <= form[p][nest + 1] && form[p][nest + 1] <= '9'){\n\t\t\tif (op == '+') result += form[p][nest + 1] - '0';\n\t\t\tif (op == '*') result *= form[p][nest + 1] - '0';\n\t\t\tp++;\n\t\t}\n\t\telse{\n\t\t\tif (op == '+') result += Calculate(nest + 1);\n\t\t\tif (op == '*') result *= Calculate(nest + 1);\n\t\t}\n\t}\n\treturn result;\n}\nint main(){\n\tint i, n;\n\twhile (1){\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tform.clear();\n\t\tfor (i = 0; i < n; i++){\n\t\t\tstring temp;\n\t\t\tcin >> temp;\n\t\t\tform.push_back(temp);\n\t\t}\n\t\tp = 0;\n\t\tcout << Calculate(0) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <stack>\nusing namespace std;\nusing ll = long long;\n\nstruct dat{\n    char op;\n    ll val;\n    dat(ll op_,ll val_){\n        op=op_;\n        val=val_;\n    }\n};\n\nvoid push_op(stack<dat>&st,char op){\n    if (op=='+') st.push(dat('+',0));\n    if (op=='*') st.push(dat('*',1));\n}\n\nvoid cal_st(stack<dat>& st,ll val){\n    dat d=st.top();\n    st.pop();\n    if (d.op=='+') d.val+=val;\n    if (d.op=='*') d.val*=val;\n    st.push(d);\n}\n\nvoid del_st(stack<dat>& st){\n    dat d=st.top();\n    st.pop();\n    cal_st(st,d.val);\n}\n\nint main(){\n    bool noend=true;\n    while (noend){\n        ll n;\n        cin >> n;\n        if (n==0){\n            noend=false;\n            continue;\n        }\n        stack<dat> st;\n        string s;\n        ll g_lev=0;\n        push_op(st,'+');\n        for (ll i=0;i<n;i++){\n            cin >> s;\n            ll lev = 0;\n            ll val = 0;\n            for (ll i=0;i<s.size();i++){\n                val*=10;\n                if (s[i]=='.') lev++;\n                else if(s[i]>='0'&& s[i]<='9') val+=s[i]-'0';\n            }\n            while (g_lev>lev){\n                g_lev--;\n                del_st(st);\n            }\n            if(s[lev]=='+'){\n                g_lev++;\n                push_op(st,'+');\n            }\n            else if(s[lev]=='*'){\n                g_lev++;\n                push_op(st,'*');\n            }\n            else {\n                cal_st(st,val);\n            }\n        }\n        while (g_lev>0){\n            g_lev--;\n            del_st(st);\n        }\n        cout << st.top().val << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n;\n    while (cin >> n, n) {\n        vector<string> s(n); cin >> s;\n        using Fop = function<ll(ll,ll)>;\n        using Line = pair<ll, string>;\n        vector<Line> v;\n        each(str, s) {\n            ll pos = 0;\n            while (str[pos] == '.') ++pos;\n            v.pb({pos, str.substr(pos)});\n        }\n        Fop plus = [](ll a, ll b) { return a + b; };\n        Fop mult = [](ll a, ll b) { return a * b; };\n        function<ll(ll&, Fop, ll)> dfs = [&](ll& pos, Fop merge, ll init) {\n            ll res = init;\n            ll nest = v[pos].first;\n            while (pos < n && v[pos].first == nest) {\n                if (v[pos].second == \"*\") {\n                    ++pos;\n                    res = merge(res, dfs(pos, mult, 1));\n                }\n                else if (v[pos].second == \"+\") {\n                    ++pos;\n                    res = merge(res, dfs(pos, plus, 0));\n                }\n                else {\n                    res = merge(res, stoll(v[pos].second));\n                    ++pos;\n                }\n            }\n            return res;\n        };\n        ll pos = 0;\n        cout << dfs(pos, plus, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vii;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip> vip;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 :1e9;\nvs in;\nint t,n;\nint f(int a){\n\tint s=0;\n\tchar c=in[t][a];\n\tif(isdigit(c)){\n\t\tt++;\n\t\treturn c-'0';\n\t}\n\tif(c=='*')s=1;\n\tt++;\n\twhile(t<n&&a+1<in[t].size()){\n\t\tif(c=='+')s+=f(a+1);\n\t\telse if(c=='*')s*=f(a+1);\n//\t\tcout<<t<<\" \"<<s<<\" \"<<a<<\" \"<<in[t].size()<<\" \"<<c<<endl;\n\t}\n//\tcout<<t<<\" \"<<s<<endl;\n\treturn s;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tin=vs(n);\n\t\trep(i,n)cin>>in[i];\n\t\tcout<<f(t=0)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nint add(vector<string>::iterator &itr);\nint mlt(vector<string>::iterator &itr);\n\nint main(){\n    while(true){\n        int n; cin >> n;\n        if( n == 0)break;\n        vector<string> s(n);\n        for(int i = 0; i < n; i++){\n            cin >> s[i];\n        }\n        int ans = 0;\n        for(auto itr = s.begin(); itr != s.end(); ++itr){\n            if((itr->back()) == '+'){\n                ans += add(itr);\n            }\n            else if((itr->back()) == '*'){\n                ans += mlt(itr);\n            }\n            else{\n                ans += itr->back() - '0';\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\nint add(vector<string>::iterator &itr){\n    int c = itr->size()+1;\n    int ret = 0;\n    ++itr;\n    while((int)(itr->size()) == c){\n        if(itr->back() == '+'){\n            ret += add(itr);\n        }\n        else if((itr->back()) == '*'){\n            ret += mlt(itr);\n        }\n        else{\n            ret += itr->back() -'0';\n        }\n        ++itr;\n    }\n        \n    --itr;\n    return ret;\n}\n\nint mlt(vector<string>::iterator &itr){\n    int c = itr->size();\n    int ret = 1;\n    ++itr;\n    while((int)(itr->size()) == c+1){\n        if(itr->back() == '+'){\n            ret *= add(itr);\n        }\n        else if((char)(itr->back()) == '*'){\n            ret *= mlt(itr);\n        }\n        else{\n            ret *= itr->back() - '0';\n        }\n        ++itr;\n    }\n    --itr;\n    return ret;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint N;\n//n??????, dep:depth, o:operator< 0:= +, 1:= *>, str \"\nint calc(int& n,int dep, char o,vector<string>& str) {\n\tint ret;\n\tif (o == '+') ret = 0;\n\telse ret = 1;\n\t\n\tfor (;n < N;) {\n\t\tif (str[n].length() != dep + 1) { break; }\n\t\tif (str[n][dep] >= '0' && str[n][dep] <= '9') {\n\t\t\tif (o == '+') { ret += str[n][dep] - '0'; n++; }\n\t\t\telse { ret *= str[n][dep] - '0';n++; }\n\t\t}\n\t\telse {\n\t\t\tn++;\n\t\t\tif (o == '+') { ret += calc(n, dep + 1, str[n-1][dep], str); }\n\t\t\telse { ret *= calc(n, dep + 1, str[n - 1][dep], str); }\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (cin >> N, N) {\n\t\tvector<string> str(N);\n\t\tfor (int i = 0; i < N;i++)cin >> str[i];\n\t\tint n = 0;\n\t\tcout << calc(n, 0, '+', str) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100\nusing namespace std;\nstring s[N];\nint n,y;\n\nint dfs(int x){\n  int res;\n  if('0'<=s[y][x]&&s[y][x]<='9')\n    return s[y][x]-'0';\n  if(s[y][x]=='+'){\n    res=0;\n    while(x+2<=s[y+1].size())\n      y++,res+=dfs(x+1);\n  }\n  if(s[y][x]=='*'){\n    res=1;\n    while(x+2<=s[y+1].size())\n      y++,res*=dfs(x+1);\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<N;i++)s[i]=\"\";\n    for(int i=0;i<n;i++)\n      cin>>s[i];\n    y=0;\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconstexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1 << 28;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nint n;\nvector<string> vs;\nvector<string> vt;\nvector<int> cnt;\nint cur;\nll dfs() {\n\n\tif (vt[cur] == \"+\") {\n\t\tll res = 0;\n\t\tint tmp = cnt[cur];\n\t\tcur++;\n\t\twhile (cur < vt.size() && tmp + 1 == cnt[cur]) {\n\t\t\tres += dfs();\n\t\t\tcur++;\n\t\t}\n\t\tcur--;\n\t\treturn res;\n\t}\n\telse if (vt[cur] == \"*\") {\n\t\tll res = 1;\n\t\tint tmp = cnt[cur];\n\t\tcur++;\n\t\twhile (cur < vt.size() && tmp + 1 == cnt[cur]) {\n\t\t\tres *= dfs();\n\t\t\tcur++;\n\t\t}\n\t\tcur--;\n\t\treturn res;\n\t}\n\telse {\n\t\treturn stoll(vt[cur]);\n\t}\n}\nint main()\n{\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n\n\tint kkt = 89;\n\twhile (kkt) {\n\t\tcur = 0;\n\t\tscanf(\"%d\", &n); if (n == 0) break;\n\t\tvs.resize(n); for (int i = 0; i < n; i++) cin >> vs[i];\n\t\tvt.resize(n), cnt.resize(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint tmp = 0;\n\t\t\tstring t;\n\t\t\tfor (int j = 0; j < vs[i].size(); j++) {\n\t\t\t\tif (vs[i][j] == '.') tmp++;\n\t\t\t\telse t += vs[i][j];\n\t\t\t}\n\t\t\tvt[i] = t;\n\t\t\tcnt[i] = tmp;\n\t\t}\n\t\tcout << dfs() << \"\\n\";\n\t}\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nint dfs(const vector<string> &s, int i, int j) {\n    if (isdigit(s[i][j])) {\n        // cout << i << \" \" << j << \" \" << s[i][j] << endl;\n        return s[i][j] - '0';\n    }\n\n    int ret = (s[i][j] == '+' ? 0 : 1);\n    int nj = j + 1;\n    rep2(ni, i + 1, s.size()) {\n        if (nj >= s[ni].size()) break;\n        if (s[ni][nj] == '.') continue;\n        if (s[i][j] == '+') ret += dfs(s, ni, nj);\n        if (s[i][j] == '*') ret *= dfs(s, ni, nj);\n    }\n    // cout << i << \" \" << j << \" \" << ret << endl;\n    return ret;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        vector<string> s(n);\n        rep(i, n) cin >> s[i];\n        cout << dfs(s, 0, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nvoid solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        st.push(make_pair(th, l-1));\n    }\n}\nint main(){\n    while(cin>>n,n){\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    solve(level);\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        st.push(make_pair(0,0));\n        solve(0);\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n# ifdef _MSVC_LANG\n\n# define _SCL_SECURE_NO_WARNINGS\n# pragma warning( disable : 0325 ) // inline namespace Error\n\n# endif\n\n\n# include <iostream>\n# include <string>\n# include <iomanip>\n# include <cstdio>\n# include <array>\n# include <numeric>\n# include <algorithm>\n# include <vector>\n# include <functional>\n# include <fstream>\n# include <random>\n# include <bitset>\n# include <map>\n# include <unordered_set>\n\n\n// C++ 11 前提\n\nusing Ull = unsigned long long;\nusing Ll = long long;\n\ntemplate<typename T>\nusing Vec = std::vector<T>;\n\ntemplate<typename T, size_t L>\nusing Ary = std::array<T, L>;\n\nnamespace\n{\n\n    namespace meta\n    {\n        namespace coming\n        {\n            // c++ 17;\n            template<class... _Types>\n            using void_t = void;\n\n            template<class _Ty,\n                _Ty _Val>\n                struct integral_constant\n            {\t// convenient template for integral constant types\n                static constexpr _Ty value = _Val;\n\n                using value_type = _Ty;\n                using type = integral_constant;\n\n                constexpr operator value_type() const noexcept\n                {\t// return stored value\n                    return (value);\n                }\n\n                constexpr value_type operator()() const noexcept\n                {\t// return stored value\n                    return (value);\n                }\n            };\n\n            // c++ 17;\n            template<bool _Val>\n            using bool_constant = integral_constant<bool, _Val>;\n\n\n            // c++ 14\n            template<bool _Test,\n                class _Ty = void>\n                using enable_if_t = typename std::enable_if<_Test, _Ty>::type;\n        }\n\n        namespace core\n        {\n\n            template < class, class = void > struct enable_std_begin_end : std::false_type {};\n            template < typename T >\n            struct enable_std_begin_end<T,\n                coming::void_t<decltype(std::begin(std::declval<const T&>()), std::end(std::declval<const T&>()))>> : std::true_type {}; // c++ 17\n\n\n            template < class, class = void > struct enable_adl_begin_end : std::false_type {};\n            template < typename T >\n            struct enable_adl_begin_end<T,\n                coming::void_t<decltype(begin(std::declval<const T&>()), end(std::declval<const T&>()))>> : std::true_type {};\n        }\n\n        template < typename T >\n        struct is_range\n            : coming::bool_constant< core::enable_std_begin_end<T>::value || core::enable_adl_begin_end<T>::value>\n        {\n        };\n\n        /// <summary>\n        /// ある値が0以上か\n        /// </summary>\n        template<class T, T num, class = std::nullptr_t> struct is_positive\n            : coming::bool_constant<(num >= 0)>\n        {\n        };\n\n    }\n\n\n    inline namespace extension\n    {\n        inline namespace container_io\n        {\n            inline namespace in\n            {\n\n                /// <summary>\n                /// for cin with STL container\n                /// </summary>\n                template< template<class ...> class Container, class ... Args, typename = meta::coming::enable_if_t<!std::is_same< typename Container, typename std::basic_string> ::value> >\n                std::istream& operator >> (std::istream& is, Container<Args ...>& container)\n                {\n                    for (auto& elem : container) is >> elem; return is;\n                }\n\n                /// <summary>\n                /// for cin with std::arary\n                /// </summary>\n                template<class T, size_t L>\n                std::istream& operator >> (std::istream& is, std::array<T, L>& container)\n                {\n                    for (auto& elem : container) is >> elem; return is;\n                }\n\n                /// <summary>\n                /// for cin with raw array\n                /// </summary>\n                template<class T, size_t L>\n                std::istream& operator >> (std::istream& is, T(&ary)[L])\n                {\n                    for (int i{}; i < L; ++i) is >> ary[i]; return is;\n                }\n\n            }\n\n            inline namespace out\n            {\n                namespace settings\n                {\n                    /// <summary>\n                    /// 要素間の区切り文字\n                    /// </summary>\n                    const auto sepOfContainerElements{\" \"};\n                    /// <summary>\n                    /// コンテナ間の区切り文字\n                    /// </summary>\n                    const auto sepOfContainer{\"\\n\"};\n                }\n\n\n                /// <summary>\n                /// for cout Container with STL container\n                /// </summary>\n                template < template<class ...> class Container, class ... Args, typename = meta::coming::enable_if_t<!std::is_same< typename Container, typename std::basic_string> ::value> >\n                std::ostream& operator << (std::ostream& os, const Container<Args ...>& container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainerElements; return os;\n                }\n\n                /// <summary>\n                /// for cout Container with std::array\n                /// </summary>\n                template < class T, size_t L>\n                std::ostream& operator << (std::ostream& os, const std::array<T, L> container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainerElements; return os;\n                }\n\n                /// <summary>\n                /// for cout Container with raw array\n                /// </summary>\n                template < class T, size_t L, typename = meta::coming::enable_if_t<!std::is_same<T, char>::value> >\n                std::ostream& operator << (std::ostream& os, const T(&ary)[L])\n                {\n                    for (const auto& elem : ary) os << elem << settings::sepOfContainerElements; return os;\n                }\n\n\n\n                /// <summary>\n                /// for cout Container in Container with STL container\n                /// </summary>\n                template < template<class ...> class Container1, class ... Cont1Args,\n                    template<class ...> class Container2, class ... Cont2Args  >\n                std::ostream& operator << (std::ostream& os, const Container1< Container2<Cont2Args ...>, Cont1Args ...>& container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainer; return os;\n                }\n\n\n\n                /// <summary>\n                /// for cout Container in Container with std::array\n                /// </summary>\n                template < template<class ...> class Container, class ... Args, size_t L >\n                std::ostream& operator << (std::ostream& os, const std::array<Container<Args ...>, L>& container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainer; return os;\n                }\n                /// <summary>\n                /// for cout Container in Container with std::array\n                /// </summary>\n                template < template<class ...> class Container, class ... Args, size_t L, class T  >\n                std::ostream& operator << (std::ostream& os, const Container<std::array<T, L>, Args ...>& container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainer; return os;\n                }\n                /// <summary>\n                /// for cout Container in Container with std::array\n                /// </summary>\n                template < class T, size_t L1, size_t L2 >\n                std::ostream& operator << (std::ostream& os, const std::array<std::array<T, L2>, L1> container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainer; return os;\n                }\n\n\n                /// <summary>\n                /// for cout raw ary in raw ary\n                /// </summary>\n                template < class T, size_t L1, size_t L2 >\n                std::ostream& operator << (std::ostream& os, const T(&ary)[L1][L2])\n                {\n                    for (size_t i{}; i < L1; ++i) os << ary[i] << settings::sepOfContainer; return os;\n                }\n\n            }\n        }\n\n\n        template<typename T, size_t L, typename Function>\n        void for_each(T(&ary)[L], Function lambda)\n        {\n            for (size_t i{}; i < L; ++i)\n                lambda(static_cast<T&>(ary[i]));\n        }\n    }\n\n\n    inline namespace util\n    {\n\n        template<typename T>\n        void SetAll(T& container, typename T::value_type value = typename T::value_type{})\n        {\n            for (typename T::reference content : container) content = value;\n        }\n\n        template<typename T, size_t L>\n        void SetAll(T(&ary)[L], T value)\n        {\n            for (size_t i{}; i < L; ++i) ary[i] = value;\n        }\n\n        template<typename T, typename U, size_t L1, size_t L2>\n        void SetAll(T(&ary)[L1][L2], U value)\n        {\n            for (size_t i{}; i < L1; ++i) SetAll(ary[i], value);\n        }\n\n\n        inline namespace ranges\n        {\n\n            namespace core\n            {\n\n                using namespace meta;\n                /// <summary>\n                /// 再帰上限回数\n                /// </summary>\n                constexpr size_t recursion_limits{490};\n\n                /// <summary>\n                /// 値が割り切れるか\n                /// </summary>\n                template<int num, int divide> struct is_divisible\n                    : coming::bool_constant<num % divide == 0>\n                {\n                };\n\n                /// <summary>\n                /// 有限回数の再帰で終わるか\n                /// </summary>\n                template<int start, int end, int step> struct is_finite_recursion_depth\n                    : coming::bool_constant<(start < end) && (step > 0) || (end < start) && (step < 0)>{};\n\n                /// <summary>\n                /// 再帰回数が上限を超えないか\n                /// </summary>\n                template<int start, int end, int step> struct is_valid_recursion_depth\n                    : coming::bool_constant<(end - start) / step <= recursion_limits>\n                {\n                };\n\n                /// <summary>\n                /// 上記メタ関数の条件をすべて満たすか\n                /// </summary>\n                template<int start, int end, int step> struct is_valid_range\n                    : coming::bool_constant<(start == end) || is_finite_recursion_depth<start, end, step>::value && is_valid_recursion_depth<start, end, step>::value && is_divisible<end - start, step>::value>\n                {\n                };\n\n                /// <summary>\n                /// 再帰を続けるか\n                /// </summary>\n                template<int start, int end, int step> struct is_count_up_or_down\n                    : coming::bool_constant<is_valid_range<start, end, step>::value && end != start>\n                {\n                };\n\n                ///// <summary>\n                ///// 初期化子リストからstd::arrayをコンパイル時生成\n                ///// </summary>\n                //template<typename T, typename ...Args>\n                //constexpr std::array<T, sizeof...(Args)> make_array(Args&&... args)\n                //{\n                //    return std::array<T, sizeof...(Args)>{ static_cast<Args&&>(args)... };\n                //}\n\n\n                /// <summary>\n                /// 本体\n                /// </summary>\n\n                // エラー処理\n                template<int start, int end, int step, class = void, int ...Ary>\n                struct Range_Impl\n                {\n                    //static_assert(is_valid_range           <start, end, step>::value, \"[ ! ] invalid teplate argments [ ! ] 値正しくないっぽいヨ！\");\n                    static_assert(is_divisible             <end - start, step>::value, \"[ ! ] (end - start) is indivisible by step number [ ! ] 割り切れないヨ！stepの値確認して！\");\n                    static_assert(is_finite_recursion_depth<start, end, step>::value, \"[ ! ] goes to infinite loop [ ! ] 無限ループなっちゃうヨ！stepの符号逆じゃない？\");\n                    static_assert(is_valid_recursion_depth <start, end, step>::value, \"[ ! ] recursion depth is out of maximum limit [ ! ] 再帰回数が大きくなりすぎｨ壊れちゃううう\");\n                };\n                // 再帰\n                template<int start, int end, int step, int ... Ary>\n                struct Range_Impl<start, end, step, meta::coming::enable_if_t<is_count_up_or_down<start, end, step>::value>, Ary ... >\n                    : Range_Impl < start + step, end, step, void, Ary ..., start>\n                {\n                };\n                // 終端\n                template<int start, int end, int step, int ... Ary>\n                struct Range_Impl < start, end, step, meta::coming::enable_if_t<start == end>, Ary ...>\n                {\n                    //static constexpr auto value = make_array<int>(Ary ..., end);\n                    //static constexpr std::array<int, (sizeof... (Ary) + 1)> value = {Ary ..., end};\n                    static constexpr int value[(sizeof ... (Ary)+1)] = {Ary ..., end};\n                };\n\n\n            }\n\n\n            template<size_t size, bool isReverse = false>\n            struct Iterate\n            {\n                static constexpr auto in = isReverse ?\n                    core::Range_Impl<static_cast<int>(size - 1), 0, -1>::value :\n                    core::Range_Impl<0, static_cast<int>(size - 1), 1>::value;\n            };\n\n            template<unsigned int upTo>\n            struct CountUp\n            {\n                static constexpr auto to = core::Range_Impl<0, static_cast<int>(upTo), 1>::value;\n            };\n            template<unsigned int downFrom>\n            struct CountDown\n            {\n                static constexpr auto from = core::Range_Impl<static_cast<int>(downFrom), 0, -1>::value;\n            };\n\n\n            template<int start, int containedEnd, int step = 0, typename = void>\n            struct Range\n            {\n                static constexpr auto& in = core::Range_Impl<start, containedEnd, step>::value;\n            };\n            template<int start, int containedEnd>\n            struct Range <start, containedEnd, 0>\n            {\n                static constexpr auto& in = core::Range_Impl<start, containedEnd, meta::is_positive<int, containedEnd - start>::value ? 1 : -1>::value;\n            };\n\n        }\n    }\n\n\n    inline namespace alg\n    {\n        bool IsPrime(const Ull n)\n        {\n            switch (n)\n            {\n            case 0: case 1:\n                return false;\n            case 2:\n                return true;\n            default:\n\n                if (n % 2 == 0) return false;\n\n                for (Ull i{3}; i * i <= n; i += 2)\n                {\n                    if (n % i == 0) return false;\n                }\n            }\n\n            return true;\n        }\n\n        // 最大公約数\n        Ull EuclideanAlg(Ull n1, Ull n2)\n        {\n            //if (n1 < 0 || n2 < 0) return 0;\n            if (n2 > n1) std::swap(n1, n2);\n\n            Ull r;\n            while ((r = n1 % n2) != 0)\n            {\n                n1 = n2;\n                n2 = r;\n            }\n\n            return n2;\n        }\n\n        // 最小公倍数\n        Ull LCM(const std::vector<Ull>& values)\n        {\n            if (values.size() == 0)\n                return 0;\n            if (values.size() == 1)\n                return values[0];\n            if (values.size() == 2)\n                return values[0] * values[1] / EuclideanAlg(values[0], values[1]);\n\n            auto mid = values.cbegin() + values.size() / 2;\n\n            return LCM(std::vector<Ull>{LCM(std::vector<Ull>(values.begin(), mid)), LCM(std::vector<Ull>(mid, values.end()))});\n        }\n    }\n\n\n    void Solve();\n\n}\n\n# if false\nint main()\n{\n    Solve();\n    return 0;\n}\n# endif\n\nnamespace\n{\n    bool isShortPhrase(const std::string& phrases)\n    {\n        constexpr Ary<char, 5> eachLength = {5, 7, 5, 7, 7};\n        \n        int sum{}, current{};\n        for (int i = 0; i < phrases.size(); ++i)\n        {\n            sum += (int)phrases[i];\n            \n            if (sum == eachLength[current])\n            {\n                if (current == eachLength.size() - 1)\n                    return true;\n\n                ++current;\n                sum = 0;\n            }\n        }\n\n        return false;\n    }\n\n    void Solve()\n    {\n        std::ofstream ofs(\"output.txt\");\n        std::cout.rdbuf(ofs.rdbuf());\n\n\n        int length;\n        while (std::cin >> length, length != 0)\n        {\n            std::string phrases(40, '\\0');\n            for (int i{}; i < length; ++i)\n            {\n                std::string temp; std::cin >> temp;\n                phrases[i] = temp.length();\n            }\n\n            for (int i{}; i < length - 4; ++i)\n            {\n                if (isShortPhrase(phrases.substr(i, phrases.size() - i)))\n                {\n                    std::cout << i + 1<< std::endl;\n                    break;\n                }\n            }\n\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define  P pair<ll,ll>\n#define FOR(i,n,m) for(ll i=n; i<(ll)m;i++)\n#define FORr(i,n,m) for(ll i=n; i>=(ll)m; i--)\n#define FORm(i,m) for(auto i=m.begin();i!=m.end();i++)\n#define VEC2(x,a,b) vector<vector<ll>> x = vector<vector<ll>>(a,vector<ll>(b,0))\n#define sortAl(v) sort(v.begin(),v.end())\n#define sortAlr(v) sort(v.begin(),v.end()); reverse(v.begin(),v.end())\n#define cinv(v,n,m) FOR(i,n,m) cin>>v.at(i)\n#define coutv(v,n,m) FOR(i,n,m) cout<<v.at(i) <<\" \"; cout<<endl\n#define cout(n) cout<<fixed<<setprecision(n)\n\nvector<string> v(100);\n\nint s_size(string s){\n  ll res = 0;\n  FOR(i,0,s.size()){\n    if(s[i] == '.') res++;\n  }\n  return res;\n}\n\n\nP calf(ll pos, ll dpt, string c){\n  ll cur_pos = pos + 1;\n  ll cur_dpt = dpt + 1;\n  ll res = 0;\n  if(c == \"*\") res++;\n  if(c == \"+\" || c == \"*\"){\n    while (true) {\n\n      //cout<<\"cur_pos = \"<<cur_pos<<endl;\n      //cout<<res<<endl;\n      if(v[cur_pos] == \"\") break;\n      if(v[cur_pos].size()-1 != cur_dpt) break;\n      if(v[cur_pos][cur_dpt] == '+'){\n        P p = calf(cur_pos,cur_dpt,\"+\");\n        if(c == \"+\") res += p.first;\n        if(c == \"*\") res *= p.first;\n        cur_pos = p.second-1;\n      }\n      else if(v[cur_pos][cur_dpt] == '*'){\n        P p = calf(cur_pos,cur_dpt,\"*\");\n        if(c == \"+\") res += p.first;\n        if(c == \"*\") res *= p.first;\n        cur_pos = p.second-1;\n      }\n      else if(c == \"+\"){\n        res += v[cur_pos][cur_dpt] - '0';\n        //cout<<\"aa\"<<endl;\n      }\n      else{\n        res *= v[cur_pos][cur_dpt] - '0';\n        //cout<<\"bb\"<<endl;\n      }\n      cur_pos++;\n    }\n    return P(res, cur_pos);\n\n  }\n  return P(stoi(c), 0);\n\n}\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n = 0;\n    cin>>n;\n    while(n!=0){\n      vector<string> ini(100);\n      v = ini;\n\n      cinv(v,0,n);\n      cout<<calf(0,0,v[0]).first<<endl;\n      cin>>n;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nint n;\nchar s[10000];\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    if (n == 1) {\n      scanf(\"%s\", s);\n      printf(\"%d\\n\", (int)s[0] - '0');\n      continue;\n    }\n    int command[1000], stack[1000], stackNum = 0; // command == 1 : add\n    for (int i = 0; i < n; i++) {\n      scanf(\"%s\", s);\n      int counter = 0;\n      while (s[counter] == '.') counter++;\n      char input = s[counter];\n      if (counter < stackNum) {\n        while (stackNum > counter) {\n          stackNum--;\n          if (command[stackNum] == 1) stack[stackNum] += stack[stackNum + 1];\n          else stack[stackNum] *= stack[stackNum + 1];\n        }\n      }\n      if (input == '*') {\n        command[++stackNum] = 2;\n        stack[stackNum] = 1;\n      } else if (input == '+') {\n        command[++stackNum] = 1;\n        stack[stackNum] = 0;\n      } else {\n        if (command[stackNum] == 1) stack[stackNum] += (int) input - '0';\n        else stack[stackNum] *= (int) input - '0';\n      }\n    }\n    while (stackNum > 0) {\n      stackNum--;\n      if (command[stackNum] == 1) stack[stackNum] += stack[stackNum + 1];\n      else stack[stackNum] *= stack[stackNum + 1];\n    }\n    printf(\"%d\\n\", stack[1]);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<climits>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nvoid solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        st.push(make_pair(th, l-1));\n    }\n}\nint main(){\n    int ca=0;\n    while(cin>>n,n){\n        while(ope.size())ope.pop();\n        while(st.size())st.pop();\n        if(ca++>100)return -1;\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    solve(level);\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        solve(0);\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint dfs(vector<string> &vs, int line, int depth=0) {\n    if((int)vs.size() <= line) return -1;\n    if((int)vs[line].size() <= depth) return -1;\n    char c = vs[line][depth];\n    if(isdigit(c)) return c - '0';\n    int ret = -2;\n    if(c == '+') {\n        int temp; ret = 0;\n        while((temp = dfs(vs, ++line, depth+1)) != -1) {\n            if(temp >= 0) ret += temp;\n        }\n    }\n    if(c == '*') {\n        int temp; ret = 1;\n        while((temp = dfs(vs, ++line, depth+1)) != -1) {\n            if(temp >= 0) ret *= temp;\n        }\n    }\n    // printf(\"line = %lld, value = %lld\\n\", line, ret);\n    return ret;\n}\n\nsigned main() {\n    int n;\n    while(cin >> n, n) {\n        vector<string> vs(n);\n        rep(i,0,n) cin >> vs[i];\n        int line = 0;\n        cout << dfs(vs, line) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s[100];\nint n,j;\nint dfs(int p){\n\n  int res=0,o=s[j].size();\n\n  if(isdigit(s[j][p]))return s[j][p]-'0';\n\n  if(s[j][p]=='+')\n    while(s[j+1].size()>o)j++,res+=dfs(p+1);\n\n  else{\n    res=1;\n    while(s[j+1].size()>o)j++,res*=dfs(p+1);\n  }\n\n  return res;\n}\nint main(){\n  while(cin>>n,n){\n\n    for(j=i=0;i<100;i++)s[i]=\"\";\n    for(i=0;i<n;i++)cin>>s[i];\n\n    cout<<dfs(0)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string.h>\n#include<stdio.h>\nusing namespace std;\nint suma(int d);\nint a;\nchar s[100000];\nint t(int d){\n  int ans=1;\n  cin>>s;\n  a--;\n  while(a>=0){\n    if(strlen(s)<d)\n      break;\n    if(s[d-1]=='*')\n      ans*=t(d+1);\n    else if(s[d-1]=='+')\n      ans*=suma(d+1);\n    else{\n      ans*=s[d-1]-'0';\n      if(a==0)\n        break;\n      cin>>s;\n      a--;\n    }\n  }\n  return ans;\n}\n\nint suma(int d){\n  int ans=0;\n  a--;\n  cin>>s;\n  while(a>=0){\n    if(strlen(s)<d)\n      break;\n    if(s[d-1]=='*')\n      ans+=t(d+1);\n    else if(s[d-1]=='+')\n      ans+=suma(d+1);\n    else{\n      if(strlen(s)!=d)\n        break;\n      ans+=s[d-1]-'0';\n      if(a==0)\n        break;\n      cin>>s;\n      a--;\n    }\n  }\n  return ans;\n}\n\nint main(){\n  int n;\n  while(1){\n    cin>>s;\n    if(strlen(s)==1&&s[0]=='0')\n      break;\n    n=strlen(s);\n    a=0;\n    for(int i=0;i<n;i++){\n      a*=10;\n      a+=s[i]-'0';\n    }\n    a--;\n    cin>>s;\n    if(s[0]=='+')\n      cout<<suma(2)<<endl;\n    else if(s[0]=='*')\n      cout<<t(2)<<endl;\n    else\n      cout<<s<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstdio>\nusing namespace std;\ntypedef vector<pair<int,string> > vpis;\nint parse(const vpis &v,int l,int r){\n\tif(v[l].second!=\"+\"&&v[l].second!=\"*\")return strtol(v[l].second.c_str(),NULL,10);\n\tint unit=v[l].second==\"+\"?0:1;\n\tfor(int i=l+1;i<r;){\n\t\tint j=i+1;\n\t\tif(v[i].second==\"+\"||v[i].second==\"*\"){\n\t\t\tfor(;v[j].first>v[i].first;j++);\n\t\t}\n\t\tint n=parse(v,i,j);\n\t\ti=j;\n\t\tif(v[l].second==\"+\")unit+=n;\n\t\telse unit*=n;\n\t}\n\treturn unit;\n}\nint main(){\n\tint N;\n\tstring s;\n\tfor(;cin>>N,N;){\n\t\tvpis v(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>s;\n\t\t\tint idx=0;\n\t\t\tfor(;s[idx]=='.';idx++);\n\t\t\tv[i]=make_pair(idx,s.substr(idx));\n\t\t}\n\t\tprintf(\"%d\\n\",parse(v,0,N));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\ntemplate<class T> void vin(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n}\n\nstring s[101];\nint j=0;\n\nint solve( int p) {\n    int res = 0, sz=s[j].size();\n    if (isdigit(s[j][p])) return s[j][p]-'0';\n    if (s[j][p] == '+') {\n        while (s[j+1].size() >sz) {\n            j++;\n            res += solve(p+1);\n        }\n    }\n    else {\n        res = 1;\n        while (s[j+1].size() > sz) {\n            j++;\n            res *= solve(p+1);\n        }\n    }\n    return res;\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        fill(s, s+n, \"\");\n        rep(i, n) cin >> s[i];\n        j=0;\n        cout << solve(0) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<string>\n#include<iomanip>\nusing namespace std;\n\nint main()\n{\n    int n, v[20][10];\n    string s;\n\n    while( cin >> n )\n    {\n        if( !n )\n            break;\n        \n        for( int i = 0; i < 20; i++ )\n            for( int j = 0; j < 10; j++ )\n                v[i][j] = -4;\n\n        for( int i = 0; i < n; i++ )\n        {\n            string s;\n            cin >> s;\n            for( int j = 0; j < s.size(); j++ )\n            {\n                switch(s[j])\n                {\n                    case '+' :\n                        v[i][j] = -1;\n                        break;\n                    case '*' :\n                        v[i][j] = -2;\n                        break;\n                    case '.' :\n                        v[i][j] = -3;\n                        break;\n                    default :\n                        v[i][j] = s[j] - '0';\n                        break;\n                }\n            }\n        }\n\n        int s = 0, t = 0, op = 0;\n        for( int j = 9; j > 0; j-- )\n        {\n            for( int i = 0; i < 20; i++ )\n            {\n                if( v[i][j-1] == -1 )\n                {\n                    op = -1;\n                    s = i; t = j - 1;\n                    v[i][j-1] = 0;\n                }\n                else if( v[i][j-1] == -2 )\n                {\n                    op = -2;\n                    s = i; t = j - 1;\n                    v[i][j-1] = 1;\n                }\n                if( 0 <= v[i][j] )\n                {\n                    if( op == -1 )\n                        v[s][t] += v[i][j];\n                    else\n                        v[s][t] *= v[i][j];\n                }\n            }\n        }\n        cout << v[0][0] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\n\nint main(){\n  int n;\n  while(1){\n    stack<int> statsmemo,pointmemo;\n    cin>>n;\n    if(n==0) break;\n    int now=1,stats=-1,point=0;\n    int count=0;\n    lp(z,n){\n      count=0;\n      char q;\n      while(1){\n\tcin>>q;\n\tcount++;\n\tif(q!='.') break;\n      }\n      if(count<now){\n\twhile(count!=now){\n\t  int statsed,pointed;\n\t  statsed=statsmemo.top();\n\t  pointed=pointmemo.top();\n\t  statsmemo.pop();\n\t  pointmemo.pop();\n\t  if(statsed==0){\n\t    point+=pointed;\n\t  }\n\t  if(statsed==1){\n\t    if(point==0){\n\t      point+=pointed;\n\t    }\n\t    else point*=pointed;\n\t  }\n\t  stats=statsed;\n\t  now--;\n\t}\n\tnow=count;\n      }\n      if(q=='+'){\n\tif(stats!=-1){\n\t  statsmemo.push(stats);\n\t  pointmemo.push(point);\n\t}\n\tstats=0;\n\tpoint=0;\n\tnow++;\n      }\n      if(q=='*'){\n\tif(stats!=-1){\n\t  statsmemo.push(stats);\n\t  pointmemo.push(point);\n\t}\n\tstats=1;\n\tpoint=0;\n\tnow++;\n      }\n      if('0'<=q && q<='9'){\n\tif(stats==0) point+=q-'0';\n\tif(stats==1){\n\t  if(point==0) point+=q-'0';\n\t  else point*=q-'0';\n\t}\n\tif(stats==-1) point+=q-'0';\n      }\n    }\n    while(count>2){\n      int statsed,pointed;\n      statsed=statsmemo.top();\n      pointed=pointmemo.top();\n      statsmemo.pop();\n      pointmemo.pop();\n      if(statsed==0){\n\tpoint+=pointed;\n      }\n      if(statsed==1){\n\tif(point==0){\n\t  point+=pointed;\n\t}\n\telse point*=pointed;\n      }\n      stats=statsed;\n      count--;\n    }\n    cout<<point<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//operand, level\nvector<pair<string, int> > v;\n\nint main(){\nwhile(1){//start\t\n\t\n\tint n;\n\tcin >> n;\n\tif(n == 0) break;\n\tint max_level = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tstring tmp;\n\t\tcin >> tmp;\n\t\t//count level and push\n\t\tint cnt = 0;\n\t\tfor(int j = 0; j < (int)tmp.size(); j++){\n\t\t\tif(tmp[j] == '.') cnt++;\n\t\t}\n\t\tv.push_back(make_pair(string() + tmp[(int)tmp.size() - 1], cnt));\n\t\tmax_level = max(max_level, cnt);\n\t}\n\n\n\treverse(v.begin(), v.end());\n\n\n\twhile(max_level > 0){\n\t\t//get head and tail, make que\n\t\t//for(int i = 0; i < (int)v.size(); i++) cout << v[i].first << \" \" << v[i].second << endl;\n\t\t//cout << \"max_level = \" << max_level << endl;\n\t\t//cout << \"vec_size = \" << v.size() << endl;\n\t\tint del_head = -1;\n\t\tint del_tail;\n\t\tint flag = 0;\n\t\tqueue<int> que;\n\t\tstring operand;\n\t\tfor(int i = 0; i < (int)v.size(); i++){\n\t\t\tif(del_head == -1 and v[i].second == max_level){\n\t\t\t\tdel_head = i;\n\t\t\t\tque.push(stoi(v[i].first));\n\t\t\t\t//cout << \"ok 1 = \" << i << endl;\n\t\t\t}\n\t\t\telse if(v[i].second == max_level){\n\t\t\t\tque.push(stoi(v[i].first));\n\t\t\t\tflag = 1;\n\t\t\t\t//cout << \"ok 2 = \" << i << endl;\n\t\t\t}\n\t\t\telse if(v[i].second == max_level - 1 and flag){\n\t\t\t\toperand = v[i].first;\n\t\t\t\tdel_tail = i; //modified\n\t\t\t\t//cout << \"ok 3 = \" << i << endl; \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t//cout << \"head = \" << del_head << endl;\n\t\t//cout << \"tail = \" << del_tail << endl;\n//NTpmDM02\n\t\t//cout << \"TEST !\" << endl;\n\t\tv.erase(v.begin() + del_head, v.begin() + del_tail);\n\t\t\n\t\t//cout << \"erased_size = \" << v.size() << endl;\n\n\t\t//make place_holder\n\t\tint place_holder;\n\t\tif(operand == \"+\") place_holder = 0;\n\t\telse if(operand == \"*\") place_holder = 1;\n\n\t\twhile(que.size()){\n\t\t\t//cout << \"que_size = \" << que.size() << endl;\n\t\t\tint x = que.front();\n\t\t\t//cout << \"x = \" << x << endl;\n\t\t\tque.pop();\n\t\t\tif(operand == \"+\") place_holder += x;\n\t\t\telse if(operand == \"*\") place_holder *= x;\n\t\t}\n\t\tv[del_head] = make_pair(to_string(place_holder), max_level - 1);\n\t\t//cout << place_holder << endl;\n\t\t//max_level--;\n\t\t//get max_level\n\t\tmax_level = 0;\n\t\tfor(int i = 0; i < (int)v.size(); i++) max_level = max(max_level, v[i].second);\n\t}\n\t\n\tcout << v[0].first << endl;\n\tv.clear();\n}//end\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, p;\nvector<string> s;\n\nint calc(char c, int dep) {\n  int res = (c == '*');\n  while (++p < n) {\n    auto f = [&](char c, int acc) { return (c == '*') ? res * acc : res + acc; };\n    if (s[p].length() != dep + 1) return res;\n    if (s[p][dep] == '*') {\n      res = f(c, calc('*', dep + 1));\n    } else if (s[p][dep] == '+') {\n      res = f(c, calc('+', dep + 1));\n    }\n    if ('0' <= s[p][dep] && s[p][dep] <= '9') {\n      res = f(c, s[p][dep] - '0');\n    }\n  }\n  return res;\n}\n\nint main() {\n  while (cin >> n, n) {\n    s = vector<string>(n);\n    for (int i = 0; i < n; ++i) cin >> s[i];\n    cout << ( (n == 1) ? s[0][0] - '0' : calc(s[0][0], 1) ) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\n\nint dfs(int line,int level,vector<string> form){\n  if(isdigit(form[line][level]))return (int)form[line][level]-'0';\n  char op=form[line][level];\n  int res=(op=='*'?1:0);\n  repl(i,line+1,n){\n    if(form[i][level]!='.')break;\n    if(form[i][level+1]=='.')continue;\n    int tmp=dfs(i,level+1,form);\n    res=(op=='*'?res*tmp:res+tmp);\n  }\n  return res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vector<string> form;\n    rep(i,n){\n      string s;\n      cin>>s;\n      form.pb(s);\n    }\n    cout<<dfs(0,0,form)<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint dfs(vector<int> &dp, vector<vector<int>> &c, vector<char> &e, int v = 0){\n  if (e[v] == '+'){\n    dp[v] = 0;\n    for (int w : c[v]){\n      dp[v] += dfs(dp, c, e, w);\n    }\n  } else if (e[v] == '*'){\n    dp[v] = 1;\n    for (int w : c[v]){\n      dp[v] *= dfs(dp, c, e, w);\n    }\n  } else {\n    dp[v] = e[v] - '0';\n  }\n  return dp[v];\n}\nint main(){\n  while (1){\n    int n;\n    cin >> n;\n    if (n == 0){\n      break;\n    }\n    vector<string> S(n);\n    for (int i = 0; i < n; i++){\n      cin >> S[i];\n    }\n    vector<int> d(n, 0);\n    for (int i = 0; i < n; i++){\n      while (S[i][d[i]] == '.'){\n        d[i]++;\n      }\n    }\n    vector<int> p(n);\n    p[0] = -1;\n    for (int i = 1; i < n; i++){\n      p[i] = i;\n      while (d[p[i]] >= d[i]){\n        p[i]--;\n      }\n    }\n    vector<vector<int>> c(n);\n    for (int i = 1; i < n; i++){\n      c[p[i]].push_back(i);\n    }\n    vector<char> e(n);\n    for (int i = 0; i < n; i++){\n      e[i] = S[i][d[i]];\n    }\n    vector<int> dp(n);\n    dfs(dp, c, e);\n    cout << dp[0] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint rec(vector<string> s, int top, int bot, int lev) {\n    if (s[top][lev] >= '0' && s[top][lev] <= '9') return s[top][lev]-'0';\n    \n    vector<int> a;\n    int y = top;\n    int x = lev+1;\n    while (y+1 <= bot && x < s[y+1].size() && s[y+1][x] != ' ') {\n        y++;\n        if (s[y][x] >= '0' && s[y][x] <= '9') {\n            a.push_back(s[y][x]-'0');\n        }\n        else if (s[y][x] == '+' || s[y][x] == '*') {\n            int b = y;\n            while (b+1 <= bot && s[b+1][x] == '.') b++;\n            a.push_back(rec(s,y,b,x));\n            y = b;\n        }\n    }\n    \n    //printf(\"top=%d bot=%d lev=%d | \",top,bot,lev);\n    //for (int i = 0; i < a.size(); i++) cout << a[i] << \" \"; cout << endl;\n    \n    int sum = 0;\n    if (s[top][lev] == '+') for (int i = 0; i < a.size(); i++) sum += a[i];\n    else if (s[top][lev] == '*') {\n        sum = 1;\n        for (int i = 0; i < a.size(); i++) sum *= a[i];\n    }\n    return sum;\n}\n\nint main(void){\n    int n;\n    while (cin>>n && n) {\n        vector<string> s(n);\n        for (int i = 0; i < n; i++) cin >> s[i];\n        cout << rec(s, 0, n-1, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 11\nusing namespace std;\nstring s[N];\nint n,y;\n\nint dfs(int x){\n  int res;\n  if('0'<=s[y][x]&&s[y][x]<='9')\n    return s[y][x]-'0';\n  if(s[y][x]=='+'){\n    res=0;\n    while(x+2<=s[y+1].size())\n      y++,res+=dfs(x+1);\n  }\n  if(s[y][x]=='*'){\n    res=1;\n    while(x+2<=s[y+1].size())\n      y++,res*=dfs(x+1);\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++)\n      cin>>s[i];\n    y=0;\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1000\n\nint calc(int a, int op, int b){\n  if(op == -1) return a + b;\n  return a * b;\n}\n\nbool isop(char c){\n  return c <= -1;\n}\n\nbool solve(){\n  int n;\n\n  scanf(\"%d\", &n);\n\n  if(n == 0) return false;\n\n  stack<pair<int,int> > st;\n\n  st.push({-1, '+'});\n  \n  for(int i=0;i<=n;i++){\n    char s[200];\n    int counter = 0;\n\n    if(i < n){\n      scanf(\"%s\", s);  \n      while(s[counter] == '.') counter++;\n    }else{\n      counter = 0;\n    }\n\n    //debug(s[counter]);\n    \n    vector<int> vec;\n    while(st.size() && (st.top().first > counter || (st.top().first == counter && isop(st.top().second) ))){\n      auto p = st.top(); st.pop();\n\n      if(isop(p.second)){\n        int res = vec[0];\n        for(int j=1;j<vec.size();j++) res = calc(res, p.second, vec[j]);\n        st.push({p.first, res});\n        vec = vector<int>();\n      }else{\n        vec.push_back(p.second);\n      }\n    }\n\n    if(s[counter] == '+')\n      st.push({counter, -1});\n    else if(s[counter] == '*')\n      st.push({counter, -2});\n    else\n      st.push({counter, s[counter]-'0'});\n  }\n\n  st.pop();\n  \n  printf(\"%d\\n\", st.top().second);\n\n  return true;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool JudgeInt(char c)\n{\n    if (c == '+' || c == '*' || c == '.')\n    {\n        return false;\n    }\n    else\n    {\n        return true;\n    }\n}\n\nint line;\n\nint search(int n, int level, bool plus, vector<string> calc)\n{\n    int ans = (plus ? 0 : 1);\n    /* if (j == n)\n    {\n        return ans;\n    }*/\n    while (line <= n && level == calc[line].size() - 1)\n    {\n\n        if (line <= n && level == calc[line].size() - 1 && JudgeInt(calc[line][level]))\n        {\n            if (plus)\n            {\n                ans += calc[line][level] - '0';\n            }\n            else\n            {\n                ans *= calc[line][level] - '0';\n            }\n            line++;\n        }\n        else if (line <= n && calc[line][level] == '+' && level == calc[line].size() - 1)\n        {\n            line++;\n            if (plus)\n                ans += search(n, level + 1, true, calc);\n            else\n                ans *= search(n, level + 1, true, calc);\n        }\n        else if (line <= n && calc[line][level] == '*' && level == calc[line].size() - 1)\n        {\n            line++;\n            if (plus)\n                ans += search(n, level + 1, false, calc);\n            else\n                ans *= search(n, level + 1, false, calc);\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    vector<int> ANS;\n    while (true)\n    {\n        int n;\n        cin >> n;\n        if (n == 0)\n            break;\n        vector<string> calc(n + 2);\n        calc[n] = \"\";\n        for (int i = 0; i < n; i++)\n        {\n            cin >> calc[i];\n        }\n        line = 0;\n        int ans = 0;\n        if (JudgeInt(calc[0][0]))\n        {\n            ans = calc[0][0] - '0';\n        }\n        else\n        {\n            ans = (calc[0] == \"+\" ? 0 : 1);\n            while (line < n)\n            {\n                if (calc[0] == \"+\")\n                {\n                    ans += search(n + 1, 0, true, calc);\n                }\n                else\n                {\n                    ans *= search(n + 1, 0, false, calc);\n                }\n            }\n        }\n        ANS.push_back(ans);\n    }\n    for (int i = 0; i < ANS.size(); i++)\n        cout << ANS[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n\n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nstring s[1024];\n\nint rec(int a,int b,int c){ //a -> 参照する文字列 b->式の階層 c-> 演算の形式\n  cout << \"call(a,b,c)\" << a << \",\" << b <<\",\" << c << endl;\n\tint res=0;\n\tif(c)res=1;\n\tfor(int i=a;i<n&&b<s[i].size();i++){\n\t\tif(s[i][b]=='.')continue;\n\t\tint x=s[i][b]-'0'; //ASCII code の性質 char -> int\n\t\tif(s[i][b]=='*')x=rec(i+1,b+1,1);\n\t\tif(s[i][b]=='+')x=rec(i+1,b+1,0);\n\t\tif(c)res*=x;\n\t\telse res+=x;\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tREP(i,n)cin>>s[i];\n\t\tcout<<rec(0,0,0)<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\ntypedef long long ll;\n\nll solve(vector<string> &s,int n,int &y,int x){\n    if(isdigit(s[y][x])) return s[y][x] - '0';\n    if(s[y][x] == '+'){\n        ll term = 0;\n        while(y+1 < n && s[y+1][x] == '.'){\n            y++;\n            term += solve(s,n,y,x+1);\n        }\n        return term;\n    }else{\n        ll term = 1;\n        while(y+1 < n && s[y+1][x] == '.'){\n            y++;\n            term *= solve(s,n,y,x+1);\n        }\n        return term;\n    }\n}\n\nint main(void){\n    int n;\n    while(cin>>n,n){\n        vector<string> s(n);\n        rep(i,n) cin>>s[i];\n        int y = 0;\n        cout<<solve(s,n,y,0)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)(?´????????`)///\nint i;\nint f(vector<string> &v,int depth,char c) {\n\tif (c == '*') {\n\t\tint ret = 1;\n\t\tfor (; i < v.size(); ++i) {\n\t\t\tif (depth >= v[i].size())return ret;\n\t\t\tchar d = v[i][depth];\n\t\t\tif (!isdigit(d)) {\n\t\t\t\t++i;\n\t\t\t\tret *= f(v, depth + 1, d);\n\t\t\t\t--i;\n\t\t\t}\n\t\t\telse ret *= (d - '0');\n\t\t}\n\t\treturn ret;\n\t}\n\telse {\n\t\tint ret = 0;\n\t\tfor (; i < v.size(); ++i) {\n\n\t\t\tif (depth >= v[i].size())return ret;\n\t\t\tchar d = v[i][depth];\n\t\t\tif (!isdigit(d)) {\n\t\t\t\t++i;\n\t\t\t\tret += f(v, depth + 1, d);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\telse ret += (d - '0');\n\t\t}\n\t\treturn ret;\n\t}\n\t\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (!n)break;\n\t\tvector<string> v(n);\n\t\ti = 0;\n\t\tREP(j, n)cin >> v[j];\n\t\tcout << f(v, 0, '+') << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n# ifdef _MSVC_LANG\n\n# define _SCL_SECURE_NO_WARNINGS\n# pragma warning( disable : 0325 ) // inline namespace Error\n\n# endif\n\n\n# include <iostream>\n# include <string>\n# include <iomanip>\n# include <cstdio>\n# include <array>\n# include <numeric>\n# include <algorithm>\n# include <vector>\n# include <functional>\n# include <fstream>\n# include <random>\n# include <bitset>\n# include <map>\n# include <unordered_set>\n\n\n// C++ 11 前提\n\nusing Ull = unsigned long long;\nusing Ll = long long;\n\ntemplate<typename T>\nusing Vec = std::vector<T>;\n\ntemplate<typename T, size_t L>\nusing Ary = std::array<T, L>;\n\nnamespace\n{\n\n    namespace meta\n    {\n        namespace coming\n        {\n            // c++ 17;\n            template<class... _Types>\n            using void_t = void;\n\n            template<class _Ty,\n                _Ty _Val>\n                struct integral_constant\n            {\t// convenient template for integral constant types\n                static constexpr _Ty value = _Val;\n\n                using value_type = _Ty;\n                using type = integral_constant;\n\n                constexpr operator value_type() const noexcept\n                {\t// return stored value\n                    return (value);\n                }\n\n                constexpr value_type operator()() const noexcept\n                {\t// return stored value\n                    return (value);\n                }\n            };\n\n            // c++ 17;\n            template<bool _Val>\n            using bool_constant = integral_constant<bool, _Val>;\n\n\n            // c++ 14\n            template<bool _Test,\n                class _Ty = void>\n                using enable_if_t = typename std::enable_if<_Test, _Ty>::type;\n        }\n\n        namespace core\n        {\n\n            template < class, class = void > struct enable_std_begin_end : std::false_type {};\n            template < typename T >\n            struct enable_std_begin_end<T,\n                coming::void_t<decltype(std::begin(std::declval<const T&>()), std::end(std::declval<const T&>()))>> : std::true_type {}; // c++ 17\n\n\n            template < class, class = void > struct enable_adl_begin_end : std::false_type {};\n            template < typename T >\n            struct enable_adl_begin_end<T,\n                coming::void_t<decltype(begin(std::declval<const T&>()), end(std::declval<const T&>()))>> : std::true_type {};\n        }\n\n        template < typename T >\n        struct is_range\n            : coming::bool_constant< core::enable_std_begin_end<T>::value || core::enable_adl_begin_end<T>::value>\n        {\n        };\n\n        /// <summary>\n        /// ある値が0以上か\n        /// </summary>\n        template<class T, T num, class = std::nullptr_t> struct is_positive\n            : coming::bool_constant<(num >= 0)>\n        {\n        };\n\n    }\n\n\n    inline namespace extension\n    {\n        inline namespace container_io\n        {\n            inline namespace in\n            {\n\n                /// <summary>\n                /// for cin with STL container\n                /// </summary>\n                template< template<class ...> class Container, class ... Args, typename = meta::coming::enable_if_t<!std::is_same< typename Container, typename std::basic_string> ::value> >\n                std::istream& operator >> (std::istream& is, Container<Args ...>& container)\n                {\n                    for (auto& elem : container) is >> elem; return is;\n                }\n\n                /// <summary>\n                /// for cin with std::arary\n                /// </summary>\n                template<class T, size_t L>\n                std::istream& operator >> (std::istream& is, std::array<T, L>& container)\n                {\n                    for (auto& elem : container) is >> elem; return is;\n                }\n\n                /// <summary>\n                /// for cin with raw array\n                /// </summary>\n                template<class T, size_t L>\n                std::istream& operator >> (std::istream& is, T(&ary)[L])\n                {\n                    for (int i{}; i < L; ++i) is >> ary[i]; return is;\n                }\n\n            }\n\n            inline namespace out\n            {\n                namespace settings\n                {\n                    /// <summary>\n                    /// 要素間の区切り文字\n                    /// </summary>\n                    const auto sepOfContainerElements{\" \"};\n                    /// <summary>\n                    /// コンテナ間の区切り文字\n                    /// </summary>\n                    const auto sepOfContainer{\"\\n\"};\n                }\n\n\n                /// <summary>\n                /// for cout Container with STL container\n                /// </summary>\n                template < template<class ...> class Container, class ... Args, typename = meta::coming::enable_if_t<!std::is_same< typename Container, typename std::basic_string> ::value> >\n                std::ostream& operator << (std::ostream& os, const Container<Args ...>& container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainerElements; return os;\n                }\n\n                /// <summary>\n                /// for cout Container with std::array\n                /// </summary>\n                template < class T, size_t L>\n                std::ostream& operator << (std::ostream& os, const std::array<T, L> container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainerElements; return os;\n                }\n\n                /// <summary>\n                /// for cout Container with raw array\n                /// </summary>\n                template < class T, size_t L, typename = meta::coming::enable_if_t<!std::is_same<T, char>::value> >\n                std::ostream& operator << (std::ostream& os, const T(&ary)[L])\n                {\n                    for (const auto& elem : ary) os << elem << settings::sepOfContainerElements; return os;\n                }\n\n\n\n                /// <summary>\n                /// for cout Container in Container with STL container\n                /// </summary>\n                template < template<class ...> class Container1, class ... Cont1Args,\n                    template<class ...> class Container2, class ... Cont2Args  >\n                std::ostream& operator << (std::ostream& os, const Container1< Container2<Cont2Args ...>, Cont1Args ...>& container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainer; return os;\n                }\n\n\n\n                /// <summary>\n                /// for cout Container in Container with std::array\n                /// </summary>\n                template < template<class ...> class Container, class ... Args, size_t L >\n                std::ostream& operator << (std::ostream& os, const std::array<Container<Args ...>, L>& container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainer; return os;\n                }\n                /// <summary>\n                /// for cout Container in Container with std::array\n                /// </summary>\n                template < template<class ...> class Container, class ... Args, size_t L, class T  >\n                std::ostream& operator << (std::ostream& os, const Container<std::array<T, L>, Args ...>& container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainer; return os;\n                }\n                /// <summary>\n                /// for cout Container in Container with std::array\n                /// </summary>\n                template < class T, size_t L1, size_t L2 >\n                std::ostream& operator << (std::ostream& os, const std::array<std::array<T, L2>, L1> container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainer; return os;\n                }\n\n\n                /// <summary>\n                /// for cout raw ary in raw ary\n                /// </summary>\n                template < class T, size_t L1, size_t L2 >\n                std::ostream& operator << (std::ostream& os, const T(&ary)[L1][L2])\n                {\n                    for (size_t i{}; i < L1; ++i) os << ary[i] << settings::sepOfContainer; return os;\n                }\n\n            }\n        }\n\n\n        template<typename T, size_t L, typename Function>\n        void for_each(T(&ary)[L], Function lambda)\n        {\n            for (size_t i{}; i < L; ++i)\n                lambda(static_cast<T&>(ary[i]));\n        }\n    }\n\n\n    inline namespace util\n    {\n\n        template<typename T>\n        void SetAll(T& container, typename T::value_type value = typename T::value_type{})\n        {\n            for (typename T::reference content : container) content = value;\n        }\n\n        template<typename T, size_t L>\n        void SetAll(T(&ary)[L], T value)\n        {\n            for (size_t i{}; i < L; ++i) ary[i] = value;\n        }\n\n        template<typename T, typename U, size_t L1, size_t L2>\n        void SetAll(T(&ary)[L1][L2], U value)\n        {\n            for (size_t i{}; i < L1; ++i) SetAll(ary[i], value);\n        }\n\n\n        inline namespace ranges\n        {\n\n            namespace core\n            {\n\n                using namespace meta;\n                /// <summary>\n                /// 再帰上限回数\n                /// </summary>\n                constexpr size_t recursion_limits{490};\n\n                /// <summary>\n                /// 値が割り切れるか\n                /// </summary>\n                template<int num, int divide> struct is_divisible\n                    : coming::bool_constant<num % divide == 0>\n                {\n                };\n\n                /// <summary>\n                /// 有限回数の再帰で終わるか\n                /// </summary>\n                template<int start, int end, int step> struct is_finite_recursion_depth\n                    : coming::bool_constant<(start < end) && (step > 0) || (end < start) && (step < 0)>{};\n\n                /// <summary>\n                /// 再帰回数が上限を超えないか\n                /// </summary>\n                template<int start, int end, int step> struct is_valid_recursion_depth\n                    : coming::bool_constant<(end - start) / step <= recursion_limits>\n                {\n                };\n\n                /// <summary>\n                /// 上記メタ関数の条件をすべて満たすか\n                /// </summary>\n                template<int start, int end, int step> struct is_valid_range\n                    : coming::bool_constant<(start == end) || is_finite_recursion_depth<start, end, step>::value && is_valid_recursion_depth<start, end, step>::value && is_divisible<end - start, step>::value>\n                {\n                };\n\n                /// <summary>\n                /// 再帰を続けるか\n                /// </summary>\n                template<int start, int end, int step> struct is_count_up_or_down\n                    : coming::bool_constant<is_valid_range<start, end, step>::value && end != start>\n                {\n                };\n\n                ///// <summary>\n                ///// 初期化子リストからstd::arrayをコンパイル時生成\n                ///// </summary>\n                //template<typename T, typename ...Args>\n                //constexpr std::array<T, sizeof...(Args)> make_array(Args&&... args)\n                //{\n                //    return std::array<T, sizeof...(Args)>{ static_cast<Args&&>(args)... };\n                //}\n\n\n                /// <summary>\n                /// 本体\n                /// </summary>\n\n                // エラー処理\n                template<int start, int end, int step, class = void, int ...Ary>\n                struct Range_Impl\n                {\n                    //static_assert(is_valid_range           <start, end, step>::value, \"[ ! ] invalid teplate argments [ ! ] 値正しくないっぽいヨ！\");\n                    static_assert(is_divisible             <end - start, step>::value, \"[ ! ] (end - start) is indivisible by step number [ ! ] 割り切れないヨ！stepの値確認して！\");\n                    static_assert(is_finite_recursion_depth<start, end, step>::value, \"[ ! ] goes to infinite loop [ ! ] 無限ループなっちゃうヨ！stepの符号逆じゃない？\");\n                    static_assert(is_valid_recursion_depth <start, end, step>::value, \"[ ! ] recursion depth is out of maximum limit [ ! ] 再帰回数が大きくなりすぎｨ壊れちゃううう\");\n                };\n                // 再帰\n                template<int start, int end, int step, int ... Ary>\n                struct Range_Impl<start, end, step, meta::coming::enable_if_t<is_count_up_or_down<start, end, step>::value>, Ary ... >\n                    : Range_Impl < start + step, end, step, void, Ary ..., start>\n                {\n                };\n                // 終端\n                template<int start, int end, int step, int ... Ary>\n                struct Range_Impl < start, end, step, meta::coming::enable_if_t<start == end>, Ary ...>\n                {\n                    //static constexpr auto value = make_array<int>(Ary ..., end);\n                    //static constexpr std::array<int, (sizeof... (Ary) + 1)> value = {Ary ..., end};\n                    static constexpr int value[(sizeof ... (Ary)+1)] = {Ary ..., end};\n                };\n\n\n            }\n\n\n            template<size_t size, bool isReverse = false>\n            struct Iterate\n            {\n                static constexpr auto in = isReverse ?\n                    core::Range_Impl<static_cast<int>(size - 1), 0, -1>::value :\n                    core::Range_Impl<0, static_cast<int>(size - 1), 1>::value;\n            };\n\n            template<unsigned int upTo>\n            struct CountUp\n            {\n                static constexpr auto to = core::Range_Impl<0, static_cast<int>(upTo), 1>::value;\n            };\n            template<unsigned int downFrom>\n            struct CountDown\n            {\n                static constexpr auto from = core::Range_Impl<static_cast<int>(downFrom), 0, -1>::value;\n            };\n\n\n            template<int start, int containedEnd, int step = 0, typename = void>\n            struct Range\n            {\n                static constexpr auto& in = core::Range_Impl<start, containedEnd, step>::value;\n            };\n            template<int start, int containedEnd>\n            struct Range <start, containedEnd, 0>\n            {\n                static constexpr auto& in = core::Range_Impl<start, containedEnd, meta::is_positive<int, containedEnd - start>::value ? 1 : -1>::value;\n            };\n\n        }\n    }\n\n\n    inline namespace alg\n    {\n        bool IsPrime(const Ull n)\n        {\n            switch (n)\n            {\n            case 0: case 1:\n                return false;\n            case 2:\n                return true;\n            default:\n\n                if (n % 2 == 0) return false;\n\n                for (Ull i{3}; i * i <= n; i += 2)\n                {\n                    if (n % i == 0) return false;\n                }\n            }\n\n            return true;\n        }\n\n        // 最大公約数\n        Ull EuclideanAlg(Ull n1, Ull n2)\n        {\n            //if (n1 < 0 || n2 < 0) return 0;\n            if (n2 > n1) std::swap(n1, n2);\n\n            Ull r;\n            while ((r = n1 % n2) != 0)\n            {\n                n1 = n2;\n                n2 = r;\n            }\n\n            return n2;\n        }\n\n        // 最小公倍数\n        Ull LCM(const std::vector<Ull>& values)\n        {\n            if (values.size() == 0)\n                return 0;\n            if (values.size() == 1)\n                return values[0];\n            if (values.size() == 2)\n                return values[0] * values[1] / EuclideanAlg(values[0], values[1]);\n\n            auto mid = values.cbegin() + values.size() / 2;\n\n            return LCM(std::vector<Ull>{LCM(std::vector<Ull>(values.begin(), mid)), LCM(std::vector<Ull>(mid, values.end()))});\n        }\n    }\n\n\n    void Solve();\n\n}\n\n# if false\nint main()\n{\n    Solve();\n    return 0;\n}\n# endif\n\nnamespace\n{\n    bool isShortPhrase(const std::string& phrases)\n    {\n        constexpr Ary<char, 5> eachLength = {5, 7, 5, 7, 7};\n        \n        int sum{}, current{};\n        for (int i = 0; i < phrases.size(); ++i)\n        {\n            sum += (int)phrases[i];\n            \n            if (sum == eachLength[current])\n            {\n                if (current == eachLength.size() - 1)\n                    return true;\n\n                ++current;\n                sum = 0;\n            }\n        }\n\n        return false;\n    }\n\n    void Solve()\n    {\n        std::ofstream ofs(\"output.txt\");\n        std::cout.rdbuf(ofs.rdbuf());\n\n\n        int length;\n        while (std::cin >> length, length != 0)\n        {\n            std::string phrases(40, '\\0');\n            for (int i{}; i < length; ++i)\n            {\n                std::string temp; std::cin >> temp;\n                phrases[i] = temp.length();\n            }\n\n            for (int i{}; i < length - 4; ++i)\n            {\n                if (isShortPhrase(phrases.substr(i, phrases.size() - i)))\n                {\n                    std::cout << i + 1<< std::endl;\n                    break;\n                }\n            }\n\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint n;\nvector< pair<int, int> > input;\n\nint dfs(int p) {\n  int t = input[p].first + 1;\n  char e = (char) input[p].second;\n  int ans;\n\n  if(e == '+') ans = 0;\n  if(e == '*') ans = 1;\n  if(e != '+' && e != '*') return e;\n\n  for(int i = p + 1; input[i].first >= t && i < input.size(); i++) {\n    if(input[i].first > t) continue;\n\n    int v;\n    if(input[i].second == '+' || input[i].second == '*') v = dfs(i);\n    else v = input[i].second;\n\n    if(e == '+') ans += v;\n    if(e == '*') ans *= v;\n  }\n\n  return ans;\n}\n\nint main(void) {\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n\n    input.clear();\n    REP(i, 0, n) {\n      string line; cin >> line;\n      int level = 0;\n      for(; line[level] == '.'; level++);\n      char c = line[level];\n      input.push_back(pair<int, int>(level, c == '+' || c == '*' ? c : c - '0'));\n    }\n\n    cout << dfs(0) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i, n, N) for(ll i=(n);i<(N);i++)\n#define RREP(i, n, N) for(ll i=(N-1);i>=(n);i--)\n#define CK(n, a, b) ((a)<=(n)&&(n)<(b))\n#define ALL(v) (v).begin(), (v).end()\n#define MCP(a, b) memcpy(b,a, sizeof(b))\n#define p(s) cout<<(s)<<endl\n#define p2(a, b) cout<<(a)<<\" \"<<(b)<<endl\ntypedef long long ll;\nusing namespace std;\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\n\nll N;\n\nint main() {\n    while (cin >> N, N) {\n        string s[30];\n        REP(i, 0, N) {\n            cin >> s[i];\n        }\n        if(N==1){\n            cout<<s[0]<<endl;\n            continue;\n        }\n        char op[30];\n        queue<ll> num[30];\n        ll now_level = 0;\n        ll ans = 0;\n        REP(i, 0, N) {\n            ll next_level = s[i].size();\n            if (next_level >= now_level) {\n                if (isdigit(s[i].back())) {\n                    num[next_level].push(s[i].back() - '0');\n                } else {\n                    op[next_level] = s[i].back();\n                }\n            } else if (next_level < now_level) {\n                RREP(j, next_level+1, now_level + 1) {\n                    ll tmp=0;\n                    if(op[j - 1]=='*') tmp=1;\n                    while (!num[j].empty()) {\n                        if (op[j - 1] == '+') {\n                            tmp += num[j].front();\n                        } else {\n                            tmp *= num[j].front();\n                        }\n\n                        num[j].pop();\n                    }\n                    num[j-1].push(tmp);\n                }\n                if (isdigit(s[i].back())) {\n                    num[next_level].push(s[i].back() - '0');\n                } else {\n                    op[next_level] = s[i].back();\n                }\n            }\n            now_level = next_level;\n        }\n\n        RREP(j, 2, now_level + 1) {\n            ll tmp=0;\n            if(op[j - 1]=='*') tmp=1;\n            while (!num[j].empty()) {\n                if (op[j - 1] == '+') {\n                    tmp += num[j].front();\n                } else {\n                    tmp *= num[j].front();\n                }\n\n                num[j].pop();\n            }\n            num[j-1].push(tmp);\n        }\n        p(num[1].front());\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring S[30];\nint pos, n;\nint Rank[30];\n\nint Add(int);\nint Multi(int);\n\nint main(){\n\tint ans;\n\twhile(cin>>n && n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>S[i];\n\t\t\tRank[i]=S[i].length()-1;\n\t\t}\n\n\t\tif('0'<=S[0][0] && S[0][0]<='9'){\n\t\t\tcout<<S[0][0]<<endl;\n\t\t\tcontinue;\n\t\t}else{\n\t\t\tpos=1;\n\t\t\tif(S[0][0]=='+'){\n\t\t\t\tans=Add(0);\n\t\t\t}else if(S[0][0]=='*'){\n\t\t\t\tans=Multi(0);\n\t\t\t}\n\n\t\t\tcout<<ans<<endl;\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nint Add(int R){\n\tint ret=0;\n\twhile(pos<n){\n\t\tif(Rank[pos]<=R)break;\n\n\t\tchar ch=S[pos][ Rank[pos] ];\n\t\tif('0'<=ch && ch<='9'){\n\t\t\tret+=(ch-'0');\n\t\t\tpos++;\n\t\t}else{\n\t\t\tpos++;\n\t\t\tif(ch=='+'){\n\t\t\t\tret+=Add(Rank[pos-1]);\n\t\t\t}else if(ch=='*'){\n\t\t\t\tret+=Multi(Rank[pos-1]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint Multi(int R){\n\tint ret=1;\n\twhile(pos<n){\n\t\tif(Rank[pos]<=R)break;\n\n\t\tchar ch=S[pos][ Rank[pos] ];\n\t\tif('0'<=ch && ch<='9'){\n\t\t\tret*=(ch-'0');\n\t\t\tpos++;\n\t\t}else{\n\t\t\tpos++;\n\t\t\tif(ch=='+'){\n\t\t\t\tret*=Add(Rank[pos-1]);\n\t\t\t}else if(ch=='*'){\n\t\t\t\tret*=Multi(Rank[pos-1]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nvoid solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        st.push(make_pair(th, l-1));\n    }\n}\nint main(){\n    while(cin>>n,n){\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    solve(level);\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        solve(0);\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint expression(int &idx, int level, vector<vector<int>> &a) {\n    int ret;\n    int mode;\n    if (a[idx][1] == -1) mode = 1;\n    else if ( a[idx][1] == -2) mode = 2;\n    else return ret = a[idx][1];\n    \n    if (mode == 1) ret = 0;\n    else if (mode == 2) ret = 1;\n    \n    while (1) {\n        idx++;\n        if (mode == 1) {\n            ret += expression(idx, level+1, a);\n        } else {\n            ret *= expression(idx, level+1, a);\n        }\n        if (level > a[idx+1][0]) return ret;\n    }\n}\n\n\nint solve(int N) {\n    vector<vector<int>> a(N+1, vector<int>(2));\n    for (int i = 0; i < N; i++) {\n        string s; cin >> s;\n        int level = 0;\n        for (int j = 0; j < s.length(); j++) {\n            if (s[j] == '.') level++;\n            if (s[j] == '+') a[i][1] = -1;\n            else if (s[j] == '*') a[i][1] = -2;\n            else a[i][1] = s[j] - '0';\n            a[i][0] = level;\n        }\n    }\n    a[N][0] = -1;\n    \n    int idx = 0;\n    int ret = expression(idx, 1, a);\n    return ret;\n}\n\nint main(void){\n    // Your code here!\n    int N;\n    vector<int> ans;\n    while (1) {\n        cin >> N;\n        if (!N) break;\n        ans.push_back(solve(N));\n    }\n    for (auto &i : ans) {\n        cout << i << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\nusing namespace std;\n\nint p;\nvector<string> s;\n\nint dfs(int d) {\n  if (s[p][d] == '+') {\n    int res = 0;\n    p++;\n    while (p < s.size() && s[p].size() - 1 > d) res += dfs(d + 1);\n    return res;\n  } else if (s[p][d] == '*') {\n    int res = 1;\n    p++;\n    while (p < s.size() && s[p].size() - 1 > d) res *= dfs(d + 1);\n    return res;\n  } else {\n    int res = s[p][d] - '0';\n    p++;\n    return res;\n  }\n}\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    s = vector<string>(n);\n    REP(i, n) cin >> s[i];\n    p = 0;\n    cout << dfs(0) << endl;;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define INF 1<<30\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nvector<string> s;\n\nint dfs(int &i, int dep) {\n\tstring t = s[i];\n\tchar c = t[t.size()-1];\n\n\ti++;\n\tint ret;\n\n\tif(c == '*') {\n\t\tret = 1;\n\t\twhile(i < n) {\n\t\t\tstring u = s[i];\n\t\t\tint depth = u.size()-1;\n\t\t\tchar c2 = u[u.size()-1];\n\n\t\t\tif(dep + 1 == depth) {\n\t\t\t\tret *= dfs(i, depth);\n\t\t\t} else break;\n\t\t}\n\t} else if(c == '+') {\n\t\tret = 0;\n\n\t\twhile(i < n) {\n\t\t\tstring u = s[i];\n\t\t\tint depth = u.size()-1;\n\t\t\tchar c2 = u[u.size()-1];\n\n\t\t\tif(dep + 1 == depth) {\n\t\t\t\tret += dfs(i, depth);\n\t\t\t} else break;\n\t\t}\n\t} else {\n\t\treturn int(c - '0');\n\t}\n\n\treturn ret;\n}\n\nint main() {\n\twhile(cin >> n && n) {\n\t\ts.clear(); s.resize(n);\n\t\trep(i, n) cin >> s[i];\n\n\t\tint i = 0;\n\t\tcout << dfs(i, 0) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nll n;\n\nll dfs(ll line,ll level,vector<string> form){\n  //dbg(line); dbg(level);\n  if(isdigit(form[line][level]))return (ll)(form[line][level]-'0');\n  char op=form[line][level];\n  ll res=(op=='*'?1:0);\n  repl(i,line+1,n){\n    if(form[i][level]!='.')break;\n    if(form[i][level+1]=='.')continue;\n    ll tmp=dfs(i,level+1,form);\n    res=(op=='*'?res*tmp:res+tmp);\n  }\n  return res;\n}\n\nint main(){\n\t//cin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vector<string> form;\n    rep(i,n){\n      string s;\n      cin>>s;\n      form.pb(s);\n    }\n    cout<<dfs(0,0,form)<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cassert>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<ctype.h>\nusing namespace std;\n\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) {\n    for(T &a : v) is >> a; return is;\n}\n\nint calc_depth(string &s) {\n    rep(i, s.size()) if(s[i] != '.') return i;\n    assert(0);\n}\n\nint calc(vector<string> &line, int &now, int depth) {\n    char c = line[now].back();\n    if(isdigit(c)) {\n        now++;\n        return c - '0';\n    } else {\n        function<int(int, int)> f;\n        int ret;\n        if(c == '+') {\n            f = [](int a, int b) { return a + b; };\n            ret = 0;\n        } else if(c == '*') {\n            f = [](int a, int b) { return a * b; };\n            ret = 1;\n        } else assert(0);\n        now++;\n        \n        while(now < line.size() and calc_depth(line[now]) > depth) {\n            ret = f(ret, calc(line, now, depth + 1));\n        }\n        return ret;\n    }\n}\n\n\nbool solve() {\n    int n; cin >> n;\n    if(n == 0) return 0;\n    vector<string> line(n); cin >> line;\n    int i = 0;\n    cout << calc(line, i, 0) << endl;\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<utility>\n#include<ctype.h>\nint main() {\n\tint n;\n\twhile (std::cin >> n,n) {\n\t\tstd::vector<std::string> s(n);\n\t\tfor (int i = 0; i < n;++i) std::cin >> s[i];\n\tint res = 0;\n\tint j = 0;\n\tint h = 0;\n\tfor (int i = 0; i < n;++i) {\n\tif (isdigit(s[i][0])) res += s[i][0] - '0';\n\t\tif (j > s[i].size()) while (j > s[i].size()) --j;\t\t\n\t\tif (s[i][j] == '+') {\n\t\t\tint d = i;\n\t\t\tj += 1;\n\t\t\twhile (d<n)\n\t\t\t{\n\t\t\t\tif (isdigit(s[d][j])) {\n\t\t\t\t\tres += s[d][j]-'0';\n\t\t\t\t}\n\t\t\t\t++d;\n\t\t\t}\n\t\t}\n\t\tif (s[i][j] == '*') {\n\t\t\tint d = i;\n\t\t\tj += 1;\n\t\t\tint a = 1;\n\t\t\twhile (d<n)\n\t\t\t{\n\t\t\t\tif (isdigit(s[d][j])) {\n\t\t\t\t\ta *= s[d][j]-'0';\n\t\t\t\t}\n\t\t\t\t++d;\n\t\t\t}\n\t\t\tres +=a;\n\t\t}\n\t}\n\tstd::cout << res << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<stack>\n\nusing namespace std;\nusing ll = long long;\n\nvoid solve(int n){\n  int ans = 0;\n  string f;\n  stack<pair<int, pair<int, int> > > st;\n  st.push({0, {-1, 0}});\n  for(int i = 0; i < n; i++){\n    cin >> f;\n    int c = 0;\n    for(int j = 0; j < f.length(); j++){\n      if(f[j] == '.'){\n        c++;\n        continue;\n      }\n      while(c != st.top().second.first + 1){\n        int tmp = st.top().second.second;\n        st.pop();\n        if(st.top().first == 0) st.top().second.second += tmp;\n        else st.top().second.second *= tmp;\n        // cout << st.top().second.first << ' ' << st.top().second.second << endl;\n      }\n      if(f[j] == '+'){\n        st.push({0, {c, 0}});\n      }\n      else if(f[j] == '*'){\n        st.push({1, {c, 1}});\n      }\n      else{\n        if(st.top().first == 0){\n          st.top().second.second += int(f[j] - '0');\n        }\n        else{\n          st.top().second.second *= int(f[j] - '0');\n        }\n      }\n    }\n    // cout << st.top().second.first << ' ' << st.top().second.second << endl;\n  }\n  while(0 != st.top().second.first + 1){\n    int tmp = st.top().second.second;\n    st.pop();\n    if(st.top().first == 0) st.top().second.second += tmp;\n    else st.top().second.second *= tmp;\n    // cout << st.top().second.first << ' ' << st.top().second.second << endl;\n  }\n  ans = st.top().second.second;\n  cout << ans << endl;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int ti = clock();\n  // start-----------------------------------------------\n  int n;\n  while(cin >> n && n){\n    solve(n);\n  }\n\n  // end-----------------------------------------------\n  // cerr << 1.0 * (clock() - ti) / CLOCKS_PER_SEC << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n\nusing namespace std;\n\n\nint add(vector<string>::iterator &itr);\nint mlt(vector<string>::iterator &itr);\n\nint main(){\n    while(true){\n        int n; cin >> n;\n        if( n == 0)break;\n        vector<string> s(n);\n        for(int i = 0; i < n; i++){\n            cin >> s[i];\n        }\n        int ans = 0;\n        for(auto itr = s.begin(); itr != s.end(); ++itr){\n            if(itr->back() == '+'){\n                ans += add(itr);\n            }\n            else if(itr->back() == '*'){\n                ans += mlt(itr);\n            }\n            else{\n                ans += itr->back() - '0';\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\nint add(vector<string>::iterator &itr){\n    int c = itr->size()+1;\n    int ret = 0;\n    ++itr;\n    while(itr->size() == c){\n        if(itr->back() == '+'){\n            ret += add(itr);\n        }\n        else if(itr->back() == '*'){\n            ret += mlt(itr);\n        }\n        else{\n            ret += itr->back() -'0';\n        }\n        ++itr;\n    }\n        \n    --itr;\n    return ret;\n}\n\nint mlt(vector<string>::iterator &itr){\n    int c = itr->size();\n    int ret = 1;\n    ++itr;\n    while(itr->size() == c+1){\n        if(itr->back() == '+'){\n            ret *= add(itr);\n        }\n        else if(itr->back() == '*'){\n            ret *= mlt(itr);\n        }\n        else{\n            ret *= itr->back() - '0';\n        }\n        ++itr;\n    }\n    --itr;\n    return ret;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    vector<pair<function<int(int, int)>, int>> v;\n    v.push_back(make_pair([](int _, int a) { return a; }, 0));\n    for (int i = 0; i < n; i++) {\n      string s;\n      cin >> s;\n      if (*s.rbegin() == '+') {\n        v.push_back(make_pair([](int a, int b) { return a + b; }, 0));\n      } else if (*s.rbegin() == '*') {\n        v.push_back(make_pair([](int a, int b) { return a * b; }, 1));\n      } else {\n        while (s.size() < v.size()) {\n          int r = v.back().second;\n          v.pop_back();\n          v.rbegin()->second = v.rbegin()->first(v.rbegin()->second, r);\n        }\n        v.rbegin()->second = v.rbegin()->first(v.rbegin()->second, *s.rbegin() - '0');\n      }\n    }\n    while (v.size() > 1) {\n      int r = v.back().second;\n      v.pop_back();\n      v.rbegin()->second = v.rbegin()->first(v.rbegin()->second, r);\n    }\n    cout << v.rbegin()->second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\ntypedef pair<int, char> PIC;\ntypedef pair<int, int> PII;\n\nint main(void) {\n  int N;\n  while (cin >> N, N) {\n    vector<PIC> lines(N);\n\n    for (int i = 0; i < N; i++) {\n      string line;\n      cin >> line;\n\n      lines[i].first = line.size() - 1;\n      lines[i].second = line.back();\n    }\n\n    vector<char> operators;\n    vector<PII> operands;\n\n    int now_dep = 0;\n    for (auto line : lines) {\n      int dep = line.first;\n      char sym = line.second;\n\n      while (dep < now_dep) {\n        char op = operators.back();\n        operators.pop_back();\n        int res = ((op == '+') ? 0 : 1);\n      \n        while (operands.back().first == now_dep) {\n          int operand = operands.back().second;\n          operands.pop_back();\n          if (op == '+') res += operand;\n          else res *= operand;\n        }\n        \n        now_dep--;\n        operands.push_back(PII(now_dep, res));\n      }\n\n      now_dep = dep;\n      \n      if (sym == '+' || sym == '*') operators.push_back(sym);\n      else operands.push_back(PII(now_dep, sym - '0'));\n    }\n\n    if (operators.size() != 0) {\n        char op = operators.back();\n        operators.pop_back();\n        int res = ((op == '+') ? 0 : 1);\n\n        while (!operands.empty()) {\n          int operand = operands.back().second;\n          operands.pop_back();\n          if (op == '+') res += operand;\n          else res *= operand;\n        }\n\n        now_dep--;\n        operands.push_back(PII(now_dep, res));\n    }\n\n    cout << operands[0].second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef string::const_iterator State;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<long long>vll;\ntypedef pair<int,int> pi;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\nint number(string s){\n  int ret=0;\n  for(int i=0;i<(int)s.size();i++){\n    if(isdigit(s[i])){\n      ret*=10;\n      ret+=(s[i]-'0');\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint calc(int ret,int num,char x){\n  if(ret==-1)return num;\n  if(x=='+')return ret+num;\n  if(x=='-')return ret-num;\n  if(x=='*')return ret*num;\n  if(x=='/')return ret/num;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    string s;\n    vector<pair<int,string> > v(n);\n    int maxi=0;\n    rep(i,n){\n      cin>>s;\n      int cnt=0;\n      for(int j=0;j<s.size();j++){\n\tif(s[j]=='.')cnt++;\n      }\n      maxi=max(maxi,cnt);\n      s.erase(s.begin(),s.begin()+cnt);\n      v[i].first=cnt;\n      v[i].second=s;\n    }\n    maxi--;\n    \n    while(v.size()!=1){  \n      bool update=false;\n      for(int i=0;i<v.size();i++){\n\tint start;\n        if(v[i].first==maxi&&!isdigit(v[i].second[0])){\n\t  start=i;\n\t  char c=v[i].second[0];\n\t  i++;\n\t  int ret=-1;\n\t  while(i<v.size()+1&&v[i].first==maxi+1){\n\t    ret=calc(ret,number(v[i].second),c);\n\t    i++;\n\t  }\n\t  v[start].second=to_string(ret);\n\t  v.erase(v.begin()+start+1,v.begin()+i);\n\t  update=true;\n\t  break;\n\t}\n      }\n      if(!update)maxi--;\n    }\n    cout<<v[0].second<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int INF = 999999;\n\nint main() {\n        int correct[5] = { 5, 7, 5, 7, 7 };\n        int n;\n\n        while (cin >> n, n != 0) {\n                vector<string> s;\n                for (int i = 0; i < n; i++) {\n                        string str;\n                        cin >> str;\n                        s.push_back(str);\n                }\n                for (int i = 0; ;i++) {\n                        int j = i;\n                        int rem = 5;\n                        while (rem > 0) {\n                                rem -= s[j].size(); j++;\n                        }\n                        if (rem != 0) continue;\n\n                        rem = 7;\n                        while (rem > 0) {\n                                rem -= s[j].size(); j++;\n                        }\n                        if (rem != 0) continue;\n                        rem = 5;\n                        while (rem > 0) {\n                                rem -= s[j].size(); j++;\n                        }\n                        if (rem != 0) continue;\n                        rem = 7;\n                        while (rem > 0) {\n                                rem -= s[j].size(); j++;\n                        }\n                        if (rem != 0) continue;\n                        rem = 7;\n                        while (rem > 0) {\n                                rem -= s[j].size(); j++;\n                        }\n                        if (rem != 0) continue;\n                        cout << i + 1 << endl;\n                        break;\n                }\n\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main() {\n  int n;\n  while ( cin >> n, n ) {\n    int ans = 0;\n    int ma = 0;\n    vector<P> dat(n);    \n    for ( int i = 0; i < n; i++ ) {      \n      string s;\n      cin >> s;\n      dat[i].first = (int)s.size()-1;\n      if ( s[s.size()-1] == '+' ) dat[i].second = -1;\n      else if ( s[s.size()-1] == '*' ) dat[i].second = -2;\n      else dat[i].second = s[s.size()-1]-'0';\n      ma = max(ma, (int)s.size()-1);      \n    }\n\n    while ( 1 ) {      \n      /*for ( int i = 0; i < dat.size(); i++ ) {\n\tif ( i ) cout << \" \";\n\tcout << dat[i].first << \" \" << dat[i].second;\n      }\n      cout << endl << endl;;*/\n      if ( dat.size() == 1 ) break;\n      bool flag = false;\n      for ( int i = 0; i < dat.size()-2; i++ ) {\n\tif ( dat[i].second >= 0 ) continue;\n\tif ( dat[i].first != ma ) continue;\t\n\tint c = dat[i].second;\n\tint d = dat[i].first;\t\n\tint sum;\n\tint cnt = 2;\t\n\tif ( d != dat[i+1].first-1 ) continue;\n\tif ( dat[i+1].second >= 0 && dat[i+2].second >= 0 && dat[i+1].first == dat[i+2].first ) {\n\t  flag = true;\n\t  //cout << 'a' << endl;\t    \t \n\t  sum = dat[i+1].second;\n\t  cnt = 2;\n\t  for ( int j = i+2; j < dat.size(); j++ ) {\n\t    //cout << sum << endl;\n\t    if ( dat[j].second < 0 ) break;\n\t    if ( dat[j].first != dat[i+1].first ) break; \n\t    if ( c == -1 ) {\n\t      sum += dat[j].second;\n\t    } else {\n\t      sum *= dat[j].second;\n\t    }\n\t    cnt++;\n\t  }\n\t}\t\n\tif ( flag ) {\n\t  //cout << i << \" \" << sum << \" \" << cnt << endl;\n\t  int tmp = dat[i].first;\n\t  for ( int j = i; j < i+cnt; j++ ) dat.erase(dat.begin()+i);\n\t  dat.insert(dat.begin()+i, P(tmp, sum));\t  \n\t  break;\n\t}\n      }\n      if ( !flag ) {\n\tma--;\n      }\n\t\t    \n      if ( dat.size() == 1 ) break;\n    }\n\n    //cout << \"end\" << endl;\n    cout << dat[0].second << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nvoid solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        st.push(make_pair(th, l-1));\n    }\n}\nint main(){\n    while(cin>>n,n){\n        while(ope.size())ope.pop();\n        while(st.size())st.pop();\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    solve(level);\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        solve(0);\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n\nusing namespace std;\n\n\nint add(vector<string>::iterator &itr);\nint mlt(vector<string>::iterator &itr);\n\nint main(){\n    while(true){\n        int n; cin >> n;\n        if( n == 0)break;\n        vector<string> s(n);\n        for(int i = 0; i < n; i++){\n            cin >> s[i];\n        }\n        int ans = 0;\n        for(auto itr = s.begin(); itr != s.end(); ++itr){\n            if(itr->back() == '+'){\n                ans += add(itr);\n            }\n            else if(itr->back() == '*'){\n                ans += mlt(itr);\n            }\n            else{\n                ans += itr->back() - '0';\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\nint add(vector<string>::iterator &itr){\n    int c = itr->size()+1;\n    int ret = 0;\n    ++itr;\n    while(itr->size() == c){\n        if(itr->back() == '+'){\n            ret += add(itr);\n        }\n        else if(itr->back() == '*'){\n            ret += mlt(itr);\n        }\n        else{\n            ret += itr->back() -'0';\n        }\n        ++itr;\n    }\n        \n    --itr;\n    return ret;\n}\n\nint mlt(vector<string>::iterator &itr){\n    int c = itr->size();\n    int ret = 1;\n    ++itr;\n    while(itr->size() == c+1){\n        if(itr->back() == '+'){\n            ret *= add(itr);\n        }\n        else if(itr->back() == '*'){\n            ret *= mlt(itr);\n        }\n        else{\n            ret *= itr->back() - '0';\n        }\n        ++itr;\n    }\n    --itr;\n    return ret;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n\nusing namespace std;\n\nint line;\nvector<string> S;\nenum Operator { add, mul };\n\nint cnt(string s){\n    int ret=0;\n    for(auto c:s){\n        if(c=='.') ret++;\n        else break;\n    }\n    return ret;\n}\n\nint dfs(int depth){\n    string s=S[line];\n    if(isdigit(s[depth])){\n        return s[depth]-'0';\n    }else{\n        int ret;\n        if(s[depth]=='+'){\n            ret=0;\n            while(line+1<S.size()&&cnt(S[line+1])==depth+1){\n                line++;\n                ret+=dfs(depth+1);\n            }\n        }else if(s[depth]=='*'){\n            ret=1;\n            while(line+1<S.size()&&cnt(S[line+1])==depth+1){\n                line++;\n                ret*=dfs(depth+1);\n            }\n        }else{\n            cout<<\"error\"<<endl;\n            exit(1);\n        }\n        return ret;\n    }\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        S.clear();\n        line=0;\n        for(int i=0;i<n;i++){\n            string s;\n            cin>>s;\n            S.push_back(s);\n        }\n        cout<<dfs(0)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\nstruct CLASSNUM{\n  char op;\n  vector<int> num;\n};\n\nint main(){\n  int n,j;\n  string str;\n  CLASSNUM classNum[9];\n  while(true){\n    cin >> n;\n    if(n == 0) break;\n    for(int i = 0; i < n; i++){\n      cin >> str;\n\n      j = 0;\n      while(str[j] == '.'){\n        j++;\n      }\n\n      if(j!=0) str = str.substr(j,1);\n\n      if(str == \"+\") classNum[j].op = '+';\n      else if(str == \"*\")classNum[j].op = '*';\n      else{\n        classNum[j].num.push_back(atoi(str.c_str()));\n      }\n    }\n    for(int i=8; i >= 1; i--){\n      if(classNum[i].num.size() == 0) continue;\n      else{\n        int sum;\n        if(classNum[i].num.size() >= 1 && classNum[i-1].op == '+') {\n          sum = 0;\n          for(int k = 0; k < classNum[i].num.size(); k++){\n            sum += classNum[i].num[k];\n          }\n          classNum[i-1].num.push_back(sum);\n        }\n        else if(classNum[i].num.size() >= 1 && classNum[i-1].op == '*') {\n          sum = 1;\n          for(int k = 0; k < classNum[i].num.size(); k++){\n            sum *= classNum[i].num[k];\n          }\n          classNum[i-1].num.push_back(sum);\n        }\n      }\n    }\n    cout << classNum[0].num[0] << endl;\n    for(int i = 0; i < 8; i++) classNum[i].num.clear();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi acos(-1.0)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint calc(vector<string> s, int &i){\n\tint depth = s[i].length();\n\tchar c = s[i][depth-1];\n\tif (c == '+'){\n\t\tint res = 0;\n\t\twhile (s[++i].length() == depth+1){\n\t\t\tres += calc(s, i);\n\t\t}\n\t\ti--;\n\t\treturn res;\n\t}else if (c == '*'){\n\t\tint res = 1;\n\t\twhile (s[++i].length() == depth+1){\n\t\t\tres *= calc(s, i);\n\t\t}\n\t\ti--;\n\t\treturn res;\n\t}else{\n\t\treturn c - '0';\n\t}\n}\n\nint main(){\n\tint n;\n\twhile (cin >> n && n){\n\t\tvector<string> s(n);\n\t\tREP(i,n) cin >> s[i];\n\t\tint i = 0;\n\t\tcout << calc(s, i) << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\n  int n;\n  while(cin >> n,n){\n    int i,j,k;\n    string buf;\n    int d[50]={};\n    for(i=0;i<n;i++){\n      cin >> buf;\n      d[i]=buf.size();\n    }\n    for(i=0;i<n;i++){\n      int c=0;\n      j=i;\n      while(c<5) c+=d[j++];\n      if(c!=5) continue;\n      c=0;\n      while(c<7) c+=d[j++];\n      if(c!=7) continue;\n      c=0;\n      while(c<5) c+=d[j++];\n      if(c!=5) continue;\n      c=0;while(c<7) c+=d[j++];\n      if(c!=7) continue;\n      c=0;\n      while(c<7) c+=d[j++];\n      if(c!=7) continue;\n      c=0;\n      cout << i+1 << endl;\n      break;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nvs v;\n\nint dfs(int &line, int depth) {\n  if (v[line][depth] == '+') {\n    int x = 0;\n    line++;\n    while (v[line].size() > depth + 1) x += dfs(line, depth + 1);\n    return x;\n  }\n  if (v[line][depth] == '*') {\n    int x = 1;\n    line++;\n    while (v[line].size() > depth + 1) x *= dfs(line, depth + 1);\n    return x;\n  }\n  return v[line++][depth] - '0';\n}\n\nmain {\n  int n;\n  while (cin >> n, n) {\n    v.assign(n + 1, \"\");\n    rep(i, n) cin >> v[i];\n    int line = 0;\n    cout << dfs(line, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <iomanip>\n#include <stack>\n#include <fstream>\n#include <cstdint>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <functional>\n\nusing namespace std;\n\nconstexpr int INF = 1000000000;/* 1e+9a */\nconstexpr int MODULO = 1000000007;\n\ntypedef int64_t ll;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while(cin >> n){\n        if(n == 0)\n            break;\n        stack<char> op;\n        map<int, stack<int>> num;\n        int cd = 0;\n        int ans = 0;\n        char ch;\n        for (int i = 0; i < n; ++i) {\n            int d = 0;\n            while(cin >> ch){\n                if(ch != '.') break;\n                else d++;\n            }\n\n            while(cd > d){\n                char opc = op.top();\n                op.pop();\n                function<int(int, int)> operato = multiplies<int>();\n                int res = 1;\n                if(opc == '+') {\n                    operato = plus<int>();\n                    res = 0;\n                }\n                auto&& cdstack = num[cd];\n                while(!cdstack.empty()){\n                    res = operato(res, cdstack.top());\n                    cdstack.pop();\n                }\n                cd--;\n                num[cd].push(res);\n//                cerr << cd << \": \" << res << '\\n';\n            }\n\n            if(ch == '+') op.push('+'), cd++;\n            else if(ch == '*') op.push('*'), cd++;\n            else num[d].push(ch - '0');\n        }\n        while(cd > 0){\n            char opc = op.top();\n            op.pop();\n            function<int(int, int)> operato = multiplies<int>();\n            int res = 1;\n            if(opc == '+') {\n                operato = plus<int>();\n                res = 0;\n            }\n            auto&& cdstack = num[cd];\n            while(!cdstack.empty()){\n                res = operato(res, cdstack.top());\n                cdstack.pop();\n            }\n            cd--;\n            num[cd].push(res);\n//            cerr << cd << \": \" << res << '\\n';\n        }\n        cout << num[0].top() << endl;\n        num[0].pop();\n\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint n; char s[20][20];\nint solve(int l, int r, int d) {\n\tif (r - l == 1) return s[l][d] - 48;\n\tint ret = (s[l][d] == '+' ? 0 : 1);\n\tint prev = -1;\n\tfor (int i = l + 1; i < r; i++) {\n\t\tif (s[i][d + 1] != '.') {\n\t\t\tif (prev != -1) ret = (s[l][d] == '+' ? ret + solve(prev, i, d + 1) : ret * solve(prev, i, d + 1));\n\t\t\tprev = i;\n\t\t}\n\t}\n\treturn (s[l][d] == '+' ? ret + solve(prev, r, d + 1) : ret * solve(prev, r, d + 1));\n}\nint main() {\n\twhile (scanf(\"%d\", &n), n) {\n\t\tfor (int i = 0; i < n; i++) scanf(\"%s\", s[i]);\n\t\tprintf(\"%d\\n\", solve(0, n, 0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> vec;\nint num;\n\nint calcu(){\n\tint a = vec[num].size()-1;\n\tint b;\n\tint result;\n\tbool flag;\n\tstring s = vec[num];\n\tif(s[a] == '+'){\n\t\tresult = 0;\n\t\tflag = true;\n\t}\n\telse if(s[a] == '*'){\n\t\tresult = 1;\n\t\tflag = false;\n\t}\n\telse{\n\t\tstringstream ss;\n\t\tss << s[a];\n\t\tss >> b;\n\t\treturn b;\n\t}\n\tnum++;\n\twhile(1){\n\t\tif(num >= vec.size())break;\n\t\ts = vec[num];\n\t\tif(s.size() == a+2){\n\t\t\tif(s[a+1] == '*' || s[a+1] == '+'){\n\t\t\t\tif(flag)result += calcu();\n\t\t\t\telse if(!flag)result *= calcu();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstringstream ss;\n\t\t\t\tss << s[a+1];\n\t\t\t\tss >> b;\n\t\t\t\tif(flag)result += b;\n\t\t\t\telse if(!flag)result *= b;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\telse break;\n\t}\n\treturn result;\n}\n\nint main(){\n\tint n;\n\tstring s;\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0)break;\n\t\tvec.clear();\n\t\tnum = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin >> s;\n\t\t\tvec.push_back(s);\n\t\t}\n\t\tcout << calcu() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<sstream>\nusing namespace std;\ntypedef long long ll;\nstring i2s(ll x){\n  if(x==0) return \"0\";\n  string y;\n  ll k=1;\n  while(x>=k) k*=10;\n  k/=10;\n  for(ll i=k;i>0;i/=10){\n    y+=(x/i)%10+'0';\n  }\n  return y;\n}\nll s2i(string x){\n  for(ll i=0;i<x.size();i++) if(x[i]=='.') x[i]=' ';\n  stringstream ss(x);\n  ll y;\n  ss >> y;\n  return y;\n}\nint main(){\n  //cout << i2s(100) << endl;\n  ll n;\n \n  while(cin>>n,n){\n    string buf;\n    vector<string> v;\n    vector<ll> d;\n    ll i,j,k;\n    for(i=0;i<n;i++){\n      cin >> buf;\n      j=0;\n      while(buf[j]=='.') j++;\n      v.push_back(buf);\n      d.push_back(j);\n    }\n    while(v.size()!=1){\n      //for(i=0;i<v.size();i++) cout << v[i] << endl;\n      //cout << endl;\n      //cout << v.size() << endl;\n      k=1;\n      for(i=0;i<v.size();i++){\n        if(d[k]<d[i]) k=i;\n      }\n      //cout << k << \":\" << v[k-1][v[k-1].size()-1] << endl;\n      if(v[k-1][v[k-1].size()-1]=='+'){\n        i=0;j=0;\n        while(1) {\n          if(d[k]!=d[k+i]) break;\n          //j*=(v[k+i][v[k+i].size()-1]-'0');\n          j+=s2i(v[k+i]);\n          i++;\n          if(k+i==d.size()) break;\n        }\n        //cout << i << \":\" << j << endl;\n        v[k-1]=v[k-1].substr(0,v[k-1].size()-1);\n        v[k-1]+=i2s(j);\n        v.erase(v.begin()+k,v.begin()+k+i);\n        d.erase(d.begin()+k,d.begin()+k+i);\n      }\n      if(v[k-1][v[k-1].size()-1]=='*'){\n        i=0;j=1;\n        while(1) {\n          if(d[k]!=d[k+i]) break;\n          //j*=(v[k+i][v[k+i].size()-1]-'0');\n          j*=s2i(v[k+i]);\n          i++;\n          if(k+i==d.size()) break;\n        }\n        //cout << i << endl;\n        v[k-1]=v[k-1].substr(0,v[k-1].size()-1);\n        v[k-1]+=i2s(j);\n        v.erase(v.begin()+k,v.begin()+k+i);\n        d.erase(d.begin()+k,d.begin()+k+i);\n      }\n       \n    }\n    cout << v[0] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nvector<string> form;\n\nint dfs(int line,int level){\n  if(isdigit(form[line][level]))return (int)form[line][level]-'0';\n  char op=form[line][level];\n  int res=(op=='*'?1:0);\n  repl(i,line+1,n){\n    if(form[i][level]!='.')break;\n    if(form[i][level+1]=='.')continue;\n    int tmp=dfs(i,level+1);\n    res=(op=='*'?res*tmp:res+tmp);\n  }\n  return res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    form.clear();\n    rep(i,n){\n      string s;\n      cin>>s;\n      form.pb(s);\n    }\n    cout<<dfs(0,0)<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nstring form[33];\n\nint dfs(int line,int level){\n  //dbg(line); dbg(level);\n  if(isdigit(form[line][level]))return (int)form[line][level]-'0';\n  char op=form[line][level];\n  int res=(op=='*'?1:0);\n  repl(i,line+1,n){\n    if(form[i][level]!='.')break;\n    if(form[i][level+1]=='.')continue;\n    int tmp=dfs(i,level+1);\n    res=(op=='*'?res*tmp:res+tmp);\n  }\n  //dbg(res);\n  return res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    rep(i,n)cin>>form[i];\n    cout<<dfs(0,0)<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<sstream>\nusing namespace std;\nstring i2s(int x){\n  string y;\n  int k=1;\n  while(x>=k) k*=10;\n  k/=10;\n  for(int i=k;i>0;i/=10){\n    y+=(x/i)%10+'0';\n  }\n  return y;\n}\nint s2i(string x){\n  for(int i=0;i<x.size();i++) if(x[i]=='.') x[i]=' ';\n  stringstream ss(x);\n  int y;\n  ss >> y;\n  return y;\n}\nint main(){\n  //cout << i2s(100) << endl;\n  int n;\n\n  while(cin>>n,n){\n    string buf;\n    vector<string> v;\n    vector<int> d;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> buf;\n      j=0;\n      while(buf[j]=='.') j++;\n      v.push_back(buf);\n      d.push_back(j);\n    }\n    while(v.size()!=1){\n      //for(i=0;i<v.size();i++) cout << v[i] << endl;\n      //cout << endl;\n      //cout << v.size() << endl;\n      k=1;\n      for(i=0;i<v.size();i++){\n        if(d[k]<d[i]) k=i;\n      }\n      //cout << k << \":\" << v[k-1][v[k-1].size()-1] << endl;\n      if(v[k-1][v[k-1].size()-1]=='+'){\n        i=0;j=0;\n        while(d[k]==d[k+i]) {\n          //j+=v[k+i][v[k+i].size()-1]-'0';\n          j+=s2i(v[k+i]);\n          i++;\n        }\n        //cout << c << endl;\n        v[k-1]=v[k-1].substr(0,v[k-1].size()-1);\n        v[k-1]+=i2s(j);\n        v.erase(v.begin()+k,v.begin()+k+i);\n        d.erase(d.begin()+k,d.begin()+k+i);\n      }\n      if(v[k-1][v[k-1].size()-1]=='*'){\n        i=0;j=1;\n        while(d[k]==d[k+i]) {\n          //j*=(v[k+i][v[k+i].size()-1]-'0');\n          j*=s2i(v[k+i]);\n          i++;\n        }\n        v[k-1]=v[k-1].substr(0,v[k-1].size()-1);\n        v[k-1]+=i2s(j);\n        v.erase(v.begin()+k,v.begin()+k+i);\n        d.erase(d.begin()+k,d.begin()+k+i);\n      }\n      \n    }\n    cout << v[0] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n, idx;\nvector<string> s;\n\nint calc(int dep) {\n  if (isdigit(s[idx][dep])) {\n    return s[idx++][dep] - '0';\n  } else {\n    char op = s[idx++][dep];\n    int res = (op == '*');\n    while (s[idx].length() > dep + 1) {\n      res = (op == '*') ? res * calc(dep + 1) : res + calc(dep + 1);\n    }\n    return res;\n  }\n}\n\nint main() {\n  while (cin >> n, n) {\n    idx = 0;\n    s = vector<string>(n + 1);\n    for (int i = 0; i < n; ++i) cin >> s[i];\n    s[n] = \"\";\n    cout << calc(0) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "def inp():\n\tglobal n\n\tn = int(input())\n\treturn n\ndef strinp():\n\tl = 0\n\ts = list(input())\n\tfor i in s:\n\t\tif i == '.':\n\t\t\tl += 1\n\t\telse:\n\t\t\tc = i\n\treturn [l,c]\ndef calc(p):\n\tglobal f\n\tl = f[p][0]\n\tc = f[p][1]\n\tp += 1\n\tif c == '+':\n\t\tans = 0\n\t\tfor i in range(p,n):\n\t\t\tif f[i][0] == l:\n\t\t\t\tbreak\n\t\t\telif f[i][0] == l+1:\n\t\t\t\tans += calc(i)\n\telif c == '*':\n\t\tans = 1\n\t\tfor i in range(p,n):\n\t\t\tif f[i][0] == l:\n\t\t\t\tbreak\n\t\t\telif f[i][0] == l+1:\n\t\t\t\tans *= calc(i)\n\telse:\n\t\tans = int(c)\n\treturn ans\n\nwhile inp() > 0:\n\tf = []\n\tfor i in range(n):\n\t\tf.append(strinp())\n\tprint(calc(0))\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nusing namespace std;\nint a=0;\nvector<string>sts;\nvector<int>ens;\nint getnum(){\n  if(sts[a]==\"*\"){\n    int num=1;\n    int pe=ens[a+1];\n    a++;\n    while(a!=sts.size()&&ens[a]==pe){\n      num*=getnum();\n    }\n    return num;\n  }\n    else if(sts[a]==\"+\"){\n      int num=0;\n      int pe=ens[a+1];\n      a++;\n      while(a!=sts.size()&&ens[a]==pe){\n\tnum+=getnum();\n      }\n      return num;\n    }else{\n      int num=stoi(sts[a]);\n      a++;\n      return num;\n    }\n}\nint main()\n{\n  while(1){\n    int n;cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;++i){\n      string st;cin>>st;\n      int n=st.find_first_not_of(\".\");\n      sts.push_back(st.substr(n));\n      ens.push_back(n);\n      // cout<<sts[i]<<\" \"<<ens[i]<<endl;\n    }\n    int ans=getnum();\n    cout<<ans<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint n;\nchar buff[100][100];\n\nint calc(int line) {\n\tchar c;\n\tint level, val, arg;\n\tlevel = strlen(buff[line]) - 1;\n\tc = buff[line][level];\n\tswitch(c){\n\tcase'*':\n\t\tline++;\n\t\tval = 1;\n\t\twhile (1){\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval *= arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tcase'+':\n\t\tline++;\n\t\tval = 0;\n\t\twhile (1) {\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval += arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tdefault:\n\t\treturn c;\n\t\tbreak;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%s\", buff[i][0]);\n\t\t\tprintf(\"%d\\n\", calc(0));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main()\n{\n  int n;\n  string s;\n  char c[40][40];\n  ll num[40][40];\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n\n    for(int i=0;i<40;i++){\n      for(int j=0;j<40;j++){\n\tc[i][j]='.';\n\tnum[i][j]=-1;\n      }\n    }\n    for(int i=0;i<n;i++){\n      cin>>s;\n      for(int j=0;j<s.length();j++){\n\tc[i][j]=s[j];\n\tif('0'<=s[j] && s[j]<='9')num[i][j]=s[j]-'0';\n      }\n    }\n      vector<int> v;\n    for(int j=39;j>=1;j--){\n      for(int i=n-1;i>=1;i--){\n\tif(num[i][j]!=-1)v.push_back(num[i][j]);\n\tif(c[i-1][j-1]=='+'){\n\t  ll sum=0;\n\t  for(int k=0;k<v.size();k++)sum+=v[k];\n\t  num[i-1][j-1]=sum;\n\t  v.clear();\n\t}\n\tif(c[i-1][j-1]=='*'){\n\t  ll sum=1;\n\t  for(int k=0;k<v.size();k++)sum*=v[k];\n\t  num[i-1][j-1]=sum;\n\t  v.clear();\n\t}\n      }\n    }\n    cout<<num[0][0]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// region template\n#define rep(i, a, b) for (int i = (a); i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nll gcd(ll a, ll b) { return __gcd(a, b); }\n\nll euclid(ll a, ll b, ll &x, ll &y) {\n    if (b) {\n        ll d = euclid(b, a % b, y, x);\n        return y -= a / b * x, d;\n    }\n    return x = 1, y = 0, a;\n}\n\ntypedef unsigned long long ull;\ntypedef long double ld;\null mod_mul(ull a, ull b, ull M) {\n    ll ret = a * b - M * ull(ld(a) * ld(b) / ld(M));\n    return ret + M * (ret < 0) - M * (ret >= (ll)M);\n}\null mod_pow(ull b, ull e, ull mod) {\n    ull ans = 1;\n    for (; e; b = mod_mul(b, b, mod), e /= 2)\n        if (e & 1)\n            ans = mod_mul(ans, b, mod);\n    return ans;\n}\n\nconst ll mod = 1000000007;\nstruct Mod {\n    ll x;\n    Mod(ll xx) : x(xx) {}\n    Mod operator+(Mod b) { return Mod((x + b.x) % mod); }\n    Mod operator-(Mod b) { return Mod((x - b.x) % mod); }\n    Mod operator*(Mod b) { return Mod((x * b.x) % mod); }\n    Mod operator/(Mod b) { return *this * invert(b); }\n    Mod invert(Mod a) {\n        ll x, y, g = euclid(a.x, mod, x, y);\n        assert(g == 1);\n        return Mod((x + mod) % mod);\n    }\n    Mod operator^(ll e) {\n        if (!e)\n            return Mod(1);\n        Mod r = *this ^ (e / 2);\n        r = r * r;\n        return e & 1 ? *this * r : r;\n    }\n};\n// endregion\n\nstruct Expr {\n    char val;\n    vector<Expr> childs;\n    int eval() {\n        if (isdigit(val)) return val - '0';\n        int n = childs.size();\n        vector<int> v(n);\n        rep(i, 0, n) v[i] = childs[i].eval();\n        int rv;\n        if (val == '+') {\n            rv = 0;\n            rep(i, 0, n) rv += v[i];\n        } else if (val == '*') {\n            rv = 1;\n            rep(i, 0, n) rv *= v[i];\n        } else {\n            printf(\"PANIC\\n\");\n            exit(1);\n        }\n        return rv;\n    }\n    void out() const {\n        cerr << \"(\" << val;\n        if (childs.size()) cerr << \" \";\n        for (const auto &e : childs) e.out();\n        cerr << \")\";\n    }\n};\n\nExpr gen(list<string> &lst, int depth = 1) {\n    // cout << depth << endl;\n\n    if (isdigit(lst.front().back())) {\n        char v = lst.front().back(); lst.pop_front();\n        return Expr {v, {}};\n    }\n\n    Expr e {lst.front().back(), {}};\n    lst.pop_front();\n    while (lst.size() && lst.front().length() > depth) {\n        e.childs.push_back(gen(lst, depth + 1));\n    }\n    return e;\n}\n\nint main() {\n    for (;;) {\n        int n; cin >> n; if (!n) break;\n        list<string> lst;\n        rep(i, 0, n) {\n            string s; cin >> s; lst.push_back(s);\n        }\n        Expr e = gen(lst);\n        // e.out(); cerr << endl;\n        cout << e.eval() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\n#ifdef __linux\n#define _U(s) s##_unlocked\n#else\n#define _U(s) _##s##_nolock\n#define _CRT_DISABLE_PERFCRIT_LOCKS\n#endif\n#define gcu _U(getchar)\n#define pcu _U(putchar)\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n#define _OP(t) inline operator t()\nstruct _in {\n#ifdef _GLIBCXX_STRING\n\t_OP(string){string s;char c;while(isspace(c = gcu()));do{s+=c;}while(c=gcu(),c!=' '&&c!='\\n'&&c!=EOF);return s;}\n#define _S\n#endif\n\t_OP(char){char c=gcu();gcu();return c;}\n\t_OP(double){double d; scanf(\"%lf\",&d); gcu();return d;}\n\t_T _OP(T){T n{},m{1},c;while(isspace(c = gcu()));if(c=='-')m=-1,c=gcu();do{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n} in;\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n#ifdef _S\n_SCAN(string &o) {int c{gcu()};if(c==EOF)return false;else{ungetc(c,stdin);string t=move(in);o=t;return true;}}\n#endif\n_T _SCAN(T &o) {int c{gcu()};return c==EOF?false:(ungetc(c,stdin),o=in,true);}\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);}\n_OUT(const char *s){while(*s)pcu(*s++);}\n_OUT(char c){pcu(c);}\n#ifdef _S\n_OUT(string &s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n\t_T _OUT(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n_HT _OUT(H &&h, T... t){out(h);out(t...);}\ntemplate <typename... T> _OUTL(T... t){out(t...);outl();}\n#define dbg(...) fprintf(stderr,__VA_ARGS__)\nstruct range{\n\tint e,b=0,s=1;range(int b,int e,int s):e(e),b(b),s(s){} range(int b,int e): e(e), b(b){} range(int e):e(e){}\n\tstruct it{int v,s; it(int v,int s):v(v),s(s){} operator int()const{return v;} operator int&(){return v;}int operator*()const{return v;}\n\t\tit& operator++(){v+=s;return *this;} }; it begin(){return {b,s};} it end(){return {e,s};}};\n#define times(i,n) for(int i=n;i;i--)\n\n_T using V = vector<T>;\nstruct P {\n\tint n, c;\n};\n\nint main() {\n\tfor (int n; (n = in);) {\n\t\tV<P> v(n);\n\t\tint m {};\n\t\tfor (int i: range(n - 1, -1, -1)) {\n\t\t\tP &t = v[i];\n\t\t\twhile ((t.c = gcu()) == '.')\n\t\t\t\tt.n++;\n\t\t\tm = max(m, t.n);\n\t\t\tgcu();\n\t\t}\n\t\tV<V<int>> s(m + 1);\n\t\tfor (auto i: v) {\n\t\t\tint a;\n\t\t\tif (isdigit(i.c))\n\t\t\t\ta = i.c - '0';\n\t\t\telse {\n\t\t\t\ta = i.c == '*';\n\t\t\t\tauto o = i.c == '*' ? [](int a, int b) {return a * b;} : [](int a, int b) {return a + b;};\n\t\t\t\tfor (int j: s[i.n + 1])\n\t\t\t\t\ta = o(a, j);\n\t\t\t\ts[i.n + 1] = {};\n\t\t\t}\n\t\t\ts[i.n].push_back(a);\n\t\t}\n\t\toutl(s[0]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nint add(vector<string>::iterator &itr);\nint mlt(vector<string>::iterator &itr);\n\nint main(){\n    while(true){\n        int n; cin >> n;\n        if( n == 0)break;\n        vector<string> s(n);\n        for(int i = 0; i < n; i++){\n            cin >> s[i];\n        }\n        int ans = 0;\n        for(auto itr = s.begin(); itr != s.end(); ++itr){\n            if((itr->back()) == '+'){\n                ans += add(itr);\n            }\n            else if((itr->back()) == '*'){\n                ans += mlt(itr);\n            }\n            else{\n                ans += itr->back() - '0';\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\nint add(vector<string>::iterator &itr){\n    int c = itr->size()+1;\n    int ret = 0;\n    ++itr;\n    while((int)(itr->size()) == c){\n        if(itr->back() == '+'){\n            ret += add(itr);\n        }\n        else if((itr->back()) == '*'){\n            ret += mlt(itr);\n        }\n        else{\n            ret += itr->back() -'0';\n        }\n        ++itr;\n    }\n        \n    --itr;\n    return ret;\n}\n\nint mlt(vector<string>::iterator &itr){\n    int c = itr->size();\n    int ret = 1;\n    ++itr;\n    while((int)(itr->size()) == c+1){\n        if(itr->back() == '+'){\n            ret *= add(itr);\n        }\n        else if((char)(itr->back()) == '*'){\n            ret *= mlt(itr);\n        }\n        else{\n            ret *= itr->back() - '0';\n        }\n        ++itr;\n    }\n    --itr;\n    return ret;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi acos(-1.0)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint calc(vector<string> s, int &i){\n\tint depth = s[i].length(), n = s.size();\n\tchar c = s[i][depth-1];\n\tif (c == '+'){\n\t\tint res = 0;\n\t\ti++;\n\t\twhile (s[i].length() == depth+1 && i < n){\n\t\t\tres += calc(s, i);\n\t\t}\n\t\treturn res;\n\t}else if (c == '*'){\n\t\tint res = 1;\n\t\ti++;\n\t\twhile (s[i].length() == depth+1 && i < n){\n\t\t\tres *= calc(s, i);\n\t\t}\n\t\treturn res;\n\t}else{\n\t\ti++;\n\t\treturn c - '0';\n\t}\n}\n\nint main(){\n\tint n;\n\tifstream ifs(\"in.txt\");\n\twhile (cin >> n && n){\n\t\tvector<string> s(n+1);\n\t\tREP(i,n) cin >> s[i];\n\t\tint i = 0;\n\t\tcout << calc(s, i) << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// macro\n#define rep(i,n) for(i=0;i<n;i++)\n#define ll long long\n#define all(v) v.begin(), v.end()\n\n// code starts\nint main()\n{\n\tint n;cin>>n;\n  while(n!=0)\n  {\n    int i;\n    vector<int> dots(n);\n    vector<int> mark(n);\n    rep(i,n)\n    {\n      string s;\n      cin>>s;\n      dots[i]=s.size()-1;\n      char back=s[s.size()-1];\n      if(back=='+')mark[i]=-1;\n      else if(back=='*')mark[i]=-2;\n      else mark[i]=back-'0';\n    }\n    int lmax=-1;\n    int lind=0;\n    rep(i,n)\n    {\n      if(dots[i]>lmax)\n      {\n        lmax=dots[i];\n        lind=i;\n      }\n    }\n    while(lmax>0)\n    {\n      if(mark[lind-1]==-1)\n      {\n        int now=lind;\n        int num=0;\n        while(now<dots.size()&&dots[now]==dots[lind-1]+1)\n        {\n          num+=mark[now];\n          mark.erase(mark.begin()+now);\n          dots.erase(dots.begin()+now);\n        }\n        mark[lind-1]=num;\n      }\n      else if(mark[lind-1]==-2)\n      {\n        int now=lind;\n        int num=1;\n        while(now<dots.size()&&dots[now]==dots[lind-1]+1)\n        {\n          num*=mark[now];\n          mark.erase(mark.begin()+now);\n          dots.erase(dots.begin()+now);\n        }\n        mark[lind-1]=num;\n      }\n      lmax=-1;\n      lind=0;\n      rep(i,dots.size())\n      {\n        if(dots[i]>lmax)\n        {\n          lmax=dots[i];\n          lind=i;\n        }\n      }\n    }\n    cout<<mark[0]<<endl;\n    cin>>n;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint n;\nvector< pair<int, int> > input;\n\nint dfs(int p) {\n  int t = input[p].first + 1;\n  char e = (char) input[p].second;\n  int ans;\n\n  if(e == '+') ans = 0;\n  if(e == '*') ans = 1;\n  if(e != '+' && e != '*') return e;\n\n  for(int i = p + 1; input[i].first >= t; i++) {\n    if(input[i].first > t) continue;\n\n    int v;\n    if(input[i].second == '+' || input[i].second == '*') v = dfs(i);\n    else v = input[i].second;\n\n    if(e == '+') ans += v;\n    if(e == '*') ans *= v;\n  }\n\n  return ans;\n}\n\nint main(void) {\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n\n    input.clear();\n    REP(i, 0, n) {\n      string line; cin >> line;\n      int level = 0;\n      for(; line[level] == '.'; level++);\n      char c = line[level];\n      input.push_back(pair<int, int>(level, c == '+' || c == '*' ? c : c - '0'));\n    }\n\n    cout << dfs(0) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring str[101];\nint n,idx=0;\n\nint cal(char ch,int a,int b){\n  if(ch=='*') return a*b;\n  return a+b;\n}\n\nint get_cnt(string a){\n  int res=0;\n  while(a[res]=='.')res++;\n  return res;\n}\n\nint dfs(){\n  int cnt=get_cnt(str[idx]);\n  char ch=str[idx][cnt];\n  if(isdigit(ch))return str[idx++][cnt]-'0';\n  int res =(ch=='*');\n  idx++;\n  while(idx<n&&get_cnt(str[idx])>=cnt+1)res=cal(ch,res,dfs());\n  return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++) cin>>str[i];\n    idx=0;\n    cout <<dfs()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            return 0;\n        }\n\n        vector<string> v;\n        for (int i = 0; i < n; ++i) {\n            string s;\n            cin >> s;\n            v.push_back(s);\n        }\n\n        enum class T {\n            N, // numeric\n            S, // sum\n            P  // product\n        };\n\n        auto parse = [](const string& s) {\n            int nest = 0;\n            for (int i = 0; i < s.size(); ++i) {\n                if (s[i] != '.') {\n                    nest = i;\n                    break;\n                }\n            }\n            if (s[nest] == '*') {\n                return make_tuple(nest, T::P, 0);\n            }\n            else if (s[nest] == '+') {\n                return make_tuple(nest, T::S, 0);\n            }\n            return make_tuple(nest, T::N, stoi(s.substr(nest)));\n        };\n\n        unordered_map<int, vector<int>> xs;\n        unordered_map<int, T> ops;\n        int max_ = 0;\n        for (auto&& i : v) {\n            int l;\n            T t;\n            int x;\n            tie(l, t, x) = parse(i);\n            if (t == T::N) {\n                xs[l].push_back(x);\n            }\n            else {\n                ops[l] = t;\n            }\n            max_ = max(max_, l);\n        }\n\n        for (int i = max_; i >= 0; --i) {\n            int r = 0;\n            if (ops.find(i - 1) == end(ops)) {\n                break;\n            }\n            else if (ops[i - 1] == T::P) {\n                r = accumulate(begin(xs[i]), end(xs[i]), 1, multiplies<>());\n            }\n            else {\n                r = accumulate(begin(xs[i]), end(xs[i]), 0);\n            }\n            xs[i - 1].push_back(r);\n        }\n        cout << xs[0][0] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mux_n = 2000;\n\nenum _operator{\n    _plus,\n    multiply,\n    none\n};\n\nvoid En_route_culc(vector<_operator>& level_ope,vector<vector<long long int> >& level_num,int min_level, int max_level ){\n    int now_level = max_level;\n    while(min_level < now_level){\n        if(level_ope[now_level-1] != none){\n            long long int sum;\n            if(level_ope[now_level-1] == _plus){\n                sum = 0;\n                for(int i=0; i<level_num[now_level].size(); i++){\n                    sum += level_num[now_level][i];\n                }\n            }\n            else if(level_ope[now_level-1] == multiply){\n                sum = 1;\n                for(int i=0; i<level_num[now_level].size(); i++){\n                    sum *= level_num[now_level][i];\n                }\n            }\n            if(now_level == 1) {\n            }\n            else{\n                level_num[now_level-1].push_back(sum);\n            }\n        }\n        now_level--;\n    }\n}\n\nint main() {\n\n    ofstream ofs(\"out.txt\");\n\n    while(1){\n\n        int n;\n\n        cin >> n;\n\n        if(n==0) break;\n\n        string input[n];\n\n        vector<vector<long long int> > level_num;\n        vector<_operator> level_ope;\n\n        level_num.resize(mux_n);\n\n\n        for(int i=0; i<mux_n; i++){\n            level_ope.push_back(none);\n        }\n\n        int max_level = 0;\n\n        for(int i=0; i<n; i++){\n            cin >> input[i];\n            for(int j=0; j<input[i].size(); j++){\n                if(input[i][j] == '+'){\n                    if(level_ope[j] != none){\n                        En_route_culc(level_ope,level_num,j,max_level);\n                        //level_num[j].push_back(tmpsum);\n                        for(int k=max_level; j<k; k--) {\n                            while (!level_num[k].empty()) {\n                                level_num[k].pop_back();\n                            }\n                        }\n                        /*while(!level_num[j+1].empty()){\n                            level_num[j+1].pop_back();\n                        }*/\n                    }\n                    level_ope[j] = _plus;\n                }\n                else if(input[i][j] == '*'){\n                    if(level_ope[j] != none){\n                        En_route_culc(level_ope,level_num,j,max_level);\n                        //level_num[j].push_back(tmpsum);\n                        for(int k=max_level; j<k; k--) {\n                            while (!level_num[k].empty()) {\n                                level_num[k].pop_back();\n                            }\n                        }\n                    }\n                    level_ope[j] = multiply;\n                }\n                else if(input[i][j] != '.'){\n                    string string_now_input_num;\n                    for(int k=j; k<input[i].size(); k++){\n                        string_now_input_num.push_back(input[i][k]);\n                    }\n                    stringstream ss;\n                    ss << string_now_input_num;\n                    int input_num;\n                    ss >> input_num;\n                    level_num[j].push_back(input_num);\n                }\n                max_level = max(max_level,j);\n            }\n        }\n\n        long long int ans = 0;\n        int now_level = max_level;\n\n        while(now_level){\n            if(level_ope[now_level-1] != none){\n                long long int sum;\n                if(level_ope[now_level-1] == _plus){\n                    sum = 0;\n                    for(int i=0; i<level_num[now_level].size(); i++){\n                        sum += level_num[now_level][i];\n                    }\n                }\n                else if(level_ope[now_level-1] == multiply){\n                    sum = 1;\n                    for(int i=0; i<level_num[now_level].size(); i++){\n                        sum *= level_num[now_level][i];\n                    }\n                }\n                if(now_level == 1) {\n                    ans = sum;\n                }\n                else{\n                    level_num[now_level-1].push_back(sum);\n                }\n            }\n            now_level--;\n        }\n\n        if(n == 1){\n            ans = level_num[0][0];\n        }\n\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n\nint solve(vector<string> &s,int n,int &y,int x){\n    if(isdigit(s[y][x])) return s[y][x] - '0';\n    if(s[y][x] == '+'){\n        int term = 0;\n        while(y+1 < n && s[y+1][x] == '.'){\n            y++;\n            term += solve(s,n,y,x+1);\n        }\n        return term;\n    }else{\n        int term = 1;\n        while(y+1 < n && s[y+1][x] == '.'){\n            y++;\n            term *= solve(s,n,y,x+1);\n        }\n        return term;\n    }\n}\n\nint main(void){\n    int n;\n    while(cin>>n,n){\n        vector<string> s(n);\n        rep(i,n) cin>>s[i];\n        int y = 0;\n        cout<<solve(s,n,y,0)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<iomanip>\n#include<string>\n#include<fstream>\nusing namespace std;\n\nint main(){\n  //std::ifstream in(\"test.txt\");\n  //  std::cin.rdbuf(in.rdbuf());\n  int n;\n  while(1){\n    cin >> n;\n    if(n==0)return 0;\n    string inp;\n    int op[n];\n    int num[n];\n    int nowl=0;\n    int chop=0;\n    for(int i=0;i<n;i++){\n      cin >> inp;\n      int level=0;\n      while(inp[level]=='.'){\n\tlevel++;\n      }\n      if(inp[level]=='+'){\n\top[level]=1;\n\tchop=1;\n      }else if(inp[level]=='*'){\n\top[level]=2;\n\tchop=2;\n      }else{\n\tif(n==1){num[0]=(int)inp[level]-48;break;}\n\tchop=0;\n\tif(op[level-1]==1){\n\t  num[level-1]+=inp[level]-48;\n\t}else{\n\t  num[level-1]*=inp[level]-48;\n\t}\n      }\n      if((chop==0 && nowl<=level)||(chop>0 && nowl <=level )||i==n-1 ){\n\tif(i==n-1)level=1;\n\tfor(int k=nowl;k>=level;k--){\n\t  if(op[k-1]==1){\n\t    num[k-1]+=num[k];\n\t  }else{\n\t    num[k-1]*=num[k];\n\t  }\n\t}\n      }\n      if(chop>0){\n\tnowl=level;\n\tnum[level]=chop-1;\n      }\n      // cout << num[nowl]<<endl;\n\t\n      \n    }\n    cout << num[0] << endl;\n  }\n\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cmath>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define FOR(i,a,b) for (int i=(a),for_##i##_max=(b);i<=(for_##i##_max);++i)\n#define RFOR(i,a,b) for (int i=(a),rfor_##i##_min=(b);i>=(rfor_##i##_min);--i)\n#define REP(i,n) for (int i=0,rep_##i##_len=(n);i<(rep_##i##_len);++i)\n#define RREP(i,n) for (int i=(n)-1;i>=0;--i)\n\nnamespace { // Basics\n\ntemplate<typename T>\nvoid chmin(T &x, T y) {\n  x = std::min(x, y);\n}\n\ntemplate<typename T>\nvoid chmax(T &x, T y) {\n  x = std::max(x, y);\n}\n\ntemplate<typename T>\n__attribute__((unused))\nconst auto minimum = static_cast<T const &(*)(T const &, T const &)>(std::min);\n\ntemplate<typename T>\n__attribute__((unused))\nconst auto maximum = static_cast<T const &(*)(T const &, T const &)>(std::max);\n\ntemplate<typename T>\n__attribute__((unused))\nT constexpr infty = std::numeric_limits<T>::max / 3;\ntemplate<>\n__attribute__((unused))\nauto constexpr infty<int> = 1'100'100'100;\ntemplate<>\n__attribute__((unused))\nauto constexpr infty<long long int> = 100'500'400'300'200'100LL;\n\nusing lli = long long int;\nusing ld = long double;\n\n} // namespace\n\nusing namespace std;\n\nvoid solve(vector<string> const &rows) {\n  stack<tuple<int,int>> stk;\n  for (auto &&row : rows) {\n    int const level = row.length() - 1;\n    char const cmd = row.back();\n    if (isdigit(cmd)) {\n      stk.emplace(level, cmd-'0');\n    } else if (cmd == '+') {\n      int sum = 0;\n      while (!stk.empty() && get<0>(stk.top()) == level + 1) {\n        sum += get<1>(stk.top());\n        stk.pop();\n      }\n      stk.emplace(level, sum);\n    } else {\n      assert(cmd == '*');\n      int product = 1;\n      while (!stk.empty() && get<0>(stk.top()) == level + 1) {\n        product *= get<1>(stk.top());\n        stk.pop();\n      }\n      stk.emplace(level, product);\n    }\n  }\n  cout << get<1>(stk.top()) << endl;\n}\n\nint main() {\n  // cout << fixed << setprecision(10);\n  int n;\n  while (cin >> n && n > 0) {\n    vector<string> rows;\n    REP(i, n) {\n      string row; cin >> row;\n      rows.push_back(row);\n    }\n    reverse(begin(rows), end(rows));\n    solve(rows);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint main(void){\n    for(int n; cin >> n, n;){\n        vector<vi> table(30);\n        vector<char> ops(30);\n        int depth = 0;\n\n        vector<string> ins(n);\n        for(auto & e : ins) cin >> e;\n        ins.push_back(\"_\");\n\n        for(auto & in : ins){\n            int cd = in.size() - 1;\n\n            while(depth > cd){\n                int len = table[depth].size();\n                int cur = table[depth][0];\n\n                if(ops[depth - 1] == '+'){\n                    rep(i, 1, len){\n                        cur += table[depth][i];\n                    }\n                }\n                else {\n                    rep(i, 1, len){\n                        cur *= table[depth][i];\n                    }\n                }\n\n                table[depth - 1].push_back(cur);\n                depth--;\n            }\n\n            depth = cd;\n\n            char c = in.back();\n            if('0' <= c and c <= '9'){\n                table[depth].push_back(c - '0');\n            }\n            else {\n                ops[depth] = c;\n                table[depth + 1] = {};\n            }\n        }\n\n        cout << table[0][0] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = long long int;\nusing ui64 = unsigned long long int;\n\n////////\n\nusing pic = pair<int,char>;\n#define mp make_pair\nusing psic = pair<stack<int>,char >;\n\npic parse(string &s){\n    return make_pair(s.length()-1,s[s.length()-1]);\n}\n\nvoid calc(deque<psic> &q, int lv){\n    while(q.size() > lv){\n        psic p = q.back();\n        \n        q.pop_back();\n        // cerr << q.size() << \" \" << p.second << endl;\n        if(p.second == '+'){\n            int ret = 0;\n            while(!p.first.empty()){\n                ret += p.first.top();\n                p.first.pop();\n            }\n            q.back().first.push(ret);\n        }\n        else if(p.second == '*'){\n            int ret = 1;\n            while(!p.first.empty()){\n                ret *= p.first.top();\n                p.first.pop();\n            }\n            q.back().first.push(ret);\n        }else assert(false);\n    }\n}\n\nint solve(deque<psic> &q){\n    calc(q,1);\n    psic p = q[0];\n    if(p.second == '+'){\n        int ret = 0;\n        while(!p.first.empty()){\n            ret += p.first.top();\n            p.first.pop();\n        }\n        return ret;\n    }\n    else if(p.second == '*'){\n        int ret = 1;\n        while(!p.first.empty()){\n            ret *= p.first.top();\n            p.first.pop();\n        }\n        return ret;\n    }else assert(false);\n}\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        int curlv = 0;\n        deque< psic > q;\n        q.push_back(mp(stack<int>(),'+'));\n\n        for(int i=0;i<n;i++){\n            string s;\n            cin >> s;\n            \n            pic ps = parse(s);\n            // cerr << ps.first << \" \" << ps.second << endl;\n            if(ps.first < curlv){\n                calc(q,ps.first + 1);\n                curlv = ps.first;\n                if(ps.second == '+' || ps.second == '*'){\n                    psic ne;\n                    ne.second = ps.second;\n                    q.push_back(ne);\n                    curlv++;\n                } \n                else{\n                    q.back().first.push(((int)(ps.second-'0')));\n                }\n            }\n            else if(ps.first == curlv){\n                if(ps.second == '+' || ps.second == '*'){\n                    psic ne;\n                    ne.second = ps.second;\n                    q.push_back(ne);\n                    curlv++;\n                } \n                else{\n                    q.back().first.push(((int)(ps.second-'0')));\n                }\n            }else assert(false);\n        }\n        cout << solve(q) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nint dfs(string s[25], int n, int y, int x) {\n    //cout << y << ' ' << x << endl;;\n    if(isdigit(s[y][x])){\n        return s[y][x] - '0';\n    }else if(s[y][x] == '.'){\n        return 0;\n    }else{\n        int res;\n        //show(s[y][x])\n        if(s[y][x] == '+'){\n            res = 0;\n            range(i,y + 1,n){\n                //cout << i << ' ' << x + 1 << endl;\n                if(x + 1 >= s[i].size()) break;\n                res += dfs(s,n,i,x + 1);\n            }\n        }else{\n            res = 1;\n            range(i,y + 1,n){\n                if(x + 1 >= s[i].size()) break;\n                int tmp = dfs(s,n,i,x + 1);\n                res *= tmp == 0 ? 1 : tmp;\n            }\n        }\n        //show(res)\n        return res;\n    }\n    assert(0);\n    return 0;\n}\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        string s[25];\n        rep(i,n) cin >> s[i];\n        cout << dfs(s,n,0,0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solver {\npublic:\n\tstatic void solve() {\n\t\tint n;\n\t\tcin >> n;\n\t\tvector<int> res;\n\t\twhile (n > 0) {\n\t\t\tvector<string> s;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tstring c;\n\t\t\t\tcin >> c;\n\t\t\t\ts.push_back(c);\n\t\t\t}\t\t\t\n\t\t\tres.push_back(DFS(s));\n\t\t\tcin >> n;\n\t\t}\n\n\t\tfor (int i = 0; i < res.size(); i++)cout << res[i] << endl;\n\t}\n\n\tstatic int DFS(vector<string> s) {\n\t\tif (s[0][0] == '+')\ts.push_back(\".0\");\n\t\telse if (s[0][0] == '*') s.push_back(\".1\");\n\t\telse return s[0][0] - '0';\n\n\t\tint val = s[0][0] == '+' ? 0 : 1;\n\t\tvector<string> sTemp;\n\t\tfor (int i = 1; i < s.size(); i++) {\n\t\t\tif (s[i][0] == '.'\n\t\t\t\t&& s[i][1]!='.') {\n\t\t\t\tif (s[0][0] == '+') {\n\t\t\t\t\tif (sTemp.size() > 0)val += DFS(sTemp);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (sTemp.size() > 0)val *= DFS(sTemp);\n\t\t\t\t}\n\t\t\t\tsTemp.clear();\n\t\t\t}\n\t\t\tsTemp.push_back(s[i].substr(1, s[i].size() - 1));\n\t\t}\n\n\t\treturn val;\n\t}\n};\n\nint main() {\n\tSolver::solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstring s[999];int n;\nbool check(string s,int l)\n{\n\tif(s.size()<=l)return 0;\n\tbool ok=1;\n\tfor(int i=0;i<l;i++)ok&=s[i]=='.';\n\treturn ok&&s[l]!='.';\n}\nint f(int r,int l,int level)\n{\n\tint first=r+1;\n\tstring a=s[r];\n\tbool A;\n\tif(a[level]>='0'&&a[level]<='9')\n\t{\n\t\treturn a[level]-'0';\n\t}\n\telse A=a[level]=='*';\n\tint ret=A?1:0;\n\tfor(int i=r+2;i<=l;i++)\n\t{\n\t\tif(check(s[i],level+1))\n\t\t{\n\t\t\tint now=f(first,i-1,level+1);\n\t\t\tret=A?ret*now:ret+now;\n\t\t\tfirst=i;\n\t\t}\n\t}\n\tint now=f(first,l,level+1);\n\tret=A?ret*now:ret+now;\n\treturn ret;\n}\nmain()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tfor(int i=0;i<n;i++)cin>>s[i];\n\t\tcout<<f(0,n-1,0)<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n\n#define f first\n#define s second\n#define pb push_back\n\n#define rep(i, n) for(ll i = 0; i < n; i++)\n\nconst char *inputFile = \"input.txt\";\nifstream ifs(inputFile);\nconst char *outputFile = \"output.txt\";\nofstream ofs(outputFile);\n\nll solve(vector<pair<ll, ll>> A){\n  if(A.size() == 1) return A[0].s;\n  ll res;\n  if(A[0].s == -1){\n    res = 0;\n    ll Rank = A[0].f;\n    for(int i = 1; i < A.size(); i++){\n      if(A[i].s >= 0 && A[i].f == Rank + 1) res += A[i].s;\n      else{\n        vector<pair<ll,ll>> P;\n        while(true){\n          P.pb(A[i]);\n          if(i+1 == A.size()) break;\n          if(A[i+1].f <= Rank + 1) break;\n          i++;\n        }\n        res += solve(P);\n      }\n    }\n  }else{\n    res = 1;\n    ll Rank = A[0].f;\n    for(int i = 1; i < A.size(); i++){\n      if(A[i].s >= 0 && A[i].f == Rank + 1) res *= A[i].s;\n      else{\n        vector<pair<ll, ll>> P;\n        while(true){\n          P.pb(A[i]);\n          if(i+1 == A.size()) break;\n          if(A[i+1].f <= Rank + 1) break;\n          i++;\n        }\n        res *= solve(P);\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(true){\n    ll N; cin >> N;\n    if(N == 0) return 0;\n    vector<pair<ll, ll>> A(N);\n    rep(i, N){\n      string S; cin >> S;\n      ll cnt = 0;\n      rep(j, S.size()){\n        if(S[j] != '.'){\n          if(S[j] == '+') A[i].s = -1;\n          else if(S[j] == '*') A[i].s = -2;\n          else A[i].s = S[j] - '0';\n        }\n        else{\n          cnt++;\n        }\n      }\n      A[i].f = cnt;\n    }\n    cout << solve(A) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstring s[100];\npair<int, char> p[100];\nint n;\nint add(int&, int);\nint mul(int&, int);\n\nint add(int& idx, int par) {\n  // cout << idx << \" \" << p[idx].second << \" add\" << endl;\n  int ret = 0;\n  while(idx < n) {\n    // cout << idx << \" \" << p[idx].first << \" \" << p[idx-1].first << endl;\n    if(p[idx].first <= par) {\n      break;\n    } else if(p[idx].second == '+') {\n      idx++;\n      ret += add(idx, p[idx-1].first);\n    } else if(p[idx].second == '*') {\n      idx++;\n      ret += mul(idx, p[idx-1].first);\n    } else {\n      ret += p[idx].second - '0';\n      idx++;\n    }\n  }\n  return ret;\n}\n\nint mul(int &idx, int par) {\n  // cout << idx << \" \" << p[idx].second << \" mul\" << endl;\n  int ret = 1;\n  while(idx < n) {\n    // cout << idx << \" \" << p[idx].first << \" \" << p[idx-1].first << endl;\n    if(p[idx].first <= par) {\n      break;\n    } else if(p[idx].second == '+') {\n      idx++;\n      ret *= add(idx, p[idx].first);\n    } else if(p[idx].second == '*') {\n      idx++;\n      ret *= mul(idx, p[idx].first);\n    } else {\n      ret *= p[idx].second - '0';\n      idx++;\n    }\n  }\n  return ret;\n}\n\nsigned main(void)\n{\n  while(true) {\n    cin >> n;\n    if(!n) break;\n    REP(i, n) cin >> s[i];\n\n    REP(i, n) p[i].first = 0;\n    REP(i, n) {\n      REP(j, s[i].size()) {\n        if(s[i][j] == '.') p[i].first++;\n        else p[i].second = s[i][j];\n      }\n    }\n    if(n == 1) {\n      cout << p[0].second << endl;\n      continue;\n    }\n\n    int ret;\n    if(p[0].second == '+') {\n      int st = 1;\n      ret = add(st, 0);\n    } else {\n      int st = 1;\n      ret = mul(st, 0);\n    }\n\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<string.h>\n#include<stdio.h>\nusing namespace std;\nint suma(int d);\nint a;\nchar s[100000];\nint t(int d){\n  int ans=1;\n  cin>>s;\n  a--;\n  while(a>=0){\n    if(strlen(s)<d)\n      break;\n    if(s[d-1]=='*')\n      ans*=t(d+1);\n    else if(s[d-1]=='+')\n      ans*=suma(d+1);\n    else{\n      ans*=s[d-1]-'0';\n      if(a==0)\n        break;\n      cin>>s;\n      a--;\n    }\n  }\n  return ans;\n}\n\nint suma(int d){\n  int ans=0;\n  a--;\n  cin>>s;\n  while(a>=0){\n    if(strlen(s)<d)\n      break;\n    if(s[d-1]=='*')\n      ans+=t(d+1);\n    else if(s[d-1]=='+')\n      ans+=suma(d+1);\n    else{\n      if(strlen(s)!=d)\n        break;\n      ans+=s[d-1]-'0';\n      if(a==0)\n        break;\n      cin>>s;\n      a--;\n    }\n  }\n  return ans;\n}\n\nint main(){\n  int n;\n  while(1){\n    cin>>s;\n    if(strlen(s)==1&&s[0]=='0')\n      break;\n    n=strlen(s);\n    a=0;\n    for(int i=0;i<n;i++){\n      a*=10;\n      a+=s[i]-'0';\n    }\n    a--;\n    cin>>s;\n    if(s[0]=='+')\n      cout<<suma(2)<<endl;\n    else if(s[0]=='*')\n      cout<<t(2)<<endl;\n    else\n      cout<<s<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint n,row;\nvector<string> str;\n\nint operand(int level) {\n    int answer = 0;\n    switch (str[row][level]) {\n        case '+':\n            row++,level++;\n            answer = 0;\n            while (row < n) {\n                if (str[row][level-1] != '.') break;\n                answer += operand(level);\n            }\n            break;\n\n        case '*':\n            row++,level++;\n            answer = 1;\n            while (row < n) {\n                if (str[row][level-1] != '.') break;\n                answer *= operand(level);\n            }\n            break;\n\n        default: answer = stoi(str[row].substr(level)); row++;\n    }\n    return answer;\n}\n\nint main() {\n    while (cin>>n && n != 0) {\n        row = 0;\n        str = vector<string>(n);\n        for (int i = 0; i < n; i++) cin>>str[i];\n        cout<<operand(0)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\n\nint a[100]={};\n\nint  solve(int n,int d,int x,vector<string> v){\n\tint ans;\n\tint sousa;\n\tfor(int i=x;i<n;i++){\n\t\tif(v[i].size()==d){\n\t\t\tsousa = a[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(sousa==10){\n\t\tans = 0;\n\t}else{\n\t\tans = 1;\n\t}\n\tfor(int i=x+1;i<n;i++){\n\t\tif(v[i].size()<d+1){\n\t\t\tbreak;\n\t\t}\n\t\tif(v[i].size()==d+1){\n\t\t\tif(sousa==10){\n\t\t\t\tif(a[i]<=9){\n\t\t\t\t\tans +=a[i];\n\t\t\t\t}else{\t\t\n\t\t\t\t\tans +=solve(n,d+1,i,v);\n\t\t\t\t}\n\t\t\t}else if(sousa==20){\n\t\t\t\tif(a[i]<=9){\n\t\t\t\t\tans *=a[i];\n\t\t\t\t}else{\n\t\t\t\t\tans *=solve(n,d+1,i,v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n>0){\n\t\tvector<string> v(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> v[i];\n\t\t}\n\t\tif(n==1){\n\t\t\tcout << v[0] << endl;\n\t\t}else{\n\t\t\tint x =1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(v[i][v[i].size()-1]=='+'){\n\t\t\t\t\ta[i] = 10;\n\t\t\t\t}else if(v[i][v[i].size()-1]=='*'){\n\t\t\t\t\ta[i] = 20;\n\t\t\t\t}else{\n\t\t\t\t\ta[i] = v[i][v[i].size()-1]-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = solve(n,1,0,v);\n\t\t\tcout << ans <<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n\nusing namespace std;\n\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//四捨五入\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り上げ\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define SUM_P(v, w) partial_sum((v).begin(), (v).end(), (w).begin())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define FOUT_L(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n        T d = EXTGCD(-a, b, x, y);\n        x = -x;\n        return d;\n    }\n    if (b < 0) {\n        T d = EXTGCD(a, -b, x, y);\n        y = -y;\n        return d;\n    }\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    } else {\n        T d = EXTGCD(b, a % b, x, y);\n        T t = x;\n        x = y;\n        y = t - (a / b) * y;\n        return d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T) (SQR(i)) < b; i++) {\n        if (small[i]) {\n            for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n                prime[j - a] = false;\n            }\n        }\n    }\n\n    return prime;\n}\n\n//約数\ntemplate<class T>\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//組み合わせ個数\ntemplate<typename T>\nT NCR(T n, T r) {\n    T ans = 1;\n    REPLL(i, r) {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//行列\nint MATRIZ_CHAIN(VI &p, VVI &s) {\n    const static int INF = 1 << 20;\n    const int n = p.size() - 1;\n    VVI X(n, VI(n, INF));\n    s.resize(n, VI(n));\n    for (int i = 0; i < n; ++i) X[i][i] = 0;\n    for (int w = 1; w < n; ++w)\n        for (int i = 0, j; j = i + w, j < n; ++i)\n            for (int k = i; k < j; ++k) {\n                int f = p[i] * p[k + 1] * p[j + 1];\n                if (X[i][k] + X[k + 1][j] + f < X[i][j]) {\n                    X[i][j] = X[i][k] + X[k + 1][j] + f;\n                    s[i][j] = k;\n                }\n            }\n    return X[0][n - 1];\n}\n\n//最長増加部分列\nVI LIS(const VI &a) {\n    const static int INF = 99999999;\n    const int n = a.size();\n    VI A(n, INF);\n    VI id(n);\n    for (int i = 0; i < n; ++i) {\n        id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n        A[id[i]] = a[i];\n    }\n    int m = *max_element(id.begin(), id.end());\n    VI b(m + 1);\n    for (int i = n - 1; i >= 0; --i)\n        if (id[i] == m) b[m--] = a[i];\n    return b;\n}\n\n//最長共通部分列 string->toVC\ntemplate<typename T>\nvector<T> LCS(const vector<T> &a, const vector<T> &b) {\n    const int n = a.size(), m = b.size();\n    vector<VI> X(n + 1, VI(m + 1));\n    vector<VI> Y(n + 1, VI(m + 1));\n    REP(i, n) {\n        REP(j, m) {\n            if (a[i] == b[j]) {\n                X[i + 1][j + 1] = X[i][j] + 1;\n                Y[i + 1][j + 1] = 0;\n            } else if (X[i + 1][j] < X[i][j + 1]) {\n                X[i + 1][j + 1] = X[i][j + 1];\n                Y[i + 1][j + 1] = +1;\n            } else {\n                X[i + 1][j + 1] = X[i + 1][j];\n                Y[i + 1][j + 1] = -1;\n            }\n        }\n    }\n    vector<T> c;\n    for (int i = n, j = m; i > 0 && j > 0;) {\n        if (Y[i][j] > 0) --i;\n        else if (Y[i][j] < 0) --j;\n        else {\n            c.PB(a[i - 1]);\n            --i;\n            --j;\n        }\n    }\n    REVERSE(c);\n    return c;\n}\n\n//コイン C総額 cs使用できるコインの種類\nVI money_change(int C, VI &cs) {\n    const int INF = 99999999;\n    int n = cs.size();\n    VI xs(C + 1, INF);\n    VI ys(C + 1);\n    xs[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int c = 0; c + cs[i] <= C; ++c) {\n            if (xs[c + cs[i]] > xs[c] + 1) {\n                xs[c + cs[i]] = xs[c] + 1;\n                ys[c + cs[i]] = c;\n            }\n        }\n    }\n    VI zs;\n    for (int c = C; c > 0; c = ys[c]) {\n        zs.push_back(c - ys[c]);\n    }\n    return zs;\n}\n\n\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(a, b) memset((a), (b),sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n * */\n\nint add(int& index, int N, int par, vector<pair<int, char>> P);\n\nint mul(int& index, int N, int par, vector<pair<int, char>> P);\n\nint add(int& index, int N, int par, vector<pair<int, char>> P) {\n    int ret = 0;\n    while (index < N) {\n        if (P[index].first <= par) {\n            break;\n        } else if (P[index].second == '+') {\n            index++;\n            ret += add(index, N, P[index - 1].first, P);\n        } else if (P[index].second == '*') {\n            index++;\n            ret += mul(index, N, P[index - 1].first, P);\n        } else {\n            ret += P[index].second - '0';\n            index++;\n        }\n    }\n\n    return ret;\n}\n\nint mul(int& index, int N, int par, vector<pair<int, char>> P) {\n    int ret = 1;\n    while (index < N) {\n        if(P[index].first <=par){\n            break;\n        }else if(P[index].second == '+'){\n            index++;\n            ret *= add(index, N, P[index-1].first, P);\n        }else if(P[index].second =='*'){\n            index++;\n            ret *= mul(index, N, P[index-1].first, P);\n        }else{\n            ret *= P[index].second -'0';\n            index++;\n        }\n    }\n\n    return ret;\n\n}\n\nint main() {\n\n    int N;\n\n\n    while (true) {\n        cin >> N;\n\n        VS S(N);\n        vector<pair<int, char>> P(N);\n\n        if (N == 0) {\n            break;\n        }\n\n        REP(i, N) {\n            cin >> S[i];\n            P[i].first = 0;\n        }\n        REP(i, N) {\n            REP(j, S[i].size()) {\n                if (S[i][j] == '.') {\n                    P[i].first++;\n                } else {\n                    P[i].second = S[i][j];\n                }\n            }\n        }\n\n\n        if (N == 1) {\n            OUT_L(P[0].first);\n            continue;\n        }\n\n        int res;\n        if (P[0].second == '+') {\n            int start = 1;\n            res = add(start, N, 0, P);\n        } else {\n            int start = 1;\n            res = mul(start, N, 0, P);\n        }\n\n        OUT_L(res);\n\n    }\n\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100\nusing namespace std;\nstring s[N];\nint n,y;\n\nint dfs(int x){\n  int res;\n  if('0'<=s[y][x]&&s[y][x]<='9')\n    return s[y][x]-'0';\n  if(s[y][x]=='+'){\n    res=0;\n    while(x+2<=s[y+1].size())\n      y++,res+=dfs(x+1);\n  }\n  if(s[y][x]=='*'){\n    res=1;\n    while(x+2<=s[y+1].size())\n      y++,res*=dfs(x+1);\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++)\n      cin>>s[i];\n    y=0;\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\n \nint N;\nvector<pair<char, int>> v;\nint idx;\n\nint solve() {\n  int d = v[idx].first; char c = v[idx].second;\n  idx ++;\n  if(isdigit(c)) {\n    return c - '0';\n  } else {\n    int ret = c == '*';\n    while(idx < N && d < v[idx].first) {\n      if(c == '*')\n        ret *= solve();\n      if(c == '+')\n        ret += solve();\n    }\n    return ret;\n  }\n}\n\nint main() {\n   \n  while(cin >> N && N) {\n    v.clear();\n    rep(i, N) {\n      string s; cin >> s;\n      v.push_back({s.size() - 1, s.back()});\n    }\n     \n    idx = 0;\n    cout << solve() << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\nstruct CalcResult {\n\tint value;\n\tint next_line_index;\n};\n\nint get_depth(std::string& s) {\n\treturn s.size() - 1;\n}\n\nCalcResult calc(std::vector<std::string>& lines, int index) {\n\tstd::string& line = lines[index];\n\tint depth = get_depth(line);\n\tchar op = line[line.size() - 1];\n\n\tint result;\n\tint next_line_index = index + 1;\n\n\tswitch (op)\n\t{\n\tcase '+':\n\t\tresult = 0;\n\t\twhile (next_line_index < lines.size()) {\n\t\t\tint ndepth = get_depth(lines[next_line_index]);\n\t\t\tif (ndepth <= depth) break;\n\t\t\tCalcResult cr = calc(lines, next_line_index);\n\t\t\tresult += cr.value;\n\t\t\tnext_line_index = cr.next_line_index;\n\t\t}\n\t\tbreak;\n\tcase '*':\n\t\tresult = 1;\n\t\twhile (next_line_index < lines.size()) {\n\t\t\tint ndepth = get_depth(lines[next_line_index]);\n\t\t\tif (ndepth <= depth) break;\n\t\t\tCalcResult cr = calc(lines, next_line_index);\n\t\t\tresult *= cr.value;\n\t\t\tnext_line_index = cr.next_line_index;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tresult = op - '0';\n\t\tbreak;\n\t}\n\n\treturn { result, next_line_index };\n}\n\nint main()\n{\n\tstd::string line;\n\n\twhile (true) {\n\t\tint n;\n\t\t{\n\t\t\tstd::getline(std::cin, line);\n\t\t\tstd::istringstream ss(line);\n\t\t\tss >> n;\n\t\t}\n\n\t\tif (n == 0) return 0;\n\n\t\tstd::vector<std::string> lines;\n\t\tlines.reserve(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstd::getline(std::cin, line);\n\t\t\tlines.push_back(line); // copy\n\t\t}\n\n\t\tstd::cout << calc(lines, 0).value << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint n;\nchar buff[17][10];\n\nint calc(int line) {\n\tchar c;\n\tint level, val, arg;\n\tlevel = strlen(buff[line]) - 1;\n\tc = buff[line][level];\n\tswitch(c){\n\tcase'*':\n\t\tline++;\n\t\tval = 1;\n\t\twhile (1){\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval *= arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tcase'+':\n\t\tline++;\n\t\tval = 0;\n\t\twhile (1) {\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval += arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tdefault:\n\t\treturn c-'0';\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%s\", buff[i][0]);\n\t\t\tprintf(\"%d\\n\", calc(0));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <tuple>\n\nusing namespace std;\n\nint N;\nvector<string> S;\nint itr = 0;\n\npair<int, char> parse(string s) {\n\tint dot;\n\tfor(dot = 0; s[dot] == '.'; ++dot);\n\treturn make_pair(dot, s.back());\n}\n\nint add(int);\n\nint mul(int depth) {\n\tint ret = 1;\n\n\twhile (itr < N) {\n\t\tint dot;\n\t\tchar sig;\n\t\ttie(dot, sig) = parse(S[itr]);\n\t\tif (dot < depth) break;\n\n\t\t++itr;\n\t\tint res = 0;\n\t\tif (sig == '+') {\n\t\t\tres = add(depth + 1);\n\t\t} else if (sig == '*') {\n\t\t\tres = mul(depth + 1);\n\t\t} else {\n\t\t\tres = sig - '0';\n\t\t}\n\n\t\tret *= res;\n\t\t\n\t}\n\n\treturn ret;\n}\n\nint add(int depth) {\n\tint ret = 0;\n\n\twhile (itr < N) {\n\t\tint dot;\n\t\tchar sig;\n\t\ttie(dot, sig) = parse(S[itr]);\n\t\tif (dot < depth) break;\n\n\t\t++itr;\n\t\tint res = 0;\n\t\tif (sig == '+') {\n\t\t\tres = add(depth + 1);\n\t\t} else if (sig == '*') {\n\t\t\tres = mul(depth + 1);\n\t\t} else {\n\t\t\tres = sig - '0';\n\t\t}\n\n\t\tret += res;\n\t}\n\n\treturn ret;\n}\n\nbool solve() {\n\titr = 0;\n\tcin >> N;\n\tif (N == 0) return false;\n\n\tS.resize(N);\n\tfor(auto& s : S) cin >> s;\n\n\tcout << add(0) << endl;\n\treturn true;\n}\n\nint main() {\n\twhile (solve());\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst double PI  = 3.1415926535897932384626433832795028841971;\nconst int    INF = 100000000;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nstring str[50];\n\nint dfs(int dep, int st, int ope){\n\tint ret;\n\tif(ope == 0) ret = 0;\n\telse ret = 1;\n\tfor(int i = st; i < n; i++){\n\t\tint cnt = 0;\n\t\tchar tmp = str[i][str[i].size()-1];\n\t\trep(j,str[i].size()){\n\t\t\tif(str[i][j]=='.')cnt++;\n\t\t\telse break;\n\t\t}\n\t\tif(cnt < dep) break;\n\t\tif(cnt > dep) continue;\n\t\tif(0<=tmp-'0'&&tmp-'0'<=9){\n\t\t\tif(ope) ret = ret*(tmp-'0');\n\t\t\telse ret = ret+(tmp-'0');\n\t\t} else if(tmp == '+'){\n\t\t\tif(ope) ret = ret*dfs(dep+1,i+1,0);\n\t\t\telse ret = ret+dfs(dep+1,i+1,0);\n\t\t} else{\n\t\t\tif(ope)ret = ret*dfs(dep+1,i+1,1);\n\t\t\telse ret = ret+dfs(dep+1,i+1,1);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid solve(){\n\trep(i,n) cin >> str[i];\n\tcout << dfs(0,0,0) << endl;\n}\n\nint main(){\n\twhile(cin >> n){\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define rrep(i, st, n) for (int i = st; i < n; ++i)\nusing pii = pair<int, int>;\n#define ceil(a, b) a / b + !!(a % b)\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n\nvoid outs(stack<pii> s) {while (!s.empty()) {cout << s.top().first << \" \" << s.top().second << endl; s.pop();}}\nint main() {\n    int n;\n    while (cin >> n && n) {\n        vector<string> v;\n        stack<pii> s;\n        rep(i, n) {string s; cin >> s; v.push_back(s);}\n        for (int i = n - 1; i >= 0; --i) {\n            int c = 0;\n            while (v[i][c] == '.') c++;\n            char last = v[i][v[i].size() - 1];\n            if (0 <= last - '0' && last - '0' <= 9) {\n                s.push({c, last - '0'});\n            } else {\n                int ret = 0;\n                if (last == '*') ret = 1;\n                while (!s.empty()) {\n                    int dot = s.top().first, num = s.top().second;\n                    s.pop();\n                    //cout << dot << \" \" << num << endl;\n                    if (dot != c + 1) {\n                        s.push({dot, num});\n                        break;\n                    }\n                    if (last == '*') ret *= num;\n                    else ret += num;\n                }\n                s.push({c, ret});\n            }\n        }\n        cout << s.top().second << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n\n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nstring s[1024];\n\nint rec(int a,int b,int c){\n\tint res=0;\n\tif(c)res=1;\n\tfor(int i=a;i<n&&b<s[i].size();i++){\n\t\tcout<<i<<endl;\n\t\tif(s[i][b]=='.')continue;\n\t\tint x=s[i][b]-'0';\n\t\tif(s[i][b]=='*')x=rec(i+1,b+1,1);\n\t\tif(s[i][b]=='+')x=rec(i+1,b+1,0);\n\t\tif(c)res*=x;\n\t\telse res+=x;\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tREP(i,n)cin>>s[i];\n\t\tcout<<rec(0,0,0)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nint calc(char op, std::vector<int> xs) {\n\n\tswitch (op) {\n\tcase '+': {\n\t\tint v = xs.at(0);\n\t\tfor (int i = 1; i < xs.size(); i++) {\n\t\t\tv += xs.at(i);\n\t\t}\n\t\treturn v;\n\t}\n\tcase '*': {\n\t\tint v = xs.at(0);\n\t\tfor (int i = 1; i < xs.size(); i++) {\n\t\t\tv *= xs.at(i);\n\t\t}\n\t\treturn v;\n\t}\n\t}\n\n\treturn xs.at(0);\n}\n\nint main() {\n\twhile (true)\n\t{\n\t\tint n;\n\t\tstd::cin >> n;\n\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\n\t\tint depth = -1;\n\n\t\tstd::stack<char> ops;\n\t\tops.push(0);\n\t\tstd::stack<std::vector<int>> vstack;\n\n\t\tstd::vector<int> vs;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstd::string s;\n\t\t\tstd::cin >> s;\n\t\t\t\n\t\t\tint d = std::count(s.begin(), s.end(), '.');\n\t\t\ts = s.substr(d);\n\n\t\t\tif (d < depth) {\n\t\t\t\tfor (; depth != d; depth--) {\n\t\t\t\t\t\n\t\t\t\t\tint tmp = calc(ops.top(), vs);\n\t\t\t\t\tvs = vstack.top();\n\t\t\t\t\tvs.push_back(tmp);\n\t\t\t\t\tvstack.pop();\n\t\t\t\t\tops.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdepth = d;\n\n\t\t\ttry {\n\t\t\t\tint tmp = std::stoi(s);\n\t\t\t\tvs.push_back(tmp);\n\t\t\t}\n\t\t\tcatch (...) {\n\t\t\t\tops.push(s.at(0));\n\t\t\t\tvstack.push(vs);\n\t\t\t\tvs.clear();\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\n\t\tint v = 0;\n\t\twhile(true) {\n\t\t\t\n\t\t\tv = calc(ops.top(), vs);\n\t\t\tif (--depth <= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tops.pop();\n\t\t\tvs = vstack.top();\n\t\t\tvs.push_back(v);\n\t\t\tvstack.pop();\n\t\t}\n\t\tstd::cout << v << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nint N;\n\nint parse(string& line, int& num, char& op) {\n    REP(i, line.length()) {\n        if (line[i] != '.') {\n            if (isdigit(line[i])) {\n                num = line[i] - '0';\n            } else {\n                op = line[i];\n            }\n            return i;\n        }\n    }\n    assert(0);\n}\n\nint dfs(int& idx, int level, char op, vs& lines) {\n    int res = 0;\n    if (op == '*') res = 1;\n    for (; idx < N; idx++) {\n        int num = 0;\n        char c = 0;\n        int lv = parse(lines[idx], num, c);\n        if (lv != level) {\n            idx--;\n            break;\n        }\n        if (c != 0) {\n            idx++;\n            num = dfs(idx, lv+1, c, lines);\n        }\n        if (op == '+') {\n            res += num;\n        } else if (op == '*') {\n            res *= num;\n        }\n    }\n    return res;\n}\n\nint main() {\n    while (cin >> N, N) {\n        vs lines(N);\n        REP(i, N) cin >> lines[i];\n        int idx = 0;\n        cout << dfs(idx, 0, '+', lines) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\nusing namespace std;\nstatic const int MAX_N = 20;\n\nint n;\nstring s[MAX_N];\n\nint rec(int cur){\n\tchar ch = s[cur][s[cur].length() - 1];\n\tif(isdigit(ch)) return ch - '0';\n\tint ret;\n\tif(ch == '+') ret = 0;\n\telse ret = 1;\n\tfor(int i = cur + 1; i < n; i++){\n\t\tif(s[i].length() <= s[cur].length()) break;\n\t\tif(s[i].length() == s[cur].length() + 1){\n\t\t\tif(ch == '+') ret += rec(i);\n\t\t\telse ret *= rec(i);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tfor(;;){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\tfor(int i = 0; i < n; i++) cin >> s[i];\n\t\tprintf(\"%d\\n\", rec(0));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstddef>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <array>\n#include <unordered_map>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <valarray>\n#include <utility>\n#include <tuple>\n#include <cmath>\n#include <memory>\n#include <random>\n#include <fstream>\n#include <locale>\n\n#if (__cplusplus >= 201703L)\n#include <filesystem>\nnamespace fs = std::filesystem;\n#endif\n\n// boost\n//#define USE_BOOST_IN_CODE\n#ifdef USE_BOOST_IN_CODE\n#include <boost/range.hpp>\n#include <boost/range/algorithm.hpp>\n#include <boost/range/numeric.hpp>\n#include <boost/range/irange.hpp>\n#include <boost/range/adaptor/strided.hpp>\n#include <boost/range/adaptor/transformed.hpp>\n#include <boost/format.hpp>\n#endif\n\nnamespace {\n\n    using ll = long long;\n    using ull = unsigned long long;\n\n    //vector\n    template <class T>\n    using vec = std::vector<T>;\n\n    template <class T>\n    using vv = vec<vec<T>>;\n\n    constexpr std::size_t operator\"\"_sz(ull n) { return std::size_t (n); }\n        \n    template <class T, class BinaryOperation>\n    constexpr T fold(std::initializer_list<T> args, T init, BinaryOperation op)\n    {\n        return std::accumulate(args.begin(), args.end(), init, op);\n    }\n\n    // numeric_low\n    namespace numeric\n    {\n        template<typename T>\n        constexpr bool isOdd(T x)\n        {\n            return x % 2 != 0;\n        }\n\n        template<typename T>\n        constexpr bool isEven(T x)\n        {\n            return x % 2 == 0;\n        }\n\n        // 最大公約数\n        template<class T>\n        constexpr T gcd(const T x, const T y)\n        {\n            if (x < 0)return gcd(-x, y);\n            if (y < 0)return gcd(x, -y);\n            return (!y) ? x : gcd(y, x % y);\n        }\n\n        // 最小公倍数\n        template<class T>\n        constexpr T lcm(const T x, const T y)\n        {\n            if (x < 0)return lcm(-x, y);\n            if (y < 0)return lcm(x, -y);\n            return x * (y / gcd(x, y));\n        }\n\n        // 素数判定\n        template<class T>\n        constexpr bool isPrime(const T x)\n        {\n            if (x <= 1)return false;\n            for (T i = 2; i * i <= x; ++i)\n                if (x % i == 0)\n                    return false;\n            return true;\n        }\n    }\n\n    // ビット演算\n    namespace bitOp\n    {\n\n        template <int N>\n        constexpr std::size_t distanceBetween(const std::bitset<N> bit, std::size_t current, bool isNext = true)\n        {\n            if (current > N || current < 0) \n                return -1;\n            const int dir = isNext ? 1 : -1;\n            for (auto i = current + dir; i >= 0 && i < N; i += dir)\n                if (bit[i]) \n                    return (i - current) * dir;\n            return -1;\n        }\n\n        // 次の立っているビットまでの距離\n        template <int N>\n        constexpr std::size_t distanceBetweenNext(const std::bitset<N> bit, std::size_t current)\n        {\n            return distanceBetween(bit, current, true);\n        }\n\n        // 前の立っているビットまでの距離\n        template <int N>\n        constexpr std::size_t distanceBetweenPrev(const std::bitset<N> bit, std::size_t current)\n        {\n            return distanceBetween(bit, current, false);\n        }\n    }\n\n\n#ifdef _MSVC_LANG\n#pragma region Vector\n#endif\n    ///////////////////////////////////////////////////////////\n    // Vector\n\n    template <class T>\n    struct Vec3D\n    {\n        T x, y, z;\n\n        Vec3D() = default;\n\n        constexpr Vec3D(T x, T y, T z)\n            : x {x}, y {y}, z {z}\n        {}\n\n        constexpr Vec3D(T x, T y)\n            : Vec3D(x, y, 0)\n        {}\n\n        static constexpr T Dot(const Vec3D& lhs, const Vec3D& rhs)\n        {\n            return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;\n        }\n\n        static constexpr Vec3D Cross(const Vec3D& lhs, const Vec3D& rhs)\n        {\n            return {\n                lhs.y*rhs.z - lhs.z*rhs.y,\n                lhs.z*rhs.x - lhs.x*rhs.z,\n                lhs.x*rhs.y - lhs.y*rhs.x\n            };\n        }\n\n        constexpr T dot(const Vec3D& rhs) const\n        {\n            Dot(*this, rhs);\n        }\n\n        constexpr Vec3D cross(const Vec3D& rhs) const\n        {\n            Dot(*this, rhs);\n        }\n\n        T magnitude() const\n        {\n            return std::sqrt(sqrMagnitude());\n        }\n\n        constexpr T sqrMagnitude() const\n        {\n            return x * x + y * y + z * z;\n        }\n\n        Vec3D normalized() const\n        {\n            return *this / magnitude();\n        }\n\n        Vec3D normalize()\n        {\n            *this = normalized();\n            return *this;\n        }\n\n        constexpr bool isZero() const\n        {\n            return x == 0 && y == 0 && z == 0;\n        }\n\n        constexpr Vec3D operator+() const\n        {\n            return *this;\n        }\n\n        constexpr Vec3D operator-() const\n        {\n            return {-x, -y, -z};\n        }\n\n\n        constexpr Vec3D operator+(Vec3D rhs) const\n        {\n            return {x + rhs.x, y + rhs.y, z + rhs.z};\n        }\n\n        constexpr Vec3D operator-(Vec3D rhs) const\n        {\n            return {x - rhs.x, y - rhs.y, z - rhs.z};\n        }\n\n        template <class U>\n        constexpr Vec3D operator*(U rhs) const\n        {\n            return {x * rhs, y * rhs, z * rhs};\n        }\n\n        template <class U>\n        constexpr Vec3D operator/(U rhs) const\n        {\n            return {x / rhs, y / rhs, z / rhs};\n        }\n\n        constexpr Vec3D& operator+=(const Vec3D& other)\n        {\n            x += other.x;\n            y += other.y;\n            z += other.z;\n            return *this;\n        }\n\n        constexpr Vec3D& operator-=(const Vec3D& other)\n        {\n            x -= other.x;\n            y -= other.y;\n            z -= other.z;\n            return *this;\n        }\n\n        template <class U>\n        constexpr Vec3D& operator*=(U s)\n        {\n            x *= s;\n            y *= s;\n            z *= s;\n            return *this;\n        }\n\n        template <class U>\n        constexpr Vec3D& operator/=(U s)\n        {\n            x /= s;\n            y /= s;\n            z /= s;\n            return *this;\n        }\n\n    };\n\n    template<class T, class U>\n    inline constexpr Vec3D<T> operator*(U s, Vec3D<T> v)\n    {\n        return {s * v.x, s * v.y, s * v.z};\n    }\n\n    // Vector\n    ///////////////////////////////////////////////////////////\n#ifdef _MSVC_LANG\n#pragma endregion Vector\n#endif\n\n    // argsからハッシュ値を作成\n    template <class... Args>\n    std::size_t hash(Args... args)\n    {\n        return fold({static_cast<std::size_t>(args)...}, 0_sz,\n            [](std::size_t seed, std::size_t x)\n            {\n                // uses magic number from boost\n                return seed ^= x + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n            });\n    }\n\n    template <class Begin, class End>\n    void printAll(Begin beginIter, End endIter, std::string delimiter)\n    {\n        for (auto iter {beginIter}; iter != endIter; ++iter)\n        {\n            std::cout << *iter;\n            if (std::distance(iter, endIter) != 1)\n                std::cout << delimiter;\n        }\n    }\n\n    template <class Container>\n    void printAll(const Container& c, std::string delimiter)\n    {\n        printAll(std::cbegin(c), std::cend(c), delimiter);\n    }\n\n    template<class T>\n    void printAll(const std::initializer_list<T>& ini, std::string delimiter)\n    {\n        printAll(ini.begin(), ini.end(), delimiter);\n    }\n\n    //template <class Container>\n    //std::istream& operator>>(std::istream& is, Container& c)\n    //{\n    //    const auto end = std::end(c);\n    //    for (auto iter = std::begin(c); iter != end; ++iter)\n    //        is >> *iter;\n    //    return is;\n    //}\n    \n\n    using State = std::vector<std::string>::const_iterator;\n\n    std::pair<int, char> getInfo(State& iter, State& end)\n    {\n        using std::string;\n        int count {};\n\n        if (iter == end)\n            return {count, ' '};\n        \n        auto str = *iter;\n        for (; str[count] == '.'; ++count)\n            ;\n        return {count, str[count]};\n    }\n\n    int asInt(char c)\n    {\n        return c - '0';\n    }\n\n    int rec(State & iter, State end)\n    {\n        auto p = getInfo(iter, end);\n        int depth = p.first;\n        char op = p.second;\n\n        if (isdigit(op))\n            return asInt(op);\n        \n        int sum {};\n\n        std::function<int(int, int)> f;\n        if (op == '+')\n        {\n            f = std::plus<int>();\n        }\n        else if (op == '*')\n        {\n            f = std::multiplies<int>();\n            sum = 1;\n        }\n        else\n        {\n            return sum;\n        }\n\n        ++iter;\n\n        while (iter != end)\n        {\n            auto p2 = getInfo(iter, end);\n\n            if (p2.first == depth + 1)\n            {\n                sum = f(sum, rec(iter, end));\n                p2 = getInfo(iter, end);\n            }\n            if (p2.first < depth)\n                return sum;\n            else if (p2.first == depth)\n            {\n                --iter;\n                return sum;\n            }\n            \n            if (*iter == \" \")\n                break;\n            ++iter;\n        }\n\n        return sum;\n    }\n\n    void solve()\n    {\n        using namespace std;\n\n        while (true)\n        {\n            int n;\n            cin >> n;\n            cin.ignore();\n            if (n == 0)\n                break;\n\n            vec<string> v(n);\n            for (auto& x : v)\n                getline(cin, x);\n            v.push_back(\" \");\n\n            auto beg = v.cbegin();\n            auto end = v.cend();\n            cout << rec(beg, end) << endl;\n\n        }\n\n    }\n}\n\nint main()\n{\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint n; char s[20][20];\nint solve(int l, int r, int d) {\n\tif (r - l == 1) return s[l][d] - 48;\n\tint ret = (s[l][d] == '+' ? 0 : 1);\n\tint prev = -1;\n\tfor (int i = l + 1; i < r; i++) {\n\t\tif (s[i][d + 1] != '.') {\n\t\t\tif (prev != -1) {\n\t\t\t\tif (s[l][d] == '+') ret += solve(prev, i, d + 1);\n\t\t\t\telse ret *= solve(prev, i, d + 1);\n\t\t\t}\n\t\t\tprev = i;\n\t\t}\n\t}\n\tif (s[l][d] == '+') ret += solve(prev, r, d + 1);\n\telse ret *= solve(prev, r, d + 1);\n\treturn ret;\n}\nint main() {\n\twhile (scanf(\"%d\", &n), n) {\n\t\tfor (int i = 0; i < n; i++) scanf(\"%s\", s[i]);\n\t\tprintf(\"%d\\n\", solve(0, n, 0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<string> vs;\n\nint calc(vector<int>& v, bool plus){\n  // std::cout << \"calc:\" << std::endl;\n  // for (int i = 0; i < v.size(); i++) {\n  //   std::cout << v[i] << std::endl;\n  // }\n  int res = (plus != true);\n  for (int i = 0; i < v.size(); i++) {\n    if(plus)res += v[i];\n    else res *= v[i];\n  }\n  // std::cout << \"res:\" << res << std::endl;\n  // std::cout << std::endl;\n  return res;\n}\n\nint dfs(bool plus, int &s, int k = 0){\n  vector<int> res;\n  //std::cout << \"k:\" << k << \" plus:\" << plus<< std::endl;\n  for (;s < vs.size(); s++) {\n    //std::cout << vs[s] << std::endl;\n    if(vs[s][k] != '.'){\n      s--;\n      return calc(res, plus);\n    }else if(vs[s][k + 1] == '+' or vs[s][k + 1] == '*'){\n      int tmp = dfs(vs[s - 1][k + 1] == '+', ++s, k + 1);\n      res.emplace_back(tmp);\n    }else{\n      res.emplace_back(atoi(vs[s].substr(k + 1).c_str()));\n    }\n  }\n  // for (int i = 0; i < res.size(); i++) {\n  //   std::cout << res[i] << std::endl;\n  // }\n  return calc(res, plus);\n}\n\nint main(){\n  int n;\n  while(std::cin >> n, n){\n    vs.resize(n);\n    int maxi = 0;\n    for (int i = 0; i < n; i++) {\n      std::cin >> vs[i];\n      maxi = max(maxi, (int)vs[i].length());\n    }\n    for (int i = 0; i < n; i++) {\n      if(vs[i].length() < maxi)\n        vs[i] += string(maxi - vs[i].length(), 'o');\n    }\n    if(n == 1){\n      std::cout << vs[0] << std::endl;\n    }else{\n      int s = 0;\n      std::cout << dfs(vs[s - 1][0] == '+', ++s) << std::endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int n;\n    while (cin >> n)\n    {\n        if (!n)\n            return 0;\n        vector<string> v(n);\n        stack<pair<int, int>> st;\n        for (int i = 0; i < n; i++)\n        {\n            cin >> v[n - i - 1];\n        }\n        for (int i = 0; i < n; i++)\n        {\n            int cnt = 0;\n            int m = v[i].size();\n            for (int j = 0; j < m; j++)\n            {\n                if (v[i][j] == '.')\n                    cnt++;\n                else if (v[i][j] == '+')\n                {\n                    int x = cnt;\n                    int sum = 0;\n                    while (st.size() && x + 1 == st.top().second)\n                    {\n                        sum += st.top().first;\n                        st.pop();\n                    }\n                    st.push({sum, x});\n                }\n                else if (v[i][j] == '*')\n                {\n                    int x = cnt;\n                    int product = 1;\n                    while (st.size() && x + 1 == st.top().second)\n                    {\n                        product *= st.top().first;\n                        st.pop();\n                    }\n                    st.push({product, x});\n                }\n                else\n                    st.push({v[i][j] - '0', cnt});\n            }\n        }\n        cout << st.top().first << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int>P;\n\nint main(){\n    \n    for(int n; cin >> n, n;){\n        vector<P>v(n);\n        for(int i = 0; i < n; i++){\n            string s;\n            cin >> s;\n            char c = s[s.size() - 1];\n            if(c == '+')v[i].first = -1;\n            else if(c == '*')v[i].first = -2;\n            else v[i].first = c - '0';\n            v[i].second = s.size() - 1;\n        }\n        while(v.size() > 1){\n            int idx = 0;\n            for(int i = 0; i < v.size(); i++){\n                if(v[i].first < 0)idx = i;\n            }\n            if(v[idx].first == -1){\n                v[idx].first = 0;\n                while(idx + 1 < v.size()){\n                    if(v[idx].second + 1 == v[idx + 1].second){\n                        v[idx].first += v[idx + 1].first;\n                        v.erase(v.begin() + idx + 1);\n                    }\n                    else break;\n                }\n            }\n            else{\n                v[idx].first = 1;\n                while(idx + 1 < v.size()){\n                    if(v[idx].second + 1 == v[idx + 1].second){\n                        v[idx].first *= v[idx + 1].first;\n                        v.erase(v.begin() + idx + 1);\n                    }\n                    else break;\n                }\n            }\n        }\n        cout << v[0].first << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <map>\n#include <set>\n#include <list>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <string>\n\n#define REP(i,n) for(long long i=0;i<n;++i)\n#define REPR(i,n) for(long long i=n;i>=0;--i)\n#define REPI(itr,v) for(auto itr=v.begin();itr!=v.end();++itr)\n#define REPIR(itr,v) for(auto itr=v.rbegin();itr!=v.rend();++itr)\n#define FOR(i,a,b) for(long long i=a;i<b;++i)\n#define SORT(v,n) sort(v, v+n)\n#define SORTV(v) sort(v.begin(), v.end())\n#define ALL(v) v.begin(),v.end()\n#define llong long long\n#define INF 999999999\n#define MOD 1000000007\n#define pb push_back\n#define pf push_front\n#define MP make_pair\n#define SV(v) {for(long long sitr=0;sitr<v.size();++sitr){cin>>v[sitr];}}\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {1, -1, 0, 0};\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint get_level(string s){\n  int res = 0;\n  REP(i,s.length()){\n    if(s[i] == '.') res++;\n  }\n  return res;\n}\n\nbool is_ope(string s){\n  REP(i,s.length()){\n    if(s[i] == '+' || s[i] == '*') return true;\n  }\n  return false;\n}\n\nint get_num(string s){\n  string tmp;\n  REP(i,s.length()){\n    if(s[i] != '.'){\n      tmp = s.substr(i,s.length()-i);\n      break;\n    }\n  }\n  return stoi(tmp);\n}\n\nstring get_ope(string s){\n  return s.substr(s.length()-1,1);\n}\n\nint main(){\n\n  while(true){\n    int n;\n    cin >> n;\n\n    if(n == 0) break;\n\n    if(n == 1){\n      int tmp;\n      cin >> tmp;\n      cout << tmp << endl; \n      continue;\n    }\n\n    vector<string> s(n);\n    REP(i,n){\n      cin >> s[i];\n    }\n\n    stack<string> st_ope;\n    vector<vector<int>> v(100);\n\n    int level = 0;\n    int ans = 0;\n    REP(i,n){\n      if(!is_ope(s[i])){\n        while(level != get_level(s[i])){\n              int sum = 0;\n              string tp = st_ope.top();\n              st_ope.pop();\n              if(tp == \"+\"){\n                REPI(itr,v[level]){\n                  sum += *itr;\n                }\n              }else{\n                sum = 1;\n                REPI(itr, v[level]){\n                  sum *= *itr;\n                }\n              }\n              v[level].clear();\n              level--;\n              v[level].pb(sum);\n       \n        }\n        int num = get_num(s[i]);\n        v[level].pb(num);\n      }else{\n        if(is_ope(s[i])){\n          if(level == get_level(s[i])){\n            st_ope.push(get_ope(s[i]));\n            level++;\n            continue;\n          }else{\n            while(level != get_level(s[i])){\n              int sum = 0;\n              string tp = st_ope.top();\n              st_ope.pop();\n              if(tp == \"+\"){\n                REPI(itr,v[level]){\n                  sum += *itr;\n                }\n              }else{\n                sum = 1;\n                REPI(itr, v[level]){\n                  sum *= *itr;\n                }\n              }\n              v[level].clear();\n              level--;\n              v[level].pb(sum);\n            }\n            st_ope.push(get_ope(s[i]));\n            level++;\n          }\n        }\n      }\n\n      if(i == n-1){\n        while(level != 1){\n          int sum = 0;\n          string tp = st_ope.top();\n          st_ope.pop();\n          if(tp == \"+\"){\n            REPI(itr,v[level]){\n              sum += *itr;\n            }\n          }else{\n            sum = 1;\n            REPI(itr, v[level]){\n              sum *= *itr;\n            }\n          }\n          level--;\n          v[level].pb(sum);\n        }\n\n        string tp = st_ope.top();\n        st_ope.pop();\n        if(tp == \"+\"){\n          REPI(itr,v[level]){\n            ans += *itr;\n          }\n        }else{\n          ans = 1;\n          REPI(itr, v[level]){\n            ans *= *itr;\n          }\n        }\n      }\n    }\n\n\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<char, int> P;\n\nint idx, N;\n\nint solve(vector<P> &v)\n{\n    char c = v[idx].first, d = v[idx].second;\n    \n    idx++;\n    if (isdigit(c)) {\n        return c - '0';\n    } else {\n        int res = (c == '*');\n        while (idx < N && d < v[idx].second) {\n            if (c == '*') {\n                res *= solve(v);\n            } else {\n                res += solve(v);\n            }\n        }\n        return res;\n    }\n}\n\nint main()\n{\n    while (cin >> N, N) {\n        vector<P> v(N);\n        string s;\n        for (int i = 0; i < N; i++) {\n            cin >> s;\n            v[i] = P(s.back(), s.size()-1);\n        }\n        idx = 0;\n        cout << solve(v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nvoid solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        st.push(make_pair(th, l-1));\n    }\n}\nint main(){\n    while(cin>>n,n){\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=1;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    solve(level);\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        st.push(make_pair(0,0));\n        solve(0);\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\ntypedef pair<int, char> PIC;\ntypedef pair<int, int> PII;\n\nint main(void) {\n  int N;\n  while (cin >> N, N) {\n    vector<PIC> lines(N);\n\n    for (int i = 0; i < N; i++) {\n      string line;\n      cin >> line;\n\n      lines[i].first = line.size() - 1;\n      lines[i].second = line.back();\n    }\n\n    if (lines[0].second == '+') {\n      lines.push_back(PIC(1, '0'));\n    }\n    \n    if (lines[0].second == '*') {\n      lines.push_back(PIC(1, '1'));\n    }\n\n    \n    vector<char> operators;\n    vector<PII> operands;\n    \n    int now_dep = 0;\n    for (auto line : lines) {\n      int dep = line.first;\n      char sym = line.second;\n    \n      while (dep < now_dep) {\n        char op = operators.back();\n        operators.pop_back();\n        int res = ((op == '+') ? 0 : 1);\n     \n        while (operands.back().first == now_dep) {\n          int operand = operands.back().second;\n          operands.pop_back();\n          if (op == '+') res += operand;\n          else res *= operand;\n        }\n       \n        now_dep--;\n        operands.push_back(PII(now_dep, res));\n      }\n    \n      now_dep = dep;\n     \n      if (sym == '+' || sym == '*') operators.push_back(sym);\n      else operands.push_back(PII(now_dep, sym - '0'));\n    }\n\n    if (operators.size() != 0) {\n        char op = operators.back();\n        operators.pop_back();\n        int res = ((op == '+') ? 0 : 1);\n    \n        while (!operands.empty()) {\n          int operand = operands.back().second;\n          operands.pop_back();\n          if (op == '+') res += operand;\n          else res *= operand;\n        }\n    \n        now_dep--;\n        operands.push_back(PII(now_dep, res));\n    }\n\n    cout << operands[0].second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\nstring get_line() {\n  string line;\n  cin >> line;\n  return line;\n}\n// 整数: 一桁\nint main() {\n  while (true) {\n    auto line_num = stoi(get_line());\n    if (line_num == 0) return 0;\n    if (line_num == 1) {\n      cout << stoi(get_line()) << endl;\n      continue;\n    }\n    vector<int> stack;\n    vector<bool> is_adds;\n    REP(i, line_num) {\n      auto line = get_line();\n      auto chr = line[line.size() - 1];\n      auto level = line.size() - 1;\n      auto calc = [&](int num) {\n        if (is_adds[is_adds.size() - 1]) {\n          stack[stack.size() - 1] += num;\n        } else {\n          stack[stack.size() - 1] *= num;\n        }\n      };\n      // リダクション\n      if (level < stack.size()) {\n        auto n = stack.size() - level;\n        REP(j, n) {\n          auto num = stack[stack.size() - 1];\n          is_adds.pop_back();\n          stack.pop_back();\n          calc(num);\n        }\n      }\n      // パース\n      if (chr == '+') {\n        stack.push_back(0);\n        is_adds.push_back(true);\n      } else if (chr == '*') {\n        stack.push_back(1);\n        is_adds.push_back(false);\n        continue;\n      } else {\n        calc(chr - '0');\n      }\n    }\n    cout << stack[stack.size() - 1] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// repetition\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\n// container util\n#define all(x) (x).begin(), (x).end()\n\n// debug\n#define dump(x) cerr << #x << \" = \" << (x) << endl;\n#define debug(x)                                         \\\n  cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" \\\n       << \" \" << __FILE__ << endl;\n\n// typedef\ntypedef long long lint;\ntypedef unsigned long long ull;\ntypedef complex<long double> Complex;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> TP;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\n// constant\nconst int MOD = (int)1e9 + 7;\nconst int INF = (int)1e18;\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\n\n// conversion\ninline int toInt(string s) {\n  int v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ntemplate <class T>\ninline string toString(T x) {\n  ostringstream sout;\n  sout << x;\n  return sout.str();\n}\n\n//\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n//\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    string s[100];\n    pair<int, string> par[100];\n    for (int i = 0; i < n; i++) {\n      cin >> s[i];\n    }\n    for (int i = 0; i < n; i++) {\n      int cnt = 0;\n      for (int j = 0; j < s[i].size(); j++) {\n        if (s[i][j] == '.')\n          cnt++;\n        else\n          par[i] = make_pair(cnt, s[i][j]);\n      }\n    }\n\n    stack<pair<int, string>> st;\n\n    for (int i = n - 1; 0 <= i; i--) {\n      if (par[i].second != \"+\" && par[i].second != \"*\") {\n        st.push(par[i]);  //数字ならスタックに積む\n        continue;\n      }\n\n      if (par[i].second == \"+\") {\n        int ret = 0;\n        while (!st.empty()) {\n          if (par[i].first + 1 != st.top().first) break;\n          ret += toInt(st.top().second);\n          st.pop();\n        }\n        st.push(make_pair(par[i].first, to_string(ret)));\n      } else {\n        int ret = 1;\n        while (!st.empty()) {\n          if (par[i].first + 1 != st.top().first) break;\n          ret *= toInt(st.top().second);\n          st.pop();\n        }\n        st.push(make_pair(par[i].first, to_string(ret)));\n      }\n    }\n\n    int ans = toInt(st.top().second);\n    cout << ans << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main() {\n  int n;\n  while ( cin >> n, n ) {\n    int ans = 0;\n    vector<P> dat(n);    \n    for ( int i = 0; i < n; i++ ) {      \n      string s;\n      cin >> s;\n      dat[i].first = (int)s.size()-1;\n      if ( s[s.size()-1] == '+' ) dat[i].second = -1;\n      else if ( s[s.size()-1] == '*' ) dat[i].second = -2;\n      else dat[i].second = s[s.size()-1]-'0';      \n    }\n\n    while ( 1 ) {      \n      /*for ( int i = 0; i < dat.size(); i++ ) {\n\tif ( i ) cout << \" \";\n\tcout << dat[i].first << \" \" << dat[i].second;\n      }\n      cout << endl << endl;;*/\n      if ( dat.size() == 1 ) break;\n      for ( int i = 0; i < dat.size()-2; i++ ) {\n\tif ( dat[i].second >= 0 ) continue;\n\tint c = dat[i].second;\n\tint d = dat[i].first;\t\n\tint sum;\n\tint cnt = 2;\n\tbool flag = false;\n\tif ( d != dat[i+1].first-1 ) continue;\n\tif ( dat[i+1].second >= 0 && dat[i+2].second >= 0 && dat[i+1].first == dat[i+2].first ) {\n\t  flag = true;\n\t  //cout << 'a' << endl;\t    \t \n\t  sum = dat[i+1].second;\n\t  cnt = 2;\n\t  for ( int j = i+2; j < dat.size(); j++ ) {\n\t    //cout << sum << endl;\n\t    if ( dat[j].second < 0 ) break;\n\t    if ( dat[j].first != dat[i+1].first ) break; \n\t    if ( c == -1 ) {\n\t      sum += dat[j].second;\n\t    } else {\n\t      sum *= dat[j].second;\n\t    }\n\t    cnt++;\n\t  }\n\t}\t\n\tif ( flag ) {\n\t  //cout << i << \" \" << sum << \" \" << cnt << endl;\n\t  int tmp = dat[i].first;\n\t  for ( int j = i; j < i+cnt; j++ ) dat.erase(dat.begin()+i);\n\t  dat.insert(dat.begin()+i, P(tmp, sum));\n\t  break;\n\t}\n      }\n      if ( dat.size() == 1 ) break;\n    }\n\n    //cout << \"end\" << endl;\n    cout << dat[0].second << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint n,row;\nvector<string> str;\n\nint operand(int level) {\n    int answer = 0;\n    cout<<\"row:\"<<row<<\" level:\"<<level<<endl;\n    switch (str[row][level]) {\n        case '+':\n            row++,level++;\n            answer = 0;\n            while (row < n) {\n                if (str[row].size() < level || str[row][level-1] != '.') break;\n                answer += operand(level);\n            }\n            break;\n\n        case '*':\n            row++,level++;\n            answer = 1;\n            while (row < n) {\n                if (str[row].size() < level || str[row][level-1] != '.') break;\n                answer *= operand(level);\n            }\n            break;\n\n        default: answer = stoi(str[row].substr(level)); row++;\n    }\n    return answer;\n}\n\nint main() {\n    while (cin>>n && n != 0) {\n        row = 0;\n        str = vector<string>(n);\n        for (int i = 0; i < n; i++) cin>>str[i];\n        cout<<operand(0)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#ifdef __GNUC__\n#include <bits/stdc++.h>\n#else\n#define _CRT_SECURE_NO_WARNINGS\n#include <__msvc_all_public_headers.hpp>\n#undef min\n#undef max\n#endif\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\t\tusing ld = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<ll>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<ld>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\tusing VPL = vector<PLL>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr ll inf_ll = (ll)1e18, MOD = 1000000007;\nconstexpr ld PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked _fwrite_nolock\n#define fflush_unlocked _fflush_nolock\n#endif\ninline int gc() { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v) { cin >> v; }\ninline void InputF(char& v) { while (isspace(v = gc())); }\ninline void InputF(bool& v) { char c; InputF(c); v = c != '0'; }\ninline void InputF(string& v) {\n\tchar c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v) {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v) {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v) {\n\tfor (auto& e : v)InputF(e);\n}\ntemplate<class T>inline T InputF() { T v; InputF(v); return v; }\ninline string GetLine() {\n\tstring v; char c; for (InputF(c); c != '\\n' && c != '\\0'; c = gc())v += c; return v;\n}\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>() {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>() {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T() { return InputF<T>(); }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n) { return InputV(n); }\n\tInputV operator[](pair<int, int> n) { return InputV(n); }\n\tvoid operator()() {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tInputF(h); operator()(forward<T>(t)...);\n\t}\n\ttemplate<class T>Input& operator,(T&& v) {\n\t\tInputF(v); return *this;\n\t}\n}in;\n#define input(T) InputF<T>()\n#define ini input(int)\n#define inl input(ll)\n#define ins input(string)\n#define inputs(T, ...) T __VA_ARGS__; in(__VA_ARGS__)\n#define INT(...) inputs(int, __VA_ARGS__)\n#define LL(...) inputs(ll, __VA_ARGS__)\n#define STR(...) inputs(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc };\n\tvoid p(int v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[10]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(ll v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[20]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(bool v) { p(v ? B.t : B.f); }\n\tvoid p(char v) { putchar_unlocked(v); }\n\tvoid p(const char* v) { fwrite_unlocked(v, 1, strlen(v), stdout); }\n\tvoid p(double v) { printf(\"%.20f\", v); }\n\tvoid p(ld v) { printf(\"%.20Lf\", v); }\n\ttemplate<class T> void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); p(D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)p(D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)p(D.l); p(v[i]); } }\npublic:\n\tOutput& operator()() { p(D.l); return *this; }\n\ttemplate<class H>Output& operator()(H&& h) { p(h); p(D.l); return *this; }\n\ttemplate<class H, class...T>Output& operator()(H&& h, T&& ...t) {\n\t\tp(h); p(D.d); return operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) { operator()(forward<T>(t)...); std::exit(EXIT_SUCCESS); }\n\tOutput& flush() { fflush_unlocked(stdout); return *this; }\n\tOutput& set(const BoolStr& b) { B = b; return *this; }\n\tOutput& set(const DivStr& d) { D = d; return *this; }\n\tOutput& set(const char* t, const char* f) { B = BoolStr(t, f); return *this; }\n}out;\n\n// --- step --- //\ntemplate<class T>struct Step {\n\tclass It {\n\t\tT a, b, c;\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() { --b; a += c; return *this; }\n\t\tconstexpr It operator++(int) { It tmp = *this; --b; a += c; return tmp; }\n\t\tconstexpr const T& operator*()const { return a; }\n\t\tconstexpr const T* operator->()const { return &a; }\n\t\tconstexpr bool operator==(const It& i)const { return b == i.b; }\n\t\tconstexpr bool operator!=(const It& i)const { return !(b == i.b); }\n\t\tconstexpr T start()const { return a; }\n\t\tconstexpr T count()const { return b; }\n\t\tconstexpr T step()const { return c; }\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin()const { return be; }\n\tconstexpr It end()const { return en; }\n\tconstexpr T start()const { return be.start(); }\n\tconstexpr T count()const { return be.count(); }\n\tconstexpr T step()const { return be.step(); }\n\tconstexpr T sum()const { return start() * count() + step() * (count() * (count() - 1) / 2); }\n\toperator vector<T>()const { return as_vector(); }\n\tvector<T> as_vector()const {\n\t\tvector<T> res; res.reserve(count()); each([&](T i) {res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>void each(const F& f)const { for (T i : *this)f(i); }\n\ttemplate<class F>auto map(const F& f)const {\n\t\tvector<decay_t<result_of_t<F(T)>>> res; res.reserve(count());\n\t\teach([&](T i) {res.push_back(f(i)); }); return res;\n\t}\n\ttemplate<class F>int count_if(const F& f)const {\n\t\tint res = 0; each([&](T i) {res += static_cast<bool>(f(i)); }); return res;\n\t}\n\ttemplate<class F>vector<T> select(const F& f)const {\n\t\tvector<T> res; each([&](T i) {if (f(i))res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>auto max(const F& f)const {\n\t\tauto v = map(f); return *max_element(v.begin(), v.end());\n\t}\n\ttemplate<class F>auto min(const F& f)const {\n\t\tauto v = map(f); return *min_element(v.begin(), v.end());\n\t}\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto sum(const F& f)const {\n\t\tU res = 0; each([&](T i) {res += static_cast<U>(f(i)); }); return res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\nprivate:\n\tIt be, en;\n};\ntemplate<class T>inline constexpr auto step(T a) { return Step<T>(0, a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b) { return Step<T>(a, b - a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b, T c) { return Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c); }\n\n// --- functions --- //\ninline namespace {\n\ttemplate<class T>inline void Sort(T& a) { sort(all(a)); }\n\ttemplate<class T>inline void RSort(T& a) { sort(rall(a)); }\n\ttemplate<class T>inline T Sorted(T a) { Sort(a); return a; }\n\ttemplate<class T>inline T RSorted(T a) { RSort(a); return a; }\n\ttemplate<class T, class F>inline void Sort(T& a, const F& f) {\n\t\tsort(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline void RSort(T& a, const F& f) {\n\t\tsort(rall(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T>inline void Reverse(T& a) { reverse(all(a)); }\n\ttemplate<class T>inline void Unique(T& a) { a.erase(unique(all(a)), a.end()); }\n\ttemplate<class T>inline void Rotate(T& a, int left) { rotate(a.begin(), a.begin() + left, a.end()); }\n\ttemplate<class T>inline T Reversed(T a) { Reverse(a); return a; }\n\ttemplate<class T>inline T Uniqued(T a) { Unique(a); return a; }\n\ttemplate<class T>inline T Rotated(T a, int left) { Rotate(a, left); return a; }\n\ttemplate<class T>inline auto Max(const T& a) { return *max_element(all(a)); }\n\ttemplate<class T>inline auto Min(const T& a) { return *min_element(all(a)); }\n\ttemplate<class T>inline int MaxPos(const T& a) { return max_element(all(a)) - a.begin(); }\n\ttemplate<class T>inline int MinPos(const T& a) { return min_element(all(a)) - a.begin(); }\n\ttemplate<class T, class F>inline auto Max(const T& a, const F& f) {\n\t\treturn *max_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline auto Min(const T& a, const F& f) {\n\t\treturn *min_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class U>inline int Count(const T& a, const U& v) { return count(all(a), v); }\n\ttemplate<class T, class F>inline int CountIf(const T& a, const F& f) { return count_if(all(a), f); }\n\ttemplate<class T, class U>inline int Find(const T& a, const U& v) { return find(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline int FindIf(const T& a, const F& f) { return find_if(all(a), f) - a.begin(); }\n\ttemplate<class T, class U = typename T::value_type>inline U Sum(const T& a) { return accumulate(all(a), U()); }\n\ttemplate<class T, class F>inline auto Sum(const T& v, const F& f) {\n\t\treturn accumulate(next(v.begin()), v.end(), f(v.front()), [&](auto a, auto b) {return a + f(b); });\n\t}\n\ttemplate<class T, class U>inline int Lower(const T& a, const U& v) { return lower_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class U>inline int Upper(const T& a, const U& v) { return upper_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline void RemoveIf(T& a, const F& f) { a.erase(remove_if(all(a), f), a.end()); }\n\ttemplate<class F>inline auto Vector(size_t size, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t)>>> res(size); for (size_t i = 0; i < size; ++i)res[i] = f(i); return res;\n\t}\n\ttemplate<class T>inline auto Grid(size_t h, size_t w, const T& v = T()) { return vector<vector<T>>(h, vector<T>(w, v)); }\n\ttemplate<class T>inline auto Slice(const T& v, size_t i, size_t len) {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\ttemplate<class T, class F>inline auto Each(const T& v, const F& f) { for (auto& i : v)f(i); }\n\ttemplate<class T, class F>inline auto Select(const T& v, const F& f) {\n\t\tT res; for (const auto& e : v)if (f(e))res.push_back(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto Map(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (const auto& e : v)res[i++] = f(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto MapIndex(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t, typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (auto it = v.begin(); it != v.end(); ++it, ++i)res[i] = f(i, *it); return res;\n\t}\n\ttemplate<class T, class F>inline auto TrueIndex(const T& v, const F& f) {\n\t\tvector<size_t> res; for (size_t i = 0; i < v.size(); ++i)if (f(v[i]))res.push_back(i); return res;\n\t}\n\tinline string operator*(string s, size_t n) { string ret; for (size_t i = 0; i < n; ++i)ret += s; return ret; }\n\ttemplate<class T>inline T Ceil(T n, T m) { return (n + m - 1) / m; }\n\ttemplate<class T>inline T Ceil2(T n, T m) { return Ceil(n, m) * m; }\n\ttemplate<class T>inline T Tri(T n) { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\n\ttemplate<class T>inline T nC2(T n) { return (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1); }\n\ttemplate<class T>inline T Mid(const T& l, const T& r) { return l + (r - l) / 2; }\n\tinline int pop_count(int n) { return bitset<32>(n).count(); }\n\tinline int pop_count(ll n) { return bitset<64>(n).count(); }\n\ttemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool inRange(const T& v, const T& min, const T& max) { return min <= v && v < max; }\n\ttemplate<class T = ll>inline T BIT(int b) { return T(1) << b; }\n\ttemplate<class T>inline T Gcd(T n, T m) { return m ? Gcd(m, n % m) : n; }\n\ttemplate<class T>inline T Lcm(T n, T m) { return n / Gcd(n, m) * m; }\n\ttemplate<class T, class U = typename T::value_type>inline U Gcdv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Gcd<U>);\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Lcmv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Lcm<U>);\n\t}\n\ttemplate<class T>inline T Pow(T a, T n) { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; } return r; }\n\ttemplate<class T>inline T Powmod(T a, T n, T m = MOD) {\n\t\tT r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r;\n\t}\n}\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\nstruct Data {\n\tint d = 0;\n\tbool is_op = false;\n\tchar op = '\\0'; int num = 0;\n\tData(const string& s) {\n\t\td = Count(s, '.');\n\t\tif (isdigit(s.back())) {\n\t\t\tnum = s.back() - '0';\n\t\t\tis_op = false;\n\t\t} else {\n\t\t\top = s.back();\n\t\t\tis_op = true;\n\t\t}\n\t}\n};\nostream& operator<<(ostream& os, const Data& d) {\n\treturn os << '(' << d.d << \",\" << char(d.is_op ? d.op : '0' + d.num) << ')';\n}\n\nint calc(vector<Data> d) {\n\n\tif (!d.front().is_op) {\n\t\tassert(d.size() == 1);\n\t\treturn d.front().num;\n\t}\n\n\tint depth = d.front().d + 1;\n\tVI a;\n\tvector<size_t> sep = TrueIndex(d, [&](Data data) {return data.d == depth; });\n\tsep.push_back(d.size());\n\trep(i, sz(sep) - 1) {\n\t\ta.push_back(calc(Slice(d, sep[i], sep[i + 1] - sep[i])));\n\t}\n\n\tint res = a.front();\n\tFOR(i, 1, sz(a)) {\n\t\tif (d.front().op == '+') {\n\t\t\tres += a[i];\n\t\t} else {\n\t\t\tres *= a[i];\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve(int n) {\n\tVS s = in[n];\n\tvector<Data> a(all(s));\n\tout(calc(a));\n}\n\nint main() {\n\tfor (int n = in; n; in(n)) {\n\t\tsolve(n);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nint n;\nvector<string> s;\n\nll dfs(int &i, int j){\n  if (isdigit(s[i][j])){\n    ll res = s[i][j] - '0';\n    i++;\n    return res;\n  }\n  if (s[i][j] == '+'){\n    ll res = 0;\n    i++;\n    while (i < n && j < s[i].size() && s[i][j] == '.'){\n      res += dfs(i, j + 1);\n    }\n    return res;\n  }\n  if (s[i][j] == '*'){\n    ll res = 1;\n    i++;\n    while (i < n && j < s[i].size() && s[i][j] == '.'){\n      res *= dfs(i, j + 1);\n    }\n    return res;\n  }\n  assert(false);\n}\n\nint main(){\n  while (cin >> n, n){\n    s.resize(n);\n    each(x, s) cin >> x;\n    int i = 0;\n    cout << dfs(i, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(void){\n    while (1) {\n        int n;\n        cin >> n;\n        \n        if (n == 0) return 0;\n        \n        int mx = 0;\n        vector<int> ope, value[20];\n        for (int i = 0; i < n; i++) {\n            string s;\n            cin >> s;\n            \n            if (s.size() <= mx) {\n                while (mx >= s.size()) {\n                    int tmp;\n                    if (ope[ope.size() - 1] == 1) {\n                        tmp = 0;\n                        while (!value[mx].empty()) {\n                            tmp += value[mx][value[mx].size() - 1];\n                            value[mx].pop_back();\n                        }\n                        value[mx - 1].push_back(tmp);\n                    }\n                    else {\n                        tmp = 1;\n                        while (!value[mx].empty()) {\n                            tmp *= value[mx][value[mx].size() - 1];\n                            value[mx].pop_back();\n                        }\n                        value[mx - 1].push_back(tmp);\n                    }\n                    ope.pop_back();\n                    mx--;\n                }\n            }\n            \n            if (char(s[s.size() - 1]) == '+') {\n                ope.push_back(1);  mx++;\n            }\n            else if (char(s[s.size() - 1]) == '*') {\n                ope.push_back(2);  mx++;\n            }\n            else {\n                value[s.size() - 1].push_back(int(s[s.size() - 1] - '0'));\n            }\n            \n            if (i == n - 1) {\n                while (mx != 0) {\n                    int tmp;\n                    if (ope[ope.size() - 1] == 1) {\n                        tmp = 0;\n                        while (!value[mx].empty()) {\n                            tmp += value[mx][value[mx].size() - 1];\n                            value[mx].pop_back();\n                        }\n                        value[mx - 1].push_back(tmp);\n                    }\n                    else {\n                        tmp = 1;\n                        while (!value[mx].empty()) {\n                            tmp *= value[mx][value[mx].size() - 1];\n                            value[mx].pop_back();\n                        }\n                        value[mx - 1].push_back(tmp);\n                    }\n                    ope.pop_back();\n                    mx--;\n                }\n            }\n            \n        }\n        \n        for (int i = 0; i < value[0].size(); i++)\n        cout << value[0][0] << endl;\n        \n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <list>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\ntypedef vector<pair<char, int> >::const_iterator vitr;\n\nvector<pair<char, int> > v;\n\nint solve(vitr& it) {\n\tchar c = it->first;\n\tint h = it->second;\n\t++it;\n\tif (isdigit(c)) return c - '0';\n\tint res = (c == '+' ? 0 : 1);\n\twhile (it != v.end() && h + 1 == it->second) {\n\t\tif (c == '*') res *= solve(it);\n\t\telse res += solve(it);\n\t}\n\treturn res;\n}\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tv.clear();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tstring s; cin >> s;\n\t\t\tv.push_back(make_pair(s[s.size() - 1], s.size() - 1));\n\t\t}\n\t\tvitr begin = v.begin();\n\t\tcout << solve(begin) << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr = ds.begin(); itr != ds.end(); ++itr)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 2000000000000000000LL\n#define EPS 1e-9\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<ull> vull;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\ntypedef vector<Edge> vE;\ntypedef priority_queue<Edge, vector<Edge>, greater<Edge> > pqlE;\n\nint calc(vs math, int depth, int &l) {\n\tif (math[l][depth] == '+') {\n\t\tint ans = 0;\n\t\tl++;\n\t\twhile (l < math.size() && math[l].length() > depth + 1) {\n\t\t\tans += calc(math, depth + 1, l);\n\t\t}\n\t\treturn ans;\n\t}\n\telse if (math[l][depth] == '*') {\n\t\tint ans = 1;\n\t\tl++;\n\t\twhile (l < math.size() && math[l].length() > depth + 1) {\n\t\t\tans *= calc(math, depth + 1, l);\n\t\t}\n\t\treturn ans;\n\t}\n\telse {\n\t\tl++;\n\t\treturn (int)(math[l - 1][depth] - '0');\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tint N;\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tvs math(N);\n\t\trep(i, N) {\n\t\t\tcin >> math[i];\n\t\t}\n\t\tint l = 0;\n\t\tcout << calc(math, 0, l) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nint dfs(const vector<string> &s, int i, int j) {\n    if (isdigit(s[i][j])) {\n        return s[i][j] - '0';\n    }\n\n    int ret = (s[i][j] == '+' ? 0 : 1);\n    int nj = j + 1;\n    rep2(ni, i + 1, s.size()) {\n        if (nj >= s[ni].size()) break;\n        if (s[ni][nj] == '.') continue;\n        if (s[i][j] == '+') ret += dfs(s, ni, nj);\n        if (s[i][j] == '*') ret *= dfs(s, ni, nj);\n    }\n    return ret;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        vector<string> s(n);\n        rep(i, n) cin >> s[i];\n        cout << dfs(s, 0, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string.h>\n#include<stdio.h>\nusing namespace std;\nint suma(int d);\nint a;\nchar s[100000];\nint t(int d){\n  int ans=1;\n  cin>>s;\n  a--;\n  while(a>=0){\n    if(strlen(s)!=d)\n      break;\n    if(s[d-1]=='*')\n      ans*=t(d+1);\n    else if(s[d-1]=='+')\n      ans*=suma(d+1);\n    else{\n      ans*=s[d-1]-'0';\n      if(a==0)\n        break;\n      cin>>s;\n      a--;\n    }\n  }\n  return ans;\n}\n\nint suma(int d){\n  int ans=0;\n  a--;\n  cin>>s;\n  while(a>=0){\n    if(strlen(s)!=d)\n      break;\n    if(s[d-1]=='*')\n      ans+=t(d+1);\n    else if(s[d-1]=='+')\n      ans+=suma(d+1);\n    else{\n      if(strlen(s)!=d)\n        break;\n      ans+=s[d-1]-'0';\n      if(a==0)\n        break;\n      cin>>s;\n      a--;\n    }\n  }\n  return ans;\n}\n\nint main(){\n  int n;\n  while(1){\n    cin>>s;\n    if(strlen(s)==1&&s[0]=='0')\n      break;\n    n=strlen(s);\n    a=0;\n    for(int i=0;i<n;i++){\n      a*=10;\n      a+=s[i]-'0';\n    }\n    a--;\n    cin>>s;\n    if(s[0]=='+')\n      cout<<suma(2)<<endl;\n    else if(s[0]=='*')\n      cout<<t(2)<<endl;\n    else\n      cout<<s<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n\nusing namespace std;\n\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//四捨五入\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り上げ\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define SUM_P(v, w) partial_sum((v).begin(), (v).end(), (w).begin())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define FOUT_L(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n        T d = EXTGCD(-a, b, x, y);\n        x = -x;\n        return d;\n    }\n    if (b < 0) {\n        T d = EXTGCD(a, -b, x, y);\n        y = -y;\n        return d;\n    }\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    } else {\n        T d = EXTGCD(b, a % b, x, y);\n        T t = x;\n        x = y;\n        y = t - (a / b) * y;\n        return d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T) (SQR(i)) < b; i++) {\n        if (small[i]) {\n            for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n                prime[j - a] = false;\n            }\n        }\n    }\n\n    return prime;\n}\n\n//約数\ntemplate<class T>\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//組み合わせ個数\ntemplate<typename T>\nT NCR(T n, T r) {\n    T ans = 1;\n    REPLL(i, r) {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//行列\nint MATRIZ_CHAIN(VI &p, VVI &s) {\n    const static int INF = 1 << 20;\n    const int n = p.size() - 1;\n    VVI X(n, VI(n, INF));\n    s.resize(n, VI(n));\n    for (int i = 0; i < n; ++i) X[i][i] = 0;\n    for (int w = 1; w < n; ++w)\n        for (int i = 0, j; j = i + w, j < n; ++i)\n            for (int k = i; k < j; ++k) {\n                int f = p[i] * p[k + 1] * p[j + 1];\n                if (X[i][k] + X[k + 1][j] + f < X[i][j]) {\n                    X[i][j] = X[i][k] + X[k + 1][j] + f;\n                    s[i][j] = k;\n                }\n            }\n    return X[0][n - 1];\n}\n\n//最長増加部分列\nVI LIS(const VI &a) {\n    const static int INF = 99999999;\n    const int n = a.size();\n    VI A(n, INF);\n    VI id(n);\n    for (int i = 0; i < n; ++i) {\n        id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n        A[id[i]] = a[i];\n    }\n    int m = *max_element(id.begin(), id.end());\n    VI b(m + 1);\n    for (int i = n - 1; i >= 0; --i)\n        if (id[i] == m) b[m--] = a[i];\n    return b;\n}\n\n//最長共通部分列 string->toVC\ntemplate<typename T>\nvector<T> LCS(const vector<T> &a, const vector<T> &b) {\n    const int n = a.size(), m = b.size();\n    vector<VI> X(n + 1, VI(m + 1));\n    vector<VI> Y(n + 1, VI(m + 1));\n    REP(i, n) {\n        REP(j, m) {\n            if (a[i] == b[j]) {\n                X[i + 1][j + 1] = X[i][j] + 1;\n                Y[i + 1][j + 1] = 0;\n            } else if (X[i + 1][j] < X[i][j + 1]) {\n                X[i + 1][j + 1] = X[i][j + 1];\n                Y[i + 1][j + 1] = +1;\n            } else {\n                X[i + 1][j + 1] = X[i + 1][j];\n                Y[i + 1][j + 1] = -1;\n            }\n        }\n    }\n    vector<T> c;\n    for (int i = n, j = m; i > 0 && j > 0;) {\n        if (Y[i][j] > 0) --i;\n        else if (Y[i][j] < 0) --j;\n        else {\n            c.PB(a[i - 1]);\n            --i;\n            --j;\n        }\n    }\n    REVERSE(c);\n    return c;\n}\n\n//コイン C総額 cs使用できるコインの種類\nVI money_change(int C, VI &cs) {\n    const int INF = 99999999;\n    int n = cs.size();\n    VI xs(C + 1, INF);\n    VI ys(C + 1);\n    xs[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int c = 0; c + cs[i] <= C; ++c) {\n            if (xs[c + cs[i]] > xs[c] + 1) {\n                xs[c + cs[i]] = xs[c] + 1;\n                ys[c + cs[i]] = c;\n            }\n        }\n    }\n    VI zs;\n    for (int c = C; c > 0; c = ys[c]) {\n        zs.push_back(c - ys[c]);\n    }\n    return zs;\n}\n\n\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(a, b) memset((a), (b),sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n * */\n\nint add(int& index, int N, int par, vector<pair<int, char>> P);\n\nint mul(int& index, int N, int par, vector<pair<int, char>> P);\n\nint add(int& index, int N, int par, vector<pair<int, char>> P) {\n    int ret = 0;\n    while (index < N) {\n        if (P[index].first <= par) {\n            break;\n        } else if (P[index].second == '+') {\n            index++;\n            ret += add(index, N, P[index - 1].first, P);\n        } else if (P[index].second == '*') {\n            index++;\n            ret += mul(index, N, P[index - 1].first, P);\n        } else {\n            ret += P[index].second - '0';\n            index++;\n        }\n    }\n\n    return ret;\n}\n\nint mul(int& index, int N, int par, vector<pair<int, char>> P) {\n    int ret = 1;\n    while (index < N) {\n        if(P[index].first <=par){\n            break;\n        }else if(P[index].second == '+'){\n            index++;\n            ret *= add(index, N, P[index-1].first, P);\n        }else if(P[index].second =='*'){\n            index++;\n            ret *= mul(index, N, P[index-1].first, P);\n        }else{\n            ret *= P[index].second -'0';\n            index++;\n        }\n    }\n\n    return ret;\n\n}\n\nint main() {\n\n    int N;\n\n\n    while (true) {\n        cin >> N;\n\n        VS S(N);\n        vector<pair<int, char>> P(N);\n\n        if (N == 0) {\n            break;\n        }\n\n        REP(i, N) {\n            cin >> S[i];\n            P[i].first = 0;\n        }\n        REP(i, N) {\n            REP(j, S[i].size()) {\n                if (S[i][j] == '.') {\n                    P[i].first++;\n                } else {\n                    P[i].second = S[i][j];\n                }\n            }\n        }\n\n\n        if (N == 1) {\n            OUT_L(P[0].second);\n            continue;\n        }\n\n        int res;\n        if (P[0].second == '+') {\n            int start = 1;\n            res = add(start, N, 0, P);\n        } else {\n            int start = 1;\n            res = mul(start, N, 0, P);\n        }\n\n        OUT_L(res);\n\n    }\n\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <numeric>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nenum class Type { N, S, P };\n\nstruct D {\n    vector<D> children;\n    Type type = Type::N;\n    int value = -1;\n    int level = -1;\n};\n\nint main()\n{\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            return 0;\n        }\n\n        vector<string> vs;\n        for (int i = 0; i < n; ++i) {\n            string s;\n            cin >> s;\n            vs.push_back(s);\n        }\n\n        auto parse = [](const string& s) {\n            int i = 0;\n            while (s[i] == '.') {\n                ++i;\n            }\n            if (s[i] == '+') {\n                return D{{}, Type::S, -1, i};\n            }\n            else if (s[i] == '*') {\n                return D{{}, Type::P, -1, i};\n            }\n            else {\n                return D{{}, Type::N, stoi(s.substr(i)), i};\n            }\n        };\n\n        unordered_map<int, vector<D>> mm;\n        for (int i = vs.size() - 1; i >= 0; --i) {\n            auto x = parse(vs[i]);\n            if (x.type == Type::N) {\n                mm[x.level].push_back(x);\n            }\n            else {\n                x.children = mm[x.level + 1];\n                mm.erase(x.level + 1);\n                mm[x.level].push_back(x);\n            }\n        }\n\n        function<int(const D&)> eval = [&eval](const D& d) {\n            if (d.type == Type::N) {\n                return d.value;\n            }\n            else if (d.type == Type::S) {\n                return accumulate(begin(d.children), end(d.children), 0,\n                                  [&eval](int a, const D& b) {\n                                      return a + eval(b);\n                                  });\n            }\n            else {\n                return accumulate(begin(d.children), end(d.children), 1,\n                                  [&eval](int a, const D& b) {\n                                      return a * eval(b);\n                                  });\n            }\n        };\n\n        cout << eval(mm[0][0]) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<climits>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nint solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        if((long long)th>2147483647){\n            return -1;\n        }\n        st.push(make_pair(th, l-1));\n    }\n    return 0;\n}\nint main(){\n    cout<<INT_MAX<<endl;\n    while(cin>>n,n){\n        while(ope.size())ope.pop();\n        while(st.size())st.pop();\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    if(solve(level)==-1)return -1;\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        if(solve(0)==-1)return -1;\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n \nusing namespace std;\n \nint solve(void);\nint getValue(const vector<string> &v, int &itr, const int depth = 0);\n \nint main(void) {\n  \n    while (solve()) {}\n \n    return 0;\n \n}\n \nint solve(void) {\n \n    int n;\n \n    cin >> n;\n \n    if ( !n ) { return 0; }\n \n    vector<string> str(n);\n     \n    for (int i = 0; i < n; i++) {\n        cin >> str[i];\n    }\n \n    int itr = 0;\n \n    cout << getValue(str, itr) << endl;\n    \n    return 1;\n}\n \nint getValue(const vector<string>& v, int &itr, const int depth)\n{\n \n    int len = v[itr].length();\n    char ch = v[itr][len - 1];\n    int ret;\n \n    itr++;\n    if (ch == '*') {\n        //multiply\n        ret = 1;\n        while (itr<v.size() && v[itr].length() - 1 > depth) {\n            ret *= getValue(v, itr, v[itr].length() - 1);\n        }\n    }\n    else if (ch == '+') {\n        //plus\n        ret = 0;\n        while (itr < v.size() && v[itr].length() - 1 > depth) {\n            ret += getValue(v, itr, v[itr].length() - 1);\n        }\n    }   \n    else {\n        //numbers\n        ret = ch - '0';\n    }\n \n \n    return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef complex<double> xy_t;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-11;\n\nint N;\nstring s[100];\nint dots[100];\n\nint multi(int num);\n\nint add(int num) {\n    int n = dots[num];\n    int m = num;\n    for (int i = num + 1; i < N; i++) {\n        if (dots[i] <= n) {\n            m = i;\n            break;\n        }\n        if (i == N - 1) {\n            m = N;\n        }\n    }\n    int ans = 0;\n    for (int i = num + 1; i < m; i++) {\n        if (isdigit(s[i][n + 1])) {\n            ans += s[i][n + 1] - '0';\n        } else if (s[i][n + 1] == '+') {\n            ans += add(i);\n        } else if (s[i][n + 1] == '*') {\n            ans += multi(i);\n        }\n    }\n    return ans;\n}\n\nint multi(int num) {\n    int n = dots[num];\n    int m = num;\n    for (int i = num + 1; i < N; i++) {\n        if (dots[i] <= n) {\n            m = i;\n            break;\n        }\n        if (i == N - 1) {\n            m = N;\n        }\n    }\n    int ans = 1;\n    for (int i = num + 1; i < m; i++) {\n        if (isdigit(s[i][n + 1])) {\n            ans *= s[i][n + 1] - '0';\n        } else if (s[i][n + 1] == '+') {\n            ans *= add(i);\n        } else if (s[i][n + 1] == '*') {\n            ans *= multi(i);\n        }\n    }\n    return ans;\n}\n\nint main() {\n    while (1) {\n        cin >> N;\n        if (N == 0) {\n            break;\n        }\n        fill(s, s + 100, \"\");\n        fill(dots, dots + 100, 0);\n        for (int i = 0; i < N; i++) {\n            cin >> s[i];\n            int len = s[i].size();\n            int num = 0;\n            for (int j = 0; j < len; j++) {\n                if (s[i][j] != '.') {\n                    break;\n                }\n                num++;\n            }\n            dots[i] = num;\n        }\n        if (isdigit(s[0][0])) {\n            cout << s[0][0] - '0' << endl;\n        } else if (s[0][0] == '+') {\n            cout << add(0) << endl;\n        } else {\n            cout << multi(0) << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint N;\nLL dfs(int& i, int lv, VS& vs){\n  if(vs[i][lv] == '+'){\n\tLL res = 0;\n\t++i;\n\twhile(i<N && SZ(vs[i]) > lv && vs[i][lv] == '.')\n\t  res += dfs(i, lv+1, vs);\n\treturn res;\n  }\n  else if(vs[i][lv] == '*'){\n\tLL res = 1;\n\t++i;\n\twhile(i<N && SZ(vs[i]) > lv && vs[i][lv] == '.')\n\t  res *= dfs(i, lv+1, vs);\n\treturn res;\n  }\n\n  return vs[i++][lv] - '0';\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  while(cin>>N,N){\n\tVS str(N);\n\tREP(i,N) cin >> str[i];\n\tint i = 0;\n\tcout << dfs(i, 0, str) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n//#include <\n#define REP(i,n) for(int i = 0;i < (n);i++)\nusing namespace std;\n\nint n;\nstring s[10000];\n\nint index = 0;\n\nint solve(bool plus,int depth){\n  depth++;\n  int ans;\n  if(plus)ans = 0;\n  else ans = 1;\n  while(index < n && s[index].size() >= depth + 1){//.wokuryosinai\n  if(plus){\n    if(s[index][depth] == '+'){//moguru\n    index++;\n    ans += solve(true,depth);\n    }else if(s[index][depth] == '*'){\n      index++;\n      ans += solve(false,depth);\n    }else{//heiretsu\n    ans += s[index][depth] - '0';\n    index++;\n    }\n  }else{\n    if(s[index][depth] == '+'){//moguru\n    index++;\n    ans *= solve(true,depth);\n    }else if(s[index][depth] == '*'){\n      index++;\n      ans *= solve(false,depth);\n    }else{//heiretsu\n    ans *= s[index][depth] - '0';\n    index++;\n    }\n  }\n  }\nreturn ans;\n}\n\nint main(){\n  while(cin>>n,n){\n    REP(i,n){\n      cin>>s[i];\n    }\n    if(isdigit(s[0][0])){\n      cout << s[0][0] << endl;\n    }else{\n      index = 1;\n      if(s[0][0] == '+')cout << solve(true,0) << endl;\n      else cout << solve(false,0) << endl;\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n\nint N;\n\nstring S[100];\n\nint dfs(int &n,int r){\n    if(isdigit(S[n][r])){\n        return S[n++][r]-'0';\n    }\n    int ret;\n    if(S[n][r]=='+'){\n        n++;\n        ret=0;\n        while(n<N&&S[n].size()>r+1&&S[n][r+1]!='.'){\n            ret+=dfs(n,r+1);\n        }\n    }\n    else{\n        n++;\n        ret=1;\n        while(n<N&&S[n].size()>r+1&&S[n][r+1]!='.'){\n            ret*=dfs(n,r+1);\n        }\n    }\n    return ret;\n}\n\nsigned main(){\n    while(cin>>N,N){\n        rep(i,N)cin>>S[i];\n        int n=0;\n        cout<<dfs(n,0)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint eval(int *l, char *c, int n, int i){\n  switch (c[i]) {\n    case '+':\n    {\n      int sum = 0;\n      for(int k = i+1 ; l[i+1] <= l[k] && i < n ; k++){\n        if(l[i+1] == l[k]){\n          sum += eval(l,c,n,k);\n        }\n      }\n      return sum;\n    }\n    case '*':\n    {\n      int prod = 1;\n      for(int k = i+1 ; l[i+1] <= l[k] && i < n ; k++){\n        if(l[i+1] == l[k]){\n          prod *= eval(l,c,n,k);\n        }\n      }\n      return prod;\n    }\n    default:\n      return c[i] - '0';\n  }\n}\nint main(void){\n  for(;;){\n    int n;\n    cin >> n;\n    if(n == 0){ return 0; }\n    int  l[n];\n    char c[n];\n    for(int i = 0 ; i < n ; i++){\n      string s;\n      cin >> s;\n      l[i] = s.length();\n      c[i] = s[l[i]-1];\n    }\n    cout << eval(l,c,n,0) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define FOR(i, a, b) for(int i=(a);i<(b);i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for(int i=(a);i>=(b);i--)\n#define RREP(i, n) RFOR(i, n, 0)\n#define MFOR(i, m) for(auto i=(m).begin();i!=(m).end();i++)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((int)(x).size())\n\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\n\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1 << 30;\n\ntemplate<typename T>\nvoid printv(vector<T> const& s) {\n  REP(i, SZ(s)) {\n    cout << s[i] << \" \";\n  }\n  cout << endl;\n}\n\nint main () {\n  cin.tie(0);\n  cout << setprecision(10);\n\n  while(1) {\n    int n; cin >> n;\n    if(n == 0) break;\n    stack<string> st;\n    int depth = 0;\n\n    REP(i, n) {\n      string s; cin >> s;\n      int cnt = 0;\n      string num = \"\";\n      REP(j, SZ(s)) {\n        if(s[j] == '.') {\n          cnt++;\n        } else {\n          num = s[j];\n        }\n      }\n\n      if(depth < cnt) {\n        st.push(num);\n        depth++;\n      } else if(depth == cnt) {\n        st.push(num);\n      } else {\n        while(depth > cnt) {\n          vector<string> tmp;\n          string op = \"\";\n          while(!st.empty()) {\n            string now = st.top(); st.pop();\n            if(now == \"+\" || now == \"*\") {\n              op = now;\n              break;\n            } else {\n              tmp.pb(now);\n            }\n          }\n          int ans = stoi(tmp[0]);\n          FOR(k, 1, SZ(tmp)) {\n            if(op == \"+\") {\n              ans += stoi(tmp[k]);\n            } else if(\"*\") {\n              ans *= stoi(tmp[k]);\n            } else {\n              break;\n            }\n          }\n          st.push(to_string(ans));\n          depth--;\n        }\n        st.push(num);\n      }\n    }\n    string op = \"\";\n    vector<string> tmp;\n    string ans = \"\";\n    while(!st.empty()) {\n      string now = st.top(); st.pop();\n      // cout << now << endl;\n      if(now == \"+\" || now == \"*\") {\n        op = now;\n        int ans = stoi(tmp[0]);\n        FOR(k, 1, SZ(tmp)) {\n          if(op == \"+\") {\n            ans += stoi(tmp[k]);\n          } else if(\"*\") {\n            ans *= stoi(tmp[k]);\n          } else {\n            break;\n          }\n        }\n        // cout << \"push \" << ans << endl;\n        st.push(to_string(ans));\n        tmp.clear();\n      } else {\n        if(st.empty()) {\n          ans = now;\n          break;\n        }\n        tmp.pb(now);\n      }\n    }\n\n\n\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint calc(vector<string>&str, vector<int>&level, int n, int max){\n  int lev= level[n];\n  if(str[n][lev]>='0' && str[n][lev] <= '9'){\n    return str[n][lev]-'0';\n  }\n  if(str[n][lev]=='+'){\n    int ans=0;\n    for(int i=n+1; i<max; i++){\n      if(level[i]<=level[n]) break;\n      if(level[i]==level[n]+1){\n        ans += calc(str, level, i, max);\n      }\n    }\n    return ans;\n  }\n  if(str[n][lev]=='*'){\n    int ans=1;\n    for(int i=n+1; i<max; i++){\n      if(level[i]<=level[n]) break;\n      if(level[i]==level[n]+1){\n        ans *= calc(str, level, i, max);\n      }\n    }\n    return ans;\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    int n;\n    cin >> n;\n    if(n==0) break;\n    \n    vector<string> str(n);\n    vector<int> l(n,0);\n    for(int i=0; i<n; i++){\n      cin >> str[i];\n      for(int j=0; str[i][j]=='.'; j++){ l[i]++; }\n    }\n    \n    cout << calc(str, l, 0, n) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint n,row;\nvector<string> str;\n\nint operand(int level) {\n    int answer = 0;\n    switch (str[row][level]) {\n        case '+':\n            row++,level++;\n            answer = 0;\n            while (row < n) {\n                if (str[row].size() < level || str[row][level-1] != '.') break;\n                answer += operand(level);\n            }\n            break;\n\n        case '*':\n            row++,level++;\n            answer = 1;\n            while (row < n) {\n                if (str[row].size() < level || str[row][level-1] != '.') break;\n                answer *= operand(level);\n            }\n            break;\n\n        default: answer = stoi(str[row].substr(level)); row++;\n    }\n    return answer;\n}\n\nint main() {\n    while (cin>>n && n != 0) {\n        row = 0;\n        str = vector<string>(n);\n        for (int i = 0; i < n; i++) cin>>str[i];\n        cout<<operand(0)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 1602.cc: ICPC Calculator\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 20;\n\n/* typedef */\n\ntypedef pair<int,int> pii;\n\nenum { ADD = 10, MUL = 11 };\n\n/* global variables */\n\nchar s[32];\npii ps[MAX_N];\n\n/* subroutines */\n\nint calc(int &u) {\n  int pd = ps[u].first, pv = ps[u].second;\n  u++;\n\n  if (pv == ADD) {\n    int r = 0;\n    while (ps[u].first == pd + 1) r += calc(u);\n    return r;\n  }\n\n  if (pv == MUL) {\n    int r = 1;\n    while (ps[u].first == pd + 1) r *= calc(u);\n    return r;\n  }\n\n  return pv;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    int n;\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n\n    for (int i = 0; i < n; i++) {\n      scanf(\"%s\", s);\n      int d = 0;\n      while (s[d] == '.') d++;\n      ps[i].first = d;\n\n      if (s[d] == '+') ps[i].second = ADD;\n      else if (s[d] == '*') ps[i].second = MUL;\n      else ps[i].second = s[d] - '0';\n    }\n    ps[n] = pii(-1, -1);\n\n    //for (int i = 0; i <= n; i++)\n    //printf(\"(%d,%d)\", ps[i].first, ps[i].second);\n    //putchar('\\n');\n\n    int u = 0;\n    int ans = calc(u);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,l[1000],a[1000],b[1000],c[1000];\nchar s[1000][1000];\nvector<int> v[1000];\nint main(){\n\tscanf(\"%d\",&n);\nwhile(n){\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\" %s\",s[i]);\n\t\tl[i]=strlen(s[i])-1;\n\t\tif(s[i][l[i]]=='+')\n\t\t\tb[i]=1;\n\t\telse if(s[i][l[i]]=='*')\n\t\t\tb[i]=2;\n\t\telse{\n\t\t\tb[i]=0;\n\t\t\ta[i]=s[i][l[i]]-'0';\n\t\t}\n\t}\n\tl[n]=0;\n\tfor(int i=0;i<=100;i++)\n\tv[i].clear();\n\tfor(int i=0;i<n;i++){\n\t\tif(b[i]==0){\n\t\t\tif(l[i]==l[i+1])\n\t\t\t\tv[l[i]].push_back(a[i]);\n\t\t\telse{\n\t\t\t\tv[l[i]].push_back(a[i]);\n\n\t\t\t\tfor(int j=l[i];j>l[i+1];j--){\n\t\t\t\t\t//for(auto k: v[j])\tprintf(\"%d \",k);printf(\"!!i%d\\n\",c[j]);\n\t\t\t\t\tint t=c[j]-1;\n\t\t\t\t\tfor(auto k:v[j])\n\t\t\t\t\t\tif(c[j]==1)\n\t\t\t\t\t\t\tt+=k;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tt*=k;\n\t\t\t\t\t//printf(\"%d %d\\n\",t,j);\n\t\t\t\t\tv[j-1].push_back(t);\n\t\t\t\t\tv[j].clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tc[l[i]+1]=b[i];\n\t\t}\n\t}\n\tprintf(\"%d\\n\",v[0][0]);\n\tscanf(\"%d\",&n);\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n\nvector< pair<int,string> > data;\n\n\nstring solve(int op,vector<int> num){\n\tint ret=0;\n\tif( data[op].second==\"+\" ){\n\t\trep(i,num.size()) ret+=stoi( data[num[i]].second );\n\t}\n\telse if( data[op].second==\"*\" ){\n\t\tret=1;\n\t\trep(i,num.size()) ret*=stoi( data[num[i]].second );\n\t}\n\tstringstream ss;\n\tss<<ret;\n\treturn ss.str();\n}\n\n\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(n==0)break;\n\t\tstring input[50];\n\t\trep(i,n) cin>>input[i];\n\t\t\n\t\tdata.clear();\n\t\trep(i,n) data.push_back(  make_pair( input[i].size(),string(1, input[i][ input[i].size()-1 ] ) )  );\n\t\t\n\t\twhile(1){\n\t\t\tint deepval=0;\n\t\t\tvector<int> deepnum;\n\t\t\trep(i,data.size()){\n\t\t\t\tif( deepval<data[i].first ){\n\t\t\t\t\tdeepval = data[i].first;\n\t\t\t\t\tdeepnum.clear();\n\t\t\t\t\tdeepnum.pb(i);\n\t\t\t\t}\n\t\t\t\telse if(deepval==data[i].first && deepnum[ deepnum.size()-1 ]+1==i){\n\t\t\t\t\tdeepnum.pb(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( deepnum.size()==1 && data.size()==1){ cout<<data[0].second<<endl; break; }\n\t\t\telse{\n\t\t\t\tint op = deepnum[0]-1;\n\t\t\t\tdata[op].second = solve( op,deepnum );\n\t\t\t\t\n\t\t\t\tint len=deepnum.size();\n\t\t\t\trep(i,len) data.erase( data.begin()+op+1 );\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nstring s[111];\n\nint solve(int& idx){\n  int ret;\n  if(isdigit(s[idx].back())) {\n    ret = s[idx].back()-'0', idx++;\n  } else {\n    ret = (s[idx].back() == '*');\n    int base = idx; idx++;\n    while(idx < n && s[base].size()+1 == s[idx].size()) {\n      if(s[base].back() == '+') ret += solve(idx);\n      else if(s[base].back() == '*') ret *= solve(idx);\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(cin >> n, n) {\n    for(int i = 0; i < n; i++) cin >> s[i];\n    int idx = 0;\n    cout << solve(idx) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#include <iostream>\n#include <vector>\n// #include <map>\n#include <string>\n// #include <algorithm>\n// #include <numeric>\n// #include <limits>\n\nusing namespace std;\n\nint n;\nconst short type_n = 0; // number\nconst short type_p = 1; // plus\nconst short type_s = 2; // star\n\nstruct Data {\n\tshort type = -1;\n\tint level = 0;\n\tint val = -1;\n\n\tData() {}\n\n\tData(string str) {\n\t\tfor (auto c : str) {\n\t\t\tif (c == '.') {\n\t\t\t\tlevel++;\n\t\t\t} else if (isdigit(c)) {\n\t\t\t\ttype = type_n;\n\t\t\t\tval = c - '0';\n\t\t\t} else {\n\t\t\t\tif (c == '+') {\n\t\t\t\t\ttype = type_p;\n\t\t\t\t} else {\n\t\t\t\t\ttype = type_s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid print() {\n\t\tcout << \"level \" << level << \" type \" << type << \" : \" << val << endl;\n\t}\n\n};\n\nvector<Data> datas;\n\nvoid input() {\n\tdatas.resize(n);\n\tstring str;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> str;\n\t\tData d(str);\n\t\tdatas[i] = d;\n\t}\n}\n\nint run(int key) {\n\tauto& d = datas[key];\n\tif (d.val != -1) {\n\t\treturn d.val;\n\t}\n\tif (d.type == type_p) {\n\t\td.val = 0;\n\t\tint l = d.level + 1; // target level\n\t\tfor (key += 1; key < n; key++) {\n\t\t\tif (datas[key].level == l) {\n\t\t\t\td.val += run(key);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (datas[key].level < l) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (d.type == type_s) {\n\t\td.val = 1;\n\t\tint l = d.level + 1; // target level\n\t\tfor (key += 1; key < n; key++) {\n\t\t\tif (datas[key].level == l) {\n\t\t\t\td.val *= run(key);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn d.val;\n}\n\nvoid solve() {\n\tinput();\n\tcout << run(0) << endl;\n\t//std::cout << \"debug \" << std::endl; // debug\n\t//for (auto d : datas) {\n\t//\td.print();\n\t//}\n\t//std::cout << \"debug end \" << std::endl; // debug\n}\n\nint main() {\n\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tsolve();\n\t}\n\n\t//std::cout << \"\\e[38;5;0m\\e[48;5;40m --- end ---  \\e[m\" << std::endl; // debug\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint idx = 0;\nint n;\nvector<string> str;\n\nint func(){\n\tint depth = str[idx].length();\n\tchar ch = str[idx][depth-1];\n\tif(isdigit(ch)) return atoi(&ch);\n\tint tmp = 0;\n\tif(ch == '*') tmp = 1;\n\tidx++;\n\twhile(idx < n){\n\t\tint len = str[idx].length();\n\t\tif(len <= depth) break;\n\t\tchar c = str[idx][len-1];\n\t\tif(isdigit(c)){\n\t\t\tif(ch == '+') tmp += (c-'0');\n\t\t\telse tmp *= (c-'0');\n\t\t\tidx++;\n\t\t} else{\n\t\t\tif(ch == '+') tmp += func();\n\t\t\telse tmp *= func();\n\t\t}\n\t}\n\treturn tmp;\n}\n\n\nint main(void){\n\twhile(1){\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tstr.clear();\n\t\tstr.resize(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> str[i];\n\t\t}\n\t\tidx = 0;\n\t\tcout << func() << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1e9\n#define ll long long\n#define ull unsigned long long\n#define M 1000000007\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define RFOR(i,m,n) for(int i=m;i>=n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n\nstring s[100];\nint a[100];\nint n;\n\n\nvoid g(int k,int m){\n\n  int i=k+1;\n  int res = a[k];\n\n  while((int)s[i].length()==m){\n    if(s[k-1][s[k-1].length()-1]=='+'){\n      res+=a[i];\n    }\n    else{\n      res*=a[i];\n    }\n    i++;\n  }\n\n  a[k-1]=res;\n  rep(j,n){\n    s[k+j]=s[i+j];\n    a[k+j]=a[i+j];\n  }\n\n}\n\n\n\n\nvoid f(){\n\n  int m=0;\n  rep(i,n){\n    cin>>s[i];\n    m = max(m,(int)s[i].length());\n    a[i]=s[i][(int)s[i].length()-1]-'0';\n  }\n\n  while(m>1){\n    rep(i,n){\n      if((int)s[i].length()==m){\n        g(i,m);\n      }\n    }\n    m--;\n  }\n\n  cout<<a[0]<<endl;\n\n\n}\n\n\nint main(){\n\n  while(1){\n    cin>>n;\n    if(n==0) break;\n    f();\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nstring s[30];\nint dfs(int d,int k){\n  bool e=0;\n  int res=0;\n  if(s[d][k]=='+')d++,k++;\n  if(s[d][k]=='*')e=1,d++,k++,res=1;\n  for(int i=d;i<n&&k<s[i].size();i++){\n    if(s[i][k]=='.')continue;\n    int a=s[i][k]-'0';\n    if(s[i][k]=='+'||s[i][k]=='*')a=dfs(i,k);\n    if(e)res*=a;\n    else res+=a;\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>s[i];\n    cout<<dfs(0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i, n, N) for(ll i=(n);i<(N);i++)\n#define RREP(i, n, N) for(ll i=(N-1);i>=(n);i--)\n#define CK(n, a, b) ((a)<=(n)&&(n)<(b))\n#define ALL(v) (v).begin(), (v).end()\n#define MCP(a, b) memcpy(b,a, sizeof(b))\n#define p(s) cout<<(s)<<endl\n#define p2(a, b) cout<<(a)<<\" \"<<(b)<<endl\ntypedef long long ll;\nusing namespace std;\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\n\nll N;\n\nint main() {\n    while (cin >> N, N) {\n        string s[30];\n        REP(i, 0, N) {\n            cin >> s[i];\n        }\n        if(N==1){\n            cout<<s[0]<<endl;\n            continue;\n        }\n        char op[30];\n        queue<ll> num[30];\n        ll now_level = 0;\n        ll ans = 0;\n        REP(i, 0, N) {\n            ll next_level = s[i].size();\n            if (next_level >= now_level) {\n                if (isdigit(s[i].back())) {\n                    num[next_level].push(s[i].back() - '0');\n                } else {\n                    op[next_level] = s[i].back();\n                }\n            } else if (next_level < now_level) {\n                RREP(j, next_level+1, now_level + 1) {\n                    ll tmp=0;\n                    if(op[j - 1]=='*') tmp=1;\n                    while (!num[j].empty()) {\n                        if (op[j - 1] == '+') {\n                            tmp += num[j].front();\n                        } else {\n                            tmp *= num[j].front();\n                        }\n\n                        num[j].pop();\n                    }\n                    num[j-1].push(tmp);\n                }\n                if (isdigit(s[i].back())) {\n                    num[next_level].push(s[i].back() - '0');\n                } else {\n                    op[next_level] = s[i].back();\n                }\n            }\n            now_level = next_level;\n        }\n\n        RREP(j, 2, now_level + 1) {\n            ll tmp=0;\n            if(op[j - 1]=='*') tmp=1;\n            while (!num[j].empty()) {\n                if (op[j - 1] == '+') {\n                    tmp += num[j].front();\n                } else {\n                    tmp *= num[j].front();\n                }\n\n                num[j].pop();\n            }\n            num[j-1].push(tmp);\n        }\n        p(num[1].front());\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n\nusing namespace std;\n\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//四捨五入\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り上げ\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define SUM_P(v, w) partial_sum((v).begin(), (v).end(), (w).begin())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define FOUT_L(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n        T d = EXTGCD(-a, b, x, y);\n        x = -x;\n        return d;\n    }\n    if (b < 0) {\n        T d = EXTGCD(a, -b, x, y);\n        y = -y;\n        return d;\n    }\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    } else {\n        T d = EXTGCD(b, a % b, x, y);\n        T t = x;\n        x = y;\n        y = t - (a / b) * y;\n        return d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T) (SQR(i)) < b; i++) {\n        if (small[i]) {\n            for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n                prime[j - a] = false;\n            }\n        }\n    }\n\n    return prime;\n}\n\n//約数\ntemplate<class T>\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//組み合わせ個数\ntemplate<typename T>\nT NCR(T n, T r) {\n    T ans = 1;\n    REPLL(i, r) {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//行列\nint MATRIZ_CHAIN(VI &p, VVI &s) {\n    const static int INF = 1 << 20;\n    const int n = p.size() - 1;\n    VVI X(n, VI(n, INF));\n    s.resize(n, VI(n));\n    for (int i = 0; i < n; ++i) X[i][i] = 0;\n    for (int w = 1; w < n; ++w)\n        for (int i = 0, j; j = i + w, j < n; ++i)\n            for (int k = i; k < j; ++k) {\n                int f = p[i] * p[k + 1] * p[j + 1];\n                if (X[i][k] + X[k + 1][j] + f < X[i][j]) {\n                    X[i][j] = X[i][k] + X[k + 1][j] + f;\n                    s[i][j] = k;\n                }\n            }\n    return X[0][n - 1];\n}\n\n//最長増加部分列\nVI LIS(const VI &a) {\n    const static int INF = 99999999;\n    const int n = a.size();\n    VI A(n, INF);\n    VI id(n);\n    for (int i = 0; i < n; ++i) {\n        id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n        A[id[i]] = a[i];\n    }\n    int m = *max_element(id.begin(), id.end());\n    VI b(m + 1);\n    for (int i = n - 1; i >= 0; --i)\n        if (id[i] == m) b[m--] = a[i];\n    return b;\n}\n\n//最長共通部分列 string->toVC\ntemplate<typename T>\nvector<T> LCS(const vector<T> &a, const vector<T> &b) {\n    const int n = a.size(), m = b.size();\n    vector<VI> X(n + 1, VI(m + 1));\n    vector<VI> Y(n + 1, VI(m + 1));\n    REP(i, n) {\n        REP(j, m) {\n            if (a[i] == b[j]) {\n                X[i + 1][j + 1] = X[i][j] + 1;\n                Y[i + 1][j + 1] = 0;\n            } else if (X[i + 1][j] < X[i][j + 1]) {\n                X[i + 1][j + 1] = X[i][j + 1];\n                Y[i + 1][j + 1] = +1;\n            } else {\n                X[i + 1][j + 1] = X[i + 1][j];\n                Y[i + 1][j + 1] = -1;\n            }\n        }\n    }\n    vector<T> c;\n    for (int i = n, j = m; i > 0 && j > 0;) {\n        if (Y[i][j] > 0) --i;\n        else if (Y[i][j] < 0) --j;\n        else {\n            c.PB(a[i - 1]);\n            --i;\n            --j;\n        }\n    }\n    REVERSE(c);\n    return c;\n}\n\n//コイン C総額 cs使用できるコインの種類\nVI money_change(int C, VI &cs) {\n    const int INF = 99999999;\n    int n = cs.size();\n    VI xs(C + 1, INF);\n    VI ys(C + 1);\n    xs[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int c = 0; c + cs[i] <= C; ++c) {\n            if (xs[c + cs[i]] > xs[c] + 1) {\n                xs[c + cs[i]] = xs[c] + 1;\n                ys[c + cs[i]] = c;\n            }\n        }\n    }\n    VI zs;\n    for (int c = C; c > 0; c = ys[c]) {\n        zs.push_back(c - ys[c]);\n    }\n    return zs;\n}\n\n\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(a, b) memset((a), (b),sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n * */\n\nbool comp(const string &left, const string &right) {\n    return left.length() > right.length();\n}\n\nint main() {\n\n    int N;\n\n\n    while (true) {\n        cin >> N;\n\n        if (N == 0) {\n            break;\n        }\n\n        VS S(N);\n        REP(i, N) {\n            cin >> S[i];\n        }\n\n        if (N == 1) {\n            OUT_L(S[0]);\n            continue;\n        }\n\n        sort(S.begin(), S.end(), comp);\n\n        int index = 0;\n        int sum = 0;\n        while (true) {\n\n            if(index>=N){\n                break;\n            }\n\n            int length = S[index].size();\n            int count = 0;\n            while (S[index + count].size() == length) {\n                count++;\n            }\n\n            VI datas;\n            for (int i = 0; i < count; i++) {\n                if (S[index + i][length - 1] != '+' && S[index + i][length - 1] != '*') {\n                    datas.push_back(S[index + i][length - 1] - '0');\n                }\n            }\n\n            bool plus = true;\n            for(int i=0;i<N;i++){\n                if(S[i].length()==length-1){\n                    if(S[i][length-1-1]=='*'){\n                        plus = false;\n                    }\n                }\n            }\n\n            if(plus) {\n                for (int i = 0; i < datas.size(); i++) {\n                    sum += datas[i];\n                }\n            }else{\n                if(sum==0){\n                    sum = 1;\n                }\n                for(int i=0;i<datas.size();i++){\n                    sum *= datas[i];\n                }\n            }\n\n            index+=count;\n\n        }\n\n        OUT_L(sum);\n\n    }\n\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\n\nint main(){\n  int n;\n  while(1){\n    stack<int> statsmemo,pointmemo;\n    cin>>n;\n    if(n==0) break;\n    int now=1,stats=-1,point=0;\n    int count=0;\n    lp(z,n){\n      count=0;\n      char q;\n      while(1){\n\tcin>>q;\n\tcount++;\n\tif(q!='.') break;\n      }\n      if(count<now){\n\twhile(count!=now){\n\t  int statsed,pointed;\n\t  statsed=statsmemo.top();\n\t  pointed=pointmemo.top();\n\t  statsmemo.pop();\n\t  pointmemo.pop();\n\t  if(statsed==0){\n\t    point+=pointed;\n\t  }\n\t  if(statsed==1){\n\t    if(point==0){\n\t      point+=pointed;\n\t    }\n\t    else point*=pointed;\n\t  }\n\t  stats=statsed;\n\t  now--;\n\t}\n\tnow=count;\n      }\n      if(q=='+'){\n\tif(stats!=-1){\n\t  statsmemo.push(stats);\n\t  pointmemo.push(point);\n\t}\n\tstats=0;\n\tpoint=0;\n\tnow++;\n      }\n      if(q=='*'){\n\tif(stats!=-1){\n\t  statsmemo.push(stats);\n\t  pointmemo.push(point);\n\t}\n\tstats=1;\n\tpoint=0;\n\tnow++;\n      }\n      if('0'<=q && q<='9'){\n\tif(stats==0) point+=q-'0';\n\tif(stats==1){\n\t  if(point==0) point+=q-'0';\n\t  else point*=q-'0';\n\t}\n\tif(stats==-1) point+=q-'0';\n      }\n    }\n    while(count>2){\n      int statsed,pointed;\n      statsed=statsmemo.top();\n      pointed=pointmemo.top();\n      statsmemo.pop();\n      pointmemo.pop();\n      if(statsed==0){\n\tpoint+=pointed;\n      }\n      if(statsed==1){\n\tif(point==0){\n\t  point+=pointed;\n\t}\n\telse point*=pointed;\n      }\n      stats=statsed;\n      count--;\n    }\n    cout<<point<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <cassert>\nusing namespace std;\n\ntypedef pair<int, char> PIC;\ntypedef pair<int, int> PII;\n\nint main(void) {\n  int N;\n  while (cin >> N, N) {\n    vector<PIC> lines(N);\n\n    for (int i = 0; i < N; i++) {\n      string line;\n      cin >> line;\n\n      lines[i].first = line.size() - 1;\n      lines[i].second = line.back();\n    }\n\n    if (lines[0].second == '+') {\n      lines.push_back(PIC(0, '0'));\n    }\n    \n    if (lines[0].second == '*') {\n      lines.push_back(PIC(0, '1'));\n    }\n\n    vector<char> operators;\n    vector<PII> operands;\n    \n    int now_dep = 0;\n    for (auto line : lines) {\n      int dep = line.first;\n      char sym = line.second;\n    \n      while (dep < now_dep) {\n        char op = operators.back();\n        operators.pop_back();\n        int res = ((op == '+') ? 0 : 1);\n     \n        while (operands.back().first == now_dep) {\n          int operand = operands.back().second;\n          operands.pop_back();\n          if (op == '+') res += operand;\n          else res *= operand;\n        }\n       \n        now_dep--;\n        operands.push_back(PII(now_dep, res));\n      }\n    \n      now_dep = dep;\n     \n      if (sym == '+' || sym == '*') operators.push_back(sym);\n      else operands.push_back(PII(now_dep, sym - '0'));\n    }\n\n    // if (operators.size() != 0) {\n    //     char op = operators.back();\n    //     operators.pop_back();\n    //     int res = ((op == '+') ? 0 : 1);\n    //\n    //     while (!operands.empty()) {\n    //       int operand = operands.back().second;\n    //       operands.pop_back();\n    //       if (op == '+') res += operand;\n    //       else res *= operand;\n    //     }\n    //\n    //     now_dep--;\n    //     operands.push_back(PII(now_dep, res));\n    // }\n\n    cout << operands[0].second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nstring s[30];\nint dfs(int d,int k,int e){\n  int res=0;\n  if(e)res=1;\n  for(int i=d;i<n&&k<s[i].size();i++){\n    if(s[i][k]=='.')continue;\n    int a=s[i][k]-'0';\n    if(s[i][k]=='+')a=dfs(i+1,k+1,0);\n    if(s[i][k]=='*')a=dfs(i+1,k+1,1);\n    if(e)res*=a;\n    else res+=a;\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>s[i];\n    cout<<dfs(0,0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <typeinfo>\n\n#define REP(i,n) for(int i=0; i<n; i++)\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\nusing namespace std;\n\nstring eq[50];\nint n, j;\n\n\nint calc(int l, int po){\n\t//printf(\"calc(%d, %d)\\n\",l, j);\n\tint ans, num;\n\tbool op;\n\tchar c;\n\t\n\tj = po;\n\t\n\tif (eq[j][l]=='+') op = true;\n\telse op = false;\n\t\n\tans = op ? 0 : 1;\n\t\n\tj++;\n\twhile(1){\n\t\tif (eq[j].length()<=l+1){\n\t\t\tj--;\n\t\t\tbreak;\n\t\t}\n\t\tc = eq[j][eq[j].length()-1];\n\t\tif (c=='+' || c=='*'){\n\t\t\tnum = calc(l+1, j);\n\t\t}else{\n\t\t\tnum = c-'0';\n\t\t}\n\t\tans = op ? ans+num : ans*num;\n\t\t//debug(j);\n\t\t//debug(ans);\n\t\tj++;\n\t}\n\t//printf(\"calc(%d, %d) = %d\\n\", l, po, ans);\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\tj = 0;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\tREP(i,n){\n\t\t\tcin >> eq[i];\n\t\t}\n\t\tif (n<=1){\n\t\t\tcout << eq[0] << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcout << calc(0,0) << endl;\n\t\t//cout << \"-------\" << endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nstruct Data{\n\tint len;\n\tchar data;\n};\n\nint n, i=0;\nData val[50];\n\nint solve(){\n\tint ans, depth = val[i].len;\n\tchar c=val[i++].data;\n\tif(c=='+')ans=0;\n\telse if(c=='*') ans=1;\n\n\twhile(i<n && val[i].len > depth){\n\t\tif(isdigit(val[i].data)){\n\t\t\tif(c=='+')ans+=val[i++].data-'0';\n\t\t\telse if(c=='*') ans*=val[i++].data-'0';\n\t\t} else{\n\t\t\tif(c=='+')ans+=solve();\n\t\t\telse if(c=='*') ans*=solve();\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tval[i].len = 0;\n\t\t\tval[i].data = '\\0';\n\t\t}\n\t\tchar tmp[50];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> tmp;\n\t\t\tval[i].len = strlen(tmp);\n\t\t\tval[i].data= tmp[strlen(tmp)-1];\n\t\t}\n\t\ti=0;\n\t\tif(n==1) cout << val[i].data << endl;\n\t\telse cout << solve() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#include<stack>\n#define INF 2147483647\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<string>vs(n);\n    for(int i=0;i<n;i++)cin>>vs[i];\n    vector<pair<int,int> >sp;\n    vector<pair<int,char> >sta;\n    for(int i=0;i<n;i++){\n      string str=vs[i];\n      if(str[str.size()-1]=='+'){\n\tsta.pb(mp(str.size(),'+'));\n      }else if(str[str.size()-1]=='*'){\n\tsta.pb(mp(str.size(),'*'));\n      }else{\n\tif((sta.empty())||(str.size()==(sta[sta.size()-1].F+1))){\n\t  char ccc=str[str.size()-1];\n\t  int nnn=ccc-'0';\n\t  sp.pb(mp(nnn,str.size()));\n\t}else{\n\t  if(sta[sta.size()-1].S=='+'){\n\t    int sum=0;\n\t    while(sp[sp.size()-1].S==sta[sta.size()-1].F+1){\n\t      int num=sp[sp.size()-1].F;\n\t      sp.pop_back();\n\t      sum+=num;\n\t    }\n\t    sp.pb(mp(sum,sta[sta.size()-1].F));\n\t    sta.pop_back();\n\t  }else if(sta[sta.size()-1].S=='*'){\n\t    int sum=1;\n\t    while(sp[sp.size()-1].S==sta[sta.size()-1].F+1){\n\t      int num=sp[sp.size()-1].F;\n\t      sp.pop_back();\n\t      sum*=num;\n\t    }\n\t    sp.pb(mp(sum,sta[sta.size()-1].F));\n\t    sta.pop_back();\n\t  }\n\t  i--;\n\t}\n      }\n    }\n    int ans=0;\n    if(sta[0].S=='+'){\n      for(int i=0;i<sp.size();i++){\n\tans+=sp[i].F;\n\t//cout<<sp[i].F<<endl;\n      }\n    }else{\n      ans=1;\n      for(int i=0;i<sp.size();i++){\n\tans*=sp[i].F;\n\t//cout<<sp[i].F<<endl;\n      }\n    }\n    //cout<<sta.size()<<\" \"<<sp.size()<<endl;\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  while(1){\n    int n;\n    cin >> n;\n    if(n==0) return 0;\n    stack<pair<char,int>> st;\n    st.push({'+',0});\n    string s;\n    int now=0;\n    rep(i,n){\n      cin >> s;\n      while(s.length()<=now){\n        int p = st.top().second;\n        st.pop();\n        if(st.top().first=='+'){\n          st.top().second+=p;\n        }else{\n          st.top().second*=p;\n        }\n        now--;\n      }\n      if(s[now]=='+'){\n        st.push({'+',0});\n        now++;\n      }else if(s[now]=='*'){\n        st.push({'*',1});\n        now++;\n      }else{\n        if(st.top().first=='+'){\n          st.top().second+=s[now]-'0';\n        }else{\n          st.top().second*=s[now]-'0';\n        }\n      }\n    }\n    while(st.size()>1){\n      int p = st.top().second;\n      st.pop();\n      if(st.top().first=='+'){\n        st.top().second+=p;\n      }else{\n        st.top().second*=p;\n      }\n    }\n    cout << st.top().second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    stack<string> st;\n    string e;\n    int d = 0;\n    for(int i = 0; i < n; ++i){\n      cin >> e;\n      int l = e.length();\n      e = e[l-1];\n      while(l < d){\n\tvector<int> t;\n\tstring s = st.top();\n\twhile(s.length() > 1 || (s >= \"0\" && s <= \"9\")){\n\t  t.push_back(stoi(s));\n\t  st.pop();\n\t  s = st.top();\n\t}\n\tstring o = \"\";\n\tif(!st.empty()){\n\t  o = st.top();\n\t  st.pop();\n\t}\n\tif(o == \"\"){\n\t  if(t.size() > 1){\n\t    cout << \"Error\" << endl;\n\t  }else{\n\t    cout << t[0] << endl;\n\t  }\n\t}else{\n\t  if(o == \"+\"){\n\t    int ret = 0;\n\t    for(int i = 0; i < t.size(); ++i){\n\t      ret += t[i];\n\t    }\n\t    st.push(to_string(ret));\n\t    --d;\n\t  }else if(o == \"*\"){\n\t    int ret = 1;\n\t    for(int i = 0; i < t.size(); ++i){\n\t      ret *= t[i];\n\t    }\n\t    st.push(to_string(ret));\n\t    --d;\n\t  }\n\t}\n      }\n      st.push(e);\n      d = l;\n    }\n\n    stack<int> st2;\n    while(!st.empty()){\n      string e = st.top();\n      st.pop();\n      if(e == \"+\"){\n\tint k = 0;\n\twhile(!st2.empty()){\n\t  int l = st2.top();\n\t  k += l;\n\t  st2.pop();\n\t}\n\tst.push(to_string(k));\n      }else if(e == \"*\"){\n\tint k = 1;\n\twhile(!st2.empty()){\n\t  int l = st2.top();\n\t  k *= l;\n\t  st2.pop();\n\t}\n\tst.push(to_string(k));\n      }else{\n\tst2.push(stoi(e));\n      }\n      if(st.empty()){\n\tcout << st2.top() << endl;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define RFOR(i,k,n) for (int (i)=(n)-1; (i)>=(k); --(i))\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define pb push_back\n#define mp make_pair\n#define all(v) begin(v), end(v)\n#define fst first\n#define snd second\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\nusing namespace std;\n\nint main(){\n    int n;\n    vector<string> s;\n    while(cin>>n && n){\n        s.resize(n);\n        REP(i,n){\n            cin >> s[i];\n        }\n        queue<pair<char,int> > Qa;\n        queue<char> Qb;\n        int lv,lvmax = 0;\n        RREP(i,n){\n            lv = s[i].length() - 1;\n            lvmax = max(lvmax, lv);\n            char c = s[i][lv];\n            if(c == '+' || c == '*'){\n                lv++;\n            }\n            Qa.push(mp(c,lv));\n        }\n        while(!Qa.empty() && lvmax >= 0){\n            int size = Qa.size();\n            REP(i,size){\n                auto p = Qa.front();\n                Qa.pop();\n                if(p.snd >= lvmax){\n                    Qb.push(p.fst);\n                }\n                else{\n                    Qa.push(p);\n                }\n            }\n            lvmax--;\n        }\n        REP(i,Qb.size()){\n            Qb.push(Qb.front());\n            Qb.pop();\n        }\n        stack <int> S;\n        while(!Qb.empty()){\n            if(Qb.front() == '+'){\n                int sum = 0;\n                while(!S.empty()){\n                    sum += (S.top());\n                    S.pop();\n                }\n                S.push(sum);\n            }\n            else if(Qb.front() == '*'){\n                int pro = 1;\n                while(!S.empty()){\n                    pro *= (S.top());\n                    S.pop();\n                }\n                S.push(pro);\n            }\n            else{\n                S.push(Qb.front() - '0');\n            }\n            Qb.pop();\n        }\n        cout << S.top() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n// typedef\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<string> vs;\n \n// container util\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for (typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n// repetition\n#define FOR(i,m,n) for (ll (i) = ((ll) m); (i) < ((ll) n); ++(i))\n#define RFOR(i,m,n) for (ll (i) = ((ll) (m)-1); (i) >= ((ll) n); --(i))\n#define REP(i,n) FOR(i,0,n)\n \n// i/o\n#define TFOUT(b,t,f) cout << ((b)? (t) : (f)) << endl\n \n// clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n \n// debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\n\n\nstruct Cell {\n    bool is_num;\n    char sym;\n    int num;\n    vector<Cell> cells;\n};\n\nstring expr(int n) {\n    string expr;\n    string s; cin >> s;\n    expr.push_back(s[0]);\n    int depth = 1;\n    REP(i, n-1) {\n        string s; cin >> s;\n        int len = s.length();\n        if (len > depth) {\n            REP(i, len - depth) {\n                expr.push_back('(');\n            }\n        } else if (len < depth) {\n            REP(i, depth - len) {\n                expr.push_back(')');\n            }\n        }\n        expr.push_back(s[len-1]);\n        depth = len;\n    }\n    REP(i, depth-1) {\n        expr.push_back(')');\n    }\n    depth = 1;\n    return expr;\n}\n\nCell tree_(const string& expr, int& pos) {\n    Cell result;\n    if (expr[pos] == '+' || expr[pos] == '*') {\n        result.is_num = false;\n        result.sym = expr[pos];\n        pos++;\n        pos++;\n        while (true) {\n            result.cells.push_back(tree_(expr, pos));\n            if (expr[pos] == ')') break;\n        }\n        pos++;\n    } else {\n        result.is_num = true;\n        result.num = expr[pos] - '0';\n        pos++;\n    }\n    return result;\n}\n\nCell tree(const string& expr) {\n    int pos = 0;\n    return tree_(expr, pos);\n}\n\nCell eval(Cell& cell) {\n    for (int i = 0; i < cell.cells.size(); i++) {\n        cell.cells[i] = eval(cell.cells[i]);\n    }\n    if (cell.is_num) return cell;\n    if (cell.sym == '+') {\n        int num = 0;\n        for (int i = 0; i < cell.cells.size(); i++) {\n            num += cell.cells[i].num;\n        }\n        cell.is_num = true;\n        cell.num = num;\n        return cell;\n    } else {\n        int num = 1;\n        for (int i = 0; i < cell.cells.size(); i++) {\n            num *= cell.cells[i].num;\n        }\n        cell.is_num = true;\n        cell.num = num;\n        return cell;\n    }\n}\n\nvoid solve(int n) {\n    string e = expr(n);\n    Cell c = tree(e);\n    c = eval(c);\n    cout << c.num << endl;;\n}\nint main() {\n    while(true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        solve(n);\n    }\n    return 0;\n}\n\n/*\nnum  ::= [0-9]\nop   ::= + | *\nexpr ::= num | op (expr expr)\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,idx; string s;\nvector<string> v;\n\nint exp(){\n    char c=v[idx].back(),lev=v[idx].size(); ++idx;\n    if (isdigit(c)) return c-'0';\n    int res=(c=='*');\n    while(idx<n&&lev<v[idx].size()){\n        if (c=='*') res*=exp();\n        if (c=='+') res+=exp();\n    }\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> n,n){\n        v.clear();\n        for (int i=0;i<n;++i){\n            cin >> s; v.emplace_back(s);\n        }\n        idx=0;\n        cout << exp() << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,d[200],p;\nchar c[200];\nstring s;\nint f(void){\n    if('0'<=c[p]&&c[p]<='9')return c[p++]-'0';\n    int k=p++,tmp=0;\n    if(c[k]=='*')tmp=1;\n    while(d[p]==d[k]+1){\n        if(c[k]=='*')tmp*=f();\n        else tmp+=f();\n    }\n    //cout<<tmp<<endl;\n    return tmp;\n}\nint main(void){\n    while(1){\n    cin>>n;\n    if(!n)return 0;\n    for(int i=0;i<200;i++){d[i]=0;}\n    for(int i=0;i<n;i++){\n        cin>>s;\n        d[i]=s.size();\n        c[i]=s[s.size()-1];\n    }\n    p=0;\n    cout<<f()<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n; i++)\nusing namespace std;\nint n;\nvector<string> v;\nint count(int line){\n  int res = 0;\n  int i = 0;\n  while(v[line][i++]=='.') res++;\n  return res;\n}\nint calc(int& line,int depth){\n  if(v[line][depth]=='+'){\n    int ret=0;\n    line++;\n    while(line<n && count(line)==depth+1){\n      ret += calc(line,depth+1);\n    }\n    return ret;\n  }\n  else if(v[line][depth]=='*'){\n    int ret=1;\n    line++;\n    while(line<n && count(line)==depth+1){\n      ret *= calc(line,depth+1);\n    }\n    return ret;\n  }\n  else return v[line++][depth]-'0';\n}\nint solve(){\n    int line = 0;\n    int ans = calc(line,0);\n    return ans;\n}\nint main(){\n  while(cin >> n,n){\n    v.resize(n);\n    rep(i,n) cin >> v[i];\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint n;\nvector< pair<int, int> > input;\n\nint dfs(int* p) {\n  int t = input[*p].first + 1;\n  char e = (char) input[*p].second;\n  int ans = e == '+' ? 0 : e == '*' ? 1 : e;\n  for((*p)++; input[*p].first >= t && *p < n;) if(e == '+') ans += dfs(p); else ans *= dfs(p);\n  return ans;\n}\n\nint main(void) {\n  while(cin >> n, n != 0) {\n    input.clear();\n    REP(i, 0, n) {\n      string line; cin >> line;\n      int level = 0;\n      for(; line[level] == '.'; level++);\n      input.push_back(pair<int, int>(level, line[level] == '+' || line[level] == '*' ? line[level] : line[level] - '0'));\n    }\n    int i = 0;\n    cout << dfs(&i) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> str;\nvector<int> level;\n\nint calc(int n, int max){\n  int lev= level[n];\n  if(str[n][lev]>='0' && str[n][lev] <= '9'){\n    return str[n][lev]-'0';\n  }\n  if(str[n][lev]=='+'){\n    int ans=0;\n    for(int i=n+1; i<max; i++){\n      if(level[i]<=level[n]) break;\n      if(level[i]==level[n]+1){\n        ans += calc(i, max);\n      }\n    }\n    return ans;\n  }\n  if(str[n][lev]=='*'){\n    int ans=1;\n    for(int i=n+1; i<max; i++){\n      if(level[i]==level[n]+1){\n        ans *= calc(i, max);\n      }\n    }\n    return ans;\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    int n;\n    cin >> n;\n    if(n==0) break;\n    \n    vector<string> input(n);\n    vector<int> l(n,0);\n    for(int i=0; i<n; i++){\n      cin >> input[i];\n      for(int j=0; input[i][j]=='.'; j++){ l[i]++; }\n    }\n    str = input;\n    level = l;\n    \n    cout << calc(0, n) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\nclass Solve {\npublic:\n    void input() {\n\n    }\n\n    // 文字列, レベル\n    pair<char, int> parse(string s) {\n        int lv = s.size();\n        char c = s.back();\n        return make_pair(c, lv);\n    }\n\n    bool isDigit(char c) {\n        return c >= '0' && c <= '9';\n    }\n\n    bool solve() {\n        int n;\n        cin >> n;\n        if (n == 0) return false;\n        input();\n\n        vector<pair<char, int>> input;\n        for (int i = 0; i < n; ++i) {\n            string s;\n            cin >> s;\n            input.push_back(parse(s));\n        }\n        reverse(all(input));\n\n        stack<pair<int, int>> st; //(value(int), level)\n        for (int i = 0; i < n; ++i) {\n            if (isdigit(input[i].first)) {\n                st.emplace(input[i].first - '0', input[i].second);\n            } else {\n                vector<int> values;\n                while (!st.empty() && st.top().second == input[i].second + 1) {\n                    values.push_back(st.top().first);\n                    st.pop();\n                }\n                int val;\n                if (input[i].first == '+') {\n                    val = accumulate(all(values), 0);\n                } else {\n                    val = 1;\n                    for (auto e : values) {\n                        val *= e;\n                    }\n                }\n                pair<int, int> p(val, input[i].second);\n                st.push(p);\n            }\n        }\n        cout << st.top().first << endl;\n        return true;\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (Solve().solve()) {}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\nstruct CLASSNUM{\n  char op;\n  vector<int> num;\n};\n\nint main(){\n  int n,j;\n  string str;\n  CLASSNUM classNum[9];\n  while(true){\n    cin >> n;\n    if(n == 0) break;\n    for(int i = 0; i < n; i++){\n      cin >> str;\n\n      j = 0;\n      while(str[j] == '.'){\n        j++;\n      }\n\n      if(j!=0) str = str.substr(j,1);\n\n      if(str == \"+\") classNum[j+1].op = '+';\n      else if(str == \"*\")classNum[j+1].op = '*';\n      else{\n        classNum[j].num.push_back(atoi(str.c_str()));\n\n        if(classNum[j].num.size() == 2 && classNum[j].op == '+') {\n          classNum[j].num[0] = classNum[j].num[0] + classNum[j].num[1];\n          classNum[j].num.pop_back();\n        }\n        else if (classNum[j].num.size() == 2 && classNum[j].op == '*') {\n          classNum[j].num[0] = classNum[j].num[0] * classNum[j].num[1];\n          classNum[j].num.pop_back();\n        }\n      }\n    }\n    for(int i=8; i >= 1; i--){\n      if(classNum[i].num.size() == 0) continue;\n      else{\n        if(classNum[i-1].num.size() >= 1 && classNum[i-1].op == '+') {\n          classNum[i-1].num[0] = classNum[i].num[0] + classNum[i-1].num[0];\n        }\n        else if (classNum[i-1].num.size() >= 1 && classNum[i-1].op == '*'){\n          classNum[i-1].num[0] = classNum[i].num[0] * classNum[i-1].num[0];\n        }\n        else if(classNum[i-1].num.size() == 0 ){\n          classNum[i-1].num.push_back(classNum[i].num[0]);\n        }\n        else if (classNum[i-1].num.size()== 0) {\n          classNum[i-1].num.push_back(classNum[i].num[0]);\n        }\n      }\n    }\n    cout << classNum[0].num[0] << endl;\n    for(int i = 0; i < 8; i++) classNum[i].num.clear();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  static auto add = [](int a, int b) { return a + b; };\n  static auto mul = [](int a, int b) { return a * b; };\n  int n;\n  while (cin >> n, n) {\n    vector<pair<function<int(int, int)>, int>> v;\n    v.push_back(make_pair(add, 0));\n    for (int i = 0; i < n; i++) {\n      string s;\n      cin >> s;\n      int d = s.size() - 1;\n      char c = *s.rbegin();\n      while (d < v.size() - 1) {\n        int r = v.back().second;\n        v.pop_back();\n        v.rbegin()->second = v.rbegin()->first(v.rbegin()->second, r);\n      }\n      if (c == '+') {\n        v.push_back(make_pair(add, 0));\n      } else if (c == '*') {\n        v.push_back(make_pair(mul, 1));\n      } else {\n        v.rbegin()->second = v.rbegin()->first(v.rbegin()->second, c - '0');\n      }\n    }\n    while (v.size() > 1) {\n      int r = v.back().second;\n      v.pop_back();\n      v.rbegin()->second = v.rbegin()->first(v.rbegin()->second, r);\n    }\n    cout << v.front().second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mux_n = 2000;\n\nenum _operator{\n    _plus,\n    multiply,\n    none\n};\n\nint main() {\n\n    while(1){\n\n        int n;\n\n        cin >> n;\n\n        if(n==0) break;\n\n        string input[n];\n\n        vector<vector<long long int> > level_num;\n        vector<_operator> level_ope;\n\n        level_num.resize(mux_n);\n\n\n        for(int i=0; i<mux_n; i++){\n            level_ope.push_back(none);\n        }\n\n        int max_level = 0;\n\n        for(int i=0; i<n; i++){\n            cin >> input[i];\n            for(int j=0; j<input[i].size(); j++){\n                if(input[i][j] == '+'){\n                    level_ope[j] = _plus;\n                }\n                else if(input[i][j] == '*'){\n                    level_ope[j] = multiply;\n                }\n                else if(input[i][j] != '.'){\n                    string string_now_input_num;\n                    for(int k=j; k<input[i].size(); k++){\n                        string_now_input_num.push_back(input[i][k]);\n                    }\n                    stringstream ss;\n                    ss << string_now_input_num;\n                    int input_num;\n                    ss >> input_num;\n                    level_num[j].push_back(input_num);\n                }\n                max_level = max(max_level,j);\n            }\n        }\n\n        long long int ans = 0;\n        int now_level = max_level;\n\n        while(now_level){\n            if(level_ope[now_level-1] != none){\n                long long int sum;\n                if(level_ope[now_level-1] == _plus){\n                    sum = 0;\n                    for(int i=0; i<level_num[now_level].size(); i++){\n                        sum += level_num[now_level][i];\n                    }\n                }\n                else if(level_ope[now_level-1] == multiply){\n                    sum = 1;\n                    for(int i=0; i<level_num[now_level].size(); i++){\n                        sum *= level_num[now_level][i];\n                    }\n                }\n                if(now_level == 1) {\n                    ans = sum;\n                }\n                else{\n                    level_num[now_level-1].push_back(sum);\n                }\n            }\n            /*else if(level_num[now_level].size() == 1){\n                if(now_level == 1) {\n                    ans = level_num[now_level][0];\n                }\n                else{\n                    level_num[now_level-1].push_back(level_num[now_level][0]);\n                }\n            }*/\n            now_level--;\n        }\n\n        if(n == 1){\n            ans = level_num[0][0];\n        }\n\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n# ifdef _MSVC_LANG\n\n# define _SCL_SECURE_NO_WARNINGS\n# pragma warning( disable : 0325 ) // inline namespace Error\n\n# endif\n\n\n# include <iostream>\n# include <string>\n# include <iomanip>\n# include <cstdio>\n# include <array>\n# include <numeric>\n# include <algorithm>\n# include <vector>\n# include <functional>\n# include <fstream>\n# include <random>\n# include <bitset>\n# include <map>\n# include <unordered_set>\n\n\n// C++ 11 前提\n\nusing Ull = unsigned long long;\nusing Ll = long long;\n\ntemplate<typename T>\nusing Vec = std::vector<T>;\n\ntemplate<typename T, size_t L>\nusing Ary = std::array<T, L>;\n\nnamespace\n{\n\n    namespace meta\n    {\n        namespace coming\n        {\n            // c++ 17;\n            template<class... _Types>\n            using void_t = void;\n\n            template<class _Ty,\n                _Ty _Val>\n                struct integral_constant\n            {\t// convenient template for integral constant types\n                static constexpr _Ty value = _Val;\n\n                using value_type = _Ty;\n                using type = integral_constant;\n\n                constexpr operator value_type() const noexcept\n                {\t// return stored value\n                    return (value);\n                }\n\n                constexpr value_type operator()() const noexcept\n                {\t// return stored value\n                    return (value);\n                }\n            };\n\n            // c++ 17;\n            template<bool _Val>\n            using bool_constant = integral_constant<bool, _Val>;\n\n\n            // c++ 14\n            template<bool _Test,\n                class _Ty = void>\n                using enable_if_t = typename std::enable_if<_Test, _Ty>::type;\n        }\n\n        namespace core\n        {\n\n            template < class, class = void > struct enable_std_begin_end : std::false_type {};\n            template < typename T >\n            struct enable_std_begin_end<T,\n                coming::void_t<decltype(std::begin(std::declval<const T&>()), std::end(std::declval<const T&>()))>> : std::true_type {}; // c++ 17\n\n\n            template < class, class = void > struct enable_adl_begin_end : std::false_type {};\n            template < typename T >\n            struct enable_adl_begin_end<T,\n                coming::void_t<decltype(begin(std::declval<const T&>()), end(std::declval<const T&>()))>> : std::true_type {};\n        }\n\n        template < typename T >\n        struct is_range\n            : coming::bool_constant< core::enable_std_begin_end<T>::value || core::enable_adl_begin_end<T>::value>\n        {\n        };\n\n        /// <summary>\n        /// ある値が0以上か\n        /// </summary>\n        template<class T, T num, class = std::nullptr_t> struct is_positive\n            : coming::bool_constant<(num >= 0)>\n        {\n        };\n\n    }\n\n\n    inline namespace extension\n    {\n        inline namespace container_io\n        {\n            inline namespace in\n            {\n\n                /// <summary>\n                /// for cin with STL container\n                /// </summary>\n                template< template<class ...> class Container, class ... Args, typename = meta::coming::enable_if_t<!std::is_same< typename Container, typename std::basic_string> ::value> >\n                std::istream& operator >> (std::istream& is, Container<Args ...>& container)\n                {\n                    for (auto& elem : container) is >> elem; return is;\n                }\n\n                /// <summary>\n                /// for cin with std::arary\n                /// </summary>\n                template<class T, size_t L>\n                std::istream& operator >> (std::istream& is, std::array<T, L>& container)\n                {\n                    for (auto& elem : container) is >> elem; return is;\n                }\n\n                /// <summary>\n                /// for cin with raw array\n                /// </summary>\n                template<class T, size_t L>\n                std::istream& operator >> (std::istream& is, T(&ary)[L])\n                {\n                    for (int i{}; i < L; ++i) is >> ary[i]; return is;\n                }\n\n            }\n\n            inline namespace out\n            {\n                namespace settings\n                {\n                    /// <summary>\n                    /// 要素間の区切り文字\n                    /// </summary>\n                    const auto sepOfContainerElements{\" \"};\n                    /// <summary>\n                    /// コンテナ間の区切り文字\n                    /// </summary>\n                    const auto sepOfContainer{\"\\n\"};\n                }\n\n\n                /// <summary>\n                /// for cout Container with STL container\n                /// </summary>\n                template < template<class ...> class Container, class ... Args, typename = meta::coming::enable_if_t<!std::is_same< typename Container, typename std::basic_string> ::value> >\n                std::ostream& operator << (std::ostream& os, const Container<Args ...>& container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainerElements; return os;\n                }\n\n                /// <summary>\n                /// for cout Container with std::array\n                /// </summary>\n                template < class T, size_t L>\n                std::ostream& operator << (std::ostream& os, const std::array<T, L> container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainerElements; return os;\n                }\n\n                /// <summary>\n                /// for cout Container with raw array\n                /// </summary>\n                template < class T, size_t L, typename = meta::coming::enable_if_t<!std::is_same<T, char>::value> >\n                std::ostream& operator << (std::ostream& os, const T(&ary)[L])\n                {\n                    for (const auto& elem : ary) os << elem << settings::sepOfContainerElements; return os;\n                }\n\n\n\n                /// <summary>\n                /// for cout Container in Container with STL container\n                /// </summary>\n                template < template<class ...> class Container1, class ... Cont1Args,\n                    template<class ...> class Container2, class ... Cont2Args  >\n                std::ostream& operator << (std::ostream& os, const Container1< Container2<Cont2Args ...>, Cont1Args ...>& container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainer; return os;\n                }\n\n\n\n                /// <summary>\n                /// for cout Container in Container with std::array\n                /// </summary>\n                template < template<class ...> class Container, class ... Args, size_t L >\n                std::ostream& operator << (std::ostream& os, const std::array<Container<Args ...>, L>& container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainer; return os;\n                }\n                /// <summary>\n                /// for cout Container in Container with std::array\n                /// </summary>\n                template < template<class ...> class Container, class ... Args, size_t L, class T  >\n                std::ostream& operator << (std::ostream& os, const Container<std::array<T, L>, Args ...>& container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainer; return os;\n                }\n                /// <summary>\n                /// for cout Container in Container with std::array\n                /// </summary>\n                template < class T, size_t L1, size_t L2 >\n                std::ostream& operator << (std::ostream& os, const std::array<std::array<T, L2>, L1> container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainer; return os;\n                }\n\n\n                /// <summary>\n                /// for cout raw ary in raw ary\n                /// </summary>\n                template < class T, size_t L1, size_t L2 >\n                std::ostream& operator << (std::ostream& os, const T(&ary)[L1][L2])\n                {\n                    for (size_t i{}; i < L1; ++i) os << ary[i] << settings::sepOfContainer; return os;\n                }\n\n            }\n        }\n\n\n        template<typename T, size_t L, typename Function>\n        void for_each(T(&ary)[L], Function lambda)\n        {\n            for (size_t i{}; i < L; ++i)\n                lambda(static_cast<T&>(ary[i]));\n        }\n    }\n\n\n    inline namespace util\n    {\n\n        template<typename T>\n        void SetAll(T& container, typename T::value_type value = typename T::value_type{})\n        {\n            for (typename T::reference content : container) content = value;\n        }\n\n        template<typename T, size_t L>\n        void SetAll(T(&ary)[L], T value)\n        {\n            for (size_t i{}; i < L; ++i) ary[i] = value;\n        }\n\n        template<typename T, typename U, size_t L1, size_t L2>\n        void SetAll(T(&ary)[L1][L2], U value)\n        {\n            for (size_t i{}; i < L1; ++i) SetAll(ary[i], value);\n        }\n\n\n        inline namespace ranges\n        {\n\n            namespace core\n            {\n\n                using namespace meta;\n                /// <summary>\n                /// 再帰上限回数\n                /// </summary>\n                constexpr size_t recursion_limits{490};\n\n                /// <summary>\n                /// 値が割り切れるか\n                /// </summary>\n                template<int num, int divide> struct is_divisible\n                    : coming::bool_constant<num % divide == 0>\n                {\n                };\n\n                /// <summary>\n                /// 有限回数の再帰で終わるか\n                /// </summary>\n                template<int start, int end, int step> struct is_finite_recursion_depth\n                    : coming::bool_constant<(start < end) && (step > 0) || (end < start) && (step < 0)>{};\n\n                /// <summary>\n                /// 再帰回数が上限を超えないか\n                /// </summary>\n                template<int start, int end, int step> struct is_valid_recursion_depth\n                    : coming::bool_constant<(end - start) / step <= recursion_limits>\n                {\n                };\n\n                /// <summary>\n                /// 上記メタ関数の条件をすべて満たすか\n                /// </summary>\n                template<int start, int end, int step> struct is_valid_range\n                    : coming::bool_constant<(start == end) || is_finite_recursion_depth<start, end, step>::value && is_valid_recursion_depth<start, end, step>::value && is_divisible<end - start, step>::value>\n                {\n                };\n\n                /// <summary>\n                /// 再帰を続けるか\n                /// </summary>\n                template<int start, int end, int step> struct is_count_up_or_down\n                    : coming::bool_constant<is_valid_range<start, end, step>::value && end != start>\n                {\n                };\n\n                ///// <summary>\n                ///// 初期化子リストからstd::arrayをコンパイル時生成\n                ///// </summary>\n                //template<typename T, typename ...Args>\n                //constexpr std::array<T, sizeof...(Args)> make_array(Args&&... args)\n                //{\n                //    return std::array<T, sizeof...(Args)>{ static_cast<Args&&>(args)... };\n                //}\n\n\n                /// <summary>\n                /// 本体\n                /// </summary>\n\n                // エラー処理\n                template<int start, int end, int step, class = void, int ...Ary>\n                struct Range_Impl\n                {\n                    //static_assert(is_valid_range           <start, end, step>::value, \"[ ! ] invalid teplate argments [ ! ] 値正しくないっぽいヨ！\");\n                    static_assert(is_divisible             <end - start, step>::value, \"[ ! ] (end - start) is indivisible by step number [ ! ] 割り切れないヨ！stepの値確認して！\");\n                    static_assert(is_finite_recursion_depth<start, end, step>::value, \"[ ! ] goes to infinite loop [ ! ] 無限ループなっちゃうヨ！stepの符号逆じゃない？\");\n                    static_assert(is_valid_recursion_depth <start, end, step>::value, \"[ ! ] recursion depth is out of maximum limit [ ! ] 再帰回数が大きくなりすぎｨ壊れちゃううう\");\n                };\n                // 再帰\n                template<int start, int end, int step, int ... Ary>\n                struct Range_Impl<start, end, step, meta::coming::enable_if_t<is_count_up_or_down<start, end, step>::value>, Ary ... >\n                    : Range_Impl < start + step, end, step, void, Ary ..., start>\n                {\n                };\n                // 終端\n                template<int start, int end, int step, int ... Ary>\n                struct Range_Impl < start, end, step, meta::coming::enable_if_t<start == end>, Ary ...>\n                {\n                    //static constexpr auto value = make_array<int>(Ary ..., end);\n                    //static constexpr std::array<int, (sizeof... (Ary) + 1)> value = {Ary ..., end};\n                    static constexpr int value[(sizeof ... (Ary)+1)] = {Ary ..., end};\n                };\n\n\n            }\n\n\n            template<size_t size, bool isReverse = false>\n            struct Iterate\n            {\n                static constexpr auto in = isReverse ?\n                    core::Range_Impl<static_cast<int>(size - 1), 0, -1>::value :\n                    core::Range_Impl<0, static_cast<int>(size - 1), 1>::value;\n            };\n\n            template<unsigned int upTo>\n            struct CountUp\n            {\n                static constexpr auto to = core::Range_Impl<0, static_cast<int>(upTo), 1>::value;\n            };\n            template<unsigned int downFrom>\n            struct CountDown\n            {\n                static constexpr auto from = core::Range_Impl<static_cast<int>(downFrom), 0, -1>::value;\n            };\n\n\n            template<int start, int containedEnd, int step = 0, typename = void>\n            struct Range\n            {\n                static constexpr auto& in = core::Range_Impl<start, containedEnd, step>::value;\n            };\n            template<int start, int containedEnd>\n            struct Range <start, containedEnd, 0>\n            {\n                static constexpr auto& in = core::Range_Impl<start, containedEnd, meta::is_positive<int, containedEnd - start>::value ? 1 : -1>::value;\n            };\n\n        }\n    }\n\n\n    inline namespace alg\n    {\n        bool IsPrime(const Ull n)\n        {\n            switch (n)\n            {\n            case 0: case 1:\n                return false;\n            case 2:\n                return true;\n            default:\n\n                if (n % 2 == 0) return false;\n\n                for (Ull i{3}; i * i <= n; i += 2)\n                {\n                    if (n % i == 0) return false;\n                }\n            }\n\n            return true;\n        }\n\n        // 最大公約数\n        Ull EuclideanAlg(Ull n1, Ull n2)\n        {\n            //if (n1 < 0 || n2 < 0) return 0;\n            if (n2 > n1) std::swap(n1, n2);\n\n            Ull r;\n            while ((r = n1 % n2) != 0)\n            {\n                n1 = n2;\n                n2 = r;\n            }\n\n            return n2;\n        }\n\n        // 最小公倍数\n        Ull LCM(const std::vector<Ull>& values)\n        {\n            if (values.size() == 0)\n                return 0;\n            if (values.size() == 1)\n                return values[0];\n            if (values.size() == 2)\n                return values[0] * values[1] / EuclideanAlg(values[0], values[1]);\n\n            auto mid = values.cbegin() + values.size() / 2;\n\n            return LCM(std::vector<Ull>{LCM(std::vector<Ull>(values.begin(), mid)), LCM(std::vector<Ull>(mid, values.end()))});\n        }\n    }\n\n\n    void Solve();\n\n}\n\n# if false\nint main()\n{\n    Solve();\n    return 0;\n}\n# endif\n\nnamespace\n{\n    bool isShortPhrase(const std::string& phrases)\n    {\n        constexpr Ary<char, 5> eachLength = {5, 7, 5, 7, 7};\n        \n        int sum{}, current{};\n        for (int i = 0; i < phrases.size(); ++i)\n        {\n            sum += (int)phrases[i];\n            \n            if (sum == eachLength[current])\n            {\n                if (current == eachLength.size() - 1)\n                    return true;\n\n                ++current;\n                sum = 0;\n            }\n        }\n\n        return false;\n    }\n\n    void Solve()\n    {\n        std::ofstream ofs(\"output.txt\");\n        std::cout.rdbuf(ofs.rdbuf());\n\n\n        int length;\n        while (std::cin >> length, length != 0)\n        {\n            std::string phrases(40, '\\0');\n            for (int i{}; i < length; ++i)\n            {\n                std::string temp; std::cin >> temp;\n                phrases[i] = temp.length();\n            }\n\n            for (int i{}; i < length - 4; ++i)\n            {\n                if (isShortPhrase(phrases.substr(i, phrases.size() - i)))\n                {\n                    std::cout << i + 1<< std::endl;\n                    break;\n                }\n            }\n\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint par[100],dep[100];\nint ans[100];\nstring s[100];\nint main(){\n\tint n;\n\twhile(true){\n\tcin>>n;\n\tif(n==0)break;\n\tint m=0;\n\n\tfor(int i=0;i<n;i++){\n\t\tcin>>s[i];\n\t\tdep[i]=s[i].size()-1;\n\t\tm=max(m,dep[i]);\n\t\tif(dep[i]>0){\n\t\t\tpar[i]=i-1;\n\t\t\twhile(true){\n\t\t\t\tif(dep[par[i]]==dep[i]-1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpar[i]--;\n\t\t\t}\n\t\t}\n\t\tif(s[i][s[i].size()-1]>='0'&&s[i][s[i].size()-1]<='9'){\n\t\t\tans[i]=s[i][s[i].size()-1]-'0';\n\t\t}\n\t\tif(s[i][s[i].size()-1]=='+')ans[i]=0;\n\t\tif(s[i][s[i].size()-1]=='*')ans[i]=1;\n\t}\n\n\tfor(int sd=m;sd>0;sd--){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(dep[i]==sd){\n\t\t\t\tif(s[par[i]][s[par[i]].size()-1]=='+'){\n\t\t\t\t\tans[par[i]]+=ans[i];\n\t\t\t\t}\n\t\t\t\tif(s[par[i]][s[par[i]].size()-1]=='*'){\n\t\t\t\t\tans[par[i]]*=ans[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans[0]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n==0) break;\n    vector<char> ops;\n    vector<int> vs;\n    ops.push_back('+');\n    vs.push_back(0);\n    auto update = [&ops,&vs](const int v) {\n      switch(ops.back()) {\n      case '+': { (vs.back()) += v; break; }\n      case '*': { (vs.back()) *= v; break; }\n      default : { throw string(\"Something Wrong in default!\"); }\n      }\n    };\n    auto pops = [&ops,&vs,&update](const int l){\n      while(l < ops.size()) {\n        int v = vs.back();\n        vs.pop_back();\n        ops.pop_back();\n        update(v);\n      }\n    };\n    for(int i = 0; i < n; i++) {\n      string s;\n      cin >> s;\n      // cout << \"read: \" << s << endl;\n      pops(s.size());\n      char c = s[ops.size()-1];\n      // cout << \"c = \" << c << endl;\n      switch(c){\n      case '.' : { throw string(\"Something Wrong!\"); }\n      case '+' : {\n        ops.push_back('+');\n        vs.push_back(0);\n        break;\n      }\n      case '*' : {\n        ops.push_back('*');\n        vs.push_back(1);\n        break;\n      }\n      default : { // '0'--'9'\n        update(c - '0');\n      }\n      }\n    }\n    pops(1);\n    cout << vs[0] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint n,num;\nvector<string> s;\n\nint solve(int c, int a, int b)\n{\n    if(c == 0){\n        return a+b;\n    }else{\n        return a*b;\n    }\n}\n\nint dfs(int d,int id)\n{\n    int res = id;\n    while(num < n){\n        if(isdigit(s[num].back())){\n            if((int)s[num].size()-1 < d){\n                return res;\n            }\n            res = solve(id,res,(s[num].back()-'0'));\n            num++;\n        }else{\n            int flag = (s[num].back()=='*');\n            num++;\n            int ans = dfs(d+1,flag);\n            res = solve(id,res,ans);\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        s.resize(n);\n        rep(i,n){\n            cin >> s[i];\n        }\n        num = 0;\n        cout << dfs(0,0) << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nint n;\nvs v;\n\nint solve(int r, int c)\n{\n\tif (v[r][c] == '+')\n\t{\n\t\tint res = 0;\n\t\tint p = r + 1;\n\t\twhile (p < n && c < v[p].size() && v[p][c] == '.')\n\t\t{\n\t\t\tif (v[p][c + 1] != '.')\n\t\t\t{\n\t\t\t\tres += solve(p, c + 1);\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\treturn res;\n\t}\n\telse if(v[r][c] == '*')\n\t{\n\t\tint res = 1;\n\t\tint p = r + 1;\n\t\twhile (p < n && c < v[p].size() && v[p][c] == '.')\n\t\t{\n\t\t\tif (v[p][c + 1] != '.')\n\t\t\t{\n\t\t\t\tres *= solve(p, c + 1);\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t\treturn res;\n\t}\n\telse if(isdigit(v[r][c]))\n\t{\n\t\treturn v[r][c] - '0';\n\t}\n\telse assert(false);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> n, n)\n\t{\n\t\tv.resize(n); cin >> v;\n\t\tcout << solve(0, 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\n\tstd::string* in;\n\tint nline;\n\tint idx;\n\nint calc(int lv = 0, char kind = '+') {\n\tint ret = 0;\n\tif(kind == '*') ret = 1;\n\n\twhile(true){\n\t//\tstd::cout << \"idx:\" << idx << \"\\n\";\n\t\tif(idx >= nline) break;\n\n\t\tstd::string& cs = in[idx];\n\t\tint clv = 0;\n\t\tfor(auto itr = cs.begin(); itr != cs.end() && *itr == '.'; itr++, clv++);\n\t\tif(lv != clv) break;\n\t\tidx++;\n\n\t\tchar cc = cs[lv];\n\t//\tstd::cout << \"cc:\" << cc << \"\\n\";\n\t\tint cnum;\n\n\t\tif(cc == '+' || cc == '*'){\n\t\t\tcnum = calc(lv+1, cc);\n\t\t}else{\n\t\t\tcnum = cc - '0';\n\t\t}\n\n\t//\tstd::cout << \"cnum=\" << cnum << \"\\n\";\n\n\t\tif(kind == '*') {\n\t\t\tret *= cnum;\n\t\t}else{\n\t\t\tret += cnum;\n\t\t}\n\n\t}\n\treturn ret;\n}\n\nint main(void) {\n\n\tint ret;\n\n\twhile(true){\n\t\tstd::cin >> nline;\n\t\tif(!nline) break;\n\n\t\tin = new std::string[nline];\n\t\tfor(int i=0; i<nline; i++) std::cin >> in[i];\n\t\tidx = 0;\n\n\t\tstd::cout << calc() << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mux_n = 1000;\n\nenum _operator{\n    _plus,\n    multiply,\n    none\n};\n\nint main() {\n\n    while(1){\n\n        int n;\n\n        cin >> n;\n\n        if(n==0) break;\n\n        string input[n];\n\n        vector<vector<int> > level_num;\n        vector<_operator> level_ope;\n\n        level_num.resize(mux_n);\n\n\n        for(int i=0; i<mux_n; i++){\n            level_ope.push_back(none);\n        }\n\n        int max_level = 0;\n\n        for(int i=0; i<n; i++){\n            cin >> input[i];\n            for(int j=0; j<input[i].size(); j++){\n                if(input[i][j] == '+'){\n                    level_ope[j] = _plus;\n                }\n                else if(input[i][j] == '*'){\n                    level_ope[j] = multiply;\n                }\n                else if(input[i][j] != '.'){\n                    stringstream ss;\n                    ss << input[i][j];\n                    int input_num;\n                    ss >> input_num;\n                    level_num[j].push_back(input_num);\n                }\n                max_level = max(max_level,j);\n            }\n        }\n\n        int ans = 0;\n        int now_level = max_level;\n\n        while(now_level){\n            if(level_ope[now_level-1] != none){\n                int sum;\n                if(level_ope[now_level-1] == _plus){\n                    sum = 0;\n                    for(int i=0; i<level_num[now_level].size(); i++){\n                        sum += level_num[now_level][i];\n                    }\n                }\n                else if(level_ope[now_level-1] == multiply){\n                    sum = 1;\n                    for(int i=0; i<level_num[now_level].size(); i++){\n                        sum *= level_num[now_level][i];\n                    }\n                }\n                if(now_level == 1) {\n                    ans = sum;\n                }\n                else{\n                    level_num[now_level-1].push_back(sum);\n                }\n            }\n            /*else if(level_num[now_level].size() == 1){\n                if(now_level == 1) {\n                    ans = level_num[now_level][0];\n                }\n                else{\n                    level_num[now_level-1].push_back(level_num[now_level][0]);\n                }\n            }*/\n            now_level--;\n        }\n\n        if(n == 1){\n            ans = level_num[0][0];\n        }\n\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<sstream>\nusing namespace std;\nstring i2s(int x){\n  string y;\n  int k=1;\n  while(x>=k) k*=10;\n  k/=10;\n  for(int i=k;i>0;i/=10){\n    y+=(x/i)%10+'0';\n  }\n  return y;\n}\nint s2i(string x){\n  for(int i=0;i<x.size();i++) if(x[i]=='.') x[i]=' ';\n  stringstream ss(x);\n  int y;\n  ss >> y;\n  return y;\n}\nint main(){\n  //cout << i2s(100) << endl;\n  int n;\n\n  while(cin>>n,n){\n    string buf;\n    vector<string> v;\n    vector<int> d;\n    int i,j,k;\n    for(i=0;i<n;i++){\n      cin >> buf;\n      j=0;\n      while(buf[j]=='.') j++;\n      v.push_back(buf);\n      d.push_back(j);\n    }\n    while(v.size()!=1){\n      //for(i=0;i<v.size();i++) cout << v[i] << endl;\n      //cout << endl;\n      //cout << v.size() << endl;\n      k=1;\n      for(i=0;i<v.size();i++){\n        if(d[k]<d[i]) k=i;\n      }\n      //cout << k << \":\" << v[k-1][v[k-1].size()-1] << endl;\n      if(v[k-1][v[k-1].size()-1]=='+'){\n        i=0;j=0;\n        while(1) {\n          if(d[k]!=d[k+i]) break;\n          //j*=(v[k+i][v[k+i].size()-1]-'0');\n          j+=s2i(v[k+i]);\n          i++;\n          if(k+i==d.size()) break;\n        }\n        //cout << k+i << endl;\n        v[k-1]=v[k-1].substr(0,v[k-1].size()-1);\n        v[k-1]+=i2s(j);\n        v.erase(v.begin()+k,v.begin()+k+i);\n        d.erase(d.begin()+k,d.begin()+k+i);\n      }\n      if(v[k-1][v[k-1].size()-1]=='*'){\n        i=0;j=1;\n        while(1) {\n          if(d[k]!=d[k+i]) break;\n          //j*=(v[k+i][v[k+i].size()-1]-'0');\n          j*=s2i(v[k+i]);\n          i++;\n          if(k+i==d.size()) break;\n        }\n        //cout << i << endl;\n        v[k-1]=v[k-1].substr(0,v[k-1].size()-1);\n        v[k-1]+=i2s(j);\n        v.erase(v.begin()+k,v.begin()+k+i);\n        d.erase(d.begin()+k,d.begin()+k+i);\n      }\n      \n    }\n    cout << v[0] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\n#define P pair<int,int>\nint n;\nstring t[1111];\nvector<P>ta;\n\nint A=1000000;\nint K=10000001;\n\n\nvector<P> calc(vector<P>tmp,int n){\n    vector<P>ret(0);\n    int scoreA=0,scoreK=1;\n    bool flagA=0,flagK=0;\n    \n    // for(int i=0;i<tmp.size();i++){\n    //     cout<<tmp[i].first<<\" \"<<tmp[i].second<<endl;\n    // }\n    // cout<<endl;\n    \n    int pos=0;\n    int ts=tmp.size();\n    \n    for(;;){\n        //cout<<n<<\" \"<<pos<<endl;\n        \n        if(pos>=ts)break;\n        int a=tmp[pos].first,b=tmp[pos].second;\n        \n        if(a!=n||(a==n&&b!=A&&b!=K)){\n            ret.push_back(tmp[pos++]);\n            continue;\n        }\n        \n        if(b==A){\n            int res=0;\n            pos++;\n            while(pos<ts&&tmp[pos].first==n+1&&tmp[pos].second<100000)res+=tmp[pos++].second;\n            ret.push_back(make_pair(n,res));\n        }\n        if(b==K){\n            int res=1;\n            pos++;\n            while(pos<ts&&tmp[pos].first==n+1&&tmp[pos].second<100000)res*=tmp[pos++].second;\n            ret.push_back(make_pair(n,res));\n        }\n    }\n    \n    //cout<<\"OK\";\n    return ret;\n}\nint main(void){\n    // Your code here!\n    while(cin>>n,n){\n        for(int i=0;i<n;i++)cin>>t[i];\n        vector<P>score(0);\n        for(int i=0;i<n;i++){\n            int a=0,b=0;\n            while(t[i][a]=='.')a++;\n            if(t[i][a]=='+')b=A;\n            else if(t[i][a]=='*')b=K;\n            else b=(t[i][a]-'0');\n            \n            score.push_back(make_pair(a,b));\n        }\n        \n        for(int i=100;i>=0;i--){\n            score=calc(score,i);\n        }\n        \n        cout<<score[0].second<<endl;\n    }\n    \n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <vector>\nusing namespace std;\n\nint N;\nvector<string> S;\n\nint op(int a, char op, int b) {\n    if (op == '+') return a + b;\n    if (op == '-') return a - b;\n    if (op == '*') return a * b;\n    return a / b;\n}\n\npair<int, char> parse_line(string s) {\n    int depth = 0;\n    while (s[depth] == '.') ++depth;\n    return make_pair(depth, s.back());\n}\n\npair<int, int> calc(int idx, int depth = 0) {\n    auto pr = parse_line(S[idx++]);\n    assert(pr.first == depth);\n    char ch = pr.second;\n    if (isdigit(ch)) return make_pair((int)(ch - '0'), idx);\n\n    pr = calc(idx, depth+1);\n    int val = pr.first;\n    idx = pr.second;\n    while (idx < N) {\n        auto lookahead = parse_line(S[idx]);\n        if (lookahead.first <= depth) break;\n        auto tmp = calc(idx, depth+1);\n        val = op(val, ch, tmp.first);\n        idx = tmp.second;\n    }\n\n    return make_pair(val, idx);\n}\n\nint main(void) {\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n        S.resize(N);\n        for (int i = 0; i < N; ++i) cin >> S[i];\n        cout << calc(0).first << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<climits>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nvoid solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        st.push(make_pair(th, l-1));\n    }\n}\nint main(){\n    int ca=0;\n    while(cin>>n,n){\n        while(ope.size())ope.pop();\n        while(st.size())st.pop();\n        if(ca++>145)return -1;\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    solve(level);\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        solve(0);\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvector<string> V;\n\nint dep(int cur){\n    int ret=0;\n    for(auto c:V[cur]) ret+=(c=='.');\n    return ret;\n}\nint rec(int depth, int &cur){\n    if(cur>=V.size()||depth!=dep(cur)) return -1;\n    int ret;\n    if(V[cur][depth]=='+'){\n        ret=0;\n        int d;\n        while(d=rec(depth+1,++cur),d!=-1) ret+=d;\n        cur--;\n        return ret;\n    }else if(V[cur][depth]=='*'){\n        ret=1;\n        int d;\n        while(d=rec(depth+1,++cur),d!=-1) ret*=d;\n        cur--;\n        return ret;\n    }else{\n        ret=0;\n        for(int i=depth;i<V[cur].size();i++){\n            ret*=10;\n            ret+=V[cur][i]-'0';\n        }\n        return ret;\n    }\n}\n\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        V.clear();\n        for(int i=0;i<n;i++){\n            string s;\n            cin>>s;\n            V.push_back(s);\n        }\n        int c=0;\n        cout<<rec(0,c)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-11;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint n;\nvs a;\n\nll dfs(int id,int d){\n\tif(isdigit(a[id][d])) return a[id][d]-'0';\n\tchar c=a[id][d];\n\tll x=(c=='+'?0:1);\n\tfor(int i=id+1;i<n&&d<a[i].size()&&a[i][d]=='.';i++) if(d+1<a[i].size()&&a[i][d+1]!='.'){\n\t\tll y=dfs(i,d+1);\n\t\tif(c=='+') x+=y;\n\t\telse x*=y;\n\t}\n\treturn x;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\ta=vs(n);\n\t\tfor(int i=0;i<n;i++) cin>>a[i];\n\t\tcout<<dfs(0,0)<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mux_n = 2000;\n\nenum _operator{\n    _plus,\n    multiply,\n    none\n};\n\nvoid En_route_culc(vector<_operator>& level_ope,vector<vector<long long int> >& level_num,int min_level, int max_level ){\n    int now_level = max_level;\n    while(min_level < now_level){\n        if(level_ope[now_level-1] != none){\n            long long int sum;\n            if(level_ope[now_level-1] == _plus){\n                sum = 0;\n                for(int i=0; i<level_num[now_level].size(); i++){\n                    sum += level_num[now_level][i];\n                }\n            }\n            else if(level_ope[now_level-1] == multiply){\n                sum = 1;\n                for(int i=0; i<level_num[now_level].size(); i++){\n                    sum *= level_num[now_level][i];\n                }\n            }\n            if(now_level == 1) {\n            }\n            else{\n                level_num[now_level-1].push_back(sum);\n            }\n        }\n        now_level--;\n    }\n}\n\nint main() {\n\n    ofstream ofs(\"out.txt\");\n\n    while(1){\n\n        int n;\n\n        cin >> n;\n\n        if(n==0) break;\n\n        string input[n];\n\n        vector<vector<long long int> > level_num;\n        vector<_operator> level_ope;\n\n        level_num.resize(mux_n);\n\n\n        for(int i=0; i<mux_n; i++){\n            level_ope.push_back(none);\n        }\n\n        int max_level = 0;\n\n        for(int i=0; i<n; i++){\n            cin >> input[i];\n            for(int j=0; j<input[i].size(); j++){\n                if(input[i][j] == '+'){\n                    if(level_ope[j] != none){\n                        En_route_culc(level_ope,level_num,j,max_level);\n                        for(int k=max_level; j<k; k--) {\n                            while (!level_num[k].empty()) {\n                                level_num[k].pop_back();\n                            }\n                        }\n                        max_level = j;\n                    }\n                    level_ope[j] = _plus;\n                }\n                else if(input[i][j] == '*'){\n                    if(level_ope[j] != none){\n                        En_route_culc(level_ope,level_num,j,max_level);\n                        for(int k=max_level; j<k; k--) {\n                            while (!level_num[k].empty()) {\n                                level_num[k].pop_back();\n                            }\n                        }\n                        max_level = j;\n                    }\n                    level_ope[j] = multiply;\n                }\n                else if(input[i][j] != '.'){\n                    string string_now_input_num;\n                    for(int k=j; k<input[i].size(); k++){\n                        string_now_input_num.push_back(input[i][k]);\n                    }\n                    stringstream ss;\n                    ss << string_now_input_num;\n                    int input_num;\n                    ss >> input_num;\n                    level_num[j].push_back(input_num);\n                }\n                max_level = max(max_level,j);\n            }\n        }\n\n        long long int ans = 0;\n        int now_level = max_level;\n\n        while(now_level){\n            if(level_ope[now_level-1] != none){\n                long long int sum;\n                if(level_ope[now_level-1] == _plus){\n                    sum = 0;\n                    for(int i=0; i<level_num[now_level].size(); i++){\n                        sum += level_num[now_level][i];\n                    }\n                }\n                else if(level_ope[now_level-1] == multiply){\n                    sum = 1;\n                    for(int i=0; i<level_num[now_level].size(); i++){\n                        sum *= level_num[now_level][i];\n                    }\n                }\n                if(now_level == 1) {\n                    ans = sum;\n                }\n                else{\n                    level_num[now_level-1].push_back(sum);\n                }\n            }\n            now_level--;\n        }\n\n        if(n == 1){\n            ans = level_num[0][0];\n        }\n\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define LAST(vec) vec[vec.size() - 1]\nstring get_line() {\n  string line;\n  cin >> line;\n  return line;\n}\n// 整数: 一桁\nint main() {\n  while (true) {\n    auto line_num = stoi(get_line());\n    if (line_num == 0) return 0;\n    if (line_num == 1) {\n      cout << stoi(get_line()) << endl;\n      continue;\n    }\n    vector<int> stack;\n    vector<bool> is_adds;\n    auto calc = [&](int num) {\n      if (LAST(is_adds)) {\n        LAST(stack) += num;\n      } else {\n        LAST(stack) *= num;\n      }\n    };\n    auto reduction = [&](int n) {\n      REP(j, n) {\n        auto num = LAST(stack);\n        is_adds.pop_back();\n        stack.pop_back();\n        calc(num);\n      }\n    };\n\n    REP(i, line_num) {\n      auto line = get_line();\n      auto level = line.size() - 1;\n      // リダクション\n      if (level < stack.size()) {\n        auto n = stack.size() - level;\n        reduction(n);\n      }\n      // パース\n      auto chr = line[line.size() - 1];\n      if (chr == '+') {\n        stack.push_back(0);\n        is_adds.push_back(true);\n      } else if (chr == '*') {\n        stack.push_back(1);\n        is_adds.push_back(false);\n      } else {\n        calc(chr - '0');\n      }\n    }\n    if (stack.size() > 1) {\n      reduction(stack.size() - 1);\n    }\n    cout << LAST(stack) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nint now[20];\nvector<int> G[20];\nint prev[20];\nint type[20];\n\nint dfs(int v){\n\tif(type[v]>=0){\n\t\treturn type[v];\n\t}else if(type[v]==-1){\n\t\tint res=0;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tres+=dfs(G[v][i]);\n\t\t}\n\t\treturn res;\n\t}else{\n\t\tint res=1;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tres*=dfs(G[v][i]);\n\t\t}\n\t\treturn res;\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<20;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tint pp=0;\n\t\t\tfor(int j=0;j<str.size();j++){\n\t\t\t\tif(str[j]>='0' && str[j]<='9'){\n\t\t\t\t\tif(pp>0)G[now[pp-1]].push_back(cnt);\n\t\t\t\t\ttype[cnt++]=str[j]-'0';\n\t\t\t\t}else if(str[j]=='+'){\n\t\t\t\t\tnow[pp]=cnt;\n\t\t\t\t\tif(pp>0)G[now[pp-1]].push_back(cnt);\n\t\t\t\t\ttype[cnt++]=-1;\n\t\t\t\t}else if(str[j]=='*'){\n\t\t\t\t\tnow[pp]=cnt;\n\t\t\t\t\tif(pp>0)G[now[pp-1]].push_back(cnt);\n\t\t\t\t\ttype[cnt++]=-2;\n\t\t\t\t}else{\n\t\t\t\t\tpp++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dfs(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n \n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n \ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n \nint dfs(const vector<string> &s, int i, int j) {\n    if (isdigit(s[i][j])) {\n        return s[i][j] - '0';\n    }\n \n    int ret = (s[i][j] == '+' ? 0 : 1);\n    int nj = j + 1;\n    rep2(ni, i + 1, s.size()) {\n        if (nj >= s[ni].size()) break;\n        if (s[ni][nj] == '.') continue;\n        if (s[i][j] == '+') ret += dfs(s, ni, nj);\n        if (s[i][j] == '*') ret *= dfs(s, ni, nj);\n    }\n    return ret;\n}\n \nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n \n    int n;\n    while (cin >> n, n) {\n        vector<string> s(n);\n        rep(i, n) cin >> s[i];\n        cout << dfs(s, 0, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\n\n\nint calc(char op, std::vector<int> xs) {\n\n\tswitch (op) {\n\tcase '+': {\n\t\tint v = xs.at(0);\n\t\tfor (int i = 1; i < xs.size(); i++) {\n\t\t\tv += xs.at(i);\n\t\t}\n\t\treturn v;\n\t}\n\tcase '*': {\n\t\tint v = xs.at(0);\n\t\tfor (int i = 1; i < xs.size(); i++) {\n\t\t\tv *= xs.at(i);\n\t\t}\n\t\treturn v;\n\t}\n\t}\n\n\treturn xs.at(0);\n}\n\nint main() {\n\twhile (true)\n\t{\n\t\tint n;\n\t\tstd::cin >> n;\n\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\n\t\tint depth = -1;\n\n\t\tstd::stack<char> ops;\n\t\tops.push(0);\n\t\tstd::stack<std::vector<int>> vstack;\n\n\t\tstd::vector<int> vs;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstd::string s;\n\t\t\tstd::cin >> s;\n\t\t\t\n\t\t\tint d = std::count(s.begin(), s.end(), '.');\n\t\t\ts = s.substr(d);\n\n\t\t\tif (d < depth) {\n\t\t\t\tfor (; depth != d; depth--) {\n\t\t\t\t\t\n\t\t\t\t\tint tmp = calc(ops.top(), vs);\n\t\t\t\t\tvs = vstack.top();\n\t\t\t\t\tvs.push_back(tmp);\n\t\t\t\t\tvstack.pop();\n\t\t\t\t\tops.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdepth = d;\n\n\t\t\ttry {\n\t\t\t\tint tmp = std::stoi(s);\n\t\t\t\tvs.push_back(tmp);\n\t\t\t}\n\t\t\tcatch (...) {\n\t\t\t\tops.push(s.at(0));\n\t\t\t\tvstack.push(vs);\n\t\t\t\tvs.clear();\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\n\t\tint v = 0;\n\t\twhile(true) {\n\t\t\t\n\t\t\tv = calc(ops.top(), vs);\n\t\t\tif (--depth <= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tops.pop();\n\t\t\tvs = vstack.top();\n\t\t\tvs.push_back(v);\n\t\t\tvstack.pop();\n\t\t}\n\t\tstd::cout << v << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef string::const_iterator State;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<long long>vll;\ntypedef pair<int,int> pi;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\nint number(string s){\n  int ret=0;\n  for(int i=0;i<(int)s.size();i++){\n    if(isdigit(s[i])){\n      ret*=10;\n      ret+=(s[i]-'0');\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint calc(int ret,int num,char x){\n  if(x=='+')return ret+num;\n  if(x=='-')return ret-num;\n  if(x=='*')return ret*num;\n  if(x=='/')return ret/num;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    string s;\n    vector<pair<int,string> > v(n);\n    int maxi=0;\n    rep(i,n){\n      cin>>s;\n      int cnt=0;\n      for(int j=0;j<s.size();j++){\n\tif(s[j]=='.')cnt++;\n      }\n      maxi=max(maxi,cnt);\n      s.erase(s.begin(),s.begin()+cnt);\n      v[i].first=cnt;\n      v[i].second=s;\n    }\n    maxi--;\n    \n    while(v.size()!=1){  \n      bool update=false;\n      for(int i=0;i<v.size();i++){\n\tint start;\n        if(v[i].first==maxi&&!isdigit(v[i].second[0])){\n\t  start=i;\n\t  char c=v[i].second[0];\n\t  i+=2;\n\t  int ret=number(v[i-1].second);\n\t  while(i<v.size()+1&&v[i].first==maxi+1){\n\t    ret=calc(ret,number(v[i].second),c);\n\t    i++;\n\t  }\n\t  v[start].second=to_string(ret);\n\t  v.erase(v.begin()+start+1,v.begin()+i);\n\t  update=true;\n\t  break;\n\t}\n      }\n      if(!update)maxi--;\n    }\n    cout<<v[0].second<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nstruct Data{\n\tint len;\n\tchar data;\n};\n\nint n, j=0;\nData val[50];\n\nint solve(){\n\tint ans, depth = val[j].len;\n\tchar c=val[j++].data;\n\tif(c=='+')ans=0;\n\telse if(c=='*') ans=1;\n\n\twhile(j<n && val[j].len > depth){\n\t\tif(isdigit(val[j].data)){\n\t\t\tif(c=='+')ans+=val[j++].data-'0';\n\t\t\telse if(c=='*') ans*=val[j++].data-'0';\n\t\t} else{\n\t\t\tif(c=='+')ans+=solve();\n\t\t\telse if(c=='*') ans*=solve();\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tval[j].len = 0;\n\t\t\tval[j].data = '\\0';\n\t\t}\n\n\t\tchar tmp[50];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> tmp;\n\t\t\tval[i].len = strlen(tmp);\n\t\t\tval[i].data= tmp[strlen(tmp)-1];\n\t\t}\n\t\tj=0;\n\t\tif(n==1) cout << val[j].data << endl;\n\t\telse cout << solve() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nstring s[111];\n\nint solve(int& idx){\n  int ret;\n  if(isdigit(s[idx].back())) {\n    ret = s[idx].back()-'0', idx++;\n  } else {\n    ret = (s[idx].back() == '*');\n    int base = idx; idx++;\n    while(s[base].size()+1 == s[idx].size()) {\n      if(s[base].back() == '+') ret += solve(idx);\n      else if(s[base].back() == '*') ret *= solve(idx);\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(cin >> n, n) {\n    for(int i = 0; i < n; i++) cin >> s[i];\n    int idx = 0;\n    cout << solve(idx) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007\n#define INF 1000000010\n#define EPS 1e-9\n#define fst first\n#define scd second\n\n#define debug(x) cout<<x<<endl;\n#define repi(i,x,n) for(int i=x;i<n;i++)\n#define rep(i,n) repi(i,0,n)\n#define lp(i,n) repi(i,0,n)\n#define repn(i,n) for(int i=n;i>=0;i--)\n#define int long long\n#define endl \"\\n\"\n\n\nsigned main(){\n  cin.tie(0);\t\n  //ios::sync_with_stdio(false);\n  while(1){\n    int n;\n    cin>>n;\n    if(n==0) break;\n    stack<int> st;\n    stack<char> now;\n    string s;\n    while(!st.empty()) st.pop();\n    while(!now.empty() ) now.pop();\n    rep(i,n){\n      cin>>s;\n      int level=0;\n      rep(j,s.size() ){\n\tif(s[j]=='.') level++;\n      }\n      while(st.size() >level){\n\tint num=st.top();\n\tst.pop();\n\tnow.pop();\n\tif(now.top() == '+') st.top()+=num;\n\telse st.top()*=num;\n      }\n      if(isdigit(s[s.size() - 1])){\n\tif(now.empty() ){\n\t  st.push(s[s.size() - 1]-'0');\n\t}else{\n\t  if(now.top()=='+'){\n\t    st.top()+=s[s.size() - 1]-'0';\n\t  }else{\n\t    st.top()*=s[s.size() - 1]-'0';\n\t  }\n\t}\n      }else{\n\tif(s[s.size() - 1]=='+'){\n\t  now.push('+');\n\t  st.push(0);\n\t  // cout<<'a'<<endl;\n\t}else{\n\t  now.push('*');\n\t  st.push(1);\n\t}\n      }\n    }\n    while(st.size() != 1){\n      int num=st.top();\n      st.pop();\n      now.pop();\n      if(now.top() == '+') st.top()+=num;\n      else st.top()*=num;\n    }\n    cout<<st.top()<<endl;\n  }\n     \n      \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint func()\n{\n  int N;\n  cin >> N;\n  if( N == 0 ) return -1;\n\n  long long int v[10] = { 0 };\n  char m[10] = { 0 };\n  int mcnt = 0;\n\n  for( int i = 0; i < N; ++i ){\n    string S;\n    cin >> S;\n\n    int cnt = 0, len = S.length();\n\n    for( int j = 0; j < len; ++j ){\n      switch( S[j] ){\n        case '.': ++cnt; break;\n        case '+': case '*': m[cnt] = S[j]; ++mcnt; break;\n        default: if( cnt == 0 ){\n                  cout << S[j]-'0' << endl;\n                  return 0;\n                 } else if( m[cnt-1] == '+' ){ v[cnt-1] += (long long int)(S[j]-'0');\n                 } else if( m[cnt-1] == '*' ){\n                     if( v[cnt-1] == 0 ) v[cnt-1] = (long long int)1;\n                     v[cnt-1] *= (long long int)(S[j]-'0');\n                 }\n                 break;\n        }\n      }\n    }\n\n    /*\n    cout << \"v:\";\n    for( int i = 0; i < 10; ++i ) cout << v[i] << \" \";\n    cout << endl << \"m:\";\n    for( int i = 0; i < 10; ++i ) cout << m[i] << \" \";\n    cout << endl;\n    /**/\n\n    long long int ans = 0;\n    if( mcnt < 2 ){\n      cout << v[0] << endl;\n      return 0;\n    }\n    for( int i = 0; m[i+1] != 0; ++i ){\n      if( m[i] == '*' ){\n        if( ans == 0 ) ans = v[i];\n        else ans *= v[i];\n      }\n    }\n    for( int i = 0; m[i+1] != 0; ++i ){\n        if( i == 0 ) ans += v[0];\n        if( m[i] == '+' ) ans += v[i+1];\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\nint main()\n{\n  while( func() != -1 ) ;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,p;\nstring s;\nint d[200];\nchar c[200];\n \nint solve(){\n  if('0'<=c[p]&&c[p]<='9')return c[p++]-'0';\n  int k=p++,res=(c[k]=='*'?1:0);\n  while(d[p]==d[k]+1){\n    if(c[k]=='+')res+=solve();\n    if(c[k]=='*')res*=solve();\n  }\n  return res;\n}\n \nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    d[n]=0;\n    for(int i=0;i<n;i++){\n      cin>>s;\n      d[i]=s.size();\n      c[i]=s[s.size()-1];\n    }\n    p=0;\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <stack>\n#include <string>\nusing namespace std;\n\nint main(){\n    while(true){\n        int n;\n        stack<int> num;\n        stack<char> ope;\n        string str;\n        char x;\n        int l, nl;\n        int m, p, q;\n        int ans;\n        cin >> n;\n        if(!n) break;\n        for(int i=0;i<n;++i){\n            cin >> str;\n            nl = str.rfind('.')+1;\n            x = str.substr(nl)[0];\n            if(x=='*' || x=='+'){\n                ope.push(x);\n            }else{\n                stringstream ss; ss << x; ss >> m;\n                if(nl==0 || l<nl){\n                    num.push(m);\n                }else{\n                    if(l>nl){\n                        ope.pop();\n                        --l;\n                        for(int j=0;j<l-nl;++j){\n                            p = num.top(); num.pop();\n                            q = num.top(); num.pop();\n                            if(ope.top()=='+') num.push(p+q);\n                            else num.push(p*q);\n                            ope.pop();\n                        }\n                    }\n                    q = num.top(); num.pop();\n                    if(ope.top()=='+') num.push(m+q);\n                    else num.push(m*q);\n                }\n            }\n            l = nl;\n        }\n        if(!ope.empty()) ope.pop();\n        while(!ope.empty()){\n            p = num.top(); num.pop();\n            q = num.top(); num.pop();\n            if(ope.top()=='+') num.push(p+q);\n            else num.push(p*q);\n            ope.pop();\n        }\n        cout << num.top() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GRIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ?????¬???????????¬??????\n#pragma region MACRO\n#define P(x) cout << (x) << endl\n#define p(x) cout << (x)\n#define PED cout << \"\\n\"\n#define rep(i,n) for(int i=0; i<(int)n; ++i)\n#define REP(i,x,n) for(int i=x; i<(int)n; ++i)\n#define repi(i,n) for(int i=0; i<=(int)n; ++i)\n#define REPI(i,x,n) for(int i=x; i<=(int)n; ++i)\n#define ILP while(true)\n#define FOR(i,c) for(__typeof((c).begin())!=(c).begin(); i!=(c).end(); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#pragma endregion\n\n// ???\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<string, string> pss;\ntypedef pair<string, int> psi;\ntypedef pair<int, string> pis;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long double> vld;\ntypedef vector<long> vl;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\n#pragma endregion\n\n// Effective std\n#pragma region ESTD\ntemplate<typename C, typename T> int count(C& c, T t) { return count(ALL(c), t); }\ntemplate<typename C, typename F> int count_if(C& c, F f) { return count_if(ALL(c), f); }\ntemplate<typename C, typename T> void erase(C& c, T t) { remove(ALL(c), t), c.end(); }\ntemplate<typename C> void remove(vector<C>& c, unsigned int index) { c.erase(c.begin()+index); }\ntemplate<typename C, typename T, typename U> void replace(C& c, T t, U u) { replace(ALL(c), t, u); }\ntemplate<typename C, typename F, typename U> void replace_if(C& c, F f, U u) { (ALL(c), f, u); }\ntemplate<typename C> void reverse(C& c) { reverse(ALL(c)); }\ntemplate<typename C> void sort(C& c) { sort(ALL(c)); }\ntemplate<typename C, typename Pred> void sort(C& c, Pred p) { sort(ALL(c), p); }\n#pragma endregion\n\n// ?????°\n#pragma region CONST_VAL\nconstexpr int PI = (2*acos(0.0));\nconstexpr int EPS = (1e-9);\nconstexpr int MOD = (int)(1e9+7);\nconstexpr int INF = 100000000;\n#pragma endregion\n\nint n;\nvector<string> v;\n\nint solve(int r, int c) {\n    if(v[r][c]=='+') {\n        int res = 0;\n        int p = r + 1;\n        while(p<n && c<v[p].size() && v[p][c]=='.') {\n            if(v[p][c+1] != '.') res += solve(p, c+1);\n            p++;\n        }\n        return res;\n    }\n    else if(v[r][c] == '*') {\n        int res = 1;\n        int p = r + 1;\n        while(p<n && c<v[p].size() && v[p][c] == '.') {\n            if(v[p][c+1] != '.') res *= solve(p, c+1);\n            p++;\n        }\n        return res;\n    }\n    else if(isdigit(v[r][c])) return v[r][c] - '0';\n    else assert(false);\n}\n\nint main() {\n    while(cin >> n, n) {\n        v.resize(n);\n        rep(i,n) cin >> v[i];\n        P(solve(0,0));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring buf;\n\nint calc(int& n, unsigned level = 0) {\n    if (n == 0) throw runtime_error(\"EOF\");\n    if (buf.empty()) cin >> buf;\n    if (buf.find_first_not_of('.') != level) throw runtime_error(\"EOL\");\n    int result;\n    switch (buf.back()) {\n        case '+':\n            buf.clear();\n            result = 0;\n            for (;;) {\n                try { result += calc(--n, level + 1); }\n                catch (...) { ++n; break; }\n            }\n            break;\n        case '*':\n            buf.clear();\n            result = 1;\n            for (;;) {\n                try { result *= calc(--n, level + 1); }\n                catch (...) { ++n; break; }\n            }\n            break;\n        default:\n            result = buf.back() - '0';\n            buf.clear();\n            break;\n    }\n    return result;\n}\n\nint main() {\n    for (int n; cin >> n, n; cout << calc(n) << endl) buf.clear();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nint n;\nstring s[1000];\n\nint get_dot(string S) {\n\treturn count(S.begin(), S.end(), '.');\n}\n\nint parse(int pos) {\n\tint retv = -1145141919;\n\tint nest = get_dot(s[pos]) + 1;\n\tbool enzan;\n\tif (s[pos][nest - 1] == '*')enzan = true;\n\tif (s[pos][nest - 1] == '+')enzan = false;\n\n\tfor (int i = pos + 1; i < n && get_dot(s[i]) >= nest; i++) {\n\t\tif (get_dot(s[i]) == nest) {\n\t\t\tif (s[i][nest] >= '0' && s[i][nest] <= '9') {\n\t\t\t\t//数字である場合\n\n\t\t\t\tif (retv == -1145141919)retv = s[i][nest] - '0';\n\t\t\t\telse {\n\t\t\t\t\tif (enzan)retv *= s[i][nest] - '0';\n\t\t\t\t\telse retv += s[i][nest] - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//演算子である場合\n\t\t\t\t\n\t\t\t\tif (retv == -1145141919)retv = parse(i);\n\t\t\t\telse {\n\t\t\t\t\tif (enzan)retv *= parse(i);\n\t\t\t\t\telse retv += parse(i);\n\t\t\t\t}\n\t\t\t\t//現在のネストの場所まで進める\n\t\t\t\ti++;\n\t\t\t\twhile (i < n && get_dot(s[i]) > nest)i++;\n\n\t\t\t\ti--;\n\n\t\t\t}\t\t\t\n\t\t}\n\t}\n\treturn retv;\n}\n\nint main() {\n\twhile (1) {\n\n\t\tcin >> n;\n\t\tif (n == 0)return 0;\n\t\tfor (int i = 0; i < n; i++)cin >> s[i];\n\t\tif (n == 1 && s[0][0] <= '9' && s[0][0] >= '0')cout << s[0] << endl;\n\t\telse cout << parse(0) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma once\n#include <stdio.h>\n#include <string>\n#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <numeric>\n#include<bitset>\n\nusing namespace std;\n#define modd 1000000007\n#define moda 1000003\n\n\ntypedef pair<long long, long long> pl;\n\n\n\n#define ll long long\n\n\n\n\n/*\nclass UnionFind {\npublic:\n\tvector <ll> par; \n\tvector <ll> siz;\n\tvector <ll> gr;\n\n\t// Constructor\n\tUnionFind(ll sz_) : par(sz_), siz(sz_, 1LL) ,gr(sz_){\n\t\tfor (ll i = 0; i < sz_; ++i) par[i] = i; \n\t}\n\tvoid init(ll sz_) {\n\t\tpar.resize(sz_);\n\t\tsiz.assign(sz_, 1LL);  // resize だとなぜか初期化されなかった\n\t\tfor (ll i = 0; i < sz_; ++i) par[i] = i; // 初期では親は自分自身\n\t}\n\n\t// Member Function\n\t// Find\n\tll root(ll x) { // 根の検索\n\t\twhile (par[x] != x) {\n\t\t\tx = par[x] = par[par[x]]; // x の親の親を x の親とする\n\t\t}\n\t\treturn x;\n\t}\n\n\t// Union(Unite, Merge)\n\tbool merge(ll x, ll y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y) return false;\n\n\t\t// merge technique（データ構造をマージするテク．小を大にくっつける）\n\t\tif (siz[x] < siz[y]) swap(x, y);\n\t\tsiz[x] += siz[y];\n\t\tpar[y] = x;\n\t\treturn true;\n\t}\n\n\n\n\tbool issame(ll x, ll y) { // 連結判定\n\t\treturn root(x) == root(y);\n\t}\n\n\tll size(ll x) { // 素集合のサイズ\n\t\treturn siz[root(x)];\n\t}\n\n\n};*/\n\n\nlong long N, M, K, a, b, c, d,e, H, W;\nlong long A[200005] = {};\nlong long B[200005] = {};\nlong long C[200005] = {};\nll X[2][51] = {};\nll Y[2][51] = {};\nll sx, sy, ex, ey;\nbool f, ff,fff;\nstring S[100];\nset <long long>sll;\npl bufpl;\nvector <long long>vl[100005];\nvector <pl>vpl[20];\nvector <string> vs[20];\nset<ll> llset;\n\nstruct ST\n{\n\tlong long Kati;\n\tint bangou;\n\n\tbool operator<(const ST& another) const\n\t{\n\t\treturn Kati < another.Kati;//比較\n\t};\n\n};\n\n\n\nvector <ST> vst;\nST st[200005];\nST bufst;\nstring bufS;\n\nbitset<5000> bits;\n\nint main() {\n\n\n\twhile (true) {\n\t\tcin >> N;\n\t\tif (N == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> S[i];\n\t\t\ta = 0;\n\t\t\tfor (int j = 0; j < S[i].size(); j++) {\n\t\t\t\tif (S[i][j] == '.') {\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (S[i][j] == '*') {\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\n\t\tif (N == 1) {\n\t\t\tcout <<S[0][0]-'0'<<endl;\n\t\t}\n\n\t\tfor (int i = N - 1; i >= 0; i--) {\n\n\t\t\ta = 0;\n\t\t\tfor (int j = 0; j < S[i].size(); j++) {\n\t\t\t\tif (S[i][j] == '.') {\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (S[i][j] == '*') {\n\t\t\t\t\t\tb = 1;\n\t\t\t\t\t\tfor (int i = 0; i < vl[a + 1].size(); i++) {\n\t\t\t\t\t\t\tb *= vl[a + 1][i];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (a > 0) {\n\t\t\t\t\t\t\tvl[a].push_back(b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcout << b << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvl[a + 1].clear();\n\t\t\t\t\t}\n\t\t\t\t\telse if (S[i][j] == '+') {\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t\tfor (int i = 0; i < vl[a + 1].size(); i++) {\n\t\t\t\t\t\t\tb += vl[a + 1][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a > 0) {\n\t\t\t\t\t\t\tvl[a].push_back(b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcout << b << endl;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvl[a + 1].clear();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvl[a].push_back(S[i][j] - '0');\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t\tS[0] = \"\";\n\t\tfor (int i = 1; i < 100; i++) {\n\t\t\tS[i] = S[0];\n\t\t}\n\n\n\t}\n\n\t\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int MUL = -202020;\nconstexpr int ADD = -292929;\nusing ex = pair<int, long>;\nconstexpr ex INVALID = ex(-1, -1);\n\nint isOperatorChar(char c) {\n  if (c == '+') return ADD;\n  if (c == '*') return MUL;\n  return 0;\n}\n\nbool isOperator(int o) {\n  return o == ADD || o == MUL;\n}\n\nbool isNumber(char c) {\n  return c >= '0' && c <= '9';\n}\n\nex getOrderExp(string s) {\n  int cnt = 0;\n  for (auto c: s) {\n    if (c == '.') cnt++;\n    else if (isOperatorChar(c)) {\n      return ex(cnt + 1, isOperatorChar(c));\n    } else {\n      return ex(cnt, c - '0');\n    };\n  }\n  return ex(-1, -1);\n}\n\nvoid debugExp(vector<ex> &v) {\n  for (auto &w: v) {\n    // cerr << \"order: \" << w.first << \"\\t\" << w.second << endl;\n  }\n}\n\nint getLargestOrder(vector<ex> &v) {\n  int ret = 0;\n  for (auto &w: v) {\n    ret = max(ret, w.first);\n  }\n  return ret;\n}\n\nvoid solve(int n) {\n  vector<ex> v;\n  for (int i = 0; i < n; i++) {\n    string s;\n    cin >> s;\n    v.push_back(getOrderExp(s));\n  }\n\n  while (1) {\n    int order = getLargestOrder(v);\n    // cerr << \"current order: \" << order << endl;\n    debugExp(v);\n    if (order == 0) break;\n    vector<ex> lower;\n    vector<ex> higher;\n    for (auto &w: v) {\n      if (w.first != order || isOperator(w.second)) {\n        if (higher.size()) {\n          if (higher.front().second == ADD) {\n            long ret = 0;\n            for (int i = 1; i < higher.size(); i++) {\n              ret += higher[i].second;\n            }\n            lower.push_back(ex(order - 1, ret));\n            // cerr << \"reducing: ret=\" << ret << endl;\n          } else if (higher.front().second == MUL) {\n            long ret = 1;\n            for (int i = 1; i < higher.size(); i++) {\n              ret *= higher[i].second;\n            }\n            lower.push_back(ex(order - 1, ret));\n            // cerr << \"reducing: ret=\" << ret << endl;\n          }\n          higher.clear();\n        }\n        if (w.first != order) {\n          lower.push_back(w);\n        } else {\n          higher.push_back(w);\n        }\n      } else {\n        higher.push_back(w);\n      }\n    }\n    if (higher.size()) {\n      if (higher.front().second == ADD) {\n        long ret = 0;\n        for (int i = 1; i < higher.size(); i++) {\n          ret += higher[i].second;\n        }\n        lower.push_back(ex(order - 1, ret));\n        // cerr << \"reducing: ret=\" << ret << endl;\n      } else if (higher.front().second == MUL) {\n        long ret = 1;\n        for (int i = 1; i < higher.size(); i++) {\n          ret *= higher[i].second;\n        }\n        lower.push_back(ex(order - 1, ret));\n        // cerr << \"reducing: ret=\" << ret << endl;\n      }\n    }\n    v = vector<ex>(lower);\n  }\n  cout << v.front().second << endl;\n}\n\nint main() {\n  long n;\n  while (1) {\n    cin >> n;\n    if (n) {\n      solve(n);\n    } else {\n      return 0;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\n\nstruct Elem {\n    string symbol;\n    char depth;\n\n    Elem(string _s, char _d) :\n    symbol(_s), depth(_d)\n    {}\n};\n\nint main() {\n    while(true) {\n        int n; cin >> n;\n        if(n == 0) break;\n        if(n == 1) {\n            string s; cin >> s;\n            cout << s << endl;\n            continue;\n        }\n\n        stack<Elem> calc_stack;\n        int depth = 0;\n        for(int i = 0; i < n; ++i) {\n            string str; cin >> str;\n            char c = str[str.length() - 1];\n            if(depth > str.length()) {\n                while(depth > str.length()) {\n                    vector<int> elems;\n                    Elem e(\"\", 0);\n                    while(true) {\n                        e = calc_stack.top();\n                        calc_stack.pop();\n                        if(e.symbol == \"+\" || e.symbol == \"*\") break;\n                        elems.emplace_back(stoi(e.symbol));\n                    }\n                    int m = 0;\n                    if(e.symbol == \"+\") {\n                        m = accumulate(elems.begin(), elems.end(), 0);\n                    } else if(e.symbol == \"*\") {\n                        m = accumulate(elems.begin(), elems.end(), 1, [](int a, int b) {return a*b;});\n                    }\n                    calc_stack.emplace(to_string(m), e.depth);\n                    depth = e.depth;\n                }\n            }\n            calc_stack.emplace(string(1, c), str.length());\n            depth = str.length();\n        }\n        vector<int> elems;\n        Elem e(\"\", 0);\n        while(true) {\n            e = calc_stack.top();\n            calc_stack.pop();\n            if(e.symbol == \"+\" || e.symbol == \"*\") break;\n            elems.emplace_back(stoi(e.symbol));\n        }\n        int m = 0;\n        if(e.symbol == \"+\") {\n            m = accumulate(elems.begin(), elems.end(), 0);\n        } else if(e.symbol == \"*\") {\n            m = accumulate(elems.begin(), elems.end(), 1, [](int a, int b) {return a*b;});\n        }\n        cout << m << endl;\n    }\n\n    return 0;\n}\n// [Problem] ICPC Calculator\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1602&lang=jp\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nstring s[30];\nlong long dfs(int d,int k){\n  bool e=0;\n  long long res=0;\n  if(s[d][k]=='+')d++,k++;\n  if(s[d][k]=='*')e=1,d++,k++,res=1;\n  for(int i=d;i<n&&k<s[i].size();i++){\n    if(s[i][k]=='.')continue;\n    int a=s[i][k]-'0';\n    if(s[i][k]=='+'||s[i][k]=='*')a=dfs(i,k);\n    if(e)res*=a;\n    else res+=a;\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>s[i];\n    cout<<dfs(0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <math.h>\n#include <queue>\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tvalue = depth = 0;\n\t\tisOP = false;\n\t\tch = 0;\n\t\tused = false;\n\t}\n\n\tint value,depth;\n\tchar ch;\n\tbool isOP,used;\n};\n\nvoid func(int n){\n\tchar buf[30];\n\n\tInfo info[30];\n\tint tmp,index = 0;\n\n\tfor(int loop = 0; loop < n; loop++){\n\t\tscanf(\"%s\",buf);\n\t\ttmp = 0;\n\t\tfor(int i = 0; buf[i] != '\\0'; i++){\n\t\t\tif(buf[i] == '.'){\n\t\t\t\ttmp++;\n\t\t\t}else if(buf[i] >= '0' && buf[i] <= '9'){\n\t\t\t\tinfo[index].isOP = false;\n\t\t\t\tinfo[index].depth = tmp;\n\t\t\t\tinfo[index].value = buf[i] - '0';\n\t\t\t\tindex++;\n\t\t\t}else{\n\t\t\t\tinfo[index].isOP = true;\n\t\t\t\tinfo[index].depth = tmp;\n\t\t\t\tinfo[index].ch = buf[i];\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n\n\tint max_depth,max_loc;\n\n\tint pre_loc;\n\n\twhile(true){\n\t\tmax_depth = -1;\n\n\t\tfor(int i = 0; i < index; i++){\n\t\t\tif(info[i].isOP == true && info[i].used == false && info[i].depth > max_depth){\n\t\t\t\tmax_depth = info[i].depth;\n\t\t\t\tmax_loc = i;\n\t\t\t}\n\t\t}\n\t\tif(max_depth == -1)break;\n\n\t\tpre_loc = -1;\n\n\t\tfor(int i = max_loc+1;(info[i].used == true || info[i].depth == max_depth+1) && i < index;i++){\n\t\t\tif(info[i].used == false && info[i].depth == max_depth+1){\n\t\t\t\tif(pre_loc == -1){\n\t\t\t\t\tpre_loc = i;\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tif(info[max_loc].ch == '*'){\n\t\t\t\t\t\tinfo[i].value *= info[pre_loc].value;\n\t\t\t\t\t\tinfo[pre_loc].used = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tinfo[i].value += info[pre_loc].value;\n\t\t\t\t\t\tinfo[pre_loc].used = true;\n\t\t\t\t\t}\n\t\t\t\t\tpre_loc = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif((i == index - 1) || (info[i+1].used == false && info[i+1].depth != max_depth+1)){\n\t\t\t\tinfo[max_loc].value = info[pre_loc].value;\n\t\t\t\tinfo[max_loc].isOP = false;\n\t\t\t\tinfo[pre_loc].used = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans;\n\n\tfor(int i = 0; i < index; i++){\n\t\tif(info[i].used == false && info[i].isOP == false){\n\t\t\tans = info[i].value;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n}\n\nint main(){\n\n\tint n;\n\twhile(true){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)break;\n\n\t\tfunc(n);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\n\nint main(){\n  int n;\n  while(1){\n    stack<int> statsmemo,pointmemo;\n    cin>>n;\n    if(n==0) break;\n    int now=1,stats=-1,point=0;\n    int count=0;\n    lp(z,n){\n      count=0;\n      char q;\n      while(1){\n\tcin>>q;\n\tcount++;\n\tif(q!='.') break;\n      }\n      if(count<now){\n\twhile(count!=now){\n\t  int statsed,pointed;\n\t  statsed=statsmemo.top();\n\t  pointed=pointmemo.top();\n\t  statsmemo.pop();\n\t  pointmemo.pop();\n\t  if(statsed==0){\n\t    point+=pointed;\n\t  }\n\t  if(statsed==1){\n\t    if(point==0){\n\t      point+=pointed;\n\t    }\n\t    else point*=pointed;\n\t  }\n\t  stats=statsed;\n\t  now--;\n\t}\n\tnow=count;\n      }\n      if(q=='+'){\n\tif(stats!=-1){\n\t  statsmemo.push(stats);\n\t  pointmemo.push(point);\n\t}\n\tstats=0;\n\tpoint=0;\n\tnow++;\n      }\n      if(q=='*'){\n\tif(stats!=-1){\n\t  statsmemo.push(stats);\n\t  pointmemo.push(point);\n\t}\n\tstats=1;\n\tpoint=0;\n\tnow++;\n      }\n      if('0'<=q && q<='9'){\n\tif(stats==0) point+=q-'0';\n\tif(stats==1){\n\t  if(point==0) point+=q-'0';\n\t  else point*=q-'0';\n\t}\n\tif(stats==-1) point+=q-'0';\n      }\n    }\n    while(count>1){\n      int statsed,pointed;\n      statsed=statsmemo.top();\n      pointed=pointmemo.top();\n      statsmemo.pop();\n      pointmemo.pop();\n      if(statsed==0){\n\tpoint+=pointed;\n      }\n      if(statsed==1){\n\tif(point==0){\n\t  point+=pointed;\n\t}\n\telse point*=pointed;\n      }\n      stats=statsed;\n      count--;\n    }\n    cout<<point<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(n); ++i)\n\ntypedef pair<int, char> P;\n\nint getLevel(string &expr) {\n    int ret = 0;\n    while(expr[ret] == '.') ret++;\n    return ret;\n}\n\nbool isdigit(char c) {\n    return c >= '0' && c <= '9';\n}\n\nint process(vector<string> &expr, int* line) {\n    int ret;\n    int level = getLevel(expr[*line]);\n    if(level == 0 && isdigit(expr[*line][level])) \n        return expr[*line][level]-'0';\n    else if(expr[*line][level] == '+') {\n        (*line)++;\n        ret = 0;\n        while((*line) < expr.size()) {\n            int new_level = getLevel(expr[*line]);\n            if(new_level == level+1) {\n                if(isdigit(expr[*line][new_level]))\n                    ret += expr[*line][new_level]-'0';\n                else \n                    ret += process(expr, line);\n                (*line)++;\n            } else {\n                (*line)--;\n                break;\n            }\n        }\n        return ret;\n    } else if(expr[*line][level] == '*') {\n        (*line)++;\n        ret = 1;\n        while((*line) < expr.size()) {\n            int new_level = getLevel(expr[*line]);\n            if(new_level == level+1) {\n                if(isdigit(expr[*line][new_level]))\n                    ret *= expr[*line][new_level]-'0';\n                else \n                    ret *= process(expr, line);\n                (*line)++;\n            } else {\n                (*line)--;\n                break;\n            }\n        }\n        return ret;\n    }\n}\n\nint main(void){\n    int n;\n    string s;\n    vector<string> expr;\n    while(cin >> n && n) {\n        cin.ignore();\n        expr.clear();\n        rep(i, n) {\n            getline(cin, s);\n            expr.push_back(s);\n        }\n        int line = 0;\n        cout << process(expr, &line) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n\nint dots_num(std::string s); \nint value_num(char c); \nvoid inner_loop(std::stack<std::pair<int, int> > &st); \nvoid dfs(int n); \n\n\nint main(void) {\n    int n;\n    while (1) {\n        std::cin >> n;\n        if (n == 0) {\n            break;\n        }\n        dfs(n);\n    }\n    return 0;\n}\n\nint dots_num(std::string s) {\n    int num = 0;\n    int loop = 0;\n    while (s[loop] == '.') {\n        ++num; \n        ++loop;\n    }\n    return num;\n}\n\nint value_num(char c) {\n    int ret;\n    if (c == '+') {\n        ret = -1; \n    } else if (c == '*') {\n        ret = -2;\n    } else {\n        ret = (int) c - 48;\n    }\n    return ret;\n}\n\nvoid inner_loop(std::stack<std::pair<int, int> > &st) {\n    int start_dots;\n    int enzan[2] = {0, 1};\n    start_dots = st.top().first;\n    std::pair<int, int> p;\n\n    while (1) {\n        if (start_dots > st.top().first) {\n            break;\n        }\n        enzan[0] += st.top().second;\n        enzan[1] *= st.top().second;\n        st.pop();\n    }\n    if (st.top().second == -1) {\n        p = std::make_pair(st.top().first, enzan[0]);\n        st.pop();\n        st.push(p);\n    } else if(st.top().second == -2) {\n        p = std::make_pair(st.top().first, enzan[1]);\n        st.pop();\n        st.push(p);\n    }\n    return;\n}\n\nvoid dfs(int n) {\n    std::string s;\n    std::stack<std::pair<int, int> > st;\n    st.push(std::make_pair(0, 0));\n    int dots;\n    int value;\n\n    for (int i = 0; i < n; i++) {\n        std::cin >> s;\n        dots = dots_num(s);\n        value = value_num(s[dots]);\n\n        while (1) {\n            if (st.top().first <= dots) {\n                break; \n            }\n            inner_loop(st); \n        }\n        st.push(std::make_pair(dots, value));\n    }\n\n    while (1) {\n        if (st.top().first == 0) {\n            break; \n        }\n        inner_loop(st); \n    }\n    std::cout << st.top().second << std::endl;\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<functional>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<climits>\n#include<cstdlib>\n#include<cmath>\n#include<string>\n#include<iomanip>\n#include<bitset>\n#include<list>\n\nusing namespace std;\n\n#define ll long long int\n\nll const MOD = 1000000007;\nll const INF = (long long int)1 << 61;\n\nstruct semanticInfo{\n    ll val;\n    ll treeIdx;\n    \n    semanticInfo(){\n        val = 0;\n        treeIdx = 0;\n    }\n\n    semanticInfo(ll initV,ll initI){\n        val = initV;\n        treeIdx = initI;\n    }\n};\n\nll mypow(ll x,ll n){\n    ll ret = 1;\n    while(n > 0){\n        if(n&1){\n            ret = (ret*x)%MOD;\n        }\n        x = (x*x)%MOD;\n        n >>= 1;\n    }\n    return ret;\n}\n\nsemanticInfo semantic(const vector<string> &statement,int idx,int depth){\n    if('0' <= statement[idx][depth] && statement[idx][depth] <= '9'){\n        return semanticInfo(statement[idx][depth] - '0',idx);\n    }\n    semanticInfo ret;\n    bool times = false;\n    if(statement[idx][depth] == '*'){\n        ret = semanticInfo(1,idx);\n        times = true;\n    }else{\n        ret = semanticInfo(0,idx);\n    }\n    while(ret.treeIdx + 1 < statement.size()){\n        ll nextdepth = 0;\n        while(statement[ret.treeIdx+1][nextdepth] == '.'){\n            nextdepth++;\n        }\n        if(depth >= nextdepth){\n            return ret;\n        }else{\n            auto tmp = semantic(statement,ret.treeIdx+1,depth+1);\n            if(times){\n                ret.val *= tmp.val;\n            }else{\n                ret.val += tmp.val;\n            }\n            ret.treeIdx = tmp.treeIdx;\n        }\n    }\n    return ret;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n \n    vector<ll> ans;\n\n    while(true){\n        ll n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        vector<string> state;\n        for(int i = 0; i < n; i++){\n            string str;\n            cin >> str;\n            state.push_back(str);\n        }\n        ans.push_back(semantic(state,0,0).val);\n    }\n\n    for(auto x: ans){\n        cout << x << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(long long int i=0;i<n;++i)\ntypedef long long int ll;\n\nint dfs(vector<string> a,int id){\n    int ret;\n    if(a[id].back()=='*'){\n        ret=1;\n        for(int i=id+1;i<a.size();i++){\n            if(a[id].size()+1==a[i].size()){\n                if(a[i].back()=='+'||a[i].back()=='*'){\n                    ret*=dfs(a,i);\n                }else{\n                    ret*=a[i].back()-'0';\n                }\n            }else if(a[i].size()<=a[id].size()){\n                break;\n            }\n        }\n    }else if(a[id].back()=='+'){\n        ret=0;\n        for(int i=id+1;i<a.size();i++){\n            if(a[id].size()+1==a[i].size()){\n                if(a[i].back()=='+'||a[i].back()=='*'){\n                    ret+=dfs(a,i);\n                }else{\n                    ret+=a[i].back()-'0';\n                }\n            }else if(a[i].size()<=a[id].size()){\n                break;\n            }\n        }\n    }else{\n        return a[id].back()-'0';\n    }\n    return ret;\n}\n\nint main(){\n\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0)break;\n        vector<string> a(n);\n        for(int i=0;i<n;i++){\n            cin >> a[i];\n        }\n        int ans=dfs(a,0);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nstring s[10];\n\nll calc(int p, int q) {\n  bool add = false;\n  if ('0' <= s[p][s[p].length() - 1] && s[p][s[p].length() - 1] <= '9') {\n    return s[p][s[p].length() - 1] - '0';\n  } else if (s[p][s[p].length() - 1] == '+') {\n    add = true;\n  }\n\n  ll ans = ((add) ? 0 : 1);\n  repl(i, p + 1, q) {\n    if ('0' <= s[i][s[i].length() - 1] && s[i][s[i].length() - 1] <= '9') {\n      if (add) ans += (s[i][s[i].length() - 1] - '0');\n      else ans *= (s[i][s[i].length() - 1] - '0');\n    } else {\n      int j = i++;\n      while(i < q && s[j].length() < s[i].length()) i++;\n      if (add) ans += calc(j, i);\n      else ans *= calc(j, i);\n      i--;\n    }\n  }\n\n  return ans;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  int n;\n\n  while(cin >> n, n) {\n    rep(i, n) cin >> s[i];\n    print(calc(0, n));\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <set>\n#include <iomanip>\n#include <stack>\n#include <fstream>\n#include <cstdint>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <functional>\n\nusing namespace std;\n\nconstexpr int INF = 1000000000;/* 1e+9a */\nconstexpr int MODULO = 1000000007;\n\ntypedef int64_t ll;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    while(cin >> n){\n        if(n == 0)\n            break;\n        stack<char> op;\n        map<int, stack<int>> num;\n        int cd = 0;\n        int ans = 0;\n        char ch;\n        for (int i = 0; i < n; ++i) {\n            int d = 0;\n            while(cin >> ch){\n                if(ch != '.') break;\n                else d++;\n            }\n\n            if(cd > d){\n                char opc = op.top();\n                op.pop();\n                function<int(int, int)> operato = multiplies<int>();\n                int res = 1;\n                if(opc == '+') {\n                    operato = plus<int>();\n                    res = 0;\n                }\n                auto&& cdstack = num[cd];\n                while(!cdstack.empty()){\n                    res = operato(res, cdstack.top());\n                    cdstack.pop();\n                }\n                cd--;\n                num[cd].push(res);\n//                cerr << cd << \": \" << res << '\\n';\n            }\n\n            if(ch == '+') op.push('+'), cd++;\n            else if(ch == '*') op.push('*'), cd++;\n            else num[cd].push(ch - '0');\n        }\n        while(cd > 0){\n            char opc = op.top();\n            op.pop();\n            function<int(int, int)> operato = multiplies<int>();\n            int res = 1;\n            if(opc == '+') {\n                operato = plus<int>();\n                res = 0;\n            }\n            auto&& cdstack = num[cd];\n            while(!cdstack.empty()){\n                res = operato(res, cdstack.top());\n                cdstack.pop();\n            }\n            cd--;\n            num[cd].push(res);\n//            cerr << cd << \": \" << res << '\\n';\n        }\n        cout << num[0].top() << endl;\n        num[0].pop();\n\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\n#define pb push_back\n#define ll long long\nusing namespace std;\nvector<string> a;\nint n,l;\n\nint calc(int v){\n  char c=a[l][v];\n  char cc;\n  int r;\n  l++;v++;\n  //cout<<\":\"<<c<<endl;\n  if(l<n-1&&(a[l][v]=='+'||a[l][v]=='*')) r=calc(v);\n  else{\n    if(c=='*') r=1;\n    else if(c=='+') r=0;\n    else r=c-'0';\n  }\n  if(l>=n) return r;\n  if(c=='+'){\n    while(a[l].size()==v+1){\n      cc=a[l][v];\n      //cout<<cc<<endl;\n      if(l+1<n&&(cc=='+'||cc=='*')) r+=calc(v);\n      else {r+=cc-'0';l++;}\n      if(l==n) break;\n    }\n  }\n  else if(c=='*'){\n    while(a[l].size()==v+1){\n      cc=a[l][v];\n      if(l+1<n&&(cc=='+'||cc=='*')) r*=calc(v);\n      else {r*=cc-'0';l++;}\n      if(l==n) break;\n    }\n  }\n  //cout<<r<<endl;\n  return r;\n}\n\nint main(){\n  int i;\n  while(cin >> n,n){\n    string s;\n    a.clear();\n    for(i=0;i<n;i++){\n      cin >> s;\n      a.pb(s);\n    }\n    l=0;\n    cout << calc(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n\nint n;\nint cursor;\nvector<string> s;\n\nint calc(int mode, int depth) {\n        int sum = mode == 1 ? 0 : 1;\n\n        while (cursor < n && depth == s[cursor].size() - 1){\n                string str = s[cursor];\n                int points = str.size() - 1;\n                char a = str[points];\n                int num = a - '0';\n                if (mode == 1){\n                        if (a == '+') {\n                                cursor++;\n                                sum += calc(1, depth + 1);\n                        }\n                        else if (a == '*') {\n                                cursor++;\n                                sum += calc(2, depth + 1);\n                        }\n                        else{\n                                cursor++;\n                                sum += num;\n                        }\n                }\n                if (mode == 2){\n                        if (a == '+') {\n                                cursor++;\n                                sum *= calc(1, depth + 1);\n                        }\n                        else if (a == '*') {\n                                cursor++;\n                                sum *= calc(2, depth + 1);\n                        }\n                        else{\n                                cursor++;\n                                sum *= num;\n                        }\n                }\n        }\n        return sum;\n}\n\nint main() {\n        while (cin >> n, n != 0) {\n                s = vector<string>(n);\n                for (int i = 0; i < n; i++){\n                        cin >> s[i];\n                }\n                cursor = 0;\n                int sum = calc(1, 0);\n                cout << sum << endl;\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n\n\n\nint main(){\n  while(1){\n  int n;\n  scanf(\"%d\",&n);\nif(n==0)break;\nstring unko[100];\nfor(int i=0;i<n;i++)cin >> unko[i] ;\nint maxlen=0;\nint atai[n];\nfor(int i=0;i<n;i++)if(unko[i][unko[i].size()-1]>='0'&&unko[i][unko[i].size()-1]<='9')atai[i]=unko[i][unko[i].size()-1]-'0';else atai[i]=-1;\nfor(int i=0;i<n;i++)if(unko[i].size()>maxlen)maxlen=unko[i].size();\nfor(int i=maxlen-1;i>=0;i--)for(int j=0;j<n;j++){\n  if(unko[j].size()==i&&atai[j]==-1){\n    int po;\n    if(unko[j][unko[j].size()-1]=='+')po=0;\n    else po=1;\n    for(int k=j+1;unko[k].size()>unko[j].size()&&k<n;k++){\n      if(unko[k].size()==unko[j].size()+1){\n        if(unko[j][unko[j].size()-1]=='+')po+=atai[k];\n        else po*=atai[k];\n      }\n    }\n    atai[j]=po;\n  }\n}\n//for(int i=0;i<n;i++)printf(\"%d \",atai[i]);\nprintf(\"%d\\n\",atai[0]);\n}\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n, i, j, k, si, temp1, temp2, sum1, sum2;\n  string str;\n  stack<int> temp;\n  \n  while(1){\n    cin>>n;\n\n    if(n == 0) break;\n\n    for(i = 0; i <= n; i++){\n      \n      if(i != n){\n\tcin>>str;\n\tsi = str.size()-1;\n\tif(i==0)temp1 = si;\n\ttemp2 = si;\n      } else {\n\ttemp2 = 0;\n      }\n      \n      \n      sum1 = 1; sum2 = 0;\n      \n      if(temp2 < temp1){\n\tj = 0;\n\twhile(1){\n\t  if(temp.top() < 0){\n\t    if(temp.top() == -1){\n\t      temp.pop();\n\t      temp.push(sum1);\n\t      } else{\n\t      temp.pop();\n\t      temp.push(sum2);\n\t    }\n\t    sum1 = 1; sum2 = 0;\n\t    j++;\n\t  }\n\t  if(temp1-temp2 <= j) break;\n\t  \n\t  sum1 *= temp.top();\n\t  sum2 +=temp.top();\n\t  temp.pop();\n\t  }\n      }\n      \n      if(i != n && str[si] == '*'){\n\ttemp.push(-1);\n\t} else if(i != n && str[si] == '+'){\n\ttemp.push(-2);\n      } else if(i != n){\n\ttemp.push(str[si] - '0');\n      }\t\n      temp1 =  temp2;\n    }\n    cout<<temp.top()<<endl;\n    temp.pop();\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  static auto add = [](int a, int b) { return a + b; };\n  static auto mul = [](int a, int b) { return a * b; };\n  int n;\n  while (cin >> n, n) {\n    vector<string> a(n);\n    for (auto& e : a) {\n      cin >> e;\n    }\n    a.push_back(\"0\");\n    vector<pair<function<int(int, int)>, int>> v{make_pair(add, 0)};\n    for (auto e : a) {\n      while (e.size() - 1 < v.size() - 1) {\n        (v.rbegin() - 1)->second = (v.rbegin() - 1)->first((v.rbegin() - 1)->second, v.rbegin()->second);\n        v.pop_back();\n      }\n      char c = *e.rbegin();\n      if (c == '+') {\n        v.push_back(make_pair(add, 0));\n      } else if (c == '*') {\n        v.push_back(make_pair(mul, 1));\n      } else {\n        v.rbegin()->second = v.rbegin()->first(v.rbegin()->second, c - '0');\n      }\n    }\n    cout << v.back().second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nint add(vector<string>::iterator &itr);\nint mlt(vector<string>::iterator &itr);\n\nint main(){\n    while(true){\n        int n; cin >> n;\n        if( n == 0)break;\n        vector<string> s(n);\n        for(int i = 0; i < n; i++){\n            cin >> s[i];\n        }\n        int ans = 0;\n        for(vector<string>::iterator itr = s.begin(); itr != s.end(); ++itr){\n            if((itr->back()) == '+'){\n                ans += add(itr);\n            }\n            else if((itr->back()) == '*'){\n                ans += mlt(itr);\n            }\n            else{\n                ans += itr->back() - '0';\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\nint add(vector<string>::iterator &itr){\n    int c = itr->size()+1;\n    int ret = 0;\n    ++itr;\n    while((int)(itr->size()) == c){\n        if(itr->back() == '+'){\n            ret += add(itr);\n        }\n        else if((itr->back()) == '*'){\n            ret += mlt(itr);\n        }\n        else{\n            ret += itr->back() -'0';\n        }\n        ++itr;\n    }\n        \n    --itr;\n    return ret;\n}\n\nint mlt(vector<string>::iterator &itr){\n    int c = itr->size();\n    int ret = 1;\n    ++itr;\n    while((int)(itr->size()) == c+1){\n        if(itr->back() == '+'){\n            ret *= add(itr);\n        }\n        else if((char)(itr->back()) == '*'){\n            ret *= mlt(itr);\n        }\n        else{\n            ret *= itr->back() - '0';\n        }\n        ++itr;\n    }\n    --itr;\n    return ret;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<climits>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nvoid solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        st.push(make_pair(th, l-1));\n    }\n}\nint main(){\n    int ca=0;\n    while(cin>>n,n){\n        while(ope.size())ope.pop();\n        while(st.size())st.pop();\n        if(ca++>15)return -1;\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    solve(level);\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        solve(0);\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <array>\n#include <functional>\n#include <sstream>\n#include <list>\n#include <iomanip>\n#include <set>\nconst int MOD=1000000007;\nconst int INF=1000000000;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-9;\nconst int inf=1e9;\ntypedef pair<int,int> P;\nstruct Point\n{\n  double x,y;\n  Point(){x=0;y=0;}\n  Point(double d_x,double d_y){x=d_x,y=d_y;}\n  double operator*(Point obj){return obj.x*x+obj.y*y;}\n  double operator%(Point obj){return obj.y*x-obj.x*y;}\n  Point operator*(double b){Point tmp;tmp.x=x*b;tmp.y=y*b;return tmp;}\n  Point operator/(double b){Point tmp;tmp.x=x/b;tmp.y=y/b;return tmp;}\n  Point operator+(Point obj){Point tmp;tmp.x=x+obj.x;tmp.y=y+obj.y;return tmp;}\n  Point operator-(){Point tmp;tmp.x=-x;tmp.y=-y;return tmp;}\n  Point operator-(Point obj){Point tmp;tmp.x=x-obj.x;tmp.y=y-obj.y;return tmp;}\n  Point operator-=(Point obj){x-=obj.x;y-=obj.y;return *this;}\n  Point operator+=(Point obj){x+=obj.x;y+=obj.y;return *this;}\n  Point operator/=(double b){x=x/b;y=y/b;return *this;}\n  Point operator*=(double b){x=x*b;y=y*b;return *this;}\n  double size(){return hypot(x,y);}\n  Point unit(){return Point(x/size(),y/size());}\n  Point normal(){return Point(y,-x);}\n  double atan(){return atan2(y,x);}\n};\n\nbool operator<(Point a,Point b){return a.x!=b.x?a.x<b.x:a.y<b.y;}\nbool operator>(Point a,Point b){return b<a;}\nbool operator<=(Point a,Point b){return !(b<a);}\nbool operator>=(Point a,Point b){return !(a<b);}\nbool operator==(Point a,Point b){return (a-b).size()<eps;}\nbool operator!=(Point a,Point b){return !(a==b);}\n\nbool equal(double a,double b){return abs(a-b)<eps;}\ndouble cross(Point a,Point b){return a%b;}\ndouble dot(Point a,Point b){return a*b;}\n\nint ccw(Point a,Point b,Point c)\n{\n  b=b-a;\n  c=c-a;\n  if(b%c>0) return +1;\n  else if(b%c<0)return -1;\n  else if(b*c<0) return +2;\n  else if(b.size()<c.size()) return -2;\n  else return 0;\n}\n\ntypedef pair<int,char> pic;\nint n;\nint getlevel(string &expr)\n{\n  int ret=0;\n  while(expr[ret]=='.') ret++;\n  return ret;\n}\n\nbool isdigit(char c)\n{\n  return c>= '0' && c<='9';\n}\n\nint process(vector<string> &expr,int* line)\n{\n  int ret;\n  int level=getlevel(expr[*line]);\n  if(level==0 && isdigit(expr[*line][level]))\n    return expr[*line][level]-'0';\n  else if(expr[*line][level]=='+')\n    {\n      (*line)++;\n      ret=0;\n      while((*line) < expr.size())\n\t{\n\t  int new_level=getlevel(expr[*line]);\n\t  if(new_level==level+1)\n\t    {\n\t      if(isdigit(expr[*line][new_level]))\n\t\tret+=expr[*line][new_level]-'0';\n\t      else\n\t\tret+=process(expr,line);\n\t      (*line)++;\n\t    }\n\t  else\n\t    {\n\t      (*line)--;\n\t      break;\n\t    }\n\t}\n      return ret;\n    }\n  else if(expr[*line][level]=='*')\n    {\n      (*line)++;\n      ret=1;\n      while((*line)<expr.size())\n\t{\n\t  int new_level=getlevel(expr[*line]);\n\t  if(new_level==level+1)\n\t    {\n\t      if(isdigit(expr[*line][new_level]))\n\t\tret*=expr[*line][new_level]-'0';\n\t      else\n\t\tret*=process(expr,line);\n\t      (*line)++;\n\t    }\n\t  else\n\t    {\n\t      (*line)--;\n\t      break;\n\t    }\n\t}\n      return ret;\n    }\n}\n\nint main(int argc,char const* argv[])\n{\n  string tmp;\n  while(1)\n    {\n      cin >> n;\n      if(!n) break;\n      string s;\n      vector<string> expr;\n      for(int i=0;i<n;i++)\n\t{\n\t  cin >> s;\n\t  expr.push_back(s);\n\t}\n      int line=0;\n      cout << process(expr,&line) << endl;\n    }\n  return 0;\n}\n\t  \n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\n\nint n;\nstring str[30];\n\nint calc(int& i){\n  int d=0;\n  while(str[i][d]=='.') d++;\n  int ans;\n  bool e=0;\n  if(str[i][d]=='+'){\n    ans=0;\n  }else if(str[i][d]=='*'){\n    ans=1;\n    e=1;\n  }else{\n    ans=(int)(str[i][d]-'0');\n    i++;\n    return ans;\n  }\n  i++;\n  while(i<n && str[i].length()>d+1){\n    if(e==0){\n      ans+=calc(i);\n    }else{\n      ans*=calc(i);\n    }\n  }\n  return ans;\n}\n\nint main()\n{\n\twhile(1){\n      scanf(\"%d\", &n);\n      if(n==0) return 0;\n      for(int i=0; i<n; i++){\n        cin>>str[i];\n      }\n      int j=0;\n      int ans=calc(j);\n      printf(\"%d\\n\", ans);\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#include <boost/multiprecision/cpp_int.hpp>\n//typedef boost::multiprecision::cpp_int ll;\ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E17;\n\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n///////////////////////////////////////\n\ntypedef string::const_iterator State;\n\n\n\nint main(){fastio\n    while(1){\n        ll n;cin>>n;\n        if(n==0)break;\n        vector<l_l>v;\n        rep(i,0,n-1){\n            string s;cin>>s;\n            ll k=s[s.length()-1]-'0';\n            if(s[s.length()-1]=='+')k=-1;\n            else if(s[s.length()-1]=='*')k=-2;\n            v.pb(l_l(s.length(),k));\n        }\n        reverse(v.begin(),v.end());\n        for(ll len=10;len>=2;len--){\n            vector<l_l>nv;\n            ll vs=v.size();\n            ll pos=0;\n            while(pos<=vs-1){\n                if(v[pos].first==len){\n                    queue<ll>q;\n                    q.push(v[pos].second);\n                    pos++;\n                    while(1){\n                        if(v[pos].first==len){\n                            q.push(v[pos].second);\n                            pos++;\n                        }else{\n                            break;\n                        }\n                    }\n                    if(v[pos].second==-1){\n                        ll k=0;\n                        while(!q.empty()){\n                            k+=q.front();q.pop();\n                        }\n                        nv.pb(l_l(len-1,k));\n                    }else if(v[pos].second==-2){\n                        ll k=1;\n                        while(!q.empty()){\n                            k*=q.front();q.pop();\n                        }\n                        nv.pb(l_l(len-1,k));\n                    }\n                    pos++;\n                }else{\n                    nv.pb(v[pos]);\n                    pos++;\n                }\n            }\n            v.clear();\n            for(auto x:nv)v.pb(x);\n        }\n        cout<<v[0].second<<endl;\n    }\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\nusing namespace std;\n\nint p;\nvector<string> s;\n\nint dfs(int d) {\n  if (s[p][d] == '+') {\n    int res = 0;\n    p++;\n    while (p < s.size() && s[p].size() - 1 > d) res += dfs(d + 1);\n    return res;\n  } else if (s[p][d] == '*') {\n    int res = 1;\n    p++;\n    while (p < s.size() && s[p].size() - 1 > d) res *= dfs(d + 1);\n    return res;\n  } else {\n    int res = s[p][d] - '0';\n    p++;\n    return res;\n  }\n}\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    s = vector<string>(n);\n    REP(i, n) cin >> s[i];\n    p = 0;\n    cout << dfs(0) << endl;;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1602&lang=jp\n#include <algorithm>\n#include <iostream>\n#include <queue>\nusing namespace std;\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nusing dset = pair<int, char>;\nqueue<dset> qu;\n\ndset sanitize(string s) {\n  // cout << s << endl;\n  int depth = 0;\n  int len = s.length();\n  for (depth = 0; depth < len; depth++) {\n    // cout << depth << s[depth] << endl;\n    if (s[depth] != '.') break;\n  }\n  // cout << depth << s[depth] << \"**\" << endl;\n  dset res = make_pair(depth, s[depth]);\n  // cout << res.first << \" \" << res.second << endl;\n  return res;\n}\n\nint cal(char enzn, int a, int b) {\n  if (enzn == '+') {\n    // cout << a << \"+\"\n    //      << b\n    //      << \"=\" << a + b << endl;\n    return a + b;\n  } else {\n    // cout << a << \"*\"\n    //      << b\n    //      << \"=\" << a * b << endl;\n    return a * b;\n  }\n}\n\nint slove() {\n  int res = 0;\n  bool init = false;\n  dset current_data = qu.front();\n  qu.pop();\n  dset next_data;\n  int current_depth = current_data.first;\n  while (!qu.empty()) {\n    next_data = qu.front();\n    if (next_data.first <= current_depth) {\n      // cout << current_depth << \" : Return : \" << res << endl;\n      return res;\n    }else{\n      if (next_data.second == '+' || next_data.second == '*') {\n        int t = slove();\n        if (init) {\n          res = cal(current_data.second, res, t);\n        } else {\n          init = true;\n          res = t;\n        }\n        // qu.pop();\n      } else {\n        if (init) {\n          res = cal(current_data.second, res, next_data.second - '0');\n        } else {\n          init = true;\n          res = next_data.second - '0';\n        }\n        qu.pop();\n      }\n    }\n  }\n  return res;\n}\n\nint main(void) {\n  int n, res;\n  while (true) {\n    cin >> n;\n    res = 0;\n    if (n == 0) break;\n    // if (!qu.empty()) {\n    // cout << \"size:\" << qu.size() << endl;\n    // while (!qu.empty()) {\n    //   dset p = qu.front(); qu.pop();\n    //   cout << p.first << \",\" << p.second << endl;\n    // }\n    // }\n    std::queue<dset> empty;\n    std::swap(qu, empty);\n    for (int i = 0; i < n; i++) {\n      string st;\n      cin >> st;\n      dset nt = sanitize(st);\n      if(n == 1) res = nt.second - '0';\n      qu.push(nt);\n    }\n    if(n != 1) res = slove();\n    // cout << \"ANS : \";\n    cout << res <<  endl;\n    // if (!qu.empty()) cout << \"q: \" << qu.front().second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\n\nint n, p;\nint d[200];\nchar c[200];\n\nint solve(){\n    if('0' <= c[p] && c[p] <= '9') return c[p++] - '0';\n    int k = p;\n    int res = (c[k] == '*' ? 1 : 0);\n    p++;\n    while(d[p] == d[k] + 1){\n        if(c[k] == '+') res += solve();\n        if(c[k] == '*') res *= solve();\n    }\n    return res;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        rep(i, 0, 200) d[i] = 0;\n        rep(i, 0, n){\n            string s;\n            cin >> s;\n            d[i] = s.size();\n            c[i] = s[s.size() - 1];\n        }\n        p = 0;\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint func()\n{\n  int N;\n  cin >> N;\n  if( N == 0 ) return -1;\n\n  long long int v[10] = { 0 };\n  char m[10] = { 0 };\n\n  for( int i = 0; i < N; ++i ){\n    string S;\n    cin >> S;\n\n    int cnt = 0, len = S.length();\n\n    for( int j = 0; j < len; ++j ){\n      switch( S[j] ){\n        case '.': ++cnt; break;\n        case '+': case '*': m[cnt] = S[j]; break;\n        default: if( cnt == 0 ){\n                  cout << S[j]-'0' << endl;\n                  return 0;\n                } else if( m[cnt-1] == '+' ){ v[cnt-1] += (long long int)(S[j]-'0');\n                 } else if( m[cnt-1] == '*' ){\n                     if( v[cnt-1] == 0 ) v[cnt-1] = (long long int)1;\n                     v[cnt-1] *= (long long int)(S[j]-'0');\n                 }\n                 //cout << \": \" << v[0] << endl;\n                 break;\n        }\n      }\n    }\n\n    long long int ans = v[0];\n    for( int i = 0; m[i+1] != 0; ++i ){\n      //if( i == 0 ){\n        //if( m[i] == '+' ) ans = v[0] + v[1];\n        //else ans = v[0] * v[1];\n      //} else {\n        if( m[i] == '+' ) ans += v[i+1];\n        else ans *= v[i+1];\n      //}\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\nint main()\n{\n  while( func() != -1 ) ;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n)  { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x)         { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nvector<string> siki;\nint n;\nint part(int *idx,int deep,bool plus) {\n\tint ret = 0;\n\tif(plus==false)\n\tret = 1;\n\twhile (*idx != n) {\n\t\tif (deep+1 > siki[*idx].length())\n\t\t\treturn ret;\n\t\tif (siki[*idx][deep] == '*') {\n\t\t\t*idx+=1;\n\t\t\tint a= part(idx, deep + 1, false);\n\t\t\tif (plus)\n\t\t\t\tret += a;\n\t\t\telse\n\t\t\t\tret *= a;\n\t\t\tcontinue;\n\t\t}\n\t\tif (siki[*idx][deep] == '+') {\n\t\t\t*idx+=1;\n\t\t\tint a= part(idx, deep + 1, true);\n\t\t\tif (plus)\n\t\t\t\tret += a;\n\t\t\telse\n\t\t\t\tret *= a;\n\t\t\tcontinue;\n\t\t}\n\t\tif (isdigit(siki[*idx][deep]))\n\t\t\tif(plus)\n\t\t\t\tret += siki[*idx][deep]-'0';\n\t\t\telse\n\t\t\t\tret *= siki[*idx][deep] - '0';\n\t\t*idx+=1;\n\t}\n\treturn ret;\n}\n\nint main() {\n\t\n\twhile (cin>>n,n) {\n\t\tsiki.resize(n);\n\t\tREP(i, n)\n\t\t\tcin >> siki[i];\n\t\tint idx=0;\n\t\tcout << part(&idx,0,false) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\nstruct CLASSNUM{\n  char op;\n  vector<int> num;\n};\n\nint main(){\n  int n,j;\n  string str;\n  CLASSNUM classNum[9];\n  while(true){\n    cin >> n;\n    if(n == 0) break;\n    for(int i = 0; i < n; i++){\n      cin >> str;\n\n      j = 0;\n      while(str[j] == '.'){\n        j++;\n      }\n\n      if(j!=0) str = str.substr(j,1);\n\n      if(str == \"+\") classNum[j+1].op = '+';\n      else if(str == \"*\")classNum[j+1].op = '*';\n      else{\n        classNum[j].num.push_back(atoi(str.c_str()));\n\n        if(classNum[j].num.size() == 2 && classNum[j].op == '+') {\n          classNum[j].num[0] = classNum[j].num[0] + classNum[j].num[1];\n          classNum[j].num.pop_back();\n        }\n        else if (classNum[j].num.size() == 2 && classNum[j].op == '*') {\n          classNum[j].num[0] = classNum[j].num[0] * classNum[j].num[1];\n          classNum[j].num.pop_back();\n        }\n      }\n    }\n    for(int i=8; i >= 1; i--){\n      if(classNum[i].num.size() == 0) continue;\n      else{\n        if(classNum[i-1].num.size() >= 1 && classNum[i-1].op == '+') {\n          classNum[i-1].num[0] = classNum[i].num[0] + classNum[i-1].num[0];\n        }\n        else if (classNum[i-1].num.size() >= 1 && classNum[i-1].op == '*'){\n          classNum[i-1].num[0] = classNum[i].num[0] * classNum[i-1].num[0];\n        }\n        else if(classNum[i-1].num.size() == 0 ){\n          classNum[i-1].num.push_back(classNum[i].num[0]);\n        }\n        else if (classNum[i-1].num.size()== 0) {\n          classNum[i-1].num.push_back(classNum[i].num[0]);\n        }\n      }\n    }\n    cout << classNum[0].num[0] << endl;\n    for(int i = 0; i < 8; i++) classNum[i].num.clear();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<char> nest;\nvector<int> dot;\nint idx;\n\nint solve(){\n  if('0' <= nest[idx] and nest[idx] <= '9') return nest[idx++] - '0';\n  int k = idx++, res = (nest[k] == '+' ? 0 : 1);\n  while(dot[idx] == dot[k] + 1){\n    if(nest[k] == '+') res += solve();\n    if(nest[k] == '*') res *= solve();\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    string str;\n    nest.clear();\n    dot.clear();\n    for(int i = 0; i < n; i++){\n      cin >> str;\n      dot.push_back(str.size());\n      nest.push_back(str[str.size() - 1]);\n    }\n    dot.push_back(0);\n    idx = 0;\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1e9\n#define ll long long\n#define ull unsigned long long\n#define M 1000000007\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define RFOR(i,m,n) for(int i=m;i>=n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n\n\nvoid f(int n){\n  vector<int> v[100];\n  vector<char> w[100];\n\n  rep(i,n){\n    string s;\n    cin>>s;\n    int c = s[s.size()-1];\n    if('0'<=c&&c<='9'){\n      v[s.size()-1].push_back(c-'0');\n    }\n    else{\n      w[s.size()].push_back(c);\n    }\n  }\n\n  RFOR(i,20,1){    \n    if(!v[i].size()) continue;\n    int s = v[i][0];\n    FOR(j,1,v[i].size()){\n      if(w[i][0]=='+') s+= v[i][j];\n      if(w[i][0]=='*') s*= v[i][j];\n    }\n    v[i-1].push_back(s);\n  }\n\n  cout<<v[0][0]<<endl;\n}\n\nint main(){\n  \n  while(1){\n    int n;\n    cin>>n;\n    if(n==0) break;\n    f(n);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint parse(int &index, int level, const vector<string> &expressions) {\n\tswitch(expressions[index][level]) {\n\tcase '+':\n\t{\n\t\tconst int next_level = level + 1;\n\t\tint res = 0;\n\t\t++index;\n\t\twhile(index < expressions.size() && next_level + 1 == expressions[index].size()) {\n\t\t\tres += parse(index, next_level, expressions);\n\t\t}\n\t\treturn res;\n\t}\n\tcase '*':\n\t{\n\t\tconst int next_level = level + 1;\n\t\tint res = 1;\n\t\t++index;\n\t\twhile(index < expressions.size() && next_level + 1 == expressions[index].size()) {\n\t\t\tres *= parse(index, next_level, expressions);\n\t\t}\n\t\treturn res;\n\t}\n\tcase '.':\n\t\tassert(false);\n\tdefault:\n\t\treturn expressions[index++][level] - '0';\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tvector<string> expressions(n);\n\t\tfor(auto &e : expressions) cin >> e;\n\n\t\tint index = 0;\n\t\tcout << parse(index, 0, expressions) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// #define TEST\n\nint isdigit(string s){\n    for (int i = 0; i < 10; ++i)\n        if (s[0] == i + '0')\n            return i;\n    return -1;\n}\n\nint ptr = 0; // next line\nint calc(vector<string>& q, int d = 0){\n    string op = q[ptr++].substr(d, 1);\n    int t = isdigit(op);\n    if (t >= 0) return t;\n    vector<int> tmp;\n    while (ptr < q.size() && q[ptr].size() > d && q[ptr].substr(d, 1) == \".\"){\n        string node = q[ptr].substr(d + 1, 1);\n        int res = isdigit(node);\n        if (res < 0)\n            res = calc(q, d + 1);\n        else ++ptr;\n        tmp.push_back(res);\n    }\n    int ans = 0;\n    if (op == \"+\"){\n        for (auto i : tmp)\n            ans += i;\n    }\n    else{\n        ans = 1;\n        for (auto i : tmp)\n            ans *= i;\n    }\n#ifdef TEST\n    cout << op << \" \";\n    for (auto i : tmp) cout << i << \" \";\n    cout << endl;\n#endif\n    return ans;\n} \n\nint main(){\n    int line; cin >> line;\n    while (line){\n        vector<string> q;\n        while (line--){\n            string s; cin >> s;\n            q.push_back(s);\n        }\n        ptr = 0;\n        cout << calc(q) << endl;\n        cin >> line;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n\nusing namespace std;\n\n\nint add(vector<string>::iterator &itr);\nint mlt(vector<string>::iterator &itr);\n\nint main(){\n    while(true){\n        int n; cin >> n;\n        if( n == 0)break;\n        vector<string> s(n);\n        for(int i = 0; i < n; i++){\n            cin >> s[i];\n        }\n        int ans = 0;\n        for(auto itr = s.begin(); itr != s.end(); ++itr){\n            if(itr->back() == '+'){\n                ans += add(itr);\n            }\n            else if(itr->back() == '*'){\n                ans += mlt(itr);\n            }\n            else{\n                ans += itr->back() - '0';\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\nint add(vector<string>::iterator &itr){\n    int c = itr->size()+1;\n    int ret = 0;\n    ++itr;\n    while(itr->size() == c){\n        if(itr->back() == '+'){\n            ret += add(itr);\n        }\n        else if(itr->back() == '*'){\n            ret += mlt(itr);\n        }\n        else{\n            ret += itr->back() -'0';\n        }\n        ++itr;\n    }\n        \n    --itr;\n    return ret;\n}\n\nint mlt(vector<string>::iterator &itr){\n    int c = itr->size();\n    int ret = 1;\n    ++itr;\n    while(itr->size() == c+1){\n        if(itr->back() == '+'){\n            ret *= add(itr);\n        }\n        else if(itr->back() == '*'){\n            ret *= mlt(itr);\n        }\n        else{\n            ret *= itr->back() - '0';\n        }\n        ++itr;\n    }\n    --itr;\n    return ret;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nint add(vector<string>::iterator &itr);\nint mlt(vector<string>::iterator &itr);\n\nint main(){\n    while(true){\n        int n; cin >> n;\n        if( n == 0)break;\n        vector<string> s(n);\n        for(int i = 0; i < n; i++){\n            cin >> s[i];\n        }\n        int ans = 0;\n        for(auto itr = s.begin(); itr != s.end(); ++itr){\n            if((itr->back()) == '+'){\n                ans += add(itr);\n            }\n            else if((itr->back()) == '*'){\n                ans += mlt(itr);\n            }\n            else{\n                ans += itr->back() - '0';\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\nint add(vector<string>::iterator &itr){\n    int c = itr->size()+1;\n    int ret = 0;\n    ++itr;\n    while((int)(itr->size()) == c){\n        if(itr->back() == '+'){\n            ret += add(itr);\n        }\n        else if((itr->back()) == '*'){\n            ret += mlt(itr);\n        }\n        else{\n            ret += itr->back() -'0';\n        }\n        ++itr;\n    }\n        \n    --itr;\n    return ret;\n}\n\nint mlt(vector<string>::iterator &itr){\n    int c = itr->size();\n    int ret = 1;\n    ++itr;\n    while((int)(itr->size()) == c+1){\n        if(itr->back() == '+'){\n            ret *= add(itr);\n        }\n        else if((char)(itr->back()) == '*'){\n            ret *= mlt(itr);\n        }\n        else{\n            ret *= itr->back() - '0';\n        }\n        ++itr;\n    }\n    --itr;\n    return ret;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define MAX_N 1000000\n#define PLUS 10\n#define MULTI 20\nusing namespace std;\n\nstring a[MAX_N];\nint b[MAX_N];\nint level[MAX_N];\n\nvoid revise(int first, int last, int n) {\n  int diff = last - first + 1;\n  for (int i = first; i + diff < n; i++) {\n    b[i] = b[i + diff];\n    level[i] = level[i + diff];\n  }\n}\n\nint calc(int first, int last) {\n  if (b[first - 1] == PLUS) {\n    int sum = 0;\n    for (int i = first; i <= last; i++)\n      sum += b[i];\n    return sum;\n  } else {\n    int multi = 1;\n    for (int i = first; i <= last; i++)\n      multi *= b[i];\n    return multi;\n  }\n}\n\nvoid make_b(int n) {\n  for (int i = 0; i < n; i++) {\n    int lev = level[i];\n    if (a[i][lev] == '+') b[i] = PLUS;\n    else if (a[i][lev] == '*') b[i] = MULTI;\n    else b[i] = a[i][lev] - '0';\n  }\n}\n\nvoid count_level(int n) {\n  for (int i = 0; i < n; i++) {\n    int count = 0;\n    for (int j = 0; ; j++) {\n      if (a[i][j] != '.') break;\n      count++;\n    }\n    level[i] = count;\n  }\n}\n\nvoid init(int n) {\n  for (int i = 0; i < n; i++) {\n    a[i] = \"\\0\";\n    b[i] = 0;\n    level[i] = 0;\n  }\n}\n\nint main() {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) return 0;\n    init(n);\n\n    for (int i = 0; i < n; i++)\n      cin >> a[i];\n\n    count_level(n);\n    \n    make_b(n);\n\n    int level_max = level[0];\n    for (int i = 1; i < n; i++)\n      if (level[i] > level_max) level_max = level[i];\n\n    while (level_max) {\n      for (int i = 0; i < n; i++) {\n\tint temp;\n\tif (level[i] == level_max) {\n\t  temp = i;\n\t  while (level[temp] == level_max && temp < n) {\n\t    temp++;\n\t  }\n\t  temp--;\n\t  int result = calc(i, temp);\n\t  b[i - 1] = result;\n\t  revise(i, temp, n);\n\t  n -= temp - i + 1;\n\t}\n      }\n      level_max--;\n    }\n    cout << b[0] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; i++ )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\nint calc(vector<string> s,int& i,int k){\n    if(isdigit(s[i][k])){\n        i++;\n        return s[i-1][k]-'0';\n    }\n    char op=s[i][k];\n    i++;\n    ll ret=calc(s,i,k+1);\n    while((int)s[i].size()>k+1){\n        ll res=calc(s,i,k+1);\n        if(op=='+')ret=ret+res;\n        if(op=='*')ret=ret*res;\n    }\n    return ret;\n}\n\nint main(){\n    int n;\n    while(cin>>n,n!=0){\n        vector<string> v;\n        rep(i,n){\n            string s;cin>>s;\n            v.push_back(s);\n        }\n        v.push_back(\"\");\n        int j=0;\n        cout<<calc(v,j,0)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring str[101];\nint n,idx=0;\n\nint cal(char ch,int a,int b){\n  if(ch=='*') return a*b;\n  return a+b;\n}\n\nint get_cnt(string a){\n  int res=0;\n  while(a[res]=='.')res++;\n  return res;\n}\n\nint dfs(){\n  int cnt=get_cnt(str[idx]);\n  char ch=str[idx][cnt];\n  if(isdigit(ch))return str[idx++][cnt]-'0';\n  int res =(ch=='*');\n  idx++,cnt++;\n  while(idx<n)\n    if(get_cnt(str[idx])>=cnt)res=cal(ch,res,dfs());\n    else break;\n  return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++) cin>>str[i];\n    idx=0;\n    cout <<dfs()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100\nusing namespace std;\nstring s[N];\nint n,y;\n \nint dfs(int x){\n  int res;\n  if('0'<=s[y][x]&&s[y][x]<='9')\n    return s[y][x]-'0';\n  if(s[y][x]=='+'){\n    res=0;\n    while(x+2<=s[y+1].size())\n      y++,res+=dfs(x+1);\n  }\n  if(s[y][x]=='*'){\n    res=1;\n    while(x+2<=s[y+1].size())\n      y++,res*=dfs(x+1);\n  }\n  return res;\n}\n \nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<N;i++)s[i]=\"\";\n    for(int i=0;i<n;i++)\n      cin>>s[i];\n    y=0;\n    cout<<dfs(0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define all(a) a.begin(),a.end()\n\nint solve(vector<string> &s,int n,int &y,int x){\n    if(isdigit(s[y][x])) return s[y++][x] - '0';\n    char op = s[y][x];\n    ++y, ++x;\n    vector<int> term;\n    while(y < n && x < (int)s[y].size()){\n        term.push_back(solve(s,n,y,x));\n    }\n    if(op == '+') return accumulate(all(term),0);\n    else return accumulate(all(term),1,multiplies<int>());\n}\n\nint main(void){\n    int n;\n    while(cin>>n,n){\n        vector<string> s(n);\n        rep(i,n) cin>>s[i];\n        int y = 0;\n        cout<<solve(s,n,y,0)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ntypedef std::vector<std::string> Data;\n\nint Multi(int,int,int,Data);\nint Add(int,int,int,Data);\n\nint Multi(int level,int pos,int n ,Data data){\n  std::vector<int> vec;\n  for(int i=pos;i<n;i++){\n    std::string tgt=data[i];\n    if(tgt[level]=='*'){\n      vec.push_back(Multi(level+1,i+1,n,data));\n    }else if(tgt[level]=='+'){\n      vec.push_back(Add(level+1,i+1,n,data));\n    }else{\n      int tgt_level=0;\n      for(int ti=0;ti<tgt.size();ti++){\n        if(tgt[ti]=='.'){\n          tgt_level++;\n        }else{\n          break;\n        }\n      }\n      if(tgt_level<level){\n        int result=1;\n        for(auto x:vec){\n          result*=x;\n        }\n        return result;\n      }else if(tgt_level==level){\n        vec.push_back(tgt[tgt_level]-'0');\n      }\n    }\n  }\n}\n\nint Add(int level,int pos,int n ,Data data){\n  std::vector<int> vec;\n  for(int i=pos;i<n;i++) {\n    std::string tgt = data[i];\n    if (tgt[level] == '*') {\n      vec.push_back(Multi(level + 1, i + 1, n, data));\n    } else if (tgt[level] == '+') {\n      vec.push_back(Add(level + 1, i + 1, n, data));\n    } else {\n      int      tgt_level = 0;\n      for (int ti        = 0; ti < tgt.size(); ti++) {\n        if (tgt[ti] == '.') {\n          tgt_level++;\n        } else {\n          break;\n        }\n      }\n      if (tgt_level < level) {\n        int       result = 0;\n        for (auto x:vec) {\n          result += x;\n        }\n        return result;\n      } else if (tgt_level == level) {\n        vec.push_back(tgt[tgt_level]-'0');\n      }\n    }\n  }\n}\n\nint main(void) {\n  cout << std::fixed << std::setprecision(10);\n  cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  while(1){\n    int n;\n    Data data;\n    cin>>n;\n    if(n==0){\n      break;\n    }else if(n==1){\n      int a;\n      cin>>a;\n      cout<<a<<endl;\n      continue;\n    }\n\n    for(int i=0;i<n;i++){\n      std::string s;\n      cin>>s;\n      data.push_back(s);\n    }\n    data.push_back(\"\");\n    n++;\n    if(data[0]==\"+\"){\n      cout<<Add(1,1,n,data)<<endl;\n    }else{\n      cout<<Multi(1,1,n,data)<<endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <cctype>\n#include <vector>\n#include <string>\n\nint nya(std::vector<std::string> const& s, size_t h, size_t w) {\n  if (isdigit(s[h].back())) return s[h].back()-'0';\n  if (s[h].back() == '+') {\n    int res = 0;\n    for (size_t i = h+1; i < s.size(); ++i) {\n      if (s[i].length() <= s[h].length()) break;\n      if (s[i][w+1] == '.') continue;\n      res += nya(s, i, w+1);\n    }\n    return res;\n  }\n  if (s[h].back() == '*') {\n    int res = 1;\n    for (size_t i = h+1; i < s.size(); ++i) {\n      if (s[i].length() <= s[h].length()) break;\n      if (s[i][w+1] == '.') continue;\n      res *= nya(s, i, w+1);\n    }\n    return res;\n  }\n  assert(false);\n}\n\nint testcase_ends() {\n  size_t n;\n  scanf(\"%zu\", &n);\n  if (n == 0) return 1;\n\n  std::vector<std::string> s(n);\n  for (auto& si: s) {\n    char buf[1024];\n    scanf(\"%s\", buf);\n    si = buf;\n  }\n\n  printf(\"%d\\n\", nya(s, 0, 0));\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cassert>\n#include<string>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n// vector\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) {\n    for(const T &t : v) os << \"\\t\" << t; return os << endl;\n}\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) {\n    for(T &a : v) is >> a; return is;\n}\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) {\n    return os << \"<\" << v.first << \" \" << v.second << \">\";\n}\n\nint calc_depth(string &s) {\n    rep(i, s.size()) if(s[i] != '.') return i;\n    assert(0);\n}\n\nint calc(vector<string> &line, int &now, int depth) {\n    char c = line[now].back();\n    if(isdigit(c)) {\n        now++;\n        return c - '0';\n    } else {\n        function<int(int, int)> f;\n        int ret;\n        if(c == '+') {\n            f = [](int a, int b) { return a + b; };\n            ret = 0;\n        } else if(c == '*') {\n            f = [](int a, int b) { return a * b; };\n            ret = 1;\n        } else assert(0);\n        now++;\n        \n        while(now < line.size() and calc_depth(line[now]) > depth) {\n            ret = f(ret, calc(line, now, depth + 1));\n        }\n        return ret;\n    }\n}\n\n\nbool solve() {\n    int n; cin >> n;\n    if(n == 0) return 0;\n    vector<string> line(n); cin >> line;\n    int i = 0;\n    cout << calc(line, i, 0) << endl;\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nstring S[100];\n\nint rec(int& idx, int depth)\n{\n  if(isdigit(S[idx][depth])) {\n    return(S[idx++][depth] - '0');\n  } else if(S[idx++][depth] == '+') {\n    int ret = 0;\n    while(S[idx].size() > depth + 1) ret += rec(idx, depth + 1);\n    return(ret);\n  } else {\n    int ret = 1;\n    while(S[idx].size() > depth + 1) ret *= rec(idx, depth + 1);\n    return(ret);\n  }\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    for(int i = 0; i < N; i++) cin >> S[i];\n    int idx = 0;\n    cout << rec(idx, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\nusing ll = long long;\nusing ld =long double;\n//#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define mp make_pair\nint cs(string s){int a=0;rep(i,s.size())if(s[i]=='.')a++;return a;}\nsigned main(){\n    int n;\n    while(cin>>n,n){\n        using pci =  pair<int,char>;\n        vector<pci>v;\n        rep(i,n){\n            string s; cin>>s;\n            int val=cs(s);\n            v.push_back(mp(val,s.back()));\n        }\n        map<int,char>opt;\n        sort(all(v));\n        vector<pci>rec;\n        rep(i,v.size())\n        if('0'>v[i].second||'9'<v[i].second)opt[v[i].first+1]=v[i].second;\n        else rec.push_back(v[i]);\n        int cal=0;\n        sort(all(rec),greater<pci>());\n        int now=0;\n        int temp=0;\n        rep(i,rec.size()){\n            if(now!=rec[i].first || i==0){\n                now=rec[i].first;\n                if(opt[rec[i].first]=='*'&&temp)temp*=rec[i].second-'0';\n                else temp+=rec[i].second-'0';\n            }else{\n                int rank=rec[i].first;\n                if(opt[rank]=='*')temp*=rec[i].second-'0';\n                if(opt[rank]=='+')temp+=rec[i].second-'0';\n            }\n        }\n        cout<<temp<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<math.h>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<set>\n#include<map>\n#define INF 999999\n#define EPS 1.0e-6\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nint n;\n\n//-1:+ -2:*\n\nint main()\n{\n\twhile (cin >> n) {\n\n\t\tif (n == 0)return 0;\n\n\t\tvector<int>v[15];\n\t\tint en[15];\n\t\tfor (int i = 0; i < 15; i++) {\n\t\t\ten[i] = 0;\n\t\t}\n\n\n\t\tstring a;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> a;\n\n\t\t\tint l = a.length() - 1;\n\t\t\tif (a[l] == '+') {\n\t\t\t\tif (!v[l + 1].empty()) {\n\t\t\t\t\tfor (int i = 14; i >= l+1; i--) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tfor (int j = 0; j < 15; j++) {\n\t\t\t\t\t\t\tfor (int k = 0; k < v[j].size(); k++) {\n\t\t\t\t\t\t\t\tcout << v[j][k] << \" \";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcout << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcout << endl;\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\tif (!v[i].empty()) {\n\t\t\t\t\t\t\tif (en[i - 1] == -1) {\n\t\t\t\t\t\t\t\tint num = 0;\n\t\t\t\t\t\t\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\t\t\t\t\t\t\tnum += v[i][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tv[i - 1].push_back(num);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tint num = 1;\n\t\t\t\t\t\t\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\t\t\t\t\t\t\tnum *= v[i][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tv[i - 1].push_back(num);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv[i].erase(v[i].begin(), v[i].end());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ten[l] = -1;\n\t\t\t}\n\t\t\telse if (a[l] == '*') {\n\t\t\t\tif (!v[l + 1].empty()) {\n\t\t\t\t\tfor (int i = 14; i >= l + 1; i--) {\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\tfor (int j = 0; j < 15; j++) {\n\t\t\t\t\t\t\tfor (int k = 0; k < v[j].size(); k++) {\n\t\t\t\t\t\t\t\tcout << v[j][k] << \" \";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcout << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcout << endl;\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\tif (!v[i].empty()) {\n\t\t\t\t\t\t\tif (en[i - 1] == -1) {\n\t\t\t\t\t\t\t\tint num = 0;\n\t\t\t\t\t\t\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\t\t\t\t\t\t\tnum += v[i][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tv[i - 1].push_back(num);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tint num = 1;\n\t\t\t\t\t\t\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\t\t\t\t\t\t\tnum *= v[i][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tv[i - 1].push_back(num);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv[i].erase(v[i].begin(), v[i].end());\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ten[l] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv[l].push_back((int)(a[l] - '0'));\n\t\t\t}\n\n\t\t}\n\n\t\tfor (int i = 14; i >= 1; i--) {\n\t\t\t/*\n\t\t\tfor (int j = 0; j < 15; j++) {\n\t\t\t\tfor (int k = 0; k < v[j].size(); k++) {\n\t\t\t\t\tcout << v[j][k] << \" \";\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t*/\n\t\t\t\n\t\t\t\n\t\t\tif (!v[i].empty()) {\n\t\t\t\t/*\n\t\t\t\tint j = 0;\n\t\t\t\twhile(j < v[i].size()) {\n\t\t\t\t\tif (v[i][j] == -1) {\n\t\t\t\t\t\tint num = 0;\n\t\t\t\t\t\tint k = j + 1;\n\t\t\t\t\t\twhile (k<v[i].size()) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tcout << \"a\" << endl;\n\t\t\t\t\t\t\tif (v[i][k] < 0)break;\n\t\t\t\t\t\t\tnum += v[i][k];\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv[i - 1].push_back(num);\n\t\t\t\t\t\tj = k;\n\t\t\t\t\t}\n\t\t\t\t\tif (v[i][j] == -2) {\n\t\t\t\t\t\tint num = 1;\n\t\t\t\t\t\tint k = j + 1;\n\t\t\t\t\t\twhile (k<v[i].size()) {\n\t\t\t\t\t\t\tcout << \"b\" << endl;\n\t\t\t\t\t\t\tif (v[i][k] < 0)break;\n\t\t\t\t\t\t\tnum *= v[i][k];\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv[i - 1].push_back(num);\n\t\t\t\t\t\tj = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*/\n\n\t\t\t\t\n\t\t\t\tif (en[i - 1] == -1) {\n\t\t\t\t\tint num = 0;\n\t\t\t\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\t\t\t\tnum += v[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tv[i - 1].push_back(num);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint num = 1;\n\t\t\t\t\tfor (int j = 0; j < v[i].size(); j++) {\n\t\t\t\t\t\tnum *= v[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tv[i - 1].push_back(num);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tcout << v[0][0] << endl;\n\t}\n\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(int i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<int,int> Pi;\nconst int INF=(ll)(1LL<<31)-1;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\n//int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\n\n\nint n;\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tPi tt[11];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring t;\n\t\t\tcin>>t;\n\t\t\tint se=t.size()-1;\n\t\t\tint l;\n\t\t\tif(t[se]=='+'){\n\t\t\t\tl=11;\n\t\t\t}else if(t[se]=='*'){\n\t\t\t\tl=12;\n\t\t\t}else{\n\t\t\t\tl=t[se]-'0';\n\t\t\t}\n\t\t\ttt[i]=Pi(se,l);\n\t\t}\n\t\tstack<Pi> ss;\n\t\tfor(int i=n-1;i>=0;i--){\n\t\t\tif(tt[i].second!=11&&tt[i].second!=12){\n\t\t\t\tss.push(tt[i]);\n\t\t\t}else if(tt[i].second==11){\n\t\t\t\tint q=0;\n\t\t\t\twhile(ss.size()&&ss.top().first==tt[i].first+1){\n\t\t\t\t\tq+=ss.top().second;\n\t\t\t\t\tss.pop();\n\t\t\t\t}\n\t\t\t\tss.push(Pi(tt[i].first,q));\n\t\t\t}else{\n\t\t\t\tint q=1;\n\t\t\t\twhile(ss.size()&&ss.top().first==tt[i].first+1){\n\t\t\t\t\tq*=ss.top().second;\n\t\t\t\t\tss.pop();\n\t\t\t\t}\n\t\t\t\tss.push(Pi(tt[i].first,q));\n\t\t\t}\n\t\t}\n\t\tcout<<ss.top().second<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring str[101];\nint n,idx=0;\n\nint cal(char ch,int a,int b){\n  if(ch=='*') return a*b;\n  return a+b;\n}\n\nint get_cnt(string a){\n  int res=0;\n  while(a[res]=='.')res++;\n  return res;\n}\n\nint dfs(){\n  int cnt=get_cnt(str[idx]);\n  char ch=str[idx][cnt];\n  if(isdigit(ch))return str[idx++][cnt]-'0';\n  int res =(ch=='*');\n  idx++,cnt++;\n  while(idx<n)\n    if(get_cnt(str[idx])>=cnt)res=cal(ch,res,dfs());\n    else return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++) cin>>str[i];\n    idx=0;\n    cout <<dfs()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n\nint n;\nvs s;\nint solve(int p){\n    char c=s[p].back();\n    if(\"+*\"s.find(c)!=string::npos){\n        vi a;\n        for(int i=p+1;i<n && s[i].length()>s[p].length();i++){\n            if(s[i].length()==s[p].length()+1)\n                a.pb(solve(i));\n        }\n        if(c=='+'){\n            return accumulate(all(a),0);\n        }else{\n            return accumulate(all(a),1,[](int _,int __){return _*__;});\n        }\n    }else{\n        return (int)(c-'0');\n    }\n}\n\n\nint main(){\n\twhile(cin>>n,n){\n\t    s.clear();\n\t    s.resize(n);\n\t\trep(i,n)cin>>s[i];\n\t\tcout<<solve(0)<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e18\n#define int long long\n#define Rep(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) Rep(i, 0, n)\n#define all(a) (a).begin(), (a).end()\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int mod = 1000000007;\n//const int mod = 998244353;\n\nint n;\nstring s[100];\n\nint f(string num)\n{\n    int res = 0;\n    rep(i, num.size())\n    {\n        if (num[i] == '.')\n            continue;\n        res = 10 * res + (num[i] - '0');\n    }\n    return res;\n}\n//op : 0 -> +, 1 -> *\nint cal(int pos, int depth, int op)\n{\n    int res = 0;\n    if (op == 1)\n        res = 1;\n    for (int i = pos; i < n && depth < s[i].size(); i++)\n    {\n        if (s[i][depth] == '.')\n            continue;\n        int num = f(s[i]);\n        if (s[i][depth] == '+')\n            num = cal(i + 1, depth + 1, 0);\n        else if (s[i][depth] == '*')\n            num = cal(i + 1, depth + 1, 1);\n        if (op == 0)\n            res += num;\n        else\n            res *= num;\n    }\n    return res;\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while (1)\n    {\n        cin >> n;\n        if (n == 0)\n            break;\n        rep(i, n) cin >> s[i];\n        cout << cal(0, 0, 0) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nll n;\n\nll dfs(ll line,ll level,vector<string> form){\n  if(form[line][level]>='0'&&form[line][level]<='9')return (ll)(form[line][level]-'0');\n  char op=form[line][level];\n  ll res=(op=='*'?1:0);\n  repl(i,line+1,n){\n    if(form[i][level]!='.')break;\n    if(form[i][level+1]=='.')continue;\n    ll tmp=dfs(i,level+1,form);\n    res=(op=='*'?res*tmp:res+tmp);\n  }\n  return res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vector<string> form;\n    rep(i,n){\n      string s;\n      cin>>s;\n      form.pb(s);\n    }\n    cout<<dfs(0,0,form)<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(idx,a,b) for(int idx=(a);idx<(b);idx++)\n#define rrep(idx,a,b) for(int idx=(b)-1;idx>=(a);idx--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\n\nvector<string> v;\nint idx = 0;\nint solve() {\n\tchar b = v[idx].back();\n\tif (b == '+') {\n\t\tint ret = 0;\n\t\tint i = idx;\n\t\tidx++;\n\t\twhile (v[i].size() < v[idx].size()) {\n\t\t\tret += solve();\n\t\t\tidx++;\n\t\t}\n\t\tidx--;\n\t\treturn ret;\n\t}\n\telse if (b == '*') {\n\t\tint ret = 1;\n\t\tint i = idx;\n\t\tidx++;\n\t\twhile (v[i].size() < v[idx].size()) {\n\t\t\tret *= solve();\n\t\t\tidx++;\n\t\t}\n\t\tidx--;\n\t\treturn ret;\n\t}\n\telse {\n\t\treturn b - '0';\n\t}\n}\n\nsigned main() {\n\tfor (int n; cin >> n&&n;) {\n\t\tidx = 0;\n\t\tv = vector<string>();\n\t\trep(i, 0, n) {\n\t\t\tstring s; cin >> s;\n\t\t\tv.emplace_back(s);\n\t\t}\n\t\tv.emplace_back(\"0\");\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int,int>;\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        int depth = 0;\n        stack<P> num;\n        stack<char> op;\n        bool fst = true;\n        string s;\n        for(int i=0;i<n;i++){\n            cin >> s;\n            while(depth >= s.size()){\n                P tmp = num.top();\n                num.pop();\n                while(!num.empty() && num.top().second == tmp.second){\n                    if(op.top() == '+'){\n                        tmp.first += num.top().first;\n                    }else{\n                        tmp.first *= num.top().first;\n                    }\n                    num.pop();\n                }\n                tmp.second--;\n                num.push(tmp);\n                depth--;\n                op.pop();\n            }\n            if(isdigit(s[depth])){\n                int x = s[depth]-'0';\n                if(fst){\n                    num.push(P(x,depth));\n                    fst = false;\n                }else{\n                    if(op.top() == '+'){\n                        num.top().first += x;\n                    }else{\n                        num.top().first *= x;\n                    }\n                }\n            }else{\n                op.push(s[depth]);\n                depth++;\n                fst = true;\n            }\n        }\n        while(depth >= 0){\n            P tmp = num.top();\n            num.pop();\n            while(!num.empty() && num.top().second == tmp.second){\n                if(op.top() == '+'){\n                    tmp.first += num.top().first;\n                }else{\n                    tmp.first *= num.top().first;\n                }\n                num.pop();\n            }\n            tmp.second--;\n            num.push(tmp);\n            depth--;\n            op.pop();\n        }\n        cout << num.top().first << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\n#define REP(i, n) for (int i = 0; i < (n); i ++)\n\nusing namespace std;\n\ntuple<int, char> parsel(string s) {\n    return make_tuple(s.size() - 1, s.back());\n}\nint c = 0;\nint solve(int level,  const vector<tuple<int, char>>& code) {\n    int l; char op; tie(l, op) = code[c]; c+=1;\n    assert(level == l);\n    if(isdigit(op)) {\n        int num = op - '0';\n        return num;\n    }\n    assert(op == '+' || op == '*');\n    vector<int> vs;\n    while (c < code.size() && get<0>(code[c]) > level){\n        vs.push_back(solve(level + 1, code));\n    }\n    if (op == '+') {\n        int res = 0;\n        REP(i, vs.size()) res += vs[i];\n        return res;\n    }else{\n        int res = 1;\n        REP(i, vs.size()) res *= vs[i];\n        return res;\n    }\n}\nint main() {\n    while(true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<tuple<int, char>> code(n);\n        REP(i, n) {\n            string k; cin >> k;\n            code[i] = parsel(k);\n        }\n        c = 0;\n        cout << solve(0, code) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint depth[1000], num[1000], T[1000], n; string S[1000];\nint main() {\n    while (true) {\n        cin >> n; if (n == 0)break;\n        for (int i = 0; i < 999; i++) num[i] = 0;\n        for (int i = 0; i < n; i++) {\n            cin >> S[i]; depth[i] = S[i].size() - 1;\n            char F = S[i][S[i].size() - 1];\n            if (F == '+') { T[i] = 1; }\n            else if (F == '*') { T[i] = 2; }\n            else { num[i] = F - '0'; T[i] = 0; }\n        }\n        for (int i = 9; i >= 0; i--) {\n            int J = -1, sum = 1;\n            for (int j = 0; j < n; j++) {\n                if (depth[j] == i) {\n                    if (J != -1) {\n                        if (T[J] >= 1)num[J] = sum;\n                    }\n                    if (T[j] == 1) { sum = 0; J = j; }\n                    if (T[j] == 2) { sum = 1; J = j; }\n                }\n                if (depth[j] == i + 1) {\n                    if (T[J] == 1)sum += num[j];\n                    if (T[J] == 2)sum *= num[j];\n                }\n            }\n            if (J >= 0) { num[J] = sum; }\n        }\n        cout << num[0] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nvector<pair<int, string>> data;\nsigned main(void)\n{\n\twhile(1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tdata.erase(ALL(data));\n\t\tREP(i, n) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tstring t{s[s.size()-1]};\n\t\t\tdata.PB({s.size()-1, t});\n\t\t}\n\t\t//for(auto i: data) {cout << i.first << \" \" << i.second << endl;}\n\t\t//cout << endl;\n\t\twhile(data.size() > 1) {\n\t\t\t//cout << \"size:\" << data.size() << endl;\n\t\t\tint ma = -1, idx = 0;\n\t\t\tREP(i, data.size()) {\n\t\t\t\tif(ma <= data[i].first) {idx = i; ma = data[i].first;}\n\t\t\t}\n\t\t\t//cout << idx << \" \" << ma << endl;\n\t\t\tint b = idx;\n\t\t\tVI a;\n\t\t\twhile(data[idx].first == ma) {a.PB(stoi(data[idx].second)); idx--;}\n\t\t\t//cout << idx << \" \" << data[idx].second << endl;\n\n\t\t\tint tmp;\n\t\t\tif(data[idx].second == \"+\") tmp = 0;\n\t\t\telse tmp = 1;\n\t\t\tfor(int i: a) {\n\t\t\t\tif(data[idx].second == \"+\") tmp += i;\n\t\t\t\telse tmp *= i;\n\t\t\t}\n\t\t\t//cout << tmp << endl;\n\t\t\tdata[idx].second = to_string(tmp);\n\t\t\t//for(auto i: data) {cout << i.first << \" \" << i.second << endl;}\n\t\t\t//cout << endl;\n\t\t\tdata.erase(data.begin()+idx+1, data.begin()+b+1);\n\t\t\t//for(auto i: data) {cout << i.first << \" \" << i.second << endl;}\n\t\t\t//cout << endl;\n\t\t}\n\t\tcout << data[0].second << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///\n// File:  1602.cpp\n// Author: ymiyamoto\n//\n// Created on Wed Dec 20 00:50:10 2017\n//\n\n#include <cstdint>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstring calc(vector<string> values, string op)\n{\n  uint32_t val;\n  if (op == \"+\") {\n    val = 0;\n  } else {\n    val = 1;\n  }\n\n  for (auto s : values) {\n    int32_t i = stoi(s);\n    if (op == \"+\") {\n      val += i;\n    } else {\n      val *= i;\n    }\n  }\n\n  return to_string(val);\n}\n\nvoid conv(stack<pair<uint32_t, string>> &s, uint32_t depth)\n{\n  while (s.top().first > depth) {\n    vector<string> values;\n    uint32_t d = s.top().first;\n    while (true) {\n      pair<uint32_t, string> t = s.top();\n      s.pop();\n      if (t.first < d) {\n        s.push({t.first, calc(values, t.second)});\n        break;\n      } else {\n        values.push_back(t.second);\n      }\n    }\n  }\n}\n\nint32_t main()\n{\n  while (true) {\n    int32_t n;\n    cin >> n;\n    if (n == 0) break;\n\n    stack<pair<uint32_t, string>> s;\n    uint32_t depth = 0;\n    for (int32_t i = 0; i < n; i++) {\n      string str;\n      cin >> str;\n      uint32_t d = str.size() - 1;\n\n      if (depth > d) {\n        conv(s, d);\n      }\n      s.push({d, string{str[str.size() - 1]}});\n      depth = d;\n    }\n    conv(s, 0);\n\n    cout << s.top().second << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\n// o=0: add, o=1: mul\nint f(const vector<string> &str, int i=0, int d=0, int o=0){\n  vector<int> cand;\n  for(int j=i; j<str.size(); j++){\n    const string &s=str[j];\n    int k=0;\n    while(s[k]=='.') k++;\n    if(k==d) cand.push_back(j);\n    else if(k<d) break;\n  }\n  int ret=o;\n  for(int j: cand){\n    const char ch=str[j][d];\n    if(o==0){\n      if(ch=='+') ret+=f(str, j+1, d+1, 0);\n      else if(ch=='*') ret+=f(str, j+1, d+1, 1);\n      else ret+=(ch-'0');\n    }else{\n      if(ch=='+') ret*=f(str, j+1, d+1, 0);\n      else if(ch=='*') ret*=f(str, j+1, d+1, 1);\n      else ret*=(ch-'0');\n    }\n  }\n  return ret;\n}\n\nint main(){\n\n  while(true){\n    int n; cin>> n;\n    if(n==0) break;\n    vector<string> str(n);\n    rep(i, n) cin>> str[i];\n    cout<< f(str)<< endl;\n  }\n\n  return 0;\n}\n\n/*\n\n  *\n  .+\n  ..2\n  ..3\n  .4\n  .+\n  ..5\n  ..6\n\n  (2+3)*4+(5+6)\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\nusing namespace std;\nint main(int argc, char *argv[])\n{\n  for(;;) {\n    int n;\n    cin >> n;\n    if(n==0) break;\n    vector<char> ops;\n    vector<int> vs;\n    ops.push_back('+');\n    vs.push_back(0);\n    for(int i = 0; i < n; i++) {\n      string s;\n      cin >> s;\n      // cout << \"read: \" << s << endl;\n      while(s.size() < ops.size()) {\n        int v = vs.back();\n        vs.pop_back();\n        ops.pop_back();\n        switch(ops.back()) {\n        case '+': { (vs.back()) += v; break; }\n        case '*': { (vs.back()) *= v; break; }\n        default : { throw string(\"Something Wrong in while!\"); }\n        }\n      }\n      char c = s[ops.size()-1];\n      // cout << \"c = \" << c << endl;\n      switch(c){\n      case '.' : { throw string(\"Something Wrong!\"); }\n      case '+' : {\n        ops.push_back('+');\n        vs.push_back(0);\n        break;\n      }\n      case '*' : {\n        ops.push_back('*');\n        vs.push_back(1);\n        break;\n      }\n      default : { // '0'--'9'\n        switch(ops.back()) {\n        case '+': { (vs.back()) += c - '0'; break; }\n        case '*': { (vs.back()) *= c - '0'; break; }\n        default : { throw string(\"Something Wrong in default!\"); }\n        }\n      }\n      }\n    }\n    while(1 < ops.size()) {\n      int v = vs.back();\n      vs.pop_back();\n      ops.pop_back();\n      switch(ops.back()) {\n      case '+': { (vs.back()) += v; break; }\n      case '*': { (vs.back()) *= v; break; }\n      default : { throw string(\"Something Wrong in while!\"); }\n      }\n    }\n    cout << vs[0] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\nconst ll MOD = 1e9+7;\nint n;\nstring s[111111];\n\nint dfs(int i=0,int j=0){\n  if('0'<=s[i][j]&&s[i][j]<='9')return s[i][j]-'0';\n  int res=(s[i][j]=='+'?0:1);\n  for(int k=i+1;k<n;k++){\n    if(j+1>=s[k].size())break;\n    if(s[k][j+1]=='.')continue;\n    if(s[i][j]=='+')res+=dfs(k,j+1);\n    if(s[i][j]=='*')res*=dfs(k,j+1);\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>s[i];\n    cout<<dfs()<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<complex>\n#include<stack>\n#define INF 2147483647\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int n;\n  while(cin>>n,n){\n    vector<string>vs(n);\n    for(int i=0;i<n;i++)cin>>vs[i];\n    vector<pair<int,int> >sp;\n    vector<pair<int,char> >sta;\n    if(n==1){\n      cout<<vs[0]<<endl;\n    }else{\n      for(int i=0;i<n;i++){\n\tstring str=vs[i];\n\tif(!sta.empty()&&(str.size()!=(sta[sta.size()-1].F+1))){\n\t  if(sta[sta.size()-1].S=='+'){\n\t    int sum=0;\n\t    while(sp[sp.size()-1].S==sta[sta.size()-1].F+1){\n\t      int num=sp[sp.size()-1].F;\n\t      sp.pop_back();\n\t      sum+=num;\n\t    }\n\t    //cout<<sum<<endl;\n\t    sp.pb(mp(sum,sta[sta.size()-1].F));\n\t    sta.pop_back();\n\t  }else if(sta[sta.size()-1].S=='*'){\n\t    int sum=1;\n\t    while(sp[sp.size()-1].S==sta[sta.size()-1].F+1){\n\t      int num=sp[sp.size()-1].F;\n\t      sp.pop_back();\n\t      sum*=num;\n\t    }\n\t    //cout<<sum<<endl;\n\t    sp.pb(mp(sum,sta[sta.size()-1].F));\n\t    sta.pop_back();\n\t  }\n\t  i--;\n\t}else if(str[str.size()-1]=='+'){\n\t  sta.pb(mp(str.size(),'+'));\n\t}else if(str[str.size()-1]=='*'){\n\t  sta.pb(mp(str.size(),'*'));\n\t}else{\n\t  if((sta.empty())||(str.size()==(sta[sta.size()-1].F+1))){\n\t    char ccc=str[str.size()-1];\n\t    int nnn=ccc-'0';\n\t    sp.pb(mp(nnn,str.size()));\n\t  }\n\t}\n      }\n      while(sta.size()!=1){\n\tif(sta[sta.size()-1].S=='+'){\n\t  int sum=0;\n\t  while(sp[sp.size()-1].S==sta[sta.size()-1].F+1){\n\t    int num=sp[sp.size()-1].F;\n\t    sp.pop_back();\n\t    sum+=num;\n\t  }\n\t  sp.pb(mp(sum,sta[sta.size()-1].F));\n\t  sta.pop_back();\n\t}else if(sta[sta.size()-1].S=='*'){\n\t  int sum=1;\n\t  while(sp[sp.size()-1].S==sta[sta.size()-1].F+1){\n\t    int num=sp[sp.size()-1].F;\n\t    sp.pop_back();\n\t    sum*=num;\n\t  }\n\t  sp.pb(mp(sum,sta[sta.size()-1].F));\n\t  sta.pop_back();\n\t}\n      }\n      int ans=0;\n      if(sta[0].S=='+'){\n\tfor(int i=0;i<sp.size();i++){\n\t  ans+=sp[i].F;\n\t  //cout<<sp[i].F<<endl;\n\t}\n      }else{\n\tans=1;\n\tfor(int i=0;i<sp.size();i++){\n\t  ans*=sp[i].F;\n\t//cout<<sp[i].F<<endl;\n\t}\n      }\n      //cout<<sta.size()<<\" \"<<sp.size()<<endl;\n      cout<<ans<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define EPS (1e-7)\n#define INF (1e9)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\nconst double PI = acos(-1);\nconst ll MOD = 1000000007;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n \ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n///////////////////////////////////////////////////////////////\n\nvector<string> S;\n\nint N,k;\n\nint dfs (char op,int w) {\n    int y;\n    if (op == '+') {\n        y = 0;\n        while (k < N && S[k].size() == w+1) {\n            if (S[k][w] == '+' || S[k][w] == '*') {\n                y += dfs(S[k++][w],w+1);\n            } else {\n                y += S[k][w] - '0';\n                k++;\n            }\n        }\n    } else {\n        y = 1;\n        while (k < N && S[k].size() == w+1) {\n            if (S[k][w] == '+' || S[k][w] == '*') {\n                y *= dfs(S[k++][w],w+1);\n            } else {\n                y *= S[k][w] - '0';\n                k++;\n            }\n        }\n    }\n    return y;\n}\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n        S.resize(N);\n        rep(i,N) cin >> S[i];\n        k = 0;\n        cout << dfs('+',0) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint n,num;\nvector<string> s;\n\nint solve(int c, int a, int b)\n{\n    if(c == 0){\n        return a+b;\n    }else{\n        return a*b;\n    }\n}\n\nint dfs(int d,int id)\n{\n    int res = id;\n    while(num < n){\n        if(isdigit(s[num].back())){\n            if((int)s[num].size()-1 < d){\n                return res;\n            }\n            res = solve(id,res,(s[num].back()-'0'));\n            num++;\n        }else{\n            int flag = (s[num].back()=='*');\n            num++;\n            int ans = dfs(d+1,flag);\n            res = solve(id,res,ans);\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    while(1){\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        s.resize(n);\n        rep(i,n){\n            cin >> s[i];\n        }\n        num = 0;\n        cout << dfs(0,0) << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nint main()\n{\n  int n;\n  string s;\n  char c[40][40];\n  ll num[40][40];\n \n  while(1){\n    cin>>n;\n    if(n==0)break;\n \n    for(int i=0;i<40;i++){\n      for(int j=0;j<40;j++){\n    c[i][j]='.';\n    num[i][j]=-1;\n      }\n    }\n    for(int i=0;i<n;i++){\n      cin>>s;\n      for(int j=0;j<s.length();j++){\n    c[i][j]=s[j];\n    if('0'<=s[j] && s[j]<='9')num[i][j]=s[j]-'0';\n      }\n    }\n      vector<int> v;\n    for(int j=39;j>=1;j--){\n      for(int i=n-1;i>=1;i--){\n    if(num[i][j]!=-1)v.push_back(num[i][j]);\n    if(c[i-1][j-1]=='+'){\n      ll sum=0;\n      for(int k=0;k<v.size();k++)sum+=v[k];\n      num[i-1][j-1]=sum;\n      v.clear();\n    }\n    if(c[i-1][j-1]=='*'){\n      ll sum=1;\n      for(int k=0;k<v.size();k++)sum*=v[k];\n      num[i-1][j-1]=sum;\n      v.clear();\n    }\n      }\n    }\n    cout<<num[0][0]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int n;\n\n    while(1) {\n        cin >> n;\n        if(n == 0) break;\n\n        string str[n];\n        vector<vector<int>> vec(10);\n\n        for(int i = 0; i < n; i++) {\n            cin >> str[i];\n        }\n\n        if(n == 1) {\n            cout << str[0] << endl;\n            continue;\n        }\n\n        for(int i = n-1; i >= 0; i--) {\n            int l = str[i].length()-1;\n            if(str[i][l] == '+' || str[i][l] == '*') {\n                int tmp;\n                if(str[i][l] == '+') {\n                    tmp = 0;\n                    for(int j = 0; j < vec[l+1].size(); j++) {\n                        tmp += vec[l+1][j];\n                    }\n                }\n                else if(str[i][l] == '*') {\n                    tmp = 1;\n                    for(int j = 0; j < vec[l+1].size(); j++) {\n                        tmp *= vec[l+1][j];\n                    }\n                }\n                vec[l].push_back(tmp);\n                vec[l+1].clear();\n            }\n            //数字の時\n            else {\n                vec[l].push_back((int)(str[i][l]-'0'));\n            }        \n        }\n        cout << vec[0][0] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\nvector<string> s;\n\nll dfs(int x,int y) {\n  if( '0' <= s[y][x] && s[y][x] <= '9' ) {\n    return (ll)(s[y][x]-'0');\n  }\n  assert( s[y][x] == '*' || s[y][x] == '+' );\n  char op = s[y][x];\n  ll ret = ( (op=='*') ? 1 : 0 );\n  ++y, ++x;\n  while( y < n && x < (int)s[y].size() ) {\n    if( '0' <= s[y][x] && s[y][x] <= '9' ) {\n      if( op == '*' ) ret *= (ll)(s[y][x]-'0');\n      else            ret += (ll)(s[y][x]-'0');\n      ++y;\n    } else {\n      if( op == '*' ) ret *= dfs(x,y);\n      else            ret += dfs(x,y);\n      ++y;\n      while( y < n && x < (int)s[y].size() && s[y][x] == '.' ) ++y;\n    }\n  }\n  return ret;\n}\n\nint main() {\n  while( cin >> n,n ) {\n    s.clear();\n    s.resize(n);\n    rep(i,n) cin >> s[i];\n    cout << dfs(0,0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<S<<endl\n#define ck(n,a,b) (a<=(n)&&(n)<=b)\n#define F first\n#define S second\nusing namespace std;\nint opCalc(char op,int left,int right){\n\tint ret;\n\tif(op=='+'){\n\t\tret=left+right;\n\t}else if(op=='*'){\n\t\tret=left*right;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tstring s[20];\n\t\tvector<pair<int,char>> vt;\n\t\tint ans=0;\n\t\tREP(i,0,n){\n\t\t\tcin>>s[i];\n\t\t\tREP(j,0,(int)s[i].size()){\n\t\t\t\tif(s[i][j]=='.') continue;\n\t\t\t\tvt.push_back({j,s[i][j]});\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(n>1){\n\t\t\tfor(int i=vt.size()-3;i>=0;i--){\n\t\t\t\tif(vt[i].S=='+'||vt[i].S=='*'){\n\t\t\t\t\tfor(int j=i+1;vt[i].F+1==vt[j].F&&j<(int)vt.size();){\n\t\t\t\t\t\tif(!ans) {\n\t\t\t\t\t\t\tans=opCalc(vt[i].S,vt[j].S-'0',vt[j+1].S-'0');\n\t\t\t\t\t\t\tvt.erase(vt.begin()+j+1);\n\t\t\t\t\t\t}else\tans=opCalc(vt[i].S,vt[j].S-'0',ans);\n\t\t\t\t\t\tvt.erase(vt.begin()+j);\n\t\t\t\t\t}\n\t\t\t\t\tvt.erase(vt.begin()+i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse ans=vt[0].S-'0';\n\n\t\tp(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\n\tstd::string* in;\n\tint nline;\n\tint idx;\n\nint calc(int lv = 0, char kind = '+') {\n\tint ret = 0;\n\tif(kind == '*') ret = 1;\n\n\twhile(true){\n\t//\tstd::cout << \"idx:\" << idx << \"\\n\";\n\t\tif(idx >= nline) break;\n\n\t\tstd::string& cs = in[idx];\n\t\tint clv = 0;\n\t\tfor(std::string::iterator itr = cs.begin(); itr != cs.end() && *itr == '.'; itr++, clv++);\n\t\tif(lv != clv) break;\n\t\tidx++;\n\n\t\tchar cc = cs[lv];\n\t//\tstd::cout << \"cc:\" << cc << \"\\n\";\n\t\tint cnum;\n\n\t\tif(cc == '+' || cc == '*'){\n\t\t\tcnum = calc(lv+1, cc);\n\t\t}else{\n\t\t\tcnum = cc - '0';\n\t\t}\n\n\t//\tstd::cout << \"cnum=\" << cnum << \"\\n\";\n\n\t\tif(kind == '*') {\n\t\t\tret *= cnum;\n\t\t}else{\n\t\t\tret += cnum;\n\t\t}\n\n\t}\n\treturn ret;\n}\n\nint main(void) {\n\n\tint ret;\n\n\twhile(true){\n\t\tstd::cin >> nline;\n\t\tif(!nline) break;\n\n\t\tin = new std::string[nline];\n\t\tfor(int i=0; i<nline; i++) std::cin >> in[i];\n\t\tidx = 0;\n\n\t\tstd::cout << calc() << \"\\n\";\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\n// <<<\n\nint32_t main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<string> s(n); cin >> s;\n\n        vector<pair<int,int>> st;\n        repR (i,n) {\n            int d = s[i].size()-1;\n            char c = s[i].back();\n            if (isdigit(c)) {\n                st.eb(d,c-'0');\n            } else {\n                int val = (c == '+' ? 0 : 1);\n                assert(st.size());\n                while (st.size() && st.back().fst == d+1) {\n                    int x = st.back().snd;\n                    st.pop_back();\n                    if (c == '+') val += x;\n                    if (c == '*') val *= x;\n                }\n                st.eb(d,val);\n            }\n        }\n        assert(sz(st) == 1);\n        assert(st[0].fst == 0);\n        cout << st[0].snd << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n// #define USE_LLONG_AS_INT\n#ifdef USE_LLONG_AS_INT\n#define int long long\n#define inf (1ll<<60)\n#else\n#define inf (1<<30)\n#endif\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define vi vector<int>\n#define vvi vector<vi>\n#define pb push_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int>>\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define MEMSET(a) memset(a,0,sizeof(a))\n#define Yes(f) cout<<(f?\"Yes\":\"No\")<<endl\n#define yes(f) cout<<(f?\"yes\":\"no\")<<endl\n#define YES(f) cout<<(f?\"YES\":\"NO\")<<endl\n#define SORT(v) sort(all(v))\n#define RSORT(v) sort(all(v), greater<int>())\n\nusing namespace std;\n\nconst int mod=1e9+7;\nconst string sp=\" \";\n\nvoid run();\n\nvoid init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(12);\n}\n\nsigned main(){\n    init();\n    run();\n    return 0;\n}\n\nchar s[20][20];\nint i;\nint n;\n\nint f(int l){\n    int ans=0;\n    if(s[i][l]=='+'){\n        i++;\n        while(i<n&&s[i][l]=='.')ans+=f(l+1);\n        return ans;\n    }\n    if(s[i][l]=='*'){\n        i++;\n        ans=1;\n        while(i<n&&s[i][l]=='.')ans*=f(l+1);\n        return ans;\n    }\n    return atoi(s[i++]+l);\n}\n\nvoid run(){\n    cin>>n;\n    if(!n)return;\n    MEMSET(s);\n    rep(i,n)cin>>s[i];\n    i=0;\n    cout<<f(0)<<endl;\n    run();\n}\n"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#include <iostream>\n#include <vector>\n// #include <map>\n#include <string>\n#include <functional>\n// #include <algorithm>\n// #include <numeric>\n// #include <limits>\n\nusing namespace std;\n\nint n;\nconst short type_n = 0; // number\nconst short type_p = 1; // plus\nconst short type_s = 2; // star\n\nstruct Data {\n\tshort type = -1;\n\tint level = 0;\n\tint val = -1;\n\n\tData() {}\n\n\tData(string str) {\n\t\tfor (auto c : str) {\n\t\t\tif (c == '.') {\n\t\t\t\tlevel++;\n\t\t\t} else if (isdigit(c)) {\n\t\t\t\ttype = type_n;\n\t\t\t\tval = c - '0';\n\t\t\t} else {\n\t\t\t\tif (c == '+') {\n\t\t\t\t\ttype = type_p;\n\t\t\t\t} else {\n\t\t\t\t\ttype = type_s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid print() {\n\t\tcout << \"level \" << level << \" type \" << type << \" : \" << val << endl;\n\t}\n\n};\n\nvector<Data> datas;\n\nvoid input() {\n\tdatas.resize(n);\n\tstring str;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> str;\n\t\tData d(str);\n\t\tdatas[i] = d;\n\t}\n}\n\nint run(int key) {\n\tauto& d = datas[key];\n\tif (d.val != -1) {\n\t\treturn d.val;\n\t}\n\tfunction<int(int, int)> func;\n\tif (d.type == type_p) {\n\t\td.val = 0;\n\t\tfunc = plus<int>();\n\t} else {\n\t\td.val = 1;\n\t\tfunc = multiplies<int>();\n\t}\n\tint l = d.level + 1; // target level\n\tfor (key += 1; key < n; key++) {\n\t\tif (datas[key].level == l) {\n\t\t\td.val = func(d.val, run(key));\n\t\t\tcontinue;\n\t\t}\n\t\tif (datas[key].level < l) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn d.val;\n}\n\nvoid solve() {\n\tinput();\n\tcout << run(0) << endl;\n\t//std::cout << \"debug \" << std::endl; // debug\n\t//for (auto d : datas) {\n\t//\td.print();\n\t//}\n\t//std::cout << \"debug end \" << std::endl; // debug\n}\n\nint main() {\n\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tsolve();\n\t}\n\n\t//std::cout << \"\\e[38;5;0m\\e[48;5;40m --- end ---  \\e[m\" << std::endl; // debug\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,p;\nstring s;\nint d[200];\nchar c[200];\n\nint solve(){\n  if('0'<=c[p]&&c[p]<='9')return c[p++]-'0';\n  int k=p++,res=(c[k]=='*'?1:0);\n  while(d[p]==d[k]+1){\n    if(c[k]=='+')res+=solve();\n    if(c[k]=='*')res*=solve();\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    d[n]=0;\n    for(int i=0;i<n;i++){\n      cin>>s;\n      d[i]=s.size();\n      c[i]=s[s.size()-1];\n    }\n    p=0;\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nint main(void) {\n    while (1) {\n\n        int n;\n        cin >> n;\n        if (n == 0) break;\n\n        string formula[n];\n        for (int i = 0; i < n; ++i) {\n            cin >> formula[i];\n        }\n\n        while (1) {\n\n            if (formula[0].length() == 1 && formula[0] != \"+\" && formula[0] != \"*\") { // 終了条件\n                cout << formula[0] << endl;\n                break;\n            }\n\n            int maxlen = 0;\n            for (int i = 0; i < n; ++i) {\n                maxlen = max(maxlen, (int) (formula[i].length()));\n            }\n\n            bool opefind = false;\n            long long result = 0;\n            string ope;\n            int pos;\n            int maxcnt = 0;\n            for (int i = 0; i < n; ++i) {\n                if (formula[i].length() == maxlen) {\n                    if (!opefind) {\n                        ope = formula[i - 1].substr(formula[i - 1].length() - 1, 1);\n                        result = (long long) (stoi(formula[i].substr(formula[i].length(), 1)));\n                        opefind = true;\n                        pos = i - 1;\n                        maxcnt += 1;\n                    } else {\n                        if (ope == \"+\") {\n                            result += (long long) (stoi(formula[i].substr(formula[i].length(), 1)));\n                        } else if (ope == \"*\") {\n                            result *= (long long) (stoi(formula[i].substr(formula[i].length(), 1)));\n                        }\n                        maxcnt += 1;\n                    }\n                    if (i + 1 != n) {\n                        if (formula[i + 1].length() != maxlen) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            string replaceformula = \"\";\n            for (int i = 0; i < maxlen - 2; ++i) {\n                replaceformula += \".\";\n            }\n            replaceformula += to_string(result);\n\n            n -= maxcnt;\n            formula[pos] = replaceformula;\n            for (int i = pos + 1; i < n; ++i) {\n                formula[i] = formula[i + maxcnt];\n            }\n\n        }\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <stack>\n#include <queue>\n\n#define REP(i,n)for (int i=0;i<(n);i++)\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define ll long long\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n;\nstring s[1024];\n\nint rec(int a,int b,int c){ //a -> 参照する文字列 b->式の階層 c-> 演算の形式\n  //cout << \"call(a,b,c)\" << a << \",\" << b <<\",\" << c << endl;\n\tint res=0;\n\tif(c)res=1;\n\tfor(int i=a;i<n&&b<s[i].size();i++){\n\t\tif(s[i][b]=='.')continue;\n\t\tint x=s[i][b]-'0'; //ASCII code の性質 char -> int\n\t\tif(s[i][b]=='*')x=rec(i+1,b+1,1);\n\t\tif(s[i][b]=='+')x=rec(i+1,b+1,0);\n\t\tif(c)res*=x;\n\t\telse res+=x;\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tREP(i,n)cin>>s[i];\n\t\tcout<<rec(0,0,0)<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing VI = vector<ll>;\nusing VV = vector<VI>;\nusing VS = vector<string>;\n\n// tourist set\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << '\\n'; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n// tourist set end\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,b) FOR(i, 0, b)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<'\\n'\n#define p2(s, t) cout << (s) << \" \" << (t) << '\\n'\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << '\\n'\n#define p_yes() p(\"YES\")\n#define p_no() p(\"NO\")\n#define SZ(x) ((int)(x).size())\n#define SORT(A) sort(ALL(A))\n#define RSORT(A) sort(ALL(A), greater<ll>())\n\nvoid no(){p_no(); exit(0);}\nvoid yes(){p_yes(); exit(0);}\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\nconst double PI = acos(-1);\n\nbool is_operator(string s){\n  if(s.find('+')!=s.npos) return true;\n  if(s.find('*')!=s.npos) return true;\n  return false;\n}\n\nbool is_multiply(string s){\n  if(s.find('*')!=s.npos) return true;\n  return false;\n}\n\n// \"...2\" => 3\nll level(string s){\n  ll L = s.size();\n  ll cnt = 0;\n  rep(i, L){\n    if(s[i]=='.') cnt++;\n  }\n  return cnt;\n}\n\n// \"...2\" => 2\nll num(string s){\n  ll i = 0;\n  while(s[i]=='.'){\n    i++;\n  }\n  string sub = s.substr(i);\n  return stoll(sub);\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // input\n    ll N; \n    while(cin>>N){\n      if(N==0) return 0;\n      if(N==1){\n        ll v; cin >> v;\n        p(v);\n        continue;\n      }\n\n      VS S(N);\n      rep(i, N){\n        cin >> S[i];\n      }\n      reverse(ALL(S));\n\n      stack<pair<ll,ll>> st;\n      rep(i, N){\n        string s = S[i];\n        if(is_operator(s)){\n          ll lv = level(s);\n          if(is_multiply(s)){\n            ll mul = 1;\n            while(st.size()>0 && st.top().first == lv+1){\n              mul *= st.top().second;\n              st.pop();\n            }\n            st.push(make_pair(lv, mul));\n          }\n          else{\n            ll sum = 0;\n            while(st.size()>0 && st.top().first == lv+1){\n              sum += st.top().second;\n              st.pop();\n            }\n            st.push(make_pair(lv, sum));\n          }\n        }\n        else{\n          // 数字\n          ll lv = level(s);\n          ll n = num(s);\n          st.push(make_pair(lv, n));\n        }\n      }\n      // 全部終えたら\n      ll ans = st.top().second;\n      p(ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint solve(void);\nint getValue(const vector<string> &v, int &itr, const int depth = 0);\n\nint main(void) {\n\n\t//FILE* fpin = freopen(\"data.txt\", \"r\", stdin);\n\n\twhile (solve()) {}\n\n\treturn 0;\n\n}\n\nint solve(void) {\n\n\tint n;\n\n\tcin >> n;\n\n\tif ( !n ) { return 0; }\n\n\tvector<string> str(n);\n\t\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> str[i];\n\t}\n\n\tint itr = 0;\n\n\tcout << getValue(str, itr) << endl;\n}\n\nint getValue(const vector<string>& v, int &itr, const int depth)\n{\n\n\tint len = v[itr].length();\n\tchar ch = v[itr][len - 1];\n\tint ret;\n\n\titr++;\n\tif (ch == '*') {\n\t\t//multiply\n\t\tret = 1;\n\t\twhile (itr<v.size() && v[itr].length() - 1 > depth) {\n\t\t\tret *= getValue(v, itr, v[itr].length() - 1);\n\t\t}\n\t}\n\telse if (ch == '+') {\n\t\t//plus\n\t\tret = 0;\n\t\twhile (itr < v.size() && v[itr].length() - 1 > depth) {\n\t\t\tret += getValue(v, itr, v[itr].length() - 1);\n\t\t}\n\t}\t\n\telse {\n\t\t//numbers\n\t\tret = ch - '0';\n\t}\n\n\n\treturn ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\nstruct CLASSNUM{\n  char op;\n  vector<int> num;\n};\n\nint main(){\n  int n,j;\n  string str;\n  CLASSNUM classNum[9];\n  while(true){\n    cin >> n;\n    if(n == 0) break;\n    for(int i = 0; i < n; i++){\n      cin >> str;\n\n      j = 0;\n      while(str[j] == '.'){\n        j++;\n      }\n\n      if(j!=0) str = str.substr(j,1);\n\n      if(str == \"+\") classNum[j].op = '+';\n      else if(str == \"*\")classNum[j].op = '*';\n      else{\n        classNum[j].num.push_back(atoi(str.c_str()));\n      }\n    }\n    for(int i=8; i >= 1; i--){\n      if(classNum[i].num.size() == 0) continue;\n      else{\n        int sum;\n        if(classNum[i].num.size() >= 1 && classNum[i-1].op == '+') {\n          sum = 0;\n          for(int k = 0; k < classNum[i].num.size(); k++){\n            sum += classNum[i].num[k];\n          }\n          classNum[i-1].num.push_back(sum);\n        }\n        else if(classNum[i].num.size() >= 1 && classNum[i-1].op == '*') {\n          sum = 1;\n          for(int k = 0; k < classNum[i].num.size(); k++){\n            sum *= classNum[i].num[k];\n          }\n          classNum[i-1].num.push_back(sum);\n        }\n      }\n    }\n    cout << classNum[0].num[0] << endl;\n    for(int i = 0; i < 8; i++) classNum[i].num.clear();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* main code starts from line 155. */\n\n/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container library\n#include <array>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\ntemplate <typename T>\nusing V = vector<T>;\ntemplate <typename T, typename U>\nusing P = pair<T, U>;\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\nusing ll = long long;\n\n#define fst first\n#define snd second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define ALL(v) (v).begin(), (v).end()\n#define SIZE(v) (LL((v).size()))\n\n#define FIND(v, k) (v).find(k) != (v).end()\n#define VFIND(v, k) find(ALL(v), k) != (v).end()\n\n#define SORT(v) sort(ALL(v))\n#define GSORT(v) sort(ALL(v), greater<decltype((v).front())>())\n\n/* ---------- repetition ---------- */\n\n#define FOR(i, a, b) for (ll i = (a); i <= (b); i++)\n#define RFOR(i, a, b) for (ll i = (a); i >= (b); i--)\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\nT sq(T a) {\n    return a * a;\n}\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    if (a > b) return gcd(b, a);\n    return a == 0 ? b : gcd(b % a, a);\n}\n\ntemplate <typename T>\nT mypow(T b, T n) {\n    if (n == 0) return 1;\n    if (n == 1) return n;\n    if (n % 2 == 0) {\n        return mypow(sq(b), n / 2);\n    } else {\n        return mypow(b, n - 1) * b;\n    }\n}\n\n/* --------------------\ntemplate <typename T>\nT mypow(T b, T n) {\n    if (n == 0) return 1;\n    if (n == 1) return n % MOD;\n    if (n % 2 == 0) {\n        return mypow(sq(b) % MOD, n / 2);\n    } else {\n        return mypow(b, n - 1) * b % MOD;\n    }\n}\n-------------------- */\n\n#define fcout cout << fixed << setprecision(10)\n\n/* ----------- debug ---------- */\n\ntemplate <typename T, typename U>\nvoid testP2(T a, U b) {\n    cout << \"(\" << a << \", \" << b << \")\" << endl;\n    return;\n}\n\ntemplate <typename T>\nvoid testV(T v) {\n    cout << \"[\";\n    for (auto i : v) {\n        cout << i << \", \";\n    }\n    cout << \"\\b\\b]\" << endl;\n    return;\n}\n\ntemplate <typename T>\nvoid testV2(T v) {\n    for (auto sv : v) {\n        testV(sv);\n    }\n    cout << endl;\n    return;\n}\n\n#define GET_VAR_NAME(variable) #variable\n#define test(x) cout << GET_VAR_NAME(x) << \" = \" << x << endl;\n#define testP(p)                      \\\n    cout << GET_VAR_NAME(p) << \" = \"; \\\n    testP2(p.fst, p.snd);\n\n/* ---------- Constants ---------- */\n\n// const ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\n// const double EPS = 1e-10;\n// const ll dx[4] = {0, -1, 1, 0};\n// const ll dy[4] = {-1, 0, 0, 1};\n// const ll dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n// const ll dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\n/* ---------- Type Definition ----------- */\n\n\n/* ---------- Global Variance ----------- */\n\n\n/* ------------- Functions -------------- */\n\n\n/* ----------- Main Function ------------ */\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        ll N;\n        cin >> N;\n        if (N == 0) break;\n\n        if (N == 1) {\n            ll S;\n            cin >> S;\n            cout << S << endl;\n            continue;\n        }\n\n        V<string> S(N + 1);\n        ll l = 2;\n\n        FOR(i, 0, N - 1) {\n            cin >> S[i];\n            l = max(l, SIZE(S[i]));\n        }\n\n        S[N] = (S[0] == \"+\" ? \".0\" : \".1\");\n\n        FOR(i, 0, N) {\n            while (SIZE(S[i]) < l + 10) {\n                S[i] += \"$\";\n            }\n        }\n\n        V<P<char, ll>> ope;\n        ll d = 0;\n        FOR(i, 0, N) {\n            while (S[i][d] == '$') {\n                auto p = ope.back();\n                ope.pop_back();\n                ll res = p.snd;\n\n                auto q = ope.back();\n                ope.pop_back();\n\n                if (q.fst == '+') {\n                    res += q.snd;\n                } else {\n                    res *= q.snd;\n                }\n                ope.pb(mp(q.fst, res));\n                d--;\n            }\n\n            if (!isdigit(S[i][d])) {\n                ope.pb(mp(S[i][d], (S[i][d] == '+' ? 0 : 1)));\n                d++;\n            } else {\n                auto p = ope.back();\n                ope.pop_back();\n\n                ll res = S[i][d] - '0';\n                if (p.fst == '+') {\n                    res += p.snd;\n                } else {\n                    res *= p.snd;\n                }\n                ope.pb(mp(p.fst, res));\n            }\n        }\n\n        cout << ope.back().snd << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <ctime>\n#define INF 999999999\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=(n);i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n#define MOD(x) (x%(mod))\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool debug=false;\n/*---------------------------------------------------*/\n\nint n,m;\nmap<int,int>wide,hight;\nint w[1505],h[1505];\n\nvoid enumerate_hight(){\n  int sum;\n  for(int i=0;i<n;i++){\n    sum=0;\n    for(int j=i;j<n;j++){\n      sum+=h[j];\n      //cout<<\"h: \"<<sum<<endl;\n      hight[sum]++;\n    }\n  }\n}\n\nvoid enumerate_wide(){\n  int sum;\n  for(int i=0;i<m;i++){\n    sum=0;\n    for(int j=i;j<m;j++){\n      sum+=w[j];\n      //cout<<\"w: \"<<sum<<endl;\n      wide[sum]++;\n    }\n  }\n}\n\nvoid solve(){\n  ll ans=0;\n  wide.clear();hight.clear();\n  for(int i=0;i<n;i++)cin>>h[i];\n  enumerate_hight();\n  for(int i=0;i<m;i++)cin>>w[i];\n  enumerate_wide();\n  //rep(i,100)cout<<i<<\":  \"<<wide[i]<<\" \"<<hight[i]<<endl;\n  rep(i,1500001)if(wide[i]!=0&&hight[i]!=0)ans+=wide[i]*hight[i];\n  cout<<ans<<endl;\n}\n\nint main(){\n  while(cin>>n>>m){\n    if(n==0&&m==0)break;\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\n\nint plus(int, int, vector<vector<char> > &);\nint dot(int, int, vector<vector<char> > &);\n\n\n\nint f(int i, int j, vector<vector<char> > &a, int op){\n        \n    \n    if(op == 0){\n    int ret = 0;\n    int e = 0;\n    while(a[i][j] != 'Z'){\n        \n        \n        if(a[i][j] == '+') ret += f(i + 1, j + 1, a, 0);\n        else if(a[i][j] == '*') ret += f(i + 1, j + 1, a, 1);\n        else if(a[i][j] == '.') ret += e;\n        else ret += a[i][j] - '0';\n        i++;\n    }\n    return ret;\n    }else{\n\n    int ret = 1;\n    int e = 1;\n    while(a[i][j] != 'Z'){\n        if(a[i][j] == '+') ret *= f(i + 1, j + 1, a, 0);\n        else if(a[i][j] == '*') ret *= f(i + 1, j + 1, a, 1);\n        else if(a[i][j] == '.') ret *= e;\n        else ret *= a[i][j] - '0';\n        i++;\n    }\n\n    return ret;\n    }\n}\n\nint calc(int i, int j, vector<vector<char> > &a){\n    \n    if(a[i][j] == '+') return f(i + 1, j + 1, a, 0);\n    else if(a[i][j] == '*') return f(i + 1, j + 1, a, 1);\n    else return a[i][j] - '0';\n}\n\n\nsigned main(){\n    \n    while(1){\n        int n; cin >> n;\n        if(!n) break;\n        vector<vector<char> > a(n + 1, vector<char> (15, 'Z'));\n\n        for(int i = 0; i < n; i++){\n            string s; cin >> s;\n            for(int j = 0; j < (int)s.size(); j++){\n                a[i][j] = s[j];\n            }\n        }\n        \n        \n        cout << calc(0, 0, a) << endl;\n\n\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<(n);i++)\n#define loop(i,a,n) for(i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint f(vs s, int t){\n    int i;\n    rep(i,s[t].size())if(s[t][i]!='.')break;\n    if(isdigit(s[t][i])) return s[t][i] - '0';\n\n    if(s[t][i] == '+'){\n        int ret = 0;\n        int j = t+1;\n        while(s.size() > j && s[j].size() > i+1){\n            if(s[j][i+1] != '.'){\n                ret += f(s, j);\n            }\n            j++;\n        }\n        return ret;\n    }else{\n        int ret = 1;\n        int j = t+1;\n        while(s.size() > j && s[j].size() > i+1){\n            if(s[j][i+1] != '.'){\n                ret *= f(s, j);\n            }\n            j++;\n        }\n        return ret;\n    }\n}\n\nint main(void) {\n    int i,j;\n    int n;\n    while(cin >> n, n){\n        vs s(n);\n        rep(i,n) cin >> s[i];\n        cout << f(s, 0) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string.h>\n#include<stdio.h>\nusing namespace std;\nint suma(int d);\nint a;\nchar s[1000];\nint t(int d){\n  int ans=1;\n  cin>>s;\n  a--;\n  while(a){\n    if(strlen(s)<d)\n      break;\n    if(s[d-1]=='*')\n      ans*=t(d+1);\n    else if(s[d-1]=='+')\n      ans*=suma(d+1);\n    else{\n      ans*=s[d-1]-'0';\n      cin>>s;\n      a--;\n    }\n  }\n  return ans;\n}\n\nint suma(int d){\n  int ans=0;\n  a--;\n  cin>>s;\n  while(a){\n    if(strlen(s)<d)\n      break;\n    if(s[d-1]=='*')\n      ans+=t(d+1);\n    else if(s[d-1]=='+')\n      ans+=suma(d+1);\n    else{\n      ans+=s[d-1]-'0';\n      cin>>s;\n    }\n  }\n  return ans;\n}\n\nint main(){\n  int n;\n  while(1){\n    cin>>s;\n    if(strlen(s)==1&&s[0]=='0')\n      break;\n    n=strlen(s);\n    a=0;\n    for(int i=0;i<n;i++){\n      a*=10;\n      a+=s[i]-'0';\n    }\n    a--;\n    cin>>s;\n    if(s[0]=='+')\n      cout<<suma(2)<<endl;\n    else if(s[0]=='*')\n      cout<<t(2)<<endl;\n    else\n      cout<<s<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<string> input;\nint level;\nchar c;\nint idx;\nbool next(){\n\tidx++;\n\tif(idx <= N){\n\t\tstring str;\n\t\tcin >> str;\n\t\tlevel = str.length() - 1;\n\t\tc = str[str.length() - 1];\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint recur(int l){\n\tif(c == '+'){\n\t\tint val = 0;\n\t\tnext();\n\t\twhile(idx <= N){\n\t\t\tif(l > level){\n\t\t\t\tbreak;\n\t\t\t}else if(c == '+' || c == '*'){\n\t\t\t\tval += recur(l + 1);\n\t\t\t}else{\n\t\t\t\tval = val + (c - '0');\n\t\t\t\tnext();\n\t\t\t}\n\t\t}\n\t\treturn val;\n\n\t}else if(c == '*'){\n\t\tint val = 1;\n\t\tnext();\n\t\twhile(idx <= N){\n\t\t\tif(l > level){\n\t\t\t\tbreak;\n\t\t\t}else if(c == '+' || c == '*'){\n\t\t\t\tval *= recur(l + 1);\n\t\t\t}else{\n\t\t\t\tval = val * (c - '0');\n\t\t\t\tnext();\n\t\t\t}\t\n\t\t}\n\t\treturn val;\n\n\t}else{\n\t\treturn c - '0';\n\t}\n}\n\nint main(){\n\twhile(cin >> N, N){\n\t\tidx = 0;\n\t\tnext();\n\t\tcout << recur(1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <cassert>\n\n#define REP(i, n) for (int i = 0; i < (n); i ++)\n\nusing namespace std;\n\ntuple<int, char> parsel(string s) {\n    return make_tuple(s.size() - 1, s.back());\n}\nint c = 0;\nint solve(int level,  const vector<tuple<int, char>>& code) {\n    int l; char op; tie(l, op) = code[c]; c+=1;\n    assert(level == l);\n    if(isdigit(op)) {\n        int num = op - '0';\n        return num;\n    }\n    assert(op == '+' || op == '*');\n    vector<int> vs;\n    while (c < code.size() && get<0>(code[c]) > level){\n        vs.push_back(solve(level + 1, code));\n    }\n    if (op == '+') {\n        int res = 0;\n        REP(i, vs.size()) res += vs[i];\n        return res;\n    }else{\n        int res = 1;\n        REP(i, vs.size()) res *= vs[i];\n        return res;\n    }\n}\nint main() {\n    while(true) {\n        int n; cin >> n;\n        if (n == 0) break;\n        vector<tuple<int, char>> code(n);\n        REP(i, n) {\n            string k; cin >> k;\n            code[i] = parsel(k);\n        }\n        c = 0;\n        cout << solve(0, code) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint n;\nstd::string t[256];\nstd::string str;\n\nint dfs(char op, int& i) {\n  int res = op == '+' ? 0 : 1;\n  i += 1; // '('\n  for(;;) {\n    char c = str[i];\n    if( c == ')' ) {\n      return res;\n    }\n    int t;\n    if( c == '+' or c == '*' ) {\n      i += 1;\n      t = dfs(c, i);      \n    }\n    else {\n      t = c - '0';\n    }\n    res = ((op == '+') ? res + t : res * t);\n    i += 1;\n  }\n  assert(0);\n  return 0;\n}\n\nint main() {\n  for(;;) {\n    for(int i = 0; i < 256; ++i) {\n      t[i].clear();\n    }\n    str.clear();\n    scanf(\"%d\", &n);\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i) {\n      std::cin >> t[i];\n    }\n    str += '(';\n    for(int i = 0; i < n; ++i) {\n      str += t[i][t[i].size()-1];\n      if( t[i].size() < t[i+1].size() ) {\n        str += '(';\n      }\n      if( t[i].size() > t[i+1].size() ) {\n        for(int j = 0; j < t[i].size() - t[i+1].size(); ++j) {\n          str += ')';\n        }\n      }\n    }\n    int i = 0;\n    int res = dfs('+', i);\n    printf(\"%d\\n\", res);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint n;\nstring s[50];\nint calc(int a, int b, bool m) {\n\tint res = m;\n\tfor (int i = b; i < n; i++) {\n\t\tif (s[i].size() <= a)break;\n\t\tif ('0' <= s[i][a] && s[i][a] <= '9') {\n\t\t\tif (m)res *= s[i][a] - '0';\n\t\t\telse res += s[i][a] - '0';\n\t\t}\n\t\tif (s[i][a] == '*') {\n\t\t\tif (m)res *= calc(a + 1, i + 1, 1);\n\t\t\telse res += calc(a + 1, i + 1, 1);\n\t\t}\n\t\tif (s[i][a] == '+') {\n\t\t\tif (m)res *= calc(a + 1, i + 1, 0);\n\t\t\telse res += calc(a + 1, i + 1, 0);\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\twhile (scanf(\"%d\", &n), n) {\n\t\trep(i, n)cin >> s[i];\n\t\tprintf(\"%d\\n\", calc(0, 0, 0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nlong long dfs(string s[25], int n, int y, int x) {\n    //cout << y << ' ' << x << endl;;\n    if(isdigit(s[y][x])){\n        return s[y][x] - '0';\n    }else if(s[y][x] == '.'){\n        assert(0);\n    }else{\n        long long res;\n        //show(s[y][x])\n        if(s[y][x] == '+'){\n            res = 0;\n            range(i,y + 1,n){\n                //cout << i << ' ' << x + 1 << endl;\n                if(x + 1 >= s[i].size()) break;\n                if(s[i][x + 1] == '.') continue;\n                res += dfs(s,n,i,x + 1);\n            }\n        }else{\n            res = 1;\n            range(i,y + 1,n){\n                if(x + 1 >= s[i].size()) break;\n                if(s[i][x + 1] == '.') continue;\n                res *= dfs(s,n,i,x + 1);\n            }\n        }\n        //show(res)\n        return res;\n    }\n    assert(0);\n    return 0;\n}\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        string s[25];\n        rep(i,n) cin >> s[i];\n        cout << dfs(s,n,0,0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdlib.h>\n#include <string.h>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <bitset>\n\nusing namespace std;\n\n\n//+, *?????????????????????????????°?????????\n//cur::suf //ope::+ or * //com::number of comma //v::array\nint rec(int cur, int ope, int com, vector<pair<char,int> > &v)\n{//ex //cur::1  //ope::+ //com::0\n\n  vector<int> nums;\n  \n  for (int i = cur+1; i < v.size(); i++) {\n    pair<char,int> p = v[i];\n    //ope?????¢??£????????°?????????ope\n    if (p.second == com+1) {\n      //num\n      if (p.first > 47) {\n\tint tmp = p.first - 48;\n\tnums.push_back(tmp);\n      }\n      //ope\n      else if (p.first == 42 || p.first == 43) {\n\tint tmp = rec(i,p.first,p.second,v);\n\tnums.push_back(tmp);\n      }\n    }\n    else if (p.second <= com)\n      break;\n  }\n\n  //+\n  if (ope == 43) {\n    int sum = 0;\n    for (int i = 0; i < nums.size(); i++) {\n      sum += nums[i];\n    }\n    return sum;\n  }\n  //*\n  else if (ope == 42) {\n    int sum = nums[0];\n    for (int i = 1; i < nums.size(); i++) {\n      sum *= nums[i];\n    }\n    return sum;\n  }\n  else {\n    pair<char,int>p = v[cur];\n    return p.first-48;\n  }\n}\n\n\nint main(void)\n{\n  while (true) {\n\n    //+ 43  //* 42\n    //. 46  //0 48 \n\n    int n;\n    cin >> n;\n\n    if (n == 0) break;\n    \n    vector<pair<char,int> > v;\n    for (int i = 0; i < n;i++) {\n      string str;\n      cin >> str;\n      int com = 0;\n      for (int j = 0; j < str.size(); j++) {\n\tint c = str[j];\n\tif (c == 46)\n\t  com++;\n\telse {\n\t  pair<char,int> p = make_pair(c,com);\n\t  v.push_back(p);\n\t}\n      }\n    }\n    pair<char, int> p = v[0];\n\n    cout << rec(0,p.first,p.second,v) << endl;\n    \n  }\n  return 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<climits>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nint solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        if(th>17483647){\n            return -1;\n        }\n        st.push(make_pair(th, l-1));\n    }\n    return 0;\n}\nint main(){\n    cout<<INT_MAX<<endl;\n    while(cin>>n,n){\n        while(ope.size())ope.pop();\n        while(st.size())st.pop();\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    if(solve(level)==-1)return -1;\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        if(solve(0)==-1)return -1;\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define debug(x) cerr<<#x<<\": \"<<x<<endl\n#define all(a) a.begin(),a.end()\n\ntypedef long long ll;\n\nll solve(vector<string> &s,int n,int &y,int x){\n    if(isdigit(s[y][x])) return s[y++][x] - '0';\n    char op = s[y][x];\n    ++y,++x;\n    vector<int> term;\n    while(y < n && (int)s[y].size() > x){\n        term.push_back(solve(s,n,y,x));\n    }\n    if(op == '+') return accumulate(all(term),0);\n    else return accumulate(all(term),1LL,multiplies<ll>());\n}\n//accumulate(a, a+5, 1, multiplies<int>());\nint main(void){\n    int n;\n    while(cin>>n,n){\n        vector<string> s(n);\n        rep(i,n) cin>>s[i];\n        int y = 0;\n        cout<<solve(s,n,y,0)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint N;\n\nstring S[20];\n\nvoid solve(){\n    for(int i=0;i<N;i++) cin>>S[i];\n    if(N==1){\n        cout<<S[0].front()<<endl;\n        return;\n    }\n\n    vector<int> v[21];\n    char opt[21];\n    char val[21];\n    int lev[21]={};\n    for(int i=0;i<N;i++){\n        for(int j=0;j<S[i].size();j++){\n            if(S[i][j]=='.') lev[i]++;\n            else val[i]=S[i][j];\n        }\n    }\n\n    int now=0;\n    for(int i=0;i<N;i++){\n        if(now==lev[i]){\n            if(val[i]=='+'||val[i]=='*'){\n                now++;\n                opt[now]=val[i];\n            }else v[now].push_back(val[i]-'0');\n        }else{\n            int num;\n            if(opt[now]=='+') num=0;\n            else num=1;\n            for(int j=0;j<v[now].size();j++){\n                if(opt[now]=='+') num+=v[now][j];\n                else num*=v[now][j];\n            }\n            v[now].clear();\n            v[now-1].push_back(num);\n            now--;\n            i--;\n        }\n    }\n\n    while(now>0){\n        int num;\n        if(opt[now]=='+') num=0;\n        else num=1;\n        for(int j=0;j<v[now].size();j++){\n            if(opt[now]=='+') num+=v[now][j];\n            else num*=v[now][j];\n        }\n        v[now].clear();\n        v[now-1].push_back(num);\n        now--;\n    }\n    cout<<v[0][0]<<endl;\n}\n\nint main(){\n  while(1){\n      cin>>N;\n      if(N==0) break;\n      solve();\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nint make(int w);\nint puls(int a,int b);\nint multi(int a,int b);\nint X=16;\nint n;\nvector<vector<int> > a(100,vector<int>(X,-4));\n\nint main(){\n  scanf (\"%d\",&n);\n  while(n){\n    string s;\n    for(int t=int(a.size());t<100;t++){\n      a.push_back(vector<int>(X,-4));\n    }\n    for(int t=0;t<100;t++){\n      for(int z=0;z<X;z++){\n        a[t][z]=-4;\n      }\n    }\n    for(int t=0;t<n;t++){\n      cin >> s;\n      for(int p=0;p<int(s.size());p++){\n        switch(s[p]){\n          case 42:\n            a[t][p]=-2;\n            break;\n          case 43:\n            a[t][p]=-1;\n            break;\n          case 48:\n          case 49:\n          case 50:\n          case 51:\n          case 52:\n          case 53:\n          case 54:\n          case 55:\n          case 56:\n          case 57:\n            a[t][p]=s[p]-48;\n            break;\n        }\n      }\n    }\n    for(int t=X-1;t>=1;){\n      if(make(t)<0){\n        t--;\n      }\n    }\n    printf(\"%d\\n\",a[0][0]);\n    scanf (\"%d\",&n);\n  }\n}\n\n\nint make(int w){\n  int q=0;\n  int end=-4;\n  for(int i=0;i<n;i++){\n    if(a[i][w]!=-4){\n      if(a[i-1][w-1]==-1){\n        q=0;\n      }\n      if(a[i-1][w-1]==-2){\n        q=1;\n      }\n      for(int k=i;a[k][w]!=-4;){\n        if(a[i-1][w-1]==-1){\n          q=puls(q,a[k][w]);\n          a.erase(a.begin() + k);\n          n--;\n        }\n        if(a[i-1][w-1]==-2){\n          q=multi(q,a[k][w]);\n          a.erase(a.begin() + k);\n          n--;\n        }\n      }\n      a[i-1][w-1]=q;\n      end=q;\n      break;\n    }\n  }\n  return end;\n}\n\n\nint puls(int a,int b){\n  return a+b;\n}\n\nint multi(int a,int b){\n  return a*b;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nlong long dfs(string s[25], int n, int y, int x) {\n    //cout << y << ' ' << x << endl;;\n    if(isdigit(s[y][x])){\n        return s[y][x] - '0';\n    }else if(s[y][x] == '.'){\n        return 0;\n    }else{\n        long long res;\n        //show(s[y][x])\n        if(s[y][x] == '+'){\n            res = 0;\n            range(i,y + 1,n){\n                //cout << i << ' ' << x + 1 << endl;\n                if(x + 1 >= s[i].size()) break;\n                res += dfs(s,n,i,x + 1);\n            }\n        }else{\n            res = 1;\n            range(i,y + 1,n){\n                if(x + 1 >= s[i].size()) break;\n                long long tmp = dfs(s,n,i,x + 1);\n                res *= tmp == 0 ? 1 : tmp;\n            }\n        }\n        //show(res)\n        return res;\n    }\n    assert(0);\n    return 0;\n}\n\nint main(){\n    int n;\n    while(cin >> n,n){\n        string s[25];\n        rep(i,n) cin >> s[i];\n        cout << dfs(s,n,0,0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <cassert>\nusing namespace std;\n\nint N;\nstring S;\n\nint main(){\n    while(cin >> N && N){\n        stack<char> op;\n        stack<int> num;\n        for(int i=0;i<N;i++){\n            cin >> S;\n            while(S.size()<=op.size()){\n                int t = num.top(); num.pop();\n                op.pop();\n                int s = num.top(); num.pop();\n                if(op.top()=='+') s += t;\n                else s *= t;\n                num.push(s);\n            }\n            if(S[op.size()]=='+'){\n                op.push('+'); num.push(0);\n            }else if(S[op.size()]=='*'){\n                op.push('*'); num.push(1);\n            }else{\n                int t = S[op.size()]-'0';\n                if(num.empty()) num.push(t);\n                else{\n                    int s = num.top(); num.pop();\n                    if(op.top()=='+') s += t;\n                    else s *= t;\n                    num.push(s);\n                }\n            }\n        }\n        while(!op.empty()){\n            int t = num.top(); num.pop();\n            op.pop();\n            if(num.empty()){\n                num.push(t); break;\n            }\n            int s = num.top(); num.pop();\n            if(op.top()=='+') s += t;\n            else s *= t;\n            num.push(s);\n        }\n        assert(num.size()==1);\n        cout << num.top() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstdio>\n#include <cassert>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\n//typedef pair<int, int> pii;\nusing pll = pair<ll, ll>;\nusing pii = pair<short, short>;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<(a);i++)\n#define rep1(i,a) for(int i=1;i<=(a);i++)\n#pragma warning(disable:4996)\n//#define INF 1000000000000000.0\nint main() {\n    int n;\n    while (cin >> n, n) {\n        vector<char> op{ '+' };\n        vector<int> num{ 0 };\n        int nest = 0;\n        rep(i, n) {\n            string buf;\n            cin >> buf;\n            int next=count(ALL(buf), '.');\n            while (nest > next) {\n                if(op[nest-1]=='+')num[nest-1] += num[nest];\n                else num[nest - 1] *= num[nest];\n                nest--;\n                num.pop_back();\n                op.pop_back();\n            }\n            if (buf[next] == '+') {\n                op.push_back('+');\n                num.push_back(0);\n            }\n            else if (buf[next] == '*') {\n                op.push_back('*');\n                num.push_back(1);\n            }\n            else if (op[next] == '+')num[next] += buf[next] - '0';\n            else num[next] *= buf[next] - '0';\n            nest = next;\n        }\n        while (nest > 0) {\n            if (op[nest - 1] == '+')num[nest - 1] += num[nest];\n            else num[nest - 1] *= num[nest];\n            nest--;\n            num.pop_back();\n        }\n        cout << num[0] << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<string>s;\n\nint calc(int a, int b, char c){\n    switch (c){\n        case '+': return a+b;\n        case '*': return a*b;\n    }\n}\n\nint calc_rec(int depth, int cur){\n    char c=s[cur][depth];\n    int res=0;\n    if(c=='+'||c=='*'){\n        int tmp;\n        if(c=='*')res=1;\n        int cur2=cur+1;\n        while(cur2<s.size()&&s[cur2].size()>=depth+2){\n            if(s[cur2][depth+1]!='.'){\n                tmp=calc_rec(depth+1,cur2);\n                res=calc(res,tmp,c);\n            }\n            cur2++;\n        }\n    }else res=int(c-'0');\n    // printf(\"char : %c\\n\",c);\n    // printf(\"return : %d\\n\",res);\n    return res;\n}\n\nint main(void){\n    while(true){\n        int n;\n        cin>>n;\n        // printf(\"input\\n\");\n        if(n==0)return 0;\n        for(int i=0;i<n;i++){\n            string tmp;\n            cin >> tmp;\n            s.push_back(tmp);\n        }\n        // printf(\"s size : %d\\n\",s.size());\n        int res=calc_rec(0,0);\n        cout << res << endl;\n        if(!s.empty())s.clear();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nenum class Type { N, S, P };\n\nstruct D {\n    vector<D> children;\n    Type type = Type::N;\n    int value = -1;\n    int level = -1;\n};\n\nint main()\n{\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            return 0;\n        }\n\n        vector<string> vs;\n        for (int i = 0; i < n; ++i) {\n            string s;\n            cin >> s;\n            vs.push_back(s);\n        }\n\n        auto parse = [](const string& s) {\n            int i = 0;\n            while (s[i] == '.') {\n                ++i;\n            }\n            if (s[i] == '+') {\n                return D{{}, Type::S, -1, i};\n            }\n            else if (s[i] == '*') {\n                return D{{}, Type::P, -1, i};\n            }\n            else {\n                return D{{}, Type::N, stoi(s.substr(i)), i};\n            }\n        };\n\n        unordered_map<int, vector<D>> mm;\n        for (int i = vs.size() - 1; i >= 0; --i) {\n            auto x = parse(vs[i]);\n            if (x.type == Type::N) {\n                mm[x.level].push_back(x);\n            }\n            else {\n                x.children = mm[x.level + 1];\n                mm.erase(x.level + 1);\n                mm[x.level].push_back(x);\n            }\n        }\n\n        function<int(const D&)> eval = [&eval](const D& d) {\n            if (d.type == Type::N) {\n                return d.value;\n            }\n            else if (d.type == Type::S) {\n                return accumulate(\n                    begin(d.children), end(d.children), 0,\n                    [&eval](int a, const D& b) { return a + eval(b); });\n            }\n            else {\n                return accumulate(\n                    begin(d.children), end(d.children), 1,\n                    [&eval](int a, const D& b) { return a * eval(b); });\n            }\n        };\n\n        cout << eval(mm[0][0]) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if (!n)break;\n    stack<pair<char, int>> op;\n    op.emplace('+', 0);\n    REP(i,n){\n      string s;\n      cin>>s;\n      switch(s.back()) {\n        case '+':\n          op.emplace(s.back(),0);\n          break;\n        case '*':\n          op.emplace(s.back(),1);\n          break;\n        default:\n          while (op.size() > s.size()) {\n            int num = op.top().second;\n            op.pop();\n            if (op.top().first == '+') {\n              op.top().second += num;\n            } else {\n              op.top().second *= num;\n            }\n          }\n          {\n            int num = s.back() - '0';\n            if (op.top().first == '+') {\n              op.top().second += num;\n            } else {\n              op.top().second *= num;\n            }\n          }\n      }\n    }\n    cout << op.top().second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define LAST(vec) vec[vec.size() - 1]\nstring get_line() {\n  string line;\n  cin >> line;\n  return line;\n}\n// 整数: 一桁\nint main() {\n  while (true) {\n    auto line_num = stoi(get_line());\n    if (line_num == 0) return 0;\n    if (line_num == 1) {\n      cout << stoi(get_line()) << endl;\n      continue;\n    }\n    vector<int> stack;\n    vector<bool> is_adds;\n    REP(i, line_num) {\n      auto line = get_line();\n      auto level = line.size() - 1;\n      auto calc = [&](int num) {\n        if (LAST(is_adds)) {\n          LAST(stack) += num;\n        } else {\n          LAST(stack) *= num;\n        }\n      };\n      // リダクション\n      if (level < stack.size()) {\n        auto n = stack.size() - level;\n        REP(j, n) {\n          auto num = LAST(stack);\n          is_adds.pop_back();\n          stack.pop_back();\n          calc(num);\n        }\n      }\n      // パース\n      auto chr = line[line.size() - 1];\n      if (chr == '+') {\n        stack.push_back(0);\n        is_adds.push_back(true);\n      } else if (chr == '*') {\n        stack.push_back(1);\n        is_adds.push_back(false);\n      } else {\n        calc(chr - '0');\n      }\n    }\n    cout << LAST(stack) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define mod 1000000007\n#define all(c) begin(c),end(c)\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nusing ll = long long;\nusing vi = vector<int>; using vs = vector<string>;\nint dd[] = { 0, 1, 0, -1, 0 }; //→↓←↑\n\nvs S; int N; int id;\nint dfs(int depth)\n{\n\tid++;\n\n\t//cout << id << \" \" << depth << endl;\n\tif (S[id][depth] == '+')\n\t{\n\t\tint ret = 0;\n\t\twhile (id + 1 < N)\n\t\t{\n\t\t\tif (depth < S[id + 1].size() && S[id + 1][depth] == '.')ret += dfs(depth + 1);\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\telse if (S[id][depth] == '*')\n\t{\n\t\tint ret = 1;\n\t\twhile (id + 1 < N)\n\t\t{\n\t\t\tif (depth < S[id + 1].size() && S[id + 1][depth] == '.')ret *= dfs(depth + 1);\n\t\t\telse break;\n\t\t}\n\t\treturn ret;\n\t}\n\telse\n\t{\n\t\treturn S[id][depth] - '0';\n\t}\n}\n\nvoid solve()\n{\n\twhile (cin >> N, N)\n\t{\n\t\tS = vs(N);\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tcin >> S[i];\n\t\t}\n\t\tid = -1;\n\t\tcout << dfs(0) << endl;\n\t}\n}\n\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define debug(x) cerr<<#x<<\": \"<<x<<endl\n\n\ntypedef long long ll;\n\nll solve(vector<string> &s,int n,int &y,int x){\n    if(isdigit(s[y][x])) return s[y][x] - '0';\n    if(s[y][x] == '+'){\n        ll term = 0;\n        while(y+1 < n && (int)s[y+1].size() > x+1 && s[y+1][x] == '.'){\n            y++;\n            term += solve(s,n,y,x+1);\n        }\n        return term;\n    }else{\n        ll term = 1;\n        while(y+1 < n && (int)s[y+1].size() > x+1 && s[y+1][x] == '.'){\n            y++;\n            term *= solve(s,n,y,x+1);\n        }\n        return term;\n    }\n}\n\nint main(void){\n    int n;\n    while(cin>>n,n){\n        vector<string> s(n);\n        rep(i,n) cin>>s[i];\n        int y = 0;\n        cout<<solve(s,n,y,0)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n\nint solve(vector<string> const &vs, int &i, int &j){\n  //cout << vs[i][j] << endl; // 0..9, +, or *\n  if(isdigit(vs[i][j])){\n    int res = vs[i][j] - '0';\n    //cout << res << endl;\n    return res;\n  }else if(vs[i][j] == '+'){\n    int res = 0;\n    i++; j++;\n    while(i < vs.size() and vs[i].size() == j+1){\n      res += solve(vs, i, j);\n      i++;\n    }\n    i--; j--;\n    //cout << res << endl;\n    return res;\n  }else if(vs[i][j] == '*'){\n    int res = 1;\n    i++; j++;\n    while(i < vs.size() and vs[i].size() == j+1){\n      res *= solve(vs, i, j);\n      i++;\n    }\n    i--; j--;\n    //cout << res << endl;\n    return res;\n  }\n  assert(false);\n}\n\nint main(void){\n  while(1){\n    int n;\n    cin >> n;\n    if(!n) break;\n\n    vector<string> vs(n);\n    rep(i, n)\n      cin >> vs[i];\n\n    int index = 0, depth = 0; // vs[index]の.の数 = depth\n    cout << solve(vs, index, depth) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                     #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,int>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\nint pr[100010];\nint inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n \n \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n\n\n                         //----------------kokomade tenpure------------\n\n\nint n,m;\nstring s[100000];\nint a[1000],b[1000];\n\nint d;\n\nint ans(){\n\tint l=s[d].length();\n//\tcout<<s[d][s[d].length()-1]-'0'<<endl;\n//\treturn 0;\n\tif('0'<=s[d][s[d].length()-1]&&'9'>=s[d][s[d].length()-1]){\n\t\td++;\n\t\treturn s[d-1][s[d-1].length()-1]-'0';\n\t}\n\telse{\n\t//\tcout<<\"d=\"<<d<<endl;\n\t\tif(s[d][s[d].length()-1]=='+'){\n\t\t\td++;\n\t\t\tint r=0;\n\t\t//\tcout<<\"+\"<<endl;\n\t\t\twhile(s[d].length()>l) r += ans(); \n\t//\t\tcout<<\"+ \"<<r<<endl;\n\t\t\treturn r;\n\t\t}\n\t\telse{\n\t\t\t\t\t\td++;\n\t\t\tint r=1;\n\t\t\twhile(s[d].length()>l) r *= ans(); \n//\t\t\tcout<<\"* \"<<r<<endl;\n\t\t\treturn r;\n\t\t}\n\t\t\n\t}\n}\n\n\nsigned main(){\n\twhile(1){\n\tcin>>n;\n\t\tif(n==0) break;\n\t//\tcout<<n<<endl;\n\t\tfor(int i=0;i<n;i++)cin>>s[i];\n\t\t\n\t\ts[n]=\"\";\n\t\td=0;\n\t\tcout<<ans()<<endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cassert>\n#include<string>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<tuple>\n#include<numeric>\n#include <ctype.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n// vector\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) {\n    for(const T &t : v) os << \"\\t\" << t; return os << endl;\n}\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) {\n    for(T &a : v) is >> a; return is;\n}\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) {\n    return os << \"<\" << v.first << \" \" << v.second << \">\";\n}\n\nint calc_depth(string &s) {\n    rep(i, s.size()) if(s[i] != '.') return i;\n    assert(0);\n}\n\nint calc(vector<string> &line, int &now, int depth) {\n    char c = line[now].back();\n    if(isdigit(c)) {\n        now++;\n        return c - '0';\n    } else {\n        function<int(int, int)> f;\n        int ret;\n        if(c == '+') {\n            f = [](int a, int b) { return a + b; };\n            ret = 0;\n        } else if(c == '*') {\n            f = [](int a, int b) { return a * b; };\n            ret = 1;\n        } else assert(0);\n        now++;\n        \n        while(now < line.size() and calc_depth(line[now]) > depth) {\n            ret = f(ret, calc(line, now, depth + 1));\n        }\n        return ret;\n    }\n}\n\n\nbool solve() {\n    int n; cin >> n;\n    if(n == 0) return 0;\n    vector<string> line(n); cin >> line;\n    int i = 0;\n    cout << calc(line, i, 0) << endl;\n    return 1;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<climits>\nusing namespace std;\n\nchar o[200];\nint d[200],n,j;\nstring s;\nint x(int _){\n    if(o[j]>='0'&&o[j]<='9')return o[j++]-'0';\n    int k=j,r;\n    o[j++]=='*'?r=1:r=0;\n    while(d[k]+1==d[j])\n        if(o[k]=='*')r*=x(j);\n        else r+=x(j);\n    return r;\n}\nint main(){\n    while(cin>>n,n){\n        for(int i=0;i<n;i++){\n            cin>>s;\n            o[i]=s[s.length()-1];\n            d[i]=s.length();\n        }\n        j=0;\n        cout<<x(0)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#include <iostream>\n#include <vector>\n// #include <map>\n#include <string>\n// #include <algorithm>\n// #include <numeric>\n// #include <limits>\n\nusing namespace std;\n\nint n;\nconst short type_n = 0; // number\nconst short type_p = 1; // plus\nconst short type_s = 2; // star\n\nstruct Data {\n\tshort type = -1;\n\tint level = 0;\n\tint val = -1;\n\n\tData() {}\n\n\tData(string str) {\n\t\tfor (auto c : str) {\n\t\t\tif (c == '.') {\n\t\t\t\tlevel++;\n\t\t\t} else if (isdigit(c)) {\n\t\t\t\ttype = type_n;\n\t\t\t\tval = c - '0';\n\t\t\t} else {\n\t\t\t\tif (c == '+') {\n\t\t\t\t\ttype = type_p;\n\t\t\t\t} else {\n\t\t\t\t\ttype = type_s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid print() {\n\t\tcout << \"level \" << level << \" type \" << type << \" : \" << val << endl;\n\t}\n\n};\n\nvector<Data> datas;\n\nvoid input() {\n\tdatas.resize(n);\n\tstring str;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> str;\n\t\tData d(str);\n\t\tdatas[i] = d;\n\t}\n}\n\nint run(int key) {\n\tauto& d = datas[key];\n\tif (d.val != -1) {\n\t\treturn d.val;\n\t}\n\tif (d.type == type_p) {\n\t\td.val = 0;\n\t\tint l = d.level + 1; // target level\n\t\tfor (key += 1; key < n; key++) {\n\t\t\tif (datas[key].level == l) {\n\t\t\t\td.val += run(key);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (datas[key].level < l) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (d.type == type_s) {\n\t\td.val = 1;\n\t\tint l = d.level + 1; // target level\n\t\tfor (key += 1; key < n; key++) {\n\t\t\tif (datas[key].level == l) {\n\t\t\t\td.val *= run(key);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (datas[key].level < l) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn d.val;\n}\n\nvoid solve() {\n\tinput();\n\tcout << run(0) << endl;\n\t//std::cout << \"debug \" << std::endl; // debug\n\t//for (auto d : datas) {\n\t//\td.print();\n\t//}\n\t//std::cout << \"debug end \" << std::endl; // debug\n}\n\nint main() {\n\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tsolve();\n\t}\n\n\t//std::cout << \"\\e[38;5;0m\\e[48;5;40m --- end ---  \\e[m\" << std::endl; // debug\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\n#define pb push_back\n#define ll long long\nusing namespace std;\nvector<string> a;\nint n,l;\n\nint calc(int v){\n  char c=a[l][v];\n  char cc;\n  int r;\n  l++;v++;\n  //cout<<\":\"<<c<<endl;\n  if(l+1<n&&(a[l][v]=='+'||a[l][v]=='*')) r=calc(v);\n  else{\n    if(c=='*') r=1;\n    else if(c=='+') r=0;\n    else r=c-'0';\n  }\n  if(l>=n) return r;\n  if(c=='+'){\n    while(a[l].size()==v+1){\n      cc=a[l][v];\n      //cout<<cc<<endl;\n      if(l+1<n&&(cc=='+'||cc=='*')) r+=calc(v);\n      else {r+=cc-'0';l++;}\n      \n    }\n  }\n  else if(c=='*'){\n    while(a[l].size()==v+1){\n      cc=a[l][v];\n      if(l+1<n&&(cc=='+'||cc=='*')) r*=calc(v);\n      else {r*=cc-'0';l++;}\n      \n    }\n  }\n  //cout<<r<<endl;\n  return r;\n}\n\nint main(){\n  int i;\n  while(cin >> n,n){\n    string s;\n    a.clear();\n    for(i=0;i<n;i++){\n      cin >> s;\n      a.pb(s);\n    }\n    l=0;\n    cout << calc(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = int(b) - 1; i >= (int)(a); --i)\nusing pii = pair<int, int>;\nusing vi = vector<int>;\n\npair<char, int>parse(string s) {\n\tint level = 0;\n\twhile (s[level] == '.') {\n\t\tlevel++;\n\t}\n\treturn make_pair(s[level], level);\n}\n\nint dfs(vector<string>& v, int& idx) {\n\n\tchar c; int level;\n\ttie(c, level) = parse(v[idx]);\n\t//cerr << \"c:\" << c << \"level:\" << level << endl;\n\tif (isdigit(c)) {\n\t\treturn (int)c - '0';\n\t}\n\telse {\n\t\tint ret;\n\t\tif (c == '+') {\n\t\t\tret = 0;\n\t\t\twhile (idx + 1 < v.size() and parse(v[idx + 1]).second == level + 1) {\n\t\t\t\tidx++;\n\t\t\t\tret += dfs(v, idx);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tret = 1;\n\t\t\twhile (idx + 1 < v.size() and parse(v[idx + 1]).second == level + 1) {\n\t\t\t\tidx++;\n\t\t\t\tret *= dfs(v, idx);\n\t\t\t}\n\t\t}\n\t\t//cerr << \"c:\" << c << \",level:\" << level << \",ret:\" << ret << \",idx:\" << idx << endl;\n\n\t\treturn ret;\n\t}\n}\n\nvoid solve(int n) {\n\tvector<string>v(n);\n\trep(i, 0, n) {\n\t\tcin >> v[i];\n\t}\n\tint idx = 0;\n\tcout << dfs(v, idx) << endl;\n}\n\nsigned main() {\n\twhile (1) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tsolve(n);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing ll  = long long;\n#define int ll\n#define rep(i,n) for(int i=0;i<n;i++)\n#define erep(e,v) for(auto && e :v)\n#define all(in) in.begin(), in.end()\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\nvector<string>vs;\nauto Depeth(string s){int a=0; rep(i,s.size())if(s[i] != '.')break;else ++a;return a;}\nint cal(int idx){\n    int depeth = Depeth(vs[idx]);\n    char op = vs[idx][depeth];\n    if(op != '*' and op != '+'/*if idx is numeric */) return op - '0' ;\n    ++depeth;\n    int res = -1;\n    for(int i = idx + 1; i < vs.size();i++){\n        if(vs[i] == \"\")continue;\n        int kd = Depeth(vs[i]);\n        char key = vs[i][kd];\n        if(key == '+' or key == '*'){\n            if(kd+1 <= depeth) break;\n            res = (res  == -1 ? res = cal(i) : (op == '+' ? res += cal(i) : res *= cal(i)));\n        } else {\n            int val = key - '0';\n            if(depeth == kd){\n                if( op == '+')(res == -1 ? res = val : res += val);\n                else ( res == -1 ? res = val : res *= val);\n                vs[i] = \"\";\n            } else {\n                //WTF\n            }\n        }\n    }\n    vs[idx] = \"\";\n    return res;\n}\n\nsigned main(){\n    int n;\n    while(cin >> n,n){\n        vs = vector<string>(n);\n        for(auto && s : vs) cin >> s;\n        cout << cal(0LL) << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,j;\nvector<string> s;\n\nint dfs(int k,int f) {\n  int ans=f;\n  while(j<n&&k<s[j].size()) {\n    int x;j++;\n    if(isdigit(s[j-1][k])) x=s[j-1][k]-'0';\n    else x=dfs(k+1,s[j-1][k]=='*');\n    if(!f) ans+=x;\n    else ans*=x;\n  }\n  return ans;\n}\n\nint main() {\n  while(cin>>n&&n) {\n    s.clear();\n    for(int i=0;i<n;i++) {\n      string t;\n      cin >> t;\n      s.push_back(t);\n    }\n    j=0;\n    cout << dfs(0,0) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1000\n\nint calc(int a, int op, int b){\n  if(op == -1) return a + b;\n  return a * b;\n}\n\nbool isop(int c){\n  return c <= -1;\n}\n\nbool solve(){\n  int n;\n\n  scanf(\"%d\", &n);\n\n  if(n == 0) return false;\n\n  stack<pair<int,int> > st;\n  \n  for(int i=0;i<=n;i++){\n    char s[200];\n    int counter = 0;\n\n    if(i < n){\n      scanf(\"%s\", s);  \n      while(s[counter] == '.') counter++;\n    }else{\n      counter = 0;\n    }\n\n    //debug(s[counter]);\n    \n    vector<int> vec;\n    while(st.size() && (st.top().first > counter || (st.top().first == counter && isop(st.top().second) ))){\n      auto p = st.top(); st.pop();\n\n      if(isop(p.second)){\n        int res = vec[0];\n        for(int j=1;j<vec.size();j++) res = calc(res, p.second, vec[j]);\n        st.push({p.first, res});\n        vec = vector<int>();\n      }else{\n        vec.push_back(p.second);\n      }\n    }\n\n    if(s[counter] == '+')\n      st.push({counter, -1});\n    else if(s[counter] == '*')\n      st.push({counter, -2});\n    else\n      st.push({counter, s[counter]-'0'});\n  }\n\n  st.pop();\n  \n  printf(\"%d\\n\", st.top().second);\n\n  return true;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define FOR(i,n,m) for(ll i=n; i<(ll)m;i++)\n#define FORr(i,n,m) for(ll i=n; i>=(ll)m; i--)\n#define FORm(i,m) for(auto i=m.begin();i!=m.end();i++)\n#define VEC2(x,a,b) vector<vector<ll>> x = vector<vector<ll>>(a,vector<ll>(b,0))\n#define sortAl(v) sort(v.begin(),v.end())\n#define sortAlr(v) sort(v.begin(),v.end()); reverse(v.begin(),v.end())\n#define cinv(v,n,m) FOR(i,n,m) cin>>v.at(i)\n#define coutv(v,n,m) FOR(i,n,m) cout<<v.at(i) <<\" \"; cout<<endl\n#define cout(n) cout<<fixed<<setprecision(n)\n\nll p;\nll n;\nvector<string> v;\n\nll solve(ll k){\n\n  ll res=0;\n  if(0<=v[p][k]-'0' && v[p][k]-'0'<=9) return v[p][k]-'0';\n  else if(v[p][k]=='+'){\n    //cout<<\"plus\"<<endl;\n    res=0;\n    p++;\n    k++;\n    //cout<<n<<\" \"<<p<<endl;\n    while( v[p][k]=='.' ||v[p][k]=='+' ||v[p][k]=='*' ||(0<=v[p][k]-'0' && v[p][k]-'0'<=9 ) ){\n      res+=solve(k);\n      p++;\n    }\n  }\n  else if(v[p][k]=='*'){\n    //cout<<\"mult\"<<endl;\n    res=1;\n    p++;\n    k++;\n    while( v[p][k]=='.' ||v[p][k]=='+' ||v[p][k]=='*' ||(0<=v[p][k]-'0' && v[p][k]-'0'<=9 ) ){\n      res*=solve(k);\n      p++;\n    }\n  }\n  p--;\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin>>n;\n  while(n>0){\n    vector<string> s;\n    v=s;\n    FOR(i,0,n){\n      string sa;\n      cin>>sa;\n      v.push_back(sa);\n    }\n    v.push_back(\" \");\n    p=0;\n    cout<<solve(0)<<endl;\n\n    cin>>n;\n  }\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\ntemplate<class T> void vin(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n}\n\nint main() {\n    ll n;\n    while (cin >> n, n) {\n        vector<string> x(n+1);\n        stack<pair<string, ll>> st;\n        rep(i, n) {\n            cin >> x[i];\n        }\n        x[n] = \"x\";\n\n        rep(i, n+1) {\n            ll num = 0;\n            string tmp = \"\";\n\n            if (x[i] == \"x\") {\n                vector<pair<string, ll>> tp;\n\n                if (st.size() == 1) {\n                    cout << st.top().first << endl;\n                    break;\n                }\n\n                while (true) {\n                    auto cur = st.top(); st.pop();\n                    if (cur.first == \"+\" or cur.first == \"*\") {\n                        ll next = (cur.first == \"+\" ? 0 : 1);\n                        for (auto t : tp) {\n                            if (cur.first == \"+\") next += (stoll(t.first));\n                            else next *= (stoll(t.first));\n                        }\n                        pair<string, ll> now2(to_string(next), cur.second);\n                        tp.clear();\n\n                        if (st.size() == 0) {\n                            cout << next << endl;\n                            break;\n                        }\n\n                        st.push(now2);\n                    }\n                    else {\n                        tp.push_back(cur);\n                    }\n                }\n\n                break;\n            }\n\n            rep(j, x[i].size()) {\n                if (x[i][j] == '.') num++;\n                else tmp += x[i][j];\n            }\n            pair<string, ll> now(tmp, num);\n            if (st.size() and st.top().second > now.second) {\n                vector<pair<string, ll>> tp;\n                while (true) {\n                    auto cur = st.top(); st.pop();\n                    if (cur.first == \"+\" or cur.first == \"*\") {\n                        ll next = (cur.first == \"+\" ? 0 : 1);\n                        for (auto t : tp) {\n                            if (cur.first == \"+\") next += (stoll(t.first));\n                            else next *= (stoll(t.first));\n                        }\n                        pair<string, ll> now2(to_string(next), cur.second);\n                        st.push(now2);\n                        tp.clear();\n                        if (now2.second == now.second) break;\n                    }\n                    else {\n                        tp.push_back(cur);\n                    }\n                }\n            }\n            st.push(now);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\n    while(1){\n        int n; cin >> n;\n        if(!n) break;\n\n        vector<string> ss(n);\n        for(int i = 0; i < n; i++) cin >> ss[i];\n\n        int d = 0;\n        for(int i = 0; i < n; i++){\n            d = max(d, (int)ss[i].size() - 1);\n        }\n\n        vector<vector<int> > s(n);\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < (int)ss[i].size(); j++){\n                if(ss[i][j] == '.') s[i].push_back(-1);\n                else if(ss[i][j] == '+') s[i].push_back(-2);\n                else if(ss[i][j] == '*') s[i].push_back(-3);\n                else s[i].push_back((int)(ss[i][j] - '0')); \n            }\n        }\n\n        //cout << max_d << endl;\n\n        while(d > 0){\n\n            int state = 0;                  //0 := 何もしない  1 := 足し算をする  2 := 掛け算をする\n            int idx;\n            int res;\n            //d-1を見ていく\n            \n            for(int i = 0; i < n; i++){\n                \n                if(state == 0){\n                    if((int)s[i].size() < d) continue;\n                    else if(s[i][d - 1] == -2){\n                        state = 1;\n                        idx = i;\n                        res = 0;\n                    }else if(s[i][d - 1] == -3){\n                        state = 2;\n                        idx = i;\n                        res = 1;\n                    }\n                }else{\n\n                    if((int)s[i].size() < d){\n                        s[idx][d - 1] = res;\n                        state = 0;\n                    }else if(s[i][d - 1] == -1){\n                        //計算する\n                        if(s[i][d] == -1) continue;\n\n                        if(state == 1) res += s[i][d];\n                        else res *= s[i][d];\n                    }else if(s[i][d - 1] == -2){\n                        s[idx][d - 1] = res;\n                        state = 1;\n                        idx = i;\n                        res = 0;\n                    }else if(s[i][d - 1] == -3){\n                        s[idx][d - 1] = res;\n                        state = 2;\n                        idx = i;\n                        res = 1;\n                    }\n                }\n            }\n\n            if(state != 0){\n                s[idx][d - 1] = res;\n                state = 0;\n            }\n            d--;\n        }\n\n        /*for(int i = 0; i < n; i++){\n            cout << s[i] << endl;\n        }*/\n\n        cout << s[0][0] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nstruct node\n{\n\tvector<shared_ptr<node>>ch;\n\tchar c;\n\tint value()\n\t{\n\t\tif (ch.empty())\n\t\t{\n\t\t\treturn c - '0';\n\t\t}\n\t\tassert('*' == c || '+' == c);\n\t\tint s = 0;\n\t\tif (c == '*')s = 1;\n\t\tfor (auto n : ch)\n\t\t{\n\t\t\tif (c == '*')s *= n->value();\n\t\t\telse s += n->value();\n\t\t}\n\t\treturn s;\n\t}\n};\n\nint main(void)\n{\n\tint n = 0;\n\tint read = 0;\n\tfor (;;)\n\t{\n\t\tcin >> n;\n\t\tif (!n)break;\n\t\t{\n\t\t\tvector<shared_ptr<node>>las;\n\t\t\tfor (int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tstring str;\n\t\t\t\tcin >> str;\n\t\t\t\tint s = str.length();\n\t\t\t\tlas.resize(s - 1);\n\t\t\t\tlas.push_back(shared_ptr<node>(new node{ vector<shared_ptr<node>>(),str.back() }));\n\t\t\t\tif (s > 1)\n\t\t\t\t{\n\t\t\t\t\tlas[las.size() - 2]->ch.push_back(las.back());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << las[0]->value() << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<char, int> P;\n\nint idx, N;\n\nint solve(vector<P> &v)\n{\n  char c = v[idx].first, d = v[idx++].second;   \n  if (isdigit(c)) {\n    return c - '0';\n  } else {\n    int res = (c == '*');\n    while (idx < N && d < v[idx].second) {\n      if (c == '*') {\n         res *= solve(v);\n      } else {\n         res += solve(v);\n      }\n    }\n    return res;\n  }\n}\n\nint main()\n{\n  while (cin >> N, N) {\n    vector<P> v(N);\n    string s;\n    for (int i = 0; i < N; i++) {\n      cin >> s;\n      v[i] = P(s.back(), s.size()-1);\n    }\n    idx = 0;\n    cout << solve(v) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define LAST(vec) vec[vec.size() - 1]\nstring get_line() {\n  string line;\n  cin >> line;\n  return line;\n}\n// 整数: 一桁\nint main() {\n  while (true) {\n    auto line_num = stoi(get_line());\n    if (line_num == 0) return 0;\n    if (line_num == 1) {\n      cout << stoi(get_line()) << endl;\n      continue;\n    }\n    vector<int> stack;\n    vector<bool> is_adds;\n    auto calc = [&](int num) {\n      if (LAST(is_adds)) {\n        LAST(stack) += num;\n      } else {\n        LAST(stack) *= num;\n      }\n    };\n    auto reduction = [&](int n) {\n      REP(j, n) {\n        auto num = LAST(stack);\n        is_adds.pop_back();\n        stack.pop_back();\n        calc(num);\n      }\n    };\n\n    REP(i, line_num) {\n      auto line = get_line();\n      auto level = line.size() - 1;\n      // リダクション\n      if (level < stack.size()) {\n        auto n = stack.size() - level;\n        reduction(n);\n      }\n      // パース\n      auto chr = line[line.size() - 1];\n      if (chr == '+') {\n        stack.push_back(0);\n        is_adds.push_back(true);\n      } else if (chr == '*') {\n        stack.push_back(1);\n        is_adds.push_back(false);\n      } else {\n        calc(chr - '0');\n      }\n    }\n    if (stack.size() > 1) {\n      reduction(stack.size() - 1);\n    }\n    cout << LAST(stack) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cctype>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef long long ll;\n\nint N;\nint pos;\nvector<int> level;\nvector<string> S;\n\nll compute() {\n  int L = level[pos];\n  char c = S[pos][level[pos]];\n  ++pos;\n  if(isdigit(c)) return c - '0';\n  else if(c == '+') {\n    ll ret = 0;\n    while(pos < N && level[pos] == L + 1) {\n      ret += compute();\n    }\n    return ret;\n  }\n  else {\n    ll ret = 1;\n    while(pos < N && level[pos] == L + 1) {\n      ret *= compute();\n    }\n    return ret;\n  }\n}\n\nint main() {\n  while(true) {\n    cin >> N;\n    if(N == 0) break;\n    level = vector<int>(N);\n    S = vector<string>(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> S[i];\n      level[i] = S[i].size() - 1;\n    }\n    pos = 0;\n    cout << compute() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define FOR(i,n,m) for(ll i=n; i<(ll)m;i++)\n#define FORr(i,n,m) for(ll i=n; i>=(ll)m; i--)\n#define FORm(i,m) for(auto i=m.begin();i!=m.end();i++)\n#define VEC2(x,a,b) vector<vector<ll>> x = vector<vector<ll>>(a,vector<ll>(b,0))\n#define sortAl(v) sort(v.begin(),v.end())\n#define sortAlr(v) sort(v.begin(),v.end()); reverse(v.begin(),v.end())\n#define cinv(v,n,m) FOR(i,n,m) cin>>v.at(i)\n#define coutv(v,n,m) FOR(i,n,m) cout<<v.at(i) <<\" \"; cout<<endl\n#define cout(n) cout<<fixed<<setprecision(n)\n\nll p;\nll n;\nchar c[100];\nvector<string> v(200);\n\nll solve(ll k){\n\n  ll res=0;\n  if(0<=v[p][k]-'0' && v[p][k]-'0'<=9) return v[p][k]-'0';\n  else if(v[p][k]=='+'){\n    //cout<<\"plus\"<<endl;\n    res=0;\n    p++;\n    k++;\n    //cout<<n<<\" \"<<p<<endl;\n    while( v[p][k]=='.' ||v[p][k]=='+' ||v[p][k]=='*' ||(0<=v[p][k]-'0' && v[p][k]-'0'<=9 ) ){\n      res+=solve(k);\n      p++;\n    }\n  }\n  else if(v[p][k]=='*'){\n    //cout<<\"mult\"<<endl;\n    res=1;\n    p++;\n    k++;\n    while( v[p][k]=='.' ||v[p][k]=='+' ||v[p][k]=='*' ||(0<=v[p][k]-'0' && v[p][k]-'0'<=9 ) ){\n      res*=solve(k);\n      p++;\n    }\n  }\n  p--;\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin>>n;\n  while(n>0){\n    vector<string> s(200);\n    v=s;\n    FOR(i,0,n){\n      cin>>v[i];\n    }\n    p=0;\n    cout<<solve(0)<<endl;\n    cin>>n;\n  }\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint get(int scount, string *s, int &now, int deep = 0) {\n\tchar c = s[now++][deep++];\n\tint temp = c == '+' ? 0 : 1;\n\twhile (now < scount) {\n\t\tif (s[now].size() <= deep) return temp;\n\t\telse if ('0' <= s[now][deep] && s[now][deep] <= '9') {\n\t\t\tif (c == '+') temp += s[now++][deep] - '0';\n\t\t\telse temp *= s[now++][deep] - '0';\n\t\t}\n\t\telse {\n\t\t\tif (c == '+') temp += get(scount, s, now, deep);\n\t\t\telse temp *= get(scount, s, now, deep);\n\t\t}\n\t}\n\treturn temp;\n}\nint main() {\n\tint i;\n\twhile(cin >> i && i != 0) {\n\t\tstring *s = new string[i];\n\t\tfor (int j = 0; j < i; j++) cin >> s[j];\n\t\tint t = 0;\n\t\tif (i != 1) cout << get(i, s, t) << endl;\n\t\telse cout << s[0][0] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s[100];\nint n,j,i;\nint dfs(int p){\n\n  int res=0,o=s[j].size();\n\n  if(isdigit(s[j][p]))return s[j][p]-'0';\n\n  if(s[j][p]=='+')\n    while(s[j+1].size()>o)j++,res+=dfs(p+1);\n\n  else{\n    res=1;\n    while(s[j+1].size()>o)j++,res*=dfs(p+1);\n  }\n\n  return res;\n}\nint main(){\n  while(cin>>n,n){\n\n    for(j=i=0;i<100;i++)s[i]=\"\";\n    for(i=0;i<n;i++)cin>>s[i];\n\n    cout<<dfs(0)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n\nusing namespace std;\n\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//四捨五入\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り上げ\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define SUM_P(v, w) partial_sum((v).begin(), (v).end(), (w).begin())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define FOUT_L(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n        T d = EXTGCD(-a, b, x, y);\n        x = -x;\n        return d;\n    }\n    if (b < 0) {\n        T d = EXTGCD(a, -b, x, y);\n        y = -y;\n        return d;\n    }\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    } else {\n        T d = EXTGCD(b, a % b, x, y);\n        T t = x;\n        x = y;\n        y = t - (a / b) * y;\n        return d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T) (SQR(i)) < b; i++) {\n        if (small[i]) {\n            for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n                prime[j - a] = false;\n            }\n        }\n    }\n\n    return prime;\n}\n\n//約数\ntemplate<class T>\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//組み合わせ個数\ntemplate<typename T>\nT NCR(T n, T r) {\n    T ans = 1;\n    REPLL(i, r) {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//行列\nint MATRIZ_CHAIN(VI &p, VVI &s) {\n    const static int INF = 1 << 20;\n    const int n = p.size() - 1;\n    VVI X(n, VI(n, INF));\n    s.resize(n, VI(n));\n    for (int i = 0; i < n; ++i) X[i][i] = 0;\n    for (int w = 1; w < n; ++w)\n        for (int i = 0, j; j = i + w, j < n; ++i)\n            for (int k = i; k < j; ++k) {\n                int f = p[i] * p[k + 1] * p[j + 1];\n                if (X[i][k] + X[k + 1][j] + f < X[i][j]) {\n                    X[i][j] = X[i][k] + X[k + 1][j] + f;\n                    s[i][j] = k;\n                }\n            }\n    return X[0][n - 1];\n}\n\n//最長増加部分列\nVI LIS(const VI &a) {\n    const static int INF = 99999999;\n    const int n = a.size();\n    VI A(n, INF);\n    VI id(n);\n    for (int i = 0; i < n; ++i) {\n        id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n        A[id[i]] = a[i];\n    }\n    int m = *max_element(id.begin(), id.end());\n    VI b(m + 1);\n    for (int i = n - 1; i >= 0; --i)\n        if (id[i] == m) b[m--] = a[i];\n    return b;\n}\n\n//最長共通部分列 string->toVC\ntemplate<typename T>\nvector<T> LCS(const vector<T> &a, const vector<T> &b) {\n    const int n = a.size(), m = b.size();\n    vector<VI> X(n + 1, VI(m + 1));\n    vector<VI> Y(n + 1, VI(m + 1));\n    REP(i, n) {\n        REP(j, m) {\n            if (a[i] == b[j]) {\n                X[i + 1][j + 1] = X[i][j] + 1;\n                Y[i + 1][j + 1] = 0;\n            } else if (X[i + 1][j] < X[i][j + 1]) {\n                X[i + 1][j + 1] = X[i][j + 1];\n                Y[i + 1][j + 1] = +1;\n            } else {\n                X[i + 1][j + 1] = X[i + 1][j];\n                Y[i + 1][j + 1] = -1;\n            }\n        }\n    }\n    vector<T> c;\n    for (int i = n, j = m; i > 0 && j > 0;) {\n        if (Y[i][j] > 0) --i;\n        else if (Y[i][j] < 0) --j;\n        else {\n            c.PB(a[i - 1]);\n            --i;\n            --j;\n        }\n    }\n    REVERSE(c);\n    return c;\n}\n\n//コイン C総額 cs使用できるコインの種類\nVI money_change(int C, VI &cs) {\n    const int INF = 99999999;\n    int n = cs.size();\n    VI xs(C + 1, INF);\n    VI ys(C + 1);\n    xs[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int c = 0; c + cs[i] <= C; ++c) {\n            if (xs[c + cs[i]] > xs[c] + 1) {\n                xs[c + cs[i]] = xs[c] + 1;\n                ys[c + cs[i]] = c;\n            }\n        }\n    }\n    VI zs;\n    for (int c = C; c > 0; c = ys[c]) {\n        zs.push_back(c - ys[c]);\n    }\n    return zs;\n}\n\n\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(a, b) memset((a), (b),sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n * */\n\nint add(int& index, int N, int par, vector<pair<int, char>> P);\n\nint mul(int& index, int N, int par, vector<pair<int, char>> P);\n\nint add(int& index, int N, int par, vector<pair<int, char>> P) {\n    int ret = 0;\n    while (index < N) {\n        if (P[index].first <= par) {\n            break;\n        } else if (P[index].second == '+') {\n            index++;\n            ret += add(index, N, P[index - 1].first, P);\n        } else if (P[index].second == '*') {\n            index++;\n            ret += mul(index, N, P[index - 1].first, P);\n        } else {\n            ret += P[index].second - '0';\n            index++;\n        }\n    }\n\n    return ret;\n}\n\nint mul(int& index, int N, int par, vector<pair<int, char>> P) {\n    int ret = 1;\n    while (index < N) {\n        if(P[index].first <=par){\n            break;\n        }else if(P[index].second == '+'){\n            index++;\n            ret *= add(index, N, P[index-1].first, P);\n        }else if(P[index].second =='*'){\n            index++;\n            ret *= mul(index, N, P[index-1].first, P);\n        }else{\n            ret *= P[index].second -'0';\n            index++;\n        }\n    }\n\n    return ret;\n\n}\n\nint main() {\n\n    int N;\n\n\n    while (true) {\n        cin >> N;\n\n        VS S(N);\n        vector<pair<int, char>> P(N);\n\n        if (N == 0) {\n            break;\n        }\n\n        REP(i, N) {\n            cin >> S[i];\n            P[i].first = 0;\n        }\n        REP(i, N) {\n            REP(j, S[i].size()) {\n                if (S[i][j] == '.') {\n                    P[i].first++;\n                } else {\n                    P[i].second = S[i][j];\n                }\n            }\n        }\n\n\n        if (N == 1) {\n            OUT_L(P[0].first);\n            continue;\n        }\n\n        int res;\n        if (P[0].second == '+') {\n            int start = 1;\n            res = add(start, N, 0, P);\n        } else {\n            int start = 1;\n            res = mul(start, N, 0, P);\n        }\n\n        OUT_L(res);\n\n    }\n\n\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint n;\nvector< pair<int, int> > input;\n\nint dfs(int* p) {\n  int t = input[*p].first + 1;\n  char e = (char) input[*p].second;\n  int ans = e == '+' ? 0 : e == '*' ? 1 : e;\n  for((*p)++; input[*p].first >= t && *p < n;) if(e == '+') ans += dfs(p); else ans *= dfs(p);\n  return ans;\n}\n\nint main(void) {\n  while(cin >> n, n != 0) {\n    input.clear();\n    REP(i, 0, n) {\n      string line; cin >> line;\n      int level = 0;\n      for(; line[level] == '.'; level++);\n      input.push_back(pair<int, int>(level, line[level] == '+' || line[level] == '*' ? line[level] : line[level] - '0'));\n    }\n    int i = 0;\n    cout << dfs(&i) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n#define rep(i,n) for(int i = 0;i < (n) ;i++)\n\nint n;\nvector<string> s;\nint r;\n\nint rec(int c) {\n    const char o = s[r++][c];\n    if('0' <= o && o <= '9') return o-'0';\n    int ret = (o == '+' ? 0 : 1);\n    while(true) {\n        if (r >= n || c+1 >= (int)s[r].size()) break;\n        int res = rec(c+1);\n        if (o == '+') ret += res;\n        else ret *= res;\n    }\n    return ret;\n}\n\nsigned main (void) {\n    while(true) {\n        cin >> n;\n        if (n == 0) break;\n        s.clear();\n        rep(i,n) {\n            string tmp;\n            cin >> tmp;\n            s.push_back(tmp);\n        }\n        r = 0;\n        cout << rec(0) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nint add(vector<string>::iterator &itr);\nint mlt(vector<string>::iterator &itr);\n\nint main(){\n    while(true){\n        int n; cin >> n;\n        if( n == 0)break;\n        vector<string> s(n);\n        for(int i = 0; i < n; i++){\n            cin >> s[i];\n        }\n        int ans = 0;\n        for(vector<string>::iterator itr = s.begin(); itr != s.end(); ++itr){\n            if((itr->back()) == '+'){\n                ans += add(itr);\n            }\n            else if((itr->back()) == '*'){\n                ans += mlt(itr);\n            }\n            else{\n                ans += itr->back() - '0';\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\nint add(vector<string>::iterator &itr){\n    int c = itr->size()+1;\n    int ret = 0;\n    ++itr;\n    while((int)(itr->size()) == c){\n        if(itr->back() == '+'){\n            ret += add(itr);\n        }\n        else if((itr->back()) == '*'){\n            ret += mlt(itr);\n        }\n        else{\n            ret += itr->back() -'0';\n        }\n        ++itr;\n    }\n        \n    --itr;\n    return ret;\n}\n\nint mlt(vector<string>::iterator &itr){\n    int c = itr->size()+1;\n    int ret = 1;\n    ++itr;\n    while((int)(itr->size()) == c){\n        if(itr->back() == '+'){\n            ret *= add(itr);\n        }\n        else if((char)(itr->back()) == '*'){\n            ret *= mlt(itr);\n        }\n        else{\n            ret *= itr->back() - '0';\n        }\n        ++itr;\n    }\n    --itr;\n    return ret;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<climits>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nvoid solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        st.push(make_pair(th, l-1));\n    }\n}\nint main(){\n    int ca=0;\n    while(cin>>n,n){\n        while(ope.size())ope.pop();\n        while(st.size())st.pop();\n        if(ca++>99)return -1;\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    solve(level);\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        solve(0);\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(void) {\n    while (1) {\n\n        int n;\n        cin >> n;\n        if (n == 0) break;\n\n        string formula[n];\n        int formulalen[n];\n        for (int i = 0; i < n; ++i) {\n            cin >> formula[i];\n            formulalen[i] = formula[i].length();\n        }\n\n        while (1) {\n\n            if (formulalen[0] == 1 && formula[0] != \"+\" && formula[0] != \"*\") { // 終了条件\n                cout << formula[0] << endl;\n                break;\n            }\n\n            int maxlen = 0;\n            for (int i = 0; i < n; ++i) {\n                maxlen = max(maxlen, formulalen[i]);\n            }\n\n            bool opefind = false;\n            long long result = 0;\n            string ope;\n            int pos = 0;\n            int maxcnt = 0;\n            for (int i = 0; i < n; ++i) {\n                if (formulalen[i] == maxlen) {\n                    if (!opefind) {\n                        ope = formula[i - 1].substr(formulalen[i - 1] - 1, 1);\n                        result = stoi(formula[i].substr(formulalen[i] - 1));\n                        opefind = true;\n                        pos = i - 1;\n                        maxcnt += 1;\n                    } else {\n                        if (ope == \"+\") {\n                            result += stoi(formula[i].substr(formulalen[i] - 1));\n                        } else if (ope == \"*\") {\n                            result *= stoi(formula[i].substr(formulalen[i] - 1));\n                        }\n                        maxcnt += 1;\n                    }\n                    if (i + 1 != n) {\n                        if (formulalen[i + 1] != maxlen) {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            string replaceformula = \"\";\n            for (int i = 0; i < maxlen - 2; ++i) {\n                replaceformula += \".\";\n            }\n            replaceformula += to_string(result);\n\n            n -= maxcnt;\n            formula[pos] = replaceformula;\n            for (int i = pos + 1; i < n; ++i) {\n                formula[i] = formula[i + maxcnt];\n                formulalen[i] = formulalen[i + maxcnt];\n            }\n\n//            printf(\"%d %d\\n\", pos + 1, maxcnt);\n//            for (int i = 0; i < n; ++i) {\n//                cout << formula[i] << \" \" << formulalen[i] << endl;\n//            }\n        }\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n\nusing namespace std;\n\n\nint add(vector<string>::iterator &itr);\nint mlt(vector<string>::iterator &itr);\n\nint main(){\n    while(true){\n        int n; cin >> n;\n        if( n == 0)break;\n        vector<string> s(n);\n        for(int i = 0; i < n; i++){\n            cin >> s[i];\n        }\n        int ans = 0;\n        for(auto itr = s.begin(); itr != s.end(); ++itr){\n            if(itr->back() == '+'){\n                ans += add(itr);\n            }\n            else if(itr->back() == '*'){\n                ans += mlt(itr);\n            }\n            else{\n                ans += itr->back() - '0';\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\nint add(vector<string>::iterator &itr){\n    int c = itr->size()+1;\n    int ret = 0;\n    ++itr;\n    while(itr->size() == c){\n        if(itr->back() == '+'){\n            ret += add(itr);\n        }\n        else if(itr->back() == '*'){\n            ret += mlt(itr);\n        }\n        else{\n            ret += itr->back() -'0';\n        }\n        ++itr;\n    }\n        \n    --itr;\n    return ret;\n}\n\nint mlt(vector<string>::iterator &itr){\n    int c = itr->size();\n    int ret = 1;\n    ++itr;\n    while(itr->size() == c+1){\n        if(itr->back() == '+'){\n            ret *= add(itr);\n        }\n        else if(itr->back() == '*'){\n            ret *= mlt(itr);\n        }\n        else{\n            ret *= itr->back() - '0';\n        }\n        ++itr;\n    }\n    --itr;\n    return ret;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <limits>\n#include <fstream>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nstring s[100];\nint N;\nint rec(int& idx, int dep){\n  if(isdigit(s[idx][dep])) return s[idx++][dep]-'0';\n  else if(s[idx++][dep]=='+'){\n    int ret = 0;\n    while(s[idx].length()==dep+2) ret += rec(idx, dep+1);\n    return ret;\n  }\n  else {\n    int ret = 1;\n    while(s[idx].length()==dep+2) ret *= rec(idx, dep+1);\n    return ret;\n  }\n}\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  while(cin>>N&&N){\n    FOR(i,0,N){\n      cin>>s[i];\n    }\n    s[N]=\"\";\n    int idx = 0;\n    cout<<rec(idx,0)<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\n\nint main(){\n  int n;\n  while(1){\n    stack<int> statsmemo,pointmemo;\n    cin>>n;\n    if(n==0) break;\n    int now=1,stats=-1,point=0;\n    int count=0;\n    lp(z,n){\n      count=0;\n      char q;\n      while(1){\n\tcin>>q;\n\tcount++;\n\tif(q!='.') break;\n      }\n      if(count<now){\n\twhile(count!=now){\n\t  int statsed,pointed;\n\t  statsed=statsmemo.top();\n\t  pointed=pointmemo.top();\n\t  statsmemo.pop();\n\t  pointmemo.pop();\n\t  if(statsed==0){\n\t    point+=pointed;\n\t  }\n\t  if(statsed==1){\n\t    if(point==0){\n\t      point+=pointed;\n\t    }\n\t    else point*=pointed;\n\t  }\n\t  stats=statsed;\n\t  now--;\n\t}\n\tnow=count;\n      }\n      if(q=='+'){\n\tif(stats!=-1){\n\t  statsmemo.push(stats);\n\t  pointmemo.push(point);\n\t}\n\tstats=0;\n\tpoint=0;\n\tnow++;\n      }\n      if(q=='*'){\n\tif(stats!=-1){\n\t  statsmemo.push(stats);\n\t  pointmemo.push(point);\n\t}\n\tstats=1;\n\tpoint=0;\n\tnow++;\n      }\n      if('0'<=q && q<='9'){\n\tif(stats==0) point+=q-'0';\n\tif(stats==1){\n\t  if(point==0) point+=q-'0';\n\t  else point*=q-'0';\n\t}\n\tif(stats==-1) point+=q-'0';\n      }\n    }\n    while(count>2){\n      int statsed,pointed;\n      statsed=statsmemo.top();\n      pointed=pointmemo.top();\n      statsmemo.pop();\n      pointmemo.pop();\n      if(statsed==0){\n\tpoint+=pointed;\n      }\n      if(statsed==1){\n\tif(point==0){\n\t  point+=pointed;\n\t}\n\telse point*=pointed;\n      }\n      stats=statsed;\n      count--;\n    }\n    cout<<point<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi acos(-1.0)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint calc(vector<string> s, int &i){\n\tint depth = s[i].length(), n = s.size();\n\tchar c = s[i][depth-1];\n\tif (c == '+'){\n\t\tint res = 0;\n\t\ti++;\n\t\twhile (s[i].length() == depth+1 && i < n){\n\t\t\tres += calc(s, i);\n\t\t\ti++;\n\t\t}\n\t\ti--;\n\t\treturn res;\n\t}else if (c == '*'){\n\t\tint res = 1;\n\t\twhile (s[++i].length() == depth+1 && i < n){\n\t\t\tres *= calc(s, i);\n\t\t}\n\t\ti--;\n\t\treturn res;\n\t}else{\n\t\treturn c - '0';\n\t}\n}\n\nint main(){\n\tint n;\n\twhile (cin >> n && n){\n\t\tvector<string> s(n);\n\t\tREP(i,n) cin >> s[i];\n\t\tint i = 0;\n\t\tcout << calc(s, i) << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cctype>\n#include<numeric>\nusing namespace std;\n\nint n, pos;\nvector<string> v;\n\nint f(int d){\n    if(isdigit(v[pos].back())){\n        int ret =  v[pos].back()-'0';\n        pos++;\n        return ret;\n    }else{\n        char op = v[pos].back();\n        pos++;\n        vector<int> child;\n        while(pos < n && v[pos].length() == d+1){\n            child.push_back(f(d+1));\n        }\n        if(op == '+'){\n            return accumulate(child.begin(), child.end(), 0);\n        }else{\n            int ret = 1;\n            for(int x : child)  ret *= x;\n            return ret;\n        }\n    }\n}\n\nint main(){\n    while(cin >> n, n){\n        v.clear();\n        v.resize(n);\n        for(int i = 0; i < n; i++)  cin >> v[i];\n        pos = 0;\n        cout << f(1) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint n; char s[20][20];\nint solve(int l, int r, int d) {\n\tif (r - l == 1) return s[l][d] - 48;\n\tint ret = (s[l][d] == '+' ? 0 : 1);\n\tint prev = -1;\n\tfor (int i = l + 1; i < r; i++) {\n\t\tif (s[i][d + 1] != '.') {\n\t\t\tif (prev != -1) ret = (s[l][d] == '+' ? ret + solve(prev, i, d + 1) : ret * solve(prev, i, d + 1));\n\t\t\tprev = i;\n\t\t}\n\t}\n\treturn (s[l][d] == '+' ? ret + solve(prev, r, d + 1) : ret * solve(prev, r, d + 1));\n}\nint main() {\n\twhile (scanf(\"%d\", &n), n) {\n\t\tfor (int i = 0; i < n; i++) scanf(\"%s\", s[i]);\n\t\tprintf(\"%d\\n\", solve(0, n, 0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  static auto add = [](int a, int b) { return a + b; };\n  static auto mul = [](int a, int b) { return a * b; };\n  int n;\n  while (cin >> n, n) {\n    vector<pair<function<int(int, int)>, int>> v;\n    v.push_back(make_pair(add, 0));\n    for (int i = 0; i < n; i++) {\n      string s;\n      cin >> s;\n      int d = s.size() - 1;\n      char c = *s.rbegin();\n      if (c == '+') {\n        v.push_back(make_pair(add, 0));\n      } else if (c == '*') {\n        v.push_back(make_pair(mul, 1));\n      } else {\n        while (d < v.size() - 1) {\n          int r = v.back().second;\n          v.pop_back();\n          v.rbegin()->second = v.rbegin()->first(v.rbegin()->second, r);\n        }\n        v.rbegin()->second = v.rbegin()->first(v.rbegin()->second, c - '0');\n      }\n    }\n    while (v.size() > 1) {\n      int r = v.back().second;\n      v.pop_back();\n      v.rbegin()->second = v.rbegin()->first(v.rbegin()->second, r);\n    }\n    cout << v.front().second << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    while(1) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n\n        vector<char> ope(n);\n        vector<vector<int>> num(n);\n\n        int cnt = 0;\n        int pre_cnt = 0;\n        for (int i = 0; i < n; i++){\n\n            string s;\n            cin >> s;\n            cnt = 0;\n            int k = (int)s.size();\n\n            for (int j = 0; j < k; j++) {\n                if (s[j] == '.') cnt++;\n                else {\n                    if (pre_cnt > cnt){\n                        for (int p = n - 1; p > cnt; p--){\n                            if (num[p].size() == 0) continue;\n                            int tmp = num[p][0];\n                            for (int q = 1; q < num[p].size(); q++){\n                                if (ope[p-1] == '*') tmp *= num[p][q];\n                                else tmp += num[p][q];\n                            }\n                            num[p].clear();\n                            num[p-1].push_back(tmp);\n                        }\n                    }\n\n                    if (s[j] == '+' || s[j] == '*'){\n                        ope[cnt] = s[j];\n                    }\n                    else num[cnt].push_back(s[j] - '0');\n                }\n            }\n\n            pre_cnt = cnt;\n        }\n\n        for (int i = n - 1; i > 0; i--){\n            if (num[i].size() == 0) continue;\n            int tmp = num[i][0];\n            for (int j = 1; j < num[i].size(); j++){\n                if (ope[i-1] == '*') tmp *= num[i][j];\n                else tmp += num[i][j];\n            }\n            num[i-1].push_back(tmp);\n        }\n        cout << num[0][0] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<climits>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nvoid solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        st.push(make_pair(th, l-1));\n    }\n}\nint main(){\n    int ca=0;\n    while(cin>>n,n){\n        while(ope.size())ope.pop();\n        while(st.size())st.pop();\n        if(ca++>10)return -1;\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    solve(level);\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        solve(0);\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FOREQ(i, a, b) for (int i = (a); i <= (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPEQ(i, n) FOREQ(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n\ntemplate <typename T> inline int size(const T& x) { return x.size(); }\n\npair<int, int> calculate(const vector<string>& lines, int index, int level) {\n    if (level >= size(lines[index]))\n        return make_pair(-1, index);\n\n    char ch = lines[index][level];\n    if ('0' <= ch && ch <= '9')\n        return make_pair(ch - '0', index+1);\n\n    assert(ch == '+' || ch == '*');\n\n    int ret_value = (ch == '+') ? 0 : 1;\n    int ret_index = index+1;\n    for (;;) {\n        auto x = calculate(lines, ret_index, level+1);\n        if (x.first == -1)\n            break;\n        ret_value = (ch == '+') ? (ret_value + x.first) : (ret_value * x.first);\n        ret_index = x.second;\n    }\n    return make_pair(ret_value, ret_index);\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int n;\n    while (cin >> n, n) {\n        vector<string> lines(n+1);\n        REP(i, n) cin >> lines[i];\n\n        cout << calculate(lines, 0, 0).first << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nll n;\n\nll dfs(ll line,ll level,vector<string> form){\n  //dbg(line); dbg(level);\n  if(isdigit(form[line][level]))return (ll)(form[line][level]-'0');\n  char op=form[line][level];\n  ll res=(op=='*'?1:0);\n  repl(i,line+1,n){\n    if(form[i][level]!='.')break;\n    if(form[i][level+1]=='.')continue;\n    ll tmp=dfs(i,level+1,form);\n    res=(op=='*'?res*tmp:res+tmp);\n  }\n  return res;\n}\n\nint main(){\n\t//cin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    vector<string> form;\n    rep(i,n){\n      string s;\n      cin>>s;\n      form.pb(s);\n    }\n    cout<<dfs(0,0,form)<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nint main()\n{\n    int n;\n    while(cin >>n,n)\n    {\n        int max_level=0;\n\n        vector<pi> a(n);\n        rep(i,n)\n        {\n            string s;\n            cin >>s;\n\n            int S=s.size();\n\n            int level=S-1;\n\n            int num=s[S-1]-'0';\n            if(s[S-1]=='+') num=-1;\n            if(s[S-1]=='*') num=-2;\n\n            a[i]=pi(level,num);\n            max_level=max(max_level,level);\n        }\n\n        for(int i=max_level-1; i>=0; --i)\n        {\n            vector<pi> nx;\n\n            int now=0;\n            int A=a.size();\n            while(now<A)\n            {\n                if(a[now].se<0 && a[now].fi==i)\n                {\n                    bool add=true;\n                    int val=0;\n                    if(a[now].se==-2)\n                    {\n                        add=false;\n                        val=1;\n                    }\n\n                    ++now;\n                    while(now<A && a[now].fi==i+1)\n                    {\n                        if(add) val+=a[now].se;\n                        else val*=a[now].se;\n                        ++now;\n                    }\n\n                    nx.pb(pi(i,val));\n                }\n                else nx.pb(a[now++]);\n            }\n\n            a=nx;\n        }\n\n        cout << a[0].se << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n; i++)\nusing namespace std;\nint n;\nvector<string> v;\nint count(int line){\n  int res = 0;\n  int i = 0;\n  while(v[line][i++]=='.') res++;\n  return res;\n}\nint calc(int& line,int depth){\n  if(v[line][depth]=='+'){\n    int ret=0;\n    line++;\n    while(line<n && count(line)==depth+1){\n      ret += calc(line,depth+1);\n    }\n    return ret;\n  }\n  else if(v[line][depth]=='*'){\n    int ret=1;\n    line++;\n    while(line<n && count(line)==depth+1){\n      ret *= calc(line,depth+1);\n    }\n    return ret;\n  }\n  else return v[line++][depth]-'0';\n}\nint solve(){\n    int line = 0;\n    int ans = calc(line,0);\n    return ans;\n}\nint main(){\n  while(cin >> n,n){\n    v.resize(n);\n    rep(i,n) cin >> v[i];\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\nusing namespace std;\nstruct P{\n\tint num, lev;\n};\n\nint n;\nstring s[30];\n\nint main() {\n\n\twhile (true) {\n\n\t\tcin >> n;\n\t\tif (!n)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> s[i];\n\t\t}\n\n\t\tstack<char> ch;\n\t\tstack<P> num;\n\t\tfor (int i = 0; i <= n; i++) {\n\n\t\t\t//cout << \"i:\" << i << endl;\n\t\t\tif (n == i && ch.size() == 0)break;\n\n\t\t\tif (ch.size() >= s[i].size() || n == i) {//レベルが低かったら\n\t\t\t\t//cout << \"a\" << endl;\n\t\t\t\tint x;\n\n\t\t\t\tchar ope = ch.top();\n\t\t\t\tif (ope == '+')x = 0;\n\t\t\t\telse x = 1;\n\n\t\t\t\twhile (!num.empty()) {\n\t\t\t\t\tP p = num.top();\n\t\t\t\t\tif (p.lev < ch.size())break;\n\t\t\t\t\tnum.pop();\n\n\t\t\t\t\tif (ope == '+') {\n\t\t\t\t\t\tx += p.num;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tx *= p.num;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tch.pop();\n\t\t\t\tnum.push(P{ x, (int)ch.size() });\n\t\t\t\ti--;\n\t\t\t\t//cout << \"  x:\" << x << endl;\n\t\t\t}\n\t\t\telse {//同じか高い場合\n\t\t\t\t//cout << \"b\" << endl;\n\t\t\t\tif (s[i][s[i].size() - 1] == '+' || s[i][s[i].size() - 1] == '*') {//演算子の場合\n\t\t\t\t\tch.push(s[i][s[i].size() - 1]);\n\t\t\t\t}\n\t\t\t\telse {//数値の場合\n\t\t\t\t\tnum.push(P{ (int)(s[i][s[i].size() - 1] - '0'), (int)ch.size() });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << num.top().num << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <algorithm>\n#include <math.h>\n\nusing namespace std;\nint a, result;\nint level, calc;\nstring w;\nint i, j;\nbool f;\n\nint times(int level,string w0);\nint sum(int level,string w0){\n    int buffer=0;\n    w=w0;\n    while(1){\n    \n    int k=0;\n        while(w[k] == '.'){\n        k++;\n        }\n    if(k == level){\n    if(w[k]=='+'){\n    cin>>w;\n    i++;\n    //cout<<buffer<<\"  \"<<level<<endl;\n    buffer+=sum(level+1,w);\n    if(i==a-1){return buffer;}\n    }\n    else if(w[k]=='*'){\n    cin>>w;\n    i++;\n    //cout<<buffer<<\"  \"<<level<<endl;\n    buffer+=times(level+1,w);\n    if(i==a-1){return buffer;}\n    }\n    else if(w[k] != '+' ||w[k] != '*'|| w[k] !='.' ){buffer += (w[k]-'0');\n    i++;\n    //cout<<i<<endl;\n    if(i==a-1){return buffer;}\n    cin >> w;\n    }\n    } \n    else break;\n    \n    \n    }\n    return buffer;\n}\nint times(int level,string w0){\n    int buffer=1;\n    w=w0;\n    while(1){\n    \n    int k=0;\n        while(w[k] == '.'){\n        k++;\n        }\n    if(k == level){\n    if(w[k]=='+'){\n    cin>>w;\n    i++;\n    //cout<<buffer<<\"  \"<<level<<endl;\n    buffer*=sum(level+1,w);\n    if(i==a-1){return buffer;}\n    }\n    else if(w[k]=='*'){\n    cin>>w;\n    i++;\n    //cout<<buffer<<\"  \"<<level<<endl;\n    buffer*=times(level+1,w);\n    if(i==a-1){return buffer;}\n    }\n    else if(w[k] != '+' ||w[k] != '*'|| w[k] !='.' ){buffer *= (w[k]-'0');\n    i++;\n    //cout<<i<<endl;\n    if(i==a-1){return buffer;}\n    cin >> w;\n    }\n    } \n    else break;\n    \n    \n    }\n    return buffer;\n}\n\n\n        \n    \n    \n\nint main()\n{\n    while(1){\n    cin >> a;\n    if(a==0)return 0;\n    result=0;\n    i = 0;\n    cin>>w;\n    if(a==1){\n    result = w[0]-'0';\n    //cout<<\"inta\"<<endl;\n    }\n    if(w == \"+\") {\n        cin>>w;\n        //cout<<\"sum\"<<endl;\n        result=sum(1,w);}\n    if(w == \"*\") {\n        cin>>w;\n        //cout<<\"tiim\"<<endl;\n        result=times(1,w);}\n    \n    cout << result << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<numeric>\n#include<map>\n#include<limits>\nusing namespace std;\n\n#define R(i,s,n) for(int i=s;i<n;i++)\n#define D(i,n,s) for(int i=n-1;i>=s;i--)\ntypedef pair<int,int> P;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nconst int MAX_N = 17;\n\nvector< vector<string> > str;\nint n,num,opr;  //、計算値格納用\nP ope;\n\nvoid solve();\n\nint main() {\n\n  while(cin>>n && n) {\n    str.resize(n);\n    string tmp = \"\";\n    ope = P(0,0);\n    R(i,0,n) {\n      cin>>tmp;\n      str[i].resize(tmp.size());\n      R(j,0,tmp.size()) str[i][j] = tmp[j];\n      if(tmp.size() > ope.second && (tmp[tmp.size()-1] == '+' || tmp[tmp.size()-1] == '*')) ope = P(i,tmp.size());\n    }\n    /*\n    str.erase(str.begin()+1,str.begin()+2);\n    R(i,0,str.size()) {\n      R(j,0,str[i].size()) cout<<str[i][j];\n      cout<<endl;\n    }\n*/\n    solve();\n  }\n  return 0;\n}\n\nvoid solve() {\n  while(str.size()>1) {\n    //cout<<str.size()<<endl;\n    num = atoi(str[ope.first+1][str[ope.first+1].size()-1].c_str());\n  //  cout << ope.first << \" \" << str[ope.first+1].size() << endl;\n    opr = str.size();\n    R(i,ope.first+2,str.size()) {\n      if(str[i].size() <= str[ope.first].size()) { opr = i; break; }\n      if(str[ope.first][str[ope.first].size()-1][0] == '+') num += atoi(str[i][str[i].size()-1].c_str());\n      else num *= atoi(str[i][str[i].size()-1].c_str());\n    }\n\n    str[ope.first][str[ope.first].size()-1] = to_string(num);\n    str.erase(str.begin()+ope.first+1,str.begin()+opr);\n\n    ope = P(0,0);\n    R(i,0,str.size()) {\n      if(str[i].size() > ope.second && (str[i][str[i].size()-1][0] == '+' || str[i][str[i].size()-1][0] == '*')) ope = P(i,str[i].size());\n    }\n  }\n\n  cout<<str[0][0]<<endl;\n  /*\n  R(i,0,n) {\n    R(j,0,str[i].size()) cout<<str[i][j];\n    cout<<endl;\n  }\n  cout<<\"ope = \"<<ope.first<<endl;\n  */\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\nint n;\nstring s[50];\nint calc(int a, int b, bool m) {int res = m;for (int i = b; i < n; i++) {if (s[i].size() <= a)break;if ('0' <= s[i][a] && s[i][a] <= '9') {if (m)res *= s[i][a] - '0';else res += s[i][a] - '0';}if (s[i][a] == '*') {if (m)res *= calc(a + 1, i + 1, 1);else res += calc(a + 1, i + 1, 1);}if (s[i][a] == '+') {if (m)res *= calc(a + 1, i + 1, 0);else res += calc(a + 1, i + 1, 0);}}return res;}\nint main() {\nwhile (scanf(\"%d\", &n), n) {rep(i, n)cin >> s[i];printf(\"%d\\n\", calc(0, 0, 0));}}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<string> vs;\n\nint calc(vector<int>& v, bool plus){\n  // std::cout << \"calc:\" << std::endl;\n  // for (int i = 0; i < v.size(); i++) {\n  //   std::cout << v[i] << std::endl;\n  // }\n  int res = (plus != true);\n  for (int i = 0; i < v.size(); i++) {\n    if(plus)res += v[i];\n    else res *= v[i];\n  }\n  // std::cout << \"res:\" << res << std::endl;\n  // std::cout << std::endl;\n  return res;\n}\n\nint dfs(bool plus, int &s, int k = 0){\n  vector<int> res;\n  //std::cout << \"k:\" << k << \" plus:\" << plus<< std::endl;\n  for (;s < vs.size(); s++) {\n    //std::cout << vs[s] << std::endl;\n    if(vs[s][k] != '.'){\n      s--;\n      return calc(res, plus);\n    }else if(vs[s][k + 1] == '+' or vs[s][k + 1] == '*'){\n      int tmp = dfs(vs[s - 1][k + 1] == '+', ++s, k + 1);\n      res.emplace_back(tmp);\n    }else{\n      res.emplace_back(atoi(vs[s].substr(k + 1).c_str()));\n    }\n  }\n  // for (int i = 0; i < res.size(); i++) {\n  //   std::cout << res[i] << std::endl;\n  // }\n  return calc(res, plus);\n}\n\nint main(){\n  int n;\n  while(std::cin >> n, n){\n    vs.resize(n);\n    int maxi = 0;\n    for (int i = 0; i < n; i++) {\n      std::cin >> vs[i];\n      maxi = max(maxi, (int)vs[i].length());\n    }\n    for (int i = 0; i < n; i++) {\n      if(vs[i].length() < maxi)\n        vs[i] += string(maxi - vs[i].length(), 'o');\n    }\n    if(n == 1){\n      std::cout << vs[0] << std::endl;\n    }else{\n      int s = 0;\n      std::cout << dfs(vs[s - 1][0] == '+', ++s) << std::endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint N;\nstring S[100];\nint p;\n\nint cnt(int i) {\n  REP(j, 0, S[i].size()) if(S[i][j] != '.') return j;\n  return 0;\n}\n\nint dfs(int l) {\n  if('0' <= S[p][l] && S[p][l] <= '9') return S[p++][l] - '0';\n  char op = S[p++][l];\n  int ret = op == '+' ? 0 : 1;\n  while(p < N && cnt(p) > l) {\n    if(op == '+') ret += dfs(l + 1);\n    else ret *= dfs(l + 1);\n  }\n  return ret;\n}\n\nint main(void) {\n  while(cin >> N, N) {\n    REP(i, 0, N) cin >> S[i];\n    p = 0;\n    cout << dfs(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nint search(vector<string>& s, int l, int pn) {\n\tif (s[l][pn-1] >= '0'&&s[l][pn-1] <= '9')return s[l][pn-1] - '0';\n\tif (s[l][pn-1] == '+') {\n\t\tint ret = 0;\n\t\tfor (int i = l + 1; i < s.size(); i++) {\n\t\t\tif (s[i].size() > pn + 1)continue;\n\t\t\tif (s[i].size() == pn + 1) {\n\t\t\t\tret += search(s, i, pn + 1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ret = 1;\n\tfor (int i = l + 1; i < s.size(); i++) {\n\t\tif (s[i].size() > pn + 1)continue;\n\t\tif (s[i].size() == pn + 1) {\n\t\t\tret *= search(s, i, pn + 1);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<int>ans;\n\twhile (N) {\n\t\tvector<string>v(N);\n\t\tfor (int i = 0; i < N; i++)cin >> v[i];\n\t\tans.push_back(search(v, 0, 1));\n\t\tcin >> N;\n\t}\n\tfor (auto i : ans) {\n\t\tcout << i << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<sstream>\nusing namespace std;\ntypedef long long ll;\nstring i2s(ll x){\n  string y;\n  ll k=1;\n  while(x>=k) k*=10;\n  k/=10;\n  for(ll i=k;i>0;i/=10){\n    y+=(x/i)%10+'0';\n  }\n  return y;\n}\nll s2i(string x){\n  for(ll i=0;i<x.size();i++) if(x[i]=='.') x[i]=' ';\n  stringstream ss(x);\n  ll y;\n  ss >> y;\n  return y;\n}\nint main(){\n  //cout << i2s(100) << endl;\n  ll n;\n\n  while(cin>>n,n){\n    string buf;\n    vector<string> v;\n    vector<ll> d;\n    ll i,j,k;\n    for(i=0;i<n;i++){\n      cin >> buf;\n      j=0;\n      while(buf[j]=='.') j++;\n      v.push_back(buf);\n      d.push_back(j);\n    }\n    while(v.size()!=1){\n      //for(i=0;i<v.size();i++) cout << v[i] << endl;\n      //cout << endl;\n      //cout << v.size() << endl;\n      k=1;\n      for(i=0;i<v.size();i++){\n        if(d[k]<d[i]) k=i;\n      }\n      //cout << k << \":\" << v[k-1][v[k-1].size()-1] << endl;\n      if(v[k-1][v[k-1].size()-1]=='+'){\n        i=0;j=0;\n        while(1) {\n          if(d[k]!=d[k+i]) break;\n          //j*=(v[k+i][v[k+i].size()-1]-'0');\n          j+=s2i(v[k+i]);\n          i++;\n          if(k+i==d.size()) break;\n        }\n        //cout << k+i << endl;\n        v[k-1]=v[k-1].substr(0,v[k-1].size()-1);\n        v[k-1]+=i2s(j);\n        v.erase(v.begin()+k,v.begin()+k+i);\n        d.erase(d.begin()+k,d.begin()+k+i);\n      }\n      if(v[k-1][v[k-1].size()-1]=='*'){\n        i=0;j=1;\n        while(1) {\n          if(d[k]!=d[k+i]) break;\n          //j*=(v[k+i][v[k+i].size()-1]-'0');\n          j*=s2i(v[k+i]);\n          i++;\n          if(k+i==d.size()) break;\n        }\n        //cout << i << endl;\n        v[k-1]=v[k-1].substr(0,v[k-1].size()-1);\n        v[k-1]+=i2s(j);\n        v.erase(v.begin()+k,v.begin()+k+i);\n        d.erase(d.begin()+k,d.begin()+k+i);\n      }\n      \n    }\n    cout << v[0] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//level（入れ子レベル）、op=0...足し算、1...掛け算\nstring s[50];\nint ind=0;\nint calc(int level,int op)\n{\n\tint ret=0;\n\tif(op==1)\n\t\tret=1;\n\t//終了条件\n\twhile(s[ind].size()>level)\n\t{\n\t\t//opだった場合\n\t\tif(s[ind][level]=='+')\n\t\t{\n\t\t\tind++;\n\t\t\tif(op==0)\n\t\t\t\tret+=calc(level+1,0);\n\t\t\telse\n\t\t\t\tret*=calc(level+1,0);\n\t\t}else if(s[ind][level]=='*'){\n\t\t\tind++;\n\t\t\tif(op==0)\n\t\t\t\tret+=calc(level+1,1);\n\t\t\telse\n\t\t\t\tret*=calc(level+1,1);\n\t\t}else{\n\t\t\tint num=s[ind][level]-'0';\n\t\t\tif(op==0)\n\t\t\t\tret+=num;\n\t\t\telse\n\t\t\t\tret*=num;\n\t\t\tind++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<50;i++)\n\t\t\ts[i].clear();\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>s[i];\n\t\t//最初の行を見る\n\t\tind=1;\n\t\tif(s[0][0]=='+')\n\t\t\tcout<<calc(1,0)<<endl;\n\t\telse if(s[0][0]=='*')\n\t\t\tcout<<calc(1,1)<<endl;\n\t\telse\n\t\t\tcout<<(int)(s[0][0]-'0')<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<string> S;\nint cur;\n\nint dfs(int depth){\n    char c = S[cur][depth];\n    if(isdigit(c)){\n        cur++;\n        return c - '0';\n    }\n    if(c == '+'){\n        int s = 0;\n        cur++;\n        while(cur < N && depth < S[cur].size() && S[cur][depth] == '.'){\n            s += dfs(depth+1);\n        }\n        return s;\n    }\n    if(c == '*'){\n        int p = 1;\n        cur++;\n        while(cur < N && depth < S[cur].size() && S[cur][depth] == '.'){\n            p *= dfs(depth+1);\n        }\n        return p;\n    }\n    \n    return -1;\n}\n\nint main(){\n    while(cin >> N, N){\n        S.resize(N);\n        for(auto &s: S){\n            cin >> s;\n        }\n        \n        cur = 0;\n        cout << dfs(0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<string> s(n);\n        for(int i = 0; i < n; ++i) {\n            cin >> s[i];\n        }\n\n        int line = 0;\n        function<int()> solve = [&]() {\n            int cur_d = 0;\n            for(auto c : s[line]) cur_d += c == '.';\n            if(isdigit(s[line][cur_d])) {\n                int res = 0;\n                while(cur_d < (int)s[line].size()) {\n                    res *= 10;\n                    res += s[line][cur_d++] - '0';\n                }\n                return res;\n            }\n            const char op = s[line][cur_d];\n            int res = op == '*';\n            while(line < n) {\n                int nxt_d = 0;\n                line += 1;\n                if(line >= n) break;\n                for(auto c : s[line]) nxt_d += c == '.';\n                if(nxt_d > cur_d) {\n                    int t = solve();\n                    if(op == '*') res *= t;\n                    else          res += t;\n                } else {\n                    line--;\n                    break;\n                }\n            }\n            return res;\n        };\n\n        cout << solve() << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n// first := 入れ子レベル second := 数字(1,2,...) もしくは op(+: -1, * -2)\n// stack<int,int>  \n// 直前の入れ子のレベルより下がったら、\n// 直前の入れ子レベルの数字と、演算子を取りだして、計算して、結果をスタックにプッシュ\n// スタックから取りだすのは、入れ子レベルが下がった時、入力が終わったとき\n\nint main()\n{\n    int n;\n    while(cin >> n, n) {\n        string s;\n        stack<pair<int,int>> stk;\n        while(n--) {\n            cin >> s;\n            int num = 0;\n            if(s.back() >= '0' && s.back() <= '9') num = s.back() - '0';\n            else if(s.back() == '+') num = -1;\n            else num = -2;\n            int ireko = s.size() -1;\n\n            // 直前の入れ子レベルと比較\n            while(!stk.empty() && stk.top().first > ireko) {\n                // 直前の入れ子レベルがirekoよりも高いものをすべて計算する\n                // 演算子が出てくるまで全て取りだす。\n                vector<int> Nums;\n                while(!stk.empty() && stk.top().second >= 0) {\n                    Nums.push_back(stk.top().second);\n                    stk.pop();\n                }\n                // tmp: 計算結果\n                int tmp;\n                // スタックの一番上が演算子\n                if(stk.top().second == -1) {\n                    // 全て足す\n                    tmp = 0;\n                    for(int x : Nums) tmp += x;\n                }\n                else {\n                    tmp = 1;\n                    for(int x : Nums) tmp *= x;\n                }\n                // スタックにプッシュする入れ子レベル == 演算子の入れ子レベル\n                int i = stk.top().first;\n                // スタックの一番上の演算子を取りだす\n                stk.pop();\n                // 計算結果をプッシュ\n                stk.push(make_pair(i, tmp));\n            }\n            // 入力したものをプッシュ\n            stk.push(make_pair(ireko, num));\n\n            // デバッグ\n            // cout << \"size: \" << stk.size() << \" top.first: \" << stk.top().first << \" top.second: \" << stk.top().second << endl;\n        }\n\n        // 最後、残っているものを計算する\n        // スタックの上にあるものの入れ子レベルが1なら、計算が終わってなくて\n        // スタックの上にあるものの入れ子レベルが0なら、もう計算がすんでいる\n        while(stk.top().first > 0) {\n            // 演算子が出てくるまで全て取りだす。\n            vector<int> Nums;\n            while (!stk.empty() && stk.top().second >= 0)\n            {\n                Nums.push_back(stk.top().second);\n                stk.pop();\n            }\n            // tmp: 計算結果\n            int tmp;\n            // ↓ここでスタックが空になっている(1つ目サンプル)\n            assert(stk.size() != 0);\n            // スタックの一番上が演算子\n            if (stk.top().second == -1)\n            {\n                // 全て足す\n                tmp = 0;\n                for (int x : Nums)\n                    tmp += x;\n            }\n            else\n            {\n                tmp = 1;\n                for (int x : Nums)\n                    tmp *= x;\n            }\n            // スタックにプッシュする入れ子レベル == 演算子の入れ子レベル\n            int i = stk.top().first;\n            // スタックの一番上の演算子を取りだす\n            stk.pop();\n            // 計算結果をプッシュ\n            stk.push(make_pair(i, tmp));\n        }\n        // 最後にのこったものを出力\n        cout << stk.top().second << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string.h>\n#include<stdio.h>\nusing namespace std;\nint suma(int d);\nint a;\nchar s[1000];\nint t(int d){\n  int ans=1;\n  cin>>s;\n  a--;\n  while(a>=0){\n    if(strlen(s)<d)\n      break;\n    if(s[d-1]=='*')\n      ans*=t(d+1);\n    else if(s[d-1]=='+')\n      ans*=suma(d+1);\n    else{\n      ans*=s[d-1]-'0';\n      if(a==0)\n        break;\n      cin>>s;\n      a--;\n    }\n  }\n  return ans;\n}\n\nint suma(int d){\n  int ans=0;\n  a--;\n  cin>>s;\n  while(a>=0){\n    if(strlen(s)<d)\n      break;\n    if(s[d-1]=='*')\n      ans+=t(d+1);\n    else if(s[d-1]=='+')\n      ans+=suma(d+1);\n    else{\n      if(strlen(s)!=d)\n        break;\n      ans+=s[d-1]-'0';\n      if(a==0)\n        break;\n      cin>>s;\n      a--;\n    }\n  }\n  return ans;\n}\n\nint main(){\n  int n;\n  while(1){\n    cin>>s;\n    if(strlen(s)==1&&s[0]=='0')\n      break;\n    n=strlen(s);\n    a=0;\n    for(int i=0;i<n;i++){\n      a*=10;\n      a+=s[i]-'0';\n    }\n    a--;\n    cin>>s;\n    if(s[0]=='+')\n      cout<<suma(2)<<endl;\n    else if(s[0]=='*')\n      cout<<t(2)<<endl;\n    else\n      cout<<s<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define pi acos(-1.0)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint calc(vector<string> s, int &i){\n\tint depth = s[i].length(), n = s.size();\n\tchar c = s[i][depth-1];\n\tif (c == '+'){\n\t\tint res = 0;\n\t\ti++;\n\t\twhile (s[i].length() == depth+1 && i < n){\n\t\t\tres += calc(s, i);\n\t\t}\n\t\treturn res;\n\t}else if (c == '*'){\n\t\tint res = 1;\n\t\ti++;\n\t\twhile (s[i].length() == depth+1 && i < n){\n\t\t\tres *= calc(s, i);\n\t\t}\n\t\treturn res;\n\t}else{\n\t\ti++;\n\t\treturn c - '0';\n\t}\n}\n\nint main(){\n\tint n;\n\tifstream ifs(\"in.txt\");\n\twhile (cin >> n && n){\n\t\tvector<string> s(n);\n\t\tREP(i,n) cin >> s[i];\n\t\tint i = 0;\n\t\tcout << calc(s, i) << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = i64(1e18) + 7;\n\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\nint n;\nvector<string> s;\n\npair<int,int> calc(int l, int d){\n\n    if('0' <= s[l][d] && s[l][d] <= '9')\n        return make_pair(s[l][d] - '0', l + 1);\n    bool mul = s[l][d] == '*';\n    assert(s[l][d] != '.');\n    ++l;\n    vector<int> res;\n    while(l != n && s[l].size() > d && s[l][d] == '.'){\n        auto p = calc(l, d + 1);\n        res.push_back(p.first);\n        l = p.second;\n    }\n    auto f = [&](auto x, auto y){return mul ? x * y : x + y;};\n    return make_pair(accumulate(res.begin(), res.end(), int(mul), f), l);\n}\n\nbool solve(){\n    cin >> n;\n    if(!n)\n        return false;\n    s.resize(n);\n    for(int i = 0; i < n; ++i)\n        cin >> s[i];\n\n    cout << calc(0, 0).first << endl;\n    return true;\n}\n\nsigned main(){\n    while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint func()\n{\n    int N;\n    cin >> N;\n    if( N == 0 ) return -1;\n\n    long long int v[10] = { 0 };\n    char m[10] = { 0 };\n    int mcnt = 0;\n\n    for( int i = 0; i < N; ++i ){\n        string S;\n        cin >> S;\n\n        int cnt = 0, len = S.length();\n\n        for( int j = 0; j < len; ++j ){\n            switch( S[j] ){\n            case '.': ++cnt; break;\n            case '+': case '*': m[cnt] = S[j]; ++mcnt; break;\n            default:\n                if( cnt == 0 ){\n                    cout << S[j]-'0' << endl;\n                    return 0;\n                } else if( m[cnt-1] == '+' ){\n                    v[cnt-1] += (long long int)(S[j]-'0');\n                } else if( m[cnt-1] == '*' ){\n                    if( v[cnt-1] == 0 ) v[cnt-1] = (long long int)1;\n                    v[cnt-1] *= (long long int)(S[j]-'0');\n                }\n                break;\n            }\n        }\n    }\n    cout << \"mcnt\" << mcnt << endl;\n\n    /**/\n    cout << \"v:\";\n    for( int i = 0; i < 10; ++i ) cout << v[i] << \" \";\n    cout << endl << \"m:\";\n    for( int i = 0; i < 10; ++i ) cout << m[i] << \" \";\n    cout << endl;\n    /**/\n\n    long long int ans = 0;\n    if( m[1] == 0 ){\n        cout << v[0] << endl;\n        return 0;\n    }\n    for( int i = 0; i < mcnt-1; ++i ){\n        bool flag = true;\n        if( m[i] == '*' && m[i+1] != 0 ){\n            if( flag ){\n                ans = v[i];\n                v[i] = 0;\n                flag = false;\n            }\n            ans *= v[i+1];\n            v[i+1] = 0;\n            cout << \"*\" << ans << endl;\n        }\n    }\n    for( int i = 0; m[i] != 0; ++i ){\n        ans += v[i];\n        cout << \"+\" << ans << endl;\n    }\n\n    /**/\n    cout << \"v:\";\n    for( int i = 0; i < 10; ++i ) cout << v[i] << \" \";\n    cout << endl << \"m:\";\n    for( int i = 0; i < 10; ++i ) cout << m[i] << \" \";\n    cout << endl;\n    /**/\n\n    cout << ans << endl;\n\n    return 0;\n}\n\nint main()\n{\n    while( func() != -1 ) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint n;\nvector<string>in;\nint a;\nint f(int b){\n\tchar c=in[a][b];\n\ta++;b++;\n\tint sum=0;\n\tif(c=='*')sum=1;\n\twhile(1){\n\t\tint t=0;\n\t\tif(isdigit(in[a][b])){\n\t\t\tt=in[a][b]-'0';\n\t\t}else{\n\t\t\tt=f(b);\n\t\t\ta--;\n\t\t}\n\t\tif(c=='*')sum*=t;\n\t\telse sum+=t;\n\t\ta++;\n\t\tif(a==n)break;\n\t\tif(in[a].size()<=b)break;\n\t}\n\treturn sum;\n}\nint main(){\n\twhile(cin>>n,n){\n\t\tin=vector<string>(n);\n\t\trep(i,n)cin>>in[i];\n\t\tif(n==1){\n\t\t\tcout<<in[0]<<endl;\n\t\t}else{\n\t\t\ta=0;\n\t\t\tcout<<f(0)<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nstring s[1000];\nint dfs(int d,int k){\n  bool e=0;\n  int res=0;\n  if(s[d][k]=='+')d++,k++;\n  if(s[d][k]=='*')e=1,d++,k++,res=1;\n  for(int i=d;i<n&&k<s[i].size();i++){\n    int a=s[i][k]-'0';\n    if(s[i][k]=='.')continue;\n    if(s[i][k]=='+'||s[i][k]=='*')a=dfs(i,k);\n    if(e)res*=a;\n    else res+=a;\n  }\n  return res;\n}\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++)cin>>s[i];\n    cout<<dfs(0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll n;\nvector<string> vs;\n\n\nll calc(int &i,int op){\n    // cout << \"!\" << i << endl;\n    ll res = INF;\n    ll d = -1;\n    while(i < vs.size()){\n        // cout << i << \" \" << res << \" \" << d <<  endl;\n        if(d > (ll)vs[i].size())break;\n        d = max(d,(ll)vs[i].size());\n        if(vs[i].back() >= '0' && vs[i].back() <= '9'){\n            if(op == -1 || res == INF)res = (vs[i].back() - '0');\n            else if(op == 0)res += (vs[i].back() - '0');\n            else if(op == 1)res *= (vs[i].back() - '0');\n            i++;\n        }\n        else if(vs[i].back() == '+'){\n            if(op == -1 || res == INF) res = calc(++i,0);\n            else if(op == 0)res += calc(++i,0);\n            else if(op == 1)res *= calc(++i,0);\n        }\n        else if(vs[i].back() == '*'){\n            if(op == -1 || res == INF) res = calc(++i,1);\n            else if(op == 0)res += calc(++i,1);\n            else if(op == 1)res *= calc(++i,1);\n        }\n    }\n    // cout << \"!!\" << i << \" \" << res << endl;\n    return res;\n}\n\nint main(){\n    while(cin >> n && n){\n        vs.clear();\n        vs.resize(n);\n        rep(i,n)cin >> vs[i];\n        int i = 0;\n        cout << calc(i,-1) << endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cctype>\nusing namespace std;\n\nint N, id;\nstring s[1000];\nchar c[1000];\nint depth[1000];\n\nint f(int d){\n    if(isdigit(c[id])){\n        int ret = c[id] - '0';\n        id++;\n        return ret;\n    }\n    if(c[id] == '+'){\n        id++;\n        int ret = 0;\n        while(id < N && depth[id] == d + 1){\n            ret += f(d + 1);\n        }\n        return ret;\n    }\n\n    // *\n    id++;\n    int ret = 1;\n    while(id < N && depth[id] == d + 1){\n          ret *= f(d + 1);\n    }\n    return ret;\n}\n\nint main(){\n    while(cin >> N, N){\n        for(int i = 0; i < N; i++) {\n            cin >> s[i];\n            depth[i] = s[i].size() - 1;\n            c[i] = s[i].back();\n            //cerr << depth[i] << \" \" << c[i] << endl;\n        }\n        id = 0;\n        cout << f(0) << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 3000000000000000000\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define REP(i,n) for(long long i = 0;i < n;++i)\n#define seg_size 524288\nlong long data[200000] = {};\nvector<int> vertexs[200000];\nlong long solver(int now){\n\tif(data[now] <= 9) return data[now];\n\tlong long ans = 0;\n\tif(data[now] == 10){\n\t\tfor(int i = 0;i < vertexs[now].size();++i){\n\t\t\tans += solver(vertexs[now][i]);\n\t\t}\n\t}else if(data[now] == 11){\n\t\tans = 1;\n\t\tfor(int i = 0;i < vertexs[now].size();++i){\n\t\t\tans *= solver(vertexs[now][i]);\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0) return 0;\n\t\tvector<string> hoget;\n\t\thoget.push_back(\"+\");\n\t\tfor(int i = 0;i < n;++i){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\thoget.push_back('.'+s);\n\t\t}\n\t\tn++;\n\t\tstack<pair<int,int>> geko;\n\t\tgeko.push(make_pair(0,0));\n\t\tdata[0] = 10;\n\t\tfor(int i = 1;i < n;++i){\n\t\t\tint nested = hoget[i].length()-1;\n\t\t\twhile(geko.empty() == false&&geko.top().second >= nested){\n\t\t\t\tgeko.pop();\n\t\t\t}\n\t\t\tvertexs[geko.top().first].push_back(i);\n\t\t\tgeko.push(make_pair(i,nested));\n\t\t\tif(hoget[i][nested] == '+'){\n\t\t\t\tdata[i] = 10;\n\t\t\t}else if(hoget[i][nested] == '*'){\n\t\t\t\tdata[i] = 11;\n\t\t\t}else data[i] = hoget[i][nested] - '0';\n\t\t}\n\t\tcout << solver(0) << endl;\n\t\tfor(int i = 0;i < 200000;++i){\n\t\t\tdata[i] = 0;\n\t\t\tvertexs[i].clear();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<string>D;\n\nint solve(int n, int m, bool b){\n        int num=b;\n        for (int i = m; i < D.size(); i++) {\n                if (D[i].size() <= n) {\n                        return num;\n                }\n                if (D[i][n] == '+') {\n                        if (b) {\n                                num *= solve(n + 1, i + 1, 0);\n                        } else {\n                                num += solve(n + 1, i + 1, 0);\n                        }\n                } else if(D[i][n] == '*') {\n                        if (b) {\n                                num *= solve(n + 1, i + 1, 1);\n                        } else {\n                                num += solve(n + 1, i + 1, 1);\n                        }\n                } else if(D[i][n] == '.') {\n                        continue;\n                } else {\n                        if (b) {\n                                num *= D[i][n] - '0';\n                        } else {\n                                num += D[i][n] - '0';\n                        }\n                }\n        }\n        return num;\n}\n\nint main(){\n        int N;\n        while (cin>>N, N) {\n                D=vector<string>(N);\n                for (int i = 0; i < N; i++) {\n                        cin>>D[i];\n                }\n                cout<<solve(0, 0, 0)<<endl;\n        }\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if (!n)break;\n    stack<pair<char, int>> op;\n    op.emplace('+', 0);\n    REP(i,n){\n      string s;\n      cin>>s;\n      while (op.size() > s.size()) {\n        int num = op.top().second;\n        op.pop();\n        if (op.top().first == '+') {\n          op.top().second += num;\n        } else {\n          op.top().second *= num;\n        }\n      }\n      switch(s.back()) {\n        case '+':\n          op.emplace(s.back(),0);\n          break;\n        case '*':\n          op.emplace(s.back(),1);\n          break;\n        default:\n          {\n            int num = s.back() - '0';\n            if (op.top().first == '+') {\n              op.top().second += num;\n            } else {\n              op.top().second *= num;\n            }\n          }\n      }\n    }\n    cout << op.top().second << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<climits>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nvoid solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        st.push(make_pair(th, l-1));\n    }\n}\nint main(){\n    while(cin>>n,n){\n        while(ope.size())ope.pop();\n        while(st.size())st.pop();\n        if(ope.size())return -1;\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    solve(level);\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        solve(0);\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<climits>\nusing namespace std;\n\nint n;\nstack<pair<char,int> >ope;\nstack<pair<int,int> >st;\nint solve(int level){\n    while(st.top().second>level){\n        char op=ope.top().first;\n        ope.pop();\n        stack<int>sta;\n        int l=st.top().second;\n        while(st.size()&&st.top().second==l){\n            sta.push(st.top().first);\n            st.pop();\n        }\n        int th=sta.top();\n        sta.pop();\n        while(sta.size()){\n            if(op=='+'){\n                th+=sta.top();\n            } else {\n                th*=sta.top();\n            }\n            sta.pop();\n        }\n        if((long long)th>147483647){\n            return -1;\n        }\n        st.push(make_pair(th, l-1));\n    }\n    return 0;\n}\nint main(){\n    cout<<INT_MAX<<endl;\n    while(cin>>n,n){\n        while(ope.size())ope.pop();\n        while(st.size())st.pop();\n        if(n==1){\n            cin>>n;\n            cout<<n<<endl;\n            continue;\n        }\n        char c;\n        int i,level;\n        for(int tt=0;tt<n;tt++){\n            cin>>c;\n            level=0;\n            while(c=='.'){\n                level++;\n                cin>>c;\n            }\n            if(c>='0'&&c<='9'){\n                i=c-'0';\n                if(st.size())\n                    if(solve(level)==-1)return -1;\n                st.push(make_pair(i, level));\n            } else\n                ope.push(make_pair(c, level));\n        }\n        if(solve(0)==-1)return -1;\n        cout<<st.top().first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nint a[11];\nstring s[100];\nint cur;\nint dfs(int d){\n    int ret;\n    if(isdigit(s[cur][d])) return s[cur++][d]-'0';\n    else{\n        if(s[cur][d]=='+'){\n            ret=0;\n            ++cur;\n            while(s[cur].size()==d+2)ret+=dfs(d+1);\n        }\n        else if(s[cur][d]=='*'){\n            ret=1;\n            ++cur;\n            while(s[cur].size()==d+2)ret*=dfs(d+1);\n        }\n    }\n    return ret;\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        cur=0;\n        rep(i,n) cin>>s[i];\n        cout<<dfs(0)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mux_n = 2000;\n\nenum _operator{\n    _plus,\n    multiply,\n    none\n};\n\nvoid En_route_culc(vector<_operator>& level_ope,vector<vector<long long int> >& level_num,int min_level, int max_level ){\n    int now_level = max_level;\n    while(min_level < now_level){\n        if(level_ope[now_level-1] != none){\n            long long int sum;\n            if(level_ope[now_level-1] == _plus){\n                sum = 0;\n                for(int i=0; i<level_num[now_level].size(); i++){\n                    sum += level_num[now_level][i];\n                }\n            }\n            else if(level_ope[now_level-1] == multiply){\n                sum = 1;\n                for(int i=0; i<level_num[now_level].size(); i++){\n                    sum *= level_num[now_level][i];\n                }\n            }\n            if(now_level == 1) {\n            }\n            else{\n                level_num[now_level-1].push_back(sum);\n            }\n        }\n        now_level--;\n    }\n}\n\nint main() {\n\n    ofstream ofs(\"out.txt\");\n\n    while(1){\n\n        int n;\n\n        cin >> n;\n\n        if(n==0) break;\n\n        string input[n];\n\n        vector<vector<long long int> > level_num;\n        vector<_operator> level_ope;\n\n        level_num.resize(mux_n);\n\n\n        for(int i=0; i<mux_n; i++){\n            level_ope.push_back(none);\n        }\n\n        int max_level = 0;\n\n        for(int i=0; i<n; i++){\n            cin >> input[i];\n            for(int j=0; j<input[i].size(); j++){\n                if(input[i][j] == '+'){\n                    if(level_ope[j] != none){\n                        En_route_culc(level_ope,level_num,j,max_level);\n                        //level_num[j].push_back(tmpsum);\n                        for(int k=max_level; j<k; k--) {\n                            while (!level_num[k].empty()) {\n                                level_num[k].pop_back();\n                            }\n                        }\n                        max_level = j;\n                        /*while(!level_num[j+1].empty()){\n                            level_num[j+1].pop_back();\n                        }*/\n                    }\n                    level_ope[j] = _plus;\n                }\n                else if(input[i][j] == '*'){\n                    if(level_ope[j] != none){\n                        En_route_culc(level_ope,level_num,j,max_level);\n                        //level_num[j].push_back(tmpsum);\n                        for(int k=max_level; j<k; k--) {\n                            while (!level_num[k].empty()) {\n                                level_num[k].pop_back();\n                            }\n                        }\n                        max_level = j;\n                    }\n                    level_ope[j] = multiply;\n                }\n                else if(input[i][j] != '.'){\n                    string string_now_input_num;\n                    for(int k=j; k<input[i].size(); k++){\n                        string_now_input_num.push_back(input[i][k]);\n                    }\n                    stringstream ss;\n                    ss << string_now_input_num;\n                    int input_num;\n                    ss >> input_num;\n                    level_num[j].push_back(input_num);\n                }\n                max_level = max(max_level,j);\n            }\n        }\n\n        long long int ans = 0;\n        int now_level = max_level;\n\n        while(now_level){\n            if(level_ope[now_level-1] != none){\n                long long int sum;\n                if(level_ope[now_level-1] == _plus){\n                    sum = 0;\n                    for(int i=0; i<level_num[now_level].size(); i++){\n                        sum += level_num[now_level][i];\n                    }\n                }\n                else if(level_ope[now_level-1] == multiply){\n                    sum = 1;\n                    for(int i=0; i<level_num[now_level].size(); i++){\n                        sum *= level_num[now_level][i];\n                    }\n                }\n                if(now_level == 1) {\n                    ans = sum;\n                }\n                else{\n                    level_num[now_level-1].push_back(sum);\n                }\n            }\n            now_level--;\n        }\n\n        if(n == 1){\n            ans = level_num[0][0];\n        }\n\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nchar s[1000][1000];\nint lv[1000];\nint f(int k,int l){\n\tchar c=s[k][l];\n\tif('0'<=c&&c<='9')return c-'0';\n\tint r=(c=='+'?0:1);\n\tfor(int i=k+1;i<n;i++){\n\t\tif(lv[i]==l+1)\n\t\t\tr=(c=='+'?\n\t\t\t\tr+f(i,l+1):\n\t\t\t\tr*f(i,l+1));\n\t\tif(lv[i]<=l)break;\n\t}\n\treturn r;\n}\nint main(){\n\twhile(scanf(\"%d\",&n),n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\" %s\",s[i]);\n\t\t\tfor(lv[i]=0;s[i][lv[i]]=='.';lv[i]++);\n\t\t}\n\t\tprintf(\"%d\\n\",f(0,0));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n# ifdef _MSVC_LANG\n\n# define _SCL_SECURE_NO_WARNINGS\n# pragma warning( disable : 0325 ) // inline namespace Error\n\n# endif\n\n\n# include <iostream>\n# include <string>\n# include <iomanip>\n# include <cstdio>\n# include <array>\n# include <numeric>\n# include <algorithm>\n# include <vector>\n# include <functional>\n# include <fstream>\n# include <random>\n# include <bitset>\n# include <map>\n# include <unordered_set>\n\n\n// C++ 11 前提\n\nusing Ull = unsigned long long;\nusing Ll = long long;\n\ntemplate<typename T>\nusing Vec = std::vector<T>;\n\ntemplate<typename T, size_t L>\nusing Ary = std::array<T, L>;\n\nnamespace\n{\n\n    namespace meta\n    {\n        namespace coming\n        {\n            // c++ 17;\n            template<class... _Types>\n            using void_t = void;\n\n            template<class _Ty,\n                _Ty _Val>\n                struct integral_constant\n            {\t// convenient template for integral constant types\n                static constexpr _Ty value = _Val;\n\n                using value_type = _Ty;\n                using type = integral_constant;\n\n                constexpr operator value_type() const noexcept\n                {\t// return stored value\n                    return (value);\n                }\n\n                constexpr value_type operator()() const noexcept\n                {\t// return stored value\n                    return (value);\n                }\n            };\n\n            // c++ 17;\n            template<bool _Val>\n            using bool_constant = integral_constant<bool, _Val>;\n\n\n            // c++ 14\n            template<bool _Test,\n                class _Ty = void>\n                using enable_if_t = typename std::enable_if<_Test, _Ty>::type;\n        }\n\n        namespace core\n        {\n\n            template < class, class = void > struct enable_std_begin_end : std::false_type {};\n            template < typename T >\n            struct enable_std_begin_end<T,\n                coming::void_t<decltype(std::begin(std::declval<const T&>()), std::end(std::declval<const T&>()))>> : std::true_type {}; // c++ 17\n\n\n            template < class, class = void > struct enable_adl_begin_end : std::false_type {};\n            template < typename T >\n            struct enable_adl_begin_end<T,\n                coming::void_t<decltype(begin(std::declval<const T&>()), end(std::declval<const T&>()))>> : std::true_type {};\n        }\n\n        template < typename T >\n        struct is_range\n            : coming::bool_constant< core::enable_std_begin_end<T>::value || core::enable_adl_begin_end<T>::value>\n        {\n        };\n\n        /// <summary>\n        /// ある値が0以上か\n        /// </summary>\n        template<class T, T num, class = std::nullptr_t> struct is_positive\n            : coming::bool_constant<(num >= 0)>\n        {\n        };\n\n    }\n\n\n    inline namespace extension\n    {\n        inline namespace container_io\n        {\n            inline namespace in\n            {\n\n                /// <summary>\n                /// for cin with STL container\n                /// </summary>\n                template< template<class ...> class Container, class ... Args, typename = meta::coming::enable_if_t<!std::is_same< typename Container, typename std::basic_string> ::value> >\n                std::istream& operator >> (std::istream& is, Container<Args ...>& container)\n                {\n                    for (auto& elem : container) is >> elem; return is;\n                }\n\n                /// <summary>\n                /// for cin with std::arary\n                /// </summary>\n                template<class T, size_t L>\n                std::istream& operator >> (std::istream& is, std::array<T, L>& container)\n                {\n                    for (auto& elem : container) is >> elem; return is;\n                }\n\n                /// <summary>\n                /// for cin with raw array\n                /// </summary>\n                template<class T, size_t L>\n                std::istream& operator >> (std::istream& is, T(&ary)[L])\n                {\n                    for (int i{}; i < L; ++i) is >> ary[i]; return is;\n                }\n\n            }\n\n            inline namespace out\n            {\n                namespace settings\n                {\n                    /// <summary>\n                    /// 要素間の区切り文字\n                    /// </summary>\n                    const auto sepOfContainerElements{\" \"};\n                    /// <summary>\n                    /// コンテナ間の区切り文字\n                    /// </summary>\n                    const auto sepOfContainer{\"\\n\"};\n                }\n\n\n                /// <summary>\n                /// for cout Container with STL container\n                /// </summary>\n                template < template<class ...> class Container, class ... Args, typename = meta::coming::enable_if_t<!std::is_same< typename Container, typename std::basic_string> ::value> >\n                std::ostream& operator << (std::ostream& os, const Container<Args ...>& container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainerElements; return os;\n                }\n\n                /// <summary>\n                /// for cout Container with std::array\n                /// </summary>\n                template < class T, size_t L>\n                std::ostream& operator << (std::ostream& os, const std::array<T, L> container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainerElements; return os;\n                }\n\n                /// <summary>\n                /// for cout Container with raw array\n                /// </summary>\n                template < class T, size_t L, typename = meta::coming::enable_if_t<!std::is_same<T, char>::value> >\n                std::ostream& operator << (std::ostream& os, const T(&ary)[L])\n                {\n                    for (const auto& elem : ary) os << elem << settings::sepOfContainerElements; return os;\n                }\n\n\n\n                /// <summary>\n                /// for cout Container in Container with STL container\n                /// </summary>\n                template < template<class ...> class Container1, class ... Cont1Args,\n                    template<class ...> class Container2, class ... Cont2Args  >\n                std::ostream& operator << (std::ostream& os, const Container1< Container2<Cont2Args ...>, Cont1Args ...>& container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainer; return os;\n                }\n\n\n\n                /// <summary>\n                /// for cout Container in Container with std::array\n                /// </summary>\n                template < template<class ...> class Container, class ... Args, size_t L >\n                std::ostream& operator << (std::ostream& os, const std::array<Container<Args ...>, L>& container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainer; return os;\n                }\n                /// <summary>\n                /// for cout Container in Container with std::array\n                /// </summary>\n                template < template<class ...> class Container, class ... Args, size_t L, class T  >\n                std::ostream& operator << (std::ostream& os, const Container<std::array<T, L>, Args ...>& container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainer; return os;\n                }\n                /// <summary>\n                /// for cout Container in Container with std::array\n                /// </summary>\n                template < class T, size_t L1, size_t L2 >\n                std::ostream& operator << (std::ostream& os, const std::array<std::array<T, L2>, L1> container)\n                {\n                    for (const auto& elem : container) os << elem << settings::sepOfContainer; return os;\n                }\n\n\n                /// <summary>\n                /// for cout raw ary in raw ary\n                /// </summary>\n                template < class T, size_t L1, size_t L2 >\n                std::ostream& operator << (std::ostream& os, const T(&ary)[L1][L2])\n                {\n                    for (size_t i{}; i < L1; ++i) os << ary[i] << settings::sepOfContainer; return os;\n                }\n\n            }\n        }\n\n\n        template<typename T, size_t L, typename Function>\n        void for_each(T(&ary)[L], Function lambda)\n        {\n            for (size_t i{}; i < L; ++i)\n                lambda(static_cast<T&>(ary[i]));\n        }\n    }\n\n\n    inline namespace util\n    {\n\n        template<typename T>\n        void SetAll(T& container, typename T::value_type value = typename T::value_type{})\n        {\n            for (typename T::reference content : container) content = value;\n        }\n\n        template<typename T, size_t L>\n        void SetAll(T(&ary)[L], T value)\n        {\n            for (size_t i{}; i < L; ++i) ary[i] = value;\n        }\n\n        template<typename T, typename U, size_t L1, size_t L2>\n        void SetAll(T(&ary)[L1][L2], U value)\n        {\n            for (size_t i{}; i < L1; ++i) SetAll(ary[i], value);\n        }\n\n\n        inline namespace ranges\n        {\n\n            namespace core\n            {\n\n                using namespace meta;\n                /// <summary>\n                /// 再帰上限回数\n                /// </summary>\n                constexpr size_t recursion_limits{490};\n\n                /// <summary>\n                /// 値が割り切れるか\n                /// </summary>\n                template<int num, int divide> struct is_divisible\n                    : coming::bool_constant<num % divide == 0>\n                {\n                };\n\n                /// <summary>\n                /// 有限回数の再帰で終わるか\n                /// </summary>\n                template<int start, int end, int step> struct is_finite_recursion_depth\n                    : coming::bool_constant<(start < end) && (step > 0) || (end < start) && (step < 0)>{};\n\n                /// <summary>\n                /// 再帰回数が上限を超えないか\n                /// </summary>\n                template<int start, int end, int step> struct is_valid_recursion_depth\n                    : coming::bool_constant<(end - start) / step <= recursion_limits>\n                {\n                };\n\n                /// <summary>\n                /// 上記メタ関数の条件をすべて満たすか\n                /// </summary>\n                template<int start, int end, int step> struct is_valid_range\n                    : coming::bool_constant<(start == end) || is_finite_recursion_depth<start, end, step>::value && is_valid_recursion_depth<start, end, step>::value && is_divisible<end - start, step>::value>\n                {\n                };\n\n                /// <summary>\n                /// 再帰を続けるか\n                /// </summary>\n                template<int start, int end, int step> struct is_count_up_or_down\n                    : coming::bool_constant<is_valid_range<start, end, step>::value && end != start>\n                {\n                };\n\n                ///// <summary>\n                ///// 初期化子リストからstd::arrayをコンパイル時生成\n                ///// </summary>\n                //template<typename T, typename ...Args>\n                //constexpr std::array<T, sizeof...(Args)> make_array(Args&&... args)\n                //{\n                //    return std::array<T, sizeof...(Args)>{ static_cast<Args&&>(args)... };\n                //}\n\n\n                /// <summary>\n                /// 本体\n                /// </summary>\n\n                // エラー処理\n                template<int start, int end, int step, class = void, int ...Ary>\n                struct Range_Impl\n                {\n                    //static_assert(is_valid_range           <start, end, step>::value, \"[ ! ] invalid teplate argments [ ! ] 値正しくないっぽいヨ！\");\n                    static_assert(is_divisible             <end - start, step>::value, \"[ ! ] (end - start) is indivisible by step number [ ! ] 割り切れないヨ！stepの値確認して！\");\n                    static_assert(is_finite_recursion_depth<start, end, step>::value, \"[ ! ] goes to infinite loop [ ! ] 無限ループなっちゃうヨ！stepの符号逆じゃない？\");\n                    static_assert(is_valid_recursion_depth <start, end, step>::value, \"[ ! ] recursion depth is out of maximum limit [ ! ] 再帰回数が大きくなりすぎｨ壊れちゃううう\");\n                };\n                // 再帰\n                template<int start, int end, int step, int ... Ary>\n                struct Range_Impl<start, end, step, meta::coming::enable_if_t<is_count_up_or_down<start, end, step>::value>, Ary ... >\n                    : Range_Impl < start + step, end, step, void, Ary ..., start>\n                {\n                };\n                // 終端\n                template<int start, int end, int step, int ... Ary>\n                struct Range_Impl < start, end, step, meta::coming::enable_if_t<start == end>, Ary ...>\n                {\n                    //static constexpr auto value = make_array<int>(Ary ..., end);\n                    //static constexpr std::array<int, (sizeof... (Ary) + 1)> value = {Ary ..., end};\n                    static constexpr int value[(sizeof ... (Ary)+1)] = {Ary ..., end};\n                };\n\n\n            }\n\n\n            template<size_t size, bool isReverse = false>\n            struct Iterate\n            {\n                static constexpr auto in = isReverse ?\n                    core::Range_Impl<static_cast<int>(size - 1), 0, -1>::value :\n                    core::Range_Impl<0, static_cast<int>(size - 1), 1>::value;\n            };\n\n            template<unsigned int upTo>\n            struct CountUp\n            {\n                static constexpr auto to = core::Range_Impl<0, static_cast<int>(upTo), 1>::value;\n            };\n            template<unsigned int downFrom>\n            struct CountDown\n            {\n                static constexpr auto from = core::Range_Impl<static_cast<int>(downFrom), 0, -1>::value;\n            };\n\n\n            template<int start, int containedEnd, int step = 0, typename = void>\n            struct Range\n            {\n                static constexpr auto& in = core::Range_Impl<start, containedEnd, step>::value;\n            };\n            template<int start, int containedEnd>\n            struct Range <start, containedEnd, 0>\n            {\n                static constexpr auto& in = core::Range_Impl<start, containedEnd, meta::is_positive<int, containedEnd - start>::value ? 1 : -1>::value;\n            };\n\n        }\n    }\n\n\n    inline namespace alg\n    {\n        bool IsPrime(const Ull n)\n        {\n            switch (n)\n            {\n            case 0: case 1:\n                return false;\n            case 2:\n                return true;\n            default:\n\n                if (n % 2 == 0) return false;\n\n                for (Ull i{3}; i * i <= n; i += 2)\n                {\n                    if (n % i == 0) return false;\n                }\n            }\n\n            return true;\n        }\n\n        // 最大公約数\n        Ull EuclideanAlg(Ull n1, Ull n2)\n        {\n            //if (n1 < 0 || n2 < 0) return 0;\n            if (n2 > n1) std::swap(n1, n2);\n\n            Ull r;\n            while ((r = n1 % n2) != 0)\n            {\n                n1 = n2;\n                n2 = r;\n            }\n\n            return n2;\n        }\n\n        // 最小公倍数\n        Ull LCM(const std::vector<Ull>& values)\n        {\n            if (values.size() == 0)\n                return 0;\n            if (values.size() == 1)\n                return values[0];\n            if (values.size() == 2)\n                return values[0] * values[1] / EuclideanAlg(values[0], values[1]);\n\n            auto mid = values.cbegin() + values.size() / 2;\n\n            return LCM(std::vector<Ull>{LCM(std::vector<Ull>(values.begin(), mid)), LCM(std::vector<Ull>(mid, values.end()))});\n        }\n    }\n\n\n    void Solve();\n\n}\n\n# if true\nint main()\n{\n    Solve();\n    return 0;\n}\n# endif\n\nnamespace\n{\n    bool isShortPhrase(const std::string& phrases)\n    {\n        constexpr Ary<char, 5> eachLength = {5, 7, 5, 7, 7};\n        \n        int sum{}, current{};\n        for (int i = 0; i < phrases.size(); ++i)\n        {\n            sum += (int)phrases[i];\n            \n            if (sum == eachLength[current])\n            {\n                if (current == eachLength.size() - 1)\n                    return true;\n\n                ++current;\n                sum = 0;\n            }\n        }\n\n        return false;\n    }\n\n    void Solve()\n    {\n        std::ofstream ofs(\"output.txt\");\n        std::cout.rdbuf(ofs.rdbuf());\n\n\n        int length;\n        while (std::cin >> length, length != 0)\n        {\n            std::string phrases(40, '\\0');\n            for (int i{}; i < length; ++i)\n            {\n                std::string temp; std::cin >> temp;\n                phrases[i] = temp.length();\n            }\n\n            for (int i{}; i < length - 4; ++i)\n            {\n                if (isShortPhrase(phrases.substr(i, phrases.size() - i)))\n                {\n                    std::cout << i + 1<< std::endl;\n                    break;\n                }\n            }\n\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\nstruct CLASSNUM{\n  char op;\n  vector<int> num;\n};\n\nint main(){\n  int n,j;\n  string str;\n  CLASSNUM classNum[9];\n  while(true){\n    cin >> n;\n    if(n == 0) break;\n    for(int i = 0; i < n; i++){\n      cin >> str;\n\n      j = 0;\n      while(str[j] == '.'){\n        j++;\n      }\n\n      if(j!=0) str = str.substr(j,1);\n\n      if(str == \"+\") classNum[j].op = '+';\n      else if(str == \"*\")classNum[j].op = '*';\n      else{\n        classNum[j].num.push_back(atoi(str.c_str()));\n      }\n    }\n    for(int i=8; i >= 1; i--){\n      if(classNum[i].num.size() == 0) continue;\n      else{\n        int sum;\n        if(classNum[i].num.size() >= 1 && classNum[i-1].op == '+') {\n          sum = 0;\n          for(int k = 0; k < classNum[i].num.size(); k++){\n            sum += classNum[i].num[k];\n          }\n          classNum[i-1].num.push_back(sum);\n        }\n        else if(classNum[i].num.size() >= 1 && classNum[i-1].op == '*') {\n          sum = 1;\n          for(int k = 0; k < classNum[i].num.size(); k++){\n            sum *= classNum[i].num[k];\n          }\n          classNum[i-1].num.push_back(sum);\n        }\n      }\n    }\n    cout << classNum[0].num[0] << endl;\n    for(int i = 0; i < 8; i++) classNum[i].num.clear();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint rec(vector<string> &s,int c){\n    int ret;\n    bool op=(s[0][c-1]=='+')?true:false;\n    if(op)ret=0;\n    else ret=1;\n    for (int i = 1; i < s.size(); ++i) {\n        if(s[i][c]=='+'||s[i][c]=='*'){\n            vector<string> tv;\n            tv.emplace_back(s[i]);\n            ++i;\n            while(i<s.size()&&s[i].size()!=c+1){\n                tv.emplace_back(s[i]);\n                ++i;\n            }\n            --i;\n            int t=rec(tv,c+1);\n            if(op)ret+=t;\n            else ret=ret*t;\n        }\n        else{\n            if(op)ret+=s[i][c]-'0';\n            else ret=ret*(s[i][c]-'0');\n        }\n    }\n    return ret;\n}\n\nint main(){\n    int n;\n    while(true){\n        cin>>n;\n        if(n==0)break;\n        vector<string> s(n);\n        for (int i = 0; i < n; ++i) {\n            cin>>s[i];\n        }\n        if(n==1)cout<<s[0][0]-'0'<<endl;\n        else cout<<rec(s,1)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\n\n\nint calc(char op, std::vector<int> xs) {\n\n\tswitch (op) {\n\tcase '+': {\n\t\tint v = xs.at(0);\n\t\tfor (int i = 1; i < xs.size(); i++) {\n\t\t\tv += xs.at(i);\n\t\t}\n\t\treturn v;\n\t}\n\tcase '*': {\n\t\tint v = xs.at(0);\n\t\tfor (int i = 1; i < xs.size(); i++) {\n\t\t\tv *= xs.at(i);\n\t\t}\n\t\treturn v;\n\t}\n\t}\n\n\treturn xs.at(0);\n}\n\nint main() {\n\twhile (true)\n\t{\n\t\tint n;\n\t\tstd::cin >> n;\n\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\n\t\tint depth = -1;\n\n\t\tstd::stack<char> ops;\n\t\tops.push(0);\n\t\tstd::stack<std::vector<int>> vstack;\n\n\t\tstd::vector<int> vs;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tstd::string s;\n\t\t\tstd::cin >> s;\n\t\t\t\n\t\t\tint d = std::count(s.begin(), s.end(), '.');\n\t\t\ts = s.substr(d);\n\n\t\t\tif (d < depth) {\n\t\t\t\tfor (; depth != d; depth--) {\n\t\t\t\t\t\n\t\t\t\t\tint tmp = calc(ops.top(), vs);\n\t\t\t\t\tvs = vstack.top();\n\t\t\t\t\tvs.push_back(tmp);\n\t\t\t\t\tvstack.pop();\n\t\t\t\t\tops.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdepth = d;\n\n\t\t\ttry {\n\t\t\t\tint tmp = std::stoi(s);\n\t\t\t\tvs.push_back(tmp);\n\t\t\t}\n\t\t\tcatch (...) {\n\t\t\t\tops.push(s.at(0));\n\t\t\t\tvstack.push(vs);\n\t\t\t\tvs.clear();\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\n\t\tint v = 0;\n\t\twhile(true) {\n\t\t\t\n\t\t\tv = calc(ops.top(), vs);\n\t\t\tif (--depth <= 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tops.pop();\n\t\t\tvs = vstack.top();\n\t\t\tvs.push_back(v);\n\t\t\tvstack.pop();\n\t\t}\n\t\tstd::cout << v << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define FOR(i, s, n) for (int i = (s); i < (n); i++)\n#define RFOR(i, s, n) for (int i = (n) - 1; i >= (s); i--)\n#define REP(i, n) FOR(i, 0, n)\n#define RREP(i, n) RFOR(i, 0, n)\n#define ALL(a) a.begin(), a.end()\n#define IN(a, x, b) (a <= x && x < b)\nconst long long MOD = 1e9+7, INF = 1e18;\ntemplate<class T>inline bool CHMAX(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool CHMIN(T&a,T b){if(a>b){a=b;return true;}return false;}\n\nint N;\nint used;\n\nint f(int ret,vector<string>&v){\n\tif(isdigit(v[used][v[used].size()-1])){\n\t\treturn v[used][v[used].size()-1] - '0';\n\t}\n\tint sz = v[used].size();\n\tint kigou = v[used][v[used].size()-1] == '*';\n\tint RETURN = kigou;\n\twhile(used+1<N&&v[used+1].size() == sz + 1){\n\t\tused++;\n\t\tif(kigou)RETURN *= f(kigou,v);\n\t\telse RETURN += f(kigou,v);\n\t}\n\treturn RETURN;\n}\n\nsigned main(){\n\tvector<int>ans;\n\twhile(cin>>N,N){\n\t\tvector<string>v;\n\t\tREP(i,N){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tv.push_back(s);\n\t\t}\n\t\tused = 0;\n\t\tans.push_back(f(0,v));\n\t}\n\tfor(auto e:ans)cout<<e<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define all(c) c.begin(),c.end()\n#define sz(c) ((int)c.size())\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\n\nint depth(string line) {\n    int r = 0;\n    rep(i, 0, sz(line)) {\n        if (line[i] == '.') r++;\n        else break;\n    }\n    return r;\n}\n\nsigned main() {\n    while (1) {\n        int n;\n        cin >> n;\n        if (n == 0) break;\n\n        vector<string> s(n);\n        rep(i, 0, n) cin >> s[i];\n\n        map<int, stack<int>> elem;\n        \n        // d --> d - 1 \n        auto prop = [&](int d) {\n            stack<int> buf;\n            while (elem[d].size()) {\n                int x = elem[d].top(); elem[d].pop();\n                if (x >= 0) buf.push(x);\n                else if (x == -1) {\n                    int sum = 0;\n                    while (buf.size()) {\n                        sum += buf.top();\n                        buf.pop();\n                    }\n                    elem[d - 1].push(sum);\n                } else {\n                    int prd = 1;\n                    while (buf.size()) {\n                        prd *= buf.top();\n                        buf.pop();\n                    }\n                    elem[d - 1].push(prd);\n                }\n            }\n        };\n\n        int d = 0;\n        rep(i, 0, n) {\n            int t = depth(s[i]);\n            while (t < d) {\n                prop(d);\n                d--;\n            }\n\n            d = t;\n            if (s[i][t] == '+') {\n                elem[t + 1].push(-1);\n            } else if (s[i][t] == '*') {\n                elem[t + 1].push(-2);\n            } else {\n                int num = s[i][t] - '0';\n                elem[t].push(num);\n            }\n        }\n        while (d > 0) {\n            prop(d);\n            d--;\n        }\n        cout << elem[0].top() << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef pair<char, int> P;\n \nint idx, N;\n \nint solve(vector<P> &v)\n{\n    char c = v[idx].first, d = v[idx].second;\n     \n    idx++;\n    if (isdigit(c)) {\n        return c - '0';\n    } else {\n        int res = (c == '*');\n        while (idx < N && d < v[idx].second) {\n            if (c == '*') {\n                res *= solve(v);\n            } else {\n                res += solve(v);\n            }\n        }\n        return res;\n    }\n}\n \nint main()\n{\n    while (cin >> N, N) {\n        vector<P> v(N);\n        string s;\n        for (int i = 0; i < N; i++) {\n            cin >> s;\n            v[i] = P(s.back(), s.size()-1);\n        }\n        idx = 0;\n        cout << solve(v) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1e9\n#define ll long long\n#define ull unsigned long long\n#define M 1000000007\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define RFOR(i,m,n) for(int i=m;i>=n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n\n\nvoid f(int n){\n  vector<ll> v[1000];\n  vector<char> w[1000];\n\n  rep(i,n){\n    string s;\n    cin>>s;\n    int c = s[s.size()-1];\n    if('0'<=c&&c<='9'){\n      v[s.size()-1].push_back(c-'0');\n    }\n    else{\n      w[s.size()].push_back(c);\n    }\n  }\n\n  RFOR(i,100,1){    \n    if(!v[i].size()) continue;\n    ll s = v[i][0];\n    FOR(j,1,v[i].size()){\n      if(w[i][0]=='+') s+= v[i][j];\n      if(w[i][0]=='*') s*= v[i][j];\n    }\n    v[i-1].push_back(s);\n  }\n\n  cout<<v[0][0]<<endl;\n}\n\nint main(){\n  \n  while(1){\n    int n;\n    cin>>n;\n    if(n==0) break;\n    f(n);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> Q;\n\nint main() {\n\tint n;\n\twhile (cin >> n) {\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tstring s;\n\t\tvector<Q> d(n);\n\t\tint mlevel = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> s;\n\t\t\tint cc = 0;\n\t\t\tfor (int j = 0; j < s.size(); j++) {\n\t\t\t\tif (s[j] == '.') {\n\t\t\t\t\tcc++;\n\t\t\t\t} else if (0 <= s[j]-'0' && s[j]-'0' <= 9) {\n\t\t\t\t\tcc--;\n\t\t\t\t\td[i].first = cc;\n\t\t\t\t\t(d[i].second).first = 0;\n\t\t\t\t\t(d[i].second).second = s[j]-'0';\n\t\t\t\t} else {\n\t\t\t\t\td[i].first = cc;\n\t\t\t\t\t(d[i].second).first = 1;\n\t\t\t\t\tint k = 0;\n\t\t\t\t\tif (s[j] == '+') {\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t} else if (s[j] == '-') {\n\t\t\t\t\t\tk = 1;\n\t\t\t\t\t} else if (s[j] == '*') {\n\t\t\t\t\t\tk = 2;\n\t\t\t\t\t} else if (s[j] == '/') {\n\t\t\t\t\t\tk = 3;\n\t\t\t\t\t}\n\t\t\t\t\t(d[i].second).second = k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmlevel = max(mlevel, cc);\n\t\t}\n\t\t//cout << mlevel << endl;\n\t\tvector<Q> d2;\n\t\twhile (true) {\n\t\t\tif (mlevel == -1) {\n\t\t\t\tcout << (d[0].second).second << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int i = 0; i < d.size(); i++) {\n\t\t\t\tif (d[i].first == mlevel) {\n\t\t\t\t\tint kc;\n\t\t\t\t\tif ((d[i].second).second == 0) {\n\t\t\t\t\t\tkc = 0;\n\t\t\t\t\t\tfor (int j = i+1; j < d.size(); j++) {\n\t\t\t\t\t\t\tif (d[j].first == mlevel && (d[j].second).first == 0) {\n\t\t\t\t\t\t\t\t//cout << j << ' ' << (d[j].second).second << endl;\n\t\t\t\t\t\t\t\tkc += (d[j].second).second;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkc = 1;\n\t\t\t\t\t\tfor (int j = i+1; j < d.size(); j++) {\n\t\t\t\t\t\t\tif (d[j].first == mlevel && (d[j].second).first == 0) {\n\t\t\t\t\t\t\t\tkc *= (d[j].second).second;\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//cout << mlevel << ' ' << kc << endl;\n\t\t\t\t\td2.push_back(Q(mlevel-1, P(0, kc)));\n\t\t\t\t} else {\n\t\t\t\t\td2.push_back(d[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\td = d2;\n\t\t\tmlevel--;\n\t\t\td2.clear();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <set>\n#include <stdio.h>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nbool solve() {\n  int n;\n  cin >> n;\n  if (n == 0)\n    return false;\n  vector<string> s(n);\n  for (int i = 0; i < n; i++)\n    cin >> s[i];\n  reverse(s.begin(), s.end());\n  vector<long long> v;\n  int indent = 0;\n  for (int i = 0; i < n; i++) {\n    int ind = 0;\n    for (; s[i][ind] == '.'; ind++)\n      ;\n    if (indent < ind) {\n      for (int j = 0; j < ind - indent; j++)\n        v.push_back(-1);\n    }\n    indent = ind;\n\n    if (s[i][ind] == '+' || s[i][ind] == '*') {\n      long long ret = (s[i][ind] == '+') ? 0 : 1;\n      while (v[v.size() - 1] >= 0) {\n        if (s[i][ind] == '+') {\n          ret += v[v.size() - 1];\n        } else {\n          ret *= v[v.size() - 1];\n        }\n        v.pop_back();\n      }\n      v.pop_back();\n      v.push_back(ret);\n    } else {\n      v.push_back(s[i][ind] - '0');\n    }\n  }\n  cout << v[0] << endl;\n  return true;\n}\n\nint main() {\n  while (solve())\n    ;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1e9\n#define ll long long\n#define ull unsigned long long\n#define M 1000000007\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=m;i<n;i++)\n#define RFOR(i,m,n) for(int i=m;i>=n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n\n\nvoid f(int n){\n  vector<int> v[1000];\n  vector<char> w[1000];\n\n  rep(i,n){\n    string s;\n    cin>>s;\n    int c = s[s.size()-1];\n    if('0'<=c&&c<='9'){\n      v[s.size()-1].push_back(c-'0');\n    }\n    else{\n      w[s.size()].push_back(c);\n    }\n  }\n\n  RFOR(i,100,1){    \n    if(!v[i].size()) continue;\n    int s = v[i][0];\n    FOR(j,1,v[i].size()){\n      if(w[i][0]=='+') s+= v[i][j];\n      if(w[i][0]=='*') s*= v[i][j];\n    }\n    v[i-1].push_back(s);\n  }\n\n  cout<<v[0][0]<<endl;\n}\n\nint main(){\n  \n  while(1){\n    int n;\n    cin>>n;\n    if(n==0) break;\n    f(n);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst long long LINF=8931145141919364364,LMOD=998244353;\n// const int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\nint dfs(vector<pair<char, int>> &str, int &now) {\n    char op = str[now].first;\n    int depth = str[now].second + 1;\n    if(op == '+') {\n        --now;\n        int ret = 0;\n        while(now >= 0 and depth <= str[now].second) {\n            if(str[now].first == '+' or str[now].first == '*') {\n                ret += dfs(str, now);\n            } else {\n                ret += str[now].first - '0';\n                --now;\n            }\n        }\n        return ret;\n    } else if(op == '*') {\n        --now;\n        int ret = 1;\n        while(now >= 0 and depth <= str[now].second) {\n            if(str[now].first == '+' or str[now].first == '*') {\n                ret *= dfs(str, now);\n            } else {\n                ret *= str[now].first - '0';\n                --now;\n            }\n        }\n        return ret;\n    }\n    return 0;\n}\n\nint solve(int &n) {\n    // {num/op, depth}\n    vector<pair<char, int>> str(n);\n    for(int i = n - 1; i >= 0; --i) {\n        string s; cin >> s;\n        str[i] = {s.back(), s.size() - 1};\n    }\n    int now = n - 1;\n    if(str[now].first == '+') return dfs(str, now);\n    if(str[now].first == '*') return dfs(str, now);\n    return str[now].first - '0';\n}\n\nint main() {\n    int n;\n    while(cin >> n and n > 0) {\n        int ans = solve(n);\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef string::const_iterator State;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<long long>vll;\ntypedef pair<int,int> pi;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\nint number(string s){\n  int ret=0;\n  for(int i=0;i<(int)s.size();i++){\n    if(isdigit(s[i])){\n      ret*=10;\n      ret+=(s[i]-'0');\n    }else{\n      break;\n    }\n  }\n  return ret;\n}\n\nint calc(int ret,int num,char x){\n  if(ret==-1)return num;\n  if(x=='+')return ret+num;\n  if(x=='-')return ret-num;\n  if(x=='*')return ret*num;\n  if(x=='/')return ret/num;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    string s;\n    vector<pair<int,string> > v(n);\n    int maxi=0;\n    rep(i,n){\n      cin>>s;\n      int cnt=0;\n      for(int j=0;j<s.size();j++){\n\tif(s[j]=='.')cnt++;\n      }\n      maxi=max(maxi,cnt);\n      s.erase(s.begin(),s.begin()+cnt);\n      v[i].first=cnt;\n      v[i].second=s;\n    }\n    maxi--;\n    \n    while(v.size()!=1){  \n      bool update=false;\n      for(int i=0;i<v.size();i++){\n\tint start;\n        if(v[i].first==maxi&&!isdigit(v[i].second[0])){\n\t  start=i;\n\t  char c=v[i].second[0];\n\t  i++;\n\t  int ret=-1;\n\t  while(i<v.size()&&v[i].first==maxi+1){\n\t    // cout<<v[i].second<<endl;\n\t    ret=calc(ret,number(v[i].second),c);\n\t    i++;\n\t  }\n\t  v[start].second=to_string(ret);\n\t  v.erase(v.begin()+start+1,v.begin()+i);\n\t  update=true;\n\t  break;\n\t}\n      }\n      // cout<<\"debug >> \"<<endl;\n      // for(auto x : v)cout<<x.first<<\" \"<<x.second<<endl;\n      if(!update)maxi--;\n    }\n    cout<<v[0].second<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nvector<string> S(100, \"\");\n\nint rec(int& idx, int depth) {\n    if (isdigit(S[idx][depth])) {\n        return (S[idx++][depth] - '0');\n    } else if (S[idx++][depth] == '+') {\n        int ret = 0;\n        while (S[idx].size() > depth + 1) ret += rec(idx, depth + 1);\n        return (ret);\n    } else {\n        int ret = 1;\n        while (S[idx].size() > depth + 1) ret *= rec(idx, depth + 1);\n        return (ret);\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n, n) {\n        for (int i = 0; i < n; i++) {\n            cin >> S[i];\n        }\n        S[n] = \"\";\n        int idx = 0;\n        cout << rec(idx, 0) << endl;\n    }\n}\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Data.Char (digitToInt)\n\nmain :: IO ()\nmain = do\n  n <- readLn\n  unless (n == 0) $ do\n    solve <$> replicateM n getLine >>= print\n    main\n\nsolve :: [String] -> Int\nsolve = snd . head . foldr f []\n  where\n    f s st\n      | c == '+' = (l, sum . map snd $ as): bs\n      | c == '*' = (l, product . map snd $ as): bs\n      | otherwise = (l, digitToInt c):st\n      where\n        l = length s\n        c = last s\n        (as, bs) = span ((== l+1) . fst) st\n\n"
  },
  {
    "language": "Haskell",
    "code": "mul [] = 1\nmul (a:as) = a * (mul as)\n\ntakeSub r = map tail $ takeWhile (\\ a -> '.' == (head a)) r\ndropSub r = dropWhile (\\ a -> '.' == (head a)) r\n\nfunc op r = op $ calc2 $ takeSub r\n\ncalc2 [] = []\ncalc2 (\"+\":r) = (func sum r):(calc2 $ dropSub r)\ncalc2 (\"*\":r) = (func mul r):(calc2 $ dropSub r)\ncalc2 (n:r) = (read n):(calc2 r)\n\ncalc1 (\"+\":r) = func sum r\ncalc1 (\"*\":r) = func mul r\n\ncalc1 (n:_) = read n :: Int\n\nans (\"0\":_) = []\nans (n:ns) =\n  let n'= read n :: Int\n      d = take n' ns\n      r = drop n' ns\n      a = calc1 d\n  in\n    a:(ans r)\n\nmain = do\n  c <- getContents\n  let i = lines c\n      o = ans i\n  mapM_ print o\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Data.List\nmain = readLn >>= main'\n    where\n        main' 0 = return ()\n        main' n = replicateM n getLine >>= print . solve >> main\n\ndata Elem = Val { val :: Int } | Sum | Prod\n    deriving (Show, Eq)\n\nsolve :: [String] -> Int\nsolve = consumeAll . foldl' ff ([], [])\n    where\n        ff (acc, ds) x\n            | null ds || head ds <= d = (next : acc, d : ds)\n            | otherwise = ff (acc', ds') x\n            where\n                d = depth x\n                x' = drop d x\n                next\n                    | x' == \"*\" = Prod\n                    | x' == \"+\" = Sum\n                    | otherwise = Val $ read x'\n                (acc', ds') = consume (head ds) acc ds\n\n        depth = inner 0\n            where\n                inner n (x : xs)\n                    | x == '.' = inner (n + 1) xs\n                    | otherwise = n\n\n        consume 0 vs ds = (vs, ds)\n        consume n vs ds\n            | v' == Sum = (sum' ys : vs', ds')\n            | otherwise = (product' ys : vs', ds')\n            where\n                (ys, v' : vs') = splitAt c vs\n                ds' = drop c ds\n                c = count ds\n                count = inner 0\n                    where\n                        inner m (x : xs)\n                            | n == x = inner (m + 1) xs\n                            | otherwise = m\n                        inner m _ = m\n\n                sum' = Val . foldl' (\\acc x -> acc + val x) 0\n                product' = Val . foldl' (\\acc x -> acc * val x) 1\n\n        consumeAll (vvs@(v : _), dds@(d : _))\n            | d == 0 = val v\n            | otherwise = consumeAll (vs, ds)\n            where\n                (vs, ds) = consume d vvs dds"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint n;\nchar raw_data[1000][128];\nint kaisou[1000];\nchar* data[1000];\n\nint calc(int pos) {\n\tif (data[pos][0] == '+' || data[pos][0] == '*') {\n\t\tint ret = (data[pos][0] == '+' ? 0 : 1);\n\t\tint i;\n\t\tfor (i = pos + 1; i < n && kaisou[i] > kaisou[pos]; i++) {\n\t\t\tif (kaisou[i] == kaisou[pos] + 1) {\n\t\t\t\tif (data[pos][0] == '+') ret += calc(i);\n\t\t\t\telse ret *= calc(i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t} else {\n\t\treturn atoi(data[pos]);\n\t}\n}\n\nint main(void) {\n\twhile (scanf(\"%d\", &n) == 1 && n > 0) {\n\t\tint i, j;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (scanf(\"%s\", raw_data[i]) != 1) return 1;\n\t\t\tfor (j = 0; raw_data[i][j] == '.'; j++);\n\t\t\tkaisou[i] = j;\n\t\t\tdata[i] = raw_data[i] + j;\n\t\t}\n\t\tprintf(\"%d\\n\", calc(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint i, n, val[500], depth[500];\n\nint func(){\n\tint ans, now;\n\n\tif(isdigit(val[i])){\n\t\treturn val[i++] - '0';\n\t}\n\n\tnow = i++;\n\tans = 1;\n\tif(val[now] == '+'){\n\t\twhile(depth[now] == depth[i]-1){\n\t\t\tans += func();\n\t\t}\n\t\tans--;\n\t} else{\n\t\twhile(depth[now] == depth[i]-1){\n\t\t\tans *= func();\n\t\t}\n\t}\n\n\treturn ans;\n}\n\n\n\nint main(void){\n\tint  ans;\n\tchar tmp[500];\n\n\twhile(1){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%s\", tmp);\n\t\t\tdepth[i] = strlen(tmp)-1;\n\t\t\tval[i] = tmp[depth[i]];\n\t\t}\n\n\t\ti = 0;\n\t\tans = func();\n\t\tprintf(\"%d\\n\", ans);\n\t}//endwhile\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar s[1010][1010];\nint r;\nint f(int j){\n  int o=s[r][j]-'*'?0:1,ans=o,n;\n  while(s[r+1][j]=='.'){\n    r++;\n    if(s[r][j+1]=='+'||s[r][j+1]=='*')n=f(j+1);\n    else      n=s[r][j+1]-'0';//printf(\"%d %d \",r,n);\n    if(o)ans*=n;\n    else ans+=n;//printf(\"%d\\n\",ans);\n  }\n  return ans;\n}\nint main(){\n  int n,i;\n  while(scanf(\"%d\",&n),n){\n    for(i=r=0;i<1000*1000;i++)s[i/1000][i%1000]=0;\n    for(i=0;i<n;i++)scanf(\"%s\",s[i]);\n    printf(\"%d\\n\",n-1?f(0):s[0][0]-'0');\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nint main(void)\n{\n\tint i,j,k,l,m,a[20],c[20],d[20],S,S1,dmax;\n\tchar s[20],s1[2];\n\t\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&k);\n\t\tif(k==0) break;\n\t\tfor(i=0;i<=k-1;i++)\n\t\t{\n\t\t\tscanf(\"%s\",s);\n\t\t\td[i]=strlen(s)-1;\n\t\t\tif(s[strlen(s)-1]=='+')\n\t\t\t{\n\t\t\t\tc[i]=1;\n\t\t\t\ta[i]=-1;\n\t\t\t}\n\t\t\telse if(s[strlen(s)-1]=='*')\n\t\t\t{\n\t\t\t\tc[i]=2;\n\t\t\t\ta[i]=-1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc[i]=0;\n\t\t\t\ts1[0]=s[strlen(s)-1];\n\t\t\t\ts1[1]='\\0';\n\t\t\t\tsscanf(s1,\"%d\",&a[i]);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<=19;i++)\n\t\t{\n\t\t\tdmax=-1;\n\t\t\tfor(j=0;j<=k-1;j++)\n\t\t\t{\n\t\t\t\tif(dmax<d[j])\n\t\t\t\t{\n\t\t\t\t\tdmax=d[j];\n\t\t\t\t\tl=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dmax==1)\n\t\t\t{\n\t\t\t\tS1=a[1];\n\t\t\t\tif(c[0]==1)\n\t\t\t\t{\n\t\t\t\t\tfor(j=2;j<=k-1;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tS1+=a[j];\n\t\t\t\t\t}\n\t\t\t\t\ti=19;\n\t\t\t\t}\n\t\t\t\telse if(c[0]==2)\n\t\t\t\t{\n\t\t\t\t\tfor(j=2;j<=k-1;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tS1*=a[j];\n\t\t\t\t\t}\n\t\t\t\t\ti=19;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(dmax==0) \n\t\t\t{\n\t\t\t\tS1=a[0];\n\t\t\t\ti=19;\n\t\t\t}\n\t\t\tj=l;\n\t\t\twhile(j<=k-1 && dmax==d[j])\n\t\t\t{\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tm=j;\n\t\t\tS=a[l];\n\t\t\tfor(j=l+1;j<=m-1;j++)\n\t\t\t{\n\t\t\t\tif(c[l-1]==1)\n\t\t\t\t{\n\t\t\t\t\tS+=a[j];\n\t\t\t\t}\n\t\t\t\telse if(c[l-1]==2)\n\t\t\t\t{\n\t\t\t\t\tS*=a[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\ta[l-1]=S;\n\t\t\tc[l-1]=0;\n\t\t\tfor(j=l;j<=k-m+l-1;j++)\n\t\t\t{\n\t\t\t\ta[j]=a[j+m-l];\n\t\t\t\tc[j]=c[j+m-l];\n\t\t\t\td[j]=d[j+m-l];\n\t\t\t}\n\t\t\tk=k-m+l;\n\t\t}\n\t\tprintf(\"%d\\n\",S1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n\nint i, n, val[50], depth[50];\n\n\nint func(){\n\tint ans, now;\n\n\tif(isdigit(val[i])){\n\t\treturn val[i++] - '0';\n\t}\n\n\tnow = i++;\n\tans = 1;\n\tif(val[now] == '+'){\n\t\twhile(depth[now] == depth[i]-1){\n\t\t\tans += func();\n\t\t}\n\t\tans--;\n\t} else{\n\t\twhile(depth[now] == depth[i]-1){\n\t\t\tans *= func();\n\t\t}\n\t}\n\n\treturn ans;\n}\n\n\n\nint main(void){\n\tint  ans;\n\tchar tmp[50];\n\n\twhile(1){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%s\", tmp);\n\t\t\tdepth[i] = strlen(tmp)-1;\n\t\t\tval[i] = tmp[depth[i]];\n\t\t}\n\n\t\ti = 0;\n\t\tans = func();\n\t\tprintf(\"%d\\n\", ans);\n\t}//endwhile\n\t\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint i, n, val[50], depth[50];\n\nint func(){\n\tint ans, now;\n\n\tif(isdigit(val[i])){\n\t\treturn val[i++] - '0';\n\t}\n\n\tnow = i++;\n\tans = 1;\n\tif(val[now] == '+'){\n\t\twhile(depth[now] == depth[i]-1){\n\t\t\tans += func();\n\t\t}\n\t\tans--;\n\t} else{\n\t\twhile(depth[now] == depth[i]-1){\n\t\t\tans *= func();\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(void){\n\tint  ans;\n\tchar tmp[50];\n\n\twhile(1){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tscanf(\"%s\", tmp);\n\t\t\tdepth[i] = strlen(tmp)-1;\n\t\t\tval[i] = tmp[depth[i]];\n\t\t}\n\n\t\ti = 0;\n\t\tans = func();\n\t\tprintf(\"%d\\n\", ans);\n\t}//endwhile\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1602\n  Title:ICPC caluculator\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n\nint N;\nchar line[17][15];\n\n\nint get_level(char *p)\n{\n  if(*p != '.')\n    return(0);\n  return (1+get_level(p+1));\n}\n\n\nint evaluate(int ln,int level)\n{\n  int   i,ret;\n\n  if(isdigit(line[ln][level]))\n    return(line[ln][level]-'0');\n  else if (line[ln][level]=='+')\n    {\n      ret=0;\n      for(i=ln+1;i<N;i++)\n\t{\n\t  if(get_level(&line[i][0])==level)\n\t    break;\n\t  if(get_level(&line[i][0])==level+1)\n\t    ret += evaluate(i,level+1);\n\t}\n    }\n  else if (line[ln][level]=='*')\n    {\n      ret=1;\n      for(i=ln+1;i<N;i++)\n\t{\n\t  if(get_level(&line[i][0])==level)\n\t    break;\n\t  if(get_level(&line[i][0])==level+1)\n\t    ret *= evaluate(i,level+1);\n\t}\n    }\n  return(ret);\n}\n\nmain()\n{\n  int i,ret;\n  \n\n  while(scanf(\"%d\",&N)  && (N))\n    {\n      for(i=0;i<N;i++)\n\t{\n\t  scanf(\"%s\",&line[i][0]);\n\t  //printf(\"%s [%d]\\n\",&line[i][0],get_level(&line[i][0]));\n\t}\n      ret=evaluate(0,0);\n      printf(\"%d\\n\",ret);\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint n;\nchar buff[17][10];\n\nint calc(int line) {\n\tchar c;\n\tint level, val, arg;\n\tlevel = strlen(buff[line]) - 1;\n\tc = buff[line][level];\n\tswitch(c){\n\tcase'*':\n\t\tline++;\n\t\tval = 1;\n\t\twhile (1){\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval *= arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tcase'+':\n\t\tline++;\n\t\tval = 0;\n\t\twhile (1) {\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval += arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tdefault:\n\t\treturn c;\n\t\tbreak;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)return 0;;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%s\", buff[i][0]);\n\t\t\tprintf(\"%d\\n\", calc(0));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define NLINE 17\n// \n式の行数の最大値\n#define LEN 9\n// \n式の１行の長さの最大値\nint n;\n// \n式の行数\nchar buff[NLINE][LEN+1];\n// \n式を格納する配列\n// line\n行目を評価して値を返す関数\nint calc(int line)\n{\nchar c;\n// \n処理内容を示す文字（数字\n, *, +\n）\nint level;\n// \n現在の行の入れ子レベル\nint val;\n// \n評価結果を入れる変数\nint arg;\n// \n演算の引数の値を入れる変数\nlevel = strlen(buff[line]) \n-\n1;\n// \n自分の入れ子レベル\nc = buff[line][level];\n// c\nはこのレベルでの処理内容\nswitch(c){\ncase '*':\n// \n乗算\nline++;\n// \n次の行から引数の値を順に評価\nval = 1;\n// \nとりあえず結果を\n1\nとする\nfor(;;){\nif(strlen(buff[line])\n-\n1 <= level) break;\n// \n引数の評価は終了\nif(strlen(buff[line])\n-\n1 == level+1){\n// \n評価すべきレベルなら\narg = calc(line);\n// \n引数の値を再帰的に求め\nval *= arg;\n// val \nにかける。\n}\nline++;\n// \n次の行へ\nif(line >= n) break;\n// \n全ての行をチェックした！\n}\nreturn val;\n// \n評価結果を返す\ncase '+':\n// \n加算\nline++;\n// \n次の行から引数の値を順に評価\nval = 0;\n// \nとりあえず結果を\n0\nとする\nfor(;;){\nif(strlen(buff[line])\n-\n1 <= level) break;\n// \n引数の評価は終了\nif(strlen(bu\nff[line])\n-\n1 == level+1){\n// \n評価すべきレベルなら\narg = calc(line);\n// \n引数の値を再帰的に求め\nval += arg;\n// val \nにたす。\n}\nline++;\n// \n次の行へ\nif(line >= n) break;\n// \n全ての行をチェックした！\n}\nreturn val;\n// \n評価結果を返す\ndefault:\n// \n１桁の整数\nreturn c \n-\n'0'\n;\n// \n対応する整数値を返す\n}\n}\nint main(void)\n{\nfor(;;){\nint i;\nscanf(\"%d\", &n);\n// \n式の行数\nn\nを読み込む\nif(n==0) break;\n// n\nが\n0\nなら終了\nfor(i=0; i<n; i++)\n// n\n行分の式を読み込む\nscanf(\"%s\", &buff[i][0]);\nprintf(\"%d\n¥\nn\", calc(0));\n// \n式を評価した結果をプリント\n}\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nchar s[1010][1010];\nint r;\nint f(int j){\n  int o=s[r][j]-'*'?0:1,ans=o,n;\n  while(s[r+1][j]=='.'){\n    r++;\n    if(s[r][j+1]=='+'||s[r][j+1]=='*')n=f(j+1);\n    else      n=s[r][j+1]-'0';//printf(\"%d %d \",r,n);\n    if(o)ans*=n;\n    else ans+=n;//printf(\"%d\\n\",ans);\n  }\n  return ans;\n}\nint main(){\n  int n,i;\n  while(scanf(\"%d\",&n),n){\n    for(i=0;i<1000*1000;i++)s[i/1000][1%1000]=0;\n    for(i=0;i<n;i++)scanf(\"%s\",s[i]);\n    printf(\"%d\\n\",n-1?f(r=0):s[0][0]-'0');\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define _USE_MATH_DEFINES\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <ctype.h>\n#include <limits.h>    \n#define inf 100000000\n#define INF 9223372036854775807\n#define EPS 1e-10\n#define sq(n) ((n)*(n))\n#define rep(i,n) for(i=0;i<n;i++)\n#define rev(i,n) for(i=n-1;i>=0;i--)\n#define sort(a,n) qsort(a,n,sizeof(TYPE),cmp)\n#define sort_r(a,n) qsort(a,n,sizeof(TYPE),cmp_r);\n#define chsort(s,n) qsort(s,n,sizeof(char),cmp)\n#define chsort_r(s,n) qsort(s,n,sizeof(char),char_cmp_r);\n#define TYPE long long\n#define MEMSET(a) memset(a,0,sizeof(a))\nlong long mod=(long long)1e09+7;\n\nint in(void){\n    int i;scanf(\"%d\",&i);\n    return i;\n}\nlong long llin(void){\n    long long i;scanf(\"%lld\",&i);\n    return i;\n}\ndouble din(void){\n    double i;scanf(\"%lf\",&i);\n    return i;\n}\nvoid chin(char s[]){\n    scanf(\"%s\",s);\n}\nvoid print(int a){\n    printf(\"%d\\n\",a);\n}\nvoid llprint(long long a){\n    printf(\"%lld\\n\",a);\n}\nvoid dprint(double a){\n    printf(\"%.10f\\n\",a);\n}\nvoid print2(int a,int b){\n    printf(\"%d %d\\n\",a,b);\n}\nlong long max(long long a,long long b){\n    return a>b?a:b;\n}\nlong long min(long long a,long long b){\n    return a<b?a:b;\n}\nint cmp(const void *a,const void *b){\n    return *(TYPE *)a-*(TYPE *)b;\n}\nint cmp_r(const void *a,const void *b){\n    return *(TYPE *)b-*(TYPE *)a;\n}\nint char_cmp(const void *a,const void *b){\n    return strcmp((char *)a,(char *)b);\n}\nint char_cmp_r(const void *a,const void *b){\n    return strcmp((char *)b,(char *)a);\n}\nvoid swap(int *a,int *b){\n    int t=*a;\n    *a=*b;\n    *b=t;\n}\nlong long gcd(long long x,long long y){\n    return x%y?gcd(y,x%y):y;\n}\nlong long lcm(long long x,long long y){\n    return x/gcd(x,y)*y;\n}\n\n// write codes below this\n// when you use 'sort',\n// make sure TYPE macro is correct\nint n;\nchar s[50][50];\nint add(int i,int j);\nint mul(int i,int j);\nint add(int i,int j){\n    int k,l,m=0,c;\n    int tmp[10];\n    int ret;\n    for(k=i;k<n;k++){\n        for(l=c=0;s[k][l];l++)c+=(s[k][l]=='.');\n        if(c>j)continue;\n        if(c<j)break;\n        if(s[k][j]=='+')\n            tmp[m]=add(k+1,j+1);\n        else if(s[k][j]=='*')\n            tmp[m]=mul(k+1,j+1);\n        else\n            tmp[m]=s[k][j]-'0';\n        m++;\n    }\n    ret=tmp[0];\n    for(k=1;k<m;k++)\n        ret+=tmp[k];\n    return ret;\n}\nint mul(int i,int j){\n    int k,l,m=0,c;\n    int tmp[10];\n    int ret;\n    for(k=i;k<n;k++){\n        for(l=c=0;s[k][l];l++)c+=(s[k][l]=='.');\n        if(c>j)continue;\n        if(c<j)break;\n        if(s[k][j]=='+')\n            tmp[m]=add(k+1,j+1);\n        else if(s[k][j]=='*')\n            tmp[m]=mul(k+1,j+1);\n        else\n            tmp[m]=s[k][j]-'0';\n        m++;\n    }\n    ret=tmp[0];\n    for(k=1;k<m;k++)\n        ret*=tmp[k];\n    return ret;\n}\nint main(void){\n    int i;\n    while(n=in()){\n        rep(i,n)chin(s[i]);\n        if(s[0][0]=='+')print(add(1,1));\n        else if(s[0][0]=='*')print(mul(1,1));\n        else printf(\"%c\\n\",s[0][0]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint n;\nchar buff[17][10];\n\nint calc(int line) {\n\tchar c;\n\tint level, val, arg;\n\tlevel = strlen(buff[line]) - 1;\n\tc = buff[line][level];\n\tswitch(c){\n\tcase'*':\n\t\tline++;\n\t\tval = 1;\n\t\twhile (1){\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval *= arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tcase'+':\n\t\tline++;\n\t\tval = 0;\n\t\twhile (1) {\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval += arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tdefault:\n\t\treturn c;\n\t\tbreak;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)break;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tscanf(\"%s\", buff[i][0]);\n\t\t\tprintf(\"%d\\n\", calc(0));\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nchar s[50][50];\nint n;\nint i;\nint f1(int x);\nint f2(int x);\nint f1(int x)\n{\n\tint res = 0;\n\tint d = strlen(s[x]);\n\ti = x + 1;\n\tfor (; i < n; i++)\n\t{\n\t\tif (strlen(s[i]) != d + 1)\n\t\t\tbreak;\n\t\tif (s[i][d] >= '0' && s[i][d] <= '9')\n\t\t\tres += s[i][d] - '0';\n\t\tif (s[i][d] == '+')\n\t\t\tres += f1(i);\n\t\tif (s[i][d] == '*')\n\t\t\tres += f2(i);\n\t}\n\ti--;\n\treturn res;\n}\nint f2(int x)\n{\n\tint res = 1;\n\tint d = strlen(s[x]);\n\ti = x + 1;\n\tfor (; i < n; i++)\n\t{\n\t\tif (strlen(s[i]) != d + 1)\n\t\t\tbreak;\n\t\tif (s[i][d] >= '0' && s[i][d] <= '9')\n\t\t\tres *= s[i][d] - '0';\n\t\tif (s[i][d] == '+')\n\t\t\tres *= f1(i);\n\t\tif (s[i][d] == '*')\n\t\t\tres *= f2(i);\n\t}\n\ti--;\n\treturn res;\n}\nint main()\n{\n\tint k, j;\n\tint ans[10002];\n\n\tfor (j = 0;; j++)\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tfor (k = 0; k < n; k++)\n\t\t\tscanf(\"%s\", s[k]);\n\t\tif (n == 1)\n\t\t{\n\t\t\tans[j] = s[0][0] - '0';\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[0][0] == '+')\n\t\t\tans[j] = f1(0);\n\t\telse\n\t\t\tans[j] = f2(0);\n\t}\n\tfor (k = 0; k < j; k++)\n\t\tprintf(\"%d\\n\", ans[k]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint n;\nchar buff[17][10];\n\nint calc(int line) {\n\tchar c;\n\tint level, val, arg;\n\tlevel = strlen(buff[line]) - 1;\n\tc = buff[line][level];\n\tswitch(c){\n\tcase'*':\n\t\tline++;\n\t\tval = 1;\n\t\twhile (1){\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval *= arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tcase'+':\n\t\tline++;\n\t\tval = 0;\n\t\twhile (1) {\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval += arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tdefault:\n\t\treturn c;\n\t}\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n)!=EOF) {\n\t\tif (n == 0)return 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%s\", buff[i][0]);\n\t\t\tprintf(\"%d\\n\", calc(0));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint n;\nchar s[20][20];\nint len[20];\nint dfs(int d,int k,int e){\n    int res=0;\n    if(e)res=1;\n    for(int i=d;i<n&&k<len[i];i++){\n        if(s[i][k]=='.')continue;\n        int a=s[i][k]-'0';\n        if(s[i][k]=='+')a=dfs(i+1,k+1,0);\n        if(s[i][k]=='*')a=dfs(i+1,k+1,1);\n        if(e)res*=a;\n        else res+=a;\n    }\n    return res;\n}int main(void){\n    while(1){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        for(int i=0;i<n;i++){\n            scanf(\"%s\",s[i]);\n            len[i]=strlen(s[i]);\n            //printf(\"%d\\n\",len[i]);\n        }\n        if(n==1) printf(\"%d\\n\",s[0][0]-'0');\n        else{\n            printf(\"%d\\n\",dfs(0,0,0));\n        }\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint n;\nchar buff[17][10];\n\nint calc(int line) {\n\tchar c;\n\tint level, val, arg;\n\tlevel = strlen(buff[line]) - 1;\n\tc = buff[line][level];\n\tswitch(c){\n\tcase'*':\n\t\tline++;\n\t\tval = 1;\n\t\twhile (1){\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval *= arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tcase'+':\n\t\tline++;\n\t\tval = 0;\n\t\twhile (1) {\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval += arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tdefault:\n\t\tif (line >= n)break;\n\t\treturn c;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%s\", buff[i][0]);\n\t\t\tprintf(\"%d\\n\", calc(0));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "// Aizu 1602: ICPC Calculator\n// 2017.9.21 bal4u@uu\n\n#include <stdio.h>\n#include <ctype.h>\n\nchar e[20][50]; int n;\n\nint calc(int lv, int *k)\n{\n\tint i, x, y, op, f, m;\n\tchar *p;\n\t\n\tm = *k;\n\tp = e[m]; for (i = 0; *p && i < lv; i++) *p++;\n\tif (isdigit(*p)) { *k = m+1; return *p - '0'; }\n\tif (!*p) return 0;  // Panic \n\top = *p, lv++, m++; if (op == '+') x = 0; else x = 1;\n\twhile (m < n) {\n\t\tf = 0;\n\t\tp = e[m]; for (i = 0; *p && i < lv; i++) if (*p++ != '.') break;\n\t\tif (i < lv) break;\n\t\tif (isdigit(*p)) y = *p - '0', f = 1;\n\t\telse             y = calc(lv, &m);\n\t\tif (op == '+') x += y; else x *= y;\n\t\tif (f) m++;\n\t}\n\t*k = m;\n\treturn x;\n}\n\nint main()\n{\n\tint i;\n\twhile (scanf(\"%d\", &n) && n) {\n\t\tfor (i = 0; i < n; i++) scanf(\"%s\", e[i]);\n\t\ti = 0; printf(\"%d\\n\", calc(0, &i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint n;\nchar buff[17][10];\n\nint calc(int line) {\n\tchar c;\n\tint level, val, arg;\n\tlevel = strlen(buff[line]) - 1;\n\tc = buff[line][level];\n\tswitch(c){\n\tcase'*':\n\t\tline++;\n\t\tval = 1;\n\t\twhile (1){\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval *= arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tcase'+':\n\t\tline++;\n\t\tval = 0;\n\t\twhile (1) {\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval += arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tdefault:\n\t\treturn c;\n\t\tbreak;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)break;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%s\", buff[i][0]);\n\t\t\tprintf(\"%d\\n\", calc(0));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n \nint N;\nchar line[17][15];\n \n \nint get_level(char *p)\n{\n  if(*p != '.')\n    return(0);\n  return (1+get_level(p+1));\n}\n \n \nint evaluate(int ln,int level)\n{\n  int   i,ret;\n \n  if(isdigit(line[ln][level]))\n    return(line[ln][level]-'0');\n  else if (line[ln][level]=='+')\n    {\n      ret=0;\n      for(i=ln+1;i<N;i++)\n    {\n      if(get_level(&line[i][0])==level)\n        break;\n      if(get_level(&line[i][0])==level+1)\n        ret += evaluate(i,level+1);\n    }\n    }\n  else if (line[ln][level]=='*')\n    {\n      ret=1;\n      for(i=ln+1;i<N;i++)\n    {\n      if(get_level(&line[i][0])==level)\n        break;\n      if(get_level(&line[i][0])==level+1)\n        ret *= evaluate(i,level+1);\n    }\n    }\n  return(ret);\n}\n \nmain()\n{\n  int i,ret;\n   \n \n  while(scanf(\"%d\",&N)  && (N))\n    {\n      for(i=0;i<N;i++)\n    {\n      scanf(\"%s\",&line[i][0]);\n      //printf(\"%s [%d]\\n\",&line[i][0],get_level(&line[i][0]));\n    }\n      ret=evaluate(0,0);\n      printf(\"%d\\n\",ret);\n    }\n  return(0);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nstruct cell{\n    int level;\n    char word;\n    struct cell *mother;\n    struct cell *child[30];\n    int count;\n};\n\nstruct cell *add(char inp[], struct cell *now);\nint calc(struct cell *now);\n\nint main(void) {\n    int n, i;\n    char inp[30];\n    struct cell node;\n    struct cell *now;\n    scanf(\"%d\",&n);\n    while(n) {\n        scanf(\"%s\",inp);\n        node.level = 1;\n        node.word = inp[0];\n        node.mother = NULL;\n        node.count = 0;\n        now = &node;\n        for(i = 1; i < n; i++) {\n            scanf(\"%s\",inp);\n            now = add(inp, now);\n        }\n        printf(\"%d\\n\",calc(&node));\n        scanf(\"%d\",&n);\n    }\n    return 0;\n}\n\nstruct cell *add(char inp[], struct cell *now) {\n    int len;\n    struct cell *new_one;\n    new_one = (struct cell *)malloc(sizeof(struct cell));\n    len = strlen(inp);\n    while(now->level+1 != len) {\n        now = now->mother;\n    }\n    new_one->level = now->level+1;\n    new_one->word = inp[len-1];\n    new_one->mother = now;\n    now->child[now->count] = new_one;\n    now->count++;\n    return new_one;\n}\n\nint calc(struct cell *now) {\n    int i, ans = 0;\n    if(now->word == '+') {\n        for(i = 0; i < now->count; i++) {\n            ans += calc(now->child[i]);\n        }\n    } else if(now->word == '*') {\n        ans = 1;\n        for(i = 0; i < now->count; i++) {\n            ans *= calc(now->child[i]);\n        }\n    } else {\n        return (now->word - '0' );\n    }\n    return ans;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=l;i<r;i++)\n\nll n,pos;\nchar s[20][20];\n\nll f(){\n\tll len=strlen(s[pos]);\n\tchar c=s[pos][len-1];\n\tif('0'<=c&&c<='9')return c-'0';\n\tll ans=(c=='+'?0:1);\n\twhile(strlen(s[pos+1])>len){\n\t\tpos++;\n\t\tll temp=f();\n\t\tans=(c=='+'?ans+temp:ans*temp);\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(scanf(\"%lld\",&n),n){\n\t\trep(i,0,n)scanf(\" %s\",s[i]);\n\t\ts[n][0]=0;\n\t\tpos=0;\n\t\tprintf(\"%lld\\n\",f());\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint n;\nchar buff[17][10];\n\nint calc(int line) {\n\tchar c;\n\tint level, val, arg;\n\tlevel = strlen(buff[line]) - 1;\n\tc = buff[line][level];\n\tswitch(c){\n\tcase'*':\n\t\tline++;\n\t\tval = 1;\n\t\twhile (1){\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval *= arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tcase'+':\n\t\tline++;\n\t\tval = 0;\n\t\twhile (1) {\n\t\t\tif (strlen(buff[line]) - 1 <= level)break;\n\t\t\tif (strlen(buff[line]) - 1 == level + 1) {\n\t\t\t\targ = calc(line);\n\t\t\t\tval += arg;\n\t\t\t}\n\t\t\tline++;\n\t\t\tif (line >= n)break;\n\t\t}\n\t\treturn val;\n\tdefault:\n\t\tif (line >= n)break;\n\t\treturn c;\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)break;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tscanf(\"%s\", buff[i][0]);\n\t\t\tprintf(\"%d\\n\", calc(0));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\npublic class Main {\n\t\n\tstatic List<P> data;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n=in.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tif(n==1) {\n\t\t\t\tint one=in.nextInt();\n\t\t\t\tSystem.out.println(one);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tdata=new ArrayList<>();\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tP p=new P();\n\t\t\t\tString str=in.next();\n\t\t\t\tp.c=str.toCharArray();\n\t\t\t\tdata.add(p);\n\t\t\t}\n\t\t\tSystem.out.println(calc(1,1,data.get(0).c[0]));\n\t\t}\n\t}\n\t\n\tstatic int calc(int level,int b,char op) {\n\t\tStack<Integer> stk=new Stack<>();\n\t\tint res;\n\t\t\n\t\tfor(int i=b;i<data.size();i++) {\n\t\t\t\n\t\t\tchar c[]=data.get(i).c;\n\t\t\tif(c.length<=level)break;\n\t\t\t//System.out.println(\"Level=\"+level+\" b=\"+i+\" data=\"+c[level]);\n\t\t\t\n\t\t\tif(c[level]=='*' || c[level]=='+') {\n\t\t\t\t//System.out.println(\"Level=\"+level+\":\"+c[level]);\n\t\t\t\tstk.push(calc(level+1,i+1,c[level]));\n\t\t\t}\n\t\t\telse if(c[level]>='0' && c[level]<='9')stk.push(c[level]-48);\n\t\t}\n\t\t\n\t\tif(op=='*') {\n\t\t\tres=1;\n\t\t\twhile(!stk.isEmpty()) res*=stk.pop();\n\t\t}\n\t\telse {\n\t\t\tres=0;\n\t\t\twhile(!stk.isEmpty())res+=stk.pop();\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n\n}\n\nclass P{\n\tchar c[];\n}\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\nimport java.util.stream.IntStream;\n\npublic class Main {\n    private static int n;\n    private static Deque<Deque<String>> stack;\n\n    public static void main(String... args) {\n        Scanner scanner = new Scanner(System.in);\n        while ((n = scanner.nextInt()) != 0) {\n            stack = new ArrayDeque<>();\n            IntStream.range(0, n)\n                .forEach(i -> {\n                        String l = scanner.next();\n                        int level = l.replaceFirst(\"[^.]\", \"\").length();                        // System.err.printf(\"level:%d%n\",level);\n                        if (stack.size() <= level) {\n                            stack.add(new ArrayDeque<String>());\n                        }\n                        calc(level);\n                        stack.peekLast().add(l.substring(l.length() - 1));\n                    });\n            calc(0);\n            System.out.println(stack.pop().pop());\n        }\n    }\n    private static void calc(int level) {\n        while (stack.size() > level + 1) {\n            Deque<String> args = stack.pollLast();\n            if (stack.isEmpty()) break;\n            String operator = stack.peekLast().pollLast();\n            if (operator.equals(\"*\")) {\n                // Specified (Long sum, String a) and (Long a, Long b) to avoid the compiler bug\n                // https://bugs.openjdk.java.net/browse/JDK-8129589\n                // JDK on Aizu Online Judge is too old!!\n                stack.peekLast().push(String.valueOf(args.stream().reduce(1l, (Long sum, String a) -> sum * Long.parseLong(a), (Long a, Long b) -> a * b)));\n            } else if (operator.equals(\"+\")) {\n                stack.peekLast().push(String.valueOf(args.stream().reduce(0l, (Long sum, String a) -> sum + Long.parseLong(a), (Long a, Long b) -> a + b)));\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int n;\n\tstatic char[][] buff=new char[17][10];\n\tstatic int[] length=new int[17];\n\t\n\tstatic int calc(int line) {\n\t\tchar c;\n\t\tint level, val;\n\t\tint arg;\n\t\tlevel=length[line]-1;\n\t\tc=buff[line][level];\n\t\tif(c=='*') {\n\t\t\tline++;\n\t\t\tval=1;\n\t\t\twhile(true) {\n\t\t\t\tif(length[line]-1<=level) break;\n\t\t\t\tif(length[line]-1==level+1) {\n\t\t\t\t\targ=calc(line);\n\t\t\t\t\tval*=arg;\n\t\t\t\t}\n\t\t\t\tline++;\n\t\t\t\tif(line>=n) break;\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t\telse if(c=='+') {\n\t\t\tline++;\n\t\t\tval=0;\n\t\t\twhile(true) {\n\t\t\t\tif(length[line]-1<=level) break;\n\t\t\t\tif(length[line]-1==level+1) {\n\t\t\t\t\targ=calc(line);\n\t\t\t\t\tval+=arg;\n\t\t\t\t}\n\t\t\t\tline++;\n\t\t\t\tif(line>=n) break;\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t\treturn c-'0';\n\t}\n\t\n\tpublic static void main(String args[]){\n\t\ttry(Scanner sc=new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tn=sc.nextInt();\n\t\t\t\tif(n==0) break;\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tString str=sc.next();\n\t\t\t\t\tlength[i]=str.length();\n\t\t\t\t\tfor(int j=0; j<str.length(); j++) {\n\t\t\t\t\t\tbuff[i][j]=str.charAt(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(calc(0));\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n} \n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * ICPC Calculator\n */\npublic class Main {\n\n\tstatic final char NOOP = ' ';\n\tstatic final char PLUS = '+';\n\tstatic final char MULTI = '*';\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = parseInt(line);\n\t\t\tif (n == 0) break;\n\n\t\t\tExp exp = main.new Exp(null, -1, PLUS);\n\t\t\tExp parent = exp;\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tline = br.readLine();\n\n\t\t\t\tint lv = 0;\n\t\t\t\tfor (char c : line.toCharArray()) {\n\t\t\t\t\tif (c == '.') {\n\t\t\t\t\t\tlv++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile (parent.lv >= lv) {\n\t\t\t\t\t\t\tparent = parent.parent;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tExp sub = main.new Exp(parent, lv, c);\n\t\t\t\t\t\tparent.exps.add(sub);\n\t\t\t\t\t\tif (c != NOOP) parent = sub;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(exp.value());\n\t\t} //end while\n\t} //end main\n\n\tclass Exp {\n\t\tint lv;\n\t\tchar op;\n\t\tint value;\n\t\t//\n\t\tExp parent;\n\t\tList<Exp> exps;\n\n\t\tExp(Exp parent, int lv, char c) {\n\t\t\tthis.parent = parent;\n\t\t\tthis.lv = lv;\n\t\t\tif (c != PLUS && c != MULTI) {\n\t\t\t\tthis.op = NOOP;\n\t\t\t\tthis.value = c - '0';\n\t\t\t} else {\n\t\t\t\tthis.op = c;\n\t\t\t\texps = new ArrayList<Exp>();\n\t\t\t}\n\t\t}\n\n\t\tint value() {\n\t\t\tif (op != NOOP) {\n\t\t\t\tif (op == PLUS) {\n\t\t\t\t\tvalue = 0;\n\t\t\t\t\tfor (Exp exp : exps) value += exp.value();\n\t\t\t\t} else {\n\t\t\t\t\tvalue = 1;\n\t\t\t\t\tfor (Exp exp : exps) value *= exp.value();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int l;\n\t\n\tstatic int count(String str) {\n\t\tint cnt = 0;\n\t\tfor(int i=0;i<str.length();i++) {\n\t\t\tif(str.charAt(i)=='.')\n\t\t\t\tcnt++;\n\t\t}\n\t\treturn cnt;\n\t}\n\t\n\tstatic int f(int[] a,char d,int k) {\t\t//数字と演算子を送って計算\n\t\t\n\t\tint sum = 0;\n\t\tint n = 0;\n\t\tboolean isMul = false;\n\t\tif(d=='*') {\n\t\t\tsum = 1;\n\t\t\tisMul = true;\n\t\t}\n\t\tfor(int aa:a) {\n\t\t\tif(isMul) sum *= aa;\n\t\t\telse sum += aa;\n\t\t\tn++;\n\t\t\tif(n==k)break;\n\t\t}\n\n\t\treturn sum;\n\t}\n\t\n\tstatic int parse(int max,String[] str,int min) {\n\t\t\n\t\tchar d = ' ';\n\t\tint k = 0;\n\t\tint[] put = new int[9];\n\t\tboolean change = false;\n\t\tString rs = \"\";\n\t\t\n\t\tif(max==min+1) {\n\t\t\td = str[0].charAt(min-1);\n\t\t\tfor(String s:str) {\n\t\t\t\tif(s.length()>=max) {\t\n\t\t\t\t\tint cnt = count(s);\t\t\t//数字だけ抜き出すため\n\t\t\t\t\tput[k] = Integer.parseInt(s.substring(cnt));\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn f(put,d,k);\n\t\t}\n\t\t\n\t\tfor(String s:str) {\n\t\t\tif(change && s.length()<=max-1) {\n\t\t\t\tString S =\"\";\n\t\t\t\tfor(int i=0;i<max-2;i++) {\n\t\t\t\t\tif(i==0) \n\t\t\t\t\t\tS = \".\";\n\t\t\t\t\telse\n\t\t\t\t\t\tS += \".\";\n\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\tS += String.valueOf(f(put,d,k));\n\t\t\t\tk = 0;\n\t\t\t\tif(rs==\"\")\n\t\t\t\t\trs = S;\n\t\t\t\telse\n\t\t\t\t\trs = rs +\":\"+S;\n\t\t\t\tchange = false;\n\t\t\t}\n\t\t\tif(s.length() >= max-1 && !Character.isDigit(s.charAt(max-2))) {\n\t\t\t\tchange = true;\n\t\t\t\tif(s.length()==max-1 && !Character.isDigit(s.charAt(max-2))) {\n\t\t\t\t\td = s.charAt(max-2);\n\t\t\t\t}\n\t\t\t\tif(s.length()>=max) {\n\t\t\t\t\tint cnt = count(s);\n\t\t\t\t\tput[k] = Integer.parseInt(s.substring(cnt));\t\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\t\n\t\t\t\tif(rs==\"\")\n\t\t\t\t\trs = s;\n\t\t\t\telse\n\t\t\t\t\trs = rs+\":\"+s;\n\t\t\t}\n\t\t}\n\t\tif(change) {\n\t\t\tString S =\"\";\n\t\t\tfor(int i=0;i<max-2;i++) {\n\t\t\t\tif(i==0) S = \".\";\n\t\t\t\telse\n\t\t\t\t\tS += \".\";\n\t\t\t}\n\t\t\t\t\n\t\t\tS += String.valueOf(f(put,d,k));\n\t\t\tif(rs==\"\")\n\t\t\t\trs = S;\n\t\t\telse\n\t\t\t\trs = rs +\":\"+S;\n\t\t}\n\t\tstr = rs.split(\":\");\n\t\treturn parse(max-1,str,min);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint l = 0;\n\t\t\tint ll = 999999999;\n\t\t\tString[] str = new String[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tstr[i] = sc.next();\n\t\t\t\tl = Math.max(l, str[i].length());\t//最大の長さ\n\t\t\t\tll = Math.min(ll, str[i].length());\n\t\t\t}\n\t\t\tif(n>1)\n\t\t\t\tSystem.out.println(parse(l,str,ll));\n\t\t\telse\n\t\t\t\tSystem.out.println(str[0]);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  Node cal(ArrayList<String> list, int idx, int level) {\n    String a = list.get(idx);\n    int _level = a.length() - 1;\n    assert (level == _level);\n    char c = a.charAt(level);\n    if (c == '+') {\n      int j = idx + 1;\n      int result = 0;\n      for (; ; ) {\n        if (j >= list.size() || list.get(j).length() - 1 != level + 1) {\n          break;\n        }\n        Node ret = cal(list, j, level + 1);\n        result += ret.result;\n        j = ret.idx;\n      }\n      Node node = new Node();\n      node.result = result;\n      node.idx = j;\n      return node;\n    } else if (c == '*') {\n      int j = idx + 1;\n      int result = 1;\n      for (; ; ) {\n        if (j >= list.size() || list.get(j).length() - 1 != level + 1) {\n          break;\n        }\n        Node ret = cal(list, j, level + 1);\n        result *= ret.result;\n        j = ret.idx;\n      }\n      Node node = new Node();\n      node.result = result;\n      node.idx = j;\n      return node;\n    } else {\n      Node node = new Node();\n      node.result = c - '0';\n      node.idx = idx + 1;\n      return node;\n    }\n  }\n\n  class Node {\n    int result;\n    int idx;\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      ArrayList<String> list = new ArrayList<>();\n      for (int i = 0; i < n; ++i) {\n        list.add(sc.next());\n      }\n      System.out.println(cal(list, 0, 0).result);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * ICPC Calculator\n */\npublic class Main {\n\n\tstatic final char NOOP = ' ';\n\tstatic final char PLUS = '+';\n\tstatic final char MULTI = '*';\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = parseInt(line);\n\t\t\tif (n == 0) break;\n\n\t\t\tExp exp = main.new Exp(null, -1, PLUS);\n\t\t\tExp parent = exp;\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tline = br.readLine();\n\n\t\t\t\tint lv = 0;\n\t\t\t\tfor (char c : line.toCharArray()) {\n\t\t\t\t\tif (c == '.') {\n\t\t\t\t\t\tlv++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile (parent.lv >= lv) {\n\t\t\t\t\t\t\tparent = parent.parent;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tExp sub = main.new Exp(parent, lv, c);\n\t\t\t\t\t\tparent.exps.add(sub);\n\t\t\t\t\t\tif (c == PLUS || c == MULTI) parent = sub;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(exp.value());\n\t\t} //end while\n\t} //end main\n\n\tclass Exp {\n\t\tint lv;\n\t\tchar op;\n\t\tint value;\n\t\t//\n\t\tExp parent;\n\t\tList<Exp> exps;\n\n\t\tExp(Exp parent, int lv, char c) {\n\t\t\tthis.parent = parent;\n\t\t\tthis.lv = lv;\n\t\t\tif (c != PLUS && c != MULTI) {\n\t\t\t\tthis.op = NOOP;\n\t\t\t\tthis.value = c - '0';\n\t\t\t} else {\n\t\t\t\tthis.op = c;\n\t\t\t\texps = new ArrayList<Exp>();\n\t\t\t}\n\t\t}\n\n\t\tint value() {\n\t\t\tif (op == PLUS) {\n\t\t\t\tvalue = 0;\n\t\t\t\tfor (Exp exp : exps) value += exp.value();\n\t\t\t} else if (op == MULTI) {\n\t\t\t\tvalue = 1;\n\t\t\t\tfor (Exp exp : exps) value *= exp.value();\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner scan = new Scanner(System.in);\n\n\tpublic static void main(String[] args) \n\t{\n\t\twhile(true)\n\t\t{\n\t\t\tint input = scan.nextInt();\n\t\t\tif(input != 0)\n\t\t\t{\n\t\t\t\tnew DataSet(input);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class DataSet\n\t{\n\t\tint num;\n\t\tint iterator;\n\t\tString carryInput = \"\";\n\t\t\n\t\tpublic DataSet(int n)\n\t\t{\n//\t\t\tSystem.out.println(checkDepth(\"a\"));\n\t\t\tnum = n;\n\t\t\titerator = 0;\n\t\t\tint ans = read(0,0);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\t\n\t\tint read(int depth, int operator)\n\t\t{\n//\t\t\tSystem.out.println(\"new read \" + depth + \" operator \" + operator);\n\t\t\tList<Integer> operands = new ArrayList<Integer>();\n\t\t\t//read operands and smaller sentences\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tString input = \"\";\n//\t\t\t\tint inputValue;\n//\t\t\t\tSystem.out.println(\"C \" + carryInput);\n\t\t\t\tif(!carryInput.equals(\"\"))\n\t\t\t\t{\n//\t\t\t\t\tSystem.out.println(\"USE CARRY \" + carryInput + \" on depth \" + depth + \" and op \" + operator);\n\t\t\t\t\tinput = carryInput;\n\t\t\t\t\tcarryInput = \"\";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(iterator < num)\n\t\t\t\t\t{\n\t\t\t\t\t\tinput = scan.next();\n\t\t\t\t\t\titerator += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n//\t\t\t\tboolean acted = false;\n//\t\t\t\twhile((!carryInput.equals(\"\") && checkDepth(carryInput) == depth) || acted == false)\n\t\t\t\t{\n//\t\t\t\t\tacted = true;\n\t\t\t\t\tif(checkDepth(input) == depth)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(removeDots(input).equals(\"+\"))\n\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tSystem.out.println(\"Start new +, d \" + depth + \" l \" + iterator);\n\t\t\t\t\t\t\tint res = read(checkDepth(input)+1, 1);\n\t\t\t\t\t\t\toperands.add( res );\n//\t\t\t\t\t\t\tSystem.out.println(\"End + \" + input + \", value \" + res);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(removeDots(input).equals(\"*\"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint res = read(checkDepth(input)+1, 2);\n\t\t\t\t\t\t\toperands.add( res );\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse //operands\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toperands.add(Integer.parseInt(removeDots(input)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(!carryInput.equals(\"\") && checkDepth(carryInput) == depth && !removeDots(carryInput).equals(\"+\") && !removeDots(carryInput).equals(\"*\"))\n\t\t\t\t{\n//\t\t\t\t\tSystem.out.println(\"USE LAST CARRY \" + carryInput + \" on depth \" + depth + \" and op \" + operator);\n\t\t\t\t\toperands.add(Integer.parseInt(removeDots(carryInput)));\n\t\t\t\t\tcarryInput = \"\";\n\t\t\t\t}\n\n\t\t\t\tif((checkDepth(input) < depth || iterator >= num) && !( !carryInput.equals(\"\") && checkDepth(carryInput) == depth ) ) //and no more carries to be added\n\t\t\t\t{\n\t\t\t\t\tif(!carryInput.equals(\"\"))\n\t\t\t\t\t{\n//\t\t\t\t\t\tSystem.out.println(\"Unused carry \" + carryInput + \" for [\" + input + \"] of depth \" + depth + \" i \" + iterator) ;\n\t\t\t\t\t}\n\t\t\t\t\tif(iterator >= num)\n\t\t\t\t\t{\n//\t\t\t\t\t\tSystem.out.println(\"last line reached, depth \" + depth + \" op \" + operator);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(iterator >= num && checkDepth(input) == depth)\n\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tSystem.out.println(\"AAA \" + input);\n//\t\t\t\t\t\t\toperands.add(Integer.parseInt(removeDots(input)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//abis...\n\t\t\t\t\tif(checkDepth(input) < depth) \n\t\t\t\t\t{\n//\t\t\t\t\t\tSystem.out.println(\"CARRY \" + input + \" cd \" + depth + \" i \" + iterator);\n\t\t\t\t\t\t\n\t\t\t\t\t\tcarryInput = input;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(operator == 0)\n\t\t\t\t\t{\n//\t\t\t\t\t\tSystem.out.println(\"R);\n\t\t\t\t\t\treturn operands.get(operands.size()-1);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(operator == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tint ans = 0;\n\t\t\t\t\t\tfor(int op : operands)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tans += op;\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tSystem.out.println(\"Returning addition result \" + ans + \" operands \" + operands);\n\t\t\t\t\t\treturn ans;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(operator == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tint ans = 1;\n\t\t\t\t\t\tfor(int op : operands)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tans *= op;\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tSystem.out.println(\"Returning multi. result \" + ans + \", operands \" + operands);\n\t\t\t\t\t\treturn ans;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t\t\n\t\t\t}\n\t\t\t\n//\t\t\treturn -999;\n\t\t}\n\t\t\n\t\tint checkDepth(String content)\n\t\t{\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tif(content.equals(\"\")) {return 0;}\n\t\t\t\n\t\t\tfor(int i = 0; i < content.length(); i++)\n\t\t\t{\n\t\t\t\tif(content.substring(i, i+1).equals(\".\"))\n\t\t\t\t{\n\t\t\t\t\tcount += 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn count;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tString removeDots(String content)\n\t\t{\n\t\t\tint d = checkDepth(content);\n\t\t\treturn content.substring(d);\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchar value[] = new char[n];\n\t\t\tint depth[] = new int[n];\n\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tString tmpStr = sc.next();\n\t\t\t\tvalue[i] = tmpStr.charAt(tmpStr.length() - 1);\n\t\t\t\tdepth[i] = tmpStr.length() - 1;\n\n//\t\t\t\tSystem.out.println(value[i] + \" \" + depth[i]);\n\t\t\t}\n\n\t\t\tSystem.out.println(solve(value, depth, 0, OP_SUM, 0));\n\t\t}\n\t}\n\n\tstatic final int OP_SUM = 0;\n\tstatic final int OP_PROD = 1;\n\tstatic int solve(char value[], int depth[], int targetDepth, int opMode, int beginIndex){\n\t\tint result = 0;\n\t\tif(opMode == OP_PROD){\n\t\t\tresult = 1;\n\t\t}\n\n\t\tfor(int i = beginIndex; i < value.length; i++){\n\t\t\tif(depth[i] < targetDepth ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(depth[i] > targetDepth){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint tmpRes;\n\t\t\tif(value[i] == '*'){\n\t\t\t\ttmpRes = solve(value, depth, targetDepth + 1, OP_PROD, i + 1);\n\t\t\t}\n\t\t\telse if(value[i] == '+'){\n\t\t\t\ttmpRes = solve(value, depth, targetDepth + 1, OP_SUM, i + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttmpRes = value[i] - '0';\n\t\t\t}\n\n\t\t\tif(opMode == OP_SUM){\n\t\t\t\tresult += tmpRes;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult *= tmpRes;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint n=sc.nextInt();//個数\n\t\t\t\tif(n==0) break;\n\t\t\t\tint nowlength=0;//level\n\t\t\t\tchar[] e=new char[10];//演算子\n\t\t\t\tboolean[][] num=new boolean[14][93];//levelと数値\n\t\t\t\twhile(n>=0) {\n\t\t\t\t\tString str=\"0\";\n\t\t\t\t\tif(n>0) {\n\t\t\t\t\t\tstr=sc.next();//読み込み\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length()-1<nowlength || n==0) {\n\t\t\t\t\t\tint sum=0;\n\n\t\t\t\t\t\tfor(int i=nowlength; i>str.length()-1; i--) {\n\t\t\t\t\t\t\tif(e[i]=='+') {\n\t\t\t\t\t\t\t\tsum=0;\n\t\t\t\t\t\t\t\tfor(int j=0; j<90; j++) {\n\t\t\t\t\t\t\t\t\tif(num[i][j]) {\n\t\t\t\t\t\t\t\t\t\tsum+=j;\n\t\t\t\t\t\t\t\t\t\tnum[i][j]=false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(e[i]=='*') {\n\t\t\t\t\t\t\t\tsum=1; \n\t\t\t\t\t\t\t\tfor(int j=0; j<90; j++) {\n\t\t\t\t\t\t\t\t\tif(num[i][j]) {\n\t\t\t\t\t\t\t\t\t\tsum*=j;\n\t\t\t\t\t\t\t\t\t\tnum[i][j]=false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[i-1][sum]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n>0) {\n\t\t\t\t\t\tfor(int i=0; i<str.length(); i++) {\n\t\t\t\t\t\t\tif(str.charAt(i)=='+') {\n\t\t\t\t\t\t\t\te[nowlength+1]='+';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(str.charAt(i)=='*') {\n\t\t\t\t\t\t\t\te[nowlength+1]='*';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(str.charAt(i)=='.') {\n\t\t\t\t\t\t\t\tnowlength=str.length()-1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tnum[nowlength][str.charAt(i)-'0']=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tn--;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<90; i++) {\n\t\t\t\t\tif(num[0][i]) {\n\t\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int n;\n\tstatic char[][] buff=new char[17][10];\n\tstatic int[] length=new int[10];\n\t\n\tstatic int calc(int line) {\n\t\tchar c;\n\t\tint level, val;\n\t\tint arg;\n\t\tlevel=length[line]-1;\n\t\tc=buff[line][level];\n\t\tif(c=='*') {\n\t\t\tline++;\n\t\t\tval=1;\n\t\t\twhile(true) {\n\t\t\t\tif(length[line]-1<=level) break;\n\t\t\t\tif(length[line]-1==level+1) {\n\t\t\t\t\targ=calc(line);\n\t\t\t\t\tval*=arg;\n\t\t\t\t}\n\t\t\t\tline++;\n\t\t\t\tif(line>=n) break;\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t\telse if(c=='+') {\n\t\t\tline++;\n\t\t\tval=0;\n\t\t\twhile(true) {\n\t\t\t\tif(length[line]-1<=level) break;\n\t\t\t\tif(length[line]-1==level+1) {\n\t\t\t\t\targ=calc(line);\n\t\t\t\t\tval+=arg;\n\t\t\t\t}\n\t\t\t\tline++;\n\t\t\t\tif(line>=n) break;\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t\treturn c-'0';\n\t}\n\t\n\tpublic static void main(String args[]){\n\t\ttry(Scanner sc=new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tn=sc.nextInt();\n\t\t\t\tif(n==0) break;\n\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\tString str=sc.next();\n\t\t\t\t\tlength[i]=str.length();\n\t\t\t\t\tfor(int j=0; j<str.length(); j++) {\n\t\t\t\t\t\tbuff[i][j]=str.charAt(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(calc(0));\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n} \n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner scan = new Scanner(System.in);\n\n\tpublic static void main(String[] args) \n\t{\n\t\twhile(true)\n\t\t{\n\t\t\tint input = scan.nextInt();\n\t\t\tif(input != 0)\n\t\t\t{\n\t\t\t\tnew DataSet(input);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class DataSet\n\t{\n\t\tint num;\n\t\tint iterator;\n\t\tString carryInput = \"\";\n\t\t\n\t\tpublic DataSet(int n)\n\t\t{\n//\t\t\tSystem.out.println(checkDepth(\"a\"));\n\t\t\tnum = n;\n\t\t\titerator = 0;\n\t\t\tint ans = read(0,0);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\t\n\t\tint read(int depth, int operator)\n\t\t{\n//\t\t\tSystem.out.println(\"new read \" + depth + \" operator \" + operator);\n\t\t\tList<Integer> operands = new ArrayList<Integer>();\n\t\t\t//read operands and smaller sentences\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tString input = \"\";\n//\t\t\t\tint inputValue;\n//\t\t\t\tSystem.out.println(\"C \" + carryInput);\n\t\t\t\tif(carryInput.equals(\"\"))\n\t\t\t\t{\n\t\t\t\t\tif(iterator < num)\n\t\t\t\t\t{\n\t\t\t\t\t\tinput = scan.next();\n\t\t\t\t\t\titerator += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(checkDepth(carryInput) == depth)\n\t\t\t\t\t{\n//\t\t\t\t\t\tSystem.out.println(\"USE CARRY \" + carryInput + \" on depth \" + depth + \" and op \" + operator);\n\t\t\t\t\t\tinput = carryInput;\n\t\t\t\t\t\tcarryInput = \"\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(checkDepth(input) == depth)\n\t\t\t\t{\n\t\t\t\t\tif(removeDots(input).equals(\"+\"))\n\t\t\t\t\t{\n\t\t\t\t\t\toperands.add( read(checkDepth(input)+1, 1) );\n\t\t\t\t\t}\n\t\t\t\t\telse if(removeDots(input).equals(\"*\"))\n\t\t\t\t\t{\n\t\t\t\t\t\toperands.add( read(checkDepth(input)+1, 2) );\n\t\t\t\t\t}\n\t\t\t\t\telse //operands\n\t\t\t\t\t{\n\t\t\t\t\t\toperands.add(Integer.parseInt(removeDots(input)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!carryInput.equals(\"\") && checkDepth(carryInput) == depth && !removeDots(carryInput).equals(\"+\") && !removeDots(carryInput).equals(\"*\"))\n\t\t\t\t{\n//\t\t\t\t\tSystem.out.println(\"USE LAST CARRY \" + carryInput + \" on depth \" + depth + \" and op \" + operator);\n\t\t\t\t\toperands.add(Integer.parseInt(removeDots(carryInput)));\n\t\t\t\t\tcarryInput = \"\";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(checkDepth(input) < depth || iterator >= num)\n\t\t\t\t{\n\t\t\t\t\tif(iterator >= num)\n\t\t\t\t\t{\n//\t\t\t\t\t\tSystem.out.println(\"last line reached, depth \" + depth + \" op \" + operator);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(iterator >= num && checkDepth(input) == depth)\n\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tSystem.out.println(\"AAA \" + input);\n//\t\t\t\t\t\t\toperands.add(Integer.parseInt(removeDots(input)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//abis...\n\t\t\t\t\tif(checkDepth(input) < depth) \n\t\t\t\t\t{\n//\t\t\t\t\t\tSystem.out.println(\"CARRY \" + input + \" cd \" + depth + \" i \" + iterator);\n\t\t\t\t\t\t\n\t\t\t\t\t\tcarryInput = input;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(operator == 0)\n\t\t\t\t\t{\n//\t\t\t\t\t\tSystem.out.println(\"R);\n\t\t\t\t\t\treturn operands.get(operands.size()-1);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(operator == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tint ans = 0;\n\t\t\t\t\t\tfor(int op : operands)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tans += op;\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tSystem.out.println(\"Returning addition result \" + ans + \" operands \" + operands);\n\t\t\t\t\t\treturn ans;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(operator == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tint ans = 1;\n\t\t\t\t\t\tfor(int op : operands)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tans *= op;\n\t\t\t\t\t\t}\n//\t\t\t\t\t\tSystem.out.println(\"Returning multi. result \" + ans + \", operands \" + operands);\n\t\t\t\t\t\treturn ans;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t\t\n\t\t\t}\n\t\t\t\n//\t\t\treturn -999;\n\t\t}\n\t\t\n\t\tint checkDepth(String content)\n\t\t{\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tif(content.equals(\"\")) {return 0;}\n\t\t\t\n\t\t\tfor(int i = 0; i < content.length(); i++)\n\t\t\t{\n\t\t\t\tif(content.substring(i, i+1).equals(\".\"))\n\t\t\t\t{\n\t\t\t\t\tcount += 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn count;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\tString removeDots(String content)\n\t\t{\n\t\t\tint d = checkDepth(content);\n\t\t\treturn content.substring(d);\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int l;\n\tstatic int f(int[] a,char d,int k) {\t\t//数字と演算子を送って計算\n\t\tint sum = 0;\n\t\tint n = 0;\n\t\tboolean isMul = false;\n\t\tif(d=='*') {\n\t\t\tsum = 1;\n\t\t\tisMul = true;\n\t\t}\n\t\tfor(int aa:a) {\n\t\t\tif(isMul) sum *= aa;\n\t\t\telse sum += aa;\n\t\t\tn++;\n\t\t\tif(n==k)break;\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tstatic int parse(int j,String[] str) {\n//\t\tfor(String a:str) {\n//\t\t\tSystem.out.print(a);\n//\t\t}\n//\t\tSystem.out.println();\n\t\tint[] put = new int[20];\n\t\tint k = 0;\n\t\tString ns = \"\";\n\t\t\n\t\t\n\t\tchar d = str[0].charAt(j);\n\t\tint c = 0;\n\t\tfor(String s:str) {\n\t\t\tif(str[0].equals(s))\n\t\t\t\tcontinue;\n\t\t\tif(Character.isDigit(s.charAt(j+1))) {\n\t\t\t\tput[k] = Integer.parseInt(String.valueOf(s.charAt(j+1)));\n\t\t\t\tk++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(c==0)\n\t\t\t\t\tns = s;\n\t\t\t\telse\n\t\t\t\t\tns = ns + \":\" + s;\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\tString[] s = ns.split(\":\");\n\t\tif(ns!=\"\") {\n\t\t\tif(d=='+')\n\t\t\t\treturn f(put,d,k)+parse(j+1,s);\n\t\t\treturn f(put,d,k)*parse(j+1,s);\n\t\t}\n\t\treturn f(put,d,k);\t\t\t\t\t\t\t//すべて同じ次数のとき\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tString[] str = new String[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tstr[i] = sc.next();\n\t\t\t}\n\t\t\t\n\t\t\tif(n>1)\n\t\t\t\tSystem.out.println(parse(0,str));\n\t\t\telse\n\t\t\t\tSystem.out.println(str[0]);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint n=sc.nextInt();//個数\n\t\t\t\tif(n==0) break;\n\t\t\t\tint nowlength=0;//level\n\t\t\t\tchar[] e=new char[10];//演算子\n\t\t\t\tboolean[][] num=new boolean[11][90];//levelと数値\n\t\t\t\twhile(n>=0) {\n\t\t\t\t\tString str=\"0\";\n\t\t\t\t\tif(n>0) {\n\t\t\t\t\t\tstr=sc.next();//読み込み\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length()-1<nowlength || n==0) {\n\t\t\t\t\t\tint sum=0;\n\n\t\t\t\t\t\tfor(int i=nowlength; i>str.length()-1; i--) {\n\t\t\t\t\t\t\tif(e[i]=='+') {\n\t\t\t\t\t\t\t\tsum=0;\n\t\t\t\t\t\t\t\tfor(int j=0; j<90; j++) {\n\t\t\t\t\t\t\t\t\tif(num[i][j]) {\n\t\t\t\t\t\t\t\t\t\tsum+=j;\n\t\t\t\t\t\t\t\t\t\tnum[i][j]=false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(e[i]=='*') {\n\t\t\t\t\t\t\t\tsum=1; \n\t\t\t\t\t\t\t\tfor(int j=0; j<90; j++) {\n\t\t\t\t\t\t\t\t\tif(num[i][j]) {\n\t\t\t\t\t\t\t\t\t\tsum*=j;\n\t\t\t\t\t\t\t\t\t\tnum[i][j]=false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[i-1][sum]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n>0) {\n\t\t\t\t\t\tfor(int i=0; i<str.length(); i++) {\n\t\t\t\t\t\t\tif(str.charAt(i)=='+') {\n\t\t\t\t\t\t\t\te[nowlength+1]='+';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(str.charAt(i)=='*') {\n\t\t\t\t\t\t\t\te[nowlength+1]='*';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(str.charAt(i)=='.') {\n\t\t\t\t\t\t\t\tnowlength=str.length()-1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tnum[nowlength][str.charAt(i)-'0']=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tn--;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<90; i++) {\n\t\t\t\t\tif(num[0][i]) {\n\t\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic PrintWriter out;\n\tstatic InputReader ir;\n\tstatic boolean debug = false;\n\n\tstatic void solve() {\n\t\tfor (;;) {\n\t\t\tint n = ir.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\treturn;\n\t\t\tif (n == 1) {\n\t\t\t\tout.println(ir.nextInt());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint[] d = new int[n];\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tString s = ir.next();\n\t\t\t\tint ct = 0;\n\t\t\t\twhile (ct < s.length() && s.charAt(ct) == '.')\n\t\t\t\t\tct++;\n\t\t\t\td[i] = ct;\n\t\t\t\ts = s.substring(ct);\n\t\t\t\tif (s.equals(\"+\")) {\n\t\t\t\t\ta[i] = -1;\n\t\t\t\t} else if (s.equals(\"*\")) {\n\t\t\t\t\ta[i] = -2;\n\t\t\t\t} else {\n\t\t\t\t\ta[i] = Integer.parseInt(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(dfs(1, n, 1, a[0], d, a));\n\t\t}\n\t}\n\n\tstatic long dfs(int l, int r, int dep, int op, int[] d, int[] a) {\n\t\tlong ret = op == -1 ? 0 : 1;\n\t\tfor (int i = l; i < r; i++) {\n\t\t\tif (d[i] == dep) {\n\t\t\t\tif (a[i] >= 0) {\n\t\t\t\t\tif (op == -1)\n\t\t\t\t\t\tret += a[i];\n\t\t\t\t\telse\n\t\t\t\t\t\tret *= a[i];\n\t\t\t\t} else {\n\t\t\t\t\tint pre = i++;\n\t\t\t\t\twhile (i < r && d[i] != dep)\n\t\t\t\t\t\ti++;\n\t\t\t\t\tif (op == -1)\n\t\t\t\t\t\tret += dfs(pre + 1, i, dep + 1, a[pre], d, a);\n\t\t\t\t\telse\n\t\t\t\t\t\tret *= dfs(pre + 1, i, dep + 1, a[pre], d, a);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tir = new InputReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream in;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int curbuf;\n\t\tprivate int lenbuf;\n\n\t\tpublic InputReader(InputStream in) {\n\t\t\tthis.in = in;\n\t\t\tthis.curbuf = this.lenbuf = 0;\n\t\t}\n\n\t\tpublic boolean hasNextByte() {\n\t\t\tif (curbuf >= lenbuf) {\n\t\t\t\tcurbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[curbuf++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tprivate void skip() {\n\t\t\twhile (hasNextByte() && isSpaceChar(buffer[curbuf]))\n\t\t\t\tcurbuf++;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskip();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (!isSpaceChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tint c = readByte();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = readByte();\n\t\t\tboolean minus = false;\n\t\t\tif (c == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tc = readByte();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = readByte();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn (minus) ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n, int m) {\n\t\t\tchar[][] map = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next().toCharArray();\n\t\t\treturn map;\n\t\t}\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tif (debug)\n\t\t\tout.println(Arrays.deepToString(o));\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true){\n            int n = sc.nextInt();\n            if (n==0) break;\n            String[] formula = new String[n];\n\n            for (int i = 0; i < n; i++) {\n                formula[i] = sc.next();\n            }\n\n            System.out.println(((n==1)?Integer.parseInt(formula[0]):dfs(formula, 0, n)));\n        }\n    }\n\n    static int dfs(String[] formula, int s, int e) {\n        int num = (formula[s].charAt(formula[s].length()-1)=='+')?0:1;\n        int j = 0, ans = 1;\n        for (int i = s+1; i < e; i++) {\n            if(formula[i].charAt(formula[i].length()-1)!='*'&&formula[i].charAt(formula[i].length()-1)!='+'){\n                ans = ((num==0)?ans+(formula[i].charAt(formula[i].length()-1) - '0'):ans*(formula[i].charAt(formula[i].length()-1) - '0'));\n            }else {\n                for (j = i+1; j < e; j++) {\n                    if (formula[j].length()==formula[i].length()) break;\n                }\n                ans = ((num==0)?ans+dfs(formula, i, j):ans*dfs(formula, i, j));\n                i = j-1;\n            }\n        }\n        return (num==0)?ans-1:ans;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\npublic class Main {\n\n\n\tstatic int n;\n\tstatic ArrayList<String> str;\n\tstatic ArrayList<Integer> slong;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n//\t\tint n;\n//\t\tArrayList<String> str;\n//\t\tArrayList<Integer> slong;\n\t\t\n\t\twhile(true) {\n\t\tn = Integer.parseInt(sc.nextLine());\n\t\tif(n == 0) {break;}\n\t\tif(n == 1) {\n\t\t\tSystem.out.println(sc.nextLine());\n\t\t\tcontinue;\n\t\t}\n\t\tstr = new ArrayList<String>();\n\t\tslong = new ArrayList<Integer>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tstr.add(sc.nextLine());\n\t\t\tslong.add(str.get(i).length()-1);\n\t\t\tstr.set(i, str.get(i).substring(slong.get(i)));\n\t\t}\n\n\t\tstr.add(\"\");\n\t\tslong.add(-1);\n\t\t\n\t\twhile(n > 2) {\n\t\t\tcalc();\n\t\t}\n\t\tSystem.out.println(str.get(1));\n\t\t\n\t\t}\n\t\tsc.close();\n\t}\n\n\tpublic static void calc() {\n\t\tint longest=0;\n\t\tint pos=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(slong.get(i) > longest) {\n\t\t\t\tlongest =  slong.get(i);\n\t\t\t\tpos = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(slong.get(pos+1) == slong.get(pos)) {\n\t\t\tif(str.get(pos-1).equals(\"+\")) {\n\t\t\t\tstr.set(pos, String.valueOf(Integer.parseInt(str.get(pos)) + Integer.parseInt(str.get(pos+1))));\n\t\t\t}else {\n\t\t\t\tstr.set(pos, String.valueOf(Integer.parseInt(str.get(pos)) * Integer.parseInt(str.get(pos+1))));\n\t\t\t}\n\t\t\tstr.remove(pos+1);\n\t\t\tslong.remove(pos+1);\n\t\t\tn --;\n\t\t}else {\n\t\t\tstr.remove(pos-1);\n\t\t\tslong.set(pos, slong.get(pos)-1);\n\t\t\tslong.remove(pos-1);\n\t\t\tn--;\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.ArrayList;\n\nclass Main{\n  public static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n\n    int count = scan.nextInt();\n\n    while(count>0) {\n      int[][] arr = new int[count][2];\n      for(int i = 0; i < count; i++) {\n        char[] input = scan.next().toCharArray();\n        //System.out.println(input);\n        arr[i][0] = input.length;\n        arr[i][1] = input[input.length-1];\n      }\n\n      Func.ite = 0;\n      Func.arr = arr;\n\n      System.out.println(new Func().calc());\n\n      count = scan.nextInt();\n    }\n  }\n}\n\nclass Func{\n  static int ite;\n  static int[][] arr;\n  char mark;\n  ArrayList<Func> list;\n\n  Func() {\n    mark = (char)arr[ite][1];\n    switch(arr[ite][1]) {\n      case '+':\n      case '*':\n        int deep = arr[ite][0];\n        ite++;\n        list = new ArrayList<>();\n        while(ite<arr.length&&arr[ite][0]>deep) {\n          list.add(new Func());\n        }\n        break;\n      default:\n        ite++;\n        break;\n    }\n  }\n\n  int calc() {\n    int sum = 0;\n    switch(mark) {\n      case '+':\n        for(Func _f : list) {\n          sum += _f.calc();\n        }\n        return sum;\n      case '*':\n        sum = 1;\n        for(Func _f : list) {\n          sum *= _f.calc();\n        }\n        return sum;\n      default:\n        return (int)(mark-'0');\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        ICPCCalculator solver = new ICPCCalculator();\n        try {\n            int testNumber = 1;\n            while (true)\n                solver.solve(testNumber++, in, out);\n        } catch (UnknownError e) {\n            out.close();\n        }\n    }\n\n    static class ICPCCalculator {\n        int n;\n        String[] S;\n        boolean[] visited;\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            n = in.nextInt();\n            if (n == 0) throw new UnknownError();\n            S = new String[n];\n            visited = new boolean[n];\n            Arrays.fill(visited, false);\n            for (int i = 0; i < n; i++) {\n                S[i] = in.next();\n            }\n            if (n == 1) {\n                out.println(S[0]);\n                return;\n            }\n            out.println(dfs(0, 0, false));\n        }\n\n        private int dfs(int now, int dot, boolean ope) {\n            int ans = ope ? 1 : 0;\n            for (int i = now; i < n; i++) {\n                if (S[i].length() <= dot) break;\n                final char c = S[i].charAt(dot);\n                if (Character.isDigit(c)) {\n                    if (ope) {\n                        ans *= c - '0';\n                    } else {\n                        ans += c - '0';\n                    }\n                } else if (c == '+' || c == '*') {\n                    if (ope) {\n                        ans *= dfs(i + 1, dot + 1, c == '*');\n                    } else {\n                        ans += dfs(i + 1, dot + 1, c == '*');\n                    }\n                } else if (c == '.') {\n                    continue;\n                } else {\n                    throw new Error();\n                }\n            }\n            return ans;\n        }\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "public class Main {\n\t\n\tprivate static int getLevel(String s) {\n\t\tint r = 0;\n\t\tfor (; r < s.length(); ++r) {\n\t\t\tif (s.charAt(r) != '.')\n\t\t\t\tbreak ;\n\t\t}\n\t\treturn (r);\n\t}\n\t\n\tprivate static String getData(String s) {\n\t\treturn s.substring(getLevel(s));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry (java.io.InputStreamReader sr = new java.io.InputStreamReader(System.in);\n\t\t\t\tjava.io.BufferedReader br = new java.io.BufferedReader(sr)) {\n\t\t\tfor (;;) {\n\t\t\t\tfinal StringBuilder sb = new StringBuilder();\n\t\t\t\tfinal String[] d = new String[Integer.parseInt(br.readLine())];\n\t\t\t\tif (d.length == 0) break ;\n\t\t\t\tfor (int i = 0; i < d.length; ++i) {\n\t\t\t\t\td[i] = br.readLine();\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < d.length; ++i) {\n\t\t\t\t\tif (i + 1 < d.length && getLevel(d[i]) < getLevel(d[i + 1]))\n\t\t\t\t\t\tsb.append('(');\n\t\t\t\t\tsb.append(getData(d[i]));\n\t\t\t\t\tfinal int diff = getLevel(d[i]) - (i + 1 < d.length ? getLevel(d[i + 1]) : 0);\n\t\t\t\t\tif (diff <= 0)\n\t\t\t\t\t\tsb.append(' ');\n\t\t\t\t\tfor (int j = 0; j < diff; ++j)\n\t\t\t\t\t\tsb.append(')');\n\t\t\t\t\tif (diff > 0 && i + 1 < d.length)\n\t\t\t\t\t\tsb.append(' ');\n\t\t\t\t}\n\t\t\t\tSystem.out.println(((Cell)Cell.parse(\"(+ \" + sb.toString() + \")\")).eval());\n\t\t\t}\n\t\t} catch (java.io.IOException e) { }\n\t}\n\n\tprivate static class Cell {\n\t\t\n\t\tpublic final Object car;\n\t\tpublic final Cell cdr;\n\t\t\n\t\tpublic Cell(Object car, Cell cdr) {\n\t\t\tthis.car = car;\n\t\t\tthis.cdr = cdr;\n\t\t}\n\t\t\n\t\tpublic String toString() {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tthis.toString(sb);\n\t\t\treturn sb.toString();\n\t\t}\n\t\t\n\t\tpublic Object eval() {\n\t\t\tjava.util.List<Object> args = new java.util.LinkedList<Object>();\n\t\t\tfor (Cell it = this.cdr; it != null; it = it.cdr) {\n\t\t\t\tif (it.car instanceof Cell) {\n\t\t\t\t\targs.add(((Cell)it.car).eval());\n\t\t\t\t} else {\n\t\t\t\t\targs.add(it.car);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (car.equals(\"+\")) {\n\t\t\t\tint res = 0;\n\t\t\t\tfor (java.util.Iterator<Object> it = args.iterator(); it.hasNext(); ) {\n\t\t\t\t\tres += ((Integer)it.next()).intValue();\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\tif (car.equals(\"*\")) {\n\t\t\t\tint res = 1;\n\t\t\t\tfor (java.util.Iterator<Object> it = args.iterator(); it.hasNext(); ) {\n\t\t\t\t\tres *= ((Integer)it.next()).intValue();\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tpublic void toString(StringBuilder sb) {\n\t\t\tsb.append('(');\n\t\t\tsb.append(this.car.toString());\n\t\t\tfor (Cell it = this.cdr; it != null; it = it.cdr) {\n\t\t\t\tsb.append(' ');\n\t\t\t\tsb.append(it.car.toString());\n\t\t\t}\n\t\t\tsb.append(')');\n\t\t}\n\t\t\n\t\tpublic static Object parse(String s) {\n\t\t\treturn (new LispParser(s)).parse();\n\t\t}\n\t\t\n\t\tpublic static Cell toList(java.util.List<Object> lis) {\n\t\t\tCell res = null;\n\t\t\tfor (java.util.ListIterator<Object> it = lis.listIterator(lis.size()); it.hasPrevious(); ) {\n\t\t\t\tres = new Cell(it.previous(), res);\n\t\t\t}\n\t\t\treturn (res);\n\t\t}\n\t\t\n\t\tprivate static class LispParser {\n\t\t\t\n\t\t\tprivate final char[] s;\n\t\t\tprivate int p;\n\t\t\t\n\t\t\tpublic LispParser(String s) {\n\t\t\t\tthis.s = s.toCharArray();\n\t\t\t\tthis.p = 0;\n\t\t\t}\n\t\t\t\n\t\t\tpublic Object parse() {\n\t\t\t\tskipWS();\n\t\t\t\tif (s[p] == '(')\n\t\t\t\t\treturn parseList();\n\t\t\t\tif (Character.isDigit(s[p]))\n\t\t\t\t\treturn parseInteger();\n\t\t\t\treturn parseAtom();\n\t\t\t}\n\t\t\t\n\t\t\tprivate Object parseList() {\n\t\t\t\tfinal java.util.List<Object> lis = new java.util.LinkedList<Object>();\n\t\t\t\tif (s[p] == '(') ++p;\n\t\t\t\tskipWS();\n\t\t\t\twhile (s[p] != ')') {\n\t\t\t\t\tlis.add(parse());\n\t\t\t\t\tskipWS();\n\t\t\t\t}\n\t\t\t\t++p;\n\t\t\t\treturn Cell.toList(lis);\n\t\t\t}\n\t\t\t\n\t\t\tprivate Object parseInteger() {\n\t\t\t\tint res = 0;\n\t\t\t\twhile (Character.isDigit(s[p])) {\n\t\t\t\t\tres = res * 10 + s[p++] - '0';\n\t\t\t\t}\n\t\t\t\treturn new Integer(res);\n\t\t\t}\n\t\t\t\n\t\t\tprivate Object parseAtom() {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\twhile (!Character.isWhitespace(s[p])) {\n\t\t\t\t\tsb.append(s[p++]);\n\t\t\t\t}\n\t\t\t\treturn sb.toString();\n\t\t\t}\n\t\t\t\n\t\t\tprivate void skipWS() {\n\t\t\t\twhile (Character.isWhitespace(s[p])) {\n\t\t\t\t\t++p;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.ArrayList;\n\nclass Main{\n  public static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n    int n = scan.nextInt();\n    while(n>0) {\n      ArrayList<String> input_arr = new ArrayList<>();\n      for(int i = 0; i < n; i++) input_arr.add(scan.next());\n\n      int[][] arr = new int[input_arr.size()][2];\n      for(int i = 0; i < input_arr.size(); i++) {\n        char[] _in = input_arr.get(i).toCharArray();\n        int count = 0;\n        int cursor = 0;\n        while(_in[cursor]=='.') {\n          count++;\n          cursor++;\n        }\n\n        int num = 0;\n        if(_in[cursor]=='+') num=-1;\n        else if(_in[cursor]=='*') num=-2;\n        else num=(int)(_in[cursor]-'0');\n        arr[i][0] = count;\n        arr[i][1] = num;\n      }\n\n      AbstractExpression ae;\n      if(AbstractExpression.isTerminal(arr,0)) {\n        ae = new TerminalExpression();\n      }else {\n        ae = new NonterminalExpression();\n      }\n      ae.interpret(arr,0);\n      System.out.println(ae.calc());\n\n      n = scan.nextInt();\n    }\n  }\n}\n\nabstract class AbstractExpression{\n  AbstractExpression() {\n\n  }\n  abstract int interpret(int[][] _arr,int num);\n  abstract int calc();\n  static boolean isTerminal(int[][] _arr,int num) {\n    return _arr[num][1]>=0;\n  }\n}\n\nclass TerminalExpression extends AbstractExpression{\n  int term;\n  TerminalExpression() {\n\n  }\n  @Override\n  int interpret(int[][] _arr,int num) {\n    term = _arr[num][1];\n    return 1;\n  }\n  @Override\n  int calc() {\n    return term;\n  }\n}\n\nclass NonterminalExpression extends AbstractExpression{\n  ArrayList<AbstractExpression> aeArray;\n  int mark = 0;\n  NonterminalExpression() {\n    aeArray = new ArrayList<>();\n  }\n  @Override\n  int interpret(int[][] _arr,int num) {\n    int startDepth = _arr[num][0];\n    mark = _arr[num][1];\n    int startNum = num;\n    num++;\n    while(num<_arr.length && _arr[num][0]>startDepth) {\n      AbstractExpression _ae = null;\n      if(isTerminal(_arr,num)) {\n        _ae = new TerminalExpression();\n      }else {\n        _ae = new NonterminalExpression();\n      }\n      aeArray.add(_ae);\n      num += _ae.interpret(_arr,num);\n    }\n    return num-startNum;\n  }\n  @Override\n  int calc() {\n    int result = 0;\n    if(mark==-1) {\n      for(AbstractExpression _ae : aeArray) result += _ae.calc();\n    }else if(mark==-2) {\n      result = 1;\n      for(AbstractExpression _ae : aeArray) result *= _ae.calc();\n    }\n    return result;\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint n=sc.nextInt();//個数\n\t\t\t\tif(n==0) break;\n\t\t\t\tint nowlength=0;//level\n\t\t\t\tchar[] e=new char[10];//演算子\n\t\t\t\tboolean[][] num=new boolean[14][400000000];//levelと数値\n\t\t\t\twhile(n>=0) {\n\t\t\t\t\tString str=\"0\";\n\t\t\t\t\tif(n>0) {\n\t\t\t\t\t\tstr=sc.next();//読み込み\n\t\t\t\t\t}\n\t\t\t\t\tif(str.length()-1<nowlength || n==0) {\n\t\t\t\t\t\tint sum=0;\n\n\t\t\t\t\t\tfor(int i=nowlength; i>str.length()-1; i--) {\n\t\t\t\t\t\t\tif(e[i]=='+') {\n\t\t\t\t\t\t\t\tsum=0;\n\t\t\t\t\t\t\t\tfor(int j=0; j<400000000; j++) {\n\t\t\t\t\t\t\t\t\tif(num[i][j]) {\n\t\t\t\t\t\t\t\t\t\tsum+=j;\n\t\t\t\t\t\t\t\t\t\tnum[i][j]=false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(e[i]=='*') {\n\t\t\t\t\t\t\t\tsum=1; \n\t\t\t\t\t\t\t\tfor(int j=0; j<400000000; j++) {\n\t\t\t\t\t\t\t\t\tif(num[i][j]) {\n\t\t\t\t\t\t\t\t\t\tsum*=j;\n\t\t\t\t\t\t\t\t\t\tnum[i][j]=false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnum[i-1][sum]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(n>0) {\n\t\t\t\t\t\tfor(int i=0; i<str.length(); i++) {\n\t\t\t\t\t\t\tif(str.charAt(i)=='+') {\n\t\t\t\t\t\t\t\te[nowlength+1]='+';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(str.charAt(i)=='*') {\n\t\t\t\t\t\t\t\te[nowlength+1]='*';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(str.charAt(i)=='.') {\n\t\t\t\t\t\t\t\tnowlength=str.length()-1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tnum[nowlength][str.charAt(i)-'0']=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tn--;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<400000000; i++) {\n\t\t\t\t\tif(num[0][i]) {\n\t\t\t\t\t\tSystem.out.println(i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\tstatic final int INF = 2 << 28;\n\tstatic final long INF_L = 2L << 60;\n\tstatic final int  MOD = 1000000007;\n\tstatic final long MOD_L = 1000000007L;\n\tstatic final int[] vx_4 = {1,0,-1,0};\n\tstatic final int[] vy_4 = {0,1,0,-1};\n\tstatic final int[] vx_5 = {1,0,-1,0,0};\n\tstatic final int[] vy_5 = {0,1,0,-1,0};\n\tstatic final int[] vx_8 = {1,1,1,0,0,-1,-1,-1};\n\tstatic final int[] vy_8 = {1,0,-1,1,-1,1,0,-1};\n\tstatic final int[] vx_9 = {1,1,1,0,0,0,-1,-1,-1};\n\tstatic final int[] vy_9 = {1,0,-1,1,0,-1,1,0,-1};\n\t\n\tstatic int idx;\n\tstatic char[][] str;\n\tstatic int lv;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tIN:while(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tstr = new char[n][];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tstr[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tint ans = start();\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic int start() {\n\t\tidx = 0;\n\t\tlv  = 0;\n\t\treturn beg();\n\t}\n\tstatic int beg() {\n\t\tif(str[idx][lv] == '+') {\n\t\t\tidx++;\n\t\t\tlv++;\n\t\t\treturn plus();\n\t\t}\n\t\telse if(str[idx][lv] == '*') {\n\t\t\tidx++;\n\t\t\tlv++;\n\t\t\treturn mul();\n\t\t}\n\t\telse {\n\t\t\tint tmp = str[idx][lv] - '0';\n\t\t\tidx++;\n\t\t\treturn tmp;\n\t\t\t\n\t\t}\n\t}\n\tstatic int plus() {\n\t\tint ret = 0;\n\t\twhile(idx < str.length && str[idx].length == lv+1) {\n\t\t\tret += beg();\n\t\t}\n\t\tlv--;\n\t\treturn ret;\n\t}\n\tstatic int mul() {\n\t\tint ret = beg();\n\t\twhile(idx < str.length && str[idx].length == lv+1) {\n\t\t\tret *= beg();\n\t\t}\n\t\tlv--;\n\t\treturn ret;\n\t}\n\t\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \tif (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner in;\n\tstatic String[] line;\n\tstatic int n;\n\t\n\tpublic static void main(String[] args){\n\t\tin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = in.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tline = new String[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tline[i] = in.next();\n\t\t\t}\n\t\t\tnow = 0;\n\t\t\tSystem.out.println(calc('+',0));\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\tstatic int now;\n\tpublic static int calc(char op,int level){\n\t\tint ans = (op=='+')?0:1;\n\t\twhile(true){\n\t\t\tif(now>=n) return ans;\n\t\t\tString next = line[now];\n\t\t\tif(level>0 && (level-1>=next.length() || next.charAt(level-1)!='.')){\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t\tif(next.charAt(level)=='+'){\n\t\t\t\tif(op=='+'){\n\t\t\t\t\tnow++;\n\t\t\t\t\tans += calc('+',level+1);\n\t\t\t\t}else{\n\t\t\t\t\tnow++;\n\t\t\t\t\tans *= calc('+',level+1);\n\t\t\t\t}\n\t\t\t}else if(next.charAt(level)=='*'){\n\t\t\t\tif(op=='+'){\n\t\t\t\t\tnow++;\n\t\t\t\t\tans += calc('*',level+1);\n\t\t\t\t}else{\n\t\t\t\t\tnow++;\n\t\t\t\t\tans *= calc('*',level+1);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(op=='+'){\n\t\t\t\t\tnow++;\n\t\t\t\t\tans += next.charAt(level)-'0';\n\t\t\t\t}else{\n\t\t\t\t\tnow++;\n\t\t\t\t\tans *= next.charAt(level)-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n// 2015 C??????, compiler\npublic class Main {\n    public static int INF = Integer.MAX_VALUE;\n    static Scanner sc;\n\n    public static void main(String[] args) {\n        init();\n\n        while (true) {\n            int n = ni();\n            if (n == 0) {\n                break;\n            }\n            nl();\n\n            Element root;\n            String ls = nl();\n            if (ls.equals(\"+\")) {\n                root = new Plus();\n            } else if (ls.equals(\"*\")) {\n                root = new Multi();\n            } else {\n                root = new Operand(Integer.parseInt(ls));\n            }\n\n            for (int i = 1; i < n; i++) {\n                String l = nl();\n                int level = l.length() - 1;\n                String value = \"\" + l.charAt(l.length() - 1);\n                if (value.equals(\"+\")) {\n                    root.add(level, new Plus());\n                } else if (value.equals(\"*\")) {\n                    root.add(level, new Multi());\n                } else {\n                    root.add(level, new Operand(Integer.parseInt(value)));\n                }\n            }\n            System.out.println(root.calc());\n        }\n\n        end();\n    }\n    public static void init() {\n        sc = new Scanner(System.in);\n    }\n    public static void end() {\n        sc.close();\n    }\n    public static int ni() {\n        return sc.nextInt();\n    }\n    public static String nl() {\n        return sc.nextLine();\n    }\n}\n\ninterface Element {\n    int calc();\n    void add(int level, Element value);\n}\n\nabstract class Operator implements Element {\n    public ArrayList<Element> elements;\n    public Operator making;\n    public Operator() {\n        this.elements = new ArrayList<>();\n    }\n    public void add(int level, Element value) {\n        if (level == 1) {\n            this.elements.add(value);\n            if (value instanceof Operator) {\n                this.making = (Operator) value;\n            }\n            return;\n        }\n        making.add(level - 1, value);\n    }\n}\n\nclass Operand implements Element {\n    int value;\n    public int calc() {\n        return value;\n    }\n    public void add(int level, Element value) {\n    }\n    Operand(int value) {\n        this.value = value;\n    }\n}\n\nclass Plus extends Operator {\n    public int calc() {\n        int ans = 0;\n        for (Element e : elements) {\n            ans += e.calc();\n        }\n        return ans;\n    }\n}\n\nclass Multi extends Operator {\n    public int calc() {\n        int ans = 1;\n        for (Element e : elements) {\n            ans *= e.calc();\n        }\n        return ans;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static Scanner sc = new Scanner(System.in);\n\tpublic static PrintWriter pw = ContestWriter.getInstance(\"out.txt\", true);\n\tpublic static void main(String[] args) throws IOException {\n\t\twhile(solve());\n\t\tpw.flush();\n\t}\n\tpublic static int n = 0;\n\tpublic static int i = 0;\n\tpublic static String[] token;\n\tpublic static int[] level;\n\tpublic static boolean solve() {\n\t\tn = sc.nextInt();\n\t\tif (n == 0) return false;\n\t\ti = 0;\n\t\ttoken = new String[n];\n\t\tlevel = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ttoken[i] = sc.next();\n\t\t\tfor(int j=0;j<token[i].length();j++) {\n\t\t\t\tif (token[i].charAt(j) != '.') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlevel[i] = j + 1;\n\t\t\t}\n\t\t}\n\t\tpw.println(exp(0));\n\t\treturn true;\n\t}\n\t\n\tpublic static long exp(int lv) {\n\t\tchar op = token[i].charAt(lv);\n\t\tif (op == '+') {\n\t\t\ti++;\n\t\t\tlong sum = 0;\n\t\t\twhile (i < n && level[i] == lv + 1) {\n\t\t\t\tsum += exp(lv + 1);\n\t\t\t}\n\t\t\treturn sum;\n\t\t}else if(op == '*') {\n\t\t\ti++;\n\t\t\tlong pi = 1;\n\t\t\twhile (i < n && level[i] == lv + 1) {\n\t\t\t\tpi *= exp(lv + 1);\n\t\t\t}\n\t\t\treturn pi;\n\t\t}else {\n\t\t\tlong val = Integer.valueOf(token[i].substring(level[i]));\n\t\t\ti++;\n\t\t\treturn val;\n\t\t}\n\t}\n\n}\nclass ContestWriter extends PrintWriter {\n\tprivate ContestWriter(String fileName) throws IOException {\n\t\tsuper(new OutputStreamWriter(new FileOutputStream(new File(fileName)), \"UTF-8\"), false);\n\t}\n\tpublic static PrintWriter getInstance(String fileName, boolean debug) {\n\t\tif (debug) return new PrintWriter(System.out);\n\t\ttry {\n\t\t\treturn new ContestWriter(fileName);\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException();\n\t\t}\n\t}\n\tpublic void println() {\n\t\twrite('\\n');\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        ICPCCalculator solver = new ICPCCalculator();\n        try {\n            int testNumber = 1;\n            while (true)\n                solver.solve(testNumber++, in, out);\n        } catch (UnknownError e) {\n            out.close();\n        }\n    }\n\n    static class ICPCCalculator {\n        int n;\n        String[] S;\n        boolean[] visited;\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            n = in.nextInt();\n            if (n == 0) throw new UnknownError();\n            S = new String[n];\n            visited = new boolean[n];\n            Arrays.fill(visited, false);\n            for (int i = 0; i < n; i++) {\n                S[i] = in.next();\n            }\n            if (n == 1) {\n                out.println(S[0]);\n                return;\n            }\n            visited[0] = true;\n            boolean ope = S[0].charAt(0) == '*';\n            out.println(dfs(1, 0, ope));\n        }\n\n        private int dfs(int now, int dot, boolean ope) {\n            if (n == now || visited[now]) return 0;\n            final int len = S[now].length();\n            if (dot >= len) return 0;\n            int ans = -1;\n            for (int i = now; i < n; i++) {\n                if (i != now && visited[i]) continue;\n                //System.err.println(now +\"  \" + i + \"  \" + (ope ? \"*\" : \"+\"));\n                if (S[i].length() <= dot) break;\n                //System.err.println(now +\"  \" + i + \"  \" + (ope ? \"*\" : \"+\"));\n                if (len < S[i].length()) break;\n                //System.err.println(now +\"  \" + i + \"  \" + (ope ? \"*\" : \"+\"));\n                final char c = S[i].charAt(dot);\n                if (c == '.') {\n                    if (ans == -1) ans = dfs(i, dot + 1, ope);\n                    else ans = (ope ? ans * dfs(i, dot + 1, ope) : ans + dfs(i, dot + 1, ope));\n                } else if (c == '+' || c == '*') {\n                    visited[i] = true;\n                    if (ans == -1) ans = dfs(i + 1, dot + 1, c == '*');\n                    else ans = (ope ? ans * dfs(i + 1, dot + 1, c == '*') : ans + dfs(i + 1, dot + 1, c == '*'));\n                } else {\n                    visited[i] = true;\n                    if (ans == -1) {\n                        if (i + 1 < n && len == S[i + 1].length()) {\n                            ans = (ope ? (c - '0') * dfs(i + 1, dot, ope) : (c - '0') + dfs(now + 1, dot, ope));\n                        } else {\n                            ans = (c - '0');\n                        }\n                    } else {\n                        if (i + 1 < n && len == S[i + 1].length()) {\n                            ans = (ope ? ans * (c - '0') * dfs(i + 1, dot, ope) : ans + (c - '0') + dfs(now + 1, dot, ope));\n                        } else {\n                            ans = (ope ? ans * (c - '0') : ans + (c - '0'));\n                        }\n                    }\n                    break;\n                }\n            }\n            //System.err.println(now + \" \" + ans + \" \" + (ope ? \"*\" : \"+\"));\n            return ans;\n        }\n\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            var n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            var a = new int[n];\n            var b = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                var s = Console.ReadLine().Trim();\n                a[i] = s.Length - s.Replace(\".\", \"\").Length;\n                s = s.Replace(\".\", \"\");\n                if (s == \"+\") b[i] = -1;\n                else if (s == \"*\") b[i] = -2;\n                else b[i] = int.Parse(s);\n            }\n            var ans =   getAns(a, b, n);\n            Console.WriteLine(ans);\n        }\n    }\n    static int getAns (int[] a, int[] b, int n)\n    {\n        var c = new List<int>[n];\n        for (int i = 0; i < n; i++) c[i] = new List<int>();\n        for (int i = n -1; i >= 0; i--)\n        {\n            if (b[i] >= 0) c[a[i]].Add(b[i]);\n            else if (b[i] == -1)\n            {\n                var t = c[a[i] + 1].Sum();\n                c[a[i]].Add(t);\n                c[a[i] + 1].Clear();\n            }\n            else\n            {\n                var t = c[a[i] + 1].Aggregate((x, y) => x * y);\n                c[a[i]].Add(t);\n                c[a[i] + 1].Clear();\n            }\n        }\n        return c[0][0];\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "class Tree\n    def initialize(*args)\n        @val, @parent = args\n        @depth = (parent ? parent.depth + 1 : 1)\n        @children = []\n        @parent.children << self if @parent\n    end\n    def eval\n        return @val.to_i if @val =~ /\\d/\n        @children.map {|c| c.eval}.inject(@val.to_sym)\n    end\n    attr_reader :parent, :children, :depth\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    root = v = nil\n    n.times do\n        gets =~ /(\\.*)(.+)/\n        depth, x = $1.size, $2\n        v = v.parent until !v || depth == v.depth\n        v = Tree.new(x, v)\n        root ||= v\n    end\n    p root.eval\nend"
  },
  {
    "language": "Ruby",
    "code": "def calc(i)\n    case $char[i]\n    when \"*\"\n        $children[i].inject(1) {|r, v| r * calc(v)}\n    when \"+\"\n        $children[i].inject(0) {|r, v| r + calc(v)}\n    else\n        $char[i].to_i\n    end\nend\n\nloop do\n    break if (l = gets.to_i) == 0\n\n    $char = Array.new(l)\n    $char[0] = gets.chomp\n    $children = Array.new(l){[]}\n\n    (l-1).times do |i|\n        i += 1\n        s = gets.chomp\n        n = s.count(\".\")\n\n        now = 0\n        (n-1).times {now = $children[now][-1]}\n\n        $children[now] << i\n        $char[i] = s[-1]\n    end\n    \n    puts calc(0)\nend\n"
  },
  {
    "language": "Ruby",
    "code": "loop do\n\n  n = gets.to_i\n  if n == 0 then break end\n\n  dimp = 0\n  dimn = 0\n  tmp = ''\n\n  optr = Array.new(n + 1, '?')\n  opnd = Array.new(n + 1).map{Array.new}\n\n  for i in 0 .. n - 1\n    \n    keynext = gets.chomp.chars\n    \n    dimn = keynext.count('.')\n    tmp  = keynext[-1]\n\n    #p optr, opnd\n\n    if dimn < dimp\n \n      opcnt = dimp - dimn\n\n      while opcnt > 0\n\n        tmpresult = opnd[dimp].shift\n\n        while opnd[dimp].size > 0\n\n          if optr[dimp - 1] == '+'\n            tmpresult = tmpresult + opnd[dimp].shift\n          elsif optr[dimp - 1] == '*'\n            tmpresult = tmpresult * opnd[dimp].shift\n          end\n\n          #p tmpresult\n        end\n        opcnt -= 1\n        dimp -= 1\n\n        opnd[dimp] << tmpresult\n        #p optr, opnd\n      end\n    end\n    dimp = dimn\n\n    if tmp == '+' || tmp == '*'\n      optr[dimn] = tmp\n    else\n      opnd[dimn].push(tmp.to_i)\n    end\n  end\n\n  while dimp > 0\n\n    tmpresult = opnd[dimp].shift\n\n    while opnd[dimp].size > 0\n\n      if optr[dimp - 1] == '+'\n        tmpresult = tmpresult + opnd[dimp].shift\n      elsif optr[dimp - 1] == '*'\n        tmpresult = tmpresult * opnd[dimp].shift\n      end\n    end\n\n    #p optr, opnd\n\n    dimp -= 1\n    opnd[dimp] << tmpresult\n  end\n  puts opnd[dimp]\nend\n\n\n\n"
  },
  {
    "language": "Ruby",
    "code": "class Tree\n    def initialize(val, parent)\n        @val, @parent = val, parent\n        @depth = (parent ? parent.depth + 1 : 1)\n        @children = []\n        @parent.children << self if @parent\n    end\n\n    def eval\n        return @val.to_i if @val =~ /\\d/\n        return @children.map {|c| c.eval}.inject(@val.to_sym)\n    end\n\n    attr_reader :parent, :children, :depth\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n\n    parent = {}\n    root = nil\n    v = nil\n    n.times do\n        gets.chomp =~ /(\\.*)(.+)/\n        indent = $1.size\n        v = v.parent until !v || indent == v.depth\n        x = $2\n        v = Tree.new(x, v)\n        root ||= v\n    end\n    p root.eval\nend"
  },
  {
    "language": "Ruby",
    "code": "def calcs(x,y,ax,ay,bx,by) ((ax-x)*(by-y)-(bx-x)*(ay-y))/2.0 end\ndef inpf() a=gets.chomp.split(\" \").map(&:to_f)end\ndef inps() a=gets.chomp.split(\" \")end  \ndef copy(a) Marshal.load(Marshal.dump(a)) end\ndef kaizyo(n)(n < 2)? 1 : (2..n).inject(:*) end\ndef scount(a) b=na(a.max+1);a.each{|n|b[n]+=1};return b end\ndef na(n,d=0) Array.new(n,d)end\ndef na2(n,m,d=0) Array.new(n){Array.new(m,d)}end\ndef na3(n,m,l,d=0) Array.new(n){Array.new(m){Array.new(l,d)}}end\ndef bit(n) n.to_s(2).split(\"\").map(&:to_i) end\ndef inp() a=gets.chomp.split(\" \").map(&:to_i)end\n@m=[]\ndef solve(cal,a,len,x)\n  return if(a[x] == nil)\n  ans = (cal == \"+\")? 0 : 1\n  while(a[x].size >= len)\n  if((a[x][-1] == \"+\" or a[x][-1] == \"*\") and a[x].size == len)\n    @m.push(a[x][-1])\n    ans += solve(a[x][-1],a,len+1,x+1) if(cal == \"+\")\n    ans *= solve(a[x][-1],a,len+1,x+1) if(cal == \"*\")\n  else\n    if cal == \"+\"\n      ans += (a[x].size == len)?  a[x][-1].to_i : 0\n    else\n      ans *= (a[x].size == len)?  a[x][-1].to_i : 1  \n    end\n  end\n  x+=1\n  break if(a[x] == nil)\n  end\n  return ans\nend\nwhile((n = inp[0])!=nil)\n  if(n == 1)\n    puts inp[0]\n    next\n  end\n  tab = []\n  n.times do \n    tab.push(gets.chomp)\n  end\n  p solve(tab[0],tab,1,0)\nend"
  },
  {
    "language": "Ruby",
    "code": "$data = []\nans = []\nmet = <<~EOS\ndef culc ope, level\n\tcase ope\n\twhen '+'\n\t\tresult = 0\n\t\texe = \"+=\"\n\twhen '*'\n\t\tresult = 1\n\t\texe = \"*=\"\n\tend\n\tloop{\n\t\tif $data.empty? || $data.first.length < level \n\t\t\treturn result\n\t\telse\n\t\t\ttmp = $data.first.split(\"\").last.to_s\n\t\t\tif tmp == '*' || tmp == '+'\n\t\t\t\tans = culc $data.shift.split(\"\").last.to_s, level + 1\n\t\t\telse\n\t\t\t\tans = $data.shift.split(\"\").last.to_i\n\t\t\tend\n\t\tend\n\t\teval(\"result\"+exe+\"ans\")\n\t}\nend\nEOS\n\nR = RubyVM::InstructionSequence\nR.compile_option = {tailcall_optimization: true, trace_instruction: false}\nR.new(met).eval\n\nloop{\n\tnum = gets.to_i\n\tbreak if num == 0\n\tnum.times do\n\t\t$data << gets.chomp \n\tend\n\tif num == 1\n\t\tans << $data.shift\n\telse\n\t\tans << culc($data.shift, 2)\n\tend\n}\nans.each do |a|\n\tputs a\nend"
  },
  {
    "language": "Ruby",
    "code": "$data = []\nans = []\ndef culc ope, level\n\tcase ope\n\twhen '+'\n\t\tresult = 0\n\t\texe = \"+=\"\n\twhen '*'\n\t\tresult = 1\n\t\texe = \"*=\"\n\tend\n\tloop{\n\t\tif $data.empty? || $data.first.length < level \n\t\t\treturn result\n\t\telse\n\t\t\ttmp = $data.first.split(\"\").last.to_s\n\t\t\tif tmp == '*' || tmp == '+'\n\t\t\t\tans = culc $data.shift.split(\"\").last.to_s, level + 1\n\t\t\telse\n\t\t\t\tans = $data.shift.split(\"\").last.to_i\n\t\t\tend\n\t\tend\n\t\teval(\"result\"+exe+\"ans\")\n\t}\nend\n\nloop{\n\tnum = gets.to_i\n\tbreak if num == 0\n\tnum.times do\n\t\t$data << gets.chomp \n\tend\n\tif num == 1\n\t\tans << $data.shift\n\telse\n\t\tans << culc($data.shift, 2)\n\tend\n}\nans.each do |a|\n\tputs a\nend"
  },
  {
    "language": "Ruby",
    "code": "def calcs(x,y,ax,ay,bx,by) ((ax-x)*(by-y)-(bx-x)*(ay-y))/2.0 end\ndef inpf() a=gets.chomp.split(\" \").map(&:to_f)end\ndef inps() a=gets.chomp.split(\" \")end  \ndef copy(a) Marshal.load(Marshal.dump(a)) end\ndef kaizyo(n)(n < 2)? 1 : (2..n).inject(:*) end\ndef scount(a) b=na(a.max+1);a.each{|n|b[n]+=1};return b end\ndef na(n,d=0) Array.new(n,d)end\ndef na2(n,m,d=0) Array.new(n){Array.new(m,d)}end\ndef na3(n,m,l,d=0) Array.new(n){Array.new(m){Array.new(l,d)}}end\ndef bit(n) n.to_s(2).split(\"\").map(&:to_i) end\ndef inp() a=gets.chomp.split(\" \").map(&:to_i)end\n@m=[]\ndef solve(cal,a,len,x)\n  return if(a[x] == nil)\n  ans = (cal == \"+\")? 0 : 1\n  while(a[x].size >= len)\n  if((a[x][-1] == \"+\" or a[x][-1] == \"*\") and a[x].size == len)\n    @m.push(a[x][-1])\n    ans += solve(a[x][-1],a,len+1,x+1) if(cal == \"+\")\n    ans *= solve(a[x][-1],a,len+1,x+1) if(cal == \"*\")\n  else\n    if cal == \"+\"\n      ans += (a[x].size == len)?  a[x][-1].to_i : 0\n    else\n      ans *= (a[x].size == len)?  a[x][-1].to_i : 1  \n    end\n  end\n  x+=1\n  break if(a[x] == nil)\n  end\n  return ans\nend\nwhile((n = inp[0])!=nil)\n  if(n == 1)\n    puts inp[0]\n    next\n  end\n  tab = []\n  n.times do \n    tab.push(gets.chomp)\n  end\n  ans = solve(tab[0],tab,1,0) \n  if(ans == nil)\n    exit\n  end\n  p ans \nend"
  },
  {
    "language": "Ruby",
    "code": "$data = []\nans = []\ndef culc ope, level\n\tcase ope\n\twhen '+'\n\t\tresult = 0\n\t\texe = \"+=\"\n\twhen '*'\n\t\tresult = 1\n\t\texe = \"*=\"\n\tend\n\tloop{\n\t\tif $data.empty? || $data.first.length < level \n\t\t\treturn result\n\t\telse\n\t\t\ttmp = $data.first.split(\"\").last.to_s\n\t\t\tif tmp == '*' || tmp == '+'\n\t\t\t\tans = culc $data.shift.split(\"\").last.to_s, level + 1\n\t\t\telse\n\t\t\t\tans = $data.shift.split(\"\").last.to_i\n\t\t\tend\n\t\tend\n\t\teval(\"result\"+exe+\"ans\")\n\t}\nend\n\nloop{\n\tnum = gets.to_i\n\tbreak if num == 0\n\tnum.times do\n\t\t$data << gets.chomp \n\tend\n\tif num == 1\n\t\tans << $data.shift\n\telse\n\t\tans << culc($data.shift ,2)\n\tend\n}\nans.each do |a|\n\tputs a\nend"
  },
  {
    "language": "Ruby",
    "code": "$data = []\nans = []\nmet = <<~EOS\ndef culc ope, level\n\tcase ope\n\twhen '+'\n\t\tresult = 0\n\t\texe = \"+=\"\n\twhen '*'\n\t\tresult = 1\n\t\texe = \"*=\"\n\tend\n\tloop{\n\t\tif $data.empty? || $data.first.length < level \n\t\t\treturn result\n\t\telse\n\t\t\ttmp = $data.first.split(\"\").last.to_s\n\t\t\tif tmp == '*' || tmp == '+'\n\t\t\t\tans = culc $data.shift.split(\"\").last.to_s, level + 1\n\t\t\telse\n\t\t\t\tans = $data.shift.split(\"\").last.to_i\n\t\t\tend\n\t\tend\n\t\teval(\"result\"+exe+\"ans\")\n\t}\nend\nEOS\n\nR = RubyVM::InstructionSequence\nR.compile_option = {tailcall_optimization: true, trace_instruction: false}\nR.new(met).eval\n\nloop{\n\tnum = gets.to_i\n\tbreak if num == 0\n\tnum.times do\n\t\t$data << gets.chomp \n\tend\n\tif num == 1\n\t\tans << $data.shift\n\telse\n\t\tans << culc($data.shift, 2)\n\tend\n}\nans.each do |a|\n\tputs a\nend"
  },
  {
    "language": "Ruby",
    "code": "$data = []\nans = []\ndef culc ope, level\n\tcase ope\n\twhen '+'\n\t\tresult = 0\n\t\texe = \"+=\"\n\twhen '*'\n\t\tresult = 1\n\t\texe = \"*=\"\n\tend\n\tloop{\n\t\tif $data.empty? || $data.first.length < level \n\t\t\treturn result\n\t\telse\n\t\t\ttmp = $data.first.split(\"\").last.to_s\n\t\t\tif tmp == '*' || tmp == '+'\n\t\t\t\tans = culc $data.shift.split(\"\").last.to_s, level + 1\n\t\t\telse\n\t\t\t\tans = $data.shift.split(\"\").last.to_i\n\t\t\tend\n\t\tend\n\t\teval(\"result\"+exe+\"ans\")\n\t}\nend\n\nloop{\n\tnum = gets.to_i\n\tbreak if num == 0\n\tnum.times do\n\t\t$data << gets.chomp \n\tend\n\tif num == 1\n\t\tans << $data.shift\n\telse\n\t\tans << culc $data.shift, 2\n\tend\n}\nans.each do |a|\n\tputs a\nend"
  },
  {
    "language": "Ruby",
    "code": "$data = []\nans = []\nmet <<~EOS\ndef culc ope, level\n\tcase ope\n\twhen '+'\n\t\tresult = 0\n\t\texe = \"+=\"\n\twhen '*'\n\t\tresult = 1\n\t\texe = \"*=\"\n\tend\n\tloop{\n\t\tif $data.empty? || $data.first.length < level \n\t\t\treturn result\n\t\telse\n\t\t\ttmp = $data.first.split(\"\").last.to_s\n\t\t\tif tmp == '*' || tmp == '+'\n\t\t\t\tans = culc $data.shift.split(\"\").last.to_s, level + 1\n\t\t\telse\n\t\t\t\tans = $data.shift.split(\"\").last.to_i\n\t\t\tend\n\t\tend\n\t\teval(\"result\"+exe+\"ans\")\n\t}\nend\nEOS\n\nR = RubyVM::InstructionSequence\nR.compile_option = {tailcall_optimization: true, trace_instruction: false}\nR.new(met).eval\n\nloop{\n\tnum = gets.to_i\n\tbreak if num == 0\n\tnum.times do\n\t\t$data << gets.chomp \n\tend\n\tif num == 1\n\t\tans << $data.shift\n\telse\n\t\tans << culc($data.shift, 2)\n\tend\n}\nans.each do |a|\n\tputs a\nend"
  },
  {
    "language": "Ruby",
    "code": "$data = []\nans = []\ndef culc ope, level\n\tcase ope\n\twhen '+'\n\t\tresult = 0\n\twhen '*'\n\t\tresult = 1\n\tend\n\tloop{\n\t\tif $data.empty? || $data.first.length < level \n\t\t\treturn result\n\t\telse\n\t\t\ttmp = $data.first.split(\"\").last.to_s\n\t\t\tif tmp == '*' || tmp == '+'\n\t\t\t\tans = culc $data.shift.split(\"\").last.to_s, level + 1\n\t\t\telse\n\t\t\t\tans = $data.shift.split(\"\").last.to_i\n\t\t\tend\n\t\tend\n\n\t\tcase ope\n\t\twhen '+'\n\t\t\tresult += ans\n\t\twhen '*'\n\t\t\tresult *= ans\n\t\tend\n\t}\nend\n\nloop{\n\tnum = gets.to_i\n\tbreak if num == 0\n\tnum.times do\n\t\t$data << gets.chomp \n\tend\n\tif num == 1\n\t\tans << $data.shift\n\telse\n\t\tans << culc($data.shift ,2)\n\tend\n}\n\nans.each do |a|\n\tputs a\nend"
  },
  {
    "language": "Ruby",
    "code": "lass Tree\n    def initialize(val, parent)\n        @val, @parent = val, parent\n        @depth = (parent ? parent.depth + 1 : 1)\n        @children = []\n        @parent.children << self if @parent\n    end\n\n    def eval\n        return @val.to_i if @val =~ /\\d/\n        return @children.map {|c| c.eval}.inject(@val.to_sym)\n    end\n\n    attr_reader :parent, :children, :depth\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n\n    parent = {}\n    root = nil\n    v = nil\n    n.times do\n        gets.chomp =~ /(\\.*)(.+)/\n        indent = $1.size\n        v = v.parent until !v || indent == v.depth\n        x = $2\n        v = Tree.new(x, v)\n        root ||= v\n    end\n    p root.eval\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n    n = gets.to_i\n    break if n == 0\n\n    lines = []\n    n.times{\n        line = gets.chomp\n        lines << [line.count('.'), line[-1]]\n    }\n\n    stack = []\n    (n - 1).downto(0){|i|\n        level, number = lines[i]\n        case number\n        when \"+\"\n            sum = 0\n            until stack.empty? || stack[-1][0] != level + 1\n                l, x = stack.pop\n                sum += x\n            end\n            stack << [level, sum]\n        when \"*\"\n            product = 1\n            until stack.empty? || stack[-1][0] != level + 1\n                l, x = stack.pop\n                product *= x\n            end\n            stack << [level, product]\n        else\n            stack << [level, number.to_i]\n        end\n    }\n    puts stack[0][1]\nend\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\n\ndef mul(A):\n    res = 1\n    for a in A:\n        res *= a\n    return res\n\nO = {'+': sum, '*': mul}\n\n\nclass Source():\n    def __init__(self, S, i = 0):\n        self.S = S\n        self.pos = i\n\ndef peek(S):\n    return S.S[S.pos] if S.pos < len(S.S) else 'a'\n\ndef next(S):\n    S.pos += 1\n\ndef level_off(S):\n    lv = 0\n    while peek(S) == '.':\n        lv += 1\n        next(S)\n\n    return lv\n\ndef level(S):\n    i = S.pos\n    lv = 0\n    while peek(S) == '.':\n        lv += 1\n        next(S)\n\n    S.pos = i\n    return lv\n\ndef expr(S, lv, ope):\n    A = []\n    while peek(S) != 'a' and level(S) == lv:\n        level_off(S)\n        A.append(factor(S, lv))\n    return ope(A)\n\ndef factor(S, lv):\n    if peek(S) in O:\n        ope = O[peek(S)]\n        next(S)\n        return expr(S, lv + 1, ope)\n    return num(S)\n\ndef num(S):\n    res = int(peek(S))\n    next(S)\n\n    return res\n\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    S = []\n    for i in range(n):\n        S.append(input())\n    print(expr(Source(''.join(S)), 0, O['+']))\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    n=int(input())\n    if n==0:\n        break;\n    elif n==1:\n        print(input())\n        continue;\n    li=[input() for i in range(n)]\n    index=0\n    def pls(depth):\n        k=0\n        global index\n        while len(li[index])>depth and li[index][depth-1]=='.':\n            if (not li[index][depth]=='+') and (not li[index][depth]=='*'):\n                k+=int(li[index][depth])\n                index+=1\n            elif li[index][depth]=='+':\n                index+=1\n                k+=pls(depth+1)\n            elif li[index][depth]=='*':\n                index+=1\n                k+=prd(depth+1)\n            if index==n:\n                return k    \n        else:\n            return k\n    def prd(depth):\n        k=1\n        global index\n        while len(li[index])>depth and li[index][depth-1]=='.':\n            if (not li[index][depth]=='+') and (not li[index][depth]=='*'):\n                k*=int(li[index][depth])\n                index+=1\n            elif li[index][depth]=='+':\n                index+=1\n                k*=pls(depth+1)\n            elif li[index][depth]=='*':\n                index+=1\n                k*=prd(depth+1)\n            if index==n:\n                return k\n        else:\n            return k\n    if li[0]=='+':\n        index+=1\n        print(pls(1))\n    elif li[0]=='*':\n        index+=1\n        print(prd(1))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nwhile True:\n    n = input()\n    lst = []\n    if n == 0:\n        break\n    if n == 1:\n        num = input()\n        print num\n        continue\n    for loop in range(n):\n        S = raw_input()\n        lst.append((len(S), S[-1]))\n    \n    c_lst = [0 for i in range(1000)]\n    v_lst = [0 for i in range(1000)]\n\n    rank = 1\n    for i in range(n):\n        r = lst[i][0]\n        c = lst[i][1]\n        while r < rank:\n            if c_lst[rank - 1] == '+':\n                v_lst[rank - 1] += v_lst[rank]\n            else:\n                v_lst[rank - 1] *= v_lst[rank]\n            rank -= 1\n        if c == '+':\n            r += 1\n            c_lst[r] = '+'\n            v_lst[r] = 0\n            rank += 1\n            continue\n        elif c == '*':\n            r += 1\n            c_lst[r] = '*'\n            v_lst[r] = 1\n            rank += 1\n            continue\n        if c_lst[r] == '+':\n            v_lst[r] += int(c)\n        else:\n            v_lst[r] *= int(c)\n    print v_lst[2]\n    \n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nfrom functools import reduce\ndef check(dt,st,lv):\n    global p\n    if p>=len(dt):\n        return st\n        \n    if not dt[p][-1].isdigit() and lv==len(dt[p]):\n        tmp=p\n        p+=1\n        st.append(reduce(lambda a,b:a+b if dt[tmp][-1]=='+' else a*b,check(dt,[],lv+1)))\n        return check(dt,st,lv)\n\n    elif lv==len(dt[p]):\n        st.append(int(dt[p][-1]))\n        p+=1\n        return check(dt,st,lv)\n    else:\n        return st\n\n    \nwhile 1:\n    n=int(input())\n    if n==0:\n        break\n    data=[]\n    for i in range(n):\n        data.append(list(input()))\n    p=0\n    print(check(data,[],1)[0])\n    \n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    n = int(input())\n    if n == 0:break\n    a = [input() for _ in range(n)]\n    while True:\n        if len(a) == 1:break\n        c = 0\n        s = 0\n        for i in range(len(a)):\n            if a[i].count('.') > c:\n                c = a[i].count('.')\n                s = i\n        e = s\n        while e < len(a) and a[e].count('.') == a[s].count('.'):\n            e += 1\n        k = a[s - 1].replace('.', '')\n        b = [a[i] for i in range(s, e)]\n        for i in range(len(b)):\n            b[i] = int(b[i].replace('.', ''))\n        if k == '+':\n            a[s] = '.'*a[s].count('.')+str(sum(b))\n            del a[s + 1:e]\n        else:\n            m = 1\n            for i in b:\n                m *= i\n            a[s] = '.'*a[s].count('.')+str(m)\n            del a[s + 1:e]\n    print(a[0])\n    \n"
  },
  {
    "language": "Python",
    "code": "while True:\n  n = int(input())\n  if n==0:\n    break\n  if n==1:\n    print(int(input()))\n    continue\n\n  op = \"+*\"\n  f = [input() for i in range(n)]\n  f = f[::-1]\n  stack = []\n\n  for i in range(n):\n    if f[i][-1] not in op:\n      stack.append(f[i])\n    else:\n      nest = f[i].count(\".\")\n      if f[i][-1]==\"*\":\n        cur = 1\n        while len(stack):\n          if stack[-1].count(\".\")!=nest+1:\n            break\n          else:\n            t = stack.pop().strip(\".\")\n            cur *= int(t)\n        stack.append(\".\"*(nest)+str(cur))\n      else:\n        cur = 0\n        while len(stack):\n          if stack[-1].count(\".\")!=nest+1:\n            break\n          else:\n            t = stack.pop().strip(\".\")\n            cur += int(t)\n        stack.append(\".\"*(nest)+str(cur))\n  print(stack[0])\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    n = int(input())\n    if n == 0:break\n    a = [input() for _ in range(n)]\n    while True:\n        if len(a) == 1:break\n        c = 0\n        s = 0\n        for i in range(len(a)):\n            if a[i].count('.') > c:\n                c = a[i].count('.')\n                s = i\n        e = s\n        while e < len(a) and a[e].count('.') == a[s].count('.'):\n            e += 1\n        k = a[s - 1].replace('.', '')\n        b = [a[i] for i in range(s, e)]\n        for i in len(b):\n            b[i] = int(b[i].replace('.', ''))\n        if k == '+':\n            a[s] = '.'*a[s].count('.')+str(sum(b))\n            del a[s + 1:e]\n        else:\n            m = 1\n            for i in b:\n                m *= i\n            a[s] = '.'*a[s].count('.')+str(m)\n            del a[s + 1:e]\n    print(a[0])\n    \n"
  },
  {
    "language": "Python",
    "code": "ans_list = []\ndef calclater(a, num_list):\n    if a == \"*\":\n        ans = 1\n        for i in num_list:\n            ans *= int(i)\n    elif a == \"+\":\n        ans = 0\n        for i in num_list:\n            ans += int(i)\n    return str(ans)\n\nwhile True:\n    n = int(input())\n    if not n:\n        break\n    s_list = [[] for i in range(100)]\n    now = 0\n    now_len = 0\n    for i in range(n):\n        s = input()\n        if not i:\n            s_list[0] = [s]\n            now_len = len(s)\n        else:\n            if len(s) == now_len:\n                s_list[now].append(s[-1])\n            elif len(s) > now_len:\n                now += 1\n                s_list[now] = [s[-1]]\n                now_len = len(s)\n            elif len(s) < now_len:\n                while len(s) < now_len:\n                    s_list[now - 1][-1] = str(calclater(s_list[now - 1][-1], list(s_list[now])))\n                    s_list[now] = []\n                    now_len -= 1\n                    now -= 1\n                s_list[now].append(s[-1])\n\n    for i in range(now - 1, -1, -1):\n        s_list[i][-1] = str(calclater(s_list[i][-1], s_list[i + 1]))\n\n    ans_list.append(s_list[0][0])\n\nfor i in ans_list:\n    print(i)\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 1602: ICPC Calculator\n# Python3 2018.7.13 bal4u\n\ndef calc(lvl, idx):\n\tc = e[idx][lvl]\n\tif c.isdigit(): return [int(c), idx+1]\n\tlvl, idx = lvl+1, idx+1\n\tx = 0 if c == '+' else 1\n\twhile idx < len(e):\n\t\tf = i = 0\n\t\twhile i < len(e[idx]) and i < lvl:\n\t\t\tif e[idx][i] != '.': break\n\t\t\ti += 1\n\t\tif i < lvl: break\n\t\tif e[idx][i].isdigit(): y, f = int(e[idx][i]), 1\n\t\telse: y, idx = calc(lvl, idx)\n\t\tx = x+y if c == '+' else x*y\n\t\tif f: idx += 1\n\treturn [x, idx]\n\nwhile True:\n\tn = int(input())\n\tif n == 0: break\n\te = [list(input()) for i in range(n)]\n\tprint(calc(0, 0)[0])\n\n"
  },
  {
    "language": "Python",
    "code": "def expression(ss, i, c_level):\n    s = ss[i]\n    code = s[-1]\n    if code == \"+\":\n        return plus(ss, i+1, c_level+1)\n    elif code == \"*\":\n        return product(ss, i+1, c_level+1)\n    return int(s[c_level:])\n\ndef plus(ss, i, c_level):\n    num = 0\n    while i < len(ss):\n        s = ss[i]\n        level = len(s)-1\n        if level < c_level:\n            break\n        if c_level < level:\n            i += 1\n            continue\n        num += expression(ss, i, c_level)\n        i += 1\n    return num\n\ndef product(ss, i, c_level):\n    num = 1\n    while i < len(ss):\n        s = ss[i]\n        level = len(s)-1\n        if level < c_level:\n            break\n        if c_level < level:\n            i += 1\n            continue\n        num *= expression(ss, i, c_level)\n        i += 1\n    return num\n\nwhile 1:\n    n = input()\n    if n == 0:\n        break\n    ss = [raw_input() for i in xrange(n)]\n    print expression(ss, 0, 0)"
  },
  {
    "language": "Python",
    "code": "def calc(p, nums):\n    if p == '+':\n        ans = sum(nums)\n    else:\n        ans = 1\n        for i in nums:\n            ans *= i\n    return ans\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        quit()\n    w = []\n    depth = 0\n    for i in range(n):\n        t = input()\n        td = t.count('.')\n        tc = t.replace('.', '')\n        if tc.isdigit():\n            tc = int(tc)\n        else:\n            td += 1\n        w.append([td, tc])\n        depth = max(depth, td)\n\n    # while len(w) != 1:\n    while depth > 0:\n        # print(w)\n        for i in range(len(w)):\n            if w[i][0] == depth:\n                temp = []\n                for j in range(i+1, len(w)):\n                    # print(w[j][1], j)\n                    if w[j][0] == depth and str(w[j][1]).isdigit():\n                        temp.append(w[j][1])\n                # print(w[i][1], temp)\n                ta = calc(w[i][1], temp)\n                # print(ta)\n                if j >= len(w):\n                    w = w[:i] + [[depth - 1, ta]]\n                else:\n                    w = w[:i] + [[depth - 1, ta]] + w[j:]\n                # w = w[:i] + w[depth, ta] + w[j:]\n                break\n        depth -= 1\n    print(w[0][1])\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(input())\ndef inpl(): return list(map(int, input().split()))\ndef inpl_str(): return list(input().split())\n\n\nwhile True:\n    N = inp()\n    if N == 0:\n        break\n    else:\n        stack_numbers = [[] for _ in range(20)]\n        stack_symbols = ['' for _ in range(20)]\n        bL = -1\n        for _ in range(N):\n            S = input()\n            L = len(S)\n            #print(stack_symbols)\n            #print(stack_numbers)\n            if L < bL:\n                for i in reversed(range(L,bL)):\n                    if stack_symbols[i] == '+':\n                        for j in range(1,len(stack_numbers[i])):\n                            stack_numbers[i][j] += stack_numbers[i][j-1]\n                    else:\n                        for j in range(1,len(stack_numbers[i])):\n                            stack_numbers[i][j] *= stack_numbers[i][j-1]\n                    stack_numbers[i-1].append(stack_numbers[i][-1])\n                    stack_numbers[i] = []\n                    stack_symbols[i] = ''\n                    #print(stack_numbers)\n\n            s = S[-1]\n            if 48 <= ord(s) <= 57:\n                s = int(s)\n                stack_numbers[L-1].append(s)\n            else:\n                stack_symbols[L] = s\n            bL = L\n\n        L = 0\n        for i in reversed(range(L,bL)):\n            if stack_symbols[i] == '+':\n                for j in range(1,len(stack_numbers[i])):\n                    stack_numbers[i][j] += stack_numbers[i][j-1]\n            else:\n                for j in range(1,len(stack_numbers[i])):\n                    stack_numbers[i][j] *= stack_numbers[i][j-1]\n            stack_numbers[i-1].append(stack_numbers[i][-1])\n            stack_numbers[i] = []\n            stack_symbols[i] = ''\n\n        print(stack_numbers[-1][0])\n\n"
  },
  {
    "language": "Python",
    "code": "from functools import reduce\nimport operator\n\nwhile True:\n  n = int(input())\n  if n == 0:break\n  def fix(x):\n    if x[-1] in (\"+\", \"*\"):\n      return (x.count(\".\"), x[-1])\n    else:\n      return (x.count(\".\"), int(x[-1]))\n\n  lst = [fix(input()) for _ in range(n)]\n  while True:\n    if len(lst) == 1:\n      print(lst[0][1])\n      break\n    \n    max_depth = -1\n    index = 100\n    op = \"-\"\n    for i, t in enumerate(lst):\n      d, v = t\n      if d > max_depth and v in (\"+\", \"*\"):\n        max_depth = d\n        index = i\n        op = v\n\n    pop_lst = []\n    acc_lst = []\n    i = index + 1\n    while i < len(lst) and lst[i][0] == max_depth + 1:\n      pop_lst.append(i)\n      acc_lst.append(lst[i][1])\n      i += 1\n    if op == \"+\":\n      new_value = reduce(operator.add, acc_lst)\n    else:\n      new_value = reduce(operator.mul, acc_lst)\n\n    for i in reversed(pop_lst):\n      lst.pop(i)\n    lst.pop(index)\n    lst.insert(index, (max_depth, new_value))\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom collections import defaultdict\ndef inpl(): return list(map(int, input().split()))\n\nN = int(input())\n\ndef cal(i):\n    if B[i] == \"*\":\n        tmp = 1\n        for g in G[i]:\n            tmp *= cal(g)\n    elif B[i] == \"+\":\n        tmp = 0\n        for g in G[i]:\n            tmp += cal(g)\n    else:\n        tmp = int(B[i])\n    return tmp\n\nwhile N:\n    A = [0]*N\n    B = [0]*N\n    for i in range(N):\n        x = input()\n        A[i], B[i] = x.count(\".\"), x.replace(\".\", \"\")\n    G = [[] for _ in range(N)]\n    D = defaultdict(int)\n    for i, a in enumerate(A):\n        D[a] = i\n        if a > 0:\n            G[D[a-1]].append(i)\n    print(cal(0))\n    N = int(input())\n\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n = input()\n    if n == 0:\n        break\n    st = [[]]\n    for i in xrange(n):\n        s = raw_input()\n        lev = s.count('.')\n        v = s[lev:]\n        while lev+1 < len(st):\n            top = st.pop()\n            op = st[-1].pop()\n            if op == '+':\n                st[-1].append(sum(top))\n            else:\n                st[-1].append(reduce(lambda x,y: x*y, top))\n        if v in '+*':\n            st[lev].append(v)\n            st.append([])\n        else:\n            st[lev].append(int(v))\n    while len(st) > 1:\n        top = st.pop()\n        op = st[-1].pop()\n        if op == '+':\n            st[-1].append(sum(top))\n        else:\n            st[-1].append(reduce(lambda x,y: x*y, top))\n    print st[-1][0]"
  },
  {
    "language": "Python",
    "code": "import functools\nimport operator\n\ndef calc(exps, level):\n    lst = []\n    while exps:\n        exp = exps[0]\n        nlevel = len(exp)-1\n\n        if nlevel < level:\n            break\n        else:\n            val = exps.pop(0)[-1]\n            if val in ('+', '*'):\n                operand = calc(exps, level+1)\n                if val == '+':\n                    val = sum(operand)\n                else:\n                    val = functools.reduce(operator.mul, operand)\n\n            elif '0' <= val <= '9':\n                val = int(val)\n\n            lst.insert(0, val)\n\n    return lst\n\ndef main():\n    while True:\n        n = int(input().strip())\n        if n == 0:\n            break\n        exps = [input().strip() for _ in range(n)]\n        print(calc(exps, 0)[0])\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    n = int(input())\n    if n == 0:break\n    a = [input() for _ in range(n)]\n    while True:\n        if len(a) == 1:break\n        c = 0\n        s = 0\n        for i in range(len(a)):\n            if a[i].count('.') > c:\n                c = a[i].count('.')\n                s = i\n        e = s\n        while e < len(a) and a[e].count('.') == a[s].count('.'):\n            e += 1\n        k = a[s - 1]\n        k.remove('.')\n        b = [a[i] for i in range(s, e)]\n        for i in len(b):\n            b[i].remove('.')\n            b[i] = int(b[i])\n        if k == '+':\n            a[s] = '.'*a[s].count('.')+str(sum(b))\n            del a[s + 1:e]\n        else:\n            m = 1\n            for i in b:\n                m *= i\n            a[s] = '.'*a[s].count('.')+str(m)\n            del a[s + 1:e]\n    print(a[0])\n    \n"
  },
  {
    "language": "Python",
    "code": "def solve(x,a,ind):\n#    print(x,a,ind)\n    if \"0\" <= a[0][ind] <=\"9\":\n        return int(a[0][ind])\n\n    if a[0][ind] ==\"+\":\n        i = j= 1\n        su = 0\n        while(i < x):\n            if a[i][ind+1] == \"+\" or a[i][ind+1]==\"*\":\n                j+=1\n                while j < x and a[j][ind +1]==\".\":\n                    j += 1\n                su += solve(j-i,a[i:j],ind+1)\n                i = j\n                j = j\n            else:\n                su += int(a[j][ind+1])\n                i += 1\n                j += 1\n\n#        print(x,a,ind,su)\n        return su\n\n\n    if a[0][ind] ==\"*\":\n        i = j= 1\n        su = 1\n        while(i < x):\n            if a[i][ind+1] == \"+\" or a[i][ind+1]==\"*\":\n                j+=1\n                while j<x and a[j][ind +1]==\".\":\n                    j += 1\n                su *= solve(j-i,a[i:j],ind+1)\n                i = j\n                j = j\n            else:\n                su *= int(a[j][ind+1])\n                i += 1\n                j += 1\n #       print(x,a,ind,su)\n        return su\n\n\nwhile(1):\n    n  = int(input())\n    if n >0:\n        a = [input() for i in range(n)]\n        print(solve(n,a,0))\n    else:\n        break\n"
  },
  {
    "language": "Python",
    "code": "#2005_c\n\"\"\"\nn = int(input())\nk = list(\"mcxi\")\nfor i in range(n):\n    d = {\"m\":0,\"c\":0,\"x\":0,\"i\":0}\n    a,b  = input().split()\n    a = list(a)\n    b = list(b)\n    a.insert(0,1)\n    b.insert(0,1)\n    for j in range(1,len(a)):\n        if a[j] in k:\n            if a[j-1] in k:\n                d[a[j]] += 1\n            else:\n                d[a[j]] += int(a[j-1])\n    for j in range(1,len(b))[::-1]:\n        if b[j] in k:\n            if b[j-1] in k:\n                d[b[j]] += 1\n            else:\n                d[b[j]] += int(b[j-1])\n            if d[b[j]] >= 10:\n                l = b[j]\n                while d[l] >= 10:\n                    d[l] -= 10\n                    l = k[k.index(l)-1]\n                    d[l] += 1\n    for j in k:\n        if d[j]:\n            if d[j] == 1:\n                print(j,end = \"\")\n            else:\n                print(str(d[j])+j,end = \"\")\n    print()\n\"\"\"\n\n#2017_c\n\"\"\"\nwhile 1:\n    h, w = map(int, input().split())\n    if h == w == 0:\n        break\n    s = [list(map(int, input().split())) for i in range(h)]\n\n    ans = 0\n    for u in range(h):\n        for d in range(u+2,h):\n            for l in range(w):\n                for r in range(l+2,w):\n                    m = float(\"inf\")\n                    for i in range(u,d+1):\n                        m = min(m,s[i][l],s[i][r])\n                    for i in range(l,r+1):\n                        m = min(m,s[u][i],s[d][i])\n                    f = 1\n                    su = 0\n                    for i in range(u+1,d):\n                        for j in range(l+1,r):\n                            su += (m-s[i][j])\n                            if s[i][j] >= m:\n                                f = 0\n                                break\n                        if not f:\n                            break\n                    if f:\n                        ans = max(ans,su)\n    print(ans)\n\"\"\"\n\n#2016_c\n\"\"\"\nwhile 1:\n    m,n = map(int, input().split())\n    if m == n == 0:\n        break\n    d = {}\n    ma = 7368791\n    for i in range(m,ma+1):\n        d[i] = 1\n    z = m\n    for i in range(n):\n        for j in range(z,ma+1):\n            if d[j]:\n                z = j\n                break\n        j = 1\n        while z*j <= ma:\n            d[z*j] = 0\n            j += 1\n    for j in range(z,ma+1):\n        if d[j]:\n            print(j)\n            break\n\"\"\"\n\n#2018_c\n\"\"\"\ndef factorize(n):\n    if n < 4:\n        return [1,n]\n    i = 2\n    l = [1]\n    while i**2 <= n:\n        if n%i == 0:\n            l.append(i)\n            if n//i != i:\n                l.append(n//i)\n        i += 1\n    l.append(n)\n    l.sort()\n    return l\nwhile 1:\n    b = int(input())\n    if b == 0:\n        break\n    f = factorize(2*b)\n    for n in f[::-1]:\n        a = 1-n+(2*b)//n\n        if a >= 1 and a%2 == 0:\n            print(a//2,n)\n            break\n\"\"\"\n\n#2010_c\n\"\"\"\nimport sys\ndp = [100]*1000000\ndp_2 = [100]*1000000\ndp[0] = 0\ndp_2[0] = 0\nfor i in range(1,181):\n    s = i*(i+1)*(i+2)//6\n    for j in range(s,1000000):\n        if dp[j-s]+1 < dp[j]:\n            dp[j] = dp[j-s]+1\n    if s%2:\n        for j in range(s,1000000):\n            if dp_2[j-s]+1 < dp_2[j]:\n                dp_2[j] = dp_2[j-s]+1\nwhile 1:\n    m = int(sys.stdin.readline())\n    if m == 0:\n        break\n    print(dp[m],dp_2[m])\n\"\"\"\n\n#2015_c\nfrom collections import deque\nwhile 1:\n    n = int(input())\n    if n == 0:\n        break\n    s = [input() for i in range(n)]\n    d = [s[i].count(\".\") for i in range(n)]\n    m = max(d)\n    c = [s[i][-1] for i in range(n)]\n    q = deque()\n    for i in range(1,m+1)[::-1]:\n        j = 0\n        while j < n:\n            for k in range(j,n):\n                if d[k] == i:break\n            else:\n                break\n            j = k\n            op = c[j-1]\n            while j < n and d[j] == i:\n                q.append(j)\n                j += 1\n            j = k\n            if op == \"+\":\n                k = 0\n                while q:\n                    x = q.pop()\n                    k += int(c[x])\n                    c.pop(x)\n                    d.pop(x)\n                    n -= 1\n            else:\n                k = 1\n                while q:\n                    x = q.pop()\n                    k *= int(c[x])\n                    c.pop(x)\n                    d.pop(x)\n                    n -= 1\n            c[j-1] = k\n    print(c[0])\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\n\ndef calc(i, level, fs, lim):\n    if fs[i][1] not in \"+*\":\n        return i, int(fs[i][1])\n    if fs[i][1] == \"+\":\n        tmp = 0\n        j = i+1\n        while j < lim:\n            if fs[j][0] <= level:\n                break\n            if fs[j][1] in \"*+\":\n                j, tmp2 = calc(j, level+1, fs, lim)\n                tmp += tmp2\n            else:\n                tmp += int(fs[j][1])\n            j += 1\n        return j-1, tmp\n    elif fs[i][1] == \"*\":\n        tmp = 1\n        j = i+1\n        while j < lim:\n            if fs[j][0] <= level:\n                break\n            if fs[j][1] in \"*+\":\n                j, tmp2 = calc(j, level+1, fs, lim)\n                tmp *= tmp2\n            else:\n                tmp *= int(fs[j][1])\n            j += 1\n        return j-1, tmp\n\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        fs = [[0,0] for i in range(n)]\n\n        for i in range(n):\n            tmp = input().strip()\n            fs[i][0] = tmp.count(\".\")\n            fs[i][1] = tmp.replace(\".\", \"\")\n        _, ans = calc(0, 0, fs, len(fs))\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "def inp():\n\tglobal n\n\tn = int(input())\n\treturn n\ndef strinp():\n\tl = 0\n\ts = list(input())\n\tfor i in s:\n\t\tif i == '.':\n\t\t\tl += 1\n\t\telse:\n\t\t\tc = i\n\treturn [l,c]\ndef calc(p):\n\tglobal f\n\tl = f[p][0]\n\tc = f[p][1]\n\tp += 1\n\tif c == '+':\n\t\tans = 0\n\t\tfor i in range(p,n):\n\t\t\tif f[i][0] == l:\n\t\t\t\tbreak\n\t\t\telif f[i][0] == l+1:\n\t\t\t\tans += calc(i)\n\telif c == '*':\n\t\tans = 1\n\t\tfor i in range(p,n):\n\t\t\tif f[i][0] == l:\n\t\t\t\tbreak\n\t\t\telif f[i][0] == l+1:\n\t\t\t\tans *= calc(i)\n\telse:\n\t\tans = int(c)\n\treturn ans\n\nwhile inp() > 0:\n\tf = []\n\tfor i in range(n):\n\t\tf.append(strinp())\n\tprint(calc(0))\n\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    n=int(input())\n    if n==0:\n        break;\n    li=[input() for i in range(n)]\n    index=0\n    def pls(depth):\n        k=0\n        global index\n        while len(li[index])>depth and li[index][depth-1]=='.':\n            if (not li[index][depth]=='+') and (not li[index][depth]=='*'):\n                k+=int(li[index][depth])\n                if not index==n-1:\n                    index+=1\n                else:\n                    return k\n            elif li[index][depth]=='+':\n                index+=1\n                k+=pls(depth+1)\n            elif li[index][depth]=='*':\n                index+=1\n                k+=prd(depth+1)\n        else:\n            return k\n    def prd(depth):\n        k=1\n        global index\n        while len(li[index])>depth and li[index][depth-1]=='.':\n            if (not li[index][depth]=='+') and (not li[index][depth]=='*'):\n                k*=int(li[index][depth])\n                if not index==n-1:\n                    index+=1\n                else:\n                    return k\n            elif li[index][depth]=='+':\n                index+=1\n                k*=pls(depth+1)\n            elif li[index][depth]=='*':\n                index+=1\n                k*=prd(depth+1)\n        else:\n            return k\n    if li[0]=='+':\n        index+=1\n        print(pls(1))\n    elif li[0]=='*':\n        index+=1\n        print(prd(1))"
  },
  {
    "language": "Python",
    "code": "def resolve():\n    n = int(input())\n    if n == 0:\n        return False\n\n    field = []\n    def add(a):\n        result = 0\n        for i in a:\n            result += i\n        return result\n\n    def mult(a):\n        result = 1\n        for i in a:\n            result *= i\n        return result\n\n\n    op = {\"+\": add, \"*\": mult}\n\n\n    for i in range(n):\n        s = input()\n        a = [s.count(\".\"), s.replace(\".\", \"\")]\n        if a[1] not in op:\n            a[1] = int(a[1])\n        field.append(a)\n\n    values = []\n    while field:\n        target = field.pop()\n        if target[1] not in op:\n            values.append(target)\n        else:\n            operands = []\n            for v in values[::-1]:\n                if v[0] != target[0] + 1:\n                    break\n                operands.append(v[1])\n                values.remove(v)\n            target[1] = op[target[1]](operands)\n            values.append(target)\n    print(values[0][1])\n    return True\n\n\nwhile resolve(): pass"
  },
  {
    "language": "Python",
    "code": "def dfs(l):\n    x = len(l[0])\n    if l[0][-1] == \"+\":\n        b = 0\n        i = 1\n        while i < len(l):\n            if len(l[i]) == x + 1 and \"0\" <= l[i][-1] <= \"9\":\n                b += int(l[i][-1])\n                i += 1\n            elif len(l[i]) == x + 1 and (l[i][-1] == \"+\" or l[i][-1] == \"*\"):\n                f = i\n                i += 1\n                while i < len(l):\n                    if len(l[i]) == x + 1:\n                        break\n                    i += 1\n                b += dfs(l[f:i])\n\n    elif l[0][-1] == \"*\":\n        b = 1\n        i = 1\n        while i < len(l):\n            if len(l[i]) == x + 1 and \"0\" <= l[i][-1] <= \"9\":\n                b *= int(l[i][-1])\n                i += 1\n            elif len(l[i]) == x + 1 and (l[i][-1] == \"+\" or l[i][-1] == \"*\"):\n                f = i\n                i += 1\n                while i < len(l):\n                    if len(l[i]) == x + 1:\n                        break\n                    i += 1\n                b *= dfs(l[f:i])\n    else:\n        b = int(l[0][-1])\n\n    return b\n\ndef main(n):\n    l = [input() for i in range(n)]\n    print(dfs(l))\n\nwhile 1:\n    n = int(input())\n    if n == 0:\n        break\n    main(n)\n"
  },
  {
    "language": "Python",
    "code": "ans_list = []\n\ndef calc(i0=0):\n    if S[i0][-1] == \"+\":\n        res = 0\n        for i in range(i0+1,n):\n            if len(S[i]) == len(S[i0]) + 1:\n                res += calc(i)\n            elif len(S[i]) <= len(S[i0]):\n                return res\n    elif S[i0][-1] == \"*\":\n        res = 1\n        for i in range(i0+1,n):\n            if len(S[i]) == len(S[i0]) + 1:\n                res *= calc(i)\n            elif len(S[i]) <= len(S[i0]):\n                return res\n    else:\n        res = int(S[i0][-1])\n    return res\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    S = [input() for _ in range(n)]\n\n    ans = calc()\n    ans_list.append(ans)\n\nfor ans in ans_list:\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "for n in iter(input, '0'):\n    st = ''\n    prv_lv = 0\n    ops = ['']\n    for _ in range(int(n)):\n        line = input()\n        lv = line.count('.')\n        op = line[lv:]\n        while prv_lv > lv:\n            ops.pop()\n            st += ')'\n            prv_lv -= 1\n        if op in '*+':\n            st += ops[-1]\n            st += '(' + str(int(op == '*'))\n            ops.append(op)\n        else:\n            st += ops[-1] + op\n        prv_lv = lv\n    while len(ops) > 1:\n        ops.pop()\n        st += ')'\n    print(eval(st))\n"
  },
  {
    "language": "Python",
    "code": "opr_list = [\"+\", \"*\"]\n\n\ndef solve():\n    N = int(input())\n    while(N != 0):\n        if(N == 1):\n            print(int(input()))\n        else:\n            ans = [0 for i in range(20)]\n            s = []\n            opr = [0 for i in range(20)]\n            for i in range(N):\n                s.append(list(input()))\n            layer = 0\n            for i in range(N):\n                nowlayer = s[i].count(\".\")\n                if(nowlayer < layer):\n                    while(nowlayer < layer):\n                        if(opr[layer-2] == \"+\"):\n                            ans[layer-1] += ans[layer]\n                        else:\n                            ans[layer-1] *= ans[layer]\n                        layer -= 1\n                if(s[i][-1] in opr_list):\n                    opr[nowlayer] = s[i][-1]\n                    ans[nowlayer + 1] = 0 if opr[nowlayer] == \"+\" else 1\n                    layer += 1\n                else:\n                    if(opr[nowlayer-1] == \"+\"):\n                        ans[nowlayer] += int(s[i][-1])\n                    else:\n                        ans[nowlayer] *= int(s[i][-1])\n                layer = nowlayer\n            if(layer > 1):\n                while(layer > 1):\n                    if(opr[layer-2] == \"+\"):\n                        ans[layer-1] += ans[layer]\n                    else:\n                        ans[layer-1] *= ans[layer]\n                    layer -= 1\n            print(ans[1])\n        N = int(input())\n\n\nsolve()"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nwhile True:\n    n = input()\n    lst = []\n    if n == 0:\n        break\n    if n == 1:\n        num = input()\n        print num\n        continue\n    for loop in range(n):\n        S = raw_input()\n        lst.append((len(S), S[-1]))\n    n += 1\n    \n    c_lst = [0 for i in range(1000)]\n    v_lst = [0 for i in range(1000)]\n\n    rank = 1\n    for i in range(n):\n        r = lst[i][0]\n        c = lst[i][1]\n        while r < rank:\n            if c_lst[rank - 1] == '+':\n                v_lst[rank - 1] += v_lst[rank]\n            else:\n                v_lst[rank - 1] *= v_lst[rank]\n            rank -= 1\n        if c == '+':\n            r += 1\n            c_lst[r] = '+'\n            v_lst[r] = 0\n            rank += 1\n            continue\n        elif c == '*':\n            r += 1\n            c_lst[r] = '*'\n            v_lst[r] = 1\n            rank += 1\n            continue\n        if c_lst[r] == '+':\n            v_lst[r] += int(c)\n        else:\n            v_lst[r] *= int(c)\n    print v_lst[2]\n    \n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\ndd = [(0,-1),(1,0),(0,1),(-1,0)]\nddn = [(0,-1),(1,-1),(1,0),(1,1),(0,1),(-1,-1),(-1,0),(-1,1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n    ii = [2**i for i in range(6)]\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n        a = [S() for _ in range(n)]\n        d = 0\n        s = [[]]\n        for c in a:\n            l = len(c)\n            while l <= d:\n                if s[-1][0] == '+':\n                    k = 0\n                    for kc in s[-1][1:]:\n                        k += kc\n                else:\n                    k = 1\n                    for kc in s[-1][1:]:\n                        k *= kc\n                s = s[:-1]\n                s[-1].append(k)\n                d -= 1\n\n            t = c[-1]\n            if t == '+' or t == '*':\n                d += 1\n                s.append([t])\n            else:\n                s[-1].append(int(t))\n\n        while len(s) > 1:\n            if s[-1][0] == '+':\n                k = 0\n                for kc in s[-1][1:]:\n                    k += kc\n            else:\n                k = 1\n                for kc in s[-1][1:]:\n                    k *= kc\n            s = s[:-1]\n            s[-1].append(k)\n\n        rr.append(s[0][0])\n\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "def product(lst):\n    ret = 1\n    for i in lst:\n        ret *= i\n    return ret\n\ndef dfs(lst, index, level):\n    nums = []\n    for i in range(index, len(lst)):\n        dn = lst[i].count(\".\")\n        if level == dn:\n            s = lst[i][level]\n            if s=='+':\n                nums.append(sum(dfs(lst, i+1, level+1)))\n            elif s=='*':\n                nums.append(product(dfs(lst, i+1, level+1)))\n            else:\n                nums.append(int(s))\n        elif level > dn:\n            break\n    return nums\n\nwhile True:\n    n = int(input())\n    if not n:\n        break\n    ls = [input() for i in range(n)]\n    print(dfs(ls, 0, 0)[0])"
  },
  {
    "language": "Python",
    "code": "import re\n\nwhile True :\n    n = int(input())\n    if n == 0:break\n    s = [input() for _ in range(n)]\n    stack = []\n\n    for n in reversed(s):\n        if re.match(\"\\.*(\\+|\\*)\",n):\n            ope = n[-1]\n            depth = n.count(\".\") + 1\n            if ope == \"+\":ans = 0\n            else: ans = 1\n            for i,a in enumerate(reversed(stack)):\n                if re.match(\"\\.\"*depth+\"\\d\",a):\n                    num = int(re.sub(\"\\.*\", \"\", stack.pop()))\n                    if ope == \"+\":\n                        ans += num\n                    else:\n                        ans *= num\n            stack.append(\".\"*(depth-1)+str(ans))\n        else:\n            stack.append(n)\n    print(stack[0])\n"
  },
  {
    "language": "Python",
    "code": "def parser(i):\n    idx = i\n    dep = s[i].count('.')\n    i += 1\n    arr = []\n    while i < N and s[i].count(\".\") > dep:\n        if \"+\" in s[i] or \"*\" in s[i]:\n            num, i = parser(i)\n            arr.append(num)\n        else:\n            arr.append(int(s[i].replace('.', '')))\n        i += 1\n    if \"+\" in s[idx]:\n        return sum(arr), i - 1\n    else:\n        ret = 1\n        for num in arr:\n            ret *= num\n        return ret, i - 1\n\nwhile True:\n    N = int(input())\n    if not N:\n        break\n    if N == 1:\n        print(input())\n        continue\n    s = [input() for _ in range(N)]\n    print(parser(0)[0])"
  },
  {
    "language": "Python",
    "code": "def cal(lst,op):\n\tif op == '+':\n\t\treturn sum(lst)\n\telse:\n\t\tret = 1\n\t\tfor num in lst:\n\t\t\tret *= num\n\t\treturn ret\n\n\ndef rec ():\n\tglobal n,S,idx\n\top = S[idx][-1]\n\tnst = len(S[idx])\n\tidx += 1\n\tlst = []\n\twhile idx < n:\n\t\tif len(S[idx]) <= nst:\n\t\t\tbreak\n\t\tif not S[idx][-1].isdigit():\n\t\t\tlst.append(rec())\n\t\telse:\n\t\t\tlst.append(int(S[idx][-1]))\n\t\t\tidx += 1\n\treturn cal(lst,op)\n\nwhile True:\n\tn = int(input())\n\tif n == 0:\n\t\tbreak\n\tif n == 1:\n\t\tprint(input())\n\t\tcontinue\n\tS = []\n\tidx = 0\n\tfor i in range(n):\n\t\tS.append(input())\n\tprint(rec())\n\n"
  },
  {
    "language": "Python",
    "code": " \n\nwhile True:\n  n = int(input())\n  if n == 0:\n    break\n  w = [input() for _ in range(n)]\n  w = reversed(w)\n\n  eles = [[] for _ in range(9)]\n\n  for item in w:\n    d,c = len(item) - 1,item[-1]\n\n    if c == \"+\":\n        eles[d].append(sum(eles[d+1]))\n        eles[d+1] = []\n    elif c == \"*\":\n        tmp = 1\n        for i in eles[d+1]:\n            tmp *= i\n        eles[d].append(tmp)\n        eles[d+1] = []\n    else:\n        eles[d].append(int(c))\n\n\n    \n\n  print(eles[0][0])\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nwhile True:\n    n = input()\n    lst = []\n    if n == 0:\n        break\n    if n == 1:\n        num = input()\n        print num\n        continue\n    for loop in range(n):\n        S = raw_input()\n        lst.append((len(S), S[-1]))\n    if lst[0][1] == '+':\n        lst.append((0, '0'))\n    else:\n        lst.append((0, '1'))\n    n += 1\n    \n    c_lst = [0 for i in range(1000)]\n    v_lst = [0 for i in range(1000)]\n\n    rank = 1\n    for i in range(n):\n        r = lst[i][0]\n        c = lst[i][1]\n        while r < rank:\n            if c_lst[rank - 1] == '+':\n                v_lst[rank - 1] += v_lst[rank]\n            else:\n                v_lst[rank - 1] *= v_lst[rank]\n            rank -= 1\n        if c == '+':\n            r += 1\n            c_lst[r] = '+'\n            v_lst[r] = 0\n            rank += 1\n            continue\n        elif c == '*':\n            r += 1\n            c_lst[r] = '*'\n            v_lst[r] = 1\n            rank += 1\n            continue\n        if c_lst[r] == '+':\n            v_lst[r] += int(c)\n        else:\n            v_lst[r] *= int(c)\n    print v_lst[2]\n    \n"
  },
  {
    "language": "Python",
    "code": "import re\n\nwhile True:\n    N = int(input())\n    if N == 0:\n        break\n    formula = [input() for _ in range(N)]\n    # print(formula)\n    stack = []\n\n    for i in reversed(formula):\n        # print(stack)\n        if re.match(\"\\.*(\\*|\\+)\", i):\n            depth = i.count(\".\")\n            i = i.replace(\".\", \"\")\n            # print(i, depth)\n            if i == \"+\":\n                cal_num = 0\n            else:\n                cal_num = 1\n            for s in reversed(stack):\n                if re.match(\"\\.\" * (depth+1) + \"\\d\", s):\n                    num = int(s.replace(\".\", \"\"))\n                    # print(cal_num)\n                    if i == \"+\":\n                        cal_num += num\n                    else:\n                        cal_num *= num\n                    stack.pop()\n            stack.append(\".\" * depth + str(cal_num))\n        else:\n            stack.append(i)\n    print(stack[0])\n"
  },
  {
    "language": "Python",
    "code": "import re\ndef dotexit(s):\n  return re.sub(\"^\\.\",\"\",s)\n\ndef prod(l):\n  x=1\n  for i in l:\n    x *= i\n  return x\n\ndef rec(s):\n  nums=[dotexit(x) for x in s[1:]]\n  ad = []\n  for i in range(len(nums)):\n    if nums[i]=='+' or nums[i]=='*':\n      rl=[nums[i]]\n      for j in range(i+1,len(nums)):\n        if nums[j][0] == '.':\n          rl.append(nums[j])\n        else:\n          break\n      ad.extend(rec(rl))\n  nums.extend(ad)\n  nums = [x for x in nums if x !='+' and x != '*' and x[0]!='.']\n  if s[0]=='+':\n    return [str(sum([int(x) for x in nums]))]\n  elif s[0]=='*':\n    return [str(prod([int(x) for x in nums]))]\n  else:\n    return s\n\nwhile True:\n  n=int(input())\n  if n==0:\n    break\n  s=[]\n  for i in range(n):\n    s.append(input())\n  print(rec(s)[0])\n"
  },
  {
    "language": "Python",
    "code": "while True:\n    n = int(input())\n    if n == 0:break\n    a = [input() for _ in range(n)]\n    while True:\n        if len(a) == 1:break\n        c = 0\n        s = 0\n        for i in range(len(a)):\n            if a[i].count('.') > c:\n                c = a[i].count('.')\n                s = i\n        e = s\n        while e < len(a) and a[e].count('.') == a[s].count('.'):\n            e += 1\n        k = a[s - 1].replace('.', '')\n        b = [a[i] for i in range(s, e)]\n        for i in range(len(b)):\n            b[i] = int(b[i].replace('.', ''))\n        if k == '+':\n            a[s - 1] = '.'*a[s - 1].count('.')+str(sum(b))\n            del a[s:e]\n        else:\n            m = 1\n            for i in b:\n                m *= i\n            a[s - 1] = '.'*a[s - 1].count('.')+str(m)\n            del a[s:e]\n    print(a[0])\n    \n"
  },
  {
    "language": "Rust",
    "code": "pub struct Scanner<R> {\n    reader: R,\n}\n\nimpl<R> Scanner<R> {\n    pub fn new(reader: R) -> Scanner<R> {\n        Scanner { reader }\n    }\n}\n\nfn is_whitespace(b: u8) -> bool {\n    b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t'\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        let buf = std::io::Read::bytes(self.reader.by_ref())\n            .map(|b| b.expect(\"Read failed\"))\n            .skip_while(|&b| is_whitespace(b))\n            .take_while(|&b| !is_whitespace(b))\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error\")\n    }\n\n    pub fn read_vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n\n    pub fn read_chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n\nstruct Solve {\n    grid: Vec<Vec<char>>,\n}\n\nimpl Solve {\n    fn parse(&self, row: usize, level: usize) -> (usize, u64) {\n        let c = self.grid[row][level];\n        assert!(c != '.');\n        if c.is_digit(10) {\n            return (row + 1, (c as u8 - b'0') as u64);\n        }\n        let mut idx = row + 1;\n        let mut ans = if c == '+' { 0 } else { 1 };\n        loop {\n            if idx >= self.grid.len() || level + 1 >= self.grid[idx].len() {\n                break;\n            }\n            let (nrow, val) = self.parse(idx, level + 1);\n            ans = if c == '+' { ans + val } else { ans * val };\n            idx = nrow;\n        }\n        (idx, ans)\n    }\n}\nfn main() {\n    let stdin = std::io::stdin();\n    let mut sc = Scanner::new(stdin.lock());\n    loop {\n        let n: usize = sc.read();\n        if n == 0 {\n            break;\n        }\n        let mut grid = Vec::new();\n        for _ in 0..n {\n            grid.push(sc.read_chars());\n        }\n        let s = Solve { grid };\n        println!(\"{}\", s.parse(0, 0).1);\n    }\n}\n\n"
  }
]