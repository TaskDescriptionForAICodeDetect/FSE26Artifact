[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint parse_expression(int indent);\n\nchar *input;\nint pos = 0;\n\nint get_indent() {\n    int indent = 0;\n    while (input[pos] == ' ') {\n        indent++;\n        pos++;\n    }\n    return indent;\n}\n\nint parse_number() {\n    int num = 0;\n    while (isdigit(input[pos])) {\n        num = num * 10 + (input[pos] - '0');\n        pos++;\n    }\n    return num;\n}\n\nint parse_expression(int indent) {\n    int current_indent = get_indent();\n    if (current_indent != indent) {\n        return -1;\n    }\n\n    if (isdigit(input[pos])) {\n        return parse_number();\n    }\n\n    char op = input[pos++];\n    pos++; // skip space\n    int a = parse_expression(indent + 1);\n    int b = parse_expression(indent + 1);\n\n    if (op == '+') {\n        return a + b;\n    } else if (op == '*') {\n        return a * b;\n    } else {\n        return -1;\n    }\n}\n\nint main() {\n    char buffer[1024];\n    fgets(buffer, sizeof(buffer), stdin);\n    input = buffer;\n\n    int result = parse_expression(0);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:01:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Node {\n    int value;\n    char op;\n    vector<Node> children;\n};\n\nNode parseExpression(const vector<string>& lines, int& index, int currentIndent) {\n    Node node;\n    string line = lines[index];\n    int indent = line.find_first_not_of(' ');\n    if (indent != currentIndent) {\n        node.value = stoi(line.substr(indent));\n        return node;\n    }\n\n    string token = line.substr(indent);\n    if (token[0] == '+' || token[0] == '*') {\n        node.op = token[0];\n        index++;\n        while (index < lines.size()) {\n            int nextIndent = lines[index].find_first_not_of(' ');\n            if (nextIndent <= currentIndent) break;\n            node.children.push_back(parseExpression(lines, index, nextIndent));\n        }\n    } else {\n        node.value = stoi(token);\n    }\n    return node;\n}\n\nint evaluate(const Node& node) {\n    if (node.children.empty()) {\n        return node.value;\n    }\n    int result = evaluate(node.children[0]);\n    for (size_t i = 1; i < node.children.size(); ++i) {\n        int val = evaluate(node.children[i]);\n        if (node.op == '+') {\n            result += val;\n        } else if (node.op == '*') {\n            result *= val;\n        }\n    }\n    return result;\n}\n\nint main() {\n    vector<string> lines;\n    string line;\n    while (getline(cin, line)) {\n        if (line.empty()) break;\n        lines.push_back(line);\n    }\n\n    if (lines.empty()) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    int index = 0;\n    Node root = parseExpression(lines, index, 0);\n    cout << evaluate(root) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:02:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class DrTsukubaNotation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        Stack<Integer> values = new Stack<>();\n        Stack<Character> ops = new Stack<>();\n        int currentIndent = 0;\n        int prevIndent = 0;\n\n        while (scanner.hasNextLine()) {\n            String line = scanner.nextLine();\n            if (line.trim().isEmpty()) {\n                break;\n            }\n            currentIndent = line.indexOf(line.trim());\n            while (prevIndent > currentIndent) {\n                evaluateTop(values, ops);\n                prevIndent -= 2;\n            }\n            prevIndent = currentIndent;\n            String token = line.trim();\n            if (token.equals(\"+\") || token.equals(\"*\")) {\n                ops.push(token.charAt(0));\n            } else {\n                values.push(Integer.parseInt(token));\n            }\n        }\n        while (!ops.isEmpty()) {\n            evaluateTop(values, ops);\n        }\n        System.out.println(values.pop());\n    }\n\n    private static void evaluateTop(Stack<Integer> values, Stack<Character> ops) {\n        char op = ops.pop();\n        int b = values.pop();\n        int a = values.pop();\n        if (op == '+') {\n            values.push(a + b);\n        } else {\n            values.push(a * b);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:02:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TsukubaNotation {\n    public static int evaluate(List<String> lines) {\n        Stack<Integer> stack = new Stack<>();\n        Stack<Integer> indentStack = new Stack<>();\n        \n        for (String line : lines) {\n            int indent = line.lastIndexOf(' ') + 1;\n            String token = line.trim();\n            \n            while (!indentStack.isEmpty() && indent <= indentStack.peek()) {\n                indentStack.pop();\n                int b = stack.pop();\n                int a = stack.pop();\n                int result = performOperation(a, b, stack.pop());\n                stack.push(result);\n            }\n            \n            if (token.equals(\"+\") || token.equals(\"*\")) {\n                stack.push(operatorToInt(token));\n            } else {\n                stack.push(Integer.parseInt(token));\n            }\n            \n            indentStack.push(indent);\n        }\n        \n        while (stack.size() > 1) {\n            int b = stack.pop();\n            int a = stack.pop();\n            int op = stack.pop();\n            int result = performOperation(a, b, op);\n            stack.push(result);\n        }\n        \n        return stack.pop();\n    }\n    \n    private static int performOperation(int a, int b, int op) {\n        return op == 1 ? a + b : a * b;\n    }\n    \n    private static int operatorToInt(String op) {\n        return op.equals(\"+\") ? 1 : 2;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<String> lines = new ArrayList<>();\n        \n        while (scanner.hasNextLine()) {\n            String line = scanner.nextLine();\n            if (line.isEmpty()) break;\n            lines.add(line);\n        }\n        \n        System.out.println(evaluate(lines));\n    }\n}",
    "timestamp": "2025-08-05 21:02:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_LINE 1024\n#define MAX_TOKENS 100\n\ntypedef enum {\n    TOKEN_NUMBER,\n    TOKEN_PLUS,\n    TOKEN_MULTIPLY\n} TokenType;\n\ntypedef struct {\n    TokenType type;\n    int value;\n    int indent;\n} Token;\n\nToken tokens[MAX_TOKENS];\nint token_count = 0;\n\nvoid parse_input() {\n    char line[MAX_LINE];\n    token_count = 0;\n\n    while (fgets(line, sizeof(line), stdin)) {\n        int indent = 0;\n        char* ptr = line;\n\n        while (*ptr == ' ') {\n            indent++;\n            ptr++;\n        }\n\n        if (strlen(ptr) <= 1) continue;\n\n        Token* token = &tokens[token_count++];\n        token->indent = indent;\n\n        if (isdigit(*ptr)) {\n            token->type = TOKEN_NUMBER;\n            token->value = atoi(ptr);\n        } else if (*ptr == '+') {\n            token->type = TOKEN_PLUS;\n        } else if (*ptr == '*') {\n            token->type = TOKEN_MULTIPLY;\n        }\n    }\n}\n\nint evaluate() {\n    int stack[MAX_TOKENS];\n    int stack_top = -1;\n\n    for (int i = 0; i < token_count; i++) {\n        Token* current = &tokens[i];\n\n        if (current->type == TOKEN_NUMBER) {\n            stack[++stack_top] = current->value;\n        } else if (current->type == TOKEN_PLUS || current->type == TOKEN_MULTIPLY) {\n            int j = i + 1;\n            while (j < token_count && tokens[j].indent > current->indent) j++;\n\n            int right = stack[stack_top--];\n            int left = stack[stack_top--];\n\n            if (current->type == TOKEN_PLUS) {\n                stack[++stack_top] = left + right;\n            } else {\n                stack[++stack_top] = left * right;\n            }\n\n            i = j - 1;\n        }\n    }\n\n    return stack[stack_top];\n}\n\nint main() {\n    parse_input();\n    printf(\"%d\\n\", evaluate());\n    return 0;\n}",
    "timestamp": "2025-08-05 21:02:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <sstream>\n\nusing namespace std;\n\nint evaluateExpression(const vector<string>& lines) {\n    stack<int> nums;\n    stack<char> ops;\n    int currentIndent = 0;\n\n    for (const string& line : lines) {\n        int indent = line.find_first_not_of(' ');\n        string token = line.substr(indent);\n\n        if (indent > currentIndent) {\n            currentIndent = indent;\n        } else if (indent < currentIndent) {\n            while (!ops.empty() && indent < currentIndent) {\n                char op = ops.top();\n                ops.pop();\n                int b = nums.top();\n                nums.pop();\n                int a = nums.top();\n                nums.pop();\n\n                if (op == '+') nums.push(a + b);\n                else if (op == '*') nums.push(a * b);\n\n                currentIndent -= 2;\n            }\n        }\n\n        if (token == \"+\" || token == \"*\") {\n            ops.push(token[0]);\n        } else {\n            nums.push(stoi(token));\n        }\n    }\n\n    while (!ops.empty()) {\n        char op = ops.top();\n        ops.pop();\n        int b = nums.top();\n        nums.pop();\n        int a = nums.top();\n        nums.pop();\n\n        if (op == '+') nums.push(a + b);\n        else if (op == '*') nums.push(a * b);\n    }\n\n    return nums.top();\n}\n\nint main() {\n    vector<string> lines;\n    string line;\n\n    while (getline(cin, line) && !line.empty()) {\n        lines.push_back(line);\n    }\n\n    cout << evaluateExpression(lines) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:02:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def parse_expression(lines):\n    def evaluate(tokens):\n        total = 0\n        current_number = 0\n        current_operator = '+'\n        \n        for token in tokens:\n            if isinstance(token, int):\n                current_number = token\n            elif isinstance(token, list):\n                # Evaluate nested expression\n                current_number = evaluate(token)\n            else:\n                current_operator = token\n            \n            if token == '+' or token == '*':\n                continue\n            \n            if current_operator == '+':\n                total += current_number\n            elif current_operator == '*':\n                total *= current_number\n               \n        return total\n    \n    def parse(tokens):\n        current_list = []\n        stack = [current_list]\n        prev_indent = 0\n        \n        for line in lines:\n            indent = len(line) - len(line.lstrip())\n            content = line.strip()\n            \n            while prev_indent > indent:\n                stack.pop()\n                current_list = stack[-1]\n                prev_indent -= 1\n            \n            if prev_indent < indent:\n                new_list = []\n                current_list.append(new_list)\n                stack.append(new_list)\n                current_list = new_list\n                prev_indent = indent\n            \n            if content.isdigit():\n                current_list.append(int(content))\n            else:\n                current_list.append(content)\n        \n        return stack[0]\n\n    tokens = parse(lines)\n    return evaluate(tokens)\n\ndef main():\n    import sys\n    input_data = sys.stdin.read().strip().splitlines()\n    result = parse_expression(input_data)\n    print(result)\n\n# For testing purpose, please uncomment the following line:\n# main()",
    "timestamp": "2025-08-13 04:37:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class DrTsukubaExpressionEvaluator {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<String> lines = new ArrayList<>();\n\n        while (scanner.hasNextLine()) {\n            lines.add(scanner.nextLine());\n        }\n\n        scanner.close();\n        System.out.println(evaluateExpression(lines));\n    }\n\n    private static int evaluateExpression(List<String> lines) {\n        Stack<Integer> addStack = new Stack<>();\n        Stack<Integer> multStack = new Stack<>();\n        int currentLevel = 0;\n\n        for (String line : lines) {\n            int level = countIndentation(line);\n            int value = Integer.parseInt(line.strip());\n\n            if (level < currentLevel) {\n                applyOperations(addStack, multStack, currentLevel - level);\n            }\n\n            if (level == currentLevel) {\n                multStack.push(value);\n            } else {\n                addStack.push(value);\n            }\n\n            currentLevel = level;\n        }\n\n        applyOperations(addStack, multStack, currentLevel);\n\n        return multStack.pop();\n    }\n\n    private static int countIndentation(String line) {\n        int count = 0;\n        while (count < line.length() && line.charAt(count) == ' ') {\n            count++;\n        }\n        return count;\n    }\n\n    private static void applyOperations(Stack<Integer> addStack, Stack<Integer> multStack, int levels) {\n        for (int i = 0; i < levels; i++) {\n            if (!multStack.isEmpty()) {\n                int product = multStack.pop();\n                while (!multStack.isEmpty()) {\n                    product *= multStack.pop();\n                }\n                multStack.push(product);\n            }\n\n            if (!addStack.isEmpty()) {\n                int sum = addStack.pop();\n                while (!addStack.isEmpty()) {\n                    sum += addStack.pop();\n                }\n                multStack.push(sum);\n            }\n        }\n    }\n}",
    "timestamp": "2025-08-13 04:37:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_EXPRESSION_LENGTH 1000\n\ntypedef struct {\n    int value;\n    char operator;\n} ParsedToken;\n\nParsedToken parseToken(char *line) {\n    ParsedToken token;\n    char *ptr = line;\n    while (*ptr == '\\t') {\n        ptr++;\n    }\n    if (sscanf(ptr, \"%d\", &token.value) == 1) {\n        token.operator = 'N';  // N for number\n    } else {\n        token.value = -1;\n        token.operator = ptr[0];\n    }\n    return token;\n}\n\nint evaluate(char lines[][MAX_EXPRESSION_LENGTH], int numLines) {\n    int levelValues[MAX_EXPRESSION_LENGTH] = {0};\n    char levelOps[MAX_EXPRESSION_LENGTH] = {'+'};\n    int levels[MAX_EXPRESSION_LENGTH] = {0};\n    int currentLevel = 0;\n\n    for (int i = 0; i < numLines; i++) {\n        ParsedToken token = parseToken(lines[i]);\n        currentLevel = strlen(lines[i]) - strlen(strchr(lines[i], token.operator));\n\n        if (token.operator == 'N') {\n            if (levelOps[currentLevel] == '+') {\n                levelValues[currentLevel] += token.value;\n            } else if (levelOps[currentLevel] == '*') {\n                levelValues[currentLevel] *= token.value;\n            }\n        } else {\n            levelOps[currentLevel] = token.operator;\n        }\n\n        if (currentLevel > 0) {\n            if (levels[currentLevel] < currentLevel) {\n                if (levelOps[currentLevel - 1] == '+') {\n                    levelValues[currentLevel - 1] += levelValues[currentLevel];\n                } else if (levelOps[currentLevel - 1] == '*') {\n                    levelValues[currentLevel - 1] *= levelValues[currentLevel];\n                }\n                levelValues[currentLevel] = 0;\n                levelOps[currentLevel] = '+';\n                levels[currentLevel] = currentLevel;\n            }\n        }\n    }\n\n    return levelValues[0];\n}\n\nint main() {\n    char lines[MAX_EXPRESSION_LENGTH][MAX_EXPRESSION_LENGTH];\n    int numLines = 0;\n\n    while (fgets(lines[numLines], sizeof(lines[numLines]), stdin)) {\n        lines[numLines][strcspn(lines[numLines], \"\\n\")] = 0; // Remove newline character\n        numLines++;\n    }\n\n    int result = evaluate(lines, numLines);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:38:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def evaluate_expression(lines):\n    def parse_expression(lines, index):\n        if index >= len(lines):\n            return None, index\n        \n        line = lines[index].rstrip()\n        indent = len(line) - len(line.lstrip())\n        value = line.strip()\n        \n        if value.isdigit():\n            return int(value), index + 1\n        \n        if value in ['+', '*']:\n            left, next_index = parse_expression(lines, index + 1)\n            right, final_index = parse_expression(lines, next_index)\n            \n            if value == '+':\n                return left + right, final_index\n            else:\n                return left * right, final_index\n        \n        return None, index\n    \n    result, _ = parse_expression(lines, 0)\n    return result\n\n# Read input\nn = int(input())\nlines = [input() for _ in range(n)]\n\n# Compute and print result\nprint(evaluate_expression(lines))",
    "timestamp": "2025-08-13 04:38:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef evaluate_expression(lines, level=0):\n    if not lines:\n        return 0\n    value = None\n    op = None\n    i = 0\n    while i < len(lines):\n        line = lines[i]\n        current_level = len(line) - len(line.lstrip())\n        if current_level < level:\n            break\n        if current_level > level:\n            sub_expr = []\n            while i < len(lines) and len(lines[i]) - len(lines[i].lstrip()) > level:\n                sub_expr.append(lines[i])\n                i += 1\n            current_value = evaluate_expression(sub_expr, level + 1)\n        else:\n            stripped = line.strip()\n            if stripped == '+':\n                op = '+'\n                i += 1\n                continue\n            elif stripped == '*':\n                op = '*'\n                i += 1\n                continue\n            else:\n                current_value = int(stripped)\n                i += 1\n        \n        if value is None:\n            value = current_value\n        else:\n            if op == '+':\n                value += current_value\n            elif op == '*':\n                value *= current_value\n    return value\n\ndef main():\n    lines = []\n    for line in sys.stdin:\n        lines.append(line.rstrip('\\n'))\n    result = evaluate_expression(lines)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 04:38:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <stack>\n#include <sstream>\n#include <vector>\n#include <string>\n\nstruct Expression {\n    int value;\n    int depth;\n};\n\nint evaluateExpressions(const std::vector<Expression>& expressions) {\n    std::stack<int> values;\n    std::stack<int> depths;\n    \n    for (size_t i = 0; i < expressions.size(); ++i) {\n        int currentValue = expressions[i].value;\n        int currentDepth = expressions[i].depth;\n        \n        while (!depths.empty() && depths.top() >= currentDepth) {\n            int tempValue = values.top();\n            values.pop();\n            int tempDepth = depths.top();\n            depths.pop();\n\n            if (depths.empty() || depths.top() < tempDepth) {\n                currentValue += tempValue;\n            } else {\n                currentValue *= tempValue;\n            }\n        }\n        \n        values.push(currentValue);\n        depths.push(currentDepth);\n    }\n    \n    int result = 0;\n    while (!values.empty()) {\n        result += values.top();\n        values.pop();\n    }\n    \n    return result;\n}\n\nint main() {\n    std::string line;\n    std::vector<Expression> expressions;\n    \n    while (std::getline(std::cin, line)) {\n        std::istringstream iss(line);\n        int depth = 0;\n        \n        while (iss.peek() == ' ') {\n            iss.get();\n            ++depth;\n        }\n        \n        int value;\n        iss >> value;\n        expressions.push_back({value, depth});\n    }\n    \n    int result = evaluateExpressions(expressions);\n    std::cout << result << std::endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:20:41"
  }
]