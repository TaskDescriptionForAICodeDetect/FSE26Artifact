[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_N 200005\n\nint parent[MAX_N];\nint rank[MAX_N];\nint adj[MAX_N][MAX_N];\nint adj_size[MAX_N];\nbool blue_edge[MAX_N][MAX_N];\n\nvoid init(int n) {\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n        adj_size[i] = 0;\n    }\n}\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    \n    if (x == y) return;\n    \n    if (rank[x] < rank[y]) {\n        parent[x] = y;\n    } else {\n        parent[y] = x;\n        if (rank[x] == rank[y])\n            rank[x]++;\n    }\n}\n\nbool is_connected(int x, int y) {\n    return find(x) == find(y);\n}\n\nbool dfs(int u, int target, int parent_node, bool* visited) {\n    visited[u] = true;\n    \n    if (u == target)\n        return true;\n    \n    for (int i = 0; i < adj_size[u]; i++) {\n        int v = adj[u][i];\n        if (v == parent_node) continue;\n        \n        if (!visited[v] && blue_edge[u][v] && dfs(v, target, u, visited))\n            return true;\n    }\n    \n    return false;\n}\n\nbool find_path(int start, int end, int n) {\n    bool visited[MAX_N] = {false};\n    return dfs(start, end, -1, visited);\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    \n    init(n);\n    \n    for (int i = 1; i < n; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        adj[a][adj_size[a]++] = b;\n        adj[b][adj_size[b]++] = a;\n        blue_edge[a][b] = blue_edge[b][a] = true;\n    }\n    \n    for (int i = 0; i < m; i++) {\n        int c, d;\n        scanf(\"%d %d\", &c, &d);\n        \n        if (is_connected(c, d)) continue;\n        \n        bool visited[MAX_N] = {false};\n        if (!find_path(c, d, n)) {\n            printf(\"No\\n\");\n            return 0;\n        }\n        \n        int curr = c;\n        int prev = -1;\n        \n        while (curr != d) {\n            for (int j = 0; j < adj_size[curr]; j++) {\n                int next = adj[curr][j];\n                \n                if (next == prev) continue;\n                \n                if (blue_edge[curr][next] && find_path(next, d, n)) {\n                    blue_edge[curr][next] = blue_edge[next][curr] = false;\n                    unite(curr, next);\n                    prev = curr;\n                    curr = next;\n                    break;\n                }\n            }\n        }\n    }\n    \n    printf(\"Yes\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 23:20:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100000\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[2 * MAX_N + 5];\nint head[MAX_N + 5];\nint edge_count = 0;\n\nint parent[MAX_N + 5];\nint depth[MAX_N + 5];\nint up[MAX_N + 5][20];\nint n;\n\nvoid add_edge(int u, int v) {\n    edges[edge_count].to = v;\n    edges[edge_count].next = head[u];\n    head[u] = edge_count++;\n}\n\nvoid dfs(int u, int p) {\n    parent[u] = p;\n    depth[u] = depth[p] + 1;\n    up[u][0] = p;\n    for (int i = 1; i < 20; i++) {\n        up[u][i] = up[up[u][i - 1]][i - 1];\n    }\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        int v = edges[i].to;\n        if (v != p) {\n            dfs(v, u);\n        }\n    }\n}\n\nint lca(int u, int v) {\n    if (depth[u] < depth[v]) {\n        int temp = u;\n        u = v;\n        v = temp;\n    }\n    for (int i = 19; i >= 0; i--) {\n        if (depth[u] - (1 << i) >= depth[v]) {\n            u = up[u][i];\n        }\n    }\n    if (u == v) return u;\n    for (int i = 19; i >= 0; i--) {\n        if (up[u][i] != up[v][i]) {\n            u = up[u][i];\n            v = up[v][i];\n        }\n    }\n    return parent[u];\n}\n\nint diff[MAX_N + 5];\nint res = 1;\n\nvoid dfs2(int u, int p) {\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        int v = edges[i].to;\n        if (v != p) {\n            dfs2(v, u);\n            diff[u] += diff[v];\n        }\n    }\n    if (diff[u] > 1) {\n        res = 0;\n    }\n}\n\nint main() {\n    memset(head, -1, sizeof(head));\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        add_edge(a, b);\n        add_edge(b, a);\n    }\n    dfs(1, 0);\n    int k;\n    scanf(\"%d\", &k);\n    for (int i = 0; i < k; i++) {\n        int c, d;\n        scanf(\"%d %d\", &c, &d);\n        int ancestor = lca(c, d);\n        diff[c]++;\n        diff[d]++;\n        diff[ancestor] -= 2;\n    }\n    dfs2(1, 0);\n    printf(\"%s\\n\", res ? \"YES\" : \"NO\");\n    return 0;\n}",
    "timestamp": "2025-08-05 23:20:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> parent;\n    UnionFind(int n) : parent(n, -1) {}\n    int root(int x) {\n        if (parent[x] < 0) return x;\n        return parent[x] = root(parent[x]);\n    }\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (parent[x] > parent[y]) swap(x, y);\n        parent[x] += parent[y];\n        parent[y] = x;\n        return true;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int N;\n    cin >> N;\n    vector<pair<int, int>> edges(N-1);\n    for (int i = 0; i < N-1; ++i) {\n        cin >> edges[i].first >> edges[i].second;\n        --edges[i].first; --edges[i].second;\n    }\n    vector<pair<int, int>> queries(N-1);\n    for (int i = 0; i < N-1; ++i) {\n        cin >> queries[i].first >> queries[i].second;\n        --queries[i].first; --queries[i].second;\n    }\n\n    UnionFind uf(N);\n    for (const auto& q : queries) {\n        uf.unite(q.first, q.second);\n    }\n\n    bool ok = true;\n    for (const auto& e : edges) {\n        if (!uf.same(e.first, e.second)) {\n            ok = false;\n            break;\n        }\n    }\n\n    cout << (ok ? \"YES\" : \"NO\") << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:22:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static class UnionFind {\n        int[] parent;\n        int[] rank;\n\n        UnionFind(int size) {\n            parent = new int[size];\n            rank = new int[size];\n            for (int i = 0; i < size; i++) {\n                parent[i] = i;\n            }\n        }\n\n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n\n        boolean union(int x, int y) {\n            int xRoot = find(x);\n            int yRoot = find(y);\n            if (xRoot == yRoot) {\n                return false;\n            }\n            if (rank[xRoot] < rank[yRoot]) {\n                parent[xRoot] = yRoot;\n            } else if (rank[yRoot] < rank[xRoot]) {\n                parent[yRoot] = xRoot;\n            } else {\n                parent[yRoot] = xRoot;\n                rank[xRoot]++;\n            }\n            return true;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int[][] edges = new int[N-1][2];\n        for (int i = 0; i < N-1; i++) {\n            edges[i][0] = sc.nextInt() - 1;\n            edges[i][1] = sc.nextInt() - 1;\n        }\n        int[][] queries = new int[N-1][2];\n        for (int i = 0; i < N-1; i++) {\n            queries[i][0] = sc.nextInt() - 1;\n            queries[i][1] = sc.nextInt() - 1;\n        }\n\n        UnionFind uf = new UnionFind(N);\n        for (int[] query : queries) {\n            uf.union(query[0], query[1]);\n        }\n\n        boolean possible = true;\n        UnionFind check = new UnionFind(N);\n        for (int[] edge : edges) {\n            if (!check.union(uf.find(edge[0]), uf.find(edge[1]))) {\n                possible = false;\n                break;\n            }\n        }\n\n        System.out.println(possible ? \"YES\" : \"NO\");\n    }\n}",
    "timestamp": "2025-08-05 23:22:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static int[] parent;\n    static int[] rank;\n\n    static int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    static void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX == rootY) return;\n        \n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n\n    public static boolean solve(int N, int[][] edges, int[][] targets) {\n        parent = new int[N + 1];\n        rank = new int[N + 1];\n        \n        for (int i = 1; i <= N; i++) {\n            parent[i] = i;\n        }\n        \n        // Initial blue tree\n        for (int[] edge : edges) {\n            union(edge[0], edge[1]);\n        }\n        \n        // Reset parent and rank for final red tree\n        for (int i = 1; i <= N; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n        \n        // Check if final configuration is possible\n        for (int[] target : targets) {\n            union(target[0], target[1]);\n        }\n        \n        // Check if target configuration can be reached\n        Set<Integer> roots = new HashSet<>();\n        for (int i = 1; i <= N; i++) {\n            roots.add(find(i));\n        }\n        \n        return roots.size() == 1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        int[][] edges = new int[N-1][2];\n        for (int i = 0; i < N-1; i++) {\n            edges[i][0] = scanner.nextInt();\n            edges[i][1] = scanner.nextInt();\n        }\n        \n        int[][] targets = new int[N-1][2];\n        for (int i = 0; i < N-1; i++) {\n            targets[i][0] = scanner.nextInt();\n            targets[i][1] = scanner.nextInt();\n        }\n        \n        boolean result = solve(N, edges, targets);\n        System.out.println(result ? \"Yes\" : \"No\");\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 23:22:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> parent, rank;\n    \n    UnionFind(int n) {\n        parent.resize(n+1);\n        rank.resize(n+1, 0);\n        for (int i = 1; i <= n; i++) {\n            parent[i] = i;\n        }\n    }\n    \n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    \n    bool unite(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px == py) return false;\n        \n        if (rank[px] < rank[py]) {\n            parent[px] = py;\n        } else {\n            parent[py] = px;\n            if (rank[px] == rank[py]) {\n                rank[px]++;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<pair<int,int>> blue_edges(N-1);\n    for (int i = 0; i < N-1; i++) {\n        cin >> blue_edges[i].first >> blue_edges[i].second;\n    }\n    \n    vector<pair<int,int>> red_edges(M);\n    for (int i = 0; i < M; i++) {\n        cin >> red_edges[i].first >> red_edges[i].second;\n    }\n    \n    UnionFind uf(N);\n    \n    for (auto& red_edge : red_edges) {\n        int u = red_edge.first, v = red_edge.second;\n        if (!uf.unite(u, v)) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    \n    vector<bool> used(N-1, false);\n    \n    for (auto& red_edge : red_edges) {\n        int u = red_edge.first, v = red_edge.second;\n        \n        bool found = false;\n        for (int i = 0; i < N-1; i++) {\n            if (used[i]) continue;\n            \n            int x = blue_edges[i].first, y = blue_edges[i].second;\n            UnionFind tmp_uf = uf;\n            \n            if (tmp_uf.find(x) != tmp_uf.find(y)) {\n                if ((tmp_uf.find(x) == tmp_uf.find(u) && tmp_uf.find(y) == tmp_uf.find(v)) ||\n                    (tmp_uf.find(x) == tmp_uf.find(v) && tmp_uf.find(y) == tmp_uf.find(u))) {\n                    uf = tmp_uf;\n                    used[i] = true;\n                    found = true;\n                    break;\n                }\n            }\n        }\n        \n        if (!found) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    \n    cout << \"Yes\" << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:22:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef can_form_red_tree(n, edges, target_edges):\n    def bfs_length(u, v):\n        queue = deque([(u, 0)])\n        visited = set([u])\n        while queue:\n            node, dist = queue.popleft()\n            if node == v:\n                return dist\n            for neighbor in tree[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, dist + 1))\n        return float('inf')\n\n    tree = defaultdict(list)\n    \n    for a, b in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n    \n    for c, d in target_edges:\n        tree[c].append(d)\n        tree[d].append(c)\n\n    for c, d in target_edges:\n        if bfs_length(c, d) != 1:\n            return \"No\"\n    \n    return \"Yes\"\n\ndef main():\n    n = int(input().strip())\n    edges = [tuple(map(int, input().strip().split())) for _ in range(n - 1)]\n    target_edges = [tuple(map(int, input().strip().split())) for _ in range(n - 1)]\n    \n    result = can_form_red_tree(n, edges, target_edges)\n    print(result)\n\nmain()",
    "timestamp": "2025-08-13 14:54:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class RedTreeTransformation {\n\n    class Edge {\n        int src, dest;\n        Edge(int src, int dest) {\n            this.src = src;\n            this.dest = dest;\n        }\n    }\n\n    public boolean canTransformToRedTree(int N, List<Edge> edges, List<Edge> redEdges) {\n        // Create adjacency list for the original tree\n        List<List<Integer>> adjList = new ArrayList<>();\n        for (int i = 0; i <= N; i++) adjList.add(new ArrayList<>());\n        for (Edge e : edges) {\n            adjList.get(e.src).add(e.dest);\n            adjList.get(e.dest).add(e.src);\n        }\n        \n        // Union-Find to determine if each pair in redEdges can be connected\n        UnionFind uf = new UnionFind(N);\n        for (Edge edge : edges) {\n            uf.union(edge.src, edge.dest);\n        }\n\n        for (Edge red : redEdges) {\n            if (!uf.connected(red.src, red.dest)) return false;\n        }\n        return true;\n    }\n\n    class UnionFind {\n        int[] parent, rank;\n        \n        UnionFind(int size) {\n            parent = new int[size + 1];\n            rank = new int[size + 1];\n            for (int i = 0; i <= size; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        int find(int p) {\n            if (parent[p] != p) {\n                parent[p] = find(parent[p]);\n            }\n            return parent[p];\n        }\n        \n        void union(int p, int q) {\n            int rootP = find(p);\n            int rootQ = find(q);\n            if (rootP != rootQ) {\n                if (rank[rootP] > rank[rootQ]) {\n                    parent[rootQ] = rootP;\n                } else if (rank[rootP] < rank[rootQ]) {\n                    parent[rootP] = rootQ;\n                } else {\n                    parent[rootQ] = rootP;\n                    rank[rootP]++;\n                }\n            }\n        }\n\n        boolean connected(int p, int q) {\n            return find(p) == find(q);\n        }\n    }\n\n    public static void main(String[] args) {\n        RedTreeTransformation solution = new RedTreeTransformation();\n\n        int N = 5;\n        List<Edge> edges = Arrays.asList(\n            solution.new Edge(1, 2),\n            solution.new Edge(1, 3),\n            solution.new Edge(2, 4),\n            solution.new Edge(3, 5)\n        );\n\n        List<Edge> redEdges = Arrays.asList(\n            solution.new Edge(4, 5),\n            solution.new Edge(2, 5)\n        );\n\n        System.out.println(solution.canTransformToRedTree(N, edges, redEdges) ? \"Yes\" : \"No\");\n    }\n}",
    "timestamp": "2025-08-13 14:54:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_N 100000\n#define MAX_EDGES (MAX_N - 1)\n\ntypedef struct {\n    int u, v;\n} Edge;\n\nint parent[MAX_N + 1], rank[MAX_N + 1];\n\nvoid init_dsu(int N) {\n    for (int i = 1; i <= N; ++i) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid union_sets(int x, int y) {\n    int rootX = find(x);\n    int rootY = find(y);\n    if (rootX != rootY) {\n        if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n}\n\nbool solve(int N, Edge blueEdges[], Edge redEdges[]) {\n    init_dsu(N);\n    for (int i = 0; i < N - 1; ++i) {\n        union_sets(blueEdges[i].u, blueEdges[i].v);\n    }\n    for (int i = 0; i < N - 1; ++i) {\n        int u = redEdges[i].u;\n        int v = redEdges[i].v;\n        if (find(u) != find(v)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Edge blueEdges[MAX_EDGES], redEdges[MAX_EDGES];\n    for (int i = 0; i < N - 1; ++i) {\n        scanf(\"%d %d\", &blueEdges[i].u, &blueEdges[i].v);\n    }\n    for (int i = 0; i < N - 1; ++i) {\n        scanf(\"%d %d\", &redEdges[i].u, &redEdges[i].v);\n    }\n    if (solve(N, blueEdges, redEdges)) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 14:54:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// Function to perform DFS and check if paths exist\nbool dfs(int node, int target, vector<vector<int>>& adj, vector<bool>& visited) {\n    if (node == target) return true;\n    visited[node] = true;\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            if (dfs(neighbor, target, adj, visited)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n// Main function to determine if the tree can be transformed\nbool canTransformTree(int N, vector<pair<int, int>>& edges, vector<pair<int, int>>& paths) {\n    vector<vector<int>> adj(N + 1);\n    for (auto& edge : edges) {\n        adj[edge.first].push_back(edge.second);\n        adj[edge.second].push_back(edge.first);\n    }\n    \n    for (auto& path : paths) {\n        vector<bool> visited(N + 1, false);\n        if (!dfs(path.first, path.second, adj, visited)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<pair<int, int>> edges(N - 1);\n    for (int i = 0; i < N - 1; ++i) {\n        cin >> edges[i].first >> edges[i].second;\n    }\n\n    int M;\n    cin >> M;\n    vector<pair<int, int>> paths(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> paths[i].first >> paths[i].second;\n    }\n\n    if (canTransformTree(N, edges, paths)) {\n        cout << \"Yes\\n\";\n    } else {\n        cout << \"No\\n\";\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:54:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, blue_edges, target_red_edges):\n    # Create adjacency list representation of the graph\n    graph = [[] for _ in range(N+1)]\n    for a, b in blue_edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Find path between two vertices using DFS\n    def find_path(start, end, visited):\n        if start == end:\n            return [start]\n        \n        visited.add(start)\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                path = find_path(neighbor, end, visited)\n                if path:\n                    return [start] + path\n        \n        return []\n    \n    # Check if transformation is possible\n    for c, d in target_red_edges:\n        path = find_path(c, d, set())\n        if not path:\n            return False\n    \n    return True\n\n# Example usage\nN = 5\nblue_edges = [(1,2), (2,3), (3,4), (4,5)]\ntarget_red_edges = [(1,5), (2,4)]\nprint(solve(N, blue_edges, target_red_edges))",
    "timestamp": "2025-08-13 14:54:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\nclass UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size + 1))\n    \n    def find(self, x):\n        while self.parent[x] != x:\n            self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]\n        return x\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root != y_root:\n            self.parent[y_root] = x_root\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    edges = []\n    for _ in range(N - 1):\n        a = int(input[ptr])\n        b = int(input[ptr + 1])\n        edges.append((a, b))\n        ptr += 2\n    cd = []\n    for _ in range(N - 1):\n        c = int(input[ptr])\n        d = int(input[ptr + 1])\n        cd.append((c, d))\n        ptr += 2\n    \n    uf = UnionFind(N)\n    for c, d in cd:\n        uf.union(c, d)\n    \n    for a, b in edges:\n        if uf.find(a) != uf.find(b):\n            print(\"NO\")\n            return\n    print(\"YES\")\n\nsolve()",
    "timestamp": "2025-08-13 14:59:14"
  }
]