[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <memory>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nstruct N;\n\ntypedef shared_ptr<N> PN;\n\nstruct N{\n\tPN a, b;\n};\n\nPN make_tree(const string& s){\n\tint t = 0;\n\tfor(int i = s.size() - 2; i >= 1; --i){\n\t\tif(t == 0 && s[i] == ','){\n\t\t\tPN p(new N);\n\t\t\tp->a = make_tree(string(s.begin() + 1, s.begin() + i));\n\t\t\tp->b = make_tree(string(s.begin() + i + 1, s.end() - 1));\n\t\t\treturn p;\n\t\t}\n\t\telse if(s[i] == ')'){\n\t\t\t++t;\n\t\t}\n\t\telse if(s[i] == '('){\n\t\t\t--t;\n\t\t}\n\t}\n\treturn nullptr;\n}\n\nstring stringify(PN p){\n\treturn p ? string(\"(\") + stringify(p->a) + \",\" + stringify(p->b) + \")\" : string();\n}\n\nPN intersect(PN& p, PN& q){\n\tif(!p || !q){\n\t\treturn nullptr;\n\t}\n\tPN r(new N);\n\tr->a = intersect(p->a, q->a);\n\tr->b = intersect(p->b, q->b);\n\treturn r;\n}\n\nPN unite(PN& p, PN& q){\n\tif(!p && !q){\n\t\treturn nullptr;\n\t}\n\telse if(!p){\n\t\treturn PN(new N(*q));\n\t}\n\telse if(!q){\n\t\treturn PN(new N(*p));\n\t}\n\tPN r(new N);\n\tr->a = unite(p->a, q->a);\n\tr->b = unite(p->b, q->b);\n\treturn r;\n}\n\nint main(){\n\tstring a, s, t;\n\twhile(cin >> a >> s >> t){\n\t\tPN p = make_tree(s);\n\t\tPN q = make_tree(t);\n\t\tif(a == \"i\"){\n\t\t\tcout << stringify(intersect(p, q)) << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << stringify(unite(p, q)) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <tuple>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <array>\n#include <functional>\n#include <list>\n#include <iomanip>\n#include <set>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\nconst int MOD=1000000007;\nconst int INF=1000000000;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-9;\nconst int inf=1e9;\ntypedef pair<int,int> P;\nchar op;\nstring s1,s2;\nstruct Tree\n{\n  vector<Tree> left,right;\n};\nTree null;\n\nclass Parser{\npublic:\n\n  Tree parsetree(State &begin)\n  {\n    Tree ret;\n    if(*begin=='(') begin++;\n    if(*begin!=',')\n      {\n\t//begin++;\n\tret.left.push_back(parsetree(begin));\n      }\n    if(*begin==',')begin++;\n    if(*begin!=')')\n      {\n\t//begin++;\n\tret.right.push_back(parsetree(begin));\n      }\n    if(*begin==')') begin++;\n    return ret;\n  }\n  string dfs_i(Tree t1,Tree t2)\n  {\n    string ret=\",\";\n    if(t1.left.size()!=0 && t2.left.size()!=0)\n      {\n\tret=\"(\"+dfs_i(t1.left[0],t2.left[0])+ret;\n      }\n    else ret=\"(\" + ret;\n    if(t1.right.size()!=0 && t2.right.size()!=0)\n      {\n\tret=ret+\")\"+dfs_i(t1.right[0],t2.right[0]);\n      }\n    else ret=ret+\")\";\n    return ret;\n  }\n  string dfs_u(Tree t1,Tree t2)\n  {\n    string ret=\",\";\n    Tree tmp1,tmp2;\n    if(t1.left.size()!=0 || t2.left.size()!=0)\n      {\n\ttmp1=(t1.left.size()!=0) ? t1.left[0]:null;\n\ttmp2=(t2.left.size()!=0) ? t2.left[0]:null;\n\tret=\"(\"+dfs_u(tmp1,tmp2)+ret;\n      }\n    else ret=\"(\" + ret;\n    if(t1.right.size()!=0 || t2.right.size()!=0)\n      {\n\ttmp1=(t1.right.size()!=0) ? t1.right[0]:null;\n\ttmp2=(t2.right.size()!=0) ? t2.right[0]:null;\n\tret=ret+dfs_u(tmp1,tmp2)+\")\";\n      }\n    else ret=ret+\")\";\n    return ret;\n  }\n  /*\n  ll number(State &begin)\n  {\n    ll ret=0;\n    while(isdigit(*begin))\n      {\n\tret*=10;\n\tret+=(*begin-'0');\n\tbegin++;\n      }\n    return ret;\n  }\n\n  ll expression(State &begin)\n  {\n    ll ret=term(begin);\n    for(;;)\n      {\n\tif(*begin=='+')\n\t  {\n\t    begin++;\n\t    ret=(ret+term(begin))%p;\n\t  }\n\telse if(*begin=='-')\n\t  {\n\t    begin++;\n\t    ret=(ret+(p-term(begin)))%p;\n\t  }\n\telse\n\t  {\n\t    break;\n\t  }\n      }\n    return ret%p;\n  }\n\n  ll term(State &begin)\n  {\n    ll ret=factor(begin);\n    for(;;)\n      {\n\tif(*begin=='*')\n\t  {\n\t    begin++;\n\t    ret=(ret*factor(begin))%p;\n\t  }\n\telse if(*begin=='/')\n\t  {\n\t    begin++;\n\t    State tmp=begin;\n\t    if(factor(tmp)==0)\n\t      {\n\t\tzerodiv=true;\n\t\treturn 0;\n\t      }\n\t    ret=(ret*(ppow(factor(begin),p-2,p)))%p;\n\t  }\n\telse\n\t  {\n\t    break;\n\t  }\n      }\n    return ret;\n  }\n\n  ll factor(State &begin)\n  {\n    ll ret;\n    if(*begin=='(')\n      {\n\tbegin++;\n        ret=expression(begin);\n\tbegin++;\n\treturn ret;\n      }\n    else\n      {\n\tret=number(begin)%p;\n      }\n      return ret;\n      }*/\n};\n\n\nint main(int argc,char const* argv[])\n{\n  while(cin >> op)\n    {\n      Parser ps;\n      cin >> s1 >> s2;\n      State begin1=s1.begin();\n      State begin2=s2.begin();\n      Tree t1=ps.parsetree(begin1);\n      Tree t2=ps.parsetree(begin2);\n      string ans=\"\";\n      if(op=='i')\n\t{\n\t  ans=ps.dfs_i(t1,t2);\n\t}\n      if(op=='u')\n\t{\n\t  ans=ps.dfs_u(t1,t2);\n\t}\n      cout << ans << endl;\n    }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct Node {\n  Node *left;\n  Node *right;\n  Node() : left(NULL), right(NULL) {;}\n};\nNode _pool[1000000];\nNode *pool;\nint pos = 0;\n\nNode *Parse(char *str) {\n  Node *ret = pool++;\n  assert(str[pos] == '(');\n  pos++;\n  if (str[pos] == '(') { ret->left = Parse(str); }\n  assert(str[pos] == ',');\n  pos++;\n  if (str[pos] == '(') { ret->right = Parse(str); }\n  assert(str[pos] == ')');\n  pos++;\n  return ret;\n}\n\nvoid Output(char op, Node *l, Node *r) {\n  Node temp;\n  if (l == NULL && r == NULL) { return; }\n  if (l == NULL) { swap(l, r); }\n  if (op == 'i') {\n    if (r == NULL) { return; }\n    putchar('(');\n    Output(op, l->left, r->left);\n    putchar(',');\n    Output(op, l->right, r->right);\n    putchar(')');\n  } else {\n    if (r == NULL) { r = &temp; }\n    putchar('(');\n    Output(op, l->left, r->left);\n    putchar(',');\n    Output(op, l->right, r->right);\n    putchar(')');\n  }\n}\n\nchar str1[10000];\nchar str2[10000];\nint main() {\n  char op;\n  while (scanf(\" %c %s %s\", &op, str1, str2) > 0) {\n    MEMSET(_pool, 0);\n    pool = _pool;\n    pos = 0;\n    Node *l = Parse(str1);\n    pos = 0;\n    Node *r = Parse(str2);\n    Output(op, l, r);\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nstd::string binary_tree(std::string, std::string, char);\n\nint main(int argc, char const *argv[]){\n\n\tchar operation = 'i';\n\tstd::string tree_A = \"((,),(,))\";\n\tstd::string tree_B = \"((,(,)),)\";\n\n\tstd::string tree_intersection = binary_tree(tree_A,tree_B,'i');\n\tstd::string tree_union = binary_tree(tree_A,tree_B,'u');\n\n\tstd::cout << tree_intersection << std::endl;\n\tstd::cout << tree_union << std::endl;\n\n\treturn 0;\n}\n\nstd::string binary_tree(std::string tree_A, std::string tree_B, char operation){\n\n\tif(tree_A==tree_B){\n\n\t\treturn tree_A;\n\t\t\n\t}else if(tree_A==\"\"){\n\n\t\tif(operation=='i'){\n\t\t\treturn tree_A;\n\t\t}else if(operation=='u'){\n\t\t\treturn tree_B;\n\t\t}else{\n\t\t\t//exception\n\t\t} \n\n\t}else if(tree_B==\"\"){\n\n\t\tif(operation=='i'){\n\t\t\treturn tree_B;\n\t\t}else if(operation=='u'){\n\t\t\treturn tree_A;\n\t\t}else{\n\t\t\t//exception\n\t\t}\n\n\t}else{\n\n\t\tstd::string node_A[2] = \"\";\n\t\tstd::string node_B[2] = \"\";\n\t\tint period;\n\n\t\tperiod = 0;\n\t\tfor (int i = 1; i < tree_A.length()-1; ++i){\n\n\t\t\tint bracket_count = 0;\n\n\t\t\tif(tree_A[i]=='('){\n\t\t\t\tdo{\n\t\t\t\t\tnode_A[period] += tree_A[i];\n\t\t\t\t\tif(tree_A[i]=='('){\n\t\t\t\t\t\tbracket_count += 1;\n\t\t\t\t\t}else if(tree_A[i]==')'){\n\t\t\t\t\t\tbracket_count -= 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//exception\n\t\t\t\t\t}\n\t\t\t\t\ti += 1;\n\t\t\t\t}while(bracket_count>0);\n\t\t\t}\n\t\t\tperiod++;\n\t\t}\n\n\t\tperiod = 0;\n\t\tfor (int i = 1; i < tree_B.length()-1; ++i){\n\n\t\t\tint bracket_count = 0;\n\n\t\t\tif(tree_B[i]=='('){\n\t\t\t\tdo{\n\t\t\t\t\tnode_B[period] += tree_B[i];\n\t\t\t\t\tif(tree_B[i]=='('){\n\t\t\t\t\t\tbracket_count += 1;\n\t\t\t\t\t}else if(tree_B[i]==')'){\n\t\t\t\t\t\tbracket_count -= 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//exception\n\t\t\t\t\t}\n\t\t\t\t\ti += 1;\n\t\t\t\t}while(bracket_count>0);\n\t\t\t}\n\t\t\tperiod++;\n\t\t}\n\n\n\t\tstd::string node[2];\n\t\tnode[0] = binary_tree(node_A[0],node_B[0],operation);\n\t\tnode[1] = binary_tree(node_A[1],node_B[1],operation);\n\n\t\treturn \"(\" + node[0] + \",\" + node[1] + \")\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n//#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct Tree\n{\n  bool root;\n  bool child[2];\n  Tree *next[2];//left -> false, right -> true\n  Tree()\n  {\n    child[0] = child[1] = false;\n    root=false;\n  }\n};\n\nstring s[2];\nTree tree[2];\n\nvoid ddfs(Tree *t)\n{\n  if(!t->child[0] && !t->child[1])return;\n    \n  if(t->child[0])\n    {\n      ddfs(t->next[0]);\n      t->child[0] = false;\n      delete t->next[0];\n    }\n\n  if(t->child[1])\n    {\n      ddfs(t->next[1]);\n      t->child[1] = false;\n      delete t->next[1];\n    }\n\n}\n\nvoid init()\n{\n  tree[0].root = tree[1].root = true;\n  rep(i,2)ddfs(&tree[i]);\n}\n\nvoid parse(int index,int &pos,Tree *t,int depth)\n{\n  if(pos >= s[index].size())return;\n  //assert(s[index][pos] == '('); \n  bool LR = false;\n\n  ++pos;\n  while(pos < s[index].size() && !(LR && s[index][pos] == ')'))\n    {\n\n      if(s[index][pos] == '(')\n\t{\n\t  t->next[LR] = new Tree;\n\t  t->next[LR]->root = false;\n\t  t->next[LR]->child[0] = t->next[LR]->child[1] = false;\n\t  t->child[LR] = true;\n\t  parse(index,pos,t->next[LR],depth+1);\n\t  if(pos < s[index].size() && LR && s[index][pos] == ')')break;\n\t}\n      if(s[index][pos] == ',') LR = true;\n\t\n      ++pos;\n    }\n  ++pos;\n}\n\nvoid tree_walk(Tree *t,int depth)\n{\n  cout << '(';\n  if(t->child[0])tree_walk(t->next[0],depth+1);\n  cout << ',';\n  if(t->child[1])tree_walk(t->next[1],depth+1);\n  cout << ')';\n}\n\nvoid dfs_i(Tree *t1,Tree *t2,Tree *ans)\n{\n  if(t1->child[0] && t2->child[0])\n    {\n      ans->next[0] = new Tree;\n      ans->child[0] = true;\n      ans->next[0]->child[0] = ans->next[0]->child[1] = false;\n      dfs_i(t1->next[0],t2->next[0],ans->next[0]);\n    }\n\n  if(t1->child[1] && t2->child[1])\n    {\n      ans->next[1] = new Tree;\n      ans->child[1] = true;\n      ans->next[1]->child[0] = ans->next[1]->child[1] = false;\n      dfs_i(t1->next[1],t2->next[1],ans->next[1]);\n    }\n\n}\n\nvoid dfs_u(Tree *t,Tree *ans)\n{\n  if(t->child[0])\n    {\n      if(ans->child[0])\n\t{//already exists\n\t  dfs_u(t->next[0],ans->next[0]);\n\t}\n      else\n\t{//not yet\n\t  ans->next[0] = new Tree;\n\t  ans->child[0] = true;\n\t  ans->next[0]->child[0] = ans->next[0]->child[1] = false;\n\t  dfs_u(t->next[0],ans->next[0]);\n\t}\n    }\n\n  if(t->child[1])\n    {\n      if(ans->child[1])\n\t{//already exists\n\t  dfs_u(t->next[1],ans->next[1]);\n\t}\n      else\n\t{//not yet\n\t  ans->next[1] = new Tree;\n\t  ans->child[1] = true;\n\t  ans->next[1]->child[0] = ans->next[1]->child[1] = false;\n\t  dfs_u(t->next[1],ans->next[1]);\n\t}\n    }\n\n}\n\nvoid compute(char c)\n{\n  Tree ans;\n  ans.root = true;\n  ans.child[0] = ans.child[1] = false;\n  if(c == 'i')\n    {\n      dfs_i(&tree[0],&tree[1],&ans);\n      tree_walk(&ans,0);\n      cout << endl;\n    }\n  else if(c == 'u')\n    {\n      dfs_u(&tree[0],&ans);\n      dfs_u(&tree[1],&ans);\n      tree_walk(&ans,0);\n      cout << endl;\n    }\n\n  ddfs(&ans);\n}\n\n\n\n//deleteまわりも後で書く <- 忘れてた <- でも通らない <- なんでや <- parseが小さいケースでしかあってない <- 構文解析間違ってた\n\nint main()\n{\n  /*\n  cin >> s[0];\n  int pos;\n  parse(0,pos=0,&tree[0],0);\n  cout << s[0] << endl;\n  tree_walk(&tree[0],0);\n  cout << endl;\n  return 0;\n  */\n  char c;\n  while(cin >> c)\n    {\n      cin >> s[0] >> s[1];\n      init();\n\n      int pos;\n      rep(i,2)\n\t{\n\t  pos = 0;\n\t  parse(i,pos,&tree[i],0);\n\t  //cout << \"output tree[\" << i << \"]\" << endl;\n\t  //cout << s[i] << endl;\n\t  //tree_walk(&tree[i],0);\n\t  //cout << endl;\n\t}\n\n      compute(c);\n   \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nvoid divide(const string& s, string& s1, string& s2) {\n  int n = s.size();\n  int brackets = 0;\n  for(int i=1; ; ++i) {\n    if(s[i] == '(') ++brackets;\n    else if(s[i] == ')') --brackets;\n    else if(brackets == 0) {\n      s1 = s.substr(1, i-1);\n      s2 = s.substr(i+1, n-i-2);\n      return;\n    }\n  }\n}\n\nstring rec(const string& op, const string& s, const string& t) {\n  if(s == \"\" || t == \"\") {\n    if(op == \"i\") return \"\";\n    else return max(s, t);\n  }\n\n  string s1, s2, t1, t2;\n  divide(s, s1, s2);\n  divide(t, t1, t2);\n\n  return '(' + rec(op, s1, t1) + ',' + rec(op, s2, t2) + ')';\n}\n\nint main() {\n  string op, strL, strR;\n\n  while(cin >> op >> strL >> strR)\n    cout << rec(op, strL, strR) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <cstring>\nusing namespace std;\n\nstruct Node {\n\tNode * l;\n\tNode * r;\n\tNode () {l = r = NULL;}\n};\n\nNode * build(char s[], int l, int r) {\n\tif (r < l) return NULL;\n\tNode * p = new Node();\n\tint cnt = 0;\n\tfor (int i = l + 1; i < r; ++i) {\n\t\tif (s[i] == '(') {cnt ++; continue;}\n\t\tif (s[i] == ')') {cnt --; continue;}\n\t\tif (s[i] == ',' && cnt == 0) {\n\t\t\tp->l = build(s, l + 1, i - 1);\n\t\t\tp->r = build(s, i + 1, r - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn p;\n}\n\nNode * getInter(Node * a, Node * b) {\n\tNode * p = new Node();\n\tif (a->l != NULL && b->l != NULL) {\n\t\tp->l = getInter(a->l, b->l);\n\t}\n\telse p->l = NULL;\n\tif (a->r != NULL && b->r != NULL) {\n\t\tp->r = getInter(a->r, b->r);\n\t}\n\telse p->r = NULL;\n\treturn p;\n}\n\nNode * getUnion(Node * a, Node * b) {\n\tNode * p = new Node();\n\tif ((a != NULL && a->l != NULL) || (b != NULL && b->l != NULL)) {\n\t\t//printf(\"l\\n\");\n\t\tp->l = getUnion(a->l, b->l);\n\t}\n\telse p->l = NULL;\n\tif ((a != NULL && a->r != NULL) || (b != NULL && b->r != NULL)) {\n\t\t//printf(\"r\\n\");\n\t\tp->r = getUnion(a->r, b->r);\n\t}\n\telse p->r = NULL;\n\treturn p;\n}\n\nstring getStr(Node * p) {\n\tif (p == NULL) {\n\t\treturn \"\";\n\t}\n\telse return \"(\" + getStr(p->l) + \",\" + getStr(p->r) + \")\";\n}\n\nint main() {\n\tchar op;\n\tchar a[2000], b[2000];\n\twhile (scanf(\"%c %s %s\", &op, a, b) != EOF) {\n\t\tgetchar();\n\t\tprintf(\"%c %s %s\\n\", op, a, b);\n\t\tint la = strlen(a), lb = strlen(b);\n\t\tNode * ra = build(a, 0, la - 1);\n\t\tNode * rb = build(b, 0, lb - 1);\n\t\tNode * root = NULL;\n\t\tif (op == 'i') root = getInter(ra, rb);\n\t\telse root = getUnion(ra, rb);\n\t\tstring res = getStr(root);\n\t\tprintf(\"%s\\n\", res.c_str());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// rep\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid division(string const &raw, string &left, string &right) {\n  \n  int const N = raw.size();\n  int retain = 0;\n  REP(pos, 1, N) {\n    if(raw[pos] == '(') retain++;\n    else if(raw[pos] == ')') retain--;\n    else if(retain == 0) {\n      //assert(raw[pos] == ',');\n      left  = raw.substr(1, pos-1);\n      right = raw.substr(pos+1, N-pos-2);\n      break;\n    }\n  }\n  \n}\n\nstring solve(char op, string const &s, string const &t) {\n  if(s.empty() || t.empty()) {\n    if(op == 'i') return min(s, t);\n    else return max(s, t);\n  }\n  \n  string sL, sR, tL, tR;\n  division(s, sL, sR);\n  division(t, tL, tR);\n  \n  return '(' + solve(op, sL, tL) + ',' + solve(op, sR, tR) + ')';\n}\n\nint main() {\n  \n  char op; string s, t;\n  while(cin >> op >> s >> t) {\n    cout << solve(op, s, t) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <map>\n#include <set>\n#include <list>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <string>\n\n#define REP(i,n) for(long long i=0;i<n;++i)\n#define REPR(i,n) for(long long i=n;i>=0;--i)\n#define REPI(itr,v) for(auto itr=v.begin();itr!=v.end();++itr)\n#define REPIR(itr,v) for(auto itr=v.rbegin();itr!=v.rend();++itr)\n#define FOR(i,a,b) for(long long i=a;i<b;++i)\n#define SORT(v,n) sort(v, v+n)\n#define SORTV(v) sort(v.begin(), v.end())\n#define ALL(v) v.begin(),v.end()\n#define llong long long\n#define INF 999999999\n#define SUR 1000000007\n#define pb push_back\n#define pf push_front\n#define MP make_pair\n#define SV(v) {for(long long sitr=0;sitr<v.size();++sitr){cin>>v[sitr];}}\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {1, -1, 0, 0};\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint find_root(string s){\n  int len = s.length();\n  //cout << s << \" \" << len << endl;\n  if(len <= 1){\n    return -1;\n  }\n  if(s == \"(,)\"){\n    return -1;\n  }\n  \n  REP(i,len-2){\n    if(s[i] == ')' && s[i+1] == ',' && s[i+2] =='('){\n      int idx = i+1;\n      int l = 0, r = 0;\n      for(int j = 0; j < idx; ++j){\n        if(s[j] == '(') l++;\n        if(s[j] == ')') r++;\n      }\n      if(l != r+1){\n        continue;\n      }\n      l = 0; r = 0;\n      for(int j = idx+1; j < len; ++j){\n        if(s[j] == '(') l++;\n        if(s[j] ==')') r++;\n      }\n      if(l+1 == r){\n        return idx;\n      }\n      \n    }\n  }\n  if(s[0] == '(' && s[1] == ',' && s[2] == '('){\n    return 1;\n  }\n  if(s[len-3] == ')' && s[len-2] == ',' && s[len-1] == ')'){\n    return len-2;\n  }\n  return -1;\n}\n\nstring solve(int ope, string s1, string s2){\n  int root1 = find_root(s1), root2 = find_root(s2);\n  //cout << \"start \" << s1 << \" \" << s2 << endl;\n  string res = \",\";\n  //左\n  string sub1 = \"\", sub2 = \"\";\n  if(root1 != -1)\n    sub1 = s1.substr(1,root1-1);\n  if(root2 != -1)\n    sub2 = s2.substr(1,root2-1);\n\n  //cout << \"l \" << s1 << \":\" << sub1 << \" v \" << s2 <<\":\" << sub2 << endl;\n  //0 is insertion\n  if(ope == 0){\n    if(sub1 != \"\" && sub2 != \"\"){\n      res = solve(ope, sub1, sub2) + res;\n    }  \n  }else{\n    if(sub1 != \"\" || sub2 != \"\"){\n      res = solve(ope, sub1, sub2) + res;\n    }\n  }\n  sub1 = \"\"; sub2 = \"\";\n  if(root1 != -1)\n    sub1 = s1.substr(root1+1,s1.length()-root1-2);\n  if(root2 != -1)\n    sub2 = s2.substr(root2+1,s2.length()-root2-2);\n\n  //cout << \"r \" << s1 << \":\" << sub1 << \" v \"  << s2 << \":\" << sub2 << endl;\n  if(ope == 0){\n    if(sub1 != \"\" && sub2 != \"\"){\n      res = res + solve(ope, sub1, sub2);\n    }\n  }else{\n    if(sub1 != \"\" || sub2 != \"\"){\n      res = res + solve(ope, sub1, sub2);\n    }\n  }\n  return \"(\" + res + \")\";\n}\n\n\nint main(){\n\n  char ope;\n  while(cin >> ope){\n    string s1, s2;\n    cin >> s1 >> s2;\n\n    if(ope == 'i'){\n      cout << solve(0, s1, s2) << endl;;\n    }else{\n      cout << solve(1, s1, s2) << endl;;\n    }\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nvector <int> getTree( string in )\n{\n\tvector <int> tree( 1000, 0 );\n\n\tint n = 1;\n\tint lr = 0;\n\tstack <int> lrs;\n\n\tfor ( string::iterator it = in.begin(); it != in.end(); it++ )\n\t{\n\t\tswitch( *it )\n\t\t{\n\t\tcase '(':\n\t\t\tn *= 2;\n\t\t\ttree[n+lr] = 1;\n\t\t\tlrs.push( lr );\n\t\t\tlr = 0;\n\t\t\tbreak;\n\n\t\tcase ')':\n\t\t\tn /= 2;\n\t\t\tlr = lrs.top();\n\t\t\tlrs.pop();\n\t\t\tbreak;\n\n\t\tcase ',':\n\t\t\tlr++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn tree;\n}\n\nvoid printTree( vector <int> &tree, int node )\n{\n\tcout << \"(\";\n\tif ( tree[node*2] == 1 )\n\t{\n\t\tprintTree( tree, node*2 );\n\t}\n\tcout << \",\";\n\tif ( tree[node*2+1] == 1 )\n\t{\n\t\tprintTree( tree, node*2+1 );\n\t}\n\tcout << \")\";\n}\n\nvector <int> intersectionTree( vector <int> &a, vector <int> &b )\n{\n\tvector <int> tree( 1000, 0 );\n\tfor ( int i = 0; i < 1000; i++ )\n\t\tif ( a[i] == 1 && b[i] == 1 )\n\t\t\ttree[i] = 1;\n\treturn tree;\n}\n\nvector <int> unionTree( vector <int> &a, vector <int> &b )\n{\n\tvector <int> tree( 1000, 0 );\n\tfor ( int i = 0; i < 1000; i++ )\n\t\tif ( a[i] == 1 || b[i] == 1 )\n\t\t\ttree[i] = 1;\n\treturn tree;\n}\n\nint main( void )\n{\n\tstring type;\n\tstring in_a;\n\tstring in_b;\n\n\twhile ( cin >> type >> in_a >> in_b )\n\t{\n\t\tvector <int> a = getTree( in_a );\n\t\tvector <int> b = getTree( in_b );\n\n\t\tvector <int> c;\n\t\tif ( type == \"i\" )\n\t\t{\n\t\t\tc = intersectionTree( a, b );\n\t\t}\n\t\telse if ( type == \"u\" )\n\t\t{\n\t\t\tc = unionTree( a, b );\n\t\t}\n\t\tprintTree( c, 2 );\n\t\tcout << endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct Tree\n{\n  bool root;\n  bool child[2];\n  Tree *next[2];//left -> false, right -> true\n  Tree()\n  {\n    child[0] = child[1] = false;\n    root=false;\n  }\n};\n\nstring s[2];\nTree tree[2];\n\nvoid init()\n{\n  tree[0].root = tree[1].root = true;\n  rep(i,2)\n    {\n      tree[i].child[0] = tree[i].child[1] = false;\n      delete tree[i].next[0];\n      delete tree[i].next[1];\n    }\n}\n\nvoid parse(int index,int &pos,Tree *t,int depth)\n{\n  if(pos >= s[index].size())return;\n  assert(s[index][pos] == '('); \n  bool LR = false;\n\n  ++pos;\n  while(pos < s[index].size() && !(LR && s[index][pos] == ')'))\n    {\n\n      if(s[index][pos] == '(')\n\t{\n\t  t->next[LR] = new Tree;\n\t  t->next[LR]->root = false;\n\t  t->next[LR]->child[0] = t->next[LR]->child[1] = false;\n\t  t->child[LR] = true;\n\t  parse(index,pos,t->next[LR],depth+1);\n\t}\n      if(s[index][pos] == ',') LR = true;\n\t\n      ++pos;\n    }\n  ++pos;\n}\n\nvoid tree_walk(Tree *t,int depth)\n{\n  cout << '(';\n  if(t->child[0])tree_walk(t->next[0],depth+1);\n  cout << ',';\n  if(t->child[1])tree_walk(t->next[1],depth+1);\n  cout << ')';\n}\n\nvoid dfs_i(Tree *t1,Tree *t2,Tree *ans)\n{\n  if(t1->child[0] && t2->child[0])\n    {\n      ans->next[0] = new Tree;\n      ans->child[0] = true;\n      ans->next[0]->child[0] = ans->next[0]->child[1] = false;\n      dfs_i(t1->next[0],t2->next[0],ans->next[0]);\n    }\n\n  if(t1->child[1] && t2->child[1])\n    {\n      ans->next[1] = new Tree;\n      ans->child[1] = true;\n      ans->next[1]->child[0] = ans->next[1]->child[1] = false;\n      dfs_i(t1->next[1],t2->next[1],ans->next[1]);\n    }\n\n}\n\nvoid dfs_u(Tree *t,Tree *ans)\n{\n  if(t->child[0])\n    {\n      if(ans->child[0])\n\t{//already exists\n\t  dfs_u(t->next[0],ans->next[0]);\n\t}\n      else\n\t{//not yet\n\t  ans->next[0] = new Tree;\n\t  ans->child[0] = true;\n\t  ans->next[0]->child[0] = ans->next[0]->child[1] = false;\n\t  dfs_u(t->next[0],ans->next[0]);\n\t}\n    }\n\n  if(t->child[1])\n    {\n      if(ans->child[1])\n\t{//already exists\n\t  dfs_u(t->next[1],ans->next[1]);\n\t}\n      else\n\t{//not yet\n\t  ans->next[1] = new Tree;\n\t  ans->child[1] = true;\n\t  ans->next[1]->child[0] = ans->next[1]->child[1] = false;\n\t  dfs_u(t->next[1],ans->next[1]);\n\t}\n    }\n\n}\n\nvoid compute(char c)\n{\n  Tree ans;\n  ans.root = true;\n  ans.child[0] = ans.child[1] = false;\n  if(c == 'i')\n    {\n      dfs_i(&tree[0],&tree[1],&ans);\n      tree_walk(&ans,0);\n      cout << endl;\n    }\n  else if(c == 'u')\n    {\n      dfs_u(&tree[0],&ans);\n      dfs_u(&tree[1],&ans);\n      tree_walk(&ans,0);\n      cout << endl;\n    }\n}\n\n//deleteまわりも後で書く\n\nint main()\n{\n\n  char c;\n  while(cin >> c)\n    {\n      cin >> s[0] >> s[1];\n      init();\n\n      int pos;\n      rep(i,2)\n\t{\n\t  pos = 0;\n\t  parse(i,pos,&tree[i],0);\n\t  //cerr << \"output the tree[\" << i << \"]\" << endl;\n\t  //tree_walk(&tree[i],0);\n\t  //cout << endl;\n\t}\n\n      compute(c);\n   \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n\nint main(){\n    std::cout << \"Hello World!\" << std::endl;\n    return 0;\n}\n        \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstruct tree{\n    vector<tree> left;\n    vector<tree> right;\n};\n\n// <exp> := ( <exp> , <exp> ) | \"\"\ntree parse(int& index, const string& str){\n    tree ret;\n    if(str[index]=='(') index++;\n    if(str[index]!=',') {\n        //<exp>\n        ret.left.push_back(parse(index,str));\n    }\n    if(str[index]==',')index++;\n    if(str[index]!=')') {\n        //<exp>\n        ret.right.push_back(parse(index,str));\n    }\n    if(str[index]==')')index++;\n    return ret;\n}\n\nstring intersection_tree(tree a, tree b){\n    string res=\",\";\n\n    if(!a.left.empty() && !b.left.empty()){\n        res=\"(\"+intersection_tree(a.left[0],b.left[0]) +res;\n    }else{\n        res=\"(\"+res;\n    }\n\n    if(!a.right.empty() && !b.right.empty()){\n        res=res+intersection_tree(a.right[0],b.right[0]) +\")\";\n    }else{\n        res=res+\")\";\n    }\n    return res;\n}\n\nstring union_tree(tree a, tree b){\n    string res=\",\";\n    tree tmp1,tmp2;\n    if(!a.left.empty() || !b.left.empty()){\n        if(a.left.size()!=0){\n            tmp1=a.left[0];\n        }else{\n            tmp1.left.clear();\n            tmp1.right.clear();\n        }\n        if(b.left.size()!=0){\n            tmp2=b.left[0];\n        }else{\n            tmp2.left.clear();\n            tmp2.right.clear();\n        }\n        res=\"(\"+union_tree(tmp1,tmp2) +res;\n    }else{\n        res=\"(\"+res;\n    }\n\n    if(!a.right.empty() || !b.right.empty()){\n        if(a.right.size()!=0){\n            tmp1=a.right[0];\n        }else{\n            tmp1.left.clear();\n            tmp1.right.clear();\n        }\n        if(b.right.size()!=0){\n            tmp2=b.right[0];\n        }else{\n            tmp2.left.clear();\n            tmp2.right.clear();\n        }\n        res=res+union_tree(tmp1, tmp2) +\")\";\n    }else{\n        res=res+\")\";\n    }\n    return res;\n}\n\nint main(){\n    int index=0;\n    char mode;\n    string a,b;\n    while(cin>>mode>>a>>b){\n        tree tmp1,tmp2;\n        //cout<<a<<endl;\n        //cout<<b<<endl;\n        index=0;\n        tmp1=parse(index,a);\n        index=0;\n        tmp2=parse(index,b);\n        if(mode=='i')\n            cout<<intersection_tree(tmp1,tmp2)<<endl;\n        else\n            cout<<union_tree(tmp1,tmp2)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n\nint main(){\n    std::cout << \"Hello World!\" << std::endl;\n    return 0;\n}\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cassert>\n#include <map>\nusing namespace std;\n\nstruct Node {\n  Node *left, *right;\n};\ntypedef pair<Node*, int> value;\n\nvalue parse(const string &s, int idx = 0) {\n  assert(s[idx] == '(');\n  assert(idx < s.length()-1);\n  Node *ret = new Node();\n  int nidx;\n  if (s[idx+1] == ',') {\n    ret->left = NULL;\n    if (s[idx+2] == ')') {\n      nidx = idx+3;\n      ret->left = ret->right = NULL;\n    } else {\n      value rv = parse(s, idx+2);\n      ret->right = rv.first;\n      nidx = rv.second+1;\n    }\n  } else {\n    value lv = parse(s, idx+1);\n    ret->left = lv.first;\n    if (s[lv.second+1] == '(') {\n      value rv = parse(s, lv.second+1);\n      ret->right = rv.first;\n      nidx = rv.second+1;\n    } else if (s[lv.second+1] == ')') {\n      ret->right = NULL;\n      nidx = lv.second+2;\n    }\n  }\n  return make_pair(ret, nidx);\n}\n\nNode* intersect(Node *t1, Node *t2) {\n  if (t1 == NULL || t2 == NULL) {\n    return NULL;\n  }\n  Node *r = new Node();\n  r->left = intersect(t1->left, t2->left);\n  r->right = intersect(t1->right, t2->right);\n  return r;\n}\nNode* uni(Node *t1, Node *t2) {\n  if (t1 == NULL && t2 == NULL) return NULL;\n  Node *r = new Node();\n  if (t1 == NULL) r = t2;\n  else r = t1;\n  r->left = uni((t1==NULL)?NULL:t1->left, (t2==NULL)?NULL:t2->left);\n  r->right = uni((t1==NULL)?NULL:t1->right, (t2==NULL)?NULL:t2->right);\n  return r;\n}\n\nvoid print(Node *t) {\n  if (t == NULL) return;\n  cout<<\"(\"; print(t->left); cout<<\",\"; print(t->right); cout<<\")\";\n}\n\nint main() {\n  string op, s1, s2;\n  while(cin>>op) {\n    cin>>s1>>s2;\n    Node *t1 = parse(s1).first;\n    Node *t2 = parse(s2).first;\n    if (op == \"i\") {\n      t1 = intersect(t1, t2);\n    } else {\n      t1 = uni(t1, t2);\n    }\n    print(t1); cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int LIM = 101;\n\nvoid toMap( const string& tree, bool map[ LIM ][ LIM ] )\n{\n\tint col = 0;\n\tint depth = -1;\n\tfor( int i = 0; i < (int)tree.size(); ++i ){\n\t\tswitch( tree[ i ] ){\n\t\t\tcase '(':\n\t\t\t\t++depth;\n\t\t\t\tcol *= 2;\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\tmap[ depth ][ col ] = true;\n\t\t\t\t++col;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\t--depth;\n\t\t\t\tcol /= 2;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nstring recFigure( const bool map[ LIM ][ LIM ], string* s, int depth, int col )\n{\n\tif( map[ depth ][ col ] ){\n\t\t*s += '(';\n\t\trecFigure( map, s, depth + 1, col * 2 );\n\t\t*s += ',';\n\t\trecFigure( map, s, depth + 1, ( col + 1 ) * 2 );\n\t\t*s += ')';\n\t}\n\treturn *s;\n}\n\nstring toFigure( const bool map[ LIM ][ LIM ] )\n{\n\tstring s;\n\treturn recFigure( map, &s, 0, 0 );\n}\n\nstring merge( const bool map0[ LIM ][ LIM ], const bool map1[ LIM ][ LIM ], char pat )\n{\n\tbool mapMerged[ LIM ][ LIM ] = {0};\n\tfor( int i = 0; i < LIM - 1; ++i ){\n\t\tfor( int j = 0; j < ( i + 1 ) * 2; ++j ){\n\t\t\tmapMerged[ i ][ j ] = ( pat == 'i' ? map0[ i ][ j ] && map1[ i ][ j ] : map0[ i ][ j ] || map1[ i ][ j ] );\n\t\t}\n\t}\n\treturn toFigure( mapMerged );\n}\n\nint main()\n{\n\tchar ope;\n\tstring tree0, tree1;\n\twhile( cin >> ope >> tree0 >> tree1 ){\n\t\tbool treeMap0[ LIM ][ LIM ] = {0};\n\t\tbool treeMap1[ LIM ][ LIM ] = {0};\n\t\ttoMap( tree0, treeMap0 );\n\t\ttoMap( tree1, treeMap1 );\n\t\tcout << merge( treeMap0, treeMap1, ope ) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nstruct Node{\n\tNode *left;\n\tNode *right;\n};\n\nNode *null = new Node;\n\ntypedef struct Node Node;\n\nint sz;\nstring s;\nsize_t cur;\n\nvoid dfs(Node *n){\n\tn->left = null;\n\tn->right = null;\n\tcur++;\n\tif(s[cur] == '('){\n\t\tn->left = new Node;\n\t\tdfs(n->left);\n\t\tassert(s[cur] == ')');\n\t\tcur++;\n\t}\n\tcur++;\n\tif(s[cur] == '('){\n\t\tn->right = new Node;\n\t\tdfs(n->right);\n\t\tassert(s[cur] == ')');\n\t\tcur++;\n\t}\n}\n\nNode* make_tree(string str){\n\ts = str;\n\tsz = s.size();\n\tcur = 0;\n\tNode *res = new Node;\n\tdfs(res);\n\treturn res;\n}\n\nbool ok(Node *n1, Node *n2, char c){\n\tif(c == 'i') return (n1 != null && n2 != null);\n\telse return (n1 != null|| n2 != null);\n}\n\nvoid output(Node *n1, Node *n2, char c){\n\tcout << '(';\n\tif(ok(n1->left, n2->left, c)) output(n1->left, n2->left, c);\n\tcout << ',';\n\tif(ok(n1->right, n2->right, c)) output(n1->right, n2->right, c);\n\tcout <<')';\n}\n\nint main(){\n\tnull->left = null->right = null;\n\tchar ch;\n\tstring s1, s2;\n\twhile(cin >> ch >> s1 >> s2){\n\t\tNode *r1 = new Node, *r2 = new Node;\n\t\tr1 = make_tree(s1);\n\t\tr2 = make_tree(s2);\n\t\toutput(r1, r2, ch);\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n//#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct Tree\n{\n  bool root;\n  bool child[2];\n  Tree *next[2];//left -> false, right -> true\n  Tree()\n  {\n    child[0] = child[1] = false;\n    root=false;\n  }\n};\n\nstring s[2];\nTree tree[2];\n\nvoid ddfs(Tree *t)\n{\n  if(!t->child[0] && !t->child[1])return;\n    \n  if(t->child[0])\n    {\n      ddfs(t->next[0]);\n      t->child[0] = false;\n      delete t->next[0];\n    }\n\n  if(t->child[1])\n    {\n      ddfs(t->next[1]);\n      t->child[1] = false;\n      delete t->next[1];\n    }\n\n}\n\nvoid init()\n{\n  tree[0].root = tree[1].root = true;\n  rep(i,2)ddfs(&tree[i]);\n}\n\nvoid parse(int index,int &pos,Tree *t,int depth)\n{\n  if(pos >= s[index].size())return;\n  //assert(s[index][pos] == '('); \n  bool LR = false;\n\n  ++pos;\n  while(pos < s[index].size() && !(LR && s[index][pos] == ')'))\n    {\n\n      if(s[index][pos] == '(')\n\t{\n\t  t->next[LR] = new Tree;\n\t  t->next[LR]->root = false;\n\t  t->next[LR]->child[0] = t->next[LR]->child[1] = false;\n\t  t->child[LR] = true;\n\t  parse(index,pos,t->next[LR],depth+1);\n\t}\n      if(s[index][pos] == ',') LR = true;\n\t\n      ++pos;\n    }\n  ++pos;\n}\n\nvoid tree_walk(Tree *t,int depth)\n{\n  cout << '(';\n  if(t->child[0])tree_walk(t->next[0],depth+1);\n  cout << ',';\n  if(t->child[1])tree_walk(t->next[1],depth+1);\n  cout << ')';\n}\n\nvoid dfs_i(Tree *t1,Tree *t2,Tree *ans)\n{\n  if(t1->child[0] && t2->child[0])\n    {\n      ans->next[0] = new Tree;\n      ans->child[0] = true;\n      ans->next[0]->child[0] = ans->next[0]->child[1] = false;\n      dfs_i(t1->next[0],t2->next[0],ans->next[0]);\n    }\n\n  if(t1->child[1] && t2->child[1])\n    {\n      ans->next[1] = new Tree;\n      ans->child[1] = true;\n      ans->next[1]->child[0] = ans->next[1]->child[1] = false;\n      dfs_i(t1->next[1],t2->next[1],ans->next[1]);\n    }\n\n}\n\nvoid dfs_u(Tree *t,Tree *ans)\n{\n  if(t->child[0])\n    {\n      if(ans->child[0])\n\t{//already exists\n\t  dfs_u(t->next[0],ans->next[0]);\n\t}\n      else\n\t{//not yet\n\t  ans->next[0] = new Tree;\n\t  ans->child[0] = true;\n\t  ans->next[0]->child[0] = ans->next[0]->child[1] = false;\n\t  dfs_u(t->next[0],ans->next[0]);\n\t}\n    }\n\n  if(t->child[1])\n    {\n      if(ans->child[1])\n\t{//already exists\n\t  dfs_u(t->next[1],ans->next[1]);\n\t}\n      else\n\t{//not yet\n\t  ans->next[1] = new Tree;\n\t  ans->child[1] = true;\n\t  ans->next[1]->child[0] = ans->next[1]->child[1] = false;\n\t  dfs_u(t->next[1],ans->next[1]);\n\t}\n    }\n\n}\n\nvoid compute(char c)\n{\n  Tree ans;\n  ans.root = true;\n  ans.child[0] = ans.child[1] = false;\n  if(c == 'i')\n    {\n      dfs_i(&tree[0],&tree[1],&ans);\n      tree_walk(&ans,0);\n      cout << endl;\n    }\n  else if(c == 'u')\n    {\n      dfs_u(&tree[0],&ans);\n      dfs_u(&tree[1],&ans);\n      tree_walk(&ans,0);\n      cout << endl;\n    }\n}\n\n\n\n//deleteまわりも後で書く <- 忘れてた\n\nint main()\n{\n\n  char c;\n  while(cin >> c)\n    {\n      cin >> s[0] >> s[1];\n      init();\n\n      int pos;\n      rep(i,2)\n\t{\n\t  pos = 0;\n\t  parse(i,pos,&tree[i],0);\n\t}\n\n      compute(c);\n   \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//38\n#include<iostream>\n\nusing namespace std;\n\nchar *a,*b;\n\nvoid si(char **s,bool f){\n  if(**s!='(')return;\n  if(f){\n    cout<<**s;\n  }\n  ++*s;\n  if(**s=='('){\n    si(s,f);\n  }\n  if(f){\n    cout<<**s;\n  }\n  ++*s;\n  if(**s=='('){\n    si(s,f);\n  }\n  if(f){\n    cout<<**s;\n  }\n  ++*s;\n}\n\nvoid op(int f){\n  if(*a!='(')return;\n  cout<<*a;\n  a++;\n  b++;\n  if(!(*a==*b&&*a==',')){\n    if(*a==*b){\n      op(f);\n    }else{\n      si(&a,f);\n      si(&b,f);\n    }\n  }\n  cout<<*a;\n  a++;\n  b++;\n  if(!(*a==*b&&*a==')')){\n    if(*a==*b){\n      op(f);\n    }else{\n      si(&a,f);\n      si(&b,f);\n    }\n  }\n  cout<<*a;\n  a++;\n  b++;\n}\n \nint main(){\n  for(char o;cin>>o;){\n    char sa[301],sb[301];\n    a=sa;\n    b=sb;\n    cin>>sa>>sb;\n    op(o=='u');\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<stack>\n#include<string>\nusing namespace std;\nint l,v,map1[1005][1005],map2[1005][1005],map3[1005][1005];\nint dfs1(int f1,int f2)\n{//cout<<f1<<\" \"<<f2<<\" \"<<l<<endl;\n    if(f1==-1&&f2==-1)return -1;\n    if(v==0&&((f1==-1&&f2!=-1)||(f1!=-1&&f2==-1)))return -1;\n    int x1=-1,x2=-1,y1=-1,y2=-1;\n    if(f1!=-1)x1=map1[f1][0];\n    if(f1!=-1)y1=map1[f1][1];\n    if(f2!=-1)x2=map2[f2][0];\n    if(f2!=-1)y2=map2[f2][1];\n    int d=l++;\n    map3[d][0]=dfs1(x1,x2);\n    map3[d][1]=dfs1(y1,y2);//if(l==2)cout<<map3[l][0]<<\"  \"<<x1<<\"  \"<<x2<<endl;\n    return d;\n}\nstring dfs2(int f)\n{\n    if(f==-1)return \"\";\n    int x=map3[f][0];\n    int y=map3[f][1];\n    return \"(\"+dfs2(x)+\",\"+dfs2(y)+\")\";\n}\nint main()\n{\n    //freopen(\"a.txt\",\"r\",stdin);\n    char c,s1[1005],s2[1005];\n    int a[1005],b[1005];\n    while(scanf(\"%c%s%s\",&c,s1,s2)!=EOF)\n    {\n        int len=strlen(s1);\n        stack<char> s;\n        stack<int> g[1000];\n        for(int i=0;i<1000;i++)while(!g[i].empty())g[i].pop();\n        while(!s.empty())s.pop();\n        int d=0,x=0;\n        int f1=-1;\n        memset(map1,-1,sizeof(map1));\n        memset(a,0,sizeof(a));\n        for(int i=0;i<len;i++)\n        {\n            if(s1[i]=='(')d++;\n            else if(s1[i]==')')d--;\n            else\n            {//cout<<g[2].size()<<\" \"<<x<<endl;\n                if(d==1)f1=x;//if(x==6)cout<<d<<\" \"<<g[d-1].size()<<endl;\n                int f=0;\n                if(g[d-1].size())\n                {\n                    int y=g[d-1].top();\n                    a[y]++;\n                    b[x]++;\n                    if(a[y]==2&&b[y]==1)g[d-1].pop();\n                    map1[y][1]=x;\n                }\n                else\n                {\n                    g[d].push(x);\n                    f=1;\n                }\n                if(g[d+1].size())\n                {\n                    int y=g[d+1].top();\n                    g[d+1].pop();\n                    a[x]++;\n                    b[y]++;\n                    map1[x][0]=y;\n                }\n                if(f==0&&f1!=-1)g[d].push(x);\n                x++;\n            }\n        }//cout<<x<<\" \"<<map1[3][0]<<\" \"<<map1[3][1]<<endl;\n        for(int i=0;i<1000;i++)while(!g[i].empty())g[i].pop();\n        while(!s.empty())s.pop();\n        d=0,x=0;\n        int f2=-1;\n        for(int i=0;i<1000;i++)while(!g[i].empty())g[i].pop();\n        memset(map2,-1,sizeof(map2));\n        len=strlen(s2);\n        memset(a,0,sizeof(a));\n        memset(b,0,sizeof(b));\n        for(int i=0;i<len;i++)\n        {\n            if(s2[i]=='(')d++;\n            else if(s2[i]==')')d--;\n            else\n            {\n                if(d==1)f2=x;\n                int f=0;\n                if(g[d-1].size())\n                {\n                    int y=g[d-1].top();\n                    a[y]++;\n                    b[x]++;\n                    if(a[y]==2&&b[y]==1)g[d-1].pop();\n                    map2[y][1]=x;\n                }\n                else\n                {\n                    g[d].push(x);\n                    f=1;\n                }\n                if(g[d+1].size())\n                {\n                    int y=g[d+1].top();\n                    g[d+1].pop();\n                    a[x]++;\n                    b[y]++;\n                    map2[x][0]=y;\n                }\n                if(f==0&&f2!=-1)g[d].push(x);\n                x++;\n            }\n        }//cout<<f2<<endl;cout<<map2[3][0]<<\" \"<<map2[3][1]<<endl;\n        if(c=='i')v=0;\n        else v=1;\n        l=0;\n        dfs1(f1,f2);//cout<<l<<endl;cout<<map3[2][0]<<\" \"<<map3[2][1]<<endl;\n        cout<<dfs2(0)<<endl;\n        getchar();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\n\nint main(){\n  char m;\n  string a,b,ans;\n  int i,j,c;\n\n  while(scanf(\" %c \",&m)!=EOF){\n    cin >> a >> b;\n\n    ans.erase();\n\n    i = 0;\n    j = 0;\n    while(i<a.size() && j<b.size()){\n      if(a[i]==b[j]){\n\tans.push_back(a[i]);\n\ti++;\n\tj++;\n      }else{\n\tc = 1;\n\tif(a[i]=='('){\n\t  if(m=='u')ans.push_back(a[i]);\n\t  while(c){\n\t    i++;\n\t    if(m=='u')ans.push_back(a[i]);\n\t    if(a[i]=='(')c++;\n\t    if(a[i]==')')c--;\n\t  }\n\t  i++;\n\t}else{\n\t  if(m=='u')ans.push_back(b[j]);\n\t  while(c){\n\t    j++;\n\t    if(m=='u')ans.push_back(b[j]);\n\t    if(b[j]=='(')c++;\n\t    if(b[j]==')')c--;\n\t  }\n\t  j++;\n\t}\n      }\n    }\n\n    cout << ans << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n\nstring myUnion(string a,string b)\n{\n    string res=\"\";\n    int i = 0, j = 0;\n    int d1 = 0, d2 = 0;\n    while(i < a.size() || j < b.size())\n    {\n        if(d1 > d2 || j >= b.size())\n        {\n            if(a[i] == '(') d1++;\n            else if(a[i] == ')') d1--;\n            res+=a[i++];\n        }\n        else if(d2 > d1|| i >= a.size())\n        {\n            if(b[j] == '(') d2++;\n            else if(b[j] == ')') d2--;\n            res+=b[j++];\n        }\n        else\n        {\n            if(a[i] == b[j])\n            {\n                if(a[i] == '(')\n                {\n                    d1++;\n                    d2++;\n                }\n                else if(a[i] == ')')\n                {\n                    d1--;\n                    d2--;\n                }\n                res+=a[i++];\n                j++;\n            }\n            else if(a[i] == '(' || b[j] == ')')\n            {\n                if(a[i] == '(') d1++;\n                else if(a[i] == ')') d1--;\n                res+=a[i++];\n            }\n            else\n            {\n                if(b[j] == '(') d2++;\n                else if(b[j] == ')') d2--;\n                res+=b[j++];\n            }\n        }\n    }\n    return res;\n}\n\nstring myIntersection(string a,string b)\n{\n    string res=\"\";\n    int i = 0, j = 0;\n    int d1 = 0, d2 = 0;\n    while(i < a.size() || j < b.size())\n    {\n        if(d1 > d2 || j >= b.size())\n        {\n            if(a[i] == '(') d1++;\n            else if(a[i] == ')') d1--;\n            i++;\n        }\n        else if(d2 > d1|| i >= a.size())\n        {\n            if(b[j] == '(') d2++;\n            else if(b[j] == ')') d2--;\n            j++;\n        }\n        else\n        {\n            if(a[i] == b[j])\n            {\n                if(a[i] == '(')\n                {\n                    d1++;\n                    d2++;\n                }\n                else if(a[i] == ')')\n                {\n                    d1--;\n                    d2--;\n                }\n                res+=a[i++];\n                j++;\n            }\n            else if(a[i] == '(' || b[j] == ')')\n            {\n                if(a[i] == '(') d1++;\n                else if(a[i] == ')') d1--;\n                i++;\n            }\n            else\n            {\n                if(b[j] == '(') d2++;\n                else if(b[j] == ')') d2--;\n                j++;\n            }\n        }\n    }\n    return res;\n}\n\n\nint main()\n{\n   string op,s1,s2;\n   while(cin>>op>>s1>>s2)\n   {\n       if(op==\"i\") cout<<myIntersection(s1,s2)<<endl;\n       else cout<<myUnion(s1,s2)<<endl;\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nstring tree[2];\nbitset<1000> node[2];\n\nvoid perse(int index, int n, int i)\n{\n  //cout << \"persed \" << n << endl;\n  if (index == tree[i].size() - 1) {\n    return;\n  }\n  if (tree[i][index] == '(') {\n    node[i][n] = true;\n    perse(index + 1, 2 * n + 1, i);\n  } else if (tree[i][index] == ')') {\n    perse(index + 1, (((n - 2) / 2 < 0) ? 0 : (n - 2) / 2), i);\n  } else {\n    perse(index + 1, n + 1, i);\n  }\n}\n\nstring _perse(int index)\n{\n  if (node[0][index]) {\n    return \"(\" + _perse(2 * index + 1) + \",\" + _perse(2 * index + 2) + \")\";\n  }\n  return \"\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    for (int i = 0; i < 2; i++) {\n      node[i].reset();\n      perse(0, 0, i);\n      \n      /*for (int j = 0; j < 300; j++) {\n\tif (node[i][j]) {\n\t  cout << j;\n\t}\n      }\n      cout << endl;*/\n    }\n    if (ex == 'u') {\n      node[0] |= node[1];\n    } else {\n      node[0] &= node[1];\n    }\n  \n    cout << _perse(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct Node {\n  Node *left, *right;\n  \n  Node() : left(NULL), right(NULL) {}\n  \n  ~Node() {\n    delete left;\n    delete right;\n  }\n};\n\nconst char *p;\n\nNode *parse(){ \n  Node *ret = new Node;\n  \n  if(*++p == '(') {\n    ret->left = parse();\n  }\n  if(*++p == '(') {\n    ret->right = parse();\n  }\n  ++p;\n  \n  return ret;\n}\n\nNode *child(Node *node, string op) {\n  return node ? ( op == \"l\" ? node->left : node->right ) : NULL;\n}\n\nNode *traverse(string op, Node *node1, Node *node2) {\n  Node *ret = NULL;\n  \n  if(op == \"i\") {\n    if(node1 && node2) {\n      ret = new Node;\n    }\n  } else {\n    if(node1 || node2) {\n      ret = new Node;\n    }\n  }\n  \n  if(ret != NULL) {\n    ret->left = traverse(op, child(node1, \"l\"), child(node2, \"l\"));\n    ret->right = traverse(op, child(node1, \"r\"), child(node2, \"r\"));\n  }\n  \n  return ret;\n}\n\nstring tostr(Node *node) {\n  if(node == NULL) return \"\";\n  return '('  + tostr(node->left) + ',' + tostr(node->right) + ')';\n}\n\nint main() {\n  \n  string op, str1, str2;\n  \n  while(cin >> op >> str1 >> str2) {\n    Node *root1, *root2, *res;\n    p = str1.c_str();\n    root1 = parse();\n    p = str2.c_str();\n    root2 = parse();\n\n    res = traverse(op, root1, root2);\n    string out;\n    out = tostr(res);\n    cout << out << endl;\n    \n    delete root1;\n    delete root2;\n    delete res;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint cnt, k;\nP E[2][100];\nint dfs(string&s, int&i) {\n\tint l = -1, r = -1;\n\tint a = cnt++;\n\ti++; if (s[i] == '(')l = dfs(s, i), i++;\n\ti++; if (s[i] == '(')r = dfs(s, i), i++;\n\tE[k][a].first = l; E[k][a].second = r;\n\treturn a;\n}\nstring calc1(int u, int v) {\n\tstring l, r;\n\tif ((u != -1 && E[0][u].first != -1) || (v != -1 && E[1][v].first != -1))\n\t\tl = calc1(u == -1 ? -1 : E[0][u].first, v == -1 ? -1 : E[1][v].first);\n\tif ((u != -1 && E[0][u].second != -1) || (v != -1 && E[1][v].second != -1))\n\t\tr = calc1(u == -1 ? -1 : E[0][u].second, v == -1 ? -1 : E[1][v].second);\n\treturn \"(\" + l + \",\" + r + \")\";\n}\nstring calc2(int u, int v) {\n\tstring l, r;\n\tif (E[0][u].first != -1 && E[1][v].first != -1)l = calc2(E[0][u].first, E[1][v].first);\n\tif (E[0][u].second != -1 && E[1][v].second != -1)r = calc2(E[0][u].second, E[1][v].second);\n\treturn \"(\" + l + \",\" + r + \")\";\n}\nint main() {\n\tstring a, b, c;\n\twhile (cin >> a >> b >> c) {\n\t\tint i = cnt = k = 0; dfs(b, i);\n\t\ti = cnt = 0; k = 1; dfs(c, i);\n\t\tif (a == \"u\")cout << calc1(0, 0) << endl;\n\t\telse cout << calc2(0, 0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\nusing namespace std;\n#define int long long\nint get_center(char *str, int l){\n\tint x=0;\n\tfor(int i=0;i<l;i++){\n\t\tif(*(str+i) == ',' && x==1) return i;\n\t\telse if(*(str+i) == '(') x++;\n\t\telse if(*(str+i) == ')') x--;\n\t}\n\treturn 0;\n}\nstring make_union(char* str1, int str1l, char* str2, int str2l){\n\tint c1 = get_center(str1, str1l);\n\tint c2 = get_center(str2, str2l);\n\tstring s=\"\";\n\tif (c1 == 1){\n\t\tstring s2(str2);\n\t\ts += s2.substr(1, c2-1);\n\t}else if(c2 == 1){\n\t\tstring s1(str1);\n\t\ts += s1.substr(1, c1-1);\n\t}else{\n\t\ts += make_union(str1+1, c1-1, str2+1, c2-1);\n\t}\n\ts+=\",\";\n\tif (str1l-c1 == 2){\n\t\tstring s2(str2);\n\t\ts += s2.substr(c2+1, str2l-c2-2);\n\t}else if(str2l-c2 == 2){\n\t\tstring s1(str1);\n\t\ts += s1.substr(c1+1, str1l-c1-2);\n\t}else{\n\t\ts += make_union(str1+c1+1, str1l-c1-2, str2+c2+1, str2l-c1-2);\n\t}\n\treturn \"(\"+s+\")\";\n}\nstring make_intersection(char* str1, int str1l, char* str2, int str2l){\n\tint c1 = get_center(str1, str1l);\n\tint c2 = get_center(str2, str2l);\n\tstring s=\"\";\n\tif (c1 == 1){\n\t}else if(c2 == 1){\n\t}else{\n\t\ts += make_intersection(str1+1, c1-1, str2+1, c2-1);\n\t}\n\ts+=\",\";\n\tif (str1l-c1 == 2){\n\t}else if(str2l-c2 == 2){\n\t}else{\n\t\ts += make_intersection(str1+c1+1, str1l-c1-2, str2+c2+1, str2l-c1-2);\n\t}\n\treturn \"(\"+s+\")\";\n}\nsigned main(){\n\tchar c;\n\tchar buf1[512], buf2[512];\n\twhile( cin >> c >> buf1 >> buf2 ){\n\t\tif(c=='i')\tcout << make_intersection(buf1, strlen(buf1), buf2, strlen(buf2)) << endl;\n\t\telse if(c=='u')\tcout << make_union(buf1, strlen(buf1), buf2, strlen(buf2)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\n\nint main() {\n\tstring oper;\n\tstring tree_1,tree_2;\n\twhile (cin >> oper >> tree_1 >> tree_2) {\n\t\tvector<char> result;\n\t\tstack<char> balance;\n\t\tif (oper == \"i\") { // intersection\n\t\t\tauto itr_1 = tree_1.begin();\n\t\t\tauto itr_2 = tree_2.begin();\n\t\t\twhile (itr_1 != tree_1.end()) {\n\t\t\t\tif ((*itr_1 == ',' || *itr_1 == ')') && *itr_2 == '(') {\n\t\t\t\t\tresult.push_back(*itr_1);\n\t\t\t\t\tbalance.push('(');\n\t\t\t\t\t++itr_2;\n\t\t\t\t\twhile (!balance.empty()) {\n\t\t\t\t\t\tif (*itr_2 == '(') {\n\t\t\t\t\t\t\tbalance.push('(');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (*itr_2 == ')') {\n\t\t\t\t\t\t\tbalance.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++itr_2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (*itr_1 == '(' && (*itr_2 == ',' || *itr_2 == ')')) {\n\t\t\t\t\tresult.push_back(*itr_2);\n\t\t\t\t\tbalance.push('(');\n\t\t\t\t\t++itr_1;\n\t\t\t\t\twhile (!balance.empty()) {\n\t\t\t\t\t\tif (*itr_1 == '(') {\n\t\t\t\t\t\t\tbalance.push('(');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (*itr_1 == ')') {\n\t\t\t\t\t\t\tbalance.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++itr_1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { // *itr_1 == *itr_2\n\t\t\t\t\tresult.push_back(*itr_1);\n\t\t\t\t}\n\t\t\t\t++itr_1;\n\t\t\t\t++itr_2;\n\t\t\t}\n\t\t}\n\t\telse { // union\n\t\t\tauto itr_1 = tree_1.begin();\n\t\t\tauto itr_2 = tree_2.begin();\n\t\t\twhile (itr_1 != tree_1.end()) {\n\t\t\t\tif ((*itr_1 == ',' || *itr_1 == ')') && *itr_2 == '(') {\n\t\t\t\t\tresult.push_back('(');\n\t\t\t\t\tbalance.push('(');\n\t\t\t\t\t++itr_2;\n\t\t\t\t\twhile (!balance.empty()) {\n\t\t\t\t\t\tresult.push_back(*itr_2);\n\t\t\t\t\t\tif (*itr_2 == '(') {\n\t\t\t\t\t\t\tbalance.push('(');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (*itr_2 == ')') {\n\t\t\t\t\t\t\tbalance.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++itr_2;\n\t\t\t\t\t}\n\t\t\t\t\tresult.push_back(*itr_1);\n\t\t\t\t}\n\t\t\t\telse if (*itr_1 == '(' && (*itr_2 == ',' || *itr_2 == ')')) {\n\t\t\t\t\tresult.push_back('(');\n\t\t\t\t\tbalance.push('(');\n\t\t\t\t\t++itr_1;\n\t\t\t\t\twhile (!balance.empty()) {\n\t\t\t\t\t\tresult.push_back(*itr_1);\n\t\t\t\t\t\tif (*itr_1 == '(') {\n\t\t\t\t\t\t\tbalance.push('(');\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (*itr_1 == ')') {\n\t\t\t\t\t\t\tbalance.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t++itr_1;\n\t\t\t\t\t}\n\t\t\t\t\tresult.push_back(*itr_2);\n\t\t\t\t}\n\t\t\t\telse { // *itr_1 == *itr_2\n\t\t\t\t\tresult.push_back(*itr_1);\n\t\t\t\t}\n\t\t\t\t++itr_1;\n\t\t\t\t++itr_2;\n\t\t\t}\n\t\t}\n\t\tfor (auto itr = result.begin();itr != result.end();++itr) {\n\t\t\tcout << *itr;\n\t\t}\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Node{\n\tNode *left,*right;\n\t\n\tNode():left(0),right(0){}\n\tNode(Node* l,Node* r):left(l),right(r){}\n\t~Node(){delete left;delete right;}\n};\n\nint parse(const string& s,int index,Node* n)\n{\n\tindex++;\n\tif(s[index]=='('){\n\t\tn->left=new Node;\n\t\tindex=parse(s,index,n->left);\n\t}\n\tindex++;\n\tif(s[index]=='('){\n\t\tn->right=new Node;\n\t\tindex=parse(s,index,n->left);\n\t}\n\tindex++;\n\treturn index;\n}\n\nvoid print(Node* n)\n{\n\tif(!n)\n\t\treturn;\n\tprintf(\"(\");\n\tprint(n->left);\n\tprintf(\",\");\n\tprint(n->right);\n\tprintf(\")\");\n}\n\nNode* tree_and(Node* n1,Node* n2)\n{\n\tif(!n1 || !n2)\n\t\treturn NULL;\n\tNode* n=new Node;\n\tif(n1->left && n2->left)\n\t\tn->left=tree_and(n1->left,n2->left);\n\tif(n1->right && n2->right)\n\t\tn->right=tree_and(n1->right,n2->right);\n\treturn n;\n}\n\nNode* tree_or(Node* n1,Node* n2)\n{\n\tif(!n1 && !n2)\n\t\treturn NULL;\n\tNode* n=new Node;\n\tif(n1 && n2){\n\t\tif(n1->left || n2->left)\n\t\t\tn->left=tree_or(n1->left,n2->left);\n\t\tif(n1->right || n2->right)\n\t\t\tn->right=tree_or(n1->right,n2->right);\n\t}\n\telse if(n1){\n\t\tif(n1->left)\n\t\t\tn->left=tree_or(n1->left,NULL);\n\t\tif(n1->right)\n\t\t\tn->right=tree_or(n1->right,NULL);\n\t}\n\telse{\n\t\tif(n2->left)\n\t\t\tn->left=tree_or(NULL,n2->left);\n\t\tif(n2->right)\n\t\t\tn->right=tree_or(NULL,n2->right);\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tfor(string op,s1,s2;cin>>op>>s1>>s2;){\n\t\t//dump(op);\n\t\t//dump(s1);\n\t\t//dump(s2);\n\t\tNode n1,n2;\n\t\tparse(s1,0,&n1);\n\t\tparse(s2,0,&n2);\n\t\t\n\t\tNode* res;\n\t\tif(op==\"i\")\n\t\t\tres=tree_and(&n1,&n2);\n\t\telse\n\t\t\tres=tree_or(&n1,&n2);\n\t\tprint(res);puts(\"\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nclass Node{\npublic:\n  int count, left, right;\n  Node() : count(0), left(-1), right(-1) {}\n};\n\nNode data[100];\nint size;\nstring out;\n\nvoid input(int l, int r, string& str, int p){\n  data[p].count++;\n  if(str.size() == 3) return;\n  int cnt = 0;\n  for(int i=l;i<=r;i++){\n    if(str[i] == '(') cnt++;\n    if(str[i] == ')') cnt--;\n    if(str[i] == ',' && cnt == 1){\n      if(l+1 != i){\n        if(data[p].left == -1) data[p].left = size++;\n        input(l+1, i-1, str, data[p].left);\n      }\n      if(i+1 != r){\n        if(data[p].right == -1) data[p].right = size++;\n        input(i+1, r-1, str, data[p].right);\n      }\n    }\n  }\n}\n\nvoid output(char ope, int p){\n  if(ope == 'i' && data[p].count < 2) return;\n  out += '(';\n  if(data[p].left != -1) output(ope, data[p].left);\n  out += ',';\n  if(data[p].right != -1) output(ope, data[p].right);\n  out += ')';\n}\n\nmain(){\n  char ope;\n  string a, b;\n  while(cin >> ope >> a >> b){\n    fill(data, data+100, Node());\n    size = 1;\n    input(0, (int)a.size()-1, a, 0);\n    input(0, (int)b.size()-1, b, 0);\n    out = \"\";\n    output(ope, 0);\n    cout << out << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <string.h>\nusing namespace std;\n#define maxn 10005\nchar a[maxn],b[maxn];\nstruct Node\n{\n    int out;\n    int l,r;\n    Node()\n    {\n        out=l=r=-1;\n    }\n}x[maxn],y[maxn];\n//int Build(string cur,int id,int f)\n//{\n//    蟒コ遶狗ャャ荳?「玲?\n//    if(f==0)\n//    {\n//        if(cur==\"\")return -1;\n//        int t=1;\n//        string t1,t2;\n//        for(int i=1; i<cur.size(); i++)\n//        {\n//            if(cur[i]=='(')\n//            {\n//                t++;\n//            }\n//            else if(cur[i]==',')\n//            {\n//                if(t==1)\n//                {\n//                    x[id].l=Build(t1,id+1,f);\n//                    for(int j=i+1; j<cur.size()-1; j++)\n//                    {\n//                        t2+=cur[j];\n//                    }\n//                    x[id].r=Build(t2,id+2,f);\n//                    break;\n//                }\n//            }\n//            else if(cur[i]==')')\n//            {\n//                t--;\n//            }\n//            t1+=cur[i];\n//        }\n//    }\n//    蟒コ遶狗ャャ荳?「玲?\n//    else\n//    {\n//        if(cur==\"\")return -1;\n//        int t=1;\n//        string t1,t2;\n//        for(int i=1; i<cur.size(); i++)\n//        {\n//            if(cur[i]=='(')\n//            {\n//                t++;\n//            }\n//            else if(cur[i]==',')\n//            {\n//                if(t==1)\n//                {\n//                    y[id].l=Build(t1,id+1,f);\n//                    for(int j=i+1; j<cur.size()-1; j++)\n//                    {\n//                        t2+=cur[j];\n//                    }\n//                    y[id].r=Build(t2,id+2,f);\n//                    break;\n//                }\n//            }\n//            else if(cur[i]==')')\n//            {\n//                t--;\n//            }\n//            t1+=cur[i];\n//        }\n//    }\n//    return id;\n//}\nvoid Out(int ix,int iy,char ch)\n{\n    if(ch=='i')//荳?    {\n        if(ix==-1||iy==-1)\n        {\n            return;\n        }\n        printf(\"(\");\n        if(x[ix].l!=-1&&y[iy].l!=-1)\n        {\n            Out(x[ix].l,y[iy].l,ch);\n        }\n        printf(\",\");\n        if(x[ix].r!=-1&&y[iy].r!=-1)\n        {\n            Out(x[ix].r,y[iy].r,ch);\n        }\n        printf(\")\");\n    }\n    else\n    {\n        if(ix!=-1&&iy!=-1)//蜷梧慮驛ス譛?        {\n            printf(\"(\");\n            Out(x[ix].l,y[iy].l,ch);\n            printf(\",\");\n            Out(x[ix].r,y[iy].r,ch);\n            printf(\")\");\n        }\n        if(ix==-1&&iy!=-1)//iy譛?        {\n            printf(\"(\");\n            Out(-1,y[iy].l,ch);\n            printf(\",\");\n            Out(-1,y[iy].r,ch);\n            printf(\")\");\n        }\n        if(ix!=-1&&iy==-1)//ix譛?        {\n            printf(\"(\");\n            Out(x[ix].l,-1,ch);\n            printf(\",\");\n            Out(x[ix].r,-1,ch);\n            printf(\")\");\n        }\n    }\n}\n\nint main()\n{\n    char ch;\n    while(scanf(\"%c%s%s\",&ch,a,b)!=EOF)\n    {\n        getchar();\n        for(int i=0; i<maxn; i++)\n        {\n            x[i].out=x[i].l=x[i].r=-1;\n            y[i].out=y[i].l=y[i].r=-1;\n        }\n        string s1=a;\n        string s2=b;\n//        Build(s1,0,0);\n//        Build(s2,0,1);\n        Out(0,0,ch);\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\ntypedef set<int> SI;\nstring cmd, sl, sr;\nSI L, R;\n\nvoid init() {\n    L.clear();\n    R.clear();\n}\n\nint parse( string s, int k, int d, SI& T ) {\n    int n = s.size();\n    int lr = 1; \n    T.insert(d);\n    for ( int i = k+1; i < n; ) {\n        if ( s[i] == '(' ) {\n            i = parse( s, i, 2*d+lr, T );\n        } else if ( s[i] == ',' ) {\n            lr = 2;\n            i ++;\n        } else if ( s[i] == ')' ) {\n            return i+1;\n        }\n    }\n    return n;\n}\n\nstring rec( SI& T, int d ) {\n    string res;\n    res += '(';\n    if ( T.count(2*d+1) ) {\n        res += rec( T, 2*d+1 );\n    }\n    res += ',';\n    if ( T.count(2*d+2) ) {\n        res += rec( T, 2*d+2 );\n    }\n    res += ')';\n    return res;\n}\n\nstring toString( SI& T ) {\n    return rec( T, 0 );\n}\n\nstring solve() {\n    parse( sl, 0, 0, L );\n    parse( sr, 0, 0, R );\n    SI T;\n    if ( cmd == \"i\" ) {\n        set_intersection( L.begin(), L.end(), R.begin(), R.end(), inserter( T, T.end() ) );\n    } else if ( cmd == \"u\" ) {\n        set_union( L.begin(), L.end(), R.begin(), R.end(), inserter( T, T.end() ) );\n    }\n    return toString(T);\n}\n\nint main() {\n    while ( cin >> cmd >> sl >> sr ) {\n        init();\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n\nint main(){\n    std::cout << \"Hello World!\" << std::endl;\n    return 0;\n}\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nconst int nil = -1;\nconst int MAX_N = 256;\n\nstruct Node {\n  int l, r, cnt;\n  Node() {\n    l = r = nil;\n    cnt = 0;\n  }\n};\n\nNode v[MAX_N];\nint nodeIndex;\n\nint parse(const char *s, int n, int root) {\n  v[root].cnt++;\n  if (s[++n] != ',') {\n    if (v[root].l == nil) v[root].l = ++nodeIndex;\n    n = parse(s, n, v[root].l);\n  }\n  if (s[++n] != ')') {\n    if (v[root].r == nil) v[root].r = ++nodeIndex;\n    n = parse(s, n, v[root].r);\n  }\n  return n+1;\n}\n\nvoid print(int root, int cnt) {\n  if (v[root].cnt < cnt) return;\n  putchar('(');\n  if (v[root].l != nil) print(v[root].l, cnt);\n  putchar(',');\n  if (v[root].r != nil) print(v[root].r, cnt);\n  putchar(')');\n}\n\nint main() {\n  char op[10], t1[256], t2[256];\n  while (scanf(\"%s %s %s\\n\", op, t1, t2) == 3) {\n    for (int i=0;i<MAX_N;i++) v[i] = Node();\n    nodeIndex = 0;\n//    parse(t1, 0, 0);\n//    parse(t2, 0, 0);\n//    print(0, (op=='u'?1:2)); putchar('\\n');\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  AOJ\n//\n//  Created by user on 2014/02/01.\n//  Copyright (c) 2014年 user. All rights reserved.\n//\n\n#include <iostream>\n#include <memory>\n#include <sstream>\nusing namespace std;\n\nstruct Tree {\n    shared_ptr<Tree> L, R;\n};\n\nshared_ptr<Tree> parseTree(string str){\n    shared_ptr<Tree> res(new Tree());\n    \n    int stack = 0;\n    int ptr = -1;\n    \n    for(int i=0;i<str.size();i++){\n        if(str[i] == '('){\n            ++stack;\n        } else if(str[i] == ')'){\n            --stack;\n        } else if(str[i] == ','){\n            if(stack == 1){\n                ptr = i;\n                break;\n            }\n        }\n    }\n    \n    string Ls = str.substr(1, ptr - 1);\n    string Rs = str.substr(ptr + 1, str.size() - ptr - 2);\n    \n    if(!Ls.empty()){\n        res->L = parseTree(Ls);\n    }\n    \n    if(!Rs.empty()){\n        res->R = parseTree(Rs);\n    }\n    \n    return res;\n}\n\nshared_ptr<Tree> TreeInsect(shared_ptr<Tree> A, shared_ptr<Tree> B){\n    shared_ptr<Tree> res(new Tree());\n    \n    if(A->L && B->L){\n        res->L = TreeInsect(A->L, B->L);\n    }\n    \n    if(A->R && B->R){\n        res->R = TreeInsect(A->R, B->R);\n    }\n    \n    return res;\n}\n\nshared_ptr<Tree> TreeUnion(shared_ptr<Tree> A, shared_ptr<Tree> B){\n    shared_ptr<Tree> res(new Tree());\n    \n    {\n        // L\n        if(A->L && !(B->L)){\n            res->L = A->L;\n        }\n        if(B->L && !(A->L)){\n            res->L = B->L;\n        }\n        if(A->L && B->L){\n            res->L = TreeUnion(A->L, B->L);\n        }\n    }\n    \n    {\n        if(A->R && !(B->R)){\n            res->R = A->R;\n        }\n        if(B->R && !(A->R)){\n            res->R = B->R;\n        }\n        if(A->R && B->R){\n            res->R = TreeUnion(A->R, B->R);\n        }\n    }\n    \n    return res;\n}\n\nstring showTree(shared_ptr<Tree> T){\n    string res = \"(\";\n    if(T->L)res += showTree(T->L);\n    res += \",\";\n    if(T->R)res += showTree(T->R);\n    res += \")\";\n    \n    return res;\n}\n\nint main(int argc, const char * argv[])\n{\n    string line;\n    while(getline(cin, line)){\n        stringstream ss(line);\n        string com, As, Bs;\n        ss >> com >> As >> Bs;\n        \n        shared_ptr<Tree> A = parseTree(As);\n        shared_ptr<Tree> B = parseTree(Bs);\n        shared_ptr<Tree> C;\n        \n        if(com == \"i\"){\n            C = TreeInsect(A, B);\n        }\n        if(com == \"u\"){\n            C = TreeUnion(A, B);\n        }\n        \n        cout << showTree(C) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstring intersection(string tree1, string tree2);\nstring tunion(string tree1, string tree2);\nint camma_pos(string tree);\n\n\nint camma_pos(string tree){\n\tint i, camma_p;\n\tint braket = 0;\n\tfor(i = 0; i < tree.size(); i++){\n\t\tif(tree[i] == '('){\n\t\t\tbraket++;\n\t\t}else if(tree[i] == ')'){\n\t\t\tbraket--;\n\t\t}\n\t\tif((tree[i] == ',') && (braket == 1)){\n\t\t\tcamma_p = i;\n\t\t}\n\t} \n\treturn camma_p;\n}\n\nstring intersection(string tree1, string tree2){\n\tint i;\n\tint braket = 0;\n\tint camma_p1, camma_p2;\n\tstring tree1_l, tree1_r;\n\tstring tree2_l, tree2_r;\n\tstring left, right;\n\tif(tree1.size() == 0 || tree2.size() == 0){\n\t\treturn \"\";\n\t}\n\tcamma_p1 = camma_pos(tree1);\n\tcamma_p2 = camma_pos(tree2);\n\ttree1_l = tree1.substr(1,camma_p1-1);\n\ttree1_r = tree1.substr(camma_p1+1, tree1.size() - camma_p1 - 2);\n\ttree2_l = tree2.substr(1,camma_p2-1);\n\ttree2_r = tree2.substr(camma_p2+1, tree2.size() - camma_p2 - 2);\n\tleft = intersection(tree1_l, tree2_l);\n\tright = intersection(tree1_r, tree2_r);\n\treturn \"(\" + left + \",\" + right + \")\";\n}\n\nstring tunion(string tree1, string tree2){\n\tint i;\n\tint braket = 0;\n\tint camma_p1, camma_p2;\n\tstring tree1_l, tree1_r;\n\tstring tree2_l, tree2_r;\n\tstring left, right;\n\tif(tree1.size() == 0){\n\t\treturn tree2;\n\t}\n\tif(tree2.size() == 0){\n\t\treturn tree1;\n\t}\n\tcamma_p1 = camma_pos(tree1);\n\tcamma_p2 = camma_pos(tree2);\n\ttree1_l = tree1.substr(1,camma_p1-1);\n\ttree1_r = tree1.substr(camma_p1+1, tree1.size() - camma_p1 - 2);\n\ttree2_l = tree2.substr(1,camma_p2-1);\n\ttree2_r = tree2.substr(camma_p2+1, tree2.size() - camma_p2 - 2);\n\tleft = tunion(tree1_l, tree2_l);\n\tright = tunion(tree1_r, tree2_r);\n\treturn \"(\" + left + \",\" + right + \")\";\n}\n\nint main(){\n\tchar ui;\n\tstring tree1, tree2, treeans;\n\tcin >> ui >> tree1 >> tree2;\n\n\tif(ui == 'i'){\n\t\ttreeans = intersection(tree1, tree2);\n\t}else{\n \t\ttreeans = tunion(tree1, tree2);\n\t}\n\tcout << treeans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint depth[2][101];\n\nstring pad(int height) {\n    int len = (height <= 0 ? 0 : 3 * ((1 << height) - 1));\n    string ret = \"\";\n    for (int i=0; i<len; ++i) {\n        ret += \" \";\n    }\n    return ret;\n}\n\nvoid pad(vector<string> &t, int height) {\n    vector<string> ts(t.size(), \"\"); // tree with spaces;\n    for (int i=0; i<(int)t.size(); ++i) {\n        for (int j=0; j<(int)t[i].size(); ++j) {\n            if (t[i][j] == ',') {\n                if (t[i][j - 1] == '(') ts[i] += pad(height - depth[i][j]);\n                ts[i] += ',';\n                if (t[i][j + 1] == ')') ts[i] += pad(height - depth[i][j]);\n            } else {\n                ts[i] += t[i][j];\n            }\n        }\n        t[i] = ts[i];\n    }\n}\n\nstring intersection(vector<string> &t, int height) {\n    pad(t, height);\n    string ret = \"\";\n    for (int i=0; i<(int)t[0].size(); ++i) {\n        if (t[0][i] != ' ' && t[1][i] != ' ') ret += t[0][i];\n    }\n    return ret;\n}\n\nstring unite(vector<string> &t, int height) {\n    pad(t, height);\n    string ret = \"\";\n    for (int i=0; i<(int)t[0].size(); ++i) {\n        if (t[0][i] != ' ') {\n            ret += t[0][i];\n        } else if (t[1][i] != ' ') {\n            ret += t[1][i];\n        }\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    char op;\n    vector<string> t(2);\n    while (cin >> op) {\n        cin >> t[0] >> t[1];\n\n        vector<int> height(2, 0);\n        for (int i=0; i<2; ++i) {\n            int c = 0;\n            for (int j=0; j<(int)t[i].size(); ++j) {\n                if (t[i][j] == '(') c ++;\n                depth[i][j] = c;\n                if (t[i][j] == ')') c --;\n                height[i] = max(height[i], c);\n            }\n        }\n\n        switch (op) {\n            case 'i':\n                cout << intersection(t, max(height[0], height[1])) << endl;\n                break;\n            case 'u':\n                cout << unite(t, max(height[0], height[1])) << endl;\n                break;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\nconst int inf = 100000000;\nint i,j;\nconst int maxn = 35; ////100005\nchar str1[maxn];\nchar str2[maxn];\nchar str[maxn];\n\nint getmid(char str[], int begin, int end)\n{\n\tint left = 0;\n\tint right = 0;\n\tfor (i = begin; i < end; i++)\n\t{\n\t\tif (str[i] == '(')\n\t\t{\n\t\t\tleft++;\n\t\t}\n\t\telse if (str[i] == ')')\n\t\t{\n\t\t\tright++;\n\t\t}\n\t\tif (left == right+1 && str[i] == ',')\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}\n\nint insert(int begin1, int end1, int begin2, int end2, int begin)\n{\n\tif (begin1 >= end1 || begin2 >= end2)\n\t{\n\t\treturn begin;\n\t}\n\tstr[begin] = '(';    ///qian\n\tint mid1 = getmid(str1, begin1, end1);\n\tint mid2 = getmid(str2, begin2, end2);\n\tint stop1 = insert(begin1+1, mid1, begin2+1, mid2, begin+1);\n\tstr[stop1] = ',';    ///zhong\n\tint stop2 = insert(mid1+1, end1-1, mid2+1, end2-1, stop1+1);\n\tstr[stop2] = ')';    ///hou\n\treturn stop2+1;\n}\n\nvoid insert()\n{\n\tint len1 = strlen(str1);\n\tint len2 = strlen(str2);\n\tint end = insert(0, len1, 0, len2, 0);\n\tstr[end] = '\\0';\n}\n\nint merge(int begin1, int end1, int begin2, int end2, int begin)\n{\n\tif (begin1 >= end1)\n\t{\n\t\tfor (i = 0; i < end2-begin2; i++)\n\t\t{\n\t\t\tstr[begin+i] = str2[begin2+i];\n\t\t}\n\t\treturn begin+i;\n\t}\n\tif (begin2 >= end2)\n\t{\n\t\tfor (i = 0; i < end1-begin1; i++)\n\t\t{\n\t\t\tstr[begin+i] = str1[begin1+i];\n\t\t}\n\t\treturn begin+i;\n\t}\n\tstr[begin] = '(';    ///qian\n\tint mid1 = getmid(str1, begin1, end1);\n\tint mid2 = getmid(str2, begin2, end2);\n\tint stop1 = merge(begin1+1, mid1, begin2+1, mid2, begin+1);\n\tstr[stop1] = ',';    ///zhong\n\tint stop2 = merge(mid1+1, end1-1, mid2+1, end2-1, stop1+1);\n\tstr[stop2] = ')';    ///hou\n\treturn stop2+1;\n}\n\nvoid merge()\n{\n\tint len1 = strlen(str1);\n\tint len2 = strlen(str2);\n\tint end = merge(0, len1, 0, len2, 0);\n\tstr[end] = '\\0';\n}\n\nint main()\n{\n\tchar sstr[10];\n\twhile (cin >> sstr >> str1 >> str2)\n\t{\n\t\tif (sstr[0] == 'i')\n\t\t{\n\t\t\tinsert();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmerge();\n\t\t}\n\t\tcout << str << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct Node{\n\tNode* l;\n\tNode* r;\n\tNode() : l(nullptr), r(nullptr){};\n};\n\nstring s;\nint c;\nNode* f(){\n\tNode* n = new Node();\n\tc++;\n\tif(s[c] == '('){\n\t\tn->l = f();\n\t\tc++;\n\t}\n\tassert(s[c] == ',');\n\tc++;\n\tif(s[c] == '('){\n\t\tn->r = f();\n\t\tc++;\n\t}\n\treturn n;\n}\n\nbool intersection;\nvoid g(Node* t1, Node* t2){\n\tif(t1 == nullptr && t2 == nullptr) return;\n\tif(intersection && (t1 == nullptr || t2 == nullptr)) return;\n\tcout << '(';\n\tNode* c1 = t1 == nullptr ? nullptr : t1->l;\n\tNode* c2 = t2 == nullptr ? nullptr : t2->l;\n\tg(c1, c2);\n\tcout << ',';\n\tc1 = t1 == nullptr ? nullptr : t1->r;\n\tc2 = t2 == nullptr ? nullptr : t2->r;\n\tg(c1, c2);\n\tcout << ')';\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tchar op;\n\twhile(cin >> op >> s){\n\t\tintersection = op == 'i';\n\t\tc = 0;\n\t\tNode* t1 = f();\n\n\t\tcin >> s;\n\t\tc = 0;\n\t\tNode* t2 = f();\n\n\t\tg(t1, t2);\n\t\tcout << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n//#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct Tree\n{\n  bool root;\n  bool child[2];\n  Tree *next[2];//left -> false, right -> true\n  Tree()\n  {\n    child[0] = child[1] = false;\n    root=false;\n  }\n};\n\nstring s[2];\nTree tree[2];\n\nvoid ddfs(Tree *t)\n{\n  if(!t->child[0] && !t->child[1])return;\n    \n  if(t->child[0])\n    {\n      ddfs(t->next[0]);\n      t->child[0] = false;\n      delete t->next[0];\n    }\n\n  if(t->child[1])\n    {\n      ddfs(t->next[1]);\n      t->child[1] = false;\n      delete t->next[1];\n    }\n\n}\n\nvoid init()\n{\n  tree[0].root = tree[1].root = true;\n  rep(i,2)ddfs(&tree[i]);\n}\n\nvoid parse(int index,int &pos,Tree *t,int depth)\n{\n  if(pos >= s[index].size())return;\n  //assert(s[index][pos] == '('); \n  bool LR = false;\n\n  ++pos;\n  while(pos < s[index].size() && !(LR && s[index][pos] == ')'))\n    {\n\n      if(s[index][pos] == '(')\n\t{\n\t  t->next[LR] = new Tree;\n\t  t->next[LR]->root = false;\n\t  t->next[LR]->child[0] = t->next[LR]->child[1] = false;\n\t  t->child[LR] = true;\n\t  parse(index,pos,t->next[LR],depth+1);\n\t}\n      if(s[index][pos] == ',') LR = true;\n\t\n      ++pos;\n    }\n  ++pos;\n}\n\nvoid tree_walk(Tree *t,int depth)\n{\n  cout << '(';\n  if(t->child[0])tree_walk(t->next[0],depth+1);\n  cout << ',';\n  if(t->child[1])tree_walk(t->next[1],depth+1);\n  cout << ')';\n}\n\nvoid dfs_i(Tree *t1,Tree *t2,Tree *ans)\n{\n  if(t1->child[0] && t2->child[0])\n    {\n      ans->next[0] = new Tree;\n      ans->child[0] = true;\n      ans->next[0]->child[0] = ans->next[0]->child[1] = false;\n      dfs_i(t1->next[0],t2->next[0],ans->next[0]);\n    }\n\n  if(t1->child[1] && t2->child[1])\n    {\n      ans->next[1] = new Tree;\n      ans->child[1] = true;\n      ans->next[1]->child[0] = ans->next[1]->child[1] = false;\n      dfs_i(t1->next[1],t2->next[1],ans->next[1]);\n    }\n\n}\n\nvoid dfs_u(Tree *t,Tree *ans)\n{\n  if(t->child[0])\n    {\n      if(ans->child[0])\n\t{//already exists\n\t  dfs_u(t->next[0],ans->next[0]);\n\t}\n      else\n\t{//not yet\n\t  ans->next[0] = new Tree;\n\t  ans->child[0] = true;\n\t  ans->next[0]->child[0] = ans->next[0]->child[1] = false;\n\t  dfs_u(t->next[0],ans->next[0]);\n\t}\n    }\n\n  if(t->child[1])\n    {\n      if(ans->child[1])\n\t{//already exists\n\t  dfs_u(t->next[1],ans->next[1]);\n\t}\n      else\n\t{//not yet\n\t  ans->next[1] = new Tree;\n\t  ans->child[1] = true;\n\t  ans->next[1]->child[0] = ans->next[1]->child[1] = false;\n\t  dfs_u(t->next[1],ans->next[1]);\n\t}\n    }\n\n}\n\nvoid compute(char c)\n{\n  Tree ans;\n  ans.root = true;\n  ans.child[0] = ans.child[1] = false;\n  if(c == 'i')\n    {\n      dfs_i(&tree[0],&tree[1],&ans);\n      tree_walk(&ans,0);\n      cout << endl;\n    }\n  else if(c == 'u')\n    {\n      dfs_u(&tree[0],&ans);\n      dfs_u(&tree[1],&ans);\n      tree_walk(&ans,0);\n      cout << endl;\n    }\n\n  ddfs(&ans);\n}\n\n\n\n//deleteまわりも後で書く <- 忘れてた\n\nint main()\n{\n\n  char c;\n  while(cin >> c)\n    {\n      cin >> s[0] >> s[1];\n      init();\n\n      int pos;\n      rep(i,2)\n\t{\n\t  pos = 0;\n\t  parse(i,pos,&tree[i],0);\n\t}\n\n      compute(c);\n   \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cassert>\nusing namespace std;\nint cur = 0;\nstruct node{\n  node *l,*r;\n  node(node *l = nullptr,node *r = nullptr):l(l),r(r){};\n};\nnode* parse(string &f){\n  assert(f[cur] == '(');\n  cur++;\n  node *current = new node();\n  if(f[cur] == '('){\n\tnode *left = parse(f);\n\tcurrent->l = left;\n  }\n  assert(f[cur] == ',');\n  cur++;\n  if(f[cur] == '('){\n\tnode *right = parse(f);\n\tcurrent->r = right;\n  }\n  assert(f[cur] == ')');\n  cur++;\n  return current;\n}\nstring dfs_i(node *f,node *s){\n  if(f == nullptr || s == nullptr)return \"\";\n  return \"(\" + dfs_i(f->l,s->l) + \",\" + dfs_i(f->r,s->r) + \")\";\n  \n}\nstring dfs_u(node *f,node *s){\n  if(f == nullptr && s == nullptr)return \"\";\n  if(f == nullptr) return \"(\" + dfs_u(nullptr,s->l) + \",\" + dfs_u(nullptr,s->r) + \")\";\n  if(s == nullptr) return \"(\" + dfs_u(f->l,nullptr) + \",\" + dfs_u(f->r,nullptr) + \")\";\n  return \"(\" + dfs_u(f->l,s->l) + \",\" + dfs_u(f->r,s->r) + \")\";\n  \n}\nint main(){\n  string f,s;\n  char c;\n  while(cin >> c >> f >> s){\n\tnode *f_t,*s_t;\n\tcur = 0;\n\tf_t = parse(f);\n\tcur = 0;\n\ts_t = parse(s);\n\t\n\tif(c == 'i')cout << dfs_i(f_t,s_t) << endl;\n\tif(c == 'u')cout << dfs_u(f_t,s_t) << endl;\n\t\n\t\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct node {\n  node *ch[2];\n  \n  node() {\n    ch[0] = ch[1] = 0;\n  }\n  ~node() {\n    delete ch[0];\n    delete ch[1];\n  }\n};\n\nvoid tostr(node *nd, string &s) {\n  if(nd) {\n    s += '(';\n    tostr(nd->ch[0], s);\n    s += ',';\n    tostr(nd->ch[1], s);\n    s += ')';\n  }\n}\n\nconst char *p;\nnode *parse() {\n  node *ret = new node;\n  if(*++p == '(') {\n    ret->ch[0] = parse();\n  }\n  if(*++p == '(') {\n    ret->ch[1] = parse();\n  }\n  ++p;\n  return ret;\n}\n\nnode *child(node *nd, int k) {\n  return nd ? nd->ch[k] : 0;\n}\n\nnode *opr(char type, node *a, node *b) {\n  node *ret = 0;\n  if (type == 'i') {\n    if(a && b) {\n      ret = new node;\n    }\n  }\n  else {\n    if(a || b) {\n      ret = new node;\n    }\n  }\n  \n  if (ret) {\n    for (int i = 0; i < 2; i++) {\n      ret->ch[i] = opr(type, child(a, i), child(b, i));\n    }\n  }\n  return ret;\n}\n\nint main() {\n  char type;\n  string s, t;\n  while(cin >> type >> s >> t) {\n    node *ns, *nt, *ret;\n    p = s.c_str();\n    ns = parse();\n    p = t.c_str();\n    nt = parse();\n    \n    ret = opr(type, ns, nt);\n\n    string u;\n    tostr(ret, u);\n    cout << u << endl;\n\n    delete ns;\n    delete nt;\n    delete ret;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nstruct N{N*l,*r;};\nchar*C(char*p,N*&n)\n{\n\tn=new N;\n\tif(*p=='(')p=C(p+1,n->l);\n\telse n->l=0;\n\tif(*p==',')++p;\n\tif(*p=='(')p=C(p+1,n->r);\n\telse n->r=0;\n\tif(*p==')')++p;\n\treturn p;\n}\nvoid I(N*&r,N*t1,N*t2)\n{\n\tr=new N;\n\tif(t1->l&&t2->l)I(r->l,t1->l,t2->l);\n\telse r->l=0;\n\tif(t1->r&&t2->r)I(r->r,t1->r,t2->r);\n\telse r->r=0;\n}\nvoid U(N*&r,N*t1,N*t2)\n{\n\tr=new N;\n\tif(t1&&t1->l || t2&&t2->l) U(r->l, t1?t1->l:0, t2?t2->l:0);\n\telse r->l=0;\n\tif(t1&&t1->r || t2&&t2->r) U(r->r, t1?t1->r:0, t2?t2->r:0);\n\telse r->r=0;\n}\nvoid P(N*t)\n{\n\tputchar('(');\n\tif(t->l)P(t->l);\n\tputchar(',');\n\tif(t->r)P(t->r);\n\tputchar(')');\n}\nvoid D(N*t)\n{\n\tif(t->l)D(t->l);\n\tif(t->r)D(t->r);\n\tdelete t;\n}\nint main()\n{\n\tchar s[999],t1[999],t2[999],*p1,*p2,o;\n\twhile(fgets(s,999,stdin))\n\t{\n\t\to=s[0];\n\t\tp1=s+2;\n\t\tp2=strchr(p1,' ');\n\t\t*p2=0;\n\t\tstrcpy(t1,p1);\n\t\tstrcpy(t2,p2+1);\n\n\t\tN *n1=0,*n2=0,*r=0;\n\t\tC(t1+1,n1);\n\t\tC(t2+1,n2);\n\t\tif(o=='i')I(r,n1,n2);\n\t\telse U(r,n1,n2);\n\t\tP(r);\n\t\tputs(\"\");\n\t\tD(n1);\n\t\tD(n2);\n\t\tD(r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nconst int nil = -1;\nconst int MAX_N = 256;\n\nstruct Node {\n  int l, r, cnt;\n  Node() {\n    l = r = nil;\n    cnt = 0;\n  }\n};\n\nNode v[MAX_N];\nint nodeIndex;\n\nint parse(const char *s, int n, int root) {\n  v[root].cnt++;\n  if (s[++n] != ',') {\n    if (v[root].l == nil) v[root].l = ++nodeIndex;\n    n = parse(s, n, v[root].l);\n  }\n  if (s[++n] != ')') {\n    if (v[root].r == nil) v[root].r = ++nodeIndex;\n    n = parse(s, n, v[root].r);\n  }\n  return n+1;\n}\n\nvoid print(int root, int cnt) {\n  if (v[root].cnt < cnt) return;\n  putchar('(');\n  if (v[root].l != nil) print(v[root].l, cnt);\n  putchar(',');\n  if (v[root].r != nil) print(v[root].r, cnt);\n  putchar(')');\n}\n\nint main() {\n  char op[5], t1[1024], t2[1024];\n  while (scanf(\"%s %s %s\", op, t1, t2) == 3) {\n    for (int i=0;i<MAX_N;i++) v[i] = Node();\n    nodeIndex = 0;\n    parse(t1, 0, 0);\n    parse(t2, 0, 0);\n    print(0, (op[0]=='u'?1:2)); putchar('\\n');\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<list>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\n\nint treeA[1100];\nint treeB[1100];\nint treeC[1100];\n\nvoid getTree(string line,int tree, int lvl){\n\tif(line==\"\" || line==\"(\" || line==\")\")return;\n\tstack<int> cnt;\n\tint b=0;\n\twhile(line[b]!=0){\n\t\tif(line[b]=='('){\n\t\t\tcnt.push(1);\n\t\t}else if(line[b]==')'){\n\t\t\tcnt.pop();\n\t\t}else{\n\t\t\tif(cnt.size()==1)break;\n\t\t}\n\t\tb++;\n\t}\n\tstring S_R = \"\";\n\tstring S_L = \"\";\n\tfor(int x=1;x<b;++x){\n\t\tS_L += line[x];\n\t}\n\tfor(int x=b+1;x<line.size()-1;++x){\n\t\tS_R += line[x];\n\t}\n\tgetTree(S_R,tree,2*lvl+1);\n\tgetTree(S_L,tree,2*lvl);\n\tif(tree==1){\n\t\ttreeA[lvl] = 1;\n\t}else{\n\t\ttreeB[lvl] = 2;\n\t}\n}\n\nstring imp(int lvl){\n\tif(lvl>=1100)return \"\";\n\tif(treeC[lvl]==0)return \"\";\n\tstringstream buf;\n\tbuf<<\"(\"<<imp(2*lvl)<<\",\"<<imp(2*lvl+1)<<\")\";\n\treturn buf.str();\n}\n\nvoid unionT(){\n\tfor(int x=1;x<1100;++x){\n\t\tif(treeA[x] || treeB[x])treeC[x] = 3;\n\t}\n\tcout<<imp(1)<<endl;\n}\n\nvoid inter(){\n\tfor(int x=1;x<1100;++x){\n\t\tif(treeA[x] && treeB[x])treeC[x] = 3;\n\t}\n\tcout<<imp(1)<<endl;\n}\n\nint main(){\n\tchar l;\n\tstring s1,s2;\n\twhile(cin>>l>>s1>>s2 && !cin.eof()){\n\t\tfor(int x=0;x<1100;++x){\n\t\t\ttreeA[x] = 0;treeB[x] = 0;treeC[x] = 0;\n\t\t}\n\t\tgetTree(s1,1,1);\n\t\tgetTree(s2,2,1);\n\t\tif(l == 'u'){\n\t\t\tunionT();\n\t\t}else{\n\t\t\tinter();\n\t\t}\n\t}\t\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing ForwardIt = typename std::string::const_iterator;\n\nstd::string node(ForwardIt&);\nstd::string node(ForwardIt&, ForwardIt&, char);\nstd::string tree(ForwardIt&, ForwardIt&, char);\n\nstd::string node(ForwardIt& s) {\n  assert(*s == '(');\n  std::string res(1, *s++);\n  int opened=1;\n  while (opened) {\n    if (*s == '(') {\n      ++opened;\n    } else if (*s == ')') {\n      --opened;\n    }\n    res += *s++;\n  }\n  return res;\n}\n\nstd::string node(ForwardIt& s, ForwardIt& t, char op) {\n  std::string res;\n  if (*s != '(') {\n    assert(*s == ',' || *s == ')');\n    if (*t != '(') {\n      assert(*t == ',' || *t == ')');\n    } else {\n      std::string tmp=node(t);\n      if (op == 'u') res += tmp;\n    }\n  } else if (*t != '(') {\n    assert(*t == ',' || *t == ')');\n    std::string tmp=node(s);\n    if (op == 'u') res += tmp;\n  } else {\n    res += tree(s, t, op);\n  }\n  return res;\n}\n\nstd::string tree(ForwardIt& s, ForwardIt& t, char op) {\n  assert(*s == '(');\n  assert(*t == '(');\n  ++s;\n  ++t;\n\n  std::string res=\"(\";\n\n  res += node(s, t, op);\n\n  assert(*s == ',');\n  assert(*t == ',');\n  ++s;\n  ++t;\n\n  res += ',';\n\n  res += node(s, t, op);\n\n  assert(*s == ')');\n  assert(*t == ')');\n  ++s;\n  ++t;\n\n  res += ')';\n  return res;\n}\n\nint testcase_ends() {\n  char op;\n  if (scanf(\" %c\", &op) == EOF) return 1;\n\n  char buf[1024];\n  scanf(\"%s\", buf);\n  std::string s=buf;\n  scanf(\"%s\", buf);\n  std::string t=buf;\n\n  auto s_it=s.cbegin();\n  auto t_it=t.cbegin();\n\n  printf(\"%s\\n\", tree(s_it, t_it, op).c_str());\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream> \n#include<string>\n#include<stack>\n#include<utility>\n\nusing namespace std;\n\nint main(void){\n\n\tstring ans;\n\tchar inp;\n\t\n\tstack<pair<char,int> > tree1,tree2;\n\tstring oper;\n\n\twhile(cin>>oper){\n\t\tinp=getchar();\n\t\twhile(1){\n\t\t\tinp=getchar();\n\t\t\tif(inp==' ') break;\n\t\t\tswitch(inp){\n\t\t\tcase '(':\n\t\t\t\tif(tree1.empty()) tree1.push(pair<char,int>(inp,0));\n\t\t\t\telse tree1.push(pair<char,int>(inp,tree1.top().second +1));\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\ttree1.push(pair<char,int>(inp,tree1.top().second -1));\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\ttree1.push(pair<char,int>(inp,tree1.top().second));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tinp=getchar();\n\t\t\tif(inp=='\\n') break;\n\t\t\tswitch(inp){\n\t\t\tcase '(':\n\t\t\t\tif(tree2.empty()) tree2.push(pair<char,int>(inp,0));\n\t\t\t\telse tree2.push(pair<char,int>(inp,tree2.top().second +1));\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\ttree2.push(pair<char,int>(inp,tree2.top().second -1));\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\ttree2.push(pair<char,int>(inp,tree2.top().second));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans=\")\";\n\t\ttree1.pop(),tree2.pop();\n\t\twhile(!tree1.empty()&&!tree2.empty()){\n\t\t\tif(tree1.top()==tree2.top()){\n\t\t\t\tans+=tree1.top().first;\n\t\t\t\ttree1.pop(),tree2.pop();\n\t\t\t}\n\t\t\telse if(tree1.top().first==tree2.top().first){\n\t\t\t\tif(tree1.top().second>tree2.top().second){\n\t\t\t\t\tif(oper==\"u\") ans+=tree1.top().first;\n\t\t\t\t\ttree1.pop();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(oper==\"u\") ans+=tree2.top().first;\n\t\t\t\t\ttree2.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(tree1.top().first==','){\n\t\t\t\tif(oper==\"u\") ans+=tree2.top().first;\n\t\t\t\ttree2.pop();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(oper==\"u\") ans+=tree1.top().first;\n\t\t\t\ttree1.pop();\n\t\t\t}\n\t\t}\n\t\tfor(int i=ans.length()-1;i>=0;i--){\n\t\t\tcout<<ans[i];\n\t\t}\n\t\tcout<<endl;\n\t}\n\t\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nconst int nil = -1;\nconst int MAX_N = 256;\n\nstruct Node {\n  int l, r, cnt;\n  Node() {\n    l = r = nil;\n    cnt = 0;\n  }\n};\n\nNode v[MAX_N];\nint nodeIndex;\n\nint parse(const char *s, int n, int root) {\n  v[root].cnt++;\n  if (s[++n] != ',') {\n    if (v[root].l == nil) v[root].l = ++nodeIndex;\n    n = parse(s, n, v[root].l);\n  }\n  if (s[++n] != ')') {\n    if (v[root].r == nil) v[root].r = ++nodeIndex;\n    n = parse(s, n, v[root].r);\n  }\n  return n+1;\n}\n\nvoid print(int root, int cnt) {\n  if (v[root].cnt < cnt) return;\n  putchar('(');\n  if (v[root].l != nil) print(v[root].l, cnt);\n  putchar(',');\n  if (v[root].r != nil) print(v[root].r, cnt);\n  putchar(')');\n}\n\nint main() {\n  char op[10], t1[256], t2[256];\n  while (scanf(\"%s %s %s\", op, t1, t2) == 3) {\n    for (int i=0;i<MAX_N;i++) v[i] = Node();\n    nodeIndex = 0;\n//    parse(t1, 0, 0);\n//    parse(t2, 0, 0);\n//    print(0, (op=='u'?1:2)); putchar('\\n');\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n\nint main(){\n    std::cout << \"Hello World!\" << std::endl;\n    return 0;\n}\n        \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<list>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\n\nmap< int, int > treeA;\nmap< int, int > treeB;\nmap< int, int > treeC;\n\nvoid getTree(string line,int tree,int lvl){\n\tif(line==\"\" || line==\"(\" || line==\")\")return;\n\tint b = 0;\n\tstack<int> cnt;\n\twhile(line[b]!=0){\n\t\tif(line[b]=='('){\n\t\t\tcnt.push(1);\n\t\t}else if(line[b]==')'){\n\t\t\tcnt.pop();\n\t\t}else{\n\t\t\tif(cnt.size()==1)break;\n\t\t}\n\t\tb++;\n\t}\n\tstring S_R=\"\",S_L= \"\";\n\tfor(int x=1;x<b;++x){\n\t\tS_L += line[x];\n\t}\n\tfor(int x=b+1;x<line.size()-1;++x){\n\t\tS_R += line[x];\n\t}\n\tif(S_L!=\"\"){\n\t\tgetTree(S_L,tree,lvl*2);\n\t}\n\tif(S_R!=\"\"){\n\t\tgetTree(S_R,tree,lvl*2+1);\n\t}\n\tif(tree==1){\n\t\ttreeA[lvl] = 1;\n\t}else{\n\t\ttreeB[lvl] = 2;\n\t}\n}\n\nvoid uniont(){\n\tfor(map<int,int>::iterator it = treeA.begin();it!=treeA.end();++it){\n\t\ttreeC[it->first] = 3;\n\t}\n\tfor(map<int,int>::iterator it = treeB.begin();it!=treeB.end();++it){\n\t\ttreeC[it->first] = 3;\n\t}\n}\n\nint locate(int n){\n\tfor(map<int,int>::iterator it=treeB.begin();treeB.end()!=it;++it){\n\t\tif(n==it->first)return 0;\n\t\tif(it->first>n)return -1;\n\t}\n\treturn -1;\n}\n\nvoid intert(){\n\tfor(map<int,int>::iterator it = treeA.begin();it!=treeA.end();++it){\n\t\tif(locate(it->first)!=-1){\n\t\t\ttreeC[it->first] = 3;\n\t\t}\n\t}\n}\n\nstring imp(int lvl){\n\tif(treeC[lvl]==0)return \"\";\n\tstringstream buf;\n\tbuf<<\"(\"<<imp(lvl*2)<<\",\"<<imp(lvl*2+1)<<\")\";\n\treturn buf.str();\n}\n\nint main(){\n\tchar l;\n\tstring s1,s2;\n\twhile(scanf(\" %c \",&l)!=EOF){\n\t\tcin>>s1>>s2;\n\t\ttreeA.clear();\n\t\ttreeB.clear();\n\t\ttreeC.clear();\n\t\tgetTree(s1,1,1);\n\t\tgetTree(s2,2,1);\n\t\tif(l=='u'){\n\t\t\tuniont();\n\t\t}else{\n\t\t\tintert();\n\t\t}\t\n\t\tcout<<imp(1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\nstruct Node {\n  Node* l, * r;\n};\n\nNode nodes[256];\nint counter;\n\nvoid Init() {\n  memset(nodes, 0, sizeof(nodes));\n  counter = 0;\n}\n\nNode* Parse(const char*(& s)) {\n  if (*s != '(') {\n    return nullptr;\n  }\n  s++;\n  Node* node = &nodes[counter++];\n  node->l = Parse(s);\n  assert(*s == ',');\n  s++;\n  node->r = Parse(s);\n  assert(*s == ')');\n  s++;\n  return node;\n}\n\nNode* Intersect(Node* a, Node* b) {\n  if (a->l && b->l) {\n    a->l = Intersect(a->l, b->l);\n  } else {\n    a->l = nullptr;\n  }\n  if (a->r && b->r) {\n    a->r = Intersect(a->r, b->r);\n  } else {\n    a->r = nullptr;\n  }\n  return a;\n}\n\nNode* Union(Node* a, Node* b) {\n  if (a->l && b->l) {\n    a->l = Union(a->l, b->l);\n  } else if (b->l) {\n    a->l = b->l;\n  }\n  if (a->r && b->r) {\n    a->r = Union(a->r, b->r);\n  } else if (b->r){\n    a->r = b->r;\n  }\n  return a;\n}\n\nNode* Solve(const string& type, Node* a, Node* b) {\n  Node* r;\n  if (type == \"i\") {\n    r = Intersect(a, b);\n  } else {\n    r = Union(a, b);\n  }\n  return r;\n}\n\nvoid Print(const Node* a) {\n  cout << \"(\";\n  if (a->l) {\n    Print(a->l);\n  }\n  cout << \",\";\n  if (a->r) {\n    Print(a->r);\n  }\n  cout << \")\";\n}\n\nint main() {\n  string type, a, b;\n  while (cin >> type >> a >> b) {\n    Init();\n    const char* pa = a.c_str();\n    const char* pb = b.c_str();\n    Node* ta = Parse(pa);\n    Node* tb = Parse(pb);\n    Print(Solve(type, ta, tb));\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <vector>\n#include <string>\n\nvoid skip(const std::string &s, size_t &i, bool out) {\n  if (s[i] == ',') return;\n  assert(s[i] == '(');\n  size_t opened=1;\n  ++i;\n  if (out) printf(\"(\");\n\n  while (opened) {\n    if (s[i] == '(') ++opened;\n    if (s[i] == ')') --opened;\n    if (out) printf(\"%c\", s[i]);\n    ++i;\n  }\n}\n\nvoid fourt(\n    const std::string &s, size_t &i, const std::string &t, size_t &j, \n    char op) {\n\n  assert(s[i] == '(' && t[j] == '(');\n  ++i;\n  ++j;\n  printf(\"(\");\n  if (s[i] == ',' && t[j] == ',') {\n  } else if (s[i] == ',') {\n    skip(t, j, (op == 'u'));\n  } else if (t[j] == ',') {\n    skip(s, i, (op == 'u'));\n  } else {\n    fourt(s, i, t, j, op);\n  }\n\n  printf(\",\");\n  assert(s[i] == ',' && t[j] == ',');\n  ++i;\n  ++j;\n  if (s[i] == ')' && t[j] == ')') {\n  } else if (s[i] == ')') {\n    skip(t, j, (op == 'u'));\n  } else if (t[j] == ')') {\n    skip(s, i, (op == 'u'));\n  } else {\n    fourt(s, i, t, j, op);\n  }\n\n  printf(\")\");\n  ++i;\n  ++j;\n}\n\nint testcase_ends() {\n  char op;\n  if (scanf(\" %c\", &op) == EOF)\n    return 1;\n\n  char buf[384];\n  scanf(\"%s\", buf);\n  std::string s=buf;\n  scanf(\"%s\", buf);\n  std::string t=buf;\n\n  size_t i=0, j=0;\n  fourt(s, i, t, j, op);\n  printf(\"\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <string>\n#include <iostream>\n\n\nusing namespace std;\n\nvoid make_tree(bool* tree, int node, string s)\n{\n\tif (s.empty())\n\t\treturn;\n\n\ttree[node] = true;\n\n\tint paren = 0;\n\tint i;\n\tfor (i = 1; paren != 0 || s[i] != ','; ++i)\n\t{\n\t\tif (s[i] == '(')\n\t\t\t++paren;\n\t\telse if (s[i] == ')')\n\t\t\t--paren;\n\t}\n\tmake_tree(tree, node*2+1, s.substr(1, i-1));\n\tmake_tree(tree, node*2+2, s.substr(i+1, s.size()-i-2));\n}\n\nvoid print_tree(bool* tree, int node)\n{\n\tif (!tree[node])\n\t\treturn;\n\n\tputchar('(');\n\tprint_tree(tree, node*2+1);\n\tputchar(',');\n\tprint_tree(tree, node*2+2);\n\tputchar(')');\n}\n\nint main()\n{\n\tconst int TreeSize = 128;\n\tchar ope;\n\tstring s1, s2;\n\tbool tree1[TreeSize], tree2[TreeSize], opedTree[TreeSize];\n\twhile (cin >> ope >> s1 >> s2)\n\t{\n\t\tfill(tree1, tree1+TreeSize, false);\n\t\tfill(tree2, tree2+TreeSize, false);\n\n\t\tmake_tree(tree1, 0, s1);\n\t\tmake_tree(tree2, 0, s2);\n\n\t\tif (ope == 'i')\n\t\t\tfor (int i = 0; i < TreeSize; ++i)\n\t\t\t\topedTree[i] = tree1[i] & tree2[i];\n\t\telse\n\t\t\tfor (int i = 0; i < TreeSize; ++i)\n\t\t\t\topedTree[i] = tree1[i] | tree2[i];\n\n\t\tprint_tree(opedTree, 0);\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <cstring>\nusing namespace std;\n\nstruct Node {\n\tNode * l;\n\tNode * r;\n\tNode () {l = r = NULL;}\n};\n\nNode * build(char s[], int l, int r) {\n\tif (r < l) return NULL;\n\tNode * p = new Node();\n\tint cnt = 0;\n\tfor (int i = l + 1; i < r; ++i) {\n\t\tif (s[i] == '(') {cnt ++; continue;}\n\t\tif (s[i] == ')') {cnt --; continue;}\n\t\tif (s[i] == ',' && cnt == 0) {\n\t\t\tp->l = build(s, l + 1, i - 1);\n\t\t\tp->r = build(s, i + 1, r - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn p;\n}\n\nNode * getInter(Node * a, Node * b) {\n\tNode * p = new Node();\n\tif (a->l != NULL && b->l != NULL) {\n\t\tp->l = getInter(a->l, b->l);\n\t}\n\telse p->l = NULL;\n\tif (a->r != NULL && b->r != NULL) {\n\t\tp->r = getInter(a->r, b->r);\n\t}\n\telse p->r = NULL;\n\treturn p;\n}\n\nNode * getUnion(Node * a, Node * b) {\n\tNode * p = new Node();\n\tif (a != NULL && b != NULL) {\n\t\tif (a->l != NULL || b->l != NULL) {\n\t\t\tp->l = getUnion(a->l, b->l);\n\t\t}\n\t\telse p->l = NULL;\n\t\tif (a->r != NULL || b->r != NULL) {\n\t\t\tp->r = getUnion(a->r, b->r);\n\t\t}\n\t\telse p->r = NULL;\n\t} else if (a == NULL) {\n\t\tif (b->l != NULL) p->l = getUnion(NULL, b->l);\n\t\telse p->l = NULL;\n\t\tif (b->r != NULL) p->r = getUnion(NULL, b->r);\n\t\telse p->r = NULL;\n\t} else {\n\t\tif (a->l != NULL) a->l = getUnion(NULL, a->l);\n\t\telse p->l = NULL;\n\t\tif (a->r != NULL) a->r = getUnion(NULL, a->r);\n\t\telse p->r = NULL;\n\t}\n\treturn p;\n}\n\nstring getStr(Node * p) {\n\tif (p == NULL) {\n\t\treturn \"\";\n\t}\n\telse return \"(\" + getStr(p->l) + \",\" + getStr(p->r) + \")\";\n}\n\nchar a[3000], b[3000];\n\nint main() {\n\tchar op;\n\twhile (scanf(\"%c %s %s\", &op, a, b) != EOF) {\n\t\tgetchar();\n\t\tint la = strlen(a), lb = strlen(b);\n\t\tNode * ra = build(a, 0, la - 1);\n\t\tNode * rb = build(b, 0, lb - 1);\n\t\tNode * root = NULL;\n\t\tif (op == 'i') root = getInter(ra, rb);\n\t\telse root = getUnion(ra, rb);\n\t\tstring res = getStr(root);\n\t\tprintf(\"%s\\n\", res.c_str());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <boost/shared_ptr.hpp>\n#include <boost/make_shared.hpp>\nusing namespace std;\n\nstruct bad_input { };\nstruct Node;\ntypedef boost::shared_ptr<Node> NodePtr;\nstruct Node {\n\tNodePtr left;\n\tNodePtr right;\n};\n\nvoid show_intersection_tree(NodePtr root1, NodePtr root2)\n{\n\tstd::cout << '(';\n\tif (root1->left && root2->left) {\n\t\tshow_intersection_tree(root1->left, root2->left);\n\t}\n\tstd::cout << ',';\n\tif (root1->right && root2->right) {\n\t\tshow_intersection_tree(root1->right, root2->right);\n\t}\n\tstd::cout << ')';\n}\n\nvoid show_union_tree(NodePtr root1, NodePtr root2)\n{\n\tstd::cout << '(';\n\tif ((root1 && root1->left) || (root2 && root2->left)) {\n\t\tshow_union_tree(root1 ? root1->left : root1, root2 ? root2->left : root2);\n\t}\n\tstd::cout << ',';\n\tif ((root1 && root1->right) || (root2 && root2->right)) {\n\t\tshow_union_tree(root1 ? root1->right : root1, root2 ? root2->right : root2);\n\t}\n\tstd::cout << ')';\n}\n\nchar get_token()\n{\n\tchar c;\n\twhile (std::cin >> c) {\n\t\tif (c == '(' || c == ',' || c == ')') {\n\t\t\tbreak;\n\t\t}\n\t\tif (c != '\\n' && c != ' ') {\n\t\t\tthrow bad_input();\n\t\t}\n\t}\n\treturn c;\n}\n\nNodePtr make_node(int no)\n{\n\tNodePtr node = boost::make_shared<Node>();\n\tchar c = get_token();\n\tif (c == '(') {\n\t\tnode->left = make_node(no + 1);\n\t\tc = get_token();\n\t}\n\tif (c == ',') {\n\t}\n\telse {\n\t\tthrow bad_input();\n\t}\n\tc = get_token();\n\tif (c == '(') {\n\t\tnode->right = make_node(no + 1);\n\t\tc = get_token();\n\t}\n\tif (c == ')') {\n\t}\n\telse {\n\t\tthrow bad_input();\n\t}\n\treturn node;\n}\n\nint main()\n{\n\tchar op;\n\twhile (std::cin >> op) {\n\t\tNodePtr root1, root2;\n\t\tif (get_token() == '(') {\n\t\t\troot1 = make_node(0);\n\t\t}\n\t\telse {\n\t\t\tthrow bad_input();\n\t\t}\n\t\tif (get_token() == '(') {\n\t\t\troot2 = make_node(0);\n\t\t}\n\t\telse {\n\t\t\tthrow bad_input();\n\t\t}\n\t\tif (op == 'i') {\n\t\t\tif (root1 && root2) {\n\t\t\t\tshow_intersection_tree(root1, root2);\n\t\t\t}\n\t\t}\n\t\telse if (op == 'u') {\n\t\t\tif (root1 || root2) {\n\t\t\t\tshow_union_tree(root1, root2);\n\t\t\t}\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=1000;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  if(id>=N){\n    cout<<\"error occured\";\n    return;\n  }\n  heap[id]++;\n  if(s==\"(,)\") return;\n  \n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;   \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n      parse(sub1, 2*id+1);\n      parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nvoid out(int th, int id){\n\n  output.push_back('(');\n\n  int ch1=0,ch2=0;//n of string of each child\n  //if(id*2+1>=N) cout<<\"error: undefined index\\n\";\n  \n  if(heap[id]>th && heap[2*id+1]>th){\n    out(th,2*id+1);\n  }\n  output.push_back(',');\n  if(heap[id]>th && heap[2*id+2]>th){\n    out(th,2*id+2);\n  }\n  \n  output.push_back(')');\n  return;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  output.clear();\n  //cout<<output<<endl;\n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0);\n  \n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  int i=0;\n  \n  while(cin>>cmd>>s1>>s2){\n    solve(cmd,s1,s2);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nclass Node{\npublic:\n  int count, left, right;\n  Node() : count(0), left(-1), right(-1) {}\n};\n\nNode data[200];\nint size;\nstring out;\n\nvoid input(int l, int r, string& str, int p){\n  data[p].count++;\n  if(str.size() == 3) return;\n  int cnt = 0;\n  for(int i=l;i<=r;i++){\n    if(str[i] == '(') cnt++;\n    if(str[i] == ')') cnt--;\n    if(str[i] == ',' && cnt == 1){\n      if(l+1 != i){\n        if(data[p].left == -1) data[p].left = size++;\n        input(l+1, i-1, str, data[p].left);\n      }\n      if(i+1 != r){\n        if(data[p].right == -1) data[p].right = size++;\n        input(i+1, r-1, str, data[p].right);\n      }\n    }\n  }\n}\n\nvoid output(char ope, int p){\n  if(ope == 'i' && data[p].count < 2) return;\n  out += '(';\n  if(data[p].left != -1) output(ope, data[p].left);\n  out += ',';\n  if(data[p].right != -1) output(ope, data[p].right);\n  out += ')';\n}\n\nmain(){\n  char ope;\n  string a, b;\n  while(cin >> ope >> a >> b){\n    fill(data, data+100, Node());\n    size = 1;\n    input(0, (int)a.size()-1, a, 0);\n    input(0, (int)b.size()-1, b, 0);\n    out = \"\";\n    output(ope, 0);\n    cout << out << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * $File: p1001.cpp\n * $Author: Wayne <tletletle@163.com>\n *\n * Task:\n *   Given two binary trees, we need to\n *   calculate the intersection or the\n *   union of them.\n *\n * Solution:\n *   String parsing. Graph theory.\n *   Just Build the trees and implement.\n*/\n\n#include <cstdio>\n#include <cstring>\n\nconst int kMaxVtx = 100;\nconst int kMaxBuf = 512;\nchar buf[kMaxBuf];\n\nstruct TreeNode {\n\tTreeNode *son[2];\n\tTreeNode() {\n\t\tson[0] = son[1] = NULL;\n\t}\n};\n\nstruct Tree {\n\tTreeNode *root;\n\tTree() {\n\t\troot = NULL;\n\t}\n} a, b, c;\n\nTreeNode *BuildTree(int l, int r) {\n\tif (l > r) return NULL;\n\tTreeNode *res = new TreeNode;\n\tif (l + 1 == r - 1) return res;\n\tint mid, sum = 0;\n\tfor (int i = l + 1; i <= r - 1; ++ i)\n\t\tif (buf[i] == '(') ++ sum;\n\t\telse if (buf[i] == ')') -- sum;\n\t\telse if (buf[i] == ',' && sum == 0) mid = i;\n\tres->son[0] = BuildTree(l + 1, mid - 1);\n\tres->son[1] = BuildTree(mid + 1, r - 1);\n\treturn res;\n}\n\nvoid ReadTree(Tree &des) {\n\tscanf(\"%s\", buf);\n\tdes.root = BuildTree(0, strlen(buf) - 1);\n}\n\nTreeNode *DfsIntersection(TreeNode *u, TreeNode *v) {\n\tif (!u || !v) return NULL;\n\tTreeNode *res = new TreeNode;\n\tres->son[0] = DfsIntersection(u->son[0], v->son[0]);\n\tres->son[1] = DfsIntersection(u->son[1], v->son[1]);\n\treturn res;\n}\n\nTreeNode *DfsUnion(TreeNode *u, TreeNode *v) {\n\tif (!u && !v) return NULL;\n\tTreeNode *res = new TreeNode;\n\tres->son[0] = DfsUnion(u ? u->son[0] : NULL, v ? v->son[0] : NULL);\n\tres->son[1] = DfsUnion(u ? u->son[1] : NULL, v ? v->son[1] : NULL);\n\treturn res;\n}\n\nTree GetIntersection(const Tree &a, const Tree &b) {\n\tTree res;\n\tres.root = DfsIntersection(a.root, b.root);\n\treturn res;\n}\n\nTree GetUnion(const Tree &a, const Tree &b) {\n\tTree res;\n\tres.root = DfsUnion(a.root, b.root);\n\treturn res;\n}\n\nvoid OutputTree(TreeNode *cur) {\n\tif (!cur) return;\n\tputchar('(');\n\tOutputTree(cur->son[0]);\n\tputchar(',');\n\tOutputTree(cur->son[1]);\n\tputchar(')');\n}\n\nint main() {\n\tstatic char cmd[2];\n\twhile (scanf(\"%s\", cmd) != EOF) {\n\t\tReadTree(a);\n\t\tReadTree(b);\n\t\tif (cmd[0] == 'i') c = GetIntersection(a, b);\n\t\telse c = GetUnion(a, b);\n\t\tOutputTree(c.root);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\n\nstruct Tree{\n\tTree *l,*r;\n\tTree():l(0),r(0){}\n\t~Tree(){delete l;delete r;}\n};\n\nTree* to_t(string s){\n\tTree *t=new Tree();\n\tif(s==\"\")return 0;\n\tif(s==\"(,)\")return t;\n\tint lev=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]=='(')lev++;\n\t\telse if(s[i]==')')lev--;\n\t\telse if(lev==1&&s[i]==','){\n\t\t\tt->l=to_t(s.substr(1,i-1));\n\t\t\tt->r=to_t(s.substr(i+1,s.size()-(i+1)-1));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn t;\n}\nstring intersection(Tree *s,Tree *t){\n\tstring res;\n\tif(!s||!t)return res;\n\tres+='(';\n\tres+=intersection(s->l,t->l);\n\tres+=',';\n\tres+=intersection(s->r,t->r);\n\tres+=')';\n\treturn res;\n}\nstring _union(Tree *s,Tree *t){\n\tstring res;\n\tif(!s&&!t)return res;\n\tres+='(';\n\tres+=_union(s?s->l:0,t?t->l:0);\n\tres+=',';\n\tres+=_union(s?s->r:0,t?t->r:0);\n\tres+=')';\n\treturn res;\n}\n\n\nint main(){\n\tchar op;\n\tstring a,b;\n\tTree * s,*t;\n\twhile(cin>>op>>a>>b){\n\t\ts=to_t(a);\n\t\tt=to_t(b);\n\t\tif(op=='i')cout<<intersection(s,t)<<endl;\n\t\telse cout<<_union(s,t)<<endl;\n\t\tdelete s;\n\t\tdelete t;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\nusing namespace std;\n\n#define SIZE 10000\n\nvector <int> getTree( string in )\n{\n\tvector <int> tree( SIZE, 0 );\n\n\tint n = 1;\n\tint lr = 0;\n\tstack <int> lrs;\n\n\tfor ( string::iterator it = in.begin(); it != in.end(); it++ )\n\t{\n\t\tswitch( *it )\n\t\t{\n\t\tcase '(':\n\t\t\tn *= 2;\n\t\t\ttree[n+lr] = 1;\n\t\t\tlrs.push( lr );\n\t\t\tlr = 0;\n\t\t\tbreak;\n\n\t\tcase ')':\n\t\t\tn /= 2;\n\t\t\tlr = lrs.top();\n\t\t\tlrs.pop();\n\t\t\tbreak;\n\n\t\tcase ',':\n\t\t\tlr++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn tree;\n}\n\nvoid printTree( vector <int> &tree, int node )\n{\n\tcout << \"(\";\n\tif ( tree[node*2] == 1 )\n\t{\n\t\tprintTree( tree, node*2 );\n\t}\n\tcout << \",\";\n\tif ( tree[node*2+1] == 1 )\n\t{\n\t\tprintTree( tree, node*2+1 );\n\t}\n\tcout << \")\";\n}\n\nvector <int> intersectionTree( vector <int> &a, vector <int> &b )\n{\n\tvector <int> tree( SIZE, 0 );\n\tfor ( int i = 0; i < SIZE; i++ )\n\t\tif ( a[i] == 1 && b[i] == 1 )\n\t\t\ttree[i] = 1;\n\treturn tree;\n}\n\nvector <int> unionTree( vector <int> &a, vector <int> &b )\n{\n\tvector <int> tree( SIZE, 0 );\n\tfor ( int i = 0; i < SIZE; i++ )\n\t\tif ( a[i] == 1 || b[i] == 1 )\n\t\t\ttree[i] = 1;\n\treturn tree;\n}\n\nint main( void )\n{\n\tstring type;\n\tstring in_a;\n\tstring in_b;\n\n\twhile ( cin >> type >> in_a >> in_b )\n\t{\n\t\tvector <int> a = getTree( in_a );\n\t\tvector <int> b = getTree( in_b );\n\n\t\tvector <int> c;\n\t\tif ( type == \"i\" )\n\t\t{\n\t\t\tc = intersectionTree( a, b );\n\t\t}\n\t\telse if ( type == \"u\" )\n\t\t{\n\t\t\tc = unionTree( a, b );\n\t\t}\n\t\tprintTree( c, 2 );\n\t\tcout << endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n#include <algorithm>\n\nusing namespace std;\n\nstring tree[2];\n\nstring uni(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    int c = 0;\n    index0++, index1++;\n    if (tree[1][index1] != ',') \n      while (true) {\n\tif (c == 0 && tree[1][index1] == ',') {break;}\n\tif (tree[1][index1] == '(') {c++;}\n\tif (tree[1][index1] == ')') {c--;}\n\tleft = left + tree[1][index1];\n\tindex1++;\n      }\n  } else if (tree[1][index1 + 1] == ',') {\n    int c = 0;\n    index0++, index1++;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ',') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      left = left + tree[0][index0];\n      index0++;\n    }\n  } else {\n    left = uni(index0 + 1, index1 + 1);\n    int c = 0;\n    index0++, index1++;\n    while (true) {\n      //      cout << tree[0][index0];\n      if (c == 0 && tree[0][index0] == ',') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      index0++;\n    }\n    c = 0;\n    while (true) {\n      //      cout << tree[1][index1];\n      if (c == 0 && tree[1][index1] == ',') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      index1++;\n    }\n  }\n\n  if (tree[0][index0 + 1] == ')') {\n    int c = 0;\n    index1++;\n    while (true) {\n      if (c == 0 && tree[1][index1] == ')') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      right = right + tree[1][index1];\n      index1++;\n    }\n  } else if (tree[1][index1 + 1] == ')') {\n    int c = 0;\n    index0++;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ')') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      right = right + tree[0][index0];\n      index0++;\n    }\n  } else {\n    right = uni(index0 + 1, index1 + 1);\n  }\n  return \"(\" + left + \",\" + right + \")\";\n}\n\nstring inter(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    int c = 0;\n    while (true) {\n      if (c == 0 && tree[1][index1] == ',') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      index1++;\n    }\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++,index1++;\n    int c = 0;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ',') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      index0++;\n    }\n  } else {\n    left = inter(index0 + 1, index1 + 1);\n    int c = 0;\n    index0++, index1++;\n    while (true) {\n      if (c == 0 && tree[1][index1] == ',') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      index1++;\n    }\n    c = 0;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ',') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      index0++;\n    }\n  }\n  \n  if (tree[0][index0 + 1] == ')' || tree[1][index1 + 1] == ')') {\n    right = \"\";\n  } else {\n    right = inter(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    cin.ignore();\n    if (ex == 'i') {\n      cout << inter(0, 0) << endl;\n    } else {\n      cout << uni(0, 0) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Node {\n\nprivate:\n  Node* left;\n  Node* right;\n\npublic:\n  Node() {\n    this->left = NULL;\n    this->right = NULL;\n  }\n\n  Node(string input) {\n    \n    int level = 0;\n\n    for(int i = 0;i < input.length();i++) {\n\n      if(input[i] == '(') level++;\n\n      if(input[i] == ')') level--;\n\n      if(level == 1 && input[i] == ',') {\n\t\n\tstring leftString = input.substr(1, i-1);\n\tstring rightString = input.substr(i+1, input.length()-i-2);\n\n\tif(leftString.length() == 0) {\n\t  this->left = NULL;\n\t}\n\telse {\n\t  this->left = new Node(leftString);\n\t}\n\t\n\tif(rightString.length() == 0) {\n\t  this->right = NULL;\n\t}\n\telse {\n\t  this->right = new Node(rightString);\n\t}\n\n      }\n\t\n    }\n      \n  }\n\n  string toString() {\n\n    string res = \"\";\n\n    if(this == NULL) return \"\";\n\n    res += \"(\";\n\n    if(this->left != NULL) res += this->left->toString();\n    \n    res += \",\";\n\n    if(this->right != NULL) res += this->right->toString();\n\n    res += \")\";\n\n    return res;\n\n  }\n\n  Node* intersection(Node* other) {\n\n    Node* intersect = new Node();\n    \n    if(this->left != NULL && other->left != NULL) {\n\n      intersect->left = this->left->intersection(other->left);\n\n    }\n\n    if(this->right != NULL && other->right != NULL) {\n\n      intersect->right = this->right->intersection(other->right);\n\n    }\n\n    return intersect;\n\n  }\n\n  Node* union_(Node* other) {\n\n    Node* uni = new Node();\n\n    if(this->left != NULL && other->left != NULL) {\n\n      uni->left = this->left->union_(other->left);\n\n    }\n\n    else {\n\n      uni->left = this->left ? this->left : other->left;\n\n      \n\n    }\n\n    if(this->right != NULL && other->right != NULL) {\n\n      uni->right = this->right->union_(other->right);\n\n    }\n\n    else {\n\n      uni->right = this->right ? this->right : other->right;\n\n\n    }\n\n    return uni;\n\n  }\n\n};\n\nint main() {\n\n  string op;\n  string nodestr, otherstr;\n\n  while(cin >> op >> nodestr >> otherstr) {\n\n    Node* result;\n    Node node(nodestr), other(otherstr);\n\n    if(op == \"i\") {\n\n      result = node.intersection(&other);\n\n    }\n\n    else if(op == \"u\") {\n\n      result = node.union_(&other);\n\n    }\n\n    cout << result->toString() << endl;\n\n\n  }\n  // Node n(\"((,(,)),((,),))\");\n  // Node other(\"((,),)\");\n\n  // Node* res = n.intersection(&other);\n  // cout << res->toString() << endl;\n\n  // Node* res2 = n.union_(&other);\n  // cout << res2->toString() << endl;\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=100;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  heap[id]++;\n  if(s==\"(,)\")  return;\n  \n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;   \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n      parse(sub1, 2*id+1);\n      parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nvoid out(int th, int id){\n\n  output.push_back('(');\n\n  int ch1=0,ch2=0;//n of string of each child\n  \n  if(heap[id]>th && heap[2*id+1]>th){\n    out(th,2*id+1);\n  }\n  output.push_back(',');\n  if(heap[id]>th && heap[2*id+2]>th){\n    out(th,2*id+2);\n  }\n  \n  output.push_back(')');\n  return;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  output.clear();\n  //cout<<output<<endl;\n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0);\n  \n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  \n  while(cin>>cmd>>s1>>s2){\n    solve(cmd,s1,s2);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <climits>\n#include <cfloat>\n\n\nusing namespace std;\n\nvoid make_tree(bool* tree, int node, string s)\n{\n\tif (s.empty())\n\t\treturn;\n\n\ttree[node] = true;\n\n\tint paren = 0;\n\tint i;\n\tfor (i = 1; paren != 0 || s[i] != ','; ++i)\n\t{\n\t\tif (s[i] == '(')\n\t\t\t++paren;\n\t\telse if (s[i] == ')')\n\t\t\t--paren;\n\t}\n\tmake_tree(tree, node*2+1, s.substr(1, i-1));\n\tmake_tree(tree, node*2+2, s.substr(i+1, s.size()-2 -i));\n}\n\nvoid print_tree(bool* tree, int node)\n{\n\tif (!tree[node])\n\t\treturn;\n\n\tputchar('(');\n\tprint_tree(tree, node*2+1);\n\tputchar(',');\n\tprint_tree(tree, node*2+2);\n\tputchar(')');\n}\n\nint main()\n{\n\tconst int TreeSize = 1024;\n\tchar ope;\n\tstring s1, s2;\n\tbool tree1[TreeSize], tree2[TreeSize], opedTree[TreeSize];\n\twhile (cin >> ope >> s1 >> s2)\n\t{\n\t\tfill(tree1, tree1+TreeSize, false);\n\t\tfill(tree2, tree2+TreeSize, false);\n\n\t\tmake_tree(tree1, 0, s1);\n\t\tmake_tree(tree2, 0, s2);\n\n\t\tif (ope == 'i')\n\t\t\tfor (int i = 0; i < TreeSize; ++i)\n\t\t\t\topedTree[i] = tree1[i] & tree2[i];\n\t\telse\n\t\t\tfor (int i = 0; i < TreeSize; ++i)\n\t\t\t\topedTree[i] = tree1[i] | tree2[i];\n\n\t\tprint_tree(opedTree, 0);\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\nbool passed[100000];\n\nchar kind;\n\nstring dfs(string str){\n\tif(str==\"\")\n\t\treturn str;\n\tstack<int> s;\n\tfor(int i = 0; i < str.size(); i++){\n\t\tif(str[i]=='('){\n\t\t\ts.push(1);\n\t\t}\n\t\telse if(str[i]==')'){\n\t\t\ts.pop();\n\t\t}\n\t\telse if(str[i]==','){\n\t\t\tif(s.size()==1){\n\t\t\t\treturn '(' + dfs(str.substr(1,i-1)) + ',' + dfs(str.substr(i+1,str.size()-i-2)) + ')';\n\t\t\t}\n\t\t}\n\t}\n}\nstring dfsi(string str,string str2){\n\tif(str==\"\"||str2==\"\")\n\t\treturn \"\";\n\tstack<int> s;\n\n\tint idx1=-1;\n\tint idx2=-1;\n\tfor(int i = 0; i < str.size(); i++){\n\t\tif(str[i]=='('){\n\t\t\ts.push(1);\n\t\t}\n\t\telse if(str[i]==')'){\n\t\t\ts.pop();\n\t\t}\n\t\telse if(str[i]==','){\n\t\t\tif(s.size()==1){\n\t\t\t\tidx1=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\ts=stack<int>();\n\tfor(int i = 0; i < str2.size(); i++){\n\t\tif(str2[i]=='('){\n\t\t\ts.push(1);\n\t\t}\n\t\telse if(str2[i]==')'){\n\t\t\ts.pop();\n\t\t}\n\t\telse if(str2[i]==','){\n\t\t\tif(s.size()==1){\n\t\t\t\tidx2=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn '(' + dfsi(str.substr(1,idx1-1),str2.substr(1,idx2-1)) + ',' \n\t\t+ dfsi(str.substr(idx1+1,str.size()-idx1-2),str2.substr(idx2+1,str2.size()-idx2-2)) + ')';\n}\n\nstring dfsu(string str,string str2){\n\tif(str==\"\"&&str2==\"\")\n\t\treturn \"\";\n\tstack<int> s;\n\n\tint idx1=-1;\n\tint idx2=-1;\n\tif(str!=\"\"){\n\t\tfor(int i = 0; i < str.size(); i++){\n\t\t\tif(str[i]=='('){\n\t\t\t\ts.push(1);\n\t\t\t}\n\t\t\telse if(str[i]==')'){\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\telse if(str[i]==','){\n\t\t\t\tif(s.size()==1){\n\t\t\t\t\tidx1=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(str2!=\"\"){\n\t\ts=stack<int>();\n\t\tfor(int i = 0; i < str2.size(); i++){\n\t\t\tif(str2[i]=='('){\n\t\t\t\ts.push(1);\n\t\t\t}\n\t\t\telse if(str2[i]==')'){\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\telse if(str2[i]==','){\n\t\t\t\tif(s.size()==1){\n\t\t\t\t\tidx2=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(idx1==-1&&idx2!=-1){\n\t\treturn '(' + dfs(str2.substr(1,idx2-1)) + ',' \n\t\t+ dfs((str2.substr(idx2+1,str2.size()-idx2-2))) + ')';\n\t}\n\telse if(idx1!=-1&&idx2==-1){\n\t\treturn '(' + dfs(str.substr(1,idx1-1)) + ','\n\t\t+ dfs((str.substr(idx1+1,str.size()-idx1-2))) + ')';\n\t}\n\treturn '(' + dfsu(str.substr(1,idx1-1),str2.substr(1,idx2-1)) + ',' \n\t\t+ dfsu(str.substr(idx1+1,str.size()-idx1-2),str2.substr(idx2+1,str2.size()-idx2-2)) + ')';\n}\n\n\n\nint main(){\n\n\tstring str1,str2;\n\twhile(cin>>kind>>str1>>str2){\n\t\t//string st=dfs(str1);\n\t\t//dfs(str2);\n\t\tstring st;\n\t\tif(kind=='i')\n\t\t\tst=dfsi(str1,str2);\n\t\telse{\n\t\t\tst=dfsu(str1,str2);\n\t\t}\n\t\tcout<<st<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nstring tree[2];\nbool node[2][100][100];\n\nstring uni(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    if (tree[1][index1] != ',') \n      for (;tree[1][index1] != ','; index1++) {\n\tleft = left + tree[1][index1];\n      }\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[0][index0] != ','; index0++) {\n      left = left + tree[0][index0];\n    }\n  } else {\n    left = uni(index0 + 1, index1 + 1);\n    for (;tree[0][index0] != ','; index0++);\n    for (;tree[0][index1] != ','; index1++);\n  }\n\n  if (tree[0][index0 + 1] == ')') {\n    index1++;\n    if (tree[1][index1] != ')') {\n      int c = 0;\n      for (;; index1++) {\n\tif (c <= 1 && tree[1][index1] == ')') {\n\t  right = right + tree[1][index1];\n\t  break;\n\t}\n\tif (tree[1][index1] == '(') {c++;}\n\tif (tree[1][index1] == ')') {c--;}\n\tright = right + tree[1][index1];\n      }\n    } else {\n      right = \"\";\n    }\n  } else if (tree[1][index1 + 1] == ')') {\n    index0++, index1++;\n    int c = 0;\n    for (;; index0++) {\n      if (c <= 1 && tree[0][index0] == ')') {\n\tright = right + tree[0][index0];\n\tbreak;\n      }\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      right = right + tree[0][index0];\n    }\n  } else {\n    right = uni(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nstring inter(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[1][index1] != ','; index1++);\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[0][index0] != ','; index0++);\n  } else {\n    left = inter(index0 + 1, index1 + 1);\n    for (;tree[0][index0] != ','; index0++);\n    for (;tree[0][index1] != ','; index1++);\n  }\n\n  if (tree[0][index0 + 1] == ')') {\n    index0++, index1++;\n    int c = 0;\n    for (;tree[1][index1] != ')' && c != 1; index1++) {\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n    }\n  } else if (tree[1][index1 + 1] == ')') {\n    index0++, index1++;\n    int c = 0;\n    for (;tree[0][index0] != ')' && c != 1; index0++) {\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n    }\n  } else {\n    right = inter(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    if (ex == 'i') {\n      cout << inter(0, 0) << endl;\n    } else {\n      cout << uni(0, 0) << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Node{\n\tNode *left,*right;\n\t\n\tNode():left(0),right(0){}\n\tNode(Node* l,Node* r):left(l),right(r){}\n\t~Node(){delete left;delete right;}\n};\n\nint parse(const string& s,int index,Node* n)\n{\n\tindex++;\n\tif(s[index]=='('){\n\t\tn->left=new Node;\n\t\tindex=parse(s,index,n->left);\n\t}\n\tindex++;\n\tif(s[index]=='('){\n\t\tn->right=new Node;\n\t\tindex=parse(s,index,n->right);\n\t}\n\tindex++;\n\treturn index;\n}\n\nvoid print(Node* n)\n{\n\tif(!n)\n\t\treturn;\n\t//if(!n->left && !n->right){\n\t//\tprintf(\"o\");\n\t//\treturn;\n\t//}\n\tprintf(\"(\");\n\tprint(n->left);\n\tprintf(\",\");\n\tprint(n->right);\n\tprintf(\")\");\n}\n\nNode* tree_and(Node* n1,Node* n2)\n{\n\tif(!n1 || !n2)\n\t\treturn NULL;\n\tNode* n=new Node;\n\tif(n1->left && n2->left)\n\t\tn->left=tree_and(n1->left,n2->left);\n\tif(n1->right && n2->right)\n\t\tn->right=tree_and(n1->right,n2->right);\n\treturn n;\n}\n\nNode* tree_or(Node* n1,Node* n2)\n{\n\tif(!n1 && !n2)\n\t\treturn NULL;\n\tNode* n=new Node;\n\tif(n1 && n2){\n\t\tif(n1->left || n2->left)\n\t\t\tn->left=tree_or(n1->left,n2->left);\n\t\tif(n1->right || n2->right)\n\t\t\tn->right=tree_or(n1->right,n2->right);\n\t}\n\telse if(n1){\n\t\tif(n1->left)\n\t\t\tn->left=tree_or(n1->left,NULL);\n\t\tif(n1->right)\n\t\t\tn->right=tree_or(n1->right,NULL);\n\t}\n\telse{\n\t\tif(n2->left)\n\t\t\tn->left=tree_or(NULL,n2->left);\n\t\tif(n2->right)\n\t\t\tn->right=tree_or(NULL,n2->right);\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tfor(string op,s1,s2;cin>>op>>s1>>s2;){\n\t\t//dump(s1);\n\t\t//dump(s2);\n\t\tNode n1,n2;\n\t\tparse(s1,0,&n1);\n\t\tparse(s2,0,&n2);\n\t\t//print(&n1);puts(\"\");\n\t\t//print(&n2);puts(\"\");\n\t\t\n\t\tNode* res;\n\t\tif(op==\"i\")\n\t\t\tres=tree_and(&n1,&n2);\n\t\telse\n\t\t\tres=tree_or(&n1,&n2);\n\t\tprint(res);puts(\"\");\n\t\t\n\t\tdelete res;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\npair<string,string> get_subtree(string tree) {\n    tree.erase(tree.begin());\n    tree.erase(tree.end()-1);\n    int point = 0;\n    for (int i = 0, count = 0; i < tree.size(); i++) {\n        if (tree[i] == '(') count++;\n        else if (tree[i] == ')') count--;\n        else if (!count) {\n            point = i;\n            break;\n        }\n    }\n\n    auto sub1 = string(tree.begin(), tree.begin() + point);\n    auto sub2 = string(tree.begin() + point + 1, tree.end());\n\n    return make_pair(sub1, sub2);\n}\n\nstring pro_i(string t1, string t2) {\n    if (t1 == \"\" || t2 == \"\") return \"\";\n\n    auto p_subtree1 = get_subtree(t1);\n    auto p_subtree2 = get_subtree(t2);\n\n    return \"(\" + pro_i(p_subtree1.first, p_subtree2.first) + \",\" + pro_i(p_subtree1.second, p_subtree2.second) + \")\";\n}\n\nstring pro_u(string t1, string t2) {\n    if (t1 == \"\") return t2;\n    if (t2 == \"\") return t1;\n\n\n    auto p_subtree1 = get_subtree(t1);\n    auto p_subtree2 = get_subtree(t2);\n\n    return \"(\" + pro_u(p_subtree1.first, p_subtree2.first) + \",\" + pro_u(p_subtree1.second, p_subtree2.second) + \")\";\n}\n\nint main() {\n    char s;\n    string t1, t2;\n    while (cin >> s >> t1 >> t2) {\n        if (s == 'i') cout << pro_i(t1, t2) << endl;\n        else cout << pro_u(t1, t2) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct Tree\n{\n  bool root;\n  bool child[2];\n  Tree *next[2];//left -> false, right -> true\n  Tree()\n  {\n    child[0] = child[1] = false;\n    root=false;\n  }\n};\n\nstring s[2];\nTree tree[2];\n\nvoid init()\n{\n  tree[0].root = tree[1].root = true;\n}\n\n\nvoid parse(int index,int &pos,Tree *t,int depth)\n{\n  if(pos >= s[index].size())return;\n  assert(s[index][pos] == '('); \n  bool LR = false;\n\n  ++pos;\n  while(pos < s[index].size() && !(LR && s[index][pos] == ')'))\n    {\n\n      if(s[index][pos] == '(')\n\t{\n\t  t->next[LR] = new Tree;\n\t  t->next[LR]->root = false;\n\t  t->next[LR]->child[0] = t->next[LR]->child[1] = false;\n\t  t->child[LR] = true;\n\t  parse(index,pos,t->next[LR],depth+1);\n\t}\n      if(s[index][pos] == ',') LR = true;\n\t\n      ++pos;\n    }\n  ++pos;\n}\n\n\nvoid tree_walk(Tree *t,int depth)\n{\n  cout << '(';\n  if(t->child[0])tree_walk(t->next[0],depth+1);\n  cout << ',';\n  if(t->child[1])tree_walk(t->next[1],depth+1);\n  cout << ')';\n}\n\nvoid dfs_i(Tree *t1,Tree *t2,Tree *ans)\n{\n  if(t1->child[0] && t2->child[0])\n    {\n      ans->next[0] = new Tree;\n      ans->child[0] = true;\n      ans->next[0]->child[0] = ans->next[0]->child[1] = false;\n      dfs_i(t1->next[0],t2->next[0],ans->next[0]);\n    }\n\n  if(t1->child[1] && t2->child[1])\n    {\n      ans->next[1] = new Tree;\n      ans->child[1] = true;\n      ans->next[1]->child[0] = ans->next[1]->child[1] = false;\n      dfs_i(t1->next[1],t2->next[1],ans->next[1]);\n    }\n\n}\n\nvoid dfs_u(Tree *t,Tree *ans)\n{\n  if(t->child[0])\n    {\n      if(ans->child[0])\n\t{//already exists\n\t  dfs_u(t->next[0],ans->next[0]);\n\t}\n      else\n\t{//not yet\n\t  ans->next[0] = new Tree;\n\t  ans->child[0] = true;\n\t  ans->next[0]->child[0] = ans->next[0]->child[1] = false;\n\t  dfs_u(t->next[0],ans->next[0]);\n\t}\n    }\n\n  if(t->child[1])\n    {\n      if(ans->child[1])\n\t{//already exists\n\t  dfs_u(t->next[1],ans->next[1]);\n\t}\n      else\n\t{//not yet\n\t  ans->next[1] = new Tree;\n\t  ans->child[1] = true;\n\t  ans->next[1]->child[0] = ans->next[1]->child[1] = false;\n\t  dfs_u(t->next[1],ans->next[1]);\n\t}\n    }\n\n}\n\nvoid compute(char c)\n{\n  Tree ans;\n  ans.root = true;\n  ans.child[0] = ans.child[1] = false;\n  if(c == 'i')\n    {\n      dfs_i(&tree[0],&tree[1],&ans);\n      tree_walk(&ans,0);\n      cout << endl;\n    }\n  else if(c == 'u')\n    {\n      dfs_u(&tree[0],&ans);\n      dfs_u(&tree[1],&ans);\n      tree_walk(&ans,0);\n      cout << endl;\n    }\n}\n\n//deleteまわりも後で書く\n\nint main()\n{\n\n  char c;\n  while(cin >> c)\n    {\n      cin >> s[0] >> s[1];\n      init();\n\n      int pos;\n      rep(i,2)\n\t{\n\t  pos = 0;\n\t  parse(i,pos,&tree[i],0);\n\t  //cerr << \"output the tree[\" << i << \"]\" << endl;\n\t  //tree_walk(&tree[i],0);\n\t  //cout << endl;\n\t}\n\n      compute(c);\n   \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <string.h>\nusing namespace std;\n#define maxn 10005\nchar a[maxn],b[maxn];\nstruct Node\n{\n    int out;\n    int l,r;\n    Node()\n    {\n        out=l=r=-1;\n    }\n}x[maxn],y[maxn];\nint Build(string cur,int id,int f)\n{\n    //蟒コ遶狗ャャ荳?「玲?\n    if(f==0)\n    {\n        if(cur==\"\")return -1;\n        int t=1;\n        string t1=\"\",t2=\"\";\n        for(int i=1; i<cur.size(); i++)\n        {\n            if(cur[i]=='(')\n            {\n                t++;\n            }\n            else if(cur[i]==',')\n            {\n                if(t==1)\n                {\n                    x[id].l=Build(t1,id+1,f);\n                    for(int j=i+1; j<cur.size()-1; j++)\n                    {\n                        t2+=cur[j];\n                    }\n                    x[id].r=Build(t2,id+2,f);\n                    return id;\n                    break;\n                }\n            }\n            else if(cur[i]==')')\n            {\n                t--;\n            }\n            t1+=cur[i];\n        }\n    }\n    if(f==1)\n    {\n        if(cur==\"\")return -1;\n        int t=1;\n        string t1=\"\",t2=\"\";\n        for(int i=1; i<cur.size(); i++)\n        {\n            if(cur[i]=='(')\n            {\n                t++;\n            }\n            else if(cur[i]==',')\n            {\n                if(t==1)\n                {\n                    y[id].l=Build(t1,id+1,f);\n                    for(int j=i+1; j<cur.size()-1; j++)\n                    {\n                        t2+=cur[j];\n                    }\n                    y[id].r=Build(t2,id+2,f);\n                    return id;\n                    break;\n                }\n            }\n            else if(cur[i]==')')\n            {\n                t--;\n            }\n            t1+=cur[i];\n        }\n    }\n}\nvoid Out(int ix,int iy,char ch)\n{\n    if(ch=='i')\n    {\n        if(ix==-1||iy==-1)\n        {\n            return;\n        }\n        printf(\"(\");\n        if(x[ix].l!=-1&&y[iy].l!=-1)\n        {\n            Out(x[ix].l,y[iy].l,ch);\n        }\n        printf(\",\");\n        if(x[ix].r!=-1&&y[iy].r!=-1)\n        {\n            Out(x[ix].r,y[iy].r,ch);\n        }\n        printf(\")\");\n    }\n    else\n    {\n        if(ix!=-1 && iy!=-1)\n        {\n            printf(\"(\");\n            Out(x[ix].l, y[iy].l, ch);\n            printf(\",\");\n            Out(x[ix].r,y[iy].r,ch);\n            printf(\")\");\n        }\n        if(ix==-1 && iy!=-1)\n        {\n            printf(\"(\");\n            Out(-1,y[iy].l,ch);\n            printf(\",\");\n            Out(-1,y[iy].r,ch);\n            printf(\")\");\n        }\n        if(ix!=-1 && iy==-1)\n        {\n            printf(\"(\");\n            Out(x[ix].l,-1,ch);\n            printf(\",\");\n            Out(x[ix].r,-1,ch);\n            printf(\")\");\n        }\n    }\n}\n\nint main()\n{\n    char ch;\n    while(scanf(\"%c%s%s\",&ch,a,b)!=EOF)\n    {\n        getchar();\n        for(int i=0; i<maxn; i++)\n        {\n            x[i].out=x[i].l=x[i].r=-1;\n            y[i].out=y[i].l=y[i].r=-1;\n        }\n        string s1=a;\n        string s2=b;\n        Build(s1,0,0);\n        Build(s2,0,1);\n        Out(0,0,ch);\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n\nint main(){\n    std::cout << \"Hello World!\" << std::endl;\n    return 0;\n}\n        \n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n\nint main(){\n    std::cout << \"Hello World!\" << std::endl;\n    return 0;\n}\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nconst int nil = -1;\nconst int MAX_N = 256;\n\nstruct Node {\n  int l, r, cnt;\n  Node() {\n    l = r = nil;\n    cnt = 0;\n  }\n};\n\nNode v[MAX_N];\nint nodeIndex;\n\nint parse(const char *s, int n, int root) {\n  v[root].cnt++;\n  if (s[++n] != ',') {\n    if (v[root].l == nil) v[root].l = ++nodeIndex;\n    n = parse(s, n, v[root].l);\n  }\n  if (s[++n] != ')') {\n    if (v[root].r == nil) v[root].r = ++nodeIndex;\n    n = parse(s, n, v[root].r);\n  }\n  return n+1;\n}\n\nvoid print(int root, int cnt) {\n  if (v[root].cnt < cnt) return;\n  putchar('(');\n  if (v[root].l != nil) print(v[root].l, cnt);\n  putchar(',');\n  if (v[root].r != nil) print(v[root].r, cnt);\n  putchar(')');\n}\n\nint main() {\n  char t1[256], t2[256];\n  int op;\n  while ((op=getchar()) != EOF) {\n    scanf(\"%s %s\\n\", t1, t2);\n    for (int i=0;i<MAX_N;i++) v[i] = Node();\n    nodeIndex = 0;\n//    parse(t1, 0, 0);\n//    parse(t2, 0, 0);\n//    print(0, (op=='u'?1:2)); putchar('\\n');\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define MP make_pair\n#define PB push_back\n\n\nchar c;\nstring str;\nint pos;\n\nmap<int,int> tree;\n\nvoid dfs(int th){\n  tree[th]++;\n  if(str[pos+1]=='('){\n    ++pos;\n    dfs(th*2+1);\n  }\n  if(str[pos+1]==','){\n    ++pos;\n  }\n  if(str[pos+1]=='('){\n    ++pos;\n    dfs(th*2+2);\n  }\n  ++pos;\n}\n\nvoid parse(int th){\n  if((c=='i' && tree[th]==2) || (c=='u' && tree[th])){\n    cout<<'(';\n    parse(th*2+1);\n    cout<<',';\n    parse(th*2+2);\n    cout<<')';\n  }\n}\n\nmain(){\n  while(cin>>c){\n    tree.clear();\n    pos=0;\n    cin>>str;\n    dfs(0);\n    pos=0;\n    cin>>str;\n    dfs(0);\n    parse(0);\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node{\n    Node *left;\n    Node *right;\n    Node() { left = NULL, right = NULL; }\n};\n\nint findcc(string s) {\n    int dd = 0;\n    for(int i=0; i<s.length(); ++i) {\n        if(s[i] == '(') dd++;\n        else if(s[i] == ')') dd--;\n        else if(s[i] == ',' && dd == 1) return i;\n    }\n    return -1;\n}\n\nNode* parse(string s) {\n    Node *r = new Node();\n    int ff = findcc(s);\n    if(ff != 1) r->left = parse(s.substr(1,ff-1));\n    if(ff != s.length()-2) {\n        string tmp = s.substr(ff+1);\n        r->right = parse(tmp.substr(0,tmp.length()-1));\n    }\n    return r;\n}\n\nNode *intersect(Node *r1,Node *r2) {\n    Node *ret = new Node();\n    if(r1->left != NULL && r2->left != NULL)\n        ret->left = intersect(r1->left,r2->left);\n\n    if(r1->right != NULL && r2->right != NULL)\n        ret->right = intersect(r1->right,r2->right);\n\n    return ret;\n}\n\nNode* uni(Node *r1,Node *r2) {\n    if(r1 == NULL && r2 == NULL) return NULL;\n\n    Node *ret = new Node();\n    ret->left = uni(((r1 == NULL)?NULL:r1->left),(r2 == NULL)?NULL:r2->left);\n    ret->right = uni(((r1 == NULL)?NULL:r1->right),(r2 == NULL)?NULL:r2->right);\n    return ret;\n}\n\nstring toStr(Node *tree) {\n    string res = \"(\";\n    if(tree->left != NULL) res += toStr(tree->left);\n    res += \",\";\n    if(tree->right != NULL) res += toStr(tree->right);\n    res += \")\";\n    return res;\n}\n\nvoid treedel(Node *node) {\n    if(node->left != NULL) treedel(node->left);\n    if(node->right != NULL) treedel(node->right);\n    delete node;\n    return;\n}\n\nint main() {\n    string op,t1,t2;\n    while(cin>>op>>t1>>t2) {\n        Node *r1 = parse(t1);\n        Node *r2 = parse(t2);\n        Node *ans;\n        if(op == \"i\") ans = intersect(r1,r2);\n        else if(op == \"u\") ans = uni(r1,r2);\n\n        cout<<toStr(ans)<<endl;\n        treedel(r1); treedel(r2); treedel(ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <string.h>\nusing namespace std;\n#define maxn 10005\nchar a[maxn],b[maxn];\nstruct Node\n{\n    int out;\n    int l,r;\n    Node()\n    {\n        out=l=r=-1;\n    }\n}x[maxn],y[maxn];\nint Build(string cur,int id,int f)\n{\n    //蟒コ遶狗ャャ荳?「玲?\n    if(f==0)\n    {\n        if(cur==\"\")return -1;\n        int t=1;\n        string t1,t2;\n        for(int i=1; i<cur.size(); i++)\n        {\n            if(cur[i]=='(')\n            {\n                t++;\n            }\n            else if(cur[i]==',')\n            {\n                if(t==1)\n                {\n                    x[id].l=Build(t1,id+1,f);\n                    for(int j=i+1; j<cur.size()-1; j++)\n                    {\n                        t2+=cur[j];\n                    }\n                    x[id].r=Build(t2,id+2,f);\n                    break;\n                }\n            }\n            else if(cur[i]==')')\n            {\n                t--;\n            }\n            t1+=cur[i];\n        }\n    }\n   // 蟒コ遶狗ャャ荳?「玲?\n    else\n    {\n        if(cur==\"\")return -1;\n        int t=1;\n        string t1,t2;\n        for(int i=1; i<cur.size(); i++)\n        {\n            if(cur[i]=='(')\n            {\n                t++;\n            }\n            else if(cur[i]==',')\n            {\n                if(t==1)\n                {\n                    y[id].l=Build(t1,id+1,f);\n                    for(int j=i+1; j<cur.size()-1; j++)\n                    {\n                        t2+=cur[j];\n                    }\n                    y[id].r=Build(t2,id+2,f);\n                    break;\n                }\n            }\n            else if(cur[i]==')')\n            {\n                t--;\n            }\n            t1+=cur[i];\n        }\n    }\n    return id;\n}\nvoid Out(int ix,int iy,char ch)\n{\n    if(ch=='i')\n    {\n        if(ix==-1||iy==-1)\n        {\n            return;\n        }\n        printf(\"(\");\n        if(x[ix].l!=-1&&y[iy].l!=-1)\n        {\n            Out(x[ix].l,y[iy].l,ch);\n        }\n        printf(\",\");\n        if(x[ix].r!=-1&&y[iy].r!=-1)\n        {\n            Out(x[ix].r,y[iy].r,ch);\n        }\n        printf(\")\");\n    }\n    else\n    {\n        if(ix!=-1 && iy!=-1)\n        {\n            printf(\"(\");\n            \n            Out(x[ix].l, y[iy].l, ch);\n            \n            printf(\",\");\n            //Out(x[ix].r,y[iy].r,ch);\n            printf(\")\");\n        }\n    }\n//        if(ix==-1&&iy!=-1)//iy譛?//        {\n//            printf(\"(\");\n//            Out(-1,y[iy].l,ch);\n//            printf(\",\");\n//            Out(-1,y[iy].r,ch);\n//            printf(\")\");\n//        }\n//        if(ix!=-1&&iy==-1)//ix譛?//        {\n//            printf(\"(\");\n//            Out(x[ix].l,-1,ch);\n//            printf(\",\");\n//            Out(x[ix].r,-1,ch);\n//            printf(\")\");\n//        }\n}\n\nint main()\n{\n    char ch;\n    while(scanf(\"%c%s%s\",&ch,a,b)!=EOF)\n    {\n        getchar();\n        for(int i=0; i<maxn; i++)\n        {\n            x[i].out=x[i].l=x[i].r=-1;\n            y[i].out=y[i].l=y[i].r=-1;\n        }\n        string s1=a;\n        string s2=b;\n        Build(s1,0,0);\n        Build(s2,0,1);\n        Out(0,0,ch);\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nstring tree[2];\nbitset<10000> node[2];\n\nvoid perse(int index, int n, int i)\n{\n  //cout << \"persed \" << n << endl;\n  if (index >= tree[i].size()) {\n    return;\n  }\n  if (tree[i][index] == '(') {\n    while (tree[i][index] == ' ') {index++;}\n    node[i][n] = true;\n    perse(index + 1, 2 * n + 1, i);\n  } else if (tree[i][index] == ')') {\n    while (tree[i][index] == ' ') {index++;}\n    perse(index + 1, (((n - 2) / 2 < 0) ? 0 : (n - 2) / 2), i);\n  } else if (\",\"){\n    while (tree[i][index] == ' ') {index++;}\n    perse(index + 1, n + 1, i);\n  }\n}\n\nstring _perse(int index)\n{\n  if (node[0][index]) {\n    return \"(\" + _perse(2 * index + 1) + \",\" + _perse(2 * index + 2) + \")\";\n  }\n  return \"\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    for (int i = 0; i < 2; i++) {\n      node[i].reset();\n      perse(0, 0, i);\n      \n      /*for (int j = 0; j < 300; j++) {\n\tif (node[i][j]) {\n\t  cout << j;\n\t}\n      }\n      cout << endl;*/\n    }\n    if (ex == 'u') {\n      node[0] |= node[1];\n    } else {\n      node[0] &= node[1];\n    }\n    cout << _perse(0) << endl;\n    cin.ignore();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n#include <algorithm>\n\nusing namespace std;\n\nstring tree[2];\n\nstring uni(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    if (tree[1][index1] != ',') \n      for (;tree[1][index1] != ','; index1++) {\n\tleft = left + tree[1][index1];\n      }\n  } else if (tree[1][index1 + 1] == ',') {\n    index1++;\n    for (;tree[0][index0] != ','; index0++) {\n      left = left + tree[0][index0];\n    }\n  } else {\n    left = uni(index0 + 1, index1 + 1);\n    for (;tree[0][index0] != ','; index0++);\n    for (;tree[1][index1] != ','; index1++);\n  }\n\n  if (tree[0][index0 + 1] == ')') {\n    int c = 0;\n    index1++;\n    while (true) {\n      if (c == 0 && tree[1][index1] == ')') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      right = right + tree[1][index1];\n      index1++;\n    }\n  } else if (tree[1][index1 + 1] == ')') {\n    int c = 0;\n    index0++;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ')') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      right = right + tree[0][index0];\n      index0++;\n    }\n  } else {\n    right = uni(index0 + 1, index1 + 1);\n  }\n  return \"(\" + left + \",\" + right + \")\";\n}\n\nstring inter(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++;\n    for (;tree[1][index1] != ','; index1++);\n  } else if (tree[1][index1 + 1] == ',') {\n    index1++;\n    for (;tree[0][index0] != ','; index0++);\n  } else {\n    left = inter(index0 + 1, index1 + 1);\n    for (;tree[0][index0] != ','; index0++);\n    for (;tree[1][index1] != ','; index1++);\n  }\n  \n  if (tree[0][index0 + 1] == ')' || tree[1][index1 + 1] == ')') {\n    right = \"\";\n  } else {\n    right = inter(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    if (ex == 'i') {\n      cout << inter(0, 0) << endl;\n    } else {\n      cout << uni(0, 0) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 105;\nstring dp[MAX][MAX];\n\nstring Intersect(const string& s1, const string& s2){\n  fill(dp[0],dp[0]+MAX*MAX,\"\");\n\n  for(int i = 0; i < (int)s1.length(); i++)\n    for(int j = 0; j < (int)s2.length(); j++){\n      if(s1[i] == s2[j]){\n\tstring nex = dp[i][j];\n     \tnex += s1[i];\n\tif(dp[i+1][j+1].length() < nex.length())dp[i+1][j+1] = nex;\n      }else{\n\tif(dp[i+1][j+1].length() < dp[i][j].length()) dp[i+1][j+1] = dp[i][j];\n\tif(dp[i+1][j+1].length() < dp[i+1][j].length()) dp[i+1][j+1] = dp[i+1][j];\n\tif(dp[i+1][j+1].length() < dp[i][j+1].length()) dp[i+1][j+1] = dp[i][j+1];\n      }\n    }\n\n  return dp[s1.length()][s2.length()];\n}\n\nint getRank(char c){\n  string s = \"(,)\";\n  for(int i = 0; i < (int)s.length(); i++) if(s[i] == c) return i-1;\n  return -1;\n}\nstring Union(const string& s1, const string& s2){\n  int p1 = 0, p2 = 0;\n  int d1 = 0, d2 = 0;\n  string ans = \"\";\n  \n  while(p1 <= (int)s1.length() && p2 <= (int)s2.length()){\n    if(s1[p1] == s2[p2]){\n      ans += s1[p1];\n      d1 -= getRank(s1[p1++]);\n      d2 -= getRank(s2[p2++]);\n    }else{\n\n      if(d1 == d2){\n\tint r1 = getRank(s1[p1]);\n\tint r2 = getRank(s2[p2]);\n\n\tif(r1 < r2){\n\t  d1 -= getRank(s1[p1]);\n\t  ans += s1[p1++];\n\t}else{\n\t  d2 -= getRank(s2[p2]);\n\t  ans += s2[p2++];\n\t}\n      }else{\n\tif(d1 > d2){\n\t  d1 -= getRank(s1[p1]);\n\t  ans += s1[p1++];\n\t}else{\n\t  d2 -= getRank(s2[p2]);\n\t  ans += s2[p2++];\n\t}\n      }\n    }\n  }\n  \n  return ans;\n}\n\nint main(){\n  char c;\n  string s1, s2;\n  while(cin >> c >> s1 >> s2){\n    if(c == 'i') cout << Intersect(s1,s2) << endl;\n    if(c == 'u') cout << Union(s1,s2) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\nusing namespace std;\n\n#define SIZE 10000\n\nvector <int> getTree( string in )\n{\n\tvector <int> tree( SIZE, 0 );\n\n\tint n = 1;\n\tint lr = 0;\n\tstack <int> lrs;\n\n\tfor ( string::iterator it = in.begin(); it != in.end(); it++ )\n\t{\n\t\tswitch( *it )\n\t\t{\n\t\tcase '(':\n\t\t\tn *= 2;\n\t\t\t// tree[n+lr] = 1;\n\t\t\tlrs.push( lr );\n\t\t\tlr = 0;\n\t\t\tbreak;\n\n\t\tcase ')':\n\t\t\tn /= 2;\n\t\t\tlr = lrs.top();\n\t\t\tlrs.pop();\n\t\t\tbreak;\n\n\t\tcase ',':\n\t\t\tlr++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn tree;\n}\n\nvoid printTree( vector <int> &tree, int node )\n{\n\tcout << \"(\";\n\tif ( tree[node*2] == 1 )\n\t{\n\t\tprintTree( tree, node*2 );\n\t}\n\tcout << \",\";\n\tif ( tree[node*2+1] == 1 )\n\t{\n\t\tprintTree( tree, node*2+1 );\n\t}\n\tcout << \")\";\n}\n\nvector <int> intersectionTree( vector <int> &a, vector <int> &b )\n{\n\tvector <int> tree( SIZE, 0 );\n\tfor ( int i = 0; i < SIZE; i++ )\n\t\tif ( a[i] == 1 && b[i] == 1 )\n\t\t\ttree[i] = 1;\n\treturn tree;\n}\n\nvector <int> unionTree( vector <int> &a, vector <int> &b )\n{\n\tvector <int> tree( SIZE, 0 );\n\tfor ( int i = 0; i < SIZE; i++ )\n\t\tif ( a[i] == 1 || b[i] == 1 )\n\t\t\ttree[i] = 1;\n\treturn tree;\n}\n\nint main( void )\n{\n\tstring type;\n\tstring in_a;\n\tstring in_b;\n\n\twhile ( cin >> type >> in_a >> in_b )\n\t{\n\t\tvector <int> a = getTree( in_a );\n\t\tvector <int> b = getTree( in_b );\n\n\t\tvector <int> c;\n\t\tif ( type == \"i\" )\n\t\t{\n\t\t\tc = intersectionTree( a, b );\n\t\t}\n\t\telse if ( type == \"u\" )\n\t\t{\n\t\t\tc = unionTree( a, b );\n\t\t}\n\t\tprintTree( c, 2 );\n\t\tcout << endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nvector <int> getTree( string in )\n{\n\tvector <int> tree( 1000, 0 );\n\n\tint n = 0;\n\tint lr = 0;\n\tstack <int> lrs;\n\n\tfor ( string::iterator it = in.begin(); it != in.end(); it++ )\n\t{\n\t\tswitch( *it )\n\t\t{\n\t\tcase '(':\n\t\t\tif ( n == 0 )\n\t\t\t\tn = 1;\n\t\t\telse\n\t\t\t\tn *= 2;\n\t\t\ttree[n+lr] = 1;\n\t\t\tlrs.push( lr );\n\t\t\tlr = 0;\n\t\t\tbreak;\n\n\t\tcase ')':\n\t\t\tlr = lrs.top();\n\t\t\tlrs.pop();\n\t\t\tn /= 2;\n\t\t\tbreak;\n\n\t\tcase ',':\n\t\t\tlr++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn tree;\n}\n\nvoid printTree( vector <int> &tree, int node )\n{\n\tcout << \"(\";\n\tif ( tree[node*2] == 1 )\n\t{\n\t\tprintTree( tree, node*2 );\n\t}\n\tcout << \",\";\n\tif ( tree[node*2+1] == 1 )\n\t{\n\t\tprintTree( tree, node*2+1 );\n\t}\n\tcout << \")\";\n}\n\nvector <int> intersectionTree( vector <int> &a, vector <int> &b )\n{\n\tvector <int> tree( 1000, 0 );\n\tfor ( int i = 0; i < 1000; i++ )\n\t\tif ( a[i] == 1 && b[i] == 1 )\n\t\t\ttree[i] = 1;\n\treturn tree;\n}\n\nvector <int> unionTree( vector <int> &a, vector <int> &b )\n{\n\tvector <int> tree( 1000, 0 );\n\tfor ( int i = 0; i < 1000; i++ )\n\t\tif ( a[i] == 1 || b[i] == 1 )\n\t\t\ttree[i] = 1;\n\treturn tree;\n}\n\nint main( void )\n{\n\tstring type;\n\tstring in_a;\n\tstring in_b;\n\n\twhile ( cin >> type >> in_a >> in_b )\n\t{\n\t\tvector <int> a = getTree( in_a );\n\t\tvector <int> b = getTree( in_b );\n\n\t\tvector <int> c;\n\t\tif ( type == \"i\" )\n\t\t{\n\t\t\tc = intersectionTree( a, b );\n\t\t}\n\t\telse if ( type == \"u\" )\n\t\t{\n\t\t\tc = unionTree( a, b );\n\t\t}\n\t\tprintTree( c, 1 );\n\t\tcout << endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n\nint main(){\n    std::cout << \"Hello World!\" << std::endl;\n    return 0;\n}\n        \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstring a,b,z;\nint d;\nstring ans;\nbool flgA[5000000];\nbool flgB[5000000];\n\nvoid rec(int x){\n\n  ans.push_back('(');\n\n  if(flgA[x*2]==true){\n    rec(x*2);\n  }\n  ans.push_back(',');\n  if(flgA[x*2+1]==true){\n    rec(x*2+1);\n  }\n\n  ans.push_back(')');\n}\n\n\nint main(){\n  while(cin>>z){\n\n    cin>>a;\n    for(int i=0;i<5000000;i++)flgA[i]=flgB[i]=false;\n    flgA[1]=flgB[1]=true;\n    \n    d=1;\n    for(int i=0;i<(int)a.size();i++){\n      if(a[i]=='('){\n\tflgA[d]=true;\n\td*=2;\n      }else if(a[i]==','){\n\td=d+1;\n      }else{\n\td/=2;\n      }\n    }\n    \n      cin>>b;\n      d=1;\n      for(int i=0;i<(int)b.size();i++){\n      if(b[i]=='('){\n\tflgB[d]=true;\n\td*=2;\n      }else if(b[i]==','){\n\td=d+1;\n      }else{\n\td/=2;\n      }\n    }\n    \n\n    for(int i=0;i<5000000;i++){\n      if(flgB[i]==false){\n\tif(z==\"i\"){\n\t  flgA[i]=false;\n\t}\n      }else{\n\tif(z==\"u\"){\n\t  flgA[i]=true;\n\t}\n      }\n\n    }\n\n    ans=\"\";\n    rec(1);\n    cout<<ans<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n\nusing namespace std;\n\nconst int SIZE = 128;\nbool A[SIZE],B[SIZE],C[SIZE];\n\nint getPos(const string& s){\n  int p = 0;\n  for(int i = 0; i < (int)s.length(); i++){\n    if(s[i] == '(') p++;\n    else if(s[i] == ')') p--;\n    if(p == 0 && s[i] == ',') return i;\n  }\n  return -1;\n}\n\nvoid parse(const string& s, bool* tree, int idx){\n  if(s == \"\") return;\n  tree[idx] = true;\n  string nex = s.substr(1,s.length()-2);\n  int pos = getPos(nex);\n  string left = nex.substr(0,pos);\n  string right = nex.substr(pos+1);\n  parse(left,tree,2*idx+1);\n  parse(right,tree,2*idx+2);\n}\n\nstring makeTree(bool* tree, int idx){\n  if(!tree[idx]) return \"\";\n  string res = \"\";\n  if(2*idx+1 < SIZE) res += makeTree(tree,2*idx+1);\n  res += \",\";\n  if(2*idx+2 < SIZE) res += makeTree(tree,2*idx+2);\n  res = \"(\" + res + \")\";\n  return res;\n}\n\nint main(){\n\n  char c;\n  string a,b;\n  while(cin >> c >> a >> b){\n    memset(A,false,sizeof(A));\n    memset(B,false,sizeof(B));\n    memset(C,false,sizeof(C));\n    parse(a,A,0);\n    parse(b,B,0);\n    if(c=='i') for(int i = 0; i < SIZE; i++) C[i] = A[i]&&B[i];\n    else for(int i = 0; i < SIZE; i++) C[i] = A[i]||B[i];\n    cout << makeTree(C,0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nconst int nil = -1;\nconst int MAX_N = 256;\n\nstruct Node {\n  int l, r, cnt;\n  Node() {\n    l = r = nil;\n    cnt = 0;\n  }\n};\n\nNode v[MAX_N];\nint nodeIndex;\n/*\nint parse(const char *s, int n, int root) {\n  v[root].cnt++;\n  if (s[++n] != ',') {\n    if (v[root].l == nil) v[root].l = ++nodeIndex;\n    n = parse(s, n, v[root].l);\n  }\n  if (s[++n] != ')') {\n    if (v[root].r == nil) v[root].r = ++nodeIndex;\n    n = parse(s, n, v[root].r);\n  }\n  return n+1;\n}\n\nvoid print(int root, int cnt) {\n  if (v[root].cnt < cnt) return;\n  putchar('(');\n  if (v[root].l != nil) print(v[root].l, cnt);\n  putchar(',');\n  if (v[root].r != nil) print(v[root].r, cnt);\n  putchar(')');\n}\n*/\nint main() {\n  char op[10], t1[256], t2[256];\n  while (scanf(\"%s %s %s\", op, t1, t2) == 3) {\n    for (int i=0;i<MAX_N;i++) v[i] = Node();\n    nodeIndex = 0;\n//    parse(t1, 0, 0);\n//    parse(t2, 0, 0);\n//    print(0, (op=='u'?1:2)); putchar('\\n');\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <string>\n#include <stack>\nusing namespace std;\n\nconst int maxn=1000;\n\nint f[maxn],g[maxn];\nbool p[maxn],q[maxn];\nstack <int> s;\nstring s1,s2;\nstring c;\nint  l1,l2;\n\nstring dfs(int i,int k)\n{\n    string lchild = \"\",rchild = \"\";\n    if (k==1)\n    {\n        if (f[2*i]!=-1) lchild = dfs(f[2*i],1);\n        if (f[2*i+1]!=-1) rchild = dfs(f[2*i+1],1);\n    }\n    else\n    {\n        if (g[2*i]!=-1) lchild = dfs(g[2*i],2);\n        if (g[2*i+1]!=-1) rchild = dfs(g[2*i+1],2);\n    }\n    return \"(\" + lchild + \",\" + rchild + \")\";\n}\n\n\nstring dfs1(int i,int j)\n{\n    string lchild = \"\",rchild = \"\";\n    if (f[2*i]!=-1 && g[2*j]!=-1) lchild = dfs1(f[2*i],g[2*j]);\n    if (f[2*i+1]!=-1 && g[2*j+1]!=-1) rchild = dfs1(f[2*i+1],g[2*j+1]);\n\n    return \"(\" + lchild + \",\" + rchild + \")\";\n}\n\nstring dfs2(int i,int j)\n{\n    string lchild = \"\",rchild = \"\";\n\n\n    if (f[2*i]!=-1 || g[2*i]!=-1)\n    {\n        if (f[2*i]!=-1 && g[2*i]!=-1) lchild = dfs2(f[2*i],g[2*i]);\n        else if (f[2*i]!=-1) lchild = dfs(f[2*i],1);\n        else if (g[2*i]!=-1) lchild = dfs(g[2*i],2);\n    }\n    if (f[2*i+1]!=-1 || g[2*i+1]!=-1)\n    {\n        if (f[2*i+1]!=-1 && g[2*i+1]!=-1) rchild = dfs2(f[2*i+1],g[2*i+1]);\n        else if (f[2*i+1]!=-1) rchild = dfs(f[2*i+1],1);\n        else if (g[2*i+1]!=-1) rchild = dfs(g[2*i+1],2);\n    }\n    string ans = \"(\" + lchild + \",\" + rchild + \")\";\n    //cout<<i<<\" \"<<ans<<endl;\n    return \"(\" + lchild + \",\" + rchild + \")\";\n}\n\n\nint main()\n{\n    while (cin>>c>>s1>>s2)\n    {\n        l1 = s1.length(); l2 = s2.length();\n\n        memset(f,-1,sizeof(f));\n        memset(g,-1,sizeof(g));\n        memset(p,true,sizeof(p));\n        memset(q,true,sizeof(q));\n\n        while (!s.empty()) s.pop();\n\n        int i=0; int cnt=0;\n        while (i < l1)\n        {\n            if (s1[i] == '(')\n            {\n                cnt++;\n                s.push(cnt);\n\n                if (i+1 < l1 && s1[i+1]==',')\n                {\n                    cnt++;\n                    p[cnt]=false;\n                }\n\n            }\n            else if (s1[i]==')')\n            {\n\n                int ch = s.top(); s.pop();\n                if (!s.empty())\n                {\n                    int fa = s.top();\n                    if (ch==fa+1) f[2*fa]=ch;\n                    else f[2*fa+1] = ch;\n                }\n            }\n            else if (s1[i]==',')\n            {\n                if (i+1 < l1 && s1[i+1]==')')\n                {\n                    cnt++;\n                    p[cnt]=false;\n                }\n            }\n            i++;\n        }\n\n\n        //for (int i=1;i<=cnt;i++)  if (p[i]) cout<<i<<\" \"<<f[2*i]<<\" \"<<f[2*i+1]<<endl;\n\n        while (!s.empty()) s.pop();\n        i = 0; cnt = 0;\n        while (i < l2)\n        {\n            if (s2[i] == '(')\n            {\n                cnt++;\n                s.push(cnt);\n                if (i+1 < l2 && s2[i+1]==',')\n                {\n                    cnt++;\n                    q[cnt]=false;\n                }\n            }\n            else if (s2[i]==')')\n            {\n                int ch = s.top(); s.pop();\n                if (!s.empty())\n                {\n                    int fa = s.top();\n                    if (ch==fa+1) g[2*fa] = ch;\n                    else g[2*fa+1] = ch;\n                }\n            }\n            else if (s2[i]==',')\n            {\n                if (i+1 < l2 && s2[i+1]==')')\n                {\n                    cnt++;\n                    q[cnt]=false;\n                }\n            }\n            i++;\n        }\n\n        //for (int i=1;i<=cnt;i++) if (q[i]) cout<<i<<\" \"<<g[2*i]<<\" \"<<g[2*i+1]<<endl;\n\n        if (c[0]=='i') cout<<dfs1(1,1)<<endl;\n        else cout<<dfs2(1,1)<<endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstring tree_op(string t1, string t2, string op)\n{\n  if (t1.empty())\n    if (op == \"i\") return \"\";\n    else return t2;\n  if (t2.empty())\n    if (op == \"i\") return \"\";\n    else return t1;\n\n  int n1 = 0, n2 = 0;\n  int p1 = 0, p2 = 0;\n  while (1)\n  {\n    if (t1[p1] == '(') n1++;\n    else if (t1[p1] == ')') n1--;\n    else if (t1[p1] == ',') if (n1 == 1) break;\n    p1++;\n  }\n  while (1)\n  {\n    if (t2[p2] == '(') n2++;\n    else if (t2[p2] == ')') n2--;\n    else if (t2[p2] == ',') if (n2 == 1) break;\n    p2++;\n  }\n\n  return \"(\" + tree_op(t1.substr(1, p1-1), t2.substr(1, p2-1), op) + \",\" +\n    tree_op(t1.substr(p1+1, t1.size()-2-p1), t2.substr(p2+1, t2.size()-2-p2), op)\n    + \")\";\n}\n\nstring union_tree(string t1, string t2)\n{\n  if (t1.empty()) return t2;\n  if (t2.empty()) return t1;\n  int n1 = 0, n2 = 0;\n  int p1 = 0, p2 = 0;\n  while (1)\n  {\n    if (t1[p1] == '(') n1++;\n    else if (t1[p1] == ')') n1--;\n    else if (t1[p1] == ',') if (n1 == 1) break;\n    p1++;\n  }\n  while (1)\n  {\n    if (t2[p2] == '(') n2++;\n    else if (t2[p2] == ')') n2--;\n    else if (t2[p2] == ',') if (n2 == 1) break;\n    p2++;\n  }\n  return \"(\" + union_tree(t1.substr(1, p1-1), t2.substr(1, p2-1)) + \",\" +\n    union_tree(t1.substr(p1+1, t1.size()-2-p1), t2.substr(p2+1, t2.size()-2-p2))\n    + \")\";\n}\n\n\nint main()\n{\n  string str;\n  string op;\n\n  while (getline(cin,str))\n  {\n    op = str[0];\n\n    int k=1;\n    while (str[k]==' ') k++;\n\n    string tree1, tree2;\n    while (str[k] != ' ')\n    {\n      tree1.push_back(str[k]);\n      k++;\n    }\n    while (str[k]==' ') k++;\n    while (k < str.size())\n    {\n      tree2.push_back(str[k]);\n      k++;\n    }\n    cout << tree_op(tree1, tree2, op) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct node{\n  node *left,*right;\n  node(){left=right=NULL;}\n};\nnode* construct(string s,int l,int r){\n  node* res=new node();\n  int op=0,c=-1;\n  for(int i=l+1;i<r-1;i++){\n    if(s[i]=='(') op++;\n    if(s[i]==')') op--;\n    if(s[i]==','&&op==0){\n      c=i;\n      break;\n    } \n  }\n  if(l+1!=c)   res->left =construct(s,l+1,c);\n  if(r-1!=c+1) res->right=construct(s,c+1,r-1);\n  return res;\n};\nstring inte(node* a,node* b){\n  string l,r;\n  if(a->left!=NULL&&b->left!=NULL)\n    l=inte(a->left,b->left);\n  if(a->right!=NULL&&b->right!=NULL)\n    r=inte(a->right,b->right);\n  return \"(\"+l+\",\"+r+\")\";\n}\nstring unio(node* a,node* b){\n  string l,r;\n  if((a!=NULL&&a->left!=NULL)||(b!=NULL&&b->left!=NULL))\n    l=unio((a!=NULL?a->left:a),(b!=NULL?b->left:b));\n  if((a!=NULL&&a->right!=NULL)||(b!=NULL&&b->right!=NULL))\n    r=unio((a!=NULL?a->right:a),(b!=NULL?b->right:b));\n  return  \"(\"+l+\",\"+r+\")\";\n}\nsigned main(){\n  string c,s,t;\n  while(cin>>c>>s>>t){\n    node* a=construct(s,0,s.size());\n    node* b=construct(t,0,t.size());\n    if(c==\"i\") cout<<inte(a,b)<<endl;\n    else if(c==\"u\") cout<<unio(a,b)<<endl;\n    else assert(0);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#coding : utf-8\n\n# version 1.0 2017/02/10  ??????????????¨???????????????\n# version 1.1 2017/02/11???????????????????°????????????????????????¶??§??????\n# version 1.2 2017/02/11???AOJ??????????????°??????\n# version 1.3 2017/02/12  ?§£????????????????????????????????¨?????§?????????????????????\n\nimport requests,sys\nimport time\nfrom selenium import webdriver\nfrom bs4 import BeautifulSoup\nimport xerox\n\ndef main():\n    print(\"Hello! This is The AOJ Chaser!\")\n    user_url='http://judge.u-aizu.ac.jp/onlinejudge/webservice/user'\n    problem_url='http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id='\n\n    # ????´¢?????????id?????\\???\n    rival_id='minaminao'\n    my_id='oshibori'\n    my_password='1225tomoki'\n    if not my_id :\n        print('Input your id!', end=' ')\n        my_id=input()\n    if not my_password :\n        print('Input your password!', end=' ')\n        my_password=input()\n    if not rival_id :\n        print('Input your rival\\'s id!', end=' ')\n        rival_id=input()\n\n\n\n    # ??????????????????\n    myparams={'id':my_id}                   #  ME\n    mydata=requests.get(user_url,params=myparams)\n    rivalparams={'id':rival_id}               #  RIVAL\n    rivaldata=requests.get(user_url,params=rivalparams)\n\n    # ??????????????????\n    mysoup=BeautifulSoup(mydata.text,\"html.parser\")\n    rivalsoup=BeautifulSoup(rivaldata.text,\"html.parser\")\n    table={}\n    cnt=0\n    result_list=[]\n    for i in mysoup.findAll('problem'):\n        table[int(i.id.string)]=1;\n\n    for i in rivalsoup.findAll('problem'):\n        x=int(i.id.string)\n        try:\n            table[x]=table[x]-1\n        except:\n            print(x)\n\n            result_list.append([int(i.judge_id.string),i.id.string])\n            cnt=cnt+1\n\n\n    print('')\n\n    result_list.sort(key=lambda x:x[0])\n    #result_list.sort(key=lambda x:x[1])\n    #for i in result_list:\n    #    print(i[1])\n    print('Sum is ',end='')\n    print(cnt)\n\n    index=0\n    while True:\n        #??????????????¶?????????\n        browser=webdriver.Chrome('./chromedriver')\n        #?????????????????¨?§?\n        browser.get(problem_url + result_list[index][1])\n        # ?????°??????\n        loginform=browser.find_element_by_id('user')\n        loginform.find_element_by_id('login').click()\n\n        loginUserID=loginform.find_element_by_name('loginUserID')\n        loginPassword=loginform.find_element_by_name('loginPassword')\n\n        loginUserID.send_keys(my_id)\n        loginPassword.send_keys(my_password)\n\n        logininput=loginform.find_element_by_id('logininput')\n        logininput.submit()\n        index=index+1\n\n        #???????????????\n        submit_url='http://judge.u-aizu.ac.jp/onlinejudge/status.jsp#submit/'+ result_list[index][1]\n        if browser.current_url == submit_url:\n            submit_area=browser.find_element_by_id('submitArea')\n            select=submit_area.find_element_by_id('submit_language')\n            select.click()\n            select.find_elements_by_tag_name('option')[4].click()  # C++14\n            select.click()\n            \n            source=submit_area.find_element_by_id('submit_source')\n            \n            \n        # ???????????????????????????????????????\n        print(browser.title)\n        print(\".....END.....\")\n\n        #????¶??¶???????\n        com = input()\n        browser.quit()\n        if com == 'done' or com == 'fin' :\n            break;\n\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nstring tree[2];\nbitset<1000> node[2];\n\nvoid perse(int index, int n, int i)\n{\n  //cout << \"persed \" << n << endl;\n  if (index == tree[i].size() - 1) {\n    return;\n  }\n  if (tree[i][index] == '(') {\n    while (tree[i][index] == ' ') {index++;}\n    node[i][n] = true;\n    perse(index + 1, 2 * n + 1, i);\n  } else if (tree[i][index] == ')') {\n    while (tree[i][index] == ' ') {index++;}\n    perse(index + 1, (((n - 2) / 2 < 0) ? 0 : (n - 2) / 2), i);\n  } else if (\",\"){\n    while (tree[i][index] == ' ') {index++;}\n    perse(index + 1, n + 1, i);\n  }\n}\n\nstring _perse(int index)\n{\n  if (node[0][index]) {\n    return \"(\" + _perse(2 * index + 1) + \",\" + _perse(2 * index + 2) + \")\";\n  }\n  return \"\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    for (int i = 0; i < 2; i++) {\n      node[i].reset();\n      perse(0, 0, i);\n      \n      /*for (int j = 0; j < 300; j++) {\n\tif (node[i][j]) {\n\t  cout << j;\n\t}\n      }\n      cout << endl;*/\n    }\n    if (ex == 'u') {\n      node[0] |= node[1];\n    } else {\n      node[0] &= node[1];\n    }\n  \n    cout << _perse(0) << endl;\n    cin.ignore();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 10000000\nusing namespace std;\nchar opr;\nstring T[2];\nbool tree[MAX][2]; //0->A, 1->B\nbool LR[MAX];\nbool A_tree[MAX];      \n\nvoid constructTree(bool which)\n{\n  int index = 1;\n  tree[index][which] = true;\n  rep(i,MAX)LR[i] = false;//false->L, true->true\n  int w = T[which].size();\n  REP(i,1,w)\n    {\n      if(T[which][i] == '(')\n\t{\n\t  index = index*2+(!LR[index]?0:1);\n\t  tree[index][which] = true;\n\t}\n      else if(T[which][i] == ',')\n\tLR[index] = true;\n      else\n\tindex /= 2;\n    }\n\n  assert(index == 0);\n}\n\nvoid constructTreePRST(string &PRST_tree,int index)\n{\n  PRST_tree += \"(\";\n  if(A_tree[index*2])constructTreePRST(PRST_tree,index*2);\n  PRST_tree += \",\";\n  if(A_tree[index*2+1])constructTreePRST(PRST_tree,index*2+1);\n  PRST_tree += \")\";\n}\n\nint main()\n{\n  while(cin >> opr >> T[0] >> T[1])\n    {\n      constructTree(false);\n      constructTree(true);\n\n     \n      if(opr == 'i')\n\t{\n\t  rep(i,MAX)\n\t    A_tree[i] = tree[i][0]&tree[i][1];\n\t}\n      else\n\t{\n\t  rep(i,MAX)\n\t    A_tree[i] = tree[i][0]|tree[i][1];\n\t}\n      string prst;\n      constructTreePRST(prst,1);\n      cout << prst << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct node{\n  node *left,*right;\n  node(){left=right=NULL;}\n};\nnode* construct(string s,int l,int r){\n  node* res=new node();\n  int op=0,c=-1;\n  for(int i=l+1;i<r-1;i++){\n    if(s[i]=='(') op++;\n    if(s[i]==')') op--;\n    if(s[i]==','&&op==0){\n      c=i;\n      break;\n    } \n  }\n  if(l+1!=c)   res->left =construct(s,l+1,c);\n  if(r-1!=c+1) res->right=construct(s,c+1,r-1);\n  return res;\n};\nstring inte(node* a,node* b){\n  string l,r;\n  if(a->left!=NULL&&b->left!=NULL)\n    l=inte(a->left,b->left);\n  if(a->right!=NULL&&b->right!=NULL)\n    l=inte(a->right,b->right);\n  return \"(\"+l+\",\"+r+\")\";\n}\nstring unio(node* a,node* b){\n  string l,r;\n  if((a!=NULL&&a->left!=NULL)||(b!=NULL&&b->left!=NULL))\n    l=unio((a!=NULL?a->left:a),(b!=NULL?b->left:b));\n  if((a!=NULL&&a->right!=NULL)||(b!=NULL&&b->right!=NULL))\n    r=unio((a!=NULL?a->right:a),(b!=NULL?b->right:b));\n  return  \"(\"+l+\",\"+r+\")\";\n}\nsigned main(){\n  string c,s,t;\n  while(cin>>c>>s>>t){\n    node* a=construct(s,0,s.size());\n    node* b=construct(t,0,t.size());\n    if(c==\"i\") cout<<inte(a,b)<<endl;\n    else cout<<unio(a,b)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\nusing namespace std;\n\n#define SIZE 10000\n\nvector <int> getTree( string in )\n{\n\tvector <int> tree( SIZE, 0 );\n\n\tint n = 1;\n\tint lr = 0;\n\tstack <int> lrs;\n\n\tfor ( string::iterator it = in.begin(); it != in.end(); it++ )\n\t{\n\t\tswitch( *it )\n\t\t{\n\t\tcase '(':\n\t\t\tn *= 2;\n\t\t\ttree[n+lr] = 1;\n\t\t\tlrs.push( lr );\n\t\t\tlr = 0;\n\t\t\tbreak;\n\n\t\tcase ')':\n\t\t\tn /= 2;\n\t\t\tlr = lrs.top();\n\t\t\tlrs.pop();\n\t\t\tbreak;\n\n\t\tcase ',':\n\t\t\tlr++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn tree;\n}\n\nvoid printTree( vector <int> &tree, int node )\n{\n\t/*\n\tcout << \"(\";\n\tif ( tree[node*2] == 1 )\n\t{\n\t\tprintTree( tree, node*2 );\n\t}\n\tcout << \",\";\n\tif ( tree[node*2+1] == 1 )\n\t{\n\t\tprintTree( tree, node*2+1 );\n\t}\n\tcout << \")\";\n\t*/\n}\n\nvector <int> intersectionTree( vector <int> &a, vector <int> &b )\n{\n\tvector <int> tree( SIZE, 0 );\n\tfor ( int i = 0; i < SIZE; i++ )\n\t\tif ( a[i] == 1 && b[i] == 1 )\n\t\t\ttree[i] = 1;\n\treturn tree;\n}\n\nvector <int> unionTree( vector <int> &a, vector <int> &b )\n{\n\tvector <int> tree( SIZE, 0 );\n\tfor ( int i = 0; i < SIZE; i++ )\n\t\tif ( a[i] == 1 || b[i] == 1 )\n\t\t\ttree[i] = 1;\n\treturn tree;\n}\n\nint main( void )\n{\n\tstring type;\n\tstring in_a;\n\tstring in_b;\n\n\twhile ( cin >> type >> in_a >> in_b )\n\t{\n\t\tvector <int> a = getTree( in_a );\n\t\tvector <int> b = getTree( in_b );\n\n\t\tvector <int> c;\n\t\tif ( type == \"i\" )\n\t\t{\n\t\t\tc = intersectionTree( a, b );\n\t\t}\n\t\telse if ( type == \"u\" )\n\t\t{\n\t\t\tc = unionTree( a, b );\n\t\t}\n\t\tprintTree( c, 2 );\n\t\tcout << endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stack>\n#include <queue>\nusing namespace std;\n\ntypedef struct Node{\n    Node *lChild;\n    Node *rChild;\n} Node;\n\nNode *createTree(string brackets);\nvoid printTree(Node *root);\nvoid getBrackets(Node *Tree, queue<char> &brackets);\nNode *intersectionTree(Node *Tree1, Node *Tree2);\nNode *unionTree(Node *Tree1, Node *Tree2);\n\nint main(int argc, const char * argv[]) {\n    string kind, bracTree1, bracTree2;\n    Node *Tree1, *Tree2, *newTree;\n    queue<queue<char>> outputs;\n    \n    while( cin>>kind>>bracTree1>>bracTree2 ){\n        Tree1 = createTree(bracTree1);\n        Tree2 = createTree(bracTree2);\n        \n        if(kind == \"i\"){\n            newTree = intersectionTree(Tree1, Tree2);\n        }\n        else{\n            newTree = unionTree(Tree1, Tree2);\n        }\n        \n        queue<char> newBrac;\n        getBrackets(newTree, newBrac);\n        outputs.push(newBrac);\n    }\n    \n    queue<char> output;\n    while (!outputs.empty()) {\n        output = outputs.front();\n        while (!output.empty()) {\n            printf(\"%c\",output.front());\n            output.pop();\n        }\n        printf(\"\\n\");\n        outputs.pop();\n    }\n    \n    return 0;\n}\n\nNode *createTree(string brackets){\n    bool meetComma;\n    Node *left, *right, *root = NULL;\n    stack<char> Stack;\n    stack<Node *> nodeStack;\n    \n    for(int i = 0; i <= brackets.length(); i++){\n        if( brackets[i] == ')'){\n            char c;\n            left = NULL, right =NULL, root = NULL;\n            meetComma = false;\n            \n            while (true) {\n                c = Stack.top();\n                Stack.pop();\n                if(c == '('){\n                    break;\n                }\n                else if( c == ','){\n                    meetComma = true;\n                }\n                else if( c == 'N' ){\n                    if(meetComma){\n                        left = nodeStack.top();\n                    }\n                    else{\n                        right = nodeStack.top();\n                    }\n                    nodeStack.pop();\n                }\n                else{\n                    cout<<\"error\"<<endl;\n                }\n            }\n            \n            root = new Node;\n            root->lChild = left;\n            root->rChild = right;\n            nodeStack.push(root);\n            Stack.push('N');\n        }\n        else{\n            Stack.push(brackets[i]);\n        }\n    }\n    return root;\n}\n\nvoid printTree(Node *root){\n    if ( root == NULL ) {\n        return;\n    }\n    \n    printf(\"(\");\n    printTree(root->lChild);\n    printf(\",\");\n    printTree(root->rChild);\n    printf(\")\");\n}\n\nNode *intersectionTree(Node *Tree1, Node *Tree2 ){\n    Node *iTree = NULL;\n    if(Tree1 != NULL && Tree2 != NULL){\n        iTree = new Node;\n        iTree->lChild = intersectionTree(Tree1->lChild, Tree2->lChild);\n        iTree->rChild = intersectionTree(Tree1->rChild, Tree2->rChild);\n    }\n    return iTree;\n}\n\nNode *unionTree(Node *Tree1, Node *Tree2){\n    Node *uTree ;\n    if(Tree1 == NULL && Tree2 == NULL){\n        uTree = NULL;\n    }\n    else if(Tree1 == NULL){\n        uTree = Tree2;\n    }\n    else if(Tree2 == NULL){\n        uTree = Tree1;\n    }\n    else{\n        uTree = new Node;\n        uTree->lChild = unionTree(Tree1->lChild, Tree2->lChild);\n        uTree->rChild = unionTree(Tree1->rChild, Tree2->rChild);\n    }\n    return uTree;\n}\n\nvoid getBrackets(Node *Tree, queue<char> &brackets){\n    if(Tree == NULL){\n        return;\n    }\n    \n    brackets.push('(');\n    getBrackets(Tree->lChild, brackets);\n    brackets.push(',');\n    getBrackets(Tree->rChild, brackets);\n    brackets.push(')');\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<list>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\n\nint treeA[500];\nint treeB[500];\nint treeC[500];\n\nvoid getTree(string line,int tree, int lvl){\n\tif(line==\"\" || line==\"(\" || line==\")\")return;\n\tstack<int> cnt;\n\tint b=0;\n\twhile(line[b]!=0){\n\t\tif(line[b]=='('){\n\t\t\tcnt.push(1);\n\t\t}else if(line[b]==')'){\n\t\t\tcnt.pop();\n\t\t}else{\n\t\t\tif(cnt.size()==1)break;\n\t\t}\n\t\tb++;\n\t}\n\tstring S_R = \"\";\n\tstring S_L = \"\";\n\tfor(int x=1;x<b;++x){\n\t\tS_L += line[x];\n\t}\n\tfor(int x=b+1;x<line.size()-1;++x){\n\t\tS_R += line[x];\n\t}\n\tif(S_R!=\"\"){getTree(S_R,tree,2*lvl+1);}\n\tif(S_L!=\"\"){getTree(S_L,tree,2*lvl);}\n\tif(tree==1){\n\t\ttreeA[lvl] = 1;\n\t}else{\n\t\ttreeB[lvl] = 2;\n\t}\n}\n\nstring imp(int lvl){\n\tif(lvl>=500)return \"\";\n\tif(treeC[lvl]==0)return \"\";\n\tstringstream buf;\n\tbuf<<\"(\"<<imp(2*lvl)<<\",\"<<imp(2*lvl+1)<<\")\";\n\treturn buf.str();\n}\n\nvoid unionT(){\n\tfor(int x=1;x<500;++x){\n\t\tif(treeA[x] || treeB[x])treeC[x] = 3;\n\t}\n\tcout<<imp(1)<<endl;\n}\n\nvoid inter(){\n\tfor(int x=1;x<500;++x){\n\t\tif(treeA[x] && treeB[x])treeC[x] = 3;\n\t}\n\tcout<<imp(1)<<endl;\n}\n\nint main(){\n\tchar l;\n\tstring s1,s2;\n\twhile(scanf(\" %c \",&l)!=EOF){\n\t\tcin>>s1>>s2;\n\t\tcout<<s1<<endl;\n\t\tcout<<s2<<endl;\n\t\tfor(int x=0;x<500;++x){\n\t\t\ttreeA[x] = 0;treeB[x] = 0;treeC[x] = 0;\n\t\t}\n\t\tgetTree(s1,1,1);\n\t\tgetTree(s2,2,1);\n\t\tif(l == 'u'){\n\t\t\tunionT();\n\t\t}else{\n\t\t\tinter();\n\t\t}\n\t}\t\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream> \n#include<string>\n#include<stack>\n#include<utility>\n\nusing namespace std;\n\nint main(void){\n\n\tstring ans;\n\tchar inp;\n\t\n\tstack<pair<char,int> > tree1,tree2;\n\tstring oper;\n\n\twhile(cin>>oper){\n\t\tinp=getchar();\n\t\twhile(1){\n\t\t\tinp=getchar();\n\t\t\tif(inp==' ') break;\n\t\t\tswitch(inp){\n\t\t\tcase '(':\n\t\t\t\tif(tree1.empty()) tree1.push(pair<char,int>(inp,0));\n\t\t\t\telse tree1.push(pair<char,int>(inp,tree1.top().second +1));\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\ttree1.push(pair<char,int>(inp,tree1.top().second -1));\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\ttree1.push(pair<char,int>(inp,tree1.top().second));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tinp=getchar();\n\t\t\tif(inp=='\\n') break;\n\t\t\tswitch(inp){\n\t\t\tcase '(':\n\t\t\t\tif(tree2.empty()) tree2.push(pair<char,int>(inp,0));\n\t\t\t\telse tree2.push(pair<char,int>(inp,tree2.top().second +1));\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\ttree2.push(pair<char,int>(inp,tree2.top().second -1));\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\ttree2.push(pair<char,int>(inp,tree2.top().second));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans=\")\";\n\t\ttree1.pop(),tree2.pop();\n\t\twhile(!tree1.empty()&&!tree2.empty()){\n\t\t\tif(tree1.top().second==tree2.top().second){\n\t\t\t\tif(tree1.top().first==tree2.top().first){\n\t\t\t\t\tans+=tree1.top().first;\n\t\t\t\t\ttree1.pop(),tree2.pop();\n\t\t\t\t}\n\t\t\t\telse if(tree1.top().first=='('&&tree2.top().first==')'){\n\t\t\t\t\tif(oper==\"u\") ans+=tree2.top().first;\n\t\t\t\t\ttree2.pop();\n\t\t\t\t}\n\t\t\t\telse if(tree1.top().first==')'&&tree2.top().first=='('){\n\t\t\t\t\tif(oper==\"u\") ans+=tree1.top().first;\n\t\t\t\t\ttree1.pop();\n\t\t\t\t}\n\t\t\t\telse if(tree1.top().first==','){\n\t\t\t\t\tif(oper==\"u\") ans+=tree2.top().first;\n\t\t\t\t\ttree2.pop();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(oper==\"u\") ans+=tree1.top().first;\n\t\t\t\t\ttree1.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(tree1.top().second>tree2.top().second){\n\t\t\t\tif(oper==\"u\") ans+=tree1.top().first;\n\t\t\t\ttree1.pop();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(oper==\"u\") ans+=tree2.top().first;\n\t\t\t\ttree2.pop();\n\t\t\t}\n\t\t}\n\t\tfor(int i=ans.length()-1;i>=0;i--){\n\t\t\tcout<<ans[i];\n\t\t}\n\t\tcout<<endl;\n\t}\n\t\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=1000;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  heap[id]++;\n  if(s==\"(,)\") return;\n  \n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;\nif(cnt<0) break;   \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n      if(i-1>=0) parse(sub1, 2*id+1);\n      if(s.length()-i-2>=0)parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nvoid out(int th, int id){\n\n  output.push_back('(');\n\n  int ch1=0,ch2=0;//n of string of each child\n  \n  if(heap[id]>th && heap[2*id+1]>th){\n    out(th,2*id+1);\n  }\n  output.push_back(',');\n  if(heap[id]>th && heap[2*id+2]>th){\n    out(th,2*id+2);\n  }\n  \n  output.push_back(')');\n  return;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  output.clear();\n  //cout<<output<<endl;\n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0);\n  \n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  int i=0;\n  \n  while(cin>>cmd>>s1>>s2){\n    solve(cmd,s1,s2);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nstd::string binary_tree(std::string, std::string, char);\n\nint main(int argc, char const *argv[]){\n\n\tchar operation;\n\tstd::string tree_A;\n\tstd::string tree_B;\n\n\twhile(std::cin >> operation >> tree_A >> tree_B){\n\t\tstd::string answer = binary_tree(tree_A,tree_B,operation);\n\t\tstd::cout << answer << std::endl;\n\t} \n\n\treturn 0;\n}\n\nstd::string binary_tree(std::string tree_A, std::string tree_B, char operation){\n\n\tif(tree_A==tree_B){\n\n\t\treturn tree_A;\n\n\t}else if(tree_A==\"\"){\n\n\t\tif(operation=='i'){\n\t\t\treturn tree_A;\n\t\t}else if(operation=='u'){\n\t\t\treturn tree_B;\n\t\t}else{\n\t\t\t//exception\n\t\t} \n\n\t}else if(tree_B==\"\"){\n\n\t\tif(operation=='i'){\n\t\t\treturn tree_B;\n\t\t}else if(operation=='u'){\n\t\t\treturn tree_A;\n\t\t}else{\n\t\t\t//exception\n\t\t}\n\n\t}else{\n\n\t\tstd::string node_A[2] = \"\";\n\t\tstd::string node_B[2] = \"\";\n\t\tint period;\n\n\t\tperiod = 0;\n\t\tfor (int i = 1; i < tree_A.length()-1; ++i){\n\n\t\t\tint bracket_count = 0;\n\n\t\t\tif(tree_A[i]=='('){\n\t\t\t\tdo{\n\t\t\t\t\tnode_A[period] += tree_A[i];\n\t\t\t\t\tif(tree_A[i]=='('){\n\t\t\t\t\t\tbracket_count += 1;\n\t\t\t\t\t}else if(tree_A[i]==')'){\n\t\t\t\t\t\tbracket_count -= 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//exception\n\t\t\t\t\t}\n\t\t\t\t\ti += 1;\n\t\t\t\t}while(bracket_count>0);\n\t\t\t}\n\t\t\tperiod++;\n\t\t}\n\n\t\tperiod = 0;\n\t\tfor (int i = 1; i < tree_B.length()-1; ++i){\n\n\t\t\tint bracket_count = 0;\n\n\t\t\tif(tree_B[i]=='('){\n\t\t\t\tdo{\n\t\t\t\t\tnode_B[period] += tree_B[i];\n\t\t\t\t\tif(tree_B[i]=='('){\n\t\t\t\t\t\tbracket_count += 1;\n\t\t\t\t\t}else if(tree_B[i]==')'){\n\t\t\t\t\t\tbracket_count -= 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//exception\n\t\t\t\t\t}\n\t\t\t\t\ti += 1;\n\t\t\t\t}while(bracket_count>0);\n\t\t\t}\n\t\t\tperiod++;\n\t\t}\n\n\n\t\tstd::string node[2];\n\t\tnode[0] = binary_tree(node_A[0],node_B[0],operation);\n\t\tnode[1] = binary_tree(node_A[1],node_B[1],operation);\n\n\t\treturn \"(\" + node[0] + \",\" + node[1] + \")\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int LIM_DEP = 101;\nconst int LIM_COL = LIM_DEP * 2;\n\nvoid toMap( const string& tree, bool map[ LIM_DEP ][ LIM_COL ] )\n{\n\tint col = 0;\n\tint depth = -1;\n\tfor( int i = 0; i < (int)tree.size(); ++i ){\n\t\tswitch( tree[ i ] ){\n\t\t\tcase '(':\n\t\t\t\t++depth;\n\t\t\t\tcol *= 2;\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\tmap[ depth ][ col ] = true;\n\t\t\t\t++col;\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\t--depth;\n\t\t\t\tcol /= 2;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nstring recFigure( const bool map[ LIM_DEP ][ LIM_COL ], string* s, int depth, int col )\n{\n\tif( map[ depth ][ col ] ){\n\t\t*s += '(';\n\t\trecFigure( map, s, depth + 1, col * 2 );\n\t\t*s += ',';\n\t\trecFigure( map, s, depth + 1, ( col + 1 ) * 2 );\n\t\t*s += ')';\n\t}\n\treturn *s;\n}\n\nstring toFigure( const bool map[ LIM_DEP ][ LIM_COL ] )\n{\n\tstring s;\n\treturn recFigure( map, &s, 0, 0 );\n}\n\nstring merge( const bool map0[ LIM_DEP ][ LIM_COL ], const bool map1[ LIM_DEP ][ LIM_COL ], char pat )\n{\n\tbool mapMerged[ LIM_DEP ][ LIM_COL ] = {0};\n\tfor( int i = 0; i < LIM_DEP - 1; ++i ){\n\t\tfor( int j = 0; j < ( i + 1 ) * 2; ++j ){\n\t\t\tmapMerged[ i ][ j ] = ( pat == 'i' ? map0[ i ][ j ] && map1[ i ][ j ] : map0[ i ][ j ] || map1[ i ][ j ] );\n\t\t}\n\t}\n\treturn toFigure( mapMerged );\n}\n\nint main()\n{\n\tchar ope;\n\tstring tree0, tree1;\n\twhile( cin >> ope >> tree0 >> tree1 ){\n\t\tbool treeMap0[ LIM_DEP ][ LIM_COL ] = {0};\n\t\tbool treeMap1[ LIM_DEP ][ LIM_COL ] = {0};\n\t\ttoMap( tree0, treeMap0 );\n\t\ttoMap( tree1, treeMap1 );\n\t\tcout << merge( treeMap0, treeMap1, ope ) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cassert>\nusing namespace std;\nint cur = 0;\nstruct node{\n  node *l,*r;\n  node(node *l = nullptr,node *r = nullptr):l(l),r(r){};\n};\nnode* parse(string &f){\n  assert(f[cur] == '(');\n  cur++;\n  node *current = new node();\n  if(f[cur] == '('){\n\tnode *left = parse(f);\n\tcurrent->l = left;\n  }\n  assert(f[cur] == ',');\n  cur++;\n  if(f[cur] == '('){\n\tnode *right = parse(f);\n\tcurrent->r = right;\n  }\n  assert(f[cur] == ')');\n  cur++;\n  return current;\n}\nstring dfs_i(node *f,node *s){\n  if(f == nullptr || s == nullptr)return \"\";\n  return \"(\" + dfs_i(f->l,s->l) + \",\" + dfs_i(f->r,s->r) + \")\";\n  \n}\nstring dfs_u(node *f,node *s){\n  if(f == nullptr && s == nullptr)return \"\";\n  if(f == nullptr) return \"(\" + dfs_u(nullptr,s->l) + \",\" + dfs_u(nullptr,s->r) + \")\";\n  if(s == nullptr) return \"(\" + dfs_u(f->l,nullptr) + \",\" + dfs_u(f->r,nullptr) + \")\";\n  return \"(\" + dfs_u(f->l,s->l) + \",\" + dfs_u(f->r,s->r) + \")\";\n  \n}\nint main(){\n  string f,s;\n  char c;\n  while(cin >> c >> f >> s){\n\tnode *f_t,*s_t;\n\tcur = 0;\n\tf_t = parse(f);\n\tcur = 0;\n\ts_t = parse(s);\n\t\n\tif(c == 'i')cout << dfs_i(f_t,s_t) << endl;\n\tif(c == 'u')cout << dfs_u(f_t,s_t) << endl;\n\t\n\t\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// rep\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define rep(i,n) REP(i,0,n)\n\nvoid division(string const &raw, string &left, string &right) {\n  \n  int const N = raw.size();\n  int retain = 0;\n  REP(pos, 1, N) {\n    if(raw[pos] == '(') retain++;\n    else if(raw[pos] == ')') retain--;\n    else if(retain == 0) {\n      //assert(raw[pos] == ',');\n      left  = raw.substr(1, pos-1);\n      right = raw.substr(pos+1, N-pos-2);\n      break;\n    }\n  }\n  \n}\n\nstring solve(char op, string const &s, string const &t) {\n  if(s.empty() || t.empty()) {\n    if(op == 'i') return min(s, t);\n    else return max(s, t);\n  }\n  \n  string sL, sR, tL, tR;\n  division(s, sL, sR);\n  division(t, tL, tR);\n  \n  return '(' + solve(op, sL, tL) + ',' + solve(op, sR, tR) + ')';\n}\n\nint main() {\n  \n  char op; string s, t;\n  while(cin >> op >> s >> t) {\n    cout << solve(op, s, t) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n  int a,b;\n  while(cin>>a>>b) {\n    cout<<a+b<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n  int a,b;\n  while(1);\n  while(cin>>a>>b) {\n    cout<<a+b<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct Node {\n    Node *left, *right;\n\n    Node() : left(NULL), right(NULL) {}\n\n    Node* intersect(Node *other) {\n        Node *n = new Node;\n        if(this->left && other->left) {\n            n->left = this->left->intersect(other->left);\n        }\n        if(this->right && other->right) {\n            n->right = this->right->intersect(other->right);\n        }\n        return n;\n    }\n\n    Node* union_(Node *other) {\n        Node *n = new Node;\n        if(this->left && other->left) {\n            n->left = this->left->union_(other->left);\n        }\n        else {\n            n->left = this->left?this->left : other->left;\n        }\n\n        if(this->right && other->right) {\n            n->right = this->right->union_(other->right);\n        }\n        else {\n            n->right = this->right?this->right : other->right;\n        }\n\n        return n;\n    }\n};\nostream& operator << (ostream &os, const Node &node) {\n    os << '(';\n    if(node.left) os << *node.left;\n    os << ',';\n    if(node.right) os << *node.right;\n    os << ')';\n}\n\nvoid skip(const string &str, char c, int &pos) {\n    if(str[pos] != c) {\n        cout << \"Expected \" << c << \" but found \" << str[pos] << \" near \" << str.substr(pos) << endl;\n    }\n    ++pos;\n}\n\nNode *getNode(const string &str, int &pos) {\n    skip(str, '(', pos);\n\n    Node *node = new Node;\n    if(str[pos] == '(') node->left = getNode(str, pos);\n    skip(str, ',', pos);\n    if(str[pos] == '(') node->right = getNode(str, pos);\n    skip(str, ')', pos);\n\n    return node;\n}\n\nint main() {\n    char cmd;\n    string s1, s2;\n\n    while(cin >> cmd >> s1 >> s2 && !cin.eof()) {\n        int pos = 0;\n        Node *n1 = getNode(s1, pos);\n        pos = 0;\n        Node *n2 = getNode(s2, pos);\n\n        if(cmd == 'i') {\n            cout << *(n1->intersect(n2)) << endl;\n        }\n        else {\n            cout << *(n1->union_(n2)) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n\nusing namespace std;\n\nconst int SIZE = 128;\nbool A[SIZE],B[SIZE],C[SIZE];\n\nint getPos(const string& s){\n  int p = 0;\n  for(int i = 0; i < (int)s.length(); i++){\n    if(s[i] == '(') p++;\n    else if(s[i] == ')') p--;\n    if(p == 0 && s[i] == ',') return i;\n  }\n  return -1;\n}\n\nvoid parse(const string& s, bool isA, int idx){\n  if(s == \"\") return;\n  if(isA) A[idx] = true;\n  else B[idx] = true;\n  string nex = s.substr(1,s.length()-2);\n  int pos = getPos(nex);\n  string left = nex.substr(0,pos);\n  string right = nex.substr(pos+1);\n  parse(left,isA,2*idx+1);\n  parse(right,isA,2*idx+2);\n}\n\nstring makeTree(int idx){\n  if(!C[idx]) return \"\";\n  string res = \"\";\n  if(2*idx+1 < SIZE) res += makeTree(2*idx+1);\n  res += \",\";\n  if(2*idx+2 < SIZE) res += makeTree(2*idx+2);\n  res = \"(\" + res + \")\";\n  return res;\n}\n\nint main(){\n\n  char c;\n  string a,b;\n  while(cin >> c >> a >> b){\n    memset(A,false,sizeof(A));\n    memset(B,false,sizeof(B));\n    memset(C,false,sizeof(C));\n    parse(a,true,0);\n    parse(b,false,0);\n    if(c=='i') for(int i = 0; i < SIZE; i++) C[i] = A[i]&&B[i];\n    else for(int i = 0; i < SIZE; i++) C[i] = A[i]||B[i];\n    cout << makeTree(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\nstruct Tree {\n    Tree* ch[2];\n};\n\nTree * parse(string::iterator b, string::iterator e){\n    if(b==e) return nullptr;\n    auto res = new Tree;\n    res->ch[0] = res->ch[1] = nullptr;\n    int d = 0;\n    for(auto it = b; it != e; ++it){\n        if(*it=='('){\n            d++;\n        } else if(*it==','){\n            if(d==1){\n                res->ch[0] = parse(b+1,it);\n                res->ch[1] = parse(it+1,e-1);\n            }\n        } else if(*it==')'){\n            d--;\n        }\n    }\n    return res;\n}\n\nTree * intersect(Tree * t, Tree * u){\n    Tree * res = new Tree;\n    res->ch[0] = res->ch[1] = nullptr;\n    rep(i,2){\n        if(t->ch[i]!=nullptr && u->ch[i]!=nullptr){\n            res->ch[i] = intersect(t->ch[i],u->ch[i]);\n        }\n    }\n    return res;\n}\n\nTree * unite(Tree * t, Tree * u){\n    if(t==nullptr && u==nullptr) return nullptr;\n    Tree * res = new Tree;\n    res->ch[0] = res->ch[1] = nullptr;\n    if(t!=nullptr && u!=nullptr){\n        rep(i,2){\n            res->ch[i] = unite(t->ch[i], u->ch[i]);\n        }\n    } else {\n        if(t==nullptr) swap(t,u);\n        rep(i,2){\n            res->ch[i] = unite(t->ch[i], nullptr);\n        }\n    }\n    return res;\n}\n\nvoid print(Tree* t){\n    cout << \"(\";\n    if(t->ch[0] != nullptr) print(t->ch[0]);\n    cout << \",\";\n    if(t->ch[1] != nullptr) print(t->ch[1]);\n    cout << \")\";\n}\n\nint main(){\n    char c;\n    while(cin>>c){\n        string s,t; cin >> s >> t;\n        auto a = parse(all(s)), b = parse(all(t));\n        if(c=='i') print(intersect(a,b));\n        else print(unite(a,b));\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"set>.cpp\"\n#include \"set>.cpp\"\n#include <iostream>\nint main(){\n while(1){\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<list>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\n\nint treeA[110];\nint treeB[110];\nint treeC[110];\n\nvoid getTree(string line,int tree, int lvl){\n\tif(line==\"\")return;\n\tstack<int> cnt;\n\tint b=0;\n\twhile(line[b]!=0){\n\t\tif(line[b]=='('){\n\t\t\tcnt.push(1);\n\t\t}else if(line[b]==')'){\n\t\t\tcnt.pop();\n\t\t}else{\n\t\t\tif(cnt.size()==1)break;\n\t\t}\n\t\tb++;\n\t}\n\tline = line.substr(0,line.size()-1);\n\tstring S_R = line.substr(b+1);\n\tstring S_L = line.substr(1,b-1);\n\tgetTree(S_R,tree,2*lvl+1);\n\tgetTree(S_L,tree,2*lvl);\n\tif(tree==1){\n\t\ttreeA[lvl] = 1;\n\t}else{\n\t\ttreeB[lvl] = 2;\n\t}\n}\n\nstring imp(int lvl){\n\tif(treeC[lvl]==0)return \"\";\n\tstringstream buf;\n\tbuf<<\"(\"<<imp(2*lvl)<<\",\"<<imp(2*lvl+1)<<\")\";\n\treturn buf.str();\n}\n\nvoid unionT(){\n\tfor(int x=1;x<110;++x){\n\t\tif(treeA[x] || treeB[x])treeC[x] = 3;\n\t}\n\tcout<<imp(1)<<endl;\n}\n\nvoid inter(){\n\tfor(int x=1;x<110;++x){\n\t\tif(treeA[x] && treeB[x])treeC[x] = 3;\n\t}\n\tcout<<imp(1)<<endl;\n}\n\nint main(){\n\tstring line;\n\twhile(getline(cin,line)){\n\t\tfor(int x=0;x<110;++x){\n\t\t\ttreeA[x] = 0;treeB[x] = 0;treeC[x] = 0;\n\t\t}\n\t\tint f = line.rfind(\" \");\n\t\tgetTree(line.substr(2,f-2),1,1);\n\t\tgetTree(line.substr(f+1),2,1);\n\t\tif(line[0] == 'u'){\n\t\t\tunionT();\n\t\t}else{\n\t\t\tinter();\n\t\t}\n\t}\t\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\nusing namespace std;\n\n#define SIZE 10000\n\nvector <int> getTree( string in )\n{\n\tvector <int> tree( SIZE, 0 );\n\n\tint n = 1;\n\tint lr = 0;\n\tstack <int> lrs;\n\n\tfor ( string::iterator it = in.begin(); it != in.end(); it++ )\n\t{\n\t\t/*\n\t\tswitch( *it )\n\t\t{\n\t\tcase '(':\n\t\t\tn *= 2;\n\t\t\ttree[n+lr] = 1;\n\t\t\tlrs.push( lr );\n\t\t\tlr = 0;\n\t\t\tbreak;\n\n\t\tcase ')':\n\t\t\tn /= 2;\n\t\t\tlr = lrs.top();\n\t\t\tlrs.pop();\n\t\t\tbreak;\n\n\t\tcase ',':\n\t\t\tlr++;\n\t\t\tbreak;\n\t\t}\n\t\t*/\n\t}\n\n\treturn tree;\n}\n\nvoid printTree( vector <int> &tree, int node )\n{\n\tcout << \"(\";\n\tif ( tree[node*2] == 1 )\n\t{\n\t\tprintTree( tree, node*2 );\n\t}\n\tcout << \",\";\n\tif ( tree[node*2+1] == 1 )\n\t{\n\t\tprintTree( tree, node*2+1 );\n\t}\n\tcout << \")\";\n}\n\nvector <int> intersectionTree( vector <int> &a, vector <int> &b )\n{\n\tvector <int> tree( SIZE, 0 );\n\tfor ( int i = 0; i < SIZE; i++ )\n\t\tif ( a[i] == 1 && b[i] == 1 )\n\t\t\ttree[i] = 1;\n\treturn tree;\n}\n\nvector <int> unionTree( vector <int> &a, vector <int> &b )\n{\n\tvector <int> tree( SIZE, 0 );\n\tfor ( int i = 0; i < SIZE; i++ )\n\t\tif ( a[i] == 1 || b[i] == 1 )\n\t\t\ttree[i] = 1;\n\treturn tree;\n}\n\nint main( void )\n{\n\tstring type;\n\tstring in_a;\n\tstring in_b;\n\n\twhile ( cin >> type >> in_a >> in_b )\n\t{\n\t\tvector <int> a = getTree( in_a );\n\t\tvector <int> b = getTree( in_b );\n\n\t\tvector <int> c;\n\t\tif ( type == \"i\" )\n\t\t{\n\t\t\tc = intersectionTree( a, b );\n\t\t}\n\t\telse if ( type == \"u\" )\n\t\t{\n\t\t\tc = unionTree( a, b );\n\t\t}\n\t\tprintTree( c, 2 );\n\t\tcout << endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stack>\n#include <queue>\nusing namespace std;\n\ntypedef struct Node{\n    Node *lChild;\n    Node *rChild;\n} Node;\n\nNode *createTree(string brackets);\nvoid printTree(Node *root);\nvoid getBrackets(Node *Tree, queue<char> &brackets);\nNode *intersectionTree(Node *Tree1, Node *Tree2);\nNode *unionTree(Node *Tree1, Node *Tree2);\n\nint main(int argc, const char * argv[]) {\n    string kind, bracTree1, bracTree2;\n    Node *Tree1, *Tree2, *newTree;\n    queue< queue<char> > outputs;\n    \n    while( cin>>kind>>bracTree1>>bracTree2 ){\n        Tree1 = createTree(bracTree1);\n        Tree2 = createTree(bracTree2);\n        \n        if(kind == \"i\"){\n            newTree = intersectionTree(Tree1, Tree2);\n        }\n        else{\n            newTree = unionTree(Tree1, Tree2);\n        }\n        \n        queue<char> newBrac;\n        getBrackets(newTree, newBrac);\n        outputs.push(newBrac);\n    }\n    \n    queue<char> output;\n    while (!outputs.empty()) {\n        output = outputs.front();\n        while (!output.empty()) {\n            printf(\"%c\",output.front());\n            output.pop();\n        }\n        printf(\"\\n\");\n        outputs.pop();\n    }\n    \n    return 0;\n}\n\nNode *createTree(string brackets){\n    bool meetComma;\n    Node *left, *right, *root = NULL;\n    stack<char> Stack;\n    stack<Node *> nodeStack;\n    \n    for(int i = 0; i <= brackets.length(); i++){\n        if( brackets[i] == ')'){\n            char c;\n            left = NULL, right =NULL, root = NULL;\n            meetComma = false;\n            \n            while (true) {\n                c = Stack.top();\n                Stack.pop();\n                if(c == '('){\n                    break;\n                }\n                else if( c == ','){\n                    meetComma = true;\n                }\n                else if( c == 'N' ){\n                    if(meetComma){\n                        left = nodeStack.top();\n                    }\n                    else{\n                        right = nodeStack.top();\n                    }\n                    nodeStack.pop();\n                }\n                else{\n                    cout<<\"error\"<<endl;\n                }\n            }\n            \n            root = new Node;\n            root->lChild = left;\n            root->rChild = right;\n            nodeStack.push(root);\n            Stack.push('N');\n        }\n        else{\n            Stack.push(brackets[i]);\n        }\n    }\n    return root;\n}\n\nvoid printTree(Node *root){\n    if ( root == NULL ) {\n        return;\n    }\n    \n    printf(\"(\");\n    printTree(root->lChild);\n    printf(\",\");\n    printTree(root->rChild);\n    printf(\")\");\n}\n\nNode *intersectionTree(Node *Tree1, Node *Tree2 ){\n    Node *iTree = NULL;\n    if(Tree1 != NULL && Tree2 != NULL){\n        iTree = new Node;\n        iTree->lChild = intersectionTree(Tree1->lChild, Tree2->lChild);\n        iTree->rChild = intersectionTree(Tree1->rChild, Tree2->rChild);\n    }\n    return iTree;\n}\n\nNode *unionTree(Node *Tree1, Node *Tree2){\n    Node *uTree ;\n    if(Tree1 == NULL && Tree2 == NULL){\n        uTree = NULL;\n    }\n    else if(Tree1 == NULL){\n        uTree = Tree2;\n    }\n    else if(Tree2 == NULL){\n        uTree = Tree1;\n    }\n    else{\n        uTree = new Node;\n        uTree->lChild = unionTree(Tree1->lChild, Tree2->lChild);\n        uTree->rChild = unionTree(Tree1->rChild, Tree2->rChild);\n    }\n    return uTree;\n}\n\nvoid getBrackets(Node *Tree, queue<char> &brackets){\n    if(Tree == NULL){\n        return;\n    }\n    \n    brackets.push('(');\n    getBrackets(Tree->lChild, brackets);\n    brackets.push(',');\n    getBrackets(Tree->rChild, brackets);\n    brackets.push(')');\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <memory>\n#include <vector>\nusing namespace std;\n\nstruct node_t {\n\tshared_ptr<node_t> left, right;\n\n\tnode_t():left(nullptr), right(nullptr) {}\n};\n\nshared_ptr<node_t> parse(string::const_iterator &it) {\n\tshared_ptr<node_t> p(new node_t());\n\n\t++it; // '('\n\tif(*it == '(') p->left = parse(it);\n\t++it; // ','\n\tif(*it == '(') p->right = parse(it);\n\t++it; // ')'\n\n\treturn p;\n}\n\ninline shared_ptr<node_t> input_tree() {\n\tstring s;\n\tcin >> s;\n\n\tauto it = s.cbegin();\n\treturn parse(it);\n}\n\ninline bool intersection_ok(const shared_ptr<node_t> &a, const shared_ptr<node_t> &b) {\n\treturn a != nullptr && b != nullptr;\n}\n\ninline bool union_ok(const shared_ptr<node_t> &a, const shared_ptr<node_t> &b) {\n\treturn a != nullptr || b != nullptr;\n}\n\ntemplate<class Predicate>\ninline string dfs(const shared_ptr<node_t> &a, const shared_ptr<node_t> &b, const Predicate &ok) {\n\tif(!ok(a, b)) return \"\";\n\n\tstring res = \"(\";\n\tres += dfs(a ? a->left : nullptr, b ? b->left : nullptr, ok);\n\tres += \",\";\n\tres += dfs(a ? a->right : nullptr, b ? b->right : nullptr, ok);\n\tres += \")\";\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(char c; cin >> c;) {\n\t\tconst auto tree1 = input_tree();\n\t\tconst auto tree2 = input_tree();\n\n\t\tconst auto ok = (c == 'i' ? &intersection_ok : &union_ok);\n\t\tcout << dfs(tree1, tree2, ok) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "// library\n#include<iostream>\n#include<memory>\n// class\nclass BinaryTree {\nprivate:\n  struct Node {\n    std::unique_ptr<Node> left_child, right_child;\n    Node() : left_child(nullptr), right_child(nullptr) {}\n  };\npublic:\n  BinaryTree(const std::string& expression = \"\");\n  std::string string() const;\nprivate:\n  std::unique_ptr<Node> parse(const std::string& expression, int& index);\n  std::string string(const std::unique_ptr<Node>& node) const;\n  std::unique_ptr<Node> root_;\n  friend const BinaryTree operator*(const BinaryTree& lhs, const BinaryTree& rhs);\n  friend const BinaryTree operator+(const BinaryTree& lhs, const BinaryTree& rhs);\n  friend std::unique_ptr<Node> union_binary_trees(const std::unique_ptr<Node>& left, const std::unique_ptr<Node>& right);\n  friend std::unique_ptr<Node> intersection_binary_trees(const std::unique_ptr<Node>& left, const std::unique_ptr<Node>& right);\n};\n// method\nBinaryTree::BinaryTree(const std::string& expression) {\n  int index = 0;\n  root_ = parse(expression, index);\n}\nstd::unique_ptr<BinaryTree::Node> BinaryTree::parse(const std::string& expression, int& index) {\n  if(expression[index] != '(') return nullptr;\n  std::unique_ptr<Node> result(new Node);\n  result->left_child = parse(expression, ++index);\n  result->right_child = parse(expression, ++index);\n  ++index;\n  return result;\n}\nstd::string BinaryTree::string() const {\n  return string(root_);\n}\nstd::string BinaryTree::string(const std::unique_ptr<Node>& node) const {\n  return !node ? \"\" : \"(\" + string(node->left_child) + \",\" + string(node->right_child) + \")\";\n}\n// operator\nconst BinaryTree operator*(const BinaryTree& lhs, const BinaryTree& rhs) {\n  BinaryTree result;\n  result.root_ = intersection_binary_trees(lhs.root_, rhs.root_);\n  return result;\n}\nstd::unique_ptr<BinaryTree::Node> intersection_binary_trees(const std::unique_ptr<BinaryTree::Node>& left, const std::unique_ptr<BinaryTree::Node>& right) {\n  if(!left || !right) return nullptr;\n  std::unique_ptr<BinaryTree::Node> result(new BinaryTree::Node);\n  result->left_child = intersection_binary_trees(left->left_child, right->left_child);\n  result->right_child = intersection_binary_trees(left->right_child, right->right_child);\n  return result;\n}\nconst BinaryTree operator+(const BinaryTree& lhs, const BinaryTree& rhs) {\n  BinaryTree result;\n  result.root_ = union_binary_trees(lhs.root_, rhs.root_);\n  return result;\n}\nstd::unique_ptr<BinaryTree::Node> union_binary_trees(const std::unique_ptr<BinaryTree::Node>& left, const std::unique_ptr<BinaryTree::Node>& right) {\n  if(!left && !right) return nullptr;\n  std::unique_ptr<BinaryTree::Node> result(new BinaryTree::Node);\n  result->left_child = union_binary_trees(left ? left->left_child : left, right ? right->left_child : right);\n  result->right_child = union_binary_trees(left ? left->right_child : left, right ? right->right_child : right);\n  return result;\n}\n// input\nstd::istream& operator>>(std::istream& is, BinaryTree& bt) {\n  std::string s;\n  is >> s;\n  bt = BinaryTree(s);\n  return is;\n}\n// output\nstd::ostream& operator<<(std::ostream& os, const BinaryTree& bt) {\n  os << bt.string();\n  return os;\n}\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main() {\n  string op;\n  BinaryTree lhs, rhs;\n  while(cin >> op >> lhs >> rhs) cout << ((op == \"u\") ? (lhs + rhs) : (lhs * rhs)) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\nusing namespace std;\ntypedef long long ll;\nset<ll> one,two;\n\nvoid input(int pos,set<ll> &to){\n\tto.insert(pos);\n\tchar c;cin >> c;\n\tif(c == '('){\n\t\tinput(pos*2,to);\n\t\tcin >> c;\n\t}\n\tcin >> c;\n\tif(c == '('){\n\t\tinput(pos*2+1,to);\n\t\tcin >> c;\n\t}\n\tif(c == ')')return;\n}\nstring ret = \"\";\nvoid gen(int pos,set<ll> &from){\n\tif(from.find(pos*2) != from.end()){\n\t\tret += \"(\";\n\t\tgen(pos*2,from);\n\t}\n\tret += \",\";\n\tif(from.find(pos*2+1) != from.end()){\n\t\tret += \"(\";\n\t\tgen(pos*2+1,from);\n\t}\n\tret += \")\";\n}\nint main(){\n\tchar type; char dummy;\n\twhile(cin >> type){\n\t\tone.clear(),two.clear();\n\t\t\n\t\tcin >> dummy;\n\t\tinput(1,one);\n\t\tcin >> dummy;\n\t\tinput(1,two);\n\t\tvector<ll> cd;\n\t\t\n\t\tset<ll> get;\n\t\tif(type == 'u'){\n\t\t\tget = one;\n\t\t\tfor(set<ll>::iterator it = two.begin(); it != two.end(); ++it)\n\t\t\t\tget.insert(*it);\n\t\t}else{\n\t\t\tfor(set<ll>::iterator it = two.begin(); it != two.end(); ++it)\n\t\t\t\tif(one.find(*it) != one.end())get.insert(*it);\n\t\t\tfor(set<ll>::iterator it = one.begin(); it != one.end(); ++it)\n\t\t\t\tif(two.find(*it) != two.end())get.insert(*it);\n\t\t}\n\t\tret = \"\";\n\t\tgen(1,get);\n\t\tcout << \"(\" << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  AOJ\n//\n//  Created by user on 2014/02/01.\n//  Copyright (c) 2014年 user. All rights reserved.\n//\n\n#include <iostream>\n#include <memory>\n#include <sstream>\nusing namespace std;\n\npair<string, string> getTree(string str){\n    int stack = 0;\n    int ptr = -1;\n    \n    for(int i=0;i<str.size();i++){\n        if(str[i] == '('){\n            ++stack;\n        } else if(str[i] == ')'){\n            --stack;\n        } else if(str[i] == ','){\n            if(stack == 1){\n                ptr = i;\n                break;\n            }\n        }\n    }\n    \n    string Ls = str.substr(1, ptr - 1);\n    string Rs = str.substr(ptr + 1, str.size() - ptr - 2);\n    \n    return make_pair(Ls, Rs);\n}\n\n\nstring TreeInsect(string As, string Bs){\n    if(As.empty())return \"\";\n    if(Bs.empty())return \"\";\n    \n    string res = \"(\";\n    \n    pair<string, string> TreeA = getTree(As);\n    pair<string, string> TreeB = getTree(Bs);\n    \n    res += TreeInsect(TreeA.first, TreeB.first);\n    res += \",\";\n    res += TreeInsect(TreeA.second, TreeB.second);\n    res += \")\";\n    \n    return res;\n}\n\nstring TreeUnion(string As, string Bs){\n    if(As.empty())return Bs;\n    if(Bs.empty())return As;\n    \n    string res = \"(\";\n    \n    pair<string, string> TreeA = getTree(As);\n    pair<string, string> TreeB = getTree(Bs);\n    \n    res += TreeUnion(TreeA.first, TreeB.first);\n    res += \",\";\n    res += TreeUnion(TreeA.second, TreeB.second);\n    res += \")\";\n    \n    return res;\n}\n\n\nint main(int argc, const char * argv[])\n{\n    string line;\n    while(getline(cin, line)){\n        stringstream ss(line);\n        string com, As, Bs;\n        ss >> com >> As >> Bs;\n        \n        string Cs = \"\";\n        \n        if(com == \"i\"){\n            Cs = TreeInsect(As, Bs);\n        }\n        if(com == \"u\"){\n            Cs = TreeUnion(As, Bs);\n        }\n        \n        cout << Cs << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstruct Node{\n  int cnt;\n  Node* children[2];\n  Node() : cnt(1) {\n    memset(children, 0, sizeof(children));\n  }\n};\nstruct Result{\n  Node* value;\n  int t;\n  Result(Node* p, int t) : value(p), t(t) {}\n};\nResult parse(Node* p, const string& s, int t = 0){\n  if(p == NULL) p = new Node();\n  else p->cnt ++;\n  assert(s[t] == '(');\n  if(s[t + 1] != ','){\n    Result r1 = parse(p->children[0], s, t + 1);\n    p->children[0] = r1.value;\n    t = r1.t;\n  }else{\n    t ++;\n  }\n  assert(s[t] == ',');\n  if(s[t + 1] != ')'){\n    Result r2 = parse(p->children[1], s, t + 1);\n    p->children[1] = r2.value;\n    t = r2.t;\n  }else{\n    t++;\n  }\n  assert(s[t] == ')');\n  return Result(p, t + 1);\n}\nvoid print(Node *p, int B){\n  if(p == NULL) return;\n  if(p->cnt < B) return;\n  printf(\"(\");\n  print(p->children[0], B);\n  printf(\",\");\n  print(p->children[1], B);\n  printf(\")\");\n}\nint main(){\n  while(true){\n    char c; cin >> c;\n    if(cin.eof()) break;\n    string s;\n    cin >> s;\n    Result r = parse(NULL, s);\n    Node* root = r.value;\n    assert(r.t == s.size());\n    cin >> s;\n    Result r2 = parse(root, s);\n    print(root, (c == 'i') ? 2 : 1);\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct Tree {\n\tTree() : left(NULL), right(NULL) { }\n\tTree *left, *right;\n};\n\nTree *build(const char **ptr){\n\tTree *cur = NULL;\n\tif(**ptr == '('){\n\t\tcur = new Tree();\n\t\t++*ptr;\n\t\tcur->left = build(ptr);\n\t\t++*ptr;\n\t\tcur->right = build(ptr);\n\t\t++*ptr;\n\t}\n\treturn cur;\n}\n\nvoid destroy(Tree *t){\n\tif(t == NULL){ return; }\n\tif(t->left != NULL){ destroy(t->left); }\n\tif(t->right != NULL){ destroy(t->right); }\n\tdelete t;\n}\n\nTree *intersect(const Tree *a, const Tree *b){\n\tTree *cur = NULL;\n\tif(a != NULL && b != NULL){\n\t\tcur = new Tree();\n\t\tcur->left = intersect(a->left, b->left);\n\t\tcur->right = intersect(a->right, b->right);\n\t}\n\treturn cur;\n}\n\nTree *unite(const Tree *a, const Tree *b){\n\tTree *cur = NULL;\n\tif(a != NULL || b != NULL){\n\t\tcur = new Tree();\n\t\tcur->left = unite(\n\t\t\ta != NULL ? a->left : NULL,\n\t\t\tb != NULL ? b->left : NULL);\n\t\tcur->right = unite(\n\t\t\ta != NULL ? a->right : NULL,\n\t\t\tb != NULL ? b->right : NULL);\n\t}\n\treturn cur;\n}\n\nstring to_str(const Tree *t){\n\tstring result = \"(\";\n\tif(t->left != NULL){ result += to_str(t->left); }\n\tresult += \",\";\n\tif(t->right != NULL){ result += to_str(t->right); }\n\tresult += \")\";\n\treturn result;\n}\n\nvoid dump(Tree *t, int d = 0){\n\tif(t->left != NULL){ dump(t->left, d + 1); }\n\tcout << string(d * 2, ' ') << \"*\" << endl;\n\tif(t->right != NULL){ dump(t->right, d + 1); }\n}\n\nint main(){\n\tstring command, a, b;\n\twhile(cin >> command >> a >> b){\n\t\tconst char *sa = a.c_str();\n\t\tconst char *sb = b.c_str();\n\t\tTree *ta = build(&sa);\n\t\tTree *tb = build(&sb);\n\t\tTree *result = NULL; \n\t\tif(command == \"i\"){\n\t\t\tresult = intersect(ta, tb);\n\t\t}else if(command == \"u\"){\n\t\t\tresult = unite(ta, tb);\n\t\t}\n\t\tcout << to_str(result) << endl;\n\t\tdestroy(result);\n\t\tdestroy(ta);\n\t\tdestroy(tb);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstruct Node\n{\n\tNode* parent;\n\tNode* left;\n\tNode* right;\n};\n\nNode*  make_tree(Node* t, int* n, string s)\n{\n\tif (s.empty())\n\t\treturn NULL;\n\n\tint paren = 0;\n\tint i;\n\tfor (i = 1; paren != 0 || s[i] != ','; ++i)\n\t{\n\t\tif (s[i] == '(')\n\t\t\t++paren;\n\t\telse if (s[i] == ')')\n\t\t\t--paren;\n\t}\n\n\tint curN = (*n)++;\n\tt[curN].left = make_tree(t, n, s.substr(1, i-1));\n\tt[curN].right = make_tree(t, n, s.substr(i+1, s.size()-2-i));\n\n\treturn t + curN;\n}\n\nvoid print_intersection(Node* a, Node* b)\n{\n\tif (a == NULL || b == NULL)\n\t\treturn;\n\tputchar('(');\n\tprint_intersection(a->left, b->left);\n\tputchar(',');\n\tprint_intersection(a->right, b->right);\n\tputchar(')');\n}\nvoid print_union(Node* a, Node* b)\n{\n\tif (a == NULL && b == NULL)\n\t\treturn;\n\tputchar('(');\n\tprint_union(a ? a->left : NULL, b ? b->left : NULL);\n\tputchar(',');\n\tprint_union(a ? a->right : NULL, b ?  b->right : NULL);\n\tputchar(')');\n}\n\nint main()\n{\n\tchar ope;\n\tstring a, b;\n\twhile (cin >> ope >> a >> b)\n\t{\n\t\tconst int TreeSize = 128;\n\t\tNode treeA[TreeSize], treeB[TreeSize];\n\t\tmemset(treeA, 0, sizeof(treeA));\n\t\tmemset(treeB, 0, sizeof(treeB));\n\n\t\tint n = 0;\n\t\tNode* first =\tmake_tree(treeA, &n, a);\n\t\tn = 0;\n\t\tNode* second = make_tree(treeB, &n, b);\n\n\t\tif (ope == 'u')\n\t\t\tprint_union(first, second);\n\t\telse\n\t\t\tprint_intersection(first, second);\n\t\tprintf(\"\\n\");\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n#include <algorithm>\n\nusing namespace std;\n\nstring tree[2];\n\nstring uni(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    if (tree[1][index1] != ',') \n      for (;tree[1][index1] != ','; index1++) {\n\tleft = left + tree[1][index1];\n      }\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[0][index0] != ','; index0++) {\n      left = left + tree[0][index0];\n    }\n  } else {\n    left = uni(index0 + 1, index1 + 1);\n    for (;tree[0][index0] != ','; index0++);\n    for (;tree[1][index1] != ','; index1++);\n  }\n\n  if (tree[0][index0 + 1] == ')') {\n    int c = 0;\n    index1++;\n    while (true) {\n      if (c == 0 && tree[1][index1] == ')') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      right = right + tree[1][index1];\n      index1++;\n    }\n  } else if (tree[1][index1 + 1] == ')') {\n    int c = 0;\n    index0++;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ')') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      right = right + tree[0][index0];\n      index0++;\n    }\n  } else {\n    right = uni(index0 + 1, index1 + 1);\n  }\n  return \"(\" + left + \",\" + right + \")\";\n}\n\nstring inter(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++;\n    for (;tree[1][index1] != ','; index1++);\n  } else if (tree[1][index1 + 1] == ',') {\n    index1++;\n    for (;tree[0][index0] != ','; index0++);\n  } else {\n    left = inter(index0 + 1, index1 + 1);\n    for (;tree[0][index0] != ','; index0++);\n    for (;tree[1][index1] != ','; index1++);\n  }\n  \n  if (tree[0][index0 + 1] == ')' || tree[1][index1 + 1] == ')') {\n    right = \"\";\n  } else {\n    right = inter(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    cin.ignore();\n    if (ex == 'i') {\n      cout << inter(0, 0) << endl;\n    } else {\n      cout << uni(0, 0) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 200\nusing namespace std;\nchar opr;\nstring T[2];\nbool tree[MAX][2]; //0->A, 1->B\nbool LR[MAX];\nbool A_tree[MAX];      \n \nvoid constructTree(bool which)\n{\n  int index = 1;\n  tree[index][which] = true;\n  rep(i,MAX)LR[i] = false;//false->L, true->true\n  int w = T[which].size();\n  REP(i,1,w)\n    {\n      if(T[which][i] == '(')\n    {\n      index = index*2+(!LR[index]?0:1);\n      tree[index][which] = true;\n    }\n      else if(T[which][i] == ',')\n    LR[index] = true;\n      else\n    index /= 2;\n    }\n \n  assert(index == 0);\n}\n \nvoid constructTreePRST(string &PRST_tree,int index)\n{\n  PRST_tree += \"(\";\n  if(A_tree[index*2])constructTreePRST(PRST_tree,index*2);\n  PRST_tree += \",\";\n  if(A_tree[index*2+1])constructTreePRST(PRST_tree,index*2+1);\n  PRST_tree += \")\";\n}\n \nint main()\n{\n  while(cin >> opr >> T[0] >> T[1])\n    {\n      constructTree(false);\n      constructTree(true);\n \n      \n      if(opr == 'i')\n    {\n      rep(i,MAX)\n        A_tree[i] = tree[i][0]&tree[i][1];\n    }\n      else\n    {\n      rep(i,MAX)\n        A_tree[i] = tree[i][0]|tree[i][1];\n    }\n      string prst;\n      constructTreePRST(prst,1);\n      cout << prst << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool tree[2][100];\nenum state {l, r};\n\n\nstring draw_tree(int c, int n)\n{\n  if (c > n) return \"\";\n  if (!tree[0][c]) return \"\";\n  int l = 2*c+1;\n  int r = 2*c+2;\n  return \"(\" + draw_tree(l, n) + \",\" + draw_tree(r, n) + \")\";\n}\n\nint main()\n{\n  string str;\n  char op;\n  int  maxn[2] = {0, 0};\n\n  while (getline(cin,str))\n  {\n    for (int i=0;i<100;i++)\n    {\n      tree[0][i]=false;\n      tree[1][i]=false;\n    }\n    op = str[0];\n\n    int k=1;\n    while (str[k]==' ') k++;\n\n    int p = 0;\n    int n = -1;\n    state s;\n    while (k < str.size())\n    {\n      if (str[k]==' ')\n      {\n        p = 1;\n        n = -1;\n      }\n      else\n      {\n        if (str[k] == '(')\n        {\n          if (n == -1) { n = 0; }\n          else if (s == l) n = 2*n + 1;\n          else n = 2*n+2;\n\n          tree[p][n] = true;\n          maxn[p] = max(maxn[p], n);\n          s = l;\n        }\n        else if (str[k] == ',')\n        {\n          s = r;\n        }\n        else\n        {\n          n = (n-1) / 2;\n        }\n      }\n      k++;\n    }\n    // End tree construction\n\n    int m = max(maxn[0],maxn[1]);\n    for (int i=0;i<=m;i++)\n    {\n      if (op == 'i') tree[0][i] = tree[0][i] && tree[1][i];\n      else tree[0][i] = tree[0][i] || tree[1][i];\n    }\n\n    int num = 0;\n    for (int i=0;i<=m;i++) if (tree[0][i]) num++;\n    cout << draw_tree(0, num) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Node{\n\tNode *left,*right;\n\t\n\tNode():left(0),right(0){}\n\tNode(Node* l,Node* r):left(l),right(r){}\n\t~Node(){delete left;delete right;}\n};\n\nint parse(const string& s,int index,Node* n)\n{\n\tindex++;\n\tif(s[index]=='('){\n\t\tn->left=new Node;\n\t\tindex=parse(s,index,n->left);\n\t}\n\tindex++;\n\tif(s[index]=='('){\n\t\tn->right=new Node;\n\t\tindex=parse(s,index,n->left);\n\t}\n\tindex++;\n\treturn index;\n}\n\nvoid print(Node* n)\n{\n\tif(!n)\n\t\treturn;\n\tprintf(\"(\");\n\tprint(n->left);\n\tprintf(\",\");\n\tprint(n->right);\n\tprintf(\")\");\n}\n\nNode* tree_and(Node* n1,Node* n2)\n{\n\tif(!n1 || !n2)\n\t\treturn NULL;\n\tNode* n=new Node;\n\tif(n1->left && n2->left)\n\t\tn->left=tree_and(n1->left,n2->left);\n\tif(n1->right && n2->right)\n\t\tn->right=tree_and(n1->right,n2->right);\n\treturn n;\n}\n\nNode* tree_or(Node* n1,Node* n2)\n{\n\tif(!n1 && !n2)\n\t\treturn NULL;\n\tNode* n=new Node;\n\tif(n1 && n2){\n\t\tif(n1->left || n2->left)\n\t\t\tn->left=tree_or(n1->left,n2->left);\n\t\tif(n1->right || n2->right)\n\t\t\tn->right=tree_or(n1->right,n2->right);\n\t}\n\telse if(n1){\n\t\tif(n1->left)\n\t\t\tn->left=tree_or(n1->left,NULL);\n\t\tif(n1->right)\n\t\t\tn->right=tree_or(n1->right,NULL);\n\t}\n\telse{\n\t\tif(n2->left)\n\t\t\tn->left=tree_or(NULL,n2->left);\n\t\tif(n2->right)\n\t\t\tn->right=tree_or(NULL,n2->right);\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tfor(string op,s1,s2;cin>>op>>s1>>s2;){\n\t\tNode n1,n2;\n\t\tparse(s1,0,&n1);\n\t\tparse(s2,0,&n2);\n\t\t\n\t\tNode* res;\n\t\tif(op==\"i\")\n\t\t\tres=tree_and(&n1,&n2);\n\t\telse\n\t\t\tres=tree_or(&n1,&n2);\n\t\tprint(res);puts(\"\");\n\t\t\n\t\tdelete res;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 100000000\nusing namespace std;\nchar opr;\nstring T[2];\nbool tree[MAX][2]; //0->A, 1->B\nbool LR[MAX];\nbool A_tree[MAX];      \n\nvoid constructTree(bool which)\n{\n  int index = 1;\n  tree[index][which] = true;\n  rep(i,MAX)LR[i] = false;//false->L, true->true\n  int w = T[which].size();\n  REP(i,1,w)\n    {\n      if(T[which][i] == '(')\n\t{\n\t  index = index*2+(!LR[index]?0:1);\n\t  tree[index][which] = true;\n\t}\n      else if(T[which][i] == ',')\n\tLR[index] = true;\n      else\n\tindex /= 2;\n    }\n\n  assert(index == 0);\n}\n\nvoid constructTreePRST(string &PRST_tree,int index)\n{\n  PRST_tree += \"(\";\n  if(A_tree[index*2])constructTreePRST(PRST_tree,index*2);\n  PRST_tree += \",\";\n  if(A_tree[index*2+1])constructTreePRST(PRST_tree,index*2+1);\n  PRST_tree += \")\";\n}\n\nint main()\n{\n  while(cin >> opr >> T[0] >> T[1])\n    {\n      constructTree(false);\n      constructTree(true);\n\n     \n      if(opr == 'i')\n\t{\n\t  rep(i,MAX)\n\t    A_tree[i] = tree[i][0]&tree[i][1];\n\t}\n      else\n\t{\n\t  rep(i,MAX)\n\t    A_tree[i] = tree[i][0]|tree[i][1];\n\t}\n      string prst;\n      constructTreePRST(prst,1);\n      cout << prst << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n\nusing namespace std;\n\nconst int SIZE = 128;\nbool A[SIZE],B[SIZE],C[SIZE];\n\nint getPos(const string& s){\n  int p = 0;\n  for(int i = 0; i < (int)s.length(); i++){\n    if(s[i] == '(') p++;\n    else if(s[i] == ')') p--;\n    if(p == 0 && s[i] == ',') return i;\n  }\n  return -1;\n}\n\nvoid parse(const string& s, bool isA, int idx){\n  if(s == \"\") return;\n  if(isA) A[idx] = true;\n  else B[idx] = true;\n  string nex = s.substr(1,s.length()-2);\n  int pos = getPos(nex);\n  if(pos == -1) return;\n  string left = nex.substr(0,pos);\n  string right = nex.substr(pos+1);\n  parse(left,isA,2*idx+1);\n  parse(right,isA,2*idx+2);\n}\n\nstring makeTree(int idx){\n  if(!C[idx]) return \"\";\n  string res = \"\";\n  if(2*idx+1 < SIZE) res += makeTree(2*idx+1);\n  res += \",\";\n  if(2*idx+2 < SIZE) res += makeTree(2*idx+2);\n  res = \"(\" + res + \")\";\n  return res;\n}\n\nint main(){\n\n  char c;\n  string a,b;\n  while(cin >> c >> a >> b){\n    memset(A,false,sizeof(A));\n    memset(B,false,sizeof(B));\n    memset(C,false,sizeof(C));\n    parse(a,true,0);\n    parse(b,false,0);\n    if(c=='i') for(int i = 0; i < SIZE; i++) C[i] = A[i]&&B[i];\n    else for(int i = 0; i < SIZE; i++) C[i] = A[i]||B[i];\n    cout << makeTree(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<list>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\n\nint treeA[110];\nint treeB[110];\nint treeC[110];\n\nvoid getTree(string line,int tree, int lvl){\n\tif(line==\"\" || line==\"(\" || line==\")\")return;\n\tstack<int> cnt;\n\tint b=0;\n\twhile(line[b]!=0){\n\t\tif(line[b]=='('){\n\t\t\tcnt.push(1);\n\t\t}else if(line[b]==')'){\n\t\t\tcnt.pop();\n\t\t}else{\n\t\t\tif(cnt.size()==1)break;\n\t\t}\n\t\tb++;\n\t}\n\tline = line.substr(0,line.size()-1);\n\tstring S_R = line.substr(b+1);\n\tstring S_L = line.substr(1,b-1);\n\tgetTree(S_R,tree,2*lvl+1);\n\tgetTree(S_L,tree,2*lvl);\n\tif(tree==1){\n\t\ttreeA[lvl] = 1;\n\t}else{\n\t\ttreeB[lvl] = 2;\n\t}\n}\n\nstring imp(int lvl){\n\tif(treeC[lvl]==0)return \"\";\n\tstringstream buf;\n\tbuf<<\"(\"<<imp(2*lvl)<<\",\"<<imp(2*lvl+1)<<\")\";\n\treturn buf.str();\n}\n\nvoid unionT(){\n\tfor(int x=1;x<110;++x){\n\t\tif(treeA[x] || treeB[x])treeC[x] = 3;\n\t}\n\tcout<<imp(1)<<endl;\n}\n\nvoid inter(){\n\tfor(int x=1;x<110;++x){\n\t\tif(treeA[x] && treeB[x])treeC[x] = 3;\n\t}\n\tcout<<imp(1)<<endl;\n}\n\nint main(){\n\tchar l;\n\tstring s1,s2;\n\twhile(cin>>l>>s1>>s2 && !cin.eof()){\n\t\tfor(int x=0;x<110;++x){\n\t\t\ttreeA[x] = 0;treeB[x] = 0;treeC[x] = 0;\n\t\t}\n\t\tgetTree(s1,1,1);\n\t\tgetTree(s2,2,1);\n\t\tif(l == 'u'){\n\t\t\tunionT();\n\t\t}else{\n\t\t\tinter();\n\t\t}\n\t}\t\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n#include <algorithm>\n\nusing namespace std;\n\nstring tree[2];\n\nstring uni(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    int c = 0;\n    index0++, index1++;\n    if (tree[1][index1] != ',') \n      while (true) {\n\tif (c == 0 && tree[1][index1] == ',') {break;}\n\tif (tree[1][index1] == '(') {c++;}\n\tif (tree[1][index1] == ')') {c--;}\n\tleft = left + tree[1][index1];\n      }\n  } else if (tree[1][index1 + 1] == ',') {\n    int c = 0;\n    index0++, index1++;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ',') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      left = left + tree[0][index0];\n    }\n  } else {\n    left = uni(index0 + 1, index1 + 1);\n    int c = 0;\n    index0++, index1++;\n    while (true) {\n      //      cout << tree[0][index0];\n      if (c == 0 && tree[0][index0] == ',') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      index0++;\n    }\n    c = 0;\n    while (true) {\n      //      cout << tree[1][index1];\n      if (c == 0 && tree[1][index1] == ',') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      index1++;\n    }\n  }\n\n  if (tree[0][index0 + 1] == ')') {\n    int c = 0;\n    index1++;\n    while (true) {\n      if (c == 0 && tree[1][index1] == ')') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      right = right + tree[1][index1];\n      index1++;\n    }\n  } else if (tree[1][index1 + 1] == ')') {\n    int c = 0;\n    index0++;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ')') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      right = right + tree[0][index0];\n      index0++;\n    }\n  } else {\n    right = uni(index0 + 1, index1 + 1);\n  }\n  return \"(\" + left + \",\" + right + \")\";\n}\n\nstring inter(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    int c = 0;\n    while (true) {\n      if (c == 0 && tree[1][index1] == ',') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      index1++;\n    }\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++,index1++;\n    int c = 0;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ',') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      index0++;\n    }\n  } else {\n    left = inter(index0 + 1, index1 + 1);\n    int c = 0;\n    index0++, index1++;\n    while (true) {\n      if (c == 0 && tree[1][index1] == ',') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      index1++;\n    }\n    c = 0;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ',') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      index0++;\n    }\n  }\n  \n  if (tree[0][index0 + 1] == ')' || tree[1][index1 + 1] == ')') {\n    right = \"\";\n  } else {\n    right = inter(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    cin.ignore();\n    if (ex == 'i') {\n      cout << inter(0, 0) << endl;\n    } else {\n      cout << uni(0, 0) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct node {\n  node *l;\n  node *r;\n  node *p;\n};\n\nnode *parse(string str) {\n\n  node *base = new node({});\n  node *p = base;\n\n  bool flag = true;\n  for (auto &c : str) {\n    switch (c) {\n    case '(': {\n      node *p_new = new node({nullptr, nullptr, p});\n      if (flag)\n        p = p->l = p_new;\n      else\n        p = p->r = p_new;\n      flag = true;\n      break;\n    }\n    case ',': {\n      flag = false;\n      break;\n    }\n    case ')': {\n      p = p->p;\n      break;\n    }\n    };\n  }\n  return base->l;\n}\n\nvoid print_tree_intersection(node *tree1, node *tree2, bool endl_flag=true) {\n  if ( (tree1 == nullptr) || (tree2 == nullptr) )\n    return;\n\n  cout << '(';\n  print_tree_intersection(tree1->l, tree2->l, false);\n  cout << ',';\n  print_tree_intersection(tree1->r, tree2->r, false);\n  cout << ')';\n\n  if (endl_flag)\n    cout << endl;\n}\n\nvoid print_tree_union(node *tree1, node *tree2, bool endl_flag=true) {\n  if ( (tree1 != nullptr) && (tree2 != nullptr) ) {\n    cout << '(';\n    print_tree_union(tree1->l, tree2->l, false);\n    cout << ',';\n    print_tree_union(tree1->r, tree2->r, false);\n    cout << ')';\n  } else if ( (tree1 != nullptr) || (tree2 != nullptr) ) {\n    node *p = (tree1) ? tree1 : tree2;\n    cout << '(';\n    print_tree_union(p->l, nullptr, false);\n    cout << ',';\n    print_tree_union(p->r, nullptr, false);\n    cout << ')';\n  }\n\n  if (endl_flag)\n    cout << endl;\n}\n\nint main() {\n\n  while (true) {\n    char iu;\n    string str1, str2;\n    cin >> iu >> str1 >> str2;\n\n    if (cin.fail())\n      break;\n\n    node *tree1 = parse(str1);\n    node *tree2 = parse(str2);\n\n    if (iu == 'i')\n      print_tree_intersection(tree1, tree2);\n    else\n      print_tree_union(tree1, tree2);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 1005;\nstring dp[MAX][MAX];\n\nstring Intersect(const string& s1, const string& s2){\n  fill(dp[0],dp[0]+MAX*MAX,\"\");\n\n  for(int i = 0; i < (int)s1.length(); i++)\n    for(int j = 0; j < (int)s2.length(); j++){\n      if(s1[i] == s2[j]){\n\tstring nex = dp[i][j];\n     \tnex += s1[i];\n\tif(dp[i+1][j+1].length() < nex.length())dp[i+1][j+1] = nex;\n      }else{\n\tif(dp[i+1][j+1].length() < dp[i][j].length()) dp[i+1][j+1] = dp[i][j];\n\tif(dp[i+1][j+1].length() < dp[i+1][j].length()) dp[i+1][j+1] = dp[i+1][j];\n\tif(dp[i+1][j+1].length() < dp[i][j+1].length()) dp[i+1][j+1] = dp[i][j+1];\n      }\n    }\n\n  return dp[s1.length()][s2.length()];\n}\n\nint getRank(char c){\n  string s = \"(,)\";\n  for(int i = 0; i < (int)s.length(); i++) if(s[i] == c) return i-1;\n  return -1;\n}\n\nstring Union(const string& s1, const string& s2){\n  int p1 = 0, p2 = 0;\n  int d1 = 0, d2 = 0;\n  string ans = \"\";\n  \n  while(p1 < (int)s1.length() || p2 < (int)s2.length()){\n    if(s1[p1] == s2[p2]){\n      ans += s1[p1];\n      d1 -= getRank(s1[p1++]);\n      d2 -= getRank(s2[p2++]);\n    }else{\n\n      if(d1 == d2){\n\tint r1 = getRank(s1[p1]);\n\tint r2 = getRank(s2[p2]);\n\n\tif(r1 < r2){\n\t  d1 -= getRank(s1[p1]);\n\t  ans += s1[p1++];\n\t}else{\n\t  d2 -= getRank(s2[p2]);\n\t  ans += s2[p2++];\n\t}\n      }else{\n\tif(d1 > d2){\n\t  d1 -= getRank(s1[p1]);\n\t  ans += s1[p1++];\n\t}else{\n\t  d2 -= getRank(s2[p2]);\n\t  ans += s2[p2++];\n\t}\n      }\n    }\n  }\n  \n  //  cout << p1 << \" \" << p2 << endl;\n  return ans;\n}\n\nint main(){\n  char c;\n  string s1, s2;\n  while(cin >> c >> s1 >> s2){\n    if(c == 'i') cout << Intersect(s1,s2) << endl;\n    if(c == 'u') cout << Union(s1,s2) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=100;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  heap[id]++;\n  if(s==\"(,)\")  return;\n  \n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;   \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n      parse(sub1, 2*id+1);\n      parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nint out(int th, int id,int n){\n\n  string c(\"(,)\");\n  for(int i=0;i<3;i++)\n    output.insert(output.begin()+n+i,c[i]);\n\n  int ch1=0,ch2=0;//n of string of each child\n  \n  if(heap[id]>th){\n    if(heap[2*id+1]>th){\n      ch1=out(th,2*id+1,n+1);\n    }\n    if(heap[2*id+2]>th){\n      ch2=out(th,2*id+2,n+ch1+2);\n    }\n  }\n  return ch1+ch2+3;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  output.clear();\n  //cout<<output<<endl;\n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0,0);\n  \n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  \n  cin>>cmd>>s1>>s2\n    solve(cmd,s1,s2);\ncout<<\"hoge\";\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\n#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n\n#define BIG_NUM 2000000000\n\nusing namespace std;\n\nenum TYPE{\n\tNONE,\n\tFIRST,\n\tSECOND,\n\tLEFT,\n\tRIGHT\n};\n\nstruct Node{\n\tNode(){\n\t\tparent = first_index = address = left_child=right_child = -1;\n\t\troute_index = 0;\n\t\tcheck = false;\n\t}\n\tvoid init(){\n\t\tparent = first_index = address = left_child=right_child = -1;\n\t\troute_index = 0;\n\t\tcheck = false;\n\t}\n\n\tvoid addRoute(char dist){\n\t\troute[route_index++] = dist;\n\t\troute[route_index] = '\\0';\n\t}\n\n\tint left_child,right_child,address,route_index,first_index,parent;\n\tchar route[150];\n\tbool check;\n};\n\nbool strCmp(char* base, char* comp){\n\tint length1 = 0,length2 = 0;\n\tfor(int i=0;base[i] != '\\0'; i++)length1++;\n\tfor(int i=0;comp[i] != '\\0'; i++)length2++;\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nNode first[120],second[120],third[120];\nint first_index = 0,second_index = 0;\nchar buf[1010];\n\nTYPE toWrite;\n\nvoid recursive(int left,int right,int parent_address,TYPE left_or_right){\n\tint calcDepth,nextRight,nextLeft,nextParentAddress = -1;\n\tif(parent_address != -1){\n\t\tcalcDepth = 0;\n\t\tfor(int i = left; i <= right; i++){\n\n\t\t\tif(calcDepth==1 && buf[i] == ','){\n\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\tfirst[first_index].address = first_index; //??????????????¢?????¬???\n\t\t\t\t\tfirst[first_index].parent = parent_address;\n\t\t\t\t\tstrcpy(first[first_index].route,first[parent_address].route);\n\t\t\t\t\tfirst[first_index].route_index = first[parent_address].route_index;\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tfirst[first_index].addRoute('L');\n\t\t\t\t\t\tfirst[parent_address].left_child = first_index;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst[first_index].addRoute('R');\n\t\t\t\t\t\tfirst[parent_address].right_child = first_index;\n\t\t\t\t\t}\n\t\t\t\t\tnextParentAddress = first_index;\n\t\t\t\t\tfirst_index++;\n\t\t\t\t}else{\n\t\t\t\t\tsecond[second_index].address = second_index;\n\t\t\t\t\tsecond[second_index].parent = parent_address;\n\t\t\t\t\tstrcpy(second[second_index].route,second[parent_address].route);\n\t\t\t\t\tsecond[second_index].route_index = second[parent_address].route_index;\n\t\t\t\t\tif(left_or_right == LEFT){\n\t\t\t\t\t\tsecond[second_index].addRoute('L');\n\t\t\t\t\t\tsecond[parent_address].left_child = second_index;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[second_index].addRoute('R');\n\t\t\t\t\t\tsecond[parent_address].right_child = second_index;\n\t\t\t\t\t}\n\t\t\t\t\tnextParentAddress = second_index;\n\t\t\t\t\tsecond_index++;\n\t\t\t\t}\n\t\t\t\tnextRight = i-1;\n\t\t\t\tnextLeft = i+1;\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\t}\n\t\t}\n\n\t\tif(nextParentAddress != -1){\n\t\t\tif(left+1 < nextRight){\n\t\t\t\trecursive(left+1,nextRight,nextParentAddress,LEFT);\n\t\t\t}\n\t\t\tif(nextLeft < right-1){\n\t\t\t\trecursive(nextLeft,right-1,nextParentAddress,RIGHT);\n\t\t\t}\n\t\t}\n\n\t}else{\n\t\tcalcDepth = 0;\n\t\tfor(int i = 0; i <= right; i++){\n\t\t\tif(buf[i] == '(')calcDepth++;\n\t\t\telse if(buf[i] == ')')calcDepth--;\n\t\t\telse{\n\t\t\t\tif(calcDepth==1 && buf[i] == ','){\n\n\t\t\t\t\tif(toWrite == FIRST){\n\t\t\t\t\t\tfirst[0].address = 0;\n\t\t\t\t\t\tfirst[0].addRoute('X');\n\t\t\t\t\t\tfirst_index++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[0].address = 0;\n\t\t\t\t\t\tsecond[0].addRoute('X');\n\t\t\t\t\t\tsecond_index++;\n\t\t\t\t\t}\n\t\t\t\t\tnextRight = i-1;\n\t\t\t\t\tnextLeft = i+1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(left+1 < nextRight){\n\t\t\trecursive(left+1,nextRight,0,LEFT);\n\t\t}\n\t\tif(nextLeft < right-1){\n\t\t\trecursive(nextLeft,right-1,0,RIGHT);\n\t\t}\n\t}\n}\n\nvoid outPut(int address){\n\n\tif(third[address].left_child != -1 || third[address].right_child != -1){\n\t\tprintf(\"(\");\n\t\tif(third[address].left_child != -1){\n\t\t\toutPut(third[address].left_child);\n\t\t}else{\n\t\t\t//Do nothing\n\t\t}\n\t\tprintf(\",\");\n\t\tif(third[address].right_child != -1){\n\t\t\toutPut(third[address].right_child);\n\t\t}else{\n\t\t\t//Do nothing\n\t\t}\n\t\tprintf(\")\");\n\t}else{\n\t\tprintf(\"(,)\");\n\t}\n}\n\n\nint main(){\n\n\tchar order[2];\n\n\twhile(scanf(\"%s\",order)!= EOF){\n\n\t\tfirst_index = 0,second_index = 0;\n\n\t\tfor(int i = 0; i < 120; i++){\n\t\t\tfirst[i].init();\n\t\t\tsecond[i].init();\n\t\t\tthird[i].init();\n\t\t}\n\n\t\tscanf(\"%s\",buf);\n\t\tint length;\n\t\tfor(length = 0; buf[length] != '\\0';length++);\n\t\ttoWrite = FIRST;\n\t\trecursive(0,length-1,-1,NONE);\n\n\t\tscanf(\"%s\",buf);\n\t\tfor(length = 0; buf[length] != '\\0';length++);\n\t\ttoWrite = SECOND;\n\t\trecursive(0,length-1,-1,NONE);\n\n\t\tif(order[0] == 'i'){\n\n\t\t\tint indexTable[1000];\n\n\t\t\tindexTable[0] = 0;\n\n\t\t\tint third_index = 1;\n\n\t\t\tfor(int i = 1; i < first_index; i++){\n\t\t\t\tfor(int k = 1; k < second_index; k++){\n\t\t\t\t\tif(strCmp(first[i].route,second[k].route)){\n\t\t\t\t\t\tthird[third_index].first_index = i;\n\t\t\t\t\t\tstrcpy(third[third_index].route,first[i].route);\n\t\t\t\t\t\tthird[third_index].route_index = first[i].route_index;\n\t\t\t\t\t\tindexTable[i] = third_index;\n\t\t\t\t\t\tthird_index++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint p_tmp;\n\n\t\t\tfor(int i = 1; i < third_index; i++){\n\t\t\t\tp_tmp = indexTable[first[third[i].first_index].parent];\n\t\t\t\tif(third[i].route[third[i].route_index-1] == 'R'){\n\t\t\t\t\tthird[p_tmp].right_child = i;\n\t\t\t\t}else{\n\t\t\t\t\tthird[p_tmp].left_child = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tint third_index;\n\n\t\t\tthird[0].left_child = first[0].left_child;\n\t\t\tthird[0].right_child = first[0].right_child;\n\t\t\tstrcpy(third[0].route,first[0].route);\n\t\t\tthird[0].route_index = first[0].route_index;\n\n\t\t\tfor(third_index = 1; third_index < first_index;third_index++){\n\t\t\t\tstrcpy(third[third_index].route,first[third_index].route);\n\t\t\t\tthird[third_index].route_index = first[third_index].route_index;\n\t\t\t\tthird[third_index].left_child = first[third_index].left_child;\n\t\t\t\tthird[third_index].right_child = first[third_index].right_child;\n\t\t\t\tthird[third_index].parent = first[third_index].parent;\n\t\t\t}\n\n\t\t\tbool restFLG,loopFLG;\n\t\t\tchar work[150];\n\n\t\t\twhile(true){\n\t\t\t\trestFLG = true;\n\n\t\t\t\tfor(int i = 1; i < second_index; i++){\n\t\t\t\t\tif(second[i].check == true)continue;\n\t\t\t\t\tloopFLG = false;\n\t\t\t\t\tfor(int k = 1; k < third_index;k++){\n\t\t\t\t\t\tif(strCmp(second[i].route,third[k].route)){\n\t\t\t\t\t\t\tloopFLG = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!loopFLG){\n\t\t\t\t\t\trestFLG = false;\n\n\t\t\t\t\t\tstrcpy(work,second[i].route);\n\t\t\t\t\t\twork[second[i].route_index-1] = '\\0';\n\n\t\t\t\t\t\tfor(int k = 1; k < third_index; k++){\n\t\t\t\t\t\t\tif(strCmp(work,third[k].route)){\n\t\t\t\t\t\t\t\tif(second[i].route[second[i].route_index-1] == 'R'){\n\t\t\t\t\t\t\t\t\tthird[k].right_child = third_index;\n\t\t\t\t\t\t\t\t\tthird[third_index].parent = k;\n\t\t\t\t\t\t\t\t\tstrcpy(third[third_index].route,second[i].route);\n\t\t\t\t\t\t\t\t\tthird[third_index].route_index = second[i].route_index;\n\t\t\t\t\t\t\t\t\tthird_index++;\n\t\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t\tthird[k].left_child = third_index;\n\t\t\t\t\t\t\t\t\tthird[third_index].parent = k;\n\t\t\t\t\t\t\t\t\tstrcpy(third[third_index].route,second[i].route);\n\t\t\t\t\t\t\t\t\tthird[third_index].route_index = second[i].route_index;\n\t\t\t\t\t\t\t\t\tthird_index++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trestFLG = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(!restFLG)break;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsecond[i].check = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(restFLG)break;\n\t\t\t}\n\t\t}\n\n\t\toutPut(0);\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvoid divide(const string& s, string& s1, string& s2)\n{\n    int n = s.size();\n    int brackets = 0;\n    for(int i=1; ; ++i){\n        if(s[i] == '(')\n            ++ brackets;\n        else if(s[i] == ')')\n            -- brackets;\n        else if(brackets == 0){\n            s1 = s.substr(1, i-1);\n            s2 = s.substr(i+1, n-i-2);\n            return;\n        }\n    }\n}\n\nstring solve(const string& ope, const string& s, const string& t)\n{\n    if(s == \"\" || t == \"\"){\n        if(ope == \"i\")\n            return \"\";\n        else\n            return max(s, t);\n    }\n\n    string s1, s2, t1, t2;\n    divide(s, s1, s2);\n    divide(t, t1, t2);\n\n    return '(' + solve(ope, s1, t1) + ',' + solve(ope, s2, t2) + ')';\n}\n\nint main()\n{\n    for(;;){\n        string ope, s, t;\n        if(!(cin >> ope >> s >> t))\n            return 0;\n\n        cout << solve(ope, s, t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=1000;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  heap[id]++;\n  if(s==\"(,)\") return;\n  if(id>=N) break;\n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;  \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n      if(i-1>=0) parse(sub1, 2*id+1);\n      if(s.length()-i-2>=0)parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nvoid out(int th, int id){\n\n  output.push_back('(');\n\n  int ch1=0,ch2=0;//n of string of each child\n  \n  if(heap[id]>th && heap[2*id+1]>th){\n    out(th,2*id+1);\n  }\n  output.push_back(',');\n  if(heap[id]>th && heap[2*id+2]>th){\n    out(th,2*id+2);\n  }\n  \n  output.push_back(')');\n  return;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  output.clear();\n  //cout<<output<<endl;\n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0);\n  \n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  int i=0;\n  \n  while(cin>>cmd>>s1>>s2){\n    solve(cmd,s1,s2);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nstring tree[2];\nbitset<1000> node[2];\n\nvoid perse(int index, int n, int i)\n{\n  //cout << \"persed \" << n << endl;\n  if (index == tree[i].size() - 1) {\n    return;\n  }\n  if (tree[i][index] == '(') {\n    node[i][n] = true;\n    perse(index + 1, 2 * n + 1, i);\n  } else if (tree[i][index] == ')') {\n    perse(index + 1, (n - 2) / 2, i);\n  } else {\n    perse(index + 1, n + 1, i);\n  }\n}\n\nstring _perse(int index)\n{\n  if (node[0][index]) {\n    return \"(\" + _perse(2 * index + 1) + \",\" + _perse(2 * index + 2) + \")\";\n  }\n  return \"\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    for (int i = 0; i < 2; i++) {\n      node[i].reset();\n      perse(0, 0, i);\n      \n      /*for (int j = 0; j < 300; j++) {\n\tif (node[i][j]) {\n\t  cout << j;\n\t}\n      }\n      cout << endl;*/\n    }\n    if (ex == 'u') {\n      node[0] |= node[1];\n    } else {\n      node[0] &= node[1];\n    }\n  \n    cout << _perse(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nstring tree[2];\nbitset<300> node[2];\n\nvoid perse(int index, int n, int i)\n{\n  //cout << \"persed \" << n << endl;\n  if (index == tree[i].size() - 1) {\n    return;\n  }\n  if (tree[i][index] == '(') {\n    node[i][n] = true;\n    perse(index + 1, 2 * n + 1, i);\n  } else if (tree[i][index] == ')') {\n    perse(index + 1, (n - 2) / 2, i);\n  } else {\n    perse(index + 1, n + 1, i);\n  }\n}\n\nstring _perse(int index)\n{\n  if (node[0][index]) {\n    return \"(\" + _perse(2 * index + 1) + \",\" + _perse(2 * index + 2) + \")\";\n  }\n  return \"\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    for (int i = 0; i < 2; i++) {\n      node[i].reset();\n      perse(0, 0, i);\n      \n      /*for (int j = 0; j < 300; j++) {\n\tif (node[i][j]) {\n\t  cout << j;\n\t}\n      }\n      cout << endl;*/\n    }\n    if (ex == 'u') {\n      node[0] |= node[1];\n    } else {\n      node[0] &= node[1];\n    }\n  \n    cout << _perse(0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nstring tree[2];\nbitset<1000> node[2];\n\nvoid perse(int index, int n, int i)\n{\n  //cout << \"persed \" << n << endl;\n  if (index == tree[i].size() - 1) {\n    return;\n  }\n  if (tree[i][index] == '(') {\n    node[i][n] = true;\n    perse(index + 1, 2 * n + 1, i);\n  } else if (tree[i][index] == ')') {\n    perse(index + 1, (((n - 2) / 2 < 0) ? 0 : (n - 2) / 2), i);\n  } else {\n    perse(index + 1, n + 1, i);\n  }\n}\n\nstring _perse(int index)\n{\n  if (node[0][index]) {\n    return \"(\" + _perse(2 * index + 1) + \",\" + _perse(2 * index + 2) + \")\";\n  }\n  return \"\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    for (int i = 0; i < 2; i++) {\n      node[i].reset();\n      perse(0, 0, i);\n      \n      /*for (int j = 0; j < 300; j++) {\n\tif (node[i][j]) {\n\t  cout << j;\n\t}\n      }\n      cout << endl;*/\n    }\n    if (ex == 'u') {\n      node[0] |= node[1];\n    } else {\n      node[0] &= node[1];\n    }\n  \n    cout << _perse(0) << endl;\n    cin.ignore();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#coding : utf-8\n\n# version 1.0 2017/02/10  ??????????????¨???????????????\n# version 1.1 2017/02/11???????????????????°????????????????????????¶??§??????\n# version 1.2 2017/02/11???AOJ??????????????°??????\n# version 1.3 2017/02/12  ?§£????????????????????????????????¨?????§?????????????????????\n\nimport requests,sys\nimport time\nfrom selenium import webdriver\nfrom bs4 import BeautifulSoup\nimport xerox\n\ndef main():\n    print(\"Hello! This is The AOJ Chaser!\")\n    user_url='http://judge.u-aizu.ac.jp/onlinejudge/webservice/user'\n    problem_url='http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id='\n\n    # ????´¢?????????id?????\\???\n    rival_id='minaminao'\n    my_id='oshibori'\n    my_password='1225tomoki'\n    if not my_id :\n        print('Input your id!', end=' ')\n        my_id=input()\n    if not my_password :\n        print('Input your password!', end=' ')\n        my_password=input()\n    if not rival_id :\n        print('Input your rival\\'s id!', end=' ')\n        rival_id=input()\n\n\n\n    # ??????????????????\n    myparams={'id':my_id}                   #  ME\n    mydata=requests.get(user_url,params=myparams)\n    rivalparams={'id':rival_id}               #  RIVAL\n    rivaldata=requests.get(user_url,params=rivalparams)\n\n    # ??????????????????\n    mysoup=BeautifulSoup(mydata.text,\"html.parser\")\n    rivalsoup=BeautifulSoup(rivaldata.text,\"html.parser\")\n    table={}\n    cnt=0\n    result_list=[]\n    for i in mysoup.findAll('problem'):\n        table[int(i.id.string)]=1;\n\n    for i in rivalsoup.findAll('problem'):\n        x=int(i.id.string)\n        try:\n            table[x]=table[x]-1\n        except:\n            print(x)\n\n            result_list.append([int(i.judge_id.string),i.id.string])\n            cnt=cnt+1\n\n\n    print('')\n\n    result_list.sort(key=lambda x:x[0])\n    #result_list.sort(key=lambda x:x[1])\n    #for i in result_list:\n    #    print(i[1])\n    print('Sum is ',end='')\n    print(cnt)\n\n    index=0\n    while True:\n        #??????????????¶?????????\n        browser=webdriver.Chrome('./chromedriver')\n        #?????????????????¨?§?\n        browser.get(problem_url + result_list[index][1])\n        # ?????°??????\n        loginform=browser.find_element_by_id('user')\n        loginform.find_element_by_id('login').click()\n\n        loginUserID=loginform.find_element_by_name('loginUserID')\n        loginPassword=loginform.find_element_by_name('loginPassword')\n\n        loginUserID.send_keys(my_id)\n        loginPassword.send_keys(my_password)\n\n        logininput=loginform.find_element_by_id('logininput')\n        logininput.submit()\n        index=index+1\n\n        #???????????????\n        submit_url='http://judge.u-aizu.ac.jp/onlinejudge/status.jsp#submit/'+ result_list[index][1]\n        if browser.current_url == submit_url:\n            submit_area=browser.find_element_by_id('submitArea')\n            select=submit_area.find_element_by_id('submit_language')\n            select.click()\n            select.find_elements_by_tag_name('option')[4].click()  # C++14\n            select.click()\n            \n            source=submit_area.find_element_by_id('submit_source')\n            \n            \n        # ???????????????????????????????????????\n        print(browser.title)\n        print(\".....END.....\")\n\n        #????¶??¶???????\n        com = input()\n        browser.quit()\n        if com == 'done' or com == 'fin' :\n            break;\n\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<int, int>;\n\nstring tree(const string &s, int &pos){\n\tstring chl, chr;\n\t++pos;\n\tif (s[pos] == '(') chl = tree(s, pos);\n\t++pos;\n\tif (s[pos] == '(') chr = tree(s, pos);\n\t++pos;\n\treturn \"(\" + chl + \",\" + chr + \")\";\n}\n\nchar c;\nstring a, b;\nint p1, p2;\n\nstring and(){\n\t++p1, ++p2;\n\n\tstring chl, chr;\n\tif (a[p1] == '(' && b[p2] == '('){\n\t\tchl = and();\n\t}\n\telse if (a[p1] == '('){\n\t\ttree(a, p1);\n\t}\n\telse if (b[p2] == '('){\n\t\ttree(b, p2);\n\t}\n\n\t++p1, ++p2;\n\n\tif (a[p1] == '(' && b[p2] == '('){\n\t\tchr = and();\n\t}\n\telse if (a[p1] == '('){\n\t\ttree(a, p1);\n\t}\n\telse if (b[p2] == '('){\n\t\ttree(b, p2);\n\t}\n\n\t++p1, ++p2;\n\n\treturn \"(\" + chl + \",\" + chr + \")\";\n}\n\nstring or(){\n\t++p1, ++p2;\n\n\tstring chl, chr;\n\tif (a[p1] == '(' && b[p2] == '('){\n\t\tchl = or();\n\t}\n\telse if (a[p1] == '('){\n\t\tchl = tree(a, p1);\n\t}\n\telse if (b[p2] == '('){\n\t\tchl = tree(b, p2);\n\t}\n\n\t++p1, ++p2;\n\n\tif (a[p1] == '(' && b[p2] == '('){\n\t\tchr = and();\n\t}\n\telse if (a[p1] == '('){\n\t\tchr = tree(a, p1);\n\t}\n\telse if (b[p2] == '('){\n\t\tchr = tree(b, p2);\n\t}\n\n\t++p1, ++p2;\n\n\treturn \"(\" + chl + \",\" + chr + \")\";\n}\n\nint main(){\n\twhile (cin >> c >> a >> b){\n\t\tp1 = p2 = 0;\n\n\t\tif (c == 'i') cout << and() << endl;\n\t\telse cout << or() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n    else \n      return max(strL, strR);\n  }\n\n  string sL1, sL2, sR1, sR2;\n  divide(strL, sL1, sL2);\n  divide(strR, sR1, sR2)\n\n  return \"(\" + solve(op, sL1, sL2) + \",\" + solve(op, s2, t2) + \")\";\n}\n\nint main() {"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=1000;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  heap[id]++;\n  if(s==\"(,)\") return;\n  \n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;   \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n      if(i<i-1) parse(sub1, 2*id+1);\n      if(i+1<s.length()-i-2)parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nvoid out(int th, int id){\n\n  output.push_back('(');\n\n  int ch1=0,ch2=0;//n of string of each child\n  \n  if(heap[id]>th && heap[2*id+1]>th){\n    out(th,2*id+1);\n  }\n  output.push_back(',');\n  if(heap[id]>th && heap[2*id+2]>th){\n    out(th,2*id+2);\n  }\n  \n  output.push_back(')');\n  return;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  output.clear();\n  //cout<<output<<endl;\n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0);\n  \n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  int i=0;\n  \n  while(cin>>cmd>>s1>>s2){\n    solve(cmd,s1,s2);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <string>\n#include <iostream>\n\n\nusing namespace std;\n\nvoid make_tree(bool* tree, int node, string s)\n{\n\tif (s.empty())\n\t\treturn;\n\n\ttree[node] = true;\n\n\tint paren = 0;\n\tint i;\n\tfor (i = 1; paren != 0 || s[i] != ','; ++i)\n\t{\n\t\tif (s[i] == '(')\n\t\t\t++paren;\n\t\telse if (s[i] == ')')\n\t\t\t--paren;\n\t}\n\tmake_tree(tree, node*2+1, s.substr(1, i-1));\n\tmake_tree(tree, node*2+2, s.substr(i+1, s.size()-2 -i));\n}\n\nstring to_s(bool* tree, int node)\n{\n\tif (!tree[node])\n\t\treturn \"\";\n\telse\n\t\treturn \"(\" + to_s(tree, node*2+1) + \",\" + to_s(tree, node*2+2) + \")\";\n}\n\nint main()\n{\n\tchar ope;\n\tstring s1, s2;\n\tconst int TreeSize = 256;\n\tbool tree1[TreeSize], tree2[TreeSize], tree[TreeSize];\n\n\twhile (cin >> ope >> s1 >> s2)\n\t{\n\t\tfill(tree1, tree1+TreeSize, false);\n\t\tfill(tree2, tree2+TreeSize, false);\n\n\t\tmake_tree(tree1, 0, s1);\n\t\tmake_tree(tree2, 0, s2);\n\n\t\tif (ope == 'i')\n\t\t\tfor (int i = 0; i < TreeSize; ++i)\n\t\t\t\ttree[i] = tree1[i] & tree2[i];\n\t\telse\n\t\t\tfor (int i = 0; i < TreeSize; ++i)\n\t\t\t\ttree[i] = tree1[i] | tree2[i];\n\n\t\tcout << to_s(tree, 0) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nstruct Tree {\n    Tree *l, *r;\n};\n \nTree *tree[2];\n \nTree* make_node()\n{\n    Tree *t = new Tree;\n    t->l = t->r = NULL;\n    return t;\n}\n \nvoid init()\n{    \n    tree[0] = make_node();\n    tree[1] = make_node();\n}\n  \nbool search_left_node(int &cur, string &s)\n{\n    int p = 0;\n    for (int i = cur; i >= 1; i--) {\n        if (s[i] == ')') {\n            p++;\n        } else if (s[i] == '(') {\n            p--;\n        }\n        if (s[i] == ',' && p == 1) {\n            cur = i;\n            return 1;\n        }\n        if (p < 0) return 0;\n    }\n    return 0;\n}\n \nbool search_right_node(int &cur, string &s)\n{\n    int p = 0;\n    for (int i = cur; i < (int)s.size()-1; i++) {\n        if (s[i] == '(') {\n            p++;\n        } else if (s[i] == ')') {\n            p--;\n        }\n        if (s[i] == ',' && p == 1) {\n            cur = i;\n            return 1;\n        }\n        if (p < 0) return 0;\n    }\n    return 0;\n}\n \nvoid add_left(Tree *t)\n{\n    t->l = make_node();\n}\n \nvoid add_right(Tree *t)\n{\n    t->r = make_node();\n}\n \nvoid dfs(int cur, string &s, Tree *t)\n{\n    int L = cur - 1, R = cur + 1;\n    if (search_left_node(L, s)) {        \n        add_left(t);\n        dfs(L, s, t->l);\n    }\n    if (search_right_node(R, s)) {\n        add_right(t);\n        dfs(R, s, t->r);\n    }\n}\n  \nstring make_i_tree(Tree *t1, Tree *t2)\n{\n    string l, r;\n    if (t1->l != NULL && t2->l != NULL) {\n        l = make_i_tree(t1->l, t2->l);\n    } \n        \n    if (t1->r != NULL && t2->r != NULL) {\n        r = make_i_tree(t1->r, t2->r);\n    }\n    return \"(\" + l + \",\" + r + \")\";\n}\n\nstring make_u_tree(Tree *t1, Tree *t2)\n{\n    string l, r;\n    if (t1->l != NULL || t2->l != NULL) {\n        if (t1->l == NULL) add_left(t1);\n        if (t2->l == NULL) add_left(t2);\n        l = make_u_tree(t1->l, t2->l);\n    } \n        \n    if (t1->r != NULL || t2->r != NULL) {\n        if (t1->r == NULL) add_right(t1);\n        if (t2->r == NULL) add_right(t2);\n        r = make_u_tree(t1->r, t2->r);\n    }\n    return \"(\" + l + \",\" + r + \")\";\n}\n\nint get_root(string &s)\n{\n    int depth = 0;\n    for (int i = 1; i < (int)s.size(); i++) {\n        if (s[i] == '(') depth++;\n        else if (s[i] == ')') depth--;\n        if (depth == 0 && s[i] == ',') {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid solve(char order, string &a, string &b)\n{\n    int cur_a = get_root(a), cur_b = get_root(b);   \n    init();\n    \n    dfs(cur_a, a, tree[0]);\n    dfs(cur_b, b, tree[1]);\n    \n    if (order == 'i') {\n        cout << make_i_tree(tree[0], tree[1]) << endl;\n    } else {\n        cout << make_u_tree(tree[0], tree[1]) << endl;\n    }\n}\n \nint main()\n{\n    char order;\n    string a, b;\n    while (cin >> order >> a >> b) {\n        solve(order, a, b);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef string::iterator S;\nconst int MAX = 105;\n\nstruct Node{\n    Node* left;\n    Node* right;\n};\n\n\nvoid makeTree(Node*& ni, S& s){\n    s++;\n    Node* tmp = ni;\n    if( *s == '(' ){\n        ni->left = tmp+1;\n        tmp++;\n        makeTree(tmp, s);\n    }else{\n        tmp->left = NULL;\n    }\n    s++;\n    if( *s == '(' ){\n        ni->right = tmp+1;\n        tmp++;\n        makeTree(tmp, s);\n    }else{\n        tmp->right = NULL;\n    }\n    ni = tmp;\n    s++;\n}\n\nvoid showIntersect(Node* n1, Node* n2){\n    cout << \"(\";\n    Node *p1 = n1?n1->left:NULL, *p2 = n2?n2->left:NULL;\n    if( p1 && p2 ){\n        showIntersect(p1, p2);\n    }\n    cout << \",\";\n    p1 = n1?n1->right:NULL, p2 = n2?n2->right:NULL;\n    if( p1 && p2 ){\n        showIntersect(p1, p2);\n    }\n    cout << \")\";\n}\n\nvoid showUnion(Node* n1, Node* n2){\n    cout << \"(\";\n    Node *p1 = n1?n1->left:NULL, *p2 = n2?n2->left:NULL;\n    if( p1 || p2 ){\n        showUnion(p1, p2);\n    }\n    cout << \",\";\n    p1 = n1?n1->right:NULL, p2 = n2?n2->right:NULL;\n    if( p1 || p2 ){\n        showUnion(p1, p2);\n    }\n    cout << \")\";\n}\n\nint main(){\n    while(true){\n        string cmd, str1, str2;\n        cin >> cmd >> str1 >> str2;\n        if(cmd.length()==0) break;\n        Node t1[MAX], t2[MAX];\n        for(int i = 0; i < MAX; i++){\n            t1[i].left = NULL;\n            t1[i].right = NULL;\n            t2[i].left = NULL;\n            t2[i].right = NULL;\n        }\n        Node* i1 = t1;\n        Node* i2 = t2;\n        S s1 = str1.begin();\n        S s2 = str2.begin();\n        makeTree(i1, s1);\n        makeTree(i2, s2);\n        if(cmd == \"i\"){\n            showIntersect(t1, t2);\n        }else{\n            showUnion(t1, t2);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nstring in[50000];\nint linum, N;\n\nstruct object {\n  vector<string> key;\n  vector<string> property;\n  vector<object *>child;\n};\n\nobject *parse(int pindent = -1) {\n  object *res = new object;\n  \n  while(linum<N) {\n    int indent = 0;\n    for(;in[linum][indent]==' ';) indent++;\n    if( indent<=pindent ) break;\n    \n    int colon = in[linum].find(\":\");\n    string key = in[linum].substr(indent, colon-indent);\n    if(colon==in[linum].size()-1){\n      res->key.push_back(key);\n      res->property.push_back(\"__object\");\n      \n      linum++;\n      res->child.push_back(parse(indent));\n    } else {\n      res->key.push_back(key);\n      res->property.push_back(in[linum].substr(colon+2));\n      res->child.push_back(NULL);\n\n      linum++;\n    }\n  }\n  return res;\n}\n\nconst string NG = \"no such property\";\n\nstring find(const object* root, const vector<string>v) {\n  for(int i=0; i<v.size()-1; i++) {\n    bool ok = 0;\n    for(int j=0; j<root->key.size(); j++) {\n      if(root->key[j]==v[i]) {\n\tif(root->property[j]!=\"__object\") break;\n\troot=root->child[j];\n\tok = 1;\n\tbreak;\n      }\n    }\n    if(!ok) return NG;\n  }\n  \n  for(int i=0; i<root->key.size(); i++) {\n    if(root->key[i]==v.back()) {\n      if(root->property[i]==\"__object\") return \"object\";\n      else return \"string \\\"\" + root->property[i] + \"\\\"\";\n    }\n  }\n  return NG;\n}\n\nint main() {\n  \n  vector<string> Query;\n  string query;\n  getline(cin, query);\n  for(int i=0; i<query.size(); i++) if(query[i] == '.') query[i] = ' ';\n  stringstream ss(query);\n  while(ss>>query) Query.push_back(query);\n  \n  linum = 0;\n  N = 0;\n  while(getline(cin, in[N])) N++;\n  object *yaml = parse();\n  \n  cout << find(yaml, Query) << endl;\n  \n  return 0;\n}\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n/////aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<list>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\n#include<string>\nusing namespace std;\n\nstruct Node{\n\tNode *left,*right;\n\tNode(){\n\t\tleft = right = NULL;\n\t}\n};\n\nNode *getTree(string line){\n\tif(line==\"\" || line==\"(\" || line==\")\")return NULL;\n\tNode *newNode = new Node();\n\tint b = 0;\n\tstack<int> cnt;\n\twhile(line[b]!=0){\n\t\tif(line[b]=='('){\n\t\t\tcnt.push(1);\n\t\t}else if(line[b]==')'){\n\t\t\tcnt.pop();\n\t\t}else{\n\t\t\tif(cnt.size()==1)break;\n\t\t}\t\n\t\tb++;\n\t}\n\tstring S_R = \"\", S_L = \"\";\n\tfor(int x=1;x<b;++x){\n\t\tS_L += line[x];\n\t}\n\tfor(int x=b+1;x<line.size()-1;++x){\n\t\tS_R += line[x];\n\t}\n\tnewNode->left = getTree(S_L);\n\tnewNode->right = getTree(S_R);\n\treturn newNode;\n}\n\nNode *unionT(Node* treeA,Node* treeB){\n\tif(treeA == NULL && treeB==NULL)return NULL;\n\tNode *newNode = new Node();\n\tNode *ll,*rl,*lr,*rr;\n\tif(treeA == NULL){\n\t\tll = NULL;\n\t\tlr = NULL;\n\t}else{\n\t\tll = treeA->left;\n\t\tlr = treeA->right;\n\t}\n\tif(treeB == NULL){\n\t\trl = NULL;\n\t\trr = NULL;\n\t}else{\t\t\n\t\trl = treeB->left;\n\t\trr = treeB->right;\n\t}\n\tnewNode->left = unionT(ll,rl);\n\tnewNode->right = unionT(lr,rr);\n\treturn newNode;\n}\n\nNode *interT(Node* treeA,Node* treeB){\n\tif(treeA == NULL || treeB == NULL)return NULL;\n\tNode *newNode = new Node();\t\n\tNode *ll = treeA->left, *lr = treeA->right, *rl = treeB->left, *rr = treeB->right;\n\tnewNode->left = interT(ll,rl);\n\tnewNode->right = interT(lr,rr);\n\treturn newNode;\n}\n\nstring imp(Node *root){\n\tif(root==NULL)return \"\";\n\tstringstream buf;\n\tbuf<<\"(\"<<imp(root->left)<<\",\"<<imp(root->right)<<\")\";\n\treturn buf.str();\n}\n\nint main(){\n\tchar c;\n\tstring s1,s2;\n\twhile(scanf(\" %c \",&c)!=EOF){\n\t\tcin>>s1>>s2;\n\t\tNode *treeA,*treeB,*treeC=NULL;\n\t\ttreeA = getTree(s1);\n\t\ttreeB = getTree(s2);\n\t\tif(c=='u'){\n\t\t\ttreeC = unionT(treeA,treeB);\n\t\t}else{\n\t\t\ttreeC = interT(treeA,treeB);\n\t\t}\n\t\tcout<<imp(treeC)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\nusing namespace std;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n\nstruct Tree {\n    Tree * ch[2];\n    Tree(){\n        ch[0] = ch[1] = nullptr;\n    }\n};\n\nTree * parse(string::iterator b, string::iterator e){\n    if(b==e) return nullptr;\n    auto res = new Tree();\n    int d = 0;\n    for(auto it = b; it != e; ++it){\n        if(*it=='('){\n            d++;\n        } else if(*it==','){\n            if(d==1){\n                res->ch[0] = parse(b+1,it);\n                res->ch[1] = parse(it+1,e-1);\n            }\n        } else if(*it==')'){\n            d--;\n        }\n    }\n    return res;\n}\n\nTree * intersect(Tree * t, Tree * u){\n    Tree * res = new Tree();\n    rep(i,2){\n        if(t->ch[i]!=nullptr && u->ch[i]!=nullptr){\n            res->ch[i] = intersect(t->ch[i],u->ch[i]);\n        }\n    }\n    return res;\n}\n\nTree * unite(Tree * t, Tree * u){\n    if(t==nullptr && u==nullptr) return nullptr;\n    Tree * res = new Tree();\n    if(t!=nullptr && u!=nullptr){\n        rep(i,2) res->ch[i] = unite(t->ch[i], u->ch[i]);\n    } else {\n        if(t==nullptr) swap(t,u);\n        rep(i,2) res->ch[i] = unite(t->ch[i], nullptr);\n    }\n    return res;\n}\n\nvoid print(Tree* t){\n    cout << \"(\";\n    if(t->ch[0] != nullptr) print(t->ch[0]);\n    cout << \",\";\n    if(t->ch[1] != nullptr) print(t->ch[1]);\n    cout << \")\";\n}\n\nint main(){\n    char c;\n    while(cin>>c){\n        string s,t; cin >> s >> t;\n        auto a = parse(all(s)), b = parse(all(t));\n        if(c=='i') print(intersect(a,b));\n        else print(unite(a,b));\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool tree[2][100];\nenum state {l, r};\n\n\nstring draw_tree(int c, int n)\n{\n  if (c > n) return \"\";\n  if (!tree[0][c]) return \"\";\n  int l = 2*c+1;\n  int r = 2*c+2;\n  return \"(\" + draw_tree(l, n) + \",\" + draw_tree(r, n) + \")\";\n}\n\nint main()\n{\n  string str;\n  char op;\n  int  maxn[2] = {0, 0};\n\n  while (getline(cin,str))\n  {\n    for (int i=0;i<100;i++)\n    {\n      tree[0][i]=false;\n      tree[1][i]=false;\n    }\n    op = str[0];\n\n    int k=1;\n    while (str[k]==' ') k++;\n\n    int p = 0;\n    int n = -1;\n    state s;\n    while (k < str.size())\n    {\n      if (str[k]==' ')\n      {\n        p = 1;\n        n = -1;\n      }\n      else\n      {\n        if (str[k] == '(')\n        {\n          if (n == -1) { n = 0; }\n          else if (s == l) n = 2*n + 1;\n          else n = 2*n+2;\n\n          tree[p][n] = true;\n          maxn[p] = max(maxn[p], n);\n          s = l;\n        }\n        else if (str[k] == ',')\n        {\n          s = r;\n        }\n        else\n        {\n          n = (n-1) / 2;\n        }\n      }\n      k++;\n    }\n    // End tree construction\n\n    int m = max(maxn[0],maxn[1]);\n    for (int i=0;i<=m;i++)\n    {\n      if (op == 'i') tree[0][i] = tree[0][i] && tree[1][i];\n      else tree[0][i] = tree[0][i] || tree[1][i];\n    }\n\n    int num = 0;\n    for (int i=0;i<=m;i++) if (tree[0][i]) num++;\n    cout << draw_tree(0, num) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct no{\n  no *left,*right;\n  no(){left=right=NULL;}\n};\ntypedef no* node;\nstring s[2];\nint n;\nnode con(int l,int r){\n  node po=new no();\n  int p=0,c=-1;\n  for(int i=l+1;i<r;i++)\n    if(s[n][i]=='(')p++;\n    else if(s[n][i]==')')p--;\n    else if(s[n][i]==','&&!p){\n      c=i;\n      break;\n    }\n  if(l+1!=c)po->left=con(l+1,c-1);\n  if(r-1!=c)po->right=con(c+1,r-1);\n  return po;\n}\nstring init(node a,node b){\n  string l,r;\n  if(a->left!=NULL&&b->left!=NULL)\n    l=init(a->left,b->left);\n  if(a->right!=NULL&&b->right!=NULL)\n    r=init(a->right,b->right);\n  return \"(\"+l+\",\"+r+\")\";\n}\nstring unit(node a,node b){\n  string l,r;\n  if((a!=NULL&&a->left!=NULL)||(b!=NULL&&b->left!=NULL))\n    l=unit((a!=NULL?a->left:a),(b!=NULL?b->left:b));\n  if((a!=NULL&&a->right!=NULL)||(b!=NULL&&b->right!=NULL))\n    r=unit((a!=NULL?a->right:a),(b!=NULL?b->right:b));\n  return \"(\"+l+\",\"+r+\")\";\n}\nint main(){\n  string s1;\n  while(cin>>s1>>s[0]>>s[1]){\n    n=0;node a=con(0,s[0].size()-1);\n    n=1;node b=con(0,s[1].size()-1);\n    if(s1==\"i\")cout<<init(a,b)<<endl;\n    else cout<<unit(a,b)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 10000\nusing namespace std;\nchar opr;\nstring T[2];\nbool tree[MAX][2]; //0->A, 1->B\nbool LR[MAX];\nbool A_tree[MAX];      \n\nvoid constructTree(bool which)\n{\n  int index = 1;\n  tree[index][which] = true;\n  rep(i,MAX)LR[i] = false;//false->L, true->true\n  int w = T[which].size();\n  REP(i,1,w)\n    {\n      if(T[which][i] == '(')\n\t{\n\t  index = index*2+(!LR[index]?0:1);\n\t  tree[index][which] = true;\n\t}\n      else if(T[which][i] == ',')\n\tLR[index] = true;\n      else\n\tindex /= 2;\n    }\n\n  assert(index == 0);\n}\n\nvoid constructTreePRST(string &PRST_tree,int index)\n{\n  PRST_tree += \"(\";\n  if(A_tree[index*2])constructTreePRST(PRST_tree,index*2);\n  PRST_tree += \",\";\n  if(A_tree[index*2+1])constructTreePRST(PRST_tree,index*2+1);\n  PRST_tree += \")\";\n}\n\nint main()\n{\n  while(cin >> opr >> T[0] >> T[1])\n    {\n      constructTree(false);\n      constructTree(true);\n\n     \n      if(opr == 'i')\n\t{\n\t  rep(i,MAX)\n\t    A_tree[i] = tree[i][0]&tree[i][1];\n\t}\n      else\n\t{\n\t  rep(i,MAX)\n\t    A_tree[i] = tree[i][0]|tree[i][1];\n\t}\n      string prst;\n      constructTreePRST(prst,1);\n      cout << prst << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nchar c;\nstring T1, T2;\nint p1, p2;\n\nvoid recS( string &T, int &p ){\n    for ( int i = 0; i < 2; i++ ){\n\tif ( T[p] == '(' ) {\n\t    if ( c == 'u' ) cout << '(';\n\t    p++; recS(T, p); p++;\n\t    if ( c == 'u' ) cout << ')';\n\t} else {\n\t    p++;\n\t}\n\tif ( i == 0 && c == 'u' ) cout << ',';\n    }\n}\n\nvoid rec(){\n    for ( int i = 0; i < 2; i++ ){\n\tif ( T1[p1] == '(' && T2[p2] == '(' ){\n\t    cout << '('; p1++; p2++;\n\t    rec();\n\t    p1++; p2++; cout << ')';\n\t} else if ( T1[p1] == '(' ){\n\t    if ( c == 'u' ) cout << \"(\";\n\t    p1++; recS( T1, p1); p1++;\n\t    p2++;\n\t    if ( c == 'u' ) cout << \")\";\n\t} else if ( T2[p2] == '(' ){\n\t    if ( c == 'u' ) cout << \"(\";\n\t    p2++; recS( T2, p2); p2++;\n\t    p1++;\n\t    if ( c == 'u' ) cout << \")\";\n\t} else {\n\t    p1++; p2++;\n\t}\n\tif ( i == 0 ) cout << ',';\n    }\n}\n\nint main(){\n    while( cin >> c ){\n\tcin >> T1 >> T2;\n\tp1 = p2 = 1;\n\tcout << '(' ; rec(); cout << ')' << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=1000;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  heap[id]++;\n  if(s==\",\") return;\n  \n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;  \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n      if(i-1>=0) parse(sub1, 2*id+1);\n      if(s.length()-i-2>=0)parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nvoid out(int th, int id){\n\n  output.push_back('(');\n\n  int ch1=0,ch2=0;//n of string of each child\n  \n  if(heap[id]>th && heap[2*id+1]>th){\n    out(th,2*id+1);\n  }\n  output.push_back(',');\n  if(heap[id]>th && heap[2*id+2]>th){\n    out(th,2*id+2);\n  }\n  \n  output.push_back(')');\n  return;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  output.clear();\n  //cout<<output<<endl;\n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0);\n  \n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  int i=0;\n  \n  while(cin>>cmd>>s1>>s2){\n    solve(cmd,s1,s2);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=1000;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  heap[id]++;\n  if(s==\"(,)\")  return;\n  \n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;   \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n      parse(sub1, 2*id+1);\n      parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nvoid out(int th, int id){\n\n  output.push_back('(');\n\n  int ch1=0,ch2=0;//n of string of each child\n  if(id*2+1>=N) cout<<\"error: undefined index\\n\";\n  \n  if(heap[id]>th && heap[2*id+1]>th){\n    out(th,2*id+1);\n  }\n  output.push_back(',');\n  if(heap[id]>th && heap[2*id+2]>th){\n    out(th,2*id+2);\n  }\n  \n  output.push_back(')');\n  return;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  output.clear();\n  //cout<<output<<endl;\n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0);\n  \n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  int i=0;\n  \n  while(cin>>cmd>>s1>>s2){\n    solve(cmd,s1,s2);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nstring tree[2];\nbitset<1000> node[2];\n\nvoid perse(int index, int n, int i)\n{\n  //cout << \"persed \" << n << endl;\n  if (index >= tree[i].size()) {\n    return;\n  }\n  if (tree[i][index] == '(') {\n    while (tree[i][index] == ' ') {index++;}\n    node[i][n] = true;\n    perse(index + 1, 2 * n + 1, i);\n  } else if (tree[i][index] == ')') {\n    while (tree[i][index] == ' ') {index++;}\n    perse(index + 1, (((n - 2) / 2 < 0) ? 0 : (n - 2) / 2), i);\n  } else if (\",\"){\n    while (tree[i][index] == ' ') {index++;}\n    perse(index + 1, n + 1, i);\n  }\n}\n\nstring _perse(int index)\n{\n  if (node[0][index]) {\n    return \"(\" + _perse(2 * index + 1) + \",\" + _perse(2 * index + 2) + \")\";\n  }\n  return \"\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    for (int i = 0; i < 2; i++) {\n      node[i].reset();\n      perse(0, 0, i);\n      \n      /*for (int j = 0; j < 300; j++) {\n\tif (node[i][j]) {\n\t  cout << j;\n\t}\n      }\n      cout << endl;*/\n    }\n    if (ex == 'u') {\n      node[0] |= node[1];\n    } else {\n      node[0] &= node[1];\n    }\n    cout << \"hoge\" << endl;\n    cout << _perse(0) << endl;\n    cin.ignore();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\n#define N 100005\n\nint n;\nint lch[3][N], rch[3][N];\nchar s[N];\n\nint gao(int flag, int l, int r) {\n    if (l < 0 || r < 0 || l >= r) return 0;\n    int cnt = 0, p = -10, node = ++n;\n    for (int i = l + 1; i < r; ++i) {\n        if (0 == cnt && s[i] == ',') {\n            p = i;\n            break;\n        }\n        if ('(' == s[i]) ++cnt;\n        if (')' == s[i]) --cnt;\n    }\n    lch[flag][node] = gao(flag, l + 1, p - 1);\n    rch[flag][node] = gao(flag, p + 1, r - 1);\n    return node;\n}\n\nint gaogao(int v1, int v2, int flag) {\n    if (0 == flag) {\n        if (0 == v1 && 0 == v2) return 0;\n    } else {\n        if (0 == v1 || 0 == v2) return 0;\n    }\n    int node = ++n;\n    lch[2][node] = gaogao(lch[0][v1], lch[1][v2], flag);\n    rch[2][node] = gaogao(rch[0][v1], rch[1][v2], flag);\n    return node;\n}\n\nvoid zaigao(int flag, int x) {\n    putchar('(');\n    if (lch[flag][x]) zaigao(flag, lch[flag][x]);\n    putchar(',');\n    if (rch[flag][x]) zaigao(flag, rch[flag][x]);\n    putchar(')');\n}\n\nint main() {\n    char op[10];\n    while (EOF != scanf(\"%s\", op)) {\n        memset(lch, 0, sizeof(lch));\n        memset(rch, 0, sizeof(rch));\n        n = 0;\n        scanf(\"%s\", s);\n        int root1 = gao(0, 0, strlen(s) - 1);\n        scanf(\"%s\", s);\n        int root2 = gao(1, 0, strlen(s) - 1);\n        int root = gaogao(root1, root2, op[0] == 'i');\n        zaigao(2, root);\n        puts(\"\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <string.h>\nusing namespace std;\n#define maxn 10005\nchar a[maxn],b[maxn];\nstruct Node\n{\n    int out;\n    int l,r;\n}x[maxn],y[maxn];\nint Build(string cur,int id,int f)\n{\n    //蟒コ遶狗ャャ荳?「玲?\n    if(f==0)\n    {\n        if(cur==\"\")return -1;\n        int t=1;\n        string t1=\"\",t2=\"\";\n        for(int i=1; i<cur.size(); i++)\n        {\n            if(cur[i]=='(')\n            {\n                t++;\n            }\n            else if(cur[i]==',')\n            {\n                if(t==1)\n                {\n                    x[id].l=Build(t1,id+1,f);\n                    for(int j=i+1; j<cur.size()-1; j++)\n                    {\n                        t2+=cur[j];\n                    }\n                    x[id].r=Build(t2,id+2,f);\n                    return id;\n                    break;\n                }\n            }\n            else if(cur[i]==')')\n            {\n                t--;\n            }\n            t1+=cur[i];\n        }\n    }\n    if(f==1)\n    {\n        if(cur==\"\")return -1;\n        int t=1;\n        string t1=\"\",t2=\"\";\n        for(int i=1; i<cur.size(); i++)\n        {\n            if(cur[i]=='(')\n            {\n                t++;\n            }\n            else if(cur[i]==',')\n            {\n                if(t==1)\n                {\n                    y[id].l=Build(t1,id+1,f);\n                    for(int j=i+1; j<cur.size()-1; j++)\n                    {\n                        t2+=cur[j];\n                    }\n                    y[id].r=Build(t2,id+2,f);\n                    return id;\n                    break;\n                }\n            }\n            else if(cur[i]==')')\n            {\n                t--;\n            }\n            t1+=cur[i];\n        }\n    }\n}\nvoid Out(int ix,int iy,char ch)\n{\n    if(ch=='i')\n    {\n        if(ix==-1||iy==-1)\n        {\n            return;\n        }\n        printf(\"(\");\n        if(x[ix].l!=-1&&y[iy].l!=-1)\n        {\n            Out(x[ix].l,y[iy].l,ch);\n        }\n        printf(\",\");\n        if(x[ix].r!=-1&&y[iy].r!=-1)\n        {\n            Out(x[ix].r,y[iy].r,ch);\n        }\n        printf(\")\");\n    }\n    else\n    {\n        if(ix!=-1 && iy!=-1)\n        {\n            printf(\"(\");\n            Out(x[ix].l, y[iy].l, ch);\n            printf(\",\");\n            Out(x[ix].r,y[iy].r,ch);\n            printf(\")\");\n        }\n        if(ix==-1 && iy!=-1)\n        {\n            printf(\"(\");\n            Out(-1,y[iy].l,ch);\n            printf(\",\");\n            Out(-1,y[iy].r,ch);\n            printf(\")\");\n        }\n        if(ix!=-1 && iy==-1)\n        {\n            printf(\"(\");\n            Out(x[ix].l,-1,ch);\n            printf(\",\");\n            Out(x[ix].r,-1,ch);\n            printf(\")\");\n        }\n    }\n}\n\nint main()\n{\n    char ch[2];\n    while(scanf(\"%s%s%s\",ch,a,b)!=EOF)\n    {\n        for(int i=0; i<maxn; i++)\n        {\n            x[i].out=x[i].l=x[i].r=-1;\n            y[i].out=y[i].l=y[i].r=-1;\n        }\n        string s1=a;\n        string s2=b;\n        Build(s1,0,0);\n        Build(s2,0,1);\n        Out(0,0,ch[0]);\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<list>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\n\nint treeA[110];\nint treeB[110];\nint treeC[110];\n\nvoid getTree(string line,int tree, int lvl){\n\tif(line==\"\")return;\n\tstack<int> cnt;\n\tint b=0;\n\twhile(line[b]!=0){\n\t\tif(line[b]=='('){\n\t\t\tcnt.push(1);\n\t\t}else if(line[b]==')'){\n\t\t\tcnt.pop();\n\t\t}else{\n\t\t\tif(cnt.size()==1)break;\n\t\t}\n\t\tb++;\n\t}\n\tline = line.substr(0,line.size()-1);\n\tstring S_R = line.substr(b+1);\n\tstring S_L = line.substr(1,b-1);\n\tgetTree(S_R,tree,2*lvl+1);\n\tgetTree(S_L,tree,2*lvl);\n\tif(tree==1){\n\t\ttreeA[lvl] = 1;\n\t}else{\n\t\ttreeB[lvl] = 2;\n\t}\n}\n\nstring imp(int lvl){\n\tif(treeC[lvl]==0)return \"\";\n\tstringstream buf;\n\tbuf<<\"(\"<<imp(2*lvl)<<\",\"<<imp(2*lvl+1)<<\")\";\n\treturn buf.str();\n}\n\nvoid unionT(){\n\tfor(int x=1;x<110;++x){\n\t\tif(treeA[x] || treeB[x])treeC[x] = 3;\n\t}\n\tcout<<imp(1)<<endl;\n}\n\nvoid inter(){\n\tfor(int x=1;x<110;++x){\n\t\tif(treeA[x] && treeB[x])treeC[x] = 3;\n\t}\n\tcout<<imp(1)<<endl;\n}\n\nint main(){\n\tstring line;\n\twhile(true){\n\t\tgetline(cin,line);\n\t\tif(line==\"\" || cin.eof())break;\n\t\tfor(int x=0;x<110;++x){\n\t\t\ttreeA[x] = 0;treeB[x] = 0;treeC[x] = 0;\n\t\t}\n\t\tint f = line.rfind(\" \");\n\t\tgetTree(line.substr(2,f-2),1,1);\n\t\tgetTree(line.substr(f+1),2,1);\n\t\tif(line[0] == 'u'){\n\t\t\tunionT();\n\t\t}else{\n\t\t\tinter();\n\t\t}\n\t}\t\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint ln,rn;\nvpint nodel,noder;\n\nvoid fl(string str,int n){\n\tnodel.PB(MP(-1,-1));\n\tif(sz(str)<4)return;\n\tint c=0;\n\tint i;\n\trep0(i,sz(str)){\n\t\tif(str[i]=='(')++c;\n\t\tif(str[i]==')')--c;\n\t\tif(str[i]==','&&c==1)break;\n\t}\n\tstring left,right;\n\tleft=str.substr(1,i-1);\n\tright=str.substr(i+1,sz(str)-i-2);\n\tif(sz(left)>0)nodel[n].first=sz(nodel);\n\tfl(left,sz(nodel));\n\tif(sz(right)>0)nodel[n].second=sz(nodel);\n\tfl(right,sz(nodel));\n\treturn;\n}\n\nvoid fr(string str,int n){\n\tnoder.PB(MP(-1,-1));\n\tif(sz(str)<4)return;\n\tint c=0;\n\tint i;\n\trep0(i,sz(str)){\n\t\tif(str[i]=='(')++c;\n\t\tif(str[i]==')')--c;\n\t\tif(str[i]==','&&c==1)break;\n\t}\n\tstring left,right;\n\tleft=str.substr(1,i-1);\n\tright=str.substr(i+1,sz(str)-i-2);\n\tif(sz(left)>0){\n\t\tnoder[n].first=sz(noder);\n\t\tfr(left,sz(noder));\n\t}\n\tif(sz(right)>0){\n\t\tnoder[n].second=sz(noder);\n\t\tfr(left,sz(noder));\n\t}\n\treturn;\n}\n\nvoid intersect(int l,int r){\n\tcout<<\"(\";\n\tif(nodel[l].first!=-1&&noder[r].first!=-1){\n\t\tintersect(nodel[l].first,noder[r].first);\n\t}\n\tcout<<\",\";\n\tif(nodel[l].second!=-1&&noder[r].second!=-1){\n\t\tintersect(nodel[l].second,noder[r].second);\n\t}\n\tcout<<\")\";\n}\n\nvoid uni(int l,int r){\n\tif(l==-1&&r==-1)return;\n\tcout<<\"(\";\n\tuni(l!=-1?nodel[l].first:-1,r!=-1?noder[r].first:-1);\n\tcout<<\",\";\n\tuni(l!=-1?nodel[l].second:-1,r!=-1?noder[r].second:-1);\n\tcout<<\")\";\n}\n\nint main() {\n\tstring a,str1,str2;\n\twhile(cin>>a>>str1>>str2){\n\t\tln=rn=0;\n\t\tnodel.clear();\n\t\tnoder.clear();\n\t\tfl(str1,0);fr(str2,0);\n\t\tif(a==\"i\")intersect(0,0);\n\t\telse uni(0,0);\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"set>.cpp\"\n#include \"set>.cpp\""
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n\nint main(){\n    std::cout << \"Hello World!\" << std::endl;\n    return 0;\n}\n        \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstring a,b,z;\nint d;\nstring ans;\nbool flgA[100000];\nbool flgB[100000];\n\nvoid rec(int x){\n\n  ans.push_back('(');\n\n  if(flgA[x*2]==true){\n    rec(x*2);\n  }\n  ans.push_back(',');\n  if(flgA[x*2+1]==true){\n    rec(x*2+1);\n  }\n\n  ans.push_back(')');\n}\n\n\nint main(){\n  while(cin>>z){\n\n    cin>>a;\n    for(int i=0;i<100000;i++)flgA[i]=flgB[i]=false;\n    flgA[1]=flgB[1]=true;\n    \n    d=1;\n    for(int i=0;i<(int)a.size();i++){\n      if(a[i]=='('){\n\tflgA[d]=true;\n\td*=2;\n      }else if(a[i]==','){\n\td=d+1;\n      }else{\n\td/=2;\n      }\n    }\n    \n      cin>>b;\n      d=1;\n      for(int i=0;i<(int)b.size();i++){\n      if(b[i]=='('){\n\tflgB[d]=true;\n\td*=2;\n      }else if(b[i]==','){\n\td=d+1;\n      }else{\n\td/=2;\n      }\n    }\n    \n\n    for(int i=0;i<10000;i++){\n      if(flgB[i]==false){\n\tif(z==\"i\"){\n\t  flgA[i]=false;\n\t}\n      }else{\n\tif(z==\"u\"){\n\t  flgA[i]=true;\n\t}\n      }\n\n    }\n\n    ans=\"\";\n    rec(1);\n    cout<<ans<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node{\n    Node *left;\n    Node *right;\n    Node() { left = NULL, right = NULL; }\n};\n\nint findcc(string s) {\n    int dd = 0;\n    for(int i=0; i<s.length(); ++i) {\n        if(s[i] == '(') dd++;\n        else if(s[i] == ')') dd--;\n        else if(s[i] == ',' && dd == 1) return i;\n    }\n    return -1;\n}\n\nNode* parse(string s) {\n    Node *r = new Node();\n    int ff = findcc(s);\n    if(ff != 1) r->left = parse(s.substr(1,ff-1));\n    if(ff != s.length()-2) {\n        string tmp = s.substr(ff+1);\n        r->right = parse(tmp.substr(0,tmp.length()-1));\n    }\n    return r;\n}\n\nNode *intersect(Node *r1,Node *r2) {\n    Node *ret = new Node();\n    if(r1->left != NULL && r2->left != NULL)\n        ret->left = intersect(r1->left,r2->left);\n\n    if(r1->right != NULL && r2->right != NULL)\n        ret->right = intersect(r1->right,r2->right);\n\n    return ret;\n}\n\nNode* uni(Node *r1,Node *r2) {\n    if(r1 == NULL && r2 == NULL) return NULL;\n\n    Node *ret = new Node();\n    ret->left = uni(((r1 == NULL)?NULL:r1->left),(r2 == NULL)?NULL:r2->left);\n    ret->right = uni(((r1 == NULL)?NULL:r1->right),(r2 == NULL)?NULL:r2->right);\n    return ret;\n}\n\nstring toStr(Node *tree) {\n    string res = \"(\";\n    if(tree->left != NULL) res += toStr(tree->left);\n    res += \",\";\n    if(tree->right != NULL) res += toStr(tree->right);\n    res += \")\";\n    return res;\n}\n\nvoid treedel(Node *node) {\n    if(node->left != NULL) treedel(node->left);\n    if(node->right != NULL) treedel(node->right);\n    delete node;\n    return;\n}\n\nint main() {\n    string op,t1,t2;\n    while(cin>>op>>t1>>t2) {\n        Node *r1 = parse(t1);\n        Node *r2 = parse(t2);\n        Node *ans;\n        if(op == \"i\") ans = intersect(r1,r2);\n        else if(op == \"u\") ans = uni(r1,r2);\n\n        cout<<toStr(ans)<<endl;\n        treedel(r1); treedel(r2); treedel(ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint depth[2][101];\n\nstring pad(int height) {\n    int len = (height <= 0 ? 0 : 3 * ((1 << height) - 1));\n    string ret = \"\";\n    for (int i=0; i<len; ++i) {\n        ret += \" \";\n    }\n    return ret;\n}\n\nvoid pad(vector<string> &t, int height) {\n    vector<string> ts(t.size(), \"\"); // tree with spaces;\n    for (int i=0; i<(int)t.size(); ++i) {\n        for (int j=0; j<(int)t[i].size(); ++j) {\n            if (t[i][j] == ',') {\n                if (t[i][j - 1] == '(') ts[i] += pad(height - depth[i][j]);\n                ts[i] += ',';\n                if (t[i][j + 1] == ')') ts[i] += pad(height - depth[i][j]);\n            } else {\n                ts[i] += t[i][j];\n            }\n        }\n        t[i] = ts[i];\n    }\n}\n\nstring intersection(vector<string> &t, int height) {\n    pad(t, height);\n    string ret = \"\";\n    for (int i=0; i<(int)t[0].size(); ++i) {\n        if (t[0][i] != ' ' && t[1][i] != ' ') ret += t[0][i];\n    }\n    return ret;\n}\n\nstring unite(vector<string> &t, int height) {\n    pad(t, height);\n    string ret = \"\";\n    for (int i=0; i<(int)t[0].size(); ++i) {\n        if (t[0][i] != ' ') {\n            ret += t[0][i];\n        } else if (t[1][i] != ' ') {\n            ret += t[1][i];\n        }\n    }\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    char op;\n    vector<string> t(2);\n    while (cin >> op) {\n        cin >> t[0] >> t[1];\n\n        vector<int> height(2, 0);\n        for (int i=0; i<2; ++i) {\n            int c = 0;\n            for (int j=0; j<(int)t[i].size(); ++j) {\n                if (t[i][j] == '(') c ++;\n                depth[i][j] = c;\n                if (t[i][j] == ')') c --;\n                height[i] = max(height[i], c);\n            }\n        }\n\n        switch (op) {\n            case 'i':\n                cout << intersection(t, max(height[0], height[1])) << endl;\n                break;\n            case 'u':\n                cout << unite(t, max(height[0], height[1])) << endl;\n                break;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nconst char *left(const char *p){\n  if(p == NULL) return NULL;\n  assert(*p == '(');\n\n  if(*(p+1) == '(') return p+1;\n  return NULL;\n}\n\nconst char *right(const char *p){\n  if(p == NULL) return NULL;\n  assert(*p == '(');\n  int depth = 0;\n  p++;\n\n  while(!(depth == 0 && *p == ',')){\n    if(*p == '(') depth++;\n    if(*p == ')') depth--;\n    p++;\n  }\n\n  p++;\n  if(*p == '(') return p;\n  return NULL;\n}\n\nvoid solve(const char *p1, const char *p2, bool inter){\n  if(p1 == NULL && p2 == NULL) return;\n\n  const char *l1 = left(p1);\n  const char *r1 = right(p1);\n  const char *l2 = left(p2);\n  const char *r2 = right(p2);\n\n  printf(\"(\");\n\n  if(inter){\n    if(l1 == NULL || l2 == NULL){\n    }else{\n      solve(l1,l2,inter);\n    }\n  }else{\n    if(l1 == NULL && l2 == NULL){\n    }else{\n      solve(l1,l2,inter);\n    }\n  }\n\n  printf(\",\");\n\n  if(inter){\n    if(r1 == NULL || r2 == NULL){\n    }else{\n      solve(r1,r2,inter);\n    }\n  }else{\n    if(r1 == NULL && r2 == NULL){\n    }else{\n      solve(r1,r2,inter);\n    }\n  }\n\n  printf(\")\");\n}\n\nint main(){\n  string str;\n  while(getline(cin, str)){\n    stringstream ss(str);\n    char w;\n    string s1,s2;\n    ss >> w >> s1 >> s2;\n\n    solve(s1.c_str(), s2.c_str(), w == 'i');\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=100;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  heap[id]++;\n  if(s==\"(,)\")  return;\n  \n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;   \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n      parse(sub1, 2*id+1);\n      parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nint out(int th, int id,int n){\n\n  string c(\"(,)\");\n  for(int i=0;i<3;i++)\n    output.insert(output.begin()+n+i,c[i]);\n\n  int ch1=0,ch2=0;//n of string of each child\n  \n  if(heap[id]>th){\n    if(heap[2*id+1]>th){\n      ch1=out(th,2*id+1,n+1);\n    }\n    if(heap[2*id+2]>th){\n      ch2=out(th,2*id+2,n+ch1+2);\n    }\n  }\n  return ch1+ch2+3;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  \n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0,0);\n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  while(1){\n    cin>>cmd>>s1>>s2;\n    if(cin.eof()) break;\n    solve(cmd,s1,s2);\n  //print();\n  \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint ln,rn;\nvpint nodel,noder;\n\nvoid fl(string str,int n){\n\tnodel.PB(MP(-1,-1));\n\tif(sz(str)<4)return;\n\tint c=0;\n\tint i;\n\trep0(i,sz(str)){\n\t\tif(str[i]=='(')++c;\n\t\tif(str[i]==')')--c;\n\t\tif(str[i]==','&&c==1)break;\n\t}\n\tstring left,right;\n\tleft=str.substr(1,i-1);\n\tright=str.substr(i+1,sz(str)-i-2);\n\tif(sz(left)>0){\n\t\tnodel[n].first=sz(nodel);\n\t\tfl(left,sz(nodel));\n\t}\n\tif(sz(right)>0){\n\t\tnodel[n].second=sz(nodel);\n\t\tfl(right,sz(nodel));\n\t}\n\treturn;\n}\n\nvoid fr(string str,int n){\n\tnoder.PB(MP(-1,-1));\n\tif(sz(str)<4)return;\n\tint c=0;\n\tint i;\n\trep0(i,sz(str)){\n\t\tif(str[i]=='(')++c;\n\t\tif(str[i]==')')--c;\n\t\tif(str[i]==','&&c==1)break;\n\t}\n\tstring left,right;\n\tleft=str.substr(1,i-1);\n\tright=str.substr(i+1,sz(str)-i-2);\n\tif(sz(left)>0){\n\t\tnoder[n].first=sz(noder);\n\t\tfr(left,sz(noder));\n\t}\n\tif(sz(right)>0){\n\t\tnoder[n].second=sz(noder);\n\t\tfr(left,sz(noder));\n\t}\n\treturn;\n}\n\nvoid intersect(int l,int r){\n\tcout<<\"(\";\n\tif(nodel[l].first!=-1&&noder[r].first!=-1){\n\t\tintersect(nodel[l].first,noder[r].first);\n\t}\n\tcout<<\",\";\n\tif(nodel[l].second!=-1&&noder[r].second!=-1){\n\t\tintersect(nodel[l].second,noder[r].second);\n\t}\n\tcout<<\")\";\n}\n\nvoid uni(int l,int r){\n\tif(l==-1&&r==-1)return;\n\tcout<<\"(\";\n\tuni(l!=-1?nodel[l].first:-1,r!=-1?noder[r].first:-1);\n\tcout<<\",\";\n\tuni(l!=-1?nodel[l].second:-1,r!=-1?noder[r].second:-1);\n\tcout<<\")\";\n}\n\nint main() {\n\tstring a,str1,str2;\n\twhile(cin>>a>>str1>>str2){\n\t\tln=rn=0;\n\t\tnodel.clear();\n\t\tnoder.clear();\n\t\tfl(str1,0);fr(str2,0);\n\t\tif(a==\"i\")intersect(0,0);\n\t\telse uni(0,0);\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nclass BinaryTree\n{\npublic:\n\tBinaryTree *parent;\n\tBinaryTree *left;\n\tBinaryTree *right;\n\tint no;\n\n\tBinaryTree()\n\t{\n\t\tparent\t= NULL;\n\t\tleft\t= NULL;\n\t\tright\t= NULL;\n\t\tno\t\t= 1;\n\t}\n\n\tBinaryTree( BinaryTree *p )\n\t{\n\t\tparent\t= p;\n\t\tleft\t= NULL;\n\t\tright\t= NULL;\n\t\tno\t\t= p->no + 1;\n\t}\n};\n\nvector <BinaryTree> Nodes( 5000 );\nint Nodes_cnt = 0;\n\nBinaryTree getTree( string in )\n{\n\tstack <int> lrs;\n\tint lr = 0;\n\n\tBinaryTree\troot;\n\tBinaryTree*\tnow;\n\n\tbool first = true;\n\tnow = &root;\n\n\tfor ( string::iterator it = in.begin(); it != in.end(); it++ )\n\t{\n\t\tif ( first )\n\t\t{\n\t\t\tfirst = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( *it == '(' )\n\t\t{\n\t\t\tif ( lr == 0 )\n\t\t\t{\n\t\t\t\tnow->left  = new BinaryTree( now );\n\t\t\t\tnow = now->left;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnow->right = new BinaryTree( now );\n\t\t\t\tnow = now->right;\n\t\t\t}\n\n\t\t\tlrs.push( lr );\n\t\t\tlr = 0;\n\t\t}\n\t\telse if ( *it == ')' )\n\t\t{\n\t\t\tif ( now->parent != NULL )\n\t\t\t{\n\t\t\t\tnow = now->parent;\n\t\t\t\tlr = lrs.top();\n\t\t\t\tlrs.pop();\n\t\t\t}\n\n\t\t}\n\t\telse if ( *it == ',' )\n\t\t{\n\t\t\tlr++;\n\t\t}\n\t}\n\n\treturn root;\n}\n\nvoid printTree( BinaryTree* tree )\n{\n\tcout << \"(\";\n\tif ( tree->left != NULL )\n\t\tprintTree( tree->left );\n\tcout << \",\";\n\tif ( tree->right != NULL )\n\t\tprintTree( tree->right );\n\tcout << \")\";\n}\n\nBinaryTree* getIntersection( BinaryTree* a, BinaryTree* b, BinaryTree* p )\n{\n\t// ツ仰、ツ津環づ按閉板閉ェツづーツ個ゥツづつつッツづゥ\n\tint nc = Nodes_cnt;\n\tNodes_cnt++;\n\tBinaryTree& node = Nodes[nc];\n\tif ( p == NULL )\n\t\tnode = BinaryTree();\n\telse\n\t\tnode = BinaryTree( p );\n\n\tif ( ( a != NULL && a->left != NULL ) && ( b != NULL && b->left != NULL ) )\n\t{\n\t\tBinaryTree* next = getIntersection( a==NULL?NULL:a->left, b==NULL?NULL:b->left, &node );\n\t\tnode.left = next;\n\t}\n\tif ( ( a != NULL && a->right != NULL ) && ( b != NULL && b->right != NULL ) )\n\t{\n\t\tBinaryTree* next = getIntersection( (a==NULL?NULL:a->right), (b==NULL?NULL:b->right), &node );\n\t\tnode.right = next;\n\t}\n\n\treturn &Nodes[nc];\n}\n\nBinaryTree* getUnion( BinaryTree* a, BinaryTree* b, BinaryTree* p )\n{\n\t// ツづづつソツつゥツづ可甘慊づ慊づェツづつ「ツづゥツづ按づァOK\n\tint nc = Nodes_cnt;\n\tNodes_cnt++;\n\tBinaryTree& node = Nodes[nc];\n\tif ( p == NULL )\n\t\tnode = BinaryTree();\n\telse\n\t\tnode = BinaryTree( p );\n\n\tif ( ( a != NULL && a->left != NULL ) || ( b != NULL && b->left != NULL ) )\n\t{\n\t\tBinaryTree* next = getUnion( (a==NULL?NULL:a->left), (b==NULL?NULL:b->left), &node );\n\t\tnode.left = next;\n\t}\n\tif ( ( a != NULL && a->right != NULL ) || ( b != NULL && b->right != NULL ) )\n\t{\n\t\tBinaryTree* next = getUnion( (a==NULL?NULL:a->right), (b==NULL?NULL:b->right), &node );\n\t\tnode.right = next;\n\t}\n\n\treturn &Nodes[nc];\n}\n\nint main( void )\n{\n\tstring type;\n\tstring in_a;\n\tstring in_b;\n\n\twhile ( cin >> type >> in_a >> in_b )\n\t{\n\t\tBinaryTree a_root = getTree( in_a );\n\t\tBinaryTree b_root = getTree( in_b );\n\n\t\tif ( type == \"i\" )\n\t\t{\n\t\t\tBinaryTree* intersectionTree = getIntersection( &a_root, &b_root, NULL );\n\t\t\tprintTree( intersectionTree );\n\t\t\tcout << endl;\n\t\t}\n\t\telse if ( type == \"u\" )\n\t\t{\n\t\t\tBinaryTree* unionTree = getUnion( &a_root, &b_root, NULL );\n\t\t\tprintTree( unionTree );\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nvector<int> treeshape(string tree);\nstring printtree(vector<int> nodes, int root);\n\nint main(){\n\tstring op, first, second;\n\twhile(!cin.eof()){\n\t\tcin>>op>>first>>second;\n\t\tif(!cin.fail()){\n\t\t\tvector<int> f, s;\n\t\t\tf = treeshape(first);\n\t\t\ts = treeshape(second);\n\t\t\tsort(f.begin(), f.end());\n\t\t\tsort(s.begin(), s.end());\n\t\t\tvector<int> result;\n\t\t\tif(op[0] == 'i'){\n\t\t\t\tset_intersection(f.begin(), f.end(), s.begin(), s.end(), back_inserter(result));\n\t\t\t}\n\t\t\tif(op[0] == 'u'){\n\t\t\t\tset_union(f.begin(), f.end(), s.begin(), s.end(), back_inserter(result));\n\t\t\t}\n\t\t\tcout<<printtree(result, result[0])<<endl;\n\t\t}\n\t}\n}\n\nvector<int> treeshape(string tree){\n\tvector<int> vec;\n\tstack<char> st;\n\tbool flag = false;\n\tint node = 1;\n\tvec.push_back(node);\n\tfor(int i = 1; i < tree.length(); i++){\n\t\tif(tree[i] == '('){\n\t\t\tst.push('(');\n\t\t\tnode *= 2;\n\t\t\tif(flag){\n\t\t\t\tnode += 1;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t\tvec.push_back(node);\n\t\t}else if(tree[i] == ',' && tree[i+1] == '('){\n\t\t\tflag = true;\n\t\t}else if(tree[i] == ')'){\n\t\t\tst.pop();\n\t\t\tnode /= 2;\n\t\t}\n\t}\n\treturn vec;\n}\n\nstring printtree(vector<int> nodes, int root){\n\tif(find(nodes.begin(), nodes.end(), root) == nodes.end())\n\t\treturn \"\";\n\tif(find(nodes.begin(), nodes.end(), root * 2) == nodes.end() && find(nodes.begin(), nodes.end(), root * 2 + 1) == nodes.end())\n\t\treturn \"(,)\";\n\treturn \"(\" + printtree(nodes, root * 2) + \",\" + printtree(nodes, root * 2 + 1) + \")\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct Node {\n  Node *ch[2];\n  Node() { ch[0] = ch[1] = NULL; }\n};\n\nvoid build(Node *node, const string &s, int &i) {\n  if( s[i] == '(' ) {\n    i++; // (\n    node->ch[0] = new Node();\n    build(node->ch[0], s, i);\n    i++; // ,\n    node->ch[1] = new Node();\n    build(node->ch[1], s, i);\n    i++; // )\n  }\n}\n\nvoid print(Node* node) {\n  if( node == NULL || (node->ch[0] == NULL && node->ch[1] == NULL) ) return;\n  cout << \"(\";\n  print(node->ch[0]);\n  cout << \",\";\n  print(node->ch[1]);\n  cout << \")\";\n}\n\nvoid erase(Node *node) {\n  for(int i = 0; i < 2; i++) if( node->ch[i] ) erase(node->ch[i]);\n  delete node;\n}\n\nvoid Intersection(Node *res, Node *a, Node *b) {\n  for(int i = 0; i < 2; i++)\n    if( a && a->ch[i] && b && b->ch[i] ) {\n      res->ch[i] = new Node();\n      Intersection(res->ch[i], a->ch[i], b->ch[i]);\n    }\n}\n\nvoid Union(Node *res, Node *a, Node *b) {\n  for(int i = 0; i < 2; i++)\n    if( (a && a->ch[i]) || (b && b->ch[i]) ) {\n      res->ch[i] = new Node();\n      Union(res->ch[i], ( a ? a->ch[i] : NULL ), (b ? b->ch[i] : NULL ));\n    }\n}\n\n\nint main() {\n  for(string cmd, A, B; cin >> cmd >> A >> B;) {\n    Node *roota = new Node();\n    Node *rootb = new Node();\n    Node *rootc = new Node();\n\n    int i = 0;\n    build(roota, A, i);\n\n    i = 0;\n    build(rootb, B, i);\n\n    if( cmd[0] == 'i' ) Intersection(rootc, roota, rootb);\n    else Union(rootc, roota, rootb);\n\n    print(rootc); cout << endl;\n\n    erase(roota);\n    erase(rootb);\n    erase(rootc);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=100;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  heap[id]++;\n  if(s==\"(,)\")  return;\n  \n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;   \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n      parse(sub1, 2*id+1);\n      parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nint out(int th, int id,int n){\n\n  string c(\"(,)\");\n  for(int i=0;i<3;i++)\n    output.insert(output.begin()+n+i,c[i]);\n\n  int ch1=0,ch2=0;//n of string of each child\n  \n  if(heap[id]>th){\n    if(heap[2*id+1]>th){\n      ch1=out(th,2*id+1,n+1);\n    }\n    if(heap[2*id+2]>th){\n      ch2=out(th,2*id+2,n+ch1+2);\n    }\n  }\n  return ch1+ch2+3;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  output.clear();\n  //cout<<output<<endl;\n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0,0);\n  \n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  \n  while(cin>>cmd>>s1>>s2){\n    solve(cmd,s1,s2);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n\nint main(){\n    std::cout << \"Hello World!\" << std::endl;\n    return 0;\n}\n        \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<stack>\n#include<string>\nusing namespace std;\nint l,v,map1[1005][1005],map2[1005][1005],map3[1005][1005];\nint dfs1(int f1,int f2)\n{//cout<<f1<<\" \"<<f2<<\" \"<<l<<endl;\n    if(f1==-1&&f2==-1)return -1;\n    if(v==0&&((f1==-1&&f2!=-1)||(f1!=-1&&f2==-1)))return -1;\n    int x1=-1,x2=-1,y1=-1,y2=-1;\n    if(f1!=-1)x1=map1[f1][0];\n    if(f1!=-1)y1=map1[f1][1];\n    if(f2!=-1)x2=map2[f2][0];\n    if(f2!=-1)y2=map2[f2][1];\n    int d=l++;\n    map3[d][0]=dfs1(x1,x2);\n    map3[d][1]=dfs1(y1,y2);//if(l==2)cout<<map3[l][0]<<\"  \"<<x1<<\"  \"<<x2<<endl;\n    return d;\n}\nstring dfs2(int f)\n{\n    if(f==-1)return \"\";\n    int x=map3[f][0];\n    int y=map3[f][1];\n    return \"(\"+dfs2(x)+\",\"+dfs2(y)+\")\";\n}\nint main()\n{\n    //freopen(\"a.txt\",\"r\",stdin);\n    char c,s1[1005],s2[1005];\n    int a[1005];\n    while(scanf(\"%c%s%s\",&c,s1,s2)!=EOF)\n    {\n        int len=strlen(s1);\n        stack<char> s;\n        stack<int> g[1000];\n        for(int i=0;i<1000;i++)while(!g[i].empty())g[i].pop();\n        while(!s.empty())s.pop();\n        int d=0,x=0;\n        int f1=-1;\n        memset(map1,-1,sizeof(map1));\n        memset(a,0,sizeof(a));\n        for(int i=0;i<len;i++)\n        {\n            if(s1[i]=='(')d++;\n            else if(s1[i]==')')d--;\n            else\n            {//cout<<g[2].size()<<\" \"<<x<<endl;\n                if(d==1)f1=x;//if(x==6)cout<<d<<\" \"<<g[d-1].size()<<endl;\n                int f=0;\n                if(g[d-1].size())\n                {\n                    int y=g[d-1].top();\n                    a[y]++;\n                    if(a[y]==2)g[d-1].pop();\n                    map1[y][1]=x;\n                }\n                else\n                {\n                    g[d].push(x);\n                    f=1;\n                }\n                if(g[d+1].size())\n                {\n                    int y=g[d+1].top();\n                    g[d+1].pop();\n                    map1[x][0]=y;\n                }\n                if(f==0&&f1!=-1)g[d].push(x);\n                x++;\n            }\n        }//cout<<x<<\" \"<<map1[5][0]<<\" \"<<map1[5][1]<<endl;\n        for(int i=0;i<1000;i++)while(!g[i].empty())g[i].pop();\n        while(!s.empty())s.pop();\n        d=0,x=0;\n        int f2=-1;\n        for(int i=0;i<1000;i++)while(!g[i].empty())g[i].pop();\n        memset(map2,-1,sizeof(map2));\n        len=strlen(s2);\n        memset(a,0,sizeof(a));\n        for(int i=0;i<len;i++)\n        {\n            if(s2[i]=='(')d++;\n            else if(s2[i]==')')d--;\n            else\n            {\n                if(d==1)f2=x;\n                int f=0;\n                if(g[d-1].size())\n                {\n                    int y=g[d-1].top();\n                    a[y]++;\n                    if(a[y]==2)g[d-1].pop();\n                    map2[y][1]=x;\n                }\n                else\n                {\n                    g[d].push(x);\n                    f=1;\n                }\n                if(g[d+1].size())\n                {\n                    int y=g[d+1].top();\n                    g[d+1].pop();\n                    map2[x][0]=y;\n                }\n                if(f==0&&f2!=-1)g[d].push(x);\n                x++;\n            }\n        }//cout<<f2<<endl;cout<<map2[2][0]<<\" \"<<map2[2][1]<<endl;\n        if(c=='i')v=0;\n        else v=1;\n        l=0;\n        dfs1(f1,f2);//cout<<l<<endl;cout<<map3[2][0]<<\" \"<<map3[2][1]<<endl;\n        cout<<dfs2(0)<<endl;\n        getchar();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nstring tree[2];\nbitset<1000000000> node[2];\n\nvoid perse(int index, int n, int i)\n{\n  //cout << \"persed \" << n << endl;\n  if (index >= tree[i].size()) {\n    return;\n  }\n  if (tree[i][index] == '(') {\n    while (tree[i][index] == ' ') {index++;}\n    node[i][n] = true;\n    perse(index + 1, 2 * n + 1, i);\n  } else if (tree[i][index] == ')') {\n    while (tree[i][index] == ' ') {index++;}\n    perse(index + 1, (((n - 2) / 2 < 0) ? 0 : (n - 2) / 2), i);\n  } else if (\",\"){\n    while (tree[i][index] == ' ') {index++;}\n    perse(index + 1, n + 1, i);\n  }\n}\n\nstring _perse(int index)\n{\n  if (node[0][index]) {\n    return \"(\" + _perse(2 * index + 1) + \",\" + _perse(2 * index + 2) + \")\";\n  }\n  return \"\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    for (int i = 0; i < 2; i++) {\n      node[i].reset();\n      perse(0, 0, i);\n      \n      /*for (int j = 0; j < 300; j++) {\n\tif (node[i][j]) {\n\t  cout << j;\n\t}\n      }\n      cout << endl;*/\n    }\n    if (ex == 'u') {\n      node[0] |= node[1];\n    } else {\n      node[0] &= node[1];\n    }\n    cout << _perse(0) << endl;\n    cin.ignore();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=1000;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  heap[id]++;\n  if(s==\"(,)\") return;\n  \n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;   \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n       parse(sub1, 2*id+1);\n      parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nvoid out(int th, int id){\n\n  output.push_back('(');\n\n  int ch1=0,ch2=0;//n of string of each child\n  \n  if(heap[id]>th && heap[2*id+1]>th){\n    out(th,2*id+1);\n  }\n  output.push_back(',');\n  if(heap[id]>th && heap[2*id+2]>th){\n    out(th,2*id+2);\n  }\n  \n  output.push_back(')');\n  return;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  output.clear();\n  //cout<<output<<endl;\n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0);\n  \n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  int i=0;\n  \n  while(cin>>cmd>>s1>>s2){\n    solve(cmd,s1,s2);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\nint lt[100], rt[100];\n\nstring parse(string str, int level, int no, int* ary)\n{\n    if(str.size() < 3 || str[0] != '(')  {\n        return \"\";\n    }\n\n    ary[no - 1] = 1;\n\n    // str = (<tree>,<tree>)\n    if(str[1] != ',') {\n        str = parse(str.substr(1), level + 1, no + (1 << level) + (no - (1 << level)), ary);\n    }\n\n    // str = ,<tree>)\n    str = str.substr(1);\n    if(str[1] != ')') {\n        str = parse(str.substr(1), level + 1, no + (1 << level) + (no - (1 << level)) + 1, ary);\n    }\n\n    // str = )\n    return str.substr(1);\n}\n\nstring unparse(int *ary, int level, int no)\n{\n    if(no > 100 || ary[no - 1] == 0) {\n        return \"\";\n    }\n\n    return \"(\" + \n        unparse(ary, level + 1, no + (1 << level) + (no - (1 << level))) +\n        \",\" + \n        unparse(ary, level + 1, no + (1 << level) + (no - (1 << level)) + 1)\n        + \")\";\n}\n\nint main()\n{\n    string op, a, b;\n    while(cin >> op >> a >> b) {\n        int ret[100];\n        for(int i = 0; i < 100; i++) {\n            lt[i] = rt[i] = ret[i] = 0;\n        }\n\n        parse(a, 0, 1, lt);\n        parse(b, 0, 1, rt);\n\n\n        for(int i = 0; i < 100; i++) {\n            if(op == \"i\") {\n                ret[i] = (lt[i] & rt[i]);\n            } else {\n                ret[i] = (lt[i] | rt[i]);\n            }\n        }\n        \n        cout << unparse(ret, 0, 1) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<int, int>;\n\nstring tree(const string &s, int &pos){\n\tstring chl, chr;\n\t++pos;\n\tif (s[pos] == '(') chl = tree(s, pos);\n\t++pos;\n\tif (s[pos] == '(') chr = tree(s, pos);\n\t++pos;\n\treturn \"(\" + chl + \",\" + chr + \")\";\n}\n\nchar c;\nstring a, b;\nint p1, p2;\n\nstring AND(){\n\t++p1, ++p2;\n\n\tstring chl, chr;\n\tif (a[p1] == '(' && b[p2] == '('){\n\t\tchl = AND();\n\t}\n\telse if (a[p1] == '('){\n\t\ttree(a, p1);\n\t}\n\telse if (b[p2] == '('){\n\t\ttree(b, p2);\n\t}\n\n\t++p1, ++p2;\n\n\tif (a[p1] == '(' && b[p2] == '('){\n\t\tchr = AND();\n\t}\n\telse if (a[p1] == '('){\n\t\ttree(a, p1);\n\t}\n\telse if (b[p2] == '('){\n\t\ttree(b, p2);\n\t}\n\n\t++p1, ++p2;\n\n\treturn \"(\" + chl + \",\" + chr + \")\";\n}\n\nstring OR(){\n\t++p1, ++p2;\n\n\tstring chl, chr;\n\tif (a[p1] == '(' && b[p2] == '('){\n\t\tchl = OR();\n\t}\n\telse if (a[p1] == '('){\n\t\tchl = tree(a, p1);\n\t}\n\telse if (b[p2] == '('){\n\t\tchl = tree(b, p2);\n\t}\n\n\t++p1, ++p2;\n\n\tif (a[p1] == '(' && b[p2] == '('){\n\t\tchr = OR();\n\t}\n\telse if (a[p1] == '('){\n\t\tchr = tree(a, p1);\n\t}\n\telse if (b[p2] == '('){\n\t\tchr = tree(b, p2);\n\t}\n\n\t++p1, ++p2;\n\n\treturn \"(\" + chl + \",\" + chr + \")\";\n}\n\nint main(){\n\twhile (cin >> c >> a >> b){\n\t\tp1 = p2 = 0;\n\n\t\tif (c == 'i') cout << AND() << endl;\n\t\telse cout << OR() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nstring op, s, t;\nint ps, pt;\n\nvoid rec(string &s, int &p, bool print = false) {\n  if(print) cout << \"(\";\n  ++p;\n  if(s[p] == '(') {\n    rec(s, p, print);\n  }\n  if(print) cout << \",\";\n  ++p;\n  if(s[p] == '(') {\n    rec(s, p, print);\n  }\n  if(print) cout << \")\";\n  ++p;\n}\n\nint rec_i() {\n  cout << \"(\";\n  ++ps; ++pt;\n  if(s[ps] == '(' && t[pt] == '(') {\n    rec_i();\n  } else {\n    if(s[ps] == '(') rec(s, ps);\n    if(t[pt] == '(') rec(t, pt);\n  }\n  cout << \",\";\n  ++ps; ++pt;\n  if(s[ps] == '(' && t[pt] == '(') {\n    rec_i();\n  } else {\n    if(s[ps] == '(') rec(s, ps);\n    if(t[pt] == '(') rec(t, pt);\n  }\n  cout << \")\";\n  ++ps; ++pt;\n}\n\nint rec_u() {\n  cout << \"(\";\n  ++ps; ++pt;\n  if(s[ps] != '(' && t[pt] != '(') {\n    // none\n  } else if(s[ps] != '(') {\n    rec(t, pt, true);\n  } else if(t[pt] != '(') {\n    rec(s, ps, true);\n  } else {\n    rec_u();\n  }\n  cout << \",\";\n  ++ps; ++pt;\n  if(s[ps] != '(' && t[pt] != '(') {\n    // none\n  } else if(s[ps] != '(') {\n    rec(t, pt, true);\n  } else if(t[pt] != '(') {\n    rec(s, ps, true);\n  } else {\n    rec_u();\n  }\n  cout << \")\";\n  ++ps; ++pt;\n}\n\nint main() {\n  while(cin >> op >> s >> t) {\n    ps = pt = 0;\n    if(op == \"i\") rec_i();\n    else rec_u();\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <string>\n#include <stack>\nusing namespace std;\n\nconst int maxn=50*1000;\n\nint f[maxn],g[maxn];\nbool p[maxn],q[maxn];\nstack <int> s;\nstring s1,s2;\nstring c;\nint  l1,l2;\n\n\nstring dfs1(int i)\n{\n    string lchild = \"\",rchild = \"\";\n    if (f[2*i]!=-1 && g[2*i]!=-1) lchild = dfs1(2*i);\n    if (f[2*i+1]!=-1 && g[2*i+1]!=-1) rchild = dfs1(2*i+1);\n    return \"(\" + lchild + \",\" + rchild + \")\";\n}\n\nstring dfs2(int i)\n{\n    string lchild = \"\",rchild = \"\";\n    if (f[2*i]!=-1 || g[2*i]!=-1) lchild = dfs2(2*i);\n    if (f[2*i+1]!=-1 || g[2*i+1]!=-1) rchild = dfs2(2*i+1);\n    return \"(\" + lchild + \",\" + rchild + \")\";\n}\n\n\nint main()\n{\n    while (cin>>c>>s1>>s2)\n    {\n        l1 = s1.length(); l2 = s2.length();\n\n        memset(f,-1,sizeof(f));\n        memset(g,-1,sizeof(g));\n        memset(p,true,sizeof(p));\n        memset(q,true,sizeof(q));\n\n        while (!s.empty()) s.pop();\n\n        int i=0; int cnt=0;\n        while (i < l1)\n        {\n            if (s1[i] == '(')\n            {\n                cnt++;\n                s.push(cnt);\n\n                if (i+1 < l1 && s1[i+1]==',')\n                {\n                    cnt++;\n                    p[cnt]=false;\n                }\n\n            }\n            else if (s1[i]==')')\n            {\n\n                int ch = s.top(); s.pop();\n                if (!s.empty())\n                {\n                    int fa = s.top();\n                    if (ch==fa+1) f[2*fa]=ch;\n                    else f[2*fa+1] = ch;\n                }\n            }\n            else if (s1[i]==',')\n            {\n                if (i+1 < l1 && s1[i+1]==')')\n                {\n                    cnt++;\n                    p[cnt]=false;\n                }\n            }\n            i++;\n        }\n\n\n        //for (int i=1;i<=cnt;i++)  cout<<i<<\" \"<<f[2*i]<<\" \"<<f[2*i+1]<<endl;\n\n        while (!s.empty()) s.pop();\n        i = 0; cnt = 0;\n        while (i < l2)\n        {\n            if (s2[i] == '(')\n            {\n                cnt++;\n                s.push(cnt);\n                if (i+1 < l2 && s2[i+1]==',')\n                {\n                    cnt++;\n                    q[cnt]=false;\n                }\n            }\n            else if (s2[i]==')')\n            {\n                int ch = s.top(); s.pop();\n                if (!s.empty())\n                {\n                    int fa = s.top();\n                    if (ch==fa+1) g[2*fa] = ch;\n                    else g[2*fa+1] = ch;\n                }\n            }\n            else if (s2[i]==',')\n            {\n                if (i+1 < l2 && s2[i+1]==')')\n                {\n                    cnt++;\n                    q[cnt]=false;\n                }\n            }\n            i++;\n        }\n\n        //for (int i=1;i<=cnt;i++) cout<<i<<\" \"<<g[2*i]<<\" \"<<g[2*i+1]<<endl;\n\n        if (c[0]=='i') cout<<dfs1(1)<<endl;\n        else cout<<dfs2(1)<<endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "class Node\n  attr_reader :left, :right\n  def initialize(left,right)\n    @left = left\n    @right = right\n  end\n  def to_s\n    \"(#{@left||\"\"},#{@right||\"\"})\"\n  end\nend\n\nclass Parser\n  def initialize(str)\n    @str = str\n    @idx = 0\n  end\n  def read\n    if @str[@idx] == ?(\n      @idx += 1\n      l = read\n      @idx += 1\n      r = read\n      @idx += 1\n      Node.new(l,r)\n    else\n      nil\n    end\n  end\nend\n\ndef its (a,b)\n  if a && b\n    Node.new(its(a.left,b.left),its(a.right,b.right))\n  else\n    nil\n  end\nend\n\ndef uni (a,b)\n  if !a\n    b\n  elsif !b\n    a\n  else\n    Node.new(uni(a.left,b.left),uni(a.right,b.right))\n  end\nend\n\nwhile line = gets\n  ch, a, b = line.split\n  c = Parser.new(a).read\n  d = Parser.new(b).read\n\n  if ch==\"i\"\n    puts its(c,d)\n  elsif ch==\"u\"\n    puts uni(c,d)\n  end\nend"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n#include <algorithm>\n\nusing namespace std;\n\nstring tree[2];\n\nstring uni(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    int c = 0;\n    index0++, index1++;\n    if (tree[1][index1] != ',') \n      while (true) {\n\tif (c == 0 && tree[1][index1] == ',') {break;}\n\tif (tree[1][index1] == '(') {c++;}\n\tif (tree[1][index1] == ')') {c--;}\n\tleft = left + tree[1][index1];\n\tindex1++;\n      }\n  } else if (tree[1][index1 + 1] == ',') {\n    int c = 0;\n    index0++, index1++;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ',') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      left = left + tree[0][index0];\n      index0++;\n    }\n  } else {\n    left = uni(index0 + 1, index1 + 1);\n    int c = 0;\n    index0++, index1++;\n    while (true) {\n      //      cout << tree[0][index0];\n      if (c == 0 && tree[0][index0] == ',') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      index0++;\n    }\n    c = 0;\n    while (true) {\n      //      cout << tree[1][index1];\n      if (c == 0 && tree[1][index1] == ',') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      index1++;\n    }\n  }\n\n  if (tree[0][index0 + 1] == ')') {\n    int c = 0;\n    index1++;\n    while (true) {\n      if (c == 0 && tree[1][index1] == ')') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      right = right + tree[1][index1];\n      index1++;\n    }\n  } else if (tree[1][index1 + 1] == ')') {\n    int c = 0;\n    index0++;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ')') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      right = right + tree[0][index0];\n      index0++;\n    }\n  } else {\n    right = uni(index0 + 1, index1 + 1);\n  }\n  return \"(\" + left + \",\" + right + \")\";\n}\n\nstring inter(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    int c = 0;\n    while (true) {\n      if (c == 0 && tree[1][index1] == ',') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      index1++;\n    }\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++,index1++;\n    int c = 0;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ',') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      index0++;\n    }\n  } else {\n    left = inter(index0 + 1, index1 + 1);\n    int c = 0;\n    index0++, index1++;\n    while (true) {\n      if (c == 0 && tree[1][index1] == ',') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      index1++;\n    }\n    c = 0;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ',') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      index0++;\n    }\n  }\n  \n  if (tree[0][index0 + 1] == ')' || tree[1][index1 + 1] == ')') {\n    right = \"\";\n  } else {\n    right = inter(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    cin.ignore();\n    if (ex == 'i') {\n      cout << inter(0, 0) << endl;\n    } else {\n      cout << uni(0, 0) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <boost/shared_ptr.hpp>\nusing namespace std;\n\nstruct bad_input { };\nstruct Node;\ntypedef boost::shared_ptr<Node> NodePtr;\nstruct Node {\n\tNodePtr left;\n\tNodePtr right;\n};\n\nvoid show_intersection_tree(NodePtr root1, NodePtr root2)\n{\n\tstd::cout << '(';\n\tif (root1->left && root2->left) {\n\t\tshow_intersection_tree(root1->left, root2->left);\n\t}\n\tstd::cout << ',';\n\tif (root1->right && root2->right) {\n\t\tshow_intersection_tree(root1->right, root2->right);\n\t}\n\tstd::cout << ')';\n}\n\nvoid show_union_tree(NodePtr root1, NodePtr root2)\n{\n\tstd::cout << '(';\n\tif ((root1 && root1->left) || (root2 && root2->left)) {\n\t\tshow_union_tree(root1 ? root1->left : root1, root2 ? root2->left : root2);\n\t}\n\tstd::cout << ',';\n\tif ((root1 && root1->right) || (root2 && root2->right)) {\n\t\tshow_union_tree(root1 ? root1->right : root1, root2 ? root2->right : root2);\n\t}\n\tstd::cout << ')';\n}\n\nchar get_token()\n{\n\tchar c;\n\twhile (std::cin >> c) {\n\t\tif (c == '(' || c == ',' || c == ')') {\n\t\t\tbreak;\n\t\t}\n\t\tif (c != '\\n' && c != ' ') {\n\t\t\tthrow bad_input();\n\t\t}\n\t}\n\treturn c;\n}\n\nNodePtr make_node(int no)\n{\n\tNodePtr node = boost::make_shared<Node>();\n\tchar c = get_token();\n\tif (c == '(') {\n\t\tnode->left = make_node(no + 1);\n\t\tc = get_token();\n\t}\n\tif (c == ',') {\n\t}\n\telse {\n\t\tthrow bad_input();\n\t}\n\tc = get_token();\n\tif (c == '(') {\n\t\tnode->right = make_node(no + 1);\n\t\tc = get_token();\n\t}\n\tif (c == ')') {\n\t}\n\telse {\n\t\tthrow bad_input();\n\t}\n\treturn node;\n}\n\nint main()\n{\n\tchar op;\n\twhile (std::cin >> op) {\n\t\tNodePtr root1, root2;\n\t\tif (get_token() == '(') {\n\t\t\troot1 = make_node(0);\n\t\t}\n\t\telse {\n\t\t\tthrow bad_input();\n\t\t}\n\t\tif (get_token() == '(') {\n\t\t\troot2 = make_node(0);\n\t\t}\n\t\telse {\n\t\t\tthrow bad_input();\n\t\t}\n\t\tif (op == 'i') {\n\t\t\tif (root1 && root2) {\n\t\t\t\tshow_intersection_tree(root1, root2);\n\t\t\t}\n\t\t}\n\t\telse if (op == 'u') {\n\t\t\tif (root1 || root2) {\n\t\t\t\tshow_union_tree(root1, root2);\n\t\t\t}\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\nstring tree(const string &s, int &pos){\n\tstring chl, chr;\n\t++pos;\n\tif (s[pos] == '(') chl = tree(s, pos);\n\t++pos;\n\tif (s[pos] == '(') chr = tree(s, pos);\n\t++pos;\n\treturn \"(\" + chl + \",\" + chr + \")\";\n}\n\nchar c;\nstring a, b;\nint p1, p2;\n\nstring and(){\n\t++p1, ++p2;\n\n\tstring chl, chr;\n\tif (a[p1] == '(' && b[p2] == '('){\n\t\tchl = and();\n\t}\n\telse if (a[p1] == '('){\n\t\ttree(a, p1);\n\t}\n\telse if (b[p2] == '('){\n\t\ttree(b, p2);\n\t}\n\n\t++p1, ++p2;\n\n\tif (a[p1] == '(' && b[p2] == '('){\n\t\tchr = and();\n\t}\n\telse if (a[p1] == '('){\n\t\ttree(a, p1);\n\t}\n\telse if (b[p2] == '('){\n\t\ttree(b, p2);\n\t}\n\n\t++p1, ++p2;\n\n\treturn \"(\" + chl + \",\" + chr + \")\";\n}\n\nstring or(){\n\t++p1, ++p2;\n\n\tstring chl, chr;\n\tif (a[p1] == '(' && b[p2] == '('){\n\t\tchl = or();\n\t}\n\telse if (a[p1] == '('){\n\t\tchl = tree(a, p1);\n\t}\n\telse if (b[p2] == '('){\n\t\tchl = tree(b, p2);\n\t}\n\n\t++p1, ++p2;\n\n\tif (a[p1] == '(' && b[p2] == '('){\n\t\tchr = and();\n\t}\n\telse if (a[p1] == '('){\n\t\tchr = tree(a, p1);\n\t}\n\telse if (b[p2] == '('){\n\t\tchr = tree(b, p2);\n\t}\n\n\t++p1, ++p2;\n\n\treturn \"(\" + chl + \",\" + chr + \")\";\n}\n\nint main(){\n\twhile (cin >> c >> a >> b){\n\t\tp1 = p2 = 0;\n\n\t\tif (c == 'i') cout << and() << endl;\n\t\telse cout << or() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef stringstream SS;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nSS ss;\n#define debug ss\n#endif\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nint ln,rn;\nvpint nodel,noder;\n\nvoid fl(string str,int n){\n\tnodel.PB(MP(-1,-1));\n\tif(sz(str)<4)return;\n\tint c=0;\n\tint i;\n\trep0(i,sz(str)){\n\t\tif(str[i]=='(')++c;\n\t\tif(str[i]==')')--c;\n\t\tif(str[i]==','&&c==1)break;\n\t}\n\tstring left,right;\n\tleft=str.substr(1,i-1);\n\tright=str.substr(i+1,sz(str)-i-2);\n\tif(sz(left)>0){\n\t\tnodel[n].first=sz(nodel);\n\t\tfl(left,sz(nodel));\n\t}\n\tif(sz(right)>0){\n\t\tnodel[n].second=sz(nodel);\n\t\tfl(right,sz(nodel));\n\t}\n\treturn;\n}\n\nvoid fr(string str,int n){\n\tnoder.PB(MP(-1,-1));\n\tif(sz(str)<4)return;\n\tint c=0;\n\tint i;\n\trep0(i,sz(str)){\n\t\tif(str[i]=='(')++c;\n\t\tif(str[i]==')')--c;\n\t\tif(str[i]==','&&c==1)break;\n\t}\n\tstring left,right;\n\tleft=str.substr(1,i-1);\n\tright=str.substr(i+1,sz(str)-i-2);\n\tif(sz(left)>0){\n\t\tnoder[n].first=sz(noder);\n\t\tfr(left,sz(noder));\n\t}\n\tif(sz(right)>0){\n\t\tnoder[n].second=sz(noder);\n\t\tfr(right,sz(noder));\n\t}\n\treturn;\n}\n\nvoid intersect(int l,int r){\n\tcout<<\"(\";\n\tif(nodel[l].first!=-1&&noder[r].first!=-1){\n\t\tintersect(nodel[l].first,noder[r].first);\n\t}\n\tcout<<\",\";\n\tif(nodel[l].second!=-1&&noder[r].second!=-1){\n\t\tintersect(nodel[l].second,noder[r].second);\n\t}\n\tcout<<\")\";\n}\n\nvoid uni(int l,int r){\n\tif(l==-1&&r==-1)return;\n\tcout<<\"(\";\n\tuni(l!=-1?nodel[l].first:-1,r!=-1?noder[r].first:-1);\n\tcout<<\",\";\n\tuni(l!=-1?nodel[l].second:-1,r!=-1?noder[r].second:-1);\n\tcout<<\")\";\n}\n\nint main() {\n\tstring a,str1,str2;\n\twhile(cin>>a>>str1>>str2){\n\t\tln=rn=0;\n\t\tnodel.clear();\n\t\tnoder.clear();\n\t\tfl(str1,0);fr(str2,0);\n\t\tif(a==\"i\")intersect(0,0);\n\t\telse uni(0,0);\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nstring solve(char op, string t1, string t2) {\n\tstring ret = \"\";\n\tunsigned int i = 0, j = 0;\n\twhile (i < t1.size() && j < t2.size()) {\n\t\tif (t1[i] == t2[j]) {\n\t\t\tret += t1[i];\n\t\t\ti ++;\n\t\t\tj ++;\n\t\t} else {\n\t\t\tbool comma = (t1[i] == ',' || t2[i] == ',');\n\t\t\tif ((comma && t1[i] == ',') || (!comma && t1[i] == ')')) {\n\t\t\t\tswap(i, j);\n\t\t\t\tswap(t1, t2);\n\t\t\t}\n\t\t\tint c = 0;\n\t\t\tunsigned int k = i;\n\t\t\tfor ( ; k<t1.size(); ++k) {\n\t\t\t\tif (t1[k] == '(') c ++;\n\t\t\t\telse if (t1[k] == ')') c --;\n\t\t\t\tif (c <= 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (op == 'u') { // for union\n\t\t\t\t\tret += t1[k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (op == 'u') ret += t1[k]; // for union\n\t\t\ti = k + 1;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tchar op;\n\tstring t1, t2;\n\twhile (cin >> op) {\n\t\tcin >> t1 >> t2;\n\t\tcout << solve(op, t1, t2) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool tree[2][100];\nenum state {l, r};\n\nint main()\n{\n  string str;\n  char op;\n  int  maxn[2] = {0, 0};\n\n  while (getline(cin,str))\n  {\n    for (int i=0;i<100;i++)\n    {\n      tree[0][i]=false;\n      tree[1][i]=false;\n    }\n    op = str[0];\n\n    int k=1;\n    while (str[k]==' ') k++;\n\n    int p = 0;\n    int n = -1;\n    state s;\n    while (k < str.size())\n    {\n      if (str[k]==' ')\n      {\n        p = 1;\n        n = -1;\n      }\n      else\n      {\n        if (str[k] == '(')\n        {\n          if (n == -1) { n = 0; }\n          else if (s == l) n = 2*n + 1;\n          else n = 2*n+2;\n\n          tree[p][n] = true;\n          maxn[p] = max(maxn[p], n);\n          s = l;\n        }\n        else if (str[k] == ',')\n        {\n          s = r;\n        }\n        else\n        {\n          n = (n-1) / 2;\n        }\n      }\n      k++;\n    }\n    // ??¨?????????????????????\n\n    for (int i=0;i<=max(maxn[0],maxn[1]);i++)\n    {\n      if (op == 'i') tree[0][i] = tree[0][i] && tree[1][i];\n      else tree[0][i] = tree[0][i] || tree[1][i];\n    }\n\n    for (int i=0;i<=max(maxn[0],maxn[1]);i++)\n      if (tree[0][i])\n      {\n        cout << i << ' ';\n      }\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n#include <algorithm>\n\nusing namespace std;\n\nstring tree[2];\n\nstring uni(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    int c = 0;\n    index0++, index1++;\n    if (tree[1][index1] != ',') \n      while (true) {\n\tif (c == 0 && tree[1][index1] == ',') {break;}\n\tif (tree[1][index1] == '(') {c++;}\n\tif (tree[1][index1] == ')') {c--;}\n\tleft = left + tree[1][index1];\n      }\n  } else if (tree[1][index1 + 1] == ',') {\n    int c = 0;\n    index0++, index1++;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ',') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      left = left + tree[0][index0];\n    }\n  } else {\n    left = uni(index0 + 1, index1 + 1);\n    int c = 0;\n    index0++, index1++;\n    while (true) {\n      //      cout << tree[0][index0];\n      if (c == 0 && tree[0][index0] == ',') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      index0++;\n    }\n    c = 0;\n    while (true) {\n      //      cout << tree[1][index1];\n      if (c == 0 && tree[1][index1] == ',') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      index1++;\n    }\n  }\n\n  if (tree[0][index0 + 1] == ')') {\n    int c = 0;\n    index1++;\n    while (true) {\n      if (c == 0 && tree[1][index1] == ')') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      right = right + tree[1][index1];\n      index1++;\n    }\n  } else if (tree[1][index1 + 1] == ')') {\n    int c = 0;\n    index0++;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ')') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      right = right + tree[0][index0];\n      index0++;\n    }\n  } else {\n    right = uni(index0 + 1, index1 + 1);\n  }\n  return \"(\" + left + \",\" + right + \")\";\n}\n\nstring inter(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    int c = 0;\n    while (true) {\n      if (c == 0 && tree[1][index1] == ',') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      index1++;\n    }\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++,index1++;\n    int c = 0;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ',') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      index0++;\n    }\n  } else {\n    left = inter(index0 + 1, index1 + 1);\n    int c = 0;\n    index0++, index1++;\n    while (true) {\n      if (c == 0 && tree[1][index1] == ',') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      index1++;\n    }\n    c = 0;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ',') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      index0++;\n    }\n  }\n  \n  if (tree[0][index0 + 1] == ')' || tree[1][index1 + 1] == ')') {\n    right = \"\";\n  } else {\n    right = inter(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    cin.ignore();\n    if (ex == 'i') {\n      cout << inter(0, 0) << endl;\n    } else {\n      cout << uni(0, 0) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=1000;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  if(id>=N){\n    cout<<\"error occured\";\n    return;\n  }\n  heap[id]++;\n  if(s==\"(,)\") return;\n  \n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;   \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n      if(i<i-1) parse(sub1, 2*id+1);\n      if(i+1<s.length()-i-2)parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nvoid out(int th, int id){\n\n  output.push_back('(');\n\n  int ch1=0,ch2=0;//n of string of each child\n  \n  if(heap[id]>th && heap[2*id+1]>th){\n    out(th,2*id+1);\n  }\n  output.push_back(',');\n  if(heap[id]>th && heap[2*id+2]>th){\n    out(th,2*id+2);\n  }\n  \n  output.push_back(')');\n  return;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  output.clear();\n  //cout<<output<<endl;\n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0);\n  \n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  int i=0;\n  \n  while(cin>>cmd>>s1>>s2){\n    solve(cmd,s1,s2);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n}\n s"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=1000;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  if(id>=N){\n    cout<<\"error occured\";\n    return;\n  }\n  heap[id]++;\n  if(s==\"(,)\") return;\n  \n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;   \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n      parse(sub1, 2*id+1);\n      parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nvoid out(int th, int id){\n\n  output.push_back('(');\n\n  int ch1=0,ch2=0;//n of string of each child\n  if(id*2+1>=N) cout<<\"error: undefined index\\n\";\n  \n  if(heap[id]>th && heap[2*id+1]>th){\n    out(th,2*id+1);\n  }\n  output.push_back(',');\n  if(heap[id]>th && heap[2*id+2]>th){\n    out(th,2*id+2);\n  }\n  \n  output.push_back(')');\n  return;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  output.clear();\n  //cout<<output<<endl;\n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0);\n  \n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  int i=0;\n  \n  while(cin>>cmd>>s1>>s2){\n    solve(cmd,s1,s2);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nstring tree[2];\nbool node[2][100][100];\n\nstring uni(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    if (tree[1][index1] != ',') \n      for (;tree[1][index1] != ','; index1++) {\n\tleft = left + tree[1][index1];\n      }\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[0][index0] != ','; index0++) {\n      left = left + tree[0][index0];\n    }\n  } else {\n    left = uni(index0 + 1, index1 + 1);\n    for (;tree[0][index0] != ','; index0++);\n    for (;tree[1][index1] != ','; index1++);\n  }\n\n  if (tree[0][index0 + 1] == ')') {\n    index1++;\n    if (tree[1][index1] != ')') {\n      int c = 0;\n      for (;; index1++) {\n\tif (c <= 1 && tree[1][index1] == ')') {\n\t  right = right + tree[1][index1];\n\t  break;\n\t}\n\tif (tree[1][index1] == '(') {c++;}\n\tif (tree[1][index1] == ')') {c--;}\n\tright = right + tree[1][index1];\n      }\n    } else {\n      right = \"\";\n    }\n  } else if (tree[1][index1 + 1] == ')') {\n    index0++, index1++;\n    int c = 0;\n    for (;; index0++) {\n      if (c <= 1 && tree[0][index0] == ')') {\n\tright = right + tree[0][index0];\n\tbreak;\n      }\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      right = right + tree[0][index0];\n    }\n  } else {\n    right = uni(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nstring inter(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[1][index1] != ','; index1++);\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[0][index0] != ','; index0++);\n  } else {\n    left = inter(index0 + 1, index1 + 1);\n    for (;tree[0][index0] != ','; index0++);\n    for (;tree[1][index1] != ','; index1++);\n  }\n\n  if (tree[0][index0 + 1] == ')') {\n    index0++, index1++;\n    int c = 0;\n    for (;; index1++) {\n      if (c <= 1 && tree[1][index1] == ')') {\n\tright = right + tree[1][index1];\n\tbreak;\n      }\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n    }\n  } else if (tree[1][index1 + 1] == ')') {\n    index0++, index1++;\n    int c = 0;\n    for (;; index0++) {\n      if (c <= 1 && tree[0][index0] == ')') {\n\tright = right + tree[0][index0];\n\tbreak;\n      }\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n    }\n  } else {\n    right = inter(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    if (ex == 'i') {\n      cout << inter(0, 0) << endl;\n    } else {\n      cout << uni(0, 0) << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=1000;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  heap[id]++;\n  if(s==\"(,)\") return;\n  \n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;   \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n      if(i-1>=0) parse(sub1, 2*id+1);\n      if(s.length()-i-2>=0)parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nvoid out(int th, int id){\n\n  output.push_back('(');\n\n  int ch1=0,ch2=0;//n of string of each child\n  \n  if(heap[id]>th && heap[2*id+1]>th){\n    out(th,2*id+1);\n  }\n  output.push_back(',');\n  if(heap[id]>th && heap[2*id+2]>th){\n    out(th,2*id+2);\n  }\n  \n  output.push_back(')');\n  return;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  output.clear();\n  //cout<<output<<endl;\n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0);\n  \n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  int i=0;\n  \n  while(cin>>cmd>>s1>>s2){\n    solve(cmd,s1,s2);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nstring tree[2];\nbitset<500000000> node[2];\n\nvoid perse(int index, int n, int i)\n{\n  //cout << \"persed \" << n << endl;\n  if (index >= tree[i].size()) {\n    return;\n  }\n  if (tree[i][index] == '(') {\n    while (tree[i][index] == ' ') {index++;}\n    node[i][n] = true;\n    perse(index + 1, 2 * n + 1, i);\n  } else if (tree[i][index] == ')') {\n    while (tree[i][index] == ' ') {index++;}\n    perse(index + 1, (((n - 2) / 2 < 0) ? 0 : (n - 2) / 2), i);\n  } else if (\",\"){\n    while (tree[i][index] == ' ') {index++;}\n    perse(index + 1, n + 1, i);\n  }\n}\n\nstring _perse(int index)\n{\n  if (node[0][index]) {\n    return \"(\" + _perse(2 * index + 1) + \",\" + _perse(2 * index + 2) + \")\";\n  }\n  return \"\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    for (int i = 0; i < 2; i++) {\n      node[i].reset();\n      perse(0, 0, i);\n      \n      /*for (int j = 0; j < 300; j++) {\n\tif (node[i][j]) {\n\t  cout << j;\n\t}\n      }\n      cout << endl;*/\n    }\n    if (ex == 'u') {\n      node[0] |= node[1];\n    } else {\n      node[0] &= node[1];\n    }\n    cout << _perse(0) << endl;\n    cin.ignore();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n\nusing namespace std;\n\nconst int SIZE = 128;\nbool A[SIZE],B[SIZE],C[SIZE];\n\nint getPos(const string& s){\n  int p = 0;\n  for(int i = 0; i < (int)s.length(); i++){\n    if(s[i] == '(') p++;\n    else if(s[i] == ')') p--;\n    if(p == 0 && s[i] == ',') return i;\n  }\n  return -1;\n}\n\nvoid parse(const string& s, bool isA, int idx){\n  if(s == \"\") return;\n  if(idx < 0 || idx >= SIZE) return;\n  if(isA) A[idx] = true;\n  else B[idx] = true;\n  string nex = s.substr(1,s.length()-2);\n  int pos = getPos(nex);\n  string left = nex.substr(0,pos);\n  string right = nex.substr(pos+1);\n  parse(left,isA,2*idx+1);\n  parse(right,isA,2*idx+2);\n}\n\nstring makeTree(int idx){\n  if(!C[idx]) return \"\";\n  string res = \"\";\n  if(2*idx+1 < SIZE) res += makeTree(2*idx+1);\n  res += \",\";\n  if(2*idx+2 < SIZE) res += makeTree(2*idx+2);\n  res = \"(\" + res + \")\";\n  return res;\n}\n\nint main(){\n\n  char c;\n  string a,b;\n  while(cin >> c >> a >> b){\n    memset(A,false,sizeof(A));\n    memset(B,false,sizeof(B));\n    memset(C,false,sizeof(C));\n    parse(a,true,0);\n    parse(b,false,0);\n    if(c=='i') for(int i = 0; i < SIZE; i++) C[i] = A[i]&&B[i];\n    else for(int i = 0; i < SIZE; i++) C[i] = A[i]||B[i];\n    cout << makeTree(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <tuple>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <array>\n#include <functional>\n#include <list>\n#include <iomanip>\n#include <set>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\nconst int MOD=1000000007;\nconst int INF=1000000000;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-9;\nconst int inf=1e9;\ntypedef pair<int,int> P;\nchar op;\nstring s1,s2;\nstruct Tree\n{\n  vector<Tree> left,right;\n};\nTree null;\n\nclass Parser{\npublic:\n\n  Tree parsetree(State &begin)\n  {\n    Tree ret;\n    if(*begin=='(') begin++;\n    if(*begin!=',')\n      {\n\t//begin++;\n\tret.left.push_back(parsetree(begin));\n      }\n    if(*begin==',')begin++;\n    if(*begin!=')')\n      {\n\t//begin++;\n\tret.right.push_back(parsetree(begin));\n      }\n    if(*begin==')') begin++;\n    return ret;\n  }\n  string dfs_i(Tree t1,Tree t2)\n  {\n    string ret=\",\";\n    if(t1.left.size()!=0 && t2.left.size()!=0)\n      {\n\tret=\"(\"+dfs_i(t1.left[0],t2.left[0])+ret;\n      }\n    else ret=\"(\" + ret;\n    if(t1.right.size()!=0 && t2.right.size()!=0)\n      {\n\tret=ret+dfs_i(t1.right[0],t2.right[0])+\")\";\n      }\n    else ret=ret+\")\";\n    return ret;\n  }\n  string dfs_u(Tree t1,Tree t2)\n  {\n    string ret=\",\";\n    Tree tmp1,tmp2;\n    if(t1.left.size()!=0 || t2.left.size()!=0)\n      {\n\ttmp1=(t1.left.size()!=0) ? t1.left[0]:null;\n\ttmp2=(t2.left.size()!=0) ? t2.left[0]:null;\n\tret=\"(\"+dfs_u(tmp1,tmp2)+ret;\n      }\n    else ret=\"(\" + ret;\n    if(t1.right.size()!=0 || t2.right.size()!=0)\n      {\n\ttmp1=(t1.right.size()!=0) ? t1.right[0]:null;\n\ttmp2=(t2.right.size()!=0) ? t2.right[0]:null;\n\tret=ret+dfs_u(tmp1,tmp2)+\")\";\n      }\n    else ret=ret+\")\";\n    return ret;\n  }\n  /*\n  ll number(State &begin)\n  {\n    ll ret=0;\n    while(isdigit(*begin))\n      {\n\tret*=10;\n\tret+=(*begin-'0');\n\tbegin++;\n      }\n    return ret;\n  }\n\n  ll expression(State &begin)\n  {\n    ll ret=term(begin);\n    for(;;)\n      {\n\tif(*begin=='+')\n\t  {\n\t    begin++;\n\t    ret=(ret+term(begin))%p;\n\t  }\n\telse if(*begin=='-')\n\t  {\n\t    begin++;\n\t    ret=(ret+(p-term(begin)))%p;\n\t  }\n\telse\n\t  {\n\t    break;\n\t  }\n      }\n    return ret%p;\n  }\n\n  ll term(State &begin)\n  {\n    ll ret=factor(begin);\n    for(;;)\n      {\n\tif(*begin=='*')\n\t  {\n\t    begin++;\n\t    ret=(ret*factor(begin))%p;\n\t  }\n\telse if(*begin=='/')\n\t  {\n\t    begin++;\n\t    State tmp=begin;\n\t    if(factor(tmp)==0)\n\t      {\n\t\tzerodiv=true;\n\t\treturn 0;\n\t      }\n\t    ret=(ret*(ppow(factor(begin),p-2,p)))%p;\n\t  }\n\telse\n\t  {\n\t    break;\n\t  }\n      }\n    return ret;\n  }\n\n  ll factor(State &begin)\n  {\n    ll ret;\n    if(*begin=='(')\n      {\n\tbegin++;\n        ret=expression(begin);\n\tbegin++;\n\treturn ret;\n      }\n    else\n      {\n\tret=number(begin)%p;\n      }\n      return ret;\n      }*/\n};\n\n\nint main(int argc,char const* argv[])\n{\n  while(cin >> op)\n    {\n      Parser ps;\n      cin >> s1 >> s2;\n      State begin1=s1.begin();\n      State begin2=s2.begin();\n      Tree t1=ps.parsetree(begin1);\n      Tree t2=ps.parsetree(begin2);\n      string ans=\"\";\n      if(op=='i')\n\t{\n\t  ans=ps.dfs_i(t1,t2);\n\t}\n      if(op=='u')\n\t{\n\t  ans=ps.dfs_u(t1,t2);\n\t}\n      cout << ans << endl;\n    }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <string.h>\n\nint is_edge(char *expression)\n{ \n  return strlen(expression)==0 ? 1 : 0;\n}\n\nint intersection_condition(char *a, char *b)\n{\n  return (!is_edge(a) && !is_edge(b)) ? 1 : 0;\n}\n\nint union_condition(char *a, char *b)\n{\n  return (!is_edge(a) || !is_edge(b)) ? 1 : 0;\n}\n\nvoid childrens_expression(char *expression, char *left, char *right)\n{\n  if (is_edge(expression)) {\n    left[0] = '\\0';\n    right[0] = '\\0';\n  } else {\n    int i;\n    int l_bracket_num = 0, r_bracket_num = 0;\n  \n    for (i=0; i<strlen(expression); ++i) {\n      int flag = 0;\n      switch (expression[i]) {\n      case '(':\n        ++l_bracket_num;\n        break;\n      case ')':\n        ++r_bracket_num;\n        break;\n      case ',':\n        if (l_bracket_num == r_bracket_num + 1) {\n          flag = 1;\n        }\n        break;\n      }\n      if (flag) {\n        break;\n      }\n    }\n  \n    expression = &expression[1];\n    strncpy(left, expression, i-1);\n    left[i-1] = '\\0';\n    expression = &expression[i];\n    strncpy(right, expression, strlen(expression)-1);\n    right[strlen(expression)-1] = '\\0';\n  }\n}\n\nvoid output(char *a, char *b, int (*condition)(char*, char*))\n{\n  char a_left[512], a_right[512], b_left[512], b_right[512];\n  childrens_expression(a, a_left, a_right);\n  childrens_expression(b, b_left, b_right);\n\n  printf(\"(\");\n\n  if (condition(a_left, b_left)) {\n    output(a_left, b_left, condition);\n  }\n\n  printf(\",\");\n\n  if (condition(a_right, b_right)) {\n    output(a_right, b_right, condition);\n  }\n\n  printf(\")\");\n}\n\nint main(void)\n{\n  char op[4];\n  char a[512], b[512];\n  \n  while (scanf(\"%s %s %s\", op, a, b) != EOF) {\n    switch (op[0]) {\n    case 'i':\n      output(a, b, intersection_condition);\n      break;\n    case 'u':\n      output(a, b, union_condition);\n      break;\n    }\n    printf(\"\\n\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nstring tree[2];\nbool node[2][100][100];\n\nstring uni(int index0, int index1)\n{\n  string left, right;\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[1][index1] != ','; index1++) {\n      left = left + tree[1][index1];\n    }\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[0][index0] != ','; index0++) {\n      left = left + tree[0][index0];\n    }\n  } else {\n    left = uni(index0 + 1, index1 + 1);\n  }\n\n  for (;tree[0][index0] != ','; index0++);\n  for (;tree[0][index1] != ','; index1++);\n\n  if (tree[0][index0 + 1] == ')') {\n    index0++, index1++;\n    for (;tree[1][index1] != ')'; index1++) {\n      right = right + tree[1][index1];\n    }\n  } else if (tree[1][index1 + 1] == ')') {\n    index0++, index1++;\n    for (;tree[0][index0] != ')'; index0++) {\n      right = right + tree[0][index0];\n    }\n  } else {\n    right = uni(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nstring inter(int index0, int index1)\n{\n  string left, right;\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[1][index1] != ','; index1++);\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[0][index0] != ','; index0++);\n  } else {\n    left = inter(index0 + 1, index1 + 1);\n  }\n\n  for (;tree[0][index0] != ','; index0++);\n  for (;tree[0][index1] != ','; index1++);\n\n  if (tree[0][index0 + 1] == ')') {\n    index0++, index1++;\n    for (;tree[1][index1] != ')'; index1++);\n  } else if (tree[1][index1 + 1] == ')') {\n    index0++, index1++;\n    for (;tree[0][index0] != ')'; index0++);\n  } else {\n    right = inter(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    if (ex == 'i') {\n      cout << inter(0, 0) << endl;\n    } else {\n      cout << uni(0, 0) << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * $File: p1001.cpp\n * $Author: Wayne <tletletle@163.com>\n *\n * Task:\n *   Given two binary trees, we need to\n *   calculate the intersection or the\n *   union of them.\n *\n * Solution:\n *   Parsing. Graph theory.\n *   Just Build the trees and implement.\n */\n\n#include <cstdio>\n#include <cstring>\n\nconst int kMaxVtx = 100;\nconst int kMaxBuf = 512;\nchar buf[kMaxBuf];\n\nstruct TreeNode {\n\tTreeNode *son[2];\n\tTreeNode() {\n\t\tson[0] = son[1] = NULL;\n\t}\n};\n\nstruct Tree {\n\tTreeNode *root;\n\tTree() {\n\t\troot = NULL;\n\t}\n} a, b, c;\n\nTreeNode *BuildTree(int l, int r) {\n\tif (l > r) return NULL;\n\tTreeNode *res = new TreeNode;\n\tif (l + 1 == r - 1) return res;\n\tint mid, sum = 0;\n\tfor (int i = l + 1; i <= r - 1; ++ i)\n\t\tif (buf[i] == '(') ++ sum;\n\t\telse if (buf[i] == ')') -- sum;\n\t\telse if (buf[i] == ',' && sum == 0) mid = i;\n\tres->son[0] = BuildTree(l + 1, mid - 1);\n\tres->son[1] = BuildTree(mid + 1, r - 1);\n\treturn res;\n}\n\nvoid ReadTree(Tree &des) {\n\tscanf(\"%s\", buf);\n\tdes.root = BuildTree(0, strlen(buf) - 1);\n}\n\nTreeNode *DfsIntersection(TreeNode *u, TreeNode *v) {\n\tif (!u || !v) return NULL;\n\tTreeNode *res = new TreeNode;\n\tres->son[0] = DfsIntersection(u->son[0], v->son[0]);\n\tres->son[1] = DfsIntersection(u->son[1], v->son[1]);\n\treturn res;\n}\n\nTreeNode *DfsUnion(TreeNode *u, TreeNode *v) {\n\tif (!u && !v) return NULL;\n\tTreeNode *res = new TreeNode;\n\tres->son[0] = DfsUnion(u ? u->son[0] : NULL, v ? v->son[0] : NULL);\n\tres->son[1] = DfsUnion(u ? u->son[1] : NULL, v ? v->son[1] : NULL);\n\treturn res;\n}\n\nTree GetIntersection(const Tree &a, const Tree &b) {\n\tTree res;\n\tres.root = DfsIntersection(a.root, b.root);\n\treturn res;\n}\n\nTree GetUnion(const Tree &a, const Tree &b) {\n\tTree res;\n\tres.root = DfsUnion(a.root, b.root);\n\treturn res;\n}\n\nvoid OutputTree(TreeNode *cur) {\n\tif (!cur) return;\n\tputchar('(');\n\tOutputTree(cur->son[0]);\n\tputchar(',');\n\tOutputTree(cur->son[1]);\n\tputchar(')');\n}\n\nint main() {\n\tstatic char cmd[2];\n\twhile (scanf(\"%s\", cmd) != EOF) {\n\t\tReadTree(a);\n\t\tReadTree(b);\n\t\tif (cmd[0] == 'i') c = GetIntersection(a, b);\n\t\telse c = GetUnion(a, b);\n\t\tOutputTree(c.root);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring o,s,t,ans;\nint x,y;\nvoid ii(){\n  while(x<s.size()&&y<t.size()){\n    if(s[x]==t[y])ans+=s[x];\n    else{\n      if(s[x]=='('){\n      stack<char>st;\n      st.push(s[x]);\n      while(!st.empty()){\n\tx++;\n\tif(s[x]=='.')continue;\n\telse if(s[x]==st.top())st.push(s[x]);\n\telse st.pop();\n      }y--;x++;}\n      else {\n      stack<char>st;\n      st.push(t[y]);\n      while(!st.empty()){\n\ty++;\n\tif(t[y]=='.')continue;\n\telse if(t[y]==st.top())st.push(t[y]);\n\telse st.pop();\n      }x--;y++;}\n    }\n    x++;y++;\n  }\n}\nvoid uu(){\n  int x1=0,y1=0;\n  while(x<s.size()&&y<t.size()){\n    if(s[x]==t[y]){\n      ans+=s[x];\n    }\n    else if(s[x]=='('){\n      stack<char>st;\n      st.push(s[x]);\n      ans+=s[x];\n      while(!st.empty()){\n\tif(x==s.size()-2){x1++;break;}\n\tx++;\n\tif(s[x]==')')st.pop(),ans+=s[x];\n\telse if(s[x]=='.')st.push(s[x]),ans+=s[x];\n\telse st.push('('),ans+=s[x];\n      }\n    }\n    else if(t[y]=='('){\n      stack<char>st;\n      st.push(t[y]);\n      ans+=t[y];\n      while(!st.empty()){\n\tif(y==t.size()-2){y1++;break;}\n\ty++;\n\tif(t[y]==')')st.pop(),ans+=t[y];\n\telse if(t[y]=='.')st.push(t[y]),ans+=t[y];\n\telse st.push('('),ans+=t[y];\n      }\n    }\n    if(x1){\n      while(y<t.size())ans+=t[y++];\n      return;\n    }\n    if(y1){\n      while(x<s.size())ans+=s[x++];\n      return;\n    }\n    x++;y++;\n  }\n}\nint main(){\n  while(cin>>o>>s>>t){\n    ans=\"\";\n    x=y=0;\n    if(s.size()<t.size())swap(s,t);\n    if(o==\"u\")uu();\n    else ii();\n    for(int i=0;i<ans.size();i++){\n      if(ans[i]==ans[i+1]&&ans[i]==','){\n\tans.erase(ans.begin()+i+1);\n\tbreak;\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Node{\n\tNode *left,*right;\n\t\n\tNode():left(0),right(0){}\n\tNode(Node* l,Node* r):left(l),right(r){}\n\t//~Node(){delete left;delete right;}\n};\n\nint parse(const string& s,int index,Node* n)\n{\n\tindex++;\n\tif(s[index]=='('){\n\t\tn->left=new Node;\n\t\tindex=parse(s,index,n->left);\n\t}\n\tindex++;\n\tif(s[index]=='('){\n\t\tn->right=new Node;\n\t\tindex=parse(s,index,n->left);\n\t}\n\tindex++;\n\treturn index;\n}\n\nvoid print(Node* n)\n{\n\tif(!n)\n\t\treturn;\n\tprintf(\"(\");\n\tprint(n->left);\n\tprintf(\",\");\n\tprint(n->right);\n\tprintf(\")\");\n}\n\nNode* tree_and(Node* n1,Node* n2)\n{\n\tif(!n1 || !n2)\n\t\treturn NULL;\n\tNode* n=new Node;\n\tif(n1->left && n2->left)\n\t\tn->left=tree_and(n1->left,n2->left);\n\tif(n1->right && n2->right)\n\t\tn->right=tree_and(n1->right,n2->right);\n\treturn n;\n}\n\nNode* tree_or(Node* n1,Node* n2)\n{\n\tif(!n1 && !n2)\n\t\treturn NULL;\n\tNode* n=new Node;\n\tif(n1 && n2){\n\t\tif(n1->left || n2->left)\n\t\t\tn->left=tree_or(n1->left,n2->left);\n\t\tif(n1->right || n2->right)\n\t\t\tn->right=tree_or(n1->right,n2->right);\n\t}\n\telse if(n1){\n\t\tif(n1->left)\n\t\t\tn->left=tree_or(n1->left,NULL);\n\t\tif(n1->right)\n\t\t\tn->right=tree_or(n1->right,NULL);\n\t}\n\telse{\n\t\tif(n2->left)\n\t\t\tn->left=tree_or(NULL,n2->left);\n\t\tif(n2->right)\n\t\t\tn->right=tree_or(NULL,n2->right);\n\t}\n\treturn n;\n}\n\nint main()\n{\n\tfor(string op,s1,s2;cin>>op>>s1>>s2;){\n\t\tNode n1,n2;\n\t\tparse(s1,0,&n1);\n\t\tparse(s2,0,&n2);\n\t\t\n\t\tNode* res;\n\t\tif(op==\"i\")\n\t\t\tres=tree_and(&n1,&n2);\n\t\telse\n\t\t\tres=tree_or(&n1,&n2);\n\t\tprint(res);puts(\"\");\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\nusing namespace std;\n#define int long long\nint get_center(char *str, int l){\n\tint x=0;\n\tfor(int i=0;i<l;i++){\n\t\tif(*(str+i) == ',' && x==1) return i;\n\t\telse if(*(str+i) == '(') x++;\n\t\telse if(*(str+i) == ')') x--;\n\t}\n\treturn 0;\n}\nstring subs(char* s, int l){\n\tstring str(s);\n\treturn str.substr(0, l);\n}\nstring make(char op, char* str1, int str1l, char* str2, int str2l){\n\tif(op=='u' && str1l==0) return subs(str2,str2l);\n\telse if (op=='u' && str2l==0) return subs(str1,str1l);\n\telse if(str1l==0 || str2l==0) return \"\";\n\telse {\n\t\tint c1 = get_center(str1, str1l);\n\t\tint c2 = get_center(str2, str2l);\n\t\treturn \"(\" + make(op,str1+1,c1-1,str2+1,c2-1) + \",\" + make(op,str1+c1+1,str1l-c1-2,str2+c2+1,str2l-c2-2) + \")\";\n\t}\n}\nsigned main(){\n\tchar c;\n\tchar buf1[512], buf2[512];\n\twhile( cin >> c >> buf1 >> buf2 ){\n\t\tcout << make(c, buf1, strlen(buf1), buf2, strlen(buf2)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\ntemplate<class T>class L{L<T*>operator->()};L<int>i=i->\n\nint main(){\n while(1){\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef bitset<100> Node;\n\nbool comp2(const Node& n1, const Node& n2)\n{\n\tint p1=99, p2=99;\n\twhile (!n1.test(p1)) p1--;\n\twhile (!n2.test(p2)) p2--;\n\n\tp1--; p2--;\n\twhile (p1>=0 && p2>=0)\n\t{\n\t\tbool t1=n1.test(p1), t2=n2.test(p2);\n\t\tif (!t1 && t2)\n\t\t\treturn true;\n\t\tif (t1 && !t2)\n\t\t\treturn false;\n\t\tp1--; p2--;\n\t}\n\n\tif (p1 > p2)\n\t\treturn !n1.test(p1);\n\tif (p1 < p2)\n\t\treturn n2.test(p2);\n\treturn false;\n}\n\nvoid parse(string s, vector<Node>& t, Node n)\n{\n\tif (s.empty())\n\t\treturn;\n\tt.push_back(n);\n\n\ts = string(s.begin()+1, s.end()-1);\n\tint c=0, i=0;\n\tfor (; i<s.size(); i++)\n\t\tif (s[i]=='(')\n\t\t\tc++;\n\t\telse if (s[i]==')')\n\t\t\tc--;\n\t\telse if (s[i]==',' && c==0)\n\t\t\tbreak;\n\n\tstring s1=string(s.begin(), s.begin()+i), s2=string(s.begin()+i+1, s.end());\n\tn <<= 1;\n\tif (!s1.empty())\n\t\tparse(s1, t, n);\n\tn = n.set(0);\n\tif (!s2.empty())\n\t\tparse(s2, t, n);\n}\n\nstring rec(vector<Node> t)\n{\n\tif (t.empty())\n\t\treturn \"\";\n\n\tvector<Node> t1, t2;\n\tvector<Node>::iterator it=find(t.begin(), t.end(), Node(1));\n\tt1 = vector<Node>(t.begin(), it);\n\tt2 = vector<Node>(it+1, t.end());\n\n\tfor (int i=0; i<t1.size(); i++)\n\t\tt1[i] >>= 1;\n\n\tfor (int i=0; i<t2.size(); i++)\n\t\tt2[i] >>= 1;\n\n\treturn \"(\" + rec(t1) + \",\" + rec(t2) + \")\";\n}\n\nint main()\n{\n\tstring s;\n\twhile (getline(cin, s))\n\t{\n\t\tchar c=s[0];\n\t\ts = string(s.begin()+1, s.end());\n\t\tfor (int i=0; i<s.size(); i++)\n\t\t\tif (s[i]==' ')\n\t\t\t{\n\t\t\t\ts.erase(s.begin()+i); i--;\n\t\t\t}\n\n\t\tint p = s.find(\")(\", 0);\n\t\tstring s1 = string(s.begin(), s.begin()+(++p));\n\t\tstring s2 = string(s.begin()+p, s.end());\n\n\t\tvector<Node> t1, t2;\n\t\tparse(s1, t1, Node(1));\n\t\tparse(s2, t2, Node(1));\n\n\t\tsort(t1.begin(), t1.end(), comp2);\n\t\tsort(t2.begin(), t2.end(), comp2);\n\n\t\tvector<Node> res(200, Node());\n\t\tvector<Node>::iterator it;\n\t\tif (c == 'i')\n\t\t\tit = set_intersection(t1.begin(), t1.end(), t2.begin(), t2.end(), res.begin(), comp2);\n\t\telse\n\t\t\tit = set_union(t1.begin(), t1.end(), t2.begin(), t2.end(), res.begin(), comp2);\n\t\tres = vector<Node>(res.begin(), it);\n\n\t\tcout << rec(res) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nconst int nil = -1;\nconst int MAX_N = 256;\n\nstruct Node {\n  int l, r, cnt;\n  Node() {\n    l = r = nil;\n    cnt = 0;\n  }\n};\n\nNode v[MAX_N];\nint nodeIndex;\n\nint parse(const char *s, int n, int root) {\n  v[root].cnt++;\n  if (s[++n] != ',') {\n    if (v[root].l == nil) v[root].l = ++nodeIndex;\n    n = parse(s, n, v[root].l);\n  }\n  if (s[++n] != ')') {\n    if (v[root].r == nil) v[root].r = ++nodeIndex;\n    n = parse(s, n, v[root].r);\n  }\n  return n+1;\n}\n\nvoid print(int root, int cnt) {\n  if (v[root].cnt < cnt) return;\n  putchar('(');\n  if (v[root].l != nil) print(v[root].l, cnt);\n  putchar(',');\n  if (v[root].r != nil) print(v[root].r, cnt);\n  putchar(')');\n}\n\nint main() {\n  char t1[256], t2[256];\n  int op;\n  while ((op=getchar()) != EOF) {\n    scanf(\"%s %s\\n\", t1, t2);\n    for (int i=0;i<MAX_N;i++) v[i] = Node();\n    nodeIndex = 0;\n    parse(t1, 0, 0);\n    parse(t2, 0, 0);\n    print(0, (op=='u'?1:2)); putchar('\\n');\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstring a,b,z;\nint d;\nstring ans;\nbool flgA[10000000];\nbool flgB[10000000];\n\nvoid rec(int x){\n\n  ans.push_back('(');\n\n  if(flgA[x*2]==true){\n    rec(x*2);\n  }\n  ans.push_back(',');\n  if(flgA[x*2+1]==true){\n    rec(x*2+1);\n  }\n\n  ans.push_back(')');\n}\n\n\nint main(){\n  while(cin>>z){\n\n    cin>>a;\n    for(int i=0;i<10000000;i++)flgA[i]=flgB[i]=false;\n    flgA[1]=flgB[1]=true;\n    \n    d=1;\n    for(int i=0;i<(int)a.size();i++){\n      if(a[i]=='('){\n\tflgA[d]=true;\n\td*=2;\n      }else if(a[i]==','){\n\td=d+1;\n      }else{\n\td/=2;\n      }\n    }\n    \n      cin>>b;\n      d=1;\n      for(int i=0;i<(int)b.size();i++){\n      if(b[i]=='('){\n\tflgB[d]=true;\n\td*=2;\n      }else if(b[i]==','){\n\td=d+1;\n      }else{\n\td/=2;\n      }\n    }\n    \n\n    for(int i=0;i<10000000;i++){\n      if(flgB[i]==false){\n\tif(z==\"i\"){\n\t  flgA[i]=false;\n\t}\n      }else{\n\tif(z==\"u\"){\n\t  flgA[i]=true;\n\t}\n      }\n\n    }\n\n    ans=\"\";\n    rec(1);\n    cout<<ans<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n\nint main(){\n    std::cout << \"Hello World!\" << std::endl;\n    return 0;\n}\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nstring tree[2];\nbitset<100000000> node[2];\n\nvoid perse(int index, int n, int i)\n{\n  //cout << \"persed \" << n << endl;\n  if (index >= tree[i].size()) {\n    return;\n  }\n  if (tree[i][index] == '(') {\n    while (tree[i][index] == ' ') {index++;}\n    node[i][n] = true;\n    perse(index + 1, 2 * n + 1, i);\n  } else if (tree[i][index] == ')') {\n    while (tree[i][index] == ' ') {index++;}\n    perse(index + 1, (((n - 2) / 2 < 0) ? 0 : (n - 2) / 2), i);\n  } else if (\",\"){\n    while (tree[i][index] == ' ') {index++;}\n    perse(index + 1, n + 1, i);\n  }\n}\n\nstring _perse(int index)\n{\n  if (node[0][index]) {\n    return \"(\" + _perse(2 * index + 1) + \",\" + _perse(2 * index + 2) + \")\";\n  }\n  return \"\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    for (int i = 0; i < 2; i++) {\n      node[i].reset();\n      perse(0, 0, i);\n      \n      /*for (int j = 0; j < 300; j++) {\n\tif (node[i][j]) {\n\t  cout << j;\n\t}\n      }\n      cout << endl;*/\n    }\n    if (ex == 'u') {\n      node[0] |= node[1];\n    } else {\n      node[0] &= node[1];\n    }\n    cout << _perse(0) << endl;\n    cin.ignore();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=1000;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  /*if(id>=N){\n    cout<<\"error occured\";\n    return;\n  }*/\n  heap[id]++;\n  if(s==\"(,)\") return;\n  \n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;   \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n      if(i<i-1) parse(sub1, 2*id+1);\n      if(i+1<s.length()-i-2)parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nvoid out(int th, int id){\n\n  output.push_back('(');\n\n  int ch1=0,ch2=0;//n of string of each child\n  \n  if(heap[id]>th && heap[2*id+1]>th){\n    out(th,2*id+1);\n  }\n  output.push_back(',');\n  if(heap[id]>th && heap[2*id+2]>th){\n    out(th,2*id+2);\n  }\n  \n  output.push_back(')');\n  return;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  output.clear();\n  //cout<<output<<endl;\n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0);\n  \n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  int i=0;\n  \n  while(cin>>cmd>>s1>>s2){\n    solve(cmd,s1,s2);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstruct Node{\n    Node* left;\n    Node* right;\n};\n\nNode* newNode(){\n    Node* ret = (Node*)malloc(sizeof(Node));\n    ret->left = NULL;\n    ret->right = NULL;\n    return ret;\n}\n\nNode* build(int &pos, const string s){\n    if(s[pos] != '(')   return NULL;\n    Node* ret = newNode();\n    pos++;  // (\n    ret->left = build(pos, s);\n    pos++;  // ,\n    ret->right = build(pos, s);\n    pos++;  // )\n    return ret;\n}\n\nvoid print(Node* root){\n    cout << \"(\";\n    if(root->left != NULL)  print(root->left);\n    cout << \",\";\n    if(root->right != NULL) print(root->right);\n    cout << \")\";\n}\n\nNode* op(char c, Node* x, Node* y){\n    int cnt = (x!=NULL) + (y!=NULL);\n    if((cnt == 2 && c == 'i') || (cnt > 0 && c == 'u')){\n        Node* root = newNode();\n        root->left = op(c, (x==NULL ? NULL : x->left), (y==NULL ? NULL : y->left));\n        root->right = op(c, (x==NULL ? NULL : x->right), (y==NULL ? NULL : y->right));\n        return root;\n    }else{\n        return NULL;\n    }\n}\n\nint main(){\n    char c;\n    string a, b;\n    while(cin >> c >> a >> b){\n        int pos = 0;\n        Node* x = build(pos, a);\n        pos = 0;\n        Node* y = build(pos, b);\n        print(op(c, x, y));\n        cout << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct node{\n\tnode *ch[2];\n\t\n\tnode(){\n\t\tch[0] = ch[1] = 0;\n\t}\n\t~node(){\n\t\tdelete ch[0];\n\t\tdelete ch[1];\n\t}\n};\n\nvoid tostr(node *nd, string &s){\n\tif(nd){\n\t\ts += '(';\n\t\ttostr(nd->ch[0], s);\n\t\ts += ',';\n\t\ttostr(nd->ch[1], s);\n\t\ts += ')';\n\t}\n}\n\nconst char *p;\nnode *parse(){\n\tnode *ret = new node;\n\tif(*++p == '('){\n\t\tret->ch[0] = parse();\n\t}\n\tif(*++p == '('){\n\t\tret->ch[1] = parse();\n\t}\n\t++p;\n\treturn ret;\n}\n\nnode *child(node *nd, int k){\n\treturn nd ? nd->ch[k] : 0;\n}\n\nnode *opr(char type, node *a, node *b){\n\tnode *ret = 0;\n\tif(type == 'i'){\n\t\tif(a && b){\n\t\t\tret = new node;\n\t\t}\n\t}\n\telse{\n\t\tif(a || b){\n\t\t\tret = new node;\n\t\t}\n\t}\n\t\n\tif(ret){\n\t\tfor(int i = 0; i < 2; ++i){\n\t\t\tret->ch[i] = opr(type, child(a, i), child(b, i));\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tchar type;\n\tstring s, t;\n\twhile(cin >> type >> s >> t){\n\t\tnode *ns, *nt, *ret;\n\t\tp = s.c_str();\n\t\tns = parse();\n\t\tp = t.c_str();\n\t\tnt = parse();\n\n\t\tret = opr(type, ns, nt);\n\t\t\n\t\tstring u;\n\t\ttostr(ret, u);\n\t\tcout << u << endl;\n\t\t\n\t\tdelete ns;\n\t\tdelete nt;\n\t\tdelete ret;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\nint main(){\n  char a;\n  string x,y;\n  while(cin >> a >> x >> y){\n    vector<int> xint,yint;\n    int depth = 0;\n    for(int i = 0; i < x.size() ;i++){\n      if(x[i] == '('){\n        depth++;\n      }else if(x[i] ==')'){\n        depth--;\n      }else{\n        xint.push_back(depth);\n      }\n    }\n    depth = 0;\n    for(int i = 0; i < y.size(); i++){\n      if(y[i] == '('){\n        depth++;\n      }else if(y[i] ==')'){\n        depth--;\n      }else{\n        yint.push_back(depth);\n      }\n    }\n    vector<int> result;\n    if(a == 'i'){\n      int i,j;\n      i = 0;\n      j = 0;\n      while(i < xint.size() && j < yint.size()){\n        if(xint[i] < yint[j]){\n          j++;\n        }else if(yint[j] < xint[i]){\n          i++;\n        }else{\n          result.push_back(xint[i]);\n          i++;\n          j++;\n        }\n      }\n    }else{\n      int i,j;\n      i = 0;\n      j = 0;\n      while(i < xint.size() && j < yint.size()){\n        if(xint[i] < yint[j]){\n          result.push_back(yint[j]);\n          j++;\n        }else if(yint[j] < xint[i]){\n          result.push_back(xint[i]);\n          i++;\n        }else{\n          result.push_back(xint[i]);\n          i++;\n          j++;\n        }\n      }\n      while(i < xint.size()){\n        result.push_back(xint[i]);\n        i++;\n      }\n      while(j < yint.size()){\n        result.push_back(yint[j]);\n        j++;\n      }\n    }\n    depth = 0;\n    for(int i = 0; i < result.size();i++){\n      if(depth < result[i]){\n        while(depth != result[i]){\n          cout << '(';\n          depth++;\n        }\n        cout << ',';\n      }else{\n        while(depth != result[i]){\n          cout << ')';\n          depth--;\n        }\n        cout << ',';\n      }\n    }\n    while(depth > 0){\n      cout << ')';\n      depth--;\n    }\n    cout << endl;\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n/*\nconst int nil = -1;\nconst int MAX_N = 256;\n\nstruct Node {\n  int l, r, cnt;\n  Node() {\n    l = r = nil;\n    cnt = 0;\n  }\n};\n\nNode v[MAX_N];\nint nodeIndex;\n\nint parse(const char *s, int n, int root) {\n  v[root].cnt++;\n  if (s[++n] != ',') {\n    if (v[root].l == nil) v[root].l = ++nodeIndex;\n    n = parse(s, n, v[root].l);\n  }\n  if (s[++n] != ')') {\n    if (v[root].r == nil) v[root].r = ++nodeIndex;\n    n = parse(s, n, v[root].r);\n  }\n  return n+1;\n}\n\nvoid print(int root, int cnt) {\n  if (v[root].cnt < cnt) return;\n  putchar('(');\n  if (v[root].l != nil) print(v[root].l, cnt);\n  putchar(',');\n  if (v[root].r != nil) print(v[root].r, cnt);\n  putchar(')');\n}\n*/\nint main() {\n  char op[10], t1[256], t2[256];\n  while (scanf(\"%s %s %s\", op, t1, t2) == 3) {\n    printf(\"%s\\n\", t1);\n/*\n    for (int i=0;i<MAX_N;i++) v[i] = Node();\n    nodeIndex = 0;\n    parse(t1, 0, 0);\n    parse(t2, 0, 0);\n    print(0, (op=='u'?1:2)); putchar('\\n');\n*/\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\n\nstruct tree{\n    vector<tree> left;\n    vector<tree> right;\n};\n\n// <exp> := ( <exp> , <exp> ) | \"\"\ntree parse(int& index, const string& str){\n    tree ret;\n    if(str[index]=='(') index++;\n    if(str[index]!=',') {\n        //<exp>\n        ret.left.push_back(parse(index,str));\n    }\n    if(str[index]==',')index++;\n    if(str[index]!=')') {\n        //<exp>\n        ret.right.push_back(parse(index,str));\n    }\n    if(str[index]==')')index++;\n    return ret;\n}\n\nstring intersection_tree(tree a, tree b){\n    string res=\",\";\n\n    if(!a.left.empty() && !b.left.empty()){\n        res=\"(\"+intersection_tree(a.left[0],b.left[0]) +res;\n    }else{\n        res=\"(\"+res;\n    }\n\n    if(!a.right.empty() && !b.right.empty()){\n        res=res+intersection_tree(a.right[0],b.right[0]) +\")\";\n    }else{\n        res=res+\")\";\n    }\n    return res;\n}\n\nstring union_tree(tree a, tree b){\n    string res=\",\";\n    tree tmp1,tmp2;\n    if(!a.left.empty() || !b.left.empty()){\n        if(a.left.size()!=0){\n            tmp1=a.left[0];\n        }\n        if(b.left.size()!=0){\n            tmp2=b.left[0];\n        }\n        res=\"(\"+union_tree(tmp1,tmp2) +res;\n    }else{\n        res=\"(\"+res;\n    }\n\n    if(!a.right.empty() || !b.right.empty()){\n        if(a.right.size()!=0){\n            tmp1=a.right[0];\n        }\n        if(b.right.size()!=0){\n            tmp2=b.right[0];\n        }\n        res=res+union_tree(tmp1, tmp2) +\")\";\n    }else{\n        res=res+\")\";\n    }\n    return res;\n}\n\nint main(){\n    int index=0;\n    char mode;\n    string a,b;\n    while(cin>>mode>>a>>b){\n        tree tmp1,tmp2;\n        //cout<<a<<endl;\n        //cout<<b<<endl;\n        index=0;\n        tmp1=parse(index,a);\n        index=0;\n        tmp2=parse(index,b);\n        if(mode=='i')\n            cout<<intersection_tree(tmp1,tmp2)<<endl;\n        else\n            cout<<union_tree(tmp1,tmp2)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nstring tree[2];\nbitset<1000> node[2];\n\nvoid perse(int index, int n, int i)\n{\n  //cout << \"persed \" << n << endl;\n  if (index >= tree[i].size()) {\n    return;\n  }\n  if (tree[i][index] == '(') {\n    while (tree[i][index] == ' ') {index++;}\n    node[i][n] = true;\n    perse(index + 1, 2 * n + 1, i);\n  } else if (tree[i][index] == ')') {\n    while (tree[i][index] == ' ') {index++;}\n    perse(index + 1, (((n - 2) / 2 < 0) ? 0 : (n - 2) / 2), i);\n  } else if (\",\"){\n    while (tree[i][index] == ' ') {index++;}\n    perse(index + 1, n + 1, i);\n  }\n}\n\nstring _perse(int index)\n{\n  if (node[0][index]) {\n    return \"(\" + _perse(2 * index + 1) + \",\" + _perse(2 * index + 2) + \")\";\n  }\n  return \"\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    for (int i = 0; i < 2; i++) {\n      node[i].reset();\n      perse(0, 0, i);\n      \n      /*for (int j = 0; j < 300; j++) {\n\tif (node[i][j]) {\n\t  cout << j;\n\t}\n      }\n      cout << endl;*/\n    }\n    if (ex == 'u') {\n      node[0] |= node[1];\n    } else {\n      node[0] &= node[1];\n    }\n  \n    cout << _perse(0) << endl;\n    cin.ignore();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\nstruct node\n{\n\tnode *l,*r;\n\tnode():l(NULL),r(NULL){}\n};\nstring Tree[2];\nvoid string_to_tree(int n,node *cur,int l,int r)\n{\n\tint cnt=0,f;\n\tfor(int i=l+1;i<r;i++)\n\t{\n\t\tif(Tree[n][i]=='(')cnt++;\n\t\tif(Tree[n][i]==')')cnt--;\n\t\tif(Tree[n][i]==','&&cnt==0)\n\t\t{\n\t\t\tf=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(Tree[n][f-1]=='('&&Tree[n][f+1]==')')return;\n\tif(Tree[n][f+1]==')')\n\t{\n\t\tcur->l = new node();\n\t\tstring_to_tree(n,cur->l,l+1,f-1);\n\t}\n\telse if(Tree[n][f-1]=='(')\n\t{\n\t\tcur->r = new node();\n\t\tstring_to_tree(n,cur->r,f+1,r-1);\n\t}\n\telse\n\t{\n\t\tcur->l = new node();\n\t\tcur->r = new node();\n\t\tstring_to_tree(n,cur->l,l+1,f-1);\n\t\tstring_to_tree(n,cur->r,f+1,r-1);\n\t}\n\treturn;\n}\nnode *root[2];\nnode *ans; \nnode *tmp;\nstring Ans;\nvoid tree_to_string(node *cur)\n{\n\tif(cur==NULL)return;\n\tAns+='(';\n\ttree_to_string(cur->l);\n\tAns+=',';\n\ttree_to_string(cur->r);\n\tAns+=')';\n\treturn;\n}\nvoid unite(node *cur,node *c1,node *c2)\n{\n\tif((c1->l)!=NULL&&(c2->l)==NULL)\n\t{\n\t\tcur->l = new node();\n\t\tunite(cur->l,c1->l,tmp);\n\t}\n\telse if((c1->l)==NULL&&(c2->l)!=NULL)\n\t{\n\t\tcur->l = new node();\n\t\tunite(cur->l,tmp,c2->l);\n\t}\n\telse if((c1->l)!=NULL&&(c2->l)!=NULL)\n\t{\n\t\tcur->l = new node();\n\t\tunite(cur->l,c1->l,c2->l);\n\t}\n\tif((c1->r)!=NULL&&(c2->r)==NULL)\n\t{\n\t\tcur->r = new node();\n\t\tunite(cur->r,c1->r,tmp);\n\t}\n\telse if((c1->r)==NULL&&(c2->r)!=NULL)\n\t{\n\t\tcur->r = new node();\n\t\tunite(cur->r,tmp,c2->r);\n\t}\n\telse if((c1->r)!=NULL&&(c2->r)!=NULL)\n\t{\n\t\tcur->r = new node();\n\t\tunite(cur->r,c1->r,c2->r);\n\t}\n\treturn;\n}\nvoid intersect(node *cur,node *c1,node *c2)\n{\n\tif((c1->l)!=NULL&&(c2->l)!=NULL)\n\t{\n\t\tcur->l = new node();\n\t\tintersect(cur->l,c1->l,c2->l);\n\t}\n\tif((c1->r)!=NULL&&(c2->r)!=NULL)\n\t{\n\t\tcur->r = new node();\n\t\tintersect(cur->r,c1->r,c2->r);\n\t}\n\treturn;\n}\nint main()\n{\n\tstring op;\n\ttmp = new node();\n\twhile(cin >> op >> Tree[0] >> Tree[1])\n\t{\n\t\tAns.clear();\n\t\troot[0] = new node();\n\t\troot[1] = new node();\n\t\tans = new node();\n\t\tstring_to_tree(0,root[0],0,((int)Tree[0].size())-1);\n\t\tstring_to_tree(1,root[1],0,((int)Tree[1].size())-1);\n\t\tif(op==\"u\")unite(ans,root[0],root[1]);\n\t\telse intersect(ans,root[0],root[1]);\n\t\ttree_to_string(ans);\n\t\tcout << Ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n\nstruct Xcsr {\n    int depth;\n    string::iterator c;\n};\n\nint main() {\n    char op;\n    string ex1, ex2;\n    int i;\n\n    while (cin) {\n        cin >> op >> ex1 >> ex2;\n        cin.ignore();\n\n        // cout << op << ex1 << ex2;\n        Xcsr x[2], *xa, *xb;\n        x[0].depth = x[1].depth = 0;\n        x[0].c = ex1.begin();\n        x[1].c = ex2.begin();\n        string result;\n        while (x[0].c != ex1.end() || x[1].c != ex2.end()) {\n\n            for (i = 0; i < 2; i++) {\n                if (*(x[i].c) == '(') {\n                    x[i].depth++;\n                }\n                else if (*(x[i].c) == ')') {\n                    x[i].depth--;\n                }\n            }\n            if (*(x[0].c) == *(x[1].c) && x[0].depth == x[1].depth) {\n                result += *(x[0].c);\n            }\n            else {\n                if (x[0].depth > x[1].depth) {\n                    xa = &x[0];\n                    xb = &x[1];\n                }\n                else {\n                    xa = &x[1];\n                    xb = &x[0];\n                }\n                while (*(xa->c) != *(xb->c) || xa->depth != xb->depth) {\n                    if (op == 'u') result += *(xa->c);\n                    xa->c++;\n                    if (*(xa->c) == '(') {\n                        xa->depth++;\n                    }\n                    else if (*(xa->c) == ')') {\n                        xa->depth--;\n                    }\n                }\n                result += *(x[0].c);\n            }\n            x[0].c++;\n            x[1].c++;\n        }\n        cout << result << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node{\n    Node *left;\n    Node *right;\n    Node() { left = NULL, right = NULL; }\n};\n\nint findcc(string s) {\n    int dd = 0;\n    for(int i=0; i<s.length(); ++i) {\n        if(s[i] == '(') dd++;\n        else if(s[i] == ')') dd--;\n        else if(s[i] == ',' && dd == 1) return i;\n    }\n    return -1;\n}\n\nNode* parse(string s) {\n    Node *r = new Node();\n    int ff = findcc(s);\n    if(ff != 1) r->left = parse(s.substr(1,ff-1));\n    if(ff != s.length()-2) {\n        string tmp = s.substr(ff+1);\n        r->right = parse(tmp.substr(0,tmp.length()-1));\n    }\n    return r;\n}\n\nNode *intersect(Node *r1,Node *r2) {\n    Node *ret = new Node();\n    if(r1->left != NULL && r2->left != NULL)\n        ret->left = intersect(r1->left,r2->left);\n\n    if(r1->right != NULL && r2->right != NULL)\n        ret->right = intersect(r1->right,r2->right);\n\n    return ret;\n}\n\nNode* uni(Node *r1,Node *r2) {\n    if(r1 == NULL && r2 == NULL) return NULL;\n\n    Node *ret = new Node();\n    ret->left = uni(((r1 == NULL)?NULL:r1->left),(r2 == NULL)?NULL:r2->left);\n    ret->right = uni(((r1 == NULL)?NULL:r1->right),(r2 == NULL)?NULL:r2->right);\n    return ret;\n}\n\nstring toStr(Node *tree) {\n    string res = \"(\";\n    if(tree->left != NULL) res += toStr(tree->left);\n    res += \",\";\n    if(tree->right != NULL) res += toStr(tree->right);\n    res += \")\";\n    return res;\n}\n\nvoid treedel(Node *node) {\n    if(node->left != NULL) treedel(node->left);\n    if(node->right != NULL) treedel(node->right);\n    delete node;\n    return;\n}\n\nint main() {\n    string op,t1,t2;\n    while(cin>>op>>t1>>t2) {\n        Node *r1 = parse(t1);\n        Node *r2 = parse(t2);\n        Node *ans;\n        if(op == \"i\") ans = intersect(r1,r2);\n        else if(op == \"u\") ans = uni(r1,r2);\n\n        cout<<toStr(ans)<<endl;\n        treedel(r1); treedel(r2); treedel(ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nstring tree[2];\nbitset<10000> node[2];\n\nvoid perse(int index, int n, int i)\n{\n  //cout << \"persed \" << n << endl;\n  if (index >= tree[i].size()) {\n    return;\n  }\n  if (tree[i][index] == '(') {\n    while (tree[i][index] == ' ') {index++;}\n    node[i][n] = true;\n    perse(index + 1, 2 * n + 1, i);\n  } else if (tree[i][index] == ')') {\n    while (tree[i][index] == ' ') {index++;}\n    perse(index + 1, (((n - 2) / 2 < 0) ? 0 : (n - 2) / 2), i);\n  } else if (\",\"){\n    while (tree[i][index] == ' ') {index++;}\n    perse(index + 1, n + 1, i);\n  }\n}\n\nstring _perse(int index)\n{\n  if (node[0][index]) {\n    return \"(\" + _perse(2 * index + 1) + \",\" + _perse(2 * index + 2) + \")\";\n  }\n  return \"\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    for (int i = 0; i < 2; i++) {\n      node[i].reset();\n      perse(0, 0, i);\n      \n      /*for (int j = 0; j < 300; j++) {\n\tif (node[i][j]) {\n\t  cout << j;\n\t}\n      }\n      cout << endl;*/\n    }\n    if (ex == 'u') {\n      node[0] |= node[1];\n    } else {\n      node[0] &= node[1];\n    }\n    cout << _perse(0) << endl;\n    cin.ignore();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n\nint main(){\n    std::cout << \"Hello World!\" << std::endl;\n    return 0;\n}\n        \n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n\nint main(){\n    std::cout << \"Hello World!\" << std::endl;\n    return 0;\n}\n        \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nchar c;\nstring T1, T2;\nint p1, p2;\n\nvoid recS( string &T, int &p ){\n    for ( int i = 0; i < 2; i++ ){\n\tif ( T[p] == '(' ) {\n\t    if ( c == 'u' ) cout << '(';\n\t    p++; recS(T, p); p++;\n\t    if ( c == 'u' ) cout << ')';\n\t} else p++;\n\tif ( i == 0 && c == 'u' ) cout << ',';\n    }\n}\n\nvoid rec(){\n    for ( int i = 0; i < 2; i++ ){\n\tif ( T1[p1] == '(' && T2[p2] == '(' ){\n\t    cout << '('; p1++; p2++;\n\t    rec();\n\t    p1++; p2++; cout << ')';\n\t} else {\n\t    if ( c == 'u' ) cout << \"(\";\n\t    if ( T1[p1] == '(' ){\n\t\tp1++; recS( T1, p1); p1++, p2++;\n\t    } else if ( T2[p2] == '(' ){\n\t\tp2++; recS( T2, p2); p2++;\n\t\tp1++;\n\t    } else {\n\t\tp1++; p2++;\n\t    }\n\t    if ( c == 'u' ) cout << \")\";\n\t}\n\tif ( i == 0 ) cout << ',';\n    }\n}\n\nint main(){\n    while( cin >> c ){\n\tcin >> T1 >> T2;\n\tp1 = p2 = 1;\n\tcout << '(' ; rec(); cout << ')' << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <cstring>\nusing namespace std;\n\nstruct Node {\n\tNode * l;\n\tNode * r;\n\tNode () {l = r = NULL;}\n};\n\nNode * build(char s[], int l, int r) {\n\tif (r < l) return NULL;\n\tNode * p = new Node();\n\tint cnt = 0;\n\tfor (int i = l + 1; i < r; ++i) {\n\t\tif (s[i] == '(') {cnt ++; continue;}\n\t\tif (s[i] == ')') {cnt --; continue;}\n\t\tif (s[i] == ',' && cnt == 0) {\n\t\t\tp->l = build(s, l + 1, i - 1);\n\t\t\tp->r = build(s, i + 1, r - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn p;\n}\n\nNode * getInter(Node * a, Node * b) {\n\tNode * p = new Node();\n\tif (a->l != NULL && b->l != NULL) {\n\t\tp->l = getInter(a->l, b->l);\n\t}\n\t//else p->l = NULL;\n\tif (a->r != NULL && b->r != NULL) {\n\t\tp->r = getInter(a->r, b->r);\n\t}\n\t//else p->r = NULL;\n\treturn p;\n}\n\nNode * getUnion(Node * a, Node * b) {\n\tNode * p = new Node();\n\tif (a != NULL && b != NULL) {\n\t\tif (a->l != NULL || b->l != NULL) {\n\t\t\tp->l = getUnion(a->l, b->l);\n\t\t}\n\t\telse p->l = NULL;\n\t\tif (a->r != NULL || b->r != NULL) {\n\t\t\tp->r = getUnion(a->r, b->r);\n\t\t}\n\t\telse p->r = NULL;\n\t} else if (a == NULL) {\n\t\tif (b->l != NULL) p->l = getUnion(NULL, b->l);\n\t\telse p->l = NULL;\n\t\tif (b->r != NULL) p->r = getUnion(NULL, b->r);\n\t\telse p->r = NULL;\n\t} else {\n\t\tif (a->l != NULL) p->l = getUnion(a->l, NULL);\n\t\telse p->l = NULL;\n\t\tif (a->r != NULL) p->r = getUnion(a->r, NULL);\n\t\telse p->r = NULL;\n\t}\n\treturn p;\n}\nvoid DFS2(Node *root,Node* root1)\n{\n    if(root1->l!=NULL)\n    {\n        if(root->l==NULL){\n        Node *node = new Node;\n        root ->l = node;}\n        DFS2(root->l,root1->l);\n    }\n    if(root1->r!=NULL)\n    {\n        if(root->r==NULL){\n        Node *node = new Node;\n        root->r = node;}\n        DFS2(root->r,root1->r);\n    }\n}\nstring getStr(Node * p) {\n\tif (p == NULL) {\n\t\treturn \"\";\n\t}\n\telse return \"(\" + getStr(p->l) + \",\" + getStr(p->r) + \")\";\n}\n\nchar a[3000], b[3000];\n\nint main() {\n\tchar op;\n\twhile (scanf(\"%c %s %s\", &op, a, b) != EOF) {\n\t\tgetchar();\n\t\tint la = strlen(a), lb = strlen(b);\n\t\tNode * ra = build(a, 0, la - 1);\n\t\tNode * rb = build(b, 0, lb - 1);\n\t\tNode * root = new Node;\n\t\tif (op == 'i') root = getInter(ra, rb);\n\t\telse {\n\t\tDFS2(root,ra);DFS2(root,rb);\n\t\t}\n\t\tstring res = getStr(root);\n\t\tprintf(\"%s\\n\", res.c_str());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nstring tree[2];\nbool node[2][100][100];\n\nstring uni(int index0, int index1)\n{\n  string left, right;\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[1][index1] != ','; index1++) {\n      left = left + tree[1][index1];\n    }\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[0][index0] != ','; index0++) {\n      left = left + tree[0][index0];\n    }\n  } else {\n    left = uni(index0 + 1, index1 + 1);\n    for (;tree[0][index0] != ','; index0++);\n    for (;tree[0][index1] != ','; index1++);\n  }\n\n  if (tree[0][index0 + 1] == ')') {\n    index0++, index1++;\n    for (;tree[1][index1] != ')'; index1++) {\n      right = right + tree[1][index1];\n    }\n  } else if (tree[1][index1 + 1] == ')') {\n    index0++, index1++;\n    for (;tree[0][index0] != ')'; index0++) {\n      right = right + tree[0][index0];\n    }\n  } else {\n    right = uni(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nstring inter(int index0, int index1)\n{\n  string left, right;\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[1][index1] != ','; index1++);\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[0][index0] != ','; index0++);\n  } else {\n    left = inter(index0 + 1, index1 + 1);\n    for (;tree[0][index0] != ','; index0++);\n    for (;tree[0][index1] != ','; index1++);\n  }\n\n  if (tree[0][index0 + 1] == ')') {\n    index0++, index1++;\n    for (;tree[1][index1] != ')'; index1++);\n  } else if (tree[1][index1 + 1] == ')') {\n    index0++, index1++;\n    for (;tree[0][index0] != ')'; index0++);\n  } else {\n    right = inter(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    if (ex == 'i') {\n      cout << inter(0, 0) << endl;\n    } else {\n      cout << uni(0, 0) << ')' << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\nint lt[10000], rt[10000];\n\nstring parse(string str, int level, int no, int* ary)\n{\n    if(str.size() == 0 || str.size() < 3 || str[0] != '(')  {\n        return \"\";\n    }\n\n    ary[no - 1] = 1;\n\n    // str = (<tree>,<tree>)\n    if(str[1] != ',') {\n        str = parse(str.substr(1), level + 1, no + (1 << level) + (no - (1 << level)), ary);\n    }\n\n    // str = ,<tree>)\n    str = str.substr(1);\n    if(str[1] != ')') {\n        str = parse(str.substr(1), level + 1, no + (1 << level) + (no - (1 << level)) + 1, ary);\n    }\n\n    // str = )\n    return str.substr(1);\n}\n\nstring unparse(int *ary, int level, int no)\n{\n    if(no > 100 || ary[no - 1] == 0) {\n        return \"\";\n    }\n\n    return \"(\" + \n        unparse(ary, level + 1, no + (1 << level) + (no - (1 << level))) +\n        \",\" + \n        unparse(ary, level + 1, no + (1 << level) + (no - (1 << level)) + 1)\n        + \")\";\n}\n\nint main()\n{\n    string op, a, b;\n    while(cin >> op >> a >> b) {\n        int ret[10000];\n        for(int i = 0; i < 10000; i++) {\n            lt[i] = rt[i] = ret[i] = 0;\n        }\n\n        parse(a, 0, 1, lt);\n        parse(b, 0, 1, rt);\n\n\n        for(int i = 0; i < 10000; i++) {\n            if(op == \"i\") {\n                ret[i] = (lt[i] & rt[i]);\n            } else {\n                ret[i] = (lt[i] | rt[i]);\n            }\n        }\n        \n        cout << unparse(ret, 0, 1) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nstring tree[2];\nbool node[2][100][100];\n\nstring uni(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    if (tree[1][index1] != ',') \n      for (;tree[1][index1] != ','; index1++) {\n\tleft = left + tree[1][index1];\n      }\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[0][index0] != ','; index0++) {\n      left = left + tree[0][index0];\n    }\n  } else {\n    left = uni(index0 + 1, index1 + 1);\n    for (;tree[0][index0] != ','; index0++);\n    for (;tree[1][index1] != ','; index1++);\n  }\n\n  if (tree[0][index0 + 1] == ')') {\n    index1++;\n    if (tree[1][index1] != ')') {\n      int c = 0;\n      for (;; index1++) {\n\tif (c <= 1 && tree[1][index1] == ')') {\n\t  right = right + tree[1][index1];\n\t  break;\n\t}\n\tif (tree[1][index1] == '(') {c++;}\n\tif (tree[1][index1] == ')') {c--;}\n\tright = right + tree[1][index1];\n      }\n    } else {\n      right = \"\";\n    }\n  } else if (tree[1][index1 + 1] == ')') {\n    index0++, index1++;\n    int c = 0;\n    for (;; index0++) {\n      if (c <= 1 && tree[0][index0] == ')') {\n\tright = right + tree[0][index0];\n\tbreak;\n      }\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      right = right + tree[0][index0];\n    }\n  } else {\n    right = uni(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nstring inter(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[1][index1] != ','; index1++);\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[0][index0] != ','; index0++);\n  } else {\n    left = inter(index0 + 1, index1 + 1);\n    for (;tree[0][index0] != ','; index0++);\n    for (;tree[1][index1] != ','; index1++);\n  }\n\n  if (tree[0][index0 + 1] == ')') {\n    index0++, index1++;\n    int c = 0;\n    for (;; index1++) {\n      if (c <= 1 && tree[1][index1] == ')') {\n\tbreak;\n      }\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n    }\n  } else if (tree[1][index1 + 1] == ')') {\n    index0++, index1++;\n    int c = 0;\n    for (;; index0++) {\n      if (c <= 1 && tree[0][index0] == ')') {\n\tbreak;\n      }\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n    }\n  } else {\n    right = inter(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    if (ex == 'i') {\n      cout << inter(0, 0) << endl;\n    } else {\n      cout << uni(0, 0) << endl;\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n\nint main(){\n    std::cout << \"Hello World!\" << std::endl;\n    return 0;\n}\n        \n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n\nint main(){\n    std::cout << \"Hello World!\" << std::endl;\n    return 0;\n}\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n \nvoid divStr(const string& s, string& s1, string& s2) {\n  int n = s.size();\n  int retain = 0;\n  for(int pos=1; ; pos++) {\n    if(s[pos] == '(') retain++;\n    if(s[pos] == ')') retain--;\n    else if(retain == 0) {\n      s1 = s.substr(1, pos-1);\n      s2 = s.substr(pos+1, n-pos-2);\n      return;\n    }\n  }\n}\n \nstring make(string op, string s, string t) {\n  if(s == \"\" || t == \"\") {\n    if(op == \"i\") return \"\";\n    else return s == \"\" ? t : s;\n  }\n \n  string sL, sR, tL, tR;\n  divStr(s, sL, sR);\n  divStr(t, tL, tR);\n \n  return '(' + make(op, sL, tL) + ',' + make(op, sR, tR) + ')';\n}\n \nint main() {\n  string op, sL, sR;\n \n  while(cin >> op >> sL >> sR)\n    cout << make(op, sL, sR) << endl;\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nstruct  b_tree {\n\tunique_ptr<b_tree>ltree;\n\tunique_ptr<b_tree>rtree;\n\tb_tree() {\n\n\t}\n\n};\nunique_ptr<b_tree> make_tree(string st, int&a) {\n\tunique_ptr<b_tree> tree=make_unique<b_tree>();\n\tassert(st[a] == '(');\n\ta++;\n\tif (st[a] == '(') {\n\t\ttree->ltree = make_tree(st, a);\n\t}\n\telse {\n\t\ttree->ltree = nullptr;\n\t}\n\tassert(st[a] == ',');\n\ta++;\n\tif (st[a] == '(') {\n\t\ttree->rtree = make_tree(st, a);\n\t}\n\telse {\n\t\ttree->rtree = nullptr;\n\t}\n\tassert(st[a] == ')');\n\ta++;\n\treturn (tree);\n}\nunique_ptr<b_tree>connect(const unique_ptr<b_tree>&l, const unique_ptr<b_tree>&r, bool isuni) {\n\tunique_ptr<b_tree> tree = make_unique<b_tree>();\n\tif (isuni) {\n\t\tif (l&&l->ltree&&r&&r->ltree) {\n\t\t\ttree->ltree = connect(l->ltree, r->ltree, isuni);\n\t\t}\n\t}\n\telse {\n\t\tif (l&&l->ltree) {\n\t\t\tif (r)tree->ltree = connect(l->ltree, r->ltree, isuni);\n\t\t\telse tree->ltree = connect(l->ltree, nullptr, isuni);\n\t\t}\n\t\telse if (r&&r->ltree) {\n\n\t\t\tif (l)tree->ltree = connect(l->ltree, r->ltree, isuni);\n\t\t\telse tree->ltree = connect(nullptr,r->ltree, isuni);\n\t\t}\n\t}\n\n\tif (isuni) {\n\t\tif (l&&l->rtree&&r&&r->rtree) {\n\t\t\ttree->rtree = connect(l->rtree, r->rtree, isuni);\n\t\t}\n\t}\n\telse {\n\t\tif (l&&l->rtree) {\n\t\t\tif (r)tree->rtree = connect(l->rtree, r->rtree, isuni);\n\t\t\telse tree->rtree = connect(l->rtree, nullptr, isuni);\n\t\t}\n\t\telse if (r&&r->rtree) {\n\t\t\tif (l)tree->rtree = connect(l->rtree, r->rtree, isuni);\n\t\t\telse tree->rtree = connect( nullptr, r->rtree,isuni);\n\t\t}\n\t}\n\treturn (tree);\n}\nvoid getst(string&ans,unique_ptr<b_tree>&tree) {\n\tans.push_back('(');\n\tif (tree->ltree) {\n\t\tgetst(ans, tree->ltree);\n\t}\n\tans.push_back(',');\n\tif (tree->rtree) {\n\t\tgetst(ans, tree->rtree);\n\t}\n\tans.push_back(')');\n\treturn;\n}\n\nint main() {\n\tstring line;\n\twhile (getline(cin, line)) {\n\t\tint fstc = line.find(' ');\n\t\tint scdc = line.find(' ', fstc + 1);\n\t\tstring ch = line.substr(0, fstc);\n\t\tstring lst = line.substr(fstc + 1, scdc-fstc-1);\n\t\tstring rst = line.substr(scdc+1);\n\t\tbool uni = ch == \"i\";\n\t\tint a = 0;\n\t\tunique_ptr<b_tree>l = make_tree(lst, a);\n\t\ta = 0;\n\t\tunique_ptr<b_tree>r(make_tree(rst, a));\n\t\t\n\t\tunique_ptr<b_tree>ans(connect(l,r,uni));\n\t\tstring st;\n\t\tgetst(st, ans);\n\t\tcout << st << endl;\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nclass BinaryTree\n{\npublic:\n\tBinaryTree *parent;\n\tBinaryTree *left;\n\tBinaryTree *right;\n\tint no;\n\n\tBinaryTree()\n\t{\n\t\tparent\t= NULL;\n\t\tleft\t= NULL;\n\t\tright\t= NULL;\n\t\tno\t\t= 1;\n\t}\n\n\tBinaryTree( BinaryTree *p )\n\t{\n\t\tparent\t= p;\n\t\tleft\t= NULL;\n\t\tright\t= NULL;\n\t\tno\t\t= p->no + 1;\n\t}\n};\n\nvector <BinaryTree> Nodes( 5000 );\nint Nodes_cnt = 0;\n\nBinaryTree getTree( string in )\n{\n\tstack <int> lrs;\n\tint lr = 0;\n\n\tBinaryTree\troot;\n\tBinaryTree*\tnow;\n\n\tbool first = true;\n\tnow = &root;\n\n\tfor ( string::iterator it = in.begin(); it != in.end(); it++ )\n\t{\n\t\tif ( first )\n\t\t{\n\t\t\tfirst = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( *it == '(' )\n\t\t{\n\t\t\tif ( lr == 0 )\n\t\t\t{\n\t\t\t\tnow->left  = new BinaryTree( now );\n\t\t\t\tnow = now->left;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnow->right = new BinaryTree( now );\n\t\t\t\tnow = now->right;\n\t\t\t}\n\n\t\t\tlrs.push( lr );\n\t\t\tlr = 0;\n\t\t}\n\t\telse if ( *it == ')' )\n\t\t{\n\t\t\tif ( now->parent != NULL )\n\t\t\t{\n\t\t\t\tnow = now->parent;\n\t\t\t\tlr = lrs.top();\n\t\t\t\tlrs.pop();\n\t\t\t}\n\n\t\t}\n\t\telse if ( *it == ',' )\n\t\t{\n\t\t\tlr++;\n\t\t}\n\t}\n\n\treturn root;\n}\n\nvoid printTree( BinaryTree* tree )\n{\n\tcout << \"(\";\n\tif ( tree->left != NULL )\n\t\tprintTree( tree->left );\n\tcout << \",\";\n\tif ( tree->right != NULL )\n\t\tprintTree( tree->right );\n\tcout << \")\";\n}\n\nBinaryTree* getIntersection( BinaryTree* a, BinaryTree* b, BinaryTree* p )\n{\n\t// ツ仰、ツ津環づ按閉板閉ェツづーツ個ゥツづつつッツづゥ\n\tint nc = Nodes_cnt;\n\tNodes_cnt++;\n\tBinaryTree& node = Nodes[nc];\n\tif ( p == NULL )\n\t\tnode = BinaryTree();\n\telse\n\t\tnode = BinaryTree( p );\n\n\tif ( ( a != NULL && a->left != NULL ) && ( b != NULL && b->left != NULL ) )\n\t{\n\t\tNodes[Nodes_cnt] = getIntersection( a==NULL?NULL:a->left, b==NULL?NULL:b->left, &node );\n\t\tnode.left = &Nodes[Nodes_cnt];\n\t\tNodes_cnt++;\n\t}\n\tif ( ( a != NULL && a->right != NULL ) && ( b != NULL && b->right != NULL ) )\n\t{\n\t\tNodes[Nodes_cnt] = getIntersection( a==NULL?NULL:a->right, b==NULL?NULL:b->right, &node );\n\t\tnode.right = &Nodes[Nodes_cnt];\n\t\tNodes_cnt++;\n\t}\n\n\treturn &Nodes[nc];\n}\n\nBinaryTree* getUnion( BinaryTree* a, BinaryTree* b, BinaryTree* p )\n{\n\t// ツづづつソツつゥツづ可甘慊づ慊づェツづつ「ツづゥツづ按づァOK\n\tint nc = Nodes_cnt;\n\tNodes_cnt++;\n\tBinaryTree& node = Nodes[nc];\n\tif ( p == NULL )\n\t\tnode = BinaryTree();\n\telse\n\t\tnode = BinaryTree( p );\n\n\tif ( ( a != NULL && a->left != NULL ) || ( b != NULL && b->left != NULL ) )\n\t{\n\t\tBinaryTree* next = getUnion( (a==NULL?NULL:a->left), (b==NULL?NULL:b->left), &node );\n\t\tnode.left = next;\n\t}\n\tif ( ( a != NULL && a->right != NULL ) || ( b != NULL && b->right != NULL ) )\n\t{\n\t\tBinaryTree* next = getUnion( (a==NULL?NULL:a->right), (b==NULL?NULL:b->right), &node );\n\t\tnode.right = next;\n\t}\n\n\treturn &Nodes[nc];\n}\n\nint main( void )\n{\n\tstring type;\n\tstring in_a;\n\tstring in_b;\n\n\twhile ( cin >> type >> in_a >> in_b )\n\t{\n\t\tBinaryTree a_root = getTree( in_a );\n\t\tBinaryTree b_root = getTree( in_b );\n\n\t\tif ( type == \"i\" )\n\t\t{\n\t\t\tBinaryTree* intersectionTree = getIntersection( &a_root, &b_root, NULL );\n\t\t\tprintTree( intersectionTree );\n\t\t\tcout << endl;\n\t\t}\n\t\telse if ( type == \"u\" )\n\t\t{\n\t\t\tBinaryTree* unionTree = getUnion( &a_root, &b_root, NULL );\n\t\t\tprintTree( unionTree );\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=100;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  heap[id]++;\n  if(s==\"(,)\")  return;\n  \n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;   \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n      parse(sub1, 2*id+1);\n      parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nint out(int th, int id,int n){\n\n  string c(\"(,)\");\n  for(int i=0;i<3;i++)\n    output.insert(output.begin()+n+i,c[i]);\n\n  int ch1=0,ch2=0;//n of string of each child\n  \n  if(heap[id]>th){\n    if(heap[2*id+1]>th){\n      ch1=out(th,2*id+1,n+1);\n    }\n    if(heap[2*id+2]>th){\n      ch2=out(th,2*id+2,n+ch1+2);\n    }\n  }\n  return ch1+ch2+3;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  output.clear();\n  //cout<<output<<endl;\n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0,0);\n  \n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  \n  while(cin>>cmd>>s1>>s2){\n    solve(cmd,s1,s2);\ncout<<\"hoge\";\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nstruct Tree {\n    Tree *l, *r;\n};\n \nTree *tree[2];\n \nTree* make_node()\n{\n    Tree *t = new Tree;\n    t->l = t->r = NULL;\n    return t;\n}\n \nvoid init()\n{    \n    tree[0] = make_node();\n    tree[1] = make_node();\n}\n  \nbool search_left_node(int &cur, string &s)\n{\n    int p = 0;\n    for (int i = cur; i >= 1; i--) {\n        if (s[i] == ')') {\n            p++;\n        } else if (s[i] == '(') {\n            p--;\n        }\n        if (s[i] == ',' && p == 1) {\n            cur = i;\n            return 1;\n        }\n        if (p < 0) return 0;\n    }\n    return 0;\n}\n \nbool search_right_node(int &cur, string &s)\n{\n    int p = 0;\n    for (int i = cur; i < (int)s.size()-1; i++) {\n        if (s[i] == '(') {\n            p++;\n        } else if (s[i] == ')') {\n            p--;\n        }\n        if (s[i] == ',' && p == 1) {\n            cur = i;\n            return 1;\n        }\n        if (p < 0) return 0;\n    }\n    return 0;\n}\n \nvoid add_left(Tree *t)\n{\n    t->l = make_node();\n}\n \nvoid add_right(Tree *t)\n{\n    t->r = make_node();\n}\n \nvoid dfs(int cur, string &s, Tree *t)\n{\n    int L = cur - 1, R = cur + 1;\n    if (search_left_node(L, s)) {        \n        add_left(t);\n        dfs(L, s, t->l);\n    }\n    if (search_right_node(R, s)) {\n        add_right(t);\n        dfs(R, s, t->r);\n    }\n}\n  \nstring make_i_tree(Tree *t1, Tree *t2)\n{\n    string l, r;\n    if (t1->l != NULL && t2->l != NULL) {\n        l = make_i_tree(t1->l, t2->l);\n    } \n        \n    if (t1->r != NULL && t2->r != NULL) {\n        r = make_i_tree(t1->r, t2->r);\n    }\n    return \"(\" + l + \",\" + r + \")\";\n}\n\nstring make_u_tree(Tree *t1, Tree *t2)\n{\n    string l, r;\n    if (t1->l != NULL || t2->l != NULL) {\n        if (t1->l == NULL) add_left(t1);\n        if (t2->l == NULL) add_left(t2);\n        l = make_u_tree(t1->l, t2->l);\n    } \n        \n    if (t1->r != NULL || t2->r != NULL) {\n        if (t1->r == NULL) add_right(t1);\n        if (t2->r == NULL) add_right(t2);\n        r = make_u_tree(t1->r, t2->r);\n    }\n    return \"(\" + l + \",\" + r + \")\";\n}\n\nint get_root(string &s)\n{\n    int depth = 0;\n    for (int i = 1; i < (int)s.size(); i++) {\n        if (s[i] == '(') depth++;\n        else if (s[i] == ')') depth--;\n        if (depth == 0 && s[i] == ',') {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid solve(char order, string &a, string &b)\n{\n    int cur_a = get_root(a), cur_b = get_root(b);   \n    init();\n    \n    dfs(cur_a, a, tree[0]);\n    dfs(cur_b, b, tree[1]);\n    \n    if (order == 'i') {\n        cout << make_i_tree(tree[0], tree[1]) << endl;\n    } else {\n        cout << make_u_tree(tree[0], tree[1]) << endl;\n    }\n}\n \nint main()\n{\n    char order;\n    string a, b;\n    while (cin >> order >> a >> b) {\n        solve(order, a, b);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n#define SET(a,c) memset(a,c,sizeof(a))\n\n#define DEBUG(x) cout<<\"#x\"<<\": \"<<x<<endl\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nconst ll INF = INT_MAX/3;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-14;\nconst int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n\ntypedef struct Btree {\n    struct Btree *left;\n    struct Btree *right;\n} Btree;\n\nBtree temp;\n\nBtree *createTree(string s){\n    // cout << \"input: \" << s << endl;\n    int center = -1;\n    stack< int > st;\n\n    if( s.size() <= 1 ) {\n        return NULL;\n    }\n\n    REP(i,s.length()){\n        if( s[i] == '(' ){\n            st.push(i);\n        }else if ( s[i] == ')'){\n            st.pop();\n        }else if ( s[i] == ',' ){\n            if(st.size() == 1) center = i;\n        }\n    }\n\n    if( center == -1) return NULL;\n    Btree *ret = new Btree;\n    ret->left = createTree(s.substr(1,center-1));\n    ret->right = createTree(s.substr(center+1,s.length()));\n    return ret;\n}\n\nvoid dfs(int n,Btree *tree){\n    if( tree == NULL) return;\n    REP(i,n) cout << \" \";\n    cout << n << endl;\n    dfs(n+1,tree->left);\n    dfs(n+1,tree->right);\n}\n\nstring patternI(Btree *a,Btree *b ){\n    string left,right;\n    left = \"\";\n    right = \"\";\n\n    if(a == NULL || b == NULL){\n        return \"\";\n    }else {\n        left = patternI(a->left,b->left);\n        right = patternI(a->right,b->right);\n    }\n\n    return \"(\" + left + \",\" + right +  \")\";\n}\n\nstring patternU(Btree *a,Btree *b ){\n    string left,right;\n    left = \"\";\n    right = \"\";\n\n    if(a == NULL && b == NULL){\n        return \"\";\n    } else if(a == NULL && b != NULL) {\n        left = patternU(NULL,b->left);\n        right = patternU(NULL,b->right);\n    }else if(a != NULL && b == NULL) {\n        left = patternU(a->left,NULL);\n        right = patternU(a->right,NULL);\n    }else {\n        left = patternU(a->left,b->left);\n        right = patternU(a->right,b->right);\n    }\n\n    return \"(\" + left + \",\" + right +  \")\";\n}\n\nint main(){\n\n    while(true){\n        char type;\n        string t1,t2;\n        cin >> type;\n        if(cin.eof()) return 0;\n        cin >> t1 >> t2;\n        Btree *a = createTree(t1);\n        Btree *b = createTree(t2);\n        if( type == 'i'){\n            cout << patternI(a,b) << endl;\n        }else if(type == 'u'){\n            cout << patternU(a,b) << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 1000\nusing namespace std;\nchar opr;\nstring T[2];\nbool tree[MAX][2]; //0->A, 1->B\nbool LR[MAX];\nbool A_tree[MAX];      \n\nvoid constructTree(bool which)\n{\n  int index = 1;\n  tree[index][which] = true;\n  rep(i,MAX)LR[i] = false;//false->L, true->true\n  int w = T[which].size();\n  REP(i,1,w)\n    {\n      if(T[which][i] == '(')\n\t{\n\t  index = index*2+(!LR[index]?0:1);\n\t  tree[index][which] = true;\n\t}\n      else if(T[which][i] == ',')\n\tLR[index] = true;\n      else\n\tindex /= 2;\n    }\n\n  assert(index == 0);\n}\n\nvoid constructTreePRST(string &PRST_tree,int index)\n{\n  PRST_tree += \"(\";\n  if(A_tree[index*2])constructTreePRST(PRST_tree,index*2);\n  PRST_tree += \",\";\n  if(A_tree[index*2+1])constructTreePRST(PRST_tree,index*2+1);\n  PRST_tree += \")\";\n}\n\nint main()\n{\n  while(cin >> opr >> T[0] >> T[1])\n    {\n      constructTree(false);\n      constructTree(true);\n\n     \n      if(opr == 'i')\n\t{\n\t  rep(i,MAX)\n\t    A_tree[i] = tree[i][0]&tree[i][1];\n\t}\n      else\n\t{\n\t  rep(i,MAX)\n\t    A_tree[i] = tree[i][0]|tree[i][1];\n\t}\n      string prst;\n      constructTreePRST(prst,1);\n      cout << prst << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<list>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\n\nint treeA[110];\nint treeB[110];\nint treeC[110];\n\nvoid getTree(string line,int tree, int lvl){\n\tif(line==\"\" || line==\"(\" || line==\")\")return;\n\tstack<int> cnt;\n\tint b=0;\n\twhile(line[b]!=0){\n\t\tif(line[b]=='('){\n\t\t\tcnt.push(1);\n\t\t}else if(line[b]==')'){\n\t\t\tcnt.pop();\n\t\t}else{\n\t\t\tif(cnt.size()==1)break;\n\t\t}\n\t\tb++;\n\t}\n\tstring S_R = \"\";\n\tstring S_L = \"\";\n\tfor(int x=1;x<b;++x){\n\t\tS_L += line[x];\n\t}\n\tfor(int x=b+1;x<line.size()-1;++x){\n\t\tS_R += line[x];\n\t}\n\tgetTree(S_R,tree,2*lvl+1);\n\tgetTree(S_L,tree,2*lvl);\n\tif(tree==1){\n\t\ttreeA[lvl] = 1;\n\t}else{\n\t\ttreeB[lvl] = 2;\n\t}\n}\n\nstring imp(int lvl){\n\tif(lvl>=101 || treeC[lvl]==0)return \"\";\n\tstringstream buf;\n\tbuf<<\"(\"<<imp(2*lvl)<<\",\"<<imp(2*lvl+1)<<\")\";\n\treturn buf.str();\n}\n\nvoid unionT(){\n\tfor(int x=1;x<110;++x){\n\t\tif(treeA[x] || treeB[x])treeC[x] = 3;\n\t}\n\tcout<<imp(1)<<endl;\n}\n\nvoid inter(){\n\tfor(int x=1;x<110;++x){\n\t\tif(treeA[x] && treeB[x])treeC[x] = 3;\n\t}\n\tcout<<imp(1)<<endl;\n}\n\nint main(){\n\tchar l;\n\tstring s1,s2;\n\twhile(cin>>l>>s1>>s2 && !cin.eof()){\n\t\tfor(int x=0;x<110;++x){\n\t\t\ttreeA[x] = 0;treeB[x] = 0;treeC[x] = 0;\n\t\t}\n\t\tgetTree(s1,1,1);\n\t\tgetTree(s2,2,1);\n\t\tif(l == 'u'){\n\t\t\tunionT();\n\t\t}else{\n\t\t\tinter();\n\t\t}\n\t}\t\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct Tree\n{\n  bool root;\n  bool child[2];\n  Tree *next[2];//left -> false, right -> true\n  Tree()\n  {\n    child[0] = child[1] = false;\n    root=false;\n  }\n};\n\nstring s[2];\nTree tree[2];\n\nvoid ddfs(Tree *t)\n{\n  if(!t->child[0] && !t->child[1])return;\n    \n  if(t->child[0])\n    {\n      ddfs(t->next[0]);\n      t->child[0] = false;\n      delete t->next[0];\n    }\n\n  if(t->child[1])\n    {\n      ddfs(t->next[1]);\n      t->child[1] = false;\n      delete t->next[1];\n    }\n}\n\nvoid init()\n{\n  tree[0].root = tree[1].root = true;\n  rep(i,2)ddfs(&tree[i]);\n}\n\nvoid parse(int index,int &pos,Tree *t,int depth)\n{\n  if(pos >= s[index].size())return;\n  bool LR = false;\n\n  ++pos;\n  while(pos < s[index].size() && !(LR && s[index][pos] == ')'))\n    {\n\n      if(s[index][pos] == '(')\n\t{\n\t  t->next[LR] = new Tree;\n\t  t->next[LR]->root = false;\n\t  t->next[LR]->child[0] = t->next[LR]->child[1] = false;\n\t  t->child[LR] = true;\n\t  parse(index,pos,t->next[LR],depth+1);\n\t  if(pos < s[index].size() && LR && s[index][pos] == ')')break;\n\t}\n      if(s[index][pos] == ',') LR = true;\n\t\n      ++pos;\n    }\n  ++pos;\n}\n\nvoid tree_walk(Tree *t,int depth)\n{\n  cout << '(';\n  if(t->child[0])tree_walk(t->next[0],depth+1);\n  cout << ',';\n  if(t->child[1])tree_walk(t->next[1],depth+1);\n  cout << ')';\n}\n\nvoid dfs_i(Tree *t1,Tree *t2,Tree *ans)\n{\n  if(t1->child[0] && t2->child[0])\n    {\n      ans->next[0] = new Tree;\n      ans->child[0] = true;\n      ans->next[0]->child[0] = ans->next[0]->child[1] = false;\n      dfs_i(t1->next[0],t2->next[0],ans->next[0]);\n    }\n\n  if(t1->child[1] && t2->child[1])\n    {\n      ans->next[1] = new Tree;\n      ans->child[1] = true;\n      ans->next[1]->child[0] = ans->next[1]->child[1] = false;\n      dfs_i(t1->next[1],t2->next[1],ans->next[1]);\n    }\n\n}\n\nvoid dfs_u(Tree *t,Tree *ans)\n{\n  if(t->child[0])\n    {\n      if(ans->child[0])\n\t{//already exists\n\t  dfs_u(t->next[0],ans->next[0]);\n\t}\n      else\n\t{//not yet\n\t  ans->next[0] = new Tree;\n\t  ans->child[0] = true;\n\t  ans->next[0]->child[0] = ans->next[0]->child[1] = false;\n\t  dfs_u(t->next[0],ans->next[0]);\n\t}\n    }\n\n  if(t->child[1])\n    {\n      if(ans->child[1])\n\t{//already exists\n\t  dfs_u(t->next[1],ans->next[1]);\n\t}\n      else\n\t{//not yet\n\t  ans->next[1] = new Tree;\n\t  ans->child[1] = true;\n\t  ans->next[1]->child[0] = ans->next[1]->child[1] = false;\n\t  dfs_u(t->next[1],ans->next[1]);\n\t}\n    }\n\n}\n\nvoid compute(char c)\n{\n  Tree ans;\n  ans.root = true;\n  ans.child[0] = ans.child[1] = false;\n  if(c == 'i')\n    {\n      dfs_i(&tree[0],&tree[1],&ans);\n      tree_walk(&ans,0);\n      cout << endl;\n    }\n  else if(c == 'u')\n    {\n      dfs_u(&tree[0],&ans);\n      dfs_u(&tree[1],&ans);\n      tree_walk(&ans,0);\n      cout << endl;\n    }\n\n  ddfs(&ans);\n}\n\n//deleteまわりも後で書く <- 忘れてた <- でも通らない <- なんでや <- parseが小さいケースでしかあってない <- 構文解析間違ってた\n\nint main()\n{\n  char c;\n  while(cin >> c)\n    {\n      cin >> s[0] >> s[1];\n      init();\n\n      int pos;\n      rep(i,2)\n\t{\n\t  pos = 0;\n\t  parse(i,pos,&tree[i],0);\n\t}\n\n      compute(c);\n   \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n}\n s"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\nint lt[100], rt[100];\n\nstring parse(string str, int level, int no, int* ary)\n{\n    if(str.size() < 3 || str[0] != '(')  {\n        return \"\";\n    }\n\n    ary[no - 1] = 1;\n\n    // str = (<tree>,<tree>)\n    if(str[1] != ',') {\n        str = parse(str.substr(1), level + 1, no + (1 << level) + (no - (1 << level)), ary);\n    }\n\n    // str = ,<tree>)\n    str = str.substr(1);\n    if(str[1] != ')') {\n        str = parse(str.substr(1), level + 1, no + (1 << level) + (no - (1 << level)) + 1, ary);\n    }\n\n    // str = )\n    return str.substr(1);\n}\n\nstring unparse(int *ary, int level, int no)\n{\n    if(ary[no - 1] == 0) {\n        return \"\";\n    }\n\n    return \"(\" + \n        unparse(ary, level + 1, no + (1 << level) + (no - (1 << level))) +\n        \",\" + \n        unparse(ary, level + 1, no + (1 << level) + (no - (1 << level)) + 1)\n        + \")\";\n}\n\nint main()\n{\n    string op, a, b;\n    while(cin >> op >> a >> b) {\n        int ret[100];\n        for(int i = 0; i < 100; i++) {\n            lt[i] = rt[i] = ret[i] = 0;\n        }\n\n        parse(a, 0, 1, lt);\n        parse(b, 0, 1, rt);\n\n\n        for(int i = 0; i < 100; i++) {\n            if(op == \"i\") {\n                ret[i] = (lt[i] & rt[i]);\n            } else {\n                ret[i] = (lt[i] | rt[i]);\n            }\n        }\n        \n        cout << unparse(ret, 0, 1) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <vector>\n#include <limits.h>\n#include <queue>\n#include <stack>\nusing namespace std;\nstack<int> S;\nint main()\n{\n    int treeNode1[101],treeNode2[101],i,j;\n    char op[2],tree1[1000],tree2[1000];\n\n    while(scanf(\"%s%s%s\",&op,&tree1,&tree2)!=EOF)\n    {\n\n        int len1 = strlen(tree1);\n        int len2 = strlen(tree2);\n        memset(treeNode1,0,sizeof(treeNode1));\n        memset(treeNode2,0,sizeof(treeNode2));\n        int cur;\n        for(i = 0;i < len1;i ++)\n        {\n            if(tree1[i] == '(')\n            {\n                if(i == 0) {S.push(1);treeNode1[1] = 1;}\n                else\n                {\n                    if(tree1[i-1] == '(')\n                    {\n                        cur = S.top();\n                        S.push(cur*2);\n                        treeNode1[cur*2] = 1;\n                    }\n                    else\n                    {\n                        cur = S.top();\n                        S.push(2*cur+1);\n                        treeNode1[cur*2+1] = 1;\n                    }\n                }\n            }\n            else if(tree1[i] == ')') S.pop();\n        }\n        for(i = 0;i < len2;i ++)\n        {\n            if(tree2[i] == '(')\n            {\n                if(i == 0) {S.push(1);treeNode2[1] = 1;}\n                else\n                {\n                    if(tree2[i-1] == '(')\n                    {\n                        cur = S.top();\n                        S.push(cur*2);\n                        treeNode2[cur*2] = 1;\n                    }\n                    else\n                    {\n                        cur = S.top();\n                        S.push(2*cur+1);\n                        treeNode2[cur*2+1] = 1;\n                    }\n                }\n            }\n            else if(tree2[i] == ')') S.pop();\n        }\n        if(op[0] == 'i')\n        {\n            int tmp[101],tmplen,pos[101];\n            tmplen = 0;\n            for(i = 1;i < 101;i ++)\n            {\n                if(treeNode1[i]&&treeNode2[i]) tmp[tmplen ++] = i;\n            }\n            string ans = \"(,)\";\n            pos[2] = 1;pos[3] = 2;\n            for(i = 1;i < tmplen;i ++)\n            {\n                if(tmp[i]%2 == 0)\n                {\n                    ans.insert(pos[tmp[i]],\"(,)\");\n                    pos[tmp[i]+1] += 3;\n                    pos[2*tmp[i]] = pos[tmp[i]]+1;\n                    pos[2*tmp[i]+1] = pos[tmp[i]]+2;\n                }\n                else\n                {\n                    ans.insert(pos[tmp[i]],\"(,)\");\n                    //pos[tmp[i]+1] += 3;\n                    pos[2*tmp[i]] = pos[tmp[i]]+1;\n                    pos[2*tmp[i]+1] = pos[tmp[i]]+2;\n                }\n            }\n            cout<<ans<<endl;\n        }\n        else\n        {\n            int tmp[101],tmplen,pos[101];\n            tmplen = 0;\n            for(i = 1;i < 101;i ++)\n            {\n                if(treeNode1[i]||treeNode2[i]) tmp[tmplen ++] = i;\n            }\n            string ans = \"(,)\";\n            pos[2] = 1;pos[3] = 2;\n            for(i = 1;i < tmplen;i ++)\n            {\n                if(tmp[i]%2 == 0)\n                {\n                    ans.insert(pos[tmp[i]],\"(,)\");\n                    pos[tmp[i]+1] += 3;\n                    pos[2*tmp[i]] = pos[tmp[i]]+1;\n                    pos[2*tmp[i]+1] = pos[tmp[i]]+2;\n                }\n                else\n                {\n                    ans.insert(pos[tmp[i]],\"(,)\");\n                    //pos[tmp[i]+1] += 3;\n                    pos[2*tmp[i]] = pos[tmp[i]]+1;\n                    pos[2*tmp[i]+1] = pos[tmp[i]]+2;\n                }\n            }\n            cout<<ans<<endl;\n        }\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#coding : utf-8\n\n# version 1.0 2017/02/10  ??????????????¨???????????????\n# version 1.1 2017/02/11???????????????????°????????????????????????¶??§??????\n# version 1.2 2017/02/11???AOJ??????????????°??????\n# version 1.3 2017/02/12  ?§£????????????????????????????????¨?????§?????????????????????\n\nimport requests,sys\nimport time\nfrom selenium import webdriver\nfrom bs4 import BeautifulSoup\nimport xerox\n\ndef main():\n    print(\"Hello! This is The AOJ Chaser!\")\n    user_url='http://judge.u-aizu.ac.jp/onlinejudge/webservice/user'\n    problem_url='http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id='\n\n    # ????´¢?????????id?????\\???\n    rival_id='minaminao'\n    my_id='oshibori'\n    my_password='1225tomoki'\n    if not my_id :\n        print('Input your id!', end=' ')\n        my_id=input()\n    if not my_password :\n        print('Input your password!', end=' ')\n        my_password=input()\n    if not rival_id :\n        print('Input your rival\\'s id!', end=' ')\n        rival_id=input()\n\n\n\n    # ??????????????????\n    myparams={'id':my_id}                   #  ME\n    mydata=requests.get(user_url,params=myparams)\n    rivalparams={'id':rival_id}               #  RIVAL\n    rivaldata=requests.get(user_url,params=rivalparams)\n\n    # ??????????????????\n    mysoup=BeautifulSoup(mydata.text,\"html.parser\")\n    rivalsoup=BeautifulSoup(rivaldata.text,\"html.parser\")\n    table={}\n    cnt=0\n    result_list=[]\n    for i in mysoup.findAll('problem'):\n        table[int(i.id.string)]=1;\n\n    for i in rivalsoup.findAll('problem'):\n        x=int(i.id.string)\n        try:\n            table[x]=table[x]-1\n        except:\n            print(x)\n\n            result_list.append([int(i.judge_id.string),i.id.string])\n            cnt=cnt+1\n\n\n    print('')\n\n    result_list.sort(key=lambda x:x[0])\n    #result_list.sort(key=lambda x:x[1])\n    #for i in result_list:\n    #    print(i[1])\n    print('Sum is ',end='')\n    print(cnt)\n\n    index=0\n    while True:\n        #??????????????¶?????????\n        browser=webdriver.Chrome('./chromedriver')\n        #?????????????????¨?§?\n        browser.get(problem_url + result_list[index][1])\n        # ?????°??????\n        loginform=browser.find_element_by_id('user')\n        loginform.find_element_by_id('login').click()\n\n        loginUserID=loginform.find_element_by_name('loginUserID')\n        loginPassword=loginform.find_element_by_name('loginPassword')\n\n        loginUserID.send_keys(my_id)\n        loginPassword.send_keys(my_password)\n\n        logininput=loginform.find_element_by_id('logininput')\n        logininput.submit()\n        index=index+1\n\n        #???????????????\n        submit_url='http://judge.u-aizu.ac.jp/onlinejudge/status.jsp#submit/'+ result_list[index][1]\n        if browser.current_url == submit_url:\n            submit_area=browser.find_element_by_id('submitArea')\n            select=submit_area.find_element_by_id('submit_language')\n            select.click()\n            select.find_elements_by_tag_name('option')[4].click()  # C++14\n            select.click()\n            \n            source=submit_area.find_element_by_id('submit_source')\n            \n            \n        # ???????????????????????????????????????\n        print(browser.title)\n        print(\".....END.....\")\n\n        #????¶??¶???????\n        com = input()\n        browser.quit()\n        if com == 'done' or com == 'fin' :\n            break;\n\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\nchar ope;\n\nstring parse(string tr1,string tr2){\n\tint len1=tr1.length(),len2=tr2.length();\n\n\tstring lhs1,rhs1;\n\tint pcnt=0;\n\trep(i,len1){\n\t\tif(tr1[i]=='(')\tpcnt++;\n\t\tif(tr1[i]==')')\tpcnt--;\n\t\tif(tr1[i]==',' && pcnt==1){\n\t\t\tlhs1=tr1.substr(1,i-1);\n\t\t\trhs1=tr1.substr(i+1,len1-i-2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstring lhs2,rhs2;\n\tpcnt=0;\n\trep(i,len2){\n\t\tif(tr2[i]=='(')\tpcnt++;\n\t\tif(tr2[i]==')')\tpcnt--;\n\t\tif(tr2[i]==',' && pcnt==1){\n\t\t\tlhs2=tr2.substr(1,i-1);\n\t\t\trhs2=tr2.substr(i+1,len2-i-2);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tstring lhs,rhs;\n\tif(ope=='i'){\t// intersection\n\t\tif(lhs1!=\"\" && lhs2!=\"\")\tlhs=parse(lhs1,lhs2);\n\t\tif(rhs1!=\"\" && rhs2!=\"\")\trhs=parse(rhs1,rhs2);\n\t}\n\telse{\t\t\t// union\n\t\tif(lhs1!=\"\" || lhs2!=\"\")\tlhs=parse(lhs1,lhs2);\n\t\tif(rhs1!=\"\" || rhs2!=\"\")\trhs=parse(rhs1,rhs2);\n\t}\n\n\treturn '('+lhs+','+rhs+')';\n}\n\nint main(){\n\tfor(string tr1,tr2;cin>>ope>>tr1>>tr2;)\tcout<<parse(tr1,tr2)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <boost/shared_ptr.hpp>\nusing namespace std;\n\nstruct bad_input { };\nstruct Node;\ntypedef boost::shared_ptr<Node> NodePtr;\nstruct Node {\n\tNodePtr left;\n\tNodePtr right;\n};\n\nvoid show_intersection_tree(NodePtr root1, NodePtr root2)\n{\n\tstd::cout << '(';\n\tif (root1->left && root2->left) {\n\t\tshow_intersection_tree(root1->left, root2->left);\n\t}\n\tstd::cout << ',';\n\tif (root1->right && root2->right) {\n\t\tshow_intersection_tree(root1->right, root2->right);\n\t}\n\tstd::cout << ')';\n}\n\nvoid show_union_tree(NodePtr root1, NodePtr root2)\n{\n\tstd::cout << '(';\n\tif ((root1 && root1->left) || (root2 && root2->left)) {\n\t\tshow_union_tree(root1 ? root1->left : root1, root2 ? root2->left : root2);\n\t}\n\tstd::cout << ',';\n\tif ((root1 && root1->right) || (root2 && root2->right)) {\n\t\tshow_union_tree(root1 ? root1->right : root1, root2 ? root2->right : root2);\n\t}\n\tstd::cout << ')';\n}\n\nchar get_token()\n{\n\tchar c;\n\twhile (std::cin >> c) {\n\t\tif (c == '(' || c == ',' || c == ')') {\n\t\t\tbreak;\n\t\t}\n\t\tif (c != '\\n' && c != ' ') {\n\t\t\tthrow bad_input();\n\t\t}\n\t}\n\treturn c;\n}\n\nNodePtr make_node(int no)\n{\n\tNodePtr node = NodePtr(new Node);\n\tchar c = get_token();\n\tif (c == '(') {\n\t\tnode->left = make_node(no + 1);\n\t\tc = get_token();\n\t}\n\tif (c == ',') {\n\t}\n\telse {\n\t\tthrow bad_input();\n\t}\n\tc = get_token();\n\tif (c == '(') {\n\t\tnode->right = make_node(no + 1);\n\t\tc = get_token();\n\t}\n\tif (c == ')') {\n\t}\n\telse {\n\t\tthrow bad_input();\n\t}\n\treturn node;\n}\n\nint main()\n{\n\tchar op;\n\twhile (std::cin >> op) {\n\t\tNodePtr root1, root2;\n\t\tif (get_token() == '(') {\n\t\t\troot1 = make_node(0);\n\t\t}\n\t\telse {\n\t\t\tthrow bad_input();\n\t\t}\n\t\tif (get_token() == '(') {\n\t\t\troot2 = make_node(0);\n\t\t}\n\t\telse {\n\t\t\tthrow bad_input();\n\t\t}\n\t\tif (op == 'i') {\n\t\t\tif (root1 && root2) {\n\t\t\t\tshow_intersection_tree(root1, root2);\n\t\t\t}\n\t\t}\n\t\telse if (op == 'u') {\n\t\t\tif (root1 || root2) {\n\t\t\t\tshow_union_tree(root1, root2);\n\t\t\t}\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n/*\nconst int nil = -1;\nconst int MAX_N = 256;\n\nstruct Node {\n  int l, r, cnt;\n  Node() {\n    l = r = nil;\n    cnt = 0;\n  }\n};\n\nNode v[MAX_N];\nint nodeIndex;\n\nint parse(const char *s, int n, int root) {\n  v[root].cnt++;\n  if (s[++n] != ',') {\n    if (v[root].l == nil) v[root].l = ++nodeIndex;\n    n = parse(s, n, v[root].l);\n  }\n  if (s[++n] != ')') {\n    if (v[root].r == nil) v[root].r = ++nodeIndex;\n    n = parse(s, n, v[root].r);\n  }\n  return n+1;\n}\n\nvoid print(int root, int cnt) {\n  if (v[root].cnt < cnt) return;\n  putchar('(');\n  if (v[root].l != nil) print(v[root].l, cnt);\n  putchar(',');\n  if (v[root].r != nil) print(v[root].r, cnt);\n  putchar(')');\n}\n*/\nint main() {\n  char op[10], t1[256], t2[256];\n  while (scanf(\"%s %s %s\", op, t1, t2) == 3) {\n/*\n    for (int i=0;i<MAX_N;i++) v[i] = Node();\n    nodeIndex = 0;\n    parse(t1, 0, 0);\n    parse(t2, 0, 0);\n    print(0, (op=='u'?1:2)); putchar('\\n');\n*/\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct Node {\n  Node *ch[2];\n  Node() { ch[0] = ch[1] = NULL; }\n};\n\nvoid build(Node *node, const string &s, int &i) {\n  if( s[i] == '(' ) {\n    i++; // (\n    node->ch[0] = new Node();\n    build(node->ch[0], s, i);\n    i++; // ,\n    node->ch[1] = new Node();\n    build(node->ch[1], s, i);\n    i++; // )\n  }\n}\n\nvoid print(Node* node) {\n  if( node == NULL || (node->ch[0] == NULL && node->ch[1] == NULL )) return;\n  cout << \"(\";\n  print(node->ch[0]);\n  cout << \",\";\n  print(node->ch[1]);\n  cout << \")\";\n}\n\nvoid erase(Node *node) {\n  for(int i = 0; i < 2; i++) if( node->ch[i] ) erase(node->ch[i]);\n  delete node;\n}\n\nvoid Intersection(Node *res, Node *a, Node *b) {\n  for(int i = 0; i < 2; i++)\n    if( a && a->ch[i] && b && b->ch[i] ) {\n      res->ch[i] = new Node();\n      Intersection(res->ch[i], a->ch[i], b->ch[i]);\n    }\n}\n\nvoid Union(Node *res, Node *a, Node *b) {\n  for(int i = 0; i < 2; i++)\n    if( (a && a->ch[i]) || (b && b->ch[i]) ) {\n      res->ch[i] = new Node();\n      Union(res->ch[i], a->ch[i], b->ch[i]);\n    }\n}\n\n\nint main() {\n  for(string cmd, A, B; cin >> cmd >> A >> B;) {\n    Node *roota = new Node();\n    Node *rootb = new Node();\n    Node *rootc = new Node();\n\n    int i = 0;\n    build(roota, A, i);\n\n    i = 0;\n    build(rootb, B, i);\n\n    if( cmd[0] == 'i' ) Intersection(rootc, roota, rootb);\n    else Union(rootc, roota, rootb);\n\n    print(rootc); cout << endl;\n\n    erase(roota);\n    erase(rootb);\n    erase(rootc);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n#include <algorithm>\n\nusing namespace std;\n\nstring tree[2];\n\nstring uni(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    if (tree[1][index1] != ',') \n      for (;tree[1][index1] != ','; index1++) {\n\tleft = left + tree[1][index1];\n      }\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[0][index0] != ','; index0++) {\n      left = left + tree[0][index0];\n    }\n  } else {\n    left = uni(index0 + 1, index1 + 1);\n    for (;tree[0][index0] != ','; index0++);\n    for (;tree[1][index1] != ','; index1++);\n  }\n\n  if (tree[0][index0 + 1] == ')') {\n    int c = 0;\n    index1++;\n    while (true) {\n      if (c == 0 && tree[1][index1] == ')') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      right = right + tree[1][index1];\n      index1++;\n    }\n  } else if (tree[1][index1 + 1] == ')') {\n    int c = 0;\n    index0++;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ')') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      right = right + tree[0][index0];\n      index0++;\n    }\n  } else {\n    right = uni(index0 + 1, index1 + 1);\n  }\n  return \"(\" + left + \",\" + right + \")\";\n}\n\nstring inter(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++;\n    for (;tree[1][index1] != ','; index1++);\n  } else if (tree[1][index1 + 1] == ',') {\n    index1++;\n    for (;tree[0][index0] != ','; index0++);\n  } else {\n    left = inter(index0 + 1, index1 + 1);\n    for (;tree[0][index0] != ','; index0++);\n    for (;tree[1][index1] != ','; index1++);\n  }\n  \n  if (tree[0][index0 + 1] == ')' || tree[1][index1 + 1] == ')') {\n    right = \"\";\n  } else {\n    right = inter(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    if (ex == 'i') {\n      cout << inter(0, 0) << endl;\n    } else {\n      cout << uni(0, 0) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint main() {\n  string line;\n  while (getline(cin, line)) {\n    stringstream stream;\n    stream << line;\n    string command, tree1, tree2;\n    stream >> command >> tree1 >>  tree2;\n    //cout << command << tree1 << tree2;\n    //cout << tree1[0] << endl;\n\n    int open = 0;\n    int index1 = 0, index2 = 0;\n    while (index1 < tree1.length() && index2 < tree2.length()) {\n      if (tree1[index1] == tree2[index2]) { //if same characters\n\tcout << tree1[index1];\n\tindex1++;\n\tindex2++;\n      } else  { //if different characters\n\tif (tree1[index1] == '(') {\n\t  open++;\n\t  index1++;\n\t  if (command == \"u\") cout << \"(\";\n\t  while (open != 0) {\n\t    if (tree1[index1] == '(') open++;\n\t    if (tree1[index1] == ')') open--;\n\t    if (command == \"u\") cout << tree1[index1];\n\t    index1++;\n\t   \n\t  }\n\t} else if (tree2[index2] == '(') {\n\t  open++;\n\t  index2++;\n\t  if (command == \"u\") cout << \"(\";\n\t  while (open != 0) {\n\t    if (tree2[index2] == '(') open++;\n\t    if (tree2[index2] == ')') open--;\n\t    if (command == \"u\") cout << tree2[index2];\n\t    index2++;\n\t    \n\t  }\n\t}\n      }\n     }\n     cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAizuOnline A1001\nBinary Tree Intersection And Union\n*/\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint find_comma(char * s)\n{ int i;\n  int depth=0;\n  char c;\n\n  for(i=0;i<strlen(s);i++)\n    {\n      c = s[i];\n      if(c=='(')depth++;\n      if(c==')')depth--;\n      if((depth==1) && (c == ','))\n        return(i);\n    }\n    return(-1);\n}\n\n\nchar *left_node(char *s)\n{\n    int pos;\n    int len;\n    char *ptr;\n  \n     pos=find_comma(s);\n     if(pos == 0||pos==1)\n          return(NULL);\n     else if(pos > 0)\n       {  len = pos -1;\n          ptr = malloc(len+1);\n          strncpy(ptr,&s[1],len);\n          ptr[len]='\\0';\n          return(ptr);\n       }\n\n}\nchar *right_node(char *s)\n{\n    int pos;\n    int len;\n    char *ptr;\n  \n     pos=find_comma(s);\n/*printf(\"P,L = %d %d\\n\",pos,strlen(s));*/\n     if(pos == strlen(s)-1||pos==strlen(s)-2)\n          return(NULL);\n     else if(pos > 0)\n       {  len = strlen(s)-pos -2;\n          ptr = malloc(len+1);\n          strncpy(ptr,&s[pos+1],len);\n          ptr[len]='\\0';\n          return(ptr);\n       }\n}\n\nvoid space_trim(char *s)\n{           int i,j;\n            for(i=strlen(s);i--;i>=0)\n              if(isspace(s[i]))\n                for(j=i;j<strlen(s);j++)\n                 s[j]=s[j+1];\n}\n\nchar * binary_tree_cons(char *x,char *y)\n{ int len;\n  char *p;\n  if(NULL == x)\n    if(NULL == y)\n      {  p=malloc(4);\n        strcpy(p,\"(,)\");\n        return(p);\n      }\n    else\n    {  len = strlen(y);\n       p=malloc(len+4);\n       p[0]='(';\n       p[1]=',';\n       strcpy(p+2,y);\n       p[len+2]=')';\n       p[len+3]='\\0';\n    }\n  else\n    if(NULL == y)\n      { len = strlen(x);\n        p=malloc(len+4);\n        p[0]='(';\n        strcpy(p+1,x);\n        p[len+1] = ',';\n        p[len+2] = ')';\n        p[len+3] = '\\0';\n      }\n    else\n      { \n         len = strlen(y)+strlen(x);\n         p=malloc(len+4);\n         p[0]='(';\n         strcpy(p+1,x);\n         p[strlen(x)+1]=',';\n         strcpy(p+strlen(x)+2,y);\n         p[len+2] = ')';\n         p[len+3] = '\\0';\n        \n          \n        }  \n    return(p);\n} \n\n\nchar * binary_tree_union(char *x,char *y)\n{ int len;\n  char *p;\n  if(NULL == x)\n    if(NULL == y)\n      {  return(NULL);\n      }\n    else\n    {  len = strlen(y);\n       p=malloc(len);\n       strcpy(p,y);\n    }\n  else\n    if(NULL == y)\n      { len = strlen(x);\n        p=malloc(len);\n        strcpy(p,x);\n      }\n    else\n      { if(0==strcmp(x,y))\n        { len = strlen(x);\n          p=malloc(len);\n          strcpy(p,x);\n        }\n        else\n          {  /* printf(\"U:%s %s %s %s \\n\",left_node(x),right_node(x),left_node(y),right_node(y));*/\n            p=binary_tree_cons(binary_tree_union (left_node(x),left_node(y)),\n                           binary_tree_union (right_node(x),right_node(y)));\n          }\n      }\n  return(p);\n} \n\n\nchar * binary_tree_intersect(char *x,char *y)\n{ int len;\n  char *p;\n  if((NULL == x) || (NULL == y))\n      {  return(NULL);\n      }\n  else\n      { if(0==strcmp(x,y))\n        { len = strlen(x);\n          p=malloc(len);\n          strcpy(p,x);\n        }\n        else\n          {  /* printf(\"I:%s %s %s %s \\n\",left_node(x),right_node(x),left_node(y),right_node(y)); */\n            p=binary_tree_cons(binary_tree_intersect (left_node(x),left_node(y)),\n                               binary_tree_intersect (right_node(x),right_node(y)));\n          }\n      }\n  return(p);\n} \n\n\n\nmain()\n{\n  char bin1[256],bin2[256];\n  char order;\n\n  \n  while(3 == scanf(\" %c %s %s\",&order,bin1,bin2))\n    {\n/*   printf(\"T1,T2=%s %s\\n\",bin1,bin2); */\n      \n\n     if(order =='i')\n      printf(\"%s\\n\",binary_tree_intersect(bin1,bin2));\n     else\n      printf(\"%s\\n\",binary_tree_union(bin2,bin1));\n\n\n    }\n  \n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n//#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct Tree\n{\n  bool root;\n  bool child[2];\n  Tree *next[2];//left -> false, right -> true\n  Tree()\n  {\n    child[0] = child[1] = false;\n    root=false;\n  }\n};\n\nstring s[2];\nTree tree[2];\n\nvoid ddfs(Tree *t)\n{\n  if(!t->child[0] && !t->child[1])return;\n    \n\n  if(t->child[0])\n    {\n      t->child[0] = false;\n      delete t->next[0];\n    }\n\n  if(t->child[1])\n    {\n      t->child[1] = false;\n      delete t->next[1];\n    }\n\n}\n\nvoid init()\n{\n  tree[0].root = tree[1].root = true;\n  rep(i,2)ddfs(&tree[i]);\n}\n\nvoid parse(int index,int &pos,Tree *t,int depth)\n{\n  if(pos >= s[index].size())return;\n  //assert(s[index][pos] == '('); \n  bool LR = false;\n\n  ++pos;\n  while(pos < s[index].size() && !(LR && s[index][pos] == ')'))\n    {\n\n      if(s[index][pos] == '(')\n\t{\n\t  t->next[LR] = new Tree;\n\t  t->next[LR]->root = false;\n\t  t->next[LR]->child[0] = t->next[LR]->child[1] = false;\n\t  t->child[LR] = true;\n\t  parse(index,pos,t->next[LR],depth+1);\n\t}\n      if(s[index][pos] == ',') LR = true;\n\t\n      ++pos;\n    }\n  ++pos;\n}\n\nvoid tree_walk(Tree *t,int depth)\n{\n  cout << '(';\n  if(t->child[0])tree_walk(t->next[0],depth+1);\n  cout << ',';\n  if(t->child[1])tree_walk(t->next[1],depth+1);\n  cout << ')';\n}\n\nvoid dfs_i(Tree *t1,Tree *t2,Tree *ans)\n{\n  if(t1->child[0] && t2->child[0])\n    {\n      ans->next[0] = new Tree;\n      ans->child[0] = true;\n      ans->next[0]->child[0] = ans->next[0]->child[1] = false;\n      dfs_i(t1->next[0],t2->next[0],ans->next[0]);\n    }\n\n  if(t1->child[1] && t2->child[1])\n    {\n      ans->next[1] = new Tree;\n      ans->child[1] = true;\n      ans->next[1]->child[0] = ans->next[1]->child[1] = false;\n      dfs_i(t1->next[1],t2->next[1],ans->next[1]);\n    }\n\n}\n\nvoid dfs_u(Tree *t,Tree *ans)\n{\n  if(t->child[0])\n    {\n      if(ans->child[0])\n\t{//already exists\n\t  dfs_u(t->next[0],ans->next[0]);\n\t}\n      else\n\t{//not yet\n\t  ans->next[0] = new Tree;\n\t  ans->child[0] = true;\n\t  ans->next[0]->child[0] = ans->next[0]->child[1] = false;\n\t  dfs_u(t->next[0],ans->next[0]);\n\t}\n    }\n\n  if(t->child[1])\n    {\n      if(ans->child[1])\n\t{//already exists\n\t  dfs_u(t->next[1],ans->next[1]);\n\t}\n      else\n\t{//not yet\n\t  ans->next[1] = new Tree;\n\t  ans->child[1] = true;\n\t  ans->next[1]->child[0] = ans->next[1]->child[1] = false;\n\t  dfs_u(t->next[1],ans->next[1]);\n\t}\n    }\n\n}\n\nvoid compute(char c)\n{\n  Tree ans;\n  ans.root = true;\n  ans.child[0] = ans.child[1] = false;\n  if(c == 'i')\n    {\n      dfs_i(&tree[0],&tree[1],&ans);\n      tree_walk(&ans,0);\n      cout << endl;\n    }\n  else if(c == 'u')\n    {\n      dfs_u(&tree[0],&ans);\n      dfs_u(&tree[1],&ans);\n      tree_walk(&ans,0);\n      cout << endl;\n    }\n}\n\n\n\n//deleteまわりも後で書く <- 忘れてた\n\nint main()\n{\n\n  char c;\n  while(cin >> c)\n    {\n      cin >> s[0] >> s[1];\n      init();\n\n      int pos;\n      rep(i,2)\n\t{\n\t  pos = 0;\n\t  parse(i,pos,&tree[i],0);\n\t  //cerr << \"output the tree[\" << i << \"]\" << endl;\n\t  //tree_walk(&tree[i],0);\n\t  //cout << endl;\n\t}\n\n      compute(c);\n   \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=100;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  heap[id]++;\n  if(s==\"(,)\")  return;\n  \n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;   \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n      parse(sub1, 2*id+1);\n      parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nint out(int th, int id,int n){\n\n  string c(\"(,)\");\n  for(int i=0;i<3;i++)\n    output.insert(output.begin()+n+i,c[i]);\n\n  int ch1=0,ch2=0;//n of string of each child\n  \n  if(heap[id]>th){\n    if(heap[2*id+1]>th){\n      ch1=out(th,2*id+1,n+1);\n    }\n    if(heap[2*id+2]>th){\n      ch2=out(th,2*id+2,n+ch1+2);\n    }\n  }\n  return ch1+ch2+3;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  \n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0,0);\n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  cin>>cmd>>s1>>s2;\n  solve(cmd,s1,s2);\n  //print();\n  \n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nstruct Node {\n  Node* left;\n  Node* right;\n  Node(Node* l, Node* r): left(l), right(r) {}\n};\n\nNode dummy(NULL, NULL);\n\npair<int, Node*> parse(const string& str, int k)\n{\n  pair<int, Node*> r1, r2;\n  assert(str[k] == '(');\n  if (str[k + 1] == '(') {\n    r1 = parse(str, k + 1);\n  } else {\n    r1 = make_pair(k + 1, (Node*)NULL);\n  }\n  assert(str[r1.first] == ',');\n  if (str[r1.first + 1] == '(') {\n    r2 = parse(str, r1.first + 1);\n  } else {\n    r2 = make_pair(r1.first + 1, (Node*)NULL);\n  }\n  assert(str[r2.first] == ')');\n  return make_pair(r2.first + 1, new Node(r1.second, r2.second));\n}\n\nNode* intersection_or_union(char op, Node* node1, Node* node2)\n{\n  if (!node1) { node1 = &dummy; }\n  if (!node2) { node2 = &dummy; }\n  bool b1 = (op == 'i') ? (node1->left && node2->left) : (node1->left || node2->left);\n  bool b2 = (op == 'i') ? (node1->right && node2->right) : (node1->right || node2->right);\n  Node* left = b1 ? intersection_or_union(op, node1->left, node2->left) : NULL;\n  Node* right = b2 ? intersection_or_union(op, node1->right, node2->right) : NULL;\n  return new Node(left, right);\n}\n\nvoid print_tree(Node* node)\n{\n  cout << \"(\";\n  if (node->left) {\n    print_tree(node->left);\n  }\n  cout << \",\";\n  if (node->right) {\n    print_tree(node->right);\n  }\n  cout << \")\";\n}\n\nint main()\n{\n  char op;\n  string str1, str2;\n  while (cin >> op >> str1 >> str2) {\n    Node* tree1 = parse(str1, 0).second;\n    Node* tree2 = parse(str2, 0).second;\n    print_tree(intersection_or_union(op, tree1, tree2));\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <cstring>\nusing namespace std;\n\nstruct Node {\n\tNode * l;\n\tNode * r;\n\tNode () {l = r = NULL;}\n};\n\nNode * build(char s[], int l, int r) {\n\tif (r < l) return NULL;\n\tNode * p = new Node();\n\tint cnt = 0;\n\tfor (int i = l + 1; i < r; ++i) {\n\t\tif (s[i] == '(') {cnt ++; continue;}\n\t\tif (s[i] == ')') {cnt --; continue;}\n\t\tif (s[i] == ',' && cnt == 0) {\n\t\t\tp->l = build(s, l + 1, i - 1);\n\t\t\tp->r = build(s, i + 1, r - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn p;\n}\n\nNode * getInter(Node * a, Node * b) {\n\tNode * p = new Node();\n\tif (a->l != NULL && b->l != NULL) {\n\t\tp->l = getInter(a->l, b->l);\n\t}\n\telse p->l = NULL;\n\tif (a->r != NULL && b->r != NULL) {\n\t\tp->r = getInter(a->r, b->r);\n\t}\n\telse p->r = NULL;\n\treturn p;\n}\n\nNode * getUnion(Node * a, Node * b) {\n\tNode * p = new Node();\n\tif (a != NULL && b != NULL) {\n\t\tif (a->l != NULL || b->l != NULL) {\n\t\t\tp->l = getUnion(a->l, b->l);\n\t\t}\n\t\telse p->l = NULL;\n\t\tif (a->r != NULL || b->r != NULL) {\n\t\t\tp->r = getUnion(a->r, b->r);\n\t\t}\n\t\telse p->r = NULL;\n\t} else if (a == NULL) {\n\t\tif (b->l != NULL) p->l = getUnion(NULL, b->l);\n\t\telse p->l = NULL;\n\t\tif (b->r != NULL) p->r = getUnion(NULL, b->r);\n\t\telse p->r = NULL;\n\t} else {\n\t\tif (a->l != NULL) p->l = getUnion(a->l, NULL);\n\t\telse p->l = NULL;\n\t\tif (a->r != NULL) p->r = getUnion(a->r, NULL);\n\t\telse p->r = NULL;\n\t}\n\treturn p;\n}\n\nstring getStr(Node * p) {\n\tif (p == NULL) {\n\t\treturn \"\";\n\t}\n\telse return \"(\" + getStr(p->l) + \",\" + getStr(p->r) + \")\";\n}\n\nchar a[3000], b[3000];\n\nint main() {\n\tchar op;\n\twhile (scanf(\"%c %s %s\", &op, a, b) != EOF) {\n\t\tgetchar();\n\t\tint la = strlen(a), lb = strlen(b);\n\t\tNode * ra = build(a, 0, la - 1);\n\t\tNode * rb = build(b, 0, lb - 1);\n\t\tNode * root = NULL;\n\t\tif (op == 'i') root = getInter(ra, rb);\n\t\telse root = getUnion(ra, rb);\n\t\tstring res = getStr(root);\n\t\tprintf(\"%s\\n\", res.c_str());\n\t}\n\treturn 0;\n}\n\n/*\ni ((,),(,)) ((,(,)),)\nu ((,),(,)) ((,(,)),)\ni (((,),),) (,(,(,)))\nu (((,),),) (,(,(,)))\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nvector<int> treeshape(string tree);\nstring printtree(vector<int> nodes, int root);\n\nint main(){\n\tstring op, first, second;\n\twhile(!cin.eof()){\n\t\tcin>>op>>first>>second;\n\t\tvector<int> f, s;\n\t\tf = treeshape(first);\n\t\ts = treeshape(second);\n\t\tsort(f.begin(), f.end());\n\t\tsort(s.begin(), s.end());\n\t\tvector<int> result;\n\t\tif(op[0] == 'i'){\n\t\t\tset_intersection(f.begin(), f.end(), s.begin(), s.end(), back_inserter(result));\n\t\t}\n\t\tif(op[0] == 'u'){\n\t\t\tset_union(f.begin(), f.end(), s.begin(), s.end(), back_inserter(result));\n\t\t}\n\t\tcout<<printtree(result, result[0])<<endl;\n\t}\n}\n\nvector<int> treeshape(string tree){\n\tvector<int> vec;\n\tstack<char> st;\n\tbool flag = false;\n\tint node = 1;\n\tvec.push_back(node);\n\tfor(int i = 1; i < tree.length(); i++){\n\t\tif(tree[i] == '('){\n\t\t\tst.push('(');\n\t\t\tnode *= 2;\n\t\t\tif(flag){\n\t\t\t\tnode += 1;\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t\tvec.push_back(node);\n\t\t}else if(tree[i] == ',' && tree[i+1] == '('){\n\t\t\tflag = true;\n\t\t}else if(tree[i] == ')'){\n\t\t\tst.pop();\n\t\t\tnode /= 2;\n\t\t}\n\t}\n\treturn vec;\n}\n\nstring printtree(vector<int> nodes, int root){\n\tif(find(nodes.begin(), nodes.end(), root) == nodes.end())\n\t\treturn \"\";\n\tif(find(nodes.begin(), nodes.end(), root * 2) == nodes.end() && find(nodes.begin(), nodes.end(), root * 2 + 1) == nodes.end())\n\t\treturn \"(,)\";\n\treturn \"(\" + printtree(nodes, root * 2) + \",\" + printtree(nodes, root * 2 + 1) + \")\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nstd::string binary_tree(std::string, std::string, char);\n\nint main(int argc, char const *argv[]){\n\n\tchar operation;\n\tstd::string tree_A;\n\tstd::string tree_B;\n\n\tif(std::cin >> operation >> tree_A >> tree_B){\n\t\tstd::string answer = binary_tree(tree_A,tree_B,operation);\n\t\tstd::cout << answer << std::endl;\n\t} \n\n\treturn 0;\n}\n\nstd::string binary_tree(std::string tree_A, std::string tree_B, char operation){\n\n\tif(tree_A==tree_B){\n\n\t\treturn tree_A;\n\n\t}else if(tree_A==\"\"){\n\n\t\tif(operation=='i'){\n\t\t\treturn tree_A;\n\t\t}else if(operation=='u'){\n\t\t\treturn tree_B;\n\t\t}else{\n\t\t\t//exception\n\t\t} \n\n\t}else if(tree_B==\"\"){\n\n\t\tif(operation=='i'){\n\t\t\treturn tree_B;\n\t\t}else if(operation=='u'){\n\t\t\treturn tree_A;\n\t\t}else{\n\t\t\t//exception\n\t\t}\n\n\t}else{\n\n\t\tstd::string node_A[2] = \"\";\n\t\tstd::string node_B[2] = \"\";\n\t\tint period;\n\n\t\tperiod = 0;\n\t\tfor (int i = 1; i < tree_A.length()-1; ++i){\n\n\t\t\tint bracket_count = 0;\n\n\t\t\tif(tree_A[i]=='('){\n\t\t\t\tdo{\n\t\t\t\t\tnode_A[period] += tree_A[i];\n\t\t\t\t\tif(tree_A[i]=='('){\n\t\t\t\t\t\tbracket_count += 1;\n\t\t\t\t\t}else if(tree_A[i]==')'){\n\t\t\t\t\t\tbracket_count -= 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//exception\n\t\t\t\t\t}\n\t\t\t\t\ti += 1;\n\t\t\t\t}while(bracket_count>0);\n\t\t\t}\n\t\t\tperiod++;\n\t\t}\n\n\t\tperiod = 0;\n\t\tfor (int i = 1; i < tree_B.length()-1; ++i){\n\n\t\t\tint bracket_count = 0;\n\n\t\t\tif(tree_B[i]=='('){\n\t\t\t\tdo{\n\t\t\t\t\tnode_B[period] += tree_B[i];\n\t\t\t\t\tif(tree_B[i]=='('){\n\t\t\t\t\t\tbracket_count += 1;\n\t\t\t\t\t}else if(tree_B[i]==')'){\n\t\t\t\t\t\tbracket_count -= 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//exception\n\t\t\t\t\t}\n\t\t\t\t\ti += 1;\n\t\t\t\t}while(bracket_count>0);\n\t\t\t}\n\t\t\tperiod++;\n\t\t}\n\n\n\t\tstd::string node[2];\n\t\tnode[0] = binary_tree(node_A[0],node_B[0],operation);\n\t\tnode[1] = binary_tree(node_A[1],node_B[1],operation);\n\n\t\treturn \"(\" + node[0] + \",\" + node[1] + \")\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n/*\nconst int nil = -1;\nconst int MAX_N = 256;\n\nstruct Node {\n  int l, r, cnt;\n  Node() {\n    l = r = nil;\n    cnt = 0;\n  }\n};\n\nNode v[MAX_N];\nint nodeIndex;\n\nint parse(const char *s, int n, int root) {\n  v[root].cnt++;\n  if (s[++n] != ',') {\n    if (v[root].l == nil) v[root].l = ++nodeIndex;\n    n = parse(s, n, v[root].l);\n  }\n  if (s[++n] != ')') {\n    if (v[root].r == nil) v[root].r = ++nodeIndex;\n    n = parse(s, n, v[root].r);\n  }\n  return n+1;\n}\n\nvoid print(int root, int cnt) {\n  if (v[root].cnt < cnt) return;\n  putchar('(');\n  if (v[root].l != nil) print(v[root].l, cnt);\n  putchar(',');\n  if (v[root].r != nil) print(v[root].r, cnt);\n  putchar(')');\n}\n*/\nint main() {\n  char op[1024], t1[1024], t2[1024];\n  while (scanf(\"%s %s %s\", op, t1, t2) == 3) {\n    printf(\"%s\\n\", t1);\n/*\n    for (int i=0;i<MAX_N;i++) v[i] = Node();\n    nodeIndex = 0;\n    parse(t1, 0, 0);\n    parse(t2, 0, 0);\n    print(0, (op=='u'?1:2)); putchar('\\n');\n*/\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 100000\nusing namespace std;\nchar opr;\nstring T[2];\nbool tree[MAX][2]; //0->A, 1->B\nbool LR[MAX];\nbool A_tree[MAX];      \n\nvoid constructTree(bool which)\n{\n  int index = 1;\n  tree[index][which] = true;\n  rep(i,MAX)LR[i] = false;//false->L, true->true\n  int w = T[which].size();\n  REP(i,1,w)\n    {\n      if(T[which][i] == '(')\n\t{\n\t  index = index*2+(!LR[index]?0:1);\n\t  tree[index][which] = true;\n\t}\n      else if(T[which][i] == ',')\n\tLR[index] = true;\n      else\n\tindex /= 2;\n    }\n\n  assert(index == 0);\n}\n\nvoid constructTreePRST(string &PRST_tree,int index)\n{\n  PRST_tree += \"(\";\n  if(A_tree[index*2])constructTreePRST(PRST_tree,index*2);\n  PRST_tree += \",\";\n  if(A_tree[index*2+1])constructTreePRST(PRST_tree,index*2+1);\n  PRST_tree += \")\";\n}\n\nint main()\n{\n  while(cin >> opr >> T[0] >> T[1])\n    {\n      constructTree(false);\n      constructTree(true);\n\n     \n      if(opr == 'i')\n\t{\n\t  rep(i,MAX)\n\t    A_tree[i] = tree[i][0]&tree[i][1];\n\t}\n      else\n\t{\n\t  rep(i,MAX)\n\t    A_tree[i] = tree[i][0]|tree[i][1];\n\t}\n      string prst;\n      constructTreePRST(prst,1);\n      cout << prst << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <vector>\n#include <limits.h>\n#include <queue>\n#include <stack>\nusing namespace std;\nstack<int> S;\nint node[1010];\nstring getans(int p)\n{\n    if(node[p] == 0) return \"\";\n    else return \"(\"+getans(2*p)+\",\"+getans(2*p+1)+\")\";\n}\nint main()\n{\n    int treeNode1[1010],treeNode2[1010],i,j;\n    char op[2],tree1[10000],tree2[10000];\n\n    while(scanf(\"%s%s%s\",&op,&tree1,&tree2)!=EOF)\n    {\n\n        int len1 = strlen(tree1);\n        int len2 = strlen(tree2);\n        memset(treeNode1,0,sizeof(treeNode1));\n        memset(treeNode2,0,sizeof(treeNode2));\n        int cur;\n        for(i = 0;i < len1;i ++)\n        {\n            if(tree1[i] == '(')\n            {\n                if(i == 0) {S.push(1);treeNode1[1] = 1;}\n                else\n                {\n                    if(tree1[i-1] == '(')\n                    {\n                        cur = S.top();\n                        S.push(cur*2);\n                        treeNode1[cur*2] = 1;\n                    }\n                    else\n                    {\n                        cur = S.top();\n                        S.push(2*cur+1);\n                        treeNode1[cur*2+1] = 1;\n                    }\n                }\n            }\n            else if(tree1[i] == ')') S.pop();\n        }\n        for(i = 0;i < len2;i ++)\n        {\n            if(tree2[i] == '(')\n            {\n                if(i == 0) {S.push(1);treeNode2[1] = 1;}\n                else\n                {\n                    if(tree2[i-1] == '(')\n                    {\n                        cur = S.top();\n                        S.push(cur*2);\n                        treeNode2[cur*2] = 1;\n                    }\n                    else\n                    {\n                        cur = S.top();\n                        S.push(2*cur+1);\n                        treeNode2[cur*2+1] = 1;\n                    }\n                }\n            }\n            else if(tree2[i] == ')') S.pop();\n        }\n        //for(i = 0;i < 10;i ++) cout<<treeNode1[i]<<\" \";cout<<endl;\n        //for(i = 0;i < 10;i ++) cout<<treeNode2[i]<<\" \";cout<<endl;\n        if(op[0] == 'i')\n        {\n            memset(node,0,sizeof(node));\n            for(i = 0 ;i < 1010;i ++)\n            {\n                if(treeNode1[i]&&treeNode2[i]) node[i] = 1;\n            }\n            string ans;\n            ans = getans(1);\n            cout<<ans<<endl;\n        }\n        else\n        {\n            memset(node,0,sizeof(node));\n            for(i = 0 ;i < 1010;i ++)\n            {\n                if(treeNode1[i]||treeNode2[i]) node[i] = 1;\n            }\n            string ans;\n            ans = getans(1);\n            cout<<ans<<endl;\n        }\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nchar c;\nstring f(string s,string t){\n  int i,j,k;\n  if(0){\n  }else if(s.empty()&&t.empty()){\n    return \"\";\n  }else if(s.empty()||t.empty()){\n    if(c=='i')\n      return \"\";\n    else{\n      if(t.empty())\n\treturn s;\n      else\n\treturn t;\n    }\n  }else{\n    i=0;\n    for(j=1;s[j]!=','||i;j++){\n      if(0){\n      }else if(s[j]=='('){\n\ti++;\n      }else if(s[j]==')'){\n\ti--;\n      }\n    }\n    i=0;\n    for(k=1;t[k]!=','||i;k++){\n      if(0){\n      }else if(t[k]=='('){\n\ti++;\n      }else if(t[k]==')'){\n\ti--;\n      }\n    }\n    return '('+f(s.substr(1,j-1),t.substr(1,k-1))+','+f(s.substr(j+1,s.length()-j-2),t.substr(k+1,t.length()-k-2))+')';\n  }\n}\nint main(){\n  string s,t;\n  while(cin>>c){\n    cin>>s>>t;\n    cout<<f(s,t)<<endl;\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX 1000000\nusing namespace std;\nstring a,b,z;\nint d;\nstring ans;\nbool flgA[MAX];\nbool flgB[MAX];\n\nvoid rec(int x){\n\n  ans.push_back('(');\n\n  if(flgA[x*2]==true){\n    rec(x*2);\n  }\n  ans.push_back(',');\n  if(flgA[x*2+1]==true){\n    rec(x*2+1);\n  }\n\n  ans.push_back(')');\n}\n\n\nint main(){\n  while(cin>>z){\n\n    cin>>a;\n    for(int i=0;i<MAX;i++)flgA[i]=flgB[i]=false;\n    flgA[1]=flgB[1]=true;\n    \n    d=1;\n    for(int i=0;i<(int)a.size();i++){\n      if(d>=MAX)continue;\n      if(a[i]=='('){\n\tflgA[d]=true;\n\td*=2;\n      }else if(a[i]==','){\n\td=d+1;\n      }else{\n\td/=2;\n      }\n    }\n    \n      cin>>b;\n      d=1;\n      for(int i=0;i<(int)b.size();i++){\n\tif(d>=MAX)continue;\n      if(b[i]=='('){\n\tflgB[d]=true;\n\td*=2;\n      }else if(b[i]==','){\n\td=d+1;\n      }else{\n\td/=2;\n      }\n    }\n    \n\n    for(int i=0;i<MAX;i++){\n      if(flgB[i]==false){\n\tif(z==\"i\"){\n\t  flgA[i]=false;\n\t}\n      }else{\n\tif(z==\"u\"){\n\t  flgA[i]=true;\n\t}\n      }\n    }\n\n    ans=\"\";\n    rec(1);\n    cout<<ans<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=100;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  heap[id]++;\n  if(s==\"(,)\")  return;\n  \n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;   \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n      parse(sub1, 2*id+1);\n      parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nint out(int th, int id,int n){\n\n  string c(\"(,)\");\n  for(int i=0;i<3;i++)\n    output.insert(output.begin()+n+i,c[i]);\n\n  int ch1=0,ch2=0;//n of string of each child\n  \n  if(heap[id]>th){\n    if(heap[2*id+1]>th){\n      ch1=out(th,2*id+1,n+1);\n    }\n    if(heap[2*id+2]>th){\n      ch2=out(th,2*id+2,n+ch1+2);\n    }\n  }\n  return ch1+ch2+3;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  output.clear();\n  //cout<<output<<endl;\n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0,0);\n  \n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  \n  cin>>cmd>>s1>>s2;\n    solve(cmd,s1,s2);\n\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nchar op,t1[500],t2[500],isI;\nint findm(char *t,int s,int e){\n\tint d=0;\n\tfor(int i=s;i<e;i++){\n\t\tif(t[i]=='(')d++;\n\t\tif(t[i]==')')d--;\n\t\tif(d==1&&t[i]==',')return i;\n\t}\n}\nvoid calc(int s1,int e1,int s2,int e2){\n\tint f1=s1<e1,f2=s2<e2,m1=e1-1,m2=e2-1;\n\tif(f1)m1=findm(t1,s1,e1);\n\tif(f2)m2=findm(t2,s2,e2);\n\tif(isI&&f1&&f2||!isI&&(f1||f2)){\n\t\tcout<<\"(\";calc(s1+1,m1,s2+1,m2);\n\t\tcout<<\",\";calc(m1+1,e1-1,m2+1,e2-1);\n\t\tcout<<\")\";\n\t}\n}\nint main(){\n\twhile(cin>>op>>t1>>t2)isI=op=='i',calc(0,strlen(t1),0,strlen(t2)),cout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 105;\nstring dp[MAX][MAX];\n\nstring Intersect(const string& s1, const string& s2){\n  fill(dp[0],dp[0]+MAX*MAX,\"\");\n\n  for(int i = 0; i < (int)s1.length(); i++)\n    for(int j = 0; j < (int)s2.length(); j++){\n      if(s1[i] == s2[j]){\n\tstring nex = dp[i][j];\n     \tnex += s1[i];\n\tif(dp[i+1][j+1].length() < nex.length())dp[i+1][j+1] = nex;\n      }else{\n\tif(dp[i+1][j+1].length() < dp[i][j].length()) dp[i+1][j+1] = dp[i][j];\n\tif(dp[i+1][j+1].length() < dp[i+1][j].length()) dp[i+1][j+1] = dp[i+1][j];\n\tif(dp[i+1][j+1].length() < dp[i][j+1].length()) dp[i+1][j+1] = dp[i][j+1];\n      }\n    }\n\n  return dp[s1.length()][s2.length()];\n}\n\nint getRank(char c){\n  string s = \"(,)\";\n  for(int i = 0; i < (int)s.length(); i++) if(s[i] == c) return i-1;\n  return -1;\n}\nstring Union(const string& s1, const string& s2){\n  int p1 = 0, p2 = 0;\n  int d1 = 0, d2 = 0;\n  string ans = \"\";\n  \n  while(p1 < (int)s1.length() && p2 < (int)s2.length()){\n    if(s1[p1] == s2[p2]){\n      ans += s1[p1];\n      d1 -= getRank(s1[p1++]);\n      d2 -= getRank(s2[p2++]);\n    }else{\n\n      if(d1 == d2){\n\tint r1 = getRank(s1[p1]);\n\tint r2 = getRank(s2[p2]);\n\n\tif(r1 < r2){\n\t  d1 -= getRank(s1[p1]);\n\t  ans += s1[p1++];\n\t}else{\n\t  d2 -= getRank(s2[p2]);\n\t  ans += s2[p2++];\n\t}\n      }else{\n\tif(d1 > d2){\n\t  d1 -= getRank(s1[p1]);\n\t  ans += s1[p1++];\n\t}else{\n\t  d2 -= getRank(s2[p2]);\n\t  ans += s2[p2++];\n\t}\n      }\n    }\n  }\n  \n  return ans+\")\";\n}\n\nint main(){\n  char c;\n  string s1, s2;\n  while(cin >> c >> s1 >> s2){\n    if(c == 'i') cout << Intersect(s1,s2) << endl;\n    if(c == 'u') cout << Union(s1,s2) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <algorithm>\n#include <string>\n\n//typedef pair<int,int> P;\n\nusing namespace std;\n\nconst int INF=INT_MAX/3;\nconst int N=1000;\n\nint heap[N];\nstring output;\n\nvoid parse(string &s,int id){\n\n  //cout<<s<<\":\"<<id<<endl;\n  if(s.empty()) return;\n\n  heap[id]++;\n  if(s==\"(,)\") return;\n  if(id>=N) return;\n  \n  int cnt=0;\n \n  for(int i=1;i<s.length()-1;i++){\n    if(s[i]=='(') cnt++;\n    if(s[i]==')') cnt--;  \n    if(s[i]==',' && cnt==0){\n      string sub1=s.substr(1,i-1);\n      string sub2=s.substr(i+1,s.length()-i-2);\n      if(i-1>=0) parse(sub1, 2*id+1);\n      if(s.length()-i-2>=0)parse(sub2, 2*id+2);\n      break;\n    }\n  }\n  return;\n}\n\nvoid out(int th, int id){\n\n  output.push_back('(');\n\n  int ch1=0,ch2=0;//n of string of each child\n  \n  if(heap[id]>th && heap[2*id+1]>th){\n    out(th,2*id+1);\n  }\n  output.push_back(',');\n  if(heap[id]>th && heap[2*id+2]>th){\n    out(th,2*id+2);\n  }\n  \n  output.push_back(')');\n  return;\n  \n}\n\nvoid print(){\n\n  for(int i=0;i<N;i++)\n    cout<<\"[\"<<i<<\"]\"<<heap[i]<<endl;\n}\n\nvoid solve(string cmd,string &s1,string &s2){\n\n  fill(heap,heap+N,0);\n  output.clear();\n  //cout<<output<<endl;\n  parse(s1,0);\n  parse(s2,0);\n\n\n  int th=-1;\n  if(cmd==\"u\") th=0;\n  if(cmd==\"i\") th=1;\n  out(th,0);\n  \n  cout<<output<<endl;\n}\n\n\n\nint main(){\n\n  string cmd,s1,s2;\n  int i=0;\n  \n  while(cin>>cmd>>s1>>s2){\n    solve(cmd,s1,s2);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n  int a,b;\n  while(1);\n  while(cin>>a>>b) {\n    cout<<a+b<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint main() {\n  string line;\n  while (getline(cin, line)) { //convert line to string\n    stringstream stream;\n    stream << line; //convert line to stream\n    string command, tree1, tree2;\n    stream >> command >> tree1 >>  tree2; //read into respective strings\n\n    int open = 0; //open parenthesis\n    int index1 = 0, index2 = 0;\n    while (index1 < tree1.length() && index2 < tree2.length()) {\n      if (tree1[index1] == tree2[index2]) { //if same characters\n\tcout << tree1[index1];\n\tindex1++;\n\tindex2++;\n      } else  { //if different characters\n\tif (command == \"u\") cout << \"(\";\n\tif (tree1[index1] == '(') {\n\t  open++;\n\t  index1++;\n\t  while (open != 0) { // skips through discrepencies\n\t    if (tree1[index1] == '(') open++;\n\t    if (tree1[index1] == ')') open--;\n\t    if (command == \"u\") cout << tree1[index1]; //if union, print discrepencies\n\t    index1++; \n\t  }\n\t} else if (tree2[index2] == '(') {\n\t  open++;\n\t  index2++;\n\t  while (open != 0) {\n\t    if (tree2[index2] == '(') open++;\n\t    if (tree2[index2] == ')') open--;\n\t    if (command == \"u\") cout << tree2[index2];\n\t    index2++;\n\t    \n\t  }\n\t}\n      }\n     }\n     cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n \nusing namespace std;\n \nconst int nil = -1;\nconst int MAX_N = 256;\n \nstruct Node {\n  int l, r, cnt;\n  Node() {\n    l = r = nil;\n    cnt = 0;\n  }\n};\n \nNode v[MAX_N];\nint nodeIndex;\n \nint parse(const char *s, int n, int root) {\n  v[root].cnt++;\n  if (s[++n] != ',') {\n    if (v[root].l == nil) v[root].l = ++nodeIndex;\n    n = parse(s, n, v[root].l);\n  }\n  if (s[++n] != ')') {\n    if (v[root].r == nil) v[root].r = ++nodeIndex;\n    n = parse(s, n, v[root].r);\n  }\n  return n+1;\n}\n \nvoid print(int root, int cnt) {\n  if (v[root].cnt < cnt) return;\n  putchar('(');\n  if (v[root].l != nil) print(v[root].l, cnt);\n  putchar(',');\n  if (v[root].r != nil) print(v[root].r, cnt);\n  putchar(')');\n}\n \nint main() {\n  char op[5], t1[1024], t2[1024];\n  while (scanf(\"%s %s %s\", op, t1, t2) == 3) {\n    for (int i=0;i<MAX_N;i++) v[i] = Node();\n    nodeIndex = 0;\n    parse(t1, 0, 0);\n    parse(t2, 0, 0);\n    print(0, (op[0]=='u'?1:2)); putchar('\\n');\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n\nusing namespace std;\n\nconst int SIZE = 256;\nbool A[SIZE],B[SIZE],C[SIZE];\n\nint getPos(const string& s){\n  int p = 0;\n  for(int i = 0; i < (int)s.length(); i++){\n    if(s[i] == '(') p++;\n    else if(s[i] == ')') p--;\n    if(p == 0 && s[i] == ',') return i;\n  }\n  return -1;\n}\n\nvoid parse(const string& s, bool* tree, int idx){\n  if(s == \"\") return;\n  tree[idx] = true;\n  string nex = s.substr(1,s.length()-2);\n  int pos = getPos(nex);\n  string left = nex.substr(0,pos);\n  string right = nex.substr(pos+1);\n  parse(left,tree,2*idx+1);\n  parse(right,tree,2*idx+2);\n}\n\nstring makeTree(bool* tree, int idx){\n  if(!tree[idx]) return \"\";\n  string res = \"\";\n  if(2*idx+1 < SIZE) res += makeTree(tree,2*idx+1);\n  res += \",\";\n  if(2*idx+2 < SIZE) res += makeTree(tree,2*idx+2);\n  res = \"(\" + res + \")\";\n  return res;\n}\n\nint main(){\n\n  char c;\n  string a,b;\n  while(cin >> c >> a >> b){\n    memset(A,false,sizeof(A));\n    memset(B,false,sizeof(B));\n    memset(C,false,sizeof(C));\n    parse(a,A,0);\n    parse(b,B,0);\n    if(c=='i') for(int i = 0; i < SIZE; i++) C[i] = A[i]&&B[i];\n    else for(int i = 0; i < SIZE; i++) C[i] = A[i]||B[i];\n    cout << makeTree(C,0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream> \n#include<string>\n#include<stack>\n#include<utility>\n\nusing namespace std;\n\nint main(void){\n\n\tstring ans;\n\tchar inp;\n\t\n\tstack<pair<char,int> > tree1,tree2;\n\tstring oper;\n\n\twhile(cin>>oper){\n\t\tinp=getchar();\n\t\twhile(1){\n\t\t\tinp=getchar();\n\t\t\tif(inp==' ') break;\n\t\t\tswitch(inp){\n\t\t\tcase '(':\n\t\t\t\tif(tree1.empty()) tree1.push(pair<char,int>(inp,0));\n\t\t\t\telse tree1.push(pair<char,int>(inp,tree1.top().second +1));\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\ttree1.push(pair<char,int>(inp,tree1.top().second -1));\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\ttree1.push(pair<char,int>(inp,tree1.top().second));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tinp=getchar();\n\t\t\tif(inp=='\\n') break;\n\t\t\tswitch(inp){\n\t\t\tcase '(':\n\t\t\t\tif(tree2.empty()) tree2.push(pair<char,int>(inp,0));\n\t\t\t\telse tree2.push(pair<char,int>(inp,tree2.top().second +1));\n\t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\ttree2.push(pair<char,int>(inp,tree2.top().second -1));\n\t\t\t\tbreak;\n\t\t\tcase ',':\n\t\t\t\ttree2.push(pair<char,int>(inp,tree2.top().second));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tans=\")\";\n\t\ttree1.pop(),tree2.pop();\n\t\twhile(!tree1.empty()&&!tree2.empty()){\n\t\t\tcout<<tree1.top().first<<tree1.top().second<<tree2.top().first<<tree2.top().second<<endl;\n\n\t\t\tif(tree1.top().second==tree2.top().second){\n\t\t\t\tif(tree1.top().first==tree2.top().first){\n\t\t\t\t\tans+=tree1.top().first;\n\t\t\t\t\ttree1.pop(),tree2.pop();\n\t\t\t\t}\n\t\t\t\telse if(tree1.top().first=='('&&tree2.top().first==')'){\n\t\t\t\t\tif(oper==\"u\") ans+=tree2.top().first;\n\t\t\t\t\ttree2.pop();\n\t\t\t\t}\n\t\t\t\telse if(tree1.top().first==')'&&tree2.top().first=='('){\n\t\t\t\t\tif(oper==\"u\") ans+=tree1.top().first;\n\t\t\t\t\ttree1.pop();\n\t\t\t\t}\n\t\t\t\telse if(tree1.top().first==','){\n\t\t\t\t\tif(oper==\"u\") ans+=tree2.top().first;\n\t\t\t\t\ttree2.pop();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(oper==\"u\") ans+=tree1.top().first;\n\t\t\t\t\ttree1.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(tree1.top().second>tree2.top().second){\n\t\t\t\tif(oper==\"u\") ans+=tree1.top().first;\n\t\t\t\ttree1.pop();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(oper==\"u\") ans+=tree2.top().first;\n\t\t\t\ttree2.pop();\n\t\t\t}\n\t\t}\n\t\tfor(int i=ans.length()-1;i>=0;i--){\n\t\t\tcout<<ans[i];\n\t\t}\n\t\tcout<<endl;\n\t}\n\t\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n\nusing namespace std;\n\nstring tree[2];\nbitset<200000000> node[2];\n\nvoid perse(int index, int n, int i)\n{\n  //cout << \"persed \" << n << endl;\n  if (index >= tree[i].size()) {\n    return;\n  }\n  if (tree[i][index] == '(') {\n    while (tree[i][index] == ' ') {index++;}\n    node[i][n] = true;\n    perse(index + 1, 2 * n + 1, i);\n  } else if (tree[i][index] == ')') {\n    while (tree[i][index] == ' ') {index++;}\n    perse(index + 1, (((n - 2) / 2 < 0) ? 0 : (n - 2) / 2), i);\n  } else if (\",\"){\n    while (tree[i][index] == ' ') {index++;}\n    perse(index + 1, n + 1, i);\n  }\n}\n\nstring _perse(int index)\n{\n  if (node[0][index]) {\n    return \"(\" + _perse(2 * index + 1) + \",\" + _perse(2 * index + 2) + \")\";\n  }\n  return \"\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    for (int i = 0; i < 2; i++) {\n      node[i].reset();\n      perse(0, 0, i);\n      \n      /*for (int j = 0; j < 300; j++) {\n\tif (node[i][j]) {\n\t  cout << j;\n\t}\n      }\n      cout << endl;*/\n    }\n    if (ex == 'u') {\n      node[0] |= node[1];\n    } else {\n      node[0] &= node[1];\n    }\n    cout << _perse(0) << endl;\n    cin.ignore();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n}\n s"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node{\n    Node *left;\n    Node *right;\n    Node() { left = NULL, right = NULL; }\n};\n\nint findcc(string s) {\n    int dd = 0;\n    for(int i=0; i<s.length(); ++i) {\n        if(s[i] == '(') dd++;\n        else if(s[i] == ')') dd--;\n        else if(s[i] == ',' && dd == 1) return i;\n    }\n    return -1;\n}\n\nNode* parse(string s) {\n    Node *r = new Node();\n    int ff = findcc(s);\n    if(ff != 1) r->left = parse(s.substr(1,ff-1));\n    if(ff != s.length()-2) {\n        string tmp = s.substr(ff+1);\n        r->right = parse(tmp.substr(0,tmp.length()-1));\n    }\n    return r;\n}\n\nNode *intersect(Node *r1,Node *r2) {\n    Node *ret = new Node();\n    if(r1->left != NULL && r2->left != NULL)\n        ret->left = intersect(r1->left,r2->left);\n\n    if(r1->right != NULL && r2->right != NULL)\n        ret->right = intersect(r1->right,r2->right);\n\n    return ret;\n}\n\nNode* uni(Node *r1,Node *r2) {\n    if(r1 == NULL && r2 == NULL) return NULL;\n\n    Node *ret = new Node();\n    ret->left = uni(((r1 == NULL)?NULL:r1->left),(r2 == NULL)?NULL:r2->left);\n    ret->right = uni(((r1 == NULL)?NULL:r1->right),(r2 == NULL)?NULL:r2->right);\n    return ret;\n}\n\nstring toStr(Node *tree) {\n    string res = \"(\";\n    if(tree->left != NULL) res += toStr(tree->left);\n    res += \",\";\n    if(tree->right != NULL) res += toStr(tree->right);\n    res += \")\";\n    return res;\n}\n\nvoid treedel(Node *node) {\n    if(node->left != NULL) treedel(node->left);\n    if(node->right != NULL) treedel(node->right);\n    delete node;\n    return;\n}\n\nint main() {\n    string op,t1,t2;\n    while(cin>>op>>t1>>t2) {\n        Node *r1 = parse(t1);\n        Node *r2 = parse(t2);\n        Node *ans;\n        if(op == \"i\") ans = intersect(r1,r2);\n        else if(op == \"u\") ans = uni(r1,r2);\n\n        cout<<toStr(ans)<<endl;\n        treedel(r1); treedel(r2); treedel(ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define X first\n#define Y second\n\nusing namespace std;\n\nstring tree(const string &s, int &pos){\n\tstring chl, chr;\n\t++pos;\n\tif (s[pos] == '(') chl = tree(s, pos);\n\t++pos;\n\tif (s[pos] == '(') chr = tree(s, pos);\n\t++pos;\n\treturn \"(\" + chl + \",\" + chr + \")\";\n}\n\nchar c;\nstring a, b;\nint p1, p2;\n\nstring AND(){\n\t++p1, ++p2;\n\n\tstring chl, chr;\n\tif (a[p1] == '(' && b[p2] == '('){\n\t\tchl = AND();\n\t}\n\telse if (a[p1] == '('){\n\t\ttree(a, p1);\n\t}\n\telse if (b[p2] == '('){\n\t\ttree(b, p2);\n\t}\n\n\t++p1, ++p2;\n\n\tif (a[p1] == '(' && b[p2] == '('){\n\t\tchr = AND();\n\t}\n\telse if (a[p1] == '('){\n\t\ttree(a, p1);\n\t}\n\telse if (b[p2] == '('){\n\t\ttree(b, p2);\n\t}\n\n\t++p1, ++p2;\n\n\treturn \"(\" + chl + \",\" + chr + \")\";\n}\n\nstring OR(){\n\t++p1, ++p2;\n\n\tstring chl, chr;\n\tif (a[p1] == '(' && b[p2] == '('){\n\t\tchl = OR();\n\t}\n\telse if (a[p1] == '('){\n\t\tchl = tree(a, p1);\n\t}\n\telse if (b[p2] == '('){\n\t\tchl = tree(b, p2);\n\t}\n\n\t++p1, ++p2;\n\n\tif (a[p1] == '(' && b[p2] == '('){\n\t\tchr = OR();\n\t}\n\telse if (a[p1] == '('){\n\t\tchr = tree(a, p1);\n\t}\n\telse if (b[p2] == '('){\n\t\tchr = tree(b, p2);\n\t}\n\n\t++p1, ++p2;\n\n\treturn \"(\" + chl + \",\" + chr + \")\";\n}\n\nint main(){\n\twhile (cin >> c >> a >> b){\n\t\tp1 = p2 = 0;\n\n\t\tif (c == 'i') cout << AND() << endl;\n\t\telse cout << OR() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nchar c;string s,t;\nint a,b;\nvoid f(){\n\twhile(1){\n\t\tif(a==s.size()&&b==t.size())break;\n\t\tif(s[a]==t[b]){\n\t\t\tcout<<s[a];\n\t\t\ta++;b++;\n\t\t}else if(s[a]=='('){\n\t\t\tint co=0;\n\t\t\twhile(1){\n\t\t\t\tif(s[a]=='(')co++;\n\t\t\t\telse if(s[a]==')')co--;\n\t\t\t\tif(c=='u')cout<<s[a];\n\t\t\t\ta++;\n\t\t\t\tif(co==0)break;\n\t\t\t}\n\t\t}else{\n\t\t\tint co=0;\n\t\t\twhile(1){\n\t\t\t\tif(t[b]=='(')co++;\n\t\t\t\telse if(t[b]==')')co--;\n\t\t\t\tif(c=='u')cout<<t[b];\n\t\t\t\tb++;\n\t\t\t\tif(co==0)break;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>c>>s>>t){\n\t\ta=b=0;\n\t\tf();\n\t\tcout<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"set>.cpp\"\n#include \"set>.cpp\"\n#include <iostream>\ntemplate<class T>class L{L<T*>operator->()};L<int>i=i->\n\nint main(){\n while(1){\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n//#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\nstruct Tree\n{\n  bool root;\n  bool child[2];\n  Tree *next[2];//left -> false, right -> true\n  Tree()\n  {\n    child[0] = child[1] = false;\n    root=false;\n  }\n};\n\nstring s[2];\nTree tree[2];\n\nvoid init()\n{\n  tree[0].root = tree[1].root = true;\n  rep(i,2)\n    {\n      tree[i].child[0] = tree[i].child[1] = false;\n      delete tree[i].next[0];\n      delete tree[i].next[1];\n    }\n}\n\nvoid parse(int index,int &pos,Tree *t,int depth)\n{\n  if(pos >= s[index].size())return;\n  //assert(s[index][pos] == '('); \n  bool LR = false;\n\n  ++pos;\n  while(pos < s[index].size() && !(LR && s[index][pos] == ')'))\n    {\n\n      if(s[index][pos] == '(')\n\t{\n\t  t->next[LR] = new Tree;\n\t  t->next[LR]->root = false;\n\t  t->next[LR]->child[0] = t->next[LR]->child[1] = false;\n\t  t->child[LR] = true;\n\t  parse(index,pos,t->next[LR],depth+1);\n\t}\n      if(s[index][pos] == ',') LR = true;\n\t\n      ++pos;\n    }\n  ++pos;\n}\n\nvoid tree_walk(Tree *t,int depth)\n{\n  cout << '(';\n  if(t->child[0])tree_walk(t->next[0],depth+1);\n  cout << ',';\n  if(t->child[1])tree_walk(t->next[1],depth+1);\n  cout << ')';\n}\n\nvoid dfs_i(Tree *t1,Tree *t2,Tree *ans)\n{\n  if(t1->child[0] && t2->child[0])\n    {\n      ans->next[0] = new Tree;\n      ans->child[0] = true;\n      ans->next[0]->child[0] = ans->next[0]->child[1] = false;\n      dfs_i(t1->next[0],t2->next[0],ans->next[0]);\n    }\n\n  if(t1->child[1] && t2->child[1])\n    {\n      ans->next[1] = new Tree;\n      ans->child[1] = true;\n      ans->next[1]->child[0] = ans->next[1]->child[1] = false;\n      dfs_i(t1->next[1],t2->next[1],ans->next[1]);\n    }\n\n}\n\nvoid dfs_u(Tree *t,Tree *ans)\n{\n  if(t->child[0])\n    {\n      if(ans->child[0])\n\t{//already exists\n\t  dfs_u(t->next[0],ans->next[0]);\n\t}\n      else\n\t{//not yet\n\t  ans->next[0] = new Tree;\n\t  ans->child[0] = true;\n\t  ans->next[0]->child[0] = ans->next[0]->child[1] = false;\n\t  dfs_u(t->next[0],ans->next[0]);\n\t}\n    }\n\n  if(t->child[1])\n    {\n      if(ans->child[1])\n\t{//already exists\n\t  dfs_u(t->next[1],ans->next[1]);\n\t}\n      else\n\t{//not yet\n\t  ans->next[1] = new Tree;\n\t  ans->child[1] = true;\n\t  ans->next[1]->child[0] = ans->next[1]->child[1] = false;\n\t  dfs_u(t->next[1],ans->next[1]);\n\t}\n    }\n\n}\n\nvoid compute(char c)\n{\n  Tree ans;\n  ans.root = true;\n  ans.child[0] = ans.child[1] = false;\n  if(c == 'i')\n    {\n      dfs_i(&tree[0],&tree[1],&ans);\n      tree_walk(&ans,0);\n      cout << endl;\n    }\n  else if(c == 'u')\n    {\n      dfs_u(&tree[0],&ans);\n      dfs_u(&tree[1],&ans);\n      tree_walk(&ans,0);\n      cout << endl;\n    }\n}\n\n//deleteまわりも後で書く\n\nint main()\n{\n\n  char c;\n  while(cin >> c)\n    {\n      cin >> s[0] >> s[1];\n      init();\n\n      int pos;\n      rep(i,2)\n\t{\n\t  pos = 0;\n\t  parse(i,pos,&tree[i],0);\n\t  //cerr << \"output the tree[\" << i << \"]\" << endl;\n\t  //tree_walk(&tree[i],0);\n\t  //cout << endl;\n\t}\n\n      compute(c);\n   \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n}\n s"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <string>\n#include <iostream>\n\n\nusing namespace std;\n\nvoid make_tree(bool* tree, int node, string s)\n{\n\tif (s.empty())\n\t\treturn;\n\n\ttree[node] = true;\n\n\tint paren = 0;\n\tint i;\n\tfor (i = 1; paren != 0 || s[i] != ','; ++i)\n\t{\n\t\tif (s[i] == '(')\n\t\t\t++paren;\n\t\telse if (s[i] == ')')\n\t\t\t--paren;\n\t}\n\tmake_tree(tree, node*2+1, s.substr(1, i-1));\n\tmake_tree(tree, node*2+2, s.substr(i+1, s.size()-i-2));\n}\n\nvoid print_tree(bool* tree, int node)\n{\n\tif (!tree[node])\n\t\treturn;\n\n\tputchar('(');\n\tprint_tree(tree, node*2+1);\n\tputchar(',');\n\tprint_tree(tree, node*2+2);\n\tputchar(')');\n}\n\nint main()\n{\n\tconst int TreeSize = 512;\n\tchar ope;\n\tstring s1, s2;\n\tbool tree1[TreeSize], tree2[TreeSize], opedTree[TreeSize];\n\twhile (cin >> ope >> s1 >> s2)\n\t{\n\t\tfill(tree1, tree1+TreeSize, false);\n\t\tfill(tree2, tree2+TreeSize, false);\n\n\t\tmake_tree(tree1, 0, s1);\n\t\tmake_tree(tree2, 0, s2);\n\n\t\tif (ope == 'i')\n\t\t\tfor (int i = 0; i < TreeSize; ++i)\n\t\t\t\topedTree[i] = tree1[i] & tree2[i];\n\t\telse\n\t\t\tfor (int i = 0; i < TreeSize; ++i)\n\t\t\t\topedTree[i] = tree1[i] | tree2[i];\n\n\t\tprint_tree(opedTree, 0);\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <string>\n#include <stack>\nusing namespace std;\n\nconst int maxn=5*1000;\n\nint f[maxn],g[maxn];\nbool isfalse[maxn];\nstack <int> s;\nstring s1,s2;\nstring c;\nint  l1,l2;\n\n\nstring dfs1(int i)\n{\n    string lchild = \"\",rchild = \"\";\n    if (f[2*i]!=-1 && g[2*i]!=-1) lchild = dfs1(2*i);\n    if (f[2*i+1]!=-1 && g[2*i+1]!=-1) rchild = dfs1(2*i+1);\n    return \"(\" + lchild + \",\" + rchild + \")\";\n}\n\nstring dfs2(int i)\n{\n    string lchild = \"\",rchild = \"\";\n    if (f[2*i]!=-1 || g[2*i]!=-1) lchild = dfs2(2*i);\n    if (f[2*i+1]!=-1 || g[2*i+1]!=-1) rchild = dfs2(2*i+1);\n    return \"(\" + lchild + \",\" + rchild + \")\";\n}\n\n\nint main()\n{\n    while (cin>>c>>s1>>s2)\n    {\n        l1 = s1.length(); l2 = s2.length();\n\n        memset(f,-1,sizeof(f));\n        memset(g,-1,sizeof(g));\n        memset(isfalse,false,sizeof(isfalse));\n\n        while (!s.empty()) s.pop();\n\n        int i=0; int cnt=0;\n        while (i < l1)\n        {\n            if (s1[i] == '(')\n            {\n                cnt++;\n                s.push(cnt);\n                if (i+1 < l1 && s1[i+1]==',')\n                {\n                    cnt++;\n                    isfalse[cnt]=true;\n                }\n            }\n            else if (s1[i]==')')\n            {\n\n                int ch = s.top(); s.pop();\n                if (!s.empty())\n                {\n                    int fa = s.top();\n                    if (ch==fa+1) f[2*fa]=ch;\n                    else f[2*fa+1] = ch;\n                }\n            }\n            else if (s1[i]==',')\n            {\n                if (i+1 < l1 && s1[i+1]==')')\n                {\n                    cnt++;\n                    isfalse[cnt]=true;\n                }\n            }\n            i++;\n        }\n\n\n        //for (int i=1;i<=cnt;i++) if (!isfalse[i]) cout<<i<<\" \"<<f[2*i]<<\" \"<<f[2*i+1]<<endl;\n\n        while (!s.empty()) s.pop();\n        i = 0; cnt = 0;\n        while (i < l2)\n        {\n            if (s2[i] == '(')\n            {\n                cnt++;\n                s.push(cnt);\n                if (i+1 < l2 && s2[i+1]==',')\n                {\n                    cnt++;\n                    isfalse[cnt]=true;\n                }\n            }\n            else if (s2[i]==')')\n            {\n                int ch = s.top(); s.pop();\n                if (!s.empty())\n                {\n                    int fa = s.top();\n                    if (ch==fa+1) g[2*fa] = ch;\n                    else g[2*fa+1] = ch;\n                }\n            }\n            else if (s2[i]==',')\n            {\n                if (i+1 < l2 && s2[i+1]==')')\n                {\n                    cnt++;\n                    isfalse[cnt]=true;\n                }\n            }\n            i++;\n        }\n\n        //for (int i=1;i<=cnt;i++) if (!isfalse[i]) cout<<i<<\" \"<<g[2*i]<<\" \"<<g[2*i+1]<<endl;\n\n        if (c[0]=='i') cout<<dfs1(1)<<endl;\n        else cout<<dfs2(1)<<endl;\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n\nint main(){\n    std::cout << \"Hello World!\" << std::endl;\n    return 0;\n}\n        \n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<string.h>\nusing namespace std;\nchar ty[3];\nchar A[10000];\nchar B[10000];\nstring solve(int al,int ar,int bl,int br){\n\tint has=0;\n\tint am,bm;\n\tfor(int i=al;i<ar;i++){\n\t\tif(A[i]=='(')has++;\n\t\telse if(A[i]==')')has--;\n\t\tif(has==1&&A[i]==','){\n\t\t\tam=i;break;\n\t\t}\n\t}\n\thas=0;\n\tfor(int i=bl;i<br;i++){\n\t\tif(B[i]=='(')has++;\n\t\telse if(B[i]==')')has--;\n\t\tif(has==1&&B[i]==','){\n\t\t\tbm=i;break;\n\t\t}\n\t}\n\tstring ret=\"(\";\n\tif(al+1==am){\n\t\tif(ty[0]=='u'){\n\t\t\tfor(int i=bl+1;i<bm;i++)ret+=B[i];\n\t\t}\n\t}else if(bl+1==bm){\n\t\tif(ty[0]=='u'){\n\t\t\tfor(int i=al+1;i<am;i++)ret+=A[i];\n\t\t}\n\t}else{\n\t\tret+=solve(al+1,am,bl+1,bm);\n\t}\n\tret+=\",\";\n\tif(am+1==ar-1){\n\t\tif(ty[0]=='u'){\n\t\t\tfor(int i=bm+1;i<br-1;i++)ret+=B[i];\n\t\t}\n\t}else if(bm+1==br-1){\n\t\tif(ty[0]=='u'){\n\t\t\tfor(int i=am+1;i<ar-1;i++)ret+=A[i];\n\t\t}\n\t}else{\n\t\tret+=solve(am+1,ar-1,bm+1,br-1);\n\t}\n\tret+=\")\";\n\t//printf(\"%d %d %d %d: %s\\n\",al,ar,bl,br,ret.c_str());\n\treturn ret;\n}\nint main(){\n\twhile(~scanf(\"%s%s%s\",ty,A,B)){\n\t\tint an=strlen(A);\n\t\tint bn=strlen(B);\n\t\tprintf(\"%s\\n\",solve(0,an,0,bn).c_str());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<eps)\nbool tree[2][105];\nbool ans[105];\nstring Tree[2];\nvoid string_to_tree(int n,int k,int l,int r)\n{\n\ttree[n][k]=true;\n\tint cnt=0,node;\n\tfor(int i=l+1;i<r;i++)\n\t{\n\t\tif(Tree[n][i]=='(')cnt++;\n\t\tif(Tree[n][i]==')')cnt--;\n\t\tif(Tree[n][i]==','&&cnt==0)\n\t\t{\n\t\t\tnode=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(Tree[n][node-1]=='('&&Tree[n][node+1]==')')return;\n\tif(Tree[n][node+1]==')')string_to_tree(n,k*2+1,l+1,node-1);\n\telse if(Tree[n][node-1]=='(')string_to_tree(n,k*2+2,node+1,r-1);\n\telse\n\t{\n\t\tstring_to_tree(n,k*2+1,l+1,node-1);\n\t\tstring_to_tree(n,k*2+2,node+1,r-1);\n\t}\n\treturn;\n}\nstring Ans;\nvoid unite()\n{\n\tfor(int i=0;i<105;i++)if(tree[0][i]||tree[1][i])ans[i]=true;\n\treturn;\n}\nvoid intersect()\n{\n\tfor(int i=0;i<105;i++)if(tree[0][i]&&tree[1][i])ans[i]=true;\n\treturn;\n}\nvoid tree_to_string(int k)\n{\n\tif(!ans[k])return;\n\tAns+='(';\n\ttree_to_string(k*2+1);\n\tAns+=',';\n\ttree_to_string(k*2+2);\n\tAns+=')';\n\treturn;\n}\nint main()\n{\n\tstring op;\n\twhile(cin >> op >> Tree[0] >> Tree[1])\n\t{\n\t\tAns.clear();\n\t\tmemset(tree,false,sizeof(tree));\n\t\tmemset(ans,false,sizeof(ans));\n\t\tstring_to_tree(0,0,0,((int)Tree[0].size())-1);\n\t\tstring_to_tree(1,0,0,((int)Tree[1].size())-1);\n\t\tif(op==\"u\")unite();\n\t\telse intersect();\n\t\ttree_to_string(0);\n\t\tcout << Ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nconst int nil = -1;\nconst int MAX_N = 256;\n\nstruct Node {\n  int l, r, cnt;\n  Node() {\n    l = r = nil;\n    cnt = 0;\n  }\n};\n\nNode v[MAX_N];\nint nodeIndex;\n\nint parse(const char *s, int n, int root) {\n  v[root].cnt++;\n  if (s[++n] != ',') {\n    if (v[root].l == nil) v[root].l = ++nodeIndex;\n    n = parse(s, n, v[root].l);\n  }\n  if (s[++n] != ')') {\n    if (v[root].r == nil) v[root].r = ++nodeIndex;\n    n = parse(s, n, v[root].r);\n  }\n  return n+1;\n}\n\nvoid print(int root, int cnt) {\n  if (v[root].cnt < cnt) return;\n  putchar('(');\n  if (v[root].l != nil) print(v[root].l, cnt);\n  putchar(',');\n  if (v[root].r != nil) print(v[root].r, cnt);\n  putchar(')');\n}\n\nint main() {\n  char op[10], t1[1024], t2[1024];\n  while (scanf(\"%s %s %s\", op, t1, t2) == 3) {\n    for (int i=0;i<MAX_N;i++) v[i] = Node();\n    nodeIndex = 0;\n    parse(t1, 0, 0);\n    parse(t2, 0, 0);\n    print(0, (op=='u'?1:2)); putchar('\\n');\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 1005;\nstring dp[MAX][MAX];\n\nstring Intersect(const string& s1, const string& s2){\n  fill(dp[0],dp[0]+MAX*MAX,\"\");\n\n  for(int i = 0; i < (int)s1.length(); i++)\n    for(int j = 0; j < (int)s2.length(); j++){\n      if(s1[i] == s2[j]){\n\tstring nex = dp[i][j];\n     \tnex += s1[i];\n\tif(dp[i+1][j+1].length() < nex.length())dp[i+1][j+1] = nex;\n      }else{\n\tif(dp[i+1][j+1].length() < dp[i][j].length()) dp[i+1][j+1] = dp[i][j];\n\tif(dp[i+1][j+1].length() < dp[i+1][j].length()) dp[i+1][j+1] = dp[i+1][j];\n\tif(dp[i+1][j+1].length() < dp[i][j+1].length()) dp[i+1][j+1] = dp[i][j+1];\n      }\n    }\n\n  return dp[s1.length()][s2.length()];\n}\n\nint getRank(char c){\n  string s = \"(,)\";\n  for(int i = 0; i < (int)s.length(); i++) if(s[i] == c) return i-1;\n  return -1;\n}\n\nstring Union(const string& s1, const string& s2){\n  int p1 = 0, p2 = 0;\n  int d1 = 0, d2 = 0;\n  string ans = \"\";\n  \n  while(p1 < (int)s1.length() && p2 < (int)s2.length()){\n    if(s1[p1] == s2[p2]){\n      ans += s1[p1];\n      d1 -= getRank(s1[p1++]);\n      d2 -= getRank(s2[p2++]);\n    }else{\n\n      if(d1 == d2){\n\tint r1 = getRank(s1[p1]);\n\tint r2 = getRank(s2[p2]);\n\n\tif(r1 < r2){\n\t  d1 -= getRank(s1[p1]);\n\t  ans += s1[p1++];\n\t}else{\n\t  d2 -= getRank(s2[p2]);\n\t  ans += s2[p2++];\n\t}\n      }else{\n\tif(d1 > d2){\n\t  d1 -= getRank(s1[p1]);\n\t  ans += s1[p1++];\n\t}else{\n\t  d2 -= getRank(s2[p2]);\n\t  ans += s2[p2++];\n\t}\n      }\n    }\n  }\n  \n  return ans+\")\";\n}\n\nint main(){\n  char c;\n  string s1, s2;\n  while(cin >> c >> s1 >> s2){\n    if(c == 'i') cout << Intersect(s1,s2) << endl;\n    if(c == 'u') cout << Union(s1,s2) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n}\n s"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n#include <algorithm>\n\nusing namespace std;\n\nstring tree[2];\n\nstring uni(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    if (tree[1][index1] != ',') \n      for (;tree[1][index1] != ','; index1++) {\n\tleft = left + tree[1][index1];\n      }\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[0][index0] != ','; index0++) {\n      left = left + tree[0][index0];\n    }\n  } else {\n    left = uni(index0 + 1, index1 + 1);\n    for (;tree[0][index0] != ','; index0++);\n    for (;tree[1][index1] != ','; index1++);\n  }\n\n  if (tree[0][index0 + 1] == ')') {\n    int c = 0;\n    index1++;\n    while (true) {\n      if (c == 0 && tree[1][index1] == ')') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      right = right + tree[1][index1];\n      index1++;\n    }\n  } else if (tree[1][index1 + 1] == ')') {\n    int c = 0;\n    index0++;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ')') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      right = right + tree[0][index0];\n      index0++;\n    }\n  } else {\n    right = uni(index0 + 1, index1 + 1);\n  }\n  return \"(\" + left + \",\" + right + \")\";\n}\n\nstring inter(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[1][index1] != ','; index1++);\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[0][index0] != ','; index0++);\n  } else {\n    left = inter(index0 + 1, index1 + 1);\n    for (;tree[0][index0] != ','; index0++);\n    for (;tree[1][index1] != ','; index1++);\n  }\n  \n  if (tree[0][index0 + 1] == ')' || tree[1][index1 + 1] == ')') {\n    right = \"\";\n  } else {\n    right = inter(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    if (ex == 'i') {\n      cout << inter(0, 0) << endl;\n    } else {\n      cout << uni(0, 0) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\n\nstruct Xcsr {\n    int depth;\n    string::iterator c;\n};\n\nint main() {\n    char op;\n    string ex1, ex2;\n    int i;\n\n    while (cin >> op >> ex1 >> ex2) {\n\n        Xcsr x[2], *xa, *xb;\n        x[0].depth = x[1].depth = 0;\n        x[0].c = ex1.begin();\n        x[1].c = ex2.begin();\n        string result;\n        while (x[0].c != ex1.end() || x[1].c != ex2.end()) {\n\n            for (i = 0; i < 2; i++) {\n                if (*(x[i].c) == '(') {\n                    x[i].depth++;\n                }\n                else if (*(x[i].c) == ')') {\n                    x[i].depth--;\n                }\n            }\n            if (*(x[0].c) == *(x[1].c) && x[0].depth == x[1].depth) {\n                result += *(x[0].c);\n            }\n            else {\n                if (x[0].depth > x[1].depth) {\n                    xa = &x[0];\n                    xb = &x[1];\n                }\n                else {\n                    xa = &x[1];\n                    xb = &x[0];\n                }\n                while (*(xa->c) != *(xb->c) || xa->depth != xb->depth) {\n                    if (op == 'u') result += *(xa->c);\n                    xa->c++;\n                    if (*(xa->c) == '(') {\n                        xa->depth++;\n                    }\n                    else if (*(xa->c) == ')') {\n                        xa->depth--;\n                    }\n                }\n                result += *(x[0].c);\n            }\n            x[0].c++;\n            x[1].c++;\n        }\n        cout << result << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstring intersection(string tree1, string tree2);\nstring tunion(string tree1, string tree2);\nint camma_pos(string tree);\n\n\nint camma_pos(string tree){\n\tint i, camma_p;\n\tint braket = 0;\n\tfor(i = 0; i < tree.size(); i++){\n\t\tif(tree[i] == '('){\n\t\t\tbraket++;\n\t\t}else if(tree[i] == ')'){\n\t\t\tbraket--;\n\t\t}\n\t\tif((tree[i] == ',') && (braket == 1)){\n\t\t\tcamma_p = i;\n\t\t}\n\t} \n\treturn camma_p;\n}\n\nstring intersection(string tree1, string tree2){\n\tint i;\n\tint braket = 0;\n\tint camma_p1, camma_p2;\n\tstring tree1_l, tree1_r;\n\tstring tree2_l, tree2_r;\n\tstring left, right;\n\tif(tree1.size() == 0 || tree2.size() == 0){\n\t\treturn \"\";\n\t}\n\tcamma_p1 = camma_pos(tree1);\n\tcamma_p2 = camma_pos(tree2);\n\ttree1_l = tree1.substr(1,camma_p1-1);\n\ttree1_r = tree1.substr(camma_p1+1, tree1.size() - camma_p1 - 2);\n\ttree2_l = tree2.substr(1,camma_p2-1);\n\ttree2_r = tree2.substr(camma_p2+1, tree2.size() - camma_p2 - 2);\n\tleft = intersection(tree1_l, tree2_l);\n\tright = intersection(tree1_r, tree2_r);\n\treturn \"(\" + left + \",\" + right + \")\";\n}\n\nstring tunion(string tree1, string tree2){\n\tint i;\n\tint braket = 0;\n\tint camma_p1, camma_p2;\n\tstring tree1_l, tree1_r;\n\tstring tree2_l, tree2_r;\n\tstring left, right;\n\tif(tree1.size() == 0){\n\t\treturn tree2;\n\t}\n\tif(tree2.size() == 0){\n\t\treturn tree1;\n\t}\n\tcamma_p1 = camma_pos(tree1);\n\tcamma_p2 = camma_pos(tree2);\n\ttree1_l = tree1.substr(1,camma_p1-1);\n\ttree1_r = tree1.substr(camma_p1+1, tree1.size() - camma_p1 - 2);\n\ttree2_l = tree2.substr(1,camma_p2-1);\n\ttree2_r = tree2.substr(camma_p2+1, tree2.size() - camma_p2 - 2);\n\tleft = tunion(tree1_l, tree2_l);\n\tright = tunion(tree1_r, tree2_r);\n\treturn \"(\" + left + \",\" + right + \")\";\n}\n\nint main(){\n\tchar ui;\n\tstring tree1, tree2, treeans;\n\twhile(cin >> ui >> tree1 >> tree2){\n\t\tif(ui == 'i'){\n\t\t\ttreeans = intersection(tree1, tree2);\n\t\t}else{\n \t\t\ttreeans = tunion(tree1, tree2);\n\t\t}\n\t\tcout << treeans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <stack>\nusing namespace std;\n\n#define SIZE 10000\n\nvector <int> getTree( string in )\n{\n\tvector <int> tree( SIZE, 0 );\n\n\tint n = 1;\n\tint lr = 0;\n\tstack <int> lrs;\n\n\tlrs.push( 0 );\n\n\tfor ( string::iterator it = in.begin(); it != in.end(); it++ )\n\t{\n\t\tswitch( *it )\n\t\t{\n\t\tcase '(':\n\t\t\tn *= 2;\n\t\t\ttree[n+lr] = 1;\n\t\t\tlrs.push( lr );\n\t\t\tlr = 0;\n\t\t\tbreak;\n\n\t\tcase ')':\n\t\t\tn /= 2;\n\t\t\tlr = lrs.top();\n\t\t\tlrs.pop();\n\t\t\tbreak;\n\n\t\tcase ',':\n\t\t\tlr++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn tree;\n}\n\nvoid printTree( vector <int> &tree, int node )\n{\n\tcout << \"(\";\n\tif ( tree[node*2] == 1 )\n\t{\n\t\tprintTree( tree, node*2 );\n\t}\n\tcout << \",\";\n\tif ( tree[node*2+1] == 1 )\n\t{\n\t\tprintTree( tree, node*2+1 );\n\t}\n\tcout << \")\";\n}\n\nvector <int> intersectionTree( vector <int> &a, vector <int> &b )\n{\n\tvector <int> tree( SIZE, 0 );\n\tfor ( int i = 0; i < SIZE; i++ )\n\t\tif ( a[i] == 1 && b[i] == 1 )\n\t\t\ttree[i] = 1;\n\treturn tree;\n}\n\nvector <int> unionTree( vector <int> &a, vector <int> &b )\n{\n\tvector <int> tree( SIZE, 0 );\n\tfor ( int i = 0; i < SIZE; i++ )\n\t\tif ( a[i] == 1 || b[i] == 1 )\n\t\t\ttree[i] = 1;\n\treturn tree;\n}\n\nint main( void )\n{\n\tstring type;\n\tstring in_a;\n\tstring in_b;\n\n\twhile ( cin >> type >> in_a >> in_b )\n\t{\n\t\tvector <int> a = getTree( in_a );\n\t\tvector <int> b = getTree( in_b );\n\n\t\tvector <int> c;\n\t\tif ( type == \"i\" )\n\t\t{\n\t\t\tc = intersectionTree( a, b );\n\t\t}\n\t\telse if ( type == \"u\" )\n\t\t{\n\t\t\tc = unionTree( a, b );\n\t\t}\n\t\tprintTree( c, 2 );\n\t\tcout << endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <bitset>\n#include <algorithm>\n\nusing namespace std;\n\nstring tree[2];\nbool node[2][100][100];\n\nstring uni(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    if (tree[1][index1] != ',') \n      for (;tree[1][index1] != ','; index1++) {\n\tleft = left + tree[1][index1];\n      }\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[0][index0] != ','; index0++) {\n      left = left + tree[0][index0];\n    }\n  } else {\n    left = uni(index0 + 1, index1 + 1);\n    for (;tree[0][index0] != ','; index0++);\n    for (;tree[1][index1] != ','; index1++);\n  }\n\n  if (tree[0][index0 + 1] == ')') {\n    int c = 0;\n    index1++;\n    while (true) {\n      if (c == 0 && tree[1][index1] == ')') {break;}\n      if (tree[1][index1] == '(') {c++;}\n      if (tree[1][index1] == ')') {c--;}\n      right = right + tree[1][index1];\n      index1++;\n    }\n  } else if (tree[1][index1 + 1] == ')') {\n    int c = 0;\n    index0++;\n    while (true) {\n      if (c == 0 && tree[0][index0] == ')') {break;}\n      if (tree[0][index0] == '(') {c++;}\n      if (tree[0][index0] == ')') {c--;}\n      right = right + tree[0][index0];\n      index0++;\n    }\n  } else {\n    right = uni(index0 + 1, index1 + 1);\n  }\n  return \"(\" + left + \",\" + right + \")\";\n}\n\nstring inter(int index0, int index1)\n{\n  string left = \"\", right = \"\";\n  if (tree[0][index0 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[1][index1] != ','; index1++);\n  } else if (tree[1][index1 + 1] == ',') {\n    index0++, index1++;\n    for (;tree[0][index0] != ','; index0++);\n  } else {\n    left = inter(index0 + 1, index1 + 1);\n    for (;tree[0][index0] != ','; index0++);\n    for (;tree[1][index1] != ','; index1++);\n  }\n  \n  if (tree[0][index0 + 1] == ')' || tree[1][index1 + 1] == ')') {\n    right = \"\";\n  } else {\n    right = inter(index0 + 1, index1 + 1);\n  }\n  \n  return \"(\" + left + \",\" + right + \")\";\n}\n\nint main()\n{ \n  char ex;\n  \n  while (cin >> ex >> tree[0] >> tree[1]) {\n    if (ex == 'i') {\n      cout << inter(0, 0) << endl;\n    } else {\n      cout << uni(0, 0) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <climits>\n#include <cfloat>\n\n\nusing namespace std;\n\nvoid make_tree(bool* tree, int node, string s)\n{\n\tif (s.empty())\n\t\treturn;\n\n\ttree[node] = true;\n\n\tint paren = 0;\n\tint i;\n\tfor (i = 1; paren != 0 || s[i] != ','; ++i)\n\t{\n\t\tif (s[i] == '(')\n\t\t\t++paren;\n\t\telse if (s[i] == ')')\n\t\t\t--paren;\n\t}\n\tmake_tree(tree, node*2+1, s.substr(1, i-1));\n\tmake_tree(tree, node*2+2, s.substr(i+1, s.size()-2 -i));\n}\n\nvoid print_tree(bool* tree, int node)\n{\n\tif (!tree[node])\n\t\treturn;\n\n\tputchar('(');\n\tprint_tree(tree, node*2+1);\n\tputchar(',');\n\tprint_tree(tree, node*2+2);\n\tputchar(')');\n}\n\n\nconst int TreeSize = 1024;\nbool tree1[TreeSize], tree2[TreeSize], opedTree[TreeSize];\n\nint main()\n{\n\tchar ope;\n\tstring s1, s2;\n\n\twhile (cin >> ope >> s1 >> s2)\n\t{\n\t\tfill(tree1, tree1+TreeSize, false);\n\t\tfill(tree2, tree2+TreeSize, false);\n\n\t\tmake_tree(tree1, 0, s1);\n\t\tmake_tree(tree2, 0, s2);\n\n\t\tif (ope == 'i')\n\t\t\tfor (int i = 0; i < TreeSize; ++i)\n\t\t\t\topedTree[i] = tree1[i] & tree2[i];\n\t\telse\n\t\t\tfor (int i = 0; i < TreeSize; ++i)\n\t\t\t\topedTree[i] = tree1[i] | tree2[i];\n\n\t\tprint_tree(opedTree, 0);\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <boost/shared_ptr.hpp>\n\nstruct Node;\ntypedef boost::shared_ptr<Node> NodePtr;\nstruct Node {\n\tNodePtr left;\n\tNodePtr right;\n};\n\nvoid show_intersection_tree(NodePtr root1, NodePtr root2)\n{\n\tstd::cout << '(';\n\tif (root1->left && root2->left) {\n\t\tshow_intersection_tree(root1->left, root2->left);\n\t}\n\tstd::cout << ',';\n\tif (root1->right && root2->right) {\n\t\tshow_intersection_tree(root1->right, root2->right);\n\t}\n\tstd::cout << ')';\n}\n\nvoid show_union_tree(NodePtr root1, NodePtr root2)\n{\n\tstd::cout << '(';\n\tif ((root1 && root1->left) || (root2 && root2->left)) {\n\t\tshow_union_tree(root1 ? root1->left : root1, root2 ? root2->left : root2);\n\t}\n\tstd::cout << ',';\n\tif ((root1 && root1->right) || (root2 && root2->right)) {\n\t\tshow_union_tree(root1 ? root1->right : root1, root2 ? root2->right : root2);\n\t}\n\tstd::cout << ')';\n}\n\nchar get_token()\n{\n\tchar c;\n\twhile (std::cin >> c) {\n\t\tif (c == '(' || c == ',' || c == ')') {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn c;\n}\n\nNodePtr make_node()\n{\n\tNodePtr node;\n\tif (get_token() == '(') {\n\t\tnode = NodePtr(new Node);\n\t\tif ((node->left = make_node())) {\n\t\t\tassert(get_token() == ',');\n\t\t}\n\t\tif ((node->right = make_node())) {\n\t\t\tassert(get_token() == ')');\n\t\t}\n\t}\n\treturn node;\n}\n\nint main()\n{\n\tchar op;\n\twhile (std::cin >> op) {\n\t\tNodePtr root1 = make_node();\n\t\tNodePtr root2 = make_node();\n\t\tif (op == 'i') {\n\t\t\tshow_intersection_tree(root1, root2);\n\t\t}\n\t\telse if (op == 'u') {\n\t\t\tshow_union_tree(root1, root2);\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <boost/format.hpp>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef unsigned long long ull;\ntypedef std::pair<std::string,std::string> P;\n\nstd::string substring(std::string s, int begin, int end){\n    return s.substr(begin, end-begin);\n}\n\nP child(std::string tree){\n    P res;\n    int parLevel = 0;\n\n    for(int i=1;i<tree.size()-1;i++){\n        if(tree[i] == '('){\n            parLevel++;\n        }else if(tree[i] == ')'){\n            parLevel--;\n        }else if(tree[i] == ',' && !parLevel){\n            res.first = substring(tree, 1, i);\n            res.second = substring(tree, i+1, tree.size()-1);\n        }\n    }\n\n    return res;\n}\n\nstd::string Union(std::string a, std::string b){\n    P a_child = child(a), b_child = child(b);\n    std::string \n        al_child = a_child.first,\n        ar_child = a_child.second,\n        bl_child = b_child.first,\n        br_child = b_child.second,\n        l_child = \"\",\n        r_child = \"\";\n\n    // std::cout << boost::format(\"%1% %2%\") % al_child % ar_child << std::endl;\n    // std::cout << boost::format(\"%1% %2%\") % bl_child % br_child << std::endl;\n        \n    if(al_child != \"\" && bl_child == \"\"){\n        l_child = al_child;\n    }else if(al_child == \"\" && bl_child != \"\"){\n        l_child = bl_child;\n    }else if(al_child != \"\" && bl_child != \"\"){\n        l_child = Union(al_child, bl_child);\n    }\n\n    if(ar_child != \"\" && br_child == \"\"){\n        r_child = ar_child;\n    }else if(ar_child == \"\" && br_child != \"\"){\n        r_child = br_child;\n    }else if(ar_child != \"\" && br_child != \"\"){\n        r_child = Union(ar_child, br_child);\n    }\n\n    // std::cout << \"Result: \" << \"(\" + l_child + \",\" + r_child + \")\" << std::endl;\n    return \"(\" + l_child + \",\" + r_child + \")\";\n}\n\nstd::string Intersection(std::string a, std::string b){\n    P a_child = child(a), b_child = child(b);\n    std::string \n        al_child = a_child.first,\n        ar_child = a_child.second,\n        bl_child = b_child.first,\n        br_child = b_child.second,\n        l_child = \"\",\n        r_child = \"\";\n\n    if(al_child != \"\" && bl_child != \"\"){\n        l_child = Intersection(al_child, bl_child);\n    }\n\n    if(ar_child != \"\" && br_child != \"\"){\n        r_child = Intersection(ar_child, br_child);\n    }\n\n    return \"(\" + l_child + \",\" + r_child + \")\";\n}\n\nint main(){\n    char c;\n    std::string a, b;\n\n    while(std::cin >> c >> a >> b, !std::cin.eof()){\n        if(c == 'u'){\n            std::cout << Union(a, b) << std::endl;\n        }else if(c == 'i'){\n            std::cout << Intersection(a, b) << std::endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cstdio>\n#include<vector>\n#include<list>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<string>\n#include<cmath>\n#include<cstdlib>\nusing namespace std;\n\nint treeA[110];\nint treeB[110];\nint treeC[110];\n\nvoid getTree(string line,int tree, int lvl){\n\tif(line==\"\" || line==\"(\" || line==\")\")return;\n\tstack<int> cnt;\n\tint b=0;\n\twhile(line[b]!=0){\n\t\tif(line[b]=='('){\n\t\t\tcnt.push(1);\n\t\t}else if(line[b]==')'){\n\t\t\tcnt.pop();\n\t\t}else{\n\t\t\tif(cnt.size()==1)break;\n\t\t}\n\t\tb++;\n\t}\n\tstring S_R = \"\";\n\tstring S_L = \"\";\n\tfor(int x=1;x<b;++x){\n\t\tS_L += line[x];\n\t}\n\tfor(int x=b+1;x<line.size()-1;++x){\n\t\tS_R += line[x];\n\t}\n\tgetTree(S_R,tree,2*lvl+1);\n\tgetTree(S_L,tree,2*lvl);\n\tif(tree==1){\n\t\ttreeA[lvl] = 1;\n\t}else{\n\t\ttreeB[lvl] = 2;\n\t}\n}\n\nstring imp(int lvl){\n\tif(treeC[lvl]==0)return \"\";\n\tstringstream buf;\n\tbuf<<\"(\"<<imp(2*lvl)<<\",\"<<imp(2*lvl+1)<<\")\";\n\treturn buf.str();\n}\n\nvoid unionT(){\n\tfor(int x=1;x<110;++x){\n\t\tif(treeA[x] || treeB[x])treeC[x] = 3;\n\t}\n\tcout<<imp(1)<<endl;\n}\n\nvoid inter(){\n\tfor(int x=1;x<110;++x){\n\t\tif(treeA[x] && treeB[x])treeC[x] = 3;\n\t}\n\tcout<<imp(1)<<endl;\n}\n\nint main(){\n\tchar l;\n\tstring s1,s2;\n\twhile(cin>>l>>s1>>s2 && !cin.eof()){\n\t\tfor(int x=0;x<110;++x){\n\t\t\ttreeA[x] = 0;treeB[x] = 0;treeC[x] = 0;\n\t\t}\n\t\tgetTree(s1,1,1);\n\t\tgetTree(s2,2,1);\n\t\tif(l == 'u'){\n\t\t\tunionT();\n\t\t}else{\n\t\t\tinter();\n\t\t}\n\t}\t\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring o,s,t,ans;\nint x,y;\nvoid ii(){\n  while(x<s.size()&&y<t.size()){\n    if(s[x]==t[y])ans+=s[x];\n    else{\n      if(s[x]=='('){\n      stack<char>st;\n      st.push(s[x]);\n      while(!st.empty()){\n\tx++;\n\tif(s[x]=='.')continue;\n\telse if(s[x]==st.top())st.push(s[x]);\n\telse st.pop();\n      }y--;x++;}\n      else {\n      stack<char>st;\n      st.push(t[y]);\n      while(!st.empty()){\n\ty++;\n\tif(t[y]=='.')continue;\n\telse if(t[y]==st.top())st.push(t[y]);\n\telse st.pop();\n      }x--;y++;}\n    }\n    x++;y++;\n  }\n}\nvoid uu(){\n  while(x<s.size()&&y<t.size()){\n    if(s[x]==t[y]){\n      ans+=s[x];\n      x++;y++;\n    }\n    else if(s[x]=='('){\n      stack<char>st;\n      st.push(s[x]);\n      ans+=s[x];\n      while(!st.empty()){\n\tx++;\n\tif(s[x]==')')st.pop(),ans+=s[x];\n\telse if(s[x]=='.')st.push(s[x]),ans+=s[x];\n\telse st.push('('),ans+=s[x];\n      }y+=2,x++;\n    }\n    else{\n      stack<char>st;\n      st.push(t[y]);\n      ans+=t[y];\n      while(!st.empty()){\n\ty++;\n\tif(t[y]==')')st.pop(),ans+=t[y];\n\telse if(t[y]=='.')st.push(t[y]),ans+=t[y];\n\telse st.push('('),ans+=t[y];\n      }x+=2,y++;\n    }\n  }\n}\nint main(){\n  while(cin>>o>>s>>t){\n    ans=\"\";\n    x=y=0;\n    if(s.size()<t.size())swap(s,t);\n    if(o==\"u\")uu();\n    else ii();\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nconst int nil = -1;\nconst int MAX_N = 256;\n\nstruct Node {\n  int l, r, cnt;\n  Node() {\n    l = r = nil;\n    cnt = 0;\n  }\n};\n\nNode v[MAX_N];\nint nodeIndex;\n\nint parse(const char *s, int n, int root) {\n  v[root].cnt++;\n  if (s[++n] != ',') {\n    if (v[root].l == nil) v[root].l = ++nodeIndex;\n    n = parse(s, n, v[root].l);\n  }\n  if (s[++n] != ')') {\n    if (v[root].r == nil) v[root].r = ++nodeIndex;\n    n = parse(s, n, v[root].r);\n  }\n  return n+1;\n}\n\nvoid print(int root, int cnt) {\n  if (v[root].cnt < cnt) return;\n  putchar('(');\n  if (v[root].l != nil) print(v[root].l, cnt);\n  putchar(',');\n  if (v[root].r != nil) print(v[root].r, cnt);\n  putchar(')');\n}\n\nint main() {\n  char op[2], t1[256], t2[256];\n  while (scanf(\"%s %s %s\", op, t1, t2) == 3) {\n    for (int i=0;i<MAX_N;i++) v[i] = Node();\n    nodeIndex = 0;\n    parse(t1, 0, 0);\n    parse(t2, 0, 0);\n    print(0, (op[0]=='u'?1:2)); putchar('\\n');\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct Tree {\n  Tree *left;\n  Tree *right;\npublic:\n  Tree() : left(0), right(0) {}\n};\n\nTree *ana(string s) {\n  int k=0;\n  Tree *node = new Tree();\n  int i;\n  if (s[1] != ',') {\n    for (i=1; i<s.length(); i++) {\n      if (s[i] == '(') k++;\n      if (s[i] == ')') k--;\n      if (k == 0) {\n        //    cout << s.substr(1,i) << endl;\n        node->left = ana(s.substr(1,i));\n        break;\n      }\n    }\n  } else\n    i=0;\n  if (s.length()-i-3) {\n    // cout << \" \" << s.substr(i+2, s.length()-i-3) << endl;\n    node->right = ana(s.substr(i+2, s.length()-i-3));\n  }\n  return node;\n}\n\nTree *inter(Tree *t1, Tree *t2) {\n  Tree *node = new Tree();\n  if (t1->left && t2->left) {\n    node->left = inter(t1->left, t2->left);\n  }\n  if (t1->right && t2->right) {\n    node->right = inter(t1->right, t2->right);\n  }\n  return node;\n}\n\nTree *unit(Tree *t1, Tree *t2) {\n  Tree *node = new Tree();\n  if (t1 && t2) {\n    if (t1->left || t2->left) {\n      node->left = unit(t1->left, t2->left);\n    }\n    if (t1->right || t2->right) {\n      node->right = unit(t1->right, t2->right);\n    }\n  }\n  if (t1 == NULL && t2) {\n    if (t2->left)\n      node->left = unit(NULL, t2->left);\n    if (t2->right)\n      node->right = unit(NULL, t2->right);\n  }\n  if (t1 && t2 == NULL) {\n    if (t1->left)\n      node->left = unit(t1->left, NULL);\n    if (t1->right)\n      node->right = unit(t1->right, NULL);\n  }\n  return node;\n}\n\nstring strTree(Tree *node) {\n  string s = \"(\";\n  if (node->left)\n    s += strTree(node->left);\n  s += \",\";\n  if (node->right)\n    s += strTree(node->right);\n  s+= \")\";\n  return s;\n}\n\nint main() {\n  char c;\n  while(cin >> c) {\n    string a, b;\n    cin >> a >> b;\n\n    Tree *root1 = ana(a);\n    Tree *root2 = ana(b);\n    if (c == 'i') {\n      cout << strTree(inter(root1,root2)) << endl;\n    } else {\n      cout << strTree(unit(root1,root2)) << endl;\n    }\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef unsigned long long ull;\ntypedef std::pair<std::string,std::string> P;\n\nstd::string substring(std::string s, int begin, int end){\n    return s.substr(begin, end-begin);\n}\n\nP child(std::string tree){\n    P res;\n    int parLevel = 0;\n\n    for(int i=1;i<tree.size()-1;i++){\n        if(tree[i] == '('){\n            parLevel++;\n        }else if(tree[i] == ')'){\n            parLevel--;\n        }else if(tree[i] == ',' && !parLevel){\n            res.first = substring(tree, 1, i);\n            res.second = substring(tree, i+1, tree.size()-1);\n        }\n    }\n\n    return res;\n}\n\nstd::string Union(std::string a, std::string b){\n    P a_child = child(a), b_child = child(b);\n    std::string \n        al_child = a_child.first,\n        ar_child = a_child.second,\n        bl_child = b_child.first,\n        br_child = b_child.second,\n        l_child = \"\",\n        r_child = \"\";\n\n    // std::cout << boost::format(\"%1% %2%\") % al_child % ar_child << std::endl;\n    // std::cout << boost::format(\"%1% %2%\") % bl_child % br_child << std::endl;\n        \n    if(al_child != \"\" && bl_child == \"\"){\n        l_child = al_child;\n    }else if(al_child == \"\" && bl_child != \"\"){\n        l_child = bl_child;\n    }else if(al_child != \"\" && bl_child != \"\"){\n        l_child = Union(al_child, bl_child);\n    }\n\n    if(ar_child != \"\" && br_child == \"\"){\n        r_child = ar_child;\n    }else if(ar_child == \"\" && br_child != \"\"){\n        r_child = br_child;\n    }else if(ar_child != \"\" && br_child != \"\"){\n        r_child = Union(ar_child, br_child);\n    }\n\n    // std::cout << \"Result: \" << \"(\" + l_child + \",\" + r_child + \")\" << std::endl;\n    return \"(\" + l_child + \",\" + r_child + \")\";\n}\n\nstd::string Intersection(std::string a, std::string b){\n    P a_child = child(a), b_child = child(b);\n    std::string \n        al_child = a_child.first,\n        ar_child = a_child.second,\n        bl_child = b_child.first,\n        br_child = b_child.second,\n        l_child = \"\",\n        r_child = \"\";\n\n    if(al_child != \"\" && bl_child != \"\"){\n        l_child = Intersection(al_child, bl_child);\n    }\n\n    if(ar_child != \"\" && br_child != \"\"){\n        r_child = Intersection(ar_child, br_child);\n    }\n\n    return \"(\" + l_child + \",\" + r_child + \")\";\n}\n\nint main(){\n    char c;\n    std::string a, b;\n\n    while(std::cin >> c >> a >> b, !std::cin.eof()){\n        if(c == 'u'){\n            std::cout << Union(a, b) << std::endl;\n        }else if(c == 'i'){\n            std::cout << Intersection(a, b) << std::endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * $File: p1001.cpp\n * $Author: Wayne <tletletle@163.com>\n *\n * Task:\n *   Given two binary trees, we need to\n *   calculate the intersection or the\n *   union of them.\n *\n * Solution:\n *   Parsing. Graph theory.\n *   Just Build the trees and implement.\n*/\n\n#include <cstdio>\n#include <cstring>\n\nconst int kMaxVtx = 100;\nconst int kMaxBuf = 512;\nchar buf[kMaxBuf];\n\nstruct TreeNode {\n\tTreeNode *son[2];\n\tTreeNode() {\n\t\tson[0] = son[1] = NULL;\n\t}\n};\n\nstruct Tree {\n\tTreeNode *root;\n\tTree() {\n\t\troot = NULL;\n\t}\n} a, b, c;\n\nTreeNode *BuildTree(int l, int r) {\n\tif (l > r) return NULL;\n\tTreeNode *res = new TreeNode;\n\tif (l + 1 == r - 1) return res;\n\tint mid, sum = 0;\n\tfor (int i = l + 1; i <= r - 1; ++ i)\n\t\tif (buf[i] == '(') ++ sum;\n\t\telse if (buf[i] == ')') -- sum;\n\t\telse if (buf[i] == ',' && sum == 0) mid = i;\n\tres->son[0] = BuildTree(l + 1, mid - 1);\n\tres->son[1] = BuildTree(mid + 1, r - 1);\n\treturn res;\n}\n\nvoid ReadTree(Tree &des) {\n\tscanf(\"%s\", buf);\n\tdes.root = BuildTree(0, strlen(buf) - 1);\n}\n\nTreeNode *DfsIntersection(TreeNode *u, TreeNode *v) {\n\tif (!u || !v) return NULL;\n\tTreeNode *res = new TreeNode;\n\tres->son[0] = DfsIntersection(u->son[0], v->son[0]);\n\tres->son[1] = DfsIntersection(u->son[1], v->son[1]);\n\treturn res;\n}\n\nTreeNode *DfsUnion(TreeNode *u, TreeNode *v) {\n\tif (!u && !v) return NULL;\n\tTreeNode *res = new TreeNode;\n\tres->son[0] = DfsUnion(u ? u->son[0] : NULL, v ? v->son[0] : NULL);\n\tres->son[1] = DfsUnion(u ? u->son[1] : NULL, v ? v->son[1] : NULL);\n\treturn res;\n}\n\nTree GetIntersection(const Tree &a, const Tree &b) {\n\tTree res;\n\tres.root = DfsIntersection(a.root, b.root);\n\treturn res;\n}\n\nTree GetUnion(const Tree &a, const Tree &b) {\n\tTree res;\n\tres.root = DfsUnion(a.root, b.root);\n\treturn res;\n}\n\nvoid OutputTree(TreeNode *cur) {\n\tif (!cur) return;\n\tputchar('(');\n\tOutputTree(cur->son[0]);\n\tputchar(',');\n\tOutputTree(cur->son[1]);\n\tputchar(')');\n}\n\nint main() {\n\tstatic char cmd[2];\n\twhile (scanf(\"%s\", cmd) != EOF) {\n\t\tReadTree(a);\n\t\tReadTree(b);\n\t\tif (cmd[0] == 'i') c = GetIntersection(a, b);\n\t\telse c = GetUnion(a, b);\n\t\tOutputTree(c.root);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Debug.Trace\nimport System.IO\n\ndata Tree = Branch Tree Tree | Leaf\n          deriving (Eq)\ninstance Show Tree where\n  show (Branch l1 r1) = \"(\"++show l1 ++ \",\"\n                        ++show r1 ++ \")\"\n  show Leaf = \"\"\n\nmain :: IO ()\nmain = do\n  eof <- isEOF\n  if eof\n    then return ()\n    else do\n    ss <- words <$> getLine\n    (print . solve) ss\n    main\n--  s <- getLine\n--  print (toTree s)\n\nsolve :: [String] -> Tree\nsolve (q:s1:s2:_) = if q == \"u\" then union' t1' t2'\n                    else inter' t1' t2'\n  where\n    t1' = toTree s1\n    t2' = toTree s2\n    union' t1 t2 =\n      case (t1, t2) of\n        ((Branch l1 r1),(Branch l2 r2)) ->\n          Branch (union' l1 l2) (union' r1 r2)\n        ((Branch _ _), Leaf) -> t1\n        (Leaf, (Branch _ _)) -> t2\n        (Leaf, Leaf) -> Leaf\n    inter' t1 t2 =\n      case (t1, t2) of\n        ((Branch l1 r1), (Branch l2 r2)) ->\n          Branch (inter' l1 l2) (inter' r1 r2)\n        (_, _) -> Leaf\n        \ntoTree :: String -> Tree\ntoTree str = fst $ go str\n  where\n    go :: String -> (Tree, String)\n    go [] = (Leaf, [])\n    go (s:ss)\n      | s == '(' = let (l, ss') = go ss\n                       (r, ss'') = go (drop 1 ss') in\n                     (Branch l r, ss'')\n      | s == ',' = (Leaf, s:ss)\n      | s == ')' = (Leaf, ss)"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\n-- import qualified Data.ByteString as BS\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\n--import qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Fixed\nimport Data.Tuple\n--import Data.Array\nimport Data.Array.Unboxed\n--import Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\nimport Text.Printf\n-- import System.IO.Unsafe\n \n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\ngetDoubles = map readDouble . words <$> getLine\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ntjoin :: (Show a, Show b) => (a, b) -> String\ntjoin (x, y) = show x ++ (' ' : show y)\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\ncoverC :: Ord a => (a, a) -> a -> Bool\ncoverC (l,r) x = l<=x && x<=r\ncoverH :: Ord a => (a, a) -> a -> Bool\ncoverH (l,r) x = l<=x && x<r\nibsearch :: (Int -> Bool) -> (Int,Int) -> Int\nibsearch f (ok,ng) = if abs (ok-ng) <= 1 then ok else let mid = (ok + ng) `div` 2 in ibsearch f (if f mid then (mid,ng) else (ok,mid))\nwhenM :: Monad m => m Bool -> m () -> m ()\nwhenM c a = c >>= flip when a\nunconsU :: [a] -> (a, [a])\nunconsU (x:xs) = (x, xs)\n-- templete\n\ndata BTree = BEmpty | BNode BTree BTree deriving Eq\ninstance Show BTree where\n  show BEmpty = \"\"\n  show (BNode l r) = '(' : show l ++ ',' : show r ++ \")\"\n\nparse :: String -> BTree\nparse ss = let (t,_) = psub ss in t\n  where\n    psub ('(':s1) = let (left, (',':s2)) = psub s1 in let (right, (')':s3)) = psub s2 in (BNode left right, s3)\n    psub s = (BEmpty, s)\n\nbtintersection :: BTree -> BTree -> BTree\nbtintersection BEmpty _ = BEmpty\nbtintersection _ BEmpty = BEmpty\nbtintersection (BNode l1 r1) (BNode l2 r2) = BNode (btintersection l1 l2) (btintersection r1 r2)\n\nbtunion :: BTree -> BTree -> BTree\nbtunion BEmpty r = r\nbtunion l BEmpty = l\nbtunion (BNode l1 r1) (BNode l2 r2) = BNode (btunion l1 l2) (btunion r1 r2)\n\nsolve \"i\" lt rt = btintersection (parse lt) (parse rt)\nsolve \"u\" lt rt = btunion (parse lt) (parse rt)\n\nmain = map (apply3 solve . words) . lines <$> getContents >>= mapM_ print\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Debug.Trace\nimport System.IO\n\ndata Tree = Branch Tree Tree | Leaf\n          deriving (Eq)\ninstance Show Tree where\n  show (Branch l1 r1) = \"(\"++show l1 ++ \",\"\n                        ++show r1 ++ \")\"\n  show Leaf = \"\"\n\nmain :: IO ()\nmain = do\n  ss <- (map words . lines) <$> getContents\n  mapM_ (print . solve) ss\n--s <- getLine\n--  print (toTree s)\n\nsolve :: [String] -> Tree\nsolve (q:s1:s2:_) = if q == \"u\" then union' t1' t2'\n                    else inter' t1' t2'\n  where\n    t1' = toTree s1\n    t2' = toTree s2\n    union' t1 t2 =\n      case (t1, t2) of\n        ((Branch l1 r1),(Branch l2 r2)) ->\n          Branch (union' l1 l2) (union' r1 r2)\n        (_, Leaf) -> t1\n        (Leaf, _) -> t2\n    inter' t1 t2 =\n      case (t1, t2) of\n        ((Branch l1 r1), (Branch l2 r2)) ->\n          Branch (inter' l1 l2) (inter' r1 r2)\n        (_, _) -> Leaf\n        \ntoTree :: String -> Tree\ntoTree str = fst $ go str\n  where\n    go :: String -> (Tree, String)\n    go [] = (Leaf, [])\n    go (s:ss)\n      | s == '(' = let (l, ss') = go ss\n                       (r, ss'') = go (drop 1 ss') in\n                     (Branch l r, ss'')\n      | s == ',' = (Leaf, s:ss)\n      | s == ')' = (Leaf, ss)"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Debug.Trace\n\ndata Tree = Branch Tree Tree | Leaf\n          deriving (Eq)\ninstance Show Tree where\n  show (Branch l1 r1) = \"(\"++show l1 ++ \",\"\n                        ++show r1 ++ \")\"\n  show (Leaf) = \"\"\n\ntype Query = Char\n\nmain :: IO ()\nmain = do\n  ss <- (map words . lines) <$> getContents\n  mapM_ (print . solve) ss\n--  s <- getLine\n--  print (toTree s)\n\nsolve :: [String] -> Tree\nsolve (q:s1:s2:_) = if q == \"u\" then union' t1' t2'\n                    else inter' t1' t2'\n  where\n    t1' = toTree s1\n    t2' = toTree s2\n    union' t1 t2 =\n      case (t1, t2) of\n        ((Branch l1 r1),(Branch l2 r2)) ->\n          Branch (union' l1 l2) (union' r1 r2)\n        (_, Leaf) -> t1\n        (Leaf, _) -> t2\n    inter' t1 t2 =\n      case (t1, t2) of\n        ((Branch l1 r1), (Branch l2 r2)) ->\n          Branch (inter' l1 l2) (inter' r1 r2)\n        (_, _) -> Leaf\n        \ntoTree :: String -> Tree\ntoTree str = fst $ go str\n  where\n    go :: String -> (Tree, String)\n    go [] = (Leaf, [])\n    go (s:ss)\n      | s == '(' = let (l, ss') = go ss\n                       (r, ss'') = go (drop 1 ss') in\n                     (Branch l r, ss'')\n      | s == ',' = (Leaf, s:ss)\n      | s == ')' = (Leaf, ss)"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Debug.Trace\n\ndata Tree = Branch Tree Tree | Leaf\n          deriving (Eq)\ninstance Show Tree where\n  show (Branch l1 r1) = \"(\"++show l1 ++ \",\"\n                        ++show r1 ++ \")\"\n  show Leaf = \"\"\n\nmain :: IO ()\nmain = do\n  ss <- (map words . lines) <$> getContents\n  mapM_ (print . solve) ss\n--  s <- getLine\n--  print (toTree s)\n\nsolve :: [String] -> Tree\nsolve (q:s1:s2:_) = if q == \"u\" then union' t1' t2'\n                    else inter' t1' t2'\n  where\n    t1' = toTree s1\n    t2' = toTree s2\n    union' t1 t2 =\n      case (t1, t2) of\n        ((Branch l1 r1),(Branch l2 r2)) ->\n          Branch (union' l1 l2) (union' r1 r2)\n        ((Branch _ _), Leaf) -> t1\n        (Leaf, (Branch _ _)) -> t2\n        (Leaf, Leaf) -> Leaf\n    inter' t1 t2 =\n      case (t1, t2) of\n        ((Branch l1 r1), (Branch l2 r2)) ->\n          Branch (inter' l1 l2) (inter' r1 r2)\n        (_, _) -> Leaf\n        \ntoTree :: String -> Tree\ntoTree str = fst $ go str\n  where\n    go :: String -> (Tree, String)\n    go [] = (Leaf, [])\n    go (s:ss)\n      | s == '(' = let (l, ss') = go ss\n                       (r, ss'') = go (drop 1 ss') in\n                     (Branch l r, ss'')\n      | s == ',' = (Leaf, s:ss)\n      | s == ')' = (Leaf, ss)"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\n\ndata BTree = BEmpty | BNode BTree BTree\ninstance Show BTree where\n  show BEmpty = \"\"\n  show (BNode l r) = '(' : show l ++ ',' : show r ++ \")\"\n\nparse ss = let (t,_) = psub ss in t\n  where\n    psub ('(':s1) = let (left, (',':s2)) = psub s1 in let (right, (')':s3)) = psub s2 in (BNode left right, s3)\n    psub s = (BEmpty, s)\n\nbtintersection BEmpty _ = BEmpty\nbtintersection _ BEmpty = BEmpty\nbtintersection (BNode l1 r1) (BNode l2 r2) = BNode (btintersection l1 l2) (btintersection r1 r2)\n\nbtunion BEmpty r = r\nbtunion l BEmpty = l\nbtunion (BNode l1 r1) (BNode l2 r2) = BNode (btunion l1 l2) (btunion r1 r2)\n\nsolve [\"i\", lt, rt] = btintersection (parse lt) (parse rt)\nsolve [\"u\", lt, rt] = btunion (parse lt) (parse rt)\n\nmain = map (solve . words) . lines <$> getContents >>= mapM_ print\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>), (<*>))\nimport Control.Monad\nimport Data.List\nimport Text.Parsec\nimport Text.Parsec.String\n\nmain :: IO ()\nmain = do\n  solve <$> getc (map words) >>= mapM_ print\n\nsolve :: [[String]] -> [BTree]\nsolve = map f\n  where\n    f :: [String] -> BTree\n    f [c, t1, t2]\n      | c == \"i\" = isect l r\n      | otherwise = unn l r\n      where\n        l = either (const Leaf) id $ parse expr \"\" t1\n        r = either (const Leaf) id $ parse expr \"\" t2\n        \ngetc :: ([String] -> a) -> IO a\ngetc f = f . lines <$> getContents\n\nexpr :: Parser BTree\nexpr = do\n  char '('\n  l <- expr <|> return Leaf\n  char ','\n  r <- expr <|> return Leaf\n  char ')'\n  return $ Node l r\n\ndata BTree = Leaf | Node BTree BTree\n\ninstance Show BTree where\n  show Leaf = \"\"\n  show (Node l r) = \"(\" ++ show l ++ \",\"++ show r  ++ \")\"\n\nisect :: BTree -> BTree -> BTree\nisect Leaf _ = Leaf\nisect _ Leaf = Leaf\nisect (Node l1 r1) (Node l2 r2) = Node (isect l1 l2) (isect r1 r2)\n\nunn :: BTree -> BTree -> BTree\nunn Leaf r = r\nunn l Leaf = l\nunn (Node l1 r1) (Node l2 r2) = Node (unn l1 l2) (unn r1 r2)"
  },
  {
    "language": "Haskell",
    "code": "module Main where\nimport Control.Monad\nimport Control.Applicative\nimport Data.Maybe\nimport Data.List\nimport qualified Text.Printf\nimport qualified Data.ByteString.Char8 as BC\nimport qualified Data.ByteString as BC\n\nimport System.IO\n\n------------------------------------------\n\ndata Tr = Em | Br Tr Tr\n  deriving (Show, Eq)\n\nparse :: String -> (Tr, String)\nparse \"\" = (Em, \"\")\nparse ('(':xs) =\n  let (lt, ',':xs') = parse xs\n      (rt, ')':xs'') = parse xs' in (Br lt rt, xs'')\nparse xs = (Em, xs)\n\nunparse :: Tr -> String\nunparse Em = \"\"\nunparse (Br lt rt) = \"(\" ++ unparse lt ++ \",\" ++ unparse rt ++ \")\"\n\nuni :: Tr -> Tr -> Tr\nuni Em Em = Em\nuni lt Em = lt\nuni Em rt = rt\nuni (Br llt lrt) (Br rlt rrt) = Br (uni llt rlt) (uni lrt rrt)\n\nintersec :: Tr -> Tr -> Tr\nintersec Em Em = Em\nintersec lt Em = Em\nintersec Em rt = Em\nintersec (Br llt lrt) (Br rlt rrt) = Br (intersec llt rlt) (intersec lrt rrt)\n\nmain :: IO ()\nmain = do\n  eof <- isEOF\n  if eof then return ()\n  else do\n  [cmd, xs, ys] <- words <$> getLine\n  let (xt, _) = parse xs\n      (yt, _) = parse ys\n      ans = if cmd == \"i\" then intersec xt yt else uni xt yt\n  putStrLn $ unparse ans\n  main\n\n------------------------------------------\n\n{- Int input -}\n\nparseInt :: BC.ByteString -> Int\nparseInt = fst . fromJust . BC.readInt\n\nparseInts :: BC.ByteString -> [Int]\nparseInts = map parseInt <$> BC.words\n\nreadInt :: IO Int\nreadInt = parseInt <$> BC.getLine\n\nreadInts :: IO [Int]\nreadInts = parseInts <$> BC.getLine\n\n{- Double Formatting -}\n\ndoubleFmt :: Double -> String\ndoubleFmt = Text.Printf.printf \"%.12f\""
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Debug.Trace\nimport System.IO\n\ndata Tree = Branch Tree Tree | Leaf\n          deriving (Eq)\ninstance Show Tree where\n  show (Branch l1 r1) = \"(\"++show l1 ++ \",\"\n                        ++show r1 ++ \")\"\n  show Leaf = \"\"\n\nmain :: IO ()\nmain = do\n  ss <- (map words . lines) <$> getContents\n--  mapM_ (print . map toTree . drop 1) ss\n  mapM_ (print . solve) ss\n--s <- getLine\n--  print (toTree s)\n\nsolve :: [String] -> Tree\nsolve (q:s1:s2:_) = if q == \"u\" then union' t1' t2'\n                    else inter' t1' t2'\n  where\n    t1' = toTree s1\n    t2' = toTree s2\n    union' t1 t2 =\n      case (t1, t2) of\n        ((Branch l1 r1),(Branch l2 r2)) ->\n          Branch (union' l1 l2) (union' r1 r2)\n        (_, Leaf) -> t1\n        (Leaf, _) -> t2\n    inter' t1 t2 =\n      case (t1, t2) of\n        ((Branch l1 r1), (Branch l2 r2)) ->\n          Branch (inter' l1 l2) (inter' r1 r2)\n        (_, _) -> Leaf\n        \ntoTree :: String -> Tree\ntoTree str = fst $ go str\n  where\n    go :: String -> (Tree, String)\n--    go [] = (Leaf, [])\n    go (s:ss)\n      | s == '(' = let (l, _:ss') = go ss\n                       (r, _:ss'') = go ss' in\n                     (Branch l r, ss'')\n      | s == ',' = (Leaf, s:ss)\n      | s == ')' = (Leaf, s:ss)"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\n\ndata BTree = BEmpty | BNode BTree BTree deriving Eq\ninstance Show BTree where\n  show BEmpty = \"\"\n  show (BNode l r) = '(' : show l ++ ',' : show r ++ \")\"\n\nparse :: String -> BTree\nparse ss = let (t,_) = psub ss in t\n  where\n    psub ('(':s1) = let (left, (',':s2)) = psub s1 in let (right, (')':s3)) = psub s2 in (BNode left right, s3)\n    psub s = (BEmpty, s)\n\nbtintersection :: BTree -> BTree -> BTree\nbtintersection BEmpty _ = BEmpty\nbtintersection _ BEmpty = BEmpty\nbtintersection (BNode l1 r1) (BNode l2 r2) = BNode (btintersection l1 l2) (btintersection r1 r2)\n\nbtunion :: BTree -> BTree -> BTree\nbtunion BEmpty r = r\nbtunion l BEmpty = l\nbtunion (BNode l1 r1) (BNode l2 r2) = BNode (btunion l1 l2) (btunion r1 r2)\n\nsolve [\"i\", lt, rt] = btintersection (parse lt) (parse rt)\nsolve [\"u\", lt, rt] = btunion (parse lt) (parse rt)\n\nmain = map (solve . words) . lines <$> getContents >>= mapM_ print\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main()\n{\nprintf(\"Hello world!\\n\");\nreturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1001: Binary Tree Intersection And Union\n// 2017.12.14 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int l, r, c; } T;\nT node[310]; int sz;\nchar buf[1210], *p;\nchar ans[610], *q;\n\nchar *parse(char *p, int i)\n{\n\tnode[i].c++; p++;\n\tif (*p != ',') {\n\t    if (node[i].l == 0) node[i].l = sz++;\n\t\tp = parse(p, node[i].l);\n\t}\n\tp++;\n\tif (*p != ')') {\n\t\tif (node[i].r == 0) node[i].r = sz++;\n\t    p = parse(p, node[i].r);\n\t}\n\treturn p+1;\n}\n\nchar *act(char *q, int i, int k)\n{\n\tif (node[i].c < k) return q;\n\t*q++ = '(';\n\tif (node[i].l > 0) q = act(q, node[i].l, k);\n\t*q++ = ',';\n\tif (node[i].r > 0) q = act(q, node[i].r, k);\n\t*q++ = ')';\n\treturn q;\n}\n\nint main()\n{\n\tint op;\n\tchar *a, *b;\n\n\twhile (fgets(p=buf, 1210, stdin) != NULL) {\n\t\tmemset(node, 0, sizeof(node));\n\n\t\top = *p, p+=2;\n\t\ta = p; while (*p != ' ') p++; *p++ = 0;\n\t\tb = p;\n\t\tsz = 1;\n\t\tparse(a, 0);\n\t\tparse(b, 0);\n\n\t\tq = act(ans, 0, op == 'i' ? 2 : 1), *q = 0;\n\t\tputs(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  char w,s1[302],s2[302];\n  int i,j,p1,p2,c1,c2,r,t;\n  while(scanf(\" %c%s%s\",&w,s1,s2)!=EOF){\n    //scanf(\"\\n\");\n    int a[450]={0};\n    int t1[100]={0};\n    int t2[100]={0};\n    t=0;\n    t1[j=0]=0;\n    for(i=0;s1[i];i++){\n      if(s1[i]=='(')t++;\n      if(s1[i]==','){\n\tt1[++j]=t;\n\tif(t==1)c1=j;\n      }\n      if(s1[i]==')')t--;\n    }\n    t1[++j]=0;\n    t=0;\n    t2[j=0]=0;\n    for(i=0;s2[i];i++){\n      if(s2[i]=='(')t++;\n      if(s2[i]==','){\n\tt2[++j]=t;\n\tif(t==1)c2=j;\n      }\n      if(s2[i]==')')t--;\n    }\n    t2[++j]=0;\n    a[r=200]=1;\n    p1=c1;\n    p2=c2;\n    while(1){\n      if(t1[--p1]*t2[--p2]==0&&w=='i')break;\n      if(t1[  p1]+t2[  p2]==0&&w=='u')break;\n      if(t1[p1]==t2[p2])a[--r]=t1[p1];\n      else if(t1[p1]>t2[p2]){\n\tif(w=='u')a[--r]=t1[p1];\n\tp2++;\n      }\n      else{\n\tif(w=='u')a[--r]=t2[p2];\n\tp1++;\n      }\n    }\n    r=200;\n    p1=c1;\n    p2=c2;\n    while(1){\n      if(t1[++p1]*t2[++p2]==0&&w=='i')break;\n      if(t1[  p1]+t2[  p2]==0&&w=='u')break;\n      if(t1[p1]==t2[p2])a[++r]=t1[p1];\n      if(t1[p1]>t2[p2]){\n\tif(w=='u')a[++r]=t1[p1];\n\tp2--;\n      }\n      else{\n\tif(w=='u')a[++r]=t2[p2];\n\tp1--;\n      }\n    }\n    t=0;\n    for(i=0;a[i]==0;i++);\n    for(;1;i++){\n      while(t<a[i]){\n\tprintf(\"(\");\n\tt++;\n      }\n      while(t>a[i]){\n\tprintf(\")\");\n\tt--;\n      }\n      if(!t)break;\n      printf(\",\");\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "char t1[301],t2[301];p1,p2,d;Skip(char*tree,int*pp){int h=0;do{if(tree[*pp]=='(')h++;if(tree[*pp]==')')h--;if(d)putchar(tree[*pp]);++*pp;}while(h);}R(d){if(t1[p1]=='('&&t2[p2]=='('){putchar('(');p1++,p2++;R();putchar(',');p1++,p2++;R();putchar(')');p1++,p2++;}else{if(t1[p1]=='(')Skip(t1,&p1);if(t2[p2]=='(')Skip(t2,&p2);}}main(){char o[2];for(;~scanf(\"%s%s%s\",o,t1,t2);){p1=p2=0;d=*o=='u';R();puts(\"\");}}"
  },
  {
    "language": "C",
    "code": "// AOJ 1001: Binary Tree Intersection And Union\n// 2017.12.14 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int l, r, c; } T;\nT node[210]; int sz;\nchar buf[400], *p;\nchar ans[200], *q;\n\nchar *parse(char *p, int i)\n{\n\tnode[i].c++; p++;\n\tif (*p != ',') {\n\t    if (node[i].l == 0) node[i].l = sz++;\n\t\tp = parse(p, node[i].l);\n\t}\n\tp++;\n\tif (*p != ')') {\n\t\tif (node[i].r == 0) node[i].r = sz++;\n\t    p = parse(p, node[i].r);\n\t}\n\treturn p+1;\n}\n\n\nchar *act(char *q, int i, int k)\n{\n\tif (node[i].c < k) return q;\n\t*q++ = '(';\n\tif (node[i].l > 0) q = act(q, node[i].l, k);\n\t*q++ = ',';\n\tif (node[i].r > 0) q = act(q, node[i].r, k);\n\t*q++ = ')';\n\treturn q;\n}\n\nint main()\n{\n\tint op;\n\tchar *a, *b;\n\n\twhile (fgets(p=buf, 400, stdin) != NULL) {\n\t\tmemset(node, 0, sizeof(node));\n\n\t\top = *p, p+=2;\n\t\ta = p; while (*p != ' ') p++; *p++ = 0;\n\t\tb = p;\n\t\tsz = 1;\n\t\tparse(a, 0);\n\t\tparse(b, 0);\n\n\t\tq = act(ans, 0, op == 'i' ? 2 : 1), *q = 0;\n\t\tputs(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint main(){\n  //ui 0:union 1:intersection\n  int i,j,k,node,t1s,t2s,ui,t1ns[105],t2ns[105],ans[210];\n  char buf[256],*t1,*t2;\n  ans[0]=t1ns[0]=t2ns[0]=0;\n  while(fgets(buf,256,stdin)!=NULL){\n    ui=buf[0]=='i'?1:0;\n    t1=buf+2;\n    t2=strchr(t1,' ');\n    t2[0]='\\0';\n    t2++;\n\n    for(i=0,node=0,t1s=1;t1[i];i++){\n      if(t1[i]=='('){\n\tnode=node*2+1;\n\tt1ns[t1s++]=node;\n      }else if(t1[i]==','){\n\tnode++;\n\tt1ns[t1s++]=node;\n      }else if(t1[i]==')'){\n\tif(node%2==0) node--;\n\tnode=(node-1)/2;\n      }\n    }\n    for(i=0,node=0,t2s=1;t2[i];i++){\n      if(t2[i]=='('){\n\tnode=node*2+1;\n\tt2ns[t2s++]=node;\n      }else if(t2[i]==','){\n\tnode++;\n\tt2ns[t2s++]=node;\n      }else if(t2[i]==')'){\n\tif(node%2==0) node--;\n\tnode=(node-1)/2;\n      }\n    }\n    \n\n    if(ui==1){\n      for(i=1,j=1,k=1;(i<t1s)&&(j<t2s);){\n\tif(t1ns[i]==t2ns[j]){\n\t  ans[k++]=t1ns[i];\n\t  i++; j++;\n\t}else if(t1ns[i]<t2ns[j]){\n\t  j++;\n\t}else{\n\t  i++;\n\t}\n      }\n    }else{\n      for(i=1,j=1,k=1;(i<t1s)&&(j<t2s);){\n\tif(t1ns[i]==t2ns[j]){\n\t  ans[k++]=t1ns[i];\n\t  i++; j++;\n\t}else if(t1ns[i]>t2ns[j]){\n\t  ans[k++]=t1ns[i++];\n\t}else{\n\t  ans[k++]=t2ns[j++];\n\t}\n      }\n      if(i<t1s){\n\twhile(i<t1s){\n\t  ans[k++]=t1ns[i++];\n\t}\n      }else if(j<t2s){\n\twhile(j<t2s){\n\t  ans[k++]=t2ns[j++];\n\t}\n      }\n    }\n    for(i=1;i<k;i++){\n      if((2*ans[i-1]+1)==ans[i]){\n\tprintf(\"(\");\n      }else if((ans[i]-ans[i-1])==1){\n\tprintf(\",\");\n      }else{\n\tj=ans[i]%2?ans[i]:ans[i]-1;\n\tfor(node=ans[i-1]%2?ans[i-1]:ans[i-1]-1;\n\t    node!=j;\n\t    node=(node-1)/2)\n\t  printf(\")\");\n\tprintf(\",\");\n      }\n    }\n    for(node=ans[i-1];node;node=(node-1)/2)\n      printf(\")\");\n    printf(\"\\n\");\n\t\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  char w,s1[302],s2[302];\n  int i,j,p1,p2,c1,c2,r,t;\n  while(scanf(\"%c %s %s \",&w,s1,s2)!=EOF){\n    //scanf(\"\\n\");\n    int a[450]={0};\n    int t1[100]={0};\n    int t2[100]={0};\n    t=0;\n    t1[j=0]=0;\n    for(i=0;s1[i];i++){\n      if(s1[i]=='(')t++;\n      if(s1[i]==','){\n\tt1[++j]=t;//printf(\"%d\",t);\n\tif(t==1)c1=j;\n      }\n      if(s1[i]==')')t--;\n    }\n    t1[++j]=0;//printf(\"%d\",c1);\n    //printf(\"\\n\");\n    t=0;\n    t2[j=0]=0;\n    for(i=0;s2[i];i++){\n      if(s2[i]=='(')t++;\n      if(s2[i]==','){\n\tt2[++j]=t;//printf(\"%d\",t);\n\tif(t==1)c2=j;\n      }\n      if(s2[i]==')')t--;\n    }//printf(\"\\n\");\n    t2[++j]=0;//printf(\"%d\",c2);\n    //printf(\"\\n\");\n    a[r=200]=1;\n    p1=c1;\n    p2=c2;\n    while(1){\n      if(t1[--p1]*t2[--p2]==0&&w=='i')break;\n      if(t1[  p1]+t2[  p2]==0&&w=='u')break;\n      if(t1[p1]==t2[p2])a[--r]=t1[p1];\n      else if(t1[p1]>t2[p2]){\n\tif(w=='u')a[--r]=t1[p1];\n\tp2++;\n      }\n      else{\n\tif(w=='u')a[--r]=t2[p2];\n\tp1++;\n      }\n    }\n    r=200;\n    p1=c1;\n    p2=c2;\n    while(1){\n      if(t1[++p1]*t2[++p2]==0&&w=='i')break;\n      if(t1[  p1]+t2[  p2]==0&&w=='u')break;\n      if(t1[p1]==t2[p2])a[++r]=t1[p1];\n      if(t1[p1]>t2[p2]){\n\tif(w=='u')a[++r]=t1[p1];\n\tp2--;\n      }\n      else{\n\tif(w=='u')a[++r]=t2[p2];\n\tp1--;\n      }\n    }\n    t=0;\n    for(i=0;a[i]==0;i++);//for(j=i;a[j];j++)printf(\"%d\",a[j]);\n    // printf(\"\\n\");\n    for(;1;i++){\n      while(t<a[i]){\n\tprintf(\"(\");\n\tt++;\n      }\n      while(t>a[i]){\n\tprintf(\")\");\n\tt--;\n      }\n      if(!t)break;\n      printf(\",\");\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1001\nBinary Tree Intersection And Union\n*/\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint find_comma(char * s)\n{ int i;\n  int depth=0;\n  char c;\n\n  for(i=0;i<strlen(s);i++)\n    {\n      c = s[i];\n      if(c=='(')depth++;\n      if(c==')')depth--;\n      if((depth==1) && (c == ','))\n        return(i);\n    }\n    return(-1);\n}\n\n\nchar *left_node(char *s)\n{\n    int pos;\n    int len;\n    char *ptr;\n  \n     pos=find_comma(s);\n     if(pos == 0||pos==1)\n          return(NULL);\n     else if(pos > 0)\n       {  len = pos -1;\n          ptr = malloc(len+1);\n          strncpy(ptr,&s[1],len);\n          ptr[len]='\\0';\n          return(ptr);\n       }\n\n}\nchar *right_node(char *s)\n{\n    int pos;\n    int len;\n    char *ptr;\n  \n     pos=find_comma(s);\n\n     if(pos == strlen(s)-1||pos==strlen(s)-2)\n          return(NULL);\n     else if(pos > 0)\n       {  len = strlen(s)-pos -2;\n          ptr = malloc(len+1);\n          strncpy(ptr,&s[pos+1],len);\n          ptr[len]='\\0';\n          return(ptr);\n       }\n}\n\nvoid space_trim(char *s)\n{           int i,j;\n            for(i=strlen(s);i--;i>=0)\n              if(isspace(s[i]))\n                for(j=i;j<strlen(s);j++)\n                 s[j]=s[j+1];\n}\n\nchar * binary_tree_cons(char *x,char *y)\n{ int len;\n  char *p;\n  if(NULL == x)\n    if(NULL == y)\n      {  p=malloc(4);\n        strcpy(p,\"(,)\");\n        return(p);\n      }\n    else\n    {  len = strlen(y);\n       p=malloc(len+4);\n       p[0]='(';\n       p[1]=',';\n       strcpy(p+2,y);\n       p[len+2]=')';\n       p[len+3]='\\0';\n    }\n  else\n    if(NULL == y)\n      { len = strlen(x);\n        p=malloc(len+4);\n        p[0]='(';\n        strcpy(p+1,x);\n        p[len+1] = ',';\n        p[len+2] = ')';\n        p[len+3] = '\\0';\n      }\n    else\n      { \n         len = strlen(y)+strlen(x);\n         p=malloc(len+4);\n         p[0]='(';\n         strcpy(p+1,x);\n         p[strlen(x)+1]=',';\n         strcpy(p+strlen(x)+2,y);\n         p[len+2] = ')';\n         p[len+3] = '\\0';\n        \n          \n        }  \n    return(p);\n} \n\n\nchar * binary_tree_union(char *x,char *y)\n{ int len;\n  char *p;\n  if(NULL == x)\n    if(NULL == y)\n      {  return(NULL);\n      }\n    else\n    {  len = strlen(y);\n       p=malloc(len);\n       strcpy(p,y);\n    }\n  else\n    if(NULL == y)\n      { len = strlen(x);\n        p=malloc(len);\n        strcpy(p,x);\n      }\n    else\n      { if(0==strcmp(x,y))\n        { len = strlen(x);\n          p=malloc(len);\n          strcpy(p,x);\n        }\n        else\n          {  \n            p=binary_tree_cons(binary_tree_union (left_node(x),left_node(y)),\n                           binary_tree_union (right_node(x),right_node(y)));\n          }\n      }\n  return(p);\n} \n\n\nchar * binary_tree_intersect(char *x,char *y)\n{ int len;\n  char *p;\n  if((NULL == x) || (NULL == y))\n      {  return(NULL);\n      }\n  else\n      { if(0==strcmp(x,y))\n        { len = strlen(x);\n          p=malloc(len);\n          strcpy(p,x);\n        }\n        else\n          {  \n            p=binary_tree_cons(binary_tree_intersect (left_node(x),left_node(y)),\n                               binary_tree_intersect (right_node(x),right_node(y)));\n          }\n      }\n  return(p);\n} \n\n\n\nmain()\n{\n  char bin1[256],bin2[256];\n  char order;\n\n  \n  while(3 == scanf(\" %c %s %s\",&order,bin1,bin2))\n    {\n\n      \n\n     if(order =='i')\n      printf(\"%s\\n\",binary_tree_intersect(bin1,bin2));\n     else\n      printf(\"%s\\n\",binary_tree_union(bin2,bin1));\n\n\n    }\n  \n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Cell Cell;\nstruct Cell\n{\n  Cell *car;\n  Cell *cdr;\n} heap[ 256 ];\nsize_t heap_n;\nconst char *e;\n\nCell*\nbuildTree (\n  void\n  )\n{\n  Cell *res = NULL;\n\n  switch ( *e )\n  {\n    case '(':\n      ++e;\n      res = &heap[ heap_n++ ];\n      res->car = buildTree ( );\n      ++e;\n      res->cdr = buildTree ( );\n      ++e;\n      break ;\n  }\n\n  return ( res );\n}\n\nvoid\nwriteTree (\n  Cell *s\n  )\n{\n  if ( s == NULL )\n    return ;\n\n  putchar ( '(' );\n  writeTree ( s->car );\n  putchar ( ',' );\n  writeTree ( s->cdr );\n  putchar ( ')' );\n\n  return ;\n}\n\nCell*\nintersectTree (\n  Cell *a,\n  Cell *b\n  )\n{\n  if ( a == NULL || b == NULL )\n    return ( NULL );\n\n  a->car = intersectTree ( a->car, b->car );\n  a->cdr = intersectTree ( a->cdr, b->cdr );\n  return ( a );\n}\n\nCell*\nunionTree (\n  Cell *a,\n  Cell *b\n  )\n{\n  if ( a == NULL )\n    return ( b );\n  if ( b == NULL )\n    return ( a );\n\n  a->car = unionTree ( a->car, b->car );\n  a->cdr = unionTree ( a->cdr, b->cdr );\n  return ( a );\n}\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  for ( ; ; )\n  {\n    char s[ BUFSIZ ];\n    char mode;\n    Cell *a, *b;\n\n    if ( scanf ( \" %c\", &mode ) == EOF )\n      break ;\n\n    heap_n = 0;\n    scanf ( \" %s\", s ); e = s;\n    a = buildTree ( );\n    scanf ( \" %s\", s ); e = s;\n    b = buildTree ( );\n\n    switch ( mode )\n    {\n      case 'i':\n        writeTree ( intersectTree ( a, b ) );\n        break ;\n      case 'u':\n        writeTree ( unionTree ( a, b ) );\n        break ;\n    }\n    puts ( \"\" );\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct node_t_tag {\n\tstruct node_t_tag *left;\n\tstruct node_t_tag *right;\n} node_t;\n\nnode_t node_pool[1000];\nint node_pool_pos=0;\n\nnode_t *create_node(void) {\n\treturn &node_pool[node_pool_pos++];\n}\n\nnode_t *create_tree_i(const char **tree_str) {\n\tnode_t *node=create_node();\n\t(*tree_str)++; /* '(' no hazu */\n\tif(*(*tree_str)=='(') {\n\t\tnode->left=create_tree_i(tree_str);\n\t} else {\n\t\tnode->left=NULL;\n\t}\n\t(*tree_str)++; /* ',' no hazu */\n\tif(*(*tree_str)=='(') {\n\t\tnode->right=create_tree_i(tree_str);\n\t} else {\n\t\tnode->right=NULL;\n\t}\n\t(*tree_str)++; /* ')' no hazu */\n\treturn node;\n}\n\nnode_t *create_tree(const char *tree_str) {\n\treturn create_tree_i(&tree_str);\n}\n\nnode_t *calc(const node_t *tree1,const node_t *tree2,int is_union) {\n\tnode_t *node;\n\tif(tree1==NULL && tree2==NULL)return NULL;\n\tif(!is_union && (tree1==NULL || tree2==NULL))return NULL;\n\tnode=create_node();\n\tnode->left=calc(\n\t\ttree1==NULL?NULL:tree1->left,tree2==NULL?NULL:tree2->left,is_union);\n\tnode->right=calc(\n\t\ttree1==NULL?NULL:tree1->right,tree2==NULL?NULL:tree2->right,is_union);\n\treturn node;\n}\n\nvoid display_tree(const node_t *node) {\n\tputchar('(');\n\tif(node->left!=NULL)display_tree(node->left);\n\tputchar(',');\n\tif(node->right!=NULL)display_tree(node->right);\n\tputchar(')');\n}\n\nint main(void) {\n\tchar query[32];\n\tchar A[1024];\n\tchar B[1024];\n\twhile(node_pool_pos=0,scanf(\"%s%s%s\",query,A,B)==3) {\n\t\tnode_t *tree1=create_tree(A);\n\t\tnode_t *tree2=create_tree(B);\n\t\tnode_t *res=calc(tree1,tree2,query[0]=='u');\n\t\tdisplay_tree(res);\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1001\nBinary Tree Intersection And Union\n*/\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#define DEBUG 0\n\nchar buffer[1000000];\nchar *bptr;\n\nchar * kalloc(int bytes)\n{       \n  char *ptr;\n  ptr = bptr;\n  bptr += (bytes+1);\n  return(ptr);\n}\n\n\nint find_comma(char * s)\n{ int i;\n  int depth=0;\n  char c;\n\n  for(i=0;i<strlen(s);i++)\n    {\n      c = s[i];\n      if(c=='(')depth++;\n      if(c==')')depth--;\n      if((depth==1) && (c == ','))\n        return(i);\n    }\n    return(-1);\n}\n\n\nchar *left_node(char *s)\n{\n    int pos;\n    int len;\n    char *ptr;\n  \n     pos=find_comma(s);\n     if(pos == 0||pos==1||pos==-1)\n          return(NULL);\n     else if(pos > 0)\n       {  len = pos -1;\n          ptr = kalloc(len+2);\n          strncpy(ptr,&s[1],len);\n          ptr[len]='\\0';\n          return(ptr);\n       }\n\n}\nchar *right_node(char *s)\n{\n    int pos;\n    int len;\n    char *ptr;\n  \n     pos=find_comma(s);\n\n     if(pos == strlen(s)-1||pos==strlen(s)-2||pos==-1)\n          return(NULL);\n     else if(pos > 0)\n       {  len = strlen(s)-pos -2;\n          ptr = kalloc(len+1);\n          strncpy(ptr,&s[pos+1],len);\n          ptr[len]='\\0';\n          return(ptr);\n       }\n}\n\nvoid space_trim(char *s)\n{           int i,j;\n            for(i=strlen(s);i--;i>=0)\n              if(isspace(s[i]))\n                for(j=i;j<strlen(s);j++)\n                 s[j]=s[j+1];\n}\n\nchar * binary_tree_cons(char *x,char *y)\n{ int len;\n  char *p;\n\n  /* printf(\"CONS X=%s,Y=%s\\n\",x,y); */\n  \n  if(NULL == x)\n    if(NULL == y)\n      {  p=kalloc(4);\n        strcpy(p,\"(,)\");\n        return(p);\n      }\n    else\n    {  len = strlen(y);\n       p=kalloc(len+4);\n       p[0]='(';\n       p[1]=',';\n       strcpy(p+2,y);\n       p[len+2]=')';\n       p[len+3]='\\0';\n    }\n  else\n    if(NULL == y)\n      { len = strlen(x);\n        p=kalloc(len+4);\n        p[0]='(';\n        strcpy(p+1,x);\n        p[len+1] = ',';\n        p[len+2] = ')';\n        p[len+3] = '\\0';\n      }\n    else\n      { \n         len = strlen(y)+strlen(x);\n         p=kalloc(len+4);\n         p[0]='(';\n         strcpy(p+1,x);\n         p[strlen(x)+1]=',';\n         strcpy(p+strlen(x)+2,y);\n         p[len+2] = ')';\n         p[len+3] = '\\0';\n        \n          \n        }  \n    return(p);\n} \n\n\nchar * binary_tree_union(char *x,char *y)\n{ int len;\n  char *p;\n\n  if(NULL == x)\n    if(NULL == y)\n      {  return(NULL);\n      }\n    else\n    {  len = strlen(y);\n       p=kalloc(len);\n       strcpy(p,y);\n    }\n  else\n    if(NULL == y)\n      { len = strlen(x);\n        p=kalloc(len);\n        strcpy(p,x);\n      }\n    else\n      {\n        if(0==strncmp (\"()\",x,2))\n          {  len = strlen(y);\n            p=kalloc(len);\n            strcpy(p,y);\n          }\n        if(0==strncmp (\"()\",y,2))\n          {  len = strlen(x);\n            p=kalloc(len);\n            strcpy(p,x);\n          }\n        \n        if(0==strcmp(x,y))\n        { len = strlen(x);\n          p=kalloc(len);\n          strcpy(p,x);\n        }\n        else\n          {\n#if DEBUG\n             printf(\"LX=%s,RX=%s,LY=%s,RY=%s\\n\",left_node(x),right_node(x),left_node(y),right_node(y));\n#endif\n            p=binary_tree_cons(binary_tree_union (left_node(x),left_node(y)),\n                               binary_tree_union (right_node(x),right_node(y)));\n          }\n      }\n  return(p);\n} \n\n\nchar * binary_tree_intersect(char *x,char *y)\n{ int len;\n  char *p;\n#if DEBUG\n  printf(\"INTERSECT |%s|%s|\\n\",x,y);\n#endif\n  if((NULL == x) || (NULL == y))\n      {  return(NULL);\n      }\n  \n if(0==strncmp (\"()\",x,2)||0==strncmp (\"()\",y,2))\n    {  p=kalloc(2);\n       strcpy(p,\"()\");\n    }\n  else\n    if(0==strcmp(x,y))\n      {\n        len = strlen(x);\n        p=kalloc(len);\n        strcpy(p,x);\n      }\n    else\n      {  \n        p=binary_tree_cons(binary_tree_intersect (left_node(x),left_node(y)),\n                           binary_tree_intersect (right_node(x),right_node(y)));\n      }\n  return(p);\n} \n\n\n\nmain()\n{\n  static char bin1[400],bin2[400];\n  char order;\n  int i;\n  \n  for(i=0;i<400;i++)\n    bin1[i]=bin2[i]='\\0';\n  bptr=buffer;\n  \n  while(EOF != scanf(\" %c %s %s\",&order,bin1,bin2))\n    {\n#if DEBUG\nprintf(\"OP1=%s OP2=%s\\n\",bin1,bin2);\n#endif\n     if(order =='i')\n      printf(\"%s\\n\",binary_tree_intersect(bin1,bin2));\n     else if(order == 'u')\n      printf(\"%s\\n\",binary_tree_union(bin1,bin2));\n\n\n    }\n  \n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1001\nBinary Tree Intersection And Union\n*/\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n#define DEBUG 0\n\nchar buffer[1000000];\nchar *bptr;\n\nchar * kalloc(int bytes)\n{       \n  char *ptr;\n  ptr = bptr;\n  bptr += (bytes+1);\n  return(ptr);\n}\n\n\nint find_comma(char * s)\n{ int i;\n  int depth=0;\n  char c;\n\n  for(i=0;i<strlen(s);i++)\n    {\n      c = s[i];\n      if(c=='(')depth++;\n      if(c==')')depth--;\n      if((depth==1) && (c == ','))\n        return(i);\n    }\n    return(-1);\n}\n\n\nchar *left_node(char *s)\n{\n    int pos;\n    int len;\n    char *ptr;\n  \n     pos=find_comma(s);\n     if(pos == 0||pos==1||pos==-1)\n          return(NULL);\n     else if(pos > 0)\n       {  len = pos -1;\n          ptr = kalloc(len+2);\n          strncpy(ptr,&s[1],len);\n          ptr[len]='\\0';\n          return(ptr);\n       }\n\n}\nchar *right_node(char *s)\n{\n    int pos;\n    int len;\n    char *ptr;\n  \n     pos=find_comma(s);\n\n     if(pos == strlen(s)-1||pos==strlen(s)-2||pos==-1)\n          return(NULL);\n     else if(pos > 0)\n       {  len = strlen(s)-pos -2;\n          ptr = kalloc(len+1);\n          strncpy(ptr,&s[pos+1],len);\n          ptr[len]='\\0';\n          return(ptr);\n       }\n}\n\nvoid space_trim(char *s)\n{           int i,j;\n            for(i=strlen(s);i--;i>=0)\n              if(isspace(s[i]))\n                for(j=i;j<strlen(s);j++)\n                 s[j]=s[j+1];\n}\n\nchar * binary_tree_cons(char *x,char *y)\n{ int len;\n  char *p;\n\n  /* printf(\"CONS X=%s,Y=%s\\n\",x,y); */\n  \n  if(NULL == x)\n    if(NULL == y)\n      {  p=kalloc(4);\n        strcpy(p,\"(,)\");\n        return(p);\n      }\n    else\n    {  len = strlen(y);\n       p=kalloc(len+4);\n       p[0]='(';\n       p[1]=',';\n       strcpy(p+2,y);\n       p[len+2]=')';\n       p[len+3]='\\0';\n    }\n  else\n    if(NULL == y)\n      { len = strlen(x);\n        p=kalloc(len+4);\n        p[0]='(';\n        strcpy(p+1,x);\n        p[len+1] = ',';\n        p[len+2] = ')';\n        p[len+3] = '\\0';\n      }\n    else\n      { \n         len = strlen(y)+strlen(x);\n         p=kalloc(len+4);\n         p[0]='(';\n         strcpy(p+1,x);\n         p[strlen(x)+1]=',';\n         strcpy(p+strlen(x)+2,y);\n         p[len+2] = ')';\n         p[len+3] = '\\0';\n        \n          \n        }  \n    return(p);\n} \n\n\nchar * binary_tree_union(char *x,char *y)\n{ int len;\n  char *p;\n\n  if(NULL == x)\n    if(NULL == y)\n      {  return(NULL);\n      }\n    else\n    {  len = strlen(y);\n       p=kalloc(len);\n       strcpy(p,y);\n    }\n  else\n    if(NULL == y)\n      { len = strlen(x);\n        p=kalloc(len);\n        strcpy(p,x);\n      }\n    else\n      {\n        if(0==strncmp (\"()\",x,2))\n          {  len = strlen(y);\n            p=kalloc(len);\n            strcpy(p,y);\n          }\n        if(0==strncmp (\"()\",y,2))\n          {  len = strlen(x);\n            p=kalloc(len);\n            strcpy(p,x);\n          }\n        \n        if(0==strcmp(x,y))\n        { len = strlen(x);\n          p=kalloc(len);\n          strcpy(p,x);\n        }\n        else\n          {\n#if DEBUG\n             printf(\"LX=%s,RX=%s,LY=%s,RY=%s\\n\",left_node(x),right_node(x),left_node(y),right_node(y));\n#endif\n            p=binary_tree_cons(binary_tree_union (left_node(x),left_node(y)),\n                               binary_tree_union (right_node(x),right_node(y)));\n          }\n      }\n  return(p);\n} \n\n\nchar * binary_tree_intersect(char *x,char *y)\n{ int len;\n  char *p;\n#if DEBUG\n  printf(\"INTERSECT |%s|%s|\\n\",x,y);\n#endif\n  if((NULL == x) || (NULL == y))\n      {  return(NULL);\n      }\n  \n if(0==strncmp (\"()\",x,2)||0==strncmp (\"()\",y,2))\n    {  p=kalloc(2);\n       strcpy(p,\"()\");\n    }\n  else\n    if(0==strcmp(x,y))\n      {\n        len = strlen(x);\n        p=kalloc(len);\n        strcpy(p,x);\n      }\n    else\n      {  \n        p=binary_tree_cons(binary_tree_intersect (left_node(x),left_node(y)),\n                           binary_tree_intersect (right_node(x),right_node(y)));\n      }\n  return(p);\n} \n\n\n\nmain()\n{\n  static char bin1[256],bin2[256];\n  char order;\n  int i;\n  \n  for(i=0;i<256;i++)\n    bin1[i]=bin2[i]='\\0';\n  bptr=buffer;\n  \n  while(EOF != scanf(\" %c %s %s\",&order,bin1,bin2))\n    {\n#if DEBUG\nprintf(\"OP1=%s OP2=%s\\n\",bin1,bin2);\n#endif\n     if(order =='i')\n      printf(\"%s\\n\",binary_tree_intersect(bin1,bin2));\n     else if(order == 'u')\n      printf(\"%s\\n\",binary_tree_union(bin1,bin2));\n\n\n    }\n  \n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "char tree1[301],tree2[301];\np1,p2,disp;\nSkip(char*tree,int*pp){\n\tint h=0;\n\tdo{\n\t\tif(tree[*pp]=='(')\n\t\t\th++;\n\t\tif(tree[*pp]==')')\n\t\t\th--;\n\t\tif(disp)\n\t\t\tputchar(tree[*pp]);\n\t\t++*pp;\n\t}while(h);\n}\nR(disp){\n\tif(tree1[p1]=='('&&tree2[p2]=='('){\n\t\tputchar('(');\n\t\tp1++,p2++;\n\t\tR();\n\t\tif(tree1[p1]!=','||tree2[p2]!=',')\n\t\t\texit(puts(\"error','\"));\n\t\tputchar(',');\n\t\tp1++,p2++;\n\t\tR();\n\t\tif(tree1[p1]!=')'||tree2[p2]!=')')\n\t\t\texit(puts(\"error')'\"));\n\t\tputchar(')');\n\t\tp1++,p2++;\n\t}else{\n\t\tif(tree1[p1]=='(')\n\t\t\tSkip(tree1,&p1);\n\t\tif(tree2[p2]=='(')\n\t\t\tSkip(tree2,&p2);\n\t}\n}\nmain(){\n\tchar ope[2];\n\tfor(;~scanf(\"%s%s%s\",ope,tree1,tree2);){\n\t\tp1=p2=0;\n\t\tdisp=*ope=='u';\n\t\tR();\n\t\tputs(\"\");\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1001: Binary Tree Intersection And Union\n// 2017.12.14 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int l, r, c; } T;\nT node[210]; int sz;\nchar buf[1210], *p;\nchar ans[610], *q;\n\nchar *parse(char *p, int i)\n{\n\tnode[i].c++; p++;\n\tif (*p != ',') {\n\t    if (node[i].l == 0) node[i].l = sz++;\n\t\tp = parse(p, node[i].l);\n\t}\n\tp++;\n\tif (*p != ')') {\n\t\tif (node[i].r == 0) node[i].r = sz++;\n\t    p = parse(p, node[i].r);\n\t}\n\treturn p+1;\n}\n\nchar *act(char *q, int i, int k)\n{\n\tif (node[i].c < k) return q;\n\t*q++ = '(';\n\tif (node[i].l > 0) q = act(q, node[i].l, k);\n\t*q++ = ',';\n\tif (node[i].r > 0) q = act(q, node[i].r, k);\n\t*q++ = ')';\n\treturn q;\n}\n\nint main()\n{\n\tint op;\n\tchar *a, *b;\n\n\twhile (fgets(p=buf, 400, stdin) != NULL) {\n\t\tmemset(node, 0, sizeof(node));\n\n\t\top = *p, p+=2;\n\t\ta = p; while (*p != ' ') p++; *p++ = 0;\n\t\tb = p;\n\t\tsz = 1;\n\t\tparse(a, 0);\n\t\tparse(b, 0);\n\n\t\tq = act(ans, 0, op == 'i' ? 2 : 1), *q = 0;\n\t\tputs(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "char*p1,*p2,t1[301],t2[301];\nd;\nS(q){\n\tchar*p=q,h=0;\n\tfor(;h+=*p==40;p++)\n\t\th-=*p==41,d&&putchar(*p);\n\treturn p;\n}\nR(){\n\tif(*p1==40&&*p2==40){\n\t\tputchar(*p1++);\n\t\tR(p2++);\n\t\tputchar(*p1++);\n\t\tR(p2++);\n\t\tputchar(*p1++);\n\t\tp2++;\n\t}else{\n\t\tp1=S(p1);\n\t\tp2=S(p2);\n\t}\n}\nmain(){\n\tfor(;~scanf(\"%s%s%s\",&d,p1=t1,p2=t2);puts(\"\"))\n\t\tR(d&=4);\n}"
  },
  {
    "language": "C",
    "code": "char*p,*q,*c;d;S(h){for(h=0;h+=*c<41;h-=*c++&1)d&4&&putchar(*c);}R(i){for(i=*p&7|*q&7?S(c=p),p=c,S(c=q),q=c,0:3;i--;i&&R())putchar(*p++),q++;}main(){for(;~scanf(\"%s%as%as\",&d,&p,&q);puts(\"\"))R();}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  char w,s1[302],s2[302];\n  int i,j,p1,p2,c1,c2,r,t;\n  while(scanf(\"%c %s %s \",&w,s1,s2)!=EOF){\n    //scanf(\"\\n\");\n    int a[450]={0};\n    int t1[100]={0};\n    int t2[100]={0};\n    t=0;\n    t1[j=0]=0;\n    for(i=0;s1[i];i++){\n      if(s1[i]=='(')t++;\n      if(s1[i]==','){\n\tt1[++j]=t;//printf(\"%d\",t);\n\tif(t==1)c1=j;\n      }\n      if(s1[i]==')')t--;\n    }\n    t1[++j]=0;//printf(\"%d\",c1);\n    //printf(\"\\n\");\n    t=0;\n    t2[j=0]=0;\n    for(i=0;s2[i];i++){\n      if(s2[i]=='(')t++;\n      if(s2[i]==','){\n\tt2[++j]=t;//printf(\"%d\",t);\n\tif(t==1)c2=j;\n      }\n      if(s2[i]==')')t--;\n    }//printf(\"\\n\");\n    t2[++j]=0;//printf(\"%d\",c2);\n    //printf(\"\\n\");\n    a[r=200]=1;\n    p1=c1;\n    p2=c2;\n    while(1){\n      if(t1[--p1]*t2[--p2]==0&&w=='i')break;\n      if(t1[  p1]+t2[  p2]==0&&w=='u')break;\n      if(t1[p1]==t2[p2])a[--r]=t1[p1];\n      else if(t1[p1]>t2[p2]){\n\tif(w=='u')a[--r]=t1[p1];\n\tp2++;\n      }\n      else{\n\tif(w=='u')a[--r]=t2[p2];\n\tp1++;\n      }\n    }\n    r=200;\n    p1=c1;\n    p2=c2;\n    while(1){\n      if(t1[++p1]*t2[++p2]==0&&w=='i')break;\n      if(t1[  p1]+t2[  p2]==0&&w=='u')break;\n      if(t1[p1]==t2[p2])a[++r]=t1[p1];\n      if(t1[p1]>t2[p2]){\n\tif(w=='u')a[++r]=t1[p1];\n\tp2--;\n      }\n      else{\n\tif(w=='u')a[++r]=t2[p2];\n\tp1--;\n      }\n    }\n    t=0;\n    for(i=0;a[i]==0;i++);//for(j=i;a[j];j++)printf(\"%d\",a[j]);\n    printf(\"\\n\");\n    for(;1;i++){\n      while(t<a[i]){\n\tprintf(\"(\");\n\tt++;\n      }\n      while(t>a[i]){\n\tprintf(\")\");\n\tt--;\n      }\n      if(!t)break;\n      printf(\",\");\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1001: Binary Tree Intersection And Union\n// 2017.12.14 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int l, r, c; } T;\nT node[210]; int sz;\nchar buf[1210], *p;\nchar ans[610], *q;\n\nchar *parse(char *p, int i)\n{\n\tnode[i].c++; p++;\n\tif (*p != ',') {\n\t    if (node[i].l == 0) node[i].l = sz++;\n\t\tp = parse(p, node[i].l);\n\t}\n\tp++;\n\tif (*p != ')') {\n\t\tif (node[i].r == 0) node[i].r = sz++;\n\t    p = parse(p, node[i].r);\n\t}\n\treturn p+1;\n}\n\nchar *act(char *q, int i, int k)\n{\n\tif (node[i].c < k) return q;\n\t*q++ = '(';\n\tif (node[i].l > 0) q = act(q, node[i].l, k);\n\t*q++ = ',';\n\tif (node[i].r > 0) q = act(q, node[i].r, k);\n\t*q++ = ')';\n\treturn q;\n}\n\nint main()\n{\n\tint op;\n\tchar *a, *b;\n\n\twhile (fgets(p=buf, 1210, stdin) != NULL) {\n\t\tmemset(node, 0, sizeof(node));\n\n\t\top = *p, p+=2;\n\t\ta = p; while (*p != ' ') p++; *p++ = 0;\n\t\tb = p;\n\t\tsz = 1;\n\t\tparse(a, 0);\n\t\tparse(b, 0);\n\n\t\tq = act(ans, 0, op == 'i' ? 2 : 1), *q = 0;\n\t\tputs(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\n\nstruct Tree{\n\tTree *l,*r;\n\tTree():l(0),r(0){}\n\t~Tree(){delete l;delete r;}\n};\n\nTree* to_t(string s){\n\tTree *t=new Tree();\n\tif(s==\"\")return 0;\n\tif(s==\"(,)\")return t;\n\tint lev=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tif(s[i]=='(')lev++;\n\t\telse if(s[i]==')')lev--;\n\t\telse if(lev==1&&s[i]==','){\n\t\t\tt->l=to_t(s.substr(1,i-1));\n\t\t\tt->r=to_t(s.substr(i+1,s.size()-(i+1)-1));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn t;\n}\nstring intersection(Tree *s,Tree *t){\n\tstring res;\n\tif(!s||!t)return res;\n\tres+='(';\n\tres+=intersection(s->l,t->l);\n\tres+=',';\n\tres+=intersection(s->r,t->r);\n\tres+=')';\n\treturn res;\n}\nstring _union(Tree *s,Tree *t){\n\tstring res;\n\tif(!s&&!t)return res;\n\tres+='(';\n\tres+=_union(s?s->l:0,t?t->l:0);\n\tres+=',';\n\tres+=_union(s?s->r:0,t?t->r:0);\n\tres+=')';\n\treturn res;\n}\n\n\nint main(){\n\tchar op;\n\tstring a,b;\n\tTree * s,*t;\n\twhile(cin>>op>>a>>b){\n\t\ts=to_t(a);\n\t\tt=to_t(b);\n\t\tif(op=='i')cout<<intersection(s,t)<<endl;\n\t\telse cout<<_union(s,t)<<endl;\n\t\tdelete s;\n\t\tdelete t;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1001\nBinary Tree Intersection And Union\n*/\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar buffer[1000000];\nchar *bptr;\n\nchar * kalloc(int bytes)\n{       \n  char *ptr;\n  ptr = bptr;\n  bptr += (bytes+1);\n  return(ptr);\n}\n\n\nint find_comma(char * s)\n{ int i;\n  int depth=0;\n  char c;\n\n  for(i=0;i<strlen(s);i++)\n    {\n      c = s[i];\n      if(c=='(')depth++;\n      if(c==')')depth--;\n      if((depth==1) && (c == ','))\n        return(i);\n    }\n    return(-1);\n}\n\n\nchar *left_node(char *s)\n{\n    int pos;\n    int len;\n    char *ptr;\n  \n     pos=find_comma(s);\n     if(pos == 0||pos==1||pos==-1)\n          return(NULL);\n     else if(pos > 0)\n       {  len = pos -1;\n          ptr = kalloc(len+2);\n          strncpy(ptr,&s[1],len);\n          ptr[len]='\\0';\n          return(ptr);\n       }\n\n}\nchar *right_node(char *s)\n{\n    int pos;\n    int len;\n    char *ptr;\n  \n     pos=find_comma(s);\n\n     if(pos == strlen(s)-1||pos==strlen(s)-2||pos==-1)\n          return(NULL);\n     else if(pos > 0)\n       {  len = strlen(s)-pos -2;\n          ptr = kalloc(len+1);\n          strncpy(ptr,&s[pos+1],len);\n          ptr[len]='\\0';\n          return(ptr);\n       }\n}\n\nvoid space_trim(char *s)\n{           int i,j;\n            for(i=strlen(s);i--;i>=0)\n              if(isspace(s[i]))\n                for(j=i;j<strlen(s);j++)\n                 s[j]=s[j+1];\n}\n\nchar * binary_tree_cons(char *x,char *y)\n{ int len;\n  char *p;\n\n  /* printf(\"CONS X=%s,Y=%s\\n\",x,y); */\n  \n  if(NULL == x)\n    if(NULL == y)\n      {  p=kalloc(4);\n        strcpy(p,\"(,)\");\n        return(p);\n      }\n    else\n    {  len = strlen(y);\n       p=kalloc(len+4);\n       p[0]='(';\n       p[1]=',';\n       strcpy(p+2,y);\n       p[len+2]=')';\n       p[len+3]='\\0';\n    }\n  else\n    if(NULL == y)\n      { len = strlen(x);\n        p=kalloc(len+4);\n        p[0]='(';\n        strcpy(p+1,x);\n        p[len+1] = ',';\n        p[len+2] = ')';\n        p[len+3] = '\\0';\n      }\n    else\n      { \n         len = strlen(y)+strlen(x);\n         p=kalloc(len+4);\n         p[0]='(';\n         strcpy(p+1,x);\n         p[strlen(x)+1]=',';\n         strcpy(p+strlen(x)+2,y);\n         p[len+2] = ')';\n         p[len+3] = '\\0';\n        \n          \n        }  \n    return(p);\n} \n\n\nchar * binary_tree_union(char *x,char *y)\n{ int len;\n  char *p;\n\n  if(strncmp (\"()\",x,2))\n    {  len = strlen(y);\n       p=kalloc(len);\n       strcpy(p,y);\n    }\n  if(strncmp (\"()\",y,2))\n    {  len = strlen(x);\n       p=kalloc(len);\n       strcpy(p,x);\n    }\n  if(NULL == x)\n    if(NULL == y)\n      {  return(NULL);\n      }\n    else\n    {  len = strlen(y);\n       p=kalloc(len);\n       strcpy(p,y);\n    }\n  else\n    if(NULL == y)\n      { len = strlen(x);\n        p=kalloc(len);\n        strcpy(p,x);\n      }\n    else\n      { if(0==strcmp(x,y))\n        { len = strlen(x);\n          p=kalloc(len);\n          strcpy(p,x);\n        }\n        else\n          { /* printf(\"LX=%s,RX=%s,LY=%s,RY=%s\",left_node(x),right_node(x),left_node(y),right_node(y));\n             printf(\"\\n\");*/\n            p=binary_tree_cons(binary_tree_union (left_node(x),left_node(y)),\n                               binary_tree_union (right_node(x),right_node(y)));\n          }\n      }\n  return(p);\n} \n\n\nchar * binary_tree_intersect(char *x,char *y)\n{ int len;\n  char *p;\n  if(strncmp (\"()\",x,2)||strncmp (\"()\",y,2))\n    {  p=kalloc(2);\n       strcpy(p,\"()\");\n    }\n  if((NULL == x) || (NULL == y))\n      {  return(NULL);\n      }\n  else\n      { if(0==strcmp(x,y))\n        { len = strlen(x);\n          p=kalloc(len);\n          strcpy(p,x);\n        }\n        else\n          {  \n            p=binary_tree_cons(binary_tree_intersect (left_node(x),left_node(y)),\n                               binary_tree_intersect (right_node(x),right_node(y)));\n          }\n      }\n  return(p);\n} \n\n\n\nmain()\n{\n  char bin1[256],bin2[256];\n  char order;\n\n  bptr=buffer;\n  \n  while(3 == scanf(\" %c %s %s\",&order,bin1,bin2))\n    {\n\n/*    printf(\"LN=%s\\n\",left_node(bin1)); */\n\n     if(order =='i')\n      printf(\"%s\\n\",binary_tree_intersect(bin1,bin2));\n     else\n      printf(\"%s\\n\",binary_tree_union(bin1,bin2));\n\n\n    }\n  \n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint main(){\n  //ui 0:union 1:intersection\n  int i,j,k,node,t1s,t2s,ui,t1ns[105],t2ns[105],ans[210];\n  char buf[1000],*t1,*t2;\n  ans[0]=t1ns[0]=t2ns[0]=0;\n  while(fgets(buf,1000,stdin)!=NULL){\n    ui=buf[0]=='i'?1:0;\n    t1=buf+2;\n    t2=strchr(t1,' ');\n    t2[0]='\\0';\n    t2++;\n\n    for(i=0,node=0,t1s=1;t1[i];i++){\n      if(t1[i]=='('){\n\tnode=node*2+1;\n\tt1ns[t1s++]=node;\n      }else if(t1[i]==','){\n\tnode++;\n\tt1ns[t1s++]=node;\n      }else if(t1[i]==')'){\n\tif(node%2==0) node--;\n\tnode=(node-1)/2;\n      }\n    }\n    for(i=0,node=0,t2s=1;t2[i];i++){\n      if(t2[i]=='('){\n\tnode=node*2+1;\n\tt2ns[t2s++]=node;\n      }else if(t2[i]==','){\n\tnode++;\n\tt2ns[t2s++]=node;\n      }else if(t2[i]==')'){\n\tif(node%2==0) node--;\n\tnode=(node-1)/2;\n      }\n    }\n    \n\n    if(ui==1){\n      for(i=1,j=1,k=1;(i<t1s)&&(j<t2s);){\n\tif(t1ns[i]==t2ns[j]){\n\t  ans[k++]=t1ns[i];\n\t  i++; j++;\n\t}else if(t1ns[i]<t2ns[j]){\n\t  j++;\n\t}else{\n\t  i++;\n\t}\n      }\n    }else{\n      for(i=1,j=1,k=1;(i<t1s)&&(j<t2s);){\n\tif(t1ns[i]==t2ns[j]){\n\t  ans[k++]=t1ns[i];\n\t  i++; j++;\n\t}else if(t1ns[i]>t2ns[j]){\n\t  ans[k++]=t1ns[i++];\n\t}else{\n\t  ans[k++]=t2ns[j++];\n\t}\n      }\n      if(i<t1s){\n\twhile(i<t1s){\n\t  ans[k++]=t1ns[i++];\n\t}\n      }else if(j<t2s){\n\twhile(j<t2s){\n\t  ans[k++]=t2ns[j++];\n\t}\n      }\n    }\n    for(i=1;i<k;i++){\n      if((2*ans[i-1]+1)==ans[i]){\n\tprintf(\"(\");\n      }else if((ans[i]-ans[i-1])==1){\n\tprintf(\",\");\n      }else{\n\tj=ans[i]%2?ans[i]:ans[i]-1;\n\tfor(node=ans[i-1]%2?ans[i-1]:ans[i-1]-1;\n\t    node!=j;\n\t    node=(node-1)/2)\n\t  printf(\")\");\n\tprintf(\",\");\n      }\n    }\n    for(node=ans[i-1];node;node=(node-1)/2)\n      printf(\")\");\n    printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(){\n    int a, b;\n    while( scanf(\"%d %d\", &a, &b) != EOF ){\n        printf(\"%d\\n\", a + b);\n    }\n    return 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "\ninterface Tree{\n    fun intersection(other:Tree):Tree\n    fun union(other:Tree):Tree\n    companion object {\n        fun parse(str:String):Tree {\n            val (tree, _) = parse(str, 0)\n            return tree\n        }\n        private fun parse(str:String, left:Int):Pair<Tree, Int> {\n            return when{\n                str[left] == '(' -> {\n                    val (leftNode, pos) = parse(str, left + 1)\n                    val (rightNode, pos2) = parse(str, pos + 1)\n                    Pair(Node(leftNode, rightNode), pos2 + 1)\n                }\n                else -> Pair(Leaf, left)\n            }\n        }\n    }\n}\nobject Leaf : Tree{\n    override fun union(other: Tree): Tree {\n        return other\n    }\n\n    override fun intersection(other:Tree): Tree {\n        return this\n    }\n\n    override fun toString(): String {\n        return \"\"\n    }\n}\nclass Node constructor(private var leftNode:Tree = Leaf, private var rightNode:Tree= Leaf): Tree {\n    override fun intersection(other: Tree): Tree {\n        return when(other){\n            is Node -> Node(leftNode.intersection(other.leftNode), rightNode.intersection(other.rightNode))\n            else -> Leaf\n        }\n    }\n\n    override fun union(other: Tree): Tree {\n        return when(other){\n            is Node -> Node(leftNode.union(other.leftNode), rightNode.union(other.rightNode))\n            else -> this\n        }\n    }\n\n    override fun toString(): String {\n        return \"($leftNode,$rightNode)\"\n    }\n}\n\nfun main(args:Array<String>):Unit {\n    var str:String? = readLine()\n    while (str != null){\n        val (order, a, b) = str!!.split(' ')\n        println(when(order){\n            \"i\" -> Tree.parse(a).intersection(Tree.parse(b))\n            else -> Tree.parse(a).union(Tree.parse(b))\n        })\n        str = readLine()\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import DataStructure.BinaryIndexedTreeTemplate\n\ninterface Tree{\n    fun intersection(other:Tree):Tree\n    fun union(other:Tree):Tree\n    companion object {\n        fun parse(str:String):Tree {\n            val (tree, _) = parse(str, 0)\n            return tree\n        }\n        private fun parse(str:String, left:Int):Pair<Tree, Int> {\n            return when{\n                str[left] == '(' -> {\n                    val (leftNode, pos) = parse(str, left + 1)\n                    val (rightNode, pos2) = parse(str, pos + 1)\n                    Pair(Node(leftNode, rightNode), pos2 + 1)\n                }\n                else -> Pair(Leaf, left)\n            }\n        }\n    }\n}\nobject Leaf : Tree{\n    override fun union(other: Tree): Tree {\n        return other\n    }\n\n    override fun intersection(other:Tree): Tree {\n        return this\n    }\n\n    override fun toString(): String {\n        return \"\"\n    }\n}\nclass Node constructor(private var leftNode:Tree = Leaf, private var rightNode:Tree= Leaf): Tree {\n    override fun intersection(other: Tree): Tree {\n        return when(other){\n            is Node -> Node(leftNode.intersection(other.leftNode), rightNode.intersection(other.rightNode))\n            else -> Leaf\n        }\n    }\n\n    override fun union(other: Tree): Tree {\n        return when(other){\n            is Node -> Node(leftNode.union(other.leftNode), rightNode.union(other.rightNode))\n            else -> this\n        }\n    }\n\n    override fun toString(): String {\n        return \"($leftNode,$rightNode)\"\n    }\n}\n\nfun main(args:Array<String>):Unit {\n    var str:String? = readLine()\n    while (str != null){\n        val (order, a, b) = str!!.split(' ')\n        println(when(order){\n            \"i\" -> Tree.parse(a).intersection(Tree.parse(b))\n            else -> Tree.parse(a).union(Tree.parse(b))\n        })\n        str = readLine()\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "\ninterface Tree{\n    fun intersection(other:Tree):Tree\n    fun union(other:Tree):Tree\n    companion object {\n        fun parse(str:String):Tree {\n            val (tree, _) = parse(str, 0)\n            return tree\n        }\n        private fun parse(str:String, left:Int):Pair<Tree, Int> {\n            return when{\n                str[left] == '(' -> {\n                    val (leftNode, pos) = parse(str, left + 1)\n                    val (rightNode, pos2) = parse(str, pos + 1)\n                    Pair(Node(leftNode, rightNode), pos2 + 1)\n                }\n                else -> Pair(Leaf, left)\n            }\n        }\n    }\n}\nobject Leaf : Tree{\n    override fun union(other: Tree): Tree {\n        return other\n    }\n\n    override fun intersection(other:Tree): Tree {\n        return this\n    }\n\n    override fun toString(): String {\n        return \"\"\n    }\n}\nclass Node constructor(private var leftNode:Tree = Leaf, private var rightNode:Tree= Leaf): Tree {\n    override fun intersection(other: Tree): Tree {\n        return when(other){\n            is Node -> Node(leftNode.intersection(other.leftNode), rightNode.intersection(other.rightNode))\n            else -> Leaf\n        }\n    }\n\n    override fun union(other: Tree): Tree {\n        return when(other){\n            is Node -> Node(leftNode.union(other.leftNode), rightNode.union(other.rightNode))\n            else -> this\n        }\n    }\n\n    override fun toString(): String {\n        return \"($leftNode,$rightNode)\"\n    }\n}\n\nfun main(args:Array<String>):Unit {\n    var str:String? = readLine()\n    while (str != null){\n        val (order, a, b) = str.split(' ')\n        println(when(order){\n            \"i\" -> Tree.parse(a).intersection(Tree.parse(b))\n            else -> Tree.parse(a).union(Tree.parse(b))\n        })\n        str = readLine()\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nclass Main {\n    Scanner sc = new Scanner(System.in);\n\n    static class Tree{\n    \tTree left;\n    \tTree right;\n    \tTree(){\n    \t}\n    \tTree(String s){\n    \t\tint bc=0;\n    \t\tint i=0;\n    \t\tfor(;i<s.length();i++){\n    \t\t\tif(s.charAt(i)=='(')bc++;\n    \t\t\tif(s.charAt(i)==')')bc--;\n    \t\t\tif(s.charAt(i)==',' && bc==1){\n    \t\t\t\tif(i>1){\n    \t\t\t\t\tleft=new Tree(s.substring(1,i));\n    \t\t\t\t}\n    \t\t\t\tif(i+1<s.length()-1){\n    \t\t\t\t\tright=new Tree(s.substring(i+1,s.length()-1));\n    \t\t\t\t}\n    \t\t\t\treturn;\n    \t\t\t}\n    \t\t}\n    \t}\n    \tpublic static Tree Intersect(Tree a,Tree b){\n    \t\tif(a!=null && b!=null){\n    \t\t\tTree tree=new Tree();\n    \t\t\tif(a.left!=null && b.left!=null){\n\t    \t\t\ttree.left=Intersect(a.left,b.left);\n\t    \t\t}\n\t    \t\tif(a.right!=null && b.right!=null){\n\t    \t\t\ttree.right=Intersect(a.right,b.right);\n\t    \t\t}\n\t    \t\treturn tree;\n    \t\t}\n    \t\treturn null;\n    \t}\n    \tpublic static Tree Union(Tree a,Tree b){\n    \t\tif(a==null && b==null){\n    \t\t\treturn null;\n    \t\t}\n    \t\tTree tree=new Tree();\n    \t\tif((a!=null && a.left!=null) || (b!=null && b.left!=null)){\n    \t\t\ttree.left=Union(a!=null?a.left:null,b!=null?b.left:null);\n    \t\t}\n    \t\tif((a!=null && a.right!=null) || (b!=null && b.right!=null)){\n    \t\t\ttree.right=Union(a!=null?a.right:null,b!=null?b.right:null);\n    \t\t}\n    \t\treturn tree;\n    \t}\n\n\n    \tpublic String toString(){\n    \t\treturn \"(\"+(left!=null?left:\"\")+\",\"+(right!=null?right:\"\")+\")\";\n    \t}\n    }\n\n    public void run() {\n        while(sc.hasNext()){\n        \tString key=sc.next(),a=sc.next(),b=sc.next();\n        \tTree ta=new Tree(a);\n        \tTree tb=new Tree(b);\n        \tif(\"i\".equals(key)){\n        \t\tln(Tree.Intersect(ta, tb));\n        \t}else if(\"u\".equals(key)){\n        \t\tln(Tree.Union(ta, tb));\n        \t}else{\n        \t}\n        }\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n    public static void pr(Object o) {\n        System.out.print(o);\n    }\n    public static void ln(Object o) {\n        System.out.println(o);\n    }\n    public static void ln() {\n        System.out.println();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class A {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\twhile (sc.hasNext()) {\n\t\t\tchar query = sc.next().charAt(0);\n\t\t\tString tree1 = sc.next();\n\t\t\tString tree2 = sc.next();\n\t\t\tNode root = new Node();\n\t\t\tparse(tree1, 0, root, 1);\n\t\t\tparse(tree2, 0, root, 2);\n\t\t\troot.write(query == 'u');\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic int parse(String tree, int pos, Node cur, int val) {\n\t\tcur.val += val;\n\t\t++pos;\n\t\tif (tree.charAt(pos) == '(') {\n\t\t\tif (cur.left == null) {\n\t\t\t\tcur.left = new Node();\n\t\t\t}\n\t\t\tpos = parse(tree, pos, cur.left, val);\n\t\t}\n\t\t++pos;\n\t\tif (tree.charAt(pos) == '(') {\n\t\t\tif (cur.right == null) {\n\t\t\t\tcur.right = new Node();\n\t\t\t}\n\t\t\tpos = parse(tree, pos, cur.right, val);\n\t\t}\n\t\treturn pos + 1;\n\t}\n\n\tstatic class Node {\n\t\tNode left;\n\t\tNode right;\n\t\tint val = 0;\n\n\t\tboolean match(boolean union) {\n\t\t\tif (union) {\n\t\t\t\treturn this.val > 0;\n\t\t\t} else {\n\t\t\t\treturn this.val == 3;\n\t\t\t}\n\t\t}\n\n\t\tvoid write(boolean union) {\n\t\t\tif (!match(union)) return;\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (this.left != null) this.left.write(union);\n\t\t\tSystem.out.print(\",\");\n\t\t\tif (this.right != null) this.right.write(union);\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n \npublic class Main {\n  \n\tpublic static class Binary{\n\t\tBinary left, right;\n\n\t\tpublic Binary(Binary left, Binary right) {\n\t\t\tsuper();\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn \"(\" + (left == null ? \"\" : left) + \",\" + (right == null ? \"\" : right) + \")\";\n\t\t}\n\t\t\n\t\tpublic static Binary add(Binary fst, Binary snd){\n\t\t\tif(fst == null && snd == null){\n\t\t\t\treturn null;\n\t\t\t}else if(fst == null){\n\t\t\t\treturn new Binary(Binary.add(null, snd.left), Binary.add(null, snd.right));\n\t\t\t}else if(snd == null){\n\t\t\t\treturn new Binary(Binary.add(fst.left, null), Binary.add(fst.right, null));\n\t\t\t}else{\n\t\t\t\treturn new Binary(Binary.add(fst.left, snd.left), Binary.add(fst.right, snd.right));\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static Binary mul(Binary fst, Binary snd){\n\t\t\tif(fst == null || snd == null){\n\t\t\t\treturn null;\n\t\t\t}else{\n\t\t\t\treturn new Binary(Binary.mul(fst.left, snd.left), Binary.mul(fst.right, snd.right));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static Binary parse(char[] input, int start, int end){\n\t\tif(start > end){\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tif(input[start] == '('){\n\t\t\tint c_lv = 1;\n\t\t\tint t_pos = -1;\n\t\t\tint c_end = -1;\n\t\t\tfor(int pos = start + 1; pos <= end; pos++){\n\t\t\t\tif(input[pos] == '('){\n\t\t\t\t\tc_lv++;\n\t\t\t\t}else if(input[pos] == ')'){\n\t\t\t\t\tc_lv--;\n\t\t\t\t\tif(c_lv == 0){\n\t\t\t\t\t\tc_end = pos;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}else if(c_lv == 1 && input[pos] == ','){\n\t\t\t\t\tt_pos = pos;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn new Binary(parse(input, start + 1, t_pos - 1), parse(input, t_pos + 1, c_end - 1));\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n         \n        while(sc.hasNext()){\n        \tString ops = sc.next();\n        \tString fst = sc.next();\n        \tString snd = sc.next();\n        \t\n        \t//System.out.println(fst + \" \" + snd);\n        \t\n        \tBinary fst_b = parse(fst.toCharArray(), 0, fst.length() - 1);\n        \tBinary snd_b = parse(snd.toCharArray(), 0, snd.length() - 1);\n        \t\n        \t//System.out.println(fst_b + \" \" + snd_b);\n        \t\n        \tSystem.out.println(ops.equals(\"u\") ? Binary.add(fst_b, snd_b) : Binary.mul(fst_b, snd_b));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main {\n\n        public static void main(String[] args) throws IOException {\n                BufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\n                String s;\n                String t[];\n                while((s = r.readLine()) != null){\n                        t = s.split(\"[ ]\");\n                        if(t[0].equals(\"i\")){\n                                print_i(t[1],t[2]);\n                        } else if(t[0].equals(\"u\")){\n                                print_u(t[1],t[2]);\n                        }   \n                }   \n        }   \n        static void print_i(String a, String b){ \n                int i = 0,j = 0;\n                while(i < a.length() && j < b.length()){\n                        if(a.charAt(i) == b.charAt(j)){\n                                System.out.print(a.charAt(i));\n                                i++;j++;\n                        } else if(a.charAt(i) == '('){\n                                while(a.charAt(i++) != ')'){\n                                }   \n                        } else if(b.charAt(j) == '('){\n                                while(b.charAt(j++) != ')'){\n                                }   \n                        }   \n                }   \n                System.out.println(\"\");\n        }   \n\n        static void print_u(String a, String b){ \n                int i = 0,j = 0;\n                while(i < a.length() && j < b.length()){\n                        if(a.charAt(i) == b.charAt(j)){\n                                System.out.print(a.charAt(i));\n                                ++i;++j;\n                        } else if(a.charAt(i) == '('){\n                                while(a.charAt(i) != ')'){\n                                        System.out.print(a.charAt(i));\n                                        ++i;\n                                }\n                                System.out.print(a.charAt(i));\n                                ++i;\n                        } else if(b.charAt(j) == '('){\n                                while(b.charAt(j) != ')'){\n                                        System.out.print(b.charAt(j));\n                                        ++j;\n                                }\n                                System.out.print(b.charAt(j));\n                                ++j;\n                        }\n                }\n                System.out.println(\"\");\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main {\n\n        public static void main(String[] args) throws IOException {\n                BufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\n                String s;\n                String t[];\n                while((s = r.readLine()) != null){\n                        t = s.split(\"[ ]\");\n                        if(t[0].equals(\"i\")){\n                                print_i(t[1],t[2]);\n                        } else if(t[0].equals(\"u\")){\n                                print_u(t[1],t[2]);\n                        }\n                }\n        }\n        static void print_i(String a, String b){\n                int i = 0,j = 0;\n                char s,t;\n                while(i < a.length() && j < b.length()){\n                        s = a.charAt(i);\n                        t = b.charAt(j);\n                        if(s == t){\n                                System.out.print(s);\n                                i++;j++;\n                        } else if(s == '('){\n                                while(a.charAt(i++) != ')'){\n                                }\n                        } else if(t == '('){\n                                while(b.charAt(j++) != ')'){\n                                }\n                        }\n                }\n                System.out.println(\"\");\n        }\n\n        static void print_u(String a, String b){\n                int i = 0,j = 0;\n                char s,t;\n                while(i < a.length() && j < b.length()){\n                        s = a.charAt(i);\n                        t = b.charAt(j);\n                        if(s == t){\n                                System.out.print(s);\n                                ++i;++j;\n                        } else if(s == '('){\n                                while(a.charAt(i) != ')'){\n                                        System.out.print(a.charAt(i));\n                                        ++i;\n                                }\n                                System.out.print(a.charAt(i));\n                                ++i;\n                        } else if(t == '('){\n                                while(b.charAt(j) != ')'){\n                                        System.out.print(b.charAt(j));\n                                        ++j;\n                                }\n                                System.out.print(b.charAt(j));\n                                ++j;\n                        }\n                }\n                System.out.println(\"\");\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n\tstatic final int INF = 2 << 28;\n\tstatic final long INF_L = 2L << 60;\n\tstatic final int  MOD = 1000000007;\n\tstatic final long MOD_L = 1000000007L;\n\tstatic final int[] vx_4 = {1,0,-1,0};\n\tstatic final int[] vy_4 = {0,1,0,-1};\n\tstatic final int[] vx_5 = {1,0,-1,0,0};\n\tstatic final int[] vy_5 = {0,1,0,-1,0};\n\tstatic final int[] vx_8 = {1,1,1,0,0,-1,-1,-1};\n\tstatic final int[] vy_8 = {1,0,-1,1,-1,1,0,-1};\n\tstatic final int[] vx_9 = {1,1,1,0,0,0,-1,-1,-1};\n\tstatic final int[] vy_9 = {1,0,-1,1,0,-1,1,0,-1};\n\t\n\tstatic int idx;\n\tstatic char[] in;\n\tstatic Node lNode;\n\tstatic Node rNode;\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(sc.hasNext()) {\n\t\t\tchar[] in = sc.next().toCharArray();\n\t\t\tchar[] lNodeIn = sc.next().toCharArray();\n\t\t\tchar[] rNodeIn = sc.next().toCharArray();\n\t\t\t\n\t\t\t\n\t\t\tMain.in = lNodeIn;\n\t\t\tNode lNode = makeNode();\n\t\t\t\n\t\t\tMain.in = rNodeIn;\n\t\t\tNode rNode = makeNode();\n\t\t\t\n\t\t\tNode res;\n\t\t\t\n\t\t\t\n\t\t\tif(in[0] == 'i') {\n\t\t\t\tres = ins(lNode,rNode);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres = uni(lNode,rNode);\n\t\t\t}\n\t\t\t\n\t\t\ttoStr(res);\n\t\t\tSystem.out.println();\n\t\t\t\n\t\t}\n\t}\n\tstatic void toStr(Node res) {\n\t\tSystem.out.print('(');\n\t\tif(res.lNode != null) toStr(res.lNode);\n\t\tSystem.out.print(',');\n\t\tif(res.rNode != null) toStr(res.rNode);\n\t\tSystem.out.print(')');\n\t}\n\t\n\tstatic Node ins(Node l, Node r) {\n\t\tNode ret = l;\n\t\tif(l.lNode != null && r.lNode != null) {\n\t\t\tret.lNode = ins(l.lNode,r.lNode);\n\t\t}\n\t\telse {\n\t\t\tret.lNode = null;\n\t\t}\n\t\t\n\t\tif(l.rNode != null && r.rNode != null) {\n\t\t\tret.rNode = ins(l.rNode,r.rNode);\n\t\t}\n\t\telse {\n\t\t\tret.rNode = null;\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\tstatic Node uni(Node l, Node r) {\n\t\tNode ret = l;\n\t\tif(l.lNode != null && r.lNode != null) {\n\t\t\tret.lNode = uni(l.lNode, r.lNode);\n\t\t}\n\t\tif(l.lNode != null && r.lNode == null) {\n\t\t\tret.lNode = l.lNode;\n\t\t}\n\t\tif(l.lNode == null && r.lNode != null) {\n\t\t\tret.lNode = r.lNode;\n\t\t}\n\t\t\n\t\tif(l.rNode != null && r.rNode != null) {\n\t\t\tret.rNode = uni(l.rNode, r.rNode);\n\t\t}\n\t\tif(l.rNode != null && r.rNode == null) {\n\t\t\tret.rNode = l.rNode;\n\t\t}\n\t\tif(l.rNode == null && r.rNode != null) {\n\t\t\tret.rNode = r.rNode;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic Node makeNode() {\n\t\tidx = 0;\n\t\treturn node();\n\t}\n\t\n\tstatic Node node() {\n\t\tNode ret = new Node();\n\t\tidx++;\n\t\tif(in[idx] == '(') ret.lNode = node();\n\t\tidx++;\n\t\tif(in[idx] == '(') ret.rNode = node();\n\t\tidx++;\n\t\treturn ret;\n\t}\n\tstatic class Node {\n\t\tNode lNode = null;\n\t\tNode rNode = null;\n\t}\n\t\t\n\t\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \tif (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNextLine()) {\n\t\t\tString[] s = sc.nextLine().split(\" \");\n\t\t\tBinaryTree t1 = BinaryTree.valueOf(s[1]);\n\t\t\tBinaryTree t2 = BinaryTree.valueOf(s[2]);\n\t\t\tif (s[0].equals(\"i\")) {\n\t\t\t\tSystem.out.println(t1.intersection(t2));\n\t\t\t}else{\n\t\t\t\tSystem.out.println(t1.union(t2));\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class BinaryTree {\n\t\tBinaryTree left,right;\n\t\tprivate int strlen = 0;\n\t\tpublic BinaryTree(BinaryTree left,BinaryTree right,int strlen) {\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t\tthis.strlen = strlen;\n\t\t}\n\n\t\tpublic static BinaryTree valueOf(String s) {\n\t\t\treturn valueOf(s.toCharArray(), 0);\n\t\t}\n\t\tpublic static BinaryTree valueOf(char[] s,int i) {\n\t\t\tint left = i;\n\t\t\tif (s[i] != '(') {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\ti++;\n\t\t\tBinaryTree t1 = valueOf(s, i);\n\t\t\tif (t1 != null) {\n\t\t\t\ti += t1.strlen;\n\t\t\t}\n\t\t\ti++;\n\t\t\tBinaryTree t2 = valueOf(s, i);\n\t\t\tif (t1 != null) {\n\t\t\t\ti += t1.strlen;\n\t\t\t}\n\t\t\ti++;\n\t\t\treturn new BinaryTree(t1, t2, i-left);\n\t\t}\n\n\t\tBinaryTree intersection(BinaryTree t) {\n\t\t\tBinaryTree l = null, r = null;\n\t\t\tif (this.left != null && t.left != null) {\n\t\t\t\tl = this.left.intersection(t.left);\n\t\t\t}\n\t\t\tif (this.right != null && t.right != null) {\n\t\t\t\tr = this.right.intersection(t.right);\n\t\t\t}\n\t\t\treturn new BinaryTree(l, r, -1);\n\t\t}\n\n\t\tBinaryTree union(BinaryTree t) {\n\t\t\tBinaryTree l = null, r = null;\n\t\t\tif (this.left != null && t.left != null) {\n\t\t\t\tl = this.left.union(t.left);\n\t\t\t}else if (this.left != null) {\n\t\t\t\tl = this.left;\n\t\t\t}else{\n\t\t\t\tl = t.left;\n\t\t\t}\n\t\t\tif (this.right != null && t.right != null) {\n\t\t\t\tr = this.right.union(t.right);\n\t\t\t}else if (this.right != null) {\n\t\t\t\tr = this.right;\n\t\t\t}else{\n\t\t\t\tr = t.right;\n\t\t\t}\n\t\t\treturn new BinaryTree(l, r, -1);\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append('(');\n\t\t\tif (left != null) {\n\t\t\t\tsb.append(left);\n\t\t\t}\n\t\t\tsb.append(',');\n\t\t\tif (right != null) {\n\t\t\t\tsb.append(right);\n\t\t\t}\n\t\t\tsb.append(')');\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main{\nstatic int i,p,d,t;\nstatic HashSet<Integer> L=new HashSet<Integer>(),M=new HashSet<Integer>(),N=new HashSet<Integer>();\npublic static void main(String[]_){\nfor(Scanner S=new Scanner(System.in);S.hasNext();L.clear(),M.clear(),N.clear()){\nString o=S.next(),s=S.next(),d=S.next();\nA(L,s);A(M,d);\nif(o.equals(\"u\")){for(int a:L)N.add(a);for(int a:M)N.add(a);}\nelse{for(int a:L)if(M.contains(a))N.add(a);}\nSystem.out.println(J(1));\n};}\nstatic String J(int a){\nif(!N.contains(a))return \"\";return \"(\"+J(a*2)+\",\"+J(a*2+1)+\")\";}\nstatic void A(HashSet<Integer> a,String s){\nd=-1;\nfor(char c:s.toCharArray()){\nt=(int)Math.pow(2,d);\nif(c==40)d++;\nif(c==44){if(a.contains(t)||a.contains(t/2))a.add(t+1);else a.add(t);}\nif(c==41)d--;\n}}}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main{\nstatic int[] L,M,N;\npublic static void main(String[]_){\nfor(Scanner S=new Scanner(System.in);S.hasNext();){\nString o=S.next(),s=S.next(),d=S.next();\nint a,b,i,n=s.length(),x=d.length();\nL=new int[n+2];\nM=new int[x+2];\na=Math.min(n,x);\nb=Math.max(n,x);\nArrays.fill(L,0);\nArrays.fill(M,0);\nA(L,s);\nA(M,d);\nif(o.equals(\"u\")){\nN=new int[b*3];\nfor(i=0;i<b;i++)if(L[i]>0||M[i]>0)N[i]++;\n}else{\nN=new int[a*3];\nfor(i=0;i<a;i++)if(L[i]>0&&M[i]>0)N[i]++;\n}\nSystem.out.println(J(1));\n};\n}\nstatic String J(int a){\nif(N[a]<1)return \"\";\nreturn \"(\"+J(a*2)+\",\"+J(a*2+1)+\")\";\n}\nstatic void A(int[] a,String s){\nint i=0,d=-1,t;\nfor(char c:s.toCharArray()){\nt=(int)Math.pow(2,d);\nif (c==40)d++;\nif (c==44){if(a[t]>0||a[t/2]>0)a[t+1]++;else a[t]++;}\nif (c==41)d--;\ni++;\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNextLine()) {\n\t\t\tString[] s = sc.nextLine().split(\" \");\n\t\t\tBinaryTree t1 = BinaryTree.valueOf(s[1]);\n\t\t\tBinaryTree t2 = BinaryTree.valueOf(s[2]);\n\t\t\tif (s[0].equals(\"i\")) {\n\t\t\t\tSystem.out.println(t1.intersection(t2));\n\t\t\t}else{\n\t\t\t\tSystem.out.println(t1.union(t2));\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class BinaryTree {\n\t\tBinaryTree left,right;\n\t\tprivate int strlen = 0;\n\t\tpublic BinaryTree(BinaryTree left,BinaryTree right,int strlen) {\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t\tthis.strlen = strlen;\n\t\t}\n\n\t\tpublic static BinaryTree valueOf(String s) {\n\t\t\treturn valueOf(s.toCharArray(), 0);\n\t\t}\n\t\tpublic static BinaryTree valueOf(char[] s,int i) {\n\t\t\tint left = i;\n\t\t\tif (s[i] != '(') {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\ti++;\n\t\t\tBinaryTree t1 = valueOf(s, i);\n\t\t\tif (t1 != null) {\n\t\t\t\ti += t1.strlen;\n\t\t\t}\n\t\t\ti++;\n\t\t\tBinaryTree t2 = valueOf(s, i);\n\t\t\tif (t2 != null) {\n\t\t\t\ti += t2.strlen;\n\t\t\t}\n\t\t\ti++;\n\t\t\treturn new BinaryTree(t1, t2, i-left);\n\t\t}\n\n\t\tBinaryTree intersection(BinaryTree t) {\n\t\t\tBinaryTree l = null, r = null;\n\t\t\tif (this.left != null && t.left != null) {\n\t\t\t\tl = this.left.intersection(t.left);\n\t\t\t}\n\t\t\tif (this.right != null && t.right != null) {\n\t\t\t\tr = this.right.intersection(t.right);\n\t\t\t}\n\t\t\treturn new BinaryTree(l, r, -1);\n\t\t}\n\n\t\tBinaryTree union(BinaryTree t) {\n\t\t\tBinaryTree l = null, r = null;\n\t\t\tif (this.left != null && t.left != null) {\n\t\t\t\tl = this.left.union(t.left);\n\t\t\t}else if (this.left != null) {\n\t\t\t\tl = this.left;\n\t\t\t}else{\n\t\t\t\tl = t.left;\n\t\t\t}\n\t\t\tif (this.right != null && t.right != null) {\n\t\t\t\tr = this.right.union(t.right);\n\t\t\t}else if (this.right != null) {\n\t\t\t\tr = this.right;\n\t\t\t}else{\n\t\t\t\tr = t.right;\n\t\t\t}\n\t\t\treturn new BinaryTree(l, r, -1);\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append('(');\n\t\t\tif (left != null) {\n\t\t\t\tsb.append(left);\n\t\t\t}\n\t\t\tsb.append(',');\n\t\t\tif (right != null) {\n\t\t\t\tsb.append(right);\n\t\t\t}\n\t\t\tsb.append(')');\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\twhile (sc.hasNext()) {\n\t\t\tchar query = sc.next().charAt(0);\n\t\t\tString tree1 = sc.next();\n\t\t\tString tree2 = sc.next();\n\t\t\tNode root = new Node();\n\t\t\tparse(tree1, 0, root, 1);\n\t\t\tparse(tree2, 0, root, 2);\n\t\t\troot.write(query == 'u');\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic int parse(String tree, int pos, Node cur, int val) {\n\t\tcur.val += val;\n\t\t++pos;\n\t\tif (tree.charAt(pos) == '(') {\n\t\t\tif (cur.left == null) {\n\t\t\t\tcur.left = new Node();\n\t\t\t}\n\t\t\tpos = parse(tree, pos, cur.left, val);\n\t\t}\n\t\t++pos;\n\t\tif (tree.charAt(pos) == '(') {\n\t\t\tif (cur.right == null) {\n\t\t\t\tcur.right = new Node();\n\t\t\t}\n\t\t\tpos = parse(tree, pos, cur.right, val);\n\t\t}\n\t\treturn pos + 1;\n\t}\n\n\tstatic class Node {\n\t\tNode left;\n\t\tNode right;\n\t\tint val = 0;\n\n\t\tboolean match(boolean union) {\n\t\t\tif (union) {\n\t\t\t\treturn this.val > 0;\n\t\t\t} else {\n\t\t\t\treturn this.val == 3;\n\t\t\t}\n\t\t}\n\n\t\tvoid write(boolean union) {\n\t\t\tif (!match(union)) return;\n\t\t\tSystem.out.print(\"(\");\n\t\t\tif (this.left != null) this.left.write(union);\n\t\t\tSystem.out.print(\",\");\n\t\t\tif (this.right != null) this.right.write(union);\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tint order = scan.next().equals(\"i\") ? 0 : 1;\n\n\t\t\tboolean[] tree1 = decode(scan.next());\n\t\t\tboolean[] tree2 = decode(scan.next());\n\t\t\tprint(tree1,tree2,order);\n\t\t}\n\t}\n\n\tpublic static boolean[] decode(String str){\n\t\tboolean[] tree = new boolean[100];\n\t\tint pos = 0;\n\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\tchar ch = str.charAt(i);\n\t\t\tif(ch=='('){\n\t\t\t\ttree[pos]=true;\n\t\t\t\tpos = pos*2+1;\n\t\t\t}\n\t\t\tif(ch==','){\n\t\t\t\tpos = pos+1;\n\t\t\t}\n\t\t\tif(ch==')'){\n\t\t\t\tpos = (pos-1)/2;\n\t\t\t}\n\t\t}\n\t\treturn tree;\n\t}\n\n\tpublic static Tree[] tr;\n\n\tpublic static void print(boolean[] tree1,boolean[] tree2,int order){\n\t\ttr = new Tree[100];\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tboolean a = tree1[i];\n\t\t\tboolean b = tree2[i];\n\t\t\tboolean leaf = order==0 ? (a && b) : (a || b);\n\n\t\t\tif(leaf){\n\t\t\t\tint par = (i-1)/2;\n\t\t\t\tif(i==0) tr[i] = new Tree();\n\t\t\t\telse{\n\t\t\t\t\ttr[i] = new Tree();\n\t\t\t\t\tif(i%2==0) tr[par].r=tr[i];\n\t\t\t\t\telse tr[par].l=tr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(trp(tr[0]));\n\t}\n\n\tpublic static String trp(Tree tree){\n\t\tString str = \"(\";\n\t\tif(tree.l!=null) str+=trp(tree.l);\n\t\tstr+=\",\";\n\t\tif(tree.r!=null) str+=trp(tree.r);\n\t\tstr+=\")\";\n\t\treturn str;\n\t}\n}\n\nclass Tree{\n\tTree l=null,r=null;\n}"
  },
  {
    "language": "Java",
    "code": "i ((,),(,)) ((,(,)),)\nu ((,),(,)) ((,(,)),)"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main{\nstatic int[] L,M,N;\npublic static void main(String[]_){\nfor(Scanner S=new Scanner(System.in);S.hasNext();System.out.println()){\nString o=S.next(),s=S.next(),d=S.next();\nint a,b,i,n=s.length(),x=d.length();\nL=new int[n];\nM=new int[x];\na=Math.min(n,x);\nb=Math.max(n,x);\nArrays.fill(L,0);\nArrays.fill(M,0);\nA(L,s);\nA(M,d);\nif(o.equals(\"u\")){\nN=new int[b*2];\nfor(i=0;i<b;i++)if(L[i]>0||M[i]>0)N[i]++;\n}else{\nN=new int[a*2];\nfor(i=0;i<a;i++)if(L[i]>0&&M[i]>0)N[i]++;\n}\nSystem.out.println(J(1));\n};\n}\nstatic String J(int a){\nif(N[a]<1)return \"\";\nreturn \"(\"+J(a*2)+\",\"+J(a*2+1)+\")\";\n}\nstatic void A(int[] a,String s){\nint i=0,d=-1,t;\nfor(char c:s.toCharArray()){\nt=(int)Math.pow(2,d);\nif (c==40)d++;\nif (c==44){if(a[t]>0||a[t/2]>0)a[t+1]++;else a[t]++;}\nif (c==41)d--;\ni++;\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String line;\n        while ((line = br.readLine()) != null) {\n            String[] items = line.split(\" \");\n            Calculator calc = parseCalculator(items[0]);\n            Node arg1 = parseNode(items[1]);\n            Node arg2 = parseNode(items[2]);\n\n            Node result = calc.calc(arg1, arg2);\n\n//            System.out.println(arg1);\n//            System.out.println(arg2);\n            System.out.println(result);\n        }\n    }\n\n    static private Calculator parseCalculator(String calculator) {\n        Calculator ret;\n        switch (calculator) {\n            case \"u\":\n                ret = new Union();\n                break;\n            case \"i\":\n                ret = new Intersect();\n                break;\n            default:\n                throw new IllegalArgumentException(\"?????????????????????\");\n        }\n        return ret;\n    }\n\n    static private Node parseNode(String node) {\n        if (node.isEmpty())\n            return null;\n\n        return new Node(node);\n    }\n\n    static private class Node {\n        private Node left;\n        private Node right;\n\n        private interface Direction {\n            boolean inRange(String str, int index);\n            char startSymbol();\n            char endSymbol();\n            int nextIndex(int index);\n        }\n        private class Forward implements Direction {\n            @Override\n            public boolean inRange(String str, int index) {\n                return (index < str.length());\n            }\n\n            @Override\n            public char startSymbol() {\n                return '(';\n            }\n\n            @Override\n            public char endSymbol() {\n                return ')';\n            }\n\n            @Override\n            public int nextIndex(int index) {\n                return index + 1;\n            }\n        }\n        private class Backward implements Direction {\n            @Override\n            public boolean inRange(String str, int index) {\n                return (0 < index);\n            }\n\n            @Override\n            public char startSymbol() {\n                return ')';\n            }\n\n            @Override\n            public char endSymbol() {\n                return '(';\n            }\n\n            @Override\n            public int nextIndex(int index) {\n                return index - 1;\n            }\n        }\n\n        public int findCorrespondingSymbol(String str, int startIndex, Direction dir) {\n            int numOfStartSymbols = 0;\n            for (int i = startIndex; dir.inRange(str, i); i = dir.nextIndex(i)) {\n                char ch = str.charAt(i);\n                if (ch == dir.endSymbol()) {\n                    // else -> pop\n                    numOfStartSymbols--;\n                    // stack is empty? -> break loop;\n                    if (numOfStartSymbols == 0)\n                        return i;\n                } else if (ch == dir.startSymbol()) {\n                    // push\n                    numOfStartSymbols++;\n                }\n            }\n            return -1;\n        }\n\n        public Node(Node left, Node right) {\n            this.left = left;\n            this.right = right;\n        }\n        public Node(String expression) {\n            // parse expression\n            if (expression.equals(\"(,)\")) {\n                left = null;\n                right = null;\n            } else {\n                if (expression.charAt(1) == '(') {\n                    // ????????????')'?????§??????????????????Node???????????????left????¨????\n                    int lastIndex = findCorrespondingSymbol(expression, 1, new Forward());\n                    String leftStr = expression.substring(1, lastIndex + 1);\n                    left = new Node(leftStr);\n                } else {\n                    left = null;\n                }\n\n                if (expression.charAt(expression.length() - 2) == ')') {\n                    // ????????????'('?????§??????????????????Node???????????????right????¨????\n                    int firstIndex = findCorrespondingSymbol(expression, expression.length() - 2,\n                            new Backward());\n                    String rightStr = expression.substring(firstIndex, expression.length() - 2 + 1);\n                    right = new Node(rightStr);\n                } else {\n                    right = null;\n                }\n            }\n        }\n\n        @Override\n        public String toString() {\n            String leftStr = (left == null)? \"\" : left.toString();\n            String rightStr = (right == null)? \"\" : right.toString();\n            return \"(\" + leftStr + \",\" + rightStr + \")\";\n        }\n    }\n\n    private interface Calculator {\n        Node calc(Node arg1, Node arg2);\n    }\n\n    static private class Intersect implements Calculator {\n        @Override\n        public Node calc(Node arg1, Node arg2) {\n            if (arg1 == null || arg2 == null) {\n                return null;\n            } else {\n                return new Node(calc(arg1.left, arg2.left), calc(arg1.right, arg2.right));\n            }\n        }\n    }\n\n    static private class Union implements Calculator {\n        @Override\n        public Node calc(Node arg1, Node arg2) {\n            if (arg1 == null && arg2 == null) {\n                return null;\n            } else if (arg1 != null && arg2 == null) {\n                return arg1;\n            } else if (arg1 == null && arg2 != null) {\n                return arg2;\n            } else {\n                return new Node(calc(arg1.left, arg2.left), calc(arg1.right, arg2.right));\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \npublic class Main{\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n \n        while(sc.hasNext()){\n            String op = sc.next();\n            char[] s1 = sc.next().toCharArray();\n            char[] s2 = sc.next().toCharArray();\n \n            s = \"\";\n            int p1 = 0, p2 = 0;\n            int l1 = s1.length, l2 = s2.length;\n            while(p1 < l1 && p2 < l2){\n                if(s1[p1] == s2[p2]){\n                    s += s1[p1];\n                    p1++;\n                    p2++;\n                }\n                else if(s1[p1] == '('){\n                    p1 = read(s1,p1,(op.equals(\"u\") ? true : false));\n                }\n                else{\n                    p2 = read(s2,p2,(op.equals(\"u\") ? true : false));\n                }\n            }\n \n            if(op.equals(\"u\")){\n                while(p1 < l1) s += s1[p1++];\n                while(p2 < l2) s += s2[p2++];\n            }\n \n            System.out.println(s);\n        }\n    }\n \n    private static String s;\n \n    private static int read(char[] t,int p,boolean flg){\n        int level = 0;\n        do{\n            if(flg) s += t[p];\n            if(t[p] == '(') level++;\n            else if(t[p] == ')') level--;\n            p++;\n        }while(level != 0);\n        return p;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class _1001_BinaryTreeIntersectionAndUnion {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tint order = scan.next().equals(\"i\") ? 0 : 1;\n\n\t\t\tboolean[] tree1 = decode(scan.next());\n\t\t\tboolean[] tree2 = decode(scan.next());\n\t\t\tprint(tree1,tree2,order);\n\t\t}\n\t}\n\n\tpublic static boolean[] decode(String str){\n\t\tboolean[] tree = new boolean[101];\n\t\tint pos = 0;\n\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\tchar ch = str.charAt(i);\n\t\t\tif(ch=='('){\n\t\t\t\ttree[pos]=true;\n\t\t\t\tpos = pos*2+1;\n\t\t\t}\n\t\t\tif(ch==','){\n\t\t\t\tpos = pos+1;\n\t\t\t}\n\t\t\tif(ch==')'){\n\t\t\t\tpos = (pos-1)/2;\n\t\t\t}\n\t\t}\n\t\treturn tree;\n\t}\n\n\tpublic static Tree[] tr;\n\n\tpublic static void print(boolean[] tree1,boolean[] tree2,int order){\n\t\ttr = new Tree[101];\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tboolean a = tree1[i];\n\t\t\tboolean b = tree2[i];\n\t\t\tboolean leaf = order==0 ? (a && b) : (a || b);\n\n\t\t\tif(leaf){\n\t\t\t\tint par = (i-1)/2;\n\t\t\t\tif(i==0) tr[i] = new Tree();\n\t\t\t\telse{\n\t\t\t\t\ttr[i] = new Tree();\n\t\t\t\t\tif(i%2==0) tr[par].r=tr[i];\n\t\t\t\t\telse tr[par].l=tr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(trp(tr[0]));\n\t}\n\n\tpublic static String trp(Tree tree){\n\t\tString str = \"(\";\n\t\tif(tree.l!=null) str+=trp(tree.l);\n\t\tstr+=\",\";\n\t\tif(tree.r!=null) str+=trp(tree.r);\n\t\tstr+=\")\";\n\t\treturn str;\n\t}\n}\n\nclass Tree{\n\tTree l=null,r=null;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main{\nstatic long i,j,d,t;\nstatic HashSet<Long> L=new HashSet<Long>(),M=new HashSet<Long>(),N=new HashSet<Long>();\npublic static void main(String[]_){\nfor(Scanner S=new Scanner(System.in);S.hasNext();L.clear(),M.clear(),N.clear()){\nString o=S.next(),s=S.next(),d=S.next();\nA(L,s);A(M,d);\nif(o.equals(\"u\")){for(long a:L)N.add(a);for(long a:M)N.add(a);}\nelse{for(long a:L)if(M.contains(a))N.add(a);}\nSystem.out.println(J(1L));\n};}\nstatic String J(long a){\nif(!N.contains(a))return \"\";return \"(\"+J(a*2)+\",\"+J(a*2+1)+\")\";}\nstatic void A(HashSet<Long> a,String s){\nd=-1;\nfor(char c:s.toCharArray()){\nt=(long)Math.pow(2,d);\nif(c==40)d++;\nif(c==44){\nfor(j=0,i=1;i<t;i*=2){j*=2;if(a.contains(i))j+=1;}\nif(a.contains(t+j)||a.contains((t+j+1)/2))a.add(t+j+1);else a.add(t+j);}\nif(c==41)d--;\n}}}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String line;\n        while ((line = br.readLine()) != null) {\n            String[] items = line.split(\" \");\n            Calculator calc = parseCalculator(items[0]);\n            Node arg1 = parseNode(items[1]);\n            Node arg2 = parseNode(items[2]);\n\n            Node result = calc.calc(arg1, arg2);\n\n            System.out.println(arg1);\n            System.out.println(arg2);\n            System.out.println(result);\n        }\n    }\n\n    static private Calculator parseCalculator(String calculator) {\n        Calculator ret;\n        switch (calculator) {\n            case \"u\":\n                ret = new Union();\n                break;\n            case \"i\":\n                ret = new Intersect();\n                break;\n            default:\n                throw new IllegalArgumentException(\"?????????????????????\");\n        }\n        return ret;\n    }\n\n    static private Node parseNode(String node) {\n        if (node.isEmpty())\n            return null;\n\n        return new Node(node);\n    }\n\n    static private class Node {\n        private Node left;\n        private Node right;\n\n        private interface Direction {\n            boolean inRange(String str, int index);\n            char startSymbol();\n            char endSymbol();\n            int nextIndex(int index);\n        }\n        private class Forward implements Direction {\n            @Override\n            public boolean inRange(String str, int index) {\n                return (index < str.length());\n            }\n\n            @Override\n            public char startSymbol() {\n                return '(';\n            }\n\n            @Override\n            public char endSymbol() {\n                return ')';\n            }\n\n            @Override\n            public int nextIndex(int index) {\n                return index + 1;\n            }\n        }\n        private class Backward implements Direction {\n            @Override\n            public boolean inRange(String str, int index) {\n                return (0 < index);\n            }\n\n            @Override\n            public char startSymbol() {\n                return ')';\n            }\n\n            @Override\n            public char endSymbol() {\n                return '(';\n            }\n\n            @Override\n            public int nextIndex(int index) {\n                return index - 1;\n            }\n        }\n\n        public int findCorrespondingSymbol(String str, int startIndex, Direction dir) {\n            int numOfStartSymbols = 0;\n            for (int i = startIndex; dir.inRange(str, i); i = dir.nextIndex(i)) {\n                char ch = str.charAt(i);\n                if (ch == dir.endSymbol()) {\n                    // else -> pop\n                    numOfStartSymbols--;\n                    // stack is empty? -> break loop;\n                    if (numOfStartSymbols == 0)\n                        return i;\n                } else if (ch == dir.startSymbol()) {\n                    // push\n                    numOfStartSymbols++;\n                }\n            }\n            return -1;\n        }\n\n        public Node(Node left, Node right) {\n            this.left = left;\n            this.right = right;\n        }\n        public Node(String expression) {\n            // parse expression\n            if (expression.equals(\"(,)\")) {\n                left = null;\n                right = null;\n            } else {\n                if (expression.charAt(1) == '(') {\n                    // ????????????')'?????§??????????????????Node???????????????left????¨????\n                    int lastIndex = findCorrespondingSymbol(expression, 1, new Forward());\n                    String leftStr = expression.substring(1, lastIndex + 1);\n                    left = new Node(leftStr);\n                } else {\n                    left = null;\n                }\n\n                if (expression.charAt(expression.length() - 2) == ')') {\n                    // ????????????'('?????§??????????????????Node???????????????right????¨????\n                    int firstIndex = findCorrespondingSymbol(expression, expression.length() - 2,\n                            new Backward());\n                    String rightStr = expression.substring(firstIndex, expression.length() - 2 + 1);\n                    right = new Node(rightStr);\n                } else {\n                    right = null;\n                }\n            }\n        }\n\n        @Override\n        public String toString() {\n            String leftStr = (left == null)? \"\" : left.toString();\n            String rightStr = (right == null)? \"\" : right.toString();\n            return \"(\" + leftStr + \",\" + rightStr + \")\";\n        }\n    }\n\n    private interface Calculator {\n        Node calc(Node arg1, Node arg2);\n    }\n\n    static private class Intersect implements Calculator {\n        @Override\n        public Node calc(Node arg1, Node arg2) {\n            if (arg1 == null || arg2 == null) {\n                return null;\n            } else {\n                return new Node(calc(arg1.left, arg2.left), calc(arg1.right, arg2.right));\n            }\n        }\n    }\n\n    static private class Union implements Calculator {\n        @Override\n        public Node calc(Node arg1, Node arg2) {\n            if (arg1 == null && arg2 == null) {\n                return null;\n            } else if (arg1 != null && arg2 == null) {\n                return arg1;\n            } else if (arg1 == null && arg2 != null) {\n                return arg2;\n            } else {\n                return new Node(calc(arg1.left, arg2.left), calc(arg1.right, arg2.right));\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nclass Main {\n    Scanner sc = new Scanner(System.in);\n\n    static class Tree{\n    \tTree left;\n    \tTree right;\n    \tTree(){\n    \t}\n    \tTree(String s){\n    \t\tint bc=0;\n    \t\tint i=0;\n    \t\tfor(;i<s.length();i++){\n    \t\t\tif(s.charAt(i)=='(')bc++;\n    \t\t\tif(s.charAt(i)==')')bc--;\n    \t\t\tif(s.charAt(i)==',' && bc==1){\n    \t\t\t\tif(i>1){\n    \t\t\t\t\tleft=new Tree(s.substring(1,i));\n    \t\t\t\t}\n    \t\t\t\tif(i+1<s.length()-1){\n    \t\t\t\t\tright=new Tree(s.substring(i+1,s.length()-1));\n    \t\t\t\t}\n    \t\t\t\treturn;\n    \t\t\t}\n    \t\t}\n    \t}\n    \tpublic static Tree Intersect(Tree a,Tree b){\n    \t\tTree tree=new Tree();\n    \t\tif(a!=null && b!=null){\n\t    \t\tif(a.left!=null && b.left!=null){\n\t    \t\t\ttree.left=Intersect(a.left,b.left);\n\t    \t\t}\n\t    \t\tif(a.right!=null && b.right!=null){\n\t    \t\t\ttree.right=Intersect(a.right,b.right);\n\t    \t\t}\n    \t\t}\n    \t\treturn tree;\n    \t}\n    \tpublic static Tree Union(Tree a,Tree b){\n    \t\tTree tree=new Tree();\n    \t\tif((a!=null && a.left!=null) || (b!=null && b.left!=null)){\n    \t\t\ttree.left=Union(a.left,b.left);\n    \t\t}\n    \t\tif((a!=null && a.right!=null) || (b!=null && b.right!=null)){\n    \t\t\ttree.right=Union(a!=null?a.right:null,b!=null?b.right:null);\n    \t\t}\n    \t\treturn tree;\n    \t}\n\n\n    \tpublic String toString(){\n    \t\treturn \"(\"+(left!=null?left:\"\")+\",\"+(right!=null?right:\"\")+\")\";\n    \t}\n    }\n\n    public void run() {\n        while(sc.hasNext()){\n        \tString key=sc.next(),a=sc.next(),b=sc.next();\n        \tTree ta=new Tree(a);\n        \tTree tb=new Tree(b);\n        \tif(\"i\".equals(key)){\n        \t\tln(Tree.Intersect(ta, tb));\n        \t}else if(\"u\".equals(key)){\n        \t\tln(Tree.Union(ta, tb));\n        \t}else{\n\n        \t}\n        }\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n    public static void pr(Object o) {\n        System.out.print(o);\n    }\n    public static void ln(Object o) {\n        System.out.println(o);\n    }\n    public static void ln() {\n        System.out.println();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Binary Tree intersection And Union\npublic class Main{\n\n\tpublic static class N{\n\t\tpublic N left;\n\t\tpublic N right;\n\t\tpublic N parent;\n\t\tpublic N() {\n\t\t\tleft = null;\n\t\t\tright = null;\n\t\t\tparent = null;\n\t\t}\n\t\tpublic void copy(N v){\n\t\t\tif(left!=null){\n\t\t\t\tv.left = new N();\n\t\t\t\tv.left.parent = v;\n\t\t\t\tleft.copy(v.left);\n\t\t\t}\n\t\t\tif(right!=null){\n\t\t\t\tv.right = new N();\n\t\t\t\tv.right.parent = v;\n\t\t\t\tright.copy(v.right);\n\t\t\t}\n\t\t}\n\t\tpublic void intersect(N v){\n\t\t\tif(left==null)v.left=null;\n\t\t\telse if(v.left!=null)left.intersect(v.left);\n\t\t\tif(right==null)v.right=null;\n\t\t\telse if(v.right!=null)right.intersect(v.right);\n\t\t}\n\t\tpublic void union(N v){\n\t\t\tif(left!=null){\n\t\t\t\tif(v.left==null){\n\t\t\t\t\tv.left = new N();\n\t\t\t\t\tv.left.parent = v;\n\t\t\t\t}\n\t\t\t\tleft.union(v.left);\n\t\t\t}\n\t\t\tif(right!=null){\n\t\t\t\tif(v.right==null){\n\t\t\t\t\tv.right = new N();\n\t\t\t\t\tv.right.parent = v;\n\t\t\t\t}\n\t\t\t\tright.union(v.right);\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\"+(left==null?\"\":left)+\",\"+(right==null?\"\":right)+\")\";\n\t\t}\n\t}\n\n\tpublic static int k;\n\n\tpublic static N f(char[] t){\n\t\tif(t[k]=='(')k++;\n\t\tN n = new N();\n\t\tif(t[k]=='('){\n\t\t\tN c = f(t);\n\t\t\tn.left = c;\n\t\t\tc.parent = n;\n\t\t}\n\t\tif(t[k]==',')k++;\n\t\tif(t[k]=='('){\n\t\t\tN c = f(t);\n\t\t\tn.right = c;\n\t\t\tc.parent = n;\n\t\t}\n\t\tif(t[k]==')'){\n\t\t\tk++;\n\t\t}\n\t\treturn n;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tchar cmd = sc.next().charAt(0);\n\t\t\tchar[] t = sc.next().toCharArray();\n\t\t\tk = 0;\n\t\t\tN t1 = f(t);\n\t\t\tt = sc.next().toCharArray();\n\t\t\tk = 0;\n\t\t\tN t2 = f(t);\n\t\t\tN g = new N();\n\t\t\tt1.copy(g);\n\t\t\tif(cmd=='i')t2.intersect(g);\n\t\t\telse t2.union(g);\n\t\t\tSystem.out.println(g);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass BTIAU{\n\tpublic static void main(String[] args){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry{\n\t\t\tString input_str;\n\t\t\twhile((input_str = br.readLine()) != null){\n\t\t\t\tString[] input_strs = input_str.split(\" \");\n\n\t\t\t\t// まずノードを生成\n\t\t\t\tNode node1 = new Node(input_strs[1]);\n\t\t\t\tNode node2 = new Node(input_strs[2]);\n\t\t\t\tNode result_node = new Node();\n\n\t\t\t\t// intersection\n\t\t\t\tif(input_strs[0].equals(\"i\")){\n\t\t\t\t\tresult_node.intersection(node1, node2);\n\t\t\t\t}\n\n\t\t\t\t// union\n\t\t\t\tif(input_strs[0].equals(\"u\")){\n\t\t\t\t\tresult_node.union(node1, node2);\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(result_node.toString());\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\tSystem.out.println(\"Error\");\n\t\t}\n\n\t\t/*\n\t\tNode node1 = new Node(\"((,),(,))\");\n\t\tSystem.out.println(\"node1: \" + node1.toString());\n\n\t\tNode node2 = new Node(\"((,(,)),)\");\n\t\tSystem.out.println(\"node2: \" + node2.toString());\n\n\t\tNode inode = new Node();\n\t\tinode.intersection(node1, node2);\n\t\tSystem.out.println(\"inode: \" + inode.toString());\n\n\t\tNode unode = new Node();\n\t\tunode.union(node1, node2);\n\t\tSystem.out.println(\"unode: \" + unode.toString());\n\t\t*/\n\t}\n}\n\nclass Node{\n\tNode left;\n\tNode right;\n\n\tNode(){\n\t\tleft = null;\n\t\tright = null;\n\t}\n\n\tNode(String str){\n\t\t//System.out.println(str);\n\n\t\tint lvl = 0;\n\t\tfor(int i = 0; i < str.length(); i++){\n\t\t\tchar ch = str.charAt(i);\n\t\t\tif(ch == '(') lvl++;\n\t\t\tif(ch == ')') lvl--;\n\t\t\tif(ch == ',' && lvl == 1){\n\t\t\t\t// 左辺\n\t\t\t\tString left_str = str.substring(1, i);\n\t\t\t\tif(left_str.length() == 0){\n\t\t\t\t\tleft = null;\n\t\t\t\t}else{\n\t\t\t\t\tleft = new Node(left_str);\n\t\t\t\t}\n\n\t\t\t\t// 右辺\n\t\t\t\tString right_str = str.substring(i+1, str.length()-1);\n\t\t\t\tif(right_str.length() == 0){\n\t\t\t\t\tright = null;\n\t\t\t\t}else{\n\t\t\t\t\tright = new Node(right_str);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic String toString(){\n\t\tString result = \"(\";\n\t\tif(left != null) result += left.toString();\n\t\tresult += \",\";\n\t\tif(right != null) result += right.toString();\n\t\tresult += \")\";\n\t\treturn result;\n\t}\n\n\tpublic Node intersection(Node node1, Node node2){\n\t\t// intersection は，どちらか片方が null なら null\n\t\t// 両方 null でないなら，子の intersection\n\t\t// left\n\t\tif(node1.left != null && node2.left != null){\n\t\t\tleft = new Node();\n\t\t\tleft.intersection(node1.left, node2.left);\n\t\t}\n\t\t// right\n\t\tif(node1.right != null && node2.right != null){\n\t\t\t// どちらも null でない\n\t\t\tright = new Node();\n\t\t\tright.intersection(node1.right, node2.right);\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic Node union(Node node1, Node node2){\n\t\t// left\n\t\tif(node1.left == null){\n\t\t\tleft = node2.left;\n\t\t}else if(node2.left == null){\n\t\t\tleft = node1.left;\n\t\t}else{\n\t\t\tleft = new Node();\n\t\t\tleft.union(node1.left, node2.left);\n\t\t}\n\t\t// right\n\t\tif(node1.right == null){\n\t\t\tright = node2.right;\n\t\t}else if(node2.right == null){\n\t\t\tright = node1.right;\n\t\t}else{\n\t\t\tright = new Node();\n\t\t\tright.union(node1.right, node2.right);\n\t\t}\n\t\treturn this;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\npublic class Main {\n        public static void main(String[] args) throws IOException {\n                BufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\n                String s;\n                String t[];\n                while((s = r.readLine()) != null){\n                        t = s.split(\"[ ]\");\n                        if(t[0].equals(\"i\")){\n                                print_i(t[1],t[2]);\n                        } else if(t[0].equals(\"u\")){\n                                print_u(t[1],t[2]);\n                        }   \n                }   \n        }   \n        static void print_i(String a, String b){ \n                String p = \"\"; \n                int i = 0,j = 0;\n                char[] s = new char[a.length()];\n                char[] t = new char[b.length()];\n                a.getChars(0,a.length(),s,0);\n                b.getChars(0,b.length(),t,0);\n                while(i < a.length() && j < b.length()){\n                        if(s[i] == t[j]){\n                                p = p+ t[j];\n                                i++;j++;\n                        } else if(s[i] == '('){\n                                while(s[i++] != ')'){\n                                }   \n                        } else if(t[j] == '('){\n                                while(t[j++] != ')'){\n                                }   \n                        }   \n                }   \n                System.out.println(p);\n        }   \n\n        static void print_u(String a, String b){ \n                String p = \"\"; \n                int i = 0,j = 0;\n                char[] s = new char[a.length()];\n                char[] t = new char[b.length()];\n                a.getChars(0,a.length(),s,0);\n                b.getChars(0,b.length(),t,0);\n                while(i < a.length() && j < b.length()){\n                        if(s[i] == t[j]){\n                                p = p + s[i];\n                                ++i;++j;\n                        } else if(s[i] == '('){\n                                while(s[i] != ')'){\n                                        p = p + s[i];\n                                        ++i;\n                                }\n                                p = p + s[i];\n                                ++i;\n                        } else if(t[j] == '('){\n                                while(t[j] != ')'){\n                                        p = p + t[j];\n                                        ++j;\n                                }\n                                p = p + t[j];\n                                ++j;\n                        }\n                }\n                System.out.println(p);\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\npublic class Main {\n        public static void main(String[] args) throws IOException {\n                BufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\n                String s;\n                String t[];\n                while((s = r.readLine()) != null){\n                        t = s.split(\"[ ]\");\n                        if(t[0].equals(\"i\")){\n                                print_i(t[1],t[2]);\n                        } else if(t[0].equals(\"u\")){\n                                print_u(t[1],t[2]);\n                        }\n                }\n        }\n        static void print_i(String a, String b){\n                int i = 0,j = 0;\n                char[] s = new char[a.length()];\n                char[] t = new char[b.length()];\n                a.getChars(0,a.length(),s,0);\n                b.getChars(0,b.length(),t,0);\n                while(i < a.length() && j < b.length()){\n                        if(s[i] == t[j]){\n                                System.out.print(s[i]);\n                                i++;j++;\n                        } else if(s[i] == '('){\n                                while(s[i++] != ')'){\n                                }   \n                        } else if(t[j] == '('){\n                                while(t[j++] != ')'){\n                                }   \n                        }   \n                }   \n                System.out.println(\"\");\n        }  \n        static void print_u(String a, String b){ \n                int i = 0,j = 0;\n                char[] s = new char[a.length()];\n                char[] t = new char[b.length()];\n                a.getChars(0,a.length(),s,0);\n                b.getChars(0,b.length(),t,0);\n                while(i < a.length() && j < b.length()){\n                        if(s[i] == t[j]){\n                                System.out.print(s[i]);\n                                ++i;++j;\n                        } else if(s[i] == '('){\n                                while(s[i] != ')'){\n                                        System.out.print(s[i]);\n                                        ++i;\n                                }\n                                System.out.print(s[i]);\n                                ++i;\n                        } else if(t[j] == '('){\n                                while(t[j] != ')'){\n                                        System.out.print(t[j]);\n                                        ++j;\n                                }\n                                System.out.print(t[j]);\n                                ++j;\n                        }\n                }\n                System.out.println(\"\");\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\tpublic static class BinNode {\n\t\tpublic BinNode left = null;\n\t\tpublic BinNode right = null;\n\t}\n\t\n\tpublic static BinNode intersect(BinNode n1, BinNode n2) {\n\t\tif(n1 == null || n2 == null)\n\t\t\treturn null;\n\t\tBinNode new1 = new BinNode();\n\t\tnew1.left = intersect(n1.left, n2.left);\n\t\tnew1.right = intersect(n1.right, n2.right);\n\t\treturn new1;\n\t}\n\tpublic static BinNode union(BinNode n1, BinNode n2) {\n\t\tif(n1 == null && n2 == null)\n\t\t\treturn null;\n\t\tBinNode new1 = new BinNode();\n\t\tBinNode n1left = (n1 == null)? null: n1.left;\n\t\tBinNode n1right = (n1 == null)? null: n1.right;\n\t\tBinNode n2left = (n2 == null)? null: n2.left;\n\t\tBinNode n2right = (n2 == null)? null: n2.right;\n\t\tnew1.left = union(n1left, n2left);\n\t\tnew1.right = union(n1right, n2right);\n\t\treturn new1;\n\t}\n\t\n\tpublic static String to_string(BinNode root) {\n\t\tif(root == null)\n\t\t\treturn \"\";\n\t\treturn \"(\" + to_string(root.left) + \",\" + to_string(root.right) + \")\";\n\t}\n\t\n\tpublic static BinNode parse(char[] buf) {\n\t\treturn parse(buf, 0, buf.length-1);\n\t}\n\tprivate static BinNode parse(char[] buf, int start, int end) {\n\t\tint idx = findNode(buf, start, end);\n\t\t//System.out.printf(\"start=%d end=%d, idx=%d\\n\", start, end, idx);\n\t\tif(idx < 0) return null;\n\t\tBinNode node = new BinNode();\n\t\tnode.left = parse(buf, start+1, idx-1);\n\t\tnode.right = parse(buf, idx+1, end-1);\n\t\treturn node;\n\t}\n\tprivate static int findNode(char[] buf, int start, int end) {\n\t\tint level = 0;\n\t\tfor(int i = start; i <= end; i++) {\n\t\t\tif(buf[i] == ',' && level == 1)\n\t\t\t\treturn i;\n\t\t\tif(buf[i] == '(')\n\t\t\t\tlevel++;\n\t\t\telse if(buf[i] == ')')\n\t\t\t\tlevel--;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString l = null;\n\t\twhile((l = br.readLine()) != null) {\n\t\t\tString cols[] = l.split(\" \");\n\t\t\tBinNode n1 = parse(cols[1].toCharArray());\n\t\t\tBinNode n2 = parse(cols[2].toCharArray());\n\t\t\tBinNode ans = null;\n\t\t\tif(cols[0].equals(\"i\") ) {\n\t\t\t\tans = intersect(n1, n2);\n\t\t\t}\n\t\t\telse if(cols[0].equals(\"u\")){\n\t\t\t\tans = union(n1, n2);\n\t\t\t}\n\t\t\tSystem.out.printf(\"%s\\n\", to_string(ans));\n\t\t}\n\t\t/**\n\t\tString l1 = \"((,(,)),)\";\n\t\tString l2 = \"((,),(,))\";\n\t\tBinNode node1 = parse(l1.toCharArray());\n\t\tBinNode node2 = parse(l2.toCharArray());\n\t\tBinNode output1 = intersect(node1, node2);\n\t\tBinNode output2 = union(node1, node2);\n\t\t\n\t\tSystem.out.printf(\"intersect= %s\\n\", to_string(output1));\n\t\tSystem.out.printf(\"union= %s\\n\", to_string(output2));\n\t\t*/\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main {\n\n        public static void main(String[] args) throws IOException {\n                BufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\n                String s;\n                String t[];\n                while((s = r.readLine()) != null){\n                        t = s.split(\"[ ]\");\n                        if(t[0].equals(\"i\")){\n                                print_i(t[1],t[2]);\n                        } else if(t[0].equals(\"u\")){\n                                print_u(t[1],t[2]);\n                        }   \n                }   \n        }   \n        static void print_i(String a, String b){ \n                int i = 0,j = 0;\n                while(i < a.length() && j < b.length()){\n                        if(a.charAt(i) == b.charAt(j)){\n                                System.out.print(a.charAt(i));\n                                i++;j++;\n                        } else if(a.charAt(i) == '('){\n                                while(a.charAt(i++) != ')'){\n                                }   \n                        } else if(b.charAt(j) == '('){\n                                while(b.charAt(j++) != ')'){\n                                }   \n                        }   \n                }   \n                System.out.println(\"\");\n        }   \n\n        static void print_u(String a, String b){ \n                int i = 0,j = 0;\n                while(i < a.length() && j < b.length()){\n                        if(a.charAt(i) == b.charAt(j)){\n                                System.out.print(a.charAt(i));\n                                ++i;++j;\n                        } else if(a.charAt(i) == '('){\n                                while(a.charAt(i) != ')'){\n                                        System.out.print(a.charAt(i));\n                                        ++i;\n                                }\n                                System.out.print(a.charAt(i));\n                                ++i;\n                        } else if(b.charAt(j) == '('){\n                                while(b.charAt(j) != ')'){\n                                        System.out.print(b.charAt(j));\n                                        ++j;\n                                }\n                                System.out.print(b.charAt(j));\n                                ++j;\n                        }\n                }\n                System.out.println(\"\");\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tString str;\n\t\t\twhile (null != (str = in.readLine())) {\n\t\t\t\tString[] sp = str.split(\" \");\n\t\t\t\tprintTree(sp[0].charAt(0), sp[1], sp[2]);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tstatic void printTree(char iu, String t1, String t2) {\n\t\t// System.out.println(\"[\" + t1 + \"][\" + t2 + \"]\");\n\t\tif (iu == 'i' ?\n\t\t\t\tt1.length() == 0 || t2.length() == 0 :\n\t\t\t\t\tt1.length() == 0 && t2.length() == 0) {\n\t\t\treturn;\n\t\t}\n\t\tString l1 = \"\", l2 = \"\", r1 = \"\", r2 = \"\";\n\t\tif (t1.length() > 0) {\n\t\t\tif (t1.charAt(1) == '(') {\n\t\t\t\tint level = 1;\n\t\t\t\tint i;\n\t\t\t\tfor (i = 2; level > 0; i++) {\n\t\t\t\t\tif (t1.charAt(i) == '(') {\n\t\t\t\t\t\tlevel++;\n\t\t\t\t\t} else if (t1.charAt(i) == ')') {\n\t\t\t\t\t\tlevel--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl1 = t1.substring(1, i);\n\t\t\t} else {\n\t\t\t\tl1 = \"\";\n\t\t\t}\n\t\t\tr1 = t1.substring(1 + l1.length() + 1, t1.length() - 1);\n\t\t}\n\t\tif (t2.length() > 0) {\n\t\t\tif (t2.charAt(1) == '(') {\n\t\t\t\tint level = 1;\n\t\t\t\tint i;\n\t\t\t\tfor (i = 2; level > 0; i++) {\n\t\t\t\t\tif (t2.charAt(i) == '(') {\n\t\t\t\t\t\tlevel++;\n\t\t\t\t\t} else if (t2.charAt(i) == ')') {\n\t\t\t\t\t\tlevel--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tl2 = t2.substring(1, i);\n\t\t\t} else {\n\t\t\t\tl2 = \"\";\n\t\t\t}\n\t\t\tr2 = t2.substring(1 + l2.length() + 1, t2.length() - 1);\n\t\t}\n\t\tSystem.out.print(\"(\");\n\t\tprintTree(iu, l1, l2);\n\t\tSystem.out.print(\",\");\n\t\tprintTree(iu, r1, r2);\n\t\tSystem.out.print(\")\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n \nclass Main{\n    public static void main(String[] args){\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        try{\n            String input_str;\n            while((input_str = br.readLine()) != null){\n                String[] input_strs = input_str.split(\" \");\n                Node node1 = new Node(input_strs[1]);\n                Node node2 = new Node(input_strs[2]);\n                Node result_node = new Node();\n                if(input_strs[0].equals(\"i\")){\n                    result_node.intersection(node1, node2);\n                }\n                if(input_strs[0].equals(\"u\")){\n                    result_node.union(node1, node2);\n                }\n                System.out.println(result_node.toString());\n            }\n        }catch(Exception e){\n        }\n    }\n}\n \nclass Node{\n    Node left;\n    Node right;\n \n    Node(){\n        left = null;\n        right = null;\n    }\n \n    Node(String str){\n        int lvl = 0;\n        for(int i = 0; i < str.length(); i++){\n            char ch = str.charAt(i);\n            if(ch == '(') lvl++;\n            if(ch == ')') lvl--;\n            if(ch == ',' && lvl == 1){\n                String left_str = str.substring(1, i);\n                if(left_str.length() == 0){\n                    left = null;\n                }else{\n                    left = new Node(left_str);\n                }\n                \n                String right_str = str.substring(i+1, str.length()-1);\n                if(right_str.length() == 0){\n                    right = null;\n                }else{\n                    right = new Node(right_str);\n                }\n            }\n        }\n    }\n \n    public String toString(){\n        String result = \"(\";\n        if(left != null) result += left.toString();\n        result += \",\";\n        if(right != null) result += right.toString();\n        result += \")\";\n        return result;\n    }\n \n    public Node intersection(Node node1, Node node2){\n        if(node1.left != null && node2.left != null){\n            left = new Node();\n            left.intersection(node1.left, node2.left);\n        }\n        \n        if(node1.right != null && node2.right != null){\n            right = new Node();\n            right.intersection(node1.right, node2.right);\n        }\n        return this;\n    }\n \n    public Node union(Node node1, Node node2){\n        if(node1.left == null){\n            left = node2.left;\n        }else if(node2.left == null){\n            left = node1.left;\n        }else{\n            left = new Node();\n            left.union(node1.left, node2.left);\n        }\n        \n        if(node1.right == null){\n            right = node2.right;\n        }else if(node2.right == null){\n            right = node1.right;\n        }else{\n            right = new Node();\n            right.union(node1.right, node2.right);\n        }\n        return this;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader a = new BufferedReader(new InputStreamReader(System.in));\n\t\tString b;\n\t\tString c[];\n\t\twhile((b = a.readLine()) != null){\n\t\t\tc = b.split(\" \");\n\t\t\tprint_iu(c[1],c[2],c[0]);\n\t\t}\n\t}\n\n\tstatic void print_iu(String a, String b, String x){\n\t\tint i = 0,j = 0;\n\t\tboolean y;\n\t\tif(x.charAt(0) == 'i'){\n\t\t\ty = false;\n\t\t} else {\n\t\t\ty = true;\n\t\t}\n\t\twhile(i < a.length() && j < b.length()){\n\t\t\tif(a.charAt(i) == b.charAt(j)){\n\t\t\t\tSystem.out.print(a.charAt(i));\n\t\t\t\t++i;\n\t\t\t\t++j;\n\t\t\t} else if(a.charAt(i) == '('){\n\t\t\t\tint c = 0;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(y){\n\t\t\t\t\t\tSystem.out.print(a.charAt(i));\n\t\t\t\t\t}\n\t\t\t\t\tif(a.charAt(i) == '('){\n\t\t\t\t\t\t++c;\n\t\t\t\t\t} else if(a.charAt(i) == ')'){\n\t\t\t\t\t\t--c;\n\t\t\t\t\t\tif(c == 0){\n\t\t\t\t\t\t\t++i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++i;\n\t\t\t\t}\n\t\t\t} else if(b.charAt(j) == '('){\n\t\t\t\tint c = 0;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(y){\n\t\t\t\t\t\tSystem.out.print(b.charAt(j));\n\t\t\t\t\t}\n\t\t\t\t\tif(b.charAt(j) == '('){\n\t\t\t\t\t\t++c;\n\t\t\t\t\t} else if(b.charAt(j) == ')'){\n\t\t\t\t\t\t--c;\n\t\t\t\t\t\tif(c == 0){\n\t\t\t\t\t\t\t++j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tint order = scan.next().equals(\"i\") ? 0 : 1;\n\n\t\t\tboolean[] tree1 = decode(scan.next());\n\t\t\tboolean[] tree2 = decode(scan.next());\n\t\t\tprint(tree1,tree2,order);\n\t\t}\n\t}\n\n\tpublic static boolean[] decode(String str){\n\t\tboolean[] tree = new boolean[101];\n\t\tint pos = 0;\n\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\tchar ch = str.charAt(i);\n\t\t\tif(ch=='('){\n\t\t\t\ttree[pos]=true;\n\t\t\t\tpos = pos*2+1;\n\t\t\t}\n\t\t\tif(ch==','){\n\t\t\t\tpos = pos+1;\n\t\t\t}\n\t\t\tif(ch==')'){\n\t\t\t\tpos = (pos-1)/2;\n\t\t\t}\n\t\t}\n\t\treturn tree;\n\t}\n\n\tpublic static Tree[] tr;\n\n\tpublic static void print(boolean[] tree1,boolean[] tree2,int order){\n\t\ttr = new Tree[101];\n\t\tfor (int i = 0; i < 101; i++) {\n\t\t\tboolean a = tree1[i];\n\t\t\tboolean b = tree2[i];\n\t\t\tboolean leaf = order==0 ? (a && b) : (a || b);\n\n\t\t\tif(leaf){\n\t\t\t\tint par = (i-1)/2;\n\t\t\t\tif(i==0) tr[i] = new Tree();\n\t\t\t\telse{\n\t\t\t\t\ttr[i] = new Tree();\n\t\t\t\t\tif(i%2==0) tr[par].r=tr[i];\n\t\t\t\t\telse tr[par].l=tr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tSystem.out.println(trp(tr[0]));\n\t}\n\n\tpublic static String trp(Tree tree){\n\t\tString str = \"(\";\n\t\tif(tree.l!=null) str+=trp(tree.l);\n\t\tstr+=\",\";\n\t\tif(tree.r!=null) str+=trp(tree.r);\n\t\tstr+=\")\";\n\t\treturn str;\n\t}\n}\n\nclass Tree{\n\tTree l=null,r=null;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\nclass Element {\n\n    static final Element NONE = new Element( null, null );\n\n    final Element left;\n    final Element right;\n\n    Element(){\n\tthis.left = NONE;\n\tthis.right = NONE;\n    };\n\n    Element( Element left, Element right ) {\n\tthis.left = left;\n\tthis.right = right;\n    }\n\n    Element intersection( Element e ) {\n\tif ( this == NONE || e == NONE ) {\n\t    return NONE;\n\t} else {\n\t    final Element interLeft = left.intersection( e.left );\n\t    final Element interRight = right.intersection( e.right );\n\t    return new Element( interLeft, interRight );\n\t}\t    \n    }\n\n    Element union( Element e ) {\n\tif ( this == NONE ) {\n\t    return e;\n\t} else if( e == NONE ) {\n\t    return this;\n\t} else {\n\t    final Element unionLeft = left.union( e.left );\n\t    final Element unionRight = right.union( e.right );\n\t    return new Element( unionLeft, unionRight );\n\t}\n    }\n\n    public String toString() {\n\tif ( this == NONE ) {\n\t    return \"\";\n\t} else {\n\t    final String strLeft = left.toString();\n\t    final String strRight = right.toString();\n\t    return String.format( \"(%s,%s)\", strLeft, strRight );\n\t}\n    }\n}\n\nclass Tokenizer {\n\n    int index;\n    final String input;\n\n    Tokenizer( final String input ) {\n\tthis.input = input;\n    }\n\n    boolean isEOF() {\n\treturn input.length() <= index;\n    }\n\n    void next() {\n\tindex++;\n    }\n\n    char token() {\n\treturn input.charAt( index );\n    }\n}\n\nclass Main {\n\n    public static void main( final String[] args ) {\n\n\tfinal Scanner stdin = new Scanner( System.in );\n\n\twhile ( stdin.hasNextLine() ) {\n\n\t    final String[] input = stdin.nextLine().split( \" \" );\n\t    final String order = input[ 0 ];\n\t    final Element left = parse( new Tokenizer( input[ 1 ] ) );\n\t    final Element right = parse( new Tokenizer( input[ 2 ] ) );\n\n\t    if ( \"i\".equals( order ) ) {\n\t\tSystem.out.println( left.intersection( right ) );\n\t    } else {\n\t\tSystem.out.println( left.union( right ) );\n\t    }\t    \n\t}\t\n    }\n\n    static Element parse( Tokenizer tk ) {\n\tif ( tk.isEOF() || tk.token() != '(' ) {\n\t    return Element.NONE;\n\t} else {\n\t    tk.next();  // (\n\t    final Element left = parse( tk );\n\t    tk.next();  // ,\n\t    final Element right = parse( tk );\n\t    tk.next(); // )\n\t    return new Element( left, right );\n\t}\n    }    \n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\tString line;\n\t\t\twhile((line=r.readLine())!=null){\n\t\t\t\tString[] vars = line.split(\" \");\n\t\t\t\tString res = \"\";\n\t\t\t\tif (vars[0].indexOf('i')>=0){//intersection\n\t\t\t\t\tres = intersection(vars[1],vars[2]);\n\t\t\t\t} else {//union\n\t\t\t\t\tres = union(vars[1],vars[2]);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic static String[] child(String a){//return left and right child\n\t\tString[] children = new String[2];\n\t\tint index = 1, level=0;\n\t\twhile(true){\n\t\t\tif(a.charAt(index)=='('){\n\t\t\t\tlevel++;\n\t\t\t} else if (a.charAt(index)==')'){\n\t\t\t\tlevel--;\n\t\t\t} else if (a.charAt(index)==','&&level==0){\n\t\t\t\tchildren[0] = a.substring(1,index);\n\t\t\t\tchildren[1] = a.substring(index+1,a.length()-1);\n\t\t\t\treturn children;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t}\n\t\n\tpublic static String intersection(String a, String b){\n\t\tif(a.length()==0||b.length()==0){\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn \"(\" + intersection(child(a)[0],child(b)[0]) + \",\" + intersection(child(a)[1],child(b)[1]) + \")\";\n\t\t}\n\t}\n\t\n\tpublic static String union(String a, String b){\n\t\tif(a.length()==0&&b.length()==0){\n\t\t\treturn \"\";\n\t\t} else if (a.length()==0){\n\t\t\treturn \"(\" + child(b)[0] + \",\" + child(b)[1] + \")\"; \n\t\t} else if (b.length()==0){\n\t\t\treturn \"(\" + child(a)[0] + \",\" + child(a)[1] + \")\";\n\t\t} else {\n\t\t\treturn \"(\" + union(child(a)[0],child(b)[0]) + \",\" + union(child(a)[1],child(b)[1]) + \")\";\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main2 { \n\tpublic static void main(String[] args) { \n \nScanner sc = new Scanner(System.in); \n\n int x = sc.nextInt(); int answer = x*x*x; \n  System.out.println(answer);  \n   } \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main {\n    static class Tree {\n        private final Tree lhs;\n        private final Tree rhs;\n\n        public Tree(Tree lhs, Tree rhs) {\n            this.lhs = lhs;\n            this.rhs = rhs;\n        }\n\n        private static char[] expr;\n        private static int ptr;\n        private static Tree constructRec() {\n            if (expr[ptr] == '(') {\n                ptr++;\n                Tree lhs = constructRec();\n                assert expr[ptr] == ',';\n                ptr++;\n                Tree rhs = constructRec();\n                assert expr[ptr] == ')';\n                ptr++;\n                return new Tree(lhs, rhs);\n            } else {\n                return null;\n            }\n        }\n\n        public static Tree construct(char[] expr) {\n            Tree.expr = expr;\n            Tree.ptr = 0;\n            return constructRec();\n        }\n\n        public static Tree intersectionOf(Tree t1, Tree t2) {\n            if (t1 == null || t2 == null) {\n                return null;\n            } else {\n                return new Tree(intersectionOf(t1.lhs, t2.lhs), \n                                intersectionOf(t1.rhs, t2.rhs));\n            }\n        }\n\n        public static Tree unionOf(Tree t1, Tree t2) {\n            if (t1 == null && t2 == null) {\n                return null;\n            } else if (t1 == null) {\n                return new Tree(unionOf(t1, t2.lhs), unionOf(t1, t2.rhs));\n            } else if (t2 == null) {\n                return new Tree(unionOf(t1.lhs, t2), unionOf(t1.rhs, t2));\n            } else {\n                return new Tree(unionOf(t1.lhs, t2.lhs), unionOf(t1.rhs, t2.rhs));\n            }\n        }\n\n        private static void showRec(Tree t) {\n            System.out.print('(');\n            if (t.lhs != null) {\n                showRec(t.lhs);\n            }\n            System.out.print(',');\n            if (t.rhs != null) {\n                showRec(t.rhs);\n            }\n            System.out.print(')');\n        }\n\n        public static void show(Tree t) {\n            showRec(t);\n            System.out.println();\n        }\n    }\n\n    private static void solve() {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            char operation = scanner.next().charAt(0);\n            Tree t1 = Tree.construct(scanner.next().toCharArray());\n            Tree t2 = Tree.construct(scanner.next().toCharArray());\n            Tree t3;\n            if (operation == 'i') {\n                t3 = Tree.intersectionOf(t1, t2);\n            } else {\n                t3 = Tree.unionOf(t1, t2);\n            }\n            Tree.show(t3);\n        }\n    }\n\n    public static void main(String... args) {\n        solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main\n{\n\tprivate static class Node\n\t{\n\t\tpublic Node l, r;\n\t\tpublic Node(Node l_, Node r_) { l = l_; r = r_; }\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;sc.hasNext();)\n\t\t{\n\t\t\tchar type = sc.next().charAt(0);\n\t\t\tString x = sc.next();\n\t\t\tString y = sc.next();\n\t\t\t\n\t\t\tpos = 0;\n\t\t\tNode nx = makeNode(x);\n\t\t\t\n\t\t\tpos = 0;\n\t\t\tNode ny = makeNode(y);\n\t\t\t\n\t\t\tSystem.out.println(toString(type == 'u' ? union(nx, ny) : intersect(nx, ny)));\n\t\t}\n\t}\n\t\n\tprivate static int pos;\n\tprivate static Node makeNode(String s)\n\t{\n\t\tNode node = new Node(null, null);\n\t\t\n\t\tif (s.charAt(pos) == '(') pos++;\n\t\t\n\t\tif (s.charAt(pos) == '(')\n\t\t{\n\t\t\tnode.l = makeNode(s);\n\t\t}\n\t\t\n\t\tif (s.charAt(pos) == ',') pos++;\n\t\t\n\t\tif (s.charAt(pos) == '(')\n\t\t{\n\t\t\tnode.r = makeNode(s);\n\t\t}\n\t\t\n\t\tif (s.charAt(pos) == ')') pos++;\n\t\t\n\t\treturn node;\n\t}\n\t\n\tprivate static Node union(Node x, Node y)\n\t{\n\t\tif (x == null)\n\t\t{\n\t\t\treturn y;\n\t\t}\n\t\telse if (y == null)\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\treturn new Node(union(x.l, y.l), union(x.r, y.r));\n\t}\n\t\n\tprivate static Node intersect(Node x, Node y)\n\t{\n\t\tif (x == null || y == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\treturn new Node(intersect(x.l, y.l), intersect(x.r, y.r));\n\t}\n\t\n\tprivate static String toString(Node node)\n\t{\n\t\treturn node == null ? \"\" : \"(\" + toString(node.l) + \",\" + toString(node.r) + \")\";\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String line;\n        while ((line = br.readLine()) != null) {\n            String[] items = line.split(\" \");\n            Calculator calc = parseCalculator(items[0]);\n            Node arg1 = parseNode(items[1]);\n            Node arg2 = parseNode(items[2]);\n\n            Node result = calc.calc(arg1, arg2);\n\n            System.out.println(arg1);\n            System.out.println(arg2);\n            System.out.println(result);\n        }\n    }\n\n    static private Calculator parseCalculator(String calculator) {\n        Calculator ret;\n        switch (calculator) {\n            case \"u\":\n                ret = new Union();\n                break;\n            case \"i\":\n                ret = new Intersect();\n                break;\n            default:\n                throw new IllegalArgumentException(\"?????????????????????\");\n        }\n        return ret;\n    }\n\n    static private Node parseNode(String node) {\n        if (node.isEmpty())\n            return null;\n\n        return new Node(node);\n    }\n\n    static private class Node {\n        private Node left;\n        private Node right;\n\n        private interface Direction {\n            boolean inRange(String str, int index);\n            char startSymbol();\n            char endSymbol();\n            int nextIndex(int index);\n        }\n        private class Forward implements Direction {\n            @Override\n            public boolean inRange(String str, int index) {\n                return (index < str.length());\n            }\n\n            @Override\n            public char startSymbol() {\n                return '(';\n            }\n\n            @Override\n            public char endSymbol() {\n                return ')';\n            }\n\n            @Override\n            public int nextIndex(int index) {\n                return index + 1;\n            }\n        }\n        private class Backward implements Direction {\n            @Override\n            public boolean inRange(String str, int index) {\n                return (0 < index);\n            }\n\n            @Override\n            public char startSymbol() {\n                return ')';\n            }\n\n            @Override\n            public char endSymbol() {\n                return '(';\n            }\n\n            @Override\n            public int nextIndex(int index) {\n                return index - 1;\n            }\n        }\n\n        public int findCorrespondingSymbol(String str, int startIndex, Direction dir) {\n            int numOfStartSymbols = 0;\n            for (int i = startIndex; dir.inRange(str, i); i = dir.nextIndex(i)) {\n                char ch = str.charAt(i);\n                if (ch == dir.endSymbol()) {\n                    // else -> pop\n                    numOfStartSymbols--;\n                    // stack is empty? -> break loop;\n                    if (numOfStartSymbols == 0)\n                        return i;\n                } else if (ch == dir.startSymbol()) {\n                    // push\n                    numOfStartSymbols++;\n                }\n            }\n            return -1;\n        }\n\n        public Node(Node left, Node right) {\n            this.left = left;\n            this.right = right;\n        }\n        public Node(String expression) {\n            // parse expression\n            if (expression.equals(\"(,)\")) {\n                left = null;\n                right = null;\n            } else {\n                if (expression.charAt(1) == '(') {\n                    // ????????????')'?????§??????????????????Node???????????????left????¨????\n                    int lastIndex = findCorrespondingSymbol(expression, 1, new Forward());\n                    String leftStr = expression.substring(1, lastIndex + 1);\n                    left = new Node(leftStr);\n                } else {\n                    left = null;\n                }\n\n                if (expression.charAt(expression.length() - 2) == ')') {\n                    // ????????????'('?????§??????????????????Node???????????????right????¨????\n                    int firstIndex = findCorrespondingSymbol(expression, expression.length() - 2,\n                            new Backward());\n                    String rightStr = expression.substring(firstIndex, expression.length() - 2 + 1);\n                    right = new Node(rightStr);\n                } else {\n                    right = null;\n                }\n            }\n        }\n\n        @Override\n        public String toString() {\n            String leftStr = (left == null)? \"\" : left.toString();\n            String rightStr = (right == null)? \"\" : right.toString();\n            return \"(\" + leftStr + \",\" + rightStr + \")\";\n        }\n    }\n\n    private interface Calculator {\n        Node calc(Node arg1, Node arg2);\n    }\n\n    static private class Intersect implements Calculator {\n        @Override\n        public Node calc(Node arg1, Node arg2) {\n            if (arg1 == null || arg2 == null) {\n                return null;\n            } else {\n                return new Node(calc(arg1.left, arg2.left), calc(arg1.right, arg2.right));\n            }\n        }\n    }\n\n    static private class Union implements Calculator {\n        @Override\n        public Node calc(Node arg1, Node arg2) {\n            if (arg1 == null && arg2 == null) {\n                return null;\n            } else if (arg1 != null && arg2 == null) {\n                return arg1;\n            } else if (arg1 == null && arg2 != null) {\n                return arg2;\n            } else {\n                return new Node(calc(arg1.left, arg2.left), calc(arg1.right, arg2.right));\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main{\nstatic int[] L,M,N;\npublic static void main(String[]_){\nfor(Scanner S=new Scanner(System.in);S.hasNext();){\nString o=S.next(),s=S.next(),d=S.next();\nint a,b,i,n=s.length(),x=d.length();\nL=new int[n*3];\nM=new int[x*3];\na=Math.min(n,x);\nb=Math.max(n,x);\nArrays.fill(L,0);\nArrays.fill(M,0);\nA(L,s);\nA(M,d);\nif(o.equals(\"u\")){\nN=new int[b*3];\nfor(i=0;i<b;i++)if(L[i]>0||M[i]>0)N[i]++;\n}else{\nN=new int[a*3];\nfor(i=0;i<a;i++)if(L[i]>0&&M[i]>0)N[i]++;\n}\nSystem.out.println(J(1));\n};\n}\nstatic String J(int a){\nif(N[a]<1)return \"\";\nreturn \"(\"+J(a*2)+\",\"+J(a*2+1)+\")\";\n}\nstatic void A(int[] a,String s){\nint i=0,d=-1,t;\nfor(char c:s.toCharArray()){\nt=(int)Math.pow(2,d);\nif (c==40)d++;\nif (c==44){if(a[t]>0||a[t/2]>0)a[t+1]++;else a[t]++;}\nif (c==41)d--;\ni++;\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main{\nstatic int i,p,d,t,m;\nstatic boolean[] L,M,N;\npublic static void main(String[]_){\nfor(Scanner S=new Scanner(System.in);S.hasNext();){\nString o=S.next(),s=S.next(),d=S.next();\nL=new boolean[(int)Math.pow(2,s.length()-1)+2];\nM=new boolean[(int)Math.pow(2,d.length()-1)+2];\nA(L,s);\nA(M,d);\nm=Math.min(s.length(),d.length())+2;\nN=new boolean[(int)Math.pow(2,m-1)];\nif(o.equals(\"u\")){for(i=0;i<m;i++)if(L[i]||M[i])N[i]=true;}\nelse{for(i=0;i<m;i++)if(L[i]&&M[i])N[i]=true;}\nSystem.out.println(J(1));\n};\n}\nstatic String J(int a){\nif(!N[a])return \"\";\nreturn \"(\"+J(a*2)+\",\"+J(a*2+1)+\")\";\n}\nstatic void A(boolean[]a,String s){\nd=-1;\nfor(char c:s.toCharArray()){\nt=(int)Math.pow(2,d);\nif(c==40)d++;\nif(c==44){if(a[t]||a[t/2])a[t+1]=true;else a[t]=true;}\nif(c==41)d--;\n}\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\tString s;\n\t\tString t[];\n\t\twhile((s = r.readLine()) != null){\n\t\t\tt = s.split(\" \");\n\t\t\tif(t[0].equals(\"i\")){\n\t\t\t\tprint_i(t[1],t[2]);\n\t\t\t} else if(t[0].equals(\"u\")){\n\t\t\t\tprint_u(t[1],t[2]);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void print_i(String a, String b){\n\t\tString p = \"\";\n\t\tint i = 0,j = 0;\n\t\tint k = a.length();\n\t\tint l = b.length();\n\t\tchar[] s = new char[k];\n\t\tchar[] t = new char[l];\n\t\ta.getChars(0,k,s,0);\n\t\tb.getChars(0,l,t,0);\n\t\twhile(i < k && j < l){\n\t\t\tif(s[i] == t[j]){\n\t\t\t\tp = p+ t[j];\n\t\t\t\ti++;j++;\n\t\t\t} else if(s[i] == '('){\n\t\t\t\twhile(s[i++] != ')'){\n\t\t\t\t}\n\t\t\t} else if(t[j] == '('){\n\t\t\t\twhile(t[j++] != ')'){\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(p);\n\t}\n\tstatic void print_u(String a, String b){\n\t\tString p = \"\";\n\t\tint i = 0,j = 0;\n\t\tint k = a.length();\n\t\tint l = b.length();\n\t\tchar[] s = new char[k];\n\t\tchar[] t = new char[l];\n\t\ta.getChars(0,k,s,0);\n\t\tb.getChars(0,l,t,0);\n\t\twhile(i < k && j < l){\n\t\t\tif(s[i] == t[j]){\n\t\t\t\tp = p + s[i];\n\t\t\t\t++i;++j;\n\t\t\t} else if(s[i] == '('){\n\t\t\t\twhile(s[i] != ')'){\n\t\t\t\t\tp = p + s[i];\n\t\t\t\t\t++i;\n\t\t\t\t}\t\n\t\t\t\tp = p + s[i];\n\t\t\t\t++i;\n\t\t\t} else if(t[j] == '('){\n\t\t\t\twhile(t[j] != ')'){\n\t\t\t\t\tp = p + t[j];\n\t\t\t\t\t++j;\n\t\t\t\t}\n\t\t\t\tp = p + t[j];\n\t\t\t\t++j;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(p);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tString s;\n\tint i1, i2;\n\tvoid intersection(String s1, String s2) {\n\t\tif (i1 == s1.length()) return;\n\t\tif (s1.charAt(i1) == s2.charAt(i2)) {\n\t\t\ts += s1.charAt(i1);\n\t\t\ti1++; i2++;\n\t\t\tintersection(s1, s2);\n\t\t} else {\n\t\t\tif (s1.charAt(i1) == '(') {\n\t\t\t\tint count = 1;\n\t\t\t\ti1++;\n\t\t\t\twhile (count > 0) {\n\t\t\t\t\tif (s1.charAt(i1) == '(') count++;\n\t\t\t\t\telse if (s1.charAt(i1) == ')') count--;\n\t\t\t\t\ti1++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s2.charAt(i2) == '(') {\n\t\t\t\tint count = 1;\n\t\t\t\ti2++;\n\t\t\t\twhile (count > 0) {\n\t\t\t\t\tif (s2.charAt(i2) == '(') count++;\n\t\t\t\t\telse if (s2.charAt(i2) == ')') count--;\n\t\t\t\t\ti2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tintersection(s1, s2);\n\t\t}\n\t}\n\t\n\tvoid union(String s1, String s2) {\n\t\tif (i1 == s1.length()) return;\n\t\tif (s1.charAt(i1) == s2.charAt(i2)) {\n\t\t\ts += s1.charAt(i1);\n\t\t\ti1++; i2++;\n\t\t\tunion(s1, s2);\n\t\t} else {\n\t\t\tif (s1.charAt(i1) == '(') {\n\t\t\t\tint count = 1;\n\t\t\t\ts += '(';\n\t\t\t\ti1++;\n\t\t\t\twhile (count > 0) {\n\t\t\t\t\ts += s1.charAt(i1);\n\t\t\t\t\tif (s1.charAt(i1) == '(') count++;\n\t\t\t\t\telse if (s1.charAt(i1) == ')') count--;\n\t\t\t\t\ti1++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (s2.charAt(i2) == '(') {\n\t\t\t\tint count = 1;\n\t\t\t\ts += '(';\n\t\t\t\ti2++;\n\t\t\t\twhile (count > 0) {\n\t\t\t\t\ts += s2.charAt(i2);\n\t\t\t\t\tif (s2.charAt(i2) == '(') count++;\n\t\t\t\t\telse if (s2.charAt(i2) == ')') count--;\n\t\t\t\t\ti2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunion(s1, s2);\n\t\t}\n\t}\n\t\n\tvoid run() {\n\t\twhile (sc.hasNext()) {\n\t\t\tchar c = sc.next().charAt(0);\n\t\t\tString s1 = sc.next(), s2 = sc.next();\n\t\t\ts = \"\";\n\t\t\ti1 = i2 = 0;\n\t\t\tif (c == 'i') {\n\t\t\t\tintersection(s1, s2);\n\t\t\t} else {\n\t\t\t\tunion(s1, s2);\n\t\t\t}\n\t\t\tout.println(s);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(sc.hasNext()){\n\t\t\tString op = sc.next();\n\t\t\tchar[] s1 = sc.next().toCharArray();\n\t\t\tchar[] s2 = sc.next().toCharArray();\n\n\t\t\ts = \"\";\n\t\t\tint p1 = 0, p2 = 0;\n\t\t\tint l1 = s1.length, l2 = s2.length;\n\t\t\twhile(p1 < l1 && p2 < l2){\n\t\t\t\tif(s1[p1] == s2[p2]){\n\t\t\t\t\ts += s1[p1];\n\t\t\t\t\tp1++;\n\t\t\t\t\tp2++;\n\t\t\t\t}\n\t\t\t\telse if(s1[p1] == '('){\n\t\t\t\t\tp1 = read(s1,p1,(op.equals(\"u\") ? true : false));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tp2 = read(s2,p2,(op.equals(\"u\") ? true : false));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(op.equals(\"u\")){\n\t\t\t\twhile(p1 < l1) s += s1[p1++];\n\t\t\t\twhile(p2 < l2) s += s2[p2++];\n\t\t\t}\n\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n\n\tprivate static String s;\n\n\tprivate static int read(char[] t,int p,boolean flg){\n\t\tint level = 0;\n\t\tdo{\n\t\t\tif(flg) s += t[p];\n\t\t\tif(t[p] == '(') level++;\n\t\t\telse if(t[p] == ')') level--;\n\t\t\tp++;\n\t\t}while(level != 0);\n\t\treturn p;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry{\n\t\t\tString input_str;\n\t\t\twhile((input_str = br.readLine()) != null){\n\t\t\t\tString[] input_strs = input_str.split(\" \");\n\n\t\t\t\t// まずノードを生成\n\t\t\t\tNode node1 = new Node(input_strs[1]);\n\t\t\t\tNode node2 = new Node(input_strs[2]);\n\t\t\t\tNode result_node = new Node();\n\n\t\t\t\t// intersection\n\t\t\t\tif(input_strs[0].equals(\"i\")){\n\t\t\t\t\tresult_node.intersection(node1, node2);\n\t\t\t\t}\n\n\t\t\t\t// union\n\t\t\t\tif(input_strs[0].equals(\"u\")){\n\t\t\t\t\tresult_node.union(node1, node2);\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println(result_node.toString());\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\tSystem.out.println(\"Error\");\n\t\t}\n\n\t\t/*\n\t\tNode node1 = new Node(\"((,),(,))\");\n\t\tSystem.out.println(\"node1: \" + node1.toString());\n\n\t\tNode node2 = new Node(\"((,(,)),)\");\n\t\tSystem.out.println(\"node2: \" + node2.toString());\n\n\t\tNode inode = new Node();\n\t\tinode.intersection(node1, node2);\n\t\tSystem.out.println(\"inode: \" + inode.toString());\n\n\t\tNode unode = new Node();\n\t\tunode.union(node1, node2);\n\t\tSystem.out.println(\"unode: \" + unode.toString());\n\t\t*/\n\t}\n}\n\nclass Node{\n\tNode left;\n\tNode right;\n\n\tNode(){\n\t\tleft = null;\n\t\tright = null;\n\t}\n\n\tNode(String str){\n\t\t//System.out.println(str);\n\n\t\tint lvl = 0;\n\t\tfor(int i = 0; i < str.length(); i++){\n\t\t\tchar ch = str.charAt(i);\n\t\t\tif(ch == '(') lvl++;\n\t\t\tif(ch == ')') lvl--;\n\t\t\tif(ch == ',' && lvl == 1){\n\t\t\t\t// 左辺\n\t\t\t\tString left_str = str.substring(1, i);\n\t\t\t\tif(left_str.length() == 0){\n\t\t\t\t\tleft = null;\n\t\t\t\t}else{\n\t\t\t\t\tleft = new Node(left_str);\n\t\t\t\t}\n\n\t\t\t\t// 右辺\n\t\t\t\tString right_str = str.substring(i+1, str.length()-1);\n\t\t\t\tif(right_str.length() == 0){\n\t\t\t\t\tright = null;\n\t\t\t\t}else{\n\t\t\t\t\tright = new Node(right_str);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic String toString(){\n\t\tString result = \"(\";\n\t\tif(left != null) result += left.toString();\n\t\tresult += \",\";\n\t\tif(right != null) result += right.toString();\n\t\tresult += \")\";\n\t\treturn result;\n\t}\n\n\tpublic Node intersection(Node node1, Node node2){\n\t\t// intersection は，どちらか片方が null なら null\n\t\t// 両方 null でないなら，子の intersection\n\t\t// left\n\t\tif(node1.left != null && node2.left != null){\n\t\t\tleft = new Node();\n\t\t\tleft.intersection(node1.left, node2.left);\n\t\t}\n\t\t// right\n\t\tif(node1.right != null && node2.right != null){\n\t\t\t// どちらも null でない\n\t\t\tright = new Node();\n\t\t\tright.intersection(node1.right, node2.right);\n\t\t}\n\t\treturn this;\n\t}\n\n\tpublic Node union(Node node1, Node node2){\n\t\t// left\n\t\tif(node1.left == null){\n\t\t\tleft = node2.left;\n\t\t}else if(node2.left == null){\n\t\t\tleft = node1.left;\n\t\t}else{\n\t\t\tleft = new Node();\n\t\t\tleft.union(node1.left, node2.left);\n\t\t}\n\t\t// right\n\t\tif(node1.right == null){\n\t\t\tright = node2.right;\n\t\t}else if(node2.right == null){\n\t\t\tright = node1.right;\n\t\t}else{\n\t\t\tright = new Node();\n\t\t\tright.union(node1.right, node2.right);\n\t\t}\n\t\treturn this;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n \nclass Main{\n    public static void main(String[] args){\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        try{\n            String input_str;\n            while((input_str = br.readLine()) != null){\n                String[] input_strs = input_str.split(\" \");\n \n                // まずノードを生成\n                Node node1 = new Node(input_strs[1]);\n                Node node2 = new Node(input_strs[2]);\n                Node result_node = new Node();\n \n                // intersection\n                if(input_strs[0].equals(\"i\")){\n                    result_node.intersection(node1, node2);\n                }\n \n                // union\n                if(input_strs[0].equals(\"u\")){\n                    result_node.union(node1, node2);\n                }\n \n                System.out.println(result_node.toString());\n            }\n        }catch(Exception e){\n            System.out.println(\"Error\");\n        }\n    }\n}\n \nclass Node{\n    Node left;\n    Node right;\n \n    Node(){\n        left = null;\n        right = null;\n    }\n \n    Node(String str){\n        int lvl = 0;\n        for(int i = 0; i < str.length(); i++){\n            char ch = str.charAt(i);\n            if(ch == '(') lvl++;\n            if(ch == ')') lvl--;\n            if(ch == ',' && lvl == 1){\n                // 左辺\n                String left_str = str.substring(1, i);\n                if(left_str.length() == 0){\n                    left = null;\n                }else{\n                    left = new Node(left_str);\n                }\n \n                // 右辺\n                String right_str = str.substring(i+1, str.length()-1);\n                if(right_str.length() == 0){\n                    right = null;\n                }else{\n                    right = new Node(right_str);\n                }\n            }\n        }\n    }\n \n    public String toString(){\n        String result = \"(\";\n        if(left != null) result += left.toString();\n        result += \",\";\n        if(right != null) result += right.toString();\n        result += \")\";\n        return result;\n    }\n \n    public Node intersection(Node node1, Node node2){\n        // left\n        if(node1.left != null && node2.left != null){\n            left = new Node();\n            left.intersection(node1.left, node2.left);\n        }\n        // right\n        if(node1.right != null && node2.right != null){\n            // どちらも null でない\n            right = new Node();\n            right.intersection(node1.right, node2.right);\n        }\n        return this;\n    }\n \n    public Node union(Node node1, Node node2){\n        // left\n        if(node1.left == null){\n            left = node2.left;\n        }else if(node2.left == null){\n            left = node1.left;\n        }else{\n            left = new Node();\n            left.union(node1.left, node2.left);\n        }\n        // right\n        if(node1.right == null){\n            right = node2.right;\n        }else if(node2.right == null){\n            right = node1.right;\n        }else{\n            right = new Node();\n            right.union(node1.right, node2.right);\n        }\n        return this;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n \nclass TEST{\n\tstatic void Main(){\n\t\tString s;\n\t\twhile((s=Console.ReadLine())!=null){\n\t\t\tvar mySol = new Sol(s);\n\t\t}\n\t}\n}\n \n \nclass Node{\n\tpublic Node parent;\n\tpublic Node left;\n\tpublic Node right;\n\tpublic Node(){\n\t\tparent=null;\n\t\tleft=null;\n\t\tright=null;\n\t}\n}\n \n \nclass Sol{\n \n\t \n\tpublic Sol(string sin){\n\t\tvar s=sin.Split(' ');\n\t\tif(s[0][0]=='i')drawIntersection(s[1],s[2]);\n\t\tif(s[0][0]=='u')drawUnion(s[1],s[2]);\n\t}\n\t\n\tpublic Node parse(String tree){\n\t\t// 文字列から2分木を復元\n\t\tNode TOP=new Node();\n\t\tNode Q=TOP;\n\t\t\n\t\tfor(int i=1;i<tree.Length;i++){\n \n\t\t\tif(tree[i]=='('){\n\t\t\t\tif(tree[i-1]==','){\n\t\t\t\t\tQ.right=new Node();\n\t\t\t\t\tQ.right.parent=Q;\n\t\t\t\t\tQ=Q.right;\n\t\t\t\t}\n\t\t\t\tif(tree[i-1]=='('){\n\t\t\t\t\tQ.left=new Node();\n\t\t\t\t\tQ.left.parent=Q;\n\t\t\t\t\tQ=Q.left;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tree[i]==','){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(tree[i]==')'){\n\t\t\t\tif(Q.parent!=null)Q=Q.parent;\n \n\t\t\t}\n\t\t}\n\t\treturn TOP;\n\t}\n \n\tpublic String parse(Node P){\n\t\t//2分木から文字列へ\n\t\tString s=\"\";\n\t\ts=s+\"(\";\n\t\tif(P.left!=null){\n\t\t\ts+=parse(P.left);\n\t\t}\n\t\ts+=\",\";\n\t\tif(P.right!=null){\n\t\t\ts+=parse(P.right);\n\t\t}\n\t\ts+=\")\";\n\t\treturn s;\n\t}\n\n\tpublic void drawUnion(String sA,String sB){\n\t\t//和集合の2分木を作る。先頭ノートは確保必要\n\t\tNode A=parse(sA);\n\t\tNode B=parse(sB);\n\t\t\n\t\tNode C=new Node();\n\t\tC=makeUnion(A,B,C);\n\t\tConsole.WriteLine(parse(C));\n\t}\n\tpublic void drawIntersection(String sA,String sB){\n\t\n\t\tNode A=parse(sA);\n\t\tNode B=parse(sB);\n\t\t\n\t\tNode C=new Node();\n\t\tC=makeIntersection(A,B,C);\n\t\tConsole.WriteLine(parse(C));\n\t}\n\t\n\tpublic Node makeIntersection(Node A,Node B,Node C){\n\t\tif(A.left!=null && B.left!=null){\n\t\t\tC.left=new Node();\n\t\t\tC.left.parent=C;\n\t\t\tmakeIntersection(A.left,B.left,C.left);\n\t\t}\n\t\tif(A.right!=null && B.right!=null){\n\t\t\tC.right=new Node();\n\t\t\tC.right.parent=C;\n\t\t\tmakeIntersection(A.right,B.right,C.right);\n\t\t}\n\t\treturn C;\n\t}\n\t\n\tpublic Node makeUnion(Node A,Node B,Node C){\n\t\t//AとBの和集合の2分木を作る\n\t\t//無いノードを追加していくだけ\n\t\tC=NodeCopy(C,A);\n\t\tC=NodeCopy(C,B);\n\t\treturn C;\n\t}\n\t\n\tpublic Node NodeCopy(Node X,Node Y){\n\t\tif(Y.left!=null){\n\t\t\tif(X.left==null){\n\t\t\t\tX.left=new Node();\n\t\t\t\tX.left.parent=X;\n\t\t\t}\n\t\t\tNodeCopy(X.left,Y.left);\n\t\t}\n\t\tif(Y.right!=null){\n\t\t\tif(X.right==null){\n\t\t\t\tX.right=new Node();\n\t\t\t\tX.right.parent=X;\n\t\t\t}\n\t\t\tNodeCopy(X.right,Y.right);\n\t\t}\n\t\treturn X;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing System.Text;\n\nnamespace AOJ\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tvar s = \"\";\n\t\t\twhile ((s = Console.ReadLine()) != null)\n\t\t\t{\n\t\t\t\tvar input = s.Split(' ');\n\n\t\t\t\tif (input[0] == \"u\")\n\t\t\t\t{\n\t\t\t\t\tvar node = Union(Parse(input[1]), Parse(input[2]));\n\t\t\t\t\tConsole.WriteLine(node.ToString());\n\t\t\t\t}\n\t\t\t\telse if (input[0] == \"i\")\n\t\t\t\t{\n\t\t\t\t\tvar node = Intersection(Parse(input[1]), Parse(input[2]));\n\t\t\t\t\tConsole.WriteLine(node.ToString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic static Node Union(Node tree1, Node tree2)\n\t\t{\n\t\t\tvar union = new Node();\n\t\t\tUnion(union, tree1, tree2);\n\t\t\treturn union;\n\t\t}\n\n\t\tpublic static void Union(Node union, Node tree1, Node tree2)\n\t\t{\n\t\t\tif (tree1 == null) tree1 = new Node();\n\t\t\tif (tree2 == null) tree2 = new Node();\n\n\t\t\tif (tree1.HasLeft() || tree2.HasLeft())\n\t\t\t{\n\t\t\t\tunion.Left = new Node();\n\t\t\t\tUnion(union.Left, tree1.Left, tree2.Left);\n\t\t\t}\n\t\t\tif (tree1.HasRight() || tree2.HasRight())\n\t\t\t{\n\t\t\t\tunion.Right = new Node();\n\t\t\t\tUnion(union.Right, tree1.Right, tree2.Right);\n\t\t\t}\n\t\t}\n\n\t\tpublic static Node Intersection(Node tree1, Node tree2)\n\t\t{\n\t\t\tvar intersection = new Node();\n\t\t\tIntersection(intersection, tree1, tree2);\n\t\t\treturn intersection;\n\t\t}\n\n\t\tpublic static void Intersection(Node intersection, Node tree1, Node tree2)\n\t\t{\n\t\t\tif (tree1.HasLeft() && tree2.HasLeft())\n\t\t\t{\n\t\t\t\tintersection.Left = new Node();\n\t\t\t\tIntersection(intersection.Left, tree1.Left, tree2.Left);\n\t\t\t}\n\t\t\tif (tree1.HasRight() && tree2.HasRight())\n\t\t\t{\n\t\t\t\tintersection.Right = new Node();\n\t\t\t\tIntersection(intersection.Right, tree1.Right, tree2.Right);\n\t\t\t}\n\t\t}\n\n\t\tpublic static Node Parse(string s)\n\t\t{\n\t\t\tvar rootNode = new Node();\n\t\t\tvar currentNode = rootNode;\n\n\t\t\tfor (int i = 0; i < s.Length; i++)\n\t\t\t{\n\t\t\t\tif (s[i] == '(')\n\t\t\t\t{\n\t\t\t\t\tcurrentNode.Left = new Node();\n\t\t\t\t\tcurrentNode = currentNode.Left;\n\t\t\t\t}\n\t\t\t\telse if (s[i] == ')')\n\t\t\t\t{\n\t\t\t\t\tcurrentNode = currentNode.Parent;\n\t\t\t\t}\n\t\t\t\telse if (s[i] == ',')\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t\tif (s[i] == '(')\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentNode.Right = new Node();\n\t\t\t\t\t\tcurrentNode = currentNode.Right;\n\t\t\t\t\t}\n\t\t\t\t\telse if (s[i] == ')')\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentNode = currentNode.Parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn rootNode.Left;\n\t\t}\n\t}\n\n\tpublic class Node\n\t{\n\t\tpublic Node Parent { get; set; }\n\n\t\tprivate Node left;\n\t\tpublic Node Left\n\t\t{\n\t\t\tget { return left; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tleft = value;\n\t\t\t\tleft.Parent = this;\n\t\t\t}\n\t\t}\n\n\t\tprivate Node right;\n\t\tpublic Node Right\n\t\t{\n\t\t\tget { return right; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tright = value;\n\t\t\t\tright.Parent = this;\n\t\t\t}\n\t\t}\n\n\t\tpublic bool HasLeft()\n\t\t{\n\t\t\treturn Left != null;\n\t\t}\n\n\t\tpublic bool HasRight()\n\t\t{\n\t\t\treturn Right != null;\n\t\t}\n\n\t\tpublic override string ToString()\n\t\t{\n\t\t\tstring leftstring = Left == null ? \"\" : Left.ToString();\n\t\t\tstring rightstring = Right == null ? \"\" : Right.ToString();\n\t\t\treturn string.Format(\"({0},{1})\", leftstring, rightstring);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _1001\n{\n\tclass Program\n\t{\n\t\tString Tree1 = \"\";\n\t\tString Tree2 = \"\";\n\t\tStringBuilder Result = new StringBuilder();\n\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tTextReader input = Console.In;\n\t\t\tif (args.Length > 0)\n\t\t\t{\n\t\t\t\tinput = File.OpenText(args[0]);\n\t\t\t}\n\n\t\t\tstring line = null;\n\t\t\twhile ((line = input.ReadLine()) != null)\n\t\t\t{\n\t\t\t\tvar tuple = line.Split(' ');\n\t\t\t\tvar p = new Program();\n\t\t\t\tp.Tree1 = tuple[1];\n\t\t\t\tp.Tree2 = tuple[2];\n\n\t\t\t\tif (tuple[0][0] == 'i')\n\t\t\t\t{\n\t\t\t\t\t// intersection\n\t\t\t\t\tp.Intersection(0, p.Tree1.Length, 0, p.Tree2.Length);\n\t\t\t\t\tConsole.Out.WriteLine(p.Result.ToString());\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\t// union\n\t\t\t\t\tp.Union(0, p.Tree1.Length, 0, p.Tree2.Length);\n\t\t\t\t\tConsole.Out.WriteLine(p.Result.ToString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid Intersection(int b1, int e1, int b2, int e2)\n\t\t{\n\t\t\tint r1 = FindRoot(Tree1, b1, e1);\n\t\t\tint r2 = FindRoot(Tree2, b2, e2);\n\n\t\t\tResult.Append('(');\n\n\t\t\tif ((b1 + 1) < r1 && (b2 + 1) < r2)\n\t\t\t{\n\t\t\t\t// 左側にノードあり\n\t\t\t\tIntersection(b1 + 1, r1, b2 + 1, r2);\n\t\t\t}\n\n\t\t\tResult.Append(',');\n\n\t\t\tif ((e1 - 2) > r1 && (e2 - 2) > r2)\n\t\t\t{\n\t\t\t\t// 右側にノードあり\n\t\t\t\tIntersection(r1 + 1, e1, r2 + 1, e2);\n\t\t\t}\n\n\t\t\tResult.Append(')');\n\t\t}\n\n\t\tvoid Union(int b1, int e1, int b2, int e2)\n\t\t{\n\t\t\tint r1 = FindRoot(Tree1, b1, e1);\n\t\t\tint r2 = FindRoot(Tree2, b2, e2);\n\n\t\t\tResult.Append('(');\n\n\t\t\tif ((b1 + 1) < r1 || (b2 + 1) < r2)\n\t\t\t{\n\t\t\t\t// 左側にノードあり\n\t\t\t\tif ((b1 + 1) >= r1)\n\t\t\t\t{\n\t\t\t\t\t// Tree2だけ\n\t\t\t\t\tResult.Append(Tree2.Substring(b2 + 1, r2 - b2 - 1));\n\t\t\t\t}\n\t\t\t\telse if ((b2 + 1) >= r2)\n\t\t\t\t{\n\t\t\t\t\t// Tree1だけ\n\t\t\t\t\tResult.Append(Tree1.Substring(b1 + 1, r1 - b1 - 1));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// 両方\n\t\t\t\t\tUnion(b1 + 1, r1, b2 + 1, r2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tResult.Append(',');\n\n\t\t\tif ((e1 - 2) > r1 || (e2 - 2) > r2)\n\t\t\t{\n\t\t\t\t// 右側にノードあり\n\t\t\t\tif ((e1 - 2) <= r1)\n\t\t\t\t{\n\t\t\t\t\t// Tree2だけ\n\t\t\t\t\tstring s = Tree2.Substring(r2 + 1, e2 - r2 - 2);\n\t\t\t\t\tResult.Append(s);\n\t\t\t\t}\n\t\t\t\telse if ((e2 - 2) <= r2)\n\t\t\t\t{\n\t\t\t\t\t// Tree1だけ\n\t\t\t\t\tstring s = Tree1.Substring(r1 + 1, e1 - r1 - 2);\n\t\t\t\t\tResult.Append(s);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// 両方\n\t\t\t\t\tUnion(r1 + 1, e1, r2 + 1, e2);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tResult.Append(')');\n\t\t}\n\n\t\tint FindRoot(String tree, int b, int e)\n\t\t{\n\t\t\tint depth = 0;\n\t\t\tfor (int index = b; index <= e; ++index)\n\t\t\t{\n\t\t\t\tif (tree[index] == '(')\n\t\t\t\t{\n\t\t\t\t\tdepth++;\n\t\t\t\t}\n\t\t\t\telse if (tree[index] == ')')\n\t\t\t\t{\n\t\t\t\t\tdepth--;\n\t\t\t\t}\n\t\t\t\telse if (depth == 1) \n\t\t\t\t{\n\t\t\t\t\t// 深さ1で,を見つけたら、それがルートの位置\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 0;// ここにはこないはず\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing System.Text;\n\nnamespace AOJ\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tvar s = \"\";\n\t\t\twhile ((s = Console.ReadLine()) != null)\n\t\t\t{\n\t\t\t\tvar input = s.Split(' ');\n\n\t\t\t\tif (input[0] == \"u\")\n\t\t\t\t{\n\t\t\t\t\tvar node = Union(Parse(input[1]), Parse(input[2]));\n\t\t\t\t\tConsole.WriteLine(node.ToString());\n\t\t\t\t}\n\t\t\t\telse if (input[0] == \"i\")\n\t\t\t\t{\n\t\t\t\t\tvar node = Intersection(Parse(input[1]), Parse(input[2]));\n\t\t\t\t\tConsole.WriteLine(node.ToString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic static Node Union(Node tree1, Node tree2)\n\t\t{\n\t\t\tvar union = new Node();\n\t\t\tUnion(union, tree1, tree2);\n\t\t\treturn union;\n\t\t}\n\n\t\tpublic static void Union(Node union, Node tree1, Node tree2)\n\t\t{\n\t\t\tif ((tree1 != null && tree1.HasLeft()) || (tree2 != null && tree2.HasLeft()))\n\t\t\t{\n\t\t\t\tunion.Left = new Node();\n\t\t\t\tUnion(union.Left, tree1.Left, tree2.Left);\n\t\t\t}\n\t\t\tif ((tree1 != null && tree1.HasRight()) || (tree2 != null && tree2.HasRight()))\n\t\t\t{\n\t\t\t\tunion.Right = new Node();\n\t\t\t\tUnion(union.Right, tree1.Right, tree2.Right);\n\t\t\t}\n\t\t}\n\n\t\tpublic static Node Intersection(Node tree1, Node tree2)\n\t\t{\n\t\t\tvar intersection = new Node();\n\t\t\tIntersection(intersection, tree1, tree2);\n\t\t\treturn intersection;\n\t\t}\n\n\t\tpublic static void Intersection(Node intersection, Node tree1, Node tree2)\n\t\t{\n\t\t\tif (tree1.HasLeft() && tree2.HasLeft())\n\t\t\t{\n\t\t\t\tintersection.Left = new Node();\n\t\t\t\tIntersection(intersection.Left, tree1.Left, tree2.Left);\n\t\t\t}\n\t\t\tif (tree1.HasRight() && tree2.HasRight())\n\t\t\t{\n\t\t\t\tintersection.Right = new Node();\n\t\t\t\tIntersection(intersection.Right, tree1.Right, tree2.Right);\n\t\t\t}\n\t\t}\n\n\t\tpublic static Node Parse(string s)\n\t\t{\n\t\t\tvar rootNode = new Node();\n\t\t\tvar currentNode = rootNode;\n\n\t\t\tfor (int i = 0; i < s.Length; i++)\n\t\t\t{\n\t\t\t\tif (s[i] == '(')\n\t\t\t\t{\n\t\t\t\t\tcurrentNode.Left = new Node();\n\t\t\t\t\tcurrentNode = currentNode.Left;\n\t\t\t\t}\n\t\t\t\telse if (s[i] == ')')\n\t\t\t\t{\n\t\t\t\t\tcurrentNode = currentNode.Parent;\n\t\t\t\t}\n\t\t\t\telse if (s[i] == ',')\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t\tif (s[i] == '(')\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentNode.Right = new Node();\n\t\t\t\t\t\tcurrentNode = currentNode.Right;\n\t\t\t\t\t}\n\t\t\t\t\telse if (s[i] == ')')\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentNode = currentNode.Parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn rootNode.Left;\n\t\t}\n\t}\n\n\tpublic class Node\n\t{\n\t\tpublic Node Parent { get; set; }\n\n\t\tprivate Node left;\n\t\tpublic Node Left\n\t\t{\n\t\t\tget { return left; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tleft = value;\n\t\t\t\tleft.Parent = this;\n\t\t\t}\n\t\t}\n\n\t\tprivate Node right;\n\t\tpublic Node Right\n\t\t{\n\t\t\tget { return right; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tright = value;\n\t\t\t\tright.Parent = this;\n\t\t\t}\n\t\t}\n\n\t\tpublic bool HasLeft()\n\t\t{\n\t\t\treturn Left != null;\n\t\t}\n\n\t\tpublic bool HasRight()\n\t\t{\n\t\t\treturn Right != null;\n\t\t}\n\n\t\tpublic override string ToString()\n\t\t{\n\t\t\tstring leftstring = Left == null ? \"\" : Left.ToString();\n\t\t\tstring rightstring = Right == null ? \"\" : Right.ToString();\n\t\t\treturn string.Format(\"({0},{1})\", leftstring, rightstring);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Text;\n \nclass TEST{\n\tstatic void Main(){\n\t\tString s;\n\t\twhile((s=Console.ReadLine())!=null){\n\t\t\tvar mySol = new Sol(s);\n\t\t\tmySol.dmy();\n\t\t}\n\t}\n}\n \n \nclass Node{\n\tpublic Node parent;\n\tpublic Node left;\n\tpublic Node right;\n\tpublic Node(){\n\t\tparent=null;\n\t\tleft=null;\n\t\tright=null;\n\t}\n}\n \n \nclass Sol{\n \n\t \n\tpublic Sol(string sin){\n\t\tvar s=sin.Split(' ');\n\t\tif(s[0][0]=='i')drawIntersection(s[1],s[2]);\n\t\tif(s[0][0]=='u')drawUnion(s[1],s[2]);\n\t}\n\t\n\tpublic void dmy(){\n\t\t//dummy (コンストラクタだけでは warningがでたorz。\n\t}\n\t\n\tpublic Node parse(String tree){\n\t\t// 文字列から2分木を復元\n\t\tNode TOP=new Node();\n\t\tNode Q=TOP;\n\t\t\n\t\tfor(int i=1;i<tree.Length;i++){\n \n\t\t\tif(tree[i]=='('){\n\t\t\t\tif(tree[i-1]==','){\n\t\t\t\t\tQ.right=new Node();\n\t\t\t\t\tQ.right.parent=Q;\n\t\t\t\t\tQ=Q.right;\n\t\t\t\t}\n\t\t\t\tif(tree[i-1]=='('){\n\t\t\t\t\tQ.left=new Node();\n\t\t\t\t\tQ.left.parent=Q;\n\t\t\t\t\tQ=Q.left;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(tree[i]==','){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(tree[i]==')'){\n\t\t\t\tif(Q.parent!=null)Q=Q.parent;\n \n\t\t\t}\n\t\t}\n\t\treturn TOP;\n\t}\n \n\tpublic String parse(Node P){\n\t\t//2分木から文字列へ\n\t\tString s=\"\";\n\t\ts=s+\"(\";\n\t\tif(P.left!=null){\n\t\t\ts+=parse(P.left);\n\t\t}\n\t\ts+=\",\";\n\t\tif(P.right!=null){\n\t\t\ts+=parse(P.right);\n\t\t}\n\t\ts+=\")\";\n\t\treturn s;\n\t}\n\n\tpublic void drawUnion(String sA,String sB){\n\t\t//和集合の2分木を作る。先頭ノートは確保必要\n\t\tNode A=parse(sA);\n\t\tNode B=parse(sB);\n\t\t\n\t\tNode C=new Node();\n\t\tC=makeUnion(A,B,C);\n\t\tConsole.WriteLine(parse(C));\n\t}\n\tpublic void drawIntersection(String sA,String sB){\n\t\n\t\tNode A=parse(sA);\n\t\tNode B=parse(sB);\n\t\t\n\t\tNode C=new Node();\n\t\tC=makeIntersection(A,B,C);\n\t\tConsole.WriteLine(parse(C));\n\t}\n\t\n\tpublic Node makeIntersection(Node A,Node B,Node C){\n\t\tif(A.left!=null && B.left!=null){\n\t\t\tC.left=new Node();\n\t\t\tC.left.parent=C;\n\t\t\tmakeIntersection(A.left,B.left,C.left);\n\t\t}\n\t\tif(A.right!=null && B.right!=null){\n\t\t\tC.right=new Node();\n\t\t\tC.right.parent=C;\n\t\t\tmakeIntersection(A.right,B.right,C.right);\n\t\t}\n\t\treturn C;\n\t}\n\t\n\tpublic Node makeUnion(Node A,Node B,Node C){\n\t\t//AとBの和集合の2分木を作る\n\t\t//無いノードを追加していくだけ\n\t\tC=NodeCopy(C,A);\n\t\tC=NodeCopy(C,B);\n\t\treturn C;\n\t}\n\t\n\tpublic Node NodeCopy(Node X,Node Y){\n\t\tif(Y.left!=null){\n\t\t\tif(X.left==null){\n\t\t\t\tX.left=new Node();\n\t\t\t\tX.left.parent=X;\n\t\t\t}\n\t\t\tNodeCopy(X.left,Y.left);\n\t\t}\n\t\tif(Y.right!=null){\n\t\t\tif(X.right==null){\n\t\t\t\tX.right=new Node();\n\t\t\t\tX.right.parent=X;\n\t\t\t}\n\t\t\tNodeCopy(X.right,Y.right);\n\t\t}\n\t\treturn X;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _1001\n{\n\tclass Program\n\t{\n\t\tString Tree1 = \"\";\n\t\tString Tree2 = \"\";\n\t\tStringBuilder Result = new StringBuilder();\n\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tTextReader input = Console.In;\n\t\t\tif (args.Length > 0)\n\t\t\t{\n\t\t\t\tinput = File.OpenText(args[0]);\n\t\t\t}\n\n\t\t\tstring line = null;\n\t\t\twhile ((line = input.ReadLine()) != null)\n\t\t\t{\n\t\t\t\tvar tuple = line.Split(' ');\n\t\t\t\tvar p = new Program();\n\t\t\t\tp.Tree1 = tuple[1];\n\t\t\t\tp.Tree2 = tuple[2];\n\n\t\t\t\tif (tuple[0][0] == 'i')\n\t\t\t\t{\n\t\t\t\t\t// intersection\n\t\t\t\t\tp.Intersection(0, p.Tree1.Length, 0, p.Tree2.Length);\n\t\t\t\t\tConsole.Out.WriteLine(p.Result.ToString());\n\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t{\n\t\t\t\t\t// union\n\t\t\t\t\tp.Union(0, p.Tree1.Length, 0, p.Tree2.Length);\n\t\t\t\t\tConsole.Out.WriteLine(p.Result.ToString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvoid Intersection(int b1, int e1, int b2, int e2)\n\t\t{\n\t\t\tint r1 = FindRoot(Tree1, b1, e1);\n\t\t\tint r2 = FindRoot(Tree2, b2, e2);\n\n\t\t\tResult.Append('(');\n\n\t\t\tif ((b1 + 1) < r1 && (b2 + 1) < r2)\n\t\t\t{\n\t\t\t\t// 左側にノードあり\n\t\t\t\tIntersection(b1 + 1, r1, b2 + 1, r2);\n\t\t\t}\n\n\t\t\tResult.Append(',');\n\n\t\t\tif ((e1 - 2) > r1 && (e2 - 2) > r2)\n\t\t\t{\n\t\t\t\t// 右側にノードあり\n\t\t\t\tIntersection(r1 + 1, e1 - 1, r2 + 1, e2 - 1);\n\t\t\t}\n\n\t\t\tResult.Append(')');\n\t\t}\n\n\t\tvoid Union(int b1, int e1, int b2, int e2)\n\t\t{\n\t\t\tint r1 = FindRoot(Tree1, b1, e1);\n\t\t\tint r2 = FindRoot(Tree2, b2, e2);\n\n\t\t\tResult.Append('(');\n\n\t\t\tif ((b1 + 1) < r1 || (b2 + 1) < r2)\n\t\t\t{\n\t\t\t\t// 左側にノードあり\n\t\t\t\tif ((b1 + 1) >= r1)\n\t\t\t\t{\n\t\t\t\t\t// Tree2だけ\n\t\t\t\t\tResult.Append(Tree2.Substring(b2 + 1, r2 - b2 - 1));\n\t\t\t\t}\n\t\t\t\telse if ((b2 + 1) >= r2)\n\t\t\t\t{\n\t\t\t\t\t// Tree1だけ\n\t\t\t\t\tResult.Append(Tree1.Substring(b1 + 1, r1 - b1 - 1));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// 両方\n\t\t\t\t\tUnion(b1 + 1, r1, b2 + 1, r2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tResult.Append(',');\n\n\t\t\tif ((e1 - 2) > r1 || (e2 - 2) > r2)\n\t\t\t{\n\t\t\t\t// 右側にノードあり\n\t\t\t\tif ((e1 - 2) <= r1)\n\t\t\t\t{\n\t\t\t\t\t// Tree2だけ\n\t\t\t\t\tstring s = Tree2.Substring(r2 + 1, e2 - r2 - 2);\n\t\t\t\t\tResult.Append(s);\n\t\t\t\t}\n\t\t\t\telse if ((e2 - 2) <= r2)\n\t\t\t\t{\n\t\t\t\t\t// Tree1だけ\n\t\t\t\t\tstring s = Tree1.Substring(r1 + 1, e1 - r1 - 2);\n\t\t\t\t\tResult.Append(s);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// 両方\n\t\t\t\t\tUnion(r1 + 1, e1 - 1, r2 + 1, e2 - 1);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tResult.Append(')');\n\t\t}\n\n\t\tint FindRoot(String tree, int b, int e)\n\t\t{\n\t\t\tint depth = 0;\n\t\t\tfor (int index = b; index <= e; ++index)\n\t\t\t{\n\t\t\t\tif (tree[index] == '(')\n\t\t\t\t{\n\t\t\t\t\tdepth++;\n\t\t\t\t}\n\t\t\t\telse if (tree[index] == ')')\n\t\t\t\t{\n\t\t\t\t\tdepth--;\n\t\t\t\t}\n\t\t\t\telse if (depth == 1) \n\t\t\t\t{\n\t\t\t\t\t// 深さ1で,を見つけたら、それがルートの位置\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 0;// ここにはこないはず\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "JavaScript",
    "code": "let input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n    input += chunk;\n});\nprocess.stdin.on('end', function() {\n    const inputs = input.split('\\n');\n    class Node {\n        constructor() {\n            this.left = null;\n            this.right = null;\n            this.parent = null;\n        }\n        insertLeft(node) {\n            this.left = node;\n            node.parent = this;\n        }\n        insertRight(node) {\n            this.right = node;\n            node.parent = this;\n        }\n        toString() {\n            return `(${this.left == null ? '' : this.left.toString()},${this.right == null ? '' : this.right.toString()})`;\n        }\n    }\n\n    const createTree = str => {\n        const root = new Node();\n        let tree = root;\n        let comma = 0;\n        for (const s of str) {\n            if (s == \"(\") {\n                const child = new Node();\n                if (comma == 0) tree.insertLeft(child);\n                else tree.insertRight(child);\n                tree = child;\n            }\n            if (s == \",\") comma = 1;\n            if (s == \")\") {\n                tree = tree.parent;\n                comma = 0;\n            }\n        }\n        return tree.left;\n    }\n    const union = (a, b) => {\n        const node = new Node();\n        if (a == null) return b;\n        if (b == null) return a;\n        let _res = union(a.left, b.left);\n        if (_res != null) node.insertLeft(_res);\n        _res = union(a.right, b.right);\n        if (_res != null) node.insertRight(_res);\n        return node;\n    };\n    const intersection = (a, b) => {\n        const node = new Node();\n        if (a == null || b == null) return null;\n        let _res = intersection(a.left, b.left);\n        if (_res != null) node.insertLeft(_res);\n        _res = intersection(a.right, b.right);\n        if (_res != null) node.insertRight(_res);\n        return node;\n    };\n    for (const input of inputs) {\n        const [type, treeStr, treeStr2] = input.split(' ');\n        const tree = createTree(treeStr);\n        const tree2 = createTree(treeStr2);\n        let res;\n        if (type == \"u\") {\n            res = union(tree, tree2);\n        } else if (type == \"i\") {\n            res = intersection(tree, tree2);\n        }\n    }\n});"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function (chunk) {\n    input += chunk;\n});\nprocess.stdin.on('end', function () {\n    var inputs = input.split('\\n');\n    inputs.pop();\n\n    var Node = function () {\n        function Node() {\n            _classCallCheck(this, Node);\n\n            this.left = null;\n            this.right = null;\n            this.parent = null;\n        }\n\n        _createClass(Node, [{\n            key: 'insertLeft',\n            value: function insertLeft(node) {\n                this.left = node;\n                node.parent = this;\n            }\n        }, {\n            key: 'insertRight',\n            value: function insertRight(node) {\n                this.right = node;\n                node.parent = this;\n            }\n        }, {\n            key: 'toString',\n            value: function toString() {\n                return '(' + (this.left == null ? '' : this.left.toString()) + ',' + (this.right == null ? '' : this.right.toString()) + ')';\n            }\n        }]);\n\n        return Node;\n    }();\n\n    var createTree = function createTree(str) {\n        var root = new Node();\n        var tree = root;\n        var comma = 0;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = str[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var s = _step.value;\n\n                if (s == \"(\") {\n                    var child = new Node();\n                    if (comma == 0) tree.insertLeft(child);else tree.insertRight(child);\n                    tree = child;\n                }\n                if (s == \",\") comma = 1;\n                if (s == \")\") {\n                    tree = tree.parent;\n                    comma = 0;\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        return tree.left;\n    };\n    var union = function union(a, b) {\n        var node = new Node();\n        if (a == null) return b;\n        if (b == null) return a;\n        var _res = union(a.left, b.left);\n        if (_res != null) node.insertLeft(_res);\n        _res = union(a.right, b.right);\n        if (_res != null) node.insertRight(_res);\n        return node;\n    };\n    var intersection = function intersection(a, b) {\n        var node = new Node();\n        if (a == null || b == null) return null;\n        var _res = intersection(a.left, b.left);\n        if (_res != null) node.insertLeft(_res);\n        _res = intersection(a.right, b.right);\n        if (_res != null) node.insertRight(_res);\n        return node;\n    };\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n        for (var _iterator2 = inputs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _input = _step2.value;\n\n            var _input$split = _input.split(' '),\n                _input$split2 = _slicedToArray(_input$split, 3),\n                type = _input$split2[0],\n                treeStr = _input$split2[1],\n                treeStr2 = _input$split2[2];\n\n            var tree = createTree(treeStr);\n            var tree2 = createTree(treeStr2);\n            var res = void 0;\n            if (type == \"u\") {\n                res = union(tree, tree2);\n            } else if (type == \"i\") {\n                res = intersection(tree, tree2);\n            }\n            console.log(res.toString());\n        }\n    } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n            }\n        } finally {\n            if (_didIteratorError2) {\n                throw _iteratorError2;\n            }\n        }\n    }\n});"
  },
  {
    "language": "JavaScript",
    "code": "let input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n    input += chunk;\n});\nprocess.stdin.on('end', function() {\n    const inputs = input.split('\\n');\n    class Node {\n        constructor() {\n            this.left = null;\n            this.right = null;\n            this.parent = null;\n        }\n        insertLeft(node) {\n            this.left = node;\n            node.parent = this;\n        }\n        insertRight(node) {\n            this.right = node;\n            node.parent = this;\n        }\n        toString() {\n            return `(${this.left == null ? '' : this.left.toString()},${this.right == null ? '' : this.right.toString()})`;\n        }\n    }\n\n    const createTree = str => {\n        const root = new Node();\n        let tree = root;\n        let comma = 0;\n        for (const s of str) {\n            if (s == \"(\") {\n                const child = new Node();\n                if (comma == 0) tree.insertLeft(child);\n                else tree.insertRight(child);\n                tree = child;\n            }\n            if (s == \",\") comma = 1;\n            if (s == \")\") {\n                tree = tree.parent;\n                comma = 0;\n            }\n        }\n        return tree.left;\n    }\n    const union = (a, b) => {\n        const node = new Node();\n        if (a == null) return b;\n        if (b == null) return a;\n        let _res = union(a.left, b.left);\n        if (_res != null) node.insertLeft(_res);\n        _res = union(a.right, b.right);\n        if (_res != null) node.insertRight(_res);\n        return node;\n    };\n    const intersection = (a, b) => {\n        const node = new Node();\n        if (a == null || b == null) return null;\n        let _res = intersection(a.left, b.left);\n        if (_res != null) node.insertLeft(_res);\n        _res = intersection(a.right, b.right);\n        if (_res != null) node.insertRight(_res);\n        return node;\n    };\n    for (const input of inputs) {\n        const [type, treeStr, treeStr2] = input.split(' ');\n        const tree = createTree(treeStr);\n        const tree2 = createTree(treeStr2);\n        let res;\n        if (type == \"u\") {\n            res = union(tree, tree2);\n        } else if (type == \"i\") {\n            res = intersection(tree, tree2);\n        }\n        console.log(res.toString());\n    }\n});"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function (chunk) {\n    input += chunk;\n});\nprocess.stdin.on('end', function () {\n    var inputs = input.split('\\n');\n\n    var Node = function () {\n        function Node() {\n            _classCallCheck(this, Node);\n\n            this.left = null;\n            this.right = null;\n            this.parent = null;\n        }\n\n        _createClass(Node, [{\n            key: 'insertLeft',\n            value: function insertLeft(node) {\n                this.left = node;\n                node.parent = this;\n            }\n        }, {\n            key: 'insertRight',\n            value: function insertRight(node) {\n                this.right = node;\n                node.parent = this;\n            }\n        }, {\n            key: 'toString',\n            value: function toString() {\n                return '(' + (this.left == null ? '' : this.left.toString()) + ',' + (this.right == null ? '' : this.right.toString()) + ')';\n            }\n        }]);\n\n        return Node;\n    }();\n\n    var createTree = function createTree(str) {\n        var root = new Node();\n        var tree = root;\n        var comma = 0;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = str[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var s = _step.value;\n\n                if (s == \"(\") {\n                    var child = new Node();\n                    if (comma == 0) tree.insertLeft(child);else tree.insertRight(child);\n                    tree = child;\n                }\n                if (s == \",\") comma = 1;\n                if (s == \")\") {\n                    tree = tree.parent;\n                    comma = 0;\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        return tree.left;\n    };\n    var union = function union(a, b) {\n        var node = new Node();\n        if (a == null) return b;\n        if (b == null) return a;\n        var _res = union(a.left, b.left);\n        if (_res != null) node.insertLeft(_res);\n        _res = union(a.right, b.right);\n        if (_res != null) node.insertRight(_res);\n        return node;\n    };\n    var intersection = function intersection(a, b) {\n        var node = new Node();\n        if (a == null || b == null) return null;\n        var _res = intersection(a.left, b.left);\n        if (_res != null) node.insertLeft(_res);\n        _res = intersection(a.right, b.right);\n        if (_res != null) node.insertRight(_res);\n        return node;\n    };\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n        for (var _iterator2 = inputs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _input = _step2.value;\n\n            var _input$split = _input.split(' '),\n                _input$split2 = _slicedToArray(_input$split, 3),\n                type = _input$split2[0],\n                treeStr = _input$split2[1],\n                treeStr2 = _input$split2[2];\n\n            var tree = createTree(treeStr);\n            var tree2 = createTree(treeStr2);\n            var res = void 0;\n            if (type == \"u\") {\n                res = union(tree, tree2);\n            } else if (type == \"i\") {\n                res = intersection(tree, tree2);\n            }\n            console.log(res.toString());\n        }\n    } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n            }\n        } finally {\n            if (_didIteratorError2) {\n                throw _iteratorError2;\n            }\n        }\n    }\n});"
  },
  {
    "language": "JavaScript",
    "code": "let input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function(chunk) {\n    input += chunk;\n});\nprocess.stdin.on('end', function() {\n    const inputs = input.split('\\n');\n    inputs.pop();\n    class Node {\n        constructor() {\n            this.left = null;\n            this.right = null;\n            this.parent = null;\n        }\n        insertLeft(node) {\n            this.left = node;\n            node.parent = this;\n        }\n        insertRight(node) {\n            this.right = node;\n            node.parent = this;\n        }\n        toString() {\n            return `(${this.left == null ? '' : this.left.toString()},${this.right == null ? '' : this.right.toString()})`;\n        }\n    }\n\n    const createTree = str => {\n        const root = new Node();\n        let tree = root;\n        let comma = 0;\n        for (const s of str) {\n            if (s == \"(\") {\n                const child = new Node();\n                if (comma == 0) tree.insertLeft(child);\n                else tree.insertRight(child);\n                tree = child;\n            }\n            if (s == \",\") comma = 1;\n            if (s == \")\") {\n                tree = tree.parent;\n                comma = 0;\n            }\n        }\n        return tree.left;\n    }\n    const union = (a, b) => {\n        const node = new Node();\n        if (a == null) return b;\n        if (b == null) return a;\n        let _res = union(a.left, b.left);\n        if (_res != null) node.insertLeft(_res);\n        _res = union(a.right, b.right);\n        if (_res != null) node.insertRight(_res);\n        return node;\n    };\n    const intersection = (a, b) => {\n        const node = new Node();\n        if (a == null || b == null) return null;\n        let _res = intersection(a.left, b.left);\n        if (_res != null) node.insertLeft(_res);\n        _res = intersection(a.right, b.right);\n        if (_res != null) node.insertRight(_res);\n        return node;\n    };\n    for (const input of inputs) {\n        const [type, treeStr, treeStr2] = input.split(' ');\n        const tree = createTree(treeStr);\n        const tree2 = createTree(treeStr2);\n        let res;\n        if (type == \"u\") {\n            res = union(tree, tree2);\n        } else if (type == \"i\") {\n            res = intersection(tree, tree2);\n        }\n        console.log(res.toString());\n    }\n});"
  },
  {
    "language": "JavaScript",
    "code": "'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar input = '';\nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\nprocess.stdin.on('data', function (chunk) {\n    input += chunk;\n});\nprocess.stdin.on('end', function () {\n    var inputs = input.split('\\n');\n\n    var Node = function () {\n        function Node() {\n            _classCallCheck(this, Node);\n\n            this.left = null;\n            this.right = null;\n            this.parent = null;\n        }\n\n        _createClass(Node, [{\n            key: 'insertLeft',\n            value: function insertLeft(node) {\n                this.left = node;\n                node.parent = this;\n            }\n        }, {\n            key: 'insertRight',\n            value: function insertRight(node) {\n                this.right = node;\n                node.parent = this;\n            }\n        }, {\n            key: 'toString',\n            value: function toString() {\n                return '(' + (this.left == null ? '' : this.left.toString()) + ',' + (this.right == null ? '' : this.right.toString()) + ')';\n            }\n        }]);\n\n        return Node;\n    }();\n\n    var createTree = function createTree(str) {\n        var root = new Node();\n        var tree = root;\n        var comma = 0;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = str[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var s = _step.value;\n\n                if (s == \"(\") {\n                    var child = new Node();\n                    if (comma == 0) tree.insertLeft(child);else tree.insertRight(child);\n                    tree = child;\n                }\n                if (s == \",\") comma = 1;\n                if (s == \")\") {\n                    tree = tree.parent;\n                    comma = 0;\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        return tree.left;\n    };\n    var union = function union(a, b) {\n        var node = new Node();\n        if (a == null) return b;\n        if (b == null) return a;\n        var _res = union(a.left, b.left);\n        if (_res != null) node.insertLeft(_res);\n        _res = union(a.right, b.right);\n        if (_res != null) node.insertRight(_res);\n        return node;\n    };\n    var intersection = function intersection(a, b) {\n        var node = new Node();\n        if (a == null || b == null) return null;\n        var _res = intersection(a.left, b.left);\n        if (_res != null) node.insertLeft(_res);\n        _res = intersection(a.right, b.right);\n        if (_res != null) node.insertRight(_res);\n        return node;\n    };\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n        for (var _iterator2 = inputs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _input = _step2.value;\n\n            var _input$split = _input.split(' '),\n                _input$split2 = _slicedToArray(_input$split, 3),\n                type = _input$split2[0],\n                treeStr = _input$split2[1],\n                treeStr2 = _input$split2[2];\n\n            var tree = createTree(treeStr);\n            var tree2 = createTree(treeStr2);\n            var res = void 0;\n            if (type == \"u\") {\n                res = union(tree, tree2);\n            } else if (type == \"i\") {\n                res = intersection(tree, tree2);\n            }\n            console.log(res.toString());\n        }\n    } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n    } finally {\n        try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n            }\n        } finally {\n            if (_didIteratorError2) {\n                throw _iteratorError2;\n            }\n        }\n    }\n});"
  },
  {
    "language": "Ruby",
    "code": "class Node\n  attr_reader :left, :right\n  def initialize(left,right)\n    @left = left\n    @right = right\n  end\n  def leaf?\n    not (left || right)\n  end\n  def to_s\n    if self.leaf?\n      \"(,)\"\n    elsif !@left\n      \"(,#@right)\"\n    elsif !@right\n      \"(#@left,)\"\n    else\n      \"(#@left,#@right)\"\n    end\n  end\nend\n\nclass Parser\n  def initialize(str)\n    @str = str\n    @idx = 0\n  end\n  def read\n    if @str[@idx] == \"(\"\n      @idx += 1\n      left = read\n      @idx += 1\n      right = read\n      @idx += 1\n      Node.new(left,right)\n    else\n      nil\n    end\n  end\nend\n\ndef its (a,b)\n  if a && b\n    Node.new(its(a.left,b.left),its(a.right,b.right))\n  else\n    nil\n  end\nend\n\ndef uni (a,b)\n  if !a\n    b\n  elsif !b\n    a\n  else\n    Node.new(uni(a.left,b.left),uni(a.right,b.right))\n  end\nend\n\nwhile line = gets\n  ch, a, b = line.split\n  c = Parser.new(a).read\n  d = Parser.new(b).read\n\n  if ch==\"i\"\n    puts its(c,d)\n  else\n    puts uni(c,d)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef make_tree(st)\n  return nil if st[0] != '('\n\n  st[0] = ''\n  lt = make_tree(st)\n  puts \"error ,\" if st[0] != ','\n  st[0] = ''\n  rt = make_tree(st)\n  puts \"error )\" if st[0] != ')'\n  st[0] = ''\n\n  [lt, rt]\nend\n\ndef intersection(t0, t1)\n  return nil if t0.nil? || t1.nil?\n\n  [ intersection(t0[0], t1[0]), intersection(t0[1], t1[1])]\nend\n\ndef union(t0, t1)\n  return t1 if t0.nil?\n  return t0 if t1.nil?\n\n  [ union(t0[0], t1[0]), union(t0[1], t1[1])]\nend\n\ndef tree2str(t)\n  return '' if t.nil?\n  '(' + tree2str(t[0]) + ',' + tree2str(t[1]) + ')'\nend\n\n### main\n\nwhile line = gets\n  op, st0, st1 = line.strip.split(' ')\n\n  t0 = make_tree(st0)\n  t1 = make_tree(st1)\n  #p t0\n  #p t1\n\n  t = (op == 'i') ? intersection(t0, t1) : union(t0, t1)\n  puts tree2str(t)\nend"
  },
  {
    "language": "Ruby",
    "code": "#!ruby -nl\n\ndef parse(str)\n  eval str.tr('(', '[').tr(')', ']').gsub('[,', '[nil,').gsub(',]', ',nil]')\nend\n\ndef intersection(l, r)\n  res = []\n  res[0] = (l && l[0]) && (r && r[0]) ? intersection(l[0], r[0]) : nil\n  res[1] = (l && l[1]) && (r && r[1]) ? intersection(l[1], r[1]) : nil\n  res\nend\n\ndef union(l, r)\n  res = []\n  res[0] = (l && l[0]) || (r && r[0]) ? union(l[0], r[0]) : nil\n  res[1] = (l && l[1]) || (r && r[1]) ? union(l[1], r[1]) : nil\n  res\nend\n\ndef print(tree)\n  puts tree.inspect.tr(' ', '').tr('[', '(').tr(']', ')').gsub('nil', '')\nend\n\nt, l, r = $_.chomp.split\ntl = parse l\ntr = parse r\n\nres = t == 'u' ? union(tl, tr) : intersection(tl, tr)\nprint(res)"
  },
  {
    "language": "Ruby",
    "code": "#!ruby -nl\n\ndef parse(str)\n  eval str.tr!('(', '[').tr!(')', ']').gsub!('[,', '[nil,').gsub!(',]', ',nil]')\nend\n\ndef intersection(l, r)\n  res = []\n  res[0] = (l && l[0]) && (r && r[0]) ? intersection(l[0], r[0]) : nil\n  res[1] = (l && l[1]) && (r && r[1]) ? intersection(l[1], r[1]) : nil\n  res\nend\n\ndef union(l, r)\n  res = []\n  res[0] = (l && l[0]) || (r && r[0]) ? union(l[0], r[0]) : nil\n  res[1] = (l && l[1]) || (r && r[1]) ? union(l[1], r[1]) : nil\n  res\nend\n\ndef print(tree)\n  p tree.inspect.tr!(' ', '').tr!('[', '(').tr!(']', ')').gsub!('nil', '')\nend\n\nt, l, r = $_.chomp.split\ntl = parse l\ntr = parse r\n\nres = t == 'u' ? union(tl, tr) : intersection(tl, tr)\nprint(res)"
  },
  {
    "language": "Ruby",
    "code": "def findr(str, s, e)\n  d, i = 0, s\n  while i < e\n    d+= 1 if str[i] == '('\n    d-= 1 if str[i] == ')'\n    return i if d == 1 and str[i] == ','\n    i += 1\n  end\nend\n\ndef solve(s1, e1, s2, e2)\n  f1, f2, m1, m2 = s1 < e1, s2 < e2, e1 - 1, e2 - 2\n  m1 = findr($t1, s1, e1) if f1\n  m2 = findr($t2, s2, e2) if f2\n  if ($isI and f1 and f2) or (not $isI and (f1 or f2))\n    printf(\"(\"); solve(s1 + 1, m1, s2 + 1, m2)\n    printf(\",\"); solve(m1 + 1, e1 - 1, m2 + 1, e2 - 1)\n    printf(\")\")\n  end\nend\n\nwhile line = gets\n  op, a, b = line.chomp.split(/\\s/)\n  $t1, $t2 = a.split(//), b.split(//)\n  $isI = (op == \"i\")\n  solve(0, $t1.size, 0, $t2.size)\n  puts\nend"
  },
  {
    "language": "Ruby",
    "code": "class Node\n  attr_reader :left, :right\n  def initialize(left,right)\n    @left = left\n    @right = right\n  end\n  def to_s\n    \"(#{@left||\"\"},#{@right||\"\"})\"\n  end\nend\n\nclass Parser\n  def initialize(str)\n    @str = str\n    @idx = 0\n  end\n  def peek\n    @str[@idx]\n  end\n  def readc\n    @idx += 1\n    @str[@idx-1]\n  end\n  def read\n    if peek == ?(\n      readc\n      l = read\n      puts \"assert,\" if readc != ?,\n      r = read\n      puts \"assert)\" if readc != ?)\n      Node.new(l,r)\n    else\n      nil\n    end\n  end\nend\n\ndef its (a,b)\n  if a && b\n    Node.new(its(a.left,b.left),its(a.right,b.right))\n  else\n    nil\n  end\nend\n\ndef uni (a,b)\n  if !a\n    b\n  elsif !b\n    a\n  else\n    Node.new(uni(a.left,b.left),uni(a.right,b.right))\n  end\nend\n\nwhile line = gets\n  ch, a, b = line.split\n  c = Parser.new(a).read\n  d = Parser.new(b).read\n\n  if ch==\"i\"\n    puts its(c,d)\n  elsif ch==\"u\"\n    puts uni(c,d)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "class Node\n  attr_reader :left, :right\n  def initialize(left,right)\n    @left = left\n    @right = right\n  end\n  def to_s\n    \"(#{@left||\"\"},#{@right||\"\"})\"\n  end\nend\n\nclass Parser\n  def initialize(str)\n    @str = str\n    @idx = 0\n  end\n  def read\n    if @str[@idx] == ?(\n      @idx += 1\n      l = read\n      @idx += 1\n      r = read\n      @idx += 1\n      Node.new(l,r)\n    else\n      nil\n    end\n  end\nend\n\ndef its (a,b)\n  if a && b\n    Node.new(its(a.left,b.left),its(a.right,b.right))\n  else\n    nil\n  end\nend\n\ndef uni (a,b)\n  if !a\n    b\n  elsif !b\n    a\n  else\n    Node.new(uni(a.left,b.left),uni(a.right,b.right))\n  end\nend\n\nwhile line = gets\n  ch, a, b = line.split\n  c = Parser.new(a).read\n  d = Parser.new(b).read\n\n  if ch==\"i\"\n    puts its(c,d)\n  elsif ch==\"u\"\n    puts uni(c,d)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def find_mid(str)\n  tmp = 0\n  len = str.length\n  for i in (0...len)\n    tmp += 1 if str[i] == '('\n    tmp -= 1 if str[i] == ')'\n    return i if str[i] == ',' and tmp == 1\n  end\nend\n\nclass Node\n  def initialize\n    @left_son = nil\n    @right_son = nil\n  end\n\n  def extend(str)\n    len = str.length\n    mid = find_mid(str)\n    if mid > 1\n      @left_son = Node.new unless @left_son\n      @left_son.extend(str[1...mid])\n    end\n    if mid < len - 2\n      @right_son = Node.new unless @right_son\n      @right_son.extend(str[mid+1...len-1])\n    end\n  end\n\n  def shrink(str)\n    len = str.length\n    mid = find_mid(str)\n    if @left_son\n      if mid > 1\n        @left_son.shrink(str[1...mid])\n      else\n        @left_son = nil\n      end\n    end\n    if @right_son\n      if mid < len - 2\n        @right_son.shrink(str[mid+1...len-1])\n      else\n        @right_son = nil\n      end\n    end\n  end\n\n  def to_s\n    str = \"(\"\n    str += @left_son.to_s if @left_son\n    str += \",\"\n    str += @right_son.to_s if @right_son\n    str += \")\"\n    return str\n  end\nend\n\nwhile line = gets\n  k, a, b = line.split()\n  root = Node.new\n  root.extend(a)\n  root.extend(b) if k == \"u\"\n  root.shrink(b) if k == \"i\"\n  puts root.to_s\nend"
  },
  {
    "language": "Ruby",
    "code": "def extract tree\n    stack, arr = [2], [1]\n    tree[1..-2].each_char{|c|\n        case c\n        when \"(\"\n            arr << stack[-1]\n            stack << stack[-1] * 2\n        when \")\"\n            stack.pop\n        when \",\"\n            stack[-1] += 1\n        end\n    }\n    return arr\nend\n\ndef express numbers\n    arr = []\n    numbers.each{|x| arr[x]  = \"(#{arr[x * 2]},#{arr[x * 2 + 1]})\"}\n    puts arr[1]\nend\n\nwhile line = gets\n    op, tree1, tree2 = line.chomp.split\n    node1 = extract(tree1)\n    node2 = extract(tree2)\n    nodes = (op == \"i\") ? (node1 - (node1 - node2)).sort.reverse : ((node1 - node2) + node2).sort.reverse\n    express nodes\nend\n"
  },
  {
    "language": "Ruby",
    "code": "class Node\n  attr_reader :left, :right\n  def initialize(left,right)\n    @left = left\n    @right = right\n  end\n  def leaf?\n    not (left || right)\n  end\n  def to_s\n    if self.leaf?\n      \"(,)\"\n    elsif !@left\n      \"(,#@right)\"\n    elsif !@right\n      \"(#@left,)\"\n    else\n      \"(#@left,#@right)\"\n    end\n  end\nend\n\nclass Parser\n  def initialize(str)\n    @str = str\n    @idx = 0\n  end\n  def read\n    if @str[@idx] == \"(\"\n      @idx += 1\n      left = read\n      @idx += 1\n      right = read\n      @idx += 1\n      Node.new(left,right)\n    else\n      nil\n    end\n  end\nend\n\ndef its (a,b)\n  if a && b\n    Node.new(its(a.left,b.left),its(a.right,b.right))\n  else\n    nil\n  end\nend\n\ndef uni (a,b)\n  if !a\n    b\n  elsif !b\n    a\n  else\n    Node.new(uni(a.left,b.left),uni(a.right,b.right))\n  end\nend\n\nwhile line = gets\n  ch, a, b = line.split\n  c = Parser.new(a).read\n  d = Parser.new(b).read\n\n  if ch==\"i\"\n    puts its(c,d)\n  else\n    puts uni(c,d)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "#!ruby -pal\ni=j=0\nt,a,b=$F\n$_=\"\"\n(e=a[i])==b[j]?($_+=e;i+=1;j+=1):(c,k,q=e<?)?[a,i,0]:[b,j];d=0;begin e=c[k];d+=e<?)?1:e<?,?-1:0;t>?i&&$_+=e;k+=1;end while d>0;q ?(i=k):j=k)while a[i]"
  },
  {
    "language": "Ruby",
    "code": "class Node\n  attr_reader :left, :right\n  def initialize(left,right)\n    @left = left\n    @right = right\n  end\n  def leaf?\n    not (left || right)\n  end\n  def to_s\n    if self.leaf?\n      \"(,)\"\n    elsif !@left\n      \"(,#@right)\"\n    elsif !@right\n      \"(#@left,)\"\n    else\n      \"(#@left,#@right)\"\n    end\n  end\nend\n\nclass Parser\n  def initialize(str)\n    @str = str\n    @idx = 0\n  end\n  def read\n    if @str[@idx] == \"(\"\n      @idx += 1\n      left = read\n      @idx += 1\n      right = read\n      @idx += 1\n      Node.new(left,right)\n    else\n      nil\n    end\n  end\nend\n\ndef its (a,b)\n  if a && b\n    Node.new(its(a.left,b.left),its(a.right,b.right))\n  else\n    nil\n  end\nend\n\ndef uni (a,b)\n  if !a\n    b\n  elsif !b\n    a\n  else\n    Node.new(uni(a.left,b.left),uni(a.right,b.right))\n  end\nend\n\nwhile line = gets\n  ch, a, b = line.split\n  c = Parser.new(a).read\n  d = Parser.new(b).read\n\n  if ch==\"i\"\n    puts its(c,d)\n  else\n    puts uni(c,d)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "#!ruby -pal\ndef f t,c,d\nn=[$,]*2\n[0,1].map{|j|t<1?(c[j]||d[j]&&c[j]||=n)&&(f t,c[j],d[j]||=n):d[j]?c[j]&&(f t,c[j],d[j]):c[j]=$,}\nc\nend\n$_=\"#{f *$F.map{|l|eval(l.tr(\"ui()\",\"01[]\").gsub /(\\[|,)(?=,|\\])/,'\\1$,')}}\".delete(\"nil \").tr\"[]\",\"()\""
  },
  {
    "language": "Ruby",
    "code": "class Node\n  attr_reader :left, :right\n  def initialize(left,right)\n    @left = left\n    @right = right\n  end\n  def leaf?\n    not (left || right)\n  end\n  def to_s\n    if self.leaf?\n      \"(,)\"\n    elsif !@left\n      \"(,#@right)\"\n    elsif !@right\n      \"(#@left,)\"\n    else\n      \"(#@left,#@right)\"\n    end\n  end\nend\n\nclass Parser\n  def initialize(str)\n    @str = str\n    @idx = 0\n  end\n  def read\n    if @str[@idx] == \"(\"\n      @idx += 1\n      left = read\n      @idx += 1\n      right = read\n      @idx += 1\n      Node.new(left,right)\n    else\n      nil\n    end\n  end\nend\n\ndef its (a,b)\n  if a && b\n    Node.new(its(a.left,b.left),its(a.right,b.right))\n  else\n    nil\n  end\nend\n\ndef uni (a,b)\n  if !a\n    b\n  elsif !b\n    a\n  else\n    Node.new(uni(a.left,b.left),uni(a.right,b.right))\n  end\nend\n\nwhile line = gets\n  ch, a, b = line.split\n  c = Parser.new(a).read\n  d = Parser.new(b).read\n\n  if ch==\"i\"\n    print its(c,d)\n  else\n    print uni(c,d)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "#!ruby -pal\ni=j=d=0\nt,a,b=$F\ns=\"\"\nwhile a[i]&&b[j]\nif a[i]==b[j] \n[s+=a[i],i+=1,j+=1]\nelse\nc,k,p=a[i]==?(?[a,i,0]:[b,j,1]\nd=1\nt>?i&&s+=c[k]\nk+=1\nwhile d>0\nc[k]==?(&&d+=1\nc[k]==?)&&d-=1\nt>?i&&s+=c[k]\nk+=1\nend\np==0?(i=k):j=k\nend\nend\n$_=s"
  },
  {
    "language": "Ruby",
    "code": "class Node\n  attr_reader :left, :right\n  def initialize(left,right)\n    @left = left\n    @right = right\n  end\n  def leaf?\n    not (left || right)\n  end\n  def to_s\n    if self.leaf?\n      \"(,)\"\n    elsif !@left\n      \"(,#@right)\"\n    elsif !@right\n      \"(#@left,)\"\n    else\n      \"(#@left,#@right)\"\n    end\n  end\nend\n\nclass Parser\n  def initialize(str)\n    @str = str\n    @idx = 0\n  end\n  def read\n    if @str[@idx] == \"(\"\n      @idx += 1\n      left = read\n      @idx += 1\n      right = read\n      @idx += 1\n      Node.new(left,right)\n    else\n      nil\n    end\n  end\nend\n\ndef its (a,b)\n  if a && b\n    Node.new(its(a.left,b.left),its(a.right,b.right))\n  else\n    nil\n  end\nend\n\ndef uni (a,b)\n  if !a\n    b\n  elsif !b\n    a\n  else\n    Node.new(uni(a.left,b.left),uni(a.right,b.right))\n  end\nend\n\nwhile line = gets\n  ch, a, b = line.split\n  c = Parser.new(a).read\n  d = Parser.new(b).read\n\n  if ch==\"i\"\n    puts its(c,d)\n  else\n    puts uni(c,d)\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "#!ruby -pal\ndef i c,d\n[0,1].map{|j|d[j]?c[j]&&(i c[j],d[j]):(c[j]=nil)}\nc\nend\ndef u c,d\n[0,1].map{|j|(c[j]||d[j]&&(c[j]||=[nil,nil]))&&(u c[j],d[j]||=[nil,nil])}\nc\nend\n$_=eval($F[0]+\" \"+$F[1,2].map{|l|l.tr(\"()\",\"[]\").gsub(/(\\[|,)(?=,|\\])/,'\\1nil')}*\",\").to_s.gsub(/nil| /,\"\").tr(\"[]\",\"()\")"
  },
  {
    "language": "OCaml",
    "code": "type tree = Br of int * tree * tree | Lf\n\nmodule IntSet = Set.Make\n                  (\n                    struct\n                      type t = int\n                      let compare (x : int) y = compare x y\n                    end\n                  )\n\nlet drop_chars str n =\n  let len = String.length str in\n  assert (n <= len);\n  String.sub str n (len - n)\n\nlet parse_tree expr =\n  let rec parse_tree expr n =\n    if expr.[0] <> '(' then (Lf, expr)\n    else\n      let expr = drop_chars expr 1 in\n      let lhs, expr = parse_tree expr (n * 2) in\n      assert (expr.[0] = ',');\n      let expr = drop_chars expr 1 in\n      let rhs, expr = parse_tree expr (n * 2 + 1) in\n      assert (expr.[0] = ')');\n      (Br (n, lhs, rhs), drop_chars expr 1) in\n  fst @@ parse_tree expr 1\n\nlet node_numbers tree =\n  let rec node_numbers set = function\n    | Lf -> set\n    | Br (n, lhs, rhs) ->\n       let set = IntSet.add n set in\n       let set = node_numbers set lhs in\n       node_numbers set rhs in\n  node_numbers IntSet.empty tree\n\nlet encode_node_numberes set =\n  let rec encode n =\n    let lhs = if IntSet.mem (n * 2) set then encode (n * 2) else \"\" in\n    let rhs = if IntSet.mem (n * 2 + 1) set then encode (n * 2 + 1) else \"\" in\n    Printf.sprintf \"(%s,%s)\" lhs rhs in\n  encode 1\n\nlet rec loop () =\n  try\n    let line = read_line () in\n    let encoded =\n      Scanf.sscanf\n        line\n        \"%c %s %s\"\n        (fun c t1 t2 ->\n         let t1, t2 =\n           (node_numbers @@ parse_tree t1), (node_numbers @@ parse_tree t2) in\n         let op = if c = 'i' then IntSet.inter else IntSet.union in\n         encode_node_numberes (op t1 t2)) in\n    print_endline encoded;\n    loop ()\n  with End_of_file -> ()\n\nlet () = loop ()"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nclass Node {\n    Node left, right;\n    this(Node left = null, Node right = null) {\n        this.left = left;\n        this.right = right;\n    }\n    override string toString() {\n        return \"(\" ~ (left is null ? \"\" : left.toString) ~ \",\"\n                   ~ (right is null ? \"\" : right.toString) ~ \")\";\n    }\n}\n \nvoid main() {\n\n    string t, a, b;\n\n    bool input() {\n        string s = readln;\n        if (s is null) return false;\n        auto _ = s.split(\" \");\n        t = _[0]; a = _[1]; b = _[2];\n        return true;\n    }\n\n    void solve() {\n\n        Node parse(string s) {\n            int index = 0;\n            Node node() {\n                assert(s[index] == '(');\n                index++;\n                Node left, right;\n                left = (s[index] == ',' ? null : node);\n                assert(s[index] == ',');\n                index++;\n                right = (s[index] == ')' ? null : node);\n                assert(s[index] == ')');\n                index++;\n                return new Node(left, right);\n            }\n            return node;\n        }\n        \n        Node x = parse(a),\n             y = parse(b);\n\n        int height(Node node) {\n            if (node is null) return 0;\n            return max(height(node.right), height(node.left)) + 1;\n        }\n\n        Node buildCompleteTree(int h) {\n            if (h == 0) return null;\n            return new Node(buildCompleteTree(h - 1), buildCompleteTree(h - 1));\n        }\n\n        if (t == \"i\") {\n            void dfs(in Node p, in Node q, ref Node r) {\n                if (p.left !is null && q.left !is null) {\n                    r.left = new Node;\n                    dfs(p.left, q.left, r.left);\n                }\n                if (p.right !is null && q.right !is null) {\n                    r.right = new Node;\n                    dfs(p.right, q.right, r.right);\n                }\n            }\n            Node z = new Node;\n            dfs(x, y, z);\n            writeln(z);\n        } else {\n            assert(t == \"u\");\n            void dfs1(in Node p, in Node q, ref Node r) {\n                if ( (p is null || p.left is null) && \n                     (q is null || q.left is null) ) {\n                    r.left = null;\n                } else {\n                    r.left = new Node;\n                    dfs1( (p is null ? null : p.left), \n                          (q is null ? null : q.left), r.left );\n                }\n                if ( (p is null || p.right is null) && \n                     (q is null || q.right is null) ) {\n                    r.right = null;\n                } else {\n                    r.right = new Node;\n                    dfs1( (p is null ? null : p.right), \n                          (q is null ? null : q.right), r.right );\n                }\n            }\n            Node z = new Node;\n            dfs1(x, y, z);\n            writeln(z);\n        }\n\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nclass Node {\n    Node left, right;\n    this(Node left = null, Node right = null) {\n        this.left = left;\n        this.right = right;\n    }\n    override string toString() {\n        return \"(\" ~ (left is null ? \"\" : left.toString) ~ \",\"\n                   ~ (right is null ? \"\" : right.toString) ~ \")\";\n    }\n}\n \nvoid main() {\n\n    string t, a, b;\n\n    bool input() {\n        string s = readln;\n        if (s is null) return false;\n        auto _ = s.split(\" \");\n        t = _[0]; a = _[1]; b = _[2];\n        return true;\n    }\n\n    void solve() {\n\n        Node parse(string s) {\n            int index = 0;\n            Node node() {\n                assert(s[index] == '(');\n                index++;\n                Node left, right;\n                left = (s[index] == ',' ? null : node);\n                assert(s[index] == ',');\n                index++;\n                right = (s[index] == ')' ? null : node);\n                assert(s[index] == ')');\n                index++;\n                return new Node(left, right);\n            }\n            return node;\n        }\n        \n        Node x = parse(a),\n             y = parse(b);\n\n        int height(Node node) {\n            if (node is null) return 0;\n            return max(height(node.right), height(node.left)) + 1;\n        }\n\n        Node buildCompleteTree(int h) {\n            if (h == 0) return null;\n            return new Node(buildCompleteTree(h - 1), buildCompleteTree(h - 1));\n        }\n\n        Node z = buildCompleteTree(max(height(x), height(y)));\n\n        if (t == \"i\") {\n            void dfs(in Node p, ref Node q) {\n                if (p is null || q is null) return;\n                if (p.left is null) q.left = null;\n                if (p.right is null) q.right = null;\n                dfs(p.left, q.left);\n                dfs(p.right, q.right);\n            }\n            dfs(x, z);\n            dfs(y, z);\n            writeln(z);\n        } else {\n            assert(t == \"u\");\n            void dfs1(in Node p, in Node q, ref Node r) {\n                if ( (p is null || p.left is null) && \n                     (q is null || q.left is null) ) {\n                    r.left = null;\n                } else {\n                    dfs1(p.left, q.left, r.left);\n                }\n                if ( (p is null || p.right is null) && \n                     (q is null || q.right is null) ) {\n                    r.right = null;\n                } else {\n                    dfs1(p.right, q.right, r.right);\n                }\n            }\n            dfs1(x, y, z);\n            writeln(z);\n        }\n\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nclass Node {\n    Node left, right;\n    this(Node left = null, Node right = null) {\n        this.left = left;\n        this.right = right;\n    }\n    override string toString() {\n        return \"(\" ~ (left is null ? \"\" : left.toString) ~ \",\"\n                   ~ (right is null ? \"\" : right.toString) ~ \")\";\n    }\n}\n \nvoid main() {\n\n    string t, a, b;\n\n    bool input() {\n        string s = readln;\n        if (s is null) return false;\n        auto _ = s.split(\" \");\n        t = _[0]; a = _[1]; b = _[2];\n        return true;\n    }\n\n    void solve() {\n\n        Node parse(string s) {\n            int index = 0;\n            Node node() {\n                assert(s[index] == '(');\n                index++;\n                Node left, right;\n                left = (s[index] == ',' ? null : node);\n                assert(s[index] == ',');\n                index++;\n                right = (s[index] == ')' ? null : node);\n                assert(s[index] == ')');\n                index++;\n                return new Node(left, right);\n            }\n            return node;\n        }\n        \n        Node x = parse(a),\n             y = parse(b);\n\n        int height(Node node) {\n            if (node is null) return 0;\n            return max(height(node.right), height(node.left)) + 1;\n        }\n\n        Node buildCompleteTree(int h) {\n            if (h == 0) return null;\n            return new Node(buildCompleteTree(h - 1), buildCompleteTree(h - 1));\n        }\n\n        //Node z = buildCompleteTree(max(height(x), height(y)));\n\n        if (t == \"i\") {\n            void dfs(in Node p, in Node q, ref Node r) {\n                if (p.left !is null && q.left !is null) {\n                    r.left = new Node;\n                    dfs(p.left, q.left, r.left);\n                }\n                if (p.right !is null && q.right !is null) {\n                    r.right = new Node;\n                    dfs(p.right, q.right, r.right);\n                }\n            }\n            Node z = new Node;\n            dfs(x, y, z);\n            writeln(z);\n        } else {\n            assert(t == \"u\");\n            void dfs1(in Node p, in Node q, ref Node r) {\n                if ( (p is null || p.left is null) && \n                     (q is null || q.left is null) ) {\n                    r.left = null;\n                } else {\n                    r.left = new Node;\n                    dfs1(p.left, q.left, r.left);\n                }\n                if ( (p is null || p.right is null) && \n                     (q is null || q.right is null) ) {\n                    r.right = null;\n                } else {\n                    r.right = new Node;\n                    dfs1(p.right, q.right, r.right);\n                }\n            }\n            Node z = new Node;\n            dfs1(x, y, z);\n            writeln(z);\n        }\n\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(10000000)\n\nfor line in sys.stdin:\n    op, S1, S2 = line.split()\n    id1 = id2 = 0\n    ans = ''\n    \n    def rem(S, ind):\n        rem = '('\n        cnt = 1\n        while cnt > 0:\n            if S[ind] == '(':\n                cnt += 1\n            elif S[ind] == ')':\n                cnt -= 1\n            rem += S[ind]\n            ind += 1\n        return rem, ind\n\n    while id1 < len(S1):\n        if S1[id1] == S2[id2]:\n            ans += S1[id1]\n            id1 += 1\n            id2 += 1\n        elif S1[id1] == '(':\n            S, id1 = rem(S1, id1 + 1)\n            if op == 'u':\n                ans += S\n        elif S2[id2] == '(':\n            S, id2 = rem(S2, id2 + 1)\n            if op == 'u':\n                ans += S\n    \n    print ans\n"
  },
  {
    "language": "Python",
    "code": "def s(p,A,B):b=lambda i:(A[i]and B[i])and s(p,A[i],B[i])or p==u and(A[i]or B[i])or 0;return(b(0),b(1))\ntry:\n while 1:g=_,i,u=raw_input().split();print`s(*map(lambda s:eval(s.replace(\"(,\",\"(0,\").replace(\",)\",\",0)\")),g))`.replace(\" \",\"\").replace(\"0\",\"\")\nexcept:pass"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n'''\nCreated on 2017/10/25\n\n@author: naja yama\n'''\n   \ndef find_r_child(tree, offset):\n    \n    offset += 1\n    count = 0\n    end = len(tree)\n    while(offset < end):\n        if tree[offset] == \"(\":\n            count += 1\n        elif tree[offset] == \")\":\n            count -= 1\n        elif count == 1 and tree[offset] == \",\":\n            return offset\n        \n        offset += 1 \n        \n    return None\n\n\n\ndef find_l_child(tree, offset):\n    \n    offset -= 1\n    count = 0\n    while(offset >= 1):\n        if tree[offset] == \"(\":\n            count -= 1\n        elif tree[offset] == \")\":\n            count += 1\n        elif count == 1 and tree[offset] == \",\":\n            return offset\n        \n        offset -= 1\n        \n    return None\n\n\ndef del_node(tree, offset, offset_r):\n    count = 0\n    i = offset - 1\n    \n    while(1):\n        if tree[i] == \")\":\n            count += 1\n        elif tree[i] == \"(\":\n            if count == 0:\n                offset2 = i\n                break\n            count -= 1\n        \n        i -= 1, \n    \n    count = 0\n    i = offset + 1        \n    \n    while(1):\n        if tree[i] == \"(\":\n\n            count += 12\n        elif tree[i] == \")\":\n            if count == 0:\n                offset3 = i\n                break            \n            count -= 1\n            \n        i += 1        \n    \n    tree = tree[:offset2] + tree[offset3 + 1:]\n    \n    if offset_r < offset2:\n        return (tree, offset_r)\n    else:\n        return (tree, offset_r - (offset3 + 1 - offset2))\n\ndef calc_union(s_tree, offset_s, r_tree, offset_r):\n        \n    offset_cs = find_l_child(s_tree, offset_s)\n    \n    if offset_cs is None:\n        pass\n    else:\n        \n        offset_rs = find_l_child(r_tree, offset_r)\n        \n        if offset_rs is None:\n            r_tree = r_tree[:offset_r] + \"(,)\" + r_tree[offset_r:]\n            offset_rs = offset_r + 2\n            \n        r_tree = calc_union(s_tree, offset_cs, r_tree, offset_rs)\n    \n    \n    offset_cs = find_r_child(s_tree, offset_s)\n    \n    if offset_cs is None:\n        return r_tree\n    \n    offset_rs = find_r_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        r_tree = r_tree[:offset_r+1] + \"(,)\" + r_tree[offset_r+1:]\n        offset_rs = offset_r + 2\n        \n    r_tree = calc_union(s_tree, offset_cs, r_tree, offset_rs)\n    \n    return r_tree\n\n\n        \ndef calc_intersection(s_tree, offset_s, r_tree, offset_r):\n    \n    offset_rs = find_l_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        pass\n    else: \n        offset_cs = find_l_child(s_tree, offset_s)\n        if offset_cs is None:    \n            (r_tree, offset_r) = del_node(r_tree, offset_rs, offset_r)\n        else:\n            r_tree = calc_intersection(s_tree, offset_cs, r_tree, offset_rs)\n\n    offset_rs = find_r_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        pass\n    else: \n        offset_cs = find_r_child(s_tree, offset_s)\n        if offset_cs is None:    \n                (r_tree, offset_r) = del_node(r_tree, offset_rs, offset_r)\n        else:\n            r_tree = calc_intersection(s_tree, offset_cs, r_tree, offset_rs)\n            \n    return r_tree\n        \n\n\n#Get  input \ninput_line = raw_input()\n\nwhile input_line:\n    #Get command, f_tree, s_tree\n    command = input_line[0:2]\n    input_line = input_line[2:]\n    \n    space = input_line.find(\" \")\n    f_tree = input_line[0:space]\n    s_tree = input_line[space+1:]\n    \n    r_tree = f_tree\n    \n    \n    if command[0] == \"u\":\n        r_tree = calc_union(s_tree, find_r_child(s_tree, -1), r_tree, find_r_child(r_tree, -1))\n        \n    else:\n        r_tree = calc_intersection(s_tree, find_r_child(s_tree, -1), r_tree, find_r_child(r_tree, -1))\n    \n    \n    #Output answer string\n    print r_tree\n    \n    #update input_line\n    input_line = raw_input()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n'''\nCreated on 2017/10/25\n\n@author: naja yama\n'''\n   \ndef find_r_child(tree, offset):\n    \n    offset += 1\n    count = 0\n    end = len(tree)\n    while(offset < end):\n        if tree[offset] == \"(\":\n            count += 1\n        elif tree[offset] == \")\":\n            count -= 1\n        elif count == 1 and tree[offset] == \",\":\n            return offset\n        \n        offset += 1 \n        \n    return None\n\n\n\ndef find_l_child(tree, offset):\n    \n    offset -= 1\n    count = 0\n    while(offset >= 1):\n        if tree[offset] == \"(\":\n            count -= 1\n        elif tree[offset] == \")\":\n            count += 1\n        elif count == 1 and tree[offset] == \",\":\n            return offset\n        \n        offset -= 1\n        \n    return None\n\n\ndef del_node(tree, offset):\n    count = 0\n    i = offset - 1\n    \n    while(1):\n        if tree[i] == \")\":\n            count += 1\n        elif tree[i] == \"(\":\n            if count == 0:\n                offset2 = i\n                break\n            count -= 1\n        \n        i -= 1\n    \n    count = 0\n    i = offset + 1        \n    \n    while(1):\n        if tree[i] == \"(\":\n\n            count += 1\n        elif tree[i] == \")\":\n            if count == 0:\n                offset3 = i\n                break            \n            count -= 1\n            \n        i += 1\n            \n    \n    tree = tree[:offset2] + tree[offset3 + 1:]\n    \n    return tree\n\n\ndef calc_union(s_tree, offset_s, r_tree, offset_r):\n    offset_cs = find_l_child(s_tree, offset_s)\n    \n    if offset_cs is None:\n        pass\n    else:\n        \n        offset_rs = find_l_child(r_tree, offset_r)\n        \n        if offset_rs is None:\n            r_tree = r_tree[:offset_r] + \"(,)\" + r_tree[offset_r:]\n            offset_rs = offset_r + 2\n            \n        r_tree = calc_union(s_tree, offset_cs, r_tree, offset_rs)\n    \n    \n    offset_cs = find_r_child(s_tree, offset_s)\n    \n    if offset_cs is None:\n        return r_tree\n    \n    offset_rs = find_r_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        r_tree = r_tree[:offset_r+1] + \"(,)\" + r_tree[offset_r+1:]\n        offset_rs = offset_r + 2\n        \n    r_tree = calc_union(s_tree, offset_cs, r_tree, offset_rs)\n    \n    return r_tree\n\n\n        \ndef calc_intersection(s_tree, offset_s, r_tree, offset_r):\n    \n    offset_rs = find_l_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        pass\n    else: \n        offset_cs = find_l_child(s_tree, offset_s)\n        if offset_cs is None:    \n            r_tree = del_node(r_tree, offset_rs)\n        else:\n            r_tree = calc_intersection(s_tree, offset_cs, r_tree, offset_rs)\n\n    offset_rs = find_r_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        pass\n    else: \n        offset_cs = find_r_child(s_tree, offset_s)\n        if offset_cs is None:    \n                r_tree = del_node(r_tree, offset_rs)\n        else:\n            r_tree = calc_intersection(s_tree, offset_cs, r_tree, offset_rs)\n            \n    return r_tree\n        \n\n\n#Get  input \ninput_line = raw_input()\n\nwhile input_line:\n    \n    #Get command, f_tree, s_tree\n    command = input_line[0:2]\n    input_line = input_line[2:]\n    \n    space = input_line.find(\" \")\n    f_tree = input_line[0:space]\n    s_tree = input_line[space+1:]\n    \n    r_tree = f_tree\n    \n    \n    if command[0] == \"u\":\n        r_tree = calc_union(s_tree, find_r_child(s_tree, -1), r_tree, find_r_child(r_tree, -1))\n        \n    else:\n        r_tree = calc_intersection(s_tree, find_r_child(s_tree, -1), r_tree, find_r_child(r_tree, -1))\n    \n    \n    #Output answer string\n    print r_tree\n        \n    #update input_line\n    input_line = raw_input()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n'''\nCreated on 2017/10/25\n\n@author: naja yama\n'''\n   \ndef find_r_child(tree, offset):\n    \n    offset += 1\n    count = 0\n    end = len(tree)\n    while(offset < end):\n        if tree[offset] == \"(\":\n            count += 1\n        elif tree[offset] == \")\":\n            count -= 1\n        elif count == 1 and tree[offset] == \",\":\n            return offset\n        \n        offset += 1 \n        \n    return None\n\n\n\ndef find_l_child(tree, offset):\n    \n    offset -= 1\n    count = 0\n    while(offset >= 1):\n        if tree[offset] == \"(\":\n            count -= 1\n        elif tree[offset] == \")\":\n            count += 1\n        elif count == 1 and tree[offset] == \",\":\n            return offset\n        \n        offset -= 1\n        \n    return None\n\n\ndef del_node(tree, offset, offset_r):\n    count = 0\n    i = offset - 1\n    \n    while(1):\n        if tree[i] == \")\":\n            count += 1\n        elif tree[i] == \"(\":\n            if count == 0:\n                offset2 = i\n                break\n            count -= 1\n        \n        i -= 1, \n    \n    count = 0\n    i = offset + 1        \n    \n    while(1):\n        if tree[i] == \"(\":\n\n            count += 12\n        elif tree[i] == \")\":\n            if count == 0:\n                offset3 = i\n                break            \n            count -= 1\n            \n        i += 1        \n    \n    tree = tree[:offset2] + tree[offset3 + 1:]\n    \n    if offset_r < offset2:\n        return (tree, offset_r)\n    else:\n        return (tree, offset_r - (offset3 + 1 - offset2))\n\ndef calc_union(s_tree, offset_s, r_tree, offset_r):\n    \n    #for right child\n    offset_cs = find_r_child(s_tree, offset_s)\n    \n    if offset_cs is None:\n        pass\n    else:\n        offset_rs = find_r_child(r_tree, offset_r)\n    \n        if offset_rs is None:\n            r_tree = r_tree[:offset_r+1] + \"(,)\" + r_tree[offset_r+1:]\n            offset_rs = offset_r + 2\n\n        r_tree = calc_union(s_tree, offset_cs, r_tree, offset_rs)\n        \n    offset_cs = find_l_child(s_tree, offset_s)\n    \n    if offset_cs is None:\n        return r_tree\n    else:\n        \n        offset_rs = find_l_child(r_tree, offset_r)\n        \n        if offset_rs is None:\n            r_tree = r_tree[:offset_r] + \"(,)\" + r_tree[offset_r:]\n            offset_rs = offset_r - 2\n            \n        r_tree = calc_union(s_tree, offset_cs, r_tree, offset_rs)\n        return r_tree\n        \ndef calc_intersection(s_tree, offset_s, r_tree, offset_r):\n    \n    offset_rs = find_r_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        pass\n    else: \n        offset_cs = find_r_child(s_tree, offset_s)\n        if offset_cs is None:    \n                (r_tree, offset_r) = del_node(r_tree, offset_rs, offset_r)\n        else:\n            r_tree = calc_intersection(s_tree, offset_cs, r_tree, offset_rs)\n            \n    offset_rs = find_l_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        return r_tree\n    else: \n        offset_cs = find_l_child(s_tree, offset_s)\n        if offset_cs is None:    \n            (r_tree, offset_r) = del_node(r_tree, offset_rs, offset_r)\n        else:\n            r_tree = calc_intersection(s_tree, offset_cs, r_tree, offset_rs)\n        \n    return r_tree\n\n#start main\n#Get  input \ninput_line = raw_input()\n\nwhile input_line:\n    #Get command, f_tree, s_tree\n    command = input_line[0:2]\n    input_line = input_line[2:]\n    \n    space = input_line.find(\" \")\n    f_tree = input_line[0:space]\n    s_tree = input_line[space+1:]\n    \n    r_tree = f_tree\n    \n    \n    if command[0] == \"u\":\n        r_tree = calc_union(s_tree, find_r_child(s_tree, -1), r_tree, find_r_child(r_tree, -1))\n        \n    else:\n        r_tree = calc_intersection(s_tree, find_r_child(s_tree, -1), r_tree, find_r_child(r_tree, -1))\n    \n    \n    #Output answer string\n    print r_tree\n    \n    #update input_line\n    input_line = raw_input()"
  },
  {
    "language": "Python",
    "code": "def treeunprocess(tstr,lv):\n    d=0\n    if len(tstr)==0:\n         return []\n    for i in range(len(tstr)):\n        if tstr[i]==\"(\":\n            d+=1\n        elif tstr[i]==\")\":\n            d-=1\n        elif tstr[i]==\",\" and d==1:\n            return [lv]+treeunprocess(tstr[1:i], 2*lv+1) + treeunprocess(tstr[i+1:-1], 2*lv+2)\n\ndef treeprocess(tlst, lv):\n    #if 2*lv+1 not in tlst and 2*lv+2 not in tlst:\n    if lv not in tlst:\n        return \"\"\n    return \"(\"+treeprocess(tlst,2*lv+1)+\",\"+treeprocess(tlst,2*lv+2)+\")\"\n\nwhile(1):\n    try:\n        IN=raw_input().split()\n    except:\n        break\n    cmd=IN[0]\n    T=IN[1:]\n    D=[[],[]]\n    for i in range(2):\n        t=T[i]\n        D[i]=treeunprocess(t,0)\n    if cmd==\"i\":\n        E=sorted([d for d in D[1] if d in D[0] ])\n    else:\n        E=sorted(D[0] + [d for d in D[1] if d not in D[0]  ] )\n    print treeprocess(E,0)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n'''\nCreated on 2017/10/25\n\n@author: naja yama\n'''\n   \ndef find_r_child(tree, offset):\n    \n    offset += 1\n    count = 0\n    end = len(tree)\n    while(offset < end):\n        if tree[offset] == \"(\":\n            count += 1\n        elif tree[offset] == \")\":\n            count -= 1\n        elif count == 1 and tree[offset] == \",\":\n            return offset\n        \n        offset += 1 \n        \n    return None\n\n\n\ndef find_l_child(tree, offset):\n    \n    offset -= 1\n    count = 0\n    while(offset >= 1):\n        if tree[offset] == \"(\":\n            count -= 1\n        elif tree[offset] == \")\":\n            count += 1\n        elif count == 1 and tree[offset] == \",\":\n            return offset\n        \n        offset -= 1\n        \n    return None\n\n\ndef del_node(tree, offset):\n    count = 0\n    i = offset - 1\n    \n    while(1):\n        if tree[i] == \")\":\n            count += 1\n        elif tree[i] == \"(\":\n            if count == 0:\n                offset2 = i\n                break\n            count -= 1\n        \n        i -= 1\n    \n    count = 0\n    i = offset + 1        \n    \n    while(1):\n        if tree[i] == \"(\":\n\n            count += 1\n        elif tree[i] == \")\":\n            if count == 0:\n                offset3 = i\n                break            \n            count -= 1\n            \n        i += 1        \n    \n    tree = tree[:offset2] + tree[offset3 + 1:]\n    \n    return tree\n\n\ndef calc_union(s_tree, offset_s, r_tree, offset_r):\n    if s_tree is None or r_tree is None:\n        print \"None!\"\n        \n    offset_cs = find_l_child(s_tree, offset_s)\n    \n    if offset_cs is None:\n        pass\n    else:\n        \n        offset_rs = find_l_child(r_tree, offset_r)\n        \n        if offset_rs is None:\n            r_tree = r_tree[:offset_r] + \"(,)\" + r_tree[offset_r:]\n            offset_rs = offset_r + 2\n            \n        r_tree = calc_union(s_tree, offset_cs, r_tree, offset_rs)\n    \n    \n    offset_cs = find_r_child(s_tree, offset_s)\n    \n    if offset_cs is None:\n        return r_tree\n    \n    offset_rs = find_r_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        r_tree = r_tree[:offset_r+1] + \"(,)\" + r_tree[offset_r+1:]\n        offset_rs = offset_r + 2\n        \n    r_tree = calc_union(s_tree, offset_cs, r_tree, offset_rs)\n    \n    return r_tree\n\n\n        \ndef calc_intersection(s_tree, offset_s, r_tree, offset_r):\n    if s_tree is None or r_tree is None:\n        print \"None!\"\n    \n    offset_rs = find_l_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        pass\n    else: \n        offset_cs = find_l_child(s_tree, offset_s)\n        if offset_cs is None:    \n            r_tree = del_node(r_tree, offset_rs)\n        else:\n            r_tree = calc_intersection(s_tree, offset_cs, r_tree, offset_rs)\n\n    offset_rs = find_r_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        pass\n    else: \n        offset_cs = find_r_child(s_tree, offset_s)\n        if offset_cs is None:    \n                r_tree = del_node(r_tree, offset_rs)\n        else:\n            r_tree = calc_intersection(s_tree, offset_cs, r_tree, offset_rs)\n            \n    return r_tree\n        \n\n\n#Get  input \ninput_line = raw_input()\n\nwhile input_line:\n    try:\n        #Get command, f_tree, s_tree\n        command = input_line[0:2]\n        input_line = input_line[2:]\n        \n        space = input_line.find(\" \")\n        f_tree = input_line[0:space]\n        s_tree = input_line[space+1:]\n        \n        r_tree = f_tree\n        \n        \n        if command[0] == \"u\":\n            r_tree = calc_union(s_tree, find_r_child(s_tree, -1), r_tree, find_r_child(r_tree, -1))\n            \n        else:\n            r_tree = calc_intersection(s_tree, find_r_child(s_tree, -1), r_tree, find_r_child(r_tree, -1))\n        \n        \n        #Output answer string\n        print r_tree\n            \n        #update input_line\n        input_line = raw_input()\n    except:\n        print(\"oh my got!\", sys.exc_info()[0])\n        \n\n        "
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n'''\nCreated on 2017/10/25\n\n@author: naja yama\n'''\n   \ndef find_r_child(tree, offset):\n    \n    offset += 1\n    count = 0\n    end = len(tree)\n    while(offset < end):\n        if tree[offset] == \"(\":\n            count += 1\n        elif tree[offset] == \")\":\n            count -= 1\n        elif count == 1 and tree[offset] == \",\":\n            return offset\n        \n        offset += 1 \n        \n    return None\n\n\n\ndef find_l_child(tree, offset):\n    \n    offset -= 1\n    count = 0\n    while(offset >= 1):\n        if tree[offset] == \"(\":\n            count -= 1\n        elif tree[offset] == \")\":\n            count += 1\n        elif count == 1 and tree[offset] == \",\":\n            return offset\n        \n        offset -= 1\n        \n    return None\n\n\ndef del_node(tree, offset, offset_r):\n    count = 0\n    i = offset - 1\n    \n    while(1):\n        if tree[i] == \")\":\n            count += 1\n        elif tree[i] == \"(\":\n            if count == 0:\n                offset2 = i\n                break\n            count -= 1\n        \n        i -= 1, \n    \n    count = 0\n    i = offset + 1        \n    \n    while(1):\n        if tree[i] == \"(\":\n\n            count += 12\n        elif tree[i] == \")\":\n            if count == 0:\n                offset3 = i\n                break            \n            count -= 1\n            \n        i += 1        \n    \n    tree = tree[:offset2] + tree[offset3 + 1:]\n    \n    if offset_r < offset2:\n        return (tree, offset_r)\n    else:\n        return (tree, offset_r - (offset3 + 1 - offset2))\n\ndef calc_union(s_tree, offset_s, r_tree, offset_r):\n        \n    offset_cs = find_l_child(s_tree, offset_s)\n    \n    if offset_cs is None:\n        pass\n    else:\n        \n        offset_rs = find_l_child(r_tree, offset_r)\n        \n        if offset_rs is None:\n            r_tree = r_tree[:offset_r] + \"(,)\" + r_tree[offset_r:]\n            offset_rs = offset_r - 2\n            \n        r_tree = calc_union(s_tree, offset_cs, r_tree, offset_rs)\n    \n    \n    offset_cs = find_r_child(s_tree, offset_s)\n    \n    if offset_cs is None:\n        return r_tree\n    \n    offset_rs = find_r_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        r_tree = r_tree[:offset_r+1] + \"(,)\" + r_tree[offset_r+1:]\n        offset_rs = offset_r + 2\n        \n    r_tree = calc_union(s_tree, offset_cs, r_tree, offset_rs)\n    \n    return r_tree\n\n\n        \ndef calc_intersection(s_tree, offset_s, r_tree, offset_r):\n    \n    offset_rs = find_l_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        pass\n    else: \n        offset_cs = find_l_child(s_tree, offset_s)\n        if offset_cs is None:    \n            (r_tree, offset_r) = del_node(r_tree, offset_rs, offset_r)\n        else:\n            r_tree = calc_intersection(s_tree, offset_cs, r_tree, offset_rs)\n\n    offset_rs = find_r_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        pass\n    else: \n        offset_cs = find_r_child(s_tree, offset_s)\n        if offset_cs is None:    \n                (r_tree, offset_r) = del_node(r_tree, offset_rs, offset_r)\n        else:\n            r_tree = calc_intersection(s_tree, offset_cs, r_tree, offset_rs)\n            \n    return r_tree\n        \n\n\n#Get  input \ninput_line = raw_input()\n\nwhile input_line:\n    #Get command, f_tree, s_tree\n    command = input_line[0:2]\n    input_line = input_line[2:]\n    \n    space = input_line.find(\" \")\n    f_tree = input_line[0:space]\n    s_tree = input_line[space+1:]\n    \n    r_tree = f_tree\n    \n    \n    if command[0] == \"u\":\n        r_tree = calc_union(s_tree, find_r_child(s_tree, -1), r_tree, find_r_child(r_tree, -1))\n        \n    else:\n        r_tree = calc_intersection(s_tree, find_r_child(s_tree, -1), r_tree, find_r_child(r_tree, -1))\n    \n    \n    #Output answer string\n    print r_tree\n    \n    #update input_line\n    input_line = raw_input()"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\ndef searchcenter (str):\n    temp_layer = 0\n    for x in range(len(str)):\n        c = str[x]\n        if c == '(':\n            temp_layer += 1\n        elif c == ')':\n            temp_layer -= 1\n        elif temp_layer == 1:\n            return x\n\n#whether either tree have common factor\ndef either_tree_have (t1len, t2len, center1_u, center2_u):\n    if center1_u == 1 and center2_u == 1:\n        return \"right\"\n    elif center1_u == t1len -2 and center2_u == t2len -2:\n        return \"left\"\n    elif 4 <= center1_u and 4 <= center2_u and center1_u <= t1len - 5 and center2_u <= t2len - 5:\n        return \"both\"\n    elif center1_u == 1 and center2_u == t2len - 2:\n        return \"t1_rightandt2_left\"\n    elif center1_u == t1len - 2 and center2_u == 1:\n        return \"t1_leftandt2_right\"\n    elif center1_u == 1 and 4 <= center2_u and center2_u <= t2len - 5:\n        return \"t1_rightandt2_both\"\n    elif center1_u == t1len - 2 and 4 <= center2_u and center2_u <= t2len - 5:\n        return \"t1_leftandt2_both\"\n    elif 4 <= center1_u and center1_u <= t1len - 5 and center2_u == 1:\n        return \"t1_bothandt2_right\"\n    elif 4 <= center1_u and center1_u <= t1len - 5 and center2_u == t2len - 2:\n        return \"t1_bothandt2_left\"\n    else:\n        return \"no\"\n\ndef operate_u (tree1, tree2):\n    length_tree1 = len(tree1)\n    length_tree2 = len(tree2)\n\n    if length_tree1 == 3 or length_tree2 == 3:\n        if length_tree1 != 3:\n            tree2 = tree1\n            length_tree2 = length_tree1\n        elif length_tree2 != 3:\n            tree1 = tree2\n            length_tree1 = length_tree2\n        else:\n            return \"(,)\"\n\n\n    center1_uo = searchcenter(tree1)\n    center2_uo = searchcenter(tree2)\n\n    e_result = either_tree_have(length_tree1, length_tree2, center1_uo, center2_uo)\n\n    if e_result == \"both\":\n        return \"(\" + operate_u(tree1[1:center1_uo], tree2[1:center2_uo]) + \",\" + operate_u(tree1[center1_uo + 1:-1], tree2[center2_uo + 1:-1]) + \")\"\n    elif e_result == \"left\":\n        return \"(\" + operate_u(tree1[1:-2], tree2[1:-2]) + \",)\"\n    elif e_result == \"right\":\n        return \"(,\" + operate_u(tree1[2:-1], tree2[2:-1]) + \")\"\n    elif e_result == \"t1_leftandt2_right\":\n        return \"(\" + operate_u(tree1[1:center1_uo], tree1[1:center1_uo]) + \",\" + operate_u(tree2[center2_uo + 1:-1], tree2[center2_uo + 1:-1]) + \")\"\n    elif e_result == \"t1_rightandt2_left\":\n        return \"(\" + operate_u(tree2[1:center2_uo], tree2[1:center2_uo]) + \",\" + operate_u(tree1[center1_uo + 1:-1], tree1[center1_uo + 1:-1]) + \")\"\n    elif e_result == \"t1_leftandt2_both\":\n        return \"(\" + operate_u(tree1[1:-2], tree2[1:center2_uo]) + \",\" + operate_u(tree2[center2_uo + 1:-1], tree2[center2_uo + 1:-1]) + \")\"\n    elif e_result == \"t1_rightandt2_both\":\n        return \"(\" + operate_u(tree2[1:center2_uo], tree2[1:center2_uo]) + \",\" + operate_u(tree1[2:-1], tree2[center2_uo + 1:-1]) + \")\"\n    elif e_result == \"t1_bothandt2_left\":\n        return \"(\" + operate_u(tree1[1:center1_uo], tree2[1:-2]) + \",\" + operate_u(tree1[center1_uo + 1:-1], tree1[center1_uo + 1:-1]) + \")\"\n    elif e_result == \"t1_bothandt2_right\":\n        return \"(\" + operate_u(tree1[1:center1_uo], tree1[1:center1_uo]) + \",\" + operate_u(tree1[center1_uo + 1:-1], tree2[2:-1]) + \")\"\n    else:\n        return \"(,)\"\n\n#whether both tree have common factor\ndef both_tree_have (t1len, t2len, center1_i, center2_i):\n    if 4 <= center1_i and 4 <= center2_i and center1_i <= t1len - 5 and center2_i <= t2len - 5:\n        return \"both\"\n    elif (center1_i == 1 and center2_i == t2len - 2) or (center1_i == t1len - 2 and center2_i == 1):\n        return \"no\"\n    elif center1_i == t1len - 2 or center2_i == t2len - 2:\n        return \"left\"\n    elif center1_i == 1 or center2_i == 1:\n        return \"right\"\n    else:\n        return \"no\"\n\n\ndef operate_i (tree1, tree2):\n    length_tree1 = len(tree1)\n    length_tree2 = len(tree2)\n\n    if length_tree1 == 3 or length_tree2 == 3:\n        return \"(,)\"\n\n    center1_io = searchcenter(tree1)\n    center2_io = searchcenter(tree2)\n\n    b_result = both_tree_have(length_tree1, length_tree2, center1_io, center2_io)\n\n    if b_result == \"both\":\n        return \"(\" + operate_i(tree1[1:center1_io], tree2[1:center2_io]) + \",\" + operate_i(tree1[center1_io + 1:-1], tree2[center2_io + 1:-1]) + \")\"\n    elif b_result == \"left\":\n        return \"(\" + operate_i(tree1[1:center1_io], tree2[1:center2_io]) + \",)\"\n    elif b_result == \"right\":\n        return \"(,\" + operate_i(tree1[center1_io + 1:-1], tree2[center2_io + 1:-1]) + \")\"\n    else:\n        return \"(,)\"\n\nclass Process:\n    \"\"\"superclass for polymofism\"\"\"\n    def process(self):\n        pass\n\nclass Intersection(Process):\n    \"\"\"i\"\"\"\n    def __init__(self, tree1, tree2):\n        self.tree1 = tree1\n        self.tree2 = tree2\n    def process(self):\n        return operate_i(self.tree1, self.tree2)\n\nclass Unit(Process):\n    \"\"\"u\"\"\"\n    def __init__(self, tree1, tree2):\n        self.tree1 = tree1\n        self.tree2 = tree2\n    def process(self):\n        return operate_u(self.tree1, self.tree2)\n\nclass BuilderProcess:\n    \"\"\"builder class\"\"\"\n    def __init__(self, line):\n        factor = line.split(\" \")\n        self.tree1 = factor[1]\n        self.tree2 = factor[2][:-1]\n        if factor[0] == 'i':\n            self.task = Intersection(self.tree1, self.tree2)\n        else:\n            self.task = Unit(self.tree1, self.tree2)\n\n\n\nif __name__ == '__main__':\n    inputs = []\n    for line in sys.stdin:\n        inputs.append(line)\n\n    for line in inputs:\n        b = BuilderProcess(line)\n        print(b.task.process())"
  },
  {
    "language": "Python",
    "code": "print \"fasd\""
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport sys\n\ndef tree_left(node, it):\n    c = next(it)\n\n    if c == \"(\":\n        node[0] = [None, None]\n        tree_left(node[0], it)\n        c = next(it)\n\n    if c == \",\":\n        tree_right(node, it)\n    else:\n        assert False\n\ndef tree_right(node, it):\n    c = next(it)\n\n    if c == \"(\":\n        node[1] = [None, None]\n        tree_left(node[1], it)\n        c = next(it)\n\n    if c == \")\":\n        pass\n    else:\n        assert False\n\ndef tree_parse(s):\n    root = [None, None]\n\n    s = s[1:]\n    it = iter(s)\n    tree_left(root, it)\n\n    return root\n\ndef tree_dump(node):\n    s = \"\"\n\n    s += \"(\"\n    if node[0]:\n        s += tree_dump(node[0])\n    s += \",\"\n    if node[1]:\n        s += tree_dump(node[1])\n    s += \")\"\n\n    return s\n\ndef intersection(t1, t2):\n    if t1 is None or t2 is None:\n        return None\n\n    node = [None, None]\n    node[0] = intersection(t1[0], t2[0])\n    node[1] = intersection(t1[1], t2[1])\n    return node\n\ndef union(t1, t2):\n    if t1 is None and t2 is None:\n        return None\n    elif t1 is None:\n        return t2\n    elif t2 is None:\n        return t1\n\n    node = [None, None]\n    node[0] = union(t1[0], t2[0])\n    node[1] = union(t1[1], t2[1])\n    return node\n\ndef main():\n    for line in sys.stdin:\n        op, s1, s2 = line.split()\n        tree1 = tree_parse(s1)\n        tree2 = tree_parse(s2)\n        #print(tree_dump(tree1))\n        #print(tree_dump(tree2))\n        if op == \"i\":\n            ans = intersection(tree1, tree2)\n            print(tree_dump(ans))\n        elif op == \"u\":\n            ans = union(tree1, tree2)\n            print(tree_dump(ans))\n\nif __name__ == \"__main__\": main()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n'''\nCreated on 2017/10/25\n\n@author: naja yama\n'''\n   \ndef find_r_child(tree, offset):\n    \n    offset += 1\n    count = 0\n    end = len(tree)\n    while(offset < end):\n        if tree[offset] == \"(\":\n            count += 1\n        elif tree[offset] == \")\":\n            count -= 1\n        elif count == 1 and tree[offset] == \",\":\n            return offset\n        \n        offset += 1 \n        \n    return None\n\n\n\ndef find_l_child(tree, offset):\n    \n    offset -= 1\n    count = 0\n    while(offset >= 1):\n        if tree[offset] == \"(\":\n            count -= 1\n        elif tree[offset] == \")\":\n            count += 1\n        elif count == 1 and tree[offset] == \",\":\n            return offset\n        \n        offset -= 1\n        \n    return None\n\n\ndef del_node(tree, offset):\n    count = 0\n    i = offset - 1\n    \n    while(1):\n        if tree[i] == \")\":\n            count += 1\n        elif tree[i] == \"(\":\n            if count == 0:\n                offset2 = i\n                break\n            count -= 1\n        \n        i -= 1\n    \n    count = 0\n    i = offset + 1        \n    \n    while(1):\n        if tree[i] == \"(\":\n\n            count += 1\n        elif tree[i] == \")\":\n            if count == 0:\n                offset3 = i\n                break            \n            count -= 1\n            \n        i += 1        \n    \n    tree = tree[:offset2] + tree[offset3 + 1:]\n    \n    return tree\n\n\ndef calc_union(s_tree, offset_s, r_tree, offset_r):\n    if s_tree is None or r_tree is None:\n        print \"None!\"\n    offset_cs = find_l_child(s_tree, offset_s)\n    \n    if offset_cs is None:\n        pass\n    else:\n        \n        offset_rs = find_l_child(r_tree, offset_r)\n        \n        if offset_rs is None:\n            r_tree = r_tree[:offset_r] + \"(,)\" + r_tree[offset_r:]\n            offset_rs = offset_r + 2\n            \n        r_tree = calc_union(s_tree, offset_cs, r_tree, offset_rs)\n    \n    \n    offset_cs = find_r_child(s_tree, offset_s)\n    \n    if offset_cs is None:\n        return r_tree\n    \n    offset_rs = find_r_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        r_tree = r_tree[:offset_r+1] + \"(,)\" + r_tree[offset_r+1:]\n        offset_rs = offset_r + 2\n        \n    r_tree = calc_union(s_tree, offset_cs, r_tree, offset_rs)\n    \n    return r_tree\n\n\n        \ndef calc_intersection(s_tree, offset_s, r_tree, offset_r):\n    if s_tree is None or r_tree is None:\n        print \"None!\"\n    \n    offset_rs = find_l_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        pass\n    else: \n        offset_cs = find_l_child(s_tree, offset_s)\n        if offset_cs is None:    \n            r_tree = del_node(r_tree, offset_rs)\n        else:\n            r_tree = calc_intersection(s_tree, offset_cs, r_tree, offset_rs)\n\n    offset_rs = find_r_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        pass\n    else: \n        offset_cs = find_r_child(s_tree, offset_s)\n        if offset_cs is None:    \n                r_tree = del_node(r_tree, offset_rs)\n        else:\n            r_tree = calc_intersection(s_tree, offset_cs, r_tree, offset_rs)\n            \n    return r_tree\n        \n\n\n#Get  input \ninput_line = raw_input()\n\nwhile input_line:\n    \n    #Get command, f_tree, s_tree\n    command = input_line[0:2]\n    input_line = input_line[2:]\n    \n    space = input_line.find(\" \")\n    f_tree = input_line[0:space]\n    s_tree = input_line[space+1:]\n    \n    r_tree = f_tree\n    \n    \n    if command[0] == \"u\":\n        r_tree = calc_union(s_tree, find_r_child(s_tree, -1), r_tree, find_r_child(r_tree, -1))\n        \n    else:\n        r_tree = calc_intersection(s_tree, find_r_child(s_tree, -1), r_tree, find_r_child(r_tree, -1))\n    \n    \n    #Output answer string\n    print r_tree\n        \n    #update input_line\n    input_line = raw_input()"
  },
  {
    "language": "Python",
    "code": "a = \"test\"\nprint \"\"\nprint a[8:]\nprint \"\""
  },
  {
    "language": "Python",
    "code": "def find_r_child(tree, offset):\n    \n    offset += 1\n    count = 0\n    end = len(tree)\n    while(offset < end):\n        if tree[offset] == \"(\":\n            count += 1\n        elif tree[offset] == \")\":\n            count -= 1\n        elif count == 1 and tree[offset] == \",\":\n            return offset\n        \n        offset += 1 \n        \n    return None\n\n\n\ndef find_l_child(tree, offset):\n    \n    offset -= 1\n    count = 0\n    while(offset >= 1):\n        if tree[offset] == \"(\":\n            count -= 1\n        elif tree[offset] == \")\":\n            count += 1\n        elif count == 1 and tree[offset] == \",\":\n            return offset\n        \n        offset -= 1\n        \n    return None\n\n\ndef del_node(tree, offset):\n    count = 0\n    i = offset - 1\n    \n    while(1):\n        if tree[i] == \")\":\n            count += 1\n        elif tree[i] == \"(\":\n            if count == 0:\n                offset2 = i\n                break\n            count -= 1\n        \n        i -= 1\n    \n    count = 0\n    i = offset + 1        \n    \n    while(1):\n        if tree[i] == \"(\":\n\n            count += 1\n        elif tree[i] == \")\":\n            if count == 0:\n                offset3 = i\n                break            \n            count -= 1\n            \n        i += 1\n            \n    \n    tree = tree[:offset2] + tree[offset3 + 1:]\n    \n    return tree\n\n\ndef calc_union(s_tree, offset_s, r_tree, offset_r):\n    offset_cs = find_l_child(s_tree, offset_s)\n    \n    if offset_cs is None:\n        pass\n    else:\n        \n        offset_rs = find_l_child(r_tree, offset_r)\n        \n        if offset_rs is None:\n            r_tree = r_tree[:offset_r] + \"(,)\" + r_tree[offset_r:]\n            offset_rs = offset_r + 2\n            \n        r_tree = calc_union(s_tree, offset_cs, r_tree, offset_rs)\n    \n    \n    offset_cs = find_r_child(s_tree, offset_s)\n    \n    if offset_cs is None:\n        return r_tree\n    \n    offset_rs = find_r_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        r_tree = r_tree[:offset_r+1] + \"(,)\" + r_tree[offset_r+1:]\n        offset_rs = offset_r + 2\n        \n    r_tree = calc_union(s_tree, offset_cs, r_tree, offset_rs)\n    \n    return r_tree\n\n\n        \ndef calc_intersection(s_tree, offset_s, r_tree, offset_r):\n    \n    offset_rs = find_l_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        pass\n    else: \n        offset_cs = find_l_child(s_tree, offset_s)\n        if offset_cs is None:    \n            r_tree = del_node(r_tree, offset_rs)\n        else:\n            r_tree = calc_intersection(s_tree, offset_cs, r_tree, offset_rs)\n\n    offset_rs = find_r_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        pass\n    else: \n        offset_cs = find_r_child(s_tree, offset_s)\n        if offset_cs is None:    \n                r_tree = del_node(r_tree, offset_rs)\n        else:\n            r_tree = calc_intersection(s_tree, offset_cs, r_tree, offset_rs)\n            \n    return r_tree\n        \n\n\n#Get  input \ninput_line = raw_input()\n\nwhile input_line:\n    \n    #Get command, f_tree, s_tree\n    command = input_line[0:2]\n    input_line = input_line[2:]\n    \n    space = input_line.find(\" \")\n    f_tree = input_line[0:space]\n    s_tree = input_line[space+1:]\n    \n    r_tree = f_tree\n    \n    \n    if command[0] == \"u\":\n        r_tree = calc_union(s_tree, find_r_child(s_tree, -1), r_tree, find_r_child(r_tree, -1))\n        \n    else:\n        r_tree = calc_intersection(s_tree, find_r_child(s_tree, -1), r_tree, find_r_child(r_tree, -1))\n    \n    \n    #Output answer string\n    print r_tree\n        \n    #update input_line\n    input_line = raw_input()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n'''\nCreated on 2017/10/25\n\n@author: naja yama\n'''\n   \ndef find_r_child(tree, offset):\n    \n    offset += 1\n    count = 0\n    end = len(tree)\n    while(offset < end):\n        if tree[offset] == \"(\":\n            count += 1\n        elif tree[offset] == \")\":\n            count -= 1\n        elif count == 1 and tree[offset] == \",\":\n            return offset\n        \n        offset += 1 \n        \n    return None\n\n\n\ndef find_l_child(tree, offset):\n    \n    offset -= 1\n    count = 0\n    while(offset >= 1):\n        if tree[offset] == \"(\":\n            count -= 1\n        elif tree[offset] == \")\":\n            count += 1\n        elif count == 1 and tree[offset] == \",\":\n            return offset\n        \n        offset -= 1\n        \n    return None\n\n\ndef del_node(tree, offset, offset_r):\n    count = 0\n    i = offset - 1\n    \n    while(1):\n        if tree[i] == \")\":\n            count += 1\n        elif tree[i] == \"(\":\n            if count == 0:\n                offset2 = i\n                break\n            count -= 1\n        \n        i -= 1, \n    \n    count = 0\n    i = offset + 1        \n    \n    while(1):\n        if tree[i] == \"(\":\n\n            count += 12\n        elif tree[i] == \")\":\n            if count == 0:\n                offset3 = i\n                break            \n            count -= 1\n            \n        i += 1        \n    \n    tree = tree[:offset2] + tree[offset3 + 1:]\n    \n    if offset_r < offset2:\n        return (tree, offset_r)\n    else:\n        return (tree, offset_r - (offset3 + 1 - offset2))\n\ndef calc_union(s_tree, offset_s, r_tree, offset_r):\n        \n    #for right child    \n    offset_cs = find_r_child(s_tree, offset_s)\n    \n    if offset_cs is None:\n        pass\n    else:\n        offset_rs = find_r_child(r_tree, offset_r)\n    \n        if offset_rs is None:\n            r_tree = r_tree[:offset_r+1] + \"(,)\" + r_tree[offset_r+1:]\n            offset_rs = offset_r + 2\n                  \n        r_tree = calc_union(s_tree, offset_cs, r_tree, offset_rs)\n        \n    offset_cs = find_l_child(s_tree, offset_s)\n    \n    if offset_cs is None:\n        return r_tree\n    else:\n        \n        offset_rs = find_l_child(r_tree, offset_r)\n        \n        if offset_rs is None:\n            r_tree = r_tree[:offset_r] + \"(,)\" + r_tree[offset_r:]\n            offset_rs = offset_r - 2\n            \n        r_tree = calc_union(s_tree, offset_cs, r_tree, offset_rs)\n        return r_tree\n        \ndef calc_intersection(s_tree, offset_s, r_tree, offset_r):\n    \n    offset_rs = find_r_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        pass\n    else: \n        offset_cs = find_r_child(s_tree, offset_s)\n        if offset_cs is None:    \n                (r_tree, offset_r) = del_node(r_tree, offset_rs, offset_r)\n        else:\n            r_tree = calc_intersection(s_tree, offset_cs, r_tree, offset_rs)\n            \n    offset_rs = find_l_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        return r_tree\n    else: \n        offset_cs = find_l_child(s_tree, offset_s)\n        if offset_cs is None:    \n            (r_tree, offset_r) = del_node(r_tree, offset_rs, offset_r)\n        else:\n            r_tree = calc_intersection(s_tree, offset_cs, r_tree, offset_rs)\n        \n    return r_tree\n\n\n#Get  input \ninput_line = raw_input()\n\nwhile input_line:\n    #Get command, f_tree, s_tree\n    command = input_line[0:2]\n    input_line = input_line[2:]\n    \n    space = input_line.find(\" \")\n    f_tree = input_line[0:space]\n    s_tree = input_line[space+1:]\n    \n    r_tree = f_tree\n    \n    \n    if command[0] == \"u\":\n        r_tree = calc_union(s_tree, find_r_child(s_tree, -1), r_tree, find_r_child(r_tree, -1))\n        \n    else:\n        r_tree = calc_intersection(s_tree, find_r_child(s_tree, -1), r_tree, find_r_child(r_tree, -1))\n    \n    \n    #Output answer string\n    print r_tree\n    \n    #update input_line\n    input_line = raw_input()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n'''\nCreated on 2017/10/25\n\n@author: naja yama\n'''\n   \ndef find_r_child(tree, offset):\n    \n    offset += 1\n    count = 0\n    end = len(tree)\n    while(offset < end):\n        if tree[offset] == \"(\":\n            count += 1\n        elif tree[offset] == \")\":\n            count -= 1\n        elif count == 1 and tree[offset] == \",\":\n            return offset\n        \n        offset += 1 \n        \n    return None\n\n\n\ndef find_l_child(tree, offset):\n    \n    offset -= 1\n    count = 0\n    while(offset >= 1):\n        if tree[offset] == \"(\":\n            count -= 1\n        elif tree[offset] == \")\":\n            count += 1\n        elif count == 1 and tree[offset] == \",\":\n            return offset\n        \n        offset -= 1\n        \n    return None\n\n\ndef del_node(tree, offset, offset_r):\n    count = 0\n    i = offset - 1\n    \n    while(1):\n        if tree[i] == \")\":\n            count += 1\n        elif tree[i] == \"(\":\n            if count == 0:\n                offset2 = i\n                break\n            count -= 1\n        \n        i -= 1, \n    \n    count = 0\n    i = offset + 1        \n    \n    while(1):\n        if tree[i] == \"(\":\n\n            count += 12\n        elif tree[i] == \")\":\n            if count == 0:\n                offset3 = i\n                break            \n            count -= 1\n            \n        i += 1        \n    \n    tree = tree[:offset2] + tree[offset3 + 1:]\n    \n    if offset_r < offset2:\n        return (tree, offset)\n    else:\n        return (tree, offset3 + 1 - offset2)\n\ndef calc_union(s_tree, offset_s, r_tree, offset_r):\n        \n    offset_cs = find_l_child(s_tree, offset_s)\n    \n    if offset_cs is None:\n        pass\n    else:\n        \n        offset_rs = find_l_child(r_tree, offset_r)\n        \n        if offset_rs is None:\n            r_tree = r_tree[:offset_r] + \"(,)\" + r_tree[offset_r:]\n            offset_rs = offset_r + 2\n            \n        r_tree = calc_union(s_tree, offset_cs, r_tree, offset_rs)\n    \n    \n    offset_cs = find_r_child(s_tree, offset_s)\n    \n    if offset_cs is None:\n        return r_tree\n    \n    offset_rs = find_r_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        r_tree = r_tree[:offset_r+1] + \"(,)\" + r_tree[offset_r+1:]\n        offset_rs = offset_r + 2\n        \n    r_tree = calc_union(s_tree, offset_cs, r_tree, offset_rs)\n    \n    return r_tree\n\n\n        \ndef calc_intersection(s_tree, offset_s, r_tree, offset_r):\n    \n    offset_rs = find_l_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        pass\n    else: \n        offset_cs = find_l_child(s_tree, offset_s)\n        if offset_cs is None:    \n            (r_tree, offset_r) = del_node(r_tree, offset_rs, offset_r)\n        else:\n            r_tree = calc_intersection(s_tree, offset_cs, r_tree, offset_rs)\n\n    offset_rs = find_r_child(r_tree, offset_r)\n    \n    if offset_rs is None:\n        pass\n    else: \n        offset_cs = find_r_child(s_tree, offset_s)\n        if offset_cs is None:    \n                (r_tree, offset_r) = del_node(r_tree, offset_rs, offset_r)\n        else:\n            r_tree = calc_intersection(s_tree, offset_cs, r_tree, offset_rs)\n            \n    return r_tree\n        \n\n\n#Get  input \ninput_line = raw_input()\n\nwhile input_line:\n    #Get command, f_tree, s_tree\n    command = input_line[0:2]\n    input_line = input_line[2:]\n    \n    space = input_line.find(\" \")\n    f_tree = input_line[0:space]\n    s_tree = input_line[space+1:]\n    \n    r_tree = f_tree\n    \n    \n    if command[0] == \"u\":\n        r_tree = calc_union(s_tree, find_r_child(s_tree, -1), r_tree, find_r_child(r_tree, -1))\n        \n    else:\n        r_tree = calc_intersection(s_tree, find_r_child(s_tree, -1), r_tree, find_r_child(r_tree, -1))\n    \n    \n    #Output answer string\n    print r_tree\n    \n    #update input_line\n    input_line = raw_input()"
  },
  {
    "language": "Python",
    "code": "import re\n\nclass bintree():\n    def __init__(self, str1):\n        self.str1 = str1\n        if self.str1[1] != \",\":\n            c = 0\n            counter = 0\n            for s in str1[1:]:\n                counter += 1\n                if s == \"(\":\n                    c += 1\n                elif s == \")\":\n                    c -= 1\n                if c == 0:\n                    break\n            self.left = bintree(str1[1:counter+1])\n                \n            #match1 = re.search(\"\\((\\(.*\\)),.*\\)\",str1)\n            #if match1 != None:\n            #    self.left = bintree(str(match1.group(1)))\n        else:\n            self.left = \"\"\n        if self.str1[-2] != \",\":\n            str1 = str1[0]+str1[1+len(str(self.left)):]\n            match2 = re.search(\"\\(,(\\(.*\\))\\)\",str1)\n            if match2 != None:\n                self.right = bintree(str(str1[2:-1]))\n        else:\n            self.right = \"\"\n    def __str__(self):\n        return self.str1\n        \ndef inter(bin1, bin2):\n    if bin1.left != \"\" and bin2.left != \"\":\n        strleft = inter(bin1.left, bin2.left)\n    else:\n        strleft = \"\"\n    if bin1.right != \"\" and bin2.right != \"\":\n        strright = inter(bin1.right, bin2.right)\n    else:\n        strright = \"\"\n    return \"(\" + strleft + \",\" + strright + \")\"\n\ndef union(bin1, bin2):\n    if bin1.left != \"\" or bin2.left != \"\":\n        if bin1.left == \"\":\n            strleft = str(bin2.left)\n        elif bin2.left == \"\":\n            strleft = str(bin1.left)\n        else:\n            strleft = union(bin1.left, bin2.left)\n    else:\n        strleft = \"\"\n    if bin1.right != \"\" or bin2.right != \"\":\n        if bin1.right == \"\":\n            strright = str(bin2.right)\n        elif bin2.right == \"\":\n            strright = str(bin1.right)\n        else:\n            strright = union(bin1.right, bin2.right)\n    else:\n        strright = \"\"\n        #print(\"(\" + strleft + \",\" + strright + \")\")\n    return \"(\" + strleft + \",\" + strright + \")\"\n\n\n\nwhile True:\n    \n    try:\n        inputs = map(str,input().split())\n        order = next(inputs)\n        if order == \"i\":\n            t1 = bintree(next(inputs))\n            t2 = bintree(next(inputs))\n            #print(t1.left,t1.right)\n            print(inter(t1, t2))#  == \"((((((,),),),),),)\")\n            \n        elif order == \"u\":\n            t1 = bintree(next(inputs))\n            t2 = bintree(next(inputs)) \n            #print(t1.left,t1.right)\n            #print(t1.left,t1.right)\n            print(union(t1,t2))# == \"((((,),(,)),((,),(,))),(((,),(,)),((,),(,))))\")\n    except EOFError as exception:\n        break\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, left, right):\n        self.left = left\n        self.right = right\n        self.val = ''\n    \n    @classmethod\n    def fromString(cls, s):\n        pos = 1\n        if s[pos] == '(':\n            e = getEnd(s, 1)\n            left = cls.fromString(s[1:e+1])\n            pos = e + 2\n        else:\n            left = None\n            pos += 1\n\n        if s[pos] == '(':\n            e = getEnd(s, pos)\n            right = Node.fromString(s[pos:e+1])\n        else:\n            right = None\n\n        return cls(left, right)\n\n    def __str__(self):\n        lstr = \"\" if self.left == None else str(self.left)\n        rstr = \"\" if self.right == None else str(self.right)\n        return \"({},{})\".format(lstr, rstr)\n\ndef getEnd(s, pos):\n    count = 0\n    while True:\n        if s[pos] == '(':\n            count += 1\n        elif s[pos] == ')':\n            count -= 1\n        if count == 0:\n            break\n        pos += 1\n    return pos\n\ndef intersection(root1, root2):\n    if root1.left == None or root2.left == None:\n        root1.left = None\n    else:\n        intersection(root1.left, root2.left)\n    \n    if root1.right == None or root2.right == None:\n        root1.right = None\n    else:\n        intersection(root1.right, root2.right)\n\ndef union(root1, root2):\n    if root1.left == None and root2.left == None:\n        pass\n    elif root1.left != None and root2.left == None:\n        pass\n    elif root1.left == None and root2.left != None:\n        root1.left = root2.left\n    else:\n        union(root1.left, root2.left)\n    \n    if root1.right == None and root2.right == None:\n        pass\n    elif root1.right != None and root2.right == None:\n        pass\n    elif root1.right == None and root2.right != None:\n        root1.right = root2.right\n    else:\n        union(root1.right, root2.right)\n\nif __name__ == '__main__':\n    try:\n        while True:\n            line = input().strip().split()\n            c = line[0]\n            a = Node.fromString(line[1])\n            b = Node.fromString(line[2])\n\n            if c == 'i':\n                intersection(a, b)\n            else:\n                union(a, b)\n\n            print(a)\n\n    except EOFError:\n        pass\n"
  },
  {
    "language": "Python",
    "code": "import sys\ndef parse_btree(s):\n    l = r = -1\n    paren = 0\n    comma = -1\n    if s == \"(,)\":\n        return ([\"node\"])\n    if s == \"\":\n        return ([\"None\"])\n    for i in range(len(s)):\n        c = s[i]\n        if c == \"(\":\n            paren += 1\n            if paren == 1 and r < 0:\n                l = i\n        elif c == \",\" and paren == 1:\n            r = i\n        elif c == \")\":\n            paren -= 1\n    \n    return ([parse_btree(s[l + 1:r]), parse_btree(s[r + 1:-1])])\n\ndef deparse_btree(bt):\n    if bt == [\"None\"]:\n        return (\"\")\n    elif bt == [\"node\"]:\n        return (\"(,)\")\n    else:\n        return (\"(\" + deparse_btree(bt[0]) + \",\" + deparse_btree(bt[1]) + \")\")\n\ndef intersection_btree(s, t):\n    if s == [\"node\"] and t != [\"None\"]:\n        return ([\"node\"])\n    elif s != [\"None\"] and t == [\"node\"]:\n        return ([\"node\"])\n    elif s == [\"None\"] or t == [\"None\"]:\n        return ([\"None\"])\n    return [intersection_btree(s[0], t[0]), intersection_btree(s[1], t[1])]\n\ndef union_btree(s, t):\n    if s == [\"node\"]:\n        if t != [\"None\"]:\n            return (t)\n        else:\n            return ([\"node\"])\n    elif s == [\"None\"]:\n        if t != [\"None\"]:\n            return (t)\n        else:\n            return ([\"None\"])\n    if t == [\"node\"]:\n        if s != [\"None\"]:\n            return (s)\n        else:\n            return ([\"node\"])\n    elif t == [\"None\"]:\n        if s != [\"None\"]:\n            return (s)\n        else:\n            return ([\"None\"])\n    return [union_btree(s[0], t[0]), union_btree(s[1], t[1])]\n\nfor line in sys.stdin:\n    s = line.strip().split()\n    a = parse_btree(s[1])\n    b = parse_btree(s[2])\n    if s[0] == 'i':\n        c = intersection_btree(a, b)\n        print(deparse_btree(c))\n    elif s[0] == 'u':\n        print(deparse_btree(union_btree(a, b)))\n"
  },
  {
    "language": "Python",
    "code": "def convert(s):\n    cur = [0]\n    def dfs():\n        result = [0, 0]\n        cur[0] += 1 # '('\n        if s[cur[0]] == '(':\n            result[0] = dfs()\n        cur[0] += 1 # ','\n        if s[cur[0]] == '(':\n            result[1] = dfs()\n        cur[0] += 1 # ')'\n        return result\n    return dfs()\ndef rconvert(C):\n    def dfs(node):\n        res = [\"\", \"\"]\n        if node[0]:\n            res[0] = rconvert(node[0])\n        if node[1]:\n            res[1] = rconvert(node[1])\n        return \"(%s,%s)\" % tuple(res)\n    return dfs(C)\ndef solve(A, B, t):\n    def get(i):\n        if A[i] and B[i]:\n            return solve(A[i], B[i], t)\n        elif t is 'u':\n            return A[i] or B[i]\n    return [get(0), get(1)]\ntry:\n    while 1:\n        ipt = raw_input().split()\n        print rconvert(solve(convert(ipt[1]), convert(ipt[2]), ipt[0]))\nexcept:pass"
  },
  {
    "language": "Python",
    "code": "# AOJ 1001: Binary Tree Intersection And Union\n# Python3 2018.7.5 bal4u\n\ndef parse(p, i):\n\tglobal sz\n\tnode[i][2] += 1\n\tdel p[0]\n\tif p[0] != ',':\n\t\tif node[i][0] == 0:\n\t\t\tnode[i][0] = sz\n\t\t\tsz += 1\n\t\tparse(p, node[i][0])\n\tdel p[0]\n\tif p[0] != ')':\n\t\tif node[i][1] == 0:\n\t\t\tnode[i][1] = sz\n\t\t\tsz += 1\n\t\tparse(p, node[i][1])\n\tdel p[0]\n\ndef act(i, k):\n\tglobal ans\n\tif node[i][2] < k: return\n\tans += '('\n\tif node[i][0] > 0: act(node[i][0], k)\n\tans += ','\n\tif node[i][1] > 0: act(node[i][1], k)\n\tans += ')'\n\nwhile True:\n\ttry: op, a, b = input().split()\n\texcept: break\n\tsz = 1\n\tnode = [[0 for j in range(3)] for i in range(210)]\n\tparse(list(a), 0)\n\tparse(list(b), 0)\n\tans = ''\n\tact(0, 2 if op== 'i' else 1)\n\tprint(ans)\n"
  }
]