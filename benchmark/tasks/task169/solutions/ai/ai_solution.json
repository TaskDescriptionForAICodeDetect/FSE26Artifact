[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Node {\n    int val; // 1, 2, or 3 (1 & 2 for intersection, 1 | 2 for union)\n    struct Node *left;\n    struct Node *right;\n} Node;\n\nNode* parseTree(const char **s) {\n    if (**s != '(') return NULL;\n    (*s)++; // skip '('\n    Node *node = malloc(sizeof(Node));\n    node->val = 0;\n    node->left = parseTree(s);\n    node->right = parseTree(s);\n    (*s)++; // skip ')'\n    return node;\n}\n\nvoid markTree(Node *node, int num) {\n    if (!node) return;\n    node->val |= num;\n    markTree(node->left, num);\n    markTree(node->right, num);\n}\n\nNode* intersect(Node *t1, Node *t2) {\n    if (!t1 || !t2) return NULL;\n    Node *node = malloc(sizeof(Node));\n    node->val = t1->val & t2->val;\n    node->left = intersect(t1->left, t2->left);\n    node->right = intersect(t1->right, t2->right);\n    return node;\n}\n\nNode* unite(Node *t1, Node *t2) {\n    if (!t1 && !t2) return NULL;\n    Node *node = malloc(sizeof(Node));\n    if (!t1) {\n        node->val = t2->val;\n        node->left = unite(NULL, t2->left);\n        node->right = unite(NULL, t2->right);\n    } else if (!t2) {\n        node->val = t1->val;\n        node->left = unite(t1->left, NULL);\n        node->right = unite(t1->right, NULL);\n    } else {\n        node->val = t1->val | t2->val;\n        node->left = unite(t1->left, t2->left);\n        node->right = unite(t1->right, t2->right);\n    }\n    return node;\n}\n\nvoid printTree(Node *node, int op) {\n    if (!node) return;\n    printf(\"(\");\n    printTree(node->left, op);\n    printTree(node->right, op);\n    printf(\")\");\n}\n\nvoid freeTree(Node *node) {\n    if (!node) return;\n    freeTree(node->left);\n    freeTree(node->right);\n    free(node);\n}\n\nint main() {\n    char op;\n    char tree1[1000], tree2[1000];\n    scanf(\" %c %s %s\", &op, tree1, tree2);\n\n    const char *p1 = tree1;\n    const char *p2 = tree2;\n    Node *t1 = parseTree(&p1);\n    Node *t2 = parseTree(&p2);\n\n    markTree(t1, 1);\n    markTree(t2, 2);\n\n    Node *result = NULL;\n    if (op == 'i') {\n        result = intersect(t1, t2);\n    } else if (op == 'u') {\n        result = unite(t1, t2);\n    }\n\n    printTree(result, op);\n    printf(\"\\n\");\n\n    freeTree(t1);\n    freeTree(t2);\n    freeTree(result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:54:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TreeIntersectionUnion {\n    static class Node {\n        int val;\n        Set<Integer> nums;\n        Node left, right;\n        \n        Node(int val, int num) {\n            this.val = val;\n            this.nums = new HashSet<>();\n            this.nums.add(num);\n        }\n    }\n    \n    public static Node parseTree(String s, int num) {\n        if (s.equals(\"()\")) return null;\n        s = s.substring(1, s.length() - 1);\n        int rootEnd = s.indexOf('(');\n        if (rootEnd == -1) rootEnd = s.length();\n        \n        Node root = new Node(Integer.parseInt(s.substring(0, rootEnd)), num);\n        \n        int leftStart = rootEnd;\n        int depth = 0;\n        for (int i = rootEnd; i < s.length(); i++) {\n            if (s.charAt(i) == '(') depth++;\n            if (s.charAt(i) == ')') depth--;\n            if (depth == 0) {\n                leftStart = rootEnd;\n                rootEnd = i + 1;\n                break;\n            }\n        }\n        \n        if (leftStart < s.length()) {\n            root.left = parseTree(s.substring(leftStart, rootEnd), num);\n        }\n        \n        if (rootEnd < s.length()) {\n            root.right = parseTree(s.substring(rootEnd), num);\n        }\n        \n        return root;\n    }\n    \n    public static Node mergeNodes(Node node1, Node node2, boolean isIntersection) {\n        if (node1 == null && node2 == null) return null;\n        if (node1 == null) return isIntersection ? null : copyTree(node2);\n        if (node2 == null) return isIntersection ? null : copyTree(node1);\n        \n        Node merged = new Node(node1.val, 0);\n        merged.nums.addAll(node1.nums);\n        merged.nums.addAll(node2.nums);\n        \n        if (isIntersection && !node1.nums.contains(2) || !node1.nums.contains(1)) return null;\n        \n        merged.left = mergeNodes(node1.left, node2.left, isIntersection);\n        merged.right = mergeNodes(node1.right, node2.right, isIntersection);\n        \n        return merged;\n    }\n    \n    public static Node copyTree(Node node) {\n        if (node == null) return null;\n        Node copy = new Node(node.val, 0);\n        copy.nums.addAll(node.nums);\n        copy.left = copyTree(node.left);\n        copy.right = copyTree(node.right);\n        return copy;\n    }\n    \n    public static String treeToString(Node node) {\n        if (node == null) return \"()\";\n        String left = treeToString(node.left);\n        String right = treeToString(node.right);\n        return \"(\" + node.val + left + right + \")\";\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        \n        char op = input.charAt(0);\n        int splitIndex = input.indexOf(input.charAt(1));\n        String tree1Str = input.substring(1, splitIndex);\n        String tree2Str = input.substring(splitIndex);\n        \n        Node tree1 = parseTree(tree1Str, 1);\n        Node tree2 = parseTree(tree2Str, 2);\n        \n        Node result = mergeNodes(tree1, tree2, op == 'i');\n        \n        System.out.println(treeToString(result));\n    }\n}",
    "timestamp": "2025-08-05 18:54:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <set>\n#include <map>\nusing namespace std;\n\nstruct TreeNode {\n    set<int> masks;\n    map<char, TreeNode*> children;\n};\n\nTreeNode* parseTree(const string& s, int& pos) {\n    TreeNode* node = new TreeNode();\n    pos++; // skip '('\n    while (s[pos] != ')') {\n        char c = s[pos];\n        pos++;\n        node->children[c] = parseTree(s, pos);\n    }\n    pos++; // skip ')'\n    return node;\n}\n\nvoid markTree(TreeNode* node, int mask) {\n    if (!node) return;\n    node->masks.insert(mask);\n    for (auto& child : node->children) {\n        markTree(child.second, mask);\n    }\n}\n\nTreeNode* intersect(TreeNode* a, TreeNode* b) {\n    if (!a || !b) return nullptr;\n    TreeNode* node = new TreeNode();\n    for (int mask : a->masks) {\n        if (b->masks.find(mask) != b->masks.end()) {\n            node->masks.insert(mask);\n        }\n    }\n    for (auto& childA : a->children) {\n        char c = childA.first;\n        if (b->children.find(c) != b->children.end()) {\n            node->children[c] = intersect(childA.second, b->children.at(c));\n        }\n    }\n    return node;\n}\n\nTreeNode* unite(TreeNode* a, TreeNode* b) {\n    TreeNode* node = new TreeNode();\n    if (a) {\n        for (int mask : a->masks) node->masks.insert(mask);\n        for (auto& child : a->children) {\n            char c = child.first;\n            if (node->children.find(c) == node->children.end()) {\n                node->children[c] = unite(child.second, nullptr);\n            } else {\n                node->children[c] = unite(child.second, node->children[c]);\n            }\n        }\n    }\n    if (b) {\n        for (int mask : b->masks) node->masks.insert(mask);\n        for (auto& child : b->children) {\n            char c = child.first;\n            if (node->children.find(c) == node->children.end()) {\n                node->children[c] = unite(nullptr, child.second);\n            } else {\n                node->children[c] = unite(node->children[c], child.second);\n            }\n        }\n    }\n    return node;\n}\n\nstring serialize(TreeNode* node) {\n    if (!node || node->masks.empty()) return \"\";\n    string res = \"(\";\n    for (auto& child : node->children) {\n        res += child.first;\n        res += serialize(child.second);\n    }\n    res += \")\";\n    return res;\n}\n\nint main() {\n    char op;\n    string s1, s2;\n    cin >> op >> s1 >> s2;\n\n    int pos1 = 0, pos2 = 0;\n    TreeNode* tree1 = parseTree(s1, pos1);\n    TreeNode* tree2 = parseTree(s2, pos2);\n\n    markTree(tree1, 1);\n    markTree(tree2, 2);\n\n    TreeNode* result = nullptr;\n    if (op == 'i') {\n        result = intersect(tree1, tree2);\n    } else if (op == 'u') {\n        result = unite(tree1, tree2);\n    }\n\n    cout << serialize(result) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:55:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LEN 1000\n\ntypedef struct Node {\n    int val;\n    int num;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nNode* createNode(int val, int num) {\n    Node* node = malloc(sizeof(Node));\n    node->val = val;\n    node->num = num;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\nNode* parseTree(char* str, int* pos, int num) {\n    if (str[*pos] != '(') return NULL;\n    (*pos)++;\n    \n    if (str[*pos] == ')') {\n        (*pos)++;\n        return NULL;\n    }\n    \n    int val = 0;\n    while (str[*pos] >= '0' && str[*pos] <= '9') {\n        val = val * 10 + (str[*pos] - '0');\n        (*pos)++;\n    }\n    \n    Node* node = createNode(val, num);\n    node->left = parseTree(str, pos, num);\n    node->right = parseTree(str, pos, num);\n    \n    (*pos)++;\n    return node;\n}\n\nNode* copyTree(Node* root, int num) {\n    if (!root) return NULL;\n    \n    Node* newNode = createNode(root->val, num);\n    newNode->left = copyTree(root->left, num);\n    newNode->right = copyTree(root->right, num);\n    \n    return newNode;\n}\n\nNode* mergeTree(Node* t1, Node* t2, char op) {\n    if (!t1) return op == 'u' ? copyTree(t2, 2) : NULL;\n    if (!t2) return op == 'u' ? copyTree(t1, 1) : NULL;\n    \n    Node* node = createNode(t1->val, t1->num | t2->num);\n    \n    if (op == 'i' && !(t1->num & t2->num)) return NULL;\n    \n    node->left = mergeTree(t1->left, t2->left, op);\n    node->right = mergeTree(t1->right, t2->right, op);\n    \n    if (!node->left && !node->right && op == 'i' && node->num != 3) {\n        free(node);\n        return NULL;\n    }\n    \n    return node;\n}\n\nvoid printTree(Node* root) {\n    if (!root) {\n        printf(\"()\");\n        return;\n    }\n    \n    printf(\"(%d\", root->val);\n    printTree(root->left);\n    printTree(root->right);\n    printf(\")\");\n}\n\nvoid freeTree(Node* root) {\n    if (!root) return;\n    freeTree(root->left);\n    freeTree(root->right);\n    free(root);\n}\n\nint main() {\n    char input[MAX_LEN];\n    fgets(input, MAX_LEN, stdin);\n    \n    int pos = 0;\n    char op = input[pos++];\n    \n    Node* t1 = parseTree(input, &pos, 1);\n    Node* t2 = parseTree(input, &pos, 2);\n    \n    Node* result = mergeTree(t1, t2, op);\n    \n    printTree(result);\n    printf(\"\\n\");\n    \n    freeTree(t1);\n    freeTree(t2);\n    freeTree(result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:55:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <stack>\nusing namespace std;\n\nclass TreeNode {\npublic:\n    int val;\n    set<int> labels;\n    TreeNode* left;\n    TreeNode* right;\n    \n    TreeNode(int v, int label) {\n        val = v;\n        labels.insert(label);\n        left = right = nullptr;\n    }\n};\n\nTreeNode* parseTree(const string& s, int label) {\n    stack<TreeNode*> st;\n    int num = 0;\n    bool negative = false;\n    \n    for (char c : s) {\n        if (c == '(') {\n            num = 0;\n            negative = false;\n        }\n        else if (c == '-') {\n            negative = true;\n        }\n        else if (isdigit(c)) {\n            num = num * 10 + (c - '0');\n        }\n        else if (c == ')') {\n            if (num || negative) {\n                int val = negative ? -num : num;\n                TreeNode* node = new TreeNode(val, label);\n                \n                while (!st.empty() && st.top() == nullptr) {\n                    st.pop();\n                }\n                \n                if (!st.empty()) {\n                    TreeNode* parent = st.top();\n                    if (!parent->left) {\n                        parent->left = node;\n                    } else {\n                        parent->right = node;\n                    }\n                }\n                \n                st.push(node);\n            } else {\n                st.push(nullptr);\n            }\n            num = 0;\n            negative = false;\n        }\n    }\n    \n    return st.empty() ? nullptr : st.top();\n}\n\nTreeNode* intersectTree(TreeNode* t1, TreeNode* t2) {\n    if (!t1 || !t2) return nullptr;\n    \n    TreeNode* node = nullptr;\n    \n    if (t1->val == t2->val) {\n        set<int> commonLabels;\n        set_intersection(t1->labels.begin(), t1->labels.end(), \n                         t2->labels.begin(), t2->labels.end(), \n                         inserter(commonLabels, commonLabels.begin()));\n        \n        if (!commonLabels.empty()) {\n            node = new TreeNode(t1->val, 1);\n            node->labels = commonLabels;\n            \n            node->left = intersectTree(t1->left, t2->left);\n            node->right = intersectTree(t1->right, t2->right);\n        }\n    }\n    \n    return node;\n}\n\nTreeNode* unionTree(TreeNode* t1, TreeNode* t2) {\n    if (!t1) return t2;\n    if (!t2) return t1;\n    \n    TreeNode* node = new TreeNode(t1->val, 1);\n    node->labels.insert(t1->labels.begin(), t1->labels.end());\n    node->labels.insert(t2->labels.begin(), t2->labels.end());\n    \n    node->left = unionTree(t1->left, t2->left);\n    node->right = unionTree(t1->right, t2->right);\n    \n    return node;\n}\n\nstring treeToString(TreeNode* root) {\n    if (!root) return \"\";\n    \n    string s = \"(\" + to_string(root->val) + \")\";\n    \n    string left = treeToString(root->left);\n    string right = treeToString(root->right);\n    \n    return s + left + right;\n}\n\nint main() {\n    string op, tree1, tree2;\n    cin >> op >> tree1 >> tree2;\n    \n    TreeNode* t1 = parseTree(tree1, 1);\n    TreeNode* t2 = parseTree(tree2, 2);\n    \n    TreeNode* result = nullptr;\n    \n    if (op == \"i\") {\n        result = intersectTree(t1, t2);\n    } else if (op == \"u\") {\n        result = unionTree(t1, t2);\n    }\n    \n    cout << treeToString(result) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:56:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BinaryTreeOperations {\n    static class TreeNode {\n        char val;\n        TreeNode left;\n        TreeNode right;\n        TreeNode(char x) { val = x; }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        char operation = input.charAt(0);\n        String[] trees = input.substring(1).split(\"(?<=\\\\))|(?=\\\\()\", 2);\n        String tree1Str = trees[0];\n        String tree2Str = trees[1];\n\n        TreeNode tree1 = parseTree(tree1Str);\n        TreeNode tree2 = parseTree(tree2Str);\n\n        TreeNode result = null;\n        if (operation == 'i') {\n            result = intersect(tree1, tree2);\n        } else if (operation == 'u') {\n            result = union(tree1, tree2);\n        }\n\n        System.out.println(serialize(result));\n    }\n\n    private static TreeNode parseTree(String s) {\n        if (s == null || s.isEmpty()) return null;\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode root = null;\n        TreeNode node = null;\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '(') {\n                if (node != null) {\n                    stack.push(node);\n                }\n                node = new TreeNode('0');\n                if (root == null) {\n                    root = node;\n                }\n            } else if (c == ')') {\n                if (!stack.isEmpty()) {\n                    TreeNode parent = stack.pop();\n                    if (parent.left == null) {\n                        parent.left = node;\n                    } else {\n                        parent.right = node;\n                    }\n                    node = parent;\n                }\n            } else {\n                node.val = c;\n            }\n        }\n        return root;\n    }\n\n    private static TreeNode intersect(TreeNode t1, TreeNode t2) {\n        if (t1 == null || t2 == null) return null;\n        TreeNode node = new TreeNode('0');\n        if (t1.val == '1' && t2.val == '1') {\n            node.val = '1';\n        } else if (t1.val == '2' && t2.val == '2') {\n            node.val = '2';\n        } else {\n            return null;\n        }\n        node.left = intersect(t1.left, t2.left);\n        node.right = intersect(t1.right, t2.right);\n        return node.left == null && node.right == null && node.val == '0' ? null : node;\n    }\n\n    private static TreeNode union(TreeNode t1, TreeNode t2) {\n        if (t1 == null && t2 == null) return null;\n        TreeNode node = new TreeNode('0');\n        if (t1 == null) {\n            node.val = t2.val;\n            node.left = union(null, t2.left);\n            node.right = union(null, t2.right);\n        } else if (t2 == null) {\n            node.val = t1.val;\n            node.left = union(t1.left, null);\n            node.right = union(t1.right, null);\n        } else {\n            if (t1.val == '1' || t2.val == '1') {\n                node.val = '1';\n            } else if (t1.val == '2' || t2.val == '2') {\n                node.val = '2';\n            }\n            node.left = union(t1.left, t2.left);\n            node.right = union(t1.right, t2.right);\n        }\n        return node.left == null && node.right == null && node.val == '0' ? null : node;\n    }\n\n    private static String serialize(TreeNode root) {\n        if (root == null) return \"\";\n        StringBuilder sb = new StringBuilder();\n        serializeHelper(root, sb);\n        return sb.toString();\n    }\n\n    private static void serializeHelper(TreeNode node, StringBuilder sb) {\n        if (node == null) return;\n        sb.append('(');\n        sb.append(node.val);\n        serializeHelper(node.left, sb);\n        serializeHelper(node.right, sb);\n        sb.append(')');\n    }\n}",
    "timestamp": "2025-08-05 18:56:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef parse_tree(expression):\n    if not expression or expression == '()':\n        return None\n    stack = []\n    current_node = None\n    i = 0\n    while i < len(expression):\n        if expression[i] == '(':\n            if current_node:\n                stack.append(current_node)\n            i += 1\n            if expression[i] != ')':\n                current_node = TreeNode(0)\n            else:\n                current_node = None\n        elif expression[i] == ')':\n            if stack:\n                parent = stack.pop()\n                if not parent.left:\n                    parent.left = current_node\n                else:\n                    parent.right = current_node\n                current_node = parent\n            i += 1\n        else:\n            current_node.val = int(expression[i])\n            i += 1\n    return current_node\n\ndef serialize_tree(node):\n    if not node:\n        return '()'\n    left = serialize_tree(node.left)\n    right = serialize_tree(node.right)\n    return f'({node.val}{left}{right})'\n\ndef intersect_trees(t1, t2):\n    if not t1 or not t2:\n        return None\n    if t1.val == t2.val:\n        new_node = TreeNode(t1.val)\n        new_node.left = intersect_trees(t1.left, t2.left)\n        new_node.right = intersect_trees(t1.right, t2.right)\n        return new_node\n    return None\n\ndef union_trees(t1, t2):\n    if not t1 and not t2:\n        return None\n    new_node = TreeNode(1 if t1 else 2)\n    if t1 and t2:\n        new_node.val = 1\n    new_node.left = union_trees(t1.left if t1 else None, t2.left if t2 else None)\n    new_node.right = union_trees(t1.right if t1 else None, t2.right if t2 else None)\n    return new_node\n\ndef process_trees(operation, tree1_expr, tree2_expr):\n    tree1 = parse_tree(tree1_expr)\n    tree2 = parse_tree(tree2_expr)\n    if operation == 'i':\n        result_tree = intersect_trees(tree1, tree2)\n    elif operation == 'u':\n        result_tree = union_trees(tree1, tree2)\n    return serialize_tree(result_tree)\n\n# Example Usage (prints result): \noperation = 'i'\ntree1_expr = \"(1(2()())())\"\ntree2_expr = \"(1(2()())(3()()))\"\nprint(process_trees(operation, tree1_expr, tree2_expr))",
    "timestamp": "2025-08-13 01:26:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TreeOperations {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.next().trim();\n        char operation = input.charAt(0);\n        String tree1Expr = input.substring(1, input.indexOf('u') == -1 ? input.indexOf('i') == -1 ? input.length() : input.indexOf('i') : input.indexOf('u'));\n        String tree2Expr = input.substring(input.indexOf(tree1Expr) + tree1Expr.length());\n\n        TreeNode tree1 = parseTree(tree1Expr);\n        TreeNode tree2 = parseTree(tree2Expr);\n\n        TreeNode resultTree;\n        if (operation == 'i') {\n            resultTree = intersection(tree1, tree2);\n        } else {\n            resultTree = union(tree1, tree2);\n        }\n\n        System.out.println(treeToString(resultTree));\n    }\n\n    private static class TreeNode {\n        TreeNode left, right;\n        TreeNode() {}\n    }\n\n    private static TreeNode parseTree(String treeExpr) {\n        if (treeExpr.isEmpty() || !treeExpr.equals(\"()\")) return null;\n\n        return parseTreeHelper(new StringTokenizer(treeExpr, \"()\", true));\n    }\n\n    private static TreeNode parseTreeHelper(StringTokenizer tokens) {\n        if (!tokens.hasMoreTokens()) return null;\n\n        tokens.nextToken(); // consume '('\n        if (!tokens.hasMoreTokens() || tokens.nextToken().equals(\")\")) {\n            return null;\n        }\n\n        TreeNode node = new TreeNode();\n        node.left = parseTreeHelper(tokens);\n        node.right = parseTreeHelper(tokens);\n\n        return node;\n    }\n\n    private static TreeNode intersection(TreeNode root1, TreeNode root2) {\n        if (root1 == null || root2 == null) return null;\n\n        TreeNode newNode = new TreeNode();\n        newNode.left = intersection(root1.left, root2.left);\n        newNode.right = intersection(root1.right, root2.right);\n\n        return newNode;\n    }\n\n    private static TreeNode union(TreeNode root1, TreeNode root2) {\n        if (root1 == null) return cloneTree(root2);\n        if (root2 == null) return cloneTree(root1);\n\n        TreeNode newNode = new TreeNode();\n        newNode.left = union(root1.left, root2.left);\n        newNode.right = union(root1.right, root2.right);\n\n        return newNode;\n    }\n\n    private static TreeNode cloneTree(TreeNode node) {\n        if (node == null) return null;\n        \n        TreeNode newNode = new TreeNode();\n        newNode.left = cloneTree(node.left);\n        newNode.right = cloneTree(node.right);\n        \n        return newNode;\n    }\n\n    private static String treeToString(TreeNode root) {\n        if (root == null) return \"()\";\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"(\");\n        sb.append(treeToString(root.left));\n        sb.append(treeToString(root.right));\n        sb.append(\")\");\n\n        return sb.toString();\n    }\n}",
    "timestamp": "2025-08-13 01:26:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nNode* parse_tree(const char* str, int* pos) {\n    if (str[*pos] != '(') return NULL;\n    (*pos)++;\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->left = parse_tree(str, pos);\n    node->right = parse_tree(str, pos);\n    (*pos)++;\n    return node;\n}\n\nNode* intersect_nodes(Node* a, Node* b) {\n    if (!a || !b) return NULL;\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->left = intersect_nodes(a->left, b->left);\n    node->right = intersect_nodes(a->right, b->right);\n    return node;\n}\n\nNode* union_nodes(Node* a, Node* b) {\n    if (!a && !b) return NULL;\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->left = union_nodes(a ? a->left : NULL, b ? b->left : NULL);\n    node->right = union_nodes(a ? a->right : NULL, b ? b->right : NULL);\n    return node;\n}\n\nvoid serialize_tree(Node* node, char* result, int* index) {\n    if (!node) return;\n    result[(*index)++] = '(';\n    serialize_tree(node->left, result, index);\n    serialize_tree(node->right, result, index);\n    result[(*index)++] = ')';\n}\n\nvoid free_tree(Node* node) {\n    if (!node) return;\n    free_tree(node->left);\n    free_tree(node->right);\n    free(node);\n}\n\nint main() {\n    char operation;\n    char tree1[1024], tree2[1024];\n    scanf(\"%c%s%s\", &operation, tree1, tree2);\n\n    int pos1 = 0, pos2 = 0;\n    Node* root1 = parse_tree(tree1, &pos1);\n    Node* root2 = parse_tree(tree2, &pos2);\n\n    Node* result_tree;\n    if (operation == 'i') {\n        result_tree = intersect_nodes(root1, root2);\n    } else { // indicate 'u'\n        result_tree = union_nodes(root1, root2);\n    }\n\n    char result[2048];\n    int index = 0;\n    serialize_tree(result_tree, result, &index);\n    result[index] = '\\0';\n\n    printf(\"%s\\n\", result);\n\n    free_tree(root1);\n    free_tree(root2);\n    free_tree(result_tree);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 01:26:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef parse_tree(s):\n    if not s or s == '()':\n        return None\n    \n    s = s[1:-1]\n    if not s:\n        return None\n    \n    parts = s.split('(', 1)\n    val = int(parts[0])\n    \n    if len(parts) == 1:\n        return TreeNode(val)\n    \n    count = 1\n    for i, char in enumerate(parts[1]):\n        if char == '(':\n            count += 1\n        elif char == ')':\n            count -= 1\n        \n        if count == 0:\n            left = parse_tree('(' + parts[1][:i+1])\n            right = parse_tree('(' + parts[1][i+1:]) if i+1 < len(parts[1]) else None\n            return TreeNode(val, left, right)\n\ndef tree_to_dict(node, numbering=1):\n    if not node:\n        return {}\n    \n    d = {node.val: numbering}\n    d.update(tree_to_dict(node.left, numbering))\n    d.update(tree_to_dict(node.right, numbering))\n    return d\n\ndef build_intersection_or_union(dict1, dict2, operation):\n    result = {}\n    if operation == 'i':\n        result = {k: (1 if k in dict1 and k in dict2 else 0) for k in set(dict1) | set(dict2)}\n        result = {k: v for k, v in result.items() if v > 0}\n    else:\n        result = {k: (1 if k in dict1 else 0) + (2 if k in dict2 else 0) for k in set(dict1) | set(dict2)}\n        result = {k: v for k, v in result.items() if v > 0}\n    return result\n\ndef construct_tree(node_dict):\n    if not node_dict:\n        return '()'\n    \n    root_val = min(node_dict.keys())\n    root = TreeNode(root_val)\n    \n    def build_subtree(val):\n        if val not in node_dict:\n            return None\n        \n        node = TreeNode(val)\n        candidates = [k for k, v in node_dict.items() if k > val]\n        \n        if candidates:\n            left_val = min(candidates)\n            node.left = build_subtree(left_val)\n        \n        remaining = {k: v for k, v in node_dict.items() if k > val and k != left_val}\n        if remaining:\n            right_val = min(remaining.keys())\n            node.right = build_subtree(right_val)\n        \n        return node\n    \n    root.left = build_subtree(min(k for k in node_dict.keys() if k > root_val)) if any(k > root_val for k in node_dict.keys()) else None\n    \n    def tree_to_str(node):\n        if not node:\n            return ''\n        return f'({node.val}{tree_to_str(node.left)}{tree_to_str(node.right)})'\n    \n    return tree_to_str(root)\n\ndef process_operation(operation):\n    op, tree1, tree2 = operation[0], operation[1:].split('(', 1)[0] + '(' + operation[1:].split('(', 1)[1], operation[1:].split('(', 1)[0] + '(' + operation[1:].split('(', 1)[1]\n    \n    parsed_tree1 = parse_tree(tree1)\n    parsed_tree2 = parse_tree(tree2)\n    \n    dict1 = tree_to_dict(parsed_tree1, 1)\n    dict2 = tree_to_dict(parsed_tree2, 2)\n    \n    result_dict = build_intersection_or_union(dict1, dict2, op)\n    \n    return construct_tree(result_dict)\n\ndef main():\n    operations = [line.strip() for line in input().split('\\n')]\n    for op in operations:\n        print(process_operation(op))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 01:26:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def parse_tree(s, idx=0):\n    if idx >= len(s) or s[idx] != '(':\n        return None, idx\n    idx += 1  # skip '('\n    node = []\n    while idx < len(s) and s[idx] != ')':\n        if s[idx] == '(':\n            child, idx = parse_tree(s, idx)\n            node.append(child)\n        else:\n            node.append(s[idx])\n            idx += 1\n    idx += 1  # skip ')'\n    return node, idx\n\ndef build_set(tree, num):\n    if not tree:\n        return set()\n    s = set()\n    for elem in tree:\n        if isinstance(elem, list):\n            s.update(build_set(elem, num))\n        else:\n            if elem == str(num):\n                s.add(elem)\n    return s\n\ndef mark_tree(tree, s1, s2, op):\n    new_tree = []\n    for elem in tree:\n        if isinstance(elem, list):\n            marked = mark_tree(elem, s1, s2, op)\n            if marked:\n                new_tree.append(marked)\n        else:\n            if op == 'i':\n                if elem in s1 and elem in s2:\n                    new_tree.append(elem)\n            elif op == 'u':\n                if elem in s1 or elem in s2:\n                    new_tree.append(elem)\n    return new_tree if new_tree else None\n\ndef tree_to_str(tree):\n    if not tree:\n        return ''\n    s = '('\n    for elem in tree:\n        if isinstance(elem, list):\n            s += tree_to_str(elem)\n        else:\n            s += elem\n    s += ')'\n    return s\n\ndef solve():\n    import sys\n    input = sys.stdin.read().split()\n    op = input[0]\n    tree1_str = input[1]\n    tree2_str = input[2]\n    \n    tree1, _ = parse_tree(tree1_str)\n    tree2, _ = parse_tree(tree2_str)\n    \n    s1 = build_set(tree1, 1)\n    s2 = build_set(tree2, 2)\n    \n    if op == 'i':\n        common = s1 & s2\n        marked_tree1 = mark_tree(tree1, s1, s2, 'i')\n        marked_tree2 = mark_tree(tree2, s1, s2, 'i')\n        # Prefer the structure of tree1 if it has the common elements\n        if marked_tree1:\n            result = tree_to_str(marked_tree1)\n        else:\n            result = tree_to_str(marked_tree2)\n    elif op == 'u':\n        union = s1 | s2\n        marked_tree1 = mark_tree(tree1, s1, s2, 'u')\n        marked_tree2 = mark_tree(tree2, s1, s2, 'u')\n        # Combine both trees, but prefer the structure of tree1\n        # This is a simplification; actual merging might be more complex\n        combined = []\n        if marked_tree1:\n            combined.extend(marked_tree1)\n        if marked_tree2:\n            for elem in marked_tree2:\n                if isinstance(elem, list):\n                    combined.append(elem)\n                else:\n                    if elem not in s1:  # already added from tree1\n                        combined.append(elem)\n        result = tree_to_str(combined) if combined else '()'\n    \n    print(result)\n\nsolve()",
    "timestamp": "2025-08-13 01:27:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <string>\n\nusing namespace std;\n\nstruct TreeNode {\n    bool exists1;\n    bool exists2;\n    TreeNode* left;\n    TreeNode* right;\n    \n    TreeNode() : exists1(false), exists2(false), left(nullptr), right(nullptr) {}\n};\n\nTreeNode* buildTree(const string &s, int &index, bool isTree1) {\n    if (index >= s.length() || s[index] != '(') return nullptr;\n    \n    TreeNode* node = new TreeNode();\n    node->exists1 = isTree1 ? true : false;\n    node->exists2 = !isTree1 ? true : false;\n    index++;\n    \n    node->left = buildTree(s, index, isTree1);\n    \n    if (index < s.length() && s[index] == ')') index++;\n    \n    node->right = buildTree(s, index, isTree1);\n\n    return node;\n}\n\nTreeNode* intersect(TreeNode* t1, TreeNode* t2) {\n    if (!t1 || !t2 || !(t1->exists1 && t2->exists2)) return nullptr;\n    \n    TreeNode* node = new TreeNode();\n    node->exists1 = node->exists2 = true;\n    node->left = intersect(t1->left, t2->left);\n    node->right = intersect(t1->right, t2->right);\n    \n    return node;\n}\n\nTreeNode* unite(TreeNode* t1, TreeNode* t2) {\n    if (!t1 && !t2) return nullptr;\n    \n    TreeNode* node = new TreeNode();\n    node->exists1 = (t1 && t1->exists1) || (t2 && t2->exists1);\n    node->exists2 = (t1 && t1->exists2) || (t2 && t2->exists2);\n    node->left = unite(t1 ? t1->left : nullptr, t2 ? t2->left : nullptr);\n    node->right = unite(t1 ? t1->right : nullptr, t2 ? t2->right : nullptr);\n    \n    return node;\n}\n\nstring serialize(TreeNode* root) {\n    if (!root) return \"\";\n    string result = \"(\";\n    result += serialize(root->left);\n    result += \")\";\n    result += serialize(root->right);\n    \n    return result;\n}\n\nstring processOperation(const string &operation, const string &tree1, const string &tree2) {\n    int index1 = 0, index2 = 0;\n    TreeNode* t1 = buildTree(tree1, index1, true);\n    TreeNode* t2 = buildTree(tree2, index2, false);\n\n    TreeNode* resultTree = nullptr;\n    if (operation == \"i\") resultTree = intersect(t1, t2);\n    else if (operation == \"u\") resultTree = unite(t1, t2);\n    \n    return serialize(resultTree);\n}\n\nint main() {\n    string operation, tree1, tree2;\n    cin >> operation >> tree1 >> tree2;\n    \n    string result = processOperation(operation, tree1, tree2);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:00:12"
  }
]