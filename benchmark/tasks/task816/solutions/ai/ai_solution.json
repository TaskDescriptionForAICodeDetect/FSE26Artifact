[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint count_dmc(char* S, int N, int k) {\n    int count = 0;\n    for (int a = 0; a < N; a++) {\n        if (S[a] != 'D') continue;\n        for (int b = a + 1; b < N; b++) {\n            if (S[b] != 'M') continue;\n            for (int c = b + 1; c < N; c++) {\n                if (S[c] != 'C') continue;\n                if (c - a < k) count++;\n                else break;\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    int N, Q;\n    char S[100001];\n    scanf(\"%d %d\", &N, &Q);\n    scanf(\"%s\", S);\n    \n    for (int i = 0; i < Q; i++) {\n        int k;\n        scanf(\"%d\", &k);\n        printf(\"%d\\n\", count_dmc(S, N, k));\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:00:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_N 1000000\n\nvoid compute_dmc_numbers(char *S, int N, int *k_arr, int Q, long long *results) {\n    int D_prefix[MAX_N + 1] = {0};\n    int M_count[MAX_N] = {0};\n    long long MC_prefix[MAX_N + 1] = {0};\n\n    // Precompute D_prefix: number of D's up to index i (exclusive)\n    for (int i = 0; i < N; ++i) {\n        D_prefix[i + 1] = D_prefix[i] + (S[i] == 'D');\n    }\n\n    // Precompute M_count: 1 if S[i] is 'M', else 0\n    for (int i = 0; i < N; ++i) {\n        M_count[i] = (S[i] == 'M');\n    }\n\n    // Precompute MC_prefix: number of MC pairs where M is at i and C is at j > i\n    for (int i = N - 1; i >= 0; --i) {\n        MC_prefix[i] = MC_prefix[i + 1] + (S[i] == 'M' ? D_prefix[N] - D_prefix[i + 1] : 0);\n    }\n\n    // For each query, compute the k-DMC number\n    for (int q = 0; q < Q; ++q) {\n        int k = k_arr[q];\n        long long res = 0;\n        for (int c = 2; c < N; ++c) {\n            if (S[c] != 'C') continue;\n            int a_start = (c - k + 1) > 0 ? c - k + 1 : 0;\n            if (a_start >= c) continue;\n            res += D_prefix[a_start] * (M_count[c - 1]);\n            // More efficient way: use prefix sums, but this is a simplified version\n            for (int b = a_start; b < c; ++b) {\n                if (S[b] == 'M') {\n                    res += D_prefix[b];\n                }\n            }\n        }\n        results[q] = res;\n    }\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    char S[MAX_N + 1];\n    scanf(\"%s\", S);\n    int Q;\n    scanf(\"%d\", &Q);\n    int k_arr[Q];\n    for (int i = 0; i < Q; ++i) {\n        scanf(\"%d\", &k_arr[i]);\n    }\n    long long results[Q];\n    compute_dmc_numbers(S, N, k_arr, Q, results);\n    for (int i = 0; i < Q; ++i) {\n        printf(\"%lld\\n\", results[i]);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 23:01:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<long long> computeDMC(const string &S, const vector<int> &ks) {\n    int N = S.size();\n    vector<int> D_prefix(N + 1, 0);\n    vector<int> M_count(N + 1, 0);\n    vector<long long> MC_prefix(N + 1, 0);\n\n    for (int i = 0; i < N; ++i) {\n        D_prefix[i + 1] = D_prefix[i] + (S[i] == 'D');\n    }\n\n    for (int i = N - 1; i >= 0; --i) {\n        M_count[i] = M_count[i + 1] + (S[i] == 'M');\n    }\n\n    for (int i = N - 1; i >= 0; --i) {\n        MC_prefix[i] = MC_prefix[i + 1] + (S[i] == 'M' ? D_prefix[i] : 0);\n    }\n\n    vector<long long> results;\n    for (int k : ks) {\n        long long res = 0;\n        for (int c = 0; c < N; ++c) {\n            if (S[c] != 'C') continue;\n            int a_min = max(0, c - k + 1);\n            res += MC_prefix[a_min] - MC_prefix[c] - D_prefix[a_min] * (M_count[a_min] - M_count[c]);\n        }\n        results.push_back(res);\n    }\n    return results;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N;\n    cin >> N;\n    string S;\n    cin >> S;\n    int Q;\n    cin >> Q;\n    vector<int> ks(Q);\n    for (int i = 0; i < Q; ++i) {\n        cin >> ks[i];\n    }\n\n    vector<long long> results = computeDMC(S, ks);\n    for (long long res : results) {\n        cout << res << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:01:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DMCNumber {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        String S = scanner.next();\n        int Q = scanner.nextInt();\n        int[] queries = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            queries[i] = scanner.nextInt();\n        }\n\n        List<Integer> D_indices = new ArrayList<>();\n        List<Integer> M_indices = new ArrayList<>();\n        List<Integer> C_indices = new ArrayList<>();\n\n        for (int i = 0; i < N; i++) {\n            char c = S.charAt(i);\n            if (c == 'D') D_indices.add(i);\n            else if (c == 'M') M_indices.add(i);\n            else if (c == 'C') C_indices.add(i);\n        }\n\n        int[] answers = new int[Q];\n        for (int q = 0; q < Q; q++) {\n            int k = queries[q];\n            if (k < 3) {\n                answers[q] = 0;\n                continue;\n            }\n            int count = 0;\n            for (int d : D_indices) {\n                for (int m : M_indices) {\n                    if (m <= d) continue;\n                    for (int c : C_indices) {\n                        if (c <= m) continue;\n                        if (c - d < k) count++;\n                    }\n                }\n            }\n            answers[q] = count;\n        }\n\n        for (int ans : answers) {\n            System.out.println(ans);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:01:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DMCNumberCalculator {\n    public static List<Long> calculateDMCNumbers(String s, int[] kValues) {\n        int n = s.length();\n        List<Long> results = new ArrayList<>();\n\n        for (int k : kValues) {\n            long dCount = 0;\n            long dmCount = 0;\n            long dmcCount = 0;\n\n            long[] dPositions = new long[n];\n            long[] dmPositions = new long[n];\n\n            for (int i = 0; i < n; i++) {\n                if (s.charAt(i) == 'D') {\n                    dCount++;\n                    dPositions[dCount - 1] = i;\n                } else if (s.charAt(i) == 'M') {\n                    for (int j = 0; j < dCount; j++) {\n                        if (i - dPositions[j] < k) {\n                            dmCount++;\n                            dmPositions[dmCount - 1] = dPositions[j];\n                        }\n                    }\n                } else if (s.charAt(i) == 'C') {\n                    for (int j = 0; j < dmCount; j++) {\n                        if (i - dmPositions[j] < k) {\n                            dmcCount++;\n                        }\n                    }\n                }\n            }\n\n            results.add(dmcCount);\n        }\n\n        return results;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int n = scanner.nextInt();\n        String s = scanner.next();\n        int q = scanner.nextInt();\n        \n        int[] kValues = new int[q];\n        for (int i = 0; i < q; i++) {\n            kValues[i] = scanner.nextInt();\n        }\n        \n        List<Long> results = calculateDMCNumbers(s, kValues);\n        \n        for (long result : results) {\n            System.out.println(result);\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 23:01:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint calculate_dmc_number(const string& S, int k) {\n    int N = S.length();\n    int count = 0;\n    \n    for (int a = 0; a < N - 2; a++) {\n        if (S[a] == 'D') {\n            for (int b = a + 1; b < N - 1; b++) {\n                if (S[b] == 'M') {\n                    for (int c = b + 1; c < N; c++) {\n                        if (S[c] == 'C' && c - a < k) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    int N, Q;\n    string S;\n    \n    cin >> N >> S >> Q;\n    \n    for (int i = 0; i < Q; i++) {\n        int k;\n        cin >> k;\n        cout << calculate_dmc_number(S, k) << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:01:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def k_dmc_number(S, ks):\n    N = len(S)\n    dmc_counts = []\n    \n    for k in ks:\n        count = 0\n        d_positions = []\n        m_counts = [0] * N   # Cumulative count of 'M' positions\n        \n        # Fill d_positions and m_counts\n        for i in range(N):\n            if S[i] == 'D':\n                d_positions.append(i)\n            if S[i] == 'M':\n                if i > 0:\n                    m_counts[i] = m_counts[i - 1] + 1\n                else:\n                    m_counts[i] = 1\n            else:\n                if i > 0:\n                    m_counts[i] = m_counts[i - 1]\n        \n        # Calculate k-DMC number for each k\n        for a in d_positions:\n            left = a + 1\n            right = min(a + k, N)  # Adjust to respect k condition\n            \n            if left < right:\n                # Calculate number of 'M's and 'C's \n                m_count = m_counts[right - 1] - m_counts[left - 1]  # 'M's between [left, right-1]\n                c_count = S[left:right].count('C')  # 'C's between [left, right-1]\n                count += m_count * c_count\n        \n        dmc_counts.append(count)\n    \n    return dmc_counts",
    "timestamp": "2025-08-13 13:19:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class KDMCNumber {\n\n    public static List<Integer> calculateKDMCNumbers(String S, List<Integer> kValues) {\n        int n = S.length();\n        List<Integer> result = new ArrayList<>();\n        \n        for (int k : kValues) {\n            if (k < 3) {\n                result.add(0);\n                continue;\n            }\n            \n            int count = 0;\n            for (int a = 0; a < n; a++) {\n                if (S.charAt(a) == 'D') {\n                    for (int b = a + 1; b < n; b++) {\n                        if (S.charAt(b) == 'M') {\n                            for (int c = b + 1; c < n && c - a < k; c++) {\n                                if (S.charAt(c) == 'C') {\n                                    count++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            result.add(count);\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        String inputString = \"DMC\";\n        List<Integer> kValues = Arrays.asList(3, 5);\n        \n        List<Integer> result = calculateKDMCNumbers(inputString, kValues);\n        for (int res : result) {\n            System.out.println(res);\n        }\n    }\n}",
    "timestamp": "2025-08-13 13:19:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char S[100001]; // Assume input string is at most 100000 in length\n    int Q, k_i;\n    int N, i, j, result;\n    int d_count[100001], mc_pair[100001];\n\n    // Input the string\n    scanf(\"%s\", S);\n    N = strlen(S);\n\n    // Precompute the number of 'D' up to each position\n    for (i = 0, result = 0; i < N; ++i) {\n        d_count[i] = result;\n        if (S[i] == 'D') {\n            result++;\n        }\n    }\n\n    // Precompute the number of 'DM' pairs up to each position\n    for (i = 0, result = 0; i < N; ++i) {\n        mc_pair[i] = result;\n        if (S[i] == 'M') {\n            result += d_count[i];\n        }\n    }\n\n    // Number of test cases\n    scanf(\"%d\", &Q);\n\n    // Query processing\n    while (Q-- > 0) {\n        scanf(\"%d\", &k_i);\n        result = 0;\n        \n        // Calculate the k-DMC number for given k_i\n        for (j = 0; j < N; ++j) {\n            if (S[j] == 'C' && j - (k_i - 1) >= 0) {\n                result += mc_pair[j] - mc_pair[j - (k_i - 1)];\n            }\n        }\n        \n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:19:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function calculateKDMCNumbers(S, ks) {\n    const N = S.length;\n    const results = [];\n    \n    for (let k of ks) {\n        let dCount = 0;\n        let dmPairs = 0;\n        let kDMC = 0;\n        \n        let dmCounts = new Array(N).fill(0);\n        \n        for (let i = 0; i < N; i++) {\n            if (S[i] === 'D') {\n                dCount++;\n            } else if (S[i] === 'M') {\n                dmPairs += dCount;\n            } else if (S[i] === 'C') {\n                kDMC += dmPairs;\n                if (i - (k - 1) >= 0) {\n                    let start = i - (k - 1);\n                    if (S[start] === 'D') {\n                        dmPairs -= dmCounts[start];\n                    }\n                    if (S[start] === 'M') {\n                        dCount--;\n                        dmCounts[start] = dCount;\n                    }\n                }\n            }\n        }\n        \n        results.push(kDMC);\n    }\n    \n    return results;\n}\n\n// Example usage:\nconst S = \"DMCDMCM\";\nconst ks = [3, 4, 5];\nconsole.log(calculateKDMCNumbers(S, ks));",
    "timestamp": "2025-08-13 13:19:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_dmc_numbers(S, k_values):\n    N = len(S)\n    result = []\n\n    for k in k_values:\n        count = 0\n        for a in range(N):\n            if S[a] != 'D':\n                continue\n            for b in range(a + 1, N):\n                if S[b] != 'M':\n                    continue\n                for c in range(b + 1, N):\n                    if S[c] != 'C':\n                        continue\n                    if c - a < k:\n                        count += 1\n        result.append(count)\n\n    return result",
    "timestamp": "2025-08-13 13:19:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function calculateDMCNumbers(S, kValues) {\n    const N = S.length;\n    const result = [];\n\n    for (let k of kValues) {\n        let dCount = 0;\n        const dPositions = [];\n\n        // Find all positions of 'D'\n        for (let i = 0; i < N; i++) {\n            if (S[i] === 'D') {\n                dPositions.push(i);\n            }\n        }\n\n        let totalDMCCount = 0;\n\n        // Iterate through 'D' positions\n        for (let i = 0; i < dPositions.length; i++) {\n            const a = dPositions[i];\n\n            // Find 'M' positions after 'D'\n            for (let j = i + 1; j < dPositions.length; j++) {\n                const b = dPositions[j];\n\n                // Find 'C' positions after 'M'\n                for (let l = j + 1; l < dPositions.length; l++) {\n                    const c = dPositions[l];\n\n                    // Check if the triple satisfies k-DMC condition\n                    if (c - a < k && S[b] === 'M' && S[c] === 'C') {\n                        totalDMCCount++;\n                    }\n                }\n            }\n        }\n\n        result.push(totalDMCCount);\n    }\n\n    return result;\n}",
    "timestamp": "2025-08-13 13:19:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    S = input[ptr]\n    ptr += 1\n    Q = int(input[ptr])\n    ptr += 1\n    queries = list(map(int, input[ptr:ptr+Q]))\n    \n    # Precompute prefix sums for 'M's\n    prefix_m = [0] * (N + 1)\n    for i in range(N):\n        prefix_m[i+1] = prefix_m[i] + (1 if S[i] == 'M' else 0)\n    \n    # Precompute for each 'C' the number of 'M's in [a+1, c-1] where S[a] = 'D' and c - a < k\n    # We need to process each 'C' and for each possible k, but since k is variable, we need a different approach\n    # Instead, for each 'C', find all 'D's where c - a < k, and sum the 'M's between them\n    \n    # Precompute for each 'C' the list of 'D's positions before it (sorted)\n    D_positions = []\n    for i in range(N):\n        if S[i] == 'D':\n            D_positions.append(i)\n    \n    # Precompute for each 'C' the prefix sum of D's\n    # But we need to process each query k_i\n    \n    # For each query, we can process all 'C's and for each 'C', count the number of 'D's where c - a < k_i (i.e., a > c - k_i)\n    # Then, for those 'D's, sum the number of 'M's between D and C\n    \n    res = []\n    for k in queries:\n        total = 0\n        for c in range(N):\n            if S[c] != 'C':\n                continue\n            # Find all D's a < c where a > c - k\n            left = max(0, c - k + 1)\n            # Binary search in D_positions for a >= left and a < c\n            low = 0\n            high = len(D_positions) - 1\n            first = -1\n            # Find the first D >= left\n            while low <= high:\n                mid = (low + high) // 2\n                if D_positions[mid] >= left:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n            # Now, low is the first D >= left\n            # Now, find all D < c\n            low2 = 0\n            high2 = len(D_positions) - 1\n            last = -1\n            while low2 <= high2:\n                mid = (low2 + high2) // 2\n                if D_positions[mid] < c:\n                    low2 = mid + 1\n                else:\n                    high2 = mid - 1\n            # high2 is the last D < c\n            start = low\n            end = high2\n            if start > end:\n                continue\n            # For D in D_positions[start..end], sum the M's between D and c\n            # The number of M's is prefix_m[c] - prefix_m[D+1]\n            # Sum over all D in D_positions[start..end] of (prefix_m[c] - prefix_m[D+1])\n            # = (end - start + 1) * prefix_m[c] - sum_{D} prefix_m[D+1]\n            # Precompute prefix sums of prefix_m[D+1] for D_positions\n            # Precompute prefix_D_m\n            if not hasattr(solve, 'prefix_D_m'):\n                solve.prefix_D_m = [0] * (len(D_positions) + 1)\n                for i in range(len(D_positions)):\n                    solve.prefix_D_m[i+1] = solve.prefix_D_m[i] + prefix_m[D_positions[i]+1]\n            \n            cnt = end - start + 1\n            sum_m = solve.prefix_D_m[end+1] - solve.prefix_D_m[start]\n            total += cnt * prefix_m[c] - sum_m\n        res.append(total)\n    print('\\n'.join(map(str, res)))\n\nsolve()",
    "timestamp": "2025-08-13 13:20:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solveDMC(S, queries) {\n    const N = S.length;\n    const prefixD = new Array(N + 1).fill(0);\n    const prefixM = new Array(N + 1).fill(0);\n    const DIndices = [];\n    const MIndices = [];\n    const CIndices = [];\n    \n    for (let i = 0; i < N; i++) {\n        prefixD[i + 1] = prefixD[i] + (S[i] === 'D' ? 1 : 0);\n        prefixM[i + 1] = prefixM[i] + (S[i] === 'M' ? 1 : 0);\n        if (S[i] === 'D') DIndices.push(i);\n        else if (S[i] === 'M') MIndices.push(i);\n        else if (S[i] === 'C') CIndices.push(i);\n    }\n    \n    const results = [];\n    for (const k of queries) {\n        let count = 0;\n        for (const c of CIndices) {\n            const start = Math.max(0, c - k + 1);\n            const dCount = prefixD[c + 1] - prefixD[start];\n            const mCount = prefixM[c] - prefixM[start];\n            count += dCount * mCount;\n        }\n        results.push(count);\n    }\n    return results;\n}\n\n// Example usage:\n// const S = \"DMMDCDMCD\";\n// const queries = [3, 4, 5];\n// console.log(solveDMC(S, queries));",
    "timestamp": "2025-08-13 13:20:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nvector<int> calculateKDMCNumber(const string& S, const vector<int>& k_values) {\n    int N = S.length();\n    vector<int> result;\n\n    for (int k : k_values) {\n        if (k < 3) continue; // As per the problem, k_i >= 3\n\n        int k_dmc_count = 0;\n        for (int a = 0; a < N - 2; ++a) {\n            if (S[a] != 'D') continue;\n            for (int b = a + 1; b < N - 1; ++b) {\n                if (S[b] != 'M') continue;\n                for (int c = b + 1; c < N; ++c) {\n                    if (S[c] == 'C' && c - a < k) {\n                        k_dmc_count++;\n                    }\n                }\n            }\n        }\n        result.push_back(k_dmc_count);\n    }\n\n    return result;\n}\n\nint main() {\n    string S;\n    int q;\n    cin >> S >> q;\n\n    vector<int> k_values(q);\n    for (int i = 0; i < q; ++i) {\n        cin >> k_values[i];\n    }\n\n    vector<int> results = calculateKDMCNumber(S, k_values);\n    for (int count : results) {\n        cout << count << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:39:11"
  }
]