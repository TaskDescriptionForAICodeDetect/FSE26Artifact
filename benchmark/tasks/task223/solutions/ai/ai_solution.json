[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 100\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint bpm(int bpGraph[MAX][MAX], int u, int seen[], int matchR[], int redCount) {\n    for (int v = 0; v < redCount; v++) {\n        if (bpGraph[u][v] && !seen[v]) {\n            seen[v] = 1;\n            if (matchR[v] < 0 || bpm(bpGraph, matchR[v], seen, matchR, redCount)) {\n                matchR[v] = u;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nint maxBPM(int bpGraph[MAX][MAX], int blueCount, int redCount) {\n    int matchR[MAX];\n    memset(matchR, -1, sizeof(matchR));\n    int result = 0;\n    for (int u = 0; u < blueCount; u++) {\n        int seen[MAX];\n        memset(seen, 0, sizeof(seen));\n        if (bpm(bpGraph, u, seen, matchR, redCount))\n            result++;\n    }\n    return result;\n}\n\nint main() {\n    int dataset = 1;\n    while (1) {\n        int blueCount, redCount;\n        if (scanf(\"%d %d\", &blueCount, &redCount) != 2)\n            break;\n\n        int blue[MAX], red[MAX];\n        for (int i = 0; i < blueCount; i++)\n            scanf(\"%d\", &blue[i]);\n        for (int i = 0; i < redCount; i++)\n            scanf(\"%d\", &red[i]);\n\n        int bpGraph[MAX][MAX] = {0};\n        for (int i = 0; i < blueCount; i++) {\n            for (int j = 0; j < redCount; j++) {\n                if (gcd(blue[i], red[j]) > 1) {\n                    bpGraph[i][j] = 1;\n                }\n            }\n        }\n\n        printf(\"%d\\n\", maxBPM(bpGraph, blueCount, redCount));\n        dataset++;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:08:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CardPairing {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (scanner.hasNext()) {\n            int blueCount = scanner.nextInt();\n            int redCount = scanner.nextInt();\n            \n            if (blueCount == 0 && redCount == 0) break;\n            \n            int[] blueCards = new int[blueCount];\n            int[] redCards = new int[redCount];\n            \n            for (int i = 0; i < blueCount; i++) {\n                blueCards[i] = scanner.nextInt();\n            }\n            \n            for (int i = 0; i < redCount; i++) {\n                redCards[i] = scanner.nextInt();\n            }\n            \n            System.out.println(maximumPairs(blueCards, redCards));\n        }\n        \n        scanner.close();\n    }\n    \n    private static int maximumPairs(int[] blueCards, int[] redCards) {\n        int pairs = 0;\n        boolean[] blueUsed = new boolean[blueCards.length];\n        boolean[] redUsed = new boolean[redCards.length];\n        \n        for (int i = 0; i < blueCards.length; i++) {\n            for (int j = 0; j < redCards.length; j++) {\n                if (!blueUsed[i] && !redUsed[j] && shareCommonDivisor(blueCards[i], redCards[j])) {\n                    blueUsed[i] = true;\n                    redUsed[j] = true;\n                    pairs++;\n                    break;\n                }\n            }\n        }\n        \n        return pairs;\n    }\n    \n    private static boolean shareCommonDivisor(int a, int b) {\n        return gcd(a, b) > 1;\n    }\n    \n    private static int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}",
    "timestamp": "2025-08-05 19:08:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\nconst int MAX = 1000000;\nvector<int> primes;\nbool is_prime[MAX + 1];\nint prime_id[MAX + 1];\n\nvoid sieve() {\n    memset(is_prime, true, sizeof(is_prime));\n    is_prime[0] = is_prime[1] = false;\n    for (int i = 2; i <= MAX; ++i) {\n        if (is_prime[i]) {\n            prime_id[i] = primes.size();\n            primes.push_back(i);\n            for (int j = i * 2; j <= MAX; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n}\n\nvector<int> get_prime_factors(int x) {\n    vector<int> factors;\n    if (x == 1) return factors;\n    for (int p : primes) {\n        if (p * p > x) break;\n        if (x % p == 0) {\n            factors.push_back(p);\n            while (x % p == 0) x /= p;\n        }\n    }\n    if (x > 1) factors.push_back(x);\n    return factors;\n}\n\nstruct Edge {\n    int to, rev, cap;\n    Edge(int t, int r, int c) : to(t), rev(r), cap(c) {}\n};\n\nclass MaxFlow {\npublic:\n    vector<vector<Edge>> g;\n    vector<int> level, iter;\n    MaxFlow(int n) : g(n), level(n), iter(n) {}\n    void add_edge(int from, int to, int cap) {\n        g[from].emplace_back(to, g[to].size(), cap);\n        g[to].emplace_back(from, g[from].size() - 1, 0);\n    }\n    void bfs(int s) {\n        fill(level.begin(), level.end(), -1);\n        queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty()) {\n            int v = q.front(); q.pop();\n            for (Edge &e : g[v]) {\n                if (e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < g[v].size(); ++i) {\n            Edge &e = g[v][i];\n            if (e.cap > 0 && level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int max_flow(int s, int t) {\n        int flow = 0;\n        while (true) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            fill(iter.begin(), iter.end(), 0);\n            int f;\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n\nint main() {\n    sieve();\n    int B, R;\n    while (cin >> B >> R) {\n        vector<int> blue(B), red(R);\n        for (int i = 0; i < B; ++i) cin >> blue[i];\n        for (int i = 0; i < R; ++i) cin >> red[i];\n\n        vector<vector<int>> blue_factors(B);\n        vector<vector<int>> red_factors(R);\n        for (int i = 0; i < B; ++i) blue_factors[i] = get_prime_factors(blue[i]);\n        for (int i = 0; i < R; ++i) red_factors[i] = get_prime_factors(red[i]);\n\n        vector<int> prime_list;\n        for (int i = 0; i < B; ++i) for (int p : blue_factors[i]) prime_list.push_back(p);\n        for (int i = 0; i < R; ++i) for (int p : red_factors[i]) prime_list.push_back(p);\n        sort(prime_list.begin(), prime_list.end());\n        prime_list.erase(unique(prime_list.begin(), prime_list.end()), prime_list.end());\n        int num_primes = prime_list.size();\n\n        int s = B + R + num_primes;\n        int t = s + 1;\n        MaxFlow mf(t + 1);\n\n        for (int i = 0; i < B; ++i) {\n            mf.add_edge(s, i, 1);\n            for (int p : blue_factors[i]) {\n                int idx = lower_bound(prime_list.begin(), prime_list.end(), p) - prime_list.begin();\n                mf.add_edge(i, B + R + idx, 1);\n            }\n        }\n        for (int i = 0; i < R; ++i) {\n            mf.add_edge(B + i, t, 1);\n            for (int p : red_factors[i]) {\n                int idx = lower_bound(prime_list.begin(), prime_list.end(), p) - prime_list.begin();\n                mf.add_edge(B + R + idx, B + i, 1);\n            }\n        }\n\n        cout << mf.max_flow(s, t) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:09:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint max_matching(int blue[], int red[], int blue_count, int red_count) {\n    int matching[blue_count];\n    int used[red_count];\n    memset(matching, -1, sizeof(matching));\n    memset(used, 0, sizeof(used));\n    int match_count = 0;\n\n    for (int i = 0; i < blue_count; i++) {\n        int visited[red_count];\n        memset(visited, 0, sizeof(visited));\n\n        for (int j = 0; j < red_count; j++) {\n            if (!used[j] && gcd(blue[i], red[j]) > 1) {\n                matching[i] = j;\n                used[j] = 1;\n                match_count++;\n                break;\n            }\n        }\n    }\n\n    return match_count;\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n\n    while (datasets--) {\n        int blue_count, red_count;\n        scanf(\"%d %d\", &blue_count, &red_count);\n\n        int blue[blue_count];\n        int red[red_count];\n\n        for (int i = 0; i < blue_count; i++) {\n            scanf(\"%d\", &blue[i]);\n        }\n\n        for (int i = 0; i < red_count; i++) {\n            scanf(\"%d\", &red[i]);\n        }\n\n        int result = max_matching(blue, red, blue_count, red_count);\n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:09:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint gcd(int a, int b) {\n    while (b) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint maxMatching(vector<int>& blue, vector<int>& red) {\n    int m = blue.size(), n = red.size();\n    vector<vector<bool>> graph(m, vector<bool>(n, false));\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (gcd(blue[i], red[j]) > 1) {\n                graph[i][j] = true;\n            }\n        }\n    }\n    \n    vector<int> match(m, -1);\n    vector<bool> used(m, false);\n    \n    function<bool(int)> dfs = [&](int v) {\n        used[v] = true;\n        for (int u = 0; u < n; u++) {\n            if (graph[v][u]) {\n                if (match[v] == -1) {\n                    match[v] = u;\n                    return true;\n                }\n                \n                if (!used[match[v]]) {\n                    if (dfs(match[v])) {\n                        match[v] = u;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    };\n    \n    int result = 0;\n    for (int i = 0; i < m; i++) {\n        fill(used.begin(), used.end(), false);\n        if (dfs(i)) result++;\n    }\n    \n    return result;\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n    \n    while (datasets--) {\n        int b, r;\n        cin >> b >> r;\n        \n        vector<int> blue(b), red(r);\n        for (int i = 0; i < b; i++) cin >> blue[i];\n        for (int i = 0; i < r; i++) cin >> red[i];\n        \n        cout << maxMatching(blue, red) << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:10:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class CardPairing {\n    static class Edge {\n        int to, rev;\n        long cap;\n        Edge(int to, int rev, long cap) {\n            this.to = to;\n            this.rev = rev;\n            this.cap = cap;\n        }\n    }\n\n    static class Dinic {\n        int n;\n        List<Edge>[] g;\n        int[] level, iter;\n\n        Dinic(int n) {\n            this.n = n;\n            g = new List[n];\n            for (int i = 0; i < n; i++) g[i] = new ArrayList<>();\n            level = new int[n];\n            iter = new int[n];\n        }\n\n        void addEdge(int from, int to, long cap) {\n            g[from].add(new Edge(to, g[to].size(), cap));\n            g[to].add(new Edge(from, g[from].size() - 1, 0));\n        }\n\n        void bfs(int s) {\n            Arrays.fill(level, -1);\n            Queue<Integer> q = new LinkedList<>();\n            level[s] = 0;\n            q.add(s);\n            while (!q.isEmpty()) {\n                int v = q.poll();\n                for (Edge e : g[v]) {\n                    if (e.cap > 0 && level[e.to] < 0) {\n                        level[e.to] = level[v] + 1;\n                        q.add(e.to);\n                    }\n                }\n            }\n        }\n\n        long dfs(int v, int t, long f) {\n            if (v == t) return f;\n            for (; iter[v] < g[v].size(); iter[v]++) {\n                Edge e = g[v].get(iter[v]);\n                if (e.cap > 0 && level[v] < level[e.to]) {\n                    long d = dfs(e.to, t, Math.min(f, e.cap));\n                    if (d > 0) {\n                        e.cap -= d;\n                        g[e.to].get(e.rev).cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        long maxFlow(int s, int t) {\n            long flow = 0;\n            while (true) {\n                bfs(s);\n                if (level[t] < 0) return flow;\n                Arrays.fill(iter, 0);\n                long f;\n                while ((f = dfs(s, t, Long.MAX_VALUE)) > 0) {\n                    flow += f;\n                }\n            }\n        }\n    }\n\n    static long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        while ((line = br.readLine()) != null) {\n            StringTokenizer st = new StringTokenizer(line);\n            int m = Integer.parseInt(st.nextToken());\n            int n = Integer.parseInt(st.nextToken());\n            long[] blue = new long[m];\n            long[] red = new long[n];\n\n            st = new StringTokenizer(br.readLine());\n            for (int i = 0; i < m; i++) {\n                blue[i] = Long.parseLong(st.nextToken());\n            }\n\n            st = new StringTokenizer(br.readLine());\n            for (int i = 0; i < n; i++) {\n                red[i] = Long.parseLong(st.nextToken());\n            }\n\n            int s = m + n;\n            int t = s + 1;\n            Dinic dinic = new Dinic(t + 1);\n\n            for (int i = 0; i < m; i++) {\n                dinic.addEdge(s, i, 1);\n            }\n            for (int j = 0; j < n; j++) {\n                dinic.addEdge(m + j, t, 1);\n            }\n\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (gcd(blue[i], red[j]) > 1) {\n                        dinic.addEdge(i, m + j, 1);\n                    }\n                }\n            }\n\n            System.out.println(dinic.maxFlow(s, t));\n        }\n    }\n}",
    "timestamp": "2025-08-05 19:10:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef max_pairs_for_dataset(blue_cards, red_cards):\n    from collections import Counter\n    blue_count = Counter(blue_cards)\n    red_count = Counter(red_cards)\n    \n    pairs = 0\n    for blue_val in blue_count:\n        for red_val in red_count:\n            if gcd(blue_val, red_val) > 1:\n                possible_pairs = min(blue_count[blue_val], red_count[red_val])\n                pairs += possible_pairs\n                blue_count[blue_val] -= possible_pairs\n                red_count[red_val] -= possible_pairs\n                \n    return pairs\n\ndef max_pairs(card_sets):\n    results = []\n    for blue_cards, red_cards in card_sets:\n        results.append(max_pairs_for_dataset(blue_cards, red_cards))\n    return results\n\n# Example usage:\ncard_sets = [\n    ([2, 4, 8], [4, 8, 12]),  # Dataset 1\n    ([3, 6, 9], [9, 15, 18]), # Dataset 2\n]\n\nprint(max_pairs(card_sets))",
    "timestamp": "2025-08-13 02:49:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class CardPairing {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        \n        while ((line = br.readLine()) != null && !line.isEmpty()) {\n            String[] parts = line.split(\" \");\n            int blueCount = Integer.parseInt(parts[0]);\n            int redCount = Integer.parseInt(parts[1]);\n            \n            int[] blueCards = new int[blueCount];\n            int[] redCards = new int[redCount];\n            \n            String[] blueValues = br.readLine().split(\" \");\n            for (int i = 0; i < blueCount; i++) {\n                blueCards[i] = Integer.parseInt(blueValues[i]);\n            }\n            \n            String[] redValues = br.readLine().split(\" \");\n            for (int i = 0; i < redCount; i++) {\n                redCards[i] = Integer.parseInt(redValues[i]);\n            }\n            \n            System.out.println(maxPairs(blueCards, redCards));\n        }\n    }\n\n    private static int maxPairs(int[] blueCards, int[] redCards) {\n        boolean[] usedBlue = new boolean[blueCards.length];\n        boolean[] usedRed = new boolean[redCards.length];\n        int pairs = 0;\n\n        for (int i = 0; i < blueCards.length; i++) {\n            for (int j = 0; j < redCards.length; j++) {\n                if (!usedBlue[i] && !usedRed[j] && gcd(blueCards[i], redCards[j]) > 1) {\n                    pairs++;\n                    usedBlue[i] = true;\n                    usedRed[j] = true;\n                    break;\n                }\n            }\n        }\n\n        return pairs;\n    }\n\n    private static int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = a % b;\n            a = b;\n            b = temp;\n        }\n        return a;\n    }\n}",
    "timestamp": "2025-08-13 02:49:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NUM 10001\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint maxCardPairs(int *blue, int blueCount, int *red, int redCount) {\n    int pairs = 0;\n    int *usedRed = malloc(sizeof(int) * redCount);\n    for (int i = 0; i < redCount; ++i) {\n        usedRed[i] = 0;\n    }\n\n    for (int i = 0; i < blueCount; ++i) {\n        for (int j = 0; j < redCount; ++j) {\n            if (!usedRed[j] && gcd(blue[i], red[j]) > 1) {\n                pairs++;\n                usedRed[j] = 1;\n                break;\n            }\n        }\n    }\n\n    free(usedRed);\n    return pairs;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t--) {\n        int blueCount, redCount;\n        scanf(\"%d\", &blueCount);\n        int *blue = malloc(sizeof(int) * blueCount);\n        for (int i = 0; i < blueCount; ++i) {\n            scanf(\"%d\", &blue[i]);\n        }\n\n        scanf(\"%d\", &redCount);\n        int *red = malloc(sizeof(int) * redCount);\n        for (int i = 0; i < redCount; ++i) {\n            scanf(\"%d\", &red[i]);\n        }\n\n        printf(\"%d\\n\", maxCardPairs(blue, blueCount, red, redCount));\n\n        free(blue);\n        free(red);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 02:49:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef max_card_pairing(blue_cards, red_cards):\n    blue_graph = {}\n    red_graph = {}\n    \n    for i, blue in enumerate(blue_cards):\n        for j, red in enumerate(red_cards):\n            if gcd(blue, red) > 1:\n                blue_graph.setdefault(i, set()).add(j)\n                red_graph.setdefault(j, set()).add(i)\n    \n    blue_matched = [False] * len(blue_cards)\n    red_matched = [False] * len(red_cards)\n    match_count = 0\n    \n    def find_match(blue_idx):\n        for red_idx in blue_graph.get(blue_idx, []):\n            if not red_matched[red_idx]:\n                blue_matched[blue_idx] = True\n                red_matched[red_idx] = True\n                return True\n        \n        for red_idx in blue_graph.get(blue_idx, []):\n            for alt_blue_idx in red_graph.get(red_idx, []):\n                if not blue_matched[alt_blue_idx] and find_match(alt_blue_idx):\n                    blue_matched[blue_idx] = True\n                    red_matched[red_idx] = True\n                    return True\n        \n        return False\n    \n    for i in range(len(blue_cards)):\n        if not blue_matched[i]:\n            if find_match(i):\n                match_count += 1\n    \n    return match_count\n\ndef main():\n    while True:\n        try:\n            m, n = map(int, input().split())\n            blue_cards = list(map(int, input().split()))\n            red_cards = list(map(int, input().split()))\n            \n            print(max_card_pairing(blue_cards, red_cards))\n        except EOFError:\n            break\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:49:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport math\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    while ptr < len(input):\n        N = int(input[ptr])\n        M = int(input[ptr+1])\n        ptr +=2\n        blue = list(map(int, input[ptr:ptr+N]))\n        ptr +=N\n        red = list(map(int, input[ptr:ptr+M]))\n        ptr +=M\n        \n        # Build bipartite graph: blue nodes on left, red on right\n        # We can model this as a bipartite graph and find maximum bipartite matching\n        \n        # We can use Hopcroft-Karp algorithm for efficiency\n        \n        # Preprocess: for each blue and red, find edges (common divisor >1)\n        # Assign indices: blue 0..N-1, red 0..M-1\n        \n        # Build adjacency list\n        adj = [[] for _ in range(N)]\n        for i in range(N):\n            a = blue[i]\n            for j in range(M):\n                b = red[j]\n                if math.gcd(a, b) > 1:\n                    adj[i].append(j)\n        \n        # Hopcroft-Karp implementation\n        def max_matching():\n            pair_U = [-1] * N\n            pair_V = [-1] * M\n            dist = [0] * N\n            \n            def bfs():\n                queue = []\n                for u in range(N):\n                    if pair_U[u] == -1:\n                        dist[u] = 0\n                        queue.append(u)\n                    else:\n                        dist[u] = float('inf')\n                dist_null = float('inf')\n                while queue:\n                    u = queue.pop(0)\n                    if dist[u] < dist_null:\n                        for v in adj[u]:\n                            if pair_V[v] == -1:\n                                dist_null = dist[u] + 1\n                            elif dist[pair_V[v]] == float('inf'):\n                                dist[pair_V[v]] = dist[u] + 1\n                                queue.append(pair_V[v])\n                return dist_null != float('inf')\n            \n            def dfs(u):\n                for v in adj[u]:\n                    if pair_V[v] == -1 or (dist[pair_V[v]] == dist[u] + 1 and dfs(pair_V[v])):\n                        pair_U[u] = v\n                        pair_V[v] = u\n                        return True\n                dist[u] = float('inf')\n                return False\n            \n            matching = 0\n            while bfs():\n                for u in range(N):\n                    if pair_U[u] == -1:\n                        if dfs(u):\n                            matching +=1\n            return matching\n        \n        print(max_matching())\n\nsolve()",
    "timestamp": "2025-08-13 02:49:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nbool hasCommonDivisor(int a, int b) {\n    for (int i = 2; i <= std::min(a, b); ++i) {\n        if (a % i == 0 && b % i == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint maxPairs(const std::vector<int>& blueCards, const std::vector<int>& redCards) {\n    int maxBlue = blueCards.size();\n    int maxRed = redCards.size();\n    std::vector<std::vector<bool>> pairable(maxBlue, std::vector<bool>(maxRed, false));\n\n    for (int i = 0; i < maxBlue; ++i) {\n        for (int j = 0; j < maxRed; ++j) {\n            pairable[i][j] = hasCommonDivisor(blueCards[i], redCards[j]);\n        }\n    }\n\n    std::vector<int> blueMatch(maxBlue, -1);\n    std::vector<int> redMatch(maxRed, -1);\n\n    std::function<bool(int, std::vector<bool>&)> tryToMatch = [&](int blue, std::vector<bool>& visited) {\n        for (int red = 0; red < maxRed; ++red) {\n            if (pairable[blue][red] && !visited[red]) {\n                visited[red] = true;\n                if (redMatch[red] == -1 || tryToMatch(redMatch[red], visited)) {\n                    blueMatch[blue] = red;\n                    redMatch[red] = blue;\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    int maxPairs = 0;\n    for (int blue = 0; blue < maxBlue; ++blue) {\n        std::vector<bool> visited(maxRed, false);\n        if (tryToMatch(blue, visited))\n            ++maxPairs;\n    }\n\n    return maxPairs;\n}\n\nint main() {\n    int numDatasets;\n    std::cin >> numDatasets;\n\n    while (numDatasets--) {\n        int numBlueCards, numRedCards;\n        std::cin >> numBlueCards >> numRedCards;\n\n        std::vector<int> blueCards(numBlueCards);\n        std::vector<int> redCards(numRedCards);\n\n        for (int i = 0; i < numBlueCards; ++i) {\n            std::cin >> blueCards[i];\n        }\n\n        for (int i = 0; i < numRedCards; ++i) {\n            std::cin >> redCards[i];\n        }\n\n        int result = maxPairs(blueCards, redCards);\n        std::cout << result << std::endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:07:41"
  }
]