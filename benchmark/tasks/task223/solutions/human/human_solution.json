[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main extends App {\n\n  import scala.io.StdIn._\n\n  solve\n  def solve: Unit = {\n    val Array(m, n) = readLine.trim.split(' ').map(_.toInt)\n    if (m == 0) return\n    val blue = readWhile(m)\n    val red = readWhile(n)\n    println(new Dinic(m, n, blue.indices.flatMap{i ⇒ red.indices.withFilter(j ⇒ gcd(blue(i), red(j)) != 1).map{j ⇒ (i, j)}}.toArray).calMaxMatching)\n    solve\n  }\n  def readWhile(n: Int): Array[Int] = {\n    var count = n\n    var result = Nil: List[Array[Int]]\n    while (count > 0){\n      val line = readLine.trim.split(' ').map(_.toInt)\n      count -= line.length\n      result ::= line\n    }\n    result.flatten.toArray\n  }\n\n  implicit class Extend[T](value: T){\n    def also(func: T ⇒ Unit): T = {func(value); value}\n    def let[A](func: T ⇒ A): A = func(value)\n  }\n  def gcd(a: Int, b: Int): Int = {\n    b match {\n      case 0 ⇒ a\n      case _ ⇒ gcd(b, a % b)\n    }\n  }\n  def maxMatching(s: Int, t: Int, edges: Array[(Int, Int)]): Int = {\n    new Dinic(s, t, edges).calMaxMatching\n  }\n  private class Dinic(s: Int, t: Int, edges: Array[(Int, Int)]) {\n    val edge = Array.tabulate(s + t + 2){_ ⇒ ArrayBuffer[(Int, Int, Boolean)]()}\n    for (x ← 1 to s){\n      edge(x).append((0, edge(0).length, false))\n      edge(0).append((x, 0, true))\n    }\n    for (y ← (s + 1) to s + t){\n      edge(y).append((s + t + 1, edge(s + t + 1).length, true))\n      edge(s + t + 1).append((y, 0, false))\n    }\n    edges.foreach{\n      case (from, to) ⇒\n        edge(from + 1).append((to + s + 1, edge(to + s + 1).length, true))\n        edge(to + s + 1).append((from + 1, edge(from + 1).length - 1, false))\n    }\n    val levels = Array.tabulate(s + t + 2){_ ⇒ -1}\n    val dfsLast = Array.tabulate(s + t + 2){_ ⇒ 0}\n    def bfs: Unit = {\n      dfsLast.indices.foreach(i ⇒ dfsLast(i) = 0)\n      levels.indices.foreach(i ⇒ levels(i) = -1)\n      levels(0) = 0\n      val queue : mutable.Queue[Int]= mutable.Queue()\n      queue.enqueue(0)\n      while(queue.nonEmpty){\n        val top = queue.dequeue()\n        for ((to, _, b) ← edge(top) if b && levels(to) == -1) {\n          levels(to) = levels(top) + 1\n          queue.enqueue(to)\n        }\n      }\n    }\n    def dfs(from: Int): Boolean= {\n      if (from == s + t + 1) true\n      else {\n        var makePath = false\n        for (i ← dfsLast(from) until edge(from).length if  !makePath && edge(from)(i)._3) {\n          dfsLast(from) = i\n          val (to, j, _) = edge(from)(i)\n          if (levels(to) > levels(from) && dfs(to)) {\n            edge(from)(i) = (to, j, false)\n            edge(to)(j) = (from, i, true)\n            dfsLast(from) += 1\n            makePath = true\n          }\n        }\n        makePath\n      }\n    }\n    def calMaxMatching: Int = {\n      var count = 0\n      var canMatch = true\n      while (canMatch){\n        canMatch = false\n        bfs\n        if (levels.last != -1) {\n          canMatch = true\n          while (dfs(0)) {\n            count += 1\n          }\n        }\n      }\n      count\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdlib.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\nconst ll mod=1000000007;\nconst ll INF=1e15;\n#define REP(i,a,b) for(ll i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nstruct edge{ ll to; ll cap; ll rev;};\n\nconst ll MAXN=2000;\nvector<edge> G[MAXN];\n\nbool used[MAXN];\nll yaku(ll a, ll b){\n    if(a>b) return yaku(b,a);\n    else{\n        if(b%a==0) return a;\n        else return yaku(b%a,a);\n    }\n}\n\nvoid addEdge0(ll from, ll to, ll cap){\n    edge A={to,cap,(ll)G[to].size()};\n    edge B={from,0,(ll)G[from].size()};\n    G[from].push_back(A);\n    G[to].push_back(B);\n    return;\n}//有向グラフを作る\n\nvoid addEdge1(ll a, ll b, ll cap){\n    edge A={b,cap,(ll)G[b].size()};\n    edge B={a,cap,(ll)G[a].size()};\n    G[a].push_back(A);\n    G[b].push_back(B);\n    return;\n}//無向グラフを作る\n\nll dfs(ll v, ll t, ll f){\n    if(v==t) return f;\n    used[v]=true;\n    rep(i,G[v].size()){\n        edge &e=G[v][i];\n        if(!used[e.to] && e.cap>0){\n            ll d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll MaxFlow(ll Start, ll Goal){\n    ll ans=0;\n    while(true){\n        rep(i,MAXN) used[i]=false;\n        ll P=dfs(Start, Goal, INF);\n        if(P==0) break;\n        ans+=P;\n    }\n    return ans;\n}\n\nint main(){\n    vec A;\n    while(true){\n        ll M,N; cin>>M>>N;\n        if(M==0 && N==0) break;\n        rep(i,MAXN) G[i].clear();\n        vec r(M), b(N);\n        rep(i,M) cin>>r.at(i);\n        rep(i,N) cin>>b.at(i);\n        rep(i,M) addEdge0(1500,i,1);\n        rep(i,N) addEdge0(i+700,1501,1);\n        rep(i,M) rep(j,N){\n            if(yaku(r.at(i),b.at(j))>1) addEdge0(i,j+700,1);\n        }\n\n        A.push_back(MaxFlow(1500,1501));\n    }\n    rep(i,A.size()) cout<<A.at(i)<<endl;\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 4444\nvector<int> v[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int a,int b){\n\tv[a].PB(b);\n\tv[b].PB(a);\n}\n\nbool matchdfs(int a){\n\tused[a] = true;\n\tfor(int i = 0;i < v[a].size();i++)\t{\n\t\tint u = v[a][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w)){\n\t\t\tmatch[u] = a;\n\t\t\tmatch[a] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//二部マッチング\nint two_matching_max(int l){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<int> prime;\n#define HOGE 111111\nbool isp[111111];\nvoid f(){\n\tREP(i,111111)isp[i] = true;\n\tisp[0] = isp[1] = false;\n\tfor(int i = 2;i < 111111;i++){\n\t\tif(isp[i]){\n\t\t\tprime.PB(i);\n\t\t\tfor(int j = i;j < 111111;j+=i)isp[j] = false;\n\t\t}\n\t}\n}\n\t\n#define HALF 1000\nint main(){\n\tf();\n\tint n,m;\n\twhile(cin >> n >> m,n|m){\n\t\tREP(i,MAX_V)v[i].clear();\n\t\tvector<int> a(n);REP(i,n)cin >> a[i];\n\t\tvector<int> b(m);REP(i,m)cin >> b[i];\n\t\tREP(i,n){\n\t\t\tvector<int> tmp;\n\t\t\tREP(j,prime.size()){\n\t\t\t\tif(a[i] % prime[j] == 0)tmp.PB(prime[j]);\n\t\t\t}\n\t\t\tREP(j,m){\n\t\t\t\tREP(k,tmp.size()){\n\t\t\t\t\tif(b[j] % tmp[k] == 0){\n\t\t\t\t\t\tadd_edge(i,j + 1000);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << two_matching_max(MAX_V) << endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nstruct edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nclass Dinic{//max flow\npublic:\n    int n;\n    vector<vector<edge> >G;//[MAX];\n    vi level,iter;//[MAX];\n    Dinic(int size){\n        n=size;\n        G=vector<vector<edge> >(n);\n    }\n    void add_edge(int from, int to, int cap){\n        edge q={to,cap,int(G[to].size())};\n        G[from].push_back(q);\n        q={from,0,int(G[from].size()-1)};\n        G[to].push_back(q);\n    }\n    int getmaxflow(int s,int t) {//from s to t,ford_fulkerson\n        int flow=0;\n        while(1){\n            bfs(s);\n            if(level[t]<0)return flow;\n            iter=vi(n);\n            int f;\n            while((f=dfs(s,t,INF))>0)flow+=f;\n        }\n    }\nprivate:\n    void bfs(int s){\n        level=vi(n,-1);\n        queue<int>q;\n        level[s]=0;\n        q.push(s);\n        while(!q.empty()){\n            int v=q.front();q.pop();\n            for(int i=0;i<G[v].size();i++){\n                edge &e=G[v][i];\n                if(e.cap>0&&level[e.to]<0){\n                    level[e.to]=level[v]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t, int f) {\n        if(v==t)return f;\n        for(int &i=iter[v];i<G[v].size();i++){\n            edge &e=G[v][i];\n            if(level[v]>=level[e.to]||e.cap<=0) continue;\n            int d =dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n};\n\nlong long gcd(long long a, long long b) {return b ? gcd(b, a % b) : a;}\nlong long lcm(long long m, long long n ){if((0 == m )||( 0 == n ))return 0;\n    return ((m / gcd(m, n)) * n);\n}\nsigned main(){\n    int a,b;\n    while(cin>>a>>b,a+b){\n        Dinic hoge(a+b+2);\n        int source=a+b;\n        int sink=a+b+1;\n        vector<int>v(a);\n        vector<int>u(b);\n        rep(i,a)cin>>v[i];\n        rep(j,b)cin>>u[j];\n        rep(i,a)hoge.add_edge(source,i, 1);\n        rep(i,b)hoge.add_edge(i+a,sink, 1);\n        rep(i,a)rep(j,b){\n            if(gcd(v[i],u[j])!=1)hoge.add_edge(i, j+a, 1);\n        }\n        cout<<hoge.getmaxflow(source, sink)<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n#define SET(a,c) memset(a,c,sizeof(a))\n\n#define DEBUG(x) cout<<\"#x\"<<\": \"<<x<<endl\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nconst ll INF = INT_MAX/3;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-14;\nconst int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n\nstruct edge{ int to;int cap;int rev; };\nint m,n;\n\nvector<edge> G[2012];\nbool used[2012];\nint a[511],b[511];\n\nvoid add_edge(int from,int to){\n    G[from].PB( (edge){to,1,(int)G[to].size()} );\n    G[to].PB( (edge){from,0,(int)G[from].size()-1} );\n}\n\nint dfs(int v,int t,int f){\n    if( v == t) return f;\n    used[v] = true;\n    REP(i,G[v].size()){\n\tedge &e = G[v][i];\n\tif(!used[e.to] && e.cap > 0){\n\t    int d = dfs(e.to,t,min(f,e.cap));\n\t    if(d > 0){\n\t\te.cap -= d;\n\t\tG[e.to][e.rev].cap += d;\n\t\treturn d;\n\t    }\n\t}\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int flow = 0;\n    while(true){\n\tREP(i,m+n+2) used[i] = false;\n\tint f = dfs(s,t,INF);\n\tif(f == 0)return flow;\n\tflow += f;\n    }\n    return -1;\n}\n\nint gcd(int a,int b){ return a % b == 0 ? b : gcd(b,a%b); }\n\nint main(){\n\n    while(true){\n\tm,n;\n\tcin >> m >> n;\n\tif(m == 0 && n == 0) break;\n\tREP(i,n+m+2){\n\t    G[i].clear();\n\t}\n\tREP(i,n+m+2) used[i] = false;\n\tREP(i,m) {\n\t    cin >> a[i];\n\t    add_edge(0,i+1);\n\t}\n\tREP(i,n) {\n\t    cin >> b[i];\n\t    add_edge(i+1+m,n+m+1);\n\t}\n\tREP(i,m){\n\t    REP(j,n){\n\t\tif(gcd(a[i],b[j]) > 1){\n\t\t    add_edge(i+1,m+j+1);\n\t\t}\n\t    }\n\t}\n\tcout << max_flow(0,n+m+1) << endl;;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 999999\n#define MAX_V 10000\nusing namespace std;\n\ntypedef struct edge{\n  int to,cap,rev;\n}edge;\n\nint val[MAX_V];\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nbool gcd(int a,int b){\n  int r=a%b;\n  while(r>0){\n    a=b;\n    b=r;\n    r=a%b;\n  }\n  if(b!=1)return true;\n  else return false;\n}\n\nvoid makeG(int m,int n){\n  memset(G,0,sizeof(G));\n  int to;\n  for(int i=0;i<m+n;i++){\n    cin>>val[i];\n  }\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++){\n      if(gcd(val[i],val[m+j])==true){\n\tG[i].push_back((edge){m+j,1,G[m+j].size()});\n\tG[m+j].push_back((edge){i,0,G[i].size()-1});\n      }\n    }\n  }\n  val[m+n]=val[m+n+1]=1;\n  for(int i=0;i<m;i++){\n    G[m+n].push_back((edge){i,1,G[i].size()});\n    G[i].push_back((edge){m+n,0,G[i].size()-1});\n  }\n  for(int i=m;i<m+n;i++){\n    G[i].push_back((edge){m+n+1,1,G[m+n+1].size()});\n    G[m+n+1].push_back((edge){i,0,G[i].size()-1});\n  }\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f=dfs(s,t,INF);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint main(){\n  int m,n;\n  while(cin>>m>>n,n){\n    makeG(m,n);\n    cout << max_flow(m+n,m+n+1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\n//int gcd( int m, int n ){\n//\twhile( m != n ){\n//\t\tif ( m > n ) m = m - n;\n//\t\telse         n = n - m;\n//\t}\n//\treturn m;\n//}\n\nint gcd(int x, int y)\n{\n    int t;\n    if(x < y) swap(x, y);\n    while(y)\n        t = x % y, x = y, y = t;\n    return x;\n}\n\nint maximum_matching(int m, int n, int graph[1002][1002], int now ,int flag){\n    if(now==m+n)return 1;\n    if(now==m+n+1){\n        int sum=0;\n        for(int i=0; i<m; i++){\n            if(graph[now][i]==0)sum++;\n            else if(maximum_matching(m, n, graph, i, flag)==1)sum++;\n        }\n        return sum;\n    }\n    if(now<m){\n        for(int i=m; i<m+n; i++){\n            if(graph[now][i]==1){\n                if(maximum_matching(m, n, graph, i, flag)==1){\n                    graph[now][i]=0;\n                    graph[i][now]=1;\n                    return 1;\n                }\n            }\n        }\n        return 0;\n    }\n    if(m<=now&&now<m+n){\n        if(flag==0){\n            if(graph[now][m+n]==1){\n                graph[now][m+n]=0;\n                return 1;\n            }else{\n                for(int i=0; i<m; i++){\n                    if(graph[now][i]==1){\n                        if(maximum_matching(m, n, graph, i, 1)==1){\n                            graph[now][i]=0;\n                            //graph[i][now]=1;\n                            return 1;\n                        }\n                    }\n                }\n            }\n            return 0;\n        }else{\n            if(graph[now][m+n]==1){\n                graph[now][m+n]=0;\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n    }\n}\n\n\n\nint main(){\n    int m,n;\n    while(cin>>m>>n){\n                if(m==0&&n==0)break;\n        int b[500];\n        int r[500];\n        for(int i=0; i<m; i++)cin>>b[i];\n        for(int i=0; i<n; i++)cin>>r[i];\n                sort(b, b+m);\n        sort(r, r+n);\n                int graph[1002][1002]={0};\n        for(int i=0; i<m; i++){\n            for(int j=0; j<n; j++){\n                if(gcd(b[i],r[j])!=1)graph[i][m+j]=1;\n            }\n        }\n                for(int i=0; i<m; i++)graph[m+n+1][i]=1;//s-b\n        for(int i=0; i<n; i++)graph[m+i][m+n]=1;//r-t\n        \n\n        \n        for(int i=0; i<m; i++){\n            for(int j=0; j<n; j++){\n                if(graph[m+n+1][i]==1&&graph[i][j]==1&&graph[j][m+n]==1){\n                    graph[m+n+1][i]=0;\n                    graph[i][j]=0;\n                    graph[j][i]=1;\n                    graph[j][m+n]=0;\n                }\n            }\n        }\n        \n        \n        \n        int sum=maximum_matching(m, n, graph, m+n+1, 0);\n        //int sum=m;\n        //for(int i=0; i<m; i++)sum-=graph[m+n+1][i];\n        cout<<sum<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 2000000000 // 1e17\nusing namespace std;\n\n// calculate |gcd|.\n// if  ether num is 0, return 0\nlong long GCD(long long left, long long right) {\n  if(left == 0 || right == 0) return 0;\n  if(left < 0) left *= -1;\n  if(right < 0) right *= -1;\n  if(left < right) swap(left, right);\n  long long nextnum, ansgcd = -1;\n  while(ansgcd == -1) {\n    nextnum = left % right;\n    if(nextnum == 0) ansgcd = right;\n    left = right;\n    right = nextnum;\n  }\n  return ansgcd;\n}\n\nlong long LCM(long long left, long long right) {\n  return left / GCD(left, right) * right;\n}\n\n// 0-indexed\ntemplate <class T>\nstruct Dinic {\n  struct edge {\n    int to;\n    T cap;\n    int rev;\n  };\n  vector<vector<edge>> lst;\n  vector<int> completed;\n  vector<int> dist;\n  Dinic(int n = 1) {\n    // if 1-indexed\n    //++n;\n    lst.resize(n);\n    completed.resize(n);\n    dist.resize(n);\n  }\n  bool add(int start, int goal, T capacity) {\n    lst[start].push_back(\n        (edge){goal, capacity, (int)lst[goal].size()});\n    lst[goal].push_back(\n        (edge){start, 0, (int)lst[start].size() - 1});\n    return 1;\n  }\n  // dist = time from start to now number\n  void distbfs(int start) {\n    fill(dist.begin(), dist.end(), -1);\n    queue<int> bfsqu;\n    dist[start] = 0;\n    bfsqu.push(start);\n    while(bfsqu.size() > 0) {\n      int now = bfsqu.front();\n      bfsqu.pop();\n      for(int i = 0; i < lst[now].size(); ++i) {\n        edge* nowe = &lst[now][i];\n        if(nowe->cap > 0 && dist[nowe->to] < 0) {\n          dist[nowe->to] = dist[now] + 1;\n          bfsqu.push(nowe->to);\n        }\n      }\n    }\n  }\n  T pathdfs(int now, int goal, T nf) {\n    if(now == goal) return nf;\n    for(int& i = completed[now]; i < lst[now].size(); ++i) {\n      edge* e = &lst[now][i];\n      if(e->cap > 0 && dist[now] < dist[e->to]) {\n        T ans = pathdfs(e->to, goal, min(nf, e->cap));\n        if(ans > 0) {\n          e->cap -= ans;\n          lst[e->to][e->rev].cap += ans;\n          return ans;\n        }\n      }\n    }\n    return 0;\n  }\n  T solve(int start, int goal) {\n    T ans = 0, nf = 0;\n    while(1) {\n      // bfs\n      distbfs(start);\n      // cannnot go to goal from start\n      if(dist[goal] < 0) return ans;\n      // reset\n      fill(completed.begin(), completed.end(), 0);\n      while((nf = pathdfs(start, goal, inf)) > 0) ans += nf;\n    }\n    return -1;\n  }\n};\n\nint n, m;\nvector<int> b, r;\n\nint solve();\n\nint main() {\n  while(1) {\n    cin >> m >> n;\n    if(n + m == 0) break;\n    b.resize(m);\n    r.resize(n);\n    for(int i = 0; i < m; ++i) cin >> b[i];\n    for(int i = 0; i < n; ++i) cin >> r[i];\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nint solve() {\n  Dinic<int> din(n + m + 2);\n  for(int i = 0; i < n; ++i) din.add(n + m, i, 1);\n  for(int i = 0; i < m; ++i) din.add(i + n, n + m + 1, 1);\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < m; ++j)\n      if(GCD(b[j], r[i]) > 1) din.add(i, j + n, 1);\n  return din.solve(n + m, n + m + 1);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nint gcd(int a,int b){\n  if(b==0) return a;\n  return gcd(b,a%b);\n}\n\nclass BipartiteGraph {\nprivate:\n  int V;\n  vector<int>* G;\n  int* match;\n  bool* used;\npublic:\n  BipartiteGraph(int n){\n    V = n;\n    match = new int[n];\n    used = new bool[n];\n    G = new vector<int>[n];\n  }\n\n  ~BipartiteGraph(){\n    delete[] match;\n    delete[] used;\n    delete[] G;\n  }\n\n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  bool dfs(int v){\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++){\n      int u = G[v][i];\n      int w = match[u];\n      if(w < 0 || (!used[w] && dfs(w))){\n\tmatch[v] = u;\n\tmatch[u] = v;\n\treturn true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching() {\n    int res = 0;\n    fill(match,match+V,-1);\n    for(int v=0; v < V;v++){\n      if(match[v] < 0){\n\tfill(used,used+V,false);\n\tif(dfs(v)){\n\t  res++;\n\t}\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int total_blue_cards;\n  int total_red_cards;\n  while(~scanf(\"%d %d\",&total_blue_cards,&total_red_cards)){\n    if(total_blue_cards == 0 && total_red_cards == 0) break;\n\n    int red_cards[501];\n    int blue_cards[501];\n\n    for(int blue_card_idx = 0; blue_card_idx < total_blue_cards; blue_card_idx++){\n      int num;\n      scanf(\"%d\",&num);\n      blue_cards[blue_card_idx] = num;\n    }\n    for(int red_card_idx = 0; red_card_idx < total_red_cards; red_card_idx++){\n      int num;\n      scanf(\"%d\",&num);\n      red_cards[red_card_idx] = num;\n    }\n\n    BipartiteGraph bg(total_blue_cards + total_red_cards);\n    for(int blue_card_idx = 0; blue_card_idx < total_blue_cards; blue_card_idx++){\n      for(int red_card_idx = 0; red_card_idx < total_red_cards; red_card_idx++){\n\tint div = gcd(blue_cards[blue_card_idx],red_cards[red_card_idx]);\n\tif(div != 1){\n\t  bg.add_edge(blue_card_idx,total_blue_cards+red_card_idx);\n\t}\n      }\n    }\n\n    printf(\"%d\\n\",bg.bipartite_matching());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing ll = long long;\nconstexpr ll INF = numeric_limits<ll>::max() / 100;\n\nclass Flow\n{\npublic:\n    using T = ll;\n    struct Edge {\n        Edge(const int from_, const int to_, const int reverse_, const T capacity_, bool is_reverse = false) : from{from_}, to{to_}, reverse{reverse_}, capacity{capacity_}, flow{0}, is_reverse(is_reverse) {}\n        int from;\n        int to;\n        int reverse;\n        T capacity;\n        T flow;\n        bool is_reverse;\n    };\n\n    Flow(const int v) : V{v}\n    {\n        edge.resize(v);\n    }\n    void addEdge(const int from, const int to, const T capacity)\n    {\n        edge[from].push_back(Edge{from, to, (int)edge[to].size(), capacity, false});\n        edge[to].push_back(Edge{to, from, (int)edge[from].size() - 1, 0, true});\n    }\n\n    T FordFulkerson(const int s, const int t)\n    {\n        vector<bool> checked(V);\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < V; i++) {\n                checked[i] = false;\n            }\n            const T f = dfs_ff(s, t, INF, checked);\n            if (f == 0) {\n                break;\n            }\n            flow += f;\n        }\n        return flow;\n    }\n\n    const int V;\n    vector<vector<Edge>> edge;\n\nprivate:\n    T dfs_ff(const int pos, const int t, const T flow, vector<bool>& checked)\n    {\n        if (pos == t) {\n            return flow;\n        }\n        checked[pos] = true;\n        for (auto& e : edge[pos]) {\n            if (not checked[e.to]) {\n                const T res = e.capacity - e.flow;\n                if (res > 0) {\n                    const T d = dfs_ff(e.to, t, min(flow, res), checked);\n                    if (d > 0) {\n                        e.flow += min(d, res);\n                        edge[e.to][e.reverse].flow -= min(d, res);\n                        return d;\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n};\n\ntemplate <typename T>\nT gcd(const T a, const T b)\n{\n    return (b != 0) ? gcd(b, a % b) : a;\n}\n\n\nint main()\n{\n    while (true) {\n        int m, n;\n        cin >> m >> n;\n        if (m == 0 and n == 0) {\n            break;\n        }\n        Flow flow(m + n + 2);\n        vector<ll> b(m);\n        for (int i = 0; i < m; i++) {\n            flow.addEdge(m + n, i, 1);\n            cin >> b[i];\n        }\n        vector<ll> r(m);\n        for (int i = 0; i < n; i++) {\n            flow.addEdge(i + m, m + n + 1, 1);\n            cin >> r[i];\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (gcd(b[i], r[j]) > 1) {\n                    flow.addEdge(i, m + j, 1);\n                }\n            }\n        }\n        cout << flow.FordFulkerson(m + n, m + n + 1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Hopcroft-Karp の最大二部マッチング\n//\n// verified\n//   AOJ 1163 カードゲーム\n//     http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1163&lang=jp\n//\n\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n\nstruct HopcroftKarp {\n    int sizeL, sizeR;\n    vector<vector<int> > list; // left to right\n    \n    // result\n    vector<bool> seen, matched;\n    vector<int> level, matching;\n\n    // base\n    HopcroftKarp(int l, int r) : sizeL(l), sizeR(r), list(l, vector<int>()) { }\n    inline vector<int>& operator [] (int i) { return list[i]; }\n    inline void addedge(int from, int to) { list[from].push_back(to); }\n    inline friend ostream& operator << (ostream& s, const HopcroftKarp& G) {\n        s << endl;\n        for (int i = 0; i < G.list.size(); ++i) {\n            s << i << \" : \";\n            for (int j = 0; j < G.list[i].size(); ++j) {\n                s << G.list[i][j];\n                if (j + 1 != G.list[i].size()) s << \", \";\n            }\n            s << endl;\n        }\n        return s;\n    }\n    \n    // methods\n    void hobfs() {\n        queue<int> que;\n        for (int left = 0; left < sizeL; ++left) {\n            level[left] = -1;\n            if (!matched[left]) {\n                que.push(left);\n                level[left] = 0;\n            }\n        }\n        level[sizeL] = sizeL;\n        while (!que.empty()) {\n            int left = que.front();\n            que.pop();\n            for (int i = 0; i < list[left].size(); ++i) {\n                int right = list[left][i];\n                int next = matching[right];\n                if (level[next] == -1) {\n                    level[next] = level[left] + 1;\n                    que.push(next);\n                }\n            }\n        }\n    }\n    bool hodfs(int left) {\n        if (left == sizeL) return true;\n        if (seen[left]) return false;\n        seen[left] = true;\n        for (int i = 0; i < list[left].size(); ++i) {\n            int right = list[left][i];\n            int next = matching[right];\n            if (level[next] > level[left] && hodfs(next)) {\n                matching[right] = left;\n                return true;\n            }\n        }\n        return false;\n    }\n    int solve() {\n        seen.assign(sizeL, false);\n        matched.assign(sizeL, false);\n        level.assign(sizeL+1, -1);\n        matching.assign(sizeR, sizeL);\n        int res = 0;\n        while (true) {\n            hobfs();\n            seen.assign(sizeL, false);\n            bool finished = true;\n            for (int left = 0; left < sizeL; ++left) {\n                if (!matched[left] && hodfs(left)) {\n                    matched[left] = true;\n                    ++res;\n                    finished = false;\n                }\n            }\n            if (finished) break;\n        }\n        return res;\n    }\n};\n\n\nint GCD(int a, int b) { return b ? GCD(b, a%b) : a; }\n\nint main() {\n    int N, M;\n    while (cin >> N >> M, N) {\n        HopcroftKarp G(N, M);\n        vector<int> left(N), right(M);\n        for (int i = 0; i < N; ++i) cin >> left[i];\n        for (int i = 0; i < M; ++i) cin >> right[i];\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < M; ++j) {\n                if (GCD(left[i], right[j]) > 1)\n                    G.addedge(i, j);\n            }\n        }\n        cout << G.solve() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint gcd(int a,int b)\n{\n\treturn b?gcd(b,a%b):a;\n}\n\nstruct Edge{\n\tint src,dst;\n\tEdge(){}\n\tEdge(int s,int d):src(s),dst(d){}\n};\ntypedef vector<vector<Edge> > Graph;\n\nbool BFS(const Graph& g,const vi& side,const vi& match,vi& level)\n{\n\tint n=g.size();\n\tlevel.assign(n,n);\n\tqueue<pii> q;\n\trep(i,n) if(side[i]==0 && match[i]==-1)\n\t\tq.push(mp(i,0));\n\tbool res=false;\n\twhile(!q.empty()){\n\t\tpii cur=q.front(); q.pop();\n\t\tint u=cur.first,l=cur.second;\n\t\tif(level[u]<=l) continue;\n\t\tlevel[u]=l;\n\t\trep(i,g[u].size()){\n\t\t\tint v=g[u][i].dst;\n\t\t\tif(match[v]==-1)\n\t\t\t\tres=true;\n\t\t\telse\n\t\t\t\tq.push(mp(match[v],l+2));\n\t\t}\n\t}\n\treturn res;\n}\n\nbool DFS(const Graph& g,const vi& side,int u,vi& match,vi& level)\n{\n\trep(i,g[u].size()){\n\t\tint v=g[u][i].dst;\n\t\tif(match[v]==-1 || level[match[v]]>level[u] && DFS(g,side,match[v],match,level)){\n\t\t\tmatch[u]=v;\n\t\t\tmatch[v]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\tlevel[u]=-1;\n\treturn false;\n}\n\nint HopcroftKarp(const Graph& g,const vi& side,vi& match)\n{\n\tint n=g.size();\n\tmatch.assign(n,-1);\n\tint res=0;\n\tfor(vi level;BFS(g,side,match,level);)\n\t\trep(i,n) if(side[i]==0 && match[i]==-1)\n\t\t\tres+=DFS(g,side,i,match,level);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int m,n;scanf(\"%d%d\",&m,&n),m|n;){\n\t\tvi bs(m),rs(n);\n\t\trep(i,m) scanf(\"%d\",&bs[i]);\n\t\trep(i,n) scanf(\"%d\",&rs[i]);\n\t\t\n\t\tGraph g(m+n);\n\t\trep(i,m) rep(j,n) if(gcd(bs[i],rs[j])>1){\n\t\t\tg[i].push_back(Edge(i,m+j));\n\t\t\tg[m+j].push_back(Edge(m+j,i));\n\t\t}\n\t\t\n\t\tvi side(m+n),match;\n\t\tfill(m+all(side),1);\n\t\tprintf(\"%d\\n\",HopcroftKarp(g,side,match));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconstexpr int MAX_V = 1014;\nconstexpr int INF = 100000;\n\nstruct Edge{\n    Edge(int t, int c, int r) \n    : to(t), cap(c), rev(r) {}\n\n    int to;\n    int cap;\n    int rev;\n};\n\nvector<Edge> G[MAX_V];\nbool used[MAX_V];\nbool can[MAX_V][MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back(Edge(to, cap, G[to].size()));\n    G[to].push_back(Edge(from, 0, G[from].size() - 1));\n}\n\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++){\n        Edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f,e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    while (1){\n        fill(used, used+MAX_V, 0);\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\nint gcd(int m, int n){\n    if (n == 0 || m == 0) return 0;\n\n    if (m < n) swap(m, n);\n    while (int r = m % n){\n        m = n;\n        n = r;\n    }\n    return n;\n}\n\nint main(int argc, char const *argv[]){\n    int m, n;\n\n    while (cin>>m>>n, m||n){\n        int s = m + n;\n        int t = s + 1;\n        int blue[500] = {};\n        int red[500] = {};\n\n        for (int i = 0; i < m; i++){\n            cin>>blue[i];\n            add_edge(s, i, 1);\n        }\n\n        for (int i = 0; i < n; i++){\n            cin>>red[i];\n            add_edge(m+i, t, 1);\n        }\n\n        for (int i = 0; i < m; i++){\n            for (int j = 0; j < n; j++){\n                if (gcd(blue[i], red[j]) > 1){\n                    can[i][j] = true;\n                }\n            }\n        }\n\n        for (int i = 0; i < m; i++){\n            for (int j = 0; j < n; j++){\n                if (can[i][j]){\n                    add_edge(i, m + j, 1);\n                }\n            }\n        }\n\n        cout<<max_flow(s, t)<<endl;\n\n        for (int i = 0; i < MAX_V; i++){\n            G[i].clear();\n            fill(can[i], can[i]+MAX_V, false);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long int ll;\n\nstruct Edge{\n\tint to,cap,rev;\n\tEdge(){}\n\tEdge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n};\n\nvector<Edge> G[1100];\nbool used[1100];\n\nvoid add_edge(int from,int to,int cap){\n\tG[from].push_back(Edge(to,cap,G[to].size()));\n\tG[to].push_back(Edge(from,0,G[from].size()-1));\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t) return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tEdge &e =G[v][i];\n\t\tif(!used[e.to]&&e.cap>0){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tfor(int i=0;i<1100;i++){\n\t\t\tused[i]=0;\n\t\t}\n\t\tint f=dfs(s,t,1e9);\n\t\tif(f==0)return flow;\n\t\tflow+=f;\n\t}\n}\n\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\n\nint main(){\n\twhile(1){\n\t\tint n,m; cin >> n >> m;\n\t\tif(n==0&&m==0)break;\n\t\tvector<ll> b(n),r(m);\n\t\tfor(int i=0;i<1100;i++){\n\t\t\tG[i].clear();\n\t\t\tused[i]=0;\n\t\t}\n\t\tint sv=0; int tv=1001;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> b[i];\n\t\t\tadd_edge(sv,i+1,1);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> r[i];\n\t\t\tadd_edge(501+i,tv,1);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(GCD(b[i],r[j])!=1){\n\t\t\t\t\tadd_edge(i+1,j+501,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << max_flow(sv,tv) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint gcd(int a,int b){\n\tif(a<b) swap(a,b);\n\tif(a%b == 0) return b;\n\telse return gcd(b,a%b);\n}\nint m,n;\nbool c[500][500],v[500];\nint b[500],r[500],p[500];\nbool match(int bc){\n\tif(bc < 0) return true;\n\tfor(int i = 0; i < n; ++i){\n\t\tif(!c[bc][i] || v[i]) continue;\n\t\tv[i] = true;\n\t\tif(match(p[i])){\n\t\t\tp[i] = bc;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\twhile(cin>>m>>n,n){\n\t\tfor(int i = 0; i < m; ++i) cin >> b[i];\n\t\tfor(int i = 0; i < n; ++i) cin >> r[i];\n\t\tfor(int i = 0; i < m; ++i)for(int j = 0; j < n; ++j){\n\t\t\tc[i][j] = gcd(b[i],r[j]) > 1;\n\t\t}\n\t\tfor(int i = 0; i < n; ++i)p[i] = -1;\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tfor(int j = 0; j < n; ++j)v[j] = 0;\n\t\t\tif(match(i)) ++ans;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\nstruct edge {int to,w,p;};\nint n,m,k,used[1002],a,b,c,cnt,A[1002];\nvector<edge> v[1002];\nint dfs(int s,int t,int r){\n    if(s==t)return r;\n    used[s]=1;\n    for(int i=0;i<v[s].size();i++){\n        edge &u=v[s][i];\n        if(used[u.to]==0&&u.w>0){\n            int F=dfs(u.to,t,min(r,u.w));\n            if(F>0){\n                u.w-=F;v[u.to][u.p].w+=F;return F;\n            }\n        }\n    }\n    return 0;\n}\nint f(int a,int b){\n    if(b==0)return a;\n    return f(b,a%b);\n}\nint main(void){\n    while(1){\n    cin>>n>>m;\n    if(n==0&&m==0)return 0;\n    for(int i=0;i<1002;i++){\n        A[i]=0;\n        v[i]={};\n    }\n    for(int i=0;i<n;i++){\n        cin>>A[i];\n        a=1000,b=i;\n        edge p={b,1,(int)v[b].size()};v[a].push_back(p);\n        edge q={a,0,(int)v[a].size()-1};v[b].push_back(q);\n    }\n    for(int i=500;i<500+m;i++){\n        cin>>A[i];\n        a=i,b=1001;\n        edge p={b,1,(int)v[b].size()};v[a].push_back(p);\n        edge q={a,0,(int)v[a].size()-1};v[b].push_back(q);\n    }\n    for(int i=0;i<n;i++){\n        for(int j=500;j<500+m;j++){\n            if(f(A[i],A[j])>1){\n                a=i,b=j;\n                edge p={b,1,(int)v[b].size()};v[a].push_back(p);\n                edge q={a,0,(int)v[a].size()-1};v[b].push_back(q);\n            }\n        }\n    }\n    int res=0;\n    while(1){\n        for(int i=0;i<1002;i++)used[i]=0;\n        int P=dfs(1000,1001,1e9);\n        if(P==0)break;\n        res++;\n    }\n    cout<<res<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef long double ld;\ntypedef vector<ld> vd;\ntypedef bool bl;\ntypedef vector<bl> vb;\ntypedef unordered_map<ll,unordered_map<ll,ll>> graph;\n\nconst ll e5 = 1 << 20;\nconst ll mod = 1000000007;\nconst ll e3 = 1 << 13;\nconst ll INF = 1ll << 60;\n\nll n,m;\ngraph g;\ngraph r;\nll s,t;\nll vis[e5];\nll level[e5];\nll idx;\nll ans = 0;\nvl anss;\n\nvoid bfs(){\n  queue<vl> q;\n  q.push(vl({s,0}));\n  vis[s]++;\n  while(!q.empty()){\n    vl p = q.front();\n    q.pop();\n    ll x = p[0];\n    ll l = p[1];\n    level[x] = l;\n    for(auto y : g[x]){\n      if(vis[y.first] == 1) continue;\n      if(y.second == 0) continue;\n      vis[y.first]++;\n      q.push(vl({y.first,l+1}));\n    }\n    for(auto y : r[x]){\n      if(vis[y.first] == 1) continue;\n      if(y.second == 0) continue;\n      vis[y.first]++;\n      q.push(vl({y.first,l+1}));\n    }\n\n  }\n}\n\nll dfs(ll x,ll c){\n  vis[x]++;\n  if(x == t) return c;\n  for(auto y : g[x]){\n    if(vis[y.first] == 1) continue;\n    if(y.second == 0) continue;\n    if(level[y.first] <= level[x]) continue;\n    ll z = dfs(y.first, min(c,y.second));\n    if(z > 0){\n      g[x][y.first] -= z;\n      r[y.first][x] += z;\n      return z;\n    }\n  }\n  for(auto y : r[x]){\n    if(vis[y.first] == 1) continue;\n    if(y.second == 0) continue;\n    if(level[y.first] <= level[x]) continue;\n    ll z = dfs(y.first, min(c,y.second));\n    if(z > 0){\n      r[x][y.first] -= z;\n      g[y.first][x] += z;\n      return z;\n    }\n  }\n  return 0;\n}\n\nll gcd(ll a,ll b){\n  while(a > 0){\n    b = b%a;\n    swap(a,b);\n  }\n  return b;\n}\n\nint main(){\n  while(true){\n    cin >> n >> m;\n    if(n == 0 && m == 0) break;\n    vl b(n+1);\n    vl c(m+1);\n    for(ll i = 1;i <= n;i++) cin >> b[i];\n    for(ll j = 1;j <= m;j++) cin >> c[j];\n    g = graph();\n    r = graph();\n    s = 0;\n    t = n+m+1;\n    ans = 0;\n    for(ll i = 1;i <= n;i++){\n      for(ll j = 1;j <= m;j++){\n        if(gcd(b[i],c[j]) > 1){\n          g[i][n+j] = 1;\n          r[n+j][i] = 0;\n        }\n      }\n    }\n    for(ll i = 1;i <= n;i++){\n      g[s][i] = 1;\n      r[i][s] = 0;\n    }\n    for(ll j = 1;j <= m;j++){\n      g[n+j][t] = 1;\n      r[t][n+j] = 0;\n    }\n    idx = t;\n    for(;;){\n      fill(vis,vis+(idx+1),0ll);\n      fill(level,level+(idx+1),-1ll);\n      bfs();\n      // for(ll i = 0;i <= t;i++) cerr << level[i] << \" \";\n      // cerr << endl;\n      if(level[t] < 0) break;\n      for(;;){\n        fill(vis,vis+(idx+1),0ll);\n        ll z = dfs(s, INF);\n        // cerr << \" \" << z << endl;\n        if(z <= 0) break;\n        ans += z;\n      }\n\n    }\n    cout << ans << endl;\n  }\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n\nusing namespace std;\nusing ll = long long;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\n\nclass Flow\n{\npublic:\n    using T = ll;\n    struct Edge {\n        Edge(const int from_, const int to_, const int reverse_, const T capacity_, bool is_reverse = false) : from{from_}, to{to_}, reverse{reverse_}, capacity{capacity_}, flow{0}, is_reverse(is_reverse) {}\n        int from;\n        int to;\n        int reverse;\n        T capacity;\n        T flow;\n        bool is_reverse;\n    };\n\n    Flow(const int v) : V{v}\n    {\n        edge.resize(v);\n    }\n    void addEdge(const int from, const int to, const T capacity)\n    {\n        edge[from].push_back(Edge{from, to, (int)edge[to].size(), capacity, false});\n        edge[to].push_back(Edge{to, from, (int)edge[from].size() - 1, 0, true});\n    }\n\n    T FordFulkerson(const int s, const int t)\n    {\n        vector<bool> checked(V);\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < V; i++) {\n                checked[i] = false;\n            }\n            const T f = dfs_ff(s, t, INF<T>, checked);\n            if (f == 0) {\n                break;\n            }\n            flow += f;\n        }\n        return flow;\n    }\n\n    const int V;\n    vector<vector<Edge>> edge;\n\nprivate:\n    T dfs_ff(const int pos, const int t, const T flow, vector<bool>& checked)\n    {\n        if (pos == t) {\n            return flow;\n        }\n        checked[pos] = true;\n        for (auto& e : edge[pos]) {\n            if (not checked[e.to]) {\n                const T res = e.capacity - e.flow;\n                if (res > 0) {\n                    const T d = dfs_ff(e.to, t, min(flow, res), checked);\n                    if (d > 0) {\n                        e.flow += min(d, res);\n                        edge[e.to][e.reverse].flow -= min(d, res);\n                        return d;\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n};\n\ntemplate <typename T>\nT gcd(const T a, const T b)\n{\n    return (b != 0) ? gcd(b, a % b) : a;\n}\n\n\nint main()\n{\n    while (true) {\n        int m, n;\n        cin >> m >> n;\n        if (m == 0 and n == 0) {\n            break;\n        }\n        Flow flow(m + n + 2);\n        vector<ll> b(m);\n        for (int i = 0; i < m; i++) {\n            flow.addEdge(m + n, i, 1);\n            cin >> b[i];\n        }\n        vector<ll> r(m);\n        for (int i = 0; i < n; i++) {\n            flow.addEdge(i + m, m + n + 1, 1);\n            cin >> r[i];\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (gcd(b[i], r[j]) > 1) {\n                    flow.addEdge(i, m + j, 1);\n                }\n            }\n        }\n        cout << flow.FordFulkerson(m + n, m + n + 1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint gcd(int a,int b)\n{\n\treturn b?gcd(b,a%b):a;\n}\n\nstruct Edge{\n\tint src,dst;\n\tEdge(){}\n\tEdge(int s,int d):src(s),dst(d){}\n};\ntypedef vector<vector<Edge> > Graph;\n\nbool BFS(const Graph& g,int left,const vi& match,vi& level)\n{\n\tint n=g.size();\n\tlevel.assign(n,n);\n\tqueue<pii> q;\n\trep(i,left) if(match[i]==-1)\n\t\tq.push(mp(i,0));\n\tbool res=false;\n\twhile(!q.empty()){\n\t\tpii cur=q.front(); q.pop();\n\t\tint u=cur.first,l=cur.second;\n\t\tif(level[u]<=l) continue;\n\t\tlevel[u]=l;\n\t\trep(i,g[u].size()){\n\t\t\tint v=g[u][i].dst;\n\t\t\tif(match[v]==-1)\n\t\t\t\tres=true;\n\t\t\telse\n\t\t\t\tq.push(mp(match[v],l+2));\n\t\t}\n\t}\n\treturn res;\n}\n\nbool DFS(const Graph& g,int left,int u,vi& vis,vi& match,vi& level)\n{\n\trep(i,g[u].size()){\n\t\tint v=g[u][i].dst;\n\t\tif(vis[v]) continue;\n\t\tvis[v]=1;\n\t\tif(match[v]==-1 || level[v]>level[u] && DFS(g,left,match[v],vis,match,level)){\n\t\t\tmatch[u]=v;\n\t\t\tmatch[v]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint HopcroftKarp(const Graph& g,int left,vi& match)\n{\n\tint n=g.size();\n\tmatch.assign(n,-1);\n\tint res=0;\n\tfor(vi level;BFS(g,left,match,level);)\n\t\trep(i,left) if(match[i]==-1){\n\t\t\tvi vis(n);\n\t\t\tres+=DFS(g,left,i,vis,match,level);\n\t\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int m,n;scanf(\"%d%d\",&m,&n),m|n;){\n\t\tvi bs(m),rs(n);\n\t\trep(i,m) scanf(\"%d\",&bs[i]);\n\t\trep(i,n) scanf(\"%d\",&rs[i]);\n\t\t\n\t\tGraph g(m+n);\n\t\trep(i,m) rep(j,n) if(gcd(bs[i],rs[j])>1){\n\t\t\tg[i].push_back(Edge(i,m+j));\n\t\t\tg[m+j].push_back(Edge(m+j,i));\n\t\t}\n\t\t\n\t\tvi match;\n\t\tprintf(\"%d\\n\",HopcroftKarp(g,m,match));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V;\nvector<int> G[1200];\nint match[1200];\nbool used[1200];\n\nvoid add_edge(int u, int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n\treturn;\n}\n\nbool dfs(int v){\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; v++){\n\t\tif (match[v] < 0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int x, int y) {\n\tif (y == 0) return x;\n\treturn gcd(y, x%y);\n}\n\nint main(void){\n\n\tint m, n;\n\n\twhile (cin >> m >> n, m, n){\n\t\tvector<int> mcard, ncard;\n\n\t\tV = m + n;\n\t\tfor (int i = 0; i < m + n; i++){\n\t\t\tG[i].clear();\n\t\t\tmatch[i] = 0;\n\t\t\tused[i] = false;\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint buff; cin >> buff;\n\t\t\tmcard.push_back(buff);\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint buff; cin >> buff;\n\t\t\tncard.push_back(buff);\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (gcd(mcard[i], ncard[j]) > 1) add_edge(i, m + j);\n\t\t\t}\n\t\t}\n\n\t\tcout << bipartite_matching() << endl;\n\n\n\t}\n\n\treturn 0;\n}\n\n/*\nfor(i=0;i<N;i++){\ncin >> X[i];\n}\n\n\nfor(i=0;i<N;i++){\nfor(j=0;j<N;j++){\ncin >> X[i][j];\n}\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, rev;\n};\n\nvector< vector<Edge> > G;\nbool used[2000];\n\nvoid addEdge(int from, int to, int cap) {\n\tG[from].push_back({to, cap, G[to].size()});\n\tG[to].push_back({from, 0, G[from].size()-1});\n}\n\nint dfs(int v, int t, int f) {\n\tif (v == t) return f;\n\tused[v] = true;\n\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n#define INF 1e9\n\nint max_flow(int s, int t) {\n\tint flow = 0;\n\twhile (1) {\n\t\tmemset(used, false, sizeof(used));\n\t\tint f = dfs(s, t, INF);\n\t\tif (f == 0) break;\n\t\tflow += f;\n\t}\n\treturn flow;\n}\n\nint gcd(int a, int b) {\n\treturn b == 0 ? a : gcd(b, a%b);\n}\n\nint main() {\n\tint M, N;\n\twhile (cin >> M >> N, M || N) {\n\t\tG.clear(); G.resize(N+M+2);\n\n\t\tvector<int> a(M);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tcin >> a[i];\n\t\t}\n\t\tvector<int> b(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> b[i];\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (gcd(a[i], b[j]) > 1) {\n\t\t\t\t\taddEdge(i, M+j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\taddEdge(M+N, i, 1);\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\taddEdge(M+i, M+N+1, 1);\n\t\t}\n\t\tcout << max_flow(N+M, N+M+1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <map>\n#include <cstring>\n#include <tuple>\n#include <queue>\n\nusing namespace std;\n\ntypedef long long ll;\n#define int ll\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n\nint n,m;\nint s,goal;\n\nstruct Edge {\n    int src, dst, len;\n    Edge(int a, int b, int c)\n        : src(a), dst(b), len(c)\n    {}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\nint augment(const Graph &g, const vvi &capacity, vvi &flow,\n    const vector<int> &level, vector<bool> &finished, int u, int t, int cur) {\n  if (u == t || cur == 0) return cur;\n  if (finished[u]) return 0;\n  finished[u] = true;\n  for(auto & e : g[u]) if (level[e.dst] > level[u]) {\n    int f = augment(g, capacity, flow, level, finished,\n        e.dst, t, min(cur, RESIDUE(u, e.dst)));\n    if (f > 0) {\n      flow[u][e.dst] += f; flow[e.dst][u] -= f;\n      finished[u] = false;\n      return f;\n    }\n  }\n  return 0;\n}\nint maximumFlow(const Graph &g, int s, int t) {\n  int n = g.size();\n  vvi flow(n, vi(n)), capacity(n, vi(n)); // adj. matrix\n  rep(u,n) for(auto & e : g[u]) capacity[e.src][e.dst] += e.len;\n\n  int total = 0;\n  for (bool cont = true; cont; ) {\n    cont = false;\n    vector<int> level(n, -1); level[s] = 0; // make layered network\n    queue<int> Q; Q.push(s);\n    for (int d = n; !Q.empty() && level[Q.front()] < d; ) {\n      int u = Q.front(); Q.pop();\n      if (u == t) d = level[u];\n      for(auto & e:g[u]) if (RESIDUE(u,e.dst) > 0 && level[e.dst] == -1)\n        Q.push(e.dst), level[e.dst] = level[u] + 1;\n    }\n    vector<bool> finished(n); // make blocking flows\n    for (int f = 1; f > 0; ) {\n        f = augment(g, capacity, flow, level, finished, s, t, 1<<29);\n      if (f == 0) break;\n      total += f; cont = true;\n    }\n  }\n  return total;\n}\n\n// signed main(){\n//     int m,n;\n//     while(cin >> m >> n && m){\n//         int S = m+n, T = n+m+1;\n//         Graph g(n+m+2);\n//         static int a[600], b[600];\n//         rep(i,m){\n//             cin >> a[i];\n//             g[S].emplace_back(S,i,1);\n//         }\n//         rep(i,n){\n//             cin >> b[i];\n//             g[m+i].emplace_back(m+i,T,1);\n//         }\n//         rep(i,m)rep(j,n){\n//             int gcd = __gcd<ll>(a[i],b[j]);\n//             int s = i;\n//             int t = m+j;\n//             if(gcd != 1) g[s].emplace_back(s,t,1);\n//         }\n//         cout << maximumFlow(g,S,T) << endl;\n//     }\n// }\n\nsigned main(){\n   int n,m;\n    while(cin>>n>>m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n)cin>>a[i];\n        rep(i,m)cin>>b[i];\n        Graph mcf(n+m+2);\n        int s=n+m, t=n+m+1;\n        rep(i,m)mcf[i+n].emplace_back(i+n,t,1);\n        rep(i,n){\n            mcf[s].emplace_back(s,i,1);\n            rep(j,m)if(__gcd(a[i],b[j])!=1)mcf[i].emplace_back(i,n+j,1);\n        }\n        cout << maximumFlow(mcf,s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint gcd(int a,int b)\n{\n\treturn b?gcd(b,a%b):a;\n}\n\nstruct Edge{\n\tint src,dst;\n\tEdge(){}\n\tEdge(int s,int d):src(s),dst(d){}\n};\ntypedef vector<vector<Edge> > Graph;\n\nbool Augment(const Graph& g,int u,vi& vis,vi& match)\n{\n\trep(i,g[u].size()){\n\t\tint v=g[u][i].dst;\n\t\tif(vis[v]) continue;\n\t\tvis[v]=1;\n\t\tif(match[v]==-1 || Augment(g,match[v],vis,match)){\n\t\t\tmatch[u]=v;\n\t\t\tmatch[v]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint BipartiteMatching(const Graph& g,vi& match)\n{\n\tint n=g.size();\n\tmatch.assign(n,-1);\n\tint res=0;\n\trep(i,n) if(match[i]==-1){\n\t\tvi vis(n);\n\t\tres+=Augment(g,i,vis,match);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int m,n;cin>>m>>n,m|n;){\n\t\tvi bs(m),rs(n);\n\t\trep(i,m) cin>>bs[i];\n\t\trep(i,n) cin>>rs[i];\n\t\t\n\t\tGraph g(m+n);\n\t\trep(i,m) rep(j,n) if(gcd(bs[i],rs[j])>1){\n\t\t\tg[i].push_back(Edge(i,m+j));\n\t\t\tg[m+j].push_back(Edge(m+j,i));\n\t\t}\n\t\t\n\t\tvi match;\n\t\tcout<<BipartiteMatching(g,match)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Hopcroft-Karp Algorithm\n// O(|E| * |V|^(1/2))\n// http://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm\n// aoj 1163\n\n#include <vector>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\nint NIL;\nconst int inf = 1<<29;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int> > Graph;\n\nbool bfs(const Graph &g,vi &dist,const vi &pair,int m) {\n    queue<int> q;\n\n    for(int i=0; i<m; ++i)\n        if(pair[i] == NIL) {\n            dist[i] = 0;\n            q.push(i);\n        }else dist[i] = inf;\n    dist[NIL] = inf;\n\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        if(v == NIL) continue;\n        for(int i=0; i<g[v].size(); ++i) {\n            int u = pair[g[v][i]];\n            if(dist[u] == inf) dist[u] = dist[v]+1, q.push(u);\n        }\n    }\n    return dist[NIL] != inf;\n}\n\nbool dfs(int v,const Graph &g,vi &dist,vi &pair) {\n    for(int i=0; i<g[v].size(); ++i) {\n        int u = g[v][i];\n        if(dist[pair[u]] == dist[v]+1)\n            if(pair[u] == NIL || dfs(pair[u],g,dist,pair)) {\n                pair[u] = v, pair[v] = u;\n                return true;\n            }\n    }\n    dist[v] = inf;\n    return false;\n}\n\n// 0ツつゥツづァm-1ツづ慊づづ個静淞点ツづツつゥツづァn-1ツづ慊づづ個静淞点ツづづ個催妥・ツマツッツチツδ督グツづーツ仰づ淞づゥ\nint hopcroft_karp(Graph &graph,int m) {\n    NIL = graph.size();\n    vi pair(NIL+1, NIL), dist(NIL+1, 0);\n    int ret = 0;\n    while(bfs(graph,dist,pair,m))\n        for(int i=0; i<m; ++i)\n            if(pair[i] == NIL)\n                if(i == NIL || dfs(i,graph,dist,pair)) ret++;\n    return ret;\n}\n\nint gcd(int x,int y) {\n    if(y == 0) return x;\n    return gcd(y,x%y);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    int m,n;\n    while(cin>>m>>n, m|n) {\n        Graph g(m+n);\n        vector<int> b(m), r(n);\n        for(int i=0; i<m; ++i) cin>>b[i];\n        for(int i=0; i<n; ++i) cin>>r[i];\n\n        for(int i=0; i<m; ++i)\n            for(int j=0; j<n; ++j)\n                if(gcd(b[i],r[j]) > 1)\n                    g[i].push_back(j+m);\n        cout<<hopcroft_karp(g,m)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <math.h>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <assert.h>\n#include <numeric>\n#include <iomanip>\n#define rep(i, a, b) for (int(i) = (a); i < (b); i++)\nusing namespace std;\n\nusing ll = long long;\n\nconst int INF = 100000000;\nconst int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nconst ll MOD = 1000000007;\n\nll pow_mod(ll x, ll y, ll mod)\n{\n\tll ans=1;\n\tfor(;y>0;y>>=1){\n\t\tif(y&1)(ans*=x)%=mod;\n\t\t(x*=x)%=mod;\n\t}\n\treturn ans;\n}\n\nll gcd(ll a,ll b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\n\nstruct Maxflow{\n\tstruct Edge{int to,cap,rev;};\n\n\tusing Edges = vector<Edge>;\n\tusing Graph = vector<Edges>;\n\n\tGraph g;\n\tvector<int> used;\n\tconst int INF = 1e8;\n\tconst int MAX_V;\n\n\tMaxflow(int V):g(V),used(V,0),MAX_V(V){}\n\n\tvoid add_edge(int from,int to,int cap){\n\t\tg[from].push_back(Edge{to,cap,(int)g[to].size()});\n\t\tg[to].push_back(Edge{from,0,(int)g[from].size()-1});\n\t}\n\n\tint dfs(int v,int t,int f){\n\t\tif(v==t)return f;\n\t\tused[v]=true;\n\t\tfor(int i=0;i<g[v].size();i++){\n\t\t\tEdge &e = g[v][i];\n\t\t\tif(!used[e.to]&&e.cap>0){\n\t\t\t\tint d =dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap -=d;\n\t\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint max_flow(int s,int t){\n\t\tint flow = 0;\n\t\tfor(;;){\n\t\t\trep(i,0,MAX_V)used[i]=false;\n\t\t\tint f=dfs(s,t,INF);\n\t\t\tif(f==0)return flow;\n\t\t\tflow+=f;\n\t\t}\n\t}\n};\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t//問題文中の添え字が0-indexか1-indexか確認!\n\twhile(1){\n\t\tint m,n;\n\t\tcin>>m>>n;\n\t\tif(m==0&&n==0)break;\n\t\tvector<int> bcards(m),rcards(n);\n\t\tMaxflow a(m+n+2);\n\t\trep(i,0,m)cin>>bcards[i];\n\t\trep(i,0,n)cin>>rcards[i];\n\t\trep(i,0,m)a.add_edge(0,i+1,1);\n\t\trep(i,0,n)a.add_edge(m+i+1,m+n+1,1);\n\t\trep(i,0,m){\n\t\t\trep(j,0,n){\n\t\t\t\tif(gcd(bcards[i],rcards[j])!=1){\n\t\t\t\t\ta.add_edge(i+1,m+j+1,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=a.max_flow(0,m+n+1);\n\t\tcout<<ans<<\"\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstruct Edge {\n  Edge() {}\n  Edge(int from, int to, int capacity, int rev) : from(from), to(to), capacity(capacity), rev(rev) {}\n  int from, to;\n  int capacity;\n  int rev;\n};\n\nstd::vector<Edge> edges[1024];\nvoid addEdge(int from, int to, int capacity) {\n  int n1 = edges[from].size();\n  int n2 = edges[to].size();\n  edges[from].push_back(Edge(from, to, capacity, n2));\n  edges[to].push_back(Edge(to, from, 0, n1));\n}\n\nbool checked[1024];\nvoid init_flow() {\n  for(int i = 0; i < 1024; ++i) {\n    checked[i] = false;\n  }\n}\nint flow(int from, int to, int v) {\n  if( from == to ) return v;\n  if( v == 0 ) return 0;\n  if( checked[from] ) return 0;\n  checked[from] = true;\n  for(Edge& edge : edges[from]) {\n    int nv = std::min(v, edge.capacity);\n    int f = flow(edge.to, to, nv);\n    if( f == 0 ) continue;\n    edge.capacity -= f;\n    edges[edge.to][edge.rev].capacity += f;\n    return f;\n  }\n  return 0;\n}\n\nint maximum_flow(int from, int to) {\n  int res = 0;\n  for(;;) {\n    init_flow();\n    int f = flow(from, to, (1 << 29));\n    res += f;\n    if( f == 0 ) break;\n  }\n  return res;\n}\n\nint source = 1022;\nint dest   = 1023;\n\nint m, n;\nint xs[1024];\nint ys[1024];\nbool load() {\n  scanf(\"%d %d\", &m, &n);\n  if( m == 0 and n == 0 ) return false;\n  for(int i = 0; i < m; ++i) {\n    scanf(\"%d\", &xs[i]);\n  }\n  for(int i = 0; i < n; ++i) {\n    scanf(\"%d\", &ys[i]);\n  }\n  return true;\n}\n\nint gcd(int x, int y) {\n  while( y != 0 ) {\n    x %= y;\n    std::swap(x, y);\n  }\n  return x;\n}\n\nint solve() {\n  for(int i = 0; i < 1024; ++i) {\n    edges[i].clear();\n  }\n  for(int i = 0; i < m; ++i) {\n    for(int j = 0; j < n; ++j) {\n      if( gcd(xs[i], ys[j]) != 1 ) {\n        addEdge(i, 512 + j, 1);\n      }\n    }\n  }\n  for(int i = 0; i < m; ++i) {\n    addEdge(source, i, 1);\n  }\n  for(int i = 0; i < n; ++i) {\n    addEdge(512 + i, dest, 1);\n  }\n  return maximum_flow(source, dest);\n}\n\nint main() {\n  while( load() ) {\n    printf(\"%d\\n\", solve());\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max() / 2;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\n\nconst int MAX_V = 10e4;\n\nstruct edge{int to,cap,rev;};\n\nstd::vector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  used[v]= true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow =0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f=dfs(s,t,INF);\n    if(f==0) return flow;\n    flow += f;\n  }\n}\n\nint gcd(int a,int b){\n  if(b==0) return a;\n  return gcd(b,a%b);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true){\n  for(int i=0;i<MAX_V;i++) {\n    G[i].erase(G[i].begin(), G[i].end());\n    used[i]=false;\n  }\n  int m,n;\n  cin >> m >> n;\n  if(m==0 && n==0) break;\n  bool can[1000][1000];//can[i][j]:b[i]テ」ツ?罫[j]テ」ツ?ォテ・ツ可イテ」ツつ甘・ツスツ禿」ツ?ヲテ・ツ渉ッティツδス\n  int b[1000],r[1000];\n  for(int i=1;i<=m;i++) cin >> b[i];\n  for(int i=1;i<=n;i++) cin >> r[i];\n  for(int i=1;i<=m;i++){\n    for(int j=1;j<=n;j++){\n      can[i][j] = (gcd(b[i],r[j])>1);\n    }\n  }\n  int s=m+n+1,t=s+1;\n\n  for(int i=1;i<=m;i++){\n    add_edge(s,i,1);\n  }\n\n  for(int i=1;i<=n;i++){\n    add_edge(m+i,t,1);\n  }\n\n  for(int i=1;i<=m;i++){\n    for(int j=1;j<=n;j++){\n      if(can[i][j]){\n        add_edge(i,m+j,1);\n      }\n    }\n  }\n  cout << max_flow(s,t) << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing Flow = int;\nstruct FlowEdge {\n  int src, dst, rev;\n  Flow cap;\n  FlowEdge(const int s = 0, const int d = 0, const Flow c = 0, const int r = 0) : src(s), dst(d), cap(c), rev(r) {}\n};\n\nusing FlowEdges = std::vector<FlowEdge>;\n\nclass FlowGraph {\n  std::vector<FlowEdges> g;\n\npublic:\n  FlowGraph(const int size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  FlowEdges &operator[](const int i) & { return g[i]; }\n\n  void addEdge(const int src, const int dst, const Flow c = 1) {\n    g[src].emplace_back(src, dst, c, g[dst].size());\n    g[dst].emplace_back(dst, src, 0, g[src].size() - 1);\n  }\n};\n\n// Change it to 'FlowGraph &g' when you need a residual network\ntemplate<Flow inf = std::numeric_limits<Flow>::max() / 8> Flow fordFulkerson(FlowGraph g, const int source, const int sink) {\n  std::vector<int> used(g.size());\n  std::function<Flow(int, Flow)> dfs = [&](int v, Flow f) -> Flow {\n    if (v == sink) return f;\n    used[v] = true;\n    for (auto &e : g[v]) {\n      if (used[e.dst] || e.cap <= 0) continue;\n      Flow d = dfs(e.dst, min(f, e.cap));\n      if (d <= 0) continue;\n      e.cap -= d;\n      g[e.dst][e.rev].cap += d;\n      return d;\n    }\n    return 0;\n  };\n  Flow s = 0;\n  for (;;) {\n    std::fill(used.begin(), used.end(), false);\n    Flow f = dfs(source, inf);\n    if (f == 0) return s;\n    s += f;\n  }\n}\n\nconstexpr int gcd(int a, int b) {\n  while (b) b ^= a ^= b ^= a %= b;\n  return a;\n}\n\nmain {\n  int m, n;\n  while (cin >> m >> n, m || n) {\n    vi b(m), r(n);\n    cin >> b >> r;\n    FlowGraph g(m + n + 2);\n    rep(i, m) g.addEdge(m + n, i);\n    rep(i, n) g.addEdge(m + i, m + n + 1);\n    rep(i, m) rep(j, n) if (gcd(b[i], r[j]) > 1) g.addEdge(i, m + j);\n    cout << fordFulkerson(g, m + n, m + n + 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX_V 1010\n\nconst int INF = 1e9;\n\nstruct edge{ int to, cap, rev; };\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0 ; i < (int)G[v].size() ; i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t){\n  int flow = 0;\n  for(; ;){\n    memset(used, 0, sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nvoid init(){\n  for(int i = 0 ; i < MAX_V ; i++) G[i].clear();\n  memset(used, 0, sizeof(used));\n}\n\nbool ok(int a, int b){\n  return __gcd(a, b) != 1;\n}\n\nint main(){\n  int N, M;\n  while(cin >> N >> M, N|M){\n    init();\n    \n    int source = M+N;\n    int tink = source + 1;\n    \n    vector<int> A(N), B(M);\n    for(int i = 0 ; i < N ; i++) cin >> A[i];\n    for(int i = 0 ; i < M ; i++) cin >> B[i];\n    \n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < M ; j++){\n\tif( ok(A[i], B[j]) ) add_edge(i, M+j, 1);\n      }\n    }\n    \n    for(int i = 0 ; i < M ; i++) add_edge(source, i, 1);\n    for(int i = 0 ; i < N ; i++) add_edge(M+i, tink, 1);\n    \n    cout << max_flow(source, tink) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n//const int M = 10000100;\nconst int M = 1000;\n\nbool isPrime[M];\nvector<int> primes;\nvoid sieve(){\n    for(int i=2;i<M;i++) isPrime[i] = true;\n    for(int i=2;i*i < M;i++){\n        if(!isPrime[i]) continue;\n        for(int j=i*i;j<M;j+=i){\n            isPrime[j] = false;\n        }\n    }\n    for(int i=0;i<M;i++){\n        if(isPrime[i]) primes.push_back(i);\n    }\n}\nstruct Edge{\n    int to,cap,rev;\n    Edge(int to,int cap,int rev) : to(to),cap(cap),rev(rev) {};\n};\n\nvoid add_edge(vector<vector<Edge> >& E,int from,int to,int cap){\n    E[from].push_back(Edge(to,cap,E[to].size()));\n    E[to].push_back(Edge(from,0,E[from].size()-1));\n}\n\nvector<int> levels(vector<vector<Edge> > &E,int s){\n    vector<int> level(E.size(),-1);\n    level[s] = 0;\n    queue<int> Q;\n    Q.push(s);\n    while(!Q.empty()){\n        int v = Q.front();\n        Q.pop();\n        for(int i=0;i<E[v].size();i++){\n            Edge &e = E[v][i];\n            if(e.cap > 0 and level[e.to] == -1){\n                level[e.to] = level[v]+1;\n                Q.push(e.to);\n            }\n        }\n    }\n    return level;\n}\n\nint good_path(vector<vector<Edge> > &E,\n        vector<int> &iter,\n        vector<int> &level,\n        int v,int t,int f){\n    if(v == t) return f;\n    for(int &i=iter[v];i<E[v].size();i++){\n        Edge &e = E[v][i];\n        if(e.cap > 0 and level[v] < level[e.to]){\n            int d = good_path(E,iter,level,e.to,t,min(f,e.cap));\n            if(d > 0){\n                e.cap -= d;\n                E[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(vector<vector<Edge> > E,int s,int t){\n    int flow = 0;\n    const int INF = 1 << 30;\n    while(true){\n        vector<int> level = levels(E,s);\n        if(level[t] < 0) return flow;\n        vector<int> iter(E.size());\n        int f;\n        while((f=good_path(E,iter,level,s,t,INF)) > 0){\n            flow += f;\n        }\n    }\n}\n\n\nint main(){\n    sieve();\n    while(true){\n    int m,n;\n    cin >> m >> n;\n    if(m == 0 and n == 0) break;\n\n    vector<int> b(m);\n    vector<int> r(n);\n    for(int i=0;i<m;i++) cin >> b[i];\n    for(int i=0;i<n;i++) cin >> r[i];\n\n    vector<vector<Edge> > E(n+m+2);\n    // 0 is start. 1 is end.\n    int start = 0,end = 1;\n    int blue_start = 2,red_start=2+m;\n\n    for(int i=0;i<m;i++){\n        add_edge(E,start,blue_start+i,1);\n    }\n    for(int i=0;i<n;i++){\n        add_edge(E,red_start+i,end,1);\n    }\n\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++){\n            for(int k=0;k<primes.size();k++){\n                if(b[i] % primes[k] == 0 and r[j] % primes[k] == 0){\n                    add_edge(E,blue_start+i,red_start+j,1);\n                    break;\n                }\n            }\n        }\n    }\n    cout << max_flow(E,start,end) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n/*bipartite_matching(二部グラフの最大マッチングを求める)*/\n\nconst int MAX_V = 1500;\nint V;//頂点数\nvector<int> G[MAX_V];//グラフの隣接リスト表現\nint match[MAX_V];//マッチングのペア\nbool used[MAX_V];//DFSですでに調べたかのフラグ\n//uとvを結ぶ辺をグラフに追加する\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n//増加パスをDFSで探す\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tint u = G[v][i];\n\t\tint w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n//二部グラフの最大マッチングを求める\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int v = 0;v < V;v++){\n\t\tif(match[v]<0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>m>>n,n||m){\n\t\tint blue[m];//青のカード\n\t\tint red[n];//赤のカード\n\t\tmemset(blue,0,sizeof(blue));\n\t\tmemset(red,0,sizeof(red));\n\t\tV = n+m;//頂点数は合計\n\t\trep(i,V){\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tcin>>blue[i];\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin>>red[i];\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tfor(int j =0;j < n;j++){\n\t\t\t\tif(__gcd(blue[i],red[j])==1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tadd_edge(i,j+m);//0~m-1を青,m~m+n-1を赤とする\n\t\t\t}\n\t\t}\n\t\tcout <<bipartite_matching()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * test.cpp\n *\n *  Created on: 2010/04/10\n *      Author: mattya\n */\n#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<complex>\n#include<numeric>\n#include<bitset>\n#define INF 1001001001\n\nusing namespace std;\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef pair<int,int> pint;\n\n\nint N = 1010;\nvvint cap(N,(vint(N,0)));\nvvint flow(N,(vint(N,0)));\nvint prev(N,-1);\ninline int nokori(int a,int b){\n\tif(cap[a][b]>=0) return cap[a][b]-flow[a][b];\n\telse return -flow[a][b];\n}\n\nint search_path(int st,int gl){\n\tqueue<int> q;\n\tq.push(st);\n\tprev[st]=st;\n\twhile(!q.empty()){\n\t\tint f = q.front();\n\t\tq.pop();\n\t\tif(f==gl) return 1;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(prev[i]==-1 && nokori(f,i)>0){\n\t\t\t\tq.push(i);\n\t\t\t\tprev[i]=f;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint mx_flow(int st,int gl){\n\tint ans=0;\n\twhile(1){\n\t\tprev = vint(N,-1);\n\t\tif(search_path(st,gl)){\n\t\t\tint val=INF;\n\t\t\tfor(int i=gl;i!=st;i=prev[i]){\n\t\t\t\tval=min(val,nokori(prev[i],i));\n\t\t\t}\n\t\t\tfor(int i=gl;i!=st;i=prev[i]){\n\t\t\t\tflow[prev[i]][i]+=val;\n\t\t\t\tflow[i][prev[i]]=-flow[prev[i]][i];\n\t\t\t}\n\t\t\tans+=val;\n\t\t}else return ans;\n\t}\n}\n//GCD\ninline int gcd(int a,int b){\n\treturn b!=0 ? gcd(b,a%b) : a;\n}\n\nint main(){\n\tint m,n;\n\twhile(1){\n\t\tcap = vvint(N,(vint(N,0)));\n\t\tflow = vvint(N,(vint(N,0)));\n\t\tprev = vint(N,-1);\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(m==0 && n==0) break;\n\t\tvint b(m),r(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d\",&b[i]);\n\t\t\tcap[1000][i]=1;\n\t\t\tcap[i][1000]=-1;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&r[i]);\n\t\t\tcap[500+i][1001]=1;\n\t\t\tcap[1001][500+i]=-1;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(gcd(b[i],r[j])>1){\n\t\t\t\t\tcap[i][500+j]=1;\n\t\t\t\t\tcap[500+j][i]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mx_flow(1000,1001) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { -1,0, 1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\n\n//マッチングに使う\nbool dfs(int v, vii &G, vi &match, vi &used) {\n  used[v] = true;\n  for (int i = 0; i < G[v].size(); i++) {\n    int u = G[v][i], w = match[u];\n    if (w < 0 || !used[w] && dfs(w, G, match, used)) {\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\n//二部グラフの最大マッチングを求める\n//二部グラフの最大マッチング = 最小点カバー = n-最小辺カバー = n-最大安定集合\nint bipartite_matching(vii &G) {\n  int res = 0;\n  vi match(G.size(), -1);\n  vi used(G.size());\n  for (int v = 0; v < G.size(); v++) {\n    if (match[v] < 0) {\n      fill(used.begin(), used.end(), 0);\n      if (dfs(v, G, match, used)) {\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\n\nint main() {\n  while (true) {\n    int m, n;\n    cin >> m >> n;\n    if (m == 0) return 0;\n    vi b(m), r(n);\n    rep (i, m) {\n      cin >> b[i];\n    }\n    rep (i, n) {\n      cin >> r[i];\n    }\n    vii G(n + m);\n    rep (i, m) {\n      rep (j, n) {\n        if (__gcd(b[i], r[j]) > 1) {\n          G[i].push_back(m + j);\n          G[m + j].push_back(i);\n        }\n      }\n    }\n    \n    int res = bipartite_matching(G);\n    cout << res << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Hopcroft-Karp Algorithm\n// O(|E| * |V|^(1/2))\n// http://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm\n// aoj 1163\n\n#include <vector>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\nint NIL;\nconst int inf = 1<<29;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int> > Graph;\n\nbool bfs(const Graph &g,vi &dist,const vi &pair,int m) {\n    queue<int> q;\n\n    for(int i=0; i<m; ++i)\n        if(pair[i] == NIL) {\n            dist[i] = 0;\n            q.push(i);\n        }else dist[i] = inf;\n    dist[NIL] = inf;\n\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        for(int i=0; i<g[v].size(); ++i) {\n            int u = g[v][i];\n            if(dist[pair[u]] == inf) {\n                dist[pair[u]] = dist[v]+1;\n                q.push(pair[u]);\n            }\n        }\n    }\n    return dist[NIL] != inf;\n}\n\nbool dfs(int v,const Graph &g,vi &dist,vi &pair) {\n    for(int i=0; i<g[v].size(); ++i) {\n        int u = g[v][i];\n        if(dist[pair[u]] == dist[v]+1) {\n            if(dfs(pair[u],g,dist,pair)) {\n                pair[u] = v, pair[v] = u;\n                return true;\n            }\n        }\n    }\n    dist[v] = inf;\n    return false;\n}\n\n// 0ツつゥツづァm-1ツづ慊づづ個静淞点ツづツつゥツづァn-1ツづ慊づづ個静淞点ツづづ個催妥・ツマツッツチツδ督グツづーツ仰づ淞づゥ\nint hopcroft_karp(Graph &graph,int m) {\n    NIL = graph.size(); graph.push_back(vector<int>(0));\n    vi pair(n+1, NIL), dist(n+1, 0);\n    int ret = 0;\n    while(bfs(graph,dist,pair,m)) {\n        for(int i=0; i<m; ++i)\n            if(pair[i] == NIL)\n                if(v == NIL || dfs(i,graph,dist,pair)) ret++;\n    }\n    return ret;\n}\n\nint gcd(int x,int y) {\n    if(y == 0) return x;\n    return gcd(y,x%y);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    int m,n;\n    while(cin>>m>>n, m|n) {\n        Graph g(m+n);\n        vector<int> b(m), r(n);\n        for(int i=0; i<m; ++i) cin>>b[i];\n        for(int i=0; i<n; ++i) cin>>r[i];\n\n        for(int i=0; i<m; ++i)\n            for(int j=0; j<n; ++j)\n                if(gcd(b[i],r[j]) > 1)\n                    g[i].push_back(j+m);\n        cout<<hopcroft_karp(g,m)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> L[2000];int N,M,E,i,j,match[2000],x[2000],y[2000];bool used[2000];\nbool DFS(int V){\n    used[V]=true;\n    for (i = 0; i < L[V].size(); i++) {\n        int u = L[V][i]; int w = match[u];\n        if (w < 0 || !used[w] && DFS(w)) {\n            match[V] = u;\n            match[u] = V;\n            return 1;\n        }\n    }\n    return 0;\n}\nint SM() {\n    int r = 0;\n    memset(match, -1, sizeof(match));\n    for (j = 0; j < N + M; j++) {\n        if (match[j] < 0) {\n            memset(used, 0, sizeof(used));\n            if (DFS(j)) { r++; }\n        }\n    }\n    return r;\n}\n \n//main.\nint main() {\n    while (true) {\n        for (i = 0; i < 2000; i++) { L[i].clear(); }\n        cin >> N >> M; if (!N) { break; }\n        for (i = 0; i < N; i++) {\n            cin >> x[i];\n        }\n        for (i = 0; i < M; i++) {\n            cin >> y[i];\n        }\n        for (i = 0; i < N; i++) {\n            for (j = 0; j < M; j++) {\n                if (__gcd(x[i], y[j]) != 1) {\n                    L[i].push_back(j + N);\n                }\n            }\n        }\n        cout << SM() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#define MAX_V 500*500+1\n#define INF 501\n\nusing namespace std;\n\n\n\nstruct edge{int to,cap,rev;};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f=dfs(s,t,INF);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint lcm(int m,int n){\n  int tmp;\n  while (m % n != 0)\n    {\n      tmp = n;\n      n = m % n;\n      m = tmp;\n    }\n  return n;\n}\n\n\n\nint main()\n{\n  for(;;){\n    for(int i=0;i<MAX_V;i++){\n      G[i].clear();\n    }\n    int m,n;\n    cin >> m >> n;\n    if(m==0)return 0;\n    int br[m+n];\n    for(int i=0;i<m+n;i++)cin >> br[i];\n\n    for(int i=0;i<m;i++){\n      for(int j=m;j<m+n;j++){\n\t//cout << br[i] << \",\" << br[j]<< \";\" << lcm(br[i],br[j]) <<endl;\n\tif(lcm(br[i],br[j])!=1){\n\t  add_edge(i,j,1);\n\t}\n      }\n    }\n    for(int i=0;i<m;i++)\n      add_edge(n+m+1,i,1);\n \n    for(int i=0;i<n;i++)\n      add_edge(m+i,n+m+2,1);\n\n    cout << max_flow(n+m+1,n+m+2) << endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define MIN(A, B) ((A) < (B))? (A) : (B)\n\nint NextInt() { int d; scanf(\"%d\", &d); return d; }\n\ntypedef struct {\n  int length;\n  int dest[501];\n} Edge;\n\nint b[501], r[501];\nEdge e[501];\nint t[501];\nint m, n;\n\nint augment(int u, int used[]) {\n  if (u < 0) {\n    return 1;\n  }\n  for (int i = 0; i < e[u].length; i++) {\n    int d = e[u].dest[i];\n    if (!used[d]) {\n      used[d] = 1;\n      if (augment(t[d], used)) {\n        t[d] = u;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\n\nint main() {\n  while (1) {\n    m = NextInt(); n = NextInt();\n    if (m + n == 0) {\n      break;\n    }\n    for (int i = 0; i < m; i++) {\n      e[i].length = 0;\n      b[i] = NextInt();\n    }\n    for (int i = 0; i < n; i++) {\n      r[i] = NextInt();\n      t[i] = -1;\n    }\n  \n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        int m = MIN(b[i], r[j]);\n        for (int k = 2; k <= m; k++) {\n          if (b[i] % k == 0 && r[j] % k == 0) {\n            e[i].dest[e[i].length++] = j;\n            break;\n          } \n        }           \n      }\n    }\n    int ans = 0;\n    for (int i = 0; i < m; i++) {\n      int used[1001] = { 0 };\n      if (augment(i, used)) {\n        ans++;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint gcd(int a, int b) {\n\tif (!b)return a;\n\treturn gcd(b, a%b);\n}\nint b[500], r[500];\nvector<int>E[500];\nbool used[1000];\nint match[1000];\n\nbool dfs(int u) {\n\tused[u] = true;\n\tfor (int v : E[u]) {\n\t\tint w = match[v];\n\t\tif (w == -1 || (!used[w] && dfs(w))) {\n\t\t\tmatch[u] = v; match[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\trep(i, m)E[i].clear();\n\t\trep(i, m)scanf(\"%d\", &b[i]);\n\t\trep(i, n)scanf(\"%d\", &r[i]);\n\t\trep(i, m)rep(j, n) {\n\t\t\tif (gcd(b[i], r[j]) != 1)E[i].push_back(m + j);\n\t\t}\n\t\tmemset(match, -1, sizeof(match));\n\t\tint ans = 0;\n\t\trep(i, m) {\n\t\t\tif (match[i] == -1) {\n\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\tif (dfs(i))ans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nclass MaxFlow {\npublic:\n    struct Edge {\n        ll to, cap, rev;\n    };\n    vector<vector<Edge>> G;\n    vector<ll> iter;\nprivate:\n    bool is_debug;\n    ll V;\n    vector<ll> bfs(ll s) {\n        vector<ll> dist(V, linf);\n        dist[s] = 0;\n        queue<ll> Q; Q.push(s);\n        while ( !Q.empty() ) {\n            ll v = Q.front(); Q.pop();\n            each(e, G[v]) {\n                if (e.cap > 0 && dist[e.to] == linf) {\n                    dist[e.to] = dist[v]+1;\n                    Q.push(e.to);\n                }\n            }\n        }\n        return dist;\n    }\n    ll dfs(ll v, ll t, ll f, const vector<ll>& dist, vector<bool>& used) {\n        if (v == t) return f;\n        if (used[v]) return 0;\n        used[v] = true;\n        for (ll& i = iter[v]; i < G[v].size(); ++i) {\n            Edge& e = G[v][i];\n            if (e.cap > 0 && dist[e.to] == dist[v]+1) {\n                ll d = dfs(e.to, t, min(f, e.cap), dist, used);\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\npublic:\n    const vector<vector<Edge>> Graph() {\n        return G;\n    }\n    MaxFlow(ll V, bool is_debug=false) : V(V), G(V), is_debug(is_debug) {}\n    void init(ll n) {\n        V = n;\n        G.assign(V, vector<Edge>());\n    }\n    void add(ll from, ll to, ll cap) {\n        if (is_debug) cout << \"ADD: \" << from << \" \" << to << \" \" << cap << endl;\n        assert(V > 0);\n        G[from].pb({to, cap, (ll)G[to].size()});\n        G[to].pb({from, 0, (ll)G[from].size()-1});\n    }\n    // S -> s, T -> t ??? inf ???????????§\n    void add(ll from, ll to, ll min_flow, ll cap, ll S, ll T) {\n        if (is_debug) cout << endl << \"ADD_MIN:\" << from << \" \" << to << \" \" << min_flow << \" \" << cap << endl;\n        add(from, to, cap-min_flow);\n        add(S, to, min_flow);\n        add(from, T, cap);\n        if (is_debug) cout << endl;\n    }\n    ll flow(ll s, ll t, ll f=linf) {\n        ll res = 0;\n        while (f > 0) {\n            vector<ll> dist = bfs(s);\n            if (dist[t] == linf) break;\n            iter.assign(G.size(), 0);\n            while (f > 0) {\n                vector<bool> used(V, false);\n                ll df = dfs(s, t, f, dist, used);\n                if (df == 0) break;\n                f -= df;\n                res += df;\n            }\n        }\n        return res;\n    }\n};\nvector<ll> prime_divisors(ll n) {\n    vector<ll> res;\n    for (ll i = 2; i*i <= n; ++i) {\n        if (n % i != 0) continue;\n        res.pb(i);\n        while (n % i == 0) n /= i;\n    }\n    if (n > 1) res.pb(n);\n    sort(all(res));\n    return res;\n}\nll gcd(ll a, ll b) {\n    return b == 0 ? a : gcd(b, a%b);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, m;\n    while (cin >> n >> m, n || m) {\n        vector<ll> a(n), b(m); cin >> a >> b;\n        // ll s = n+m, t = s+1;\n        // MaxFlow mf(t+1);\n        // rep(i, n) rep(j, m) {\n        //     if (gcd(a[i], b[j]) > 1) {\n        //         mf.add(i, n+j, 1);\n        //     }\n        // }\n        // rep(i, n) mf.add(s, i, 1);\n        // rep(i, m) mf.add(n+i, t, 1);\n        vector<vector<ll>> ad(n), bd(m);\n        map<ll,ll> id;\n        rep(i, n) ad[i] = prime_divisors(a[i]);\n        rep(i, m) bd[i] = prime_divisors(b[i]);\n        rep(i, n) each(x, ad[i]) id[x];\n        rep(i, m) each(x, bd[i]) id[x];\n        ll lid = 0;\n        each(p, id) p.second = lid++;\n        ll ids = lid;\n        ll s = n+m+ids, t = s+1;\n        MaxFlow mf(t+1);\n        rep(i, n) mf.add(s, i, 1);\n        rep(i, m) mf.add(n+i, t, 1);\n        rep(i, n) each(x, ad[i]) mf.add(i, n+m+id[x], 1);\n        rep(i, m) each(x, bd[i]) mf.add(n+m+id[x], n+i, 1);\n        cout << mf.flow(s, t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nclass BipartiteMatching {\n    int n, n0;\n    int mode;\n    vvi adj;\n    vi mc;\n    vi used;\n\n    bool dfs(int v) {\n        used[v] = true;\n        for (int i = 0; i < adj[v].size(); i++) {\n            int u = adj[v][i];\n            int w = mc[u];\n            if (w < 0 || (!used[w] && dfs(w))) {\n                mc[v] = u;\n                mc[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\npublic:\n    BipartiteMatching(int n) : n(n), adj(n), mc(n, -1) {\n        mode = 0;\n    }\n    BipartiteMatching(int n, int m) : n(n + m), n0(n), adj(n + m), mc(n + m, -1) {\n        mode = 1;\n    }\n\n    void addEdge(int u, int v) {\n        if (mode == 0) {\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        } else {\n            adj[u].push_back(n0 + v);\n            adj[n0 + v].push_back(u);\n        }\n    }\n\n    int match() {\n        int ret = 0;\n        for (int v = 0; v < n; v++) {\n            if (mc[v] < 0) {\n                used = vi(n);\n                if (dfs(v)) {\n                    ret++;\n                }\n            }\n        }\n        return ret;\n    }\n\n    int operator[](int k) {\n        return mc[k];\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while (1) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0) break;\n        vector<int> as(n), bs(m);\n        for (int i = 0; i < n; i++) cin >> as[i];\n        for (int i = 0; i < m; i++) cin >> bs[i];\n        BipartiteMatching match(n, m);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (__gcd(as[i], bs[j]) > 1) match.addEdge(i, j);\n            }\n        }\n        cout << match.match() << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nconstexpr int MAX_V = 1000;\n \nclass twoMatching {\nprivate:\n  vector<int> G[MAX_V];\n  int match[MAX_V];\n  bool used[MAX_V];\n  int V;\npublic:\n  twoMatching(int v) {\n    V = v;\n  }\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n \n  bool dfs(int v) {\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n      int u = G[v][i], w = match[u];\n      if (w < 0 || !used[w] && dfs(w)) {\n    match[v] = u;\n    match[u] = v;\n    return true;\n      }\n    }\n    return false;\n  }\n \n  int bipartite_matching() {\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for (int v = 0; v < V; v++) {\n      if (match[v] < 0) {\n    memset(used, 0, sizeof(used));\n    if (dfs(v)) res++;\n      }\n    }\n    return res;\n  }\n};\n \nint prime[1000]; // max 4000\nint primeNumber = 0;\n \nint main() {\n  int m, n;\n  int b[500], r[500];\n  for (int i = 2; i < 4000; i++) {\n    bool check = true;\n    for (int j = 0; j < primeNumber; j++) {\n      if (i % prime[j] == 0) {\n        check = false;\n        break;\n      }\n    }\n    if (check) {\n      prime[primeNumber] = i;\n      primeNumber++;\n    }\n  }\n \n  while (1) {\n    scanf(\"%d%d\", &m, &n);\n    if (m == 0) break;\n    for (int i = 0; i < m; i++) scanf(\"%d\", &b[i]);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &r[i]);\n    twoMatching t(m + n);\n    for (int i = 0; i < primeNumber; i++) {\n      for (int j = 0; j < m; j++) {\n        if (b[j] % prime[i] != 0) continue;\n        for (int k = 0; k < n; k++) {\n          if (r[k] % prime[i] != 0) continue;\n          t.add_edge(j, k + m);\n        }\n      }\n    }\n    printf(\"%d\\n\", t.bipartite_matching());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nll gcd(ll a,ll b){if(a<b)swap(a,b); return (b?gcd(a%b,b):a);}\n#define N 1010\nll n,m;\nvector<ll> g[N];\nnamespace bipma{\n  bool vis[N];\n  ll match[N];\n  bool dfs(ll x){\n      if(vis[x])return 0; vis[x]=1;\n      for(auto y:g[x]){\n\t  if(!~match[y]||dfs(match[y])){\n\t      match[y]=x;\n\t      return 1;\n\t  }\n      }\n      return 0;\n  }\n  void main(){\n      for(int i=0;i<n+m;i++)match[i]=-1;\n      ll ans=0;\n      for(int i=0;i<n;i++){\n\t  for(int j=0;j<n+m;j++)vis[j]=0;\n\t  ans+=dfs(i);\n      }\n      cout<<ans<<endl;\n  }  \n};\nint main(){\n    ll a[N],b[N];\n    while(cin>>n>>m&&n+m){\n\tfor(int i=0;i<n;i++)cin>>a[i];\n\tfor(int i=0;i<m;i++)cin>>b[i];\n\tfor(int i=0;i<N;i++)g[i].clear();\n\tfor(int i=0;i<n;i++){\n\t    for(int j=0;j<m;j++){\n\t\tif(gcd(a[i],b[j])>1){\n\t\t    g[i].push_back(j+n);\n\t\t    g[j+n].push_back(i);\n\t\t}\n\t    }\n\t}\n\tbipma::main();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n//Class.\nvector<int> list[2000];\nint N, M, E;\nint match[2000];\nbool used[2000];\nint x[2000], y[2000];\n\nbool DFS(int V) {\n\tused[V] = true;\n\tfor (int i = 0; i < list[V].size(); i++) {\n\t\tint u = list[V][i]; int w = match[u];\n\t\tif (w < 0 || !used[w] && DFS(w)) {\n\t\t\tmatch[V] = u;\n\t\t\tmatch[u] = V;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint supermatching() {\n\tint r = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int j = 0; j < N + M; j++) {\n\t\tif (match[j] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (DFS(j)) { r++; }\n\t\t}\n\t}\n\treturn r;\n}\n\n//main.\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 2000; i++) { list[i].clear(); }\n\t\tcin >> N >> M; if (!N) { break; }\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i];\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> y[i];\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tif (__gcd(x[i], y[j]) != 1) {\n\t\t\t\t\tlist[i].push_back(j + N);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << supermatching() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define clr(n)\tmemset(n,0,sizeof(n));\nconst int INF = 1e9;\n\nint gcd(int a, int b) {\n\treturn b ? gcd(b, a%b) : a; \n}\n\nstruct edge { int to, cap, rev; };\nvector<edge> G[1001];\nbool used[1001];\n\nvoid clear() {\n\trep(i, 1001) {\n\t\tG[i].clear();\n\t\tused[i] = false;\n\t}\n}\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, int(G[to].size()) });\n\tG[to].push_back(edge{ from, 0, int(G[from].size()) - 1 });\n}\n\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\trep(i, G[v].size()) {\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tclr(used);\n\t\tint f = dfs(s, t, INF);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n}\n\nint main() {\n\tint m, n;\n\n\twhile (cin >> m >> n && m) {\n\t\tvector<int> r(m), b(n);\n\t\tclear();\n\t\trep(i, m) {\n\t\t\tcin >> r[i];\n\t\t\tadd_edge(m + n, i, 1);\n\t\t}\n\t\trep(i, n) {\n\t\t\tcin >> b[i];\n\t\t\tadd_edge( m + i, m + n + 1, 1);\n\t\t}\n\t\trep(i, m)rep(j, n) {\n\t\t\tif (gcd(r[i], b[j]) != 1) {\n\t\t\t\tadd_edge(i, m + j, 1);\n\t\t\t}\n\t\t}\n\n\t\tcout << max_flow(m + n, m + n + 1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 501;\nconst int MAX_V = 2000;\n// ティツオツ、テ」ツ?ィテゥツ敖津」ツ?ョテ」ツつォテ」ツδシテ」ツδ?\nint b[MAX_N],r[MAX_N];\n// テゥツ?づァツつケテヲツ閉ー\nint V;\n// テ」ツつーテ」ツδゥテ」ツδ?\nvector<int> G[MAX_V];\n// テ」ツδ榲」ツδε」ツδ?」ツδウテ」ツつーテ」ツ?ョテ」ツδ堙」ツつ「\nint match[MAX_V];\n// テ」ツ?凖」ツ?ァテ」ツ?ォティツェツソテ」ツ?ケテ」ツ?淌」ツ?凝」ツ?ゥテ」ツ??」ツ??\nbool used[MAX_V];\n\n// aテ」ツ?ィbテ」ツ?ョテヲツ慊?・ツ、ツァテ・ツ?ャテァツエツ?ヲツ閉ーテ」ツつ津ィツソツ氾」ツ??テ」ツδヲテ」ツδシテ」ツつッテ」ツδェテ」ツδε」ツδ嘉」ツ?ョテ、ツコツ津ゥツ卍、テヲツウツ?\nint gcd(int a, int b){\n    return (b>0)? gcd( b , a%b ) : a ;\n}\n\n// ティツセツコテ」ツ?ョティツソツステ・ツ環?\nvoid add_edge(int u, int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\n// テ・ツ「ツ療・ツ環?ath テ」ツつ?DFSテ」ツ?ァテヲツ篠「テ」ツ??\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\tint u = G[v][i];\n\t\tint w = match[u];\n\t\tif( w < 0 || !used[w] && dfs(w) ){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// テ、ツコツ古ゥツδィテ」ツつーテ」ツδゥテ」ツδ陛」ツ?ョテヲツ慊?・ツ、ツァテ」ツδ榲」ツδε」ツδ?」ツδウテ」ツつーテ」ツつ津ヲツアツづ」ツつ?」ツつ?\nint solve(){\n\tint res = 0;\n\tfor(int v=0 ; v < V ; v++ ){\n\t\tif( match[v] < 0 ){\n\t\t\t// テ・ツ按敕ヲツ慊淌・ツ個?\n\t\t\tfor(int i=0 ; i < V ; i++ ){\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t\tif( dfs(v) ){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n// テ・ツ按敕ヲツ慊淌・ツ個?\nvoid init(){\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tG[i].clear();\n\t\tmatch[i] = -1;\n\t}\n}\n\nint main(){\n\tint m, n;\n\twhile( cin >> m >> n , m || n ){\n\t\t// テ・ツ按敕ヲツ慊淌・ツ個?\n\t\tV = n + m;\n\t\tinit();\n\t\t\n\t\t// テ・ツ?・テ・ツ環?\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tcin >> b[i];\n\t\t}\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tcin >> r[i];\n\t\t}\n\t\t\n\t\t// テ」ツδ堙」ツつ「テ」ツつ津ヲツ篠「テ」ツ?療」ツ?ヲティツセツコテ」ツつ津ィツソツステ・ツ環?」ツ?療」ツ?ヲテ」ツ?甘」ツ??\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\tif( gcd(b[i], r[j]) >= 2 ){\n\t\t\t\t\tint u = i;\n\t\t\t\t\tint v = j + m;\n\t\t\t\t\tadd_edge(u,v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = solve();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct edge { int to, cap, rev; };\n\nconst int MAX_V = 1002;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap)\n{\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, 0, G[to].size() - 1});\n}\n\nint dfs(int v, int t, int f)\n{\n    if(v == t)\n        return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nlong long gcd(long long x, long long y)\n{\n    if(y > x)\n        swap(x, y);\n    return __gcd(x, y);\n}\n\nint main()\n{\n    int m, n, cards[202];\n    while(cin >> m >> n && m && n) {\n\n        for(int i = 0; i < MAX_V; i++) \n            G[i].clear();\n\n        for(int i = 0; i < m; i++) {\n            cin >> cards[1 + i];\n            add_edge(0, 1 + i, 1);\n        }\n\n        for(int i = 0; i < n; i++) {\n            cin >> cards[1 + m + i];\n            add_edge(1 + m + i, 1 + m + n, 1);\n        }\n        for(int i = 0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                if(gcd(cards[1 + i], cards[1 + m + j]) > 1) {\n                    add_edge(1 + i, 1 + m + j, 1);\n                }\n            }\n        }\n\n        int ans = 0;\n        while(true) {\n            fill(used, used + MAX_V, false);\n            int f = dfs(0, 1 + m + n, 1);\n            if(f == 0) \n                break;\n            ans += f;\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\ntypedef long long Int;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst) : src(src),dst(dst) {}\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) {}\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vec<Edge> Edges;\ntypedef vec<Edges> Graph;\n\n#define MAXMN 500\nint B[MAXMN];\nint R[MAXMN];\n\nint gcd(int a, int b)\n{   \n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\n\n\nmain() {\n  int M,N;\n  Graph g;\n  while(cin>>M>>N,M) {\n    g.clear();\n    g.resize(M+N+2);\n    REP(i,M) cin>>B[i];\n    REP(i,N) cin>>R[i];\n    REP(i,M) {\n      Edges es, es2;\n      REP(j,N) {\n\tif(gcd(B[i],R[j])!=1) { es.pb(Edge(i,M+j)); es2.pb(Edge(M+j,i)); }\n      }\n      g[i] = es;\n      g[M+i] = es2;\n    }\n    Edges matching;\n    cout << bipartiteMatching(g,M,matching) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000009;\nconst int INF = INT_MAX / 3;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nstruct edge { int to, cap, rev, cost; };\n\nconstexpr int MAX_V = 1000;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,cost });\n}\n\nvoid bfs(int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\t\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tint f;\n\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\ntypedef pair<int, int> P;\nint V;\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tfill_n(dist, V, numeric_limits<int>::max());\n\t\tdist[s] = 0;\n\t\tque.push({ 0,s });\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first)continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d*h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint m, n;\n\tvector<int> prime;\n\tvector<int> isprime(50000, 1);\n\tisprime[0] = isprime[1] = 0;\n\tfor(int i=0;i<50000;i++)\n\t\tif (isprime[i]) {\n\t\t\tprime.push_back(i);\n\t\t\tfor (int j = i * 2; j < 50000; j += i)\n\t\t\t\tisprime[j] = 0;\n\n\n\t\t}\n\twhile ( cin >> m >> n, m) {\n\t\tfor (int i = 0; i < MAX_V; i++)\n\t\t\tG[i].clear();\n\t\tvector<int> b(m);\n\t\tvector<int> r(n);\n\t\tREP(i, m)\n\t\t\tcin >> b[i];\n\t\tREP(i, n)\n\t\t\tcin >> r[i];\n\t\tREP(i, m) {\n\t\t\tadd_edge(n + m, i, 1);\n\n\t\t}\n\t\tREP(j, n) {\n\t\t\tadd_edge(j + m, m + n + 1, 1);\n\t\t}\n\t\tREP(i,m)\n\t\t\tREP(j,n) {\n\t\t\tfor (int k = 0; k < prime.size(); k++) {\n\t\t\t\tif (b[i]%prime[k]==0 && r[j]%prime[k]==0) {\n\t\t\t\t\tadd_edge(i, m + j, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t}\n\n\t\tcout << max_flow(n + m, n + m + 1) << endl;\n\n\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint m, n;\nint a[1000];\nvector<int> g[1000];\nint match[1000];\nbool used[1000];\n\nbool dfs(int v){\n\tused[v] = true;\n\tfor (int u : g[v]){\n\t\tint w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint solve(){\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < m + n; v++){\n\t\tif (match[v] < 0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v)) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &m, &n), m){\n\t\tfill_n(g, 1000, vector<int>());\n\t\tfor (int i = 0; i < m + n; i++){\n\t\t\tscanf(\"%d\", a + i);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tfor (int j = m; j < n + m; j++){\n\t\t\t\tif (__gcd(a[i], a[j]) > 1){\n\t\t\t\t\tg[i].push_back(j);\n\t\t\t\t\tg[j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nstruct edge{\n    int to, cap, rev;\n};\n\n#define MAX_V 1002\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size()-1});\n}\n\n// v...target vertex, t...end vertex, f...maximum flow \nint dfs(int v, int t, int f){\n    if(v == t)  return f;\n\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n\n    return 0;\n}\n\nconst int INF = 1<<29;\n\n// maxflow from s to t\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0)  return flow;\n        flow += f;\n    }\n}\n\nint gcd(int a, int b){\n    return b == 0 ? a : gcd(b, a%b);\n}\n\nint main(){\n    int m, n;\n    while(cin >> m >> n, m+n){\n        for(int i = 0; i < 1002; i++)   G[i].clear();\n        vector<int> b(m), r(n);\n        int SOURCE = 1000, SINK = 1001;\n        for(int i = 0; i < m; i++)  cin >> b[i], add_edge(SOURCE,i,1);\n        for(int i = 0; i < n; i++)  cin >> r[i], add_edge(i+m, SINK, 1);\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(gcd(b[i],r[j])>1)    add_edge(i, m+j, 1);\n            }\n        }\n        cout << max_flow(SOURCE, SINK) << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct edge { int to, cap, rev; };\n\nconst int MAX_V = 100000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap)\n{\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, 0, G[to].size() - 1});\n}\n\nint dfs(int v, int t, int f)\n{\n    if(v == t)\n        return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nlong long gcd(long long x, long long y)\n{\n    if(y > x)\n        return __gcd(y, x);\n    else\n        return __gcd(x, y);\n}\n\nint main()\n{\n    int m, n, cards[MAX_V];\n    while(cin >> m >> n && m && n) {\n\n        for(int i = 0; i < MAX_V; i++) \n            G[i].clear();\n\n        for(int i = 0; i < m; i++) {\n            cin >> cards[1 + i];\n            add_edge(0, 1 + i, 1);\n        }\n\n        for(int i = 0; i < n; i++) {\n            cin >> cards[1 + m + i];\n            add_edge(1 + m + i, 1 + m + n, 1);\n        }\n        for(int i = 0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                if(gcd(cards[1 + i], cards[1 + m + j]) > 1) {\n                    add_edge(1 + i, 1 + m + j, 1);\n                }\n            }\n        }\n\n        int ans = 0;\n        while(true) {\n            fill(used, used + MAX_V, false);\n            int f = dfs(0, 1 + m + n, 1);\n            if(f == 0) \n                break;\n            ans += f;\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define SIZE 1000\n\nusing namespace std;\n\nint m, n, b[501], r[501];\nint match[SIZE];\nbool used[SIZE];\nvector<int> G[SIZE];\n\nbool dfs(int v){\n\tused[v]=1;\n\tfor(int i=0; i<G[v].size(); i++){\n\t\tint u=G[v][i], w=match[u];\n\t\tif(w<0||!used[w]&&dfs(w)){\n\t\t\tmatch[v]=u, match[u]=v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid solve(){\n\tint res=0;\n\tmemset(match, -1, sizeof(match));\n\tfor(int v=0; v<m+n; v++){\n\t\tif(match[v]<0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif(dfs(v)) res++;\n\t\t}\n\t}\n\tcout<<res<<endl;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n && !m) break;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> b[i];\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcin >> r[i];\n\t\t}\n\t\tfor(int i=0; i<SIZE; i++) G[i].clear;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tint a=b[i], c=r[j];\n\t\t\t\twhile(c){\n\t\t\t\t\ta%=c;\n\t\t\t\t\tswap(a, c);\n\t\t\t\t}\n\t\t\t\tif(a!=1)G[i].push_back(j+n), G[n+j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define SORT(c) sort((c).begin(),(c).end())\n#define IINF INT_MAX\n#define LLINF LLONG_MAX\n \ntypedef long long ll;\ntypedef pair<int, int> ii;\n\n#define DEBUG false\n\n#define MAX_V 1100\n\nint V;\nvector<vector<int>> G(1100);\nint match[MAX_V];\nbool used[MAX_V];\n\nbool dfs(int v){\n\tused[v] = true;\n\trep(i, G[v].size()){\n\t\tint u = G[v][i], w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nll solve(){\n\tll ret = 0;\n\tmemset(match, -1, sizeof(match));\n\trep(v, V){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif(dfs(v)) ret++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\n\tll n, m;\n\t/*\n\tvector<int> prime;\n\tvector<bool> used(10000001);\n\tREP(i, 2, 10000001){\n\t\tif(!used[i]) prime.push_back(i);\n\t\tfor(int j = 2; i * j < 10000001; j++) used[i*j] = true;\n\t}\n\t*/\n\t\n\twhile(cin >> n >> m){\n\t\tif(n == 0 && m == 0) break;\n\t\t\n\t\trep(i, MAX_V) G[i].clear();\n\t\tV = n + m;\n\t\tvector<ll> b(n), r(m);\n\t\trep(i, n) cin >> b[i];\n\t\trep(i, m) cin >> r[i];\n\t\t\n\t\trep(i, n){\n\t\t\trep(j, m){\n\t\t\t\tif(__gcd(b[i], r[j]) != 1){\n\t\t\t\t\t\tG[i].push_back(n+j);\n\t\t\t\t\t\tG[n+j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tcout << solve() << endl;\n\t\n\t\t\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define INF 1<<30\nconstexpr int gcd(int a,int b){return b?gcd(b,a%b):a;}\nconstexpr int lcm(int a,int b){return a*b/gcd(a,b);}\n\nstruct MaxFlow{\n    struct edge{\n        int to,cap,rev;\n        edge(int t, int c, int r):to(t),cap(c),rev(r){}\n    };\n    vector<vector<edge>> g;\n    vector<bool> used;\n    MaxFlow(int n){\n        g=vector<vector<edge>>(n);\n        used=vector<bool>(n);\n    }\n    void add(int from, int to, int cap){\n        g[from].eb(to,cap,g[to].size());\n        g[to].eb(from,0,g[from].size()-1);\n    }\n    int dfs(int v, int t, int f){\n        if(v==t) return f;\n        used[v]=true;\n        rep(i,g[v].size()){\n            auto &e=g[v][i];\n            if(!used[e.to] && e.cap>0){\n                int d=dfs(e.to, t, min(f,e.cap));\n                if(d>0){\n                    e.cap-=d;\n                    g[e.to][e.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int calcMF(int s, int t){\n        int flow=0;\n        while(1){\n            fill(all(used),false);\n            int f=dfs(s,t,INF);\n            if(f==0) return flow;\n            flow+=f;\n        }\n    }\n};\n\nint main(){\n\tint m,n;\n\twhile(cin>>m>>n,n){\n\t    MaxFlow mf(m+n+2);\n\t    int s=m+n,t=m+n+1;\n        vi b(m),r(n);\n        rep(i,m){\n            cin>>b[i];\n            mf.add(s,i,1);\n        }\n        rep(i,n){\n            cin>>r[i];\n            mf.add(m+i,t,1);\n            rep(j,m){\n                if(gcd(b[j],r[i])!=1){\n                    mf.add(j,m+i,1);\n                }\n            }\n        }\n        cout<<mf.calcMF(s,t)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nclass Bipartite_Matching {\n    vector<vector<int>> G;\n    vector<int> match, used, alive;\n    int t;\npublic:\n    explicit Bipartite_Matching(int n): t(0), G(n), match(n, -1), used(n, 0), alive(n, -1){};\n\n    void connect(int a, int b){\n        G[a].emplace_back(b);\n        G[b].emplace_back(a);\n    }\n\n    bool dfs(int x){\n        used[x] = t;\n        for (auto &&i : G[x]) {\n            int w = match[i];\n            if(alive[i] == 0) continue;\n            if(w == -1 || (used[w] != t && dfs(w))){\n                match[x] = i;\n                match[i] = x;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int matching() {\n        int ans = 0;\n        for (int i = 0; i < G.size(); ++i) {\n            if(alive[i] == 0) continue;\n            if(match[i] == -1) {\n                ++t;\n                ans += dfs(i);\n            }\n        }\n        return ans;\n    }\n};\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n|m) {\n        vector<int> v(n), u(m);\n        for (auto &&i : v) scanf(\"%d\", &i);\n        for (auto &&j : u) scanf(\"%d\", &j);\n        Bipartite_Matching G(n+m);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if(__gcd(v[i], u[j]) > 1){\n                    G.connect(i, n+j);\n                }\n            }\n        }\n        cout << G.matching() << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef vector<int> Node;\ntypedef vector<Node> Graph;\nint V1, V2;\nGraph G;\nint dist[1002];\nint match[1002];\nconst int NIL = 1001;\nbool BFS(){\n  queue<int> que;\n  REP(v, V1){\n    if(match[v] == NIL){\n      dist[v] = 0;\n      que.push(v);\n    }else{\n      dist[v] = INF;\n    }\n  }\n  dist[NIL] = INF;\n  while(!que.empty()){\n    int v = que.front(); que.pop();\n    if(dist[v] < dist[NIL]){\n      for(int i = 0; i < G[v].size(); i++){\n        int u = G[v][i];\n        if(dist[match[u]] == INF){\n          dist[match[u]] = dist[v] + 1;\n          que.push(match[u]);\n        }\n      }\n    }\n  }\n  return dist[NIL] != INF;\n}\n\nbool DFS(int v){\n  if(v != NIL){\n    for(int i = 0; i < G[v].size(); i++){\n      int u = G[v][i];\n      if(dist[match[u]] == dist[v] + 1 && DFS(match[u])){\n        match[u] = v;\n        match[v] = u;\n        return true;\n      }\n    }\n    dist[v] = INF;\n    return false;\n  }\n  return true;\n}\n\nint Hopcroft_Karp(){\n  REP(v, G.size()) match[v] = NIL;\n  int matching = 0;\n  while(BFS()){\n    REP(v, V1){\n      if(match[v] == NIL && DFS(v)){\n        matching ++;\n      }\n    }\n  }\n  return matching;\n}\nint main(){\n  while(scanf(\"%d %d\", &V1, &V2) && (V1 != 0 || V2 != 0)){\n    G = Graph(V1 + V2);\n    static int blue[500];\n    static int red[500];\n    REP(i, V1) scanf(\"%d\", blue + i);\n    REP(i, V2) scanf(\"%d\", red + i);\n    REP(u, V1) REP(v, V2){\n      if(__gcd(blue[u], red[v]) != 1) {\n        G[u].push_back(V1 + v);\n        //G[V1 + v].push_back(u);\n      }\n    }\n    printf(\"%d\\n\", Hopcroft_Karp());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n/*bipartite_matching(二部グラフの最大マッチングを求める)*/\n\nconst int MAX_V = 1500;\nint V;//頂点数\nvector<int> G[MAX_V];//グラフの隣接リスト表現\nint match[MAX_V];//マッチングのペア\nbool used[MAX_V];//DFSですでに調べたかのフラグ\n//uとvを結ぶ辺をグラフに追加する\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n//増加パスをDFSで探す\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tint u = G[v][i];\n\t\tint w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n//二部グラフの最大マッチングを求める\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match,-1,sizeof(used));\n\tfor(int v = 0;v < V;v++){\n\t\tif(match[v]<0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>m>>n,n||m){\n\t\tint blue[m];//青のカード\n\t\tint red[n];//赤のカード\n\t\tmemset(blue,0,sizeof(blue));\n\t\tmemset(red,0,sizeof(red));\n\t\tV = n+m;//頂点数は合計\n\t\trep(i,V){\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tcin>>blue[i];\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin>>red[i];\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tfor(int j =0;j < n;j++){\n\t\t\t\tif(__gcd(blue[i],red[j])==1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tadd_edge(i,j+m);//0~m-1を青,m~m+n-1を赤とする\n\t\t\t}\n\t\t}\n\t\tcout <<bipartite_matching()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data);\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for (const T &x : vec) os << x << \" \";\n    return os;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\n//const int dx[] = {-1, 0, 1, 0};\n//const int dy[] = {0, 1, 0, -1};\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n        T d = EXTGCD(-a, b, x, y);\n        x = -x;\n        return d;\n    }\n    if (b < 0) {\n        T d = EXTGCD(a, -b, x, y);\n        y = -y;\n        return d;\n    }\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    } else {\n        T d = EXTGCD(b, a % b, x, y);\n        T t = x;\n        x = y;\n        y = t - (a / b) * y;\n        return d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T) (SQR(i)) < b; i++) {\n        if (small[i]) {\n            for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n                prime[j - a] = false;\n            }\n        }\n    }\n\n    return prime;\n}\n\n//約数\ntemplate<class T>\n//vector<T> DIVISOR(T n) {\n//    vector<T> v;\n//    for (int i = 1; i * i <= n; ++i) {\n//        if (n % i == 0) {\n//            v.push_back(i);\n//            if (i != n / i) {\n//                v.push_back(n / i);\n//            }\n//        }\n//    }\n//    sort(v.begin(), v.end());\n//    return v;\n//}\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//組み合わせ個数\ntemplate<typename T>\nT NCR(T n, T r) {\n    T ans = 1;\n    REPLL(i, r) {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//行列\nint MATRIZ_CHAIN(VI &p, VVI &s) {\n    const static int INF = 1 << 20;\n    const int n = p.size() - 1;\n    VVI X(n, VI(n, INF));\n    s.resize(n, VI(n));\n    for (int i = 0; i < n; ++i) X[i][i] = 0;\n    for (int w = 1; w < n; ++w)\n        for (int i = 0, j; j = i + w, j < n; ++i)\n            for (int k = i; k < j; ++k) {\n                int f = p[i] * p[k + 1] * p[j + 1];\n                if (X[i][k] + X[k + 1][j] + f < X[i][j]) {\n                    X[i][j] = X[i][k] + X[k + 1][j] + f;\n                    s[i][j] = k;\n                }\n            }\n    return X[0][n - 1];\n}\n\n//最長増加部分列\nVI LIS(const VI &a) {\n    const static int INF = 99999999;\n    const int n = a.size();\n    VI A(n, INF);\n    VI id(n);\n    for (int i = 0; i < n; ++i) {\n        id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n        A[id[i]] = a[i];\n    }\n    int m = *max_element(id.begin(), id.end());\n    VI b(m + 1);\n    for (int i = n - 1; i >= 0; --i)\n        if (id[i] == m) b[m--] = a[i];\n    return b;\n}\n\n//最長共通部分列 string->toVC\ntemplate<typename T>\nvector<T> LCS(const vector<T> &a, const vector<T> &b) {\n    const int n = a.size(), m = b.size();\n    vector<VI> X(n + 1, VI(m + 1));\n    vector<VI> Y(n + 1, VI(m + 1));\n    REP(i, n) {\n        REP(j, m) {\n            if (a[i] == b[j]) {\n                X[i + 1][j + 1] = X[i][j] + 1;\n                Y[i + 1][j + 1] = 0;\n            } else if (X[i + 1][j] < X[i][j + 1]) {\n                X[i + 1][j + 1] = X[i][j + 1];\n                Y[i + 1][j + 1] = +1;\n            } else {\n                X[i + 1][j + 1] = X[i + 1][j];\n                Y[i + 1][j + 1] = -1;\n            }\n        }\n    }\n    vector<T> c;\n    for (int i = n, j = m; i > 0 && j > 0;) {\n        if (Y[i][j] > 0) --i;\n        else if (Y[i][j] < 0) --j;\n        else {\n            c.PB(a[i - 1]);\n            --i;\n            --j;\n        }\n    }\n    REVERSE(c);\n    return c;\n}\n\n//コイン C総額 cs使用できるコインの種類\nVI money_change(int C, VI &cs) {\n    const int INF = 99999999;\n    int n = cs.size();\n    VI xs(C + 1, INF);\n    VI ys(C + 1);\n    xs[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int c = 0; c + cs[i] <= C; ++c) {\n            if (xs[c + cs[i]] > xs[c] + 1) {\n                xs[c + cs[i]] = xs[c] + 1;\n                ys[c + cs[i]] = c;\n            }\n        }\n    }\n    VI zs;\n    for (int c = C; c > 0; c = ys[c]) {\n        zs.push_back(c - ys[c]);\n    }\n    return zs;\n}\n\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\n#define MAX_V 3000\n#define INF (1<<20)\n\nstruct Edge {\n    int to;\n    int cap;\n    int rev;\n};\n\nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((Edge) {to, cap, (int) G[to].size()});\n    G[to].push_back((Edge) {from, 0, (int) G[from].size()});\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n\n    used[v] = true;\n\n    for (int i = 0; i < G[v].size(); i++) {\n        Edge &e = G[v][i];\n\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(e.cap, f));\n\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n\n        }\n\n    }\n\n\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (true) {\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0) {\n            return flow;\n        }\n        flow += f;\n    }\n}\n\n\nint main() {\n\n    while (true) {\n        int m, n;\n        cin >> m >> n;\n\n        if (m == 0 && n == 0) break;\n\n        for (int i = 0; i < MAX_V; i++) {\n            G[i] = vector<Edge>();\n        }\n\n        VI b(m);\n        for (int i = 0; i < m; i++) cin >> b[i];\n        VVI blueDivisor(m);\n        for (int i = 0; i < m; i++) blueDivisor[i] = DIVISOR(b[i]), blueDivisor[i].erase(blueDivisor[i].begin());\n\n        VI r(n);\n        for (int i = 0; i < n; i++) cin >> r[i];\n        VVI redDivisor(n);\n        for (int i = 0; i < n; i++) redDivisor[i] = DIVISOR(r[i]), redDivisor[i].erase(redDivisor[i].begin());\n\n        int s = 0;\n        int t = m + n + 1;\n\n        for (int i = 0; i < m; i++) {\n            add_edge(s, i + 1, 1);\n        }\n        for (int i = 0; i < n; i++) {\n            add_edge(i + m + 1, t, 1);\n        }\n\n        for (int i = 0; i < m; i++) {\n            VI blue = blueDivisor[i];\n            for (int j = 0; j < n; j++) {\n                VI red = redDivisor[j];\n                bool exist = false;\n                for (int k = 0; k < blue.size(); k++) {\n                    if (VECTOR_EXISTS(red, blue[k])) exist = true;\n                }\n                if (exist) {\n                    int left = s + i + 1;\n                    int right = s + j + m + 1;\n                    add_edge(left, right, 1);\n                }\n            }\n        }\n\n        int ans = max_flow(s, t);\n\n        OUT_L(ans);\n\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\ntypedef vector<vector<int> > G;\n\nint flow(G &g, int s, int d){\n  int n = g.size();\n  int ans = 0;\n\n  while(true){\n    vector<int> prevs(n,-1);\n    queue<int> q;\n    bool ok = false;\n\n    prevs[s]=n;\n    q.push(s);\n    while(!q.empty()){\n      int now = q.front();\n      q.pop();\n      if(now == d){\n        ok = true;\n        break;\n      }\n      for(int i=0;i<n;i++){\n        if(g[now][i]>0){\n          if(prevs[i]==-1){\n            prevs[i]=now;\n            q.push(i);\n          }\n        }\n      }\n    }\n\n    if(!ok) return ans;\n\n    int f = 100000;\n    int pos = d;\n    while(pos != s){\n      int pos2 = prevs[pos];\n      f = min(f,g[pos2][pos]);\n      pos = pos2;\n    }\n    pos = d;\n    while(pos != s){\n      int pos2 = prevs[pos];\n      g[pos2][pos]-=f;\n      g[pos][pos2]+=f;\n      pos = pos2;\n    }\n    ans += f;\n  }\n}\n\nint gcd(int a, int b){\n  if(a > b) swap(a, b);\n  if(a == 0) return b;\n  return gcd(a, b%a);\n}\n\n\nint main(){\n  int m,n;\n  int r[500];\n  int b[500];\n  while((m = getInt()) + (n = getInt())){\n    vector<vector<int> > g(n+m+2, vector<int>(n+m+2, 0));\n\n    REP(i,m){\n      b[i] = getInt();\n      g[n+m][i] = 1;\n    }\n    REP(i,n){\n      r[i] = getInt();\n      g[m+i][n+m+1] = 1;\n    }\n\n    REP(i,m) REP(j,n) if(gcd(b[i], r[j]) != 1)\n      g[i][m+j] = 1;\n\n    print(flow(g, n+m, n+m+1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int>L[1000];int N,M,E,i,j,match[1000],x[1000],y[1000];bool used[1000];\nbool DFS(int V){\n\tused[V]=true;\n\tfor(i=0;i<L[V].size();i++){\n\t\tint u=L[V][i],w=match[u];\n\t\tif(w<0||!used[w]&&DFS(w)){\n\t\t\tmatch[V]=u;\n\t\t\tmatch[u]=V;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint SM(){\n\tint r=0;\n\tmemset(match,-1,sizeof(match));\n\tfor(j=0;j<N+M;j++){\n\t\tif(match[j]<0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(DFS(j)){r++;}\n\t\t}\n\t}\n\treturn r;\n}\nint main(){\n\twhile(1){\n\t\tfor(i=0;i<1000;i++){L[i].clear();}\n\t\tcin>>N>>M;if(!N){break;}\n\t\tfor(i=0;i<N;i++){\n\t\t\tcin>>x[i];\n\t\t}\n\t\tfor(i=0;i<M;i++){\n\t\t\tcin>>y[i];\n\t\t}\n\t\tfor(i=0;i<N;i++){\n\t\t\tfor(j=0;j<M;j++){\n\t\t\t\tif(__gcd(x[i],y[j])>1){\n\t\t\t\t\tL[i].push_back(j+N);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<SM()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nconstexpr int MAX_V = 1000;\n \nclass twoMatching {\nprivate:\n  vector<int> G[MAX_V];\n  int match[MAX_V];\n  bool used[MAX_V];\n  int V;\npublic:\n  twoMatching(int v) {\n    V = v;\n  }\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n \n  bool dfs(int v) {\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n      int u = G[v][i], w = match[u];\n      if (w < 0 || !used[w] && dfs(w)) {\n    match[v] = u;\n    match[u] = v;\n    return true;\n      }\n    }\n    return false;\n  }\n \n  int bipartite_matching() {\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for (int v = 0; v < V; v++) {\n      if (match[v] < 0) {\n    memset(used, 0, sizeof(used));\n    if (dfs(v)) res++;\n      }\n    }\n    return res;\n  }\n};\n \nint prime[1000]; // max 4000\nint primeNumber = 0;\n \nint main() {\n  int m, n;\n  int b[500], r[500];\n  for (int i = 2; i < 4000; i++) {\n    bool check = true;\n    for (int j = 0; j < primeNumber; j++) {\n      if (i % prime[j] == 0) {\n        check = false;\n        break;\n      }\n    }\n    if (check) {\n      prime[primeNumber] = i;\n      primeNumber++;\n    }\n  }\n \n  while (1) {\n    scanf(\"%d%d\", &m, &n);\n    if (m == 0) break;\n    for (int i = 0; i < m; i++) scanf(\"%d\", &b[i]);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &r[i]);\n    twoMatching t(m + n);\n    for (int i = 0; i < primeNumber; i++) {\n      for (int j = 0; j < m; j++) {\n        if (b[j] % prime[i] != 0) continue;\n        for (int k = 0; k < n; k++) {\n          if (r[k] % prime[i] != 0) continue;\n          t.add_edge(j, k + m);\n        }\n      }\n    }\n    printf(\"%d\\n\", t.bipartite_matching());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nint bipartiteMaximumMatchings(const vector<vector<bool> >& graph)\n{\n    int answer = 0;\n    int n = graph.size();\n    int m = graph[0].size();\n    vector<int> selectN(n, -1);\n    vector<int> selectM(m, -1);\n\n    for(int i=0; i<n; ++i){\n        vector<bool> visitedN(n, false);\n        vector<bool> visitedM(m, false);\n        visitedN[i] = true;\n        vector<int> path(min(n,m)*2, -1);\n\n        path[0] = i;\n        int index = 1;\n        for(;;){\n            while(++path[index] < m && (!graph[path[index-1]][path[index]] || selectN[path[index-1]]==path[index] || visitedM[path[index]]));\n            if(path[index] < m){\n                if(selectM[path[index]] == -1){\n                    for(int j=0; j<index; j+=2){\n                        selectN[path[j]] = path[j+1];\n                        selectM[path[j+1]] = path[j];\n                    }\n                    ++ answer;\n                    break;\n                }\n                if(!visitedN[selectM[path[index]]]){\n                    path[index+1] = selectM[path[index]];\n                    visitedM[path[index]] = true;\n                    visitedN[path[index+1]] = true;\n                    index += 2;\n                }\n            }\n            else{\n                path[index] = -1;\n                index -= 2;\n                if(index < 0)\n                    break;\n            }\n        }\n\n\t\tif(answer == m)\n\t\t\tbreak;\n    }\n\n    return answer;\n}\n\nvoid solve(const vector<int>& blue, const vector<int>& red)\n{\n\tvector<vector<bool> > graph(blue.size(), vector<bool>(red.size(), false));\n\tfor(unsigned i=0; i<blue.size(); ++i){\n\t\tvector<int> num;\n\t\tint a = blue[i];\n\t\tint b = 2;\n\t\twhile(a >= b*b){\n\t\t\tif(a % b == 0){\n\t\t\t\tnum.push_back(b);\n\t\t\t\twhile(a % b == 0)\n\t\t\t\t\ta /= b;\n\t\t\t}\n\t\t\t++ b;\n\t\t}\n\t\tif(a > 1)\n\t\t\tnum.push_back(a);\n\n\t\tfor(unsigned j=0; j<red.size(); ++j){\n\t\t\tfor(unsigned k=0; k<num.size(); ++k){\n\t\t\t\tif(red[j] % num[k] == 0){\n\t\t\t\t\tgraph[i][j] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << bipartiteMaximumMatchings(graph) << endl;\n}\n\nint main()\n{\n    for(;;){\n        int m, n;\n        cin >> m >> n;\n        if(m == 0 && n == 0)\n            break;\n\n\t\tvector<int> blue(m);\n\t\tvector<int> red(n);\n\t\tfor(int i=0; i<m; ++i)\n\t\t\tcin >> blue[i];\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tcin >> red[i];\n\n        solve(blue, red);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;vector<int> L[2000];int N,M,E,C[2000],x[2000],y[2000];bool U[2000];bool D(int V){U[V]=true;for(int i=0;i<L[V].size();i++){int u=L[V][i],w=C[u];if(w<0||!U[w]&&D(w)){C[V]=u;C[u]=V;return 1;}}return 0;}int SM(){int r=0;memset(C,-1,8000);for(int j=0;j<N+M;j++){if(C[j]<0){memset(U,0,8000);if(D(j)){r++;}}}return r;}main(){while(1){for(int i=0;i<2000;i++){L[i].clear();}cin>>N>>M;if(!N){break;}for(int i=0;i<N;i++){cin>>x[i];}for(int i=0;i<M;i++){cin>>y[i];}for(int i=0;i<N;i++){for(int j=0;j<M;j++){if(__gcd(x[i],y[j])>1){L[i].push_back(j+N);}}}cout<<SM()<<endl;}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define pii pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< pii >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define in(x, a, b) ((a) <= (x) && (x) < (b))\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0};\n// 01Trie BIT CHT DFT FFT avl cmd cusum dijkstra dinic geo2 gin graph kruskal lca lcm matrix ncm next_combination ppuf segtree st tmp topcoder uf vi \n\n//最大公約数\nint gcd(int x, int y) { return y ? gcd(y, x%y) : x; }\n//最小公倍数\nint lcm(int x, int y) { return x / gcd(x, y) * y; }\n//最大公約数 複数個\nint gcd(const vector<int> &v) {\n    int ret = v[0];\n    for (int i = 1; i < v.size(); i++)\n        ret = gcd(ret, v[i]);\n    return ret;\n}\n//最小公倍数 複数個\nint lcm(const vector<int> &v) {\n    int ret = v[0];\n    for (int i = 1; i < v.size(); i++)\n        ret = lcm(ret, v[i]);\n    return ret;\n}\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n    int s, d; Weight w; Flow c;\n    Edge() {};\n    Edge(int s, int d, Weight w = 1) : s(s), d(d), w(w), c(w) {};\n};\nbool operator<(const Edge &e1, const Edge &e2) { return e1.w < e2.w; }\nbool operator>(const Edge &e1, const Edge &e2) { return e2 < e1; }\ninline ostream &operator<<(ostream &os, const Edge &e) { return (os << '(' << e.s << \", \" << e.d << \", \" << e.w << ')'); }\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nvoid addArc(Graph &g, int s, int d, Weight w = 1) {\n    g[s].emplace_back(s, d, w);\n}\nvoid addEdge(Graph &g, int a, int b, Weight w = 1) {\n    addArc(g, a, b, w);\n    addArc(g, b, a, w);\n}\n\n/* \n * 必ずgraphも一緒にincludeすること\n */\nstruct Dinic {\n    int n, s, t;\n    vector<int> level, prog, que;\n    vector< vector< Flow > > cap, flow;\n    vector< vector < int > > g;\n    Flow inf;\n    Dinic(const Graph &graph)\n        : n(graph.size()),\n        cap(n, vector<Flow>(n)),\n        flow(n, vector<Flow>(n)),\n        g(n, vector<int>()),\n        inf(numeric_limits<Flow>::max() / 8) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < graph[i].size(); j++) {\n                    Edge e = graph[i][j];\n                    int u = e.s, v = e.d;\n                    Flow c = e.c;\n                    cap[u][v] += c;\n                    cap[v][u] += c;\n                    flow[v][u] += c;\n                    g[u].push_back(v);\n                    g[v].push_back(u);\n                }\n            }\n        }\n    inline Flow residue(int u, int v) { return cap[u][v] - flow[u][v]; }\n    Flow solve(int s_, int t_) {\n        this->t = t_, this->s = s_;\n        que.resize(n + 1);\n        Flow res = 0;\n        while (levelize()) {\n            prog.assign(n, 0);\n            res += augment(s, inf);\n        }\n        return res;\n    }\n    bool levelize() {\n        int l = 0, r = 0;\n        level.assign(n, -1);\n        level[s] = 0;\n        que[r++] = s;\n        while (l != r) {\n            int v = que[l++];\n            if (v == t) break;\n            for (int i = 0; i < g[v].size(); i++) {\n                int d = g[v][i];\n                if (level[d] == -1 && residue(v, d) != 0) {\n                    level[d] = level[v] + 1;\n                    que[r++] = d;\n                }\n            }\n        }\n        return level[t] != -1;\n    }\n    Flow augment(int v, Flow lim) {\n        Flow res = 0;\n        if (v == t) return lim;\n        for (int &i = prog[v]; i < (int)g[v].size(); i++) {\n            const int &d = g[v][i];\n            if (residue(v, d) == 0 || level[v] >= level[d]) continue;\n            const Flow aug = augment(d, min(lim, residue(v, d)));\n            flow[v][d] += aug;\n            flow[d][v] -= aug;\n            res += aug;\n            lim -= aug;\n            if (lim == 0) break;\n        }\n        return res;\n    }\n};\n\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    while (cin >> n >> m, m) {\n        vector<int> a(n);\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        vector<int> b(m);\n        for (int i = 0; i < m; i++) {\n            cin >> b[i];\n        }\n        Graph g(n+m+2);\n        for (int i = 1; i <= n; i++) {\n            addArc(g, 0, i, 1);\n        }\n        for (int i = 1; i <= m; i++) {\n            addArc(g, n+i, n+m+1, 1);\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (gcd(a[i], b[j]) != 1) {\n                    addArc(g, i+1, n+j+1, 1);\n                }\n            }\n        }\n        Dinic funami(g); \n        cout << funami.solve(0, n+m+1) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond(b);i<i##_cond;++i)\n#define sz(x) ((int)(x).size())\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n#define inf 1<<30\n\nvector<int> prime(int n){\n  // n以下の素数を要素に持つviを返す\n  // 時間 O(n ln ln n)\n  // 答えのサイズ n / ln n\n\n  vector<bool> isprime(n+1,true);\n  vector<int> ans;\n  isprime[0] = isprime[1] = false;\n  FOR(i,2,n+1)\n    if(isprime[i]){\n      ans.push_back(i);\n      for(int j = 2 * i; j <= n; j += i) isprime[j] = false;\n    }\n  return ans;\n}\n\n// dinic\nstruct max_flow {\n    struct edge { int to, cap, rev; };\n    int V;\n    vector<vector<edge>> G;\n    vector<int> itr, level;\n\n    max_flow(int _V) : V(_V) { G.assign(_V,vector<edge>()); }\n\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back((edge) {to, cap, (int) G[to].size()});\n        G[to].push_back((edge) {from, 0, (int) G[from].size()-1});\n    }\n\n    void bfs(int s) {\n        level.assign(V,-1);\n        queue<int> q;\n        level[s] = 0; q.push(s);\n        while (!q.empty()) {\n            int v = q.front(); q.pop();\n            for(auto &e: G[v]){\n                if (e.cap > 0 and level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int& i = itr[v]; i < (int) G[v].size(); ++i) {\n            edge& e = G[v][i];\n            if (e.cap > 0 and level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int run(int s, int t) {\n        int ret = 0, f;\n        while (bfs(s), level[t] >= 0) {\n            itr.assign(V,0);\n            while ((f = dfs(s, t, inf)) > 0) ret += f;\n        }\n        return ret;\n    }\n};\n\nint main(){  \n  vi p = prime(10000000);\n  \n  while(1){\n    // input\n    int m, n; cin >> m >> n; if(m == 0) break;\n    vi b(m); rep(i,m) cin >> b[i];\n    vi r(n); rep(i,n) cin >> r[i];\n\n    // rの素因数分解\n    vvi factor(n,vi(sz(p)));\n    rep(i,n) rep(j,sz(p))\n      if(r[i] % p[j] == 0) factor[i][j] = 1;\n\n    // フロー\n    struct max_flow f(n+m+2); // 左右+1+1\n    rep(i,m) f.add_edge(0,i+1,1); // sから左側\n    rep(i,n) f.add_edge(m+i+1,m+n+1,1); // 右側からt\n\n    // 同じ素因数を持つとき辺を追加\n    rep(i,m) rep(j,sz(p))\n      if(b[i] % p[j] == 0)\n\trep(k,n)\n\t  if(factor[k][j])\n\t    f.add_edge(i+1,m+k+1,1);\n\n    // フローを流す\n    int ans = f.run(0,n+m+1);\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint gcd(int a,int b){\n    if(a<b)return gcd(b,a);\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\n\nbool check(int a,int b){\n    return gcd(a,b)!=1;\n}\n\n\nint main(){\n    \n    while(true){\n        bool arr[501][501];\n        vector<int> a;\n        vector<int> b;\n\n        int n,m;\n        cin>>n>>m;\n        if(n==0&&m==0)return 0;\n        for(int i=0;i<n;i++){int t;cin>>t;a.push_back(t);}\n        for(int i=0;i<m;i++){int t;cin>>t;b.push_back(t);}\n        \n        for(int i=0;i<n;i++)\n            for(int k=0;k<m;k++){\n                arr[i][k]=check(a[i],b[k]);\n            }\n\n        int ans=0;\n\n        for(int i=1;;i++){\n            bool flag = true;\n\n            int ea,eb;\n            int n=100000;\n            for(int k=0;k<a.size();k++){\n                vector<int> v;\n                for(int j=0;j<b.size();j++){\n                    if(a[k]!=0&&b[j]!=0&&/*check(a[k],b[j])*/arr[k][j]){\n                        v.push_back(j);\n                    }\n                }\n                if(v.size()!=0 && v.size()<n){\n                    flag=false;\n                    n=v.size();\n                    ea = k;\n                    eb = v[0];\n                }\n            }\n            for(int j=0;j<b.size();j++){\n                vector<int> v;\n                for(int k=0;k<a.size();k++){\n                    if(a[k]!=0&&b[j]!=0&&/*check(a[k],b[j])*/arr[k][j]){\n                        v.push_back(k);\n                    }\n                }\n                if(v.size()!=0 && v.size()<n){\n                   flag=false;\n                   n = v.size();\n                   ea=v[0];\n                   eb=j;\n                }\n            }\n            if(flag)break; else{\n                a[ea]=0;\n                b[eb]=0;\n                ans++;\n            }\n         }\n          cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<set>\n#include<string>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#define P pair<int ,int>\n#define MAX_N 1002\nusing namespace std;\n#define rep(i,a) for(int i = 0;i < a; i++)\n\nstruct E{\n\tint to, cap, rev;\n\tE(int t, int c, int r) : to(t), cap(c), rev(r){}\n};\n//始点0, 終点1\nvector<E> G[MAX_N];\nbool f[MAX_N];\nconst int INF = 1 << 10;\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(E(to, cap, G[to].size()));\n\tG[to].push_back(E(from, 0, G[from].size() - 1));\n}\n\nint gcd(int x, int y)\n{\n\tif (!x | !y) return 0;\n\t\n\twhile (x != y) {\n\t\tif (x > y) x -= y;\n\t\telse y -= x;\n\t}\n\t\n\treturn x;\n}\n\nbool dfs(int s, int e, int fl) {\n\tif (s == e) return fl;\n\tf[s] = 1;\n\trep(i, G[s].size()) {\n\t\tE &ed = G[s][i];\n\t\tif (!f[ed.to] && ed.cap > 0) {\n\t\t\tint d = dfs(ed.to, e, min(fl, ed.cap));\n\t\t\tif (d > 0) {\n\t\t\t\ted.cap -= d;\n\t\t\t\tG[ed.to][ed.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint max_flow(int src, int snk)\n{\n\tint flow = 0;\n\t\n\twhile (1) {\n\t\tmemset(f, 0, sizeof(f));\n\t\tint fl = dfs(src, snk, INF);\n\t\tif (fl == 0) break;\n\t\tflow += fl;\n\t}\n\t\n\treturn flow;\n}\n\nint main()\n{\n\tint m, n;\n\tint b[MAX_N];\n\t\n\twhile (cin >> m >> n, m) {\n\t\trep(i, MAX_N) G[i].clear();\n\t\t\n\t\trep(i, m) {\n\t\t\tcin >> b[i];\n\t\t\tadd_edge(0, i + 2, 1);\n\t\t}\n\t\t\n\t\tint r;\n\t\trep(i, n) {\n\t\t\t cin >> r;\n\t\t\t add_edge(m + 2 + i, 1, 1);\n\t\t\t rep(j ,m) {\n\t\t\t \t if (gcd(r, b[j]) > 1) {\n\t\t\t \t \t add_edge(j + 2, m + 2 + i, 1);\n\t\t\t \t }\n\t\t\t }\n\t\t}\n\n\t\tint res = max_flow(0, 1);\n\t\t\n\t\tcout << res << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int INF=1000;\nstruct edge{\n    int to,cap,rev;\n};\nvector<edge> graph[1010];\nbool used[1010];\nvoid add_edge(int from,int to,int cap){\n    graph[from].push_back((edge){to,cap,static_cast<int>(graph[to].size())});\n    graph[to].push_back((edge){from,0,static_cast<int>(graph[from].size()-1)});\n}\nint dfs(int at,int t,int f){\n    if(at==t) return f;\n    used[at]=true;\n    for(int i=0;i<graph[at].size();i++){\n        edge &now=graph[at][i];\n        if(!used[now.to] && now.cap>0){\n            int d=dfs(now.to,t,min(f,now.cap));\n            if(d>0){\n                now.cap-=d;\n                graph[now.to][now.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s,int t,int V){\n    int flow=0;\n    for(;;){\n        for(int i=0;i<V;i++){\n            used[i]=false;\n        }\n        int f=dfs(s,t,INF);\n        if(f==0) return flow;\n        flow+=f;\n    }\n}\n\nint b[510],r[510];\nint main(){\n    int m,n;\n    for(;;){\n        scanf(\"%d%d\",&m,&n);\n        if(m==0 && n==0) break;\n        fill(graph,graph+m+n+2,vector<edge>());\n        for(int i=0;i<m;i++){\n            add_edge(m+n,i,1);\n            scanf(\"%d\",&b[i]);\n        }\n        for(int i=0;i<n;i++){\n            add_edge(i+m,m+n+1,1);\n            scanf(\"%d\",&r[i]);\n        }\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(__gcd(b[i],r[j])>1) add_edge(i,j+m,1);\n            }\n        }\n        printf(\"%d\\n\",max_flow(m+n,m+n+1,m+n+2));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nconst int DINIC_MAX_V=1002;\nconst int DINIC_v_size=1002;\n//const int INF=99999999;\nvector<pair<pair<int,int> ,int> >DINIC_G[DINIC_MAX_V];\nint DINIC_level[DINIC_MAX_V];\nint DINIC_iter[DINIC_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tDINIC_G[from].push_back(make_pair(make_pair(to,cap),DINIC_G[to].size()));\n\tDINIC_G[to].push_back(make_pair(make_pair(from,0),DINIC_G[from].size()-1));\n}\nvoid DINIC_bfs(int s){\n\tfor(int i=0;i<DINIC_v_size;i++)DINIC_level[i]=-1;\n\tqueue<int> Q;\n\tDINIC_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<DINIC_G[v].size();i++){\n\t\t\tif(DINIC_G[v][i].first.second>0&&DINIC_level[DINIC_G[v][i].first.first]<0){\n\t\t\t\tDINIC_level[DINIC_G[v][i].first.first]=DINIC_level[v]+1;\n\t\t\t\tQ.push(DINIC_G[v][i].first.first);\n\t\t\t}\n\t\t}\n\t}\n}\nint DINIC_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;DINIC_iter[v]<DINIC_G[v].size();DINIC_iter[v]++){\n\t\tint i=DINIC_iter[v];\n\t\tif(DINIC_G[v][i].first.second>0&&DINIC_level[v]<DINIC_level[DINIC_G[v][i].first.first]){\n\t\t\tint d=DINIC_dfs(DINIC_G[v][i].first.first,t,min(f,DINIC_G[v][i].first.second));\n\t\t\tif(d>0){\n\t\t\t\tDINIC_G[v][i]=make_pair(make_pair(DINIC_G[v][i].first.first,DINIC_G[v][i].first.second-d),DINIC_G[v][i].second);\n\t\t\t\tDINIC_G[DINIC_G[v][i].first.first][DINIC_G[v][i].second]=make_pair(make_pair(DINIC_G[DINIC_G[v][i].first.first][DINIC_G[v][i].second].first.first,DINIC_G[DINIC_G[v][i].first.first][DINIC_G[v][i].second].first.second+d),DINIC_G[DINIC_G[v][i].first.first][DINIC_G[v][i].second].second);\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tDINIC_bfs(s);\n\t\tif(DINIC_level[t]<0)return flow;\n\t\tfor(int i=0;i<DINIC_v_size;i++)DINIC_iter[i]=0;\n\t\tint f;\n\t\twhile((f=DINIC_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nint c[500];\nint d[500];\nint gcd(int a,int b){\n\twhile(b){\n\t\ta%=b;\n\t\tint c=a;\n\t\ta=b;\n\t\tb=c;\n\t}return a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a+b){\n\t\tfor(int i=0;i<1002;i++)DINIC_G[i].clear();\n\t\tfor(int i=0;i<1002;i++)DINIC_level[i]=DINIC_iter[i]=0;\n\t\tfor(int i=0;i<a;i++)scanf(\"%d\",c+i);\n\t\tfor(int i=0;i<b;i++)scanf(\"%d\",d+i);\n\t\tfor(int i=0;i<a;i++)add_edge(1000,i,1);\n\t\tfor(int i=0;i<b;i++)add_edge(a+i,1001,1);\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<b;j++)\n\t\t\t\tif(gcd(c[i],d[j])!=1)add_edge(i,a+j,1);\n\t\tprintf(\"%d\\n\",max_flow(1000,1001));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define LOOP(i,x,n) for(int i=x;i<n;i++)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define MP make_pair\n#define FIR first\n#define SEC second\n#define int long long\nusing namespace std;\nconst int MOD=1000000007;\nconst int INF=1000000009;\n\ntypedef int Flow;\nstruct Edge{\n  int src;int dst;int rev;\n  Flow cap;\n  Edge(int s=0,int d=0,Flow c=0,int r=0):\n  src(s),dst(d),cap(c),rev(r){}\n};\n\nusing Graph = vector<vector<Edge>>;\nGraph g;\nint m,n;\nbool used[10005];\n\nvoid add(int src,int dst,int cap){\n  g[src].emplace_back(src,dst,cap,g[dst].size());\n  g[dst].emplace_back(dst,src,0,g[src].size()-1);\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  REP(i,g[v].size()){\n    Edge &e=g[v][i];\n    if(!used[e.dst]&&e.cap>0){\n      int d=dfs(e.dst,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        g[e.dst][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\n\nint maximum_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(used,used+n+m+10,0);\n    int f=dfs(s,t,INF);\n    if(!f) return flow;\n    flow+=f;\n  }\n}\nint gcd(int a,int b){\n  if(a<b)swap(a,b);\n  if(b==0)return a;\n  return gcd(b,a%b);\n}\n\nsigned main(){\n  while(cin>>m>>n,m){\n    int b,r;\n    g=Graph(m+n+10);\n    vector<pair<int,int>> B,R;\n    REP(i,m){\n      cin>>b;\n      B.PB(MP(i+1,b));\n    }\n    REP(i,n){\n      cin>>r;\n      R.PB(MP(i+1+m,r));\n    }\n    REP(i,m)add(0,i+1,1);\n    REP(i,n)add(m+i+1,n+m+1,1);\n    REP(i,m)REP(j,n){\n      if(gcd(B[i].SEC,R[j].SEC)>1){\n        add(B[i].FIR,R[j].FIR,1);\n      }\n    }\n    printf(\"%d\\n\",maximum_flow(0,n+m+1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define rep(i,j,n) for(int i=j;i<n;++i)\n#define all(i) i.begin(),i.end()\n#define rall(i) i.rbegin(), i.rend()\n#define INF 1e9\n#define LINF 1e18\nconst int mod = 1e9 + 7;\n \ntypedef long long i64;\ntypedef pair<int, int> pi;\n \ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\n \ni64 gcd(i64 n, i64 m) {return (m == 0? n : gcd(m, n % m));}\ni64 lcd(i64 n, i64 m) {return (n / gcd(n, m) * m);}\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n \nstruct BipartiteMatching {\n  vector<vector<int>> graph;\n  vector<int> match, alive, used;\n  int timestamp;\n \n  BipartiteMatching(int n) : graph(n), alive(n, 1), used(n, 0), match(n, -1), timestamp(0) {}\n \n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n \n  bool dfs(int idx) {\n    used[idx] = timestamp;\n    for(auto &to : graph[idx]) {\n      int to_match = match[to];\n      if(alive[to] == 0) continue;\n      if(to_match == -1 || (used[to_match] != timestamp && dfs(to_match))) {\n        match[idx] = to;\n        match[to] = idx;\n        return true;\n      }\n    }\n    return false;\n  }\n \n  int bipartite_matching() {\n    int ret = 0;\n    for(int i = 0; i < graph.size(); i++) {\n      if(alive[i] == 0) continue;\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return ret;\n  }\n};\n \nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n \n  int m, n;\n  while(cin >> m >> n, m != 0 || n != 0) {\n    vt<int> b(m), r(n);\n    rep(i, 0, m) cin >> b[i];\n    rep(i, 0, n) cin >> r[i];\n \n    BipartiteMatching bm(m + n);\n    rep(i, 0, m) {\n      rep(j, 0, n) {\n        if(gcd(b[i], r[j]) != 1) bm.add_edge(i, j + m);\n      }\n    }\n    cout << bm.bipartite_matching() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <map>\n#include <ctime>\n#include <cstdlib>\n \nusing namespace std;\n \ntypedef int lli;\ntypedef pair<lli, lli> P;\ntypedef vector<double> array;\ntypedef vector<array> matrix;\nconst double EPS = 1e-8;\n\nlli gcd(lli a, lli b){\n\treturn (b == 0 ? a : gcd(b, a%b));\n}\n \nlli rank(matrix &A){\n\tlli n = A.size();\n  lli res = 0;\n\tmatrix B(n, array(n+1,1));\n  for(lli i=0;i<n;i++) for(lli j=0;j<n;j++) B[i][j] = A[i][j];\n    \n  for(lli i=0;i<n;i++){\n    lli pivot = i;\n    for(lli j=i;j<n;j++){\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n    }\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i]) > EPS) res++;\n    if(abs(B[i][i]) > EPS){\n      for(lli j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n      for(lli j=0;j<n;j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tfor(lli k=i+1;k<=n;k++) B[j][k] -= B[j][i] * B[i][k];\n\t\t\t\t}\n      }\n    }\n  }\n  return res;\n}\n \nint main(){\n\tsrand((unsigned)time(NULL));\n\tlli n, m;\n\twhile(cin >> n >> m && (n|m)){\n\t\tvector<int> A(n), B(m);\n\t\tfor(int i=0;i<n;i++) cin >> A[i];\n\t\tfor(int i=0;i<m;i++) cin >> B[i];\n\t\tvector<P> edge;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(gcd(A[i], B[j]) > 1){\n\t\t\t\t\tedge.push_back(make_pair(i, n+j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlli ans = 0;\n\t\tmatrix mat(n+m, array(n+m, 0));\n\t\tfor(lli i=0;i<edge.size();i++){\n\t\t\tlli tmp = rand() + 10;\n\t\t\tlli a = edge[i].first, b = edge[i].second;\n\t\t\tmat[a][b] = tmp;\n\t\t\tmat[b][a] = -tmp;\n\t\t}\n\t\tcout << rank(mat) / 2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n#define MAX 2000\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\nstruct edge{ int to, cap, rev; };\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].pb((edge){to, cap, G[to].size()});\n    G[to].pb((edge){from, 0, G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    rep(i, G[v].size()){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\nint N, K;\nint main() {\n    while(cin >> N >> K, N||K){\n        vector<int> b(N), r(K);\n        rep(i, N) cin >> b[i];\n        rep(i, K) cin >> r[i];\n        rep(i, MAX) G[i].clear();\n        int s = N+K, t = s+1;\n        rep(i, N) add_edge(s, i, 1);\n        rep(i, K) add_edge(N+i, t, 1);\n        rep(i, N) rep(j, K) if(__gcd(b[i], r[j]) > 1) add_edge(i, N+j, 1);\n        cout << max_flow(s, t) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <climits>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\nstruct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) {}\n};\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<Edge>> AdjList;\nAdjList graph;\n\nconst int INF = 100000000;\n\n\n\nint GCD(int a, int b){\n    if(a < b) swap(a, b);\n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\nint N, K;\nbool can[510][510];\nstruct edge{ int to, cap, rev;};\nvector<edge> G[1010];\nbool used[1010];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size() });\n    G[to].push_back((edge){from, 0, (int)G[from].size()-1}) ;\n}\n\nint dfs(int v, int t, int f) {\n    if(v == t) return f;\n    used[v] = true;\n\n    for(int i=0; i<G[v].size(); ++i){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if( d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if( f == 0) return flow;\n        flow += f;\n    }\n}\n\n\nint main() {\n    //cout << fixed << setprecision(15);\n   \n    int m, n;\n    while(cin >> m >> n){\n        if(m == 0 && n==0) break;\n        for(int i=0; i<1010; ++i) G[i].clear();\n        int s = m + n, t = s+1;\n\n        for(int i=0; i<m; ++i){\n            add_edge(s, i, 1);\n        }\n        for(int i=0; i<n; ++i){\n            add_edge(m+i, t, 1);\n        }\n\n        vector<int> r, b;\n        for(int i=0; i<m; ++i){\n            int a = readInt();\n            b.push_back(a);\n        }\n        for(int i=0; i<n; ++i){\n            int a = readInt();\n            r.push_back(a);\n        }\n        for(int i=0; i<m; ++i){\n            for(int j=0; j<n; ++j){\n                int d = GCD(b[i], r[j]);\n                if(d > 1) add_edge(i, m+j, 1);\n            }\n        }\n\n        cout << max_flow(s, t) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vc = vector<char>;\nusing vvc = vector<vc>;\nusing pll = pair<ll, ll>;\nusing stkll = vector<pll>;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1e9 + 7;\n#define rep(i, n) for (ll i = 0; i < (n); i++)\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#ifndef ONLINE_JUDGE\n    #define debug(x) cerr << #x << \": \" << x << endl;\n#else\n    #define debug(x)\n#endif\n\n/*  FordFulkerson: Ford-Fulkersonのアルゴリズムで最大流を求める構造体\n\n    verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_A&lang=ja\n\n    max_flow(G,s,t)：sからtへのグラフGの最大流を求める\n    副作用：G は最大流の残余ネットワークになる\n    計算量: O(|f*||E|) (f*:最大流) (この最悪ケースになることはほぼ無い)\n*/\n\ntemplate <class T>\nstruct Edge {\n    int rev, from, to;  // rev:逆向きの辺の番号\n    T cap, original_cap;\n    Edge(int r, int f, int t, T c) : rev(r), from(f), to(t), cap(c), original_cap(c) {}\n};\ntemplate <class T>\nstruct Graph {\n    vector<vector<Edge<T>>> G;\n    Graph(int n = 0) : G(n) {}\n    vector<Edge<T>>& operator[](int i) { return G[i]; }\n    const size_t size() const { return G.size(); }\n    Edge<T>& redge(Edge<T> e) {  // 逆向きの辺を返す\n        return G[e.to][e.rev];   // 自己ループはないと仮定（あれば G[e.to][e.rev + 1] とする必要がある）\n    }\n    void add_edge(int from, int to, T cap) {  // 有向辺を加える\n        G[from].push_back(Edge<T>((int)G[to].size(), from, to, cap));\n        G[to].push_back(Edge<T>((int)G[from].size() - 1, to, from, 0));\n    }\n};\n/* FordFulkerson: Ford-Fulkersonのアルゴリズムで最大流を求める構造体\n    max_flow(G,s,t)：sからtへのグラフGの最大流を求める\n    副作用：G は最大流の残余ネットワークになる\n    計算量: O(|f*||E|) (f*:最大流) (この最悪ケースになることはほぼ無い)\n*/\ntemplate <class T>\nstruct FordFulkerson {\n    const T INF = 1e9;\n    vector<int> used;\n    FordFulkerson(){};\n    T dfs(Graph<T>& G, int v, int t, T f) {  // 増加可能経路を見つけて増加分のフローを返す\n        if (v == t) return f;\n        used[v] = true;\n        for (auto& e : G[v]) {\n            if (!used[e.to] && e.cap > 0) {\n                T d = dfs(G, e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G.redge(e).cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    T max_flow(Graph<T>& G, int s, int t) {\n        T flow = 0;\n        while (true) {\n            used.assign(G.size(), 0);\n            T f = dfs(G, s, t, INF);  // f が増加分のフロー\n            if (f == 0) {\n                return flow;\n            } else {\n                flow += f;\n            }\n        }\n        return 0;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    ll m, n;\n    while(cin >> m >> n) {\n        if(m == 0 && n == 0) return 0;\n\n        Graph<ll> g(m+n+2);\n        vll b(m), r(n);\n        rep(i,m) cin >> b[i];\n        rep(i,n) cin >> r[i];\n        rep(i,m) rep(j,n) if(__gcd(b[i], r[j]) > 1) g.add_edge(i, m+j, 1);\n\n        ll s = m+n, t = m+n+1;\n        rep(i, m) g.add_edge(s, i, 1);\n        rep(i, n) g.add_edge(m+i, t, 1);\n\n        FordFulkerson<ll> ff;\n        ll ans = ff.max_flow(g, s, t);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/////////////////////////////////////////////////////////\n//\n//  c/temp.cpp file\n//  Last Updated: 2018-10-23 ...Maybe\n//\n//    I hope you adding this code to the setting file\n//    alias g++='g++ -std=c++1y -DDEBUG_LOCAL'\n//\n/////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n//#define int long long\n\n#define _overload3(_1,_2,_3,name,...) name\n#define _REP(i,n) REAP(i,0,n)\n#define REAP(i,a,b) for(int i=int(a);i<int(b);++i)\n#define REP(...) _overload3(__VA_ARGS__,REAP,_REP,)(__VA_ARGS__)\n\n#define _REPR(i,n) REAPR(i,n,0)\n#define REAPR(i,a,b) for(int i=int(a-1);i>=int(b);--i)\n#define REPR(...) _overload3(__VA_ARGS__,REAPR,_REPR,)(__VA_ARGS__)\n\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n\n#define coutALL(a) {int loop_coutALL=0;for(auto e:a) cout<<(loop_coutALL++?\" \":\"\")<<e; cout<<endl;}\n\n#define coutYN(a) cout<<((a)?\"YES\":\"NO\")<<endl;\n#define coutYn(a) cout<<((a)?\"Yes\":\"No\")<<endl;\n#define coutyn(a) cout<<((a)?\"yes\":\"no\")<<endl;\n\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n\nconst int INF=1145141919;\n//const long long INF=114514191911451419;\nconst int MOD=(int)1e9+7;\nconst double EPS=1e-12;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n//const int dx[]={-1,-1,-1,0,1,1,1,0},dy[]={-1,0,1,1,1,0,-1,-1};\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,string> pis;\ntypedef pair<string,int> psi;\ntypedef pair<string,string> pss;\n\ntypedef long long ll;\n\ntemplate<typename T> istream &operator >> (istream &is, vector<T> &v){for(T &x:v) is>>x;return is;}\ntemplate<typename T> ostream &operator << (ostream &os, vector<T> &v){int i=0;for(T &x:v) os<<(i++?\" \":\"\")<<x;return os;}\n\nll rev(ll n){ll x=0;for(;n>0;){x=x*10+n%10;n/=10;}return x;}\n\nll upper(ll n,ll m){return (n+m-1)/m;};\nll rounding(ll n){return (long double)n+0.5;};\n\nbool inG(ll x,ll n){return 0<=x && 0<n;}\nbool outG(ll x,ll n){return x<0 || n<=x;}\n\ninline int qp(int a,ll b){if(!b)return 1;int ans=1;do{if(b&1)ans=1ll*ans*a;a=1ll*a*a;}while(b>>=1);return ans;}\ninline int qp(int a,ll b,int mo){if(!b)return 1;int ans=1;do{if(b&1)ans=1ll*ans*a%mo;a=1ll*a*a%mo;}while(b>>=1);return ans;}\n\ninline ll fac(ll k,ll n){ll a=1;for(int i=0;i<n;i++)a*=k--;return a;}\ninline ll fac(ll k,ll n,int mo){ll a=1;for(int i=0;i<n;i++)a*=k--,a%=mo;return a;}\n\ninline int dsum(ll n){int a=0;for(;n;n/=10)a+=n%10;return a;}\n\nstruct Arithmetic{Arithmetic(){cin.tie(0);ios::sync_with_stdio(0);cout<<fixed<<setprecision(20);}};\n\n//#define DEBUG_LOCAL\n\n#ifdef DEBUG_LOCAL\ntemplate<typename T> void deb(T a){cerr<<\"deb: \"<<a<<\"です\"<<endl;}\n#define debl {cerr<<\"debug: \"<<__LINE__<<\"行目だ\"<<endl;}\nvoid what_cr(){cout<<__GCC_ATOMIC_CHAR16_T_LOCK_FREE<<\" ←？\"<<endl;}\n//ori_func S\n\n//ori_func E\n#else\ntemplate<typename T>void deb(T a){}\n#define debl\nvoid what_cr(){}void t_t(){}\n#endif\n\nint m,n;\nint match[1000];\nbool used[1000];\n\nint dfs(int now,vi g[1000]){\n\n  used[now]=true;\n  REP(i,g[now].size()){\n    int u=g[now][i], w=match[u];\n    if(w<0 || (!used[w] && dfs(w,g))){\n      match[now]=u;\n      match[u]=now;\n      return true;\n    }\n  }\n\n  return false;\n\n}\n\n\nsigned main(){\n\n  Arithmetic Exception;\n\n  for(;cin>>m>>n,m;){\n\n    vi b(m),r(n);\n    cin>>b>>r;\n\n    vi g[1000];\n\n    REP(i,m)\n    REP(j,n)\n    if(__gcd(b[i],r[j]) >= 2){\n      g[i].pb(m+j);\n      g[m+j].pb(i);\n    }\n\n    // REP(i,m+n) cout<<g[i]<<endl;\n\n    int ans=0;\n    fill(match,match+1000,-1);\n\n    REP(i,m+n){\n      if(match[i]<0){\n        fill(used,used+1000,0);\n        if(dfs(i,g)) ans++;\n      }\n    }\n\n    cout<<ans<<endl;\n\n  }\n\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 2009à\\IE J[hQ[\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector< vector<int> > graph;\n\ngraph g;\nvector<int> match;\nvector<bool> visit;\n\nbool search(int u){\n\tif(u<0) return true;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint next = g[u][i];\n\t\tif(visit[next]) continue;\n\t\tvisit[next] = true;\n\t\tif(search(match[next])){\n\t\t\tmatch[u] = next, match[next] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint maximumMatch(int L, int R){\n\tint res = 0;\n\tmatch.assign(L+R, -1);\n\tfor(int i=0;i<L;i++){\n\t\tvisit.assign(L+R, false);\n\t\tres += search(i);\n\t}\n\treturn res;\n}\n\nint gcd(int a, int b){ return b==0 ? a : gcd(b, a%b); }\n\nint main(){\n\tint m, n;\n\tint blue[500], red[500];\n\twhile(cin >> m >> n){\n\t\tif(!(m||n)) break;\n\t\tfor(int i=0;i<m;i++) cin >> blue[i];\n\t\tfor(int i=0;i<n;i++) cin >> red[i];\n\t\tg.assign(m+n, vector<int>());\n\t\tfor(int i=0;i<m;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tif(gcd(blue[i],red[j])!=1){\n\t\t\t\t\tg[i].push_back(j+m);\n\t\t\t\t\tg[j+m].push_back(i);\n\t\t\t\t}\n\t\tcout << maximumMatch(m,n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\nbool augment(int l, vvi& E, vi& r2l, vi& visited) {\n\tif(l == -1) return true;\n\tif(visited[l]) return false;\n\tvisited[l] = true;\n\tfor(int r:E[l]) {\n\t\tif(augment(r2l[r], E, r2l, visited)) {\n\t\t\tr2l[r] = l;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint match(vvi& e, int l, int r) {\n\tvi r2l(r, -1);\n\tint res = 0;\n\tfor(int i = 0; i < l; i++) {\n\t\tvi visited(l);\n\t\tif(augment(i, e, r2l, visited)) res++;\n\t}\n\treturn res;\n}\n\nint main() {\n\tint m, n;\n\n\twhile(cin >> m >> n, m) {\n\t\tint ans = 0;\n\n\t\tvi B(m), R(n);\n\t\tfor(auto &i:B) cin >> i;\n\t\tfor(auto &i:R) cin >> i;\n\n\t\tvvi edge(m);\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tif(__gcd(B[i], R[j]) > 1) {\n\t\t\t\t\tedge[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << match(edge, m, n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint gcd(int a, int b) {\n\tif (!b)return a;\n\treturn gcd(b, a%b);\n}\nint b[500], r[500];\nvector<int>E[500];\nbool used[1000];\nint match[1000];\n\nbool dfs(int u) {\n\tused[u] = true;\n\tfor (int v : E[u]) {\n\t\tint w = match[v];\n\t\tif (w == -1 || (!used[w] && dfs(w))) {\n\t\t\tmatch[u] = v; match[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\trep(i, 1000)E[i].clear();\n\t\trep(i, m)scanf(\"%d\", &b[i]);\n\t\trep(i, n)scanf(\"%d\", &r[i]);\n\t\trep(i, m)rep(j, n) {\n\t\t\tif (gcd(b[i], r[j]) != 1)E[i].push_back(m + j);\n\t\t}\n\t\tmemset(match, -1, sizeof(match));\n\t\tint ans = 0;\n\t\trep(i, m) {\n\t\t\tif (match[i] == -1) {\n\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\tif (dfs(i))ans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nvector<int> blue,red,redpair,v;\nvector<vector<int>>c;\n/*blue[i]??§i?????????????????????????????°???,red[i]??§i?????????????????????????????°???,redpair[i]??§i??????????????????????????¨?????¢????????????????????????????????????????????????,v[i]??§i??????????????????????????????????????????????????????(1:?????????0:??????)\nc[i][j]??§blue[i]??¨red[j]????????¢?????§???????????¨???*/\nint m=0,n=0;\n\nint gcd(int x,int y){\n\tif(x%y==0){return y;}\n\treturn gcd(y,x%y);\n}\n\nbool match(int x){\n\tif(x==-1)return 1;\n\tfor(int i=0;i<n;i++){\n\t\tif(c[x][i]==1 && v[i]==0){\n\t\t\tv[i]=1;\n\t\t\tif(match(redpair[i])){\n\t\t\t\tredpair[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(cin>>m>>n){\n\t\tif(m==0 && n==0){break;}\n\t\tblue.clear();\n\t\tred.clear();\n\t\tredpair.clear();\n\t\tv.clear();\n\t\tc.clear();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint tmp=0;\n\t\t\tcin>>tmp;\n\t\t\tblue.push_back(tmp);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmp=0;\n\t\t\tcin>>tmp;\n\t\t\tred.push_back(tmp);\n\t\t\tredpair.push_back(-1);//-1??§?????¢??????????????¶????????¨???\n\t\t\tv.push_back(0);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tc.push_back(vector<int>());\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tc[i].push_back(gcd(blue[i],red[j])!=1);\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tv[j]=0;\n\t\t\t}\n\t\t\tif(match(i)){ans++;}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n \nint main(){\n    int n, m;\n    while(cin >> n >> m, n+m){\n        vector<pair<int, int> > a(n), b(m);\n        for(int i=0; i< n; i++){int p; cin >> p; a[i] = make_pair(0, p);}\n        for(int i=0; i< m; i++){int p; cin >> p; b[i] = make_pair(0, p);}\n \n        for(int i=0; i< n; i++)for(int j=0; j < m; j++){\n            if(__gcd(a[i].second, b[j].second) != 1){a[i].first++; b[j].first++;}\n        }\n        sort(a.begin(), a.end()); sort(b.begin(), b.end());\n \n        bool ba[500] = {false}, bb[500] = {false};\n        int ret = 0;\n        for(int i=0; i< n; i++)for(int j=0; j< m; j++){\n            if(!ba[i] && !bb[j] && __gcd(a[i].second, b[j].second) != 1){\n                ret++;\n                ba[i] = true; bb[j] = true;\n                break;\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nclass bipartite_matching {\npublic:\n    int n;\n    vector<vector<int>> g;\n    vector<int> match;\n\n    bipartite_matching(int n_) : n(n_), g(n_), match(n_), used(n_) {}\n\n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    int maximum_matching(void) {\n        int res = 0;\n        fill(begin(match), end(match), -1);\n        for (int v = 0; v < n; ++v) {\n            if (match[v] == -1) {\n                fill(begin(used), end(used), false);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    vector<int> used;\n    bool dfs(int v) {\n        used[v] = true;\n        for (int u : g[v]) {\n            int w = match[u];\n            if (w == -1 || (!used[w] && dfs(w))) {\n                match[v] = u; match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nint gcd(int a, int b) {\n    return b ? gcd(b, a%b) : a;\n}\n\nint n, m;\nint a[500], b[500];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    while (cin >> n >> m && n) {\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        for (int i = 0; i < m; i++) {\n            cin >> b[i];\n        }\n\n        bipartite_matching bm(n + m);\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (gcd(a[i], b[j]) != 1) {\n                    bm.add_edge(i, n + j);\n                }\n            }\n        }\n\n        cout << bm.maximum_matching() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\nint INF = 10e8;\nint m, n;\nint b[1005];\nint r[1005];\n\nvector<int> bd[1005];\nvector<int> rd[1005];\n\nstruct edge{\n    int to, cap, rev;\n};\nbool used[1005];\nvector<edge> g[1005];\n\nint s, t;\n\nvoid add_edge(int from, int to, int cap){\n    g[from].push_back((edge){to, cap, g[to].size()});\n    g[to].push_back((edge){from, 0, g[from].size()-1});\n}\n\nint dfs(int v, int t, int f){\n    if(v==t) return f;\n    used[v] = true;\n    REP(i, g[v].size()){\n        edge &e = g[v][i];\n        if(!used[e.to] && e.cap>0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d>0){\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f==0) return flow;\n        flow += f;\n    }\n}\n\nbool euclid(int x, int y){\n    if(x<y){\n        int tmp = x;\n        x = y;\n        y = tmp;\n    }\n\n    int r = x % y;\n    while(r!=0){\n        x = y;\n        y = r;\n        r = x % y;\n    }\n\n    if(y>1){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main(){\n    while(1){\n        cin >> m >> n;\n\n        if(m==0) break;\n\n        REP(i, m) cin >> b[i];\n        REP(i, n) cin >> r[i];\n\n        int s = m+n, t = s+1;\n\n        REP(i, 1005) g[i].clear();\n\n        REP(i, m){\n            REP(j, n){\n                if(euclid(b[i], r[j])){\n                    add_edge(i, m+j, 1);\n                }\n            }\n        }\n\n        REP(i, m) add_edge(s, i, 1);\n        REP(i, n) add_edge(m+i, t, 1);\n\n        int output = max_flow(s, t);\n        cout << output << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\n\nint gcd(int a,int b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\n\nstruct edge{\n\tint to,cap,rev;\n};\n\nvector<edge> G[1001];\nbool used[1001];\n\nvoid add_edge(int from,int to,int cap){\n\tedge e;\n\te.to=to,e.cap=cap,e.rev=G[to].size();\n\tG[from].push_back(e);\n\te.to=from;\n\te.cap=0,e.rev=G[from].size()-1;\n\tG[to].push_back(e);\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to] && e.cap>0){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(1){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,1);\n\t\tif(f==0)return flow;\n\t\tflow+=f;\n\t}\n}\n\nint m,n;\nint b[501],k[501];\n\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(m+n==0)break;\n\t\tfor(int i=0;i<=m+n+2;i++)G[i].clear();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d\",&b[i]);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d\",&k[i]);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tadd_edge(0,i+1,1);\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(gcd(b[i],k[j])>=2)add_edge(i+1,j+m+1,1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tadd_edge(i+m+1,m+n+2,1);\n\t\t}\n\t\tprintf(\"%d\\n\",max_flow(0,n+m+2));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n\ntypedef vector<int> vint;\n\n\ntemplate<class V> class MaxFlow_dinic{\npublic:\n\tstruct edge{int to,reve;V cap;};\n\tstatic const int MV = 1100;\n\tvector<edge> E[MV];\n\tint itr[MV],lev[MV];\n\n\tvoid add_edge(int x,int y,V cap,bool undir=false){\n\t\tE[x].push_back((edge){y,(int)E[y].size(),cap});\n\t\tE[y].push_back((edge){x,(int)E[x].size()-1,undir?cap:0});\n\t}\t\n\tvoid bfs(int cur){\n\t\tmemset(lev,0xff,sizeof(lev));\n\t\tqueue<int> q;\n\t\tlev[cur]=0;\n\t\tq.push(cur);\n\t\twhile(q.size()){\n\t\t\tint v=q.front();\n\t\t\tq.pop();\n\t\t\tfor(__typeof(E[v].begin()) e=E[v].begin();e!=E[v].end();e++) if(e->cap>0&&lev[e->to]<0) lev[e->to]=lev[v]+1,q.push(e->to);\n\t\t}\n\t}\n\n\tV dfs(int from,int to,V cf){\n\t\tif(from==to){\n\t\t\treturn cf;\n\t\t}\n\t\tfor(;itr[from]<E[from].size();itr[from]++){\n\t\t\tedge* e=&E[from][itr[from]];\n\t\t\tif(e->cap>0&&lev[from]<lev[e->to]){\n\t\t\t\tV f=dfs(e->to,to,min(cf,e->cap));\n\t\t\t\tif(f>0){\n\t\t\t\t\te->cap-=f;\n\t\t\t\t\tE[e->to][e->reve].cap += f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tV maxflow(int from,int to){\n\t\tV fl = 0,tf;\n\t\twhile(1){\n\t\t\tbfs(from);\n\t\t\tif(lev[to]<0) return fl;\n\t\t\tmemset(itr,0,sizeof(itr));\n\t\t\twhile((tf=dfs(from,to,numeric_limits<V>::max()))>0) fl += tf;\n\t\t}\n\t}\n};\n\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\tvint a(n);\n\t\tvint b(m);\n\t\trep(i,n) cin>>a[i];\n\t\trep(i,m) cin>>b[i];\n\t\tMaxFlow_dinic<int> mf;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tint t = __gcd(a[i],b[j]);\n\t\t\t\tif(t==1) continue;\n\t\t\t\tmf.add_edge(i,n+j,1);\n\t\t\t}\n\t\t}\n\t\tint souce = n+m;\n\t\tint sink = n+m+1;\n\t\trep(i,n) mf.add_edge(souce,i,1);\n\t\trep(i,m) mf.add_edge(n+i,sink,1);\n\t\tint ans = 0;\n\t\tans = mf.maxflow(souce,sink);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\nstruct edge{int to,cap,rev;};\nint m,n;\nvector<edge> G[1500];\nint v[1500];\nbool used[1500];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,int(G[to].size())});\n  G[to].push_back((edge){from,0,int(G[from].size()-1)});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  used[v]=1;\n  for(int i=0;i<G[v].size();++i){\n    edge &e = G[v][i];\n    if(used[e.to] || e.cap<=0) continue;\n    int d = dfs(e.to,t,min(f,e.cap));\n    if(d>0){\n      e.cap-=d;\n      G[e.to][e.rev].cap+=d;\n      return d;\n    }\n  }\n  return 0;\n}\n\nint ford_fulkerson(int s,int t){\n  int flow = 0,f;\n  while(true){\n    memset(used,0,sizeof(used));\n    f=dfs(s,t,1<<28);\n    if(f==0) break;\n    flow+=f;\n  }\n  return flow;\n}\n\nint main(){\n  while(cin>>m>>n,m||n){\n    for(int i=0;i<=m+n+1;++i) G[i].clear();\n    for(int i=1;i<=m;++i) cin>>v[i];\n    for(int i=m+1;i<=m+n;++i) cin>>v[i];\n    for(int i=1;i<=m;++i) add_edge(0,i,1);\n    for(int j=m+1;j<=m+n;++j) add_edge(j,m+n+1,1);\n    for(int i=1;i<=m;++i)\n      for(int j=m+1;j<=m+n;++j)\n\tif(__gcd(v[i],v[j])>1)\n\t  add_edge(i,j,1);\n\n    cout << ford_fulkerson(0,m+n+1) << endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_V = 1100;\nconst int INF = 100000000;\n\n// &#65533;&#65533;&#65533;_&#65533;&#65533;\nint V;\n// &#65533;O&#65533;&#65533;&#65533;t&#65533;&#771;&#65533;&#65533;X&#65533;g&#65533;\\&#65533;&#65533;\nvector<int> G[MAX_V];\n// &#65533;}&#65533;b&#65533;`&#65533;&#65533;&#65533;O&#65533;&#771;y&#65533;A\nint match[MAX_V];\n// dfs&#65533;&#322;&#65533;&#65533;&#322;&#594;&#65533;&#65533;&#1474;&#65533;&#65533;&#65533;&#65533;&#450;&#65533;&#65533;&#65533;&#65533;&#771;t&#65533;&#65533;&#65533;O\nstatic bool used[MAX_V];\n\n// u&#65533;&#65533;v&#65533;&#65533;&#1301;&#1218;&#65533;O&#65533;&#65533;&#65533;t&#65533;&#594;&#457;&#65533;\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\n// &#65533;&#65533;&#65533;&#65533;p&#65533;X&#65533;&#65533;dfs&#65533;&#338;T&#65533;&#65533;\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i],w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// &#65533;&#349443;O&#65533;&#65533;&#65533;t&#65533;&#781;&#337;&#65533;}&#65533;b&#65533;`&#65533;&#65533;&#65533;O&#65533;&#65533;&#1986;&#65533;\nint bipartite_matching(){\n\tint res = 0;\n\t//memset(match,-1,sizeof(match));\n\tfor(int i = 0; i < MAX_V; i++)\n\t\tmatch[i]=-1;\n\tfor(int v = 0; v < V; v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int a,int b){\n\tif(b==0)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\n\n\nint main(){\n\n\tint n,m;\n\tvector<int> bs,rs;\n\tint b,r;\n\n\twhile(cin>>m>>n&&!(m==0&&n==0)){\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\tG[i].clear();\n\t\tbs.clear();\n\t\trs.clear();\n\n\t\tV=n+m;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin>>b;\n\t\t\tbs.push_back(b);\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>r;\n\t\t\trs.push_back(r);\n\t\t}\n\t\tfor(int i = 0; i < rs.size(); i++){\n\t\t\tfor(int j = 0;j < bs.size(); j++){\n\t\t\t\tint res=gcd(rs[i],bs[j]);\n\t\t\t\tif(res>1)\n\t\t\t\t\tadd_edge(i,j+rs.size());\n\t\t\t}\n\t\t}\n\t\tcout<<bipartite_matching()<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nclass HopcroftKarp {\n    void bfs() {\n        const int n = g.size();\n        dist.assign(n, -1);\n        queue<int> que;\n        for (int i = 0; i < n; ++i) if (!used[i]) {\n            que.push(i);\n            dist[i] = 0;\n        }\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (int& u : g[v]) {\n                int w = match[u];\n                if (w >= 0 && dist[w] == -1) {\n                    dist[w] = dist[v] + 1;\n                    que.emplace(w);\n                }\n            }\n        }\n    }\n\n    bool dfs(int v) {\n        vv[v] = true;\n        for (auto& u : g[v]) {\n            int w = match[u];\n            if (w < 0 || (!vv[w] && dist[w] == dist[v] + 1 && dfs(w))) {\n                match[u] = v;\n                used[v] = true;\n                return true;\n            }\n        }\n        return false;\n    }\n    \npublic:\n    vector<vector<int>> g;\n    vector<int> dist, match;\n    vector<bool> used, vv;\n\n    HopcroftKarp(int n, int m) : g(n), match(m, -1), used(n) {}\n\n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n    }\n\n    int bipartite_matching() {\n        const int n = g.size();\n        int res = 0;\n        while (true) {\n            bfs();\n            vv.assign(n, false);\n            int flow = 0;\n            for (int i = 0; i < n; ++i) {\n                if (!used[i] && dfs(i)) ++flow;\n            }\n            if (!flow) break;\n            res += flow;\n        }\n        return res;\n    }\n\n    void print() {\n        for (int i = 0; i < match.size(); ++i) {\n            if (~match[i]) cout << match[i] << \" - \" << i << endl;\n        }\n    }\n};\n\n// O(log max{a, b})\nlong long gcd(long long a, long long b) {\n    while (b) {\n        long long c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nint m, n;\nint b[500], r[500];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (cin >> m >> n, m) {\n        REP (i, m) cin >> b[i];\n        REP (i, n) cin >> r[i];\n        HopcroftKarp g(m, n);\n        REP (i, m) REP (j, n) if (gcd(b[i], r[j]) > 1) {\n            g.add_edge(i, j);\n        }\n        cout << g.bipartite_matching() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    // #define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct Dinic {\n    int n, s, t;\n    vector<int> level, iter;\n    vector<vector<Capacity>> cap, flow;\n    vector<vector<int>> g;\n    Capacity inf;\n    Dinic(int n)\n        : n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n          g(n, vector<int>()), inf(numeric_limits<Capacity>::max()/8){}\n    Dinic(const Graph &graph){\n        *this = Dinic(graph.size());\n        rep(i,n) for(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n    }\n    void addEdge(int u, int v, Capacity c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    Capacity residue(int u, int v){\n        return cap[u][v] - flow[u][v];\n    }\n    Capacity solve(int s, int t){\n        this->t = t, this->s = s;\n        Capacity res = 0, aug = 1;\n        while(aug > 0){\n            levelize();\n            iter.assign(n, 0);\n            aug = augment(s, inf);\n            res += aug;\n        }\n        return res;\n    }\n    void levelize(){\n        level.assign(n, inf); level[s] = 0;\n        queue<int> q; q.emplace(s);\n        while(q.size()){\n            int v = q.front(); q.pop();\n            for(const int &d : g[v]){\n                if(level[d] <= level[v] + 1 || residue(v,d) == 0) continue;\n                level[d] = level[v] + 1; q.emplace(d);\n            }\n        }\n    }\n    Capacity augment(int v, Capacity lim){\n        Capacity res = 0;\n        if(v == t) return lim;\n        for(int &i = iter[v]; i < (int)g[v].size(); i++){\n            const int &d = g[v][i];\n            if(residue(v,d) == 0 || level[v] + 1 != level[d]) continue;\n            Capacity aug = augment(d, min(lim, residue(v,d)));\n            if(aug > 0){\n                lim -= aug;\n                flow[v][d] += aug; flow[d][v] -= aug;\n                res += aug;\n                if(lim == 0) return res;\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    int n,m;\n    while(cin >> n >> m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        Dinic d(n+m+2);\n        int s = n+m, t = n+m+1;\n        rep(i,m) d.addEdge(i+n,t,1);\n        rep(i,n){\n            d.addEdge(s,i,1);\n            rep(j,m) if(__gcd(a[i],b[j]) != 1) d.addEdge(i,n+j,1);\n        }\n        rep(i,n)rep(j,m){\n            if(d.flow[i][j+n]) dump(i,j, d.flow[i][j+m]);\n        }\n        cout << d.solve(s,t) << endl;\n    }\n}\n\n// int main(){\n//     int N,M;\n//     cin >> N >> M;\n//     Graph g(N);\n//     rep(i,M){\n//         int a,b,c;\n//         cin >> a >> b >> c;\n//         g[a].emplace_back(a,b,c);\n//     }\n//     Dinic dinic(g);\n//     cout << dinic.solve(0,N-1) << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n// ------ Variable ------ //\n\nint N, M;\n\n\n// ------ Greatest Common Divisor ------ //\n\nint GCD(int a, int b)\n{\n\tif (a % b == 0) { return b; }\n\tif (b % a == 0) { return a; }\n\n\tif (a > b) { return GCD(a % b, b); }\n\tif (b > a) { return GCD(b % a, a); }\n}\n\n\n// ------ Bipartite Matching ------ //\n\nvector<vector<int> > Graph;\n\nvector<int> match;\n\nvector<bool> used;\n\nbool dfs(int v)\n{\n\tused[v] = true;\n\n\tfor (int i = 0; i < Graph[v].size(); i++)\n\t{\n\t\tint u = Graph[v][i], w = match[u];\n\n\t\tif (w < 0 || !used[w] && dfs(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint Bipartite_Matching()\n{\n\tint Ans = 0;\n\n\tmatch = vector<int>(max(N, M), -1);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (match[i] < 0)\n\t\t{\n\t\t\tused = vector<bool>(max(N, M), 0);\n\n\t\t\tif (dfs(i))\n\t\t\t{\n\t\t\t\tAns++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Ans;\n}\n\nint main()\n{\n\tcin >> N >> M;\n\n\tGraph = vector<vector<int> >(N, vector<int>());\n\n\tvector<int> A(N);\n\tvector<int> B(M);\n\n\tfor (int i = 0; i < N; i++) { cin >> A[i]; }\n\tfor (int i = 0; i < M; i++) { cin >> B[i]; }\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tfor (int j = 0; j < M; j++)\n\t\t{\n\t\t\tif (GCD(A[i], B[j]) != 1)\n\t\t\t{\n\t\t\t\tGraph[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << Bipartite_Matching() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#define SIZE 1000\n\nusing namespace std;\n\nint m, n, b[501], r[501];\nint match[SIZE];\nbool used[SIZE];\nvector<int> G[SIZE];\n\nbool dfs(int v){\n\tused[v]=1;\n\tfor(int i=0; i<G[v].size(); i++){\n\t\tint u=G[v][i], w=match[u];\n\t\tif(w<0||!used[w]&&dfs(w)){\n\t\t\tmatch[v]=u, match[u]=v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid solve(){\n\tint res=0;\n\tmemset(match, -1, sizeof(match));\n\tfor(int v=0; v<m+n; v++){\n\t\tif(match[v]<0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif(dfs(v)) res++;\n\t\t}\n\t}\n\tcout<<res<<endl;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n && !m) break;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> b[i];\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcin >> r[i];\n\t\t}\n\t\tfor(int i=0; i<SIZE; i++) G[i].clear();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tint a = b[i], c = r[j];\n\t\t\t\twhile(c){\n\t\t\t\t\ta %= c;\n\t\t\t\t\tswap(a, c);\n\t\t\t\t}\n\t\t\t\tif(a != 1){\n\t\t\t\t\tG[i].push_back(j+n);\n\t\t\t\t\tG[n+j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <valarray>\n#include <string>\n#include <algorithm>\n#include <set>\ntypedef unsigned long long ull;\ntypedef long long ll;\n#define fst first\n#define snd second\n#define rep(i,n) for(ull i = 0;i<(n);i++)\n#define rep1(i,n) for(ull i = 1;i<=(n);i++)\n#define revrep(i,n) for(ull i = (n-1);i>=0;i--)\n#define all(n) (n).begin(),(n).end()\n#define show(x) cout << \"debug \" << #x << \":\" << x << endl;\n#define showvec(x) cout << endl << \"debug \" << #x << \";\" << endl; \\\n    for(ull __i = 0;__i < x.size();__i++){ \\\n        for(ull __j = 0;__j<x[0].size();__j++){ \\\n            cout << x[__i][__j] << \" \"; \\\n        } \\\n        cout << endl; \\\n    } \\\n    cout << endl;\nusing namespace std;\n\nll P[510];\nbool V[510];\nbool C[510][510];\nll B[510];\nll R[510];\n\nint M,N;\nll gcd(ll a, ll b){\n  ll c;\n  while ( a != 0 ) {\n     c = a; a = b%a;  b = c;\n  }\n  return b;\n}\n\nbool match(ll m){\n\tif(m < 0) return true;\n\trep(n,N){\n\t\tif(!C[m][n] || V[n]) continue;\n\t\tV[n] = true;\n\t\tif(match(P[n])){\n\t\t\tP[n] = m;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint main(){\n\twhile(cin >> M >> N, M){\n\t\trep(m,M){\n\t\t\tint b;\n\t\t\tcin >> b;\n\t\t\tB[m] = b;\n\t\t}\n\t\trep(n,N){\n\t\t\tint r;\n\t\t\tcin >> r;\n\t\t\tR[n] = r;\n\t\t}\n\t\trep(i,510){\n\t\t\tP[i] = -1;\n\t\t}\n\t\trep(m,M)rep(n,N){\n\t\t\tC[m][n] = (gcd(B[m],R[n]) >= 2);\n\t\t}\n\t\tll count = 0;\n\t\trep(m,M){\n\t\t\trep(n,N){\n\t\t\t\tV[n] = false;\n\t\t\t}\n\t\t\tif(match(m)) count++;\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\n#define MAX_V 1111\nstruct edge {\n  int to,cap,rev;\n};\nconst int inf = 1<<21;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int f,int t,int cap)\n{\n  G[f].push_back((edge){t,cap,(int)G[t].size()});\n  G[t].push_back((edge){f,0,(int)G[f].size()-1});\n}\n\n void bfs(int s)\n{\n  memset(level,-1,sizeof(level));\n  queue<int> q;\n  level[s] = 0;\n  q.push(s);\n  while( !q.empty() ) {\n    int v = q.front(); q.pop();\n    for( int i = 0; i < int(G[v].size()); i++ ) {\n      edge& e = G[v][i];\n      if( e.cap > 0 && level[e.to] < 0 ) {\n        level[e.to] = level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f)\n{\n  if( v == t ) return f;\n  for( int &i = iter[v]; i < int(G[v].size()); i++ ) {\n    edge& e = G[v][i];\n    if( e.cap > 0 && level[v] < level[e.to] ) {\n      int d  = dfs(e.to,t,min(f,e.cap));\n      if( d > 0 ) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t)\n{\n  int flow = 0;\n  for(;;) {\n    bfs(s);\n    if( level[t] < 0 ) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while( (f = dfs(s,t,inf)) > 0 ) {\n      flow += f;\n    }\n  }\n}\n\nint main(void)\n{\n  int m,n;\n  int a[555],b[555];\n  for(;;) {\n    scanf(\"%d%d\",&m,&n); if( m+n == 0 ) break;\n    for( int i = 0; i < m+n+2; i++ ) G[i].clear();\n    for( int i = 0; i < m; i++ ) scanf(\"%d\", a+i);\n    for( int i = 0; i < n; i++ ) scanf(\"%d\", b+i);\n    for( int i = 0; i < m; i++ ) {\n      add_edge(0,i+1,1);\n    }\n    for( int i = 0; i < m; i++ ) {\n      for( int j = 0; j < n; j++ ) {\n        if( __gcd(a[i],b[j]) != 1 ) {\n          add_edge(i+1,m+1+j,1);\n        }\n      }\n    }\n    for( int i = 0; i < n; i++ ) {\n      add_edge(m+1+i,n+m+1,1);\n    }\n    printf(\"%d\\n\",max_flow(0,n+m+1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int>list[1000];int N,M,E,i,jmatch[1000],x[1000],y[1000];bool used[1000];\nbool DFS(int V){\n\tused[V]=true;\n\tfor(i=0;i<list[V].size();i++){\n\t\tint u=list[V][i],w=match[u];\n\t\tif(w<0||!used[w]&&DFS(w)){\n\t\t\tmatch[V]=u;\n\t\t\tmatch[u]=V;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint SM(){\n\tint r=0;\n\tmemset(match,-1,sizeof(match));\n\tfor(j=0;j<N+M;j++){\n\t\tif(match[j]<0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(DFS(j)){r++;}\n\t\t}\n\t}\n\treturn r;\n}\nint main(){\n\twhile(1){\n\t\tfor(i=0;i<1000;i++){list[i].clear();}\n\t\tcin>>N>>M;if(!N){break;}\n\t\tfor(i=0;i<N;i++){\n\t\t\tcin>>x[i];\n\t\t}\n\t\tfor(i=0;i<M;i++){\n\t\t\tcin>>y[i];\n\t\t}\n\t\tfor(i=0;i<N;i++){\n\t\t\tfor(j=0;j<M;j++){\n\t\t\t\tif(__gcd(x[i],y[j])>1){\n\t\t\t\t\tlist[i].push_back(j+N);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<SM()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count etc.\n#include <cstdlib>\t// require abs\n#include <cstdio>\t// require printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require sqrt ceil floor\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <stdint.h>\t// require uint64_t\n#include <fstream>\t// require freopen\n\nusing namespace std;\nconst int MAX_V = 1000;\nconst int MAX_N = 500;\n// ¸_\nint V;\n// OtÌ×ÚXg\\»\nvector <int> G[MAX_V];\n\n\nint R[MAX_N], B[MAX_N];\n// }b`OÌyA\nint match[MAX_V];\n\n// DFSÅ·ÅÉ²×½©ÌtO\nbool used[MAX_V];\n\n// uÆvðÔÓðOtÉÇÁ·é\nvoid add_edge (int u, int v )\n{\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\n// ÁpXðDFSÅT·\nbool dfs (int v )\n{\n\n\tused[v] = true;\n\n\tfor (int i = 0; i < G[v].size(); ++i ){\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w) ){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t} // end if\n\t} // end for\n\t\n\treturn false;\n}\n\n// ñOtÌÅå}b`Oðßé\nint bipartite_matching (void)\n{\n\tint res = 0;\n\tmemset (match, -1, sizeof(match ) );\n\tfor (int v = 0; v < V; ++v ){\n\t\tif (match[v] < 0 ){\n\t\t\tmemset (used, 0, sizeof(used) );\n\t\t\tif (dfs(v) ) {\n\t\t\t\t++res;\n\t\t\t} // end if\n\t\t} // end if\n\t} // end for\n\n\treturn res;\n}\n\nint gcd (int a, int b )\n{\n\tif (a > b ){\n\t\tswap (a, b );\n\t} // end if\n\twhile (b % a != 0 ){\n\t\tb = b % a;\n\t\tif (a > b ){\n\t\t\tswap (a, b );\n\t\t} // end if\n\t} // end while\n\n\treturn a;\n}\n\nvoid solve (int m, int n )\n{\n\tV = m + n;\n\tfor (int i = 0; i < m; ++i ){\n\t\tfor (int j = 0; j < n; ++j ){\n\t\t\t\tif (gcd(B[i], R[j] ) != 1 ){\n\t\t\t\t\tadd_edge (i, m + j );\n\t\t\t\t} // end if\n\t\t} // end for\n\t} // end for\n\n\tcout << bipartite_matching() << endl;\t\n}\n\nvoid init (void )\n{\n\tmemset (B, 0, sizeof(B) );\n\tmemset (R, 0, sizeof(R) );\n\tfor (int i = 0; i < MAX_V; ++i ){\n\t\tG[i].clear();\n\t} // end for\t\t\n}\t\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.card1163\", \"r\", stdin );\n\tint m, n;\n\n\twhile (cin >> m >> n && m && n){\n\t\tinit();\n\t\tfor (int i = 0; i < m; ++i){\n\t\t\tcin >> B[i];\n\t\t} // end for\n\t\tfor (int j = 0; j < n; ++j ){\n\t\t\tcin >> R[j];\n\t\t} // end for\n\t\n\t\tsolve (m,n );\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, rev;\n};\n\n#define INF 1e9\n\nbool used[1000];\nvector< vector<Edge> > G;\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back( (Edge){to, cap, G[to].size()} );\n\tG[to].push_back( (Edge){from, 0, G[from].size()-1} );\n}\nint dfs(int s, int t, int f) {\n\tif (s == t) return f;\n\tused[s] = true;\n\tfor (int i = 0; i < G[s].size(); ++i) {\n\t\tEdge& e = G[s][i];\n\t\tif ( !used[e.to] && e.cap > 0 ) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t) {\n\tint res = 0;\n\twhile (1) {\n\t\tfill(used, used+1000, false);\n\t\tint f = dfs(s, t, INF);\n\t\tif ( f == 0 ) break;\n\t\tres += f;\n\t}\n\treturn res;\n}\n\nint gcd(int a, int b) {\n\treturn b == 0 ? a : gcd(b, a%b);\n}\n\nint main() {\n\tint M, N;\n\twhile ( cin >> M >> N, M || N ) {\n\t\tvector<int> v1(M), v2(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tcin >> v1[i];\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> v2[i];\n\t\t}\n\t\tint s = M+N, t = M+N+1;\n\t\tG.clear(); G.resize(t+1);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (gcd(v1[i], v2[j]) > 1) {\n\t\t\t\t\tadd_edge(i, M+j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tadd_edge(s, i, 1);\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tadd_edge(M+i, t, 1);\n\t\t}\n\t\tcout << max_flow(s, t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define MIN(A, B) ((A) < (B))? (A) : (B)\n\nint NextInt() { int d; scanf(\"%d\", &d); return d; }\n\ntypedef struct {\n  int length;\n  int dest[501];\n} Edge;\n\nint b[501], r[501];\nEdge e[501];\nint t[501];\nint m, n;\n\nint augment(int u, int used[]) {\n  if (u < 0) {\n    return 1;\n  }\n  for (int i = 0; i < e[u].length; i++) {\n    int d = e[u].dest[i];\n    if (!used[d]) {\n      used[d] = 1;\n      if (augment(t[d], used)) {\n        t[d] = u;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\n\nint main() {\n  while (1) {\n    m = NextInt(); n = NextInt();\n    if (m + n == 0) {\n      break;\n    }\n    for (int i = 0; i < m; i++) {\n      e[i].length = 0;\n      b[i] = NextInt();\n    }\n    for (int i = 0; i < n; i++) {\n      r[i] = NextInt();\n      t[i] = -1;\n    }\n  \n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        int m = MIN(b[i], r[j]);\n        for (int k = 2; k <= m; k++) {\n          if (b[i] % k == 0 && r[j] % k == 0) {\n            e[i].dest[e[i].length++] = j;\n          } \n        }           \n      }\n    }\n    int ans = 0;\n    for (int i = 0; i < m; i++) {\n      int used[1001] = { 0 };\n      if (augment(i, used)) {\n        ans++;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n// ------ Variable ------ //\n\nint N, M;\n\n\n// ------ Greatest Common Divisor ------ //\n\nint GCD(int a, int b)\n{\n\tif (a % b == 0) { return b; }\n\tif (b % a == 0) { return a; }\n\n\tif (a > b) { return GCD(a % b, b); }\n\tif (b > a) { return GCD(b % a, a); }\n}\n\n\n// ------ Bipartite Matching ------ //\n\nvector<vector<int> > Graph;\n\nvector<int> match;\n\nvector<bool> used;\n\nbool dfs(int v)\n{\n\tused[v] = true;\n\n\tfor (int i = 0; i < Graph[v].size(); i++)\n\t{\n\t\tint u = Graph[v][i], w = match[u];\n\n\t\tif (w < 0 || !used[w] && dfs(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint Bipartite_Matching()\n{\n\tint Ans = 0;\n\n\tmatch = vector<int>(N + M, -1);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (match[i] < 0)\n\t\t{\n\t\t\tused = vector<bool>(N + M, 0);\n\n\t\t\tif (dfs(i))\n\t\t\t{\n\t\t\t\tAns++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Ans;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> N >> M;\n\n\t\tif (N == 0 && M == 0) { break; }\n\n\t\tGraph = vector<vector<int> >(N, vector<int>());\n\n\t\tvector<int> A(N);\n\t\tvector<int> B(M);\n\n\t\tfor (int i = 0; i < N; i++) { cin >> A[i]; }\n\t\tfor (int i = 0; i < M; i++) { cin >> B[i]; }\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < M; j++)\n\t\t\t{\n\t\t\t\tif (GCD(A[i], B[j]) != 1)\n\t\t\t\t{\n\t\t\t\t\tGraph[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << Bipartite_Matching() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nint b[501],r[501],m,n;\nint primes[10001];\nvector<int> G[1001];\n\n\nvoid make_prime() {\n    memset(primes, 0, sizeof(primes));\n    primes[0] = primes[1] = 1;\n    for(int i=4; i<=10000; i+=2) primes[i] = 1;\n    for(int i=3; i*i<=10000; i+=2)\n        if(primes[i] == 0)\n            for(int j=2; i*j<=10000; ++j) primes[i*j] = 1;\n}\n\nvector<int> factorize(const int xx) {\n    int x = xx;\n    vector<int> factor;\n\n    if(x%2 == 0) factor.push_back(2);\n    while(x%2 == 0) x/=2;\n\n    if(primes[x] == 0) {\n        factor.push_back(x);\n        return factor;\n    }\n\n    for(int i=3; i<=xx; i+=2) {\n        if(x == 1) break;\n        if(primes[i]) continue;\n        if(x%i == 0) factor.push_back(i);\n        while(x%i == 0) x /= i;\n    }\n    sort(factor.begin(), factor.end());\n    return factor;\n}\n\nbool iscon(const int i,const int j,const vector<vector<int> > &fact) {\n    for(int x=0,y=0; x<fact[i].size() && y<fact[j+m].size(); ) {\n        if(fact[i][x] == fact[j+m][y]) return true;\n        if(fact[i][x] > fact[j+m][y]) y++;\n        else x++;\n    }\n    return false;\n}\n\nbool bfs(vector<int> &pair_v,vector<int> &dist) {\n    queue<int> Q;\n    const int NIL = n+m;\n    fill(dist.begin(), dist.end(), 1<<29);\n    for(int i=0; i<n+m; ++i)\n        if(pair_v[i] == NIL) {\n            dist[i] = 0;\n            Q.push(i);\n        }\n\n    while(!Q.empty()) {\n        int v = Q.front(); Q.pop();\n        if(v != NIL) {\n            for(int i=0; i<G[v].size(); ++i) {\n                if(dist[pair_v[G[v][i]]] == 1<<29) {\n                    dist[pair_v[G[v][i]]] = dist[v]+1;\n                    Q.push(pair_v[G[v][i]]);\n                }\n            }\n        }\n    }\n    return dist[NIL] != 1<<29;\n}\n\nbool dfs(int v,vector<int> &pair_v,vector<int> &dist) {\n    const int NIL = n+m;\n    if(v != NIL) {\n        for(int i=0; i<G[v].size(); ++i) {\n            int u = G[v][i];\n            if(dist[pair_v[u]] == dist[v]+1) {\n                if(dfs(pair_v[u],pair_v,dist)) {\n                    pair_v[u] = v;\n                    pair_v[v] = u;\n                    return true;\n                }\n            }\n        }\n        dist[v] = 1<<29;\n        return false;\n    }\n    return true;\n}\n\nint biparate_matching() {\n    vector<int> pair_v(n+m+1, n+m); // NIL == n+m\n    vector<int> dist(n+m+1);\n    int matching = 0;\n    int bc = 0;\n    while(bfs(pair_v,dist)) {\n        //cout<<\"bfs : \"<<bc<<endl;\n        bc++;\n        for(int i=0; i<n+m; ++i) {\n            if(pair_v[i] == n+m) if(dfs(i,pair_v,dist)) {\n                    matching++;\n                }\n        }\n    }\n    return matching;\n}\n\nint main() {\n    int i,j;\n    make_prime();\n    while(cin>>m>>n, m|n) {\n        rep(i,m) cin>>b[i];\n        rep(i,n) cin>>r[i];\n\n        vector<vector<int> > fact(n+m ,vector<int>(0));\n        rep(i,m) fact[i] = factorize(b[i]);\n        rep(i,n) fact[i+m] = factorize(r[i]);\n\n        //cout<<\"end factorize\"<<endl;\n\n        // rep(i,n+m) {\n        //     cout<<i<<\" \";\n        //     rep(j,fact[i].size()) cout<<fact[i][j]<<\" \";\n        //     cout<<endl;\n        // }\n\n        rep(i,n+m) G[i].clear();\n        rep(i,m) rep(j,n) {\n            if(iscon(i,j,fact)) {\n                G[i].push_back(j+m);\n                G[j+m].push_back(i);\n                //cout<<\"add edge \"<<i<<\" \"<<j<<endl;\n            }\n        }\n\n        //cout<<\"let's matching\"<<endl;\n\n        cout<<biparate_matching()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nll gcd(ll a,ll b){\n    if(a%b==0){return b;}\n    return gcd(b,a%b);\n}\n\nclass Flow{\nprivate:\n    struct edge{\n        ll to;\n        ll cap;\n        ll rev;\n    };\n    \n    ll INF;\n    ll v;\n    vector<vector<edge>> e;\n    vector<bool> used;\n    \n    void reset_used(){\n        for(int i=0;i<used.size();i++){used[i]=false;}\n    }\n    \n    ll dfs(ll where,ll to,ll flow){\n        if(where==to){return flow;}\n        used[where]=true;\n        for(int i=0;i<e[where].size();i++){\n            edge &E=e[where][i];\n            if(!used[E.to] && E.cap>0){\n                ll d=dfs(E.to,to,min(flow,E.cap));\n                if(d>0){\n                    E.cap-=d;\n                    e[E.to][E.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \npublic:\n    Flow(ll v):v(v){\n        e.resize(v);\n        used.resize(v,false);\n        INF=1e18+7;\n    }\n    \n    void add_edge(ll from,ll to,ll cap){\n        e[from].push_back((edge){to,cap,(ll)e[to].size()});\n        e[to].push_back((edge){from,0,(ll)e[from].size()-1});\n    }\n    \n    ll max_flow(ll s,ll t){\n        vector<vector<edge>> ed=e;\n        ll flow=0;\n        while(1){\n            reset_used();\n            ll f=dfs(s,t,INF);\n            if(f==0){break;}\n            flow+=f;\n        }\n        e=ed;\n        return flow;\n    }\n};\n\n\n\nint main(){\n    ll m,n;\n    while(cin>>m>>n){\n        if(m==0 && n==0){break;}\n    vector<ll> a(m),b(n);\n    Flow F(m+n+2);\n    ll s=m+n;\n    ll g=s+1;\n    for(int i=0;i<m;i++){cin>>a[i]; F.add_edge(s,i,1);}\n    for(int i=0;i<n;i++){cin>>b[i]; F.add_edge(m+i,g,1);}\n    for(int i=0;i<m;i++){\n        for(int t=0;t<n;t++){\n            if(gcd(a[i],b[t])>1){\n                F.add_edge(i,m+t,1);\n            }\n        }\n    }\n    cout<<F.max_flow(s,g)<<endl;\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector< vector<int> > graph;\n\ngraph g;\nvector<int> match;\nvector<bool> visit;\n\nbool search(int u){\n\tif(u<0) return true;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint next = g[u][i];\n\t\tif(visit[next]) continue;\n\t\tvisit[next] = true;\n\t\tif(search(match[next])){\n\t\t\tmatch[u] = next, match[next] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint maximumMatch(int L, int R){\n\tint res = 0;\n\tmatch.assign(L+R, -1);\n\tfor(int i=0;i<L;i++){\n\t\tvisit.assign(L+R, false);\n\t\tres += search(i);\n\t}\n\treturn res;\n}\n\nint gcd(int a, int b){ return b==0 ? a : gcd(b, a%b); }\n\nint main(){\n\tint m, n;\n\tint blue[500], red[500];\n\twhile(cin >> m >> n){\n\t\tif(!(m||n)) break;\n\t\tfor(int i=0;i<m;i++) cin >> blue[i];\n\t\tfor(int i=0;i<n;i++) cin >> red[i];\n\t\tg.assign(m+n, vector<int>());\n\t\tfor(int i=0;i<m;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tif(gcd(blue[i],red[j])!=1){\n\t\t\t\t\tg[i].push_back(j+m);\n\t\t\t\t\tg[j+m].push_back(i);\n\t\t\t\t}\n\t\tcout << maximumMatch(m,n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint gcd(int a,int b)\n{\n\treturn b?gcd(b,a%b):a;\n}\n\nstruct Edge{\n\tint src,dst;\n\tEdge(){}\n\tEdge(int s,int d):src(s),dst(d){}\n};\ntypedef vector<vector<Edge> > Graph;\n\nbool BFS(const Graph& g,const vi& side,const vi& match,vi& level)\n{\n\tint n=g.size();\n\tlevel.assign(n,n);\n\tqueue<pii> q;\n\trep(i,n) if(side[i]==0 && match[i]==-1)\n\t\tq.push(mp(i,0));\n\tbool res=false;\n\twhile(!q.empty()){\n\t\tpii cur=q.front(); q.pop();\n\t\tint u=cur.first,l=cur.second;\n\t\tif(level[u]<=l) continue;\n\t\tlevel[u]=l;\n\t\trep(i,g[u].size()){\n\t\t\tint v=g[u][i].dst;\n\t\t\tif(match[v]==-1)\n\t\t\t\tres=true;\n\t\t\telse\n\t\t\t\tq.push(mp(match[v],l+2));\n\t\t}\n\t}\n\treturn res;\n}\n\nbool DFS(const Graph& g,const vi& side,int u,vi& match,vi& level)\n{\n\trep(i,g[u].size()){\n\t\tint v=g[u][i].dst;\n\t\tif(match[v]==-1 || level[match[v]]>level[u] && DFS(g,side,match[v],match,level)){\n\t\t\tmatch[u]=v;\n\t\t\tmatch[v]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\tlevel[u]=-1;\n\treturn false;\n}\n\nint HopcroftKarp(const Graph& g,const vi& side,vi& match)\n{\n\tint n=g.size();\n\tmatch.assign(n,-1);\n\tint res=0;\n\tfor(vi level;BFS(g,side,match,level);)\n\t\trep(i,n) if(side[i]==0 && match[i]==-1)\n\t\t\tres+=DFS(g,side,i,match,level);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int m,n;scanf(\"%d%d\",&m,&n),m|n;){\n\t\tvi bs(m),rs(n);\n\t\trep(i,m) scanf(\"%d\",&bs[i]);\n\t\trep(i,n) scanf(\"%d\",&rs[i]);\n\t\t\n\t\tGraph g(m+n);\n\t\trep(i,m) rep(j,n) if(gcd(bs[i],rs[j])>1){\n\t\t\tg[i].push_back(Edge(i,m+j));\n\t\t\tg[m+j].push_back(Edge(m+j,i));\n\t\t}\n\t\t\n\t\tvi side(m+n),match;\n\t\tfill(n+all(side),1);\n\t\tprintf(\"%d\\n\",HopcroftKarp(g,side,match));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n/*--------------------------*/\nconst int kMax_n = 1001; //頂点数の最大値\n\nint n; //頂点数\nvvi G(kMax_n);\nvi match(kMax_n); //マッチングのペア\nvi used(kMax_n);\n\n// uとvを結ぶ辺をグラフに追加する\nvoid add_edge(int u, int v){\n    G[u].pb(v);\n    G[v].pb(u);\n}\n\n// 増加パスをDFSで探す\nbool dfs(int v){\n    used[v] = true;\n    \n    for(auto u : G[v]){\n        int w = match[u];\n\n        if(w < 0 || !used[w] && dfs(w)){\n            match[v] = u;\n            match[u] = v;\n\n            return true;\n        }\n    }\n\n    return false;\n}\n\n//二分グラフの最大マッチングを求める\nint b_match(void){\n    int res = 0;\n\n    fill(all(match), -1);\n\n    rep(i, n){\n        if(match[i] < 0){\n            fill(all(used), false);\n\n            if(dfs(i)) res++;\n        }\n    }\n\n    return res;\n}\n\nvoid init_G(void){\n    for(auto & g : G) g.clear();\n}\n/*--------------------------*/\n\nint main(void){\n    for(int mm, nn; cin >> mm >> nn, mm;){\n        vi b(mm), r(nn);\n        for(auto & bb : b) cin >> bb;\n        for(auto & rr : r) cin >> rr;\n\n        n = mm + nn;\n        init_G();\n\n        rep(i, mm){\n            rep(j, nn){\n                if(__gcd(b[i], r[j]) == 1) continue;\n\n                add_edge(i, mm + j);\n            }\n        }\n\n        cout << b_match() << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint m, n;\nint blue[505];\nint red[505];\n\nbool bluematch[505];\nint redpair[505];\n\nint path[505][505];\n\nint gcd(int a, int b)\n{\n    int m;\n    \n    while(1){\n        m = a%b;\n        if(m==0)\n            return b;\n        a = b;\n        b = m;\n    }\n    return 1;\n}\n\nbool match(int x){\n    if(x<0) return true;\n    \n    if(bluematch[x]){\n        return false;\n    }\n    bluematch[x]=true;\n    \n    for(int y=0; y<n; y++){\n        if(!path[x][y]) continue;\n        if(match(redpair[y])){\n            redpair[y]=x;\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    \n    int i, j, cnt;\n    while(1){\n        cin >> m >> n;\n        if(m==0)\n            return 0;\n        \n        for(i=0;i<m;i++){\n            cin >> blue[i];\n        }\n        \n        for(i=0;i<n;i++){\n            cin >> red[i];\n        }\n        \n        for(i=0; i<m; i++){\n            for(j=0; j<n; j++){\n                if(gcd(blue[i],red[j])!=1){\n                    path[i][j]=1;\n                }\n                else{\n                    path[i][j]=0;\n                }\n            }\n        }\n        \n        fill(redpair, redpair+n, -1);\n        cnt=0;\n        for(i=0; i<m; i++){\n            fill(bluematch, bluematch+m, 0);\n            if(match(i)){\n                cnt++;\n            }\n        }\n        cout << cnt << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint m,n;\nint b[500],r[500],p[500];\nbool v[500],c[500][500];\n\nint gcd(int m,int n){\n  if(m==n)\n    return m;\n  else if(m>n)\n    return gcd(n,m);\n  else\n    return gcd (m,n-m);\n}\n\nbool match(int blue){\n  if(blue<0) return true;\n  for(int red=0; red<n; red++){\n    if(!c[blue][red] || v[red]) continue;\n    v[red] = true;\n    if(match(p[red])){\n      p[red] = blue;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(scanf(\"%d %d\",&m,&n),n){\n    for(int i=0; i<m; i++)\n      scanf(\"%d\",&b[i]);\n    for(int i=0; i<n; i++)\n      scanf(\"%d\",&r[i]);\n\n    for(int i=0; i<n; i++) p[i]=-1;\n    for(int i=0; i<m; i++) \n      for(int j=0; j<n; j++) \n\tc[i][j] = (gcd(b[i],r[j])>=2);\n\n    int cnt=0;\n    for(int i=0; i<m; i++){\n      for(int j=0; j<n; j++) v[j]=false;\n      if(match(i)) ++cnt;\n    }\n\n    printf(\"%d\\n\",cnt);    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<functional>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define MaxCards 1000\nusing namespace std;\nint\tb,r,V;\nint blue[MaxCards],red[MaxCards];\nvector<int> G[MaxCards];\nint match[MaxCards]; // マッチングのペア\nbool used[MaxCards]; // DFSですでに調べたかのフラグ\n\n\n// uからvを結ぶ辺をグラフに追加する\nvoid add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\n// 増加パスをDFSで探す\nbool dfs(int v) {\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++) {\n        int u = G[v][i], w = match[u];\n        if (w < 0 || !used[w] && dfs(w)) {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\n// 二部グラフの最大マッチングを求める\nint bipartite_matching() {\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for(int v = 0; v < V; v++) {\n        if (match[v] < 0) {\n            memset(used, 0, sizeof(used));\n            if (dfs(v)) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\nint gcd(int n1,int n2){\n\tif(n1%n2==0) return n2;\n\treturn gcd(n2,n1%n2);\n}\nint main(){\n\n\twhile(true){\n\t\tmemset(blue,0,sizeof(blue));\n\t\tmemset(red,0,sizeof(red));\n\t\tfor(int i=0;i<MaxCards;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tcin>>b>>r;\n\t\tV=b+r;\n\t\tif(b==0)\n\t\t\tbreak;\n\t\tint idx=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tcin >> blue[i];\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin >> red[i];\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tfor(int j=0;j<r;j++){\n\t\t\t\tif(blue[i]>red[j]){\n\t\t\t\t\tif(gcd(blue[i],red[j])!=1){\n\t\t\t\t\t\tadd_edge(i,b+j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(gcd(red[j],blue[i])!=1){\n\t\t\t\t\tadd_edge(i,b+j);\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <string>\n#include <string.h>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\n\nconst int MAX_P = 10000;\nconst int MAX_V = 1010;\nconst int INF = 0x3f3f3f3f;\n\nint M, N;\nvector<bool> isPrime(MAX_P, true);\nvi primes;\n\n// 辺を表す構造体（行き先、容量、逆辺）\nstruct edge { int to, cap, rev; };\n\nclass MF {\npublic:\n  vector<edge> G[MAX_V];  // グラフの隣接リスト表現\n  bool used[MAX_V];   // DFSですでに調べたかのフラグ\n\n  // fromからtoへ向かう容量capの辺をグラフに追加する\n  void add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, 0, G[from].size() - 1});\n  }\n\n  // 増加パスをDFSで探す\n  int dfs(int v, int t, int f) {\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++) {\n      edge &e = G[v][i];\n      if(!used[e.to] && e.cap > 0) {\n        int d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  int max_flow(int s, int t) {\n    int flow = 0;\n    for(;;) {\n      memset(used, 0, sizeof(used));\n      int f = dfs(s, t, INF);\n      if(f == 0) return flow;\n      flow += f;\n    }\n  }\n};\n\nvoid init() {\n  isPrime[0] = isPrime[1] = false;\n  for (int i = 0; i < MAX_P; i++) {\n    if (!isPrime[i]) continue;\n    primes.pb(i);\n    for (int j = i; j < MAX_P; j+=i) {\n      isPrime[j] = false;\n    }\n  }\n}\n\nint main() {\n  init();\n  while (true) {\n    vi Bs, Rs;\n    cin >> M >> N;\n    if (M==0 && N==0) {\n      break;\n    }\n    MF mf;\n    for (int i = 0; i < M; i++) {\n      int b; cin >> b;\n      Bs.pb(b);\n      mf.add_edge(0, i+1, 1);\n    }\n    for (int i = 0; i < N; i++) {\n      int r; cin >> r;\n      Rs.pb(r);\n      mf.add_edge(i+M+1, M+N+1, 1);\n    }\n    for (int i = 0; i < M; i++) {\n      for (int j = 0; j < N; j++) {\n        for (int k = 0; k < (int)primes.size(); k++) {\n          if (Bs[i]%primes[k]==0 && Rs[j]%primes[k]==0) {\n            // cout << i+1 << \", \" << j+1 << endl;\n            mf.add_edge(i+1, j+M+1, 1);\n            break;\n          }\n        }\n      }\n    }\n    cout << mf.max_flow(0, M+N+1) << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<string>\n#include<cmath>\n#include<cassert>\n#include<map>\n  using namespace std;\n\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ (i)=0;(i)<(j);(i)++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);(i)++)\n#define all(v) begin(v),end(v)\n\n#define MAX_N 501\nclass maxFlow\n{\npublic:\n  int N;//???????????°\n  int G[MAX_N][MAX_N];//G[i][j] :=???i??????j????????§?????????\n  bool is_visited[MAX_N];\n\n  maxFlow(int n)\n  {\n    N=n;\n    //?????????????????¨????????°???????????§??????\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tG[i][j]=0;\n  }\n\n  //n1->n2???arc?????????\n  void add_arc(int n1,int n2,int capacity)\n  {\n    G[n1][n2]+=capacity;//????????§?????±???\n  }\n\n  //??´???????????§???????????¢?´¢\n  int dfs(int now,int end,int min_capacity)\n  {\n    if(now==end)return min_capacity;\n    if(!is_visited[now])\n      {\n\tis_visited[now]=true;\n\tfor(int i=0;i<N;i++){\n\t  if(G[now][i]>0){//now??????i????????§??????????????????????????°????????§??????\n\t    int ret=dfs(i,end,min(min_capacity,G[now][i]));\n\t    if(ret>0){//??´???????????????????????????????????§?¢???????????????????????????????????????´??°\n\t      G[now][i]-=ret;\n\t      G[i][now]+=ret;\n\t      return ret;\n\t    }\n\t  }\n\t}\n\treturn -2;//??´????????????????????????????????£???\n      }\n    else return -1;//?????§????¨???????????????£???\n  }\n  \n  int get_maxFlow(int start,int end)\n  {\n    int temp,ans=0;\n    //??´???????????????????????????????????§????????????????????????????????????????´¢\n    while(true){\n      for(int i=0;i<N;i++)is_visited[i]=false;\n      temp=dfs(start,end,100);\n      if(temp>0)ans+=temp;\n      else break;\n    }\n    return ans;\n  }\n  \n};\n\nint gcd(int a,int b){\n  if(b==0)return a;\n  return gcd(b,a%b);\n}\n\nint main()\n{\n  int n,m;\n\n  while(true){\n    cin>>m>>n;\n    if(m==0&&n==0)break;\n    maxFlow G(m+n+2);\n    vector<int> b(m);\n    vector<int> r(n);\n    rep(i,m){\n      cin>>b[i];\n      G.add_arc(m+n, i, 1);\n    }\n    rep(i,n){\n      cin>>r[i];\n      G.add_arc(m+i, m+n+1 , 1);\n    }\n    \n    rep(i,m){\n      rep(j,n){\n        if(gcd(b[i],r[j])!=1){\n          G.add_arc(i, m+j, 1);\n        }\n      }\n    }\n\n    cout<<G.get_maxFlow(m+n, m+n+1)<<endl;\n    \n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\"\n \nusing namespace std;\nusing ll = long long int;\n \n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);cout<<(v)<<endl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(remove_const<decltype(l)>::type cnt=0;(cnt)<(l);++(cnt))\n#define rrepeat(cnt,l) for(auto cnt=(l)-1;0<=(cnt);--(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define diterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);--(cnt))\nconst ll MD = 1000000007ll; const long double PI = 3.1415926535897932384626433832795L;\ntemplate<typename T1, typename T2> inline void assert_equal(T1 expected, T2 actual) { if (!(expected == actual)) { cerr << \"assertion fault: expected=\" << expected << \" actual=\" << actual << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_less(T1 actual, T2 threshold) { if (!(actual < threshold)) { cerr << \"assertion fault: \" << actual << \" < (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_eqless(T1 actual, T2 threshold) { if (!(actual <= threshold)) { cerr << \"assertion fault: \" << actual << \" <= (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << '(' << p.first << ':' << p.second << ')'; return o; }\ntemplate<typename Vec> inline ostream& _ostream_vecprint(ostream &o, const Vec& p) { o << '['; for (auto& e : p) o << e << ','; o << ']'; return o; }\ntemplate<typename T> inline ostream& operator<<(ostream& o, const vector<T>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T, size_t S> inline ostream& operator<<(ostream& o, const array<T, S>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T> inline T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> inline T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(code); }\nmt19937_64 randdev(8901016);\ntemplate<typename T> inline T rand(T l, T h) { return uniform_int_distribution<T>(l, h)(randdev); }\ntemplate<> inline double rand<double>(double l, double h) { return uniform_real_distribution<double>(l, h)(randdev); }\ntemplate<> inline float rand<float>(float l, float h) { return uniform_real_distribution<float>(l, h)(randdev); }\n \n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif defined(__GNUC__)\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc && cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var * sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = '\\n') { for (auto it = begin; it != end; ++it) *this << *it << sep; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\nclass DGraphF {\npublic:\n    typedef int cap_t;\n    size_t n_;\n    struct Arc {\n        int from, to;\n        // 残量\n        cap_t left;\n        // 容量\n        cap_t cap;\n\n        Arc(int from = 0, int to = 0, cap_t w = 1) :from(from), to(to), left(w), cap(w) {}\n        inline bool operator<(const Arc& a) const { return (left != a.left) ? left < a.left : (left<a.left) | (cap<a.cap) | (from<a.from) | (to<a.to); }\n        inline bool operator==(const Arc& a) const { return (from == a.from) && (to == a.to) && (left == a.left) && (cap == a.cap); }\n    };\n    vector<vector<int>> vertex_to;\n    vector<vector<int>> vertex_from;\n    vector<Arc> edges;\n\n    DGraphF(int n = 1) :n_(n), vertex_to(n), vertex_from(n) { }\n\n    void connect(int from, int to, cap_t left) {\n        vertex_to[(size_t)from].push_back((int)edges.size()); // toto\n        vertex_from[(size_t)to].push_back((int)edges.size()); // fromfrom\n        edges.emplace_back(from, to, left);\n    }\n};\n\n\nvoid dinic(DGraphF &graph, vector<DGraphF::cap_t>& result, int i_source, int i_sink) {\n    assert(i_source != i_sink);\n\n    result.resize(graph.n_);\n    vector<int> dist(graph.n_);\n    queue<int> q;\n    vector<int> flag(graph.n_);\n\n    static function<DGraphF::cap_t(int, int, DGraphF::cap_t)> _dfs = [&](int u, int i_sink, DGraphF::cap_t mini) {\n        // DAG\n        // TODO: 経路再利用\n        if (i_sink == u) return mini;\n        if (flag[u]) return (DGraphF::cap_t) - 1;\n        flag[u] = true;\n\n        DGraphF::cap_t sumw = 0;\n        bool term = true;\n        for (int e : graph.vertex_to[u]) {\n            auto& edge = graph.edges[e];\n            if (edge.left > 0 && dist[u]>dist[edge.to]) {\n                DGraphF::cap_t w = (mini < 0) ? edge.left : min(edge.left, mini);\n\n                w = _dfs(edge.to, i_sink, w);\n                if (w == -1) continue;\n                edge.left -= w;\n                result[edge.to] += w;\n\n                sumw += w;\n                mini -= w;\n                term = false;\n                flag[u] = false; // TODO: 末尾では? \n\n                if (mini == 0) return sumw;\n            }\n        }\n        for (int e : graph.vertex_from[u]) {\n            auto& edge = graph.edges[e];\n            if (edge.cap>edge.left && dist[u]>dist[edge.from]) {\n                DGraphF::cap_t w = (mini < 0) ? (edge.cap - edge.left) : min(edge.cap - edge.left, mini);\n\n                w = _dfs(edge.from, i_sink, w);\n                if (w == -1) continue;\n                edge.left += w;\n                result[edge.to] -= w;\n\n                sumw += w;\n                mini -= w;\n                term = false;\n                flag[u] = false;\n                if (mini == 0) return sumw;\n            }\n        }\n        return term ? (DGraphF::cap_t)(-1) : sumw;\n    };\n\n\n    for (int distbegin = 0; ; distbegin += (int)graph.n_) {\n\n        q.emplace(i_sink); // bfsはsinkからsourceへの距離を計算．\n        dist[i_sink] = distbegin + 1;\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int ie : graph.vertex_from[v]) {\n                const auto edge = graph.edges[ie];\n                if (0 < edge.left && dist[edge.from] <= distbegin) {\n                    dist[edge.from] = dist[v] + 1;\n                    q.emplace(edge.from);\n                }\n            }\n            for (int ie : graph.vertex_to[v]) {\n                const auto edge = graph.edges[ie];\n                if (edge.left < edge.cap && dist[edge.to] <= distbegin) {\n                    dist[edge.to] = dist[v] + 1;\n                    q.emplace(edge.to);\n                }\n            }\n        }\n        fill(flag.begin(), flag.end(), false);\n\n        if (dist[i_source] <= distbegin)\n            break;\n        else\n            result[i_source] += _dfs(i_source, i_sink, -1);\n    }\n}\n\n\ntemplate<typename T> inline T gcd(T a, T b) { while(b){T t=a%b;a=b;b=t;}return a; }\ntemplate<typename T> inline T lcm(T a, T b) { return a*b/gcd(a,b); }\n\n\n\nint main(){\n    int blue[555],red[555];\n    \n    int m,n;\n    while(scanner >> m >> n, m != 0 || n != 0){\n        DGraphF g(m+n+2);\n        const int vs = m+n, vt = m+n+1;\n        scanner.in(blue,blue+m);\n        scanner.in(red,red+n);\n        repeat(i, m)\n            repeat(j, n)\n                if (gcd(blue[i],red[j])>1) g.connect(i,m+j,1);\n        repeat(i,m)\n            g.connect(vs,i,1);\n        repeat(j,n)\n            g.connect(j,vt,1);\n            \n        vector<int> f;\n        dinic(g,f,vs,vt);\n        printer << f[vt] << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\n\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define X first\n#define Y second\n#define MP(x,y) make_pair(x,y)\nusing namespace std;\n\n\nconst int  MAX_V = 2000;\n\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v) {\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v) {\n  // cout << \"dfs\" << endl;\n  used[v] = true;\n  rep(i,G[v].size()){\n    int u = G[v][i], w = match[u];\n    if( w < 0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bi(){\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  rep(v, V){\n    if(match[v] < 0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v)){\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\nint b[1000];\nint r[1000];\n\nbool is_p(int x){\n  if(x <= 1) return false;\n  for(int i = 2; i*i <= x; ++i){\n    if(x % i == 0){\n      return false;\n    }\n  }\n  return true;\n}\n\nvector<int> primes[1280000];\n\nint main(void){\n  int n,m;\n\n  while(cin >> n>> m, n){\n    V = 2000;\n    rep(i,n)cin >> b[i];\n    rep(j,m)cin >> r[j];\n    rep(i,n)rep(j,m){\n      if(__gcd(b[i], r[j]) != 1){\n        // cout << i << \" <-> \" << j  << endl;\n        // cout << i << \" <-> \" << j + 1000 << endl;\n        add_edge(i,j+1000);\n      }\n    }\n    cout << bi() << endl;;\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\n// edge e, G[e.to][e.rev].to=e\nvector<int> blue,red;\nvector<vector<int> > adj;\nvector<vector<int> > F;\nvoid addflow(int from,int to,int cap)\n{\n  adj[from].push_back(to);\n  adj[to].push_back(from);\n  F[from][to]+=cap;\n}\nvoid flow(int from,int to,int cap)\n{\n  F[from][to]-=cap;\n  F[to][from]+=cap;\n}\nset<int> already;\nint FF(int so,int si,int mcap)\n{\n  //cout << \"FF \" << so << ' ' << si << ' ' << mcap << endl;\n  if(so==si) return mcap;\n  if(!already.insert(so).second) return 0;\n  REP(i,adj[so].size()){\n    //cout << \"FF2\" << endl;\n    int answer;\n    if(F[so][adj[so][i]])\n      if(answer=FF(adj[so][i],si,min(mcap,F[so][adj[so][i]]))){\n\tflow(so,adj[so][i],answer);\n\treturn answer;\n      }\n  }\n  return 0;\n}\nint maxflow(int so,int si)\n{\n  int answer=0;\n  already.clear();\n  while(int tmp=FF(so,si,1048576)){\n    answer+=tmp;\n    already.clear();\n    //cout << tmp << endl;\n  }\n  return answer;\n}\nint gcd(int a,int b){ return b?gcd(b,a%b):a; }\nint main(void)\n{\n  for(;;){\n    int m,n;\n    cin >> m >> n;\n    if(!m&&!n) return 0;\n    blue.resize(m);\n    REP(i,m) cin >> blue[i];\n    red.resize(n);\n    REP(i,n) cin >> red[i];\n    adj.assign(m+n+2,vector<int>());\n    F.resize(m+n+2);\n    REP(i,m+n+2) F[i].assign(m+n+2,0);\n    REP(j,n) addflow(m+j,m+n+1,1);\n    REP(i,m) REP(j,n) if(gcd(blue[i],red[j])!=1) addflow(i,m+j,1);\n    REP(i,m) addflow(m+n,i,1);\n    cout << maxflow(m+n,m+n+1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define FOR(i,a,n) for(int i = a; i < n; i++)\n\ntypedef long long ll;\ntypedef vector<int> VI;\n\n#define MAX_V 1010\n\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  rep(i,G[v].size()){\n    int u = G[v][i], w = match[u];\n    if(w < 0 || (!used[w] && dfs(w)) ){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint m,n;\nint bipartie_matching(){\n  int V = n+m;\n  int res = 0;\n  memset(match, -1, sizeof(match));\n\n  for(int v = 0; v < V; v++){\n    if(match[v] < 0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v)){\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\nlong long gcd( long long m, long long n ){\n    if ( n == 0) return m;\n    return gcd(n,m%n);\n}//最大公約数\n\nint main(){\n  while(true){\n\n    cin >> m >> n;\n    if(m == 0 && n == 0) break;\n    VI b(m),r(n);\n    rep(i,m) cin >> b[i];\n    rep(i,n) cin >> r[i];\n\n    rep(i,m)rep(j,n){\n      if( gcd(b[i],r[j]) > 1 ){\n        add_edge(i,j+m);\n      }\n    }\n\n    int ans = bipartie_matching();\n    cout << ans << \"\\n\";\n    rep(i,MAX_V) G[i].clear();\n    memset(used,false,sizeof(used));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<29\n\nusing namespace std;\n/*\n\t二部マッチング\n\n\t説明\n\t\t二部グラフの最大マッチングを求める Ford-Fulerson like なアルゴリズム\n\t\tbipartite_matching がメインルーチン\n\n\t引数\n\t\tL : 左の頂点集合のサイズ\n\t\tR : 右の頂点集合のサイズ\n\t\tG : 二部グラフ（表示方法が特殊なので注意）\n\t\t\tG[0],...,G[L-1] まであり、G[u] は u と辺でつながっている右の頂点集合を表す。\n\t\t\tここで、右の頂点は 0,...,R-1 と番号付けられている。\n\n\t戻り値\n\t\t最大マッチングのサイズ\n\t\n\t制約\n\t\tなし\n\t\n\t計算量\n\t\tO(V*(V+E))\n\n\t備考\n\t\tV_MAX は max(L,R) 以上であればよい。\n\n\t\tマッチングが具体的にほしいときは match を返すようにする\n\t\tmatch[0][u] := 左の頂点 u とマッチしている右の頂点の番号（存在しなければ -1 ）\n\t\tmatch[1][v] := 右の頂点 v とマッチしている左の頂点の番号（存在しなければ -1 ）\n\n*/\nconst int V_MAX=500;\n\nbool augment(int u,bool *vis,int match[2][V_MAX], const vector<int> *G ){\n\tif(u==-1) return true;\n\n\trep(i,G[u].size()){\n\t\tint v=G[u][i];\n\t\tif(!vis[v]){\n\t\t\tvis[v]=true;\n\t\t\tif(augment(match[1][v],vis,match,G)){\n\t\t\t\tmatch[0][u]=v;\n\t\t\t\tmatch[1][v]=u;\n\t\t\t\treturn true;\n\t\t\t} // end if\n\t\t} // end if\n\t} // end rep\n\treturn false;\n}\n\nint bipartite_matching(int L,int R,const vector<int> *G){\n\tstatic int match[2][V_MAX];\n\trep(u,L) match[0][u]=-1;\n\trep(v,R) match[1][v]=-1;\n\t\n\tint res=0;\n\tstatic bool vis[V_MAX];\n\trep(u,L){\n\t\trep(v,R) vis[v]=false;\n\t\tif(augment(u,vis,match,G)) res++;\n\t} // end rep\n\n\treturn res;\n}\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.1163\", \"r\", stdin );\n\tint n, m;\n\twhile (scanf (\"%d %d\", &n, &m ), n, m ){\n\t\tstatic vector<int> G[V_MAX];\n\t\trep (i, V_MAX ) G[i].clear();\n\t\t// 0 〜 n-1: bule card n〜n+m-1: red card\n\t\tvector<int> cards (n+m, 0 );\n\t\trep (i, n ){\n\t\t\tscanf (\"%d\", &cards[i] );\n\t\t} // end rep\n\t\trep (j, m ){\n\t\t\tscanf (\"%d\", &cards[n+j] );\n\t\t} // end rep\n\n\t\trep (i, n ){\n\t\t\trep (j, m ){\n\t\t\t\tif (__gcd (cards[i], cards[n+j] ) != 1 ){\n\t\t\t\t\tG[i].push_back (j );\n\t\t\t\t} // end if\n\t\t\t} // end rep\n\t\t} // end rep\n\t\tint res = bipartite_matching (n, m, G );\n\t\tprintf (\"%d\\n\", res );\n\t} // end while\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nvector<int> blue;\nvector<int> red;\nvector<int> redpair;\nvector<int> v;\nvector<vector<int> > c;\nint m = 0;\nint n = 0;\n\n\nint gcd(int x,int y){\n    if(x % y == 0){\n        return y;\n    }\n    return gcd(y,x%y);\n}\n\nbool match(int x){\n    if(x == -1){\n        return 1;\n    }\n    for(int i = 0;i < n;i++){\n        if(c[x][i] == 1 && v[i] == 0){\n            v[i] = 1;\n            if(match(redpair[i])){\n                redpair[i] = x;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\n\nint main(){\n\n    while(cin >> m >> n){\n        if(m == 0 && n == 0){\n            break;\n        }\n        blue.clear();\n        red.clear();\n        redpair.clear();\n        v.clear();\n        c.clear();\n        for(int i = 0;i < m;i++){\n            int tmp;\n            cin >> tmp;\n            blue.push_back(tmp);\n        }\n        for(int i = 0;i < n;i++){\n            int tmp;\n            cin >> tmp;\n            red.push_back(tmp);\n            redpair.push_back(-1);\n            v.push_back(0);\n        }\n        for(int i = 0;i < m;i++){\n            c.push_back(vector<int>());\n            for(int j = 0;j < n;j++){\n                c[i].push_back(gcd(blue[i],red[j]) != 1);\n            }\n        }\n        int ans = 0;\n        for(int i = 0;i < m;i++){\n            for(int j = 0;j < n;j++){\n                v[j] = 0;\n            }\n            if(match(i)){\n                ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n//#define EACH(i, c) for (auto &(i): c)\n#define all(c) begin(c),end(c)\n//#define EXIST(s, e) ((s).find(e)!=(s).end())\n//#define SORT(c) sort(begin(c),end(c))\n//#define pb emplace_back\n//#define MP make_pair\n//#define SZ(a) int((a).size())\n\n//#define LOCAL 0\n//#ifdef LOCAL\n//#define DEBUG(s) cout << (s) << endl\n//#define dump(x)  cerr << #x << \" = \" << (x) << endl\n//#define BR cout << endl;\n//#else\n//#define DEBUG(s) do{}while(0)\n//#define dump(x) do{}while(0)\n//#define BR\n//#endif\n\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n//ここから編集する\n\nclass Flow {\npublic:\n    struct edge {\n        int to, cap, rev;\n    };\n    vector<vector<edge> > G;\n    vector<bool> used;\n    vector<int> level;//sからの距離\n    vector<int> iter;//どこまで調べ終わったか\n\n    //0 ~ maxSize-1 のフローを構築できるようにする\n    explicit Flow(unsigned maxSize) {\n        G.resize(maxSize, vector<edge>());\n        used.resize(maxSize, false);\n        level.resize(maxSize, 0);\n        iter.resize(maxSize, 0);\n    }\n\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back((edge) {to, cap, (int) G[to].size()});\n        G[to].push_back((edge) {from, 0, (int) G[from].size() - 1});\n    }\n\n    //sからの最短距離をDFSで探す\n    void bfs(int s) {\n//        memset(level, -1, sizeof(level));\n        fill(level.begin(), level.end(), -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (int i = 0; i < G[v].size(); i++) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    //増加パスを探す\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    //sからtへの最大流を求める\n    int max_flow(int s, int t) {\n        int flow = 0;\n        for (;;) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n//            memset(iter, 0, sizeof(iter));\n            fill(iter.begin(), iter.end(), 0);\n            int f;\n            while ((f = dfs(s, t, INF)) > 0) {\n                flow += f;\n            }\n        }\n    }\n\n};\n\nll gcd(ll a, ll b) {\n    if (a < b) swap(a, b);\n    if (a % b == 0) return b;\n    return gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n    return a / gcd(a, b) * b;\n}\n\nbool calc() {\n    int n, m;\n    cin >> n >> m;\n    if (n == 0 && m == 0) return false;\n    vector<int> b(n), r(m);\n    rep(i, 0, n) cin >> b[i];\n    rep(i, 0, m) cin >> r[i];\n\n    int s = 0;\n    int t = n + m + 1;\n    Flow flow(n + m + 2);\n    rep(i, 0, n) {\n        flow.add_edge(s, i + 1, 1);\n    }\n    rep(i, 0, m) {\n        flow.add_edge(n + i + 1, t, 1);\n    }\n    rep(i, 0, n) {\n        rep(j, 0, m) {\n            if (gcd(b[i], r[j]) > 1) {\n                flow.add_edge(i + 1, j + n + 1, 1);\n            }\n        }\n    }\n\n    int ans = flow.max_flow(s, t);\n    cout << ans << endl;\n\n\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (calc()) {}\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define REPD(i,n) for(int i=(int)(n); i-->0;)\n#define REPI(i,a,b) for(int i=(int)(a); i<=(int)(b); i++)\n#define ALL(a) (a).begin(),(a).end()\n#define mp make_pair\n#define fst first\n#define snd second\n\n#define INFTY 1000000000\n#define EPS 1e-9\n#define PI 3.141592653589793\n\n#define INF (INFTY/3)\n\n#define rev(s) (string((s).rbegin(), (s).rend()))\n\ntypedef long long Int;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<double,double> pdd;\n\nvoid debug(vi v){ REP(i,v.size()) cout<<v[i]<<\" \"; cout<<endl; }\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\nEdge(int src, int dst) : src(src),dst(dst) {}\nEdge(int src, int dst, Weight weight) :\n  src(src), dst(dst), weight(weight) {}\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vec<Edge> Edges;\ntypedef vec<Edges> Graph;\n\ntypedef vec<Weight> Array;\ntypedef vec<Array> Matrix;\n#define MAXMN 500\n#define Int long long\nint B[MAXMN];\nint R[MAXMN];\n\nInt gcd(Int a, Int b)\n{   \n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\n\n\nmain() {\n  int M,N;\n  Graph g;\n  while(cin>>M>>N,M) {\n    g.clear();\n    g.resize(M+N+2);\n    REP(i,M) cin>>B[i];\n    REP(i,N) cin>>R[i];\n    REP(i,M) {\n      Edges es, es2;\n      REP(j,N) {\n\tif(gcd(B[i],R[j])!=1) { es.pb(Edge(i,M+j)); es2.pb(Edge(M+j,i)); }\n      }\n      g[i] = es;\n      g[M+i] = es2;\n    }\n    Edges matching;\n    cout << bipartiteMatching(g,M,matching) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct BipartiteMatching\n{\n  vector< vector<int> > G;\n  vector<int> matched;\n  vector<bool> used;\n  BipartiteMatching(int V):G(V), matched(V, -1), used(V, false){}\n  void add_edge(int u, int v)\n  {\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n  bool dfs(int u)\n  {\n    used[u] = true;\n    for(auto& v : G[u]) {\n      int w = matched[v];\n      if(w < 0 || !used[w] && dfs(w)) {\n\tmatched[u] = v;\n\tmatched[v] = u;\n\treturn true;\n      }\n    }\n    return false;\n  }\n  int match()\n  {\n    int res = 0;\n    for(int u = 0; u < G.size(); u++) {\n      if(matched[u] < 0) {\n\tused.clear(); used.resize(G.size(), false);\n\tif(dfs(u)) res++;\n      }\n    }\n    return res;\n  }\n};\n\nint main()\n{\n  int m, n;\n  while(cin >> m >> n, m || n) {\n    vector<int> b(m), r(n);\n    for(int i = 0; i < m; i++) cin >> b[i];\n    for(int i = 0; i < n; i++) cin >> r[i];\n    BipartiteMatching bimatch(m + n);\n    for(int i = 0; i < m; i++) {\n      for(int j = 0; j < n; j++) {\n\tif(__gcd(b[i], r[j]) > 1) bimatch.add_edge(i, m + j);\n      }\n    }\n    cout << bimatch.match() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX 500\n#define TEST 0\nint b[MAX],r[MAX];\nint c[MAX][MAX];\n\nint p[MAX];//pairing red->blue\nbool v[MAX];//red[?]がすでに新しい割り当て先のないことが決まっている場合true\n\nint gcd(int x,int y)\n{\n\twhile(y!=0)\n\t{\n\t\tint r=x%y;\n\t\tx=y;\n\t\ty=r;\n\t}\n\treturn x;\n}\n\nint match(int bl,int n,bool v[MAX])\n{\n\tif(bl<0)\n\t{\n\t\tputs(\"error bl<0\");\n\t\texit(1);\n\t}\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tif(!c[bl][i] || v[i])continue;\n\t\tv[i]=true;\n\t\tint ano=p[i];\n\t\tif(p[i]<0)\n\t\t{\n\t\t\tp[i]=bl;\n\t\t\treturn 1;\n\t\t}\n\t\tint sub=match(p[i],n,v);\n\t\tif(sub>0)\n\t\t{\n\t\t\tp[i]=bl;\n\t\t\treturn sub;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void)\n{\n\tint m,n;\nwhile(scanf(\"%d%d\",&m,&n)==2 && (m||n))\n{\n\tint count=0;\n\tfor(int i=0;i<m;++i)\n\t{\t\n\t\tscanf(\"%d\",b+i);\n\t}\n\tfor(int j=0;j<n;++j)\n\t{\n\t\tscanf(\"%d\",r+j);\n\t\tp[j]=-1;\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tc[i][j]=gcd(b[i],r[j])!=1?1:0;\n\t\t}\n\t}\n\tfor(int i=0;i<m;++i)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tv[j]=false;\n\t\t}\n\t\tint res=match(i,n,v);\n\t\tcount+=res;\n\t}\n\tprintf(\"%d\\n\",count);\n\tif(TEST)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tprintf(\"(%d,%d)\\n\",p[j],j);\n\t\t}\n\t}\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int MAX_V = 100;\nconst int INF = 10000000;\n\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap)\n{\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f)\n{\n  if(v == t) return f;\n\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n\n  return 0;\n}\n\nint max_flow(int s, int t)\n{\n  int flow = 0;\n  for(;;){\n    fill(used, used + MAX_V, false);\n    int f = dfs(s, t, INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint gcd(int a, int b)\n{\n  int c;\n  if (a < b) {\n    a+=b; b=a-b; a-=b;\n  }\n  while (b != 0) {\n    c = a % b;\n    a = b;\n    b = c;\n  }\n  return a;\n}\n\nint main()\n{\n  while(1){\n    int m, n;\n    cin >> m >> n;\n    if(m == 0 && n == 0) break;\n    int b[m], r[n];\n    for(int i = 0; i < m; i++)\n      cin >> b[i];\n    for(int i = 0; i < n; i++)\n      cin >> r[i];\n    for(int i = 0; i < m; i++){\n      for(int j = 0; j < n; j++){\n        if(gcd(b[i], r[j]) != 1){\n          add_edge(i+2, j+m+2, 1);\n        }\n      }\n    }\n    for(int i = 2; i < m + 2; i++)\n      add_edge(0, i, 1);\n    for(int i = m+2; i < m+n+2; i++)\n      add_edge(i, 1, 1);\n    cout << max_flow(0, 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint V;\nvector<int> G[1010];\nint match[1010];\nbool used[1010];\n\nvoid add_edge(int u, int v) {\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tint u = G[v][i];\n\t\tint w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching() {\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; v++) {\n\t\tif (match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nlong long int gcd(long long int a, long long int b) {\n\tif (b == 0) {\n\t\treturn a;\n\t}\n\telse {\n\t\treturn gcd(b, a%b);\n\t}\n}\n\nint main() {\n\tint m, n;\n\twhile (cin >> m >> n) {\n\t\tif (m == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 1010; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t\tV = m + n;\n\t\tvector<long long int> b(m);\n\t\tvector<long long int> r(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> b[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> r[i];\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (gcd(b[i], r[j]) != 1) {\n\t\t\t\t\tadd_edge(i, m+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 502\nusing namespace std;\n\nint m,n,b[MAX],r[MAX];\nint match[MAX+MAX];\nbool used[MAX+MAX];\nvector<int> e[MAX+MAX];\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<e[v].size();i++){\n    int u=e[v][i],w=match[u];\n    if(w<0||(!used[w]&&dfs(w))){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int i=0;i<MAX+MAX;i++){\n    if(match[i]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(i))res++;\n    }\n  }\n  return res;\n}\n\nint gcd(int a,int b){\n  if(b==0)return a;\n  return gcd(b,a%b);\n}\n\nint main(){\n  while(1){\n    cin>>m>>n;\n    if(!m&&!n)break;\n    for(int i=0;i<m;i++)cin>>b[i];\n    for(int i=0;i<n;i++)cin>>r[i];\n    for(int i=0;i<m;i++)\n      for(int j=0;j<n;j++)\n\tif(gcd(b[i],r[j])>1){\n\t  e[i].push_back(j+m);\n\t  e[j+m].push_back(i);\n\t}\n    cout<<bipartite_matching()<<endl;\n    for(int i=0;i<MAX+MAX;i++)e[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <numeric>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <limits>\n#include <cassert>\n//#include <boost/multiprecision/cpp_int.hpp>\n\n\n\nusing namespace std;\nusing Int = long long;\n//using namespace boost::multiprecision;\n\nconst double EPS = 1e-10;\nlong long const MOD = 1000000007;\n\nlong long mod_pow(long long x, long long n) {\n    long long res = 1;\n    for(int i = 0;i < 60; i++){\n        if(n >> i & 1) res = res * x % MOD;\n        x = x * x % MOD;\n    }\n    return res;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n    return b != 0 ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    return a * b / gcd(a, b);\n}\n\nvoid fastInput() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\nstruct edge {\n    int to, cap, rev;\n};\n\nvector<vector<edge>> G; // 最大流のグラフ(頂点数で初期化)\nvector<int> used; // DFSで頂点を使ったかどうか(上と同じ頂点数で初期化)\n\n// fromからtoへ向かう容量capの辺をGに追加する\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back({to, cap, (int)G[to].size()});\n    G[to].push_back({from, 0, (int)G[from].size()-1});\n}\n\n// 増加パスをDFSで探す\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = 1;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// sからtへの最大流を求める\nint max_flow(int s, int t) {\n    const int INF = 10000000;\n    int flow = 0;\n    for (;;) {\n        fill(used.begin(), used.end(), 0);\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint solve(int N, int M) {\n    vector<int> blue(N+1);\n    vector<int> red(M+1);\n    for (int i = 1; i <= N; i++) {\n        cin >> blue[i];\n    }\n    for (int i = 1; i <= M; i++) {\n        cin >> red[i];\n    }\n    G = vector<vector<edge>>(1+N+M+1);\n    used = vector<int> (1+N+M+1);\n    for (int i = 1; i <= N; i++) {\n        add_edge(0, i, 1);\n    }\n    for (int i = 1; i <= M; i++) {\n        add_edge(N+i, N+M+1, 1); \n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= M; j++) {\n            int GCD = gcd<int>(blue[i], red[j]);\n            if (GCD > 1) {\n                add_edge(i, N+j, 1);\n            }\n        }\n    }\n    int ret = max_flow(0, N+M+1);\n    return ret;\n}\n\nint main(void) {\n    int M, N;\n    vector<int> ans;\n    while (1) {\n        cin >> N >> M;\n        if (N == 0) break;\n        ans.push_back(solve(N, M));\n    }\n    for (auto &i : ans) {\n        cout << i << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\nconst int INF = 1e9;\nconst int MAX_V = 300000;\n\nint m, n;\nstruct Flow{\n    struct edge{\n        int to, cap, rev;\n    };\n    vector<edge> G[MAX_V];//隣接リスト\n    bool used[MAX_V];\n\n    void add_edge(int from, int to, int cap){\n        G[from].push_back((edge){to, cap, (int)G[to].size()});//from -> to\n        G[to].push_back((edge){from, 0, (int)G[from].size() - 1});//to -> from\n    }\n\n    //増加パスを探す\n    int dfs(int v, int t, int f){\n        if(v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); ++i){\n            edge &e = G[v][i];\n            if(!used[e.to] && e.cap > 0){\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    //sからtへの最大流\n    int max_flow(int s, int t){\n        int flow = 0;\n        while(1){\n            memset(used, 0, sizeof(used));\n            int f = dfs(s, t, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nint b[510], r[510];\nint main(void){\n    while(1){\n        cin >> m >> n;\n        if(m == 0 && n == 0) return 0;\n        rep(i, m) cin >> b[i];\n        rep(i, n) cin >> r[i];\n        int s = m + n, t = m + n + 1;\n        Flow mf;\n        //s -> b\n        rep(i, m){\n            mf.add_edge(s, i, 1);\n        }\n        //r -> t\n        rep(i, n){\n            mf.add_edge(m + i, t, 1);\n        }\n        //b -> r\n        rep(i, m)rep(j, n){\n            if(__gcd(b[i], r[j]) > 1){//1以上の約数を持つ\n                mf.add_edge(i, m + j, 1);\n            }\n        }\n        printf(\"%d\\n\", mf.max_flow(s, t));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n//Class.\nvector<int> L[2000];\nint N, M, E;\nint match[2000];\nbool used[2000];\nint x[2000], y[2000];\n \nbool DFS(int V) {\n    used[V] = true;\n    for (int i = 0; i < L[V].size(); i++) {\n        int u = L[V][i]; int w = match[u];\n        if (w < 0 || !used[w] && DFS(w)) {\n            match[V] = u;\n            match[u] = V;\n            return true;\n        }\n    }\n    return false;\n}\n \nint supermatching() {\n    int r = 0;\n    memset(match, -1, sizeof(match));\n    for (int j = 0; j < N + M; j++) {\n        if (match[j] < 0) {\n            memset(used, 0, sizeof(used));\n            if (DFS(j)) { r++; }\n        }\n    }\n    return r;\n}\n \n//main.\nint main() {\n    while (true) {\n        for (int i = 0; i < 2000; i++) { L[i].clear(); }\n        cin >> N >> M; if (!N) { break; }\n        for (int i = 0; i < N; i++) {\n            cin >> x[i];\n        }\n        for (int i = 0; i < M; i++) {\n            cin >> y[i];\n        }\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                if (__gcd(x[i], y[j]) != 1) {\n                    L[i].push_back(j + N);\n                }\n            }\n        }\n        cout << supermatching() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define MP make_pair\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STRING(x) string x;cin>>x;\n# define STR(x) STRING(x);\n# define DOUBLE(x) double x;cin>>x;\n# define DBL(x) DOUBLE(x); \n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl\n# define INIT(a) memset(a,-1,sizeof a)\n# define CLR(a) memset(a,0,sizeof a)\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\n//const int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n//const int M = 1000000007;\ntemplate<class T> void debug(T a) { for ( auto i : a )cout << i << endl; }\n\nstruct edge { int to, cap, rev; edge(int to, int cap, int rev) :to(to), cap(cap), rev(rev) {} };\nvector<edge> G[600];\nbool used[600];\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back(edge(to, cap, G[to].size()));\n\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nint dfs(int v, int t, int f)\n{\n\tif ( v == t )return f;\n\tused[v] = true;\n\tFOR(i, G[v].size())\n\t{\n\t\tedge &e = G[v][i];\n\t\tif ( !used[e.to] && e.cap > 0 )\n\t\t{\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif ( d > 0 )\n\t\t\t{\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t)\n{\n\tint flow = 0;\n\twhile ( true )\n\t{\n\t\tCLR(used);\n\t\tint f = dfs(s, t, INF);\n\t\tif ( f == 0 )return flow;\n\t\tflow += f;\n\t}\n}\nint gcd(int a, int b)\n{\n\tif ( a < b )swap(a, b);\n\tif ( b == 0 )return a;\n\treturn gcd(b, a%b);\n}\nint main()\n{\n\twhile ( true )\n\t{\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tif ( !m&&!n )break;\n\t\tint s = m + n, t = s + 1;\n\t\tvi b, r;\n\t\tvector<edge> Empty[600];\n\t\tswap(Empty, G);\n\t\tFOR(i, m)\n\t\t{\n\t\t\tINT(x);\n\t\t\tb.push_back(x);\n\t\t\tadd_edge(s, i, 1);\n\t\t}\n\n\t\tFOR(i, n)\n\t\t{\n\t\t\tINT(x);\n\t\t\tr.push_back(x);\n\t\t\tadd_edge(m + i, t, 1);\n\t\t}\n\n\t\tFOR(i, m)\n\t\t{\n\t\t\tFOR(j, n)\n\t\t\t{\n\t\t\t\tif ( gcd(b[i], r[j]) != 1 )\n\t\t\t\t{\n\t\t\t\t\tadd_edge(i, j + m, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << max_flow(s, t) << endl;\n\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nstruct Bipartite_Matching\n{\n  vector< vector< int > > graph;\n  vector< int > dist, match;\n  vector< bool > used, vv;\n\n  Bipartite_Matching(int n, int m)\n  {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, false);\n  }\n\n  void add_edge(int u, int v)\n  {\n    graph[u].push_back(v);\n  }\n\n  void bfs()\n  {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a)\n  {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching()\n  {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nint dp[1000][1000];\n\nint gcd(int x, int y)\n{\n  if(x < 1000) {\n    if(~dp[x][y]) return (dp[x][y]);\n    int r = x % y;\n    if(r == 0) return dp[x][y] = y;\n    return dp[x][y] = gcd(y, r);\n  } else {\n    int r = x % y;\n    if(r == 0) return y;\n    return gcd(y, r);\n  }\n}\n\nint main()\n{\n  memset(dp, -1, sizeof(dp));\n\n  int M, N, B[500], R[500];\n  while(scanf(\"%d %d\", &M, &N), M) {\n    Bipartite_Matching flow(M, N);\n    for(int i = 0; i < M; i++) scanf(\"%d\", &B[i]);\n    for(int i = 0; i < N; i++) scanf(\"%d\", &R[i]);\n    for(int i = 0; i < M; i++) {\n      for(int j = 0; j < N; j++) {\n        if(gcd(max(B[i], R[j]), min(B[i], R[j])) > 1) flow.add_edge(i, j);\n      }\n    }\n    printf(\"%d\\n\", flow.bipartite_matching());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n/*#include <iostream>\n#include <vector>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <numeric>\n#include <complex>\n#include <bitset>\n#include <functional>\n#include <stack>\n#include <regex>\n#include <tuple>\n#include <iomanip>\n*/\n#define int long long\n#define REP(i,a,n) for(int i=a;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define REV(i,a,n) for(int i=n;i>=a;--i)\n#define all(e) e.begin(),e.end()\n#define rall(e) e.rbegin(),e.rend()\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define show(n) cerr<<#n<<\" = \"<<n<<endl\n#define showp(n) cerr<<n.fs<<\", \"<<n.sc<<endl\n#define shows(n) for(auto z:n){cerr<<z<<\", \";}cerr<<endl\n#define showsp(n) for(auto z:n){cerr<<z.fs<<\" \"<<z.sc<<\", \"}cerr<<endl\n\n#define yes puts(\"Yes\")\n#define no puts(\"No\")\n#define case(i) printf(\"Case #%lld: \",i)\n\nusing namespace std;\n\nusing vi=vector<int>;\nusing pint=pair<int,int>;\n\ninline void io(){cin.tie(0);ios::sync_with_stdio(false);cout.tie(0);cout<<fixed<<setprecision(20);}\ninline int   in(){int n;scanf(\"%lld\",&n);return n;}\ninline void out(int n){printf(\"%lld\\n\",n);}\n\nconst int INF=1LL<<55;\nconst int MOD=1000000007;\nconst double EPS=1e-8;\n\nconst int MAX_V = 1010;\n\nint m,n;\nint V;\nvi G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\nvi blue(MAX_V/2);\nvi red(MAX_V/2);\n\nvoid add_edge(int u,int v) {\n    G[u].pb(v);\n    G[v].pb(u);\n}\n\nbool dfs(int v){\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        int u=G[v][i],w=match[u];\n        if(w<0 || (!used[w] && dfs(w))) {\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(){\n    int res=0;\n    memset(match,-1,sizeof(match));\n    for(int v=0;v<V;v++){\n        if(match[v]<0){\n            memset(used,0,sizeof(used));\n            if(dfs(v)){\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nvoid init(){\n    V=m+n;\n    rep(i,MAX_V){\n        G[i].clear();\n    }\n}\n\nvoid solve(){\n    init();\n    rep(i,m) cin>>blue[i];\n    rep(i,n) cin>>red[i];\n    rep(i,m){\n        rep(j,n){\n            if(gcd(blue[i],red[j])>1){\n                add_edge(i,m+j);\n            }\n        }\n    }\n    out(bipartite_matching());\n}\n\nsigned main() {\n    io();\n\n    while(cin>>m>>n,n){\n        solve();\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<utility>\n#include<ctype.h>\n\n#define FOR(i,n) for(int i=0;i<n;++i)\nlong long int  memo[100001] = {};\nconst int inf = 1 << 30;\n\nint main() {\n\tint n, m;\n\twhile (true){\n\t\tstd::cin >> n >> m;\n\t\tif (!n) {\n\t\t\tbreak;\n\t\t}\n\t\tint a[500], b[500], ct = 0;\n\t\t\n\t\tFOR(i, n)std::cin >> a[i];\n\t\tFOR(i, m)std::cin >> b[i];\n\t\t\n\t\tif (n >= m) {\n\t\t\tFOR(i, n) {\n\t\t\t\tstd::vector<bool> tf(a[i]+1);\n\t\t\t\tFOR(j, a[i]+1)tf[j] = 0;\n\t\t\t\tbool ok = 0;\n\t\t\t\tif(!ok)\n\t\t\t\t\tfor (int j = 2; j <= a[i]; ++j) {\n\t\t\t\t\t\tif (!tf[j])\n\t\t\t\t\t\t\tif (a[i] % j == 0) {\n\t\t\t\t\t\t\t\tFOR(k, m) {\n\t\t\t\t\t\t\t\t\tif (b[k] % j == 0) {\n\t\t\t\t\t\t\t\t\t\t++ct;\n\t\t\t\t\t\t\t\t\t\tb[k] = 1;\n\t\t\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (int k = 2; k*j < a[i]; ++k) {\n\t\t\t\t\t\t\t\t\ttf[k*j] = true;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\telse {\n\t\t\tFOR(i, m) {\n\t\t\t\tstd::vector<bool> tf(b[i]+1);\n\t\t\t\tFOR(j, b[i]+1)tf[j] = 0;\n\t\t\t\tbool ok = 0;\n\t\t\t\tif (!ok)\n\t\t\t\t\tfor (int j = 2; j <= b[i]; ++j) {\n\t\t\t\t\t\tif (b[i] % j == 0) {\n\t\t\t\t\t\t\tFOR(k, n) {\n\t\t\t\t\t\t\t\tif (a[k] % j == 0) {\n\t\t\t\t\t\t\t\t\t++ct;\n\t\t\t\t\t\t\t\t\ta[k] = 1;\n\t\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int k = 2; k*j < b[i]; ++k) {\n\t\t\t\t\t\t\t\ttf[k*j] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << ct << std::endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n/*bipartite_matching(二部グラフの最大マッチングを求める)*/\n\nconst int MAX_V = 1500;\nint V;//頂点数\nvector<int> G[MAX_V];//グラフの隣接リスト表現\nint match[MAX_V];//マッチングのペア\nbool used[MAX_V];//DFSですでに調べたかのフラグ\n//uとvを結ぶ辺をグラフに追加する\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n//増加パスをDFSで探す\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tint u = G[v][i];\n\t\tint w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n//二部グラフの最大マッチングを求める\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match,-1,sizeof(used));\n\tfor(int v = 0;v < V;v++){\n\t\tif(match[v]<0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>m>>n,n||m){\n\t\tint blue[m];//青のカード\n\t\tint red[n];//赤のカード\n\t\tV = n+m;//頂点数は合計\n\t\trep(i,V){\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tcin>>blue[i];\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin>>red[i];\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tfor(int j =0;j < n;j++){\n\t\t\t\tif(__gcd(blue[i],red[j])==1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tadd_edge(i,j+m);//0~m-1を青,m~m+n-1を赤とする\n\t\t\t}\n\t\t}\n\t\tcout <<bipartite_matching()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n\n// Bipartite_Matching \n// Verify AOJ\n// O(EV)\n\nclass Bipartite_Matching{\n\tpublic :\n\t\tvoid init(int _n){\n\t\t\tn=_n;\n\t\t\tG.resize(n);\n\t\t\tmatch.resize(n);\n\t\t\tused.resize(n);\n\t\t}\n\n\t\tvoid add_edge(int from,int to){\n\t\t\tG[from].push_back(to);\n\t\t\tG[to].push_back(from);\n\t\t}\n\t\n\t\tvoid add_edge_both(int from,int to){\n\t\t\tadd_edge(from,to);\n\t\t\tadd_edge(to,from);\n\t\t}\n\t\n\t\t\n\t\tint bipartite_matching(void){\n\t\t\tint res=0;\n\t\t\tmatch.assign(n,-1);\n\t\t\trep(v,n){\n\t\t\t\tif(match[v] <0){\n\t\t\t\t\tused.assign(n,false);\n\t\t\t\t\tif(dfs(v))\n\t\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\t\n\n\tprivate:\n\t\n\t\tint n;\n\t\tstatic const int DINIC_INF = inf;\n\t\tvvi G;\n\t\tvi match;\n\t\tvector<bool> used;\n\n\t\tbool dfs(int v){\n\t\t\tused[v]=true;\n\t\t\trep(i,G[v].size()){\n\t\t\t\tint u=G[v][i],w=match[u];\n\t\t\t\tif(w<0|| !used[w]&& dfs(w)){\n\t\t\t\t\tmatch[u]=v;\n\t\t\t\t\tmatch[v]=u;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n};\n\n\nint m,n;\nint blue[510];\nint red[510];\n\nint main(void){\n\twhile(cin >> m >> n,m|n){\n\t\tBipartite_Matching b;\n\t\trep(i,m) cin >> blue[i];\n\t\trep(i,n) cin >> red[i];\n\t\tb.init(m+n);\n\t\trep(i,m)rep(j,n){\n\t\t\tif(__gcd(blue[i],red[j])==1)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tb.add_edge(i,m+j);\n\t\t}\n\t\tcout << b.bipartite_matching() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nstruct E {\n  int to, cost, cap, rev;\n  E(int to, int cost, int cap, int rev)\n    : to(to), cost(cost), cap(cap), rev(rev) {}\n  E() {}\n};\n\ntypedef vector<vector<E> > G;\n\nvoid addEdgeF(int from, int to, int cost, int cap, G &g) {\n  g[from].push_back(E(to,cost,cap,g[to].size()));\n  g[to].push_back(E(from,cost,0,(int)g[from].size()-1));\n}\n\nint dfsF(int v, int t, int f, bool *used, G &g) {\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < g[v].size(); ++i) {\n    E &e = g[v][i];\n    if(!used[e.to] && e.cap > 0) {\n      int d = dfsF(e.to, t, min(f, e.cap), used, g);\n      if(d > 0) {\n        e.cap -= d;\n        g[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int s, int t, G g) {\n  int flow = 0;\n  bool used[g.size()];\n  while(1) {\n    memset(used, 0, sizeof(used));\n    int f = dfsF(s, t, INF, used, g);\n    if(f == 0) break;\n    flow += f;\n  }\n  return flow;\n}\n\nint gcd(int a, int b) {\n  return b == 0 ? a : gcd(b, a%b);\n}\n\nint main() {\n  int m, n, tmp;\n  vector<int> b, r;\n  G g;\n  while(cin >> m >> n && (m|n)) {\n    b.resize(m);\n    r.resize(n);\n    for(int i = 0; i < m; ++i) {\n      cin >> b[i];\n    }\n    for(int i = 0; i < n; ++i) {\n      cin >> r[i];\n    }\n\n    g = G(m+n+2);\n    for(int i = 0; i < m; ++i) {\n      addEdgeF(m+n, i, 0, 1, g);\n    }\n    for(int i = 0; i < m; ++i) {\n      for(int j = 0; j < n; ++j) {\n        if(gcd(b[i], r[j]) != 1) {\n          addEdgeF(i, m+j, 0, 1, g);\n        }\n      }\n    }\n    for(int i = 0; i < n; ++i) {\n      addEdgeF(m+i, m+n+1, 0, 1, g);\n    }\n    cout << maxFlow(m+n, m+n+1, g) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bipartite_Matching\n{\n  vector< vector< int > > graph;\n  vector< int > dist, match;\n  vector< bool > used, vv;\n\n  Bipartite_Matching(int n, int m)\n  {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, false);\n  }\n\n  void add_edge(int u, int v)\n  {\n    graph[u].push_back(v);\n  }\n\n  void bfs()\n  {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a)\n  {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching()\n  {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nint main()\n{\n  int M, N, B[500], R[500];\n  while(scanf(\"%d %d\", &M, &N), M) {\n    Bipartite_Matching flow(M, N);\n    for(int i = 0; i < M; i++) scanf(\"%d\", &B[i]);\n    for(int i = 0; i < N; i++) scanf(\"%d\", &R[i]);\n    for(int i = 0; i < M; i++) {\n      for(int j = 0; j < N; j++) {\n        if(__gcd(B[i], R[j]) > 1) flow.add_edge(i, j);\n      }\n    }\n    printf(\"%d\\n\", flow.bipartite_matching());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\nnamespace boost {template <class T>struct integer_iterator {T a;bool operator != (integer_iterator const & it) const { return a != it.a; }T operator * () const { return a; }integer_iterator & operator ++ () { ++ a; return *this; }integer_iterator operator ++ (int) { return { a ++ }; }};template <class T>struct integer_range {T l, r;typedef integer_iterator<T> iterator;iterator begin() const { return { l }; }iterator end  () const { return { r }; }};template <class T>integer_range<T> irange(T l, T r) { return { l, r }; }template <class T>struct integer_iterator_with_step {T a, d, i;bool operator != (integer_iterator_with_step const & it) const { return a != it.a or d != it.d or i != it.i; }T operator * () const { return a+d*i; }integer_iterator_with_step & operator ++ () { ++ i; return *this; }integer_iterator_with_step operator ++ (int) { return { a, d, i ++ }; }};template <class T>struct strided_integer_range {T l, r, s;typedef integer_iterator_with_step<T> iterator;iterator begin() const { return { l, s, 0 }; }iterator end  () const { return { l, s, (r - l) / s + 1 }; }};template <class T>strided_integer_range<T> irange(T l, T r, T s) { return { l, r, s }; }}\ntemplate <typename T>class ford_fulkerson {public:struct edge_t { int to; T cap; int rev; };static T infinity;ford_fulkerson(int n) : graph(n) {}std::vector<std::vector<edge_t> > graph; \nnamespace boost {namespace math {template <typename T>T gcd(T a, T b) {if (b <= a) std::swap(a,b);while (a) {T a0 = a;a = b % a0;b = a0;}return b;}template <typename T>T lcm(T a, T b) {return (a * b) / gcd(a,b);}}}\n#define repeat(i,n) for (int i = 0; (i) < (int)(n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (int)(n); ++(i))\nusing namespace std;\nint main() {\n    while (true) {\n        int m, n; cin >> m >> n;\n        if (m == 0 and n == 0) break;\n        vector<int> b(m), r(n);\n        repeat (i,m) cin >> b[i];\n        repeat (i,n) cin >> r[i];\n        ford_fulkerson<int> g(m+n+2);\n        repeat (i,m) g.add_edge(m+n,i,1);\n        repeat (i,n) g.add_edge(m+i,m+n+1,1);\n        repeat (i,m) repeat (j,n) {\n            if (boost::math::gcd(b[i], r[j]) != 1) {\n                g.add_edge(i,m+j,1);\n            }\n        }\n        cout << g.run_destructive(m+n,m+n+1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nstruct edge { int to, cap, rev; };//ikisaki youryou gyakuhen\n#define MAX 1010\nvector<vector<edge> >G(MAX);//[MAX];\nvector<bool>used(MAX);//[MAX];\nvoid add_edge(int from, int to, int cap){\n\tedge q={to,cap,int(G[to].size())};\n    G[from].push_back(q);\n\tq={from,0,int(G[from].size()-1)};\n    G[to].push_back(q);\n}\n\nint dfs(int v, int t, int f) {\n    if(v == t) return f;\n    used[v] = 1;\n    for(int i = 0 ; i < G[v].size(); i++){\n        edge &e = G[v][i];\n        if(used[e.to] || e.cap <= 0) continue;\n        int d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0){\n            e.cap -= d;\n            G[e.to][e.rev].cap += d;\n            return d;\n        }\n    }\n    return 0;\n}\nint ford_fulkerson(int s, int t) {//from s to t\n    int flow = 0, f;\n    while(1){\n\t\tused=vector<bool>(MAX,false);\n        f = dfs(s, t, inf);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\nint gcd(int a,int b){\n\tif(a<b)swap(a,b);\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\tvi a(n);\n\t\tvi b(m);\n\t\trep(i,MAX)G[i].clear();\n\t\tused=vector<bool>(MAX,false);\n\t\trep(i,n)cin>>a[i];\n\t\trep(i,m)cin>>b[i];\n\t\tint s=n+m;int t=s+1;\n\t\trep(i,n)rep(j,m)if(gcd(a[i],b[j])!=1)add_edge(i,n+j,1);\n\t\trep(i,n)add_edge(s,i,1);\n\t\trep(i,m)add_edge(n+i,t,1);\n\t\tcout<<ford_fulkerson(s,t)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint gcd(int a,int b)\n{\n\treturn b?gcd(b,a%b):a;\n}\n\nstruct Edge{\n\tint src,dst;\n\tEdge(){}\n\tEdge(int s,int d):src(s),dst(d){}\n};\ntypedef vector<vector<Edge> > Graph;\n\nbool Augment(const Graph& g,int u,vi& vis,vi& match)\n{\n\trep(i,g[u].size()){\n\t\tint v=g[u][i].dst;\n\t\tif(vis[v]) continue;\n\t\tvis[v]=1;\n\t\tif(match[v]==-1 || Augment(g,match[v],vis,match)){\n\t\t\tmatch[u]=v;\n\t\t\tmatch[v]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint BipartiteMatching(const Graph& g,vi& match)\n{\n\tint n=g.size();\n\tmatch.assign(n,-1);\n\tint res=0;\n\trep(i,n) if(match[i]==-1){\n\t\tvi vis(n);\n\t\tres+=Augment(g,i,vis,match);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int m,n;scanf(\"%d%d\",&m,&n),m|n;){\n\t\tvi bs(m),rs(n);\n\t\trep(i,m) scanf(\"%d\",&bs[i]);\n\t\trep(i,n) scanf(\"%d\",&rs[i]);\n\t\t\n\t\tGraph g(m+n);\n\t\trep(i,m) rep(j,n) if(gcd(bs[i],rs[j])>1){\n\t\t\tg[i].push_back(Edge(i,m+j));\n\t\t\tg[m+j].push_back(Edge(m+j,i));\n\t\t}\n\t\t\n\t\tvi match;\n\t\t//printf(\"%d\\n\",BipartiteMatching(g,match));\n\t\tprintf(\"%d\\n\",-1);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include \"../lib/define.h\"\n#include \"../lib/graph.h\"\n#define MAXMN 500\n#define Int long long\nint B[MAXMN];\nint R[MAXMN];\n\nInt gcd(Int a, Int b)\n{   \n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\n\n\nmain() {\n  int M,N;\n  Graph g;\n  while(cin>>M>>N,M) {\n    g.clear();\n    g.resize(M+N+2);\n    REP(i,M) cin>>B[i];\n    REP(i,N) cin>>R[i];\n    REP(i,M) {\n      Edges es, es2;\n      REP(j,N) {\n\tif(gcd(B[i],R[j])!=1) { es.pb(Edge(i,M+j)); es2.pb(Edge(M+j,i)); }\n      }\n      g[i] = es;\n      g[M+i] = es2;\n    }\n    Edges matching;\n    cout << bipartiteMatching(g,M,matching) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int64_t i = 0; i < (n); i++)\n#define irep(i, n) for (int64_t i = 0; i <= (n); i++)\n#define rrep(i, n) for (int64_t i = (n)-1; i >= 0; i--)\n#define rirep(i, n) for (int64_t i = n; i >= 0; i--)\n\nclass FlowNetwork {\n  struct Edge {\n    int from;\n    int to;\n    int64_t capacity;\n    int64_t flow;\n  };\n\n  vector<vector<int>> outEdge, inEdge;\n  vector<Edge> edgeData;\n\n public:\n  FlowNetwork(int size) : outEdge(size), inEdge(size) {}\n\n  void addEdge(const int from, const int to, const int64_t capacity) {\n    const int eId = edgeData.size();\n    Edge eData;\n    eData.from = from;\n    eData.to = to;\n    eData.flow = 0;\n    eData.capacity = capacity;\n    edgeData.push_back(eData);\n    outEdge[from].push_back(eId);\n    inEdge[to].push_back(eId);\n  }\n\n  int64_t maxflow(const int source, const int sink) {\n    const int n = outEdge.size();\n\n    while (true) {\n      // check if reachable to sink\n      vector<int> parent(n, -1);\n      queue<int> q;\n      q.push(source);\n\n      while (!q.empty()) {\n        const int v = q.front();\n        q.pop();\n\n        for (const int e : outEdge[v]) {\n          const Edge &data = edgeData[e];\n          const int nv = data.to;\n          if (parent[nv] < 0 && data.capacity - data.flow > 0) {\n            q.push(nv);\n            parent[nv] = e;\n          }\n        }\n\n        for (const int e : inEdge[v]) {\n          const Edge &data = edgeData[e];\n          const int nv = data.from;\n          if (parent[nv] < 0 && data.flow > 0) {\n            q.push(nv);\n            parent[nv] = e;\n          }\n        }\n      }\n\n      if (parent[sink] < 0) {\n        break;\n      }\n\n      // select path from source to sink\n      int64_t d = numeric_limits<int64_t>::max();\n      int v = sink;\n      while (v != source) {\n        const int e = parent[v];\n        const Edge &data = edgeData[e];\n        if (data.to == v) {\n          d = min(d, data.capacity - data.flow);\n          v = data.from;\n        } else {\n          d = min(d, data.flow);\n          v = data.to;\n        }\n      }\n\n      // update flow on the path\n      v = sink;\n      while (v != source) {\n        const int e = parent[v];\n        Edge &data = edgeData[e];\n        if (data.to == v) {\n          data.flow += d;\n          v = data.from;\n        } else {\n          data.flow -= d;\n          v = data.to;\n        }\n      }\n    }\n\n    int64_t result = 0;\n    for (const int e : inEdge[sink]) {\n      result += edgeData[e].flow;\n    }\n    return result;\n  }\n};\n\nint64_t gcd(const int64_t a, const int64_t b) {\n  if (b == 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\n\nvoid solve(const int m, const int n) {\n  vector<int> blue(m), red(n);\n\n  rep(i, m) { cin >> blue[i]; }\n  rep(i, n) { cin >> red[i]; }\n\n  const int nodeNum = m + n + 2;\n  const int source = nodeNum - 2;\n  const int sink = nodeNum - 1;\n\n  FlowNetwork net(nodeNum);\n  rep(i, m) { net.addEdge(source, i, 1); }\n  rep(i, n) { net.addEdge(m + i, sink, 1); }\n\n  rep(i, m) rep(j, n) {\n    if (gcd(blue[i], red[j]) != 1) {\n      net.addEdge(i, m + j, 1);\n    }\n  }\n\n  cout << net.maxflow(source, sink) << endl;\n}\n\nint main() {\n  int m, n;\n  cin >> m >> n;\n  while (m != 0 || n != 0) {\n    solve(m, n);\n    cin >> m >> n;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Hopcroft-Karp Algorithm\n// O(|E| * |V|^(1/2))\n// http://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm\n// aoj 1163\n\n#include <vector>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\nint NIL;\nconst int inf = 1<<29;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int> > Graph;\n\nbool bfs(const Graph &g,vi &dist,const vi &pair,int m) {\n    queue<int> q;\n\n    for(int i=0; i<m; ++i)\n        if(pair[i] == NIL) {\n            dist[i] = 0;\n            q.push(i);\n        }else\n            dist[i] = inf;\n    dist[NIL] = inf;\n\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        if(v == NIL) continue;\n        for(int i=0; i<g[v].size(); ++i) {\n            int u = g[v][i];\n            if(dist[pair[u]] == inf) {\n                dist[pair[u]] = dist[v]+1;\n                q.push(pair[u]);\n            }\n        }\n    }\n    return dist[NIL] != inf;\n}\n\nbool dfs(int v,const Graph &g,vi &dist,vi &pair) {\n    if(v != NIL) {\n        for(int i=0; i<g[v].size(); ++i) {\n            int u = g[v][i];\n            if(dist[pair[u]] == dist[v]+1) {\n                if(dfs(pair[u],g,dist,pair)) {\n                    pair[u] = v, pair[v] = u;\n                    return true;\n                }\n            }\n        }\n        dist[v] = inf;\n        return false;\n    }\n    return true;\n}\n\n// 0ツつゥツづァm-1ツづ慊づづ個静淞点ツづツつゥツづァn-1ツづ慊づづ個静淞点ツづづ個催妥・ツマツッツチツδ督グツづーツ仰づ淞づゥ\nint hopcroft_karp(Graph &graph,int m) {\n    const int n = graph.size();\n    NIL = n;\n    vi pair(n+1, NIL), dist(n+1, 0);\n    int ret = 0;\n    while(bfs(graph,dist,pair,m)) {\n        for(int i=0; i<m; ++i)\n            if(pair[i] == NIL)\n                if(v == NIL || dfs(i,graph,dist,pair)) ret++;\n    }\n    return ret;\n}\n\nint gcd(int x,int y) {\n    if(y == 0) return x;\n    return gcd(y,x%y);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    int m,n;\n    while(cin>>m>>n, m|n) {\n        Graph g(m+n);\n        vector<int> b(m), r(n);\n        for(int i=0; i<m; ++i) cin>>b[i];\n        for(int i=0; i<n; ++i) cin>>r[i];\n\n        for(int i=0; i<m; ++i)\n            for(int j=0; j<n; ++j)\n                if(gcd(b[i],r[j]) > 1)\n                    g[i].push_back(j+m);\n        cout<<hopcroft_karp(g,m)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\ntemplate<typename T>\nstruct FordFulkerson {\n    struct edge {\n        int to, rev;\n        T cap;\n        edge(int to, T cap, int rev) :\n            to(to), cap(cap), rev(rev) {}\n    };\n\n    vector<vector<edge>> g;\n    vector<int> used;\n    const T INF;\n    int timestamp;\n\n    FordFulkerson(int n) :\n        INF(numeric_limits<T>::max()),\n        timestamp(0), g(n), used(n, -1) {}\n\n    void add_edge(int s, int t, T cap) {\n        g[s].emplace_back(t, cap, (int)g[t].size());\n        g[t].emplace_back(s,   0, (int)g[s].size() - 1);\n    }\n\n    T dfs(int v, const int t, T flow) {\n        if (v == t) return flow;\n        used[v] = timestamp;\n        for (edge &e : g[v]) {\n            if (e.cap > 0 and used[e.to] != timestamp) {\n                T d = dfs(e.to, t, min(flow, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T max_flow(int s, int t) {\n        T flow = 0;\n        for(T f; (f = dfs(s, t, INF)) > 0; timestamp++) {\n            flow += f;\n        }\n        return flow;\n    }\n};\n\ntemplate<typename T>\nstruct Dinic {\n    // O(EV^2)\n    struct edge {\n        int to, rev;\n        T cap;\n        edge(int to, T cap, int rev) :\n            to(to), cap(cap), rev(rev) {}\n    };\n\n    vector<vector<edge>> g;\n    vector<int> level, iter;\n    const T INF;\n\n    Dinic(int V) : INF(numeric_limits<T>::max()), g(V) {}\n\n    void add_edge(int s, int t, T cap) {\n        g[s].emplace_back(t, cap, (int)g[t].size());\n        g[t].emplace_back(s,   0, (int)g[s].size() - 1);\n    }\n\n    bool bfs(int s, int t) {\n        level.assign(g.size(), -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (auto &e : g[v]) {\n                if (e.cap > 0 && level[e.to] == -1) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n        return level[t] != -1;\n    }\n\n    T dfs(int v, const int t, T flow) {\n        if (v == t) return flow;\n        for (int &i = iter[v]; i < g[v].size(); i++) {\n            edge &e = g[v][i];\n            if (e.cap > 0 && level[v] < level[e.to]) {\n                T d = dfs(e.to, t, min(flow, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T max_flow(int s, int t) {\n        T flow = 0;\n        while (bfs(s, t)) {\n            iter.assign(g.size(), 0);\n            T f = 0;\n            while((f = dfs(s, t, INF)) > 0) flow += f;\n        }\n        return flow;\n    }\n};\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (true) {\n        int m, n;\n        cin >> m >> n;\n        if (m == 0) break;\n        vector<int> b(m), r(n); cin >> b >> r;\n\n        Dinic<int> g(m+n+2);\n        for (int i = 0; i < m; ++i) {\n            g.add_edge(m+n, i, 1);\n        }\n        for (int i = 0; i < n; ++i) {\n            g.add_edge(i+m, m+n+1, 1);\n        }\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (__gcd(b[i], r[j]) != 1) {\n                    g.add_edge(i, j+m, 1);\n                }\n            }\n        }\n\n        cout << g.max_flow(m+n, m+n+1) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\n//int gcd( int m, int n ){\n//\twhile( m != n ){\n//\t\tif ( m > n ) m = m - n;\n//\t\telse         n = n - m;\n//\t}\n//\treturn m;\n//}\n\nint gcd(int x, int y)\n{\n    int t;\n    if(x < y) swap(x, y);\n    while(y)\n        t = x % y, x = y, y = t;\n    return x;\n}\n\nint maximum_matching(int m, int n, int graph[1002][1002], int now ,int flag){\n    if(now==m+n)return 1;\n    if(now==m+n+1){\n        int sum=0;\n        for(int i=0; i<m; i++){\n            if(graph[now][i]==0)sum++;\n            else if(maximum_matching(m, n, graph, i, flag)==1)sum++;\n        }\n        return sum;\n    }\n    if(now<m){\n        for(int i=m; i<m+n; i++){\n            if(graph[now][i]==1){\n                if(maximum_matching(m, n, graph, i, flag)==1){\n                    graph[now][i]=0;\n                    graph[i][now]=1;\n                    return 1;\n                }\n            }\n        }\n        return 0;\n    }\n    if(m<=now&&now<m+n){\n        if(flag==0){\n            if(graph[now][m+n]==1){\n                graph[now][m+n]=0;\n                return 1;\n            }else{\n                for(int i=0; i<m; i++){\n                    if(graph[now][i]==1){\n                        if(maximum_matching(m, n, graph, i, 1)==1){\n                            graph[now][i]=0;\n                            //graph[i][now]=1;\n                            return 1;\n                        }\n                    }\n                }\n            }\n            return 0;\n        }else{\n            if(graph[now][m+n]==1){\n                graph[now][m+n]=0;\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n    }\n}\n\n\n\nint main(){\n    int m,n;\n    while(cin>>m>>n){\n        if(m==0&&n==0)break;\n        int b[500]={0};\n        int r[500]={0};\n        for(int i=0; i<m; i++){\n            cin>>b[i];\n\n        }\n        for(int i=0; i<n; i++){\n            int temp;\n            cin>>r[i];\n        }\n//        cout<<\"bb\"<<endl;\n//        for(int i=0; i<n; i++){\n//            cout<<i<<endl;\n//            scanf(\"%d\",&r[i]);\n//            cout<<r[i]<<endl;\n//        }\n        int graph[1002][1002]={0};\n        for(int i=0; i<m; i++){\n            for(int j=0; j<n; j++){\n                if(gcd(b[i],r[j])!=1)graph[i][m+j]=1;\n            }\n        }\n        for(int i=0; i<m; i++)graph[m+n+1][i]=1;//s-b\n        for(int i=0; i<n; i++)graph[m+i][m+n]=1;//r-t\n        \n        \n        \n        for(int i=0; i<m; i++){\n            for(int j=0; j<n; j++){\n                if(graph[m+n+1][i]==1&&graph[i][j]==1&&graph[j][m+n]==1){\n                    graph[m+n+1][i]=0;\n                    graph[i][j]=0;\n                    graph[j][i]=1;\n                    graph[j][m+n]=0;\n                }\n            }\n        }\n        \n        \n        \n        int sum=maximum_matching(m, n, graph, m+n+1, 0);\n        //int sum=m;\n        //for(int i=0; i<m; i++)sum-=graph[m+n+1][i];\n        cout<<sum<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define rep(i,j,n) for(int i=j;i<n;++i)\n#define all(i) i.begin(),i.end()\n#define rall(i) i.rbegin(), i.rend()\n#define INF 1e9\n#define LINF 1e18\nconst int mod = 1e9 + 7;\n \ntypedef long long i64;\ntypedef pair<int, int> pi;\n \ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\n \ni64 gcd(i64 n, i64 m) {return (m == 0? n : gcd(m, n % m));}\ni64 lcm(i64 n, i64 m) {return (n / gcd(n, m) * m);}\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nclass BipartiteMatching {\n  private:\n    std::vector<std::vector<int>> graph;\n    std::vector<int> match;\n    std::vector<bool> used;\n\n    bool dfs(int v) {\n      used[v] = true;\n\n      for(auto &e : graph[v]) {\n        int m = match[e];\n\n        if(m < 0 || (!used[m] && dfs(m))) {\n          match[v] = e;\n          match[e] = v;\n          return true;\n        }\n      }\n      return false;\n    }\n\n  public:\n    BipartiteMatching(int v) {\n      graph = std::vector<std::vector<int>>(v);\n      match = std::vector<int>(v, -1);\n      used = std::vector<bool>(v);\n    }\n\n    void add_edge(int u, int v) {\n      graph[u].push_back(v);\n      graph[v].push_back(u);\n    }\n\n    int bipartite_matching() {\n      int res = 0;\n\n      for(int v = 0; v < graph.size(); ++v) {\n        if(match[v] < 0) {\n          used.assign(used.size(), false);\n          if(dfs(v)) res++;\n        }\n      }\n      return res;\n    }\n};\n \nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int m, n;\n  while(cin >> m >> n, m != 0 && n != 0) {\n    BipartiteMatching bm(m + n);\n    vt<int> b(m), r(n);\n    rep(i, 0, m) cin >> b[i];\n    rep(i, 0, n) cin >> r[i];\n\n    rep(i, 0, m) {\n      rep(j, 0, n) {\n        if(gcd(b[i], r[j]) > 1) bm.add_edge(i, m + j);\n      }\n    }\n    cout << bm.bipartite_matching() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <map>\n#include <set>\n#include <cmath>\n#include <string>\n#define SIZE 1002\n#define INF 10000005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll K;\n\nstruct edge{int to,cap,rev;};\n\nvector<edge> G[SIZE];\nbool used[SIZE];\n\n//グラフ追加: from -> to (cap)\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back((edge){to,cap,(int)G[to].size()});\n\tG[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n\n//パスを一本見つける\nint dfs(int v, int t, int f){\n\tif(v==t)return f;\n\tused[v] = true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap>0){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){ //v -> G[v][i].toにd流す\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f = dfs(s,t,INF);\n\t\tif(f==0)return flow;\n\t\tflow += f;\n\t}\n}\n\nint gcd(int a,int b){ //a>=b\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\n\nbool imain()\n{\n\tint m,n;\n\tint B[500];\n\tint R[500];\n\tscanf(\"%d %d\",&m,&n);\n\tif(m==0&&n==0)return false;\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d\",&B[i]);\n\t\tadd_edge(1000,i,1);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&R[i]);\n\t\tadd_edge(i+500,1001,1);\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(gcd(B[i],R[j])!=1){\n\t\t\t\tadd_edge(i,500+j,1);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = max_flow(1000,1001);\n\tprintf(\"%d\\n\",ans);\n\tfor(int i=0;i<m;i++)G[i].clear();\n\tfor(int i=0;i<n;i++)G[i+500].clear();\n\tG[1000].clear();\n\tG[1001].clear();\n\treturn true;\n}\n\nint main(){\n\twhile(imain());\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include<vector>\n\n#define MAXN1 50000\n#define MAXN2 50000\n#define MAXM 150000\n\nusing namespace std;\n\nint n1, n2, edges, last[MAXN1];\nint preve[MAXM];\nint head[MAXM];\nint matching[MAXN2], dist[MAXN1], Q[MAXN1];\nbool used[MAXN1], vis[MAXN1];\n\nvoid init(int _n1, int _n2) {\n  n1=_n1;\n  n2=_n2;\n  edges=0;\n  fill(last, last + n1, -1);\n}\n\nvoid add_edge(int u, int v) {\n  head[edges]=v;\n  preve[edges] = last[u];\n  last[u] = edges++;\n}\n\nvoid bfs() {\n  fill(dist,dist+n1,-1);\n  int sizeQ=0;\n  for (int u=0;u<n1;u++) {\n    if (!used[u]) {\n      Q[sizeQ++]=u;\n      dist[u]=0;\n    }\n  }\n  for (int i=0;i<sizeQ;i++) {\n    int u1 = Q[i];\n    for (int e=last[u1];e>=0;e=preve[e]) {\n      int u2 = matching[head[e]];\n      if (u2>=0 && dist[u2]<0) {\n\tdist[u2]=dist[u1]+1;\n\tQ[sizeQ++]=u2;\n      }\n    }\n  }\n}\n\nbool dfs(int u1) {\n  vis[u1]=true;\n  for (int e=last[u1];e>=0;e=preve[e]) {\n    int v=head[e];\n    int u2=matching[v];\n    if (u2<0 || (!vis[u2] && dist[u2]==dist[u1]+1 && dfs(u2))) {\n      matching[v]=u1;\n      return used[u1]=true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching() {\n  fill(used,used+n1,false);\n  fill(matching,matching+n2,-1);\n  for (int res=0;;) {\n    bfs();\n    fill(vis,vis+n1,false);\n    int f=0;\n    for(int u=0;u<n1;u++)\n      if(!used[u] && dfs(u))f++;\n    if (!f)return res;\n    res+=f;\n  }\n}\n\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\n\nint main(void){\n  \n  int m,n;\n  \n  while(cin >> m >> n,m|n){\n \n    init(m,n);\n    \n    vector<int>b(m),r(n);\n    for(int i=0;i<m;i++)cin >> b[i];\n    for(int i=0;i<n;i++)cin >> r[i];\n    \n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n\tif(gcd(b[i],r[j])!=1)add_edge(i,j);\n      }\n    }\n\n    cout << bipartite_matching() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// problem: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1163\n\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <unordered_map>\n#include <vector>\n#include <string.h>\n#include <set>\n\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> void printvec(const vector<T>& v) {\n  for (auto x : v) { cout << x << \" \"; }\n  cout << endl;\n}\ntemplate<class T> void printtree(const vector< vector<T> >& tree) {\n  for (long long i = 0; i < tree.size(); ++i) {\n    cout << i + 1 << \": \"; printvec(tree[i]);\n  }\n}\ntemplate<class T, class U> void printmap(const map<T, U>& mp) {\n  for (auto x : mp) { cout << x.first << \"=>\" << x.second << endl; }\n}\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define all(s) s.begin(), s.end()\n#define sz(x) (ll)(x).size()\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> triple;\ntypedef double D;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n\nconst ll MOD = 1000000007;  // 1e9 + 7\n\n// Dinic's algorithm.\n\ntypedef ll FLOW;       // Type of flow. int here.\nconst ll MAX_V = 1005;  // Maximum number of nodes in a graph.\nconst FLOW INF = 1e15;\n\nstruct Edge {\n  ll rev, from, to;\n  FLOW cap, icap; // icap: initial cap\n\n  Edge(ll r, ll f, ll t, FLOW c) : rev(r), from(f), to(t), cap(c), icap(c) {}\n\n  friend ostream& operator << (ostream& s, const Edge& E) {\n    if (E.cap > 0) {\n      return s << E.from << \"->\" << E.to << '(' << E.cap << ')';\n    } else {\n      return s;\n    }\n  }\n};\n\nclass Graph {\npublic:\n  Graph(ll n = 0) : V(n) {\n    rep(i, MAX_V) { list[i].clear(); }\n  }\n\n  void init(ll n = 0) {\n    V = n;\n    rep(i, MAX_V) { list[i].clear(); }\n  }\n\n  void resize(ll n = 0) { V = n; }\n\n  void reset() {\n    rep(i, V) {\n      rep(j, list[i].size()) {\n        list[i][j].cap = list[i][j].icap;\n      }\n    }\n  }\n\n  inline vector<Edge>& operator [] (ll i) {\n    return list[i];\n  }\n\n  Edge &redge(Edge e) {\n    if (e.from != e.to) {\n      return list[e.to][e.rev];\n    } else {\n      return list[e.to][e.rev + 1];\n    }\n  }\n\n  void addedge(ll from, ll to, FLOW cap) {\n    list[from].push_back(Edge((ll)list[to].size(), from, to, cap));\n    list[to].push_back(Edge((ll)list[from].size() - 1, to, from, 0));\n  }\n\nprivate:\n  ll V;\n  vector<Edge> list[MAX_V];\n};\n\nstatic ll level[MAX_V];\nstatic ll iter[MAX_V];\n\nvoid dibfs(Graph &G, ll s) {\n  rep(i, MAX_V) { level[i] = -1; }\n  level[s] = 0;\n  queue<ll> que;\n  que.push(s);\n  while (!que.empty()) {\n    ll v = que.front();\n    que.pop();\n    rep(i, G[v].size()) {\n      Edge &e = G[v][i];\n      if (level[e.to] < 0 && e.cap > 0) {\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nFLOW didfs(Graph &G, ll v, ll t, FLOW f) {\n  if (v == t) { return f; }\n\n  for (ll &i = iter[v]; i < G[v].size(); ++i) {\n    Edge &e = G[v][i], &re = G.redge(e);\n    if (level[v] < level[e.to] && e.cap > 0) {\n      FLOW d = didfs(G, e.to, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        re.cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\n// Main function for calculatig maximum flow\nFLOW Dinic(Graph &G, int s, int t) {\n  FLOW res = 0;\n  while (true) {\n    dibfs(G, s);\n    if (level[t] < 0) { return res; }\n    memset(iter, 0, sizeof(iter));\n    FLOW flow;\n    while ((flow = didfs(G, s, t, INF)) > 0) {\n      res += flow;\n    }\n  }\n}\n\n// int main(int argc, char** argv) {\n//   int V, E;\n//   cin >> V >> E;\n//   Graph g(V);\n//   rep(i, E) {\n//     ll u, v, c;\n//     cin >> u >> v >> c;\n//     g.addedge(u, v, c);\n//   }\n//\n//   ll r = Dinic(g, 0, V - 1);\n//   cout << r << endl;\n// }\n\nint gcd(int a, int b) {\n  if (a < b) { swap(a, b); }\n  if (b == 0) { return a; }\n  return gcd(b, a % b);\n}\n\nint main(int argc, char** argv) {\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ios_base::sync_with_stdio(false);\n  //cout << setprecision(10) << fixed;\n\n  while (true) {\n    ll m,n;\n    cin >> m >> n;\n    if (m==0 && n==0) { break; }\n    vector<ll> b(m);\n    vector<ll> r(n);\n    rep(i,m) { cin >> b[i]; }\n    rep(i,n) { cin >> r[i]; }\n    ll s=m+n,t=s+1;\n    Graph g(m+n+2);\n    rep(i,m) { g.addedge(s,i,1); }\n    rep(i,n) { g.addedge(m+i,t,1); }\n    rep(i,m)rep(j,n) {\n      if (gcd(b[i],r[j]) > 1) {\n        g.addedge(i,m+j,1);\n      }\n    }\n    ll ans = Dinic(g,s,t);\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define FOR(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(v) v.begin(),v.end()\n\ntemplate<typename flow_t>\nstruct edge {\n\tint to;\n\tflow_t cap;\n\tint rev;\n\tbool isrev;\n\tint idx;\n\tedge(int to, flow_t cap, int rev, bool isrev, int idx) :to(to), cap(cap), rev(rev), isrev(isrev), idx(idx) {}\n};\n\ntemplate< typename flow_t >\nstruct Dinic {\n\tconst flow_t INF;\n\n\tvector< vector< edge<flow_t> > > graph;\n\tvector< int > min_cost, iter;\n\n\tDinic(int V) : INF(numeric_limits< flow_t >::max()), graph(V) {}\n\n\tvoid add_edge(int from, int to, flow_t cap, int idx = -1) {\n\t\tgraph[from].push_back((edge<flow_t>) { to, cap, (int)graph[to].size(), false, idx });\n\t\tgraph[to].push_back((edge<flow_t>) { from, 0, (int)graph[from].size() - 1, true, idx });\n\t}\n\n\tbool bfs(int s, int t) {\n\t\tmin_cost.assign(graph.size(), -1);\n\t\tqueue< int > que;\n\t\tmin_cost[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty() && min_cost[t] == -1) {\n\t\t\tint p = que.front();\n\t\t\tque.pop();\n\t\t\tfor (auto &e : graph[p]) {\n\t\t\t\tif (e.cap > 0 && min_cost[e.to] == -1) {\n\t\t\t\t\tmin_cost[e.to] = min_cost[p] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min_cost[t] != -1;\n\t}\n\n\tflow_t dfs(int idx, const int t, flow_t flow) {\n\t\tif (idx == t) return flow;\n\t\tfor (int &i = iter[idx]; i < graph[idx].size(); i++) {\n\t\t\tedge<flow_t> &e = graph[idx][i];\n\t\t\tif (e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n\t\t\t\tflow_t d = dfs(e.to, t, min(flow, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tgraph[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tflow_t max_flow(int s, int t) {\n\t\tflow_t flow = 0;\n\t\twhile (bfs(s, t)) {\n\t\t\titer.assign(graph.size(), 0);\n\t\t\tflow_t f = 0;\n\t\t\twhile ((f = dfs(s, t, INF)) > 0) flow += f;\n\t\t}\n\t\treturn flow;\n\t}\n\n\tvoid output() {\n\t\tfor (int i = 0; i < graph.size(); i++) {\n\t\t\tfor (auto &e : graph[i]) {\n\t\t\t\tif (e.isrev) continue;\n\t\t\t\tauto &rev_e = graph[e.to][e.rev];\n\t\t\t\tcout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << e.cap + rev_e.cap << \")\" << endl;\n\t\t\t}\n\t\t}\n\t}\n};\nlong long gcd(long long x, long long y) {\n\tlong long m = max(x, y), n = min(x, y);\n\tif (m%n == 0)return n;\n\telse return gcd(m%n, n);\n}\n\nvoid solve() {\n\tint N, M; cin >> N >> M;\n\tif (N == 0)exit(0);\n\tvector<int>B(N), R(M);\n\tint s = N + M, t = N + M + 1;\n\tDinic<int>g(N + M + 2);\n\tREP(i, N) {\n\t\tcin >> B[i];\n\t\tg.add_edge(s, i, 1);\n\t}\n\tREP(i, M) {\n\t\tcin >> R[i];\n\t\tg.add_edge(N + i, t, 1);\n\t}\n\tREP(i, N) {\n\t\tREP(j, M) {\n\t\t\tif(gcd(B[i],R[j])!=1)g.add_edge(i, N + j, 1);\n\t\t}\n\t}\n\tcout << g.max_flow(s, t) << endl;\n}\n\n//void solve() {\n//\tint V, E; cin >> V >> E;\n//\tDinic<int>g(V);\n//\tREP(i, E) {\n//\t\tint u, v, c; cin >> u >> v >> c;\n//\t\tg.add_edge(u, v, c);\n//\t}\n//\tcout << g.max_flow(0, V - 1) << endl;\n//}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n    while(true)\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <boost/multiprecision/cpp_dec_float.hpp>\n#include <boost/multiprecision/cpp_int.hpp>\n#include <boost/numeric/interval.hpp>\n#include <boost/numeric/interval/io.hpp>\nusing namespace::std;\nnamespace mp = boost::multiprecision;\ntypedef mp::number<mp::cpp_dec_float<32,int64_t>> cfloat;\ntypedef mp::cpp_int cint;\ntypedef long long lint;\ntypedef long long ll;\ntypedef long double ldouble;\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\n#define rep(i, n) for(lint i = 0; i < (lint)(n); i++)\n#define irep(i) for(lint i = 0;; i++)\n#define irep1(i) for(lint i = 1;; i++)\n#define irep2(i) for(lint i = 2;; i++)\n#define rrep(i, n) for(lint i = (lint)(n-1); i >-1; i--)\n#define rrepi(i,a,b) for(lint i = (lint)(b-1); i >a-1; i--)\n#define repi(i,a,b) for(lint i=lint(a);i<lint(b);i++)\n#define rep2(i,a,b,c) for(lint i=lint(a);i>lint(b);i+=c)\n#define all(x) (x).begin(),(x).end()\n#define sl(c) (('a')<=(c)&&(c)<=('z'))\n#define ll(c) (('A')<=(c)&&(c)<=('Z'))\n#define max3(a,b,c) max(a,max(b,c))\n#define min3(a,b,c) min(a,min(b,c))\n#define PI 3.141592653589793\n#define cout (cout<<fixed<<setprecision(15))\n#define makeupper(t) (transform(all(t),t.begin(),::toupper))\n#define makelower(t) (transform(all(t),t.begin(),::tolower))\n#define dist(x1,y1,x2,y2) (pow(pow(x2-x1,2)+pow(y2-y1,2),0.5))\n#define NEXT_LINE string junk; getline(cin, junk);\n#define output(v) do{rep(i,v.size())cout<<(i?\" \":\"\")<<v[i];cout<<\"\\n\";}while(0)\n#define output2(v) rep(i,v.size()){rep(j,v[i].size()){cout<<(j?\" \":\"\")<<v[i][j];}cout<<\"\\n\";}\n#define INF 1LL<<40\n#define IINF 1<<30\n#define LINF 9223372036854775807\n#define MOD 1000000007\nvector<lint> dx={-1,1,0,0,1,1,-1,-1};\nvector<lint> dy={0,0,-1,1,1,-1,1,-1};\nvector<lint> operator+(const vector<lint>& v1,const vector<lint>& v2){\n    vector<lint> v(v1.size()+v2.size(),0);\n    rep(i,v1.size())v[i]=v1[i];\n    rep(i,v2.size())v[i+v1.size()]=v2[i];\n    return v;\n}\ninline lint sum(vector<lint> v){\n    lint sum=0;\n    rep(i,v.size())sum+=v[i];\n    return sum;\n}\ninline string replace(string str, string before, std::string after) {\n\tstring::size_type  Pos(str.find(before));\n\twhile (Pos != std::string::npos) {\n\t\tstr.replace(Pos, before.length(), after);\n\t\tPos = str.find(before, Pos + after.length());\n\t}\n\treturn str;\n}\ninline vector<string> split(string s, string delim) {\n\tvector<string> elems;\n\ts=replace(s, \"#\", \"HASH\");\n\ts=replace(s, delim,\"#\");\n\tstringstream ss(s);\n\tstring item;\n\twhile (getline(ss, item, '#')) {\n\t\telems.push_back(replace(item, \"HASH\", \"#\"));\n\t}\n\treturn elems;\n}\ninline vector<int> cross(vector<int> a, vector<int> b) {\n    return { a[1] * b[2] - a[2] * b[1],a[2] * b[0] - a[0] * b[2],a[0] * b[1] - a[1] * b[0] };\n}\ninline lint GCD(lint a,lint b){return b?GCD(b,a%b):a;}\ninline vector<lint> primeList(lint n) {\n    vector<bool> p(n+1);\n    vector<lint> list;\n    repi(i,1, n+1)p[i] = true;\n    repi(i,2,sqrt(n)+1) {\n        if (p[i]) {\n            repi(j,2,n/i+1) {\n                p[i*j] = false;\n            }\n        }\n    }\n    repi(i, 2, n+1)if (p[i])list.push_back(i);\n    return list;\n}\ninline set<lint> primeSet(lint n) {\n    vector<bool> p(n+1);\n    set<lint> set;\n    repi(i,1, n+1)p[i] = true;\n    repi(i,2,sqrt(n)+1) {\n        if (p[i]) {\n            repi(j,2,n/i+1) {\n                p[i*j] = false;\n            }\n        }\n    }\n    repi(i, 2, n+1)if (p[i])set.insert(i);\n    return set;\n}\ninline bool isPrime(int num){\n    if (num < 2) return false;\n    else if (num == 2) return true;\n    else if (num % 2 == 0) return false;\n    double sqrtNum = sqrt(num);\n    for (int i = 3; i <= sqrtNum; i += 2){\n        if (num % i == 0)return false;\n    }\n    return true;\n}\ninline lint max(vector<lint> num){\n    lint M=num[0];\n    rep(i,num.size())M=max(M,num[i]);\n    return M;\n}\ninline lint min(vector<lint> num){\n    lint M=num[0];\n    rep(i,num.size())M=min(M,num[i]);\n    return M;\n}\ninline cint cmax(vector<cint> num){\n    cint M=num[0];\n    rep(i,num.size())if(M<num[i])M=num[i];\n    return M;\n}\ninline cint cmin(vector<cint> num){\n    cint M=num[0];\n    rep(i,num.size())if(M>num[i])M=num[i];\n    return M;\n}\ninline lint signal(lint val){\n    if(val==0)return 0;\n    else return val/abs(val);\n}\nstruct IVector2{\n    lint x,y;\n};\nbool operator< (const IVector2 &s, const IVector2 &t){\n        return s.x==t.x?s.y<t.y:s.x<t.x;\n};\nbool operator> (const IVector2 &s, const IVector2 &t){\n        return s.x==t.x?s.y>t.y:s.x>t.x;\n};\nstruct IVector3{\n    lint x,y,z;\n};\nstruct IVector4{\n    lint x,y,z,w;\n};\nstruct MF {\n    struct edge { lint to, cap, rev; };\n    lint V;\n    vector<vector<edge>> G;\n    vec itr, level;\n\n    MF(lint V) : V(V) { G.assign(V,vector<edge>()); }\n\n    void add_edge(lint from, lint to, lint cap) {\n        G[from].push_back((edge) {to, cap, (lint) G[to].size()});\n        G[to].push_back((edge) {from, 0, (lint) G[from].size()-1});\n    }\n\n    void bfs(lint s) {\n        level.assign(V,-1);\n        queue<lint> q;\n        level[s] = 0; q.push(s);\n        while (!q.empty()) {\n            lint v = q.front(); q.pop();\n            for(auto &e: G[v]){\n                if (e.cap > 0 and level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    lint dfs(lint v, lint t, lint f) {\n        if (v == t) return f;\n        for (lint& i = itr[v]; i < (lint) G[v].size(); ++i) {\n            edge& e = G[v][i];\n            if (e.cap > 0 and level[v] < level[e.to]) {\n                lint d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    lint run(lint s, lint t) {\n        lint ret = 0, f;\n        while (bfs(s), level[t] >= 0) {\n            itr.assign(V,0);\n            while ((f = dfs(s, t, INF)) > 0) ret += f;\n        }\n        return ret;\n    }\n};\nint main(){\n    while(1){\n        lint m,n;\n        cin>>m>>n;\n        if(m==0&&n==0)break;\n        vec u(m),v(n);\n        rep(i,m)cin>>u[i];\n        rep(i,n)cin>>v[i];\n        MF mf=MF(2+n+m);\n        rep(i,m){\n            mf.add_edge(m+n,i,1);\n        }\n        rep(i,n){\n            mf.add_edge(i+m,m+n+1,1);\n        }\n        rep(i,m)rep(j,n){\n            if(GCD(u[i],v[j])!=1)mf.add_edge(i,m+j,1);\n        }\n        cout<<mf.run(m+n,m+n+1)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\n\nconst int MAX_P = 10000;\nconst int MAX_V = 1010;\nconst int INF = 0x3f3f3f3f;\n\nint M, N;\nvector<bool> isPrime(MAX_P, true);\nvi primes;\n\n// 辺を表す構造体（行き先、容量、逆辺）\nstruct edge { int to, cap, rev; };\n\nclass MF {\npublic:\n  vector<edge> G[MAX_V];  // グラフの隣接リスト表現\n  bool used[MAX_V];   // DFSですでに調べたかのフラグ\n\n  // fromからtoへ向かう容量capの辺をグラフに追加する\n  void add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, 0, G[from].size() - 1});\n  }\n\n  // 増加パスをDFSで探す\n  int dfs(int v, int t, int f) {\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++) {\n      edge &e = G[v][i];\n      if(!used[e.to] && e.cap > 0) {\n        int d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  int max_flow(int s, int t) {\n    int flow = 0;\n    for(;;) {\n      memset(used, 0, sizeof(used));\n      int f = dfs(s, t, INF);\n      if(f == 0) return flow;\n      flow += f;\n    }\n  }\n};\n\nvoid init() {\n  isPrime[0] = isPrime[1] = false;\n  for (int i = 0; i < MAX_P; i++) {\n    if (!isPrime[i]) continue;\n    primes.pb(i);\n    for (int j = i; j < MAX_P; j+=i) {\n      isPrime[j] = false;\n    }\n  }\n}\n\nint main() {\n  init();\n  while (true) {\n    vi Bs, Rs;\n    cin >> M >> N;\n    if (M==0 && N==0) {\n      break;\n    }\n    MF mf;\n    for (int i = 0; i < M; i++) {\n      int b; cin >> b;\n      Bs.pb(b);\n      mf.add_edge(0, i+1, 1);\n    }\n    for (int i = 0; i < N; i++) {\n      int r; cin >> r;\n      Rs.pb(r);\n      mf.add_edge(i+M+1, M+N+1, 1);\n    }\n    for (int i = 0; i < M; i++) {\n      for (int j = 0; j < N; j++) {\n        for (int k = 0; k < (int)primes.size(); k++) {\n          if (Bs[i]%primes[k]==0 && Rs[j]%primes[k]==0) {\n            // cout << i+1 << \", \" << j+1 << endl;\n            mf.add_edge(i+1, j+M+1, 1);\n            break;\n          }\n        }\n      }\n    }\n    cout << mf.max_flow(0, M+N+1) << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Hopcroft-Karp Algorithm\n// O(|E| * |V|^(1/2))\n// http://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm\n// aoj 1163\n\n#include <vector>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\nint NIL;\nconst int inf = 1<<29;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int> > Graph;\n\nbool bfs(const Graph &g,vi &dist,const vi &pair,int m) {\n    queue<int> q;\n\n    for(int i=0; i<m; ++i)\n        if(pair[i] == NIL) {\n            dist[i] = 0;\n            q.push(i);\n        }else\n            dist[i] = inf;\n    dist[NIL] = inf;\n\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        if(v == NIL) continue;\n        for(int i=0; i<g[v].size(); ++i) {\n            int u = g[v][i];\n            if(dist[pair[u]] == inf) {\n                dist[pair[u]] = dist[v]+1;\n                q.push(pair[u]);\n            }\n        }\n    }\n    return dist[NIL] != inf;\n}\n\nbool dfs(int v,const Graph &g,vi &dist,vi &pair) {\n    for(int i=0; i<g[v].size(); ++i) {\n        int u = g[v][i];\n        if(dist[pair[u]] == dist[v]+1) {\n            if(pair[u] == NIL || dfs(pair[u],g,dist,pair)) {\n                pair[u] = v, pair[v] = u;\n                return true;\n            }\n        }\n    }\n    dist[v] = inf;\n    return false;\n}\n\n// 0ツつゥツづァm-1ツづ慊づづ個静淞点ツづツつゥツづァn-1ツづ慊づづ個静淞点ツづづ個催妥・ツマツッツチツδ督グツづーツ仰づ淞づゥ\nint hopcroft_karp(Graph &graph,int m) {\n    const int n = graph.size();\n    NIL = n;\n    vi pair(n+1, NIL), dist(n+1, 0);\n    int ret = 0;\n    while(bfs(graph,dist,pair,m)) {\n        for(int i=0; i<m; ++i)\n            if(pair[i] == NIL)\n                if(i == NIL || dfs(i,graph,dist,pair)) ret++;\n    }\n    return ret;\n}\n\nint gcd(int x,int y) {\n    if(y == 0) return x;\n    return gcd(y,x%y);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    int m,n;\n    while(cin>>m>>n, m|n) {\n        Graph g(m+n);\n        vector<int> b(m), r(n);\n        for(int i=0; i<m; ++i) cin>>b[i];\n        for(int i=0; i<n; ++i) cin>>r[i];\n\n        for(int i=0; i<m; ++i)\n            for(int j=0; j<n; ++j)\n                if(gcd(b[i],r[j]) > 1)\n                    g[i].push_back(j+m);\n        cout<<hopcroft_karp(g,m)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\n \n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n \n#define MAX_N 500\n#define MAX_K 500\n#define MAX_V 1002\n#define INF 1000000000\n \n \nstruct edge { int to, cap, rev; };\nvector<edge> G[MAX_V];\nbool used[MAX_V]; \nint V;\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\nvoid resetG(int ver){\n    V = ver;\n    REP(i,V)\n        G[i].clear();\n}\n \nint N, K;\nbool can[MAX_N][MAX_K];\nvoid solve() {\n    int s = N + K, t = s + 1;\n    for (int i = 0; i < N; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < K; i++) {\n        add_edge(N + i, t, 1);\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < K; j++) {\n            if (can[i][j]) {\n                add_edge(i, N + j, 1);\n            }\n        }\n    }\n    printf(\"%d\\n\",max_flow(s,t));\n}\n \nint gcd(int a,int b){\n    if(a < b){\n        int c = a;\n        a = b;\n        b = c;\n    }\n    if(a % b == 0)\n        return b;\n    return gcd(b,a % b);\n}\n \nint inb[500],inr[500];\n \nbool input(){\n    scanf(\"%d%d\",&N,&K);\n    if(N == 0 && K == 0)\n        return false;\n    REP(i,N)\n        scanf(\"%d\",&inb[i]);\n    REP(i,K)\n        scanf(\"%d\",&inr[i]);\n \n    memset(can,false,sizeof(can));\n    REP(i,N){\n        REP(j,K){\n            if(gcd(inb[i],inr[j]) > 1)\n                can[i][j] = true;\n        }\n    }\n    resetG(N + K + 2);\n    return true;\n}\n \nint main(){\n    while(input()){\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint V1, V2;\nint size[1002];\nint to[1002][1002];\nint dist[1002];\nint match[1002];\nconst int NIL = 1001;\nbool BFS(){\n  queue<int> que;\n  REP(v, V1){\n    if(match[v] == NIL){\n      dist[v] = 0;\n      que.push(v);\n    }else{\n      dist[v] = INF;\n    }\n  }\n  dist[NIL] = INF;\n  while(!que.empty()){\n    int v = que.front(); que.pop();\n    if(dist[v] < dist[NIL]){\n      for(int i = 0; i < size[v]; i++){\n        int u = to[v][i];\n        if(dist[match[u]] == INF){\n          dist[match[u]] = dist[v] + 1;\n          que.push(match[u]);\n        }\n      }\n    }\n  }\n  return dist[NIL] != INF;\n}\n\nbool DFS(int v){\n  if(v != NIL){\n    for(int i = 0; i < size[v]; i++){\n      int u = to[v][i];\n      if(dist[match[u]] == dist[v] + 1 && DFS(match[u])){\n        match[u] = v;\n        match[v] = u;\n        return true;\n      }\n    }\n    dist[v] = INF;\n    return false;\n  }\n  return true;\n}\n\nint Hopcroft_Karp(){\n  REP(v, V1 + V2) match[v] = NIL;\n  int matching = 0;\n  while(BFS()){\n    REP(v, V1){\n      if(match[v] == NIL && DFS(v)){\n        matching ++;\n      }\n    }\n  }\n  return matching;\n}\nint main(){\n  while(scanf(\"%d %d\", &V1, &V2) && (V1 != 0 || V2 != 0)){\n    REP(i, V1) size[i] = 0;\n    static int blue[500];\n    static int red[500];\n    REP(i, V1) scanf(\"%d\", blue + i);\n    REP(i, V2) scanf(\"%d\", red + i);\n    REP(u, V1) REP(v, V2){\n      if(__gcd(blue[u], red[v]) != 1) {\n        to[u][size[u]++] = V1 + v;\n        //G[u].push_back(V1 + v);\n        //G[V1 + v].push_back(u);\n      }\n    }\n    printf(\"%d\\n\", Hopcroft_Karp());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n \nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return abs(a);\n\telse return gcd(b, a % b);\n}\n\nstruct flow_network {\n\tint n;\n\tstruct edge { int v; ll c; int rev; };\n\tvector< vector<edge> > G;\n\tflow_network(int _n) : n(_n), G(_n) {}\n\tvoid add_edge(int u, int v, ll c) {\n\t\tedge e = {v, c, G[v].size()}, _e = {u, 0, G[u].size()};\n\t\tG[u].push_back(e); G[v].push_back(_e);\n\t}\n\tll dfs(int u, int t, ll f, vector<bool>& vis) {\n\t\tif (u == t) return f;\n\t\tvis[u] = true;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge& e = G[u][i];\n\t\t\tif (vis[e.v] || e.c == 0) continue;\n\t\t\tll d = min(e.c, dfs(e.v, t, min(f, e.c), vis));\n\t\t\tif (d == 0) continue;\n\t\t\te.c -= d;\n\t\t\tG[e.v][e.rev].c += d;\n\t\t\treturn d;\n\t\t}\n\t\treturn 0;\n\t}\n\tll max_flow(int s, int t) {\n\t\tll res = 0;\n\t\tfor (;;) {\n\t\t\tvector<bool> vis(n);\n\t\t\tll f = dfs(s, t, LLONG_MAX, vis);\n\t\t\tif (f == 0) return res;\n\t\t\tres += f;\n\t\t}\n\t}\n};\n\nint main() {\n\tfor (;;) {\n\t\tint n, m; cin >> n >> m;\n\t\tif (n == 0 && m == 0) break;\n\t\tvector<int> a(n), b(m);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcin >> a[i];\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tcin >> b[j];\n\t\tflow_network fn(n + m + 2);\n\t\tint s = n + m, t = n + m + 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfn.add_edge(s, i, 1);\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tfn.add_edge(n + j, t, 1);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tif (gcd(a[i], b[j]) != 1)\n\t\t\t\t\tfn.add_edge(i, n + j, 1);\n\t\tcout << fn.max_flow(s, t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nstruct E {\n  int to, cost, cap, rev;\n  E(int to, int cost, int cap, int rev)\n    : to(to), cost(cost), cap(cap), rev(rev) {}\n  E() {}\n};\n\ntypedef vector<vector<E> > G;\n\nvoid addEdgeF(int from, int to, int cost, int cap, G &g) {\n  g[from].push_back(E(to,cost,cap,g[to].size()));\n  g[to].push_back(E(from,cost,0,(int)g[from].size()-1));\n}\n\nint dfsF(int v, int t, int f, bool *used, G &g) {\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < g[v].size(); ++i) {\n    E &e = g[v][i];\n    if(!used[e.to] && e.cap > 0) {\n      int d = dfsF(e.to, t, min(f, e.cap), used, g);\n      if(d > 0) {\n        e.cap -= d;\n        g[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int s, int t, G g) {\n  int flow = 0;\n  bool *used = new bool[g.size()];\n  while(1) {\n    fill(used, used + g.size(), false);\n    int f = dfsF(s, t, INF, used, g);\n    if(f == 0) break;\n    flow += f;\n  }\n  delete [] used;\n  return flow;\n}\n\nint gcd(int a, int b) {\n  return b == 0 ? a : gcd(b, a%b);\n}\n\nint main() {\n  int m, n, tmp;\n  vector<int> b, r;\n  G g;\n  while(cin >> m >> n && (m|n)) {\n    b.resize(m);\n    r.resize(n);\n    for(int i = 0; i < m; ++i) {\n      cin >> b[i];\n    }\n    for(int i = 0; i < n; ++i) {\n      cin >> r[i];\n    }\n\n    g = G(m+n+2);\n    for(int i = 0; i < m; ++i) {\n      addEdgeF(m+n, i, 0, 1, g);\n    }\n    for(int i = 0; i < m; ++i) {\n      for(int j = 0; j < n; ++j) {\n        if(gcd(b[i], r[j]) != 1) {\n          addEdgeF(i, m+j, 0, 1, g);\n        }\n      }\n    }\n    for(int i = 0; i < n; ++i) {\n      addEdgeF(m+i, m+n+1, 0, 1, g);\n    }\n    cout << maxFlow(m+n, m+n+1, g) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\nstruct edge{int to,cap,rev;};\n\nvector<edge> G[10000];\nbool used[10000];\nvoid add_edge(int from,int to,int cap){\n    G[from].pb((edge){to,cap,(int)G[to].size()});\n    G[to].pb((edge){from,0,(int)(G[from].size())-1});\n}\n\n// テ・ツ「ツ療・ツ環?」ツδ妥」ツつケテ」ツつ奪FSテ」ツ?ァテヲツ篠「テ」ツ??\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap)); if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n// sテ」ツ?凝」ツつ液テ」ツ?クテ」ツ?ョテヲツ慊?・ツ、ツァテヲツオツ?」ツつ津ヲツアツづ」ツつ?」ツつ?\nint max_flow(int s, int t) {\n    int flow = 0; for (;;) {\n        memset(used, 0, sizeof(used)); int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\n\n\nint main(){\n    int m,n;\n    while(cin>>n>>m){\n        if(n==0&&m==0)break;\n        rep(i,10000)G[i].clear();\n        rep(i,10000)used[i]=false;\n        int x[600];\n        int y[600];\n        rep(i,n) cin>>x[i];\n        rep(i,m) cin>>y[i];\n        \n        rep(i,n){\n            rep(j,m){\n                if(__gcd(x[i],y[j])>1){\n                    add_edge(i,n+j,1);\n                }\n            }\n        }\n        int s=n+m,t=s+1;\n        rep(i,n){\n            add_edge(s,i,1);\n        }\n        rep(i,m){\n            add_edge(n+i,t,1);\n        }\n        cout<<max_flow(s,t)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n//typedef long long Int;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst) : src(src),dst(dst) {}\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) {}\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight :\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vec<Edge> Edges;\ntypedef vec<Edges> Graph;\n\n#define MAXMN 500\nint B[MAXMN];\nint R[MAXMN];\n\nint gcd(int a, int b)\n{   \n  return b != 0 ? gcd(b, a % b) : a;\n}\n\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e,g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  return match;\n}\n\n\nint main(int argc, char **argv) {\n  int M,N;\n  Graph g; g.reserve(MAXMN+MAXMN);\n  while(cin>>M>>N,M) {\n    g.clear();\n    g.resize(M+N);\n    REP(i,M) cin>>B[i];\n    REP(i,N) cin>>R[i];\n    REP(i,M) {\n      Edges es, es2;\n      REP(j,N) {\n\tif(gcd(B[i],R[j])!=1) { es.pb(Edge(i,M+j)); es2.pb(Edge(M+j,i)); }\n      }\n      g[i] = es;\n      g[M+i] = es2;\n    }\n    cout << bipartiteMatching(g,M) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = 1e18+7;\n\ntemplate <typename T = i64>\nstruct Range{\n    struct iterator{\n        T value;\n        const T step, last;\n        const T& operator*(){return value;}\n        iterator(T value, T step, T last) :\n            value(step < static_cast<T>(0) ? max(last, value) : min(last, value)),\n            step(step),\n            last(last)\n        {\n        }\n        iterator operator++(){value = step < static_cast<T>(0) ? max(value + step, last) : min(value + step, last); return *this;}\n        bool operator!=(const iterator& x){return value != x.value;}\n    };\n    const T start, last, step;\n\n    Range(const T start, const T last, const T step = static_cast<T>(1)) :\n        start(start),\n        last(last),\n        step(step)\n    {\n    }\n\n    Range(const T last) :\n        start(0),\n        last(last),\n        step(1)\n    {\n    }\n\n    iterator begin(){return iterator(start, step, last);}\n    iterator end(){return iterator(last, step, last);}\n};\n\ntemplate <typename F>\nstruct FixPoint{\n    const F _f;\n    FixPoint(F&& f) : _f(forward<F>(f)){}\n\n    template<typename... Types>\n    decltype(auto) operator()(Types&&... args) const{\n        return _f(*this, forward<Types>(args)...);\n    }\n};\n\ntemplate <typename F>\nstatic decltype(auto) makeRec(F&& f){\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate <typename T, T Value = T()>\nvector<T> makeVector(size_t x){\n    return vector<T>(x, T(Value));\n}\n\ntemplate <typename T, T Value = T(), typename... Types>\nauto makeVector(size_t x, Types... args){\n    return vector<decltype(makeVector<T, Value>(args...))>(x, makeVector<T, Value>(args...));\n}\n\ntemplate <typename T = i64>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T = i64>\nbool chmin(T& a, T b){\n    if(a > b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define dump(x) fprintf(stderr, \"line =%4d, name =%7s , \", __LINE__, #x); clog << \"value = \" << x << endl;\n\n#define vecdump(x) fprintf(stderr, \"line =%4d, name =%7s\\n\", __LINE__, #x); _dump_macro(x);\n\nvoid _dump(int, string& x){\n    clog << x << endl;\n}\n\ntemplate <typename T>\nvoid _dump(bool, T& x){\n    clog << x << \" \";\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _dump(int, T& x){\n\n    for(auto& elm : x)\n        _dump(0, elm);\n\n    clog << endl;\n}\n\ntemplate <typename T>\nvoid _dump_macro(T& x){\n    _dump(0, x);\n}\n\nvoid _input(int, string& x){\n    cin >> x;\n}\n\ntemplate <typename T>\nvoid _input(bool, T& x){\n    cin >> x;\n}\n\ntemplate <typename T, typename U = typename T::iterator>\nvoid _input(int, T& x){\n\n    for(auto& elm : x)\n        _input(0, elm);\n}\n\ntemplate <typename T>\nvoid input_single(T& x){\n    _input(0, x);\n}\n\nauto input(){}\n\ntemplate <typename T, typename... Types>\nvoid input(T& value, Types&&... args){\n    input_single(value);\n    input(forward<Types>(args)...);\n};\n\nvoid _pararell_input(size_t){}\n\ntemplate <typename T, typename... Types>\nvoid _pararell_input(size_t index, T& value, Types&&... args){\n    input(value[index]);\n    _pararell_input(index, forward<Types>(args)...);\n}\n\ntemplate <typename... Types>\nvoid pararell_input(size_t count, Types&&... args){\n    for(const auto& i : Range<>(count))\n        _pararell_input(i, forward<Types>(args)...);\n}\n\ntemplate< typename flow_t >\nstruct Dinic {\n  const flow_t INF;\n\n  struct edge {\n    int to;\n    flow_t cap;\n    int rev;\n    bool isrev;\n  };\n\n  vector< vector< edge > > graph;\n  vector< int > min_cost, iter;\n\n  Dinic(int V) : INF(numeric_limits< flow_t >::max()), graph(V) {}\n\n  void add_edge(int from, int to, flow_t cap) {\n    graph[from].emplace_back((edge) {to, cap, (int) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, (int) graph[from].size() - 1, true});\n  }\n\n  bool bfs(int s, int t) {\n    min_cost.assign(graph.size(), -1);\n    queue< int > que;\n    min_cost[s] = 0;\n    que.push(s);\n    while(!que.empty() && min_cost[t] == -1) {\n      int p = que.front();\n      que.pop();\n      for(auto &e : graph[p]) {\n        if(e.cap > 0 && min_cost[e.to] == -1) {\n          min_cost[e.to] = min_cost[p] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return min_cost[t] != -1;\n  }\n\n  flow_t dfs(int idx, const int t, flow_t flow) {\n    if(idx == t) return flow;\n    for(int &i = iter[idx]; i < graph[idx].size(); i++) {\n      edge &e = graph[idx][i];\n      if(e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n        flow_t d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  flow_t max_flow(int s, int t) {\n    flow_t flow = 0;\n    while(bfs(s, t)) {\n      iter.assign(graph.size(), 0);\n      flow_t f = 0;\n      while((f = dfs(s, t, INF)) > 0) flow += f;\n    }\n    return flow;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << e.cap + rev_e.cap << \")\" << endl;\n      }\n    }\n  }\n};\n\n\nbool solve(){\n\n    int n, m;\n    input(n, m);\n    if(!n && !m)\n        return false;\n    vector<int> a(n), b(m);\n    input(a, b);\n    vector<vector<int>> edges(n);\n    Dinic<int> d(n + m + 2);\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < m; ++j)\n            if(__gcd(a[i], b[j]) != 1)\n                d.add_edge(i, n + j, 1);\n    for(int i = 0; i < n; ++i)\n        d.add_edge(n + m, i, 1);\n    for(int i = 0; i < m; ++i)\n        d.add_edge(n + i, n + m + 1, 1);\n\n    cout << d.max_flow(n + m, n + m + 1) << endl;\n\n    return true;\n}\n\nsigned main(){\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    while(solve());\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\nusing namespace std;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Capacity> Array;\ntypedef vector<Array> Matrix;\n\nconst int inf = 1e8;\n\nstruct FordFulkerson {\n    typedef vector<vector<Capacity>> Matrix;\n    int n, t;\n    vector<bool> vis;\n    Matrix cap, flow;\n    vector<vector<int>> g;\n    FordFulkerson(int n){ *this = FordFulkerson(Graph(n)); }\n    FordFulkerson(const Graph &graph)\n        : n(graph.size()), cap(n, Array(n)),\n          flow(n, Array(n)), g(n, vector<int>()){\n        rep(i,n)\n            for(const Edge &e : graph[i])\n                add_edge(e.src, e.dst, e.cap);\n    }\n    void add_edge(int u, int v, Capacity c){\n        cap[u][v] += c;\n        cap[v][u] += c;\n        flow[v][u] += c;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    Capacity solve(int s, int t){\n        this->t = t;\n        Capacity res = 0, f = -1;\n        while(f){\n            vis.assign(n,false);\n            res += (f = augment(s,inf));\n        }\n        return res;\n    }\n    Capacity augment(int v, Capacity lim){\n        vis[v] = true;\n        if(v == t) return lim;\n        for(const int &i : g[v]){\n            if(vis[i] || flow[v][i] == cap[v][i]) continue;\n            Capacity f = augment(i, min(lim, cap[v][i] - flow[v][i]));\n            flow[v][i] += f;\n            flow[i][v] -= f;\n            if(f) return f;\n        }\n        return 0;\n    }\n};\n\nint gcd(int a, int b){\n    return b == 0 ? a : gcd(b,a%b);\n}\n\nint main(){\n    int n,m;\n    while(cin >> n >> m && n){\n        Graph g(1002);\n        int s = 1000, t = 1001;\n        int a[555], b[555];\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        rep(i,n)rep(j,n){\n            if(gcd(a[i],b[j]) != 1){\n                g[i].emplace_back(i,j+500,1);\n            }\n        }\n        rep(i,n) g[s].emplace_back(s,i,1);\n        rep(i,m) g[i+500].emplace_back(i+500,t,1);\n        cout << FordFulkerson(g).solve(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\n\nint gcd(int x, int y){\n    int r;\n    while((r=x%y) != 0){\n        x = y;\n        y = r;\n    }\n    return y;\n}\n\nint dfs(int n, int flow, vector<vector<int> >& adj, vector<bool>& used){\n\tif(n == (int)adj.size()-1){\n\t\treturn flow;\n\t}\n\tfor(int i=0; i<(int)adj.size(); i++){\n\t\tif(!used[i] && adj[n][i] > 0){\n\t\t\tused[i] = true;\n\t\t\tint ret = dfs(i, min(flow, adj[n][i]), adj, used);\n\t\t\tif(ret > 0){\n\t\t\t\tadj[n][i] -= ret;\n\t\t\t\tadj[i][n] += ret;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\twhile(1){\n\t\tint m,n;\n\t\tcin >> m >> n;\n\t\tif(m==0) break;\n\t\t\n\t\tvector<int> cards(m+n+1);\n\t\tfor(int i=1; i<=m+n; i++) cin >> cards[i];\n\t\t\n\t\tvector<vector<int> > g(m+n+2, vector<int>(m+n+2, 0));\n\t\tfor(int i=1; i<=m; i++){\n\t\t\tfor(int j=1; j<=n; j++){\n\t\t\t\tif(gcd(cards[i], cards[m+j]) != 1){\n\t\t\t\t\tg[i][m+j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<=m; i++) g[0][i] = 1;\n\t\tfor(int i=m+1; i<=m+n; i++) g[i][m+n+1] = 1;\n\t\t\n\t\tint ans = 0;\n\t\twhile(1){\n\t\t\tvector<bool> used(m+n+2, false);\n\t\t\tused[0] = true;\n\t\t\tint ret = dfs(0, inf, g, used);\n\t\t\tif(ret==-1) break;\n\t\t\tans += ret;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <iostream>\n#include <random>\n#include <map>\n#include <iomanip>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include <fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\n\nusing ll = long long;\nusing vll = vector<ll>;\nusing pll = pair<ll, ll>;\nusing qll = queue<ll>;\nusing vb = vector<bool>;\nusing mll = map<ll, ll>;\nusing sll = stack<ll>;\n#define REP(i,n) for(ll i(0);(i)<(n);(i)++)\n#define rep(i,n) for(ll i(0);(i)<(n);(i)++)\n#define ALL(a) a.begin(), a.end()\n#define elnd endl //* missspell check\nconst ll INF = 1LL << 60;\n\nll gcd (ll a, ll b){ return b == 0? a : gcd(b, a % b); }\n\nvoid add_edge(vector<vll> &G, ll u, ll v){\n    G[u].push_back(v); G[v].push_back(u);\n}\n\nbool dfs(vector<vll> &G, vb &checked, vll &match, ll v){\n    //* match is initialized -1 outside\n    checked[v] = true;\n    REP(i, G[v].size()){\n        ll u = G[v][i], w = match[u];\n        if(w < 0 || !checked[w] && dfs(G, checked, match, w)){\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nll BipartiteMatching(vector<vll> &G){\n    ll N = G.size();\n    vb checked(N, false);\n    vll match(N, -1);\n    ll res = 0;\n    REP(v, N){\n        if(match[v] < 0){\n            fill(ALL(checked), false);\n            if(dfs(G, checked, match, v)){\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(1){\n        ll M, N; cin >> M >> N;\n        if(M == 0 && N == 0)\n            break;\n\n        vll b(M), r(N);\n        REP(i, M) cin >>b[i];\n        REP(j, N) cin >>r[j];\n        vector<vll> G(M+N);\n        REP(i, M){\n            REP(j, N){\n                if(gcd(b[i], r[j]) > 1){\n                    add_edge(G, i, j+M);\n                }\n            }\n        }\n        ll m = 0; \n        m = BipartiteMatching(G);\n        cout << m << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// MEMO\n//\n// O(VE)\n\n// THE BEGINNING OF THE LIBRARY.\n\nstruct BipartiteMatching {\n\tusing UnWeightedGraph=vector< vector<int> >;\n\n\tint n;\n\tUnWeightedGraph G;\n\tvector<int> match,used;\n\n\tBipartiteMatching() {}\n\tBipartiteMatching(int sz):n(sz),G(sz),match(sz),used(sz) {}\n\n\tvoid add_edge(int u,int v) {\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tbool dfs(int v) {\n\t\tused[v]=true;\n\t\tfor(auto u:G[v]) {\n\t\t\tint w=match[u];\n\t\t\tif(w<0||(!used[w]&&dfs(w))) {\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint bipartite_matching() {\n\t\tint res=0;\n\t\tfill(match.begin(),match.end(),-1);\n\t\tfor(int v=0;v<n;v++) {\n\t\t\tif(match[v]<0) {\n\t\t\t\tfill(used.begin(),used.end(),0);\n\t\t\t\tif(dfs(v)) res++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint gcd(int a,int b) {\n\tif(a<b) swap(a,b);\n\tint r;\n\twhile(a%b!=0) {\n\t\tr=b;b=a%b;a=r;\n\t}\n\treturn b;\n}\n\n// THE ENDING OF THE LIBRARY.\n// THE FOLLOWING IS AN EXAMPLE OF USE.\n\nint main() {\n\n    while(1) {\n\tint m,n;\n\tcin>>m>>n;\n    if(m==0) break;\n\tvector<int> a(m),b(n);\n\tfor(int i=0;i<m;i++) cin>>a[i];\n\tfor(int i=0;i<n;i++) cin>>b[i];\n\tBipartiteMatching bimatch(m+n);\n\tfor(int i=0;i<m;i++) {\n\t\tfor(int j=0;j<n;j++) {\n\t\t\tif(gcd(a[i],b[j])>1) bimatch.add_edge(i,j+m);\n\t\t}\n\t}\n\tcout<<bimatch.bipartite_matching()<<endl;\n    } \n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 1050\n\nvector<int> G[MAX_V];\nint match[MAX_V],V;\nbool used[MAX_V];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0||!used[w]&&dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint n,m;\nvoid init(){\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n  memset(match,-1,sizeof(match));\n  V=n+m;\n}\n\nint main(){\n  while(cin>>m>>n,m||n){\n    init();\n    int b[m],r[n],i,j;\n    for(i=0;i<m;i++) cin>>b[i];\n    for(i=0;i<n;i++) cin>>r[i];\n    for(i=0;i<m;i++){\n      for(j=0;j<n;j++){\n\tif(__gcd(b[i],r[j])!=1) add_edge(i,m+j);\n      }\n    }\n    cout << bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\ntypedef int Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight == rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nWeight augment(Graph &g, Matrix &capacity, const vector<int> &level, vector<bool> &finished, int from, int t, Weight cur) {\n  if (from == t || cur == 0) { return cur; }\n  if (finished[from]) { return 0; }\n  for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n    int to = it->dest;\n    if (level[to] <= level[from]) { continue; }\n    Weight f = augment(g, capacity, level, finished, to, t, min(cur, capacity[from][to]));\n    if (f > 0) {\n      capacity[from][to] -= f;\n      capacity[to][from] += f;\n      return f;\n    }\n  }\n  finished[from] = true;\n  return 0;\n}\n\nWeight MaxFlow(Graph &g, int s, int t) {\n  int n = g.size();\n  Matrix capacity(n, Array(n));\n  for (int from = 0; from < n; from++) {\n    for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n      int to = it->dest;\n      capacity[from][to] += it->weight;\n    }\n  }\n  int ans = 0;\n  while (true) {\n    vector<int> level(n, -1);\n    level[s] = 0;\n    queue<int> que;\n    que.push(s);\n    for (int d = n; !que.empty() && level[que.front()] < d; ) {\n      int from = que.front();\n      que.pop();\n      if (from == t) { d = level[from]; }\n      for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n        int to = it->dest;\n        if (capacity[from][to] > 0 && level[to] == -1) {\n          que.push(to);\n          level[to] = level[from] + 1;\n        }\n      }\n    }\n    vector<bool> finished(n);\n    bool end = true;\n    while (true) {\n      Weight f = augment(g, capacity, level, finished, s, t, 1000000000);\n      if (f == 0) { break; }\n      ans += f;\n      end = false;\n    }\n    if (end) { break; }\n  }\n  return ans;\n}\n\n\nint gcd(int a, int b) {\n  if (b == 0) { return a; }\n  return gcd(b, a % b);\n}\n\nint m, n;\nint blue[501];\nint red[501];\n\nint BLUE(int x) { return x; }\nint RED(int x) { return m + x; }\nint SOURCE() { return m + n; }\nint DEST() { return m + n + 1; }\nint SIZE() { return m + n + 2; }\n\nint main() {\n  while (scanf(\"%d %d\", &m, &n), m|n) {\n    Graph g(SIZE());\n    REP(b, m) {\n      scanf(\"%d\", &blue[b]);\n      g[SOURCE()].push_back(Edge(SOURCE(), BLUE(b), 1));\n      g[BLUE(b)].push_back(Edge(BLUE(b), SOURCE(), 0));\n    }\n    REP(r, n) {\n      scanf(\"%d\", &red[r]);\n      g[RED(r)].push_back(Edge(RED(r), DEST(), 1));\n      g[DEST()].push_back(Edge(DEST(), RED(r), 0));\n    }\n    REP(b, m) {\n      REP(r, n) {\n        if (gcd(blue[b], red[r]) != 1) {\n          g[BLUE(b)].push_back(Edge(BLUE(b), RED(r), 1));\n          g[RED(r)].push_back(Edge(RED(r), BLUE(b), 0));\n        }\n      }\n    }\n    int ans = MaxFlow(g, SOURCE(), DEST());\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nvector<int> blue;\nvector<int> red;\nvector<int> redpair;\nvector<int> v;\nvector<vector<int> >c;\n\nint m = 0;\nint n = 0;\n\nint gcd(int x,int y){\n    if(x % y == 0){\n        return y;\n    }\n    return gcd(y,x%y);\n}\n\nbool match(int x){\n    if(x == -1){\n        return 1;\n    }\n    for(int i = 0;i < n;i++){\n        if(c[x][i] == 1 && v[i] == 0){\n            v[i] = 1;\n            if(match(redpair[i])){\n                redpair[i] = x;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\n\nint main(){\n    while(cin >> m >> n){\n        if(m == 0 && n == 0){\n            break;\n        }\n        blue.clear();\n        red.clear();\n        redpair.clear();\n        v.clear();\n        c.clear();\n        for(int i = 0;i < m;i++){\n            int tmp = 0;\n            cin >> tmp;\n            blue.push_back(tmp);\n        }\n        for(int i = 0;i < n;i++){\n            int tmp = 0;\n            cin >> tmp;\n            red.push_back(tmp);\n            redpair.push_back(-1);//-1??§?????¢??????????????¶????????¨???\n            v.push_back(0);\n        }\n        for(int i = 0;i < m;i++){\n            c.push_back(vector<int>());\n            for(int j = 0;j < n;j++){\n                c[i].push_back(gcd(blue[i],red[j]) != 1);\n            }\n        }\n        int ans = 0;\n        for(int i = 0;i < m;i++){\n            for(int j = 0;j < n;j++){\n                v[j] = 0;\n            }\n            if(match(i)){ans++;}\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int64 INF = 1LL << 55;\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename T >\nT hungarian(Matrix< T > &A) {\n  const T infty = numeric_limits< T >::max();\n  const int N = (int) A.size();\n  const int M = (int) A[0].size();\n  vector< int > P(M), way(M);\n  vector< T > U(N, 0), V(M, 0), minV;\n  vector< bool > used;\n\n  for(int i = 1; i < N; i++) {\n    P[0] = i;\n    minV.assign(M, infty);\n    used.assign(M, false);\n    int j0 = 0;\n    while(P[j0] != 0) {\n      int i0 = P[j0], j1 = 0;\n      used[j0] = true;\n      T delta = infty;\n      for(int j = 1; j < M; j++) {\n        if(used[j]) continue;\n        T curr = A[i0][j] - U[i0] - V[j];\n        if(curr < minV[j]) minV[j] = curr, way[j] = j0;\n        if(minV[j] < delta) delta = minV[j], j1 = j;\n      }\n      for(int j = 0; j < M; j++) {\n        if(used[j]) U[P[j]] += delta, V[j] -= delta;\n        else minV[j] -= delta;\n      }\n      j0 = j1;\n    }\n    do {\n      P[j0] = P[way[j0]];\n      j0 = way[j0];\n    } while(j0 != 0);\n  }\n  return (-V[0]);\n}\n\nint main() {\n  int M, N, B[500], R[500];\n  while(cin >> M >> N, M) {\n    for(int i = 0; i < M; i++) {\n      cin >> B[i];\n    }\n    for(int i = 0; i < N; i++) {\n      cin >> R[i];\n    }\n    if(M > N) swap(M, N), swap(B, R);\n    Matrix< int > mat(M + 1, vector< int >(N + 1));\n    for(int i = 0; i < M; i++) {\n      for(int j = 0; j < N; j++) {\n        if(__gcd(B[i], R[j]) > 1) mat[i + 1][j + 1] = -1;\n      }\n    }\n    cout << -hungarian(mat) << endl;\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint gcd(int a, int b) {\n\treturn a % b ? gcd(b, a % b) : b;\n}\n\nstruct s {\n\tint dst, rev, cap;\n\ts(){}\n\ts(int d, int r, int c){\n\t\tdst=d; rev=r; cap=c;\n\t}\n};\n\nvoid add(int src, int dst, int cost, vector<vector<s> >& G) {\n\tG[src].push_back(s(dst,G[dst].size(),cost));\n\tG[dst].push_back(s(src,G[src].size()-1,0));\n}\n\nint dfs(int n, int dst, int flow, vector<vector<s> > &G, bool* vis) {\n\tif(vis[n]) return 0;\n\tif(n == dst) {\n\t\treturn flow;\n\t}\n\tvis[n] = true;\n\tfor(int i = 0; i < G[n].size(); i++) {\n\t\tif(G[n][i].cap > 0) {\n\t\t\tint res = dfs(G[n][i].dst, dst, min(flow,G[n][i].cap), G, vis);\n\t\t\tif(res) {\n\t\t\t\tG[n][i].cap -= res;\n\t\t\t\tG[G[n][i].dst][G[n][i].rev].cap += res;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxf(int src, int dst, vector<vector<s> > &G) {\n\tint res = 0;\n\tbool f = true;\n\twhile(f) {\n\t\tf = false;\n\t\tbool vis[1100] = {};\n\t\tint tmp = dfs(src, dst, 100, G, vis);\n\t\tif(tmp) {\n\t\t\tf = true;\n\t\t\tres += tmp;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint m, n;\n\twhile(cin >> m >> n, m || n) {\n\t\tvector<int> b(m), r(n);\n\t\tvector<vector<s> > G(m+n+2);\n\t\tfor(int i = 0; i < m; i++) cin >> b[i];\n\t\tfor(int i = 0; i < n; i++) cin >> r[i];\n\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tif(gcd(b[i],r[j]) > 1) {\n\t\t\t\t\tadd(i+1, j+m+1, 1, G);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m; i++) add(0,i+1,1,G);\n\t\tfor(int i = 0; i < n; i++) add(i+1+m,n+m+1,1,G);\n\t\tcout << maxf(0,n+m+1,G) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nclass MaxFlow {\n    struct Edge {\n        ll to, cap, rev;\n    };\n    ll V;\n    vector<vector<Edge>> G;\n    vector<ll> bfs(ll s) {\n        vector<ll> dist(V, linf);\n        dist[s] = 0;\n        queue<ll> Q; Q.push(s);\n        while ( !Q.empty() ) {\n            ll v = Q.front(); Q.pop();\n            EACH(e, G[v]) {\n                if (e.cap > 0 && dist[e.to] == linf) {\n                    dist[e.to] = dist[v]+1;\n                    Q.push(e.to);\n                }\n            }\n        }\n        return dist;\n    }\n    ll dfs(ll v, ll t, ll f, const vector<ll>& dist) {\n        if (v == t) return f;\n        EACH(e, G[v]) {\n            if (e.cap > 0 && dist[e.to] == dist[v]+1) {\n                ll d = dfs(e.to, t, min(f, e.cap), dist);\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\npublic:\n    const vector<vector<Edge>> Graph() {\n        return G;\n    }\n    MaxFlow(ll V) : V(V), G(V) {}\n    void init(ll n) {\n        V = n;\n        G.assign(V, vector<Edge>());\n    }\n    void add(ll from, ll to, ll cap) {\n        assert(V > 0);\n        G[from].pb({to, cap, (ll)G[to].size()});\n        G[to].pb({from, 0, (ll)G[from].size()-1});\n    }\n    ll flow(ll s, ll t, ll f=linf) {\n        ll res = 0;\n        while (1) {\n            vector<ll> dist = bfs(s);\n            if (dist[t] == linf) break;\n            while (1) {\n                ll df = dfs(s, t, f, dist);\n                if (df == 0) break;\n                f -= df;\n                res += df;\n            }\n        }\n        return res;\n    }\n};\nll gcd(ll a, ll b) {\n    return b == 0 ? a : gcd(b, a%b);\n}\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    ll m, n;\n    while (cin >> m >> n, m || n) {\n        vector<ll> A(m), B(n); cin >> A >> B;\n        ll s = m+n, t = s+1;\n        MaxFlow mf(t+1);\n        REP(i, m) REP(j, n) {\n            if (gcd(A[i], B[j]) > 1) {\n                mf.add(i, m+j, 1);\n            }\n        }\n        REP(i, m) mf.add(s, i, 1);\n        REP(i, n) mf.add(m+i, t, 1);\n        cout << mf.flow(s, t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define rrep(i,n) for (int i = (n)-1; i >= 0; i--)\n#define rep2(i,s,n) for (int i = (s); i < (n); ++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vs vector<string>\n#define vc vector<char>\n#define vb vector<bool>\n#define vp vector<P>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\nusing LP = pair<ll,ll>;\ntemplate<class T> istream& operator>>(istream& is,vector<T>& v) { for(T& t:v){is>>t;} return is; }\ntemplate<class T> ostream& operator<<(ostream& os,const vector<T>& v) { for(T t:v){os<<t<<\" \";} os<<\"\\n\"; return os; }\nvoid Yes(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YES(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate<class T> inline bool chmin(T& a,T b) {if(a > b){a = b; return true;} return false;}\ntemplate<class T> inline bool chmax(T& a,T b) {if(a < b){a = b; return true;} return false;}\nconst int inf = 1001001001;\nconst ll linf = 1001001001001001001;\n\nclass flow {\n    struct edge {\n        int to,cap,rev;\n        edge(int to,int cap,int rev):to(to),cap(cap),rev(rev) {}\n    };\n    int n;\n    vector<vector<edge>> G;\n    vi level,iter;\n\n    void bfs(int s) {\n        level.assign(n,-1);\n        queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while(!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for(auto& e : G[v]) {\n                if(e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t,int f) {\n        if(v == t) return f;\n        rep2(i,iter[v],G[v].size()) {\n            auto &e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]) {\n                int d = dfs(e.to,t,min(f,e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    explicit flow(int n):n(n),G(n),level(n),iter(n) {}\n    void add_edge(int from,int to,int cap) {\n        G[from].eb(to,cap,G[to].size());\n        G[to].eb(from,0,G[from].size()-1);\n    }\n    // O(|E||V|^2) dinic-algorithm\n    int max_flow(int s,int t) {\n        int fl = 0;\n        while(true) {\n            bfs(s);\n            if(level[t] < 0) return fl;\n            iter.assign(n,0);\n            int f;\n            while((f = dfs(s,t,inf)) > 0) fl += f;\n        }\n    }\n};\n\nint gcd(int a,int b) {\n    if(a < b) swap(a,b);\n    if(b == 0) return a;\n    return gcd(b,a%b);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n    while(true) {\n        int m,n;\n        cin >> m >> n;\n        if(m == 0 && n == 0) return 0;\n        vi b(m),r(n);\n        cin >> b >> r;\n        flow fl(m+n+2);\n        int s = m+n,t = s+1;\n        rep(i,m) fl.add_edge(s,i,1);\n        rep(i,n) fl.add_edge(m+i,t,1);\n        rep(i,m) rep(j,n) if(gcd(b[i],r[j]) > 1) fl.add_edge(i,m+j,1);\n        cout << fl.max_flow(s,t) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\nconst int MAX_V = 10005;\n\nclass Edge{\n    public:\n        int to, cap, rev;\n        Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n    private:\n        vector<Edge> G[MAX_V];\n        bool used[MAX_V];\n        int level[MAX_V]; //s??????????????¢\n        int iter[MAX_V]; //???????????§??????????????£??????\n        int dfs(int v, int t, int f){\n            if(v == t) return f;\n            used[v] = true;\n            rep(i,G[v].size()){\n                Edge &e = G[v][i];\n                if(not used[e.to] && e.cap > 0){\n                    int d = dfs(e.to, t, min(f, e.cap));\n                    if(d > 0){\n                        e.cap -= d;\n                        G[e.to][e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n        int dfs_(int v, int t, int f){\n            if(v == t) return f;\n            for(int &i = iter[v]; i < G[v].size(); i++){\n                Edge &e = G[v][i];\n                if(e.cap > 0 && level[v] < level[e.to]){\n                    int d = dfs_(e.to, t, min(f, e.cap));\n                    if(d > 0){\n                        e.cap -= d;\n                        G[e.to][e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n        void bfs(int s){\n            memset(level, -1, sizeof(level));\n            queue<int> que;\n            level[s] = 0;\n            que.push(s);\n            while(not que.empty()){\n                int v = que.front(); que.pop();\n                rep(i,G[v].size()){\n                    Edge &e = G[v][i];\n                    if(e.cap > 0 && level[e.to] < 0){\n                        level[e.to] = level[v] + 1;\n                        que.push(e.to);\n                    }\n                }\n            }\n        }\n    public:\n        void addEdge(int from, int to, int cap){\n            G[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n            G[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n        }\n        int fordFulkerson(int s, int t){\n            int flow = 0;\n            while(true){\n                memset(used, 0, sizeof(used));\n                int f = dfs(s, t, INF);\n                if(f == 0) return flow;\n                flow += f;\n            }\n        }\n        int dinic(int s, int t){\n            int flow = 0;\n            while(true){\n                bfs(s);\n                if(level[t] < 0) return flow;\n                memset(iter, 0, sizeof(iter));\n                int f;\n                while( (f = dfs_(s, t, INF)) > 0){\n                    flow += f;\n                }\n            }\n        }\n};\n\nint gcd(int x, int y) {\n    int r;\n    if(x < y) swap(x, y);\n\n    while(y > 0){\n        r = x % y;\n        x = y;\n        y = r;\n    }\n    return x;\n}\n\nbool isCoprime(int a, int b){\n    return (gcd(a,b) == 1 ? true : false);\n}\n\nint main(){\n    int m,n;\n    while(cin >> m >> n,m){\n        int b[505], r[505];\n        rep(i,m) cin >> b[i];\n        rep(i,n) cin >> r[i];\n\n        //0~m-1, m~m+n-1, m+n, m+n+1\n        Flow ob;\n        rep(i,m){\n            rep(j,n){\n                if(not isCoprime(b[i], r[j])){\n                    ob.addEdge(i,m + j,1);\n                }\n            }\n        }\n\n        int s = m + n, t = s + 1;\n        rep(i,m) ob.addEdge(s,i,1);\n        rep(i,n) ob.addEdge(m + i,t,1);\n\n        cout << ob.fordFulkerson(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nconst int SIZE = 1005;\nint parent[SIZE];\nint maxflow(int capacity[SIZE][SIZE], int s, int e, int size) {\n  int ans = 0;\n  while (true) {\n    memset(parent, -1, sizeof(parent));\n    queue<int> que;\n    que.push(s);\n    parent[s] = s;\n    while (!que.empty()) {\n      int from = que.front();\n      que.pop();\n      if (from == e) { break; }\n      for (int to = 0; to < size; to++) {\n        if (capacity[from][to] == 0 || parent[to] != -1) { continue; }\n        parent[to] = from;\n        que.push(to);\n      }\n    }\n    if (parent[e] == -1) { break; }\n    int flow = 2000000000;\n    int from = parent[e];\n    int to = e;\n    while (from != to) {\n      flow = min(flow, capacity[from][to]);\n      from = parent[from];\n      to = parent[to];\n    }\n    from = parent[e];\n    to = e;\n    while (from != to) {\n      capacity[from][to] -= flow;\n      capacity[to][from] += flow;\n      from = parent[from];\n      to = parent[to];\n    }\n    ans += flow;\n  }\n  return ans;\n}\n\nint gcd(int a, int b) {\n  if (b == 0) { return a; }\n  return gcd(b, a % b);\n}\n\nint m, n;\nint capacity[SIZE][SIZE];\nint blue[501];\nint red[501];\n\nint BLUE(int x) { return x; }\nint RED(int x) { return m + x; }\nint SOURCE() { return m + n; }\nint DEST() { return m + n + 1; }\n\nint main() {\n  while (scanf(\"%d %d\", &m, &n), m|n) {\n    REP(i, m) { scanf(\"%d\", &blue[i]); }\n    REP(i, n) { scanf(\"%d\", &red[i]); }\n    MEMSET(capacity, 0);\n    REP(b, m) {\n      REP(r, n) {\n        if (gcd(blue[b], red[r]) != 1) {\n          capacity[BLUE(b)][RED(r)] = 1;\n        }\n        capacity[RED(r)][DEST()] = 1;\n      }\n      capacity[SOURCE()][BLUE(b)] = 1;\n    }\n    int ans = maxflow(capacity, SOURCE(), DEST(), m + n + 2);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int x, int y){return y?gcd(y,x%y):x;}\n\nint card[1000];\nint tree[2048][2];\nvoid treeinit(){\n\tfor(int i=0;i<1010;i++)tree[1024+i][1]=i;\n}\nvoid update(int pos){\n\tif(1024<=pos){\n\t\tupdate(pos/2);\n\t}\n\tif(1<=pos && pos<1024){\n\t\tint a=pos*2,b=pos*2+1;\n\t\tif(tree[b][0]==0){\n\t\t\ttree[pos][0]=tree[a][0];\n\t\t\ttree[pos][1]=tree[a][1];\n\t\t}\n\t\telse if(tree[a][0]==0){\n\t\t\ttree[pos][0]=tree[b][0];\n\t\t\ttree[pos][1]=tree[b][1];\n\t\t}\n\t\telse if(tree[a][0]>tree[b][0]){\n\t\t\ttree[pos][0]=tree[b][0];\n\t\t\ttree[pos][1]=tree[b][1];\n\t\t}\n\t\telse{\n\t\t\ttree[pos][0]=tree[a][0];\n\t\t\ttree[pos][1]=tree[a][1];\n\t\t}\n\t\tupdate(pos/2);\n\t}\n}\n\n\n\nint main(){\n\ttreeinit();\n\t\n\tfor(int m,n;cin>>m>>n,m;){\n\t\tint ans=0;\n\t\tfor(int i=0;i<1000;i++)card[i]=0;\n\t\tfor(int i=0;i<m;i++)cin>>card[i];\n\t\tfor(int i=0;i<n;i++)cin>>card[500+i];\n\t\tvector<int>V[1000];\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(gcd(card[i],card[500+j])==1)continue;\n\t\t\t\tV[i].push_back(500+j);\n\t\t\t\tV[500+j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<1000;i++){\n\t\t\ttree[1024+i][0]=V[i].size();\n\t\t\tupdate(1024+i);\n\t\t}\n\t\twhile(tree[1][0]){\n\t\t\tint pos=tree[1][1];\n\t\t\tint tmpos=-1;\n\t\t\tint tmp=9999;\n\t\t\tfor(int i=0;i<V[pos].size();i++){\n\t\t\t\tint t=tree[1024+V[pos][i]][0];\n\t\t\t\tif(t==0)continue;\n\t\t\t\tif(t<tmp){\n\t\t\t\t\ttmp=t;\n\t\t\t\t\ttmpos=V[pos][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout<<pos<<\"(\"<<card[pos]<<\") \"<<tmpos<<\"(\"<<card[tmpos]<<\") \"<<endl;\n\t\t\tans++;\n\t\t\tfor(int i=0;i<V[pos].size();i++){\n\t\t\t\tif(tree[1024+V[pos][i]][0]==0)continue;\n\t\t\t\ttree[1024+V[pos][i]][0]--;\n\t\t\t\tupdate(1024+V[pos][i]);\n\t\t\t}\n\t\t\tfor(int i=0;i<V[tmpos].size();i++){\n\t\t\t\tif(tree[1024+V[tmpos][i]][0]==0)continue;\n\t\t\t\ttree[1024+V[tmpos][i]][0]--;\n\t\t\t\tupdate(1024+V[tmpos][i]);\n\t\t\t}\n\t\t\ttree[1024+pos][0]=0;\n\t\t\tupdate(1024+pos);\n\t\t\ttree[1024+tmpos][0]=0;\n\t\t\tupdate(1024+tmpos);\n\t\t\t\n\t\t}\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nint gcd(int a, int b){\n    return b ? gcd(b, a%b) : a;\n}\n\nclass BipartiteGraph{\nprivate:\n    int lV, rV;\n    int V;\n    vector<vector<int> > G;\n    vector<int> match;\n    vector<bool> used;\n    \n    bool dfs(int v){\n        used[v] = true;\n        for(int i=0; i<G[v].size(); i++){\n            int u = G[v][i], w = match[u];\n            if(w < 0 || (!used[w] && dfs(w))){\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\npublic:\n    BipartiteGraph(int _lV, int _rV): lV(_lV), rV(_rV){\n        V = rV + lV;\n        G.resize(V);\n        match.resize(V);\n        used.resize(V);\n    }\n    \n    void add_edge(int l, int r){\n        r += lV;\n        G[l].push_back(r);\n        G[r].push_back(l);\n    }\n    \n    int max_matching(){\n        fill(match.begin(), match.end(), -1);\n        int res = 0;\n        for(int i=0; i<lV; i++){\n            if(match[i] < 0){\n                fill(used.begin(), used.end(), false);\n                res += dfs(i);\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int N, M;\n    while(cin>>N>>M, N|M){\n        vector<int> blues(N);\n        vector<int> reds(M);\n        for(auto &b: blues)\n            cin >> b;\n        for(auto &r: reds)\n            cin >> r;\n        \n        auto bipartite_graph = BipartiteGraph(N, M);\n        for(int i=0; i<N; i++)\n            for(int j=0; j<M; j++)\n                if(gcd(blues[i], reds[j]) != 1)\n                    bipartite_graph.add_edge(i, j);\n        \n        cout << bipartite_graph.max_matching() << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<int> blue;\nvector<int> red;\nvector<int> redpair;\nvector<int> v;\nvector<vector<int> > c;\nint m = 0;\nint n = 0;\n\nint gcd(int x,int y){\n    if(x % y == 0){\n        return y;\n    }\n    return gcd(y,x%y);\n}\n\nbool match(int x){\n    if(x == -1){\n        return 1;\n    }\n    for(int i = 0;i < n;i++){\n        if(c[x][i] == 1 && v[i] == 0){\n            v[i] = 1;\n            if(match(redpair[i])){\n                redpair[i] = x;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nint main(){\n    while(cin >> m >> n){\n        if(m == 0 && n == 0){\n            break;\n        }\n        blue.clear();\n        red.clear();\n        redpair.clear();\n        v.clear();\n        c.clear();\n        for(int i = 0;i < m;i++){\n            int tmp;\n            cin >> tmp;\n            blue.push_back(tmp);\n        }\n        for(int i = 0;i < n;i++){\n            int tmp;\n            cin >> tmp;\n            red.push_back(tmp);\n            redpair.push_back(-1);\n            v.push_back(0);\n        }\n        for(int i = 0;i < m;i++){\n            c.push_back(vector<int>());\n            for(int j = 0;j < n;j++){\n                c[i].push_back(gcd(blue[i],red[j]) != 1);\n            }\n        }\n        int ans = 0;\n        for(int i = 0;i < m;i++){\n            for(int j = 0;j < n;j++){\n                v[j] = 0;\n            }\n            if(match(i)){\n                ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint m,n;\n\nvector<int> G[500];\nbool vis[500];\nint match[500];\nint bl[500];\nint re[500];\n\nbool augment(int v){\n  vis[v] = true;\n  FOR(it,G[v]){\n    if(match[*it]==-1 ||\n       (!vis[match[*it]] && augment(match[*it]))){\n      match[*it]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid solve(){\n  rep(i,m) G[i].clear();\n  rep(i,m) cin >> bl[i];\n  rep(i,n) cin >> re[i];\n  rep(i,m) rep(j,n) if(__gcd(bl[i],re[j])!=1) G[i].pb(j);\n  memset(match,-1,sizeof(match));\n  int ans=0;\n  rep(i,m){\n    CLR(vis);\n    ans += augment(i);\n  }\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> m >> n && m) solve();\n}  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e9\nusing namespace std;\n\ttypedef struct edge{\n\tint to,cap,rev;\n\t}edge;\nvoid add_edge(int from,int to,int cap,vector<vector<edge> > &g){\n\tedge f,t;\n\tf = (edge){to,cap,(int)g[to].size()};\n\tg[from].push_back(f);\n\tt = (edge){from,0,(int)g[from].size()-1};\n\tg[to].push_back(t);\n}\nint dfs(int v,int t,int f,vector<vector<edge> > &g,vector<bool> &used){\n\tif(v==t)return f;\n\tused[v] = true;\n\tfor(int i=0;i<g[v].size();i++){\n\t\tedge &e = g[v][i];\n\t\tif(!used[e.to]&&e.cap>0){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap),g,used);\n\t\t\tif(d>0){\n\t\t\t\te.cap -=d;\n\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t,vector<vector<edge> > &g){\n\tint flow=0;\n\twhile(1){\n\t\tvector<bool>  used(g.size(),false);\n\t\tint f = dfs(s,t,INF,g,used);\n\t\tif(f==0) return flow;\n\t\tflow+=f;\n\t}\n}\n\nint gcd(int a,int b){\nif(b==0)return a;\nelse return gcd(b,a%b);\n}\nint main(){\n\twhile(1){\n\tint n,m;\n\tcin>>m>>n;\n\tif(m==0)break;\n\tvector<int> b(m),r(n);\n\tfor(int i=0;i<m;i++)cin>>b[i];\n\tfor(int i=0;i<n;i++)cin>>r[i];\n\tvector<vector<edge> > g(n+m+2);\n\tfor(int i=0;i<m;i++) add_edge(0,i+1,1,g);\n\tfor(int i=0;i<n;i++) add_edge(m+i+1,m+n+1,1,g);\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(gcd(b[i],r[j])!=1)add_edge(i+1,1+m+j,1,g);\n\t\t}\n\t}\n\tcout<<max_flow(0,m+n+1,g)<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_V = 10000;\nconst int INF = 100000000;\n\n// ¸_\nint V;\n// OtÌXg\\»\nvector<int> G[MAX_V];\n// }b`OÌyA\nint match[MAX_V];\n// dfsÅ·ÅÉ²×½©Ç¤©ÌtO\nstatic bool used[MAX_V];\n\n// uÆvðÔÓðOtÉÇÁ\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\n// ÁpXðdfsÅT·\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i],w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// ñOtÌÅå}b`Oðßé\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\t//for(int i = 0; i < sizeof(match); i++){\n\t//\tif(i==sizeof(match)-1){\n\t//\t\tcout<<endl;\n\t//\t}\n\t//\tmatch[i] = -1;\n\t//}\n\tfor(int v = 0; v < V; v++){\n\t\tif(match[v] < 0){\n\t\t\tfor(int i = 0; i < sizeof(used); i++)\n\t\t\t\tused[i] = 0;\n//\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int a,int b){\n\tif(b==0)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\n\n\nint main(){\n\n\tint n,m;\n\twhile(cin>>m>>n&&!(m==0&&n==0)){\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\tG[i].clear();\n\n\t\tvector<int> bs,rs;\n\t\tint b,r;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin>>b;\n\t\t\tbs.push_back(b);\n\t\t\tV++;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>r;\n\t\t\trs.push_back(r);\n\t\t\tV++;\n\t\t}\n\t\tfor(int i = 0; i < rs.size(); i++){\n\t\t\tfor(int j = 0;j < bs.size(); j++){\n\t\t\t\tint res=gcd(rs[i],bs[j]);\n\t\t\t\tif(res!=1)\n\t\t\t\t\tadd_edge(i,j+rs.size());\n\t\t\t}\n\t\t}\n\t\tcout<<bipartite_matching()<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 4444\nvector<int> v[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int a,int b){\n\tv[a].PB(b);\n\tv[b].PB(a);\n}\n\nbool matchdfs(int a){\n\tused[a] = true;\n\tfor(int i = 0;i < v[a].size();i++)\t{\n\t\tint u = v[a][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w)){\n\t\t\tmatch[u] = a;\n\t\t\tmatch[a] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//二部マッチング\nint two_matching_max(int l){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<int> prime;\n#define HOGE 111111\nbool isp[111111];\nvoid f(){\n\tREP(i,111111)isp[i] = true;\n\tisp[0] = isp[1] = false;\n\tfor(int i = 2;i < 111111;i++){\n\t\tif(isp[i]){\n\t\t\tprime.PB(i);\n\t\t\tfor(int j = i;j < 111111;j+=i)isp[j] = false;\n\t\t}\n\t}\n}\n\t\n#define HALF 1000\nint main(){\n\tf();\n\tint n,m;\n\twhile(cin >> m >> n,n|m){\n\t\tREP(i,MAX_V)v[i].clear();\n\t\tvector<int> a(m);REP(i,m)cin >> a[i];\n\t\tvector<int> b(n);REP(i,n)cin >> b[i];\n\t\tREP(i,m){\n\t\t\tvector<int> tmp;\n\t\t\tREP(j,prime.size()){\n\t\t\t\tif(a[i] % prime[j] == 0)tmp.PB(prime[j]);\n\t\t\t}\n\t\t\tREP(j,n){\n\t\t\t\tREP(k,tmp.size()){\n\t\t\t\t\tif(b[j] % tmp[k] == 0){\n\t\t\t\t\t\tadd_edge(i,j + 1000);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << two_matching_max(MAX_V) << endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define inf 1000000007\n#define rep(i, n) for(int i = 0; i < n; i++)\n\ntypedef long long ll;\n\nclass path {\npublic:\n  int t;\n  ll c;\n  int p;\n};\n\nclass dinic {\npublic:\n  int n;\n  vector<path> p;\n  vector<int>* v;\n  int* l;\n  int* o;\n  dinic(int nw) {\n    n = nw;\n    v = new vector<int>[n];\n    l = new int[n];\n    o = new int[n];\n  }\n  void add(int from, int to, ll cap) {\n    assert(from < n);\n    assert(to < n);\n    path w1, w2;\n    w1.t = to;\n    w1.c = cap;\n    w1.p = p.size() + 1;\n    v[from].push_back(p.size());\n    w2.t = from;\n    w2.c = 0;\n    w2.p = p.size();\n    v[to].push_back(p.size() + 1);\n    p.push_back(w1);\n    p.push_back(w2);\n  }\n  void dics(int from) {\n    rep(i, n) {\n      l[i] = inf;\n    }\n    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\n    pq.push(make_pair(0, from));\n    while(!pq.empty()) {\n      int k = pq.top().first;\n      int m = pq.top().second;\n      pq.pop();\n      if(l[m] > k) {\n        l[m] = k;\n        rep(i, v[m].size()) {\n          int x = v[m][i];\n          if(p[x].c > 0) {\n            pq.push(make_pair(k + 1, p[x].t));\n          }\n        }\n      }\n    }\n  }\n  ll dfs(int now, int to, ll mi) {\n    if(now == to) {\n      return mi;\n    }\n    ll all = 0;\n    while(o[now] < v[now].size()) {\n      int x = v[now][o[now]];\n      if(l[p[x].t] == l[now] + 1) {\n        ll w = dfs(p[x].t, to, min(mi - all, p[x].c));\n        p[x].c -= w;\n        p[p[x].p].c += w;\n        all += w;\n        if(mi - all == 0) {\n          break;\n        }\n      }\n      o[now]++;\n    }\n    return all;\n  }\n  ll solve(int from, int to) {\n    assert(from < n);\n    assert(to < n);\n    ll all = 0;\n    while(1) {\n      dics(from);\n      rep(i, n) {\n        o[i] = 0;\n      }\n      ll w = dfs(from, to, inf);\n      all += w;\n      if(w == 0) {\n        break;\n      }\n    }\n    return all;\n  }\n  ~dinic() {\n    delete[] v;\n    delete[] l;\n    delete[] o;\n  }\n};\n\nll gcd(ll a, ll b) {\n  if(b % a == 0) {\n    return a;\n  }\n  else {\n    return gcd(b % a, a);\n  }\n}\n\nll nd[1000], md[1000];\n\nint main() {\n  while(1) {\n    int n, m;\n    scanf(\"%d%d\",&n,&m);\n    if(n == 0) {\n      break;\n    }\n    rep(i, n) {\n      scanf(\"%lld\", nd + i);\n    }\n    rep(i, m) {\n      scanf(\"%lld\", md + i);\n    }\n    dinic s(2 + n + m);\n    rep(i, n) {\n      s.add(n + m, i, 1);\n    }\n    rep(i, m) {\n      s.add(n + i, n + m + 1, 1);\n    }\n    rep(i, n) {\n      rep(j, m) {\n        if(gcd(nd[i], md[j]) > 1) {\n          s.add(i, n + j, 1);\n        }\n      }\n    }\n    printf(\"%lld\\n\", s.solve(n + m, n + m + 1));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define REP(i,n) for(int i=0;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(v) (v).begin(),(v).end()\n#define all(v) ALL(v)\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n#define CININIT cin.tie(0),ios::sync_with_stdio(false)\nstruct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n\nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nclass FordFulkerson{\n    private:\n        struct edge{\n            int to,cap,rev;\n            edge(){}\n            edge(int t,int c,int r) : to(t),cap(c),rev(r){}\n        };\n        vector<vector<edge>> G;\n        vector<bool> used;\n    public:\n        FordFulkerson(int maxv) : G(maxv) , used(maxv,false){}\n        void add_edge(int from,int to,int cap){\n            G[from].push_back(edge(to,cap,G[to].size()));\n            G[to].push_back(edge(from,0,G[from].size()-1));\n        }\n        int dfs(int v,int t,int f){\n            if(v==t) return f;\n            used[v]=true;\n            for(int i=0;i<G[v].size();i++){\n                edge &e=G[v][i];\n                if(!used[e.to] && e.cap>0){\n                    int d=dfs(e.to,t,min(f,e.cap));\n                    if(d>0){\n                        e.cap -= d;\n                        G[e.to][e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n        int maxflow(int s,int t){\n            int flow=0;\n            while(1){\n                fill(used.begin(),used.end(),false);\n                int f=dfs(s,t,INF);\n                if(f==0) return flow;\n                flow+=f;\n            }\n        }\n};\n\nvoid solve(int n,int m){\n    int s=n+m,t=s+1;\n    FordFulkerson f(n+m+2);\n\n    vector<int> blue(n),red(m);\n    rep(i,n) cin>>blue[i];\n    rep(i,m) cin>>red[i];\n\n    for(int i=0;i<n;i++){\n        f.add_edge(s,i,1);\n    }\n    for(int i=0;i<m;i++){\n        f.add_edge(i+n,t,1);\n    }\n\n\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            int g=gcd(blue[i],red[j]);\n            if(g!=1){\n                f.add_edge(i,n+j,1);\n            }\n        }\n    }\n\n    int ans = f.maxflow(s,t);\n    cout << ans << endl;\n}\n\nint main(){\n    int n,m;\n    while(cin>>n>>m){\n        if(n==0 && m==0) break;\n        solve(n,m);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<list>\nint F(int x,int y)\n{\n\tif(!y)return x;\n\treturn F(y,x%y);\n}\ntypedef std::list<int>L;\nL e[1002];\nint m,n;\nbool f[1002];\nint G(int s,int d)\n{\n\tif(s==d)return 1;\n\tif(f[s])return 0;\n\tf[s]=1;\n\tfor(L::iterator i=e[s].begin();i!=e[s].end();++i)\n\t{\n\t\tif(G(*i,d))\n\t\t{\n\t\t\te[*i].push_back(s);\n\t\t\te[s].erase(i);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint a[100],i,j,x;\n\twhile(scanf(\"%d%d\",&m,&n),m)\n\t{\n\t\tfor(i=0;i<m+n+2;++i)e[i].clear();\n\t\tfor(i=0;i<m;++i)scanf(\"%d\",&a[i]),e[m+n].push_back(i);\n\t\tfor(j=0;j<n;++j)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tfor(i=0;i<m;++i)if(F(a[i],x)>1)e[i].push_back(m+j);\n\t\t\te[m+j].push_back(m+n+1);\n\t\t}\n\t\tfor(x=0;memset(f,0,sizeof(f)),G(m+n,m+n+1);)++x;\n\t\tprintf(\"%d\\n\",x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\nconst int SIZE = 502;\nint parent[SIZE];\nint maxflow(int capacity[SIZE][SIZE], int s, int e, int size) {\n  int ans = 0;\n  while (true) {\n    memset(parent, -1, sizeof(parent));\n    queue<int> que;\n    que.push(s);\n    parent[s] = s;\n    while (!que.empty()) {\n      int from = que.front();\n      que.pop();\n      if (from == e) { break; }\n      for (int to = 0; to < size; to++) {\n        if (capacity[from][to] == 0 || parent[to] != -1) { continue; }\n        parent[to] = from;\n        que.push(to);\n      }\n    }\n    if (parent[e] == -1) { break; }\n    int flow = 2000000000;\n    int from = parent[e];\n    int to = e;\n    while (from != to) {\n      flow = min(flow, capacity[from][to]);\n      from = parent[from];\n      to = parent[to];\n    }\n    from = parent[e];\n    to = e;\n    while (from != to) {\n      capacity[from][to] -= flow;\n      capacity[to][from] += flow;\n      from = parent[from];\n      to = parent[to];\n    }\n    ans += flow;\n  }\n  return ans;\n}\n\nint gcd(int a, int b) {\n  if (b == 0) { return a; }\n  return gcd(b, a % b);\n}\n\nint m, n;\nint capacity[502][502];\nint blue[501];\nint red[501];\n\nint BLUE(int x) { return x; }\nint RED(int x) { return m + x; }\nint SOURCE() { return m + n; }\nint DEST() { return m + n + 1; }\n\nint main() {\n  while (scanf(\"%d %d\", &m, &n), m|n) {\n    REP(i, m) { scanf(\"%d\", &blue[i]); }\n    REP(i, n) { scanf(\"%d\", &red[i]); }\n    MEMSET(capacity, 0);\n    REP(b, m) {\n      REP(r, n) {\n        if (gcd(blue[b], red[r]) != 1) {\n          capacity[BLUE(b)][RED(r)] = 1;\n        }\n        capacity[RED(r)][DEST()] = 1;\n      }\n      capacity[SOURCE()][BLUE(b)] = 1;\n    }\n    int ans = maxflow(capacity, SOURCE(), DEST(), m + n + 2);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 1000000\n#define INF 1e9\n\nint gcd(int a, int b){\n\n    if(b == 0) return a;\n    else return gcd(b, (a % b));\n}\n\n//辺を表す構造体　(行先、容量、逆辺の場所)\nstruct edge{\n    int to, cap, rev;\n};\n\n//vector<vector<edge> > G(MAX_V);       //グラフの隣接リスト表現\nbool used[MAX_V];                    //DFSですでに調べたかのグラフ\n\n\n// from から to へ向かう容量 cap の辺をグラフに張る\nvoid add_edge(int from, int to, int cap, vector<vector<edge> >& G){\n\n    edge F;\n    edge T;\n    F.to = to;\n    F.cap = cap;\n    F.rev = G[to].size();\n    G[from].push_back(F);\n\n    T.to = from;\n    T.cap = 0;\n    T.rev = G[from].size() - 1;\n    G[to].push_back(T);    \n}\n\n//増加パスをDFSで探す\nint dfs(int v, int t, int f, vector<vector<edge> >& G){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        edge &e = G[v][i];                          //すごい\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap), G);\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;            //もっとすごい\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n//s から t への最大流を求める\nint max_flow(int s, int t, vector<vector<edge> >& G){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF, G);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(){\n    \n    while(1){\n\n        int m, n; cin >> m >> n;\n        if(!m) break;\n  \n        vector<vector<edge> > G(MAX_V);\n        vector<int> b(m);\n        vector<int> r(n);\n        for(int i = 0; i < m; i++) cin >> b[i];\n        for(int i = 0; i < n; i++) cin >> r[i];\n\n        //入力\n        //xはuに属する\n        //yはvに属する\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(gcd(b[i], r[j]) != 1){\n                    int x = i + 1;\n                    int y = j + 1;\n                    y += m;\n                    add_edge(x, y, 1, G);\n                }\n            }\n        }\n\n        for(int i = 1; i <= m; i++) add_edge(0, i, 1, G);\n        for(int i = m + 1; i <= m + n; i++) add_edge(i, m + n + 1, 1, G);\n        \n        cout << max_flow(0, m + n + 1, G) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <unordered_set>\n#include <algorithm>\n#undef max\n#undef min\n\nint euclideanAlgorithm(int m, int n) {\n\tint a = std::max(m, n) % std::min(m, n);\n\treturn a ? euclideanAlgorithm(std::min(m, n), a) : std::min(m, n);\n}\n\nint solve(int s, int t, std::vector<std::vector<int>> residualNet) {\n\tint sum = 0;\n\twhile (1) {\n\t\tbool isOk = false;\n\t\tstd::vector<int> route; // 辿ってきた道\n\t\tstd::unordered_set<int> visited;\n\t\troute.push_back(s);\n\n\t\t// 経路探索\n\t\twhile (!route.empty() && !isOk) {\n\t\t\tbool isMoved = false;\n\t\t\tauto pos = route.back();\n\n\t\t\t// 移動先を検索\n\t\t\tfor (int next = 1; next < residualNet[pos].size(); next++) {\n\t\t\t\tif (!residualNet[pos][next]) continue;\n\t\t\t\tif (visited.count(next)) continue;\n\t\t\t\tif (next == t) {\n\t\t\t\t\tisOk = true;\n\t\t\t\t\tisMoved = true;\n\t\t\t\t\troute.push_back(next);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// 次のところへ移動\n\t\t\t\tisMoved = true;\n\t\t\t\troute.push_back(next);\n\t\t\t\tvisited.insert(next);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!isMoved) route.pop_back();\n\t\t}\n\n\t\t// 増加路無し\n\t\tif (route.empty()) {\n\t\t\tbreak;\n\t\t}\n\n\t\t// 増加路あり\n\t\tint min = 999999;\n\t\tfor (int i = 0; i < route.size() - 1; i++) {\n\t\t\tmin = std::min(min, residualNet[route[i]][route[i + 1]]);\n\t\t}\n\t\tsum += min;\n\t\t// 残余ネットワーク更新\n\t\tfor (int i = 0; i < route.size() - 1; i++) {\n\t\t\tresidualNet[route[i]][route[i + 1]] -= min;\n\t\t\tresidualNet[route[i + 1]][route[i]] += min;\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main() {\n\tint n, m;\n\tint sum = 0;\n\twhile (std::cin >> m >> n && m && n) {\n\t\tstd::vector<int> red, blue;\n\t\tstd::vector<std::vector<int>> residualNet(n + m + 2, std::vector<int>(n + m + 2, 0)); // +2はスタートとゴール分\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint b; std::cin >> b;\n\t\t\tblue.push_back(b);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint b; std::cin >> b;\n\t\t\tred.push_back(b);\n\t\t}\n\n\t\t// ペア作成\n\t\tfor (int i = 0; i < blue.size(); i++) {\n\t\t\tfor (int j = 0; j < red.size(); j++) {\n\t\t\t\tint a = euclideanAlgorithm(blue[i], red[j]);\n\t\t\t\tif (a > 1) {\n\t\t\t\t\tresidualNet[i + 1][m + j + 1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// スタートと青を接続\n\t\tfor (int i = 0; i < blue.size(); i++) {\n\t\t\tresidualNet[0][i + 1] = 1;\n\t\t}\n\t\t// 赤とゴールを接続\n\t\tfor (int i = 0; i < red.size(); i++) {\n\t\t\tresidualNet[m + i + 1][m + n + 1] = 1;\n\t\t}\n\n\t\tstd::cout << solve(0, m + n + 1, residualNet) << std::endl;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX_V=1050;\nconst int INF=1e9;\n\nstruct edge{\n    int to,cap,rev;\n    edge(int to=0,int cap=0,int rev=0)\n        :to(to),cap(cap),rev(rev){}\n};\n\nvector<edge>G[MAX_V];\nbool used[MAX_V];\n\nvoid init(){\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n}\n\nvoid add_edge(int from,int to,int cap){\n    G[from].push_back(edge(to,cap,G[to].size()));\n    G[to].push_back(edge(from,0,G[from].size()-1));\n}\n\nint dfs(int v,int t,int f){\n    if(v==t)return f;\n    used[v]=true;\n\n    for(int i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(e.cap==0||used[e.to])continue;\n        int d=dfs(e.to,t,min(f,e.cap));\n        if(d){\n            e.cap-=d;\n            G[e.to][e.rev].cap+=d;\n            return d;\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int flow=0;\n    while(true){\n        fill_n(used,MAX_V,false);\n        int f=dfs(s,t,INF);\n        if(f)flow+=f;\n        else return flow;\n    }\n}\n\nint main(){\n    int S=1000,T=1001;\n    int n,m;\n    while(cin>>n>>m,n||m){\n        init();\n\n        vector<int>a(n),b(m);\n        for(int i=0;i<n;i++)cin>>a[i];\n        for(int i=0;i<m;i++)cin>>b[i];\n\n        for(int i=0;i<n;i++)add_edge(S,i,1);\n        for(int i=0;i<m;i++)add_edge(i+n,T,1);\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(__gcd(a[i],b[j])==1)continue;\n                add_edge(i,j+n,1);\n            }\n        }\n\n        cout<<max_flow(S,T)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<stack>\n#include<string>\n#include<algorithm>\n#include<functional>\n#include<cstring>\n#include<complex>\n#include<bitset>\n#include<iostream>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> Q;\ntypedef complex<double> C;\n#define cx real()\n#define cy imag()\nconst ll INF = 1LL << 60;\nconst double DINF = 1e30;\nconst ll mod = 1000000007;\nconst ll dx[4] = {1, 0, -1, 0};\nconst ll dy[4] = {0, -1, 0, 1};\nconst C I = C(0, 1);\nconst double EPS = 1e-10;\nconst ll NCK_MAX = 510000;\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y) {\n  if (b == 0) {\n    x = 1, y = 0; return a;\n  }\n  ll q = a/b, g = extgcd(b, a - q*b, x, y);\n  ll z = x - q * y;\n  x = y;\n  y = z;\n  return g;\n}\n\nll invmod (ll a, ll m) { // a^-1 mod m\n  ll x, y;\n  extgcd(a, m, x, y);\n  x %= m;\n  if (x < 0) x += m;\n  return x;\n}\n\nll *fac, *finv, *inv;\n\nvoid nCk_init(ll mod) {\n  fac = new ll[NCK_MAX];\n  finv = new ll[NCK_MAX];\n  inv = new ll[NCK_MAX];\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (ll i = 2; i < NCK_MAX; i++) {\n    fac[i] = fac[i-1] * i % mod;\n    inv[i] = mod - inv[mod%i] * (mod / i) % mod;\n    finv[i] = finv[i-1] * inv[i] % mod;\n  }\n}\n\nll nCk(ll n, ll k, ll mod) {\n  if (fac == NULL) nCk_init(mod);\n  if (n < k) return 0;\n  if (n < 0 || k < 0) return 0;\n  return fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\ntemplate <typename T>\nclass Zip {\n  vector<T> d;\n  bool flag;\n  void init() {\n    sort(d.begin(), d.end());\n    d.erase(unique(d.begin(), d.end()), d.end());\n    flag = false;\n  }\npublic:\n  Zip() {\n    flag = false;\n  }\n  void add(T x) {\n    d.push_back(x);\n    flag = true;\n  }\n  ll getNum(T x) {\n    if (flag) init();\n    return lower_bound(d.begin(), d.end(), x) - d.begin();\n  }\n  ll size() {\n    if (flag) init();\n    return (ll)d.size();\n  }\n};\n\nclass UnionFind {\n  vector<ll> par, rank; // par > 0: number, par < 0: -par\npublic:\n  void init(ll n) {\n    par.resize(n); rank.resize(n);\n    fill(par.begin(), par.end(), 1); fill(rank.begin(), rank.end(), 0);\n  }\n  ll getSize(ll x) {\n    return par[find(x)];\n  }\n  ll find(ll x) {\n    if (par[x] > 0) return x;\n    return -(par[x] = -find(-par[x]));\n  }\n  void merge(ll x, ll y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) {\n      par[y] += par[x];\n      par[x] = -y;\n    } else {\n      par[x] += par[y];\n      par[y] = -x;\n      if (rank[x] == rank[y]) rank[x]++;\n    }\n  }\n  bool isSame(ll x, ll y) {\n    return find(x) == find(y);\n  }\n};\n\n\ntemplate <typename T>\nclass SegmentTree {\n  ll n;\n  vector<T> node;\n  function<T(T, T)> fun, fun2;\n  bool customChange;\n  T outValue, initValue;\npublic:\n  void init(ll num, function<T(T, T)> resultFunction, T init, T out, function<T(T, T)> changeFunction = NULL) {\n    // changeFunction: (input, beforevalue) => newvalue\n    fun = resultFunction;\n    fun2 = changeFunction;\n    customChange = changeFunction != NULL;\n    n = 1;\n    while (n < num) n *= 2;\n    node.resize(2 * n - 1);\n    fill(node.begin(), node.end(), init);\n    outValue = out;\n    initValue = init;\n  }\n  void valueChange(ll num, T value) {\n    num += n-1;\n    if (customChange) node[num] = fun2(value, node[num]);\n    else node[num] = value;\n    while (num > 0) num = (num - 1) / 2, node[num] = fun(node[num * 2 + 1], node[num * 2 + 2]);\n  }\n  T rangeQuery(ll a, ll b, ll l = 0, ll r = -1, ll k = 0) { // [a, b)\n    if (r == -1) r = n;\n    if (a <= l && r <= b) return node[k];\n    if (b <= l || r <= a) return outValue;\n    ll mid = (l + r) / 2;\n    return fun(rangeQuery(a, b, l, mid, 2*k+1), rangeQuery(a, b, mid, r, 2*k+2));\n  }\n};\n\ntemplate <typename T>\nclass Graph {\n  struct edge { ll to; T cost; };\n  struct edge_data { ll from, to; T cost; };\n\n  ll v;\n  vector<vector<edge>> e, re;\n  vector<edge_data> ed;\n  vector<bool> used;\n  vector<ll> vs, cmp;\n  bool isDirected, isMinasEdge;\npublic:\n  Graph(ll _v, bool _isDirected = true) {\n    //_v++;\n    v = _v, isDirected = _isDirected; isMinasEdge = false;\n    e.resize(v), re.resize(v);\n  }\n  void add_edge(ll s, ll t, T cost = 1) {\n    e[s].push_back((edge){t, cost});\n    if (!isDirected) e[t].push_back((edge){s, cost});\n    else re[t].push_back((edge){s, cost});\n    ed.push_back((edge_data){s, t, cost});\n    if (cost < 0) isMinasEdge = true;\n  }\n  vector<T> dijkstra(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    auto edge_cmp = [](const edge& a, const edge& b) { return a.cost > b.cost; };\n    priority_queue<edge, vector<edge>, decltype(edge_cmp)> pq(edge_cmp);\n    pq.push((edge){s, 0});\n    while (!pq.empty()) {\n      edge temp = pq.top(); pq.pop();\n      if (d[temp.to] < temp.cost) continue;\n      for (const edge& next : e[temp.to]) {\n        T cost = temp.cost + next.cost;\n        if (d[next.to] > cost) {\n          d[next.to] = cost;\n          pq.push((edge){next.to, cost});\n        }\n      }\n    }\n    return d;\n  }\n  vector<T> bellmanford(ll s) {\n    vector<T> d(v, INF);\n    d[s] = 0;\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = d[temp.from] + temp.cost;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = d[temp.to] + temp.cost;\n      }\n    }\n    for (ll i = 0; i < v; i++) {\n      for (const edge_data& temp : ed) {\n        if (d[temp.from] != INF && d[temp.to] > d[temp.from] + temp.cost) d[temp.to] = -INF;\n        if (!isDirected && d[temp.to] != INF && d[temp.from] > d[temp.to] + temp.cost) d[temp.from] = -INF;\n      }\n    }\n    return d;\n  }\n  vector<T> shortest_path(ll s) {\n    if (isMinasEdge) return bellmanford(s);\n    else return dijkstra(s);\n  }\n  T kruskal() {\n    // if (isDirected)\n    UnionFind uf;\n    uf.init(v);\n    auto edge_data_cmp = [](const edge_data& a, const edge_data& b) { return a.cost < b.cost; };\n    sort(ed.begin(), ed.end(), edge_data_cmp);\n    T ans = 0;\n    for (const edge_data& temp : ed) {\n      if (uf.isSame(temp.from, temp.to)) continue;\n      uf.merge(temp.from, temp.to);\n      ans += temp.cost;\n    }\n    return ans;\n  }\n  void scc_dfs(ll s) {\n    used[s] = true;\n    for (const edge& i : e[s]) if (!used[i.to]) scc_dfs(i.to);\n    vs.push_back(s);\n  }\n  void scc_rdfs(ll s, ll k) {\n    used[s] = true;\n    cmp[s] = k;\n    for (const edge& i : re[s]) if (!used[i.to]) scc_rdfs(i.to, k);\n  }\n  vector<ll> scc() {\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    cmp.resize(v);\n    vs.clear();\n    for (ll i = 0; i < v; i++) if (!used[i]) scc_dfs(i);\n    used.resize(v);\n    fill(used.begin(), used.end(), false);\n    ll k = 0;\n    for (ll i = vs.size() - 1; i >= 0; i--) if (!used[vs[i]]) scc_rdfs(vs[i], k++);\n    return cmp;\n  }\n};\n\ntemplate<typename T>\nclass Flow {\n  struct edge {\n    ll to; T cap; ll rev;\n  };\n\n  vector<vector<edge> > G;\n  vector<ll> level, iter;\n  bool isDirected;\npublic:\n  Flow(ll n, bool _isDirected = true) : G(n), level(n), iter(n), isDirected(_isDirected) {}\n\n  void add_edge(ll from, ll to, T cap) {\n    G[from].emplace_back((edge){to, cap, (ll)G[to].size()});\n    G[to].emplace_back((edge){from, isDirected ? 0LL : cap, (ll)G[from].size()-1});\n    //return G[to].back().rev;\n  }\n\n  void bfs(ll s) {\n    fill(level.begin(), level.end(), -1);\n    queue<ll> que;\n    level[s] = 0;\n    que.emplace(s);\n    while (!que.empty()) {\n      ll v=que.front(); que.pop();\n      for (ll i=0; i < (ll)G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v]+1;\n          que.emplace(e.to);\n        }\n      }\n    }\n  }\n\n  T dfs(ll v, ll t, T f) {\n    if (v == t) return f;\n    for (ll &i = iter[v]; i < (ll)G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (e.cap > 0 && level[v] < level[e.to]) {\n        T d = dfs(e.to, t, min(f, e.cap));\n        if (d == 0) continue;\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n    return 0;\n  }\n\n  T maxflow(ll s, ll t, T lim = INF) {\n    T fl = 0;\n    while (1) {\n      bfs(s);\n      if (level[t] < 0 || lim == 0) break;\n      fill(iter.begin(), iter.end(), 0);\n      while(1) {\n        T f = dfs(s, t, lim);\n        if(f == 0) break;\n        fl += f;\n        lim -= f;\n      }\n    }\n    return fl;\n  }\n};\n\nclass BipartiteMatching {\n  vector<ll> pre, root;\n  vector<vector<ll>> to;\n  vector<ll> p, q;\n  ll n, m;\npublic:\n  BipartiteMatching(ll n, ll m) : pre(n, -1), root(n, -1), to(n), p(n, -1), q(m, -1), n(n), m(m){}\n  void add(ll a, ll b) { to[a].push_back(b);}\n  ll solve() {\n    ll res = 0;\n    bool upd = true;\n    while (upd) {\n      upd = false;\n      queue<ll> s;\n      for (ll i = 0; i < n; ++i) {\n        if (!~p[i]) {\n          root[i] = i;\n          s.push(i);\n        }\n      }\n      while (!s.empty()) {\n        ll v = s.front(); s.pop();\n        if (~p[root[v]]) continue;\n        for (ll i = 0; i < (ll)to[v].size(); ++i) {\n          ll u = to[v][i];\n          if (!~q[u]) {\n            while (~u) {\n              q[u] = v;\n              swap(p[v],u);\n              v = pre[v];\n            }\n            upd = true;\n            ++res;\n            break;\n          }\n          u = q[u];\n          if (~pre[u]) continue;\n          pre[u] = v; root[u] = root[v];\n          s.push(u);\n        }\n      }\n      if (upd) fill(pre.begin(),pre.end(),-1), fill(root.begin(),root.end(),-1);\n    }\n    return res;\n  }\n};\n\nclass MinCostFlow {\npublic:\n  struct edge { ll to, cap, cost, rev; };\n\n  ll V;\n  vector<vector<edge> > G;\n  vector<ll> dist, prevv, preve, h;\n\n  MinCostFlow(ll v) : G(v), dist(v), prevv(v), preve(v), h(v) {\n    V = v;\n  }\n  void add_edge(ll from, ll to, ll cap, ll cost) {\n    G[from].push_back((edge){to, cap, cost, (ll)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (ll)G[from].size() - 1});\n  }\n  void add_undirected_edge(ll e1, ll e2, ll cap, ll cost) {\n    add_edge(e1, e2, cap, cost);\n    add_edge(e2, e1, cap, cost);\n  }\n  ll min_cost_flow(ll s, ll t, ll f) { // minas\n    ll res = 0;\n    while (f > 0) {\n      fill(dist.begin(), dist.end(), INF);\n      dist[s] = 0;\n      bool update = true;\n      while (update) {\n        update = false;\n        for (ll v = 0; v < V; v++) {\n          if (dist[v] == INF) continue;\n          for (ll i = 0; i < (ll)G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n              dist[e.to] = dist[v] + e.cost;\n              prevv[e.to] = v;\n              preve[e.to] = i;\n              update = true;\n            }\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      ll d = f;\n      for (ll v = t; v != s; v = prevv[v]) {\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * dist[t];\n      for (ll v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n  ll min_cost_flow_dijkstra(ll s, ll t, ll f) {\n    ll res = 0;\n    fill(h.begin(), h.end(), 0);\n    while (f > 0) {\n      priority_queue<P, vector<P>, greater<P> > que;\n      fill(dist.begin(), dist.end(), 0);\n      dist[s] = 0;\n      que.push(P(0, s));\n      while (!que.empty()) {\n        P p = que.top(); que.pop();\n        ll v = p.second;\n        if (dist[v] < p.first) continue;\n        for (ll i = 0; i < G[v].size(); i++) {\n          edge &e = G[v][i];\n          if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            que.push(P(dist[e.to], e.to));\n          }\n        }\n      }\n      if (dist[t] == INF) {\n        return -1;\n      }\n      for (ll v = 0; v < V; v++) h[v] += dist[v];\n      ll d = f;\n      for (ll v = t; v != s; v = prevv[v]) {\n        d = min(d, G[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d * h[t];\n      for (ll v = t; v != s; v = prevv[v]) {\n        edge &e = G[prevv[v]][preve[v]];\n        e.cap -= d;\n        G[v][e.rev].cap += d;\n      }\n      return res;\n    }\n    return 0;\n  }\n};\n\nll m, n, b[500], r[500];\n\nint main() {\n  while (scanf(\"%lld%lld\", &m, &n), m) {\n    for (ll i = 0; i < m; i++) scanf(\"%lld\", &b[i]);\n    for (ll i = 0; i < n; i++) scanf(\"%lld\", &r[i]);\n    BipartiteMatching bm(m, n);\n    for (ll i = 0; i < m; i++) for (ll j = 0; j < n; j++) if (gcd(b[i], r[j]) > 1) bm.add(i, j);\n    printf(\"%lld\\n\", bm.solve());\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<(o)<<\" \";}\n#define dumpl(o) if(DBG){cerr<<#o<<\" \"<<(o)<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\n\n//?????¨??°?????? O(f(N+M)) f????????§??????????????°?????°??§??????N\nclass BipartiteMatching {\npublic:\n\tint n;\n\tvector<vector<int>> g;\n\tvector<int> match;\n\tBipartiteMatching(int n) : n(n), g(n), match(n), used(n) {}\n\tvoid add_edge(int u, int v) {\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\t//?????§??????????????°\n\tint maximum_matching() {\n\t\tint ret = 0;\n\t\tfill(match.begin(), match.end(), -1);\n\t\tfor (int v = 0; v < n; v++) {\n\t\t\tif (match[v] == -1) {\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tif (dfs(v)) ret++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\nprivate:\n\tvector<int> used;\n\tbool dfs(int v) {\n\t\tused[v] = true;\n\t\tfor (int u : g[v]) {\n\t\t\tint w = match[u];\n\t\t\tif (w == -1 || (!used[w] && dfs(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n//?????§??¬?´???°\nint gcd(int x, int y) { return y ? gcd(y, x%y) : x; }\nsigned main() {\n\tfor (int m, n; cin >> m >> n&&m;) {\n\t\tvector<int> b(m); rep(i, 0, m) { cin >> b[i]; }\n\t\tvector<int> r(n); rep(i, 0, n) { cin >> r[i]; }\n\t\tBipartiteMatching bm(m + n);\n\t\trep(i, 0, m)rep(j, 0, n) {\n\t\t\tif (gcd(b[i], r[j]) == 1)continue;\n\t\t\tbm.add_edge(i, m + j);\n\t\t}\n\t\tint ans = bm.maximum_matching();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <map>\n#include <ctime>\n#include <cstdlib>\n \nusing namespace std;\n \ntypedef pair<int, int> P;\ntypedef vector<double> array;\ntypedef vector<array> matrix;\nconst double EPS = 1e-8;\n\nint gcd(int a, int b){ return (b == 0 ? a : gcd(b, a%b)); }\n \nint rank(matrix &A){\n\tint n = A.size();\n  int res = 0;\n\tmatrix B(n, array(n+1,1));\n  for(int i=0;i<n;i++) for(int j=0;j<n;j++) B[i][j] = A[i][j];\n    \n  for(int i=0;i<n;i++){\n    int pivot = i;\n    for(int j=i;j<n;j++){\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n    }\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i]) > EPS) res++;\n    if(abs(B[i][i]) > EPS){\n      for(int j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n      for(int j=0;j<n;j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tfor(int k=i+1;k<=n;k++) B[j][k] -= B[j][i] * B[i][k];\n\t\t\t\t}\n      }\n    }\n  }\n  return res;\n}\n \nint main(){\n\tsrand((unsigned)time(NULL));\n\tint n, m;\n\twhile(cin >> n >> m && (n|m)){\n\t\tvector<int> A(n), B(m);\n\t\tfor(int i=0;i<n;i++) cin >> A[i];\n\t\tfor(int i=0;i<m;i++) cin >> B[i];\n\t\tvector<P> edge;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(gcd(A[i], B[j]) > 1){\n\t\t\t\t\tedge.push_back(make_pair(i, n+j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tmatrix mat(n+m, array(n+m, 0));\n\t\tfor(int i=0;i<edge.size();i++){\n\t\t\tint tmp = rand();\n\t\t\tint a = edge[i].first, b = edge[i].second;\n\t\t\tmat[a][b] = tmp;\n\t\t\tmat[b][a] = -tmp;\n\t\t}\n\t\tcout << rank(mat) / 2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nvector< vector<int> > g;\nint n, m;\n\nvector<bool> visited;\nvector<int> matching;\n\nbool augment(int left) {\n  if (left < 0)\n    return true;\n  if (visited[left])\n    return false;\n  visited[left] = true;\n  REP(i, g[left].size()) {\n    int right = g[left][i];\n    if (augment(matching[right])) {\n      matching[right] = left;\n      return true;\n    }\n  }\n  return false;\n}\nint match() {\n  matching.assign(m, -1);\n  int matches = 0;\n  REP(left, n) {\n    visited.assign(n, false);\n    if (augment(left))\n      matches++;\n  }\n  return matches;\n}\n\nint gcd(int a, int b){\n  if(a > b) swap(a, b);\n  if(a == 0) return b;\n  return gcd(a, b%a);\n}\n\nint main(){\n  int r[500];\n  int b[500];\n  while((n = getInt()) + (m = getInt())){\n    g = vector<vector<int> >(n);\n    visited = vector<bool>(n);\n    matching = vector<int>(m);\n\n    REP(i,n)\n      b[i] = getInt();\n\n    REP(i,m)\n      r[i] = getInt();\n\n    REP(i,n) REP(j,m) if(gcd(b[i], r[j]) != 1){\n      g[i].push_back(j);\n    }\n\n    print(match());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define i_7 (ll)(1E9+7)\n#define i_5 (ll)(1E9+5)\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    else return c+i_7;\n}\ntypedef pair<int,int> i_i;\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E12;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll * pos,ll val){*pos=max(*pos,val);}//Max(&dp[i][j],dp[i-1][j]);\nvoid Min(ll * pos,ll val){*pos=min(*pos,val);}\nvoid Add(ll * pos,ll val){*pos=mod(*pos+val);}\nconst long double EPS=1E-8;\n////////////////////////////////////////\n#define MAX_V 30000//調節！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n//辺を表す構造体{行き先、容量、逆辺}\nstruct edge{ll to,cap,rev;};\nvector<edge> G[MAX_V];\nbool used[MAX_V];//dfsですでに調べたかのフラグ\n//fromからtoへの流量capの辺をグラフに追加\nvoid add_edge(ll from,ll to,ll cap){\n    //cout<<from<<\" \"<<to<<\" \"<<cap<<endl;\n    G[from].push_back((edge){to,cap,static_cast<ll>(G[to].size())});\n    G[to].push_back((edge){from,0,static_cast<ll>(G[from].size()-1)});\n}\n//増加パスをdfsで探す\nll dfs(ll v,ll t,ll f){\n    if(v==t)return f;\n    used[v]=true;\n    for(ll i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(!used[e.to]&&e.cap>0){\n            ll d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nll max_flow(ll s,ll t){\n    ll flow=0;\n    while(1){\n        memset(used,0,sizeof(used));\n        ll f=dfs(s,t,inf);\n        if(f==0)return flow;\n        flow+=f;\n    }\n}\n///////////////////////////////////////\n\nint gcd(int a,int b){\n    if(a>b)swap(a,b);\n    if(a==0)return b;\n    else return gcd(b%a,a);\n}\n\nint main(){\n    int N=505;\n    while(1){\n        int m,n;cin>>m>>n;if(m==0)return 0;\n        rep(i,0,MAX_V-1)G[i].clear();\n        int a[m],b[n];rep(i,0,m-1)cin>>a[i];rep(i,0,n-1)cin>>b[i];\n        rep(i,0,m-1){\n            rep(j,0,n-1){\n                if(gcd(a[i],b[j])>=2){\n                    add_edge(i,j+N,1);\n                }\n            }\n        }\n        int sta=2*N,end=2*N+1;\n        rep(i,0,m-1){\n            add_edge(sta,i,1);\n        }\n        rep(i,0,n-1){\n            add_edge(i+N,end,1);\n        }\n        cout<<max_flow(sta,end)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define rep(i,n) for(int i=0;i<n;i++)\n\nstruct edge{int to,cap,rev;};\n\nvector<edge> g[1002];\nbool used[1002];\n\nvoid addEdge(int from,int to,int cap){\n\tedge e;\n\te.to=to;e.cap=cap;e.rev=g[to].size();\n\tg[from].push_back(e);\n\te.to=from;e.cap=0;e.rev=g[from].size()-1;\n\tg[to].push_back(e);\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tused[v]=1;\n\trep(i,g[v].size()){\n\t\tedge &e=g[v][i];\n\t\tif(!used[e.to]&&e.cap>0){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxFlow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tfill(used,used+1001,0);\n\t\tint f=dfs(s,t,INF);\n\t\tif(!f)return flow;\n\t\tflow+=f;\n\t}\n}\n\nint gcd(int a,int b){\n\tif(!b)return a;\n\treturn gcd(b,a%b);\n}\n\nint m,n,k,a[1002];\n\nint main(){\n\twhile(cin>>m>>n&&m){\n\t\trep(i,m+n+2)g[i].clear();\n\t\trep(i,m+n)cin>>a[i];\n\t\tint S=m+n,G=S+1;\n\t\trep(i,m)addEdge(S,i,1);\n\t\trep(i,n)addEdge(m+i,G,1);\n\t\trep(i,m)rep(j,n)if(gcd(a[i],a[m+j])>1){addEdge(i,m+j,1);}\n\t\tcout<<maxFlow(S,G)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#define INF 1000000000\n#define MAX_V 1000\n#define MAX 10000000\nusing namespace std;\n\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nbool prime[MAX+1];\n\nvoid eratos(){\n  int n=MAX;\n  for(int i=0;i<=n;i++) prime[i]=false;\n  for(int i=3;i<=n;i+=2) prime[i]=true;\n  prime[2]=true;\n  int limit=(int)sqrt((double)n)+1;\n  for(int i=3;i<=limit;i+=2){\n    if(!prime[i]) continue;\n    for(int j=i+i;j<=n;j+=i)\n      prime[j]=false;\n  }\n}\n\nvoid add_edge(int u, int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i], w=match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  memset(match, -1, sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v)){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nmain(){\n  eratos();\n  int primdata[664580];\n  for(int i=0, j=0;i<=MAX;i++){\n    if(prime[i]) primdata[j++]=i;\n  }\n  primdata[664579]=-1;\n  int m, n;\n  while(1){\n    cin >> m >> n;\n    if(m==0 && n==0) break;\n    for(int i=0;i<m+n;i++){\n      G[i].clear();\n    }\n    int in1[500], in2[500];\n    for(int i=0;i<m;i++){\n      cin >> in1[i];\n    }\n    for(int i=0;i<n;i++){\n      cin >> in2[i];\n    }\n    bool can[500][500];\n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n\tcan[i][j]=false;\n\tfor(int k=0;;k++){\n\t  if(primdata[k]==-1) break;\n\t  if(primdata[k]>in1[i] || primdata[k]>in2[j]) break;\n\t  if(in1[i]%primdata[k]==0 && in2[j]%primdata[k]==0) can[i][j]=true;\n\t}\n      }\n    }\n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n\tif(can[i][j]){\n\t  add_edge(i, m+j);\n\t}\n      }\n    }\n    V=m+n;\n    cout << bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nlong long e, v;\n\nclass pass\n{\npublic:\n\tlong long t;\n\tlong long c;\n\tlong long p;\n};\n\npass p[250000];\n\nlong long noded[1000];\npair<long long, long long> nodef[1000];\nvector<long long> node[1000];\n\nvoid add(long long f, long long t, long long c)\n{\n\tp[e].t = t;\n\tp[e].c = c;\n\tp[e].p = e + 1;\n\tp[e + 1].t = f;\n\tp[e + 1].c = 0;\n\tp[e + 1].p = e;\n\tnode[f].push_back(e);\n\tnode[t].push_back(e + 1);\n\te += 2;\n}\n\nvoid push()\n{\n\tpriority_queue<pair<long long, long long>> q;\n\tfor (long long i = 0; i < v; i++)\n\t{\n\t\tnoded[i] = 0;\n\t\tnodef[i] = make_pair(0, 0);\n\t}\n\tnoded[0] = v;\n\tfor (auto i : node[0])\n\t{\n\t\tif (p[i].c > 0)\n\t\t{\n\t\t\tp[p[i].p].c += p[i].c;\n\t\t\tnodef[p[i].t].first += p[i].c;\n\t\t\tnodef[0].second += p[i].c;\n\t\t\tp[i].c = 0;\n\t\t\tq.push(make_pair(0, p[i].t));\n\t\t}\n\t}\n\tnodef[v - 1].second = ((long long)1 << 50);\n\twhile (!q.empty())\n\t{\n\t\tlong long np = q.top().second;\n\t\tq.pop();\n\t\twhile (1)\n\t\t{\n\t\t\tfor (auto i : node[np])\n\t\t\t{\n\t\t\t\tif (p[i].c > 0)\n\t\t\t\t{\n\t\t\t\t\tlong long t = p[i].t;\n\t\t\t\t\tif (noded[np] == noded[t] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long kae = min(p[i].c, nodef[np].first - nodef[np].second);\n\t\t\t\t\t\tp[i].c -= kae;\n\t\t\t\t\t\tp[p[i].p].c += kae;\n\t\t\t\t\t\tnodef[np].second += kae;\n\t\t\t\t\t\tbool w = (nodef[t].first <= nodef[t].second);\n\t\t\t\t\t\tnodef[t].first += kae;\n\t\t\t\t\t\tif (w && nodef[t].first > nodef[t].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tq.push(make_pair(noded[t], t));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nodef[np].first <= nodef[np].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nodef[np].first > nodef[np].second && np != 0)\n\t\t\t{\n\t\t\t\tlong long minw = ((long long)1 << 50);\n\t\t\t\tfor (auto i : node[np])\n\t\t\t\t{\n\t\t\t\t\tif (p[i].c > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tminw = min(minw, noded[p[i].t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnoded[np] = minw + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long dn[1000];\nlong long dm[1000];\n\nlong long gcd(long long a, long long b)\n{\n\tif (a % b == 0)\n\t{\n\t\treturn b;\n\t}\n\treturn gcd(b, a % b);\n}\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tlong long n, m;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tv = n + m + 2;\n\t\tfor (long long i = 0; i < v; i++)\n\t\t{\n\t\t\tnode[i].clear();\n\t\t}\n\t\te = 0;\n\t\tfor (long long i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &dn[i]);\n\t\t\tadd(0, 1 + i, 1);\n\t\t}\n\t\tfor (long long i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &dm[i]);\n\t\t\tadd(n + 1 + i, n + m + 1, 1);\n\t\t}\n\t\tfor (long long i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (long long ii = 0; ii < m; ii++)\n\t\t\t{\n\t\t\t\tif (1 < gcd(dn[i], dm[ii]))\n\t\t\t\t{\n\t\t\t\t\tadd(1 + i, n + 1 + ii, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpush();\n\t\tlong long all = 0;\n\t\tfor (auto i : node[0])\n\t\t{\n\t\t\tif (i % 2 == 0)\n\t\t\t{\n\t\t\t\tall += p[p[i].p].c;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", all);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define clr(a,v) memset((a),(v),sizeof(a))\n\nconst int MAX_M = 500, MAX_N = 500;\n\nint m, n;\nint b[MAX_M], r[MAX_N];\nstd::vector<int> G[MAX_M];\nbool used[MAX_M];\nint pr[MAX_M];\nint ans;\n\nbool dfs( int v )\n{\n  if( v < 0 )\n    return true;\n  if( used[v] )\n    return false;\n\n  used[v] = true;\n\n  for( int u : G[v] )\n  {\n    if( dfs( pr[u] ) )\n    {\n      pr[u] = v;\n      return true;\n    }\n  }\n\n  return false;\n}\n\nint gcd( int a, int b )\n{ return b ? gcd( b, a%b ) : a; }\n\nint main()\n{\n  while( scanf( \"%d%d\", &m, &n ), m|n )\n  {\n    rep( i, m )\n      G[i].clear();\n    ans = 0;\n\n    rep( i, m )\n      scanf( \"%d\", b+i );\n    rep( i, n )\n      scanf( \"%d\", r+i );\n\n    rep( i, m ) rep( j, n ) if( gcd( b[i], r[j] ) != 1 )\n      G[i].push_back( j );\n\n    clr( pr, -1 );\n\n    rep( v, m )\n    {\n      clr( used, false );\n      \n      if( dfs(v) )\n        ++ans;\n    }\n\n    printf( \"%d\\n\", ans );\n}\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n//typedef long long Int;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst) : src(src),dst(dst) {}\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) {}\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vec<Edge> Edges;\ntypedef vec<Edges> Graph;\n\n#define MAXMN 500\nint B[MAXMN];\nint R[MAXMN];\n\nint gcd(int a, int b)\n{   \n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  return match;\n}\n\n\nint main(int argc, char **argv) {\n  int M,N;\n  Graph g; g.reserve(MAXMN+MAXMN);\n  while(cin>>M>>N,M) {\n    g.clear();\n    g.resize(M+N);\n    REP(i,M) cin>>B[i];\n    REP(i,N) cin>>R[i];\n    REP(i,M) {\n      Edges es, es2;\n      REP(j,N) {\n\tif(gcd(B[i],R[j])!=1) { es.pb(Edge(i,M+j)); es2.pb(Edge(M+j,i)); }\n      }\n      g[i] = es;\n      g[M+i] = es2;\n    }\n    cout << bipartiteMatching(g,M) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define LOOP(i,x,n) for(int i=x;i<n;i++)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define MP make_pair\n#define FIR first\n#define SEC second\n#define int long long\nusing namespace std;\nconst int MOD=1000000007;\nconst int INF=1000000009;\n\ntypedef int Flow;\nstruct Edge{\n  int src;int dst;int rev;\n  Flow cap;\n  Edge(int s=0,int d=0,Flow c=0,int r=0):\n  src(s),dst(d),cap(c),rev(r){}\n};\n\nusing Graph = vector<vector<Edge>>;\nGraph g;\nint m,n;\nbool used[10005];\n\nvoid add(int src,int dst,int cap){\n  g[src].emplace_back(src,dst,cap,g[dst].size());\n  g[dst].emplace_back(dst,src,0,g[src].size()-1);\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  REP(i,g[v].size()){\n    Edge &e=g[v][i];\n    if(!used[e.dst]&&e.cap>0){\n      int d=dfs(e.dst,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        g[e.dst][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\n\nint maximum_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(used,used+n+m+10,0);\n    int f=dfs(s,t,INF);\n    if(!f) return flow;\n    flow+=f;\n  }\n}\n\nsigned main(){\n  while(cin>>m>>n,m){\n    int b,r;\n    g=Graph(m+n+10);\n    vector<pair<int,int>> B,R;\n    REP(i,m){\n      cin>>b;\n      B.PB(MP(i+1,b));\n    }\n    REP(i,n){\n      cin>>r;\n      R.PB(MP(i+1+m,r));\n    }\n    REP(i,m)add(0,i+1,1);\n    REP(i,n)add(m+i+1,n+m+1,1);\n    REP(i,m)REP(j,n){\n      int tmp=min(B[i].SEC,R[j].SEC);\n      LOOP(k,2,tmp+1){\n        if(B[i].SEC%k==0&&R[j].SEC%k==0){\n            add(B[i].FIR,R[j].FIR,1);\n        }\n      }\n    }\n    cout<<maximum_flow(0,m+n+1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct edge { int to, cap, rev; };\n\nconst int MAX_V = 100000;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap)\n{\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, 0, G[to].size() - 1});\n}\n\nint dfs(int v, int t, int f)\n{\n    if(v == t)\n        return f;\n    used[v] = true;\n    for(unsigned int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nlong long gcd(long long x, long long y)\n{\n    if(y > x)\n        return __gcd(y, x);\n    else\n        return __gcd(x, y);\n}\n\nint main()\n{\n    int m, n, cards[MAX_V];\n    while(cin >> m >> n && m && n) {\n\n        for(int i = 0; i < MAX_V; i++) \n            G[i].clear();\n\n        for(int i = 0; i < m; i++) {\n            cin >> cards[1 + i];\n            add_edge(0, 1 + i, 1);\n        }\n\n        for(int i = 0; i < n; i++) {\n            cin >> cards[1 + m + i];\n            add_edge(1 + m + i, 1 + m + n, 1);\n        }\n        for(int i = 0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                if(gcd(cards[1 + i], cards[1 + m + j]) > 1) {\n                    add_edge(1 + i, 1 + m + j, 1);\n                }\n            }\n        }\n\n        int ans = 0;\n        while(true) {\n            fill(used, used + MAX_V, false);\n            int f = dfs(0, 1 + m + n, 1);\n            if(f == 0) \n                break;\n            ans += f;\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n#define SET(a,c) memset(a,c,sizeof(a))\n\n#define DEBUG(x) cout<<\"#x\"<<\": \"<<x<<endl\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nconst ll INF = INT_MAX/3;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-14;\nconst int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n\nstruct edge{ int to;int cap;int rev; };\ntypedef struct edge edge;\n\nint m,n;\n\nvector<edge> G[2002];\nint used[300002];\n\nvoid add_edge(int from,int to){\n    G[from].PB( (edge){to,1,(int)G[to].size()} );\n    G[to].PB( (edge){from,0,(int)G[to].size()-1} );\n}\n\nint dfs(int v,int t,int f){\n    if( v == t) return f;\n    used[v] = true;\n    REP(i,G[v].size()){\n\tedge &e = G[v][i];\n\tif(!used[e.to] && e.cap > 0){\n\t    int d = dfs(e.to,t,min(f,e.cap));\n\t    if(d > 0){\n\t\te.cap -= d;\n\t\tG[e.to][e.rev].cap += d;\n\t\treturn d;\n\t    }\n\t}\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int flow = 0;\n    while(true){\n\tSET(used,false);\n\tint f = dfs(s,t,INF);\n\tif(f == 0)return flow;\n\tflow += f;\n    }\n    return -1;\n}\n\nint gcd(int a,int b){ return a % b == 0 ? b : gcd(b,a%b); }\n\nint main(){\n\n    while(true){\n\tm,n;\n\tcin >> m >> n;\n\tif(m == 0 && n == 0) break;\n\tREP(i,1002) G[i].clear();\n\tSET(used,false);\n\tint a[501],b[501];\n\tREP(i,m) {\n\t    cin >> a[i];\n\t    add_edge(0,i+1);\n\t}\n\tREP(i,n) {\n\t    cin >> b[i];\n\t    add_edge(i+1+m,n+m+1);\n\t}\n\tREP(i,m){\n\t    REP(j,n){\n\t\tif(gcd(a[i],b[j]) > 1){\n\t\t    add_edge(i+1,m+j+1);\n\t\t}\n\t    }\n\t}\n\tcout << max_flow(0,n+m+1) << endl;;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_V = 1000;\nvector<int> G[MAX_V];\nint match[MAX_V], p[500], q[500];\nbool used[MAX_V];\n\nint gcd_rec(int a, int b) {\n  return !b ? a : gcd_rec(b, a % b);\n}\n\nint gcd(int a, int b) {\n  return a < b ? gcd_rec(b, a) : gcd_rec(a, b);\n}\n\nvoid add_edge(int u, int v) {\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v) {\n  used[v] = true;\n  for (int i = 0; i < G[v].size(); i++) {\n    int u = G[v][i], w = match[u];\n    if (w < 0 || !used[w] && dfs(w)) {\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  for (;;) {\n    int m, n;\n    cin >> m >> n;\n    if (!m && !n) return 0;\n    for (int i = 0; i < m; i++)\n      cin >> p[i];\n    for (int i = 0; i < n; i++)\n      cin >> q[i];\n    for (int i = 0; i < m; i++)\n      for (int j = 0; j < n; j++)\n        if (gcd(p[i], q[j]) > 1)\n          add_edge(i, m+j);\n    int r = 0, V = m + n;\n    fill(match, match+V, -1);\n    for (int v = 0; v < V; v++)\n      if (match[v] < 0) {\n        fill(used, used+V, false);\n        if (dfs(v))\n          r++;\n      }\n    cout << r << endl;\n    for (int v = 0; v < V; v++)\n      G[v].clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n// max_flow\nconst int MAX_V = 1050;\nclass FordFulkerson {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n        edge() {}\n        edge(int t, int c, int r) : to(t), cap(c), rev(r) {}\n    };\n    vector<edge> G[MAX_V];\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back(edge(to, cap, G[to].size()));\n        G[to].push_back(edge(from, 0, G[from].size() - 1));\n    }\n    int max_flow(int s, int t) {\n        int flow = 0;\n        while (1) {\n            for (int i = 0; i < MAX_V; i++) used[i] = false;\n            int f = dfs(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\nprivate:\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (!used[e.to] && e.cap > 0) {\n                int d = dfs(e.to, t, min(e.cap, f));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    bool used[MAX_V];\n};\n\nint b[600], r[600];\n\nint main(void) {\n    int m, n;\n    while (cin >> m >> n) {\n        if (m == 0 && n == 0) break;\n        FordFulkerson ff;\n        for (int i = 0; i < m; i++) {\n            cin >> b[i];\n        }\n        for (int i = 0; i < n; i++) {\n            cin >> r[i];\n        }\n        int s = m+n, t = s+1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (__gcd(b[i], r[j]) > 1) {\n                    ff.add_edge(i, m+j, 1);\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            ff.add_edge(s, i, 1);\n        }\n        for (int i = 0; i < n; i++) {\n            ff.add_edge(i+m, t, 1);\n        }\n        cout << ff.max_flow(s, t) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nconstexpr int MAX_V = 1000;\n \nclass twoMatching {\nprivate:\n  vector<int> G[MAX_V];\n  int match[MAX_V];\n  bool used[MAX_V];\n  int V;\npublic:\n  twoMatching(int v) {\n    V = v;\n  }\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n \n  bool dfs(int v) {\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n      int u = G[v][i], w = match[u];\n      if (w < 0 || !used[w] && dfs(w)) {\n    match[v] = u;\n    match[u] = v;\n    return true;\n      }\n    }\n    return false;\n  }\n \n  int bipartite_matching() {\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for (int v = 0; v < V; v++) {\n      if (match[v] < 0) {\n    memset(used, 0, sizeof(used));\n    if (dfs(v)) res++;\n      }\n    }\n    return res;\n  }\n};\n \nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nint main() {\n  int m, n;\n  int b[500], r[500];\n \n  while (1) {\n    scanf(\"%d%d\", &m, &n);\n    if (m == 0) break;\n    for (int i = 0; i < m; i++) scanf(\"%d\", &b[i]);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &r[i]);\n    twoMatching t(m + n);\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (gcd(b[i], r[j]) == 1) continue;\n        t.add_edge(i, j + m);\n      }\n    }\n    printf(\"%d\\n\", t.bipartite_matching());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n/*#include <iostream>\n#include <vector>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <numeric>\n#include <complex>\n#include <bitset>\n#include <functional>\n#include <stack>\n#include <regex>\n#include <tuple>\n#include <iomanip>\n*/\n#define int long long\n#define REP(i,a,n) for(int i=a;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define REV(i,a,n) for(int i=n;i>=a;--i)\n#define all(e) e.begin(),e.end()\n#define rall(e) e.rbegin(),e.rend()\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define show(n) cerr<<#n<<\" = \"<<n<<endl\n#define showp(n) cerr<<n.fs<<\", \"<<n.sc<<endl\n#define shows(n) for(auto z:n){cerr<<z<<\", \";}cerr<<endl\n#define showsp(n) for(auto z:n){cerr<<z.fs<<\" \"<<z.sc<<\", \"}cerr<<endl\n\n#define yes puts(\"Yes\")\n#define no puts(\"No\")\n#define case(i) printf(\"Case #%lld: \",i)\n\nusing namespace std;\n\nusing vi=vector<int>;\nusing pint=pair<int,int>;\n\ninline void io(){cin.tie(0);ios::sync_with_stdio(false);cout.tie(0);cout<<fixed<<setprecision(20);}\ninline int   in(){int n;scanf(\"%lld\",&n);return n;}\ninline void out(int n){printf(\"%lld\\n\",n);}\n\nconst int INF=1LL<<55;\nconst int MOD=1000000007;\nconst double EPS=1e-8;\n\nconst int MAX_V = 1010;\n\nint m,n;\nint V;\nvi G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\nvi blue(MAX_V/2);\nvi red(MAX_V/2);\n\nvoid add_edge(int u,int v) {\n    G[u].pb(v);\n    G[v].pb(u);\n}\n\nbool dfs(int v){\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        int u=G[v][i],w=match[u];\n        if(w<0 || (!used[w] && dfs(w))) {\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(){\n    int res=0;\n    memset(match,-1,sizeof(match));\n    for(int v=0;v<V;v++){\n        if(match[v]<0){\n            memset(used,0,sizeof(used));\n            if(dfs(v)){\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nvoid init(){\n    V=m+n;\n    rep(i,MAX_V){\n        G[i].erase(all(G[i]));\n    }\n}\n\nvoid solve(){\n    init();\n    rep(i,m) blue[i]=in();\n    rep(i,n) red[i]=in();\n    rep(i,m){\n        rep(j,n){\n            if(gcd(blue[i],red[j])>1){\n                add_edge(i,m+j);\n            }\n        }\n    }\n    out(bipartite_matching());\n}\n\nsigned main() {\n    io();\n\n    while(cin>>m>>n,n){\n        solve();\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\n//a<b\nlong pgcd(long a,long b){\n  if(a==0)\n    return b;\n  else\n    return pgcd(b%a,a);\n}\n\nlong gcd(long a, long b){\n  return pgcd(min(a,b), max(a,b));\n}\n\nint m,n;//blue,red\nint c[500][500];\nlong b[500], r[500];\nbool v[500];\nint p[500];\nbool match(int b){\n  if(b<0) return true;\n  rep(j,n){\n    if(!c[b][j] || v[j]) continue;\n    v[j]=true;\n    if(match(p[j])) {\n      p[j]=b;\n      return true;\n    }\n  }\n  return false;\n}\n\n\n\nint main(){\n  scanf(\"%d %d\", &m, &n);\n  rep(i,m) scanf(\" %ld\", b+i);\n  rep(j,n) scanf(\" %ld\", r+j);\n\n  rep(i,m) rep(j,n) c[i][j]=gcd(b[i],r[j]) > 1 ? 1 : 0;\n\n  rep(j,n) v[j]=-1;\n\n  int count=0;\n  rep(i,m){\n    rep(j,n) v[j]=false;\n    if(match(i)) count++;\n  }\n  printf(\"%d\",count);\n\n}"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\nclass Dinic {\n    struct Edge {\n        ll to, cap, rev_idx;\n    };\n    \n    VV<Edge> edges;\n    const ll inf;\n\n    V<ll> bfs(ll S) {\n        V<ll> dist(edges.size(), -1);\n        queue<PLL> que;\n        que.emplace(S, 0);\n        dist[S] = 0;\n        while (que.size()) {\n            ll now, d;\n            tie(now, d) = que.front();\n            que.pop();\n            for (const auto &e : edges[now]) {\n                if (e.cap <= 0) continue;\n                ll nxt = e.to;\n                if (dist[nxt] != -1 && dist[nxt] <= d + 1) continue;\n                dist[nxt] = d + 1;\n                que.emplace(nxt, d + 1);\n            }\n        }\n        return move(dist);\n    }\n\n    ll dfs(ll now, ll pre, ll T, ll flow, const V<ll> &dist, V<ll> &watched) {\n        if (now == T) return flow;\n        for (ll i = watched[now] + 1; i < edges[now].size(); i++) {\n            watched[now]++;\n            auto &e = edges[now][i];\n            if (dist[e.to] <= dist[now]) continue;\n            if (e.cap <= 0) continue;\n            if (e.to == pre) continue;\n            ll f = dfs(e.to, now, T, min(flow, e.cap), dist, watched);\n            e.cap -= f;\n            edges[e.to][e.rev_idx].cap += f;\n            if (f > 0) return f;\n        }\n        return 0;\n    }\n\npublic: \n    Dinic(const VV<PLL> &v, ll inf) : inf(inf) {\n        edges.resize(v.size());\n        for (ll i = 0; i < v.size(); i++) {\n            for (auto e : v[i]) {\n                edges[i].push_back((Edge) {e.first, e.second, (ll)edges[e.first].size()} );\n                edges[e.first].push_back((Edge) {i, 0, (ll)edges[i].size() - 1} );\n            }\n        }\n    }\n\n    Dinic(const VV<PLL> &v) : Dinic(v, 5e15) {};\n\n    ll max_flow(ll S, ll T) {\n        ll ret = 0;\n        while (true) {\n            auto dist = bfs(S);\n            if (dist[T] == -1) break;\n            V<ll> watched(edges.size(), -1);\n            while (true) {\n                ll tmp = dfs(S, -1, T, inf, dist, watched);\n                if (tmp == 0) break;\n                ret += tmp;\n            }\n        }\n        return ret;\n    }\n};\n\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\n\nbool solve() {\n    ll M, N;\n    cin >> M >> N;\n    if (M == 0 && N == 0) return false;\n\n    V<ll> B(M), R(N);\n    for (ll &e : B) cin >> e;\n    for (ll &e : R) cin >> e;\n\n    ll start = M + N;\n    ll goal = start + 1;\n    VV<PLL> edges(goal + 1);\n    for (ll i = 0; i < M; i++) for (ll j = 0; j < N; j++) {\n        ll a = B[i], b = R[j];\n        if (gcd(a, b) == 1) continue;\n        edges[i].emplace_back(M + j, 1);\n    }\n\n    for (ll i = 0; i < M; i++) edges[start].emplace_back(i, 1);\n    for (ll i = 0; i < N; i++) edges[M + i].emplace_back(goal, 1);\n\n    Dinic dinic(edges);\n\n    cout << dinic.max_flow(start, goal) << endl;\n    return true;\n}\n\nint main() {\n    while (solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint V;\nvector<int> G[1001];\nint match[1001];\nbool used[1001];\n\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i], w=match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int v=0;v<V;v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(true){\n\t\tint m,n;\n\t\tcin >> m >> n;\n\t\tif(m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tvector<int> b;\n\t\tvector<int> r;\n\t\tV = m+n;\n\t\tfor(int i=0;i<V;i++){\n\t\t\tvector<int> buf(0);\n\t\t\tG[i] = buf;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tb.push_back(buf);\n\t\t}\n\t\tfor(int j=0;j<n;j++){\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tr.push_back(buf);\n\t\t}\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=2;k<=min(b[i],r[j]);k++){\n\t\t\t\t\tif(b[i]%k==0&&r[j]%k==0){\n\t\t\t\t\t\tadd_edge(i,j+m);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass pass\n{\npublic:\n\tll t;\n\tll c;\n\tll p;\n};\n\nclass scale\n{\nprivate:\n\tll v, e;\n\n\tpass* p;\n\n\tvector<ll>* node;\n\tbool* used;\n\tll* nowin;\npublic:\n\tvoid set(ll vw, ll ew)\n\t{\n\t\tv = vw;\n\t\tp = new pass[ew * 2];\n\t\tnode = new vector<ll>[v];\n\t\tused = new bool[v];\n\t\tnowin = new ll[v];\n\t\te = 0;\n\t}\n\n\tvoid add(ll f, ll t, ll c)\n\t{\n\t\tp[e].t = t;\n\t\tp[e].c = c;\n\t\tp[e].p = e + 1;\n\t\tp[e + 1].t = f;\n\t\tp[e + 1].c = 0;\n\t\tp[e + 1].p = e;\n\t\tnode[f].push_back(e);\n\t\tnode[t].push_back(e + 1);\n\t\te += 2;\n\t}\n\n\tll solve()\n\t{\n\t\tll nn = 0;\n\t\tfor (auto i : node[0])\n\t\t{\n\t\t\tnn = max(nn, p[i].c);\n\t\t}\n\t\twhile (nn > 0)\n\t\t{\n\t\t\tstack<ll> st;\n\t\t\tqueue<ll> q;\n\t\t\tfor (ll i = 0; i < v; i++)\n\t\t\t{\n\t\t\t\tused[i] = false;\n\t\t\t\tnowin[i] = 0;\n\t\t\t}\n\t\t\tq.push(0);\n\t\t\tused[0] = true;\n\t\t\twhile (!q.empty())\n\t\t\t{\n\t\t\t\tll np = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tst.push(np);\n\t\t\t\tfor (auto i : node[np])\n\t\t\t\t{\n\t\t\t\t\tif (p[i].c > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tll t = p[i].t;\n\t\t\t\t\t\tnowin[t] += p[i].c;\n\t\t\t\t\t\tif (nowin[t] >= nn && !used[t])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (t == v - 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tst.push(t);\n\t\t\t\t\t\t\t\tgoto aa;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tq.push(t);\n\t\t\t\t\t\t\tused[t] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\taa:\n\t\t\tif (st.top() != v - 1)\n\t\t\t{\n\t\t\t\tnn /= 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (!q.empty())\n\t\t\t{\n\t\t\t\tused[q.front()] = false;\n\t\t\t\tq.pop();\n\t\t\t}\n\t\t\tfor (int i = 0; i < v; i++)\n\t\t\t{\n\t\t\t\tnowin[i] = 0;\n\t\t\t}\n\t\t\tnowin[v - 1] = nn;\n\t\t\twhile (st.size() > 1)\n\t\t\t{\n\t\t\t\tll np = st.top();\n\t\t\t\tst.pop();\n\t\t\t\tfor (auto i : node[np])\n\t\t\t\t{\n\t\t\t\t\tll h = p[i].p;\n\t\t\t\t\tif (used[p[i].t] && p[h].c > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tll w = min(p[h].c, nowin[np]);\n\t\t\t\t\t\tp[h].c -= w;\n\t\t\t\t\t\tp[i].c += w;\n\t\t\t\t\t\tnowin[np] -= w;\n\t\t\t\t\t\tnowin[p[i].t] += w;\n\t\t\t\t\t\tif (nowin[np] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tused[np] = false;\n\t\t\t}\n\t\t}\n\t\tll all = 0;\n\t\tfor (auto i : node[0])\n\t\t{\n\t\t\tif (i % 2 == 0)\n\t\t\t{\n\t\t\t\tall += p[p[i].p].c;\n\t\t\t}\n\t\t}\n\t\treturn all;\n\t}\n\n\tvoid del()\n\t{\n\t\tdelete[] p;\n\t\tdelete[] node;\n\t\tdelete[] used;\n\t\tdelete[] nowin;\n\t}\n};\n\nll dn[2000];\nll dm[2000];\n\nll gcd(ll a, ll b)\n{\n\tif (a % b == 0)\n\t{\n\t\treturn b;\n\t}\n\treturn gcd(b, a % b);\n}\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tscale a;\n\t\tll n, m;\n\t\tscanf(\"%lld%lld\", &n, &m);\n\t\tif (n == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\ta.set(n + m + 2, n * m * 2);\n\t\tfor (ll i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%lld\", &dn[i]);\n\t\t\ta.add(0, 1 + i, 1);\n\t\t}\n\t\tfor (ll i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%lld\", &dm[i]);\n\t\t\ta.add(n + 1 + i, n + m + 1, 1);\n\t\t}\n\t\tfor (ll i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (ll ii = 0; ii < m; ii++)\n\t\t\t{\n\t\t\t\tif (1 < gcd(dn[i], dm[ii]))\n\t\t\t\t{\n\t\t\t\t\ta.add(1 + i, n + 1 + ii, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", a.solve());\n\t\ta.del();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define N 10000000\n\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\nbool augment(int l, vvi& E, vi& r2l, vi& visited) {\n\tif(l == -1) return true;\n\tif(visited[l]) return false;\n\tvisited[l] = true;\n\tfor(auto r:E[l]) {\n\t\tif(augment(r2l[r], E, r2l, visited)) {\n\t\t\tr2l[r] = l;\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\nint match(vvi& e, int l, int r) {\n\tvi r2l(r, -1);\n\tint res = 0;\n\tfor(int i = 0; i < l; i++) {\n\t\tvi visited(l);\n\t\tif(augment(i, e, r2l, visited)) res++;\n\t}\n\treturn res;\n}\n\nint main() {\n\tint m, n;\n\n\twhile(cin >> m >> n, m) {\n\t\tint ans = 0;\n\n\t\tvi B(m), R(n);\n\t\tfor(auto &i:B) cin >> i;\n\t\tfor(auto &i:R) cin >> i;\n\n\t\tvvi edge;\n\t\tedge.resize(m);\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tif(__gcd(B[i], R[j]) > 1) {\n\t\t\t\t\tedge[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << match(edge, m, n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\nconst int MAXV = 2005;\nconst int MAXE = 505 * 505;\nconst int INF = 1<<29;\n\nstruct BiparateMatching {\n    int N, M, E, match[MAXV+1], dist[MAXV+1];\n    int last[MAXE], prev[MAXE], to[MAXE];\n    BiparateMatching(int n, int m) : N(n), M(m), E(0) {\n        memset(last, -1, sizeof(last));\n    }\n    void add_edge(int x, int y) { // x \\in [0, N), y \\in [0, M)\n        to[E] = y + N; prev[E] = last[x]; last[x] = E; E++;\n    }\n    bool bfs() {\n        queue<int> q;\n        for (int i=0; i<N; ++i) {\n            if (match[i] == -1) {\n                q.push(i); dist[i] = 0;\n            } else dist[i] = INF;\n        }\n\n        bool ret = false;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = last[v]; e != -1; e = prev[e]) {\n                if (match[to[e]] == -1) ret = true;\n                else if (dist[match[to[e]]] == INF) {\n                    dist[match[to[e]]] = dist[v] + 1;\n                    q.push(match[to[e]]);\n                }\n            }\n        }\n        return ret;\n    }\n    bool dfs(int v) {\n        for (int e = last[v]; e != -1; e = prev[e]) {\n            bool update = false;\n            if (match[to[e]] == -1) {\n                match[to[e]] = v; match[v] = to[e];\n                update = true;\n            } else if (dist[match[to[e]]] == dist[v] + 1) {\n                if (dfs(match[to[e]])) {\n                    match[to[e]] = v; match[v] = to[e];\n                    update = true;\n                }\n            }\n            if (update) return true;\n        }\n        dist[v] = INF;\n        return false;\n    }\n    int matching() {\n        int ret = 0;\n        memset(match, -1, sizeof(match));\n        while(bfs()) {\n            for (int i=0; i<N; ++i)\n                if (match[i] == -1 && dfs(i)) ret++;\n        }\n        return ret;\n    }\n};\n\nint gcd(int x, int y) {\n    if (y == 0) return x;\n    return gcd(y, x%y);\n}\n\nint b[501], r[501];\nint main() {\n    int m,n;\n    while(scanf(\"%d %d\", &m, &n), m|n) {\n        BiparateMatching bm(m, n);\n        for (int i=0; i<m; ++i) scanf(\"%d\", &b[i]);\n        for (int i=0; i<n; ++i) scanf(\"%d\", &r[i]);\n        for (int i=0; i<m; ++i) {\n            for (int j=0; j<n; ++j)\n                if (gcd(b[i], r[j]) > 1) bm.add_edge(i, j);\n        }\n        printf(\"%d\\n\", bm.matching());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin() i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n//typedef long long Int;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst) : src(src),dst(dst) {}\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) {}\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vec<Edge> Edges;\ntypedef vec<Edges> Graph;\n\n#define MAXMN 500\nint B[MAXMN];\nint R[MAXMN];\n\nint gcd(int a, int b)\n{   \n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  return match;\n}\n\n\nint main(int argc, char **argv) {\n  int M,N;\n  Graph g; g.reserve(MAXMN+MAXMN);\n  while(cin>>M>>N,M) {\n    g.clear();\n    g.resize(M+N);\n    REP(i,M) cin>>B[i];\n    REP(i,N) cin>>R[i];\n    REP(i,M) {\n      Edges es, es2;\n      REP(j,N) {\n\tif(gcd(B[i],R[j])!=1) { es.pb(Edge(i,M+j)); es2.pb(Edge(M+j,i)); }\n      }\n      g[i] = es;\n      g[M+i] = es2;\n    }\n    cout << bipartiteMatching(g,M) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nstruct edge\n{\n  int to;\n  int from;\n  int cap;\n  int rev;\n};\nconst int max_v= 1010;\nint s=0, t;\nbool visited[max_v];\nvector<edge> g[max_v];\nint red_card[510], blue_card[510];\n\nint max_flow();\nint get_card();\nvoid print_g();\nint dfs(int node, int f);\n\nvoid clear()\n{\n  for(int i=0;i<max_v;i++)\n    {\n      g[i].clear();\n    }\n}\n\nint main()\n{\n  while(true)\n    {\n      clear();\n      if(get_card()==-1)\n\t{\n\t  break;\n\t}\n  cout << max_flow() << endl;\n  //print_g();\n    }\n  return 0;\n}\n  \nvoid print_g()\n{\n  for(int i=0;i<=t;i++)\n    {\n      for(int j=0;j<g[i].size();j++)\n\t{\n\t  if(g[i][j].cap!=0)\n\t    {\n\t  cout << \"{\" << g[i][j].from << g[i][j].to << g[i][j].cap << g[i][j].rev << \"}\";\n\t    }\n\t}\n      cout << endl;\n    }\n}\n\nint max_flow()\n{\n  int sum = 0, f=0;\n  \n  while(1)\n    {\n      fill(visited ,visited+max_v, false);\n      f = dfs(s, INT_MAX/3);\n      \n      if(f==0)\n\t{\n\t  break;\n\t}\n      sum += f;\n    }\n  return sum;\n}\n\n\nint dfs(int node, int f)\n{\n  //  cout << \"node:\" <<node << \" f:\" << f;\n  int d = 0;\n \n  if(node == t)//goal\n    {\n      //  cout <<\"f:\"<< f << endl;\n      return f;\n    }\n  else if(visited[node]==true)// if visited\n    {\n      return -1;\n    }\n  else\n    {\n      visited[node]=true;//visited\n    }\n\n  for(int i=0;i<g[node].size();i++)//root form node\n    {\n      edge& e = g[node][i];\n      // cout <<\" e,to:\"  <<e.to <<endl;\n      if(e.cap != 0)\n\t{\n\t  d = dfs(e.to, min(f, e.cap));\n\t  /*if(dfs(g[node][i].to, f) == 1)\n\t    {\n\t    return 1;\n\t    }*/\n\t  //   cout << \"node:\" << node << \" f:\" << f << \" d:\" << d << endl;      \n\t  if(d>0)\n\t    {\n\t      e.cap -= d;\n\t      g[e.to][e.rev].cap += d;\n\t      \n\t      return d;\n\t    }\n\t}\n\n    }\n  return 0;\n}\n\n\nvoid add_edge(int i, int j)\n{\n  g[i].push_back({j, i, 1, (int)g[j].size()});\n  g[j].push_back({i, j, 0, (int)g[i].size()-1});\n}\n\nint get_card()\n{\n  int red, blue;\n  cin >> blue >> red;\n  if(blue == 0)\n    {\n      return -1;\n    }\n  for(int i=0;i<blue;i++)\n    {\n      cin >> blue_card[i];\n    }\n  for(int i=0;i<red;i++)\n    {\n      cin >> red_card[i];\n    }\n  \n  \n  for(int i=0;i<blue;i++)\n    {\n      for(int j=0;j<red;j++)\n\t{\n\t  if(__gcd(blue_card[i], red_card[j])!=1)\n\t    {// to from cap rev\n\t      add_edge(i+1, j+blue+1);\n\t    }\n\t}\n    }\n\n   for(int i=1;i<=blue;i++)\n    {\n      add_edge(0, i);\n    }\n\n   t = blue+red+1;\n   for(int i=blue+1;i<t;i++)\n     {\n       add_edge(i, t);\n     }\n\n   /*     for(int i=0;i<=t;i++)\n    {\n      for(int j=0;j<g[i].size();j++)\n\t{\n\t  cout << \"{\" << g[i][j].from << g[i][j].to << g[i][j].cap << g[i][j].rev << \"}\";\n\t}\n      cout << endl;\n      }*/\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\nconstexpr int IINF = INT_MAX;\n\nstruct edge{\n    int to, cap, rev;\n};\n\nvector<vector<edge> > G;\nvector<bool> used;\n\nvoid add_edge(int from, int to, int cap){\n    G[from].emplace_back((edge){to, cap, int(G[to].size())});\n    G[to].emplace_back((edge){from, 0, int(G[from].size())-1});\n}\n\n// 増加路の探索\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(auto &e : G[v]){\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    used.resize(G.size());\n    int flow = 0;\n    while(1){\n        fill(used.begin(), used.end(), false);\n        int f = dfs(s, t, IINF);\n        if(f==0) break;\n        flow += f;\n    }\n    return flow;\n}\n\nint gcd(int p, int q){\n    if(q==0) return p;\n    else return gcd(q, p%q);\n}\n\nint main() {\n    int n, m;\n    while(cin >> m >> n, m){\n        G.clear();\n        G.resize(m+n+2);\n        vector<int> a(m), b(n);\n        for(int i=0;i<m;i++) cin >> a[i];\n        for(int i=0;i<n;i++) cin >> b[i];\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(gcd(a[i], b[j]) > 1){\n                    add_edge(i,j+m,1);\n                }\n            }\n        }\n        for(int i=0;i<m;i++){\n            add_edge(n+m,i,1);\n        }\n        for(int i=0;i<n;i++){\n            add_edge(i+m,n+m+1,1);\n        }\n        cout << max_flow(n+m, n+m+1) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\"\n \nusing namespace std;\nusing ll = long long int;\n \n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);cout<<(v)<<endl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(remove_const<decltype(l)>::type cnt=0;(cnt)<(l);++(cnt))\n#define rrepeat(cnt,l) for(auto cnt=(l)-1;0<=(cnt);--(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define diterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);--(cnt))\nconst ll MD = 1000000007ll; const long double PI = 3.1415926535897932384626433832795L;\ntemplate<typename T1, typename T2> inline void assert_equal(T1 expected, T2 actual) { if (!(expected == actual)) { cerr << \"assertion fault: expected=\" << expected << \" actual=\" << actual << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_less(T1 actual, T2 threshold) { if (!(actual < threshold)) { cerr << \"assertion fault: \" << actual << \" < (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_eqless(T1 actual, T2 threshold) { if (!(actual <= threshold)) { cerr << \"assertion fault: \" << actual << \" <= (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << '(' << p.first << ':' << p.second << ')'; return o; }\ntemplate<typename Vec> inline ostream& _ostream_vecprint(ostream &o, const Vec& p) { o << '['; for (auto& e : p) o << e << ','; o << ']'; return o; }\ntemplate<typename T> inline ostream& operator<<(ostream& o, const vector<T>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T, size_t S> inline ostream& operator<<(ostream& o, const array<T, S>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T> inline T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> inline T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(code); }\nmt19937_64 randdev(8901016);\ntemplate<typename T> inline T rand(T l, T h) { return uniform_int_distribution<T>(l, h)(randdev); }\ntemplate<> inline double rand<double>(double l, double h) { return uniform_real_distribution<double>(l, h)(randdev); }\ntemplate<> inline float rand<float>(float l, float h) { return uniform_real_distribution<float>(l, h)(randdev); }\n \n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif defined(__GNUC__)\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc && cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var * sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = '\\n') { for (auto it = begin; it != end; ++it) *this << *it << sep; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\nclass DGraphF {\npublic:\n    typedef int cap_t;\n    size_t n_;\n    struct Arc {\n        int from, to;\n        // 残量\n        cap_t left;\n        // 容量\n        cap_t cap;\n\n        Arc(int from = 0, int to = 0, cap_t w = 1) :from(from), to(to), left(w), cap(w) {}\n        inline bool operator<(const Arc& a) const { return (left != a.left) ? left < a.left : (left<a.left) | (cap<a.cap) | (from<a.from) | (to<a.to); }\n        inline bool operator==(const Arc& a) const { return (from == a.from) && (to == a.to) && (left == a.left) && (cap == a.cap); }\n    };\n    vector<vector<int>> vertex_to;\n    vector<vector<int>> vertex_from;\n    vector<Arc> edges;\n\n    DGraphF(int n = 1) :n_(n), vertex_to(n), vertex_from(n) { }\n\n    void connect(int from, int to, cap_t left) {\n        vertex_to[(size_t)from].push_back((int)edges.size()); // toto\n        vertex_from[(size_t)to].push_back((int)edges.size()); // fromfrom\n        edges.emplace_back(from, to, left);\n    }\n};\n\n\nvoid dinic(DGraphF &graph, vector<DGraphF::cap_t>& result, int i_source, int i_sink) {\n    assert(i_source != i_sink);\n\n    result.resize(graph.n_);\n    vector<int> dist(graph.n_);\n    queue<int> q;\n    vector<int> flag(graph.n_);\n\n    static function<DGraphF::cap_t(int, int, DGraphF::cap_t)> _dfs = [&](int u, int i_sink, DGraphF::cap_t mini) {\n        // DAG\n        // TODO: 経路再利用\n        if (i_sink == u) return mini;\n        if (flag[u]) return (DGraphF::cap_t) - 1;\n        flag[u] = true;\n\n        DGraphF::cap_t sumw = 0;\n        bool term = true;\n        for (int e : graph.vertex_to[u]) {\n            auto& edge = graph.edges[e];\n            if (edge.left > 0 && dist[u]>dist[edge.to]) {\n                DGraphF::cap_t w = (mini < 0) ? edge.left : min(edge.left, mini);\n\n                w = _dfs(edge.to, i_sink, w);\n                if (w == -1) continue;\n                edge.left -= w;\n                result[edge.to] += w;\n\n                sumw += w;\n                mini -= w;\n                term = false;\n                flag[u] = false; // TODO: 末尾では? \n\n                if (mini == 0) return sumw;\n            }\n        }\n        for (int e : graph.vertex_from[u]) {\n            auto& edge = graph.edges[e];\n            if (edge.cap>edge.left && dist[u]>dist[edge.from]) {\n                DGraphF::cap_t w = (mini < 0) ? (edge.cap - edge.left) : min(edge.cap - edge.left, mini);\n\n                w = _dfs(edge.from, i_sink, w);\n                if (w == -1) continue;\n                edge.left += w;\n                result[edge.to] -= w;\n\n                sumw += w;\n                mini -= w;\n                term = false;\n                flag[u] = false;\n                if (mini == 0) return sumw;\n            }\n        }\n        return term ? (DGraphF::cap_t)(-1) : sumw;\n    };\n\n\n    for (int distbegin = 0; ; distbegin += (int)graph.n_) {\n\n        q.emplace(i_sink); // bfsはsinkからsourceへの距離を計算．\n        dist[i_sink] = distbegin + 1;\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int ie : graph.vertex_from[v]) {\n                const auto edge = graph.edges[ie];\n                if (0 < edge.left && dist[edge.from] <= distbegin) {\n                    dist[edge.from] = dist[v] + 1;\n                    q.emplace(edge.from);\n                }\n            }\n            for (int ie : graph.vertex_to[v]) {\n                const auto edge = graph.edges[ie];\n                if (edge.left < edge.cap && dist[edge.to] <= distbegin) {\n                    dist[edge.to] = dist[v] + 1;\n                    q.emplace(edge.to);\n                }\n            }\n        }\n        fill(flag.begin(), flag.end(), false);\n\n        if (dist[i_source] <= distbegin)\n            break;\n        else\n            result[i_source] += _dfs(i_source, i_sink, -1);\n    }\n}\n\n\nint main(){\n    int blue[555],red[555];\n    \n    int m,n;\n    while(scanner >> m >> n, m != 0 || n != 0){\n        DGraphF g(m+n+2);\n        const int vs = m+n, vt = m+n+1;\n        scanner.in(blue,blue+m);\n        scanner.in(red,red+n);\n        repeat(i, m)\n            repeat(j, n)\n                if (gcd(blue[i],red[j])>1) g.connect(i,m+j,1);\n        repeat(i,m)\n            g.connect(v_s,i,1);\n        repeat(j,n)\n            g.connect(v_t,j,1);\n        \n        vector<int> f;\n        dinic(g,f,vs,vt);\n        printer << f[vt] << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define inf 1000000007\n#define rep(i, n) for(int i = 0; i < n; i++)\n\ntypedef long long ll;\n\nclass path {\npublic:\n  int t;\n  ll c;\n  int p;\n};\n\nclass dinic {\npublic:\n  int n;\n  vector<path> p;\n  vector<int>* v;\n  int* l;\n  int* o;\n  dinic(int nw) {\n    n = nw;\n    v = new vector<int>[n];\n    l = new int[n];\n    o = new int[n];\n  }\n  void add(int from, int to, ll cap) {\n    assert(from < n);\n    assert(to < n);\n    path w1, w2;\n    w1.t = to;\n    w1.c = cap;\n    w1.p = p.size() + 1;\n    v[from].push_back(p.size());\n    w2.t = from;\n    w2.c = 0;\n    w2.p = p.size();\n    v[to].push_back(p.size() + 1);\n    p.push_back(w1);\n    p.push_back(w2);\n  }\n  void dics(int from) {\n    rep(i, n) {\n      l[i] = inf;\n    }\n    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\n    pq.push(make_pair(0, from));\n    while(!pq.empty()) {\n      int k = pq.top().first;\n      int m = pq.top().second;\n      pq.pop();\n      if(l[m] > k) {\n        l[m] = k;\n        rep(i, v[m].size()) {\n          int x = v[m][i];\n          if(p[x].c > 0) {\n            pq.push(make_pair(k + 1, p[x].t));\n          }\n        }\n      }\n    }\n  }\n  ll dfs(int now, int to, ll mi) {\n    if(now == to) {\n      return mi;\n    }\n    ll all = 0;\n    while(o[now] < v[now].size()) {\n      int x = v[now][o[now]];\n      if(l[p[x].t] == l[now] + 1) {\n        ll w = dfs(p[x].t, to, min(mi - all, p[x].c));\n        p[x].c -= w;\n        p[p[x].p].c += w;\n        all += w;\n        if(mi - all == 0) {\n          break;\n        }\n      }\n      o[now]++;\n    }\n    return all;\n  }\n  ll solve(int from, int to) {\n    assert(from < n);\n    assert(to < n);\n    ll all = 0;\n    while(1) {\n      dics(from);\n      rep(i, n) {\n        o[i] = 0;\n      }\n      ll w = dfs(from, to, inf);\n      all += w;\n      if(w == 0) {\n        break;\n      }\n    }\n    return all;\n  }\n  ~dinic() {\n    delete[] v;\n    delete[] l;\n    delete[] o;\n  }\n};\n\nll gcd(ll a, ll b) {\n  if(a > b) {\n    return gcd(b, a);\n  }\n  if(b % a == 0) {\n    return a;\n  }\n  else {\n    return gcd(b % a, a);\n  }\n}\n\nll nd[1000], md[1000];\n\nint main() {\n  while(1) {\n    int n, m;\n    scanf(\"%d%d\",&n,&m);\n    if(n == 0) {\n      break;\n    }\n    rep(i, n) {\n      scanf(\"%lld\", nd + i);\n    }\n    rep(i, m) {\n      scanf(\"%lld\", md + i);\n    }\n    dinic s(2 + n + m);\n    rep(i, n) {\n      s.add(n + m, i, 1);\n    }\n    rep(i, m) {\n      s.add(n + i, n + m + 1, 1);\n    }\n    rep(i, n) {\n      rep(j, m) {\n        if(gcd(nd[i], md[j]) > 1) {\n          s.add(i, n + j, 1);\n        }\n      }\n    }\n    printf(\"%lld\\n\", s.solve(n + m, n + m + 1));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint M, N;\nint blue[510], red[510];\n\nint gcd(int a, int b) {\n    if(b == 0) return a;\n    return gcd(b, a%b);\n}\n\n// ?????¨??????????????° (?????§???????????£????§£???)\n// ?????????????????????????????????????????§??\\???????????? 2 ?????¨?????????\n\ntemplate <typename T>\nstruct Edge {\n    int to; T cap, cost; int rev;\n    Edge(int t, T c, int r) : to(t), cap(c), rev(r) {}\n    Edge(int t, T ca, T co, int r) : to(t), cap(ca), cost(co), rev(r) {}\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\nstruct BipartiteMatching {\n    int S, T, E, a, b;\n    vector< vector< Edge<int> > > G;\n    vector<int> used;\n    BipartiteMatching(int x, int y, int z) : S(x), T(y), E(z) {\n        G.resize(S+T+2);\n        used.resize(S+T+2);\n        a = S + T, b = a + 1;\n    }\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back(Edge<int>(to  , cap, G[to  ].size()    ));\n        G[to  ].push_back(Edge<int>(from, 0  , G[from].size() - 1));\n    }\n    void readGraph() {\n        for(int i=0; i<M; i++) {\n            for(int j=0; j<N; j++) {\n                if(gcd(blue[i], red[j]) != 1) {\n                    add_edge(i, j+S, 1);\n                }\n            }\n        }\n        for(int i=0; i<S; i++) add_edge(a  , i, 1);\n        for(int i=0; i<T; i++) add_edge(i+S, b, 1);\n    }\n    int dfs(int v, int t, int f) {\n        if(v == t) return f;\n        used[v] = true;\n        for(size_t i=0; i<G[v].size(); i++) {\n            Edge<int> &e = G[v][i];\n            if(!used[e.to] && e.cap > 0) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int solve() {\n        int flow = 0;\n        while(1) {\n            fill(used.begin(), used.end(), 0);\n            int f = dfs(a, b, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\n/*\nsigned main() {\n    int x, y, e; cin >> x >> y >> e;\n    BipartiteMatching B(x, y, e);\n    B.readGraph();\n    cout << B.solve() << endl;\n    return 0;\n}\n*/\n\nsigned main() {\n    while(cin >> M >> N, M || N) {\n        rep(i,0,M) cin >> blue[i];\n        rep(i,0,N) cin >> red[i];\n        BipartiteMatching B(M, N, 0);\n        B.readGraph();\n        cout << B.solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF (long long)(1e18)\n#define MOD (int)(1e9+7)\n\n#define yn(f) ((f)?\"Yes\":\"No\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n#define MAX 1100\n#define MAX_V MAX\n\nstruct edge{ int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nint V, E;\nint n, m;\nint a[MAX], b;\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back((edge){to,cap,(int)G[to].size()});\n\tG[to].push_back((edge){from, 0, (int)G[from].size()-1});\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tmemset(used, 0,sizeof(used));\n\t\tint f = dfs(s,t,INF);\n\t\tif(f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(7);\n\t\n\twhile(true){\n\t\n\tcin>>m>>n;\n\t\n\tif(!n&&!m) break;\n\t\n\tfor(int i = 0; i <= n+m+1; i++) G[i].clear();\n\t\n\tfor(int i = 1; i <= m; i++){\n\t\tcin>>a[i];\n\t\tadd_edge(0,i,1);\n\t}\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tcin>>b;\n\t\tfor(int j = 1; j <= m; j++){\n\t\t\tif(__gcd(a[j],b) != 1){\n\t\t\t\tadd_edge(j,i+m,1);\n\t\t\t}\n\t\t}\n\t\tadd_edge(i+m,n+m+1,1);\n\t}\n\t\n\tcout<<max_flow(0,n+m+1)<<endl;\n\t\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint m,n,b[500],r[500],p[1000],v[1000];\nvector<vector<int> >e;\nbool match(int s){\n\tif(s<0)return 1;\n\trep(i,e[s].size())if(!v[e[s][i]]){\n\t\tv[e[s][i]]=1;\n\t\tif(match(p[e[s][i]]))return p[s]=e[s][i],p[e[s][i]]=s,1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin>>m>>n,m){\n\t\trep(i,m)cin>>b[i];rep(i,n)cin>>r[i];\n\t\t\n\t\te.clear();e.resize(m+n);\n\t\trep(i,m)rep(j,n)if(__gcd(b[i],r[j])>1)e[i].push_back(m+j),e[m+j].push_back(i);\n\t\t\n\t\tint ans=0;rep(i,m+n)p[i]=-1;\n\t\trep(i,m){\n\t\t\trep(j,m+n)v[j]=0;\n\t\t\tif(match(i))ans++;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\nint M, N, B[500], R[500], P[500];\nbool C[500][500], V[500];\n\nbool match(int i) {\n\tif (i < 0) return true;\n\tfor (int j = 0; j < N; j++) {\n\t\tif (!C[i][j] || V[j]) continue;\n\t\tV[j] = true;\n\t\tif (match(P[j])) {\n\t\t\tP[j] = i;\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\treturn false;\n\n}int main() {\n\twhile (cin >> M >> N && M) {\n\t\tfor (int i = 0; i < M; i++)\n\t\t\tcin >> B[i];\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tcin >> R[j];\n\t\tfill(P, P + N, -1);\n\t\tfor (int i = 0; i < M; i++)\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\tC[i][j] = (__gcd(B[i], R[j]) >= 2);\n\t\tint count = 0;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tfill(V, V + N, false);\n\t\t\tif (match(i)) ++count;\n\t\t}\n\t\tcout << count << endl;\n\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<cmath>\nusing namespace std;\ntypedef vector<int> vi;\nconst int MAX_V=1e3+5;\nconst int INF=1e9;\nbool cando[505][505];\nint gcd(int a, int b)\n{\n  if(b==0) return a;\n  return gcd(b,a%b);\n}\nstruct edge\n{\n  int to,cap,rev;\n};\n\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap,vector<edge> *G)\n{\n  edge F;\n  edge T;\n  F.to=to;\n  F.cap=cap;\n  F.rev=G[to].size();\n  G[from].push_back(F);\n\n  T.to=from;\n  T.cap=0;\n  T.rev=G[from].size()-1;\n  G[to].push_back(T);\n}\n\nint dfs(int v,int t,int f,vector<edge> *G)\n{\n  if(v==t) return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)\n    {\n      edge &e=G[v][i];\n      if(!used[e.to] && e.cap>0)\n\t{\n\t  int d=dfs(e.to,t,min(f,e.cap),G);\n\t  if(d>0)\n\t    {\n\t      e.cap-=d;\n\t      G[e.to][e.rev].cap+=d;\n\t      return d;\n\t    }\n\t}\n    }\n  return 0;\n}\n\nint max_flow(int s,int t,vector<edge> *G)\n{\n  int flow=0;\n  while(1)\n    {\n      memset(used,false,sizeof(used));\n      int f=dfs(s,t,INF,G);\n      if(f==0) return flow;\n      flow+=f;\n    }\n}\n\nint main(void)\n{\n  int m,n;\n  while(cin >> m >> n && m)\n    {\n      memset(cando,false,sizeof(cando));\n      memset(used,false,sizeof(used));\n      vector<edge> G[1005];\n      int s=n+m;\n      int t=s+1;\n      vector<int> blue;\n      vector<int> red;\n      for (int i = 0; i < m; ++i)\n\t{\n\t  int b;\n\t  cin >>b;\n\t  blue.push_back(b);\n\t  add_edge(s,i,1,G);\n\t}\n      for (int i = 0; i < n; ++i)\n\t{\n\t  int r;\n\t  cin >> r;\n\t  red.push_back(r);\n\t  add_edge(m+i,t,1,G);\n\t}\n      for (int i = 0; i < m; ++i)\n\t{\n\t  for(int j=0;j<n;j++)\n\t    {\n\t      if(gcd(blue[i],red[j])>1)\n\t\t{\n\t\t  add_edge(i,m+j,1,G);\n\t\t}\n\t    }\n\t}\n      cout << max_flow(s,t,G) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <cmath>\n#include <map>\n#include <cstring>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for (int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define Cout(obj) cout << obj << endl\n#define Size(obj) (int)(obj).size()\n#define fcout cout << fixed << setprecision(10)\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nconst int MaxV = 10000;\n\nvector<int> graph[MaxV];\nint match[MaxV];\nbool used[MaxV];\n\nvoid addEdge(int u, int v)\n{\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n}\n\nbool dfs(int v)\n{\n    used[v] = true;\n\n    for (auto &e : graph[v])\n    {\n        int u = e, w = match[u];\n\n        if (w < 0 || !used[w] && dfs(w))\n        {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint bipartiteMatcing()\n{\n    int res = 0;\n\n    memset(match, -1, sizeof(match));\n\n    REP(v, MaxV)\n    {\n        if (match[v] < 0)\n        {\n            memset(used, 0, sizeof(used));\n\n            if (dfs(v))\n            {\n                res++;\n            }\n        }\n    }\n\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int M, N;\n    while(cin >> M >> N && M)\n    {\n        vector<int> B(M), R(N);\n\n        REP(i, 1010)\n        {\n            graph[i].clear();\n            match[i] = 0;\n            used[i] = false;\n        }\n\n        REP(i, M)\n        {\n            cin >> B[i];\n        }\n\n        REP(i, N)\n        {\n            cin >> R[i];\n        }\n\n        REP(i, M)\n        {\n            REP(j, N)\n            {\n                if(max(B[i], R[j]) % min(B[i], R[j]) == 0)\n                {\n                    addEdge(i, j + M);\n                }   \n            }\n        }\n\n         Cout(bipartiteMatcing());\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint V1, V2;\nint size[1002];\nint to[1002][1002];\nint dist[1002];\nint match[1002];\nconst int NIL = 1001;\nbool BFS(){\n  queue<int> que;\n  REP(v, V1){\n    if(match[v] == NIL){\n      dist[v] = 0;\n      que.push(v);\n    }else{\n      dist[v] = INF;\n    }\n  }\n  dist[NIL] = INF;\n  while(!que.empty()){\n    int v = que.front(); que.pop();\n    if(dist[v] < dist[NIL]){\n      for(int i = 0; i < size[v]; i++){\n        int u = to[v][i];\n        if(dist[match[u]] == INF){\n          dist[match[u]] = dist[v] + 1;\n          que.push(match[u]);\n        }\n      }\n    }\n  }\n  return dist[NIL] != INF;\n}\n\nbool DFS(int v){\n  if(v != NIL){\n    for(int i = 0; i < size[v]; i++){\n      int u = to[v][i];\n      if(dist[match[u]] == dist[v] + 1 && DFS(match[u])){\n        match[u] = v;\n        match[v] = u;\n        return true;\n      }\n    }\n    dist[v] = INF;\n    return false;\n  }\n  return true;\n}\n\nint Hopcroft_Karp(){\n  REP(v, V1 + V2) match[v] = NIL;\n  int matching = 0;\n  while(BFS()){\n    REP(v, V1){\n      if(match[v] == NIL && DFS(v)){\n        matching ++;\n      }\n    }\n  }\n  return matching;\n}\nint gcd(int x, int y){\n  int r = x % y;\n  if(r == 0) return y;\n  return gcd(y, r);\n}\nint main(){\n  while(scanf(\"%d %d\", &V1, &V2) && (V1 != 0 || V2 != 0)){\n    REP(i, V1) size[i] = 0;\n    static int blue[500];\n    static int red[500];\n    REP(i, V1) scanf(\"%d\", blue + i);\n    REP(i, V2) scanf(\"%d\", red + i);\n    REP(u, V1) REP(v, V2){\n      if(gcd(blue[u], red[v]) != 1) {\n        to[u][size[u]++] = V1 + v;\n        //G[u].push_back(V1 + v);\n        //G[V1 + v].push_back(u);\n      }\n    }\n    printf(\"%d\\n\", Hopcroft_Karp());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nstruct edge{int to,cap,rev;};\nstruct Dinic{\n    int n;\n    vector<vector<edge>> v;\n    vector<int> dist,iter;\n    Dinic(int n):n(n),v(n),dist(n),iter(n){}\n    void add_edge(int from,int to,int c){\n        int x=v[to].size(),y=v[from].size();\n        v[from].push_back({to,c,x});\n        v[to].push_back({from,0,y});\n    } \n\n    void bfs(int s){\n        fill(dist.begin(),dist.end(),-1);\n        queue<int> q;\n        dist[s]=0;\n        q.push(s);\n        while(!q.empty()){\n            int x=q.front();q.pop();\n            for(auto& e :v[x]){\n                if(e.cap&&dist[e.to]<0){\n                    dist[e.to]=dist[x]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    int dfs(int x,int t,int f){\n        if(x==t)return f;\n        for(int& i=iter[x];i<v[x].size();++i){\n            edge& e=v[x][i];\n            if(e.cap&&dist[x]<dist[e.to]){\n                int d=dfs(e.to,t,min(f,e.cap));\n                if(d>0){\n                    e.cap-=d;\n                    v[e.to][e.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int max_flow(int s,int t){\n        int ret=0;\n        while(1){\n            bfs(s);\n            if(dist[t]<0)return ret;\n            fill(iter.begin(),iter.end(),0);\n            int f;\n            while((f=dfs(s,t,inf))>0)ret+=f;\n        }\n    }\n};\n\nint gcd(int x,int y){\n    if(x<y)swap(x,y);\n    return y? gcd(y,x%y) : x;\n}\n\nvoid solve(int n,int m){\n    int a[n],b[m];\n    rep(i,n)cin>>a[i];\n    rep(i,m)cin>>b[i];\n    int s=n+m,t=n+m+1;\n    Dinic dn(n+m+2);\n    rep(i,n)rep(j,m){\n        if(gcd(a[i],b[j])>1)dn.add_edge(i, j+n, 1);\n    }\n    rep(i,n)dn.add_edge(s, i, 1);\n    rep(i,m)dn.add_edge(i+n, t, 1);\n    cout<<dn.max_flow(s, t)<<endl;\n}\nint main(){\n    int n,m;\n    while(cin>>n>>m,max(n,m)!=0)solve(n,m);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n#include <iterator>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define FOR( v, c ) for ( auto &v : c )\n\n#define EACH( it, c ) for ( auto it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n#define DRANGE( c, p ) (c).begin(), (c).begin() + p, (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nint gcd( int a, int b )\n{\n\tif ( b == 0 )\n\t{\n\t\treturn a;\n\t}\n\telse\n\t{\n\t\treturn gcd( b, a % b );\n\t}\n}\n\n// 二部グラフマッチング O( |V||E| )\nclass BipertiteMatching\n{\nprivate:\n\tconst int V;\n\tvector< vector<int> > G;\n\tvector<int> match;\n\tvector<bool> used;\n\npublic:\n\tBipertiteMatching( int v ) : V( v ), G( V ), match( V, -1 ), used( V )\n\t{\n\t\treturn;\n\t}\n\n\tvoid connect( int u, int v )\n\t{\n\t\tG[u].push_back( v );\n\t\tG[v].push_back( u );\n\t\treturn;\n\t}\n\n\tint solve()\n\t{\n\t\tint res = 0;\n\t\tfill( match.begin(), match.end(), -1 );\n\n\t\tfor ( int v = 0; v < V; ++v )\n\t\t{\n\t\t\tif ( match[v] == -1 )\n\t\t\t{\n\t\t\t\tfill( used.begin(), used.end(), false );\n\t\t\t\tif ( dfs( v ) )\n\t\t\t\t{\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\nprivate:\n\tint dfs( int v )\n\t{\n\t\tused[v] = true;\n\n\t\tfor ( int i = 0; i < G[v].size(); ++i )\n\t\t{\n\t\t\tint u = G[v][i], w = match[u];\n\t\t\tif ( w == -1 || !used[w] && dfs( w ) )\n\t\t\t{\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n};\n// BipertiteMatching( |V| )\n// connect( u, v )\n// solve()\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint n, m;\n\t\tcin >> n >> m;\n\n\t\tif ( !( n | m ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tVI as( n ), bs( m );\n\t\tFOR( a, as )\n\t\t{\n\t\t\tcin >> a;\n\t\t}\n\t\tFOR( b, bs )\n\t\t{\n\t\t\tcin >> b;\n\t\t}\n\n\t\tBipertiteMatching bm( n + m );\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tREP( j, 0, m )\n\t\t\t{\n\t\t\t\tif ( gcd( as[i], bs[j] ) == 1 )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbm.connect( i, n + j );\n\t\t\t}\n\t\t}\n\n\t\tcout << bm.solve() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nint gcd(int m,int n){\n  if (m==0||n==0){\n    return 0;\n  } else {\n    while(m!=n){\n      if(m>n){\n        m=m-n;\n      } else {\n        n=n-m;\n      }\n    }\n    return m;\n  }\n}\n\nclass bipartite_matching {\npublic:\n    int n;\n    std::vector<std::vector<int>> g;\n    std::vector<int> match;\n\n    bipartite_matching(int n_) : n(n_), g(n_), match(n_), used(n_) {}\n\n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    int maximum_matching(void) {\n        int res = 0;\n        fill(begin(match), end(match), -1);\n        for (int v = 0; v < n; ++v) {\n            if (match[v] == -1) {\n                fill(begin(used), end(used), false);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    std::vector<int> used;\n    bool dfs(int v) {\n        used[v] = true;\n        for (int u : g[v]) {\n            int w = match[u];\n            if (w == -1 || (!used[w] && dfs(w))) {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\n\nint main(){\n  while(1){\n    int m,n;\n    cin >> m >> n;\n    if(m==0)break;\n    vector<int> b(m),r(n);\n    rep(i,m)cin>>b[i];\n    rep(i,n)cin>>r[i];\n    bipartite_matching bm(m+n);\n    rep(i,m)rep(j,n){\n      if (gcd(b[i],r[j])>1){\n        bm.add_edge(i,j+m);\n      }\n    }\n    cout << bm.maximum_matching()<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define inf 1000000007\n#define rep(i, n) for(int i = 0; i < n; i++)\n\ntypedef long long ll;\n\nclass path {\npublic:\n  int t;\n  ll c;\n  int p;\n};\n\nclass dinic {\npublic:\n  int n;\n  vector<path> p;\n  vector<int>* v;\n  int* l;\n  int* o;\n  dinic(int nw) {\n    n = nw;\n    v = new vector<int>[n];\n    l = new int[n];\n    o = new int[n];\n  }\n  void add(int from, int to, ll cap) {\n    path w1, w2;\n    w1.t = to;\n    w1.c = cap;\n    w1.p = p.size() + 1;\n    v[from].push_back(p.size());\n    w2.t = from;\n    w2.c = 0;\n    w2.p = p.size();\n    v[to].push_back(p.size() + 1);\n    p.push_back(w1);\n    p.push_back(w2);\n  }\n  void dics(int from) {\n    rep(i, n) {\n      l[i] = inf;\n    }\n    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\n    pq.push(make_pair(0, from));\n    while(!pq.empty()) {\n      int k = pq.top().first;\n      int m = pq.top().second;\n      pq.pop();\n      if(l[m] > k) {\n        l[m] = k;\n        rep(i, v[m].size()) {\n          int x = v[m][i];\n          if(p[x].c > 0) {\n            pq.push(make_pair(k + 1, p[x].t));\n          }\n        }\n      }\n    }\n  }\n  ll dfs(int now, int to, ll mi) {\n    if(now == to) {\n      return mi;\n    }\n    ll all = 0;\n    while(o[now] < v[now].size()) {\n      int x = v[now][o[now]];\n      ll w = dfs(p[x].t, min(mi - all, p[x].c));\n      p[x].c -= w;\n      p[p[x].p].c += w;\n      all += w;\n      if(mi - all == 0) {\n        break;\n      }\n      o[now]++;\n    }\n    return all;\n  }\n  ll solve(int from, int to) {\n    ll all = 0;\n    while(1) {\n      dics(from);\n      rep(i, n) {\n        o[i] = 0;\n      }\n      int w = dfs(from, to, inf);\n      all += w;\n      if(w == 0) {\n        break;\n      }\n    }\n    return all;\n  }\n  ~dinic() {\n    delete[] v;\n    delete[] l;\n    delete[] o;\n  }\n};\n\nll gcd(ll a, ll b) {\n  if(a > b) {\n    return gcd(b, a);\n  }\n  if(b % a == 0) {\n    return a;\n  }\n  else {\n    return gcd(b % a, a);\n  }\n}\n\nll nd[1000], md[1000];\n\nint main() {\n  while(1) {\n    int n, m;\n    scanf(\"%d%d\",&n,&m);\n    if(n == 0) {\n      break;\n    }\n    rep(i, n) {\n      scanf(\"%lld\", nd + i);\n    }\n    rep(i, m) {\n      scanf(\"%lld\", md + i);\n    }\n    dinic s(2 + n + m);\n    rep(i, n) {\n      s.add(n + m, i, 1);\n    }\n    rep(i, m) {\n      s.add(n + i, n + m + 1, 1);\n    }\n    rep(i, n) {\n      rep(j, m) {\n        if(gcd(nd[i], md[j]) > 1) {\n          s.add(i, n + j, 1);\n        }\n      }\n    }\n    printf(\"%lld\\n\", s.solve(n + m, n + m + 1));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nclass MaxFlow {\npublic:\n    struct Edge {\n        ll to, cap, rev;\n    };\n    vector<vector<Edge>> G;\n    vector<ll> iter;\nprivate:\n    bool is_debug;\n    ll V;\n    vector<ll> bfs(ll s) {\n        vector<ll> dist(V, linf);\n        dist[s] = 0;\n        queue<ll> Q; Q.push(s);\n        while ( !Q.empty() ) {\n            ll v = Q.front(); Q.pop();\n            each(e, G[v]) {\n                if (e.cap > 0 && dist[e.to] == linf) {\n                    dist[e.to] = dist[v]+1;\n                    Q.push(e.to);\n                }\n            }\n        }\n        return dist;\n    }\n    ll dfs(ll v, ll t, ll f, const vector<ll>& dist, vector<bool>& used) {\n        if (v == t) return f;\n        if (used[v]) return 0;\n        used[v] = true;\n        for (ll i = iter[v]; i < G[v].size(); ++i) {\n            Edge& e = G[v][i];\n            if (e.cap > 0 && dist[e.to] == dist[v]+1) {\n                ll d = dfs(e.to, t, min(f, e.cap), dist, used);\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\npublic:\n    const vector<vector<Edge>> Graph() {\n        return G;\n    }\n    MaxFlow(ll V, bool is_debug=false) : V(V), G(V), is_debug(is_debug) {}\n    void init(ll n) {\n        V = n;\n        G.assign(V, vector<Edge>());\n    }\n    void add(ll from, ll to, ll cap) {\n        if (is_debug) cout << \"ADD: \" << from << \" \" << to << \" \" << cap << endl;\n        assert(V > 0);\n        G[from].pb({to, cap, (ll)G[to].size()});\n        G[to].pb({from, 0, (ll)G[from].size()-1});\n    }\n    // S -> s, T -> t ??? inf ???????????§\n    void add(ll from, ll to, ll min_flow, ll cap, ll S, ll T) {\n        if (is_debug) cout << endl << \"ADD_MIN:\" << from << \" \" << to << \" \" << min_flow << \" \" << cap << endl;\n        add(from, to, cap-min_flow);\n        add(S, to, min_flow);\n        add(from, T, cap);\n        if (is_debug) cout << endl;\n    }\n    ll flow(ll s, ll t, ll f=linf) {\n        ll res = 0;\n        while (f > 0) {\n            vector<ll> dist = bfs(s);\n            if (dist[t] == linf) break;\n            iter.assign(G.size(), 0);\n            while (f > 0) {\n                vector<bool> used(V, false);\n                ll df = dfs(s, t, f, dist, used);\n                if (df == 0) break;\n                f -= df;\n                res += df;\n            }\n        }\n        return res;\n    }\n};\nvector<ll> primes;\nvector<bool> is_prime;\nvoid init_primes() {\n    const ll mx = 1e4;\n    is_prime.assign(mx+1, true);\n    is_prime[0] = is_prime[1] = false;\n    rep(i, mx+1) {\n        if (!is_prime[i]) continue;\n        primes.pb(i);\n        for (ll j = i*2; j <= mx; j += i) {\n            is_prime[j] = false;\n        }\n    }\n}\nvector<ll> prime_divisors(ll n) {\n    vector<ll> res;\n    for (ll i = 0; primes[i]*primes[i] <= n; ++i) {\n        if (n % primes[i] == 0) {\n            ll a = primes[i], b = n/primes[i];\n            res.pb(a);\n            if (b < is_prime.size() && !is_prime[b]) continue;\n            if (a != b) res.pb(b);\n        }\n    }\n    sort(all(res));\n    return res;\n}\nll gcd(ll a, ll b) {\n    return b == 0 ? a : gcd(b, a%b);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, m;\n    init_primes();\n    while (cin >> n >> m, n || m) {\n        vector<ll> a(n), b(m); cin >> a >> b;\n        ll s = n+m, t = s+1;\n        MaxFlow mf(t+1);\n        rep(i, n) rep(j, m) {\n            if (gcd(a[i], b[j]) > 1) {\n                mf.add(i, n+j, 1);\n            }\n        }\n        rep(i, n) mf.add(s, i, 1);\n        rep(i, m) mf.add(n+i, t, 1);\n        // vector<vector<ll>> ad(n), bd(m);\n        // map<ll,ll> id;\n        // rep(i, n) ad[i] = prime_divisors(a[i]);\n        // rep(i, m) bd[i] = prime_divisors(b[i]);\n        // rep(i, n) each(x, ad[i]) id[x];\n        // rep(i, m) each(x, bd[i]) id[x];\n        // ll lid = 0;\n        // each(p, id) p.second = lid++;\n        // ll ids = lid;\n        // ll s = n+m+ids, t = s+1;\n        // MaxFlow mf(t+1);\n        // rep(i, n) mf.add(s, i, 1);\n        // rep(i, m) mf.add(n+i, t, 1);\n        // rep(i, n) each(x, ad[i]) mf.add(i, n+m+id[x], 1);\n        // rep(i, m) each(x, bd[i]) mf.add(n+m+id[x], n+i, 1);\n        cout << mf.flow(s, t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// 2013/07/05 Tazoe\n\n#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nint V; // 頂点数\nvector<int> G[1000]; // グラフの隣接リスト表現\nint match[1000]; // マッチングのペア\nbool used[1000]; // DFSですでに調べたかのフラグ\n\n// uからvを結ぶ辺をグラフに追加する\nvoid add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\n// 増加パスをDFSで探す\nbool dfs(int v) {\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++) {\n        int u = G[v][i], w = match[u];\n        if (w < 0 || !used[w] && dfs(w)) {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\n// 二部グラフの最大マッチングを求める\nint bipartite_matching() {\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for(int v = 0; v < V; v++) {\n        if (match[v] < 0) {\n            memset(used, 0, sizeof(used));\n            if (dfs(v)) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nint euclid(int a, int b)\n{\n\tif(a%b==0)\n\t\treturn b;\n\n\treturn euclid(b, a%b);\n}\t\n\nint main()\n{\n\twhile(true){\n\t\tint m, n;\n\t\tcin >> m >> n;\n\n\t\tif(m==0 && n==0)\n\t\t\tbreak;\n\n\t\tint b[500];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcin >> b[i];\n\t\t}\n\n\t\tint r[500];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> r[i];\n\t\t}\n\n\t\tV = m+n;\n\n\t\tfor(int i=0; i<1000; i++)\n\t\t\tG[i].clear();\n\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(euclid(b[i], r[j])>1)\n\t\t\t\t\tadd_edge(i, m+j);\n\t\t\t}\n\t\t}\n/*\n\t\tfor(int i=0; i<V; i++){\n\t\t\tfor(int j=0; j<G[i].size(); j++){\n\t\t\t\tcout << G[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n*/\n\n\t\tcout << bipartite_matching() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\ntypedef pair<LL, LL> P;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQ(c)     (c).erase(unique(ALL((c))),(c).end())\n# define mp          make_pair\n# define eb          emplace_back\n# define FOR(i,a,b)  for(int i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(int i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint m, n;\nint b[550], r[550];\n\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\nlong long lcm(long long a, long long b) {\n\tlong long g = gcd(a, b);\n\treturn a / g * b;\n}\n\nstruct edge { int to, cap, rev; };\n\nconst int MAX_SIZE = 2000;\n\nvector<edge>G[MAX_SIZE];\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size() });\n\tG[to].push_back(edge{ from, 0, (int)G[from].size() - 1 });\n}\n\nbool used[MAX_SIZE];\nint dfs(int p, int t, int f) {\n\tif (p == t)return f;\n\tused[p] = true;\n\n\tfor (int i = 0; i<G[p].size(); i++) {\n\t\tedge &e = G[p][i];\n\t\tif (used[e.to] || e.cap == 0)continue;\n\t\tint _f = dfs(e.to, t, min(f, e.cap));\n\t\tif (_f) {\n\t\t\te.cap -= _f;\n\t\t\tG[e.to][e.rev].cap += _f;\n\t\t\treturn _f;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint max_flow(int s, int t) {\n\tint flow = 0;\n\twhile (true) {\n\t\tREP(i, MAX_SIZE)used[i] = false;\n\t\tint f = dfs(s, t, INF);\n\t\tif (f)flow += f;\n\t\telse return flow;\n\t}\n}\n\nint main() {\n\tint s = 1234, t = 1235;\n\twhile (cin >> m >> n&&m&&n) {\n\n\t\tREP(i, MAX_SIZE) {\n\t\t\tG[i].clear();\n\t\t}\n\n\t\tREP(i, m) {\n\t\t\tcin >> b[i];\n\t\t\tadd_edge(s, i, 1);\n\t\t}\n\t\tREP(i, n) {\n\t\t\tcin >> r[i];\n\t\t\tadd_edge(m + i, t, 1);\n\t\t}\n\t\tREP(i, m) {\n\t\t\tREP(j, n) {\n\t\t\t\tif (gcd(b[i], r[j]) != 1)add_edge(i, j + m, 1);\n\t\t\t}\n\t\t}\n\t\tcout << max_flow(s, t) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 2222\nvector<int> v[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int a,int b){\n\tv[a].PB(b);\n\tv[b].PB(a);\n}\n\nbool matchdfs(int a){\n\tused[a] = true;\n\tfor(int i = 0;i < v[a].size();i++)\t{\n\t\tint u = v[a][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w)){\n\t\t\tmatch[u] = a;\n\t\t\tmatch[a] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//二部マッチング\nint two_matching_max(int l){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<int> prime;\n#define HOGE 111111\nbool isp[111111];\nvoid f(){\n\tREP(i,111111)isp[i] = true;\n\tisp[0] = isp[1] = false;\n\tfor(int i = 2;i < 111111;i++){\n\t\tif(isp[i]){\n\t\t\tprime.PB(i);\n\t\t\tfor(int j = i;j < 111111;j+=i)isp[j] = false;\n\t\t}\n\t}\n}\n\t\n#define HALF 1000\nint main(){\n\tf();\n\tint n,m;\n\twhile(cin >> n >> m,n|m){\n\t\tREP(i,MAX_V)v[i].clear();\n\t\tvector<int> a(n);REP(i,n)cin >> a[i];\n\t\tvector<int> b(m);REP(i,m)cin >> b[i];\n\t\tREP(i,n){\n\t\t\tvector<int> tmp;\n\t\t\tREP(j,prime.size()){\n\t\t\t\tif(a[i] % prime[j] == 0)tmp.PB(prime[j]);\n\t\t\t}\n\t\t\tREP(j,m){\n\t\t\t\tREP(k,tmp.size()){\n\t\t\t\t\tif(b[j] % tmp[k] == 0){\n\t\t\t\t\t\tadd_edge(i,j + 1000);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << two_matching_max(MAX_V) << endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 4444\nvector<int> v[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int a,int b){\n\tv[a].PB(b);\n\tv[b].PB(a);\n}\n\nbool matchdfs(int a){\n\tused[a] = true;\n\tfor(int i = 0;i < v[a].size();i++)\t{\n\t\tint u = v[a][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w)){\n\t\t\tmatch[u] = a;\n\t\t\tmatch[a] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//二部マッチング\nint two_matching_max(int l){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<int> prime;\n#define HOGE 111111\nbool isp[HOGE];\nvoid f(){\n\tREP(i,HOGE)isp[i] = true;\n\tisp[0] = isp[1] = false;\n\tfor(int i = 2;i < HOGE;i++){\n\t\tif(isp[i]){\n\t\t\tprime.PB(i);\n\t\t\tfor(int j = i;j < HOGE;j+=i)isp[j] = false;\n\t\t}\n\t}\n}\n\t\n#define HALF 1000\nint main(){\n\tf();\n\tint n,m;\n\twhile(cin >> m >> n,n|m){\n\t\tREP(i,MAX_V)v[i].clear();\n\t\tvector<int> a(m);REP(i,m)cin >> a[i];\n\t\tvector<int> b(n);REP(i,n)cin >> b[i];\n\t\tREP(i,m){\n\t\t\tvector<int> tmp;\n\t\t\tREP(j,prime.size()){\n\t\t\t\tif(a[i] % prime[j] == 0)tmp.PB(prime[j]);\n\t\t\t}\n\t\t\tREP(j,n){\n\t\t\t\tREP(k,tmp.size()){\n\t\t\t\t\tif(b[j] % tmp[k] == 0){\n\t\t\t\t\t\tadd_edge(i,j + 1000);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << two_matching_max(MAX_V) << endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n// ------ Variable ------ //\n\nint N, M;\n\n\n// ------ Greatest Common Divisor ------ //\n\nint GCD(int a, int b)\n{\n\tif (a % b == 0) { return b; }\n\tif (b % a == 0) { return a; }\n\n\tif (a > b) { return GCD(a % b, b); }\n\tif (b > a) { return GCD(b % a, a); }\n}\n\n\n// ------ Bipartite Matching ------ //\n\nvector<vector<int> > Graph;\n\nvector<int> match;\n\nvector<bool> used;\n\nbool dfs(int v)\n{\n\tused[v] = true;\n\n\tfor (int i = 0; i < Graph[v].size(); i++)\n\t{\n\t\tint u = Graph[v][i], w = match[u];\n\n\t\tif (w < 0 || !used[w] && dfs(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint Bipartite_Matching()\n{\n\tint Ans = 0;\n\n\tmatch = vector<int>(N + M, -1);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (match[i] < 0)\n\t\t{\n\t\t\tused = vector<bool>(N + M, 0);\n\n\t\t\tif (dfs(i))\n\t\t\t{\n\t\t\t\tAns++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Ans;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> N >> M;\n\n\t\tif (N == 0 && M == 0) { break; }\n\n\t\tGraph = vector<vector<int> >(N + M, vector<int>());\n\n\t\tvector<int> A(N);\n\t\tvector<int> B(M);\n\n\t\tfor (int i = 0; i < N; i++) { cin >> A[i]; }\n\t\tfor (int i = 0; i < M; i++) { cin >> B[i]; }\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < M; j++)\n\t\t\t{\n\t\t\t\tif (GCD(A[i], B[j]) != 1)\n\t\t\t\t{\n\t\t\t\t\tGraph[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << Bipartite_Matching() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int my_inf=2147483647;\nconst long long int my_linf=9223372036854775807;\n\n\n\n#define _GLIBCXX_DEBUG\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\nconst int INF = 2147483647;\nconst long long int L_INF = 9223372036854775807;\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n\n//流量0の逆辺も張らないと正しく求まらないので注意\nWeight maximumFlow(const Graph &ag, int s, int t) {\n\n\tGraph g(ag);\n\tfor (int i = 0; i < ag.size(); ++i) {\n\t\tfor (int j = 0; j < ag[i].size(); ++j) {\n\t\t\tint d = ag[i][j].dst;\n\t\t\tint s = ag[i][j].src;\n\n\t\t\tbool ok = false;\n\t\t\tfor (int k = 0; k < ag[d].size(); ++k) {\n\t\t\t\tif (ag[d][k].src == s) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tg[d].push_back(Edge(d, s, 0));\n\t\t\t}\n\t\t}\n\t}\n\tint n = g.size();\n\tMatrix flow(n, Array(n)), capacity(n, Array(n));\n\tREP(u, n) FOR(e, g[u]) capacity[e->src][e->dst] += e->weight;\n\n\n\tWeight total = 0;\n\twhile (1) {\n\t\tqueue<int> Q; Q.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile (!Q.empty() && prev[t] < 0) {\n\t\t\tint u = Q.front(); Q.pop();\n\t\t\tFOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > 0) {\n\t\t\t\tprev[e->dst] = u;\n\t\t\t\tQ.push(e->dst);\n\t\t\t}\n\t\t}\n\t\tif (prev[t] < 0) return total; // prev[x] == -1 <=> t-side\n\t\tWeight inc = INF;\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tinc = min(inc, RESIDUE(prev[j], j));\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tflow[prev[j]][j] += inc, flow[j][prev[j]] -= inc;\n\t\ttotal += inc;\n\t}\n}\n\nlong long int gcd(long long int l, long long int r) {\n\tassert(l > 0 && r > 0);\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tif (r%l) {\n\t\t\treturn gcd(l, r%l);\n\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (1) {\n\n\n\t\tint m, n; cin >> m >> n;\n\t\tif (!m)break;\n\t\tvector<int>blues, reds;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint a; cin >> a;\n\t\t\tblues.push_back(a);\n\t\t}\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tint a; cin >> a;\n\t\t\treds.push_back(a);\n\t\t}\n\t\tconst int start = 0;\n\t\tconst int bluea = 1;\n\t\tconst int blueb = bluea + m;\n\t\tconst int reda = blueb + m;\n\t\tconst int redb = reda + n;\n\t\tconst int goal = redb + n;\n\t\tGraph g(goal + 1);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tg[start].push_back(Edge(start, bluea + i, 1));\n\t\t\tg[bluea + i].push_back(Edge(bluea + i, blueb + i, 1));\n\t\t}\n\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (gcd(blues[i], reds[j]) != 1) {\n\t\t\t\t\tg[blueb + i].push_back(Edge(blueb + i, reda + j, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tg[reda + i].push_back(Edge(reda + i, redb + i, 1));\n\t\t\tg[redb + i].push_back(Edge(redb + i, goal, 1));\n\n\t\t}\n\t\tint ans = maximumFlow(g, start, goal);\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <complex>\n#include <limits>\nusing namespace std;\ntypedef complex<double> P;\n\n#define EPS (1e-10)\n#define REP(i,n) for(int i = 0; i < (int)(n); i++)\n#define FOR(it,c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\n\ntypedef double Weight;\nconst Weight WEIGHT_INFTY = numeric_limits<Weight>::max() / 4;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n\t\tEdge(int a,int b){\n\t\t\tsrc = a;\n\t\t\tdst = b;\n\t\t}\n};\nbool operator<(const Edge& a, const Edge& b) {\n    return (a.weight < b.weight);\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\n \nint gcd(int x,int y){\n\treturn y ? gcd(y,x%y) : x ;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tvector<int> l,r;\n\t\tGraph g;\n\t\tREP(i,n){ int a; cin>>a; l.push_back(a); }\n\t\tREP(i,m){ int a; cin>>a; r.push_back(a); }\n\t\t\n\t\tREP(i,l.size()){\n\t\t\tvector<Edge> node;\n\t\t\tREP(j,r.size())if( gcd(l[i],r[j])>1 ){\n\t\t\t\tnode.push_back( Edge(i,j+n) );\n\t\t\t}\n\t\t\tg.push_back( node );\n\t\t}\n\t\tREP(i,r.size()){\n\t\t\tvector<Edge> node;\n\t\t\tREP(j,l.size())if(gcd(r[i],l[j])>1){\n\t\t\t\tnode.push_back( Edge(i+n,j) );\n\t\t\t}\n\t\t\tg.push_back( node );\n\t\t}\n\t\t/*\n\t\tREP(i,g.size()){\n\t\t\tREP(j,g[i].size()){\n\t\t\t\tprintf(\"%d:(%d,%d)\\n\",i,g[i][j].src,g[i][j].dst);\n\t\t\t}\n\t\t}*/\n\t\tEdges ed;\n\t\tint ret = bipartiteMatching(g, n, ed);\n\t\t/*\n\t\tREP(i,ed.size()){\n\t\t\tprintf(\"%d -> %d\\n\",ed[i].src,ed[i].dst);\n\t\t}\n\t\t*/\n\t\tprintf(\"%d\\n\",ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst int MAX_V = 1000;\nint V; //????????°\nvector<int> G[MAX_V]; //??°??????\nint match[MAX_V]; // ??????????????°????????¢\nbool used[MAX_V]; // dfs??§??¢???????????????\n\nvoid add_edge(int u, int v){\n    G[u].push_back(v); G[v].push_back(u);\n}\n\n// ?¢???????????????¢?´¢\nbool bp_dfs(int v){\n    used[v]=true;\n    rep(i,G[v].size()){\n        int u=G[v][i], w=match[u];\n        if(w<0 || (!used[w]&&bp_dfs(w))){\n            match[v]=u; match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(){\n    int ret=0;\n    memset(match,-1,sizeof(match));\n    rep(i,V){\n        if(match[i]<0){\n            memset(used,0,sizeof(used));\n            if(bp_dfs(i)) ++ret;\n        }\n    }\n    return ret;\n}\n\nconst int N=3170;\nbool prime[N+1];\nvector<int> p;\n\nint main()\n{\n    fill(prime,prime+N+1,true);\n    prime[0]=prime[1]=false;\n    for(int i=2; i<=N; ++i)\n    {\n        if(prime[i])for(int j=i*2; j<=N; j+=i) prime[j]=false;\n    }\n\n    rep(i,N)if(prime[i]) p.pb(i);\n\n    // printf(\"size %d\\n\", p.size());\n\n    int m,n;\n    while(scanf(\" %d %d\",&m,&n),m)\n    {\n        vector<int> b(m),r(n);\n        rep(i,m) scanf(\" %d\", &b[i]);\n        rep(i,n) scanf(\" %d\", &r[i]);\n\n        V = n+m;\n        rep(i,MAX_V) G[i].clear();\n\n        rep(i,m)rep(j,n)\n        {\n            if(b[i]==r[j]) add_edge(i,m+j);\n        }\n\n        rep(i,m)rep(j,n)if(b[i]!=r[j])\n        {\n            rep(k,p.size())\n            {\n                int d=p[k];\n                if(b[i]%d==0 && r[j]%d==0)\n                {\n                    add_edge(i,m+j);\n                    break;\n                }\n            }\n        }\n\n        printf(\"%d\\n\", bipartite_matching());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <iterator>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int src,int dst,int weight):src(src),dst(dst),weight(weight){}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool DFS(Graph& g,int v,vi& used,vi& match)\n{\n\tused[v]=true;\n\trep(i,g[v].size()){\n\t\tint u=g[v][i].dst,w=match[u];\n\t\tif(w==-1 || !used[w] && DFS(g,w,used,match)){\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint BiparateMatching(const Graph& _g,int m)\n{\n\tint n=_g.size()-m;\n\tGraph g=_g;\n\trep(i,_g.size())\n\t\tforeach(e,_g[i])\n\t\t\tg[e->dst].push_back(Edge(e->dst,e->src,e->weight));\n\t\n\tvi used(m+n);\n\tvi match(m+n,-1);\n\tint res=0;\n\trep(i,m+n){\n\t\tif(match[i]==-1){\n\t\t\tfill(allof(used),0);\n\t\t\tres+=DFS(g,i,used,match);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tfor(int m,n;cin>>m>>n,m|n;){\n\t\tvi bs(m),rs(n);\n\t\trep(i,m) cin>>bs[i];\n\t\trep(i,n) cin>>rs[i];\n\t\tGraph g(m+n);\n\t\trep(i,m) rep(j,n)\n\t\t\tif(__gcd(bs[i],rs[j])>1)\n\t\t\t\tg[i].push_back(Edge(i,m+j,1));\n\t\tcout<<BiparateMatching(g,m)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nclass MaxFlow {\npublic:\n    struct Edge {\n        ll to, cap, rev;\n    };\n    vector<vector<Edge>> G;\n    vector<ll> iter;\nprivate:\n    bool is_debug;\n    ll V;\n    vector<ll> bfs(ll s) {\n        vector<ll> dist(V, linf);\n        dist[s] = 0;\n        queue<ll> Q; Q.push(s);\n        while ( !Q.empty() ) {\n            ll v = Q.front(); Q.pop();\n            each(e, G[v]) {\n                if (e.cap > 0 && dist[e.to] == linf) {\n                    dist[e.to] = dist[v]+1;\n                    Q.push(e.to);\n                }\n            }\n        }\n        return dist;\n    }\n    ll dfs(ll v, ll t, ll f, const vector<ll>& dist, vector<bool>& used) {\n        if (v == t) return f;\n        if (used[v]) return 0;\n        used[v] = true;\n        for (ll& i = iter[v]; i < G[v].size(); ++i) {\n            Edge& e = G[v][i];\n            if (e.cap > 0 && dist[e.to] == dist[v]+1) {\n                ll d = dfs(e.to, t, min(f, e.cap), dist, used);\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\npublic:\n    const vector<vector<Edge>> Graph() {\n        return G;\n    }\n    MaxFlow(ll V, bool is_debug=false) : V(V), G(V), is_debug(is_debug) {}\n    void init(ll n) {\n        V = n;\n        G.assign(V, vector<Edge>());\n    }\n    void add(ll from, ll to, ll cap) {\n        if (is_debug) cout << \"ADD: \" << from << \" \" << to << \" \" << cap << endl;\n        assert(V > 0);\n        G[from].pb({to, cap, (ll)G[to].size()});\n        G[to].pb({from, 0, (ll)G[from].size()-1});\n    }\n    // S -> s, T -> t ??? inf ???????????§\n    void add(ll from, ll to, ll min_flow, ll cap, ll S, ll T) {\n        if (is_debug) cout << endl << \"ADD_MIN:\" << from << \" \" << to << \" \" << min_flow << \" \" << cap << endl;\n        add(from, to, cap-min_flow);\n        add(S, to, min_flow);\n        add(from, T, cap);\n        if (is_debug) cout << endl;\n    }\n    ll flow(ll s, ll t, ll f=linf) {\n        ll res = 0;\n        while (f > 0) {\n            vector<ll> dist = bfs(s);\n            if (dist[t] == linf) break;\n            iter.assign(G.size(), 0);\n            while (f > 0) {\n                vector<bool> used(V, false);\n                ll df = dfs(s, t, f, dist, used);\n                if (df == 0) break;\n                f -= df;\n                res += df;\n            }\n        }\n        return res;\n    }\n};\nvector<ll> primes;\nvector<bool> is_prime;\nvoid init_primes() {\n    const ll mx = 1e4;\n    is_prime.assign(mx+1, true);\n    is_prime[0] = is_prime[1] = false;\n    rep(i, mx+1) {\n        if (!is_prime[i]) continue;\n        primes.pb(i);\n        for (ll j = i*2; j <= mx; j += i) {\n            is_prime[j] = false;\n        }\n    }\n}\nvector<ll> prime_divisors(ll n) {\n    vector<ll> res;\n    for (ll i = 0; primes[i]*primes[i] <= n; ++i) {\n        if (n % primes[i] == 0) {\n            ll a = primes[i], b = n/primes[i];\n            res.pb(a);\n            if (b < is_prime.size() && !is_prime[b]) continue;\n            if (a != b) res.pb(b);\n        }\n    }\n    sort(all(res));\n    return res;\n}\nll gcd(ll a, ll b) {\n    return b == 0 ? a : gcd(b, a%b);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, m;\n    init_primes();\n    while (cin >> n >> m, n || m) {\n        vector<ll> a(n), b(m); cin >> a >> b;\n        ll s = n+m, t = s+1;\n        MaxFlow mf(t+1);\n        rep(i, n) rep(j, m) {\n            if (gcd(a[i], b[j]) > 1) {\n                mf.add(i, n+j, 1);\n            }\n        }\n        rep(i, n) mf.add(s, i, 1);\n        rep(i, m) mf.add(n+i, t, 1);\n        // vector<vector<ll>> ad(n), bd(m);\n        // map<ll,ll> id;\n        // rep(i, n) ad[i] = prime_divisors(a[i]);\n        // rep(i, m) bd[i] = prime_divisors(b[i]);\n        // rep(i, n) each(x, ad[i]) id[x];\n        // rep(i, m) each(x, bd[i]) id[x];\n        // ll lid = 0;\n        // each(p, id) p.second = lid++;\n        // ll ids = lid;\n        // ll s = n+m+ids, t = s+1;\n        // MaxFlow mf(t+1);\n        // rep(i, n) mf.add(s, i, 1);\n        // rep(i, m) mf.add(n+i, t, 1);\n        // rep(i, n) each(x, ad[i]) mf.add(i, n+m+id[x], 1);\n        // rep(i, m) each(x, bd[i]) mf.add(n+m+id[x], n+i, 1);\n        cout << mf.flow(s, t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <map>\n#include <ctime>\n#include <cstdlib>\n \nusing namespace std;\n \ntypedef int lli;\ntypedef pair<lli, lli> P;\ntypedef vector<double> array;\ntypedef vector<array> matrix;\nconst double EPS = 1e-8;\n\nlli gcd(lli a, lli b){\n\treturn (b == 0 ? a : gcd(b, a%b));\n}\n \nlli rank(matrix &A){\n\tlli n = A.size();\n  lli res = 0;\n\tmatrix B(n, array(n+1,1));\n  for(lli i=0;i<n;i++) for(lli j=0;j<n;j++) B[i][j] = A[i][j];\n    \n  for(lli i=0;i<n;i++){\n    lli pivot = i;\n    for(lli j=i;j<n;j++){\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n    }\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i]) > EPS) res++;\n    if(abs(B[i][i]) > EPS){\n      for(lli j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n      for(lli j=0;j<n;j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tfor(lli k=i+1;k<=n;k++) B[j][k] -= B[j][i] * B[i][k];\n\t\t\t\t}\n      }\n    }\n  }\n  return res;\n}\n \nint main(){\n\tsrand((unsigned)time(NULL));\n\tlli n, m;\n\twhile(cin >> n >> m && (n|m)){\n\t\tvector<int> A(n), B(m);\n\t\tfor(int i=0;i<n;i++) cin >> A[i];\n\t\tfor(int i=0;i<m;i++) cin >> B[i];\n\t\tvector<P> edge;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(gcd(A[i], B[j]) > 1){\n\t\t\t\t\tedge.push_back(make_pair(i, n+j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlli ans = 0;\n\t\tmatrix mat(n+m, array(n+m, 0));\n\t\tfor(lli i=0;i<edge.size();i++){\n\t\t\tlli tmp = rand() + 10;\n\t\t\tlli a = edge[i].first, b = edge[i].second;\n\t\t\tmat[a][b] = tmp;\n\t\t\tmat[b][a] = -tmp;\n\t\t}\n\t\tcout << rank(mat) / 2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nconst int MAX = 3000;\nconst int INF = 1e8;\n#define gcd(a,b) __gcd(a,b)\n\nstruct edge{ \n  int to, cap, rev;\n};\n\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to ,cap ,G[to].size()});\n  G[to].push_back((edge){from ,0 ,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0 ; i < G[v].size() ; i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n\n  for(;;){\n    memset(used,false,sizeof(used));\n    int f = dfs(s,t,INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main(){\n  int m,n,b,r;\n  \n  while(cin >> m >> n , m + n){\n    vector<int> B,R;\n    int s = m+n,t = s+1;\n    memset(G,0,sizeof(G));\n    for(int i = 0 ; i < m ; i++){\n      cin >> b;\n      B.push_back(b);\n      add_edge(s,i,1);\n    }\n\n    for(int j = 0 ; j < n ; j++){\n      cin >> r;\n      R.push_back(r);\n      add_edge(m+j,t,1);\n    }\n \n    for(int i = 0 ; i < m ; i++){\n      for(int j = 0 ; j < n ; j++){\n\tif(gcd(B[i],R[j]) != 1){\n\t  add_edge(i,m+j,1);\n\t}\n      }\n    }\n    cout << max_flow(s,t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nstruct BipartiteMatching {\n    vector<vector<int> > G;\n    vector<int> match;\n    vector<bool> used;\n\n    int V;\n    BipartiteMatching(int V):V(V){\n        G.resize(V);\n        match.resize(V);\n        used.resize(V);\n    }\n\n    void add_edge(int u,int v) {\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    bool dfs(int v) {\n        used[v]=true;\n        for(int i=0;i<G[v].size();i++){\n            int u=G[v][i];\n            int w=match[u];\n            if(w<0||!used[w]&&dfs(w)) {\n                match[v]=u;\n                match[u]=v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int operator() () {\n        int res=0;\n        match.assign(V,-1);\n        for(int v=0;v<V;v++){\n            if(match[v]<0) {\n                used.assign(V,0);\n                if(dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n};\n\nint m,n;\nint b[502];\nint r[502];\n\nvoid solve() {\n    rep(i,m) cin>>b[i];\n    rep(i,n) cin>>r[i];\n    BipartiteMatching bm(m+n);\n\n    rep(i,m) rep(j,n) {\n        if(__gcd(b[i],r[j])>1) {\n            bm.add_edge(i,j+m);\n            bm.add_edge(j+m,i);\n        }\n    }\n\n    cout<<bm()<<endl;\n\n}\n\nint main() {\n    while(cin>>m>>n) {\n        if(n+m==0) break;\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nclass bipartite_matching{\nprivate:\n  int V;\n  vector< vector< int > > info;\n  vector< int > match;\n  vector< bool > used;\npublic:\n  bipartite_matching(int V_size):V(V_size){\n    info.resize(V_size);\n    used.resize(V_size);\n    match.resize(V_size);\n  };\n  void add_edge( int u, int v){\n    info[u].push_back(v);\n    info[v].push_back(u);\n  }\n  bool dfs( int v){\n    used[v] = true;\n    for(int i = 0; i < info[v].size(); i++){\n      int u = info[v][i], w = match[u];\n      if(w < 0 || !used[w] && dfs(w)){\n        match[v] = u, match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n  int run(){\n    match.assign(V,-1);\n    int ret = 0;\n    for(int i = 0; i < V; i++){\n      if(match[i] < 0){\n        used.assign(V,false);\n        if(dfs(i)) ret++;\n      }\n    }\n    return ret;\n  }\n};\n\nint main(){\n  int m, n, b[500], r[500];\n  while(cin >> m >> n , m){\n    bipartite_matching bm(n + m);\n    for(int i = 0; i < m; i++){\n      cin >> b[i];\n    }\n    for(int i = 0; i < n; i++){\n      cin >> r[i];\n    }\n    for(int i = 0; i < m; i++){\n      for(int j = 0; j < n; j++){\n        if(__gcd(b[i],r[j]) > 1) bm.add_edge( i, m + j);\n      }\n    }\n    cout << bm.run() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nclass MaxFlow {\npublic:\n    struct Edge {\n        ll to, cap, rev;\n    };\n    vector<vector<Edge>> G;\n    vector<ll> iter;\nprivate:\n    bool is_debug;\n    ll V;\n    vector<ll> bfs(ll s) {\n        vector<ll> dist(V, linf);\n        dist[s] = 0;\n        queue<ll> Q; Q.push(s);\n        while ( !Q.empty() ) {\n            ll v = Q.front(); Q.pop();\n            each(e, G[v]) {\n                if (e.cap > 0 && dist[e.to] == linf) {\n                    dist[e.to] = dist[v]+1;\n                    Q.push(e.to);\n                }\n            }\n        }\n        return dist;\n    }\n    ll dfs(ll v, ll t, ll f, const vector<ll>& dist, vector<bool>& used) {\n        if (v == t) return f;\n        if (used[v]) return 0;\n        used[v] = true;\n        for (ll& i = iter[v]; i < G[v].size(); ++i) {\n            Edge& e = G[v][i];\n            if (e.cap > 0 && dist[e.to] == dist[v]+1) {\n                ll d = dfs(e.to, t, min(f, e.cap), dist, used);\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\npublic:\n    const vector<vector<Edge>> Graph() {\n        return G;\n    }\n    MaxFlow(ll V, bool is_debug=false) : V(V), G(V), is_debug(is_debug) {}\n    void init(ll n) {\n        V = n;\n        G.assign(V, vector<Edge>());\n    }\n    void add(ll from, ll to, ll cap) {\n        if (is_debug) cout << \"ADD: \" << from << \" \" << to << \" \" << cap << endl;\n        assert(V > 0);\n        G[from].pb({to, cap, (ll)G[to].size()});\n        G[to].pb({from, 0, (ll)G[from].size()-1});\n    }\n    // S -> s, T -> t ??? inf ???????????§\n    void add(ll from, ll to, ll min_flow, ll cap, ll S, ll T) {\n        if (is_debug) cout << endl << \"ADD_MIN:\" << from << \" \" << to << \" \" << min_flow << \" \" << cap << endl;\n        add(from, to, cap-min_flow);\n        add(S, to, min_flow);\n        add(from, T, cap);\n        if (is_debug) cout << endl;\n    }\n    ll flow(ll s, ll t, ll f=linf) {\n        ll res = 0;\n        while (f > 0) {\n            vector<ll> dist = bfs(s);\n            if (dist[t] == linf) break;\n            iter.assign(G.size(), 0);\n            while (f > 0) {\n                vector<bool> used(V, false);\n                ll df = dfs(s, t, f, dist, used);\n                if (df == 0) break;\n                f -= df;\n                res += df;\n            }\n        }\n        return res;\n    }\n};\nvector<ll> prime_divisors(ll n) {\n    vector<ll> res;\n    for (ll i = 2; i*i <= n; ++i) {\n        if (n % i != 0) continue;\n        res.pb(i);\n        while (n % i == 0) n /= i;\n    }\n    if (n > 1) res.pb(n);\n    // sort(all(res));\n    return res;\n}\nll gcd(ll a, ll b) {\n    return b == 0 ? a : gcd(b, a%b);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, m;\n    while (cin >> n >> m, n || m) {\n        vector<ll> a(n), b(m); cin >> a >> b;\n        // ll s = n+m, t = s+1;\n        // MaxFlow mf(t+1);\n        // rep(i, n) rep(j, m) {\n        //     if (gcd(a[i], b[j]) > 1) {\n        //         mf.add(i, n+j, 1);\n        //     }\n        // }\n        // rep(i, n) mf.add(s, i, 1);\n        // rep(i, m) mf.add(n+i, t, 1);\n        vector<vector<ll>> ad(n), bd(m);\n        map<ll,ll> id;\n        rep(i, n) ad[i] = prime_divisors(a[i]);\n        rep(i, m) bd[i] = prime_divisors(b[i]);\n        rep(i, n) each(x, ad[i]) id[x];\n        rep(i, m) each(x, bd[i]) id[x];\n        ll lid = 0;\n        each(p, id) p.second = lid++;\n        ll ids = lid;\n        ll s = n+m+ids, t = s+1;\n        MaxFlow mf(t+1);\n        rep(i, n) mf.add(s, i, 1);\n        rep(i, m) mf.add(n+i, t, 1);\n        rep(i, n) each(x, ad[i]) mf.add(i, n+m+id[x], 1);\n        rep(i, m) each(x, bd[i]) mf.add(n+m+id[x], n+i, 1);\n        cout << mf.flow(s, t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nstruct edge\n{\n  int to;\n  int from;\n  int cap;\n  int rev;\n};\n\nint s=0, t;\nbool visited[1000];\nvector<edge> g[1000];\nint red_card[500], blue_card[500];\n\nint max_flow();\nint get_card();\nvoid print_g();\nint dfs(int node, int f);\n\nvoid clear()\n{\n  for(int i=0;i<1000;i++)\n    {\n      g[i].clear();\n    }\n}\n\nint main()\n{\n  while(true)\n    {\n      clear();\n      if(get_card()==-1)\n\t{\n\t  break;\n\t}\n  cout << max_flow() << endl;\n  //print_g();\n    }\n  return 0;\n}\n  \nvoid print_g()\n{\n  for(int i=0;i<=t;i++)\n    {\n      for(int j=0;j<g[i].size();j++)\n\t{\n\t  if(g[i][j].cap!=0)\n\t    {\n\t  cout << \"{\" << g[i][j].from << g[i][j].to << g[i][j].cap << g[i][j].rev << \"}\";\n\t    }\n\t}\n      cout << endl;\n    }\n}\n\nint max_flow()\n{\n  int sum = 0, f=0;\n  \n  while(1)\n    {\n      fill(visited ,visited+1000, false);\n      f = dfs(s, INT_MAX/3);\n      \n      if(f==0)\n\t{\n\t  break;\n\t}\n      sum += f;\n    }\n  return sum;\n}\n\n\nint dfs(int node, int f)\n{\n  //  cout << \"node:\" <<node << \" f:\" << f;\n  int d = 0;\n \n  if(node == t)//goal\n    {\n      //  cout <<\"f:\"<< f << endl;\n      return f;\n    }\n  else if(visited[node]==true)// if visited\n    {\n      return -1;\n    }\n  else\n    {\n      visited[node]=true;//visited\n    }\n\n  for(int i=0;i<g[node].size();i++)//root form node\n    {\n      edge& e = g[node][i];\n      // cout <<\" e,to:\"  <<e.to <<endl;\n      if(e.cap != 0)\n\t{\n\t  d = dfs(e.to, min(f, e.cap));\n\t  /*if(dfs(g[node][i].to, f) == 1)\n\t    {\n\t    return 1;\n\t    }*/\n\t  //   cout << \"node:\" << node << \" f:\" << f << \" d:\" << d << endl;      \n\t  if(d>0)\n\t    {\n\t      e.cap -= d;\n\t      g[e.to][e.rev].cap += d;\n\t      \n\t      return d;\n\t    }\n\t}\n\n    }\n  return 0;\n}\n\n\nvoid add_edge(int i, int j)\n{\n  g[i].push_back({j, i, 1, (int)g[j].size()});\n  g[j].push_back({i, j, 0, (int)g[i].size()-1});\n}\n\nint get_card()\n{\n  int red, blue;\n  cin >> blue >> red;\n  if(blue == 0)\n    {\n      return -1;\n    }\n  for(int i=0;i<blue;i++)\n    {\n      cin >> blue_card[i];\n    }\n  for(int i=0;i<red;i++)\n    {\n      cin >> red_card[i];\n    }\n  \n  \n  for(int i=0;i<blue;i++)\n    {\n      for(int j=0;j<red;j++)\n\t{\n\t  if(__gcd(blue_card[i], red_card[j])!=1)\n\t    {// to from cap rev\n\t      add_edge(i+1, j+blue+1);\n\t      //g[i+1].push_back({j+blue+1, i+1, 1,(int)g[j+1].size()});\n\t      //g[j+1].push_back({i+1, j+blue+1, 0, (int)g[i+1].size()-1});\n\t    }\n\t}\n    }\n\n   for(int i=1;i<=blue;i++)\n    {\n      add_edge(0, i);\n      //g[0].push_back({i, 0, 1, (int)g[i].size()});\n      //g[i].push_back({0, i, 0, (int)g[0].size()-1});\n    }\n\n   t = blue+red+1;\n   for(int i=blue+1;i<t;i++)\n     {\n       add_edge(i, t);\n       //g[i].push_back({t, i, 1, (int)g[t].size()});\n       // g[t].push_back({i, t, 0, (int)g[i].size()-1});\n     }\n\n   /*  for(int i=0;i<=t;i++)\n    {\n      for(int j=0;j<g[i].size();j++)\n\t{\n\t  cout << \"{\" << g[i][j].from << g[i][j].to << g[i][j].cap << g[i][j].rev << \"}\";\n\t}\n      cout << endl;\n    }\n   */return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,r) for(auto& (i) : (r))\n\nusing namespace std;\n\nstruct Edge{\n  \tint src, dst;\n    Edge(int s, int d) : src(s),dst(d){}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool augment(const Graph& g, int u, vector<int>& matchTo, vector<bool>& visited) {\n  \tif (u < 0) return true;\n  \tFOR(e, g[u]) if (!visited[e.dst]) {\n    \tvisited[e.dst] = true;\n    \tif (augment(g, matchTo[e.dst], matchTo, visited)) {\n      \t\tmatchTo[e.src] = e.dst;\n      \t\tmatchTo[e.dst] = e.src;\n      \t\treturn true;\n    \t}\n  \t}\n  \treturn false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\n\nint gcd(int x, int y){\n  if(x<y)return gcd(y,x);\n  if(y==0)return x;\n  return gcd(y,x%y);\n}\n\nint main() {\n  while(1){\n    int m,n;\n    cin >> m >> n;\n    if(!m) break;\n    vector<int> b(m);\n    vector<int> a(n);\n    REP(i,m) cin >> b[i];\n    REP(i,n) cin >> a[i];\n    Graph g(n+m);\n    REP(i,m)REP(j,n){\n      if(gcd(b[i],a[j]) != 1){\n        g[i].push_back(Edge(i, j+m));\n      }\n    }\n    Edges e;\n    cout << bipartiteMatching(g, m, e) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct BipartiteMatching {\n    int n, timestamp;\n    vector<vector<int>> graph;\n    vector<int> alive, used, match;\n    BipartiteMatching(int n) : \\\n    n(n), timestamp(0), graph(n), alive(n, 1), used(n, 0), match(n, -1) { }\n    void add_edge(int u, int v) {\n        graph[u].emplace_back(v);\n        graph[v].emplace_back(u);\n    }\n    bool dfs(int idx) {\n        used[idx] = timestamp;\n        for (auto &to: graph[idx]) if (alive[to]) {\n            int to_match = match[to];\n            if (to_match == -1 || (used[to_match] != timestamp && dfs(to_match))) {\n                match[idx] = to;\n                match[to] = idx;\n                return true;\n            }\n        }\n        return false;\n    }\n    int bipartite_matching(int ret = 0) {\n        for (int i = 0; i < n; i++) if (alive[i]) {\n            if (match[i] == -1) ++timestamp, ret += dfs(i);\n        }\n        return ret;\n    }\n    friend ostream& operator<<(ostream& os, BipartiteMatching& bm) {\n        for (int i = 0; i < bm.n; i++) if (i < bm.match[i]) {\n            os << i << \" - \" << bm.match[i] << endl;\n        }\n        return os;\n    }\n};\n\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n\nint main() {\n    int m, n;\n    while (cin >> m >> n, m) {\n        BipartiteMatching bm(m + n);\n        vector<int> left(m), right(n);\n        for (int& li: left) cin >> li;\n        for (int& ri: right) cin >> ri;\n        for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) {\n            if (gcd(left[i], right[j]) > 1) bm.add_edge(i, j + m);\n        }\n        cout << bm.bipartite_matching() << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                     #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,int>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\nint pr[100010];\nint inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n \n \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n\n\n                         //----------------kokomade tenpure------------\n\n\ntypedef pair<int,int> P;\nstruct edge{ int to,cap,cost,rev;};\nvector<int> G[100010];\nbool used[100010]={0};\nint match[100010]={0};\nint V;//V???????????°\n\nvoid add_edge(int u,int v){\nG[u].push_back(v);\nG[v].push_back(u);\n}\n\nbool ddffss(int v){\nused[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0 || !used[w] &&ddffss(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bi_match(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(ddffss(v)){\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\n\nint n,m;\n\nint a[1000],b[1000];\nsigned main(){\n\twhile(1){\n\t\tfor(int i=0;i<100000;i++) G[i].clear();\n\t\t\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tV=10000;\n\t\tfor(int i=0;i<n;i++) cin>>a[i];\n\t\tfor(int j=0;j<m;j++) cin>>b[j];\n\t\t\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<m;j++){\n\t\t\tif(gcd(a[i],b[j])!=1){\n\t\t\t\tadd_edge(i,1000+j); \n\t//\t\t\tcout<<i<<\" \"<<j<<endl;\n\t\t\t}\n\t//\tcout<<i<<\" \"<<j<<endl;\n\t\t}\n\t//\tcout<<n<<\" \"<<m<<endl;\n\t\tcout<<bi_match()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<utility>\n#include<ctype.h>\n\n#define FOR(i,n) for(int i=0;i<n;++i)\nlong long int  memo[100001] = {};\nconst int inf = 1 << 30;\n\nint main() {\n\tint n, m;\n\twhile (true){\n\t\tstd::cin >> n >> m;\n\t\tif (!n) {\n\t\t\tbreak;\n\t\t}\n\t\tint a[500], b[500], ct = 0;\n\t\tFOR(i, n)std::cin >> a[i];\n\t\tFOR(i, m)std::cin >> b[i];\n\t\tif (n >= m) {\n\t\t\tFOR(i, n) {\n\t\t\t\tbool ok = 0;\n\t\t\t\tif(!ok)\n\t\t\t\tfor (int j = 2; j <= a[i]; ++j) {\n\t\t\t\t\tif(a[i]%j==0)FOR(k, m) {\n\t\t\t\t\t\tif (b[k] % j == 0) {\n\t\t\t\t\t\t\t++ct;\n\t\t\t\t\t\t\tb[k] = 1;\n\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tFOR(i, m) {\n\t\t\t\tbool ok = 0;\n\t\t\t\tif (!ok)\n\t\t\t\t\tfor (int j = 2; j <= b[i]; ++j) {\n\t\t\t\t\t\tif (b[i] % j == 0)FOR(k, n) {\n\t\t\t\t\t\t\tif (a[k] % j == 0) {\n\t\t\t\t\t\t\t\t++ct;\n\t\t\t\t\t\t\t\ta[k] = 1;\n\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << ct << std::endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<n; i++)\n\nint m, n;\nint b[555];\nint r[555];\nint V;\nvector<int> G[555+555];\nint match[555+555];\nint used[555+555];\n\ninline int gcd(int a, int b)\n{\n  int t;\n  while(b){\n    t = a;\n    a = b;\n    b = t % b;\n  }\n  return a;\n}\n\nbool dfs(int v)\n{\n  used[v] = true;\n  rep(i, G[v].size()){\n    int u = G[v][i], w = match[u];\n    if(w < 0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint matching()\n{\n  int res = 0;\n  rep(i, V) match[i] = -1;\n  rep(v, V){\n    if(match[v] < 0){\n      rep(i, V) used[i] = 0;\n      if(dfs(v)) res += 1;\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  while(cin >> m >> n, m){\n    rep(i, m) cin >> b[i];\n    rep(i, n) cin >> r[i];\n    V = m + n;\n    rep(i, V) G[i].clear();\n\n    rep(i, m) rep(j, n) if(gcd(b[i], r[j]) > 1){\n      G[i].push_back(j + m);\n      G[m + j].push_back(i);\n    }\n\n    cout << matching() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nint b[501],r[501],m,n;\nint primes[10050];\nvector<int> G[1001];\n\nint gcd(int x,int y) {\n    if(y == 0) return x;\n    return gcd(y,x%y);\n}\n\nbool bfs(vector<int> &pair_v,vector<int> &dist) {\n    queue<int> Q;\n    const int NIL = n+m;\n    fill(dist.begin(), dist.end(), 1<<29);\n    for(int i=0; i<n+m; ++i)\n        if(pair_v[i] == NIL) {\n            dist[i] = 0;\n            Q.push(i);\n        }\n\n    while(!Q.empty()) {\n        int v = Q.front(); Q.pop();\n        if(v != NIL) {\n            for(int i=0; i<G[v].size(); ++i) {\n                if(dist[pair_v[G[v][i]]] == 1<<29) {\n                    dist[pair_v[G[v][i]]] = dist[v]+1;\n                    Q.push(pair_v[G[v][i]]);\n                }\n            }\n        }\n    }\n    return dist[NIL] != 1<<29;\n}\n\nbool dfs(int v,vector<int> &pair_v,vector<int> &dist) {\n    const int NIL = n+m;\n    if(v != NIL) {\n        for(int i=0; i<G[v].size(); ++i) {\n            int u = G[v][i];\n            if(dist[pair_v[u]] == dist[v]+1) {\n                if(dfs(pair_v[u],pair_v,dist)) {\n                    pair_v[u] = v;\n                    pair_v[v] = u;\n                    return true;\n                }\n            }\n        }\n        dist[v] = 1<<29;\n        return false;\n    }\n    return true;\n}\n\nint biparate_matching() {\n    vector<int> pair_v(n+m+1, n+m); // NIL == n+m\n    vector<int> dist(n+m+1);\n    int matching = 0;\n    int bc = 0;\n    while(bfs(pair_v,dist)) {\n        //cout<<\"bfs : \"<<bc<<endl;\n        bc++;\n        for(int i=0; i<n+m; ++i) {\n            if(pair_v[i] == n+m) if(dfs(i,pair_v,dist)) {\n                    matching++;\n                }\n        }\n    }\n    return matching;\n}\n\nint main() {\n    int i,j;\n    while(cin>>m>>n, m|n) {\n        rep(i,m) cin>>b[i];\n        rep(i,n) cin>>r[i];\n\n\n        rep(i,n+m) G[i].clear();\n        rep(i,m) rep(j,n) {\n            if(gcd(b[i],r[j]) > 1) {\n                G[i].push_back(j+m);\n                G[j+m].push_back(i);\n                //cout<<\"add edge \"<<i<<\" \"<<j<<endl;\n            }\n        }\n\n        //cout<<\"let's matching\"<<endl;\n\n        cout<<biparate_matching()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 4444\nvector<int> v[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int a,int b){\n\tv[a].PB(b);\n\tv[b].PB(a);\n}\n\nbool matchdfs(int a){\n\tused[a] = true;\n\tfor(int i = 0;i < v[a].size();i++)\t{\n\t\tint u = v[a][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w)){\n\t\t\tmatch[u] = a;\n\t\t\tmatch[a] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//二部マッチング\nint two_matching_max(int l){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<int> prime;\n#define HOGE 111111\nbool isp[HOGE];\nvoid f(){\n\tREP(i,HOGE)isp[i] = true;\n\tisp[0] = isp[1] = false;\n\tfor(int i = 2;i < HOGE;i++){\n\t\tif(isp[i]){\n\t\t\tprime.PB(i);\n\t\t\tfor(int j = i;j < HOGE;j+=i)isp[j] = false;\n\t\t}\n\t}\n}\n\nint gcd(int a,int b){\n\tif(a < b)swap(a,b);\n\tif(b == 0)return a;\n\treturn gcd(b,a%b);\n}\n\t\n#define HALF 1000\nint main(){\n\tint n,m;\n\twhile(cin >> m >> n,n|m){\n\t\tREP(i,MAX_V)v[i].clear();\n\t\tvector<ll> a(m);REP(i,m)cin >> a[i];\n\t\tvector<ll> b(n);REP(i,n)cin >> b[i];\n\t\tREP(i,m){\n\t\t\tREP(j,n){\n\t\t\t\tif(gcd(a[i],b[j]) > 1)add_edge(i,j+1000);\n\t\t\t}\n\t\t}\n\t\tcout << two_matching_max(MAX_V) << endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_V = 10000;\nconst int INF = 100000000;\n\n// ¸_\nint V;\n// OtÌXg\\»\nvector<int> G[MAX_V];\n// }b`OÌyA\nint match[MAX_V];\n// dfsÅ·ÅÉ²×½©Ç¤©ÌtO\nstatic bool used[MAX_V];\n\n// uÆvðÔÓðOtÉÇÁ\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\n// ÁpXðdfsÅT·\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i],w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// ñOtÌÅå}b`Oðßé\nint bipartite_matching(){\n\tint res = 0;\n\t//memset(match,-1,sizeof(match));\n\tfor(int i = 0; i < MAX_V; i++)\n\t\tmatch[i]=-1;\n\tfor(int v = 0; v < V; v++){\n\t\tif(match[v] < 0){\n\t\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\t\tused[i]=false;\n\t\t\t//memset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int a,int b){\n\tif(b==0)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\n\n\nint main(){\n\n\tint n,m;\n\twhile(cin>>m>>n&&!(m==0&&n==0)){\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\tG[i].clear();\n\n\t\tvector<int> bs,rs;\n\t\tint b,r;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin>>b;\n\t\t\tbs.push_back(b);\n\t\t\tV++;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>r;\n\t\t\trs.push_back(r);\n\t\t\tV++;\n\t\t}\n\t\tfor(int i = 0; i < rs.size(); i++){\n\t\t\tfor(int j = 0;j < bs.size(); j++){\n\t\t\t\tint res=gcd(rs[i],bs[j]);\n\t\t\t\tif(res!=1)\n\t\t\t\t\tadd_edge(i,j+rs.size());\n\t\t\t}\n\t\t}\n\t\tcout<<bipartite_matching()<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <iomanip>\n#include <climits>\n#include <fstream>\n#include <random>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define revrep(i, n) for(int i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n#define chmin(x, y) x = min(x, y);\n#define chmax(x, y) x = max(x, y);\n#define sz(x) ((int)(x).size())\n\n//const ll INFL = LLONG_MAX;//10^18 = 2^60\nconst ll INFL = 1LL<<60;\n//const int INF = INT_MAX;\nconst int INF = 1 << 30;//10^9\nll MOD = 1000000007;\n//const ll MOD = 998244353;\ndouble EPS = 1e-10;\n\nvector<ll> dy = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, 0, -1, 0, 1, -1, 1, -1, 0};\n\nvoid pres(double A){printf(\"%.12lf\\n\", A);}\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nll cnt_bit(ll x){return __builtin_popcountll(x);}\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x; k /= 2;\n  }\n  return res;\n}\n\nll pow_mod(ll x, ll k){\n  x %= MOD;\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\n\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nll lcm(ll x, ll y){\n  ll res = x / gcd(x, y);\n  res *= y;\n  return res;\n};\n\n\n#define MAX_V 2000\nstruct edge {ll to, cap, rev;};\nvector<edge> G[MAX_V];\nll level[MAX_V];\nll iter[MAX_V];\n\nvoid init_flow(){\n  rep(i, MAX_V){\n    G[i].resize(0);\n  }\n}\n\nvoid add_edge(ll from, ll to, ll cap){\n  G[from].push_back((edge){to, cap, (ll)G[to].size()});\n  G[to].push_back((edge){from, 0, (ll)G[from].size() - 1});\n}\n\nvoid bfs(ll s){\n  rep(i, MAX_V) level[i] = -1;\n  queue<ll> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    ll v = que.front(); que.pop();\n    for(ll i = 0; i < G[v].size(); i++){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nll dfs(ll v, ll t, ll f){\n  if(v == t) return f;\n  for(ll &i = iter[v]; i < G[v].size(); i++){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      ll d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nll max_flow(ll s, ll t){\n  ll flow = 0;\n  for(;;){\n    bfs(s);\n    if(level[t] < 0) return flow;\n    rep(i, MAX_V) iter[i] = 0;\n    ll f;\n    while((f = dfs(s, t, INFL)) > 0){\n      flow += f;\n    }\n  }\n}\n\n\n\nint n, m;\nint a[510], b[510];\nvoid solve(){\n  while(true){\n    cin >> n >> m;\n    if(n == 0 && m == 0) return;\n    rep(i, n) cin >> a[i];\n    rep(i, m) cin >> b[i];\n    init_flow();\n    rep(i, n)rep(j, m){\n      if(gcd(a[i], b[j]) != 1){\n        add_edge(i, 600+j, 1);\n      }\n    }\n    int s = 1200, t = 1201;\n    rep(i, n){\n      add_edge(s, i, 1);\n    }\n    rep(i, m){\n      add_edge(600+i, t, 1);\n    }\n    cout << max_flow(s, t) << endl;\n  }\n}\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  cin.tie(0), cout.tie(0);\n  solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <queue>\nusing namespace std;\n\nstruct Dinic {\n\tstatic const int INF = 1e9;\n\n\tstruct E {\n\t\t//to,??????,?????????index\n\t\tint to, cap, rev;\n\t\tE(int t, int c, int r) {\n\t\t\tto = t;\n\t\t\tcap = c;\n\t\t\trev = r;\n\t\t}\n\t};\n\n\t//?????§????????°\n\tint MAX_V;\n\tvector<vector<E>>G;\n\tDinic(int max_v) {\n\t\tMAX_V = max_v;\n\t\tG.resize(MAX_V);\n\t}\n\n\t//?????????\n\tinline void add_edge(int from, int to, int cap) {\n\t\tif (from == to)return;\n\t\tG[from].push_back(E(to, cap, G[to].size()));\n\t\tG[to].push_back(E(from, 0, G[from].size() - 1));\n\t}\n\n\t//?????????\n\tinline void add_undirected_edge(int from, int to, int cap) {\n\t\tif (from == to)return;\n\t\tG[from].push_back(E(to, cap, G[to].size()));\n\t\tG[to].push_back(E(from, cap, G[from].size() - 1));\n\t}\n\n\t//??±???\n\tvector<int>level;\n\n\t//??±?????????????????????\n\tvoid bfs(int s) {\n\t\tlevel.assign(MAX_V, -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tE &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//s -- v -- u -- t\n\t//t????????±???????????¢?´¢\n\tint dfs(int s, int u, int crr) {\n\t\tif (s == u || crr == 0)return crr;\n\n\t\tint sum = 0;\n\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tE& e = G[u][i];\t\t\t\t//u - v\n\t\t\tint v = e.to;\n\t\t\tE& ee = G[v][e.rev];\t\t//v - u\n\n\t\t\tif (level[v] >= level[u] || ee.cap <= 0)continue;\n\n\t\t\tint f = dfs(s, v, min(crr - sum, ee.cap));\n\t\t\tif (f <= 0)continue;\n\n\t\t\t//???????????´??°\n\t\t\tee.cap -= f;\n\t\t\te.cap += f;\n\n\t\t\t//???????????´??°\n\t\t\tsum += f;\n\n\t\t\tif (sum == crr)break;\n\t\t}\n\n\t\treturn sum;\n\t}\n\n\tint max_flow(int s, int t) {\n\t\tint flow = 0;\n\t\t//t??????????????????????????§\n\t\twhile (1) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tflow += dfs(s, t, INF);\n\t\t}\n\t}\n};\n\nint gcd(int a, int b) {\n\tif (b == 0)return a;\n\n\treturn gcd(b,a%b);\n}\n\nint main()\n{\n\twhile (1) {\n\t\tint m, n; cin >> m >> n;\n\t\tif (m == 0)break;\n\n\t\tvector<int>b(m), r(n);\n\t\tfor (int i = 0; i < m; i++)cin >> b[i];\n\t\tfor (int i = 0; i < n; i++)cin >> r[i];\n\n\t\tDinic dnc(m + n + 2);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (gcd(b[i], r[j]) != 1) {\n\t\t\t\t\tdnc.add_edge(i, m + j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++)dnc.add_edge(m + n, i, 1);\n\t\tfor (int j = 0; j < n; j++)dnc.add_edge(m + j, m + n + 1, 1);\n\n\t\tint ans = dnc.max_flow(m+n, m+n+1);\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nconst int MAX_V = 1000;\n\nint V;\nvvi G(MAX_V, vi());\nvi match(MAX_V);\nvi used(MAX_V);\n\nvoid add_edge(int u, int v) {\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v) {\n\tused[v] = 1;\n\tint size = G[v].size();\n\tREP(i, size) {\n\t\tint u = G[v][i], w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching() {\n\tint res = 0;\n\tREP(i, MAX_V) {\n\t\tmatch[i] = -1;\n\t}\n\tREP(i, V) {\n\t\tif(match[i] < 0) {\n\t\t\tREP(j, MAX_V) {\n\t\t\t\tused[j] = 0;\n\t\t\t}\n\t\t\tif(dfs(i)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int a, int b) {\n\tif(b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\nint main() {\n\tint m, n;\n\twhile(cin >> m >> n, m) {\n\t\tV = m+n;\n\t\tREP(i, MAX_V) {\n\t\t\tG[i].clear();\n\t\t\tmatch[i] = -1;\n\t\t\tused[i] = 0;\n\t\t}\n\t\tvi a(m), b(n);\n\t\tREP(i, m) {\n\t\t\tcin >> a[i];\n\t\t}\n\t\tREP(i, n) {\n\t\t\tcin >> b[i];\n\t\t}\n\t\tREP(i, m) {\n\t\t\tREP(j, n) {\n\t\t\t\tif(gcd(a[i], b[j]) != 1) {\n\t\t\t\t\tadd_edge(i, m+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond(b);i<i##_cond;++i)\n#define rall(a) (a).rbegin(),(a).rend()\n#define sz(x) ((int)(x).size())\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n#define inf 1<<30\n\nvector<int> prime(int n){\n  // n以下の素数を要素に持つviを返す\n  // 時間 O(n ln ln n)\n  // 答えのサイズ n / ln n\n\n  vector<bool> isprime(n+1, true);\n  vector<int> ans;\n  isprime[0] = isprime[1] = false;\n  FOR(i, 2, n+1)\n    if(isprime[i]){\n      ans.push_back(i);\n      for(int j = 2 * i; j <= n; j += i) isprime[j] = false;\n    }\n  return ans;\n}\n\n// dinic\nstruct max_flow {\n    struct edge { int to, cap, rev; };\n    int V;\n    vector<vector<edge>> G;\n    vector<int> itr, level;\n\n    max_flow(int _V) : V(_V) { G.assign(_V,vector<edge>()); }\n\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back((edge) {to, cap, (int) G[to].size()});\n        G[to].push_back((edge) {from, 0, (int) G[from].size()-1});\n    }\n\n    void bfs(int s) {\n        level.assign(V,-1);\n        queue<int> q;\n        level[s] = 0; q.push(s);\n        while (!q.empty()) {\n            int v = q.front(); q.pop();\n            for(auto &e: G[v]){\n                if (e.cap > 0 and level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int& i = itr[v]; i < (int) G[v].size(); ++i) {\n            edge& e = G[v][i];\n            if (e.cap > 0 and level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int run(int s, int t) {\n        int ret = 0, f;\n        while (bfs(s), level[t] >= 0) {\n            itr.assign(V,0);\n            while ((f = dfs(s, t, inf)) > 0) ret += f;\n        }\n        return ret;\n    }\n};\n\nint main(){  \n  vi p = prime(10000000);\n  \n  while(1){\n    // input\n    int m, n; cin >> m >> n; if(m == 0) break;\n    vi b(m); rep(i, m) cin >> b[i]; sort(rall(b));\n    vi r(n); rep(i, n) cin >> r[i]; sort(rall(r));\n\n    // 初期化\n    struct max_flow f(n+m+2); // 左右+1+1\n    rep(i,m) f.add_edge(0, i+1, 1); // sから左側\n    rep(i,n) f.add_edge(m+i+1, m+n+1, 1); // 右側からt\n\n    // 同じ素因数を持つとき辺を追加\n    rep(i,m) rep(j,n) rep(k,sz(p)){\n      if(b[i] < p[k] or r[j] < p[k]) break;\n      if(b[i] % p[k] == 0 and r[j] % p[k] == 0){\n\tf.add_edge(i+1, m+j+1, 1);\n\tbreak;\n      }\n    }\n\n    // フローを流す\n    int ans = f.run(0,n+m+1);\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64, i64> P;\n#define rep(i, s, e) for (int i = (s); i <= (e); i++)\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nusing i64 = long long;\n\nstruct Graph {\n  struct edge {\n    int to;\n    i64 cap;\n    i64 rev;\n  };\n\n  int n;\n  vector<vector<edge>> edges;\n\n  Graph(int N) {\n    n = N;\n    edges.resize(n, vector<edge>());\n  }\n\n  int size() const { return n; }\n\n  vector<edge> &operator[](int v) { return edges[v]; }\n};\n\nstruct Dinic {\n  int N;\n  vector<int> level;\n  vector<int> itr;\n  Graph G;\n\n  Dinic(int n) : G(n) { N = n; }\n\n  void add_edge(int from, int to, int cap, int rev_cap) {\n    G[from].push_back({to, cap, (int)G[to].size()});\n    G[to].push_back({from, rev_cap, (int)G[from].size() - 1});\n  }\n\n  bool g_level(int s, int t) {\n    level.assign(N, -1);\n    queue<int> que;\n    que.push(s);\n    level[s] = 0;\n    while (!que.empty()) {\n      int v = que.front();\n      que.pop();\n      for (auto &e : G[v]) {\n        if (e.cap > 0 && level[e.to] == -1) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return level[t] >= 0;\n  }\n\n  i64 dfs(int v, int t, i64 f) {\n    if (v == t)\n      return f;\n\n    for (int &i = itr[v]; i < G[v].size(); i++) {\n      auto &e = G[v][i];\n      if (e.cap > 0 && level[e.to] > level[v]) {\n        i64 mi_f = dfs(e.to, t, min(f, e.cap));\n        if (mi_f > 0) {\n          e.cap -= mi_f;\n          G[e.to][e.rev].cap += mi_f;\n          return mi_f;\n        }\n      }\n    }\n    return 0;\n  }\n\n  i64 max_flow(int s, int t) {\n    i64 result = 0;\n    i64 flow;\n    while (g_level(s, t)) {\n      itr.assign(N, 0);\n      while ((flow = dfs(s, t, 1e9)) > 0)\n        result += flow;\n    }\n    return result;\n  }\n};\n\n/*\n\nchecked\n    http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2723921#1\n*/\n\nint gcd(int a,int b){\n\tif(b == 0) return a;\n\treturn gcd(b,a % b);\n}\n\nint m;\nint n;\n\nint main() {\n  while (cin >> m >> n, n) {\n    vector<int> a(m + 1), b(n + 1);\n    rep(i, 1, m) { cin >> a[i]; }\n    rep(i, 1, n) { cin >> b[i]; }\n\tDinic din(m + n + 2);\n\tint s= 0;\n\tint t = m + n + 1;\n\trep(i,1,m){\n\t\tdin.add_edge(s, i, 1, 0);\n\t}\n\trep(i,1,n){\n\t\tdin.add_edge(i + m, t, 1, 0);\n\t}\n\trep(i,1,m){\n\t\trep(j,1,n){\n\t\t\tif(gcd(a[i],b[j]) > 1){\n\t\t\t\tdin.add_edge(i, j + m, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << din.max_flow(s, t) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// MEMO\n//\n// O(VE)\n\n// THE BEGINNING OF THE LIBRARY.\n\nstruct BipartiteMatching {\n\tusing UnWeightedGraph=vector< vector<int> >;\n\n\tint n;\n\tUnWeightedGraph G;\n\tvector<int> match,used;\n\n\tBipartiteMatching() {}\n\tBipartiteMatching(int sz):n(sz),G(sz),match(sz),used(sz) {}\n\n\tvoid add_edge(int u,int v) {\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tbool dfs(int v) {\n\t\tused[v]=true;\n\t\tfor(auto u:G[v]) {\n\t\t\tint w=match[u];\n\t\t\tif(w<0||(!used[w]&&dfs(w))) {\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint bipartite_matching() {\n\t\tint res=0;\n\t\tfill(match.begin(),match.end(),-1);\n\t\tfor(int v=0;v<n;v++) {\n\t\t\tif(match[v]<0) {\n\t\t\t\tfill(used.begin(),used.end(),0);\n\t\t\t\tif(dfs(v)) res++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint gcd(int a,int b) {\n\tif(a<b) swap(a,b)\n\tint r;\n\twhile(a%b!=0) {\n\t\tr=b;b=a%b;a=r;\n\t}\n\treturn b;\n}\n\n// THE ENDING OF THE LIBRARY.\n// THE FOLLOWING IS AN EXAMPLE OF USE.\n\nint main() {\n\n\tint m,n;\n\tcin>>m>>n;\n\tvector<int> a(m),b(n);\n\tfor(int i=0;i<m;i++) cin>>a[i];\n\tfor(int i=0;i<n;i++) cin>>b[i];\n\tBipartiteMatching bimatch(m+n);\n\tfor(int i=0;i<m;i++) {\n\t\tfor(int j=0;j<n;j++) {\n\t\t\tif(gcd(a[i],b[j])!=1) bimatch.add_edge(i,j+m);\n\t\t}\n\t}\n\tcout<<bimatch.bipartite_matching()<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\nconst int MAXV = 1005;\nconst int MAXE = MAXV * MAXV;\nconst int INF = 1<<29;\n\nstruct BiparateMatching {\n    int N, M, E, match[MAXV+1], dist[MAXV+1];\n    int last[MAXE], prev[MAXE], to[MAXE];\n    BiparateMatching(int n, int m) : N(n), M(m), E(0) {\n        memset(last, -1, sizeof(last));\n    }\n    void add_edge(int x, int y) { // x \\in [0, N), y \\in [0, M)\n        to[E] = y + N; prev[E] = last[x]; last[x] = E; E++;\n    }\n    bool bfs() {\n        queue<int> q;\n        for (int i=0; i<N; ++i) {\n            if (match[i] == -1) {\n                q.push(i); dist[i] = 0;\n            } else dist[i] = INF;\n        }\n\n        bool ret = false;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = last[v]; e != -1; e = prev[e]) {\n                if (match[to[e]] == -1) ret = true;\n                else if (dist[match[to[e]]] == INF) {\n                    dist[match[to[e]]] = dist[v] + 1;\n                    q.push(match[to[e]]);\n                }\n            }\n        }\n        return ret;\n    }\n    bool dfs(int v) {\n        for (int e = last[v]; e != -1; e = prev[e]) {\n            bool update = false;\n            if (match[to[e]] == -1) {\n                match[to[e]] = v; match[v] = to[e];\n                update = true;\n            } else if (dist[match[to[e]]] == dist[v] + 1) {\n                if (dfs(match[to[e]])) {\n                    match[to[e]] = v; match[v] = to[e];\n                    update = true;\n                }\n            }\n            if (update) return true;\n        }\n        dist[v] = INF;\n        return false;\n    }\n    int matching() {\n        int ret = 0;\n        memset(match, -1, sizeof(match));\n        while(bfs()) {\n            for (int i=0; i<N; ++i)\n                if (match[i] == -1 && dfs(i)) ret++;\n        }\n        return ret;\n    }\n};\n\nint gcd(int x, int y) {\n    if (y == 0) return x;\n    return gcd(y, x%y);\n}\n\nint b[501], r[501];\nint main() {\n    int m,n;\n    while(scanf(\"%d %d\", &m, &n), m|n) {\n        BiparateMatching bm(m, n);\n        for (int i=0; i<m; ++i) scanf(\"%d\", &b[i]);\n        for (int i=0; i<n; ++i) scanf(\"%d\", &r[i]);\n        for (int i=0; i<m; ++i) {\n            for (int j=0; j<n; ++j)\n                if (gcd(b[i], r[j]) > 1) bm.add_edge(i, j);\n        }\n        printf(\"%d\\n\", bm.matching());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint gcd(int m,int n){\n\tif(n>m)return gcd(n,m);\n\telse{\n\t\tif(m%n==0){\n\t\t\treturn n;\n\t\t}else{\n\t\t\treturn gcd(n,m%n);\n\t\t}\n\t}\n}\n\nbool matching(vector<vector<pair<int,int> > >& edges,int u,vector<int>& match,vector<bool>& visited){\n\tif(u<0)return true;\n\tfor(int i=0;i<edges[u].size();i++)if(!visited[edges[u][i].second]){\n\t\tvisited[edges[u][i].second] = true;\n\t\tif(matching(edges,match[edges[u][i].second],match,visited)){\n\t\t\tmatch[edges[u][i].first] = edges[u][i].second;\n\t\t\tmatch[edges[u][i].second] = edges[u][i].first;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nvoid solve(int m,int n){\n\tvector<int> blue(m),red(n);\n\tfor(int i=0;i<m;i++){\n\t\tcin >> blue[i];\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcin >> red[i];\n\t}\n\tvector<vector<pair<int,int> > >edges;\n\tfor(int i=0;i<m;i++){\n\t\tvector<pair<int,int> > edge;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(gcd(blue[i],red[j])>1){\n\t\t\t\tedge.push_back(make_pair(i,m+j));\n\t\t\t}\n\t\t}\n\t\tedges.push_back(edge);\n\t}\n\tvector<int> match(m+n,-1);\n\tint ans = 0;\n\tfor(int i=0;i<m;i++){\n\t\tvector<bool> visited(m+n);\n\t\tif(matching(edges,i,match,visited))ans++;\n\t}\n\tcout << ans << endl;\n\treturn;\n}\n\n\nint main(){\n\tint m,n;\n\twhile(1){\n\t\tcin >> m >> n;\n\t\tif(m==0&&n==0)break;\n\t\tsolve(m,n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"avx\")\n#include \"bits/stdc++.h\"\n \nusing namespace std;\nusing ll = long long int;\n \n#define debug(v) {printf(\"L%d %s > \",__LINE__,#v);cout<<(v)<<endl;}\n#define debugv(v) {printf(\"L%d %s > \",__LINE__,#v);for(auto e:(v)){cout<<e<<\" \";}cout<<endl;}\n#define debuga(m,w) {printf(\"L%d %s > \",__LINE__,#m);for(int x=0;x<(w);x++){cout<<(m)[x]<<\" \";}cout<<endl;}\n#define debugaa(m,h,w) {printf(\"L%d %s >\\n\",__LINE__,#m);for(int y=0;y<(h);y++){for(int x=0;x<(w);x++){cout<<(m)[y][x]<<\" \";}cout<<endl;}}\n#define ALL(v) (v).begin(),(v).end()\n#define repeat(cnt,l) for(remove_const<decltype(l)>::type cnt=0;(cnt)<(l);++(cnt))\n#define rrepeat(cnt,l) for(auto cnt=(l)-1;0<=(cnt);--(cnt))\n#define iterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);++(cnt))\n#define diterate(cnt,b,e) for(auto cnt=(b);(cnt)!=(e);--(cnt))\nconst ll MD = 1000000007ll; const long double PI = 3.1415926535897932384626433832795L;\ntemplate<typename T1, typename T2> inline void assert_equal(T1 expected, T2 actual) { if (!(expected == actual)) { cerr << \"assertion fault: expected=\" << expected << \" actual=\" << actual << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_less(T1 actual, T2 threshold) { if (!(actual < threshold)) { cerr << \"assertion fault: \" << actual << \" < (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline void assert_eqless(T1 actual, T2 threshold) { if (!(actual <= threshold)) { cerr << \"assertion fault: \" << actual << \" <= (const)\" << threshold << endl; abort(); } }\ntemplate<typename T1, typename T2> inline ostream& operator <<(ostream &o, const pair<T1, T2> p) { o << '(' << p.first << ':' << p.second << ')'; return o; }\ntemplate<typename Vec> inline ostream& _ostream_vecprint(ostream &o, const Vec& p) { o << '['; for (auto& e : p) o << e << ','; o << ']'; return o; }\ntemplate<typename T> inline ostream& operator<<(ostream& o, const vector<T>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T, size_t S> inline ostream& operator<<(ostream& o, const array<T, S>& v) { return _ostream_vecprint(o, v); }\ntemplate<typename T> inline T& maxset(T& to, const T& val) { return to = max(to, val); }\ntemplate<typename T> inline T& minset(T& to, const T& val) { return to = min(to, val); }\nvoid bye(string s, int code = 0) { cout << s << endl; exit(code); }\nmt19937_64 randdev(8901016);\ntemplate<typename T> inline T rand(T l, T h) { return uniform_int_distribution<T>(l, h)(randdev); }\ntemplate<> inline double rand<double>(double l, double h) { return uniform_real_distribution<double>(l, h)(randdev); }\ntemplate<> inline float rand<float>(float l, float h) { return uniform_real_distribution<float>(l, h)(randdev); }\n \n#if defined(_WIN32) || defined(_WIN64)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#elif defined(__GNUC__)\n#else\n#define getchar_unlocked getchar\n#define putchar_unlocked putchar\n#endif\nnamespace {\n#define isvisiblechar(c) (0x21<=(c)&&(c)<=0x7E)\n    class MaiScanner {\n    public:\n        template<typename T> void input_integer(T& var) {\n            var = 0; T sign = 1;\n            int cc = getchar_unlocked();\n            for (; cc<'0' || '9'<cc; cc = getchar_unlocked())\n                if (cc == '-') sign = -1;\n            for (; '0' <= cc && cc <= '9'; cc = getchar_unlocked())\n                var = (var << 3) + (var << 1) + cc - '0';\n            var = var * sign;\n        }\n        inline int c() { return getchar_unlocked(); }\n        inline MaiScanner& operator>>(int& var) { input_integer<int>(var); return *this; }\n        inline MaiScanner& operator>>(long long& var) { input_integer<long long>(var); return *this; }\n        inline MaiScanner& operator>>(string& var) {\n            int cc = getchar_unlocked();\n            for (; !isvisiblechar(cc); cc = getchar_unlocked());\n            for (; isvisiblechar(cc); cc = getchar_unlocked())\n                var.push_back(cc);\n            return *this;\n        }\n        template<typename IT> void in(IT begin, IT end) { for (auto it = begin; it != end; ++it) *this >> *it; }\n    };\n    class MaiPrinter {\n    public:\n        template<typename T>\n        void output_integer(T var) {\n            if (var == 0) { putchar_unlocked('0'); return; }\n            if (var < 0)\n                putchar_unlocked('-'),\n                var = -var;\n            char stack[32]; int stack_p = 0;\n            while (var)\n                stack[stack_p++] = '0' + (var % 10),\n                var /= 10;\n            while (stack_p)\n                putchar_unlocked(stack[--stack_p]);\n        }\n        inline MaiPrinter& operator<<(char c) { putchar_unlocked(c); return *this; }\n        inline MaiPrinter& operator<<(int var) { output_integer<int>(var); return *this; }\n        inline MaiPrinter& operator<<(long long var) { output_integer<long long>(var); return *this; }\n        inline MaiPrinter& operator<<(char* str_p) { while (*str_p) putchar_unlocked(*(str_p++)); return *this; }\n        inline MaiPrinter& operator<<(const string& str) {\n            const char* p = str.c_str();\n            const char* l = p + str.size();\n            while (p < l) putchar_unlocked(*p++);\n            return *this;\n        }\n        template<typename IT> void join(IT begin, IT end, char sep = '\\n') { for (auto it = begin; it != end; ++it) *this << *it << sep; }\n    };\n}\nMaiScanner scanner;\nMaiPrinter printer;\n\n\nclass DGraphF {\npublic:\n    typedef int cap_t;\n    size_t n_;\n    struct Arc {\n        int from, to;\n        // 残量\n        cap_t left;\n        // 容量\n        cap_t cap;\n\n        Arc(int from = 0, int to = 0, cap_t w = 1) :from(from), to(to), left(w), cap(w) {}\n        inline bool operator<(const Arc& a) const { return (left != a.left) ? left < a.left : (left<a.left) | (cap<a.cap) | (from<a.from) | (to<a.to); }\n        inline bool operator==(const Arc& a) const { return (from == a.from) && (to == a.to) && (left == a.left) && (cap == a.cap); }\n    };\n    vector<vector<int>> vertex_to;\n    vector<vector<int>> vertex_from;\n    vector<Arc> edges;\n\n    DGraphF(int n = 1) :n_(n), vertex_to(n), vertex_from(n) { }\n\n    void connect(int from, int to, cap_t left) {\n        vertex_to[(size_t)from].push_back((int)edges.size()); // toto\n        vertex_from[(size_t)to].push_back((int)edges.size()); // fromfrom\n        edges.emplace_back(from, to, left);\n    }\n};\n\n\nvoid dinic(DGraphF &graph, vector<DGraphF::cap_t>& result, int i_source, int i_sink) {\n    assert(i_source != i_sink);\n\n    result.resize(graph.n_);\n    vector<int> dist(graph.n_);\n    queue<int> q;\n    vector<int> flag(graph.n_);\n\n    static function<DGraphF::cap_t(int, int, DGraphF::cap_t)> _dfs = [&](int u, int i_sink, DGraphF::cap_t mini) {\n        // DAG\n        // TODO: 経路再利用\n        if (i_sink == u) return mini;\n        if (flag[u]) return (DGraphF::cap_t) - 1;\n        flag[u] = true;\n\n        DGraphF::cap_t sumw = 0;\n        bool term = true;\n        for (int e : graph.vertex_to[u]) {\n            auto& edge = graph.edges[e];\n            if (edge.left > 0 && dist[u]>dist[edge.to]) {\n                DGraphF::cap_t w = (mini < 0) ? edge.left : min(edge.left, mini);\n\n                w = _dfs(edge.to, i_sink, w);\n                if (w == -1) continue;\n                edge.left -= w;\n                result[edge.to] += w;\n\n                sumw += w;\n                mini -= w;\n                term = false;\n                flag[u] = false; // TODO: 末尾では? \n\n                if (mini == 0) return sumw;\n            }\n        }\n        for (int e : graph.vertex_from[u]) {\n            auto& edge = graph.edges[e];\n            if (edge.cap>edge.left && dist[u]>dist[edge.from]) {\n                DGraphF::cap_t w = (mini < 0) ? (edge.cap - edge.left) : min(edge.cap - edge.left, mini);\n\n                w = _dfs(edge.from, i_sink, w);\n                if (w == -1) continue;\n                edge.left += w;\n                result[edge.to] -= w;\n\n                sumw += w;\n                mini -= w;\n                term = false;\n                flag[u] = false;\n                if (mini == 0) return sumw;\n            }\n        }\n        return term ? (DGraphF::cap_t)(-1) : sumw;\n    };\n\n\n    for (int distbegin = 0; ; distbegin += (int)graph.n_) {\n\n        q.emplace(i_sink); // bfsはsinkからsourceへの距離を計算．\n        dist[i_sink] = distbegin + 1;\n        while (!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for (int ie : graph.vertex_from[v]) {\n                const auto edge = graph.edges[ie];\n                if (0 < edge.left && dist[edge.from] <= distbegin) {\n                    dist[edge.from] = dist[v] + 1;\n                    q.emplace(edge.from);\n                }\n            }\n            for (int ie : graph.vertex_to[v]) {\n                const auto edge = graph.edges[ie];\n                if (edge.left < edge.cap && dist[edge.to] <= distbegin) {\n                    dist[edge.to] = dist[v] + 1;\n                    q.emplace(edge.to);\n                }\n            }\n        }\n        fill(flag.begin(), flag.end(), false);\n\n        if (dist[i_source] <= distbegin)\n            break;\n        else\n            result[i_source] += _dfs(i_source, i_sink, -1);\n    }\n}\n\n\ntemplate<typename T> inline T gcd(T a, T b) { while(b){T t=a%b;a=b;b=t;}return a; }\ntemplate<typename T> inline T lcm(T a, T b) { return a*b/gcd(a,b); }\n\n\n\nint main(){\n    int blue[555],red[555];\n    \n    int m,n;\n    while(scanner >> m >> n, m != 0 || n != 0){\n        DGraphF g(m+n+2);\n        const int vs = m+n, vt = m+n+1;\n        scanner.in(blue,blue+m);\n        scanner.in(red,red+n);\n        repeat(i, m)\n            repeat(j, n)\n                if (gcd(blue[i],red[j])>1) g.connect(i,m+j,1);\n        repeat(i,m)\n            g.connect(vs,i,1);\n        repeat(j,n)\n            g.connect(m+j,vt,1);\n            \n        vector<int> f;\n        dinic(g,f,vs,vt);\n        printer << f[vt] << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) ((y)<0||(x)<0||(y)>=(h)||(x)>=(w))\n#define dump(...)\nconst signed INF_=1001001001; const ll INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct{template<class T> operator T(){T x;cin>>x;return x;}} IN;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\ntemplate <typename T>\nstruct EdmondsKarp {\n    struct Edge {\n        int from;\n        int to;\n        T cap;\n    };\n\n    int size;\n    vector<Edge> edge;\n    vector<vector<int>> graph;\n\n    EdmondsKarp(int size_) : size(size_) {\n        graph.resize(size);\n    }\n    void add_edge(int from, int to, T cap) {\n        graph[from].push_back(edge.size());\n        edge.push_back(Edge{from, to, cap});\n        graph[to].push_back(edge.size());\n        edge.push_back(Edge{to, from, 0});\n    }\n    T max_flow(int s, int t) {\n        auto get_reverse_edge = [](int e) {\n            if (e % 2) return e - 1;\n            else return e + 1;\n        };\n\n        T flow = 0;\n        while (1) {\n            queue<int> q;\n            q.push(s);\n            vector<int> from(size, -1);\n            from[s] = -2;\n            while (!q.empty()) {\n                int v = q.front(); q.pop();\n                if (v == t) break;\n                for (auto &e : graph[v]) {\n                    int w = edge[e].to;\n                    if (edge[e].cap <= 0 || from[w] != -1) continue;\n                    from[w] = e;\n                    q.push(w);\n                }\n            }\n            if (from[t] == -1) break;\n\n            int cur = t;\n            vector<int> arg_path;\n            T bottleneck = 0;\n            while (cur != s) {\n                int e = from[cur];\n                if (bottleneck == 0 || bottleneck > edge[e].cap) {\n                    bottleneck = edge[e].cap;\n                }\n                arg_path.push_back(e);\n                cur = edge[e].from;\n            }\n            for (auto &e : arg_path) {\n                edge[e].cap -= bottleneck;\n                edge[get_reverse_edge(e)].cap += bottleneck;\n            }\n            flow += bottleneck;\n        }\n        return flow;\n    }\n};\n\nint gcd(int a, int b) { return a ? gcd(b % a, a) : b; }\n\nsigned main() {\n    while(1) {\n        int n,m;\n        cin>>n>>m;\n        if(n==0 && m==0) break;\n        vector<int> a(n),b(m);\n        cin>>a>>b;\n        EdmondsKarp<int> mf(n+m+2);\n        REP(i,n) mf.add_edge(n+m,i,1);\n        REP(i,m) mf.add_edge(i+n,n+m+1,1);\n        REP(i,n) REP(j,m) if(gcd(a[i],b[j])>1) mf.add_edge(i,j+n,1);\n        cout<<mf.max_flow(n+m,n+m+1)<<endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// Hopcroft-Karp Algorithm\n// O(|E| * |V|^(1/2))\n// http://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm\n// aoj 1163\n\n#include <vector>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\nint NIL;\nconst int inf = 1<<29;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int> > Graph;\n\nbool bfs(const Graph &g,vi &dist,const vi &pair,int m) {\n    queue<int> q;\n\n    for(int i=0; i<m; ++i)\n        if(pair[i] == NIL) {\n            dist[i] = 0;\n            q.push(i);\n        }else\n            dist[i] = inf;\n    dist[NIL] = inf;\n\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        if(v == NIL) continue;\n        for(int i=0; i<g[v].size(); ++i) {\n            int u = g[v][i];\n            if(dist[pair[u]] == inf) {\n                dist[pair[u]] = dist[v]+1;\n                q.push(pair[u]);\n            }\n        }\n    }\n    return dist[NIL] != inf;\n}\n\nbool dfs(int v,const Graph &g,vi &dist,vi &pair) {\n    if(v != NIL) {\n        for(int i=0; i<g[v].size(); ++i) {\n            int u = g[v][i];\n            if(dist[pair[u]] == dist[v]+1) {\n                if(dfs(pair[u],g,dist,pair)) {\n                    pair[u] = v, pair[v] = u;\n                    return true;\n                }\n            }\n        }\n        dist[v] = inf;\n        return false;\n    }\n    return true;\n}\n\n// 0ツつゥツづァm-1ツづ慊づづ個静淞点ツづツつゥツづァn-1ツづ慊づづ個静淞点ツづづ個催妥・ツマツッツチツδ督グツづーツ仰づ淞づゥ\nint hopcroft_karp(Graph &graph,int m) {\n    const int n = graph.size();\n    NIL = n;\n    vi pair(n+1, NIL), dist(n+1, 0);\n    int ret = 0;\n    while(bfs(graph,dist,pair,m)) {\n        for(int i=0; i<m; ++i)\n            if(pair[i] == NIL)\n                if(dfs(i,graph,dist,pair)) ret++;\n    }\n    return ret;\n}\n\nint gcd(int x,int y) {\n    if(y == 0) return x;\n    return gcd(y,x%y);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    int m,n;\n    while(cin>>m>>n, m|n) {\n        Graph g(m+n);\n        vector<int> b(m), r(n);\n        for(int i=0; i<m; ++i) cin>>b[i];\n        for(int i=0; i<n; ++i) cin>>r[i];\n\n        for(int i=0; i<m; ++i)\n            for(int j=0; j<n; ++j)\n                if(gcd(b[i],r[j]) > 1)\n                    g[i].push_back(j+m);\n        cout<<hopcroft_karp(g,m)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<string>\n#include<cmath>\n#include<cassert>\n#include<map>\n  using namespace std;\n\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ (i)=0;(i)<(j);(i)++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);(i)++)\n#define all(v) begin(v),end(v)\n\n#define MAX_N 501\nclass maxFlow\n{\npublic:\n  int N;//???????????°\n  int G[MAX_N][MAX_N];//G[i][j] :=???i??????j????????§?????????\n  bool is_visited[MAX_N];\n\n  maxFlow(int n)\n  {\n    N=n;\n    //?????????????????¨????????°???????????§??????\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tG[i][j]=0;\n  }\n\n  //n1->n2???arc?????????\n  void add_arc(int n1,int n2,int capacity)\n  {\n    G[n1][n2]+=capacity;//????????§?????±???\n  }\n\n  //??´???????????§???????????¢?´¢\n  int dfs(int now,int end,int min_capacity)\n  {\n    if(now==end)return min_capacity;\n    if(!is_visited[now])\n      {\n\tis_visited[now]=true;\n\tfor(int i=0;i<N;i++){\n\t  if(G[now][i]>0){//now??????i????????§??????????????????????????°????????§??????\n\t    int ret=dfs(i,end,min(min_capacity,G[now][i]));\n\t    if(ret>0){//??´???????????????????????????????????§?¢???????????????????????????????????????´??°\n\t      G[now][i]-=ret;\n\t      G[i][now]+=ret;\n\t      return ret;\n\t    }\n\t  }\n\t}\n\treturn -2;//??´????????????????????????????????£???\n      }\n    else return -1;//?????§????¨???????????????£???\n  }\n  \n  int get_maxFlow(int start,int end)\n  {\n    int temp,ans=0;\n    //??´???????????????????????????????????§????????????????????????????????????????´¢\n    while(true){\n      for(int i=0;i<N;i++)is_visited[i]=false;\n      temp=dfs(start,end,100);\n      if(temp>0)ans+=temp;\n      else break;\n    }\n    return ans;\n  }\n  \n};\n\nint gcd(int a,int b){\n  if(b==0)return a;\n  return gcd(b,a%b);\n}\n\nint main()\n{\n  int n,m;\n\n  while(true){\n    cin>>m>>n;\n    if(m==0&&n==0)break;\n    maxFlow G(m+n+2);\n    vector<int> b(m);\n    vector<int> r(n);\n    rep(i,m){\n      cin>>b[i];\n      G.add_arc(m+n, i, 1);\n    }\n    rep(i,n){\n      cin>>r[i];\n      G.add_arc(m+i, m+n+1 , 1);\n    }\n    \n    rep(i,m){\n      rep(j,n){\n        if(gcd(b[i],r[j])!=1){\n          G.add_arc(i, m+j, 1);\n        }\n      }\n    }\n\n    cout<<G.get_maxFlow(m+n, m+n+1)<<endl;\n    \n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int MAX_V = 10000;\nconst int INF = 10000000;\n\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap)\n{\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f)\n{\n  if(v == t) return f;\n\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n\n  return 0;\n}\n\nint max_flow(int s, int t)\n{\n  int flow = 0;\n  for(;;){\n    fill(used, used + MAX_V, false);\n    int f = dfs(s, t, INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint gcd(int a, int b)\n{\n  int c;\n  if (a < b) {\n    a+=b; b=a-b; a-=b;\n  }\n  while (b != 0) {\n    c = a % b;\n    a = b;\n    b = c;\n  }\n  return a;\n}\n\nint main()\n{\n  while(1){\n    int m, n;\n    cin >> m >> n;\n    if(m == 0 && n == 0) break;\n    int b[m], r[n];\n    for(int i = 0; i < m; i++)\n      cin >> b[i];\n    for(int i = 0; i < n; i++)\n      cin >> r[i];\n    for(int i = 0; i < m; i++){\n      for(int j = 0; j < n; j++){\n        if(gcd(b[i], r[j]) != 1){\n          add_edge(i+2, j+m+2, 1);\n        }\n      }\n    }\n    for(int i = 2; i < m + 2; i++)\n      add_edge(0, i, 1);\n    for(int i = m+2; i < m+n+2; i++)\n      add_edge(i, 1, 1);\n    cout << max_flow(0, 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nint gcd(int a, int b) {\n\tif (a < b) {\n\t\tswap(a, b);\n\t}\n\twhile (b != 0) {\n\t\ta = a%b;\n\t\tswap(a, b);\n\t}\n\treturn a;\n}\nint main() {\n\tint blue_size, red_size;\n\twhile (cin >> blue_size >> red_size, red_size) {\n\t\tvector<int> blue(blue_size);\n\t\tREP(i, blue_size)\n\t\t\tcin >> blue[i];\n\t\tvector<int> red(red_size);\n\t\tREP(i, red_size)\n\t\t\tcin >> red[i];\n\t\tSORT(blue);\n\t\tSORT(red);\n\t\tvb blueu(blue.size(), false);\n\t\tvb redu(red.size(), false);\n\t\tvvi bluec(blue.size());\n\t\tvvi redc(red.size());\n\t\tset<pii> connect;//blue red\n\t\tREP(i, blue.size()) {\n\t\t\tREP(j, red.size()) {\n\t\t\t\tif (gcd(blue[i], red[j]) != 1) {\n\t\t\t\t\tbluec[i].push_back(j);\n\t\t\t\t\tredc[j].push_back(i);\n\t\t\t\t\tif (!blueu[i] && !redu[j]) {\n\t\t\t\t\t\tblueu[i] = true;\n\t\t\t\t\t\tredu[j] = true;\n\t\t\t\t\t\tconnect.insert({ i,j });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, blue.size()) {\n\t\t\tif (!blueu[i]) {\n\t\t\t\tstack<pii> route;\n\t\t\t\troute.push({ i,0 });\n\t\t\t\tvb bluev(blue.size(), false);\n\t\t\t\tvb redv(red.size(), false);\n\t\t\t\tbluev[i] = true;\n\t\t\t\twhile (!route.empty()) {\nwf:\n\t\t\t\t\tpii st = route.top();\n\t\t\t\t\tif (st.second == 1 && !redu[st.first]) {\n\t\t\t\t\t\tredu[st.first] = true;\n\t\t\t\t\t\twhile (route.size() > 1) {\n\t\t\t\t\t\t\tif (route.size() % 2 == 0) {\n\t\t\t\t\t\t\t\tpii st2 = route.top();\n\t\t\t\t\t\t\t\troute.pop();\n\t\t\t\t\t\t\t\tconnect.insert({ route.top().first,st2.first });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tpii st2 = route.top();\n\t\t\t\t\t\t\t\troute.pop();\n\t\t\t\t\t\t\t\tconnect.erase({ st2.first,route.top().first });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tblueu[i] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (st.second == 0) {\n\t\t\t\t\t\tREP(j, bluec[st.first].size()) {\n\t\t\t\t\t\t\tif (!redv[bluec[st.first][j]] && connect.find({st.first,bluec[st.first][j] })==connect.end()) {\n\t\t\t\t\t\t\t\tredv[bluec[st.first][j]] = true;\n\t\t\t\t\t\t\t\troute.push({ bluec[st.first][j],1});\n\t\t\t\t\t\t\t\tgoto wf;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tREP(j, redc[st.first].size()) {\n\t\t\t\t\t\t\tif (!bluev[redc[st.first][j]] && connect.find({ redc[st.first][j],st.first }) != connect.end()) {\n\t\t\t\t\t\t\t\tbluev[redc[st.first][j]] = true;\n\t\t\t\t\t\t\t\troute.push({ redc[st.first][j],0 });\n\t\t\t\t\t\t\t\tgoto wf;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\troute.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << connect.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// Hopcroft-Karp Algorithm\n// O(|E| * |V|^(1/2))\n// http://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm\n// aoj 1163\n\n#include <vector>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\nint NIL;\nconst int inf = 1<<29;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int> > Graph;\n\nbool bfs(const Graph &g,vi &dist,const vi &pair,int m) {\n    queue<int> q;\n\n    for(int i=0; i<m; ++i)\n        if(pair[i] == NIL) {\n            dist[i] = 0;\n            q.push(i);\n        }else\n            dist[i] = inf;\n    dist[NIL] = inf;\n\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        if(v == NIL) continue;\n        for(int i=0; i<g[v].size(); ++i) {\n            int u = g[v][i];\n            if(dist[pair[u]] == inf) {\n                dist[pair[u]] = dist[v]+1;\n                q.push(pair[u]);\n            }\n        }\n    }\n    return dist[NIL] != inf;\n}\n\nbool dfs(int v,const Graph &g,vi &dist,vi &pair) {\n    if(v != NIL) {\n        for(int i=0; i<g[v].size(); ++i) {\n            int u = g[v][i];\n            if(dist[pair[u]] == dist[v]+1) {\n                if(dfs(pair[u],g,dist,pair)) {\n                    pair[u] = v, pair[v] = u;\n                    return true;\n                }\n            }\n        }\n        dist[v] = inf;\n        return false;\n    }\n    return true;\n}\n\n// 0ツつゥツづァm-1ツづ慊づづ個静淞点ツづツつゥツづァn-1ツづ慊づづ個静淞点ツづづ個催妥・ツマツッツチツδ督グツづーツ仰づ淞づゥ\nint hopcroft_karp(Graph &graph,int m) {\n    const int n = graph.size();\n    NIL = n;\n    vi pair(n+1, NIL), dist(n+1, 0);\n    int ret = 0;\n    while(bfs(graph,dist,pair,m)) {\n        for(int i=0; i<m; ++i)\n            if(pair[i] == NIL)\n                if(dfs(i,graph,dist,pair)) ret++;\n    }\n    return ret;\n}\n\nint gcd(int x,int y) {\n    if(y == 0) return x;\n    return gcd(y,x%y);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    int m,n;\n    while(cin>>m>>n, m|n) {\n        Graph g(m+n);\n        vector<int> b(m), r(n);\n        for(int i=0; i<m; ++i) cin>>b[i];\n        for(int i=0; i<n; ++i) cin>>r[i];\n\n        for(int i=0; i<m; ++i)\n            for(int j=0; j<n; ++j)\n                if(gcd(b[i],r[j]) > 1)\n                    g[i].push_back(j+m);\n        cout<<hopcroft_karp(g,m)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\nconst int INF=1<<17;\n\n#define NUM 1000\nstruct BM{\n\n    int V;\n    vector<int> G[NUM];\n    int match[NUM];\n    bool used[NUM];\n     \n    void add_edge(int from,int to){\n        G[from].push_back(to);\n        G[to].push_back(from);\n    }\n     \n    int dfs(int node_id){\n        used[node_id] = true;\n     \n        for(int i = 0; i < G[node_id].size(); i++){\n            int adj_node_id = G[node_id][i],pair_id = match[adj_node_id];\n            if((pair_id < 0)||(used[pair_id] == false && dfs(pair_id) == true)){\n                match[node_id] = adj_node_id;\n                match[adj_node_id] = node_id;\n                return true;\n            }\n        }\n        return false;\n    }\n     \n     \n    int bipartie_matching(){\n        int ret = 0;\n        for(int i = 0; i < V; i++)match[i] = -1;\n        for(int node_id = 0; node_id < V; node_id++){\n            if(match[node_id] < 0){\n                for(int i = 0; i < V; i++)used[i] = false;\n                if(dfs(node_id)){\n                    ret++;\n                }\n            }\n        }\n        return ret;\n    }\n\n};\n\nint main(){\n    int m,n;\n    while(cin >> m >> n){\n        if(m==0&&n==0) break;\n        BM bm;\n        vector<int> l(m),r(n);\n        for(int i=0;i<m;i++) cin >> l[i];\n        for(int i=0;i<n;i++){\n            cin >> r[i];\n            for(int j=2;j*j<=r[i];j++){\n                if(r[i]%j==0){\n                    for(int k=0;k<m;k++){\n                        if(l[k]%j==0||l[k]%(r[i]/j)==0) bm.add_edge(k,m+i);\n                    }\n                }\n            }\n            for(int k=0;k<m;k++){\n                if(l[k]%r[i]==0) bm.add_edge(k,m+i);\n            }\n        }\n        bm.V=m+n;\n        cout << bm.bipartie_matching() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\nusing namespace std;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Capacity> Array;\ntypedef vector<Array> Matrix;\n\nconst int inf = 1e8;\n\nstruct FordFulkerson {\n    typedef vector<vector<Capacity>> Matrix;\n    int n, t;\n    vector<bool> vis;\n    Matrix cap, flow;\n    vector<vector<int>> g;\n    FordFulkerson(int n){ *this = FordFulkerson(Graph(n)); }\n    FordFulkerson(const Graph &graph)\n        : n(graph.size()), cap(n, Array(n)),\n          flow(n, Array(n)), g(n, vector<int>()){\n        rep(i,n)\n            for(const Edge &e : graph[i])\n                add_edge(e.src, e.dst, e.cap);\n    }\n    void add_edge(int u, int v, Capacity c){\n        cap[u][v] += c;\n        cap[v][u] += c;\n        flow[v][u] += c;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    Capacity solve(int s, int t){\n        this->t = t;\n        Capacity res = 0, f = -1;\n        while(f){\n            vis.assign(n,false);\n            res += (f = augment(s,inf));\n        }\n        return res;\n    }\n    Capacity augment(int v, Capacity lim){\n        vis[v] = true;\n        if(v == t) return lim;\n        for(const int &i : g[v]){\n            if(vis[i] || flow[v][i] == cap[v][i]) continue;\n            Capacity f = augment(i, min(lim, cap[v][i] - flow[v][i]));\n            flow[v][i] += f;\n            flow[i][v] -= f;\n            if(f) return f;\n        }\n        return 0;\n    }\n};\n\nint gcd(int a, int b){\n    return b == 0 ? a : gcd(b,a%b);\n}\n\nint main(){\n    int n,m;\n    while(cin >> n >> m && n){\n        Graph g(1002);\n        int s = 1000, t = 1001;\n        int a[555], b[555];\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        rep(i,n)rep(j,n){\n            if(gcd(a[i],b[j]) != 1){\n                g[i].emplace_back(i,j+100,1);\n            }\n        }\n        rep(i,n) g[s].emplace_back(s,i,1);\n        rep(i,m) g[i+100].emplace_back(i+100,t,1);\n        cout << FordFulkerson(g).solve(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint V1, V2;\nint size[1002];\nint to[1002][1002];\nint dist[1002];\nint match[1002];\nconst int NIL = 1001;\nbool BFS(){\n  queue<int> que;\n  REP(v, V1){\n    if(match[v] == NIL){\n      dist[v] = 0;\n      que.push(v);\n    }else{\n      dist[v] = INF;\n    }\n  }\n  dist[NIL] = INF;\n  while(!que.empty()){\n    int v = que.front(); que.pop();\n    if(dist[v] < dist[NIL]){\n      for(int i = 0; i < size[v]; i++){\n        int u = to[v][i];\n        if(dist[match[u]] == INF){\n          dist[match[u]] = dist[v] + 1;\n          que.push(match[u]);\n        }\n      }\n    }\n  }\n  return dist[NIL] != INF;\n}\n\nbool DFS(int v){\n  if(v != NIL){\n    for(int i = 0; i < size[v]; i++){\n      int u = to[v][i];\n      if(dist[match[u]] == dist[v] + 1 && DFS(match[u])){\n        match[u] = v;\n        match[v] = u;\n        return true;\n      }\n    }\n    dist[v] = INF;\n    return false;\n  }\n  return true;\n}\n\nint Hopcroft_Karp(){\n  REP(v, V1 + V2) match[v] = NIL;\n  int matching = 0;\n  while(BFS()){\n    REP(v, V1){\n      if(match[v] == NIL && DFS(v)){\n        matching ++;\n      }\n    }\n  }\n  return matching;\n}\nint memo[1000][1000];\nint gcd(int x, int y){\n  if(x < 1000){\n    if(memo[x][y] != -1) return memo[x][y];\n    int r = x % y;\n    if(r == 0) return memo[x][y] = y;\n    return memo[x][y] = gcd(y, r);\n  }else{\n    int r = x % y;\n    if(r == 0) return y;\n    return gcd(y, r);\n  }\n}\nint main(){\n  memset(memo, -1, sizeof(memo));\n  while(scanf(\"%d %d\", &V1, &V2) && (V1 != 0 || V2 != 0)){\n    REP(i, V1) size[i] = 0;\n    static int blue[500];\n    static int red[500];\n    REP(i, V1) scanf(\"%d\", blue + i);\n    REP(i, V2) scanf(\"%d\", red + i);\n    REP(u, V1) REP(v, V2){\n      int x = max(blue[u], red[v]);\n      int y = min(blue[u], red[v]);\n      if(gcd(x, y) != 1) {\n        to[u][size[u]++] = V1 + v;\n        //G[u].push_back(V1 + v);\n        //G[V1 + v].push_back(u);\n      }\n    }\n    printf(\"%d\\n\", Hopcroft_Karp());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nvector<int> blue,red,redpair,v;\nvector<vector<int> >c;\n\nint m=0,n=0;\n\nint gcd(int x,int y){\n    if(x%y==0){return y;}\n    return gcd(y,x%y);\n}\n\nbool match(int x){\n\tif(x==-1)return 1;\n\tfor(int i=0;i<n;i++){\n\t\tif(c[x][i]==1 && v[i]==0){\n\t\t\tv[i]=1;\n\t\t\tif(match(redpair[i])){\n\t\t\t\tredpair[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(){\n    while(cin >> m >> n){\n        if(m == 0 && n == 0){\n            break;\n        }\n        blue.clear();\n        red.clear();\n        redpair.clear();\n        v.clear();\n        c.clear();\n        for(int i = 0;i < m;i++){\n            int tmp = 0;\n            cin >> tmp;\n            blue.push_back(tmp);\n        }\n        for(int i = 0;i < n;i++){\n            int tmp = 0;\n            cin >> tmp;\n            red.push_back(tmp);\n            redpair.push_back(-1);//-1??§?????¢??????????????¶????????¨???\n            v.push_back(0);\n        }\n        for(int i = 0;i < m;i++){\n            c.push_back(vector<int>());\n            for(int j = 0;j < n;j++){\n                c[i].push_back(gcd(blue[i],red[j]) != 1);\n            }\n        }\n        int ans = 0;\n        for(int i = 0;i < m;i++){\n            for(int j = 0;j < n;j++){\n                v[j] = 0;\n            }\n            if(match(i)){ans++;}\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nconst int MAX = 1000;\nconst int INF = 1<<30;\n#define gcd(a,b) __gcd(a,b)\n\nstruct edge{ \n  int to, cap, rev;\n};\n\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to ,cap ,G[to].size()});\n  G[to].push_back((edge){from ,0 ,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0 ; i < G[v].size() ; i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n\n  for(;;){\n    memset(used,false,sizeof(used));\n    int f = dfs(s,t,INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main(){\n  int m,n,b,r;\n  \n  while(cin >> m >> n , m + n){\n    vector<int> B,R;\n    int s = m+n,t = s+1;\n    memset(G,0,sizeof(G));\n    for(int i = 0 ; i < m ; i++){\n      cin >> b;\n      B.push_back(b);\n      add_edge(s,i,1);\n    }\n\n    for(int j = 0 ; j < n ; j++){\n      cin >> r;\n      R.push_back(r);\n      add_edge(m+j,t,1);\n    }\n \n    for(int i = 0 ; i < m ; i++){\n      for(int j = 0 ; j < n ; j++){\n\tif(gcd(B[i],R[j]) != 1){\n\t  add_edge(i,m+j,1);\n\t}\n      }\n    }\n    cout << max_flow(s,t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 1500\n#define INF 1<<29\nusing namespace std;\nstruct edge{int to,cap,rev;};\nvector<edge>G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int>q;\n  level[s]=0;\n  q.push(s);\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(int i=0;i<G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n        level[e.to]=level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    bfs(s);\n    if(level[t]<0)return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\nint main(){\n  int a,b;\n  while(cin>>a>>b,a+b){\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n    int aa[a],bb[b];\n    for(int i=0;i<a;i++)scanf(\"%d\",&aa[i]);\n    for(int i=0;i<b;i++)scanf(\"%d\",&bb[i]);\n    for(int i=101;i<601;i++)add_edge(0,i,1);\n    for(int i=701;i<1201;i++)add_edge(i,1499,1);\n    for(int i=0;i<a;i++)\n     for(int j=0;j<b;j++)\n      if((__gcd(aa[i],bb[j]))!=1)add_edge(i+101,j+701,1);\n    cout<<max_flow(0,1499)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_V 1000\n\nint m, n, v;\nvector<int> g[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nint euclidean(int a, int b) {\n  if (a == 0) return b;\n  else euclidean(b % a, a);\n}\n\nbool dfs(int i) {\n  used[i] = true;\n  rep(j, g[i].size()) {\n    int u = g[i][j], w = match[u];\n    if (w < 0 || !used[w] && dfs(w)) {\n      match[i] = u;\n      match[u] = i;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartiteMatching() {\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  rep(i, v) {\n    if (match[i] < 0) {\n      memset(used, 0, sizeof(used));\n      if (dfs(i)) res++;\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  while(cin >> m >> n, m | n) {\n    v = m + n;\n    rep(i, v) g[i].clear();\n\n    vector<int> b(m), r(n);\n    rep(i, m) cin >> b[i];\n    rep(i, n) cin >> r[i];\n    rep(i, m)rep(j, n) if (euclidean(b[i], r[j]) > 1) g[i].pb(m + j), g[m + j].pb(i);\n\n    cout << bipartiteMatching() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAX_V = 10000;\nconst int INF = 10000000;\n\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap)\n{\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f)\n{\n  if(v == t) return f;\n\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n\n  return 0;\n}\n\nint max_flow(int s, int t)\n{\n  int flow = 0;\n  for(;;){\n    fill(used, used + MAX_V, false);\n    int f = dfs(s, t, INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main()\n{\n  while(1){\n    int m, n;\n    cin >> m >> n;\n    if(m == 0 && n == 0) break;\n    int b[m], r[n];\n    for(int i = 0; i < m; i++)\n      cin >> b[i];\n    for(int i = 0; i < n; i++)\n      cin >> r[i];\n    for(int i = 0; i < m; i++){\n      for(int j = 0; j < n; j++){\n        if(__gcd(b[i], r[j]) != 1){\n          add_edge(i+2, j+m+2, 1);\n        }\n      }\n    }\n    for(int i = 2; i < m + 2; i++)\n      add_edge(0, i, 1);\n    for(int i = m+2; i < m+n+2; i++)\n      add_edge(i, 1, 1);\n    cout << max_flow(0, 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct edge { int to, cap, rev; };\n\nconst int MAX_V = 202;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap)\n{\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, 0, G[to].size() - 1});\n}\n\nint dfs(int v, int t, int f)\n{\n    if(v == t)\n        return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nlong long gcd(long long x, long long y)\n{\n    if(y > x)\n        swap(x, y);\n    return __gcd(x, y);\n}\n\nlong long lcm(long long x, long long y)\n{\n    if(y > x)\n        swap(x, y);\n    return (x * y) / __gcd(x, y);\n}\n\nint main()\n{\n    int m, n, cards[202];\n    while(cin >> m >> n && m && n) {\n\n        for(int i = 0; i < MAX_V; i++) \n            G[i].clear();\n\n        for(int i = 0; i < m; i++) {\n            cin >> cards[1 + i];\n            add_edge(0, 1 + i, 1);\n            //cout << 0 << \" -> \" << i << endl;\n        }\n\n        for(int i = 0; i < n; i++) {\n            cin >> cards[1 + m + i];\n            add_edge(1 + m + i, 1 + m + n, 1);\n            //cout << 1 + m + i << \" -> \" << 1 + m + n << endl;\n        }\n        for(int i = 0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                if(__gcd(cards[1 + i], cards[1 + m + j]) > 1) {\n                    //cout << 1 + i << \" -> \" << 1 + m + j << endl;\n                    add_edge(1 + i, 1 + m + j, 1);\n                }\n            }\n        }\n\n        int ans = 0;\n        while(true) {\n            fill(used, used + MAX_V, false);\n            int f = dfs(0, 1 + m + n, 1);\n            if(f == 0) \n                break;\n            ans += f;\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n#include <vector>\n#include <map>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\ntypedef int Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight == rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nWeight augment(Graph &g, Matrix &capacity, const vector<int> &level, vector<bool> &finished, int from, int t, Weight cur) {\n  if (from == t || cur == 0) { return cur; }\n  if (finished[from]) { return 0; }\n  for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n    int to = it->dest;\n    if (level[to] <= level[from]) { continue; }\n    Weight f = augment(g, capacity, level, finished, to, t, min(cur, capacity[from][to]));\n    if (f > 0) {\n      capacity[from][to] -= f;\n      capacity[to][from] += f;\n      return f;\n    }\n  }\n  finished[from] = true;\n  return 0;\n}\n\nWeight MaxFlow(Graph &g, int s, int t) {\n  int n = g.size();\n  Matrix capacity(n, Array(n));\n  for (int from = 0; from < n; from++) {\n    for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n      int to = it->dest;\n      capacity[from][to] += it->weight;\n    }\n  }\n  int ans = 0;\n  while (true) {\n    vector<int> level(n, -1);\n    level[s] = 0;\n    queue<int> que;\n    que.push(s);\n    for (int d = n; !que.empty() && level[que.front()] < d; ) {\n      int from = que.front();\n      que.pop();\n      if (from == t) { d = level[from]; }\n      for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n        int to = it->dest;\n        if (capacity[from][to] > 0 && level[to] == -1) {\n          que.push(to);\n          level[to] = level[from] + 1;\n        }\n      }\n    }\n    vector<bool> finished(n);\n    bool end = true;\n    while (true) {\n      Weight f = augment(g, capacity, level, finished, s, t, 1000000000);\n      if (f == 0) { break; }\n      ans += f;\n      end = false;\n    }\n    if (end) { break; }\n  }\n  return ans;\n}\n\nint maxFlow(const Graph &g, int s, int t) {\n  const int n = g.size();\n  Matrix capacity(n, Array(n, 0));\n  for (int i = 0; i < n; i++) {\n    for (Edges::const_iterator it = g[i].begin(); it != g[i].end(); it++) {\n      capacity[it->src][it->dest] = it->weight;\n    }\n  }\n  int ret = 0;\n  vector<int> parent(n);\n  while (true) {\n    fill(parent.begin(), parent.end(), -1);\n    priority_queue<Edge> que;\n    que.push(Edge(s, s, 0));\n    while (!que.empty()) {\n      Edge node = que.top();\n      que.pop();\n      if (parent[node.dest]) { continue; }\n      parent[node.dest] = node.src;\n      if (node.dest == t) { break; }\n      int from = node.dest;\n      for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n        int to = it->dest;\n        if (capacity[from][to] == 0 || parent[to] != -1) { continue; }\n        que.push(Edge(from, to, 0));\n      }\n    }\n    if (parent[t] == -1) { break; }\n    Weight flow = 2000000000;\n    int from = parent[t];\n    int to = t;\n    while (from != to) {\n      flow = min(flow, capacity[from][to]);\n      from = parent[from];\n      to = parent[to];\n    }\n    from = parent[t];\n    to = t;\n    while (from != to) {\n      capacity[from][to] -= flow;\n      capacity[to][from] += flow;\n      from = parent[from];\n      to = parent[to];\n    }\n    ret += flow;\n  }\n  return ret;\n}\n\n\n\nint gcd(int a, int b) {\n  if (b == 0) { return a; }\n  return gcd(b, a % b);\n}\n\nint m, n;\nint blue[501];\nint red[501];\n\nint BLUE(int x) { return x; }\nint RED(int x) { return m + x; }\nint SOURCE() { return m + n; }\nint DEST() { return m + n + 1; }\nint SIZE() { return m + n + 2; }\n\nint main() {\n  while (scanf(\"%d %d\", &m, &n), m|n) {\n    Graph g(SIZE());\n    REP(b, m) {\n      scanf(\"%d\", &blue[b]);\n      g[SOURCE()].push_back(Edge(SOURCE(), BLUE(b), 1));\n      g[BLUE(b)].push_back(Edge(BLUE(b), SOURCE(), 0));\n    }\n    REP(r, n) {\n      scanf(\"%d\", &red[r]);\n      g[RED(r)].push_back(Edge(RED(r), DEST(), 1));\n      g[DEST()].push_back(Edge(DEST(), RED(r), 0));\n    }\n    REP(b, m) {\n      REP(r, n) {\n        if (gcd(blue[b], red[r]) != 1) {\n          g[BLUE(b)].push_back(Edge(BLUE(b), RED(r), 1));\n          g[RED(r)].push_back(Edge(RED(r), BLUE(b), 0));\n        }\n      }\n    }\n    assert(MaxFlow(g, SOURCE(), DEST()) == maxFlow(g, SOURCE(), DEST()));\n    int ans = MaxFlow(g, SOURCE(), DEST());\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint N, M, B[500], R[500];\nvector<int> G[1000];\nint match[1000];\nbool used[1000];\n\nint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\n\nbool dfs(int v) {\n  used[v] = true;\n  REP(i, 0, G[v].size()) {\n    int u = G[v][i], w = match[u];\n    if(w < 0 || (!used[w] && dfs(w))) {\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(void) {\n  while(cin >> M >> N, M && N) {\n    REP(i, 0, M) cin >> B[i];\n    REP(i, 0, N) cin >> R[i];\n    REP(i, 0, M + N) G[i].clear();\n    REP(i, 0, M) REP(j, 0, N) if(gcd(B[i], R[j]) > 1) {\n      G[i].push_back(M + j);\n      G[M + j].push_back(i);\n    }\n\n    int ans = 0;\n    REP(i, 0, M + N) match[i] = -1;\n    REP(i, 0, M + N) {\n      if(match[i] < 0) {\n        REP(j, 0, M + N) used[j] = 0;\n        if(dfs(i)) ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nvector<int> blue;\nvector<int> red;\nvector<int> redpair;\nvector<int> v;\nvector<vector<int> > c;\nint m = 0;\nint n = 0;\n\n\nint gcd(int x,int y){\n    if(x % y == 0){\n        return y;\n    }\n    return gcd(y,x%y);\n}\n\nbool match(int x){\n    if(x == -1){\n        return 1;\n    }\n    for(int i = 0;i < n;i++){\n        if(c[x][i] == 1 && v[i] == 0){\n            v[i] = 1;\n            if(match(redpair[i])){\n                redpair[i] = x;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\n\nint main(){\n\n    while(cin >> m >> n){\n        if(m == 0 && n == 0){\n            break;\n        }\n        blue.clear();\n        red.clear();\n        redpair.clear();\n        v.clear();\n        c.clear();\n        for(int i = 0;i < m;i++){\n            int tmp = 0;\n            cin >> tmp;\n            blue.push_back(tmp);\n        }\n        for(int i = 0;i < n;i++){\n            int tmp = 0;\n            cin >> tmp;\n            red.push_back(tmp);\n            redpair.push_back(-1);\n            v.push_back(0);\n        }\n        for(int i = 0;i < m;i++){\n            c.push_back(vector<int>());\n            for(int j = 0;j < n;j++){\n                c[i].push_back(gcd(blue[i],red[j]) != 1);\n            }\n        }\n        int ans = 0;\n        for(int i = 0;i < m;i++){\n            for(int j = 0;j < n;j++){\n                v[j] = 0;\n            }\n            if(match(i)){ans++;}\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nbool augment(const Graph& g, int u,\n\t\t\t vector<int>& matchTo, vector<bool>& visited) {\n  if(u < 0) return true;\n  FOR(e, g[u]) if(!visited[e->dst]) {\n\tvisited[e->dst] = true;\n\tif(augment(g, matchTo[e->dst], matchTo, visited)) {\n\t  matchTo[e->src] = e->dst;\n\t  matchTo[e->dst] = e->src;\n\t  return true;\n\t}\n  }\n  return false;\n}\n\nint bipartiteMatching(const Graph& g, int L) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n\tvector<bool> visited(n);\n\tif(augment(g, u, matchTo, visited)) ++ match;\n  }\n\n  return match;\n}\n\nint main() {\n  int blue[500], red[500];\n  int m, n;\n  \n  while(cin >> m >> n && (m|n)) {\n\tGraph g(m+n);\n\tREP(i, m) cin >> blue[i];\n\tREP(i, n) cin >> red[i];\n\t\n\tREP(i, m) REP(j, n) {\n\t  if(__gcd(blue[i], red[j]) > 1) {\n\t\tg[i].push_back(Edge(i, m+j, 1));\n\t\tg[m+j].push_back(Edge(m+j, i, 1));\n\t  }\n\t}\n\t\n\tcout << bipartiteMatching(g, m) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  return match;\n}\n\nint gcd(int a, int b) {\n  return b!=0 ? gcd(b, a%b) : a;\n}\n\nint main() {\n  int m, n;\n  while(cin >> m >> n, m||n) {\n    vector<int> b(m);\n    vector<int> r(n);\n    REP(i,m)\n      cin >> b[i];\n    REP(i,n)\n      cin >> r[i];\n\n    Graph g(m+n);\n    REP(i,m) {\n      REP(j,n) {\n        if (gcd(b[i],r[j]) != 1) {\n          g[i].push_back(Edge(i, m+j, 1));\n          g[m+j].push_back(Edge(m+j, i, 1));\n        }\n      }\n    }\n    cout << bipartiteMatching(g, m) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<cstring>\nusing namespace std;\n\nint V;\nvector<int> G[1001];\nint match[1001];\nbool used[1001];\n\nvector<int> prime;\n\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i], w=match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int v=0;v<V;v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid primesolve(){\n\tprime.push_back(2);\n\tprime.push_back(3);\n\n\tfor(int i=4;i<1000000;i++){\n\t\tbool flag = true;\n\t\tfor(int k=2;k*k<=i;k++){\n\t\t\tif(i%k == 0){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tprime.push_back(i);\n\t\t}\n\t}\n}\nvector<int> primelist(int x){\n\tset<int> s;\n\tint index = 0;\n\twhile(prime[index]<=x){\n\t\tif(x%prime[index]==0){\n\t\t\ts.insert(prime[index]);\n\t\t}\n\t\tindex++;\n\t}\n\treturn vector<int>(s.begin(),s.end());\n}\n\nint main(){\n\tprimesolve();\n\twhile(true){\n\t\tint m,n;\n\t\tcin >> m >> n;\n\t\tif(m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tvector<int> b;\n\t\tvector<int> r;\n\t\tV = m+n;\n\t\tfor(int i=0;i<1001;i++){\n\t\t\tvector<int> buf;\n\t\t\tG[i] = buf;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tb.push_back(buf);\n\t\t}\n\t\tfor(int j=0;j<n;j++){\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tr.push_back(buf);\n\t\t}\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tvector<int> bs = primelist(b[i]);\n\t\t\t\tvector<int> rs = primelist(r[j]);\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int k=0;k<bs.size() && flag;k++){\n\t\t\t\t\tfor(int l=0;l<rs.size() && flag;l++){\n\t\t\t\t\t\tif(bs[k]==rs[l]){\n\t\t\t\t\t\t\tadd_edge(i,j+m);\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\nint NIL;\nconst int inf = 1<<29;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int> > Graph;\n\nbool bfs(const Graph &g,vi &dist,const vi &pair,int m) {\n    queue<int> q;\n\n    for(int i=0; i<m; ++i)\n        if(pair[i] == NIL) {\n            dist[i] = 0;\n            q.push(i);\n        }else\n            dist[i] = inf;\n    dist[NIL] = inf;\n\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        if(v == NIL) continue;\n        for(int i=0; i<g[v].size(); ++i) {\n            int u = g[v][i];\n            if(dist[pair[u]] == inf) {\n                dist[pair[u]] = dist[v]+1;\n                q.push(pair[u]);\n            }\n        }\n    }\n    return dist[NIL] != inf;\n}\n\nbool dfs(int v,const Graph &g,vi &dist,vi &pair) {\n    if(v != NIL) {\n        for(int i=0; i<g[v].size(); ++i) {\n            int u = g[v][i];\n            if(dist[pair[u]] == dist[v]+1) {\n                if(dfs(pair[u],g,dist,pair)) {\n                    pair[u] = v, pair[v] = u;\n                    return true;\n                }\n            }\n        }\n        dist[v] = inf;\n        return false;\n    }\n    return true;\n}\n\n// 0-(m-1)  <-->  m-(n-1)\n// O(|E| * |V|^(1/2))\nint hopcroft_karp(Graph &graph,int m) {\n    const int n = graph.size();\n    NIL = n;\n    vi pair(n+1, NIL), dist(n+1, 0);\n    int ret = 0;\n    while(bfs(graph,dist,pair,m)) {\n        for(int i=0; i<m; ++i)\n            if(pair[i] == NIL)\n                if(dfs(i,graph,dist,pair)) ret++;\n    }\n    return ret;\n}\n\nint gcd(int x,int y) {\n    if(y == 0) return x;\n    return gcd(y,x%y);\n}\n\nint main() {\n    int m,n;\n    while(cin>>m>>n, m|n) {\n        Graph g(m+n);\n        vector<int> b(m), r(n);\n        for(int i=0; i<m; ++i) cin>>b[i];\n        for(int i=0; i<n; ++i) cin>>r[i];\n\n        for(int i=0; i<m; ++i)\n            for(int j=0; j<n; ++j)\n                if(gcd(b[i],r[j]) > 1)\n                    g[i].push_back(j+m);\n        cout<<hopcroft_karp(g,m)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool augument(const vector<vector<int> >& g, int u, vector<int>& match_to, vector<bool>& visited)\n{\n  if (u < 0) {\n    return true;\n  }\n\n  for (vector<int>::const_iterator it(g[u].begin()); it != g[u].end(); ++it) {\n    if (!visited[*it]) {\n      visited[*it] = true;\n      if (augument(g, match_to[*it], match_to, visited)) {\n        match_to[u] = *it;\n        match_to[*it] = u;\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(const vector<vector<int> >& g, int L, vector<pair<int,int> >& matching)\n{\n  const int N = g.size();\n  vector<int> match_to(N, -1);\n  int match = 0;\n  for (int u = 0; u < N; u++) {\n    vector<bool> visited(N, false);\n    if (augument(g, u, match_to, visited)) {\n      match++;\n    }\n  }\n  for (int u = 0; u < L; u++) {\n    if (match_to[u] >= 0) {\n      matching.push_back(make_pair(u, match_to[u]));\n    }\n  }\n  return match;\n}\n\nint gcd(int a, int b)\n{\n  if (a < b) {\n    swap(a, b);\n  }\n  int r;\n  while ((r = a % b) != 0) {\n    a = b;\n    b = r;\n  }\n  return b;\n}\n\nint main()\n{\n  int n, m;\n  while (cin >> m >> n && !(m == 0 && n == 0)) {\n    vector<int> blue(m), red(n);\n    for (int i = 0; i < m; i++) {\n      cin >> blue[i];\n    }\n    for (int i = 0; i < n; i++) {\n      cin >> red[i];\n    }\n\n    vector<vector<int> > g(n+m);\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (gcd(blue[i], red[j]) > 1) {\n          g[i].push_back(m+j);\n        }\n      }\n    }\n\n    vector<pair<int,int> > matching;\n    int ans = bipartite_matching(g, m, matching);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#define INF 1000000000\n#define MAX_V 1000\n#define MAX 10000000\nusing namespace std;\n\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i], w=match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  memset(match, -1, sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v)){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint gcd(int x, int y){\n  int r;\n  if(x<y) swap(x, y);\n  while(y>0){\n    r=x%y;\n    x=y;\n    y=r;\n  }\n  return x;\n}\n\n\nmain(){\n  int m, n;\n  while(1){\n    cin >> m >> n;\n    if(m==0 && n==0) break;\n    for(int i=0;i<m+n;i++){\n      G[i].clear();\n    }\n    int in1[500], in2[500];\n    for(int i=0;i<m;i++){\n      cin >> in1[i];\n    }\n    for(int i=0;i<n;i++){\n      cin >> in2[i];\n    }\n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n\tif(gcd(in1[i], in2[j])!=1) add_edge(i, m+j);\n      }\n    }\n    V=m+n;\n    cout << bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX_M 500\n#define MAX_N 500\n#define MAX_V (MAX_M + MAX_N + 2)\n\n#define INF (1<<28)\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    if (a < b) swap(a, b);\n    return gcd(b, a%b);\n}\n\nstruct edge {\n    int to;\n    int cap;\n    int rev;\n    edge() {}\n    edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nvector<edge> G[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size()-1));\n}\n\nbool used[MAX_V];\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (true) {\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint m, n;\nint main() {\n    while (cin >> m >> n, m || n) {\n        for (int i = 0; i < m+n+2; i++) G[i].clear();\n        int blue[MAX_M];\n        int  red[MAX_N];\n        for (int i = 0; i < m; i++) cin >> blue[i];\n        for (int i = 0; i < n; i++) cin >>  red[i];\n\n        for (int i =   1; i <=   m; i++) add_edge(0,     i, 1);\n        for (int i = m+1; i <= m+n; i++) add_edge(i, m+n+1, 1);\n        for (int i = 0; i < m; i++) \n            for (int j = 0; j < n; j++) \n                if (gcd(blue[i], red[j]) != 1) \n                    add_edge(i+1, m+j+1, 1);\n\n        cout << max_flow(0, m+n+1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a) = min((a), (b)))\n#define chmax(a, b) ((a) = max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\nconst double pi = acos(-1);\nconst double eps = 1e-10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\n\nconst int MAX_V = 1010;\n\nint match[MAX_V];\nbool used[MAX_V];\nvector<vector<int>> G(MAX_V);\n\nbool dfs(int v){\n    used[v] = true;\n    for(int i=0; i<G[v].size(); i++){\n        int u = G[v][i], w = match[u];\n\n        if(w < 0 || (!used[w] && dfs(w))){\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nint bipartite_matching(int V){\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    memset(used, 0, sizeof(used));\n\n    for(int v=0; v<V; v++){\n        if(match[v] < 0){\n            memset(used, false, sizeof(used));\n            if(dfs(v)){\n                res++;\n            }\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    while(1){\n        int m, n; cin>>m>>n;\n        if(m == 0) return 0;\n\n        vector<int> a(m), b(n);\n        for(int i=0; i<m; i++) cin>>a[i];\n        for(int i=0; i<n; i++) cin>>b[i];\n\n        int V = m + n;\n\n        for(int i=0; i<m; i++){\n            for(int j=0; j<n; j++){\n                if(__gcd(a[i], b[j]) != 1){\n                    int from = i;\n                    int to = m + j;\n\n                    G[from].emplace_back(to);\n                    G[to].emplace_back(from);\n                }\n            }\n        }\n\n        cout << bipartite_matching(V) << endl;\n\n        for(int i=0; i<V; i++){\n            G[i].clear();\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max() / 2;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\n\nconst int MAX_V = 10e4;\n\nstruct edge\n{\n    int to, cap, rev;\n};\n\nstd::vector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap)\n{\n    G[from].push_back(edge{to, cap, (int)G[to].size()});\n    G[to].push_back(edge{from, 0, (int)G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f)\n{\n    if (v == t)\n        return f;\n    used[v] = true;\n    for (int i = 0; i <(int)G[v].size(); i++)\n    {\n        edge &e = G[v][i];\n        if (!used[e.to] && e.cap > 0)\n        {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0)\n            {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t)\n{\n    int flow = 0;\n    for (;;)\n    {\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0)\n            return flow;\n        flow += f;\n    }\n}\n\nint gcd(int a, int b)\n{\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true)\n    {\n        for (int i = 0; i < MAX_V; i++)\n        {\n            G[i].erase(G[i].begin(), G[i].end());\n            used[i] = false;\n        }\n        int m, n;\n        cin >> m >> n;\n        if (m == 0 && n == 0)\n            break;\n        bool can[1000][1000]; //can[i][j]:b[i]???r[j]?????????????????????\n        int b[1000], r[1000];\n        for (int i = 1; i <= m; i++)\n            cin >> b[i];\n        for (int i = 1; i <= n; i++)\n            cin >> r[i];\n        for (int i = 1; i <= m; i++)\n        {\n            for (int j = 1; j <= n; j++)\n            {\n                can[i][j] = (gcd(b[i], r[j]) > 1);\n            }\n        }\n        int s = m + n + 1, t = s + 1;\n\n        for (int i = 1; i <= m; i++)\n        {\n            add_edge(s, i, 1);\n        }\n\n        for (int i = 1; i <= n; i++)\n        {\n            add_edge(m + i, t, 1);\n        }\n\n        for (int i = 1; i <= m; i++)\n        {\n            for (int j = 1; j <= n; j++)\n            {\n                if (can[i][j])\n                {\n                    add_edge(i, m + j, 1);\n                }\n            }\n        }\n        cout << max_flow(s, t) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n#define reps(i,s,n) for(int (i)=(s);(i)<(n);++(i))\n#define rep(i,n) reps(i,0,n)\n#define rept(i,n) rep(i,(n)+1)\n#define repst(i,s,n) reps(i,s,(n)+1)\n#define reprt(i,n,t) for(int (i)=(n);(i)>=(t);--(i))\n#define repr(i,n) reprt(i,n,0)\n#define each(itr,v) for(auto &(itr):(v))\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define tmax(x,y,z) max(x,max(y,z))\n#define tmin(x,y,z) min(x,min(y,z))\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n#define ln '\\n'\n#define bln(i,n) (((i)==(n)-1)?'\\n':' ')\n#define dbg(x) cout<<#x\" = \"<<(x)<<ln<<flush\n#define dbga(x,n) {cout<<#x\" : \";for(int (i)=0;i<(n);++i){cout<<((x)[i])<<(i==((n)-1)?'\\n':' ')<<flush;}}\n#define zero(a) memset(a,0,sizeof(a))\n#define unq(a) sort(all(a)),a.erase(unique(all(a)),a.end())\n\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vst;\ntypedef vector<bool> vb;\ntypedef vector<ld> vld;\ntypedef vector<pii> vpii;\ntypedef vector<pll> vpll;\ntypedef vector<vector<int> > mat;\n\nconst ll inf = (ll)1e9+10;\nconst ll linf = (ll)1e18+10;\nconst ll mod = (ll)(1e9+7);\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\nconst int ddx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int ddy[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst double eps = 1e-10;\n\nll mop(ll a,ll b,ll m=mod) {ll r=1;a%=m; assert(b>=0); for(;b;b>>=1){if(b&1)r=r*a%m;a=a*a%m;}return r;}\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b) {return a*b/gcd(a,b);}\n\nstruct oreno_initializer {\n\toreno_initializer() {\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(0);\n\t}\n} oreno_initializer;\n\n// ━━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…\n// .｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋.｡.:( ^ω^)・ﾟ＋\n// ・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・‥…━━━☆・\n\nconst int MAXV = 1010;\nclass FordFulkerson {\n\tprivate:\n\tstruct edge {int to, cap, rev;};\n\tvector<edge> g[MAXV];\n\tbool used[MAXV];\n\tpublic:\n\t// fromからtoへ向かう要領capの辺をグラフに追加する\n\tvoid add_edge(int from, int to, int cap) {\n\t\tg[from].push_back((edge){to, cap, (int)g[to].size()});\n\t\tg[to].push_back((edge){from, 0, (int)g[from].size()-1});\n\t}\n\t// 増加パスをdfsで探す\n\tint dfs(int v, int t, int f) {\n\t\tif (v==t) return f;\n\t\tused[v] = true;\n\t\tfor (int i = 0; i < g[v].size(); ++i) {\n\t\t\tedge &e = g[v][i];\n\t\t\tif (!used[e.to] && e.cap>0) {\n\t\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\t\tif (d>0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t// sからtへの最大流を求める\n\tint getflow(int s, int t) {\n\t\tint flow = 0;\n\t\twhile (true) {\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tint f = dfs(s,t,(int)1e9+10);\n\t\t\tif (f==0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n};\n\nint n, m, b[505], r[505];\n\nsigned main() {\n\twhile (1) {\n\t\tcin >> n >> m;\n\t\tif (n==0) break;\n\t\tFordFulkerson f;\n\t\trepst(i,1,n) {\n\t\t\tcin >> b[i];\n\t\t\tf.add_edge(0,i,1);\n\t\t}\n\t\trepst(i,1,m) {\n\t\t\tcin >> r[i];\n\t\t\tf.add_edge(n+i,n+m+1,1);\n\t\t\trepst(j,1,n) if (gcd(b[j],r[i])!=1) f.add_edge(j,n+i,1);\n\t\t}\n\t\tcout << f.getflow(0,n+m+1) << ln;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define MAX_V 1000\n\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid initialize(int v){\n\tV = v;\n\tfor(int i = 0; i < v; ++i){\n\t\tG[i].clear();\n\t}\n}\n\nvoid add_edge(int u, int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); ++i){\n\t\tint u = G[v][i], w = match[u];\n\t\tif( w < 0 || !used[w] && dfs(w) ){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor(int v = 0; v < V; ++v){\n\t\tif( match[v] < 0 ){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif( dfs(v)){\n\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int a, int b){\n\twhile(b){\n\t\tint r = a % b;\n\t\ta = b;\n\t\tb = r;\n\t}\n\treturn a;\n}\n\nint main(){\n\tint m, n;\n\tint b[500], r[500];\n\twhile( scanf(\"%d%d\", &m, &n), m != 0 ){\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tscanf(\"%d\", &b[i]);\n\t\t}\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%d\", &r[i]);\n\t\t}\n\n\t\tinitialize(m + n);\n\t\tfor(int i = 0; i < m; ++i)\n\t\tfor(int j = 0; j < n; ++j){\n\t\t\tif( gcd(b[i], r[j]) > 1 ){\n\t\t\t\tadd_edge(i, j + m);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", bipartite_matching());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint PY[510] = {};\nbool D[510][510] = {};\nbool V[510] = {};\nint X, Y;\n\n\nbool link(int n, int m) {\n\tint p = n;\n\tint q = m;\n\twhile (p != 0 && q != 0) {\n\t\tif (p > q)p %= q;\n\t\telse if (q > p)q %= p;\n\t\telse break;\n\t}\n\treturn (p == 1 || q == 1) ? false : true;\n}\n\nbool match(int x) {\n\tif (x < 0) return true;\n\tif (V[x])return false;\n\tV[x] = true;\n\tfor (int y = 0; y<Y; ++y) {\n\t\tif (!D[x][y]) continue;\n\t\tif (match(PY[y])) {\n\t\t\tPY[y] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\n\n\nint main() {\n\twhile (true) {\n\t\tcin >> X >> Y;\n\t\tif (X == 0 && Y == 0)break;\n\t\tint R[510] = {};\n\t\tint B[510] = {};\n\t\tfor (int i = 0; i < X; i++) {\n\t\t\tcin >> R[i];\n\t\t}\n\t\tfor (int i = 0; i < Y; i++) {\n\t\t\tcin >> B[i];\n\t\t}\n\t\tfor (int i = 0; i < 510; i++) {\n\t\t\tfor (int j = 0; j < 510; j++) {\n\t\t\t\tD[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < X; i++) {\n\t\t\tfor (int j = 0; j < Y; j++) {\n\t\t\t\tD[i][j] = link(R[i], B[j]);\n\t\t\t}\n\t\t}\n\t\tfill(PY, PY + Y, -1);\n\t\tint count = 0;\n\t\tfor (int x = 0; x<X; ++x) {\n\t\t\tfill(V, V + X, false);\n\t\t\tif (match(x)) ++count;\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#define SIZE 1000\n\nusing namespace std;\n\nint m, n, b[501], r[501];\nint match[SIZE];\nbool used[SIZE];\nvector<int> G[SIZE];\n\nbool dfs(int v){\n\tused[v]=1;\n\tfor(int i=0; i<G[v].size(); i++){\n\t\tint u = G[v][i], w = match[u];\n\t\tif(w<0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u, match[u] = v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(){\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n && !m) break;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> b[i];\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcin >> r[i];\n\t\t}\n\t\tfor(int i=0; i<SIZE; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tint a = b[i], c = r[j];\n\t\t\t\twhile(c){\n\t\t\t\t\ta %= c;\n\t\t\t\t\tswap(a, c);\n\t\t\t\t}\n\t\t\t\tif(a != 1){\n\t\t\t\t\tG[i].push_back(j+n);\n\t\t\t\t\tG[n+j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res=0;\n\t\tfill(match, match+SIZE, -1);\n\t\tfor(int v=0; v<m+n; v++){\n\t\t\tif(match[v]<0){\n\t\t\t\tfill(used, used+SIZE, 0);\n\t\t\t\tif(dfs(v)) res++;\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#define SIZE 1000\n\nusing namespace std;\n\nint m, n, b[501], r[501];\nint match[SIZE];\nbool used[SIZE];\nvector<int> G[SIZE];\n\nbool dfs(int v){\n\tused[v]=1;\n\tfor(int i=0; i<G[v].size(); i++){\n\t\tint u = G[v][i], w = match[u];\n\t\tif(w<0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u, match[u] = v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid solve(){\n\tint res=0;\n\tmemset(match, -1, sizeof(match));\n\tfor(int v=0; v<m+n; v++){\n\t\tif(match[v]<0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif(dfs(v)) res++;\n\t\t}\n\t}\n\tcout<<res<<endl;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n && !m) break;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> b[i];\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcin >> r[i];\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tG[i].clear();\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tint a = b[i], c = r[j];\n\t\t\t\twhile(c){\n\t\t\t\t\ta %= c;\n\t\t\t\t\tswap(a, c);\n\t\t\t\t}\n\t\t\t\tif(a != 1){\n\t\t\t\t\tG[i].push_back(j+n);\n\t\t\t\t\tG[n+j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <cstring>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nconst int MAX_V=1000;\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\nint gcd(int a,int b){\n\tif(a>b) swap(a,b);\n\tif(a==0) return b;\n\treturn gcd(b%a,a);\n}\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\nbool dfs(int v){\n\tused[v]=true;\n\trep(i,G[v].size()){\n\t\tint u=G[v][i],w=match[u];\n\t\tif(w<0 || (!used[w] && dfs(w))){\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint nibu(){\n\tint res=0;\n\tmemset(match,-1,sizeof(match));\n\trep(v,V){\n\t\tif(match[v]<0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)) res++;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\twhile(true){\n\t\tint m,n,b[500],r[500];\n\t\tcin>>m>>n;\n\t\tif(m==0) break;\n\t\trep(i,m) cin >> b[i];\n\t\trep(i,n) cin >> r[i];\n\t\tV=m+n;\n\t\trep(i,V) G[i].clear();\n\t\trep(i,m) rep(j,n) if(gcd(b[i],r[j])>1) add_edge(i,j+m);\n\t\tcout << nibu() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//59\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n\nusing namespace std;\n\nint V;\nvector<int> G[1000];\nint match[1000];\nbool used[1000];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0||!used[w]&&dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint solve(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nbool cd(int a,int b){\n  if(a<b){\n    swap(a,b);\n  }\n  while(b){\n    int r=a%b;\n    a=b;\n    b=r;\n  }\n  return a>1;\n}\n\nint main(){\n  for(int m,n;cin>>m>>n,m|n;){\n    vector<int> b,r;\n    for(int i=0;i<m;i++){\n      int j;\n      cin>>j;\n      b.push_back(j);\n    }\n    for(int i=0;i<n;i++){\n      int j;\n      cin>>j;\n      r.push_back(j);\n    }\n    V=n+m;\n    for(int i=0;i<m+n;i++){\n      G[i].clear();\n    }\n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n\tif(cd(b[i],r[j])){\n\t  add_edge(i+n,j);\n\t}\n      }\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\n//Class.\nvector<int> list[100000];\nint N, M, E;\nint match[100000];\nbool used[100000];\nint x[10000], y[10000];\n\nbool DFS(int V) {\n\tused[V] = true;\n\tfor (int i = 0; i < list[V].size(); i++) {\n\t\tint u = list[V][i]; int w = match[u];\n\t\tif (w < 0 || !used[w] && DFS(w)) {\n\t\t\tmatch[V] = u;\n\t\t\tmatch[u] = V;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint supermatching() {\n\tint r = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int j = 0; j < N + M; j++) {\n\t\tif (match[j] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (DFS(j)) { r++; }\n\t\t}\n\t}\n\treturn r;\n}\n\n//main.\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> x[i];\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> y[i];\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (__gcd(N, M) != 1) {\n\t\t\t\tlist[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << supermatching() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct Dinic {\n    int n, s, t;\n    vector<int> level, iter;\n    vector<vector<Capacity>> cap, flow;\n    vector<vector<int>> g;\n    Capacity inf;\n    Dinic(int n)\n        : n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n          g(n, vector<int>()), inf(numeric_limits<Capacity>::max()/8){}\n    Dinic(const Graph &graph){\n        *this = Dinic(graph.size());\n        rep(i,n) for(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n    }\n    void addEdge(int u, int v, Capacity c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    Capacity residue(int u, int v){\n        return cap[u][v] - flow[u][v];\n    }\n    Capacity solve(int s, int t){\n        this->t = t, this->s = s;\n        Capacity res = 0, aug = 1;\n        while(aug > 0){\n            levelize();\n            iter.assign(n, 0);\n            aug = augment(s, inf);\n            res += aug;\n        }\n        return res;\n    }\n    void levelize(){\n        level.assign(n, inf); level[s] = 0;\n        queue<int> q; q.emplace(s);\n        while(q.size()){\n            int v = q.front(); q.pop();\n            for(const int &d : g[v]){\n                if(level[d] <= level[v] + 1 || residue(v,d) == 0) continue;\n                level[d] = level[v] + 1; q.emplace(d);\n            }\n        }\n    }\n    Capacity augment(int v, Capacity lim){\n        Capacity res = 0;\n        if(v == t) return lim;\n        for(int i = iter[v]; i < (int)g[v].size(); i++){\n            const int &d = g[v][i];\n            if(residue(v,d) == 0 || level[v] + 1 != level[d]) continue;\n            Capacity aug = augment(d, min(lim, residue(v,d)));\n            if(aug > 0){\n                lim -= aug;\n                flow[v][d] += aug; flow[d][v] -= aug;\n                res += aug;\n                if(lim == 0) return res;\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    fastios();\n    int n,m;\n    while(cin >> n >> m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        Dinic d(n+m+2);\n        int s = n+m, t = n+m+1;\n        rep(i,m) d.addEdge(i+n,t,1);\n        rep(i,n){\n            d.addEdge(s,i,1);\n            rep(j,m) if(__gcd(a[i],b[j]) != 1) d.addEdge(i,n+j,1);\n        }\n        rep(i,n)rep(j,m){\n            if(d.flow[i][j+n]) dump(i,j, d.flow[i][j+m]);\n        }\n        cout << d.solve(s,t) << endl;\n    }\n}\n\n// int main(){\n//     int N,M;\n//     cin >> N >> M;\n//     Graph g(N);\n//     rep(i,M){\n//         int a,b,c;\n//         cin >> a >> b >> c;\n//         g[a].emplace_back(a,b,c);\n//     }\n//     Dinic dinic(g);\n//     cout << dinic.solve(0,N-1) << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\nint dy[]={0, 0, 1, -1, 0};\nint dx[]={1, -1, 0, 0, 0};\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\n#define MAX_N 500\n#define MAX_K 500\n#define MAX_V 1002\n#define INF 1000000000\n\n\nstruct edge { int to, cap, rev; };\nvector<edge> G[MAX_V];\nbool used[MAX_V]; \nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint N, K;\nbool can[MAX_N][MAX_K];\nvoid solve() {\n    int s = N + K, t = s + 1;\n    for (int i = 0; i < N; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < K; i++) {\n        add_edge(N + i, t, 1);\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < K; j++) {\n            if (can[i][j]) {\n                add_edge(i, N + j, 1);\n            }\n        }\n    }\n    printf(\"%d\\n\",max_flow(s,t));\n}\n\nint gcd(int a,int b){\n    if(a < b){\n        int c = a;\n        a = b;\n        b = c;\n    }\n    if(a % b == 0)\n        return b;\n    return gcd(b,a % b);\n}\n\nint inb[500],inr[500];\n\nbool input(){\n    scanf(\"%d%d\",&N,&K);\n    if(N == 0 && K == 0)\n        return false;\n    REP(i,N)\n        scanf(\"%d\",&inb[i]);\n    REP(i,K)\n        scanf(\"%d\",&inr[i]);\n\n    memset(can,false,sizeof(can));\n    REP(i,N){\n        REP(j,K){\n            if(gcd(inb[i],inr[j]) > 1)\n                can[i][j] = true;\n        }\n    }\n    REP(i,N + K + 2){\n        while(!G[i].empty()){\n            G[i].pop_back();\n        }\n    }\n    return true;\n}\n\nint main(){\n    while(input()){\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nvector<int> blue,red,redpair,v;\n//blue[i]??§i?????????????????????????????°???,red[i]??§i?????????????????????????????°???,redpair[i]??§i??????????????????????????¨?????¢????????????????????????????????????????????????,v[i]??§i????????????????????????????????????????????????????????¨???(1:?????????0:??????)\nint m=0,n=0;\n\nint gcd(int x,int y){\n\tif(x%y==0){return y;}\n\treturn gcd(y,x%y);\n}\n\nbool match(int x){\n\tif(x==-1)return 1;\n\tfor(int i=0;i<n;i++){\n\t\tif(gcd(blue[x],red[i])!=1 && v[i]==0){\n\t\t\tv[i]=1;\n\t\t\tif(match(redpair[i])){\n\t\t\t\tredpair[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tv[i]=0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(cin>>m>>n){\n\t\tif(m==0 && n==0){break;}\n\t\tblue=vector<int>();\n\t\tred=vector<int>();\n\t\tredpair=vector<int>();\n\t\tv=vector<int>();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint tmp=0;\n\t\t\tcin>>tmp;\n\t\t\tblue.push_back(tmp);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmp=0;\n\t\t\tcin>>tmp;\n\t\t\tred.push_back(tmp);\n\t\t\tredpair.push_back(-1);//-1??§?????¢??????????????¶????????¨???\n\t\t\tv.push_back(0);\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(match(i)){ans++;}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct Dinic {\n    int n, s, t;\n    vector<int> level, iter, que;\n    vector<vector<Capacity>> cap, flow;\n    vector<vector<int>> g;\n    Capacity inf;\n    Dinic(int n)\n        : n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n          g(n, vector<int>()), inf(numeric_limits<Capacity>::max()/8){}\n    Dinic(const Graph &graph){\n        *this = Dinic(graph.size());\n        rep(i,n) for(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n    }\n    void addEdge(int u, int v, Capacity c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    inline Capacity residue(int u, int v){ return cap[u][v] - flow[u][v]; }\n    Capacity solve(int s, int t){\n        this->t = t, this->s = s;\n        Capacity res = 0, aug = 1;\n        while(aug > 0){\n            levelize();\n            iter.assign(n, 0);\n            res += (aug = augment(s, inf));\n        }\n        return res;\n    }\n    void levelize(){\n        level.assign(n, inf); level[s] = 0;\n        int l = 0, r = 0;\n        que.assign(n+1, 0);\n        que[r++] = s;\n        while(l != r){\n            int v = que[l++];\n            for(const int &d : g[v]){\n                if(level[d] <= level[v] + 1 || residue(v,d) == 0) continue;\n                level[d] = level[v] + 1; que[r++] = d;\n            }\n        }\n    }\n    Capacity augment(int v, Capacity lim){\n        Capacity res = 0;\n        if(v == t) return lim;\n        for(int &i = iter[v]; i < (int)g[v].size(); i++){\n            const int &d = g[v][i];\n            if(residue(v,d) == 0 || level[v] + 1 != level[d]) continue;\n            const Capacity aug = augment(d, min(lim, residue(v,d)));\n            if(aug > 0){\n                flow[v][d] += aug; flow[d][v] -= aug;\n                res += aug; lim -= aug;\n                if(lim == 0) break;\n            }\n        }\n        return res;\n    }\n};\n\nint dp[500][500];\nint gcd(int a, int b){\n    return a < 500 && b < 500 ? dp[a][b] : b == 0 ? a : gcd(b, a%b);\n}\n\n\nint main(){\n    rep(i,500)rep(j,i+1) dp[i][j] = dp[j][i] = __gcd(i,j);\n    fastios();\n    int n,m;\n    while(cin >> n >> m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        Dinic d(n+m+2);\n        int s = n+m, t = n+m+1;\n        rep(i,m) d.addEdge(i+n,t,1);\n        rep(i,n){\n            d.addEdge(s,i,1);\n            rep(j,m) if(gcd(a[i],b[j]) != 1) d.addEdge(i,n+j,1);\n        }\n        rep(i,n)rep(j,m){\n            if(d.flow[i][j+n]) dump(i,j, d.flow[i][j+m]);\n        }\n        cout << d.solve(s,t) << endl;\n    }\n}\n\n// int main(){\n//     int N,M;\n//     cin >> N >> M;\n//     Graph g(N);\n//     rep(i,M){\n//         int a,b,c;\n//         cin >> a >> b >> c;\n//         g[a].emplace_back(a,b,c);\n//     }\n//     Dinic dinic(g);\n//     cout << dinic.solve(0,N-1) << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string.h>\nusing namespace std;\n\nint V;\nvector<int> G[2000];\nint match[2000];\nbool used[2000];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<(int)G[v].size();i++){\n    int u=G[v][i],w=match[u];\n\n    if( w<0 || !used[w] && dfs(w) ){\n\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\n\nint m,n;\nint b[500],r[500];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin>>m>>n){\n    if(m==0&&n==0)break;\n\n    for(int i=0;i<m;i++)cin>>b[i];\n    for(int i=0;i<n;i++)cin>>r[i];\n\n    for(int i=0;i<2000;i++)G[i].clear();\n\n    //for(int i=0;i<m;i++)add_edge(n+m,i);\n    //for(int i=0;i<n;i++)add_edge(m+i,n+m+1);\n\n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n\tif( __gcd(b[i],r[j])> 1 )add_edge(i,m+j);\n      }\n    }\n\n    V=m;\n    cout<<bipartite_matching()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, rev;\n};\n\nvector< vector<Edge> > G;\nbool used[2000];\n\nvoid addEdge(int from, int to, int cap) {\n\tG[from].push_back({to, cap, G[to].size()});\n\tG[to].push_back({from, 0, G[from].size()-1});\n}\n\nint dfs(int v, int t, int f) {\n\tif (v == t) return f;\n\tused[v] = true;\n\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#define INF 1e9\n\nint max_flow(int s, int t) {\n\tint flow = 0;\n\twhile (1) {\n\t\tmemset(used, false, sizeof(used));\n\t\tint f = dfs(s, t, INF);\n\t\tif (f == 0) break;\n\t\tflow += f;\n\t}\n\treturn flow;\n}\n\nint gcd(int a, int b) {\n\treturn b == 0 ? a : gcd(b, a%b);\n}\n\nint main() {\n\tint M, N;\n\twhile (cin >> M >> N, M || N) {\n\t\tG.clear(); G.resize(N+M+2);\n\n\t\tvector<int> a(M);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tcin >> a[i];\n\t\t}\n\t\tvector<int> b(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> b[i];\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (gcd(a[i], b[j]) > 1) {\n\t\t\t\t\taddEdge(i, M+j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\taddEdge(M+N, i, 1);\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\taddEdge(M+i, M+N+1, 1);\n\t\t}\n\t\tcout << max_flow(N+M, N+M+1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define MAX 600\n\n\nint blaue[MAX];\nint rote[MAX];\n\nint c[MAX][MAX];\nint p[MAX];//rote->blaue\n\nint gcd(int x,int y)\n{\n    while(y!=0)\n    {\n        int r=x%y;\n        x=y;\n        y=r;\n    }\n    return x;\n}\n\nint match(int m,int n,int *v,int bn)\n{\n    if(bn<0)return 1;\n    for(int j=0;j<n;j++)\n    {\n        if(c[bn][j]==0 || v[j])continue;\n        v[j]=1;\n        if(match(m,n,v,p[j]))//if p[j]==-1, the result is true(1)\n        {\n            p[j]=bn;\n            return 1;\n        }\n    }\n    return 0;\n}\n\n\nint main(void)\n{\n    int m,n;\n    while(scanf(\"%d%d\",&m,&n)==2&&(m||n))\n    {\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d\",blaue+i);\n        }\n        for(int j=0;j<n;j++)\n        {\n            scanf(\"%d\",rote+j);\n            p[j]=-1;\n        }\n        for(int i=0;i<m;i++)\n        {\n            for(int j=0;j<n;++j)\n            {\n                c[i][j]=gcd(blaue[i],rote[j])>=2?1:0;\n            }\n        }\n        int result=0;\n        for(int i=0;i<m;i++)\n        {\n            int v[MAX]={0};\n            result+=match(m,n,v,i);\n        }\n        printf(\"%d\\n\",result);\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\n\nconst int MAX_V=1000;\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\nbool dfs(int v) {\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++) {\n        int u = G[v][i], w = match[u];\n        if (w < 0 || !used[w] && dfs(w)) {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching() {\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for(int v = 0; v < V; v++) {\n        if (match[v] < 0) {\n            memset(used, 0, sizeof(used));\n            if (dfs(v)) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nint gcd(int a, int b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nint main(){\n\tint m,n;\n\twhile(cin>>m>>n,m|n){\n\t\tvi b(m),r(n);\n\t\tREP(i,m){\n\t\t\tcin>>b[i];\n\t\t}\n\t\tREP(i,n){\n\t\t\tcin>>r[i];\n\t\t}\n\n\t\tV=n+m;\n\t\tREP(i,V){\n\t\t\tG[i].clear();\n\t\t}\n\t\tREP(i,m){\n\t\t\tREP(j,n){\n\t\t\t\tif(gcd(b[i],r[j])>1){\n\t\t\t\t\tadd_edge(i,m+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<bipartite_matching()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1000000000;\nconst long long int llINF = 1000000000000000000;\n\nusing namespace std;\nusing ll = long long int;\nusing vl = vector<ll>;\nusing vvl = vector<vector<ll>>;\nusing vvvl = vector<vector<vector<ll>>>;\n\ntypedef pair<ll, ll> pll;\nbool paircomp(const pll &a, const pll &b) {\n  if (a.first == b.first)\n    return a.second < b.second;\n  return a.first < b.first;\n}\nstruct multi {\n  ll first;\n  ll second;\n  ll third;\n};\nbool multicomp(const multi &a, const multi &b) {\n  if (a.first == b.first)\n    return a.second < b.second;\n  return a.first < b.first;\n}\n#define REP(i, n) for (ll i = 0; i < (n); i++)\n#define RREP(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define AUTO(i, m) for (auto &i : m)\n#define ALL(a) (a).begin(), (a).end()\n#define MAX(vec) *std::max_element(vec.begin(), vec.end())\n#define MIN(vec) *std::min_element(vec.begin(), vec.end())\n#define ARGMAX(vec)                                                            \\\n  std::distance(vec.begin(), std::max_element(vec.begin(), vec.end()))\n#define ARGMIN(vec)                                                            \\\n  std::distance(vec.begin(), std::min_element(vec.begin(), vec.end()))\n#define REV(T) greater<T>()\n#define PQ(T) priority_queue<T, vector<T>, greater<T>>\n#define VVL(a, b, c) vector<vector<ll>>(a, vector<ll>(b, c))\n#define VVVL(a, b, c, d)                                                       \\\n  vector<vector<vector<ll>>>(a, vector<vector<ll>>(b, vector<ll>(c, d)))\n#define SP(a) setprecision(a)\n#define SQRT(a) sqrt((long double)(a))\n#define DPOW(a, b) pow((long double)(a), (long double)(b))\n#define UNIQUE(vec)                                                            \\\n  do {                                                                         \\\n    sort(ALL((vec)));                                                          \\\n    (vec).erase(std::unique(ALL((vec))), (vec).end());                         \\\n  } while (0)\n\nll POW(ll n, ll m) {\n  if (m == 0) {\n    return 1;\n  } else if (m % 2 == 0) {\n    ll tmp = POW(n, m / 2);\n    return (tmp * tmp);\n  } else {\n    return (n * POW(n, m - 1));\n  }\n}\nll GCD(ll a, ll b) {\n  if (b == 0)\n    return a;\n  return GCD(b, a % b);\n}\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\ntypedef ll Weight;\nstruct Edge {\n  ll src, dst;\n  Weight weight;\n  Edge(ll src, ll dst, Weight weight) : src(src), dst(dst), weight(weight) {}\n};\nbool operator<(const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n             e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool augment(const Graph &g, ll u, vector<ll> &matchTo, vector<bool> &visited) {\n  if (u < 0)\n    return true;\n  AUTO(e, g[u]) if (!visited[e.dst]) {\n    visited[e.dst] = true;\n    if (augment(g, matchTo[e.dst], matchTo, visited)) {\n      matchTo[e.src] = e.dst;\n      matchTo[e.dst] = e.src;\n      return true;\n    }\n  }\n  return false;\n}\nll bipartiteMatching(const Graph &g, ll L, Edges &matching) {\n  const ll n = g.size();\n  vector<ll> matchTo(n, -1);\n  ll match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited))\n      ++match;\n  }\n  REP(u, L)\n  if (matchTo[u] >= 0)\n    matching.push_back(Edge(u, matchTo[u], 1));\n  return match;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(NULL);\n  vl ANS;\n\n  while (true) {\n    ll N, M;\n    cin >> M >> N;\n    if (M == 0 || N == 0)\n      break;\n    vl B(M), R(N);\n    Graph G(N + M);\n    Edges E;\n\n    REP(i, M) cin >> B[i];\n    REP(i, N) cin >> R[i];\n    REP(i, B.size()) REP(j, R.size()) {\n      if (GCD(B[i], R[j]) > 1) {\n        G[i].push_back(Edge(i, M + j, 1));\n        G[M + j].push_back(Edge(M + j, i, 1));\n      }\n    }\n    ANS.push_back(bipartiteMatching(G, M, E));\n  }\n  AUTO(a, ANS) cout << a << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 10000000;\n\nstruct edge {\n    int to, cap, rev;\n    edge(int t, int c, int r) : to(t), cap(c), rev(r) {};\n};\n\nconst int MAX_V = 500 + 500 + 2;\nvector<vector<edge> > G(MAX_V, vector<edge>());\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap)\n{\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nint dfs(int v, int t, int f)\n{\n    if (v == t)\n        return f;\n\n    used[v] = true;\n\n    for (int i = 0; i < G[v].size(); ++i) {\n        edge &e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t)\n{\n    int f = 0;\n\n    for (;;) {\n        memset(used, 0, sizeof(used));\n        int d = dfs(s, t, INF);\n        if (d == 0)\n            break;\n        f += d;\n    }\n\n    return f;\n}\n\nint gcd(int a, int b)\n{\n    if (a < b)\n        swap(a, b);\n\n    while (b != 0) {\n        a = a % b;\n        swap(a, b);\n    }\n\n    return a;\n}\n\nint b[500], r[500];\n\n#define sv 0\n#define bv(i) (1 + (i))\n#define rv(i) (1 + m + (i))\n#define tv (1 + m + n)\n\nint main()\n{\n    for (;;) {\n        int m, n;\n        scanf(\"%d %d\", &m, &n);\n        if (m ==0 && n == 0)\n            break;\n\n        for (int i = 0; i < MAX_V; ++i)\n            G[i].clear();\n\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%d\", &b[i]);\n            add_edge(sv, bv(i), 1);\n        }\n        for (int i = 0; i < n; ++i) {\n            scanf(\"%d\", &r[i]);\n            add_edge(rv(i), tv, 1);\n        }\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (gcd(b[i], r[j]) != 1) {\n                    add_edge(bv(i), rv(j), 1);\n                }\n            }\n        }\n\n        /*\n        for (int i = 0; i <= tv; ++i) {\n            printf(\"%d to:\\n\", i);\n            for (int j = 0; j < G[i].size(); ++j) {\n                printf(\"%2d \", G[i][j].to);\n            }\n            printf(\"\\n\");\n        }\n        */\n\n        printf(\"%d\\n\", max_flow(sv, tv));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <functional>\nusing namespace std;\n\n#ifdef __linux\n#define _U(s) s##_unlocked\n#else\n#define _U(s) _##s##_nolock\n#define _CRT_DISABLE_PERFCRIT_LOCKS\n#endif\n#define gcu _U(getchar)\n#define pcu _U(putchar)\n#define _DEF(r, n, ...) inline r n(__VA_ARGS__) noexcept\n#define _T template <typename T>\n#define _HT template <typename H,typename... T>\n#define _OP(t) inline operator t()\nstruct _in {\n#ifdef _GLIBCXX_STRING\n\t_OP(string){string s;char c;while(isspace(c = gcu()));do{s+=c;}while(c=gcu(),c!=' '&&c!='\\n'&&c!=EOF);return s;}\n#define _S\n#endif\n\t_OP(char){char c=gcu();gcu();return c;}\n\t_OP(double){double d; scanf(\"%lf\",&d); gcu();return d;}\n\t_T _OP(T){T n{},m{1},c;while(isspace(c = gcu()));if(c=='-')m=-1,c=gcu();do{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m*n;}\n} in;\n#define _SCAN(...) _DEF(bool,scan,__VA_ARGS__)\n#ifdef _S\n_SCAN(string &o) {int c{gcu()};if(c==EOF)return false;else{ungetc(c,stdin);string t=move(in);o=t;return true;}}\n#endif\n_T _SCAN(T &o) {int c{gcu()};return c==EOF?false:(ungetc(c,stdin),o=in,true);}\n_HT _SCAN(H &h,T&&... t){return scan(h)&&scan(t...);}\n#define _OUT(...) _DEF(void,out,__VA_ARGS__)\n#define _OUTL(...) _DEF(void,outl,__VA_ARGS__)\n_OUT(bool b){pcu('0'+b);}\n_OUT(const char *s){while(*s)pcu(*s++);}\n_OUT(char c){pcu(c);}\n#ifdef _S\n_OUT(string &s){for(char c:s)pcu(c);}\n#endif\n_T _OUT(T n){static char b[20];char *p=b;T m=n<0?pcu('-'),-1:1;\n\tif(!n)*p++='0';else while(n)*p++=(char)(n%10*m+'0'),n/=10;while(p!=b)pcu(*--p);}\n_OUTL(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n\t_T _OUT(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);}\n#endif\n\t_HT _OUT(H &&h, T... t){out(h);out(t...);}\n\ttemplate <typename... T> _OUTL(T... t){out(t...);outl();}\n\tstruct range{\n\t\tint e,b=0,s=1;range(int _b,int _e,int _s):e(_e),b(_b),s(_s){} range(int _b,int _e): e(_e), b(_b){} range(int _e):e(_e){}\n\t\tstruct it{int v,s; it(int _v,int _s):v(_v),s(_s){} operator int()const{return v;} operator int&(){return v;}int operator*()const{return v;}\n\t\t\tit& operator++(){v+=s;return *this;} }; it begin(){return {b,s};} it end(){return {e,s};}};\n#define times(i,n) for(int i=n;i;i--)\n\ntemplate <typename T>\nusing V = vector<T>;\n\nint main() {\n\tfor (int m, n; m = in, n = in;) {\n\t\tV<int> b(m), r(n);\n\t\tV<V<int>> g(m + n);\n\t\tfor (int &i: b)\n\t\t\ti = in;\n\t\tfor (int &i: r)\n\t\t\ti = in;\n\t\tfor (int i: range(m))\n\t\t\tfor (int j: range(n))\n\t\t\t\tif (__gcd(b[i], r[j]) > 1) {\n\t\t\t\t\tg[i].push_back(j + m);\n\t\t\t\t\tg[j + m].push_back(i);\n\t\t\t\t}\n\n\t\tV<int> match(g.size(), -1);\n\t\tint res = {};\n\t\tfor (int i: range(g.size()))\n\t\t\tif (match[i] < 0) {\n\t\t\t\tV<bool> used(g.size());\n\t\t\t\tfunction<bool(int)> dfs = [&] (int v) {\n\t\t\t\t\tused[v] = true;\n\t\t\t\t\tfor (int u: g[v]) {\n\t\t\t\t\t\tint w = match[u];\n\t\t\t\t\t\tif (w < 0 || (!used[w] && dfs(w))) {\n\t\t\t\t\t\t\tmatch[v] = u;\n\t\t\t\t\t\t\tmatch[u] = v;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t\tif (dfs(i))\n\t\t\t\t\tres++;\n\t\t\t}\n\t\toutl(res);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint V1, V2;\nint size[1002];\nint to[1002][1002];\nint dist[1002];\nint match[1002];\nconst int NIL = 1001;\nbool BFS(){\n  queue<int> que;\n  REP(v, V1){\n    if(match[v] == NIL){\n      dist[v] = 0;\n      que.push(v);\n    }else{\n      dist[v] = INF;\n    }\n  }\n  dist[NIL] = INF;\n  while(!que.empty()){\n    int v = que.front(); que.pop();\n    if(dist[v] < dist[NIL]){\n      for(int i = 0; i < size[v]; i++){\n        int u = to[v][i];\n        if(dist[match[u]] == INF){\n          dist[match[u]] = dist[v] + 1;\n          que.push(match[u]);\n        }\n      }\n    }\n  }\n  return dist[NIL] != INF;\n}\n\nbool DFS(int v){\n  if(v != NIL){\n    for(int i = 0; i < size[v]; i++){\n      int u = to[v][i];\n      if(dist[match[u]] == dist[v] + 1 && DFS(match[u])){\n        match[u] = v;\n        match[v] = u;\n        return true;\n      }\n    }\n    dist[v] = INF;\n    return false;\n  }\n  return true;\n}\n\nint Hopcroft_Karp(){\n  REP(v, V1 + V2) match[v] = NIL;\n  int matching = 0;\n  while(BFS()){\n    REP(v, V1){\n      if(match[v] == NIL && DFS(v)){\n        matching ++;\n      }\n    }\n  }\n  return matching;\n}\nint memo[1000][1000];\nint gcd(int x, int y){\n  if(x < 1000){\n    if(memo[x][y] != -1) return memo[x][y];\n    int r = x % y;\n    if(r == 0) return memo[x][y] = y;\n    return memo[x][y] = gcd(y, r);\n  }else{\n    int r = x % y;\n    if(r == 0) return y;\n    return gcd(y, r);\n  }\n}\nint main(){\n  memset(memo, -1, sizeof(memo));\n  while(scanf(\"%d %d\", &V1, &V2) && (V1 != 0 || V2 != 0)){\n    REP(i, V1) size[i] = 0;\n    static int blue[500];\n    static int red[500];\n    REP(i, V1) scanf(\"%d\", blue + i);\n    REP(i, V2) scanf(\"%d\", red + i);\n    REP(u, V1) REP(v, V2){\n      if(gcd(blue[u], red[v]) != 1) {\n        to[u][size[u]++] = V1 + v;\n        //G[u].push_back(V1 + v);\n        //G[V1 + v].push_back(u);\n      }\n    }\n    printf(\"%d\\n\", Hopcroft_Karp());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\nint n,k;int inline gcd(int a, int b) {while (b) {int c=a%b;a=b,b=c;} return a;}\nvector<vector<int> >g;\nvector<int>mt;\nvector<char>used;\nbool try_kuhn(int v) {\n\tif (used[v]) return false;\n\tused[v]=1;\n\tfor (int i=g[v].size()-1;i>=0;i--) {\n\t\tint to=g[v][i];\n\t\tif (mt[to]==-1 || try_kuhn(mt[to])) {\n\t\t\tmt[to]=v;return true;\n\t\t}\n\t}\n\treturn false;\n}\nint A[505],B[505];\nint main() {\n\tint i,j;\n\twhile (scanf(\"%d %d\",&n,&k)!=EOF && (n || k)) {\n\t\tg.clear();mt.assign(k,-1);g.resize(n+k);\n\t\tfor (i=0;i<n;scanf(\"%d\",&A[i++]));\n\t\tfor (i=0;i<k;scanf(\"%d\",&B[i++]));\n\t\tfor (i=0;i<n;i++) for (j=0;j<k;j++) if (gcd(A[i],B[j])>1) g[i].push_back(j);\n\t\tfor (i=0;i<n;i++) {\n\t\t\tused.assign(n,false);\n\t\t\ttry_kuhn(i);\n\t\t}\n\t\tfor (i=0,j=0;i<k;i++) if (mt[i]!=-1) j++;\n\t\tprintf(\"%d\\n\",j);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,b,e) for(int i=(b);i<(e);++i)\n#define rep(i,e) for(int i=0;i<(e);++i)\n\nstruct edge{int to, cap, rev;};\nint INF = (1<<30);\n\nint m, n;\nint b[500], r[500];\n\nvector<edge> G[1010];\nint level[1010];\nint iter[1010];\n\nvoid add_edge(int from, int to, int cap){\n  G[from].push_back((edge){to, cap, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nvoid bfs(int s){\n  memset(level, -1, sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front(); que.pop();\n    for(int i=0; i<(int)G[v].size(); i++){\n      edge &e = G[v][i];\n      if(e.cap>0 && level[e.to]<0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v, int t, int f){\n  if(v==t) return f;\n  for(int &i = iter[v]; i<(int)G[v].size(); i++){\n    edge &e = G[v][i];\n    if(e.cap>0 && level[v]<level[e.to]){\n      int d=dfs(e.to, t, min(f, e.cap));\n      if(d>0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t){\n  int flow = 0;\n  for(;;){\n    bfs(s);\n    if(level[t]<0) return flow;\n    memset(iter, 0, sizeof(iter));\n    int f;\n    while((f=dfs(s, t, INF)) > 0){\n      flow += f;\n    }\n  }\n}\n\nint gcd(int a, int b){\n  if(b==0) return a;\n  return gcd(b, a%b);\n}\n\nint main(){\n  while(true){\n    cin>>m>>n;\n    if(m==0) break;\n\n    int s=m+n, t=s+1;\n    memset(G, 0, sizeof(G));\n    memset(level, 0, sizeof(level));\n    memset(iter, 0, sizeof(iter));\n\n    rep(i,m) cin>>b[i];\n    rep(j,n) cin>>r[j];\n\n    rep(i,m) add_edge(s, i, 1);\n    rep(j,n) add_edge(m+j, t, 1);\n\n    rep(i,m)rep(j,n){\n      if(gcd(b[i], r[j])>1){\n        add_edge(i, m+j, 1);\n      }\n    }\n\n    int ans = max_flow(s, t);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nvector<int> blue,red,redpair,v;\n//blue[i]??§i?????????????????????????????°???,red[i]??§i?????????????????????????????°???,redpair[i]??§i??????????????????????????¨?????¢????????????????????????????????????????????????,v[i]??§i????????????????????????????????????????????????????????¨???(1:?????????0:??????)\nint m=0,n=0;\n\nint gcd(int x,int y){\n\tif(x%y==0){return y;}\n\treturn gcd(y,x%y);\n}\n\nbool match(int x){\n\tif(x==-1)return 1;\n\tfor(int i=0;i<n;i++){\n\t\tif(gcd(blue[x],red[i])!=1 && v[i]==0){\n\t\t\tv[i]=1;\n\t\t\tif(match(redpair[i])){\n\t\t\t\tredpair[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(cin>>m>>n){\n\t\tif(m==0 && n==0){break;}\n\t\tblue.clear();\n\t\tred.clear();\n\t\tredpair.clear();\n\t\tv.clear();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint tmp=0;\n\t\t\tcin>>tmp;\n\t\t\tblue.push_back(tmp);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmp=0;\n\t\t\tcin>>tmp;\n\t\t\tred.push_back(tmp);\n\t\t\tredpair.push_back(-1);//-1??§?????¢??????????????¶????????¨???\n\t\t\tv.push_back(0);\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tv[j]=0;\n\t\t\t}\n\t\t\tif(match(i)){ans++;}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\n#define INF (1<<29)\n#define max_n 1010\n\nusing namespace std;\n\nstruct edge{int to,cap,rev;};\n\nstruct node_t{\n\n  node_t *pp,*lp,*rp;\n  int id,val,mini,minId,lazy;\n  edge *e;\n\n  node_t(int id,int v):id(id),val(v){\n    pp=lp=rp=NULL; lazy=0; update();\n  }\n\n  void update(){\n    mini=val,minId=id;\n    if(lp && mini>lp->mini)mini=lp->mini,minId=lp->minId;\n    if(rp && mini>=rp->mini)mini=rp->mini,minId=rp->minId;\n  }\n\n  void apply(int v){ lazy+=v, val+=v, mini+=v; }\n\n  void push(){\n    if(lp)lp->apply(lazy);\n    if(rp)rp->apply(lazy);\n    lazy=0;\n  }\n\n  bool is_root(){\n    return !pp || (pp->lp != this && pp->rp != this);\n  }\n\n  void rotr(){\n    node_t *q=pp,*r=q->pp;\n    q->push(),push();\n    if((q->lp=rp))rp->pp=q;\n    rp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n    q->update();\n  }\n\n  void rotl(){\n    node_t *q=pp,*r=q->pp;\n    q->push(),push();\n    if((q->rp=lp))lp->pp=q;\n    lp=q;q->pp=this;\n    if((pp=r)){\n      if(r->lp==q)r->lp=this;\n      if(r->rp==q)r->rp=this;\n    }\n    q->update();\n  }\n\n  void splay(){\n    while(!is_root()){\n      node_t *q=pp;\n      if(q->is_root()){\n\tif(q->lp==this)rotr();\n\telse rotl();\n      } else {\n\tnode_t *r=q->pp;\n\tif(r->lp==q){\n\t  if(q->lp==this){q->rotr();rotr();}\n\t  else {rotl();rotr();}\n\t} else {\n\t  if(q->rp==this){q->rotl();rotl();}\n\t  else {rotr();rotl();}\n\t}\n      }\n    }\n    push();\n    update();\n  }\n};\n\nnode_t *expose(node_t *x){\n  node_t *rp=NULL;\n  for(node_t *p=x;p;p=p->pp){\n    p->splay();\n    p->rp=rp;\n    p->update();\n    rp=p;\n  }\n  x->splay();\n  return x;\n}\n\nnode_t *find_root(node_t *x){\n  expose(x);\n  while(x->lp)x=x->lp;\n  return x;\n}\n\nvoid cut(node_t *c){\n  expose(c);\n  node_t *p=c->lp;\n  c->lp=NULL;\n  p->pp=NULL;\n  c->val=INF;\n}\n\nvoid link(node_t *c,node_t *p){\n  expose(c);\n  expose(p);\n  c->pp=p;\n  p->rp=c;\n}\n\nvoid link(node_t *c,node_t *p,int val,edge *e){\n  link(c,p);\n  c->val=val;\n  c->update();\n  c->e=e;\n}\n\nint minId(node_t *x){expose(x); return x->minId;}\nvoid add(node_t *x,int val){ expose(x); x->apply(val); }\n\nvector<edge> g[max_n];\n\nvoid add_edge(int from,int to,int cap){\n  g[from].push_back((edge){to,cap,g[to].size()});\n  g[to].push_back((edge){from,0,g[from].size()-1});\n}\n\nint dist[max_n];\n\nbool bfs(int s,int t){\n  fill(dist,dist+max_n,-1);\n  dist[s]=0;\n  queue<int>que;\n  que.push(s);\n  while(!que.empty()){\n    int u=que.front();que.pop();\n    if(u==t)return true;\n    for(int j=0;j<g[u].size();j++){\n      edge e=g[u][j];\n      if(dist[e.to]<0 && e.cap>0){\n\tdist[e.to]=dist[u]+1;\n\tque.push(e.to);\n      }\n    }\n  }\n  return false;\n}\n\nint n,ptr[max_n];\nnode_t *nodes[max_n];\nvector<int>lists[max_n];\n\nbool pour(int id,int i){\n  int u=lists[id][i];\n  if(find_root(nodes[u])==nodes[u])return true;\n  edge *e=nodes[u]->e;\n  expose(nodes[u]);\n  int df=e->cap-nodes[u]->val;\n  e->cap-=df;\n  g[e->to][e->rev].cap+=df;\n  return false;\n}\n\nint max_flow(int S,int T){\n  int flow=0;\n  while(bfs(S,T)){\n\n    fill(ptr,ptr+max_n,0);\n    for(int i=0;i<n;i++)nodes[i]=new node_t(i,INF);\n\n    node_t *s=nodes[S],*t=nodes[T];\n    for(int i=0;i<n;i++)lists[i].clear();\n\n    while(true){\n      node_t *v=find_root(s);\n\n      if(v==t){\n\texpose(v=nodes[minId(s)]);\n\tflow+=v->mini;\n\tadd(s,-v->mini);\n\twhile(true){\n\t  expose(v=nodes[minId(s)]);\n\t  if(v->val>0)break;\n\t  g[v->e->to][v->e->rev].cap+=v->e->cap;\n\t  v->e->cap=0;\n\t  cut(v);\n\t}\n\tcontinue;\n      }\n\n      if(ptr[v->id] < g[v->id].size()){\n\tedge &e=g[v->id][ptr[v->id]++];\n\tif(dist[e.to]==dist[v->id]+1 && e.cap>0){\n\t  link(v,nodes[e.to],e.cap,&e);\n\t  lists[e.to].push_back(v->id);\n\t}\n      } else {\n\tif(v==s){\n\t  for(int i=0;i<n;i++){\n\t    for(int j=0;j<lists[i].size();j++)pour(i,j);\n\t    lists[i].clear();\n\t  }\n\t  break;\n\t}\n\tfor(int i=0;i<lists[v->id].size();i++){\n\t  if(!pour(v->id,i))cut(nodes[lists[v->id][i]]);\n\t}\n\tlists[v->id].clear();\n      }\n    }\n  }\n  return flow;\n}\n \nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\n \nint main(void){\n   \n  int M,N,s,t;\n   \n  while(cin >> M >> N,M|N){\n    s=M+N,t=s+1,n=M+N+2;\n    for(int i=0;i<n;i++)g[i].clear();\n    vector<int>b(M),r(N);\n    for(int i=0;i<M;i++)cin >> b[i];\n    for(int i=0;i<N;i++)cin >> r[i];\n     \n    for(int i=0;i<M;i++){\n      for(int j=0;j<N;j++){\n\tif(gcd(b[i],r[j])!=1)add_edge(i,j+M,1);\n      }\n    }\n\n    for(int i=0;i<M;i++)add_edge(s,i,1);\n    for(int i=0;i<N;i++)add_edge(i+M,t,1);\n\n    cout << max_flow(s,t) << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nconst int VMAX = 5000;\nconst int INF = 1e7;\n\nint V;\nvector<int> G[VMAX];\nint match[VMAX];\nbool used[VMAX];\n\nvoid add_edge(int u, int v) {\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v) {\n  used[v] = true;\n  for (auto u : G[v]) {\n    int w = match[u];\n    if (w < 0 || !used[w] && dfs(w)) {\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching() {\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  REP (v, V) {\n    if (match[v] < 0) {\n      memset(used, 0, sizeof(used));\n      if (dfs(v)) {\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\nint gcd(int a, int b) {\n  return (b == 0 ? a : gcd(b, a % b));\n}\n\nbool pickable(int b, int r) {\n  return gcd(b, r) > 1;\n}\n\nconst int MMAX = 600, NMAX = 600;\n\nint m, n;\nint blues[MMAX], reds[NMAX];\n\nint blue_idx(int i) {\n  return i;\n}\n\nint red_idx(int i) {\n  return m + i + 10;\n}\n\nvoid init(int v) {\n  REP(i, v) {\n    G[i].clear();\n  }\n\n  memset(match, -1, sizeof(match));\n  memset(used, 0, sizeof(used));\n}\n\nint main() {\n  while (cin >> m >> n and m) {\n    init(m + n + 100);\n    REP(i, m) {\n      cin >> blues[i];\n    }\n\n    REP(i, n) {\n      cin >> reds[i];\n    }\n\n    REP(b, m) REP(r, n) {\n      if (pickable(blues[b], reds[r])) {\n        add_edge(blue_idx(b), red_idx(r));\n      }\n    }\n\n    V = m + n + 100;\n\n    cout << bipartite_matching() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct edge{\n\tint to, cap, rev;\n\tedge(int a, int b, int c){\n\t\tto = a, cap = b, rev = c;\n\t}\n};\n\nint V, S, T;\nint m, n;\nint b[505], r[505];\nvector<edge> G[1005];\nbool used[1005];\n\nvoid addedge(int s, int t)\n{\n\tG[s].push_back( edge(t, 1, G[t].size()) );\n\tG[t].push_back( edge(s, 0, G[s].size() - 1) );\n}\n\nint gcd(int a, int b)\n{\n\tif(b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\nint dfs(int v, int t, int c)\n{\n\tif(v == t) return c;\n\tused[v] = true;\n\t\n\tint ret;\n\tfor(int i = 0; i < (int)G[v].size(); i++){\n\t\tif(used[G[v][i].to] || G[v][i].cap == 0) continue;\n\t\tret = dfs(G[v][i].to, t, min(c, G[v][i].cap));\n\t\tif(ret > 0){\n\t\t\tG[v][i].cap -= ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap += ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> m >> n;\n\t\tif(m == 0 && n == 0) break;\n\t\tV = m + n;\n\t\tS = 0, T = V+1;\n\t\t\n\t\tfor(int i = 1; i <= m; i++) cin >> b[i];\n\t\tfor(int i = 1; i <= n; i++) cin >> r[i];\n\t\t\n\t\tfor(int i = 0; i <= T; i++) G[i].clear();\n\t\tfor(int i = 1; i <= m; i++) addedge(S, i);\n\t\tfor(int i = 1; i <= n; i++) addedge(m+i, T);\n\t\t\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tif(gcd(b[i], r[j]) == 1) continue;\n\t\t\t\taddedge(i, m+j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret, ans = 0;\n\t\twhile(1){\n\t\t\tfor(int i = 0; i <= T; i++) used[i] = false;\n\t\t\tret = dfs(S, T, inf);\n\t\t\tif(ret == 0) break;\n\t\t\tans += ret;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#define SIZE 1000\n\nusing namespace std;\n\nint m, n, b[501], r[501];\nint match[SIZE];\nbool used[SIZE];\nvector<int> G[SIZE];\n\nbool dfs(int v){\n\tused[v]=1;\n\tfor(int i=0; i<G[v].size(); i++){\n\t\tint u=G[v][i], w=match[u];\n\t\tif(w<0||!used[w]&&dfs(w)){\n\t\t\tmatch[v]=u, match[u]=v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid solve(){\n\tint res=0;\n\tmemset(match, -1, sizeof(match));\n\tfor(int v=0; v<m+n; v++){\n\t\tif(match[v]<0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif(dfs(v)) res++;\n\t\t}\n\t}\n\tcout<<res<<endl;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n && !m) break;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> b[i];\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcin >> r[i];\n\t\t}\n\t\tfor(int i=0; i<SIZE; i++) G[i].clear;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tint a=b[i], c=r[j];\n\t\t\t\twhile(c){\n\t\t\t\t\ta%=c;\n\t\t\t\t\tswap(a, c);\n\t\t\t\t}\n\t\t\t\tif(a!=1)G[i].push_back(j+n), G[n+j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint gcd(int a,int b){\n    if(a<b)return gcd(b,a);\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\n\nbool check(int a,int b){\n    return gcd(a,b)!=1;\n}\n\nint main(){\n    \n    while(true){\n        vector<int> a;\n        vector<int> b;\n\n        int n,m;\n        cin>>n>>m;\n        if(n==0&&m==0)return 0;\n        for(int i=0;i<n;i++){int t;cin>>t;a.push_back(t);}\n        for(int i=0;i<m;i++){int t;cin>>t;b.push_back(t);}\n\n        int ans=0;\n\n        for(int i=1;;i++){\n            bool flag = true;\n\n            int ea,eb;\n            int n=100000;\n            for(int k=0;k<a.size();k++){\n                vector<int> v;\n                for(int j=0;j<b.size();j++){\n                    if(a[k]!=0&&b[j]!=0&&check(a[k],b[j])){\n                        v.push_back(j);\n                    }\n                }\n                if(v.size()!=0 && v.size()<n){\n                    flag=false;\n                    n=v.size();\n                    ea = k;\n                    eb = v[0];\n                }\n            }\n            for(int j=0;j<b.size();j++){\n                vector<int> v;\n                for(int k=0;k<a.size();k++){\n                    if(a[k]!=0&&b[j]!=0&&check(a[k],b[j])){\n                        v.push_back(k);\n                    }\n                }\n                if(v.size()!=0 && v.size()<n){\n                   flag=false;\n                   n = v.size();\n                   ea=v[0];\n                   eb=j;\n                }\n            }\n            if(flag)break; else{\n                a[ea]=0;\n                b[eb]=0;\n                ans++;\n            }\n         }\n          cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 4444\nvector<int> v[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int a,int b){\n\tv[a].PB(b);\n\tv[b].PB(a);\n}\n\nbool matchdfs(int a){\n\tused[a] = true;\n\tfor(int i = 0;i < v[a].size();i++)\t{\n\t\tint u = v[a][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w)){\n\t\t\tmatch[u] = a;\n\t\t\tmatch[a] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//二部マッチング\nint two_matching_max(int l){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<int> prime;\n#define HOGE 222222\nbool isp[HOGE];\nvoid f(){\n\tREP(i,HOGE)isp[i] = true;\n\tisp[0] = isp[1] = false;\n\tfor(int i = 2;i < HOGE;i++){\n\t\tif(isp[i]){\n\t\t\tprime.PB(i);\n\t\t\tfor(int j = i;j < HOGE;j+=i)isp[j] = false;\n\t\t}\n\t}\n}\n\t\n#define HALF 1000\nint main(){\n\tf();\n\tint n,m;\n\twhile(cin >> m >> n,n|m){\n\t\tREP(i,MAX_V)v[i].clear();\n\t\tvector<ll> a(m);REP(i,m)cin >> a[i];\n\t\tvector<ll> b(n);REP(i,n)cin >> b[i];\n\t\tREP(i,m){\n\t\t\tvector<ll> tmp;\n\t\t\tREP(j,prime.size()){\n\t\t\t\tif(a[i] % prime[j] == 0)tmp.PB(prime[j]);\n\t\t\t}\n\t\t\tREP(j,n){\n\t\t\t\tREP(k,tmp.size()){\n\t\t\t\t\tif(b[j] % tmp[k] == 0){\n\t\t\t\t\t\tadd_edge(i,j + 1000);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << two_matching_max(MAX_V) << endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond(b);i<i##_cond;++i)\n#define rall(a) (a).rbegin(),(a).rend()\n#define sz(x) ((int)(x).size())\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n#define inf 1<<30\n\nvector<int> prime(int n){\n  // n以下の素数を要素に持つviを返す\n  // 時間 O(n ln ln n)\n  // 答えのサイズ n / ln n\n\n  vector<bool> isprime(n+1,true);\n  vector<int> ans;\n  isprime[0] = isprime[1] = false;\n  FOR(i,2,n+1)\n    if(isprime[i]){\n      ans.push_back(i);\n      for(int j = 2 * i; j <= n; j += i) isprime[j] = false;\n    }\n  return ans;\n}\n\n// dinic\nstruct max_flow {\n    struct edge { int to, cap, rev; };\n    int V;\n    vector<vector<edge>> G;\n    vector<int> itr, level;\n\n    max_flow(int _V) : V(_V) { G.assign(_V,vector<edge>()); }\n\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back((edge) {to, cap, (int) G[to].size()});\n        G[to].push_back((edge) {from, 0, (int) G[from].size()-1});\n    }\n\n    void bfs(int s) {\n        level.assign(V,-1);\n        queue<int> q;\n        level[s] = 0; q.push(s);\n        while (!q.empty()) {\n            int v = q.front(); q.pop();\n            for(auto &e: G[v]){\n                if (e.cap > 0 and level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int& i = itr[v]; i < (int) G[v].size(); ++i) {\n            edge& e = G[v][i];\n            if (e.cap > 0 and level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int run(int s, int t) {\n        int ret = 0, f;\n        while (bfs(s), level[t] >= 0) {\n            itr.assign(V,0);\n            while ((f = dfs(s, t, inf)) > 0) ret += f;\n        }\n        return ret;\n    }\n};\n\nint main(){  \n  vi p = prime(10000000);\n  \n  while(1){\n    // input\n    int m, n; cin >> m >> n; if(m == 0) break;\n    vi b(m); rep(i,m) cin >> b[i];\n    vi r(n); rep(i,n) cin >> r[i]; sort(rall(r));\n\n    // フロー初期化\n    struct max_flow f(n+m+2); // 左右+1+1\n    rep(i,m) f.add_edge(0,i+1,1); // sから左側\n    rep(i,n) f.add_edge(m+i+1,m+n+1,1); // 右側からt\n\n    // 同じ素因数を持つとき辺を追加\n    rep(i,m) for(int j = 0; j < sz(p) and p[j] <= b[i]; ++j)\n      if(b[i] % p[j] == 0)\n\tfor(int k = 0; k < n and p[j] <= r[k]; ++k)\n\t  if(r[k] % p[j] == 0)\n\t    f.add_edge(i+1,m+k+1,1);\n\n    // フローを流す\n    int ans = f.run(0,n+m+1);\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\nint INF = 10e8;\nint m, n;\nint b[501];\nint r[501];\n\nvector<int> bd[501];\nvector<int> rd[501];\n\nstruct edge{\n    int to, cap, rev;\n};\nbool used[501];\nvector<edge> g[501];\n\nint s, t;\n\nvoid add_edge(int from, int to, int cap){\n    g[from].push_back((edge){to, cap, g[to].size()});\n    g[to].push_back((edge){from, 0, g[from].size()-1});\n}\n\nint dfs(int v, int t, int f){\n    if(v==t) return f;\n    used[v] = true;\n    REP(i, g[v].size()){\n        edge &e = g[v][i];\n        if(!used[e.to] && e.cap>0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d>0){\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f==0) return flow;\n        flow += f;\n    }\n}\n\nbool euclid(int x, int y){\n    if(x<y){\n        int tmp = x;\n        x = y;\n        y = tmp;\n    }\n\n    int r = x % y;\n    while(r!=0){\n        x = y;\n        y = r;\n        r = x % y;\n    }\n\n    if(y>1){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main(){\n    while(1){\n        cin >> m >> n;\n\n        if(m==0) break;\n\n        REP(i, m) cin >> b[i];\n        REP(i, n) cin >> r[i];\n\n        int s = m+n, t = s+1;\n\n        REP(i, 501) g[i].clear();\n\n        REP(i, m){\n            REP(j, n){\n                if(euclid(b[i], r[j])){\n                    add_edge(i, m+j, 1);\n                }\n            }\n        }\n\n        REP(i, m) add_edge(s, i, 1);\n        REP(i, n) add_edge(m+i, t, 1);\n\n        int output = max_flow(s, t);\n        cout << output << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define CEIL(a,b) ((a) / (b) + ((a) % (b) == 0 ? 0 : 1))\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconstexpr int MOD = 1'000'000'007;\nconstexpr int INF = 1'000'000'001;\nconstexpr ll LLINF = 4'000'000'000'000'000'001;\n// constexpr int INF = 2147483647; // 2 * 1e9\n// constexpr ll LLINF = 9223372036854775807; // 9 * 1e18\n\nconst int dx[] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconst int dy[] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\n\ntemplate<typename T>\nclass Dinic{\n    struct Edge{\n        int to, rev;\n        T cap;\n        Edge(int to, int rev, T cap) : to(to), rev(rev), cap(cap){}\n    };\n\n    vector<vector<Edge>> g; // グラフ\n    vector<int> level, iter; // スタートからの距離、どこまで調べ終わったか\n    int size;\npublic:\n    Dinic(int size) : g(size, vector<Edge>()), size(size){}\n\n    void init(int size){\n        g = vector<vector<Edge>>(size, vector<Edge>());\n        this->size = size;\n    }\n\n    void add_edge(int from, int to, T cap){\n        g[from].push_back(Edge(to, g[to].size(), cap));\n        g[to].push_back(Edge(from, g[from].size() - 1, 0));\n    }\n\n    void bfs(int s){\n        level = vector<int>(size, -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(0);\n        while (!que.empty()){\n            int v = que.front(); que.pop();\n            for(auto && e : g[v]){\n                if(e.cap > 0 && level[e.to] < 0){\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    int dfs(int v, int t, int f){\n        if(v == t) return f;\n        for(int i = iter[v]; i < g[v].size(); ++i){\n            Edge &e = g[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]){\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    g[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int max_flow(int s, int t){\n        int flow = 0;\n        while(true){\n            bfs(s);\n            if(level[t] < 0) return flow;\n            iter = vector<int>(size);\n            int f;\n            while((f = dfs(s, t, INF)) > 0) flow += f;\n        }\n    }\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n    while(true){\n    int m, n;\n        cin >> m >> n;\n        if(m + n == 0) break;\n        vector<int> b(m), r(n);\n        for(int i = 0; i < m; ++i){\n            cin >> b[i];\n        }\n        for(int i = 0; i < n; ++i){\n            cin >> r[i];\n        }\n        Dinic<int> dinic(m + n + 2);\n        for(int i = 0; i < m; ++i){\n            dinic.add_edge(0, i+1, 1);\n            for(int j = 0; j < n; ++j){\n                if(__gcd(b[i], r[j]) > 1) dinic.add_edge(i+1, j + m + 1, 1);\n            }\n        }\n        for(int i = 0; i < n; ++i){\n            dinic.add_edge(i + m + 1, m + n + 1, 1);\n        }\n        cout << dinic.max_flow(0, m + n + 1) << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct BipartiteMatching\n{\n  vector< vector<int> > G;\n  vector<int> matched;\n  vector<bool> used;\n  BipartiteMatching(int V):G(V), matched(V, -1), used(V, false){}\n  void add_edge(int u, int v)\n  {\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n  bool dfs(int u)\n  {\n    used[u] = true;\n    for(auto& v : G[u]) {\n      int w = matched[v];\n      if(w < 0 || !used[w] && dfs(w)) {\n\tmatched[u] = v;\n\tmatched[v] = u;\n\treturn true;\n      }\n    }\n    return false;\n  }\n  int match()\n  {\n    int res = 0;\n    for(int u = 0; u < G.size(); u++) {\n      if(matched[u] < 0) {\n\tused.clear(); used.resize(G.size(), false);\n\tif(dfs(u)) res++;\n      }\n    }\n    return res;\n  }\n};\n\nint main()\n{\n  int m, n;\n  while(cin >> m >> n, m || n) {\n    vector<int> b(m), r(n);\n    for(int i = 0; i < m; i++) cin >> b[i];\n    for(int i = 0; i < n; i++) cin >> r[i];\n    BipartiteMatching bimatch(m + n);\n    for(int i = 0; i < m; i++) {\n      for(int j = 0; j < n; j++) {\n\tif(__gcd(b[i], r[j]) > 1) bimatch.add_edge(i, m + j);\n      }\n    }\n    cout << bimatch.match() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nstruct E {\n  int to, cost, cap, rev;\n  E(int to, int cost, int cap, int rev)\n    : to(to), cost(cost), cap(cap), rev(rev) {}\n  E() {}\n};\n\ntypedef vector<vector<E> > G;\n\nvoid addEdgeF(int from, int to, int cost, int cap, G &g) {\n  g[from].push_back(E(to,cost,cap,g[to].size()));\n  g[to].push_back(E(from,cost,0,(int)g[from].size()-1));\n}\n\nbool used[2000];\nG g;\n\nint dfsF(int v, int t, int f) {\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < g[v].size(); ++i) {\n    E &e = g[v][i];\n    if(!used[e.to] && e.cap > 0) {\n      int d = dfsF(e.to, t, min(f, e.cap));\n      if(d > 0) {\n        e.cap -= d;\n        g[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int s, int t) {\n  int flow = 0;\n  while(1) {\n    fill(used, used+2000, 0);\n    int f = dfsF(s, t, INF);\n    if(f == 0) break;\n    flow += f;\n  }\n  return flow;\n}\n\nint gcd(int a, int b) {\n  return b == 0 ? a : gcd(b, a%b);\n}\n\nint main() {\n  int m, n, tmp;\n  vector<int> b, r;\n  while(cin >> m >> n && (m|n)) {\n    b.resize(m);\n    r.resize(n);\n    for(int i = 0; i < m; ++i) {\n      cin >> b[i];\n    }\n    for(int i = 0; i < n; ++i) {\n      cin >> r[i];\n    }\n\n    g = G(m+n+2);\n    for(int i = 0; i < m; ++i) {\n      addEdgeF(m+n, i, 0, 1, g);\n    }\n    for(int i = 0; i < m; ++i) {\n      for(int j = 0; j < n; ++j) {\n        if(gcd(b[i], r[j]) != 1) {\n          addEdgeF(i, m+j, 0, 1, g);\n        }\n      }\n    }\n    for(int i = 0; i < n; ++i) {\n      addEdgeF(m+i, m+n+1, 0, 1, g);\n    }\n    cout << maxFlow(m+n, m+n+1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <iterator>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int src,int dst,int weight):src(src),dst(dst),weight(weight){}\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight<rhs.weight;\n}\n\nbool operator>(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight>rhs.weight;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid BFS(const Graph& g,int begin,int end,const vvi& capacity,const vvi& flow,vi& label)\n{\n\tqueue<pii> q;\n\tq.push(mp(begin,0));\n\twhile(!q.empty()){\n\t\tpii v=q.front(); q.pop();\n\t\tif(label[v.first]<=v.second)\n\t\t\tcontinue;\n\t\tlabel[v.first]=v.second;\n\t\tforeach(e,g[v.first])\n\t\t\tif(capacity[e->src][e->dst]-flow[e->src][e->dst]>0)\n\t\t\t\tq.push(mp(e->dst,v.second+1));\n\t}\n}\n\nint DFS(const Graph& g,int v,int end,const vvi& capacity,vvi& flow,vi& label,vi& finished,int f)\n{\n\tif(v==end)\n\t\treturn f;\n\tif(finished[v])\n\t\treturn 0;\n\tfinished[v]=true;\n\t\n\tforeach(e,g[v]){\n\t\tif(label[e->src]>=label[e->dst])\n\t\t\tcontinue;\n\t\tint r=capacity[e->src][e->dst]-flow[e->src][e->dst];\n\t\tif(r<=0)\n\t\t\tcontinue;\n\t\tint inc=DFS(g,e->dst,end,capacity,flow,label,finished,min(f,r));\n\t\tif(inc>0){\n\t\t\tflow[e->src][e->dst]+=inc;\n\t\t\tflow[e->dst][e->src]-=inc;\n\t\t\tfinished[v]=false;\n\t\t\treturn inc;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\nint Dinic(const Graph& _g,int begin,int end)\n{\n\tint size=_g.size();\n\t\n\t// tûüÌÓðÁ¦é(eÊÍ0É·é)\n\tGraph g=_g;\n\trep(i,size)\n\t\tforeach(e,_g[i])\n\t\t\tg[e->dst].push_back(Edge(e->dst,e->src,0));\n\t\n\tvvi capacity(size,vi(size)),flow(size,vi(size));\n\trep(i,size)\n\t\tforeach(e,g[i])\n\t\t\tcapacity[e->src][e->dst]+=e->weight;\n\t\n\tfor(;;){\n\t\tvi label(size,INFTY);\n\t\tBFS(g,begin,end,capacity,flow,label);\n\t\tif(label[end]==INFTY)\n\t\t\tbreak;\n\t\tvi finished(size);\n\t\twhile(DFS(g,begin,end,capacity,flow,label,finished,INFTY))\n\t\t\t;\n\t}\n\t\n\treturn accumulate(allof(flow[begin]),0);\n}\n\n// [0,m): left, [m,gsize): right\nint BiparateMatching(const Graph& _g,int m)\n{\n\tint n=_g.size()-m;\n\tGraph g=_g;\n\tg.resize(g.size()+2);\n\trep(i,m)\n\t\tg[m+n].push_back(Edge(m+n,i,1));\n\trep(i,n)\n\t\tg[m+i].push_back(Edge(m+i,m+n+1,1));\n\treturn Dinic(g,m+n,m+n+1);\n}\n\nint main()\n{\n\tfor(int m,n;cin>>m>>n,m|n;){\n\t\tvi bs(m),rs(n);\n\t\trep(i,m) cin>>bs[i];\n\t\trep(i,n) cin>>rs[i];\n\t\tGraph g(m+n);\n\t\trep(i,m) rep(j,n)\n\t\t\tif(__gcd(bs[i],rs[j])>1)\n\t\t\t\tg[i].push_back(Edge(i,m+j,1));\n\t\tcout<<BiparateMatching(g,m)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include \"push_relabel.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n  each(x,vec) is >> x;\n  return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n  rep(i,vec.size()) {\n    if (i) os << \" \";\n    os << vec[i];\n  }\n  return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n  rep(i,vec.size()) {\n    if (i) os << endl;\n    os << vec[i];\n  }\n  return os;\n}\n\nclass MaxFlow {\npublic:\n  struct Edge {\n    ll to, cap, rev;\n  };\n  vector<vector<Edge>> G;\n  vector<ll> iter;\nprivate:\n  bool is_debug;\n  ll V;\n  vector<ll> bfs(ll s) {\n    vector<ll> dist(V, linf);\n    dist[s] = 0;\n    queue<ll> Q; Q.push(s);\n    while ( !Q.empty() ) {\n      ll v = Q.front(); Q.pop();\n      each(e, G[v]) {\n        if (e.cap > 0 && dist[e.to] == linf) {\n          dist[e.to] = dist[v]+1;\n          Q.push(e.to);\n        }\n      }\n    }\n    return dist;\n  }\n  ll dfs(ll v, ll t, ll f, const vector<ll>& dist, vector<bool>& used) {\n    if (v == t) return f;\n    if (used[v]) return 0;\n    used[v] = true;\n    for (ll& i = iter[v]; i < G[v].size(); ++i) {\n      Edge& e = G[v][i];\n      if (e.cap > 0 && dist[e.to] == dist[v]+1) {\n        ll d = dfs(e.to, t, min(f, e.cap), dist, used);\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\npublic:\n  const vector<vector<Edge>>& Graph() {\n    return G;\n  }\n  MaxFlow(ll V, bool is_debug=false) : V(V), G(V), is_debug(is_debug) {}\n  void init(ll n) {\n    V = n;\n    G.assign(V, vector<Edge>());\n  }\n  void add(ll from, ll to, ll cap) {\n    if (is_debug) cout << \"ADD: \" << from << \" \" << to << \" \" << cap << endl;\n    assert(V > 0);\n    G[from].pb({to, cap, (ll)G[to].size()});\n    G[to].pb({from, 0, (ll)G[from].size()-1});\n  }\n  // S -> s, T -> t に inf は自力で\n  void add(ll from, ll to, ll min_flow, ll cap, ll S, ll T) {\n    if (is_debug) cout << endl << \"ADD_MIN:\" << from << \" \" << to << \" \" << min_flow << \" \" << cap << endl;\n    add(from, to, cap-min_flow);\n    add(S, to, min_flow);\n    add(from, T, cap);\n    if (is_debug) cout << endl;\n  }\n  ll flow(ll s, ll t, ll f=linf) {\n    ll res = 0;\n    while (f > 0) {\n      vector<ll> dist = bfs(s);\n      if (dist[t] == linf) break;\n      iter.assign(G.size(), 0);\n      while (f > 0) {\n        vector<bool> used(V, false);\n        ll df = dfs(s, t, f, dist, used);\n        if (df == 0) break;\n        f -= df;\n        res += df;\n      }\n    }\n    return res;\n  }\n};\n\nll gcd(ll a, ll b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  ll n, m;\n  while (cin >> n >> m, n || m) {\n    vector<ll> a(n), b(m); cin >> a >> b;\n    ll s = n + m, t = s + 1;\n    MaxFlow mf(t+1);\n    rep(i, n) rep(j, m) {\n      if (gcd(a[i], b[j]) > 1) {\n        mf.add(i, n+j, 1);\n      }\n    }\n    rep(i, n) mf.add(s, i, 1);\n    rep(i, m) mf.add(n+i, t, 1);\n    cout << mf.flow(s, t) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nint main() {\n\tint n, m;\n\t\n\n\twhile (1)\n\t{\n\t\tstd::cin >> n >> m;\n\t\tif (n) {\n\t\t\tbreak;\n\t\t}\n\t\tint a[500], b[500], ct = 0;\n\t\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tstd::cin >> a[i];\n\t\t}\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tstd::cin >> b[i];\n\t\t}\n\t\t\n\t\tif (n > m) {\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tbool ok = 0;\tbool pr[10000000];\n\t\t\t\tfor (int j = 2; j*j < a[i]; ++j) {\n\t\t\t\t\tif (!ok) {\n\t\t\t\t\t\tif (!pr[j]) {\n\t\t\t\t\t\t\tif (a[i] % j == 0) {\n\t\t\t\t\t\t\t\tfor (int k = 0; k < m; ++k) {\n\t\t\t\t\t\t\t\t\tif (b[k] % j == 0) {\n\t\t\t\t\t\t\t\t\t\t++ct;\n\t\t\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (int k = 2; k*j < 10000000; ++k) {\n\t\t\t\t\t\t\t\t\tpr[k] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse \tfor (int k = 2; k*j < 10000000; ++k) {\n\t\t\t\t\t\t\t\tpr[k] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse for (int i = 0; i < m; ++i) {\n\t\t\tbool ok = 0;\tbool pr[10000000];\n\t\t\tfor (int j = 2; j*j < b[i]; ++j) {\n\t\t\t\tif (!ok) {\n\t\t\t\t\tif (!pr[j]) {\n\t\t\t\t\t\tif (b[i] % j == 0) {\n\t\t\t\t\t\t\tfor (int k = 0; k < n; ++k) {\n\t\t\t\t\t\t\t\tif (a[k] % j == 0) {\n\t\t\t\t\t\t\t\t\t++ct;\n\t\t\t\t\t\t\t\t\tok = 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (int k = 2; k*j < 10000000; ++k) {\n\t\t\t\t\t\t\t\tpr[k] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tfor (int k = 2; k*j < 10000000; ++k) {\n\t\t\t\t\t\t\tpr[k] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << ct << std::endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 502;\nconst int MAX_V = 1005;\n\nstruct edge\n{\n\tint to,cap,rev;\n};\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nint n,m;\nint a[MAX_N],b[MAX_N];\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nvoid bfs(int s)\n{\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v = que.front();\n\t\tque.pop();\n\t\trep(i,G[v].size()){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v,int t,int f)\n{\n\tif(v==t){\n\t\treturn f;\n\t}\n\tfor(int &i = iter[v];i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t)\n{\n\tint flow = 0;\n\tfor(;;){\n\t\tbfs(s);\n\t\tif(level[t]<0){\n\t\t\treturn flow;\n\t\t}\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,INF)) > 0){\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint gcd(int x, int y){\n    if(x % y == 0){\n        return y;\n    }\n    gcd(y,x % y);\n}\n\nint main()\n{\n    while(1){\n        scanf(\"%d%d\",&n,&m);\n        if(n == 0 && m == 0){\n            break;\n        }\n    \trep(i,n){\n    \t\tscanf(\"%d\",&a[i]);\n    \t}\n        rep(i,m){\n            scanf(\"%d\",&b[i]);\n        }\n        rep(i,n+m+2){\n            G[i].clear();\n        }\n        rep(i,n){\n            add_edge(0,i+1,1);\n        }\n        rep(i,m){\n            add_edge(n+i+1,n+m+1,1);\n        }\n        rep(i,n){\n            rep(j,m){\n                if(gcd(a[i],b[j]) > 1){\n                    add_edge(i+1,n+j+1,INF);\n                }\n            }\n        }\n        printf(\"%d\\n\",max_flow(0,n+m+1));\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct Dinic {\n    int n, s, t;\n    vector<int> level, iter, que;\n    vector<vector<Capacity>> cap, flow;\n    vector<vector<int>> g;\n    Capacity inf;\n    Dinic(int n)\n        : n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n          g(n, vector<int>()), inf(numeric_limits<Capacity>::max()/8){}\n    Dinic(const Graph &graph){\n        *this = Dinic(graph.size());\n        rep(i,n) for(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n    }\n    void addEdge(int u, int v, Capacity c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    inline Capacity residue(int u, int v){ return cap[u][v] - flow[u][v]; }\n    Capacity solve(int s, int t){\n        this->t = t, this->s = s;\n        Capacity res = 0, aug = 1;\n        while(aug > 0){\n            levelize();\n            iter.assign(n, 0);\n            res += (aug = augment(s, inf));\n        }\n        return res;\n    }\n    void levelize(){\n        level.assign(n, inf); level[s] = 0;\n        int l = 0, r = 0;\n        que.assign(n+1, 0);\n        que[r++] = s;\n        while(l != r){\n            int v = que[l++];\n            for(const int &d : g[v]){\n                if(level[d] <= level[v] + 1 || residue(v,d) == 0) continue;\n                level[d] = level[v] + 1; que[r++] = d;\n            }\n        }\n    }\n    Capacity augment(int v, Capacity lim){\n        Capacity res = 0;\n        if(v == t) return lim;\n        for(int &i = iter[v]; i < (int)g[v].size(); i++){\n            const int &d = g[v][i];\n            if(residue(v,d) == 0 || level[v] + 1 != level[d]) continue;\n            const Capacity aug = augment(d, min(lim, residue(v,d)));\n            if(aug > 0){\n                flow[v][d] += aug; flow[d][v] -= aug;\n                res += aug; lim -= aug;\n                if(lim == 0) return res;\n            }\n        }\n        return res;\n    }\n};\n\nint dp[2000][2000];\nint gcd(int a, int b){\n    return a < 2000 && b < 2000 ? dp[a][b] : b == 0 ? a : gcd(b, a%b);\n}\n\n\nint main(){\n    rep(i,2000)rep(j,i+1) dp[i][j] = dp[j][i] = __gcd(i,j);\n    fastios();\n    int n,m;\n    while(cin >> n >> m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        Dinic d(n+m+2);\n        int s = n+m, t = n+m+1;\n        rep(i,m) d.addEdge(i+n,t,1);\n        rep(i,n){\n            d.addEdge(s,i,1);\n            rep(j,m) if(gcd(a[i],b[j]) != 1) d.addEdge(i,n+j,1);\n        }\n        rep(i,n)rep(j,m){\n            if(d.flow[i][j+n]) dump(i,j, d.flow[i][j+m]);\n        }\n        cout << d.solve(s,t) << endl;\n    }\n}\n\n// int main(){\n//     int N,M;\n//     cin >> N >> M;\n//     Graph g(N);\n//     rep(i,M){\n//         int a,b,c;\n//         cin >> a >> b >> c;\n//         g[a].emplace_back(a,b,c);\n//     }\n//     Dinic dinic(g);\n//     cout << dinic.solve(0,N-1) << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nconstexpr int MAX_V = 1000;\n \nclass twoMatching {\nprivate:\n  vector<int> G[MAX_V];\n  int match[MAX_V];\n  bool used[MAX_V];\n  int V;\npublic:\n  twoMatching(int v) {\n    V = v;\n  }\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n \n  bool dfs(int v) {\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n      int u = G[v][i], w = match[u];\n      if (w < 0 || !used[w] && dfs(w)) {\n    match[v] = u;\n    match[u] = v;\n    return true;\n      }\n    }\n    return false;\n  }\n \n  int bipartite_matching() {\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for (int v = 0; v < V; v++) {\n      if (match[v] < 0) {\n    memset(used, 0, sizeof(used));\n    if (dfs(v)) res++;\n      }\n    }\n    return res;\n  }\n};\n \nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nint main() {\n  int m, n;\n  int b[500], r[500];\n \n  while (1) {\n    scanf(\"%d%d\", &m, &n);\n    if (m == 0) break;\n    for (int i = 0; i < m; i++) scanf(\"%d\", &b[i]);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &r[i]);\n    twoMatching t(m + n);\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (gcd(b[i], r[j]) == 1) continue;\n        t.add_edge(i, j + m);\n      }\n    }\n    printf(\"%d\\n\", t.bipartite_matching());\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Hopcroft-Karp Algorithm\n// O(|E| * |V|^(1/2))\n// http://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm\n// aoj 1163\n\n#include <vector>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\nint NIL;\nconst int inf = 1<<29;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int> > Graph;\n\nbool bfs(const Graph &g,vi &dist,const vi &pair,int m) {\n    queue<int> q;\n\n    for(int i=0; i<m; ++i)\n        if(pair[i] == NIL) {\n            dist[i] = 0;\n            q.push(i);\n        }else\n            dist[i] = inf;\n    dist[NIL] = inf;\n\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        if(v == NIL) continue;\n        for(int i=0; i<g[v].size(); ++i) {\n            int u = g[v][i];\n            if(dist[pair[u]] == inf) {\n                dist[pair[u]] = dist[v]+1;\n                q.push(pair[u]);\n            }\n        }\n    }\n    return dist[NIL] != inf;\n}\n\nbool dfs(int v,const Graph &g,vi &dist,vi &pair) {\n    for(int i=0; i<g[v].size(); ++i) {\n        int u = g[v][i];\n        if(dist[pair[u]] == dist[v]+1) {\n            if(dfs(pair[u],g,dist,pair)) {\n                pair[u] = v, pair[v] = u;\n                return true;\n            }\n        }\n    }\n    dist[v] = inf;\n    return false;\n}\n\n// 0ツつゥツづァm-1ツづ慊づづ個静淞点ツづツつゥツづァn-1ツづ慊づづ個静淞点ツづづ個催妥・ツマツッツチツδ督グツづーツ仰づ淞づゥ\nint hopcroft_karp(Graph &graph,int m) {\n    const int n = graph.size();\n    NIL = n;\n    vi pair(n+1, NIL), dist(n+1, 0);\n    int ret = 0;\n    while(bfs(graph,dist,pair,m)) {\n        for(int i=0; i<m; ++i)\n            if(pair[i] == NIL)\n                if(i == NIL || dfs(i,graph,dist,pair)) ret++;\n    }\n    return ret;\n}\n\nint gcd(int x,int y) {\n    if(y == 0) return x;\n    return gcd(y,x%y);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    int m,n;\n    while(cin>>m>>n, m|n) {\n        Graph g(m+n);\n        vector<int> b(m), r(n);\n        for(int i=0; i<m; ++i) cin>>b[i];\n        for(int i=0; i<n; ++i) cin>>r[i];\n\n        for(int i=0; i<m; ++i)\n            for(int j=0; j<n; ++j)\n                if(gcd(b[i],r[j]) > 1)\n                    g[i].push_back(j+m);\n        cout<<hopcroft_karp(g,m)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct Dinic {\n    int n, s, t;\n    vector<int> level, iter, que;\n    vector<vector<Capacity>> cap, flow;\n    vector<vector<int>> g;\n    Capacity inf;\n    Dinic(int n)\n        : n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n          g(n, vector<int>()), inf(numeric_limits<Capacity>::max()/8){}\n    Dinic(const Graph &graph){\n        *this = Dinic(graph.size());\n        rep(i,n) for(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n    }\n    void addEdge(int u, int v, Capacity c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    inline Capacity residue(int u, int v){ return cap[u][v] - flow[u][v]; }\n    Capacity solve(int s, int t){\n        this->t = t, this->s = s;\n        Capacity res = 0, aug = 1;\n        while(aug > 0){\n            levelize();\n            iter.assign(n, 0);\n            res += (aug = augment(s, inf));\n        }\n        return res;\n    }\n    void levelize(){\n        level.assign(n, inf); level[s] = 0;\n        int l = 0, r = 0;\n        que.assign(n+1, 0);\n        que[r++] = s;\n        while(l != r){\n            int v = que[l++];\n            for(const int &d : g[v]){\n                if(level[d] <= level[v] + 1 || residue(v,d) == 0) continue;\n                level[d] = level[v] + 1; que[r++] = d;\n            }\n        }\n    }\n    Capacity augment(int v, Capacity lim){\n        Capacity res = 0;\n        if(v == t) return lim;\n        for(int &i = iter[v]; i < (int)g[v].size(); i++){\n            const int &d = g[v][i];\n            if(residue(v,d) == 0 || level[v] + 1 != level[d]) continue;\n            const Capacity aug = augment(d, min(lim, residue(v,d)));\n            if(aug > 0){\n                flow[v][d] += aug; flow[d][v] -= aug;\n                res += aug; lim -= aug;\n                if(lim == 0) return res;\n            }\n        }\n        return res;\n    }\n};\n\nint dp[5000][5000];\nint gcd(int a, int b){\n    return a < 5000 && b < 5000 ? dp[a][b] : __gcd(a,b);\n}\n\n\nint main(){\n    rep(i,5000)rep(j,i+1) if(i*j) dp[i][j] = dp[j][i] = __gcd(i,j);\n    fastios();\n    int n,m;\n    while(cin >> n >> m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        Dinic d(n+m+2);\n        int s = n+m, t = n+m+1;\n        rep(i,m) d.addEdge(i+n,t,1);\n        rep(i,n){\n            d.addEdge(s,i,1);\n            rep(j,m) if(gcd(a[i],b[j]) != 1) d.addEdge(i,n+j,1);\n        }\n        rep(i,n)rep(j,m){\n            if(d.flow[i][j+n]) dump(i,j, d.flow[i][j+m]);\n        }\n        cout << d.solve(s,t) << endl;\n    }\n}\n\n// int main(){\n//     int N,M;\n//     cin >> N >> M;\n//     Graph g(N);\n//     rep(i,M){\n//         int a,b,c;\n//         cin >> a >> b >> c;\n//         g[a].emplace_back(a,b,c);\n//     }\n//     Dinic dinic(g);\n//     cout << dinic.solve(0,N-1) << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n#include <vector>\n#include <map>\n#include <assert.h>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\ntypedef int Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight == rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nWeight augment(Graph &g, Matrix &capacity, const vector<int> &level, vector<bool> &finished, int from, int t, Weight cur) {\n  if (from == t || cur == 0) { return cur; }\n  if (finished[from]) { return 0; }\n  for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n    int to = it->dest;\n    if (level[to] <= level[from]) { continue; }\n    Weight f = augment(g, capacity, level, finished, to, t, min(cur, capacity[from][to]));\n    if (f > 0) {\n      capacity[from][to] -= f;\n      capacity[to][from] += f;\n      return f;\n    }\n  }\n  finished[from] = true;\n  return 0;\n}\n\nWeight MaxFlow(Graph &g, int s, int t) {\n  int n = g.size();\n  Matrix capacity(n, Array(n));\n  for (int from = 0; from < n; from++) {\n    for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n      int to = it->dest;\n      capacity[from][to] += it->weight;\n    }\n  }\n  int ans = 0;\n  while (true) {\n    vector<int> level(n, -1);\n    level[s] = 0;\n    queue<int> que;\n    que.push(s);\n    for (int d = n; !que.empty() && level[que.front()] < d; ) {\n      int from = que.front();\n      que.pop();\n      if (from == t) { d = level[from]; }\n      for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n        int to = it->dest;\n        if (capacity[from][to] > 0 && level[to] == -1) {\n          que.push(to);\n          level[to] = level[from] + 1;\n        }\n      }\n    }\n    vector<bool> finished(n);\n    bool end = true;\n    while (true) {\n      Weight f = augment(g, capacity, level, finished, s, t, 1000000000);\n      if (f == 0) { break; }\n      ans += f;\n      end = false;\n    }\n    if (end) { break; }\n  }\n  return ans;\n}\n\nint maxFlow(const Graph &g, int s, int t) {\n  const int n = g.size();\n  Matrix capacity(n, Array(n, 0));\n  for (int i = 0; i < n; i++) {\n    for (Edges::const_iterator it = g[i].begin(); it != g[i].end(); it++) {\n      capacity[it->src][it->dest] = it->weight;\n    }\n  }\n  int ret = 0;\n  vector<int> parent(n);\n  while (true) {\n    fill(parent.begin(), parent.end(), -1);\n    priority_queue<Edge> que;\n    que.push(Edge(s, s, 0));\n    while (!que.empty()) {\n      Edge node = que.top();\n      que.pop();\n      if (parent[node.dest] != -1) { continue; }\n      parent[node.dest] = node.src;\n      if (node.dest == t) { break; }\n      int from = node.dest;\n      for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n        int to = it->dest;\n        if (capacity[from][to] == 0 || parent[to] != -1) { continue; }\n        que.push(Edge(from, to, 0));\n      }\n    }\n    if (parent[t] == -1) { break; }\n    Weight flow = 2000000000;\n    int from = parent[t];\n    int to = t;\n    while (from != to) {\n      flow = min(flow, capacity[from][to]);\n      from = parent[from];\n      to = parent[to];\n    }\n    from = parent[t];\n    to = t;\n    while (from != to) {\n      capacity[from][to] -= flow;\n      capacity[to][from] += flow;\n      from = parent[from];\n      to = parent[to];\n    }\n    ret += flow;\n  }\n  return ret;\n}\n\n\n\nint gcd(int a, int b) {\n  if (b == 0) { return a; }\n  return gcd(b, a % b);\n}\n\nint m, n;\nint blue[501];\nint red[501];\n\nint BLUE(int x) { return x; }\nint RED(int x) { return m + x; }\nint SOURCE() { return m + n; }\nint DEST() { return m + n + 1; }\nint SIZE() { return m + n + 2; }\n\nint main() {\n  while (scanf(\"%d %d\", &m, &n), m|n) {\n    Graph g(SIZE());\n    REP(b, m) {\n      scanf(\"%d\", &blue[b]);\n      g[SOURCE()].push_back(Edge(SOURCE(), BLUE(b), 1));\n      g[BLUE(b)].push_back(Edge(BLUE(b), SOURCE(), 0));\n    }\n    REP(r, n) {\n      scanf(\"%d\", &red[r]);\n      g[RED(r)].push_back(Edge(RED(r), DEST(), 1));\n      g[DEST()].push_back(Edge(DEST(), RED(r), 0));\n    }\n    REP(b, m) {\n      REP(r, n) {\n        if (gcd(blue[b], red[r]) != 1) {\n          g[BLUE(b)].push_back(Edge(BLUE(b), RED(r), 1));\n          g[RED(r)].push_back(Edge(RED(r), BLUE(b), 0));\n        }\n      }\n    }\n    assert(maxFlow(g, SOURCE(), DEST()) == MaxFlow(g, SOURCE(), DEST()));\n    int ans = maxFlow(g, SOURCE(), DEST());\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <memory.h>\n#include <functional>\n\nusing namespace std;\n\n#define REP(i,x) for(int i = 0; i <(int)(x);i++)\n\ntypedef int Weight;\n\nstruct Edge{\n\tint src, dst;\n\tWeight weight;\n\tEdge(int f, int t, Weight c):src(f),dst(t),weight(c){}\n};\n\nstruct Node:public vector<Edge>{};\nbool operator<(const Edge &a, const Edge &b){\n\treturn a.weight<b.weight;\n}\nbool operator>(const Edge &a, const Edge &b){\n\treturn b<a;\n}\n\ntypedef vector<Node>Graph;\n\n//FILE * in = freopen(\"E\", \"r\", stdin);\n\nint n, m;\nint data1[1000];\nint data2[1000];\n\nGraph data;\n\nint gcd(int a, int b){\n\treturn b>0?gcd(b,a%b):a;\n}\n\nvoid input(){\n\tdata.clear();\n\tdata.push_back(Node());\n\tfor(int i = 1; i <= n; i++){\n\t\tscanf(\"%d\", &data1[i]);\n\t\tdata.push_back(Node());\n\t\t//data[0].push_back(Edge(0,i,1));\n\t\t//data[i].push_back(Edge(i,0,1));\n\t}\n\tfor(int j = 1; j <= m; j++) {\n\t\tscanf(\"%d\", &data2[j]);\n\t\tdata.push_back(Node());\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tif(gcd(data1[i], data2[j])>1){\n\t\t\t\tdata[i].push_back(Edge(i,n+j,1));\n\t\t\t}\n\t\t}\n\t\t//data[n+j].push_back(Edge(n+j,n+m+1,1));\n\t}\n\tdata.push_back(Node());\n\tfor(int j = 1; j <= m;j++){\n\t\t//data[n+m+1].push_back(Edge(n+m+1,n+j,1));\n\t}\n}\n\nbool dfs(const Graph &G, int v, vector<int> &match, vector<bool>&visit){\n\tvisit[v] = true;\n\tREP(i,G[v].size()){\n\t\tint dst=G[v][i].dst;\n\t\tint w = match[dst];\n\t\tif(w == -1 || (!visit[w] && dfs(G,w,match,visit))) {\n\t\t\tmatch[v] = dst;\n\t\t\tmatch[dst] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(const Graph &G){\n\tint res = 0;\n\tvector<int> match(G.size(),-1);\n\tREP(v,G.size())if(match[v] == -1){\n\t\tvector<bool>visit(G.size());\n\t\tif(dfs(G,v,match,visit))res++;\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn res;\n}\n\nint main() {\n\twhile(true){\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(n == 0) break;\n\t\tinput();\n\t\tbipartite_matching(data);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing Bool = bool;\nusing Int = long long int;\ntemplate <class T>\nusing Vector = std::vector<T>;\n\nconstexpr Int INF = std::numeric_limits<Int>::max() / 3;\n\nInt gcd(Int a, Int b) {\n    if (a < b) std::swap(a, b);\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nstruct MaxFlow {\n    struct Edge {\n        Int src, dst, cap, rev;\n        Edge(Int src, Int dst, Int cap, Int rev)\n            : src(src), dst(dst), cap(cap), rev(rev) {}\n    };\n\n    Vector<Vector<Edge>> graph;\n    Vector<Bool> visited;\n\n    MaxFlow(Int n) : graph(n), visited(n, false) {}\n\n    void span(Int src, Int dst, Int cap) {\n        graph[src].emplace_back(src, dst, cap, graph[dst].size());\n        graph[dst].emplace_back(dst, src, 0, graph[src].size() - 1);\n    }\n\n    Bool dfs(Int v, Int sink, Int f) {\n        if (v == sink) return f;\n        visited[v] = true;\n\n        for (auto& e : graph[v]) {\n            if (visited[e.dst] || e.cap == 0) continue;\n            Int df = dfs(e.dst, sink, std::min(f, e.cap));\n            if (df == 0) continue;\n\n            e.cap -= df;\n            graph[e.dst][e.rev].cap += df;\n            return df;\n        }\n        return 0;\n    }\n\n    Int exec(Int s, Int g) {\n        Int flow = 0;\n        while (true) {\n            std::fill(visited.begin(), visited.end(), false);\n            Int f = dfs(s, g, INF);\n            if (f == 0) break;\n            flow += f;\n        }\n        return flow;\n    }\n};\n\nBool solve() {\n    Int n, m;\n    std::cin >> n >> m;\n    if (n == 0) return false;\n\n    Vector<Int> a(n), b(m);\n    for (auto& x : a) std::cin >> x;\n    for (auto& x : b) std::cin >> x;\n\n    Int s = n + m, g = n + m + 1;\n    MaxFlow mf(n + m + 2);\n    for (Int u = 0; u < n; ++u) mf.span(s, u, 1);\n    for (Int u = 0; u < n; ++u) {\n        for (Int v = 0; v < m; ++v) {\n            if (gcd(a[u], b[v]) > 1) mf.span(u, v + n, 1);\n        }\n    }\n    for (Int v = 0; v < m; ++v) mf.span(v + n, g, 1);\n\n    std::cout << mf.exec(s, g) << std::endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint m,n;\nint b[500], r[500];\nint C[500][500]; //C[b][r]=0(?????¢?????§???????????´???), =1(??§????????´???)\nint P[500]; //P[r], red??¨?????¢????????£?????????????????????\nbool V[500]; //V[r], true??????????????°???????????????????????????false????????????\n\nint gcd(int a, int b) //a>=b\n{\t\n\tif(b==0){\n\t\treturn a;\n\t} else {\n\t\treturn gcd(b, a%b);\n\t}\n}\n\nbool match(int b)\n{\n\tif(b<0) return true;\n\tfor(int j=0;j<n;++j){\n\t\tif(C[b][j]==0||V[j]==true) continue;\n\t\tV[j]=true;\n\t\tif(match(P[j])){\n\t\t\tP[j]=b;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tfor(int k=0;k<101;++k){\n\t\tcin>>m>>n;\n\t\tif(m==0&&n==0) break;\n\t\t\n\t\tfill(P,P+n,-1);\n\t\tfor(int i=0;i<m;++i){\n\t\t\tcin>>b[i];\n\t\t\t//cout<<b[i]<<\" \";\n\t\t}\n\t\t//cout<<endl;\n\t\tfor(int j=0;j<n;++j){\n\t\t\tcin>>r[j];\n\t\t\t//cout<<r[j]<<\" \";\n\t\t}\n\t\t//cout<<endl;\n\n\t\t//C[b][r]?????\\???\n\t\tfor(int i=0;i<m;++i){ //for all blue cards\n\t\t\tfor(int j=0;j<n;++j){ //for all red cards\n\t\t\t\tif(b[i]>=r[j]){\n\t\t\t\t\tC[i][j]=(gcd(b[i],r[j])>=2);\n\t\t\t\t} else {\n\t\t\t\t\tC[i][j]=(gcd(r[j],b[i])>=2);\n\t\t\t\t}\n\n\t\t\t\t//cout<<C[i][j]<<\" \";\n\t\t\t}\n\t\t\t//cout<<endl;\n\t\t}\n\n\n\t\tint num=0;\n\t\tfor(int i=0;i<m;++i){ //for all blue cards\n\t\t\tfor(int j=0;j<n;++j){ //for all red cards\n\t\t\t\tV[j]=false;\n\t\t\t}\n\t\t\tif(match(i)) ++num;\n\t\t\t\t//cout<<i<<\" \"<<j<<\" \"<<num<<endl;\n\t\t}\n\t\tcout<<num<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T> void cmin(T &a, const T&b) { if (a > b)a = b; }\ntemplate<class T> void cmax(T &a, const T&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//テゥツ?淌・ツコツヲテ」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ?湘」ツδ。テ」ツδ「テ」ツδェテ・ツ環ケテァツ篠?」ツつ津ィツ?ε」ツ?暗」ツつ凝」ツ?ェテ」ツつ詠ankテ」ツ?ョテ」ツ?凝」ツつ湘」ツつ甘」ツ?ォsizeテ」ツつ津、ツスツソテ」ツ??\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.first);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\nstruct edge { int to, cap, rev, cost; };\n\nconstexpr int MAX_V = 2000;\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap,(int) G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,cost });\n}\nvoid bfs(int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tint f;\n\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\ntypedef pair<int, int> P;\nint V;\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tfill_n(dist, V, numeric_limits<int>::max());\n\t\tdist[s] = 0;\n\t\tque.push({ 0,s });\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first)continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]){\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d*h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\tint m, n;\n\tfor (;;) {\n\t\tfill_n(G, MAX_V, vector<edge>());\n\t\tcin >> m >> n;\n\t\tif (!m)break;\n\t\tvi b(m), r(n);\n\t\trep(i, m)cin >> b[i];\n\t\trep(i, n)cin >> r[i];\n\t\trep(i, m) {\n\t\t\tadd_edge(0, i + 1, 1);\n\t\t\trep(j, n) {\n\t\t\t\tif (gcd(b[i], r[j]) > 1) {\n\t\t\t\t\tadd_edge(i + 1, m + 1 + j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, n) {\n\t\t\tadd_edge(m + 1 + i, m + n + 1, 1);\n\t\t}\n\t\tcout << max_flow(0, m + n + 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\n#define MAX_N 1000\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});  \n}\n\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nint N,K;\nbool can[MAX_N][MAX_N]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(){\n  //0??????N-1: ???????????\\???????????????????????????\n  //N??????N+K-1: ???????????????????????????\n  int s = N+K, t = s+1;\n  \n  //s??¨???????????\\??????????????¶\n  for(int i=0; i<N; i++) add_edge(s,i,1);\n  \n  //????????¨t?????????\n  for(int i=0; i<K; i++) add_edge(N+i,t,1);\n  \n  //???????????\\????????¨??????????????¶\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)\n      if(can[i][j]) add_edge(i, N+j , 1);\n\n  return max_flow(s,t);\n}\n\nint main(){\n  while(1){\n  int b,r,B[501],R[501];\n  cin>>b>>r;\n  if(!b&&!r)break;\n  for(int i=0;i<b;i++) cin>>B[i];\n  for(int i=0;i<r;i++) cin>>R[i];\n\n  memset(can,0,sizeof(can));\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n  N=b,K=r;\n  for(int i=0;i<b;i++)\n    for(int j=0;j<r;j++)\n      if(__gcd(B[i],R[j])>1) can[i][j]=1;\n\n  cout<<Biparite_Matching()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define INF 10000000\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define MAX_V 1003\n#define MAX_N 501\n#define MAX_M 501\nusing namespace std;\nstruct edge{\n\tint to,cap,rev;\n};\nbool used[MAX_V];\nbool can[MAX_N][MAX_M];\nvector<edge> G[MAX_V];\nvoid add_edge(int from,int to,int cap){\n\tedge pre;\n\tpre.to=to;pre.cap=cap;pre.rev=G[to].size();\n\tG[from].push_back(pre);\n\tpre.to=from;pre.cap=0;pre.rev=G[from].size()-1;\n\tG[to].push_back(pre);\n}\nint N,M;\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to]&&e.cap>0){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)return flow;\n\t\tflow+=f;\n\t}\n}\nvoid solve(){\n\tint s=N+M,t=s+1;\n\tfor(int i=0;i<M;i++){\n\t\tadd_edge(s,i,1);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tadd_edge(M+i,t,1);\n\t}\n\tfor(int i=0;i<M;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(can[i][j]){\n\t\t\t\tadd_edge(i,M+j,1);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<max_flow(s,t)<<endl;\n}\nint main(){\n\tint n[501],m[501];\n\twhile(cin>>M>>N,N||M){\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>m[i];\n\t\t}\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>n[i];\n\t\t}\n\t\tfor(int i=0;i<M;i++)\n\t\tfor(int j=0;j<N;j++){\n\t\t\tcan[i][j]=0;\n\t\t\tif(__gcd(m[i],n[j])>1){\n\t\t\t\tcan[i][j]=1;\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t\tfor(int i=0;i<=M+N+1;i++)\n\t\tG[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string.h>\n#include <queue>\nusing namespace std;\nstruct edge{int to, cap, rev;};\nint INF = 10000000;\nint iter[1002];\nint level[1002];\n\nvoid bfs(vector< vector<edge> > &G, int s){\n  memset(level,-1,sizeof(level));\n  level[s] = 0;\n  queue<int> que;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i = 0; i < G[v].size(); ++i){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n\tlevel[e.to] = level[v] + 1;\n\tque.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(vector< vector<edge> > &G, int v, int t, int f){\n  if(v == t) return f;\n  for(int &i = iter[v]; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(G,e.to,t,min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(vector< vector<edge> > &G, int s, int t){\n  int flow = 0;\n  for(;;){\n    bfs(G,s);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f = dfs(G,s,t,INF)) > 0){\n      flow += f;\n    }\n  }\n}\n\nint gcd(int a, int b){\n  if(a < b) swap(a,b);\n  if(a % b) return gcd(b,a%b);\n  return b;\n}\n\nint main(){\n  int m, n;\n  while(cin >> m >> n, m){\n    int b[m], r[n];\n    vector< vector<edge> > G(n+m+2);\n    for(int i = 0; i < m; ++i)\n      cin >> b[i];\n    for(int i = 0; i < n; ++i)\n      cin >> r[i];\n    for(int i = 0; i < m; ++i){\n      for(int j = 0; j < n; ++j){\n\tif(gcd(b[i],r[j]) != 1){\n\t  G[i].push_back((edge){j+m,1,G[j+m].size()});\n\t  G[j+m].push_back((edge){i,0,G[i].size()-1});\n\t}\n      }\n    }\n    int s = n + m, t = n + m + 1;\n    for(int i = 0; i < m; ++i){\n      G[s].push_back((edge){i,1,G[i].size()});\n      G[i].push_back((edge){s,0,G[s].size()-1});\n    }\n    for(int i = 0; i < n; ++i){\n      G[i+m].push_back((edge){t,1,G[t].size()});\n      G[t].push_back((edge){i+m,0,G[i+m].size()});\n    }\n    cout << max_flow(G,s,t) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nstruct edge{\n  int to, cap, rev;\n  edge(){}\n  edge(int to, int cap, int rev):\n    to(to), cap(cap), rev(rev) {}\n};\ntypedef vector<edge> edges;\nint gcd(int m,int n){\n  return (m%n)?gcd(n, m%n):n;\n}\nvoid add_edge(vector<edges>& g, int from, int to, int cap){\n  g[from].push_back(edge(to, cap, g[to].size()));\n  g[to].push_back(edge(from, 0, g[from].size()-1));\n}\nbool used[1002];\nint dfs(vector<edges>& g, int u, int end, int f){\n  if(u == end) return f;\n  used[u] = true;\n  REP(i,g[u].size()){\n    edge& e = g[u][i];\n    if(used[e.to] || e.cap <= 0) continue;\n    int t = dfs(g, e.to, end, min(f,e.cap));\n    if(t > 0){\n      e.cap -= t;\n      g[e.to][e.rev].cap += t;\n      return t;\n    }\n  }\n  return 0;\n}\nint maxflow(vector<edges>& g, int s, int e){\n  int res = 0;\n  while(true){\n    memset(used, 0, sizeof(used));\n    int f = dfs(g, s, e, 1);\n    if(f == 0) return res;\n    else res += f;\n  }\n  return -1;\n}\n\nint main(){\n  int m,n;\n  while(cin>>m>>n,m||n){\n    vector<int> v1(m);\n    vector<int> v2(n);\n    REP(i,m)cin>>v1[i];\n    REP(i,n)cin>>v2[i];\n    const int start = m + n;\n    const int end = m + n + 1;;\n    vector<edges> graph(end + 1);\n    REP(i,m)add_edge(graph, start, i, 1);\n    REP(i,n)add_edge(graph, m + i, end, 1);\n    REP(i,m)REP(j,n)if(gcd(v1[i],v2[j])!=1){\n      add_edge(graph, i, m + j, 1);\n    }\n    cout<<maxflow(graph,start,end)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, start, end) for (long long i = start; i < end; ++i)\n#define repreverse(i, start, end) for (long long i = start; i >= end; --i)\n#define all(x) (x).begin(), (x).end()\n#define len(x) ((long long)(x).size())\n#define lcm(a, b) ((a) / __gcd((a), (b)) * (b))\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vll = vector<ll>;\nusing vllvll = vector<vll>;\nusing pll = pair<ll, ll>;\ntemplate<class T>void print1d(T x,ll n=-1){if(n==-1)n=x.size();rep(i,0,n){cout<<x[i]<<' ';}cout<<'\\n';}\ntemplate<class T>void print2d(T x,ll r=-1,ll c=-1){if(r==-1)r=x.size();if(c==-1)c=x[0].size();rep(i,0,r)print1d(x[i],c);}\ntemplate<class T, class U>bool haskey(T mp, U key) { return mp.find(key) != mp.end(); }\ntemplate<class T, class U>bool isin(T el, U container) { return find(all(container), el) != container.end(); }\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<class T>bool even(T n) { return ! (n & 1); }\ntemplate<class T>bool odd(T n) { return n & 1; }\ntemplate<class T>ld deg2rad(T deg) { return M_PI * deg / 180.0; }\ntemplate<class T>ld rad2deg(T rad) { return 180.0 * rad / M_PI; }\nll intpow(ll a,ll n){ll p=1;while(n){if(n&1)p*=a;a*=a;n>>=1;}return p;}\nconst long double pi = M_PI;\nconst long long big = 1LL << 50;\nconst long long inf = 1LL << 60;\nconst long long mod = 1e9 + 7;\n\nconst int MAX = 1100;\n\nstruct Edge\n{\n        long long to, cap, rev;\n};\n\nstd::vector<std::vector<Edge> > flowGraph(MAX);\nstd::vector<long long> level(MAX);\nstd::vector<long long> iter(MAX);\n\nvoid init()\n{\n        std::fill(flowGraph.begin(), flowGraph.end(), vector<Edge>(0));\n}\n\nvoid add_edge(long long from, long long to, long long cap)\n{\n        flowGraph[from].push_back((Edge){to, cap, (long long)flowGraph[to].size()});\n        flowGraph[to].push_back((Edge){from, 0, (long long)flowGraph[from].size()-1});\n}\n\nvoid _bfs(long long s)\n{\n        std::fill(level.begin(), level.end(), -1);\n        std::queue<long long> q;\n        level[s] = 0;\n        q.push(s);\n        while (! q.empty()) {\n                long long v = q.front();\n                q.pop();\n                for (long long i = 0; i < (long long)flowGraph[v].size(); ++i) {\n                        Edge &e = flowGraph[v][i];\n                        if (e.cap > 0 and level[e.to] < 0) {\n                                level[e.to] = level[v] + 1;\n                                q.push(e.to);\n                        }\n                }\n        }\n}\n\nlong long _dfs(long long v, long long t, long long f)\n{\n        if (v == t) return f;\n\n        for (long long& i = iter[v]; i < (long long)flowGraph[v].size(); ++i) {\n                Edge &e = flowGraph[v][i];\n                if (level[v] < level[e.to] and e.cap > 0) {\n                        long long d = _dfs(e.to, t, min(f, e.cap));\n                        if (d > 0) {\n                                e.cap -= d;\n                                flowGraph[e.to][e.rev].cap += d;\n                                return d;\n                        }\n                }\n        }\n        return 0;\n}\n\nlong long max_flow(long long s, long long t)\n{\n        long long flow = 0;\n        while (true) {\n                _bfs(s);\n                if (level[t] < 0) return flow;\n                std::fill(iter.begin(), iter.end(), 0);\n                long long f;\n                while ((f = _dfs(s, t, 1LL<<60)) > 0) {\n                        flow += f;\n                }\n        }\n}\n\n\n\nint main()\n{\n        vll ans;\n        while (true) {\n                ll m, n;\n                cin >> m >> n;\n                if (m == 0 and n == 0) break;\n                \n                init();\n                vll b(m), r(n);\n                rep(i, 0, m) cin >> b[i];\n                rep(i, 0, n) cin >> r[i];\n\n                vllvll connected(m, vll(n));\n\n                rep(i, 0, m) {\n                        rep(j, 0, n) {\n                                if (__gcd(b[i], r[j]) >= 2) {\n                                        connected[i][j] = 1;\n                                }\n                        }\n                }\n\n                ll left = MAX-2;\n                ll right = MAX-1;\n\n                rep(i, 0, m) {\n                        add_edge(left, i, 1);\n                }\n\n                rep(i, 0, m) {\n                        rep(j, 0, n) {\n                                if (connected[i][j]) {\n                                        add_edge(i, m+j, 1);\n                                }\n                        }\n                }\n\n                rep(i, 0, n) {\n                        add_edge(m+i, right, 1);\n                }\n\n                ans.push_back(max_flow(left, right));\n        }\n        rep(i, 0, len(ans)) {\n                cout << ans[i] << endl;\n        }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define clear(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nclass BipatiteGraph\n{\n\tvector<bool> used;\n\n\tbool _dfs(int v)\n\t{\n\t\tused[v] = true;\n\t\tfor (int i = 0; i < edges[v].size(); ++i)\n\t\t{\n\t\t\tint u = edges[v][i];\n\t\t\tint m = match[u];\n\t\t\tif (m < 0 || !used[m] && _dfs(m))\n\t\t\t{\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\npublic:\n\tint vertices;\n\tvector<vector<int> > edges;\n\tvector<int> match;\n\n\tBipatiteGraph(int n)\n\t\t: vertices(n), edges(n), match(n), used(n)\n\t{\n\t}\n\n\tvoid add_edge(int a, int b)\n\t{\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\n\tbool dfs(int v)\n\t{\n\t\tfill(used.begin(), used.end(), false);\n\t\treturn _dfs(v);\n\t}\n\n\tint matching()\n\t{\n\t\tfill(match.begin(), match.end(), -1);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < vertices; ++i)\n\t\t{\n\t\t\tif (match[i] < 0)\n\t\t\t{\n\t\t\t\tif (dfs(i))\n\t\t\t\t\t++res;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\nint main()\n{\n\tint m, n, b[512], r[512];\n\twhile (scanf(\"%d%d\", &m, &n), m)\n\t{\n\t\tfor (int i = 0; i < m; ++i)\n\t\t\tscanf(\"%d\", b + i);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tscanf(\"%d\", r + i);\n\n\t\tBipatiteGraph bg(m + n);\n\t\tfor (int i = 0; i < m; ++i)\n\t\t\tfor (int j = 0; j < n; ++j)\n\t\t\t\tif (gcd(b[i], r[j]) != 1)\n\t\t\t\t\tbg.add_edge(i, m + j);\n\t\tprintf(\"%d\\n\", bg.matching());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main() {\n\tint m, n, red[500], blue[500], num[10];\n\tcin >> m >> n;\n\n\twhile (m != 0 && n != 0) {\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\t//cout << \"redcard????????\\?????????????????????\" << endl;\n\t\t\tcin >> red[i];\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t//cout << \"bluecard???????????\\?????????????????????\" << endl;\n\t\t\tcin >> blue[i];\n\t\t}\n\n\t\tint a;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (red[i] < red[i + 1]) {\n\t\t\t\t\ta = red[i];\n\t\t\t\t\tred[i] = red[i + 1];\n\t\t\t\t\tred[i + 1] = a;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tint b;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (blue[i] < blue[i + 1]) {\n\t\t\t\t\tb = blue[i];\n\t\t\t\t\tblue[i] = blue[i + 1];\n\t\t\t\t\tblue[i + 1] = b;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t////////////////////???????????????\n\n\t\tint x = 0, ans;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (red[i] == blue[j]) {\n\t\t\t\t\t//cout << red[i] << \"?????????\" << endl;\n\t\t\t\t\tblue[j] = 0;\n\t\t\t\t\tx++;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tif (red[i] < blue[j]) {\n\t\t\t\t\t\tfor (int k = i; k <= 1000; k++) {\n\t\t\t\t\t\t\tans = red[i] * k;\n\t\t\t\t\t\t\tif (ans == blue[j]) {\n\t\t\t\t\t\t\t\t//cout << \"red= \" << red[i] << \"blue=\" << blue[j] << endl;\n\t\t\t\t\t\t\t\tblue[j] = 0;\n\t\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\telse if (red[i] > blue[j]) {\n\t\t\t\t\t\tfor (int k = i; k <= 1000; k++) {\n\t\t\t\t\t\t\tans = blue[j] * k;\n\t\t\t\t\t\t\tif (ans == red[j]) {\n\t\t\t\t\t\t\t\t//cout << \"red=\" << red[i] << \"blue=\" << blue[j];\n\t\t\t\t\t\t\t\tblue[j] = 0;\n\t\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}break;\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tcout << x << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* vim: set st=2 sts=2 :*/\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint m,n,b[500],r[500];\nbool c[500][500],V[500];\nint P[500];\n\nbool match(int i){\n  if(i<0) return true;\n  for(int j=0;j<n;j++){\n    if((!c[i][j])||V[j]) continue;\n    V[j]=true;\n    if(match(P[j])){\n      P[j]=i;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&m,&n),m|n){\n    for(int i=0;i<m;i++) scanf(\"%d\",b+i);\n    for(int i=0;i<n;i++) scanf(\"%d\",r+i);\n    fill(P,P+n,-1);\n    for(int i=0;i<m;i++)\n      for(int j=0;j<n;j++)\n        c[i][j]=(__gcd(b[i],r[j])>=2);\n    int cnt=0;\n    for(int i=0;i<m;i++){\n      fill(V,V+n,false);\n      if(match(i)) ++cnt;\n    }\n    printf(\"%d\\n\",cnt);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> L[2000];int N,M,E,match[2000],x[2000],y[2000];bool used[2000];\n bool DFS(int V) {\n    used[V] = true;\n    for (int i = 0; i < L[V].size(); i++) {\n        int u = L[V][i]; int w = match[u];\n        if (w < 0 || !used[w] && DFS(w)) {\n            match[V] = u;\n            match[u] = V;\n            return 1;\n        }\n    }\n    return 0;\n}\nint SM() {\n    int r = 0;\n    memset(match, -1, sizeof(match));\n    for (int j = 0; j < N + M; j++) {\n        if (match[j] < 0) {\n            memset(used, 0, sizeof(used));\n            if (DFS(j)) { r++; }\n        }\n    }\n    return r;\n}\n \n//main.\nint main() {\n    while (true) {\n        for (int i = 0; i < 2000; i++) { L[i].clear(); }\n        cin >> N >> M; if (!N) { break; }\n        for (int i = 0; i < N; i++) {\n            cin >> x[i];\n        }\n        for (int i = 0; i < M; i++) {\n            cin >> y[i];\n        }\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                if (__gcd(x[i], y[j]) != 1) {\n                    L[i].push_back(j + N);\n                }\n            }\n        }\n        cout << SM() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include <map>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string.h>\n#include\"time.h\"\nusing namespace std;\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n\n/*\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tFlow cap;\n\tEdge() : src(0), dst(0), weight(0) {}\n\tEdge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n\tg[a].emplace_back(a, b, w);\n\tg[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\n*/\n\nclass bipartite_matching {\npublic:\n\tint n;\n\tvector<vector<int>> g;\n\tvector<int> match;\n\n\tbipartite_matching(int n_) : n(n_), g(n_), match(n_), used(n_) {}\n\n\tvoid add_edge(int u, int v) {\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\n\tint maximum_matching(void) {\n\t\tint res = 0;\n\t\tfill(match.begin(),match. end(), -1);\n\t\tfor (int v = 0; v < n; ++v) {\n\t\t\tif (match[v] == -1) {\n\t\t\t\tfill(begin(used), end(used), false);\n\t\t\t\tif (dfs(v)) res++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\nprivate:\n\tvector<int> used;\n\tbool dfs(int v) {\n\t\tused[v] = true;\n\t\tfor (int u : g[v]) {\n\t\t\tint w = match[u];\n\t\t\tif (w == -1 || (!used[w] && dfs(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\n\n//?????????????????´???\n#define NM_MAX 500\n\n\n//??????????????¨??????\nint m,n;\nint b[NM_MAX];\nint r[NM_MAX];\n\n//b,r????????????????´??????°\nset<int> primeB[NM_MAX];\nset<int> primeR[NM_MAX];\n\n\nint main() {\n\twhile(1){\n\t\t//?????????\n\t\tCLR(b);\n\t\tCLR(r);\n\t\tREP(i, NM_MAX)primeB[i].clear();\n\t\tREP(i, NM_MAX)primeR[i].clear();\n\n\t\t//??\\???????????????\n\t\tcin>>m>>n;\n\t\tif(m==0 && n==0)break;\n\t\tREP(i, m)cin >> b[i];\n\t\tREP(i, n)cin >> r[i];\n\n\t\t//?´??????°????§£\n\t\tint prime;\n\t\tREP(i, m) {\n\t\t\tprime=2;\n\t\t\twhile (prime <= sqrt(b[i])) {\n\t\t\t\t//cout<<prime<<\"  \"<<b[i]<<endl;\n\t\t\t\tif (b[i] % prime == 0) {\n\t\t\t\t\tb[i]/=prime;\n\n\t\t\t\t\tprimeB[i].insert(prime);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprime++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprimeB[i].insert(b[i]);\n\n\t\t}\t\n\n\t\tREP(i, n) {\n\t\t\tprime = 2;\n\t\t\twhile (prime <= sqrt(r[i])) {\n\n\t\t\t\tif (r[i] % prime == 0) {\n\t\t\t\t\tr[i] /= prime;\n\t\t\t\t\tprimeR[i].insert(prime);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprime++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprimeR[i].insert(r[i]);\n\t\t}\n\n\t\t//???????????£?????????\n\t\tbipartite_matching bm = bipartite_matching(m + n + 1);\n\t\tbool okFlag;//???????????????????????????\n\t\tREP(i, m)REP(j, n) {\n\t\t\tokFlag=false;\n\n\t\t\tfor (set<int>::iterator it = primeB[i].begin(); it != primeB[i].end(); it++) {\n\n\t\t\t\t//?????´??????????´?????????£?????´???\n\t\t\t\tif (primeR[j].find(*it) != primeR[j].end()) {\n\t\t\t\t\tokFlag=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(okFlag)bm.add_edge(i,m+j);\n\t\t}\n\n\t\t//??????????????§??????????????°????±?????????????\n\t\tint ans=bm.maximum_matching();\n\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef struct{\n\tint t;\n\tint c;\n\tint r;\n} edge;\n\nvector<edge> g[502];\n\nvoid add_edge(int from,int to,int cap){\n\tedge e1 = {to,cap,g[to].size()};\n\tg[from].push_back(e1);\n\tedge e2 = {from,0,g[from].size() - 1};\n\tg[to].push_back(e2);\n}\n\n\nint gcd(int x,int y){\n\tif(!y) return x;\n\treturn gcd(y,x % y);\n}\n\nint uv[502];\n\nint dfs(int v,int t,int f){\n\tint i;\n\tif(v == t) return f;\n\tuv[v] = 0;\n\tfor(i = 0;i < g[v].size();i++){\n\t\tif(uv[g[v][i].t] && g[v][i].c > 0){\n\t\t\tint d = dfs(g[v][i].t,t,min(f,g[v][i].c));\n\t\t\tif(d > 0){\n\t\t\t\tg[v][i].c -= d;\n\t\t\t\tg[g[v][i].t][g[v][i].r].c += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint maxflow(int s,int t){\n\tint f, res = 0;\n\twhile(1){\n\t\tmemset(uv,-1,sizeof(uv));\n\t\tf = 0;\n\t\tf += dfs(s,t,2);\n\t\tif(f == 0) return res;\n\t\tres += f;\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint m, n, b[500], r[500], i, j;\n\twhile(1){\n\t\tscanf(\"%d%d\",&m,&n);\n\t\tif(m + n == 0) break;\n\t\tfor(i = 0;i < m;i++)\n\t\t\tscanf(\"%d\",&b[i]);\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d\",&r[i]);\n\t\tfor(i = 0;i < m;i++)\n\t\t\tadd_edge(0,i + 1,1);\n\t\tfor(i = 0;i < m;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tif(gcd(b[i],r[j]) != 1){\n\t\t\t\t\tadd_edge(i + 1,m + j + 1,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < n;i++)\n\t\t\tadd_edge(m + i + 1,m + n + 1,1);\n\t\tprintf(\"%d\\n\",maxflow(0,m + n + 1));\n\t\tfor(i = 0;i < m + n + 2;i++)\n\t\t\twhile(g[i].size()) g[i].pop_back();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct Dinic {\n    int n, s, t;\n    vector<int> level, iter;\n    vector<vector<Capacity>> cap, flow;\n    vector<vector<int>> g;\n    Capacity inf;\n    Dinic(int n)\n        : n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n          g(n, vector<int>()), inf(numeric_limits<Capacity>::max()/8){}\n    Dinic(const Graph &graph){\n        *this = Dinic(graph.size());\n        rep(i,n) for(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n    }\n    void addEdge(int u, int v, Capacity c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    inline Capacity residue(int u, int v){ return cap[u][v] - flow[u][v]; }\n    Capacity solve(int s, int t){\n        this->t = t, this->s = s;\n        Capacity res = 0, aug = 1;\n        while(aug > 0){\n            levelize();\n            iter.assign(n, 0);\n            aug = augment(s, inf);\n            res += aug;\n        }\n        return res;\n    }\n    void levelize(){\n        level.assign(n, inf); level[s] = 0;\n        queue<int> q; q.emplace(s);\n        while(q.size()){\n            int v = q.front(); q.pop();\n            for(const int &d : g[v]){\n                if(level[d] <= level[v] + 1 || residue(v,d) == 0) continue;\n                level[d] = level[v] + 1; q.emplace(d);\n            }\n        }\n    }\n    Capacity augment(int v, Capacity lim){\n        Capacity res = 0;\n        if(v == t) return lim;\n        for(int &i = iter[v]; i < (int)g[v].size(); i++){\n            const int &d = g[v][i];\n            if(residue(v,d) == 0 || level[v] + 1 != level[d]) continue;\n            Capacity aug = augment(d, min(lim, residue(v,d)));\n            if(aug > 0){\n                flow[v][d] += aug; flow[d][v] -= aug;\n                res += aug; lim -= aug;\n                if(lim == 0) return res;\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    fastios();\n    int n,m;\n    while(cin >> n >> m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        Dinic d(n+m+2);\n        int s = n+m, t = n+m+1;\n        rep(i,m) d.addEdge(i+n,t,1);\n        rep(i,n){\n            d.addEdge(s,i,1);\n            rep(j,m) if(__gcd(a[i],b[j]) != 1) d.addEdge(i,n+j,1);\n        }\n        rep(i,n)rep(j,m){\n            if(d.flow[i][j+n]) dump(i,j, d.flow[i][j+m]);\n        }\n        cout << d.solve(s,t) << endl;\n    }\n}\n\n// int main(){\n//     int N,M;\n//     cin >> N >> M;\n//     Graph g(N);\n//     rep(i,M){\n//         int a,b,c;\n//         cin >> a >> b >> c;\n//         g[a].emplace_back(a,b,c);\n//     }\n//     Dinic dinic(g);\n//     cout << dinic.solve(0,N-1) << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long int integer;\n\nstruct edge {\n  integer to, cap, rev;\n};\n\nconst integer VMAX = 2000, INF = 1e10;\n\nvector<edge> G[VMAX];\nbool used[VMAX];\n\nvoid add_edge(integer from, integer to, integer cap) {\n  G[from].push_back((edge) {to, cap, (integer)G[to].size()});\n  G[to].push_back((edge) {from, 0, (integer)G[from].size()-1});\n}\n\ninteger dfs(integer v, integer t, integer f) {\n  if (v == t) return f;\n  used[v] = true;\n  for (int i = 0, size = G[v].size(); i < size; i++) {\n    edge &e = G[v][i];\n    if (!used[e.to] && e.cap > 0) {\n      integer d = dfs(e.to, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\ninteger max_flow(integer s, integer t) {\n  integer flow = 0;\n  while (true) {\n    for (int i = 0; i < VMAX; i++) {\n      used[i] = false;\n    }\n    integer f = dfs(s, t, INF);\n    if (f == 0) return flow;\n    flow += f;\n  }\n}\n\ninteger gcd(integer a, integer b) {\n  return (b == 0 ? a : gcd(b, a % b));\n}\n\nint main() {\n  const int SEPARATOR = 600, SOURCE = 1900, SINK = 1901;\n  int m, n;\n  while (cin >> m >> n && m) {\n    for (int i = 0; i < VMAX; i++) {\n      G[i].clear();\n    }\n    vector<integer> b(m), r(n);\n    for (int i = 0; i < m; i++) {\n      cin >> b[i];\n    }\n    for (int i = 0; i < n; i++) {\n      cin >> r[i];\n    }\n    \n    for (int i = 0; i < m; i++) {\n      add_edge(SOURCE, i, 1);\n    }\n    for (int i = 0; i < n; i++) {\n      add_edge(SEPARATOR + i, SINK, 1);\n    }\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (gcd(b[i], r[j]) > 1) {\n          add_edge(i, SEPARATOR + j, 1);\n        }\n      }\n    }\n    cout << max_flow(SOURCE, SINK) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nclass Edge{\npublic:\n    int to, from ,cost,cap,rev;\n    Edge(int _from,int _to,int _cost){\n        to=_to;\n        from=_from;\n        cost=_cost;\n    }\n    Edge(int _from,int _to,int _cost,int _cap){\n        from=_from;\n        to=_to;\n        cost=_cost;\n        cap=_cap;\n    }\n};\nclass Dinic{//max flow\npublic:\n    int n;\n    vector<vector<Edge> >G;//[MAX];\n    vi level,iter;//[MAX];\n    Dinic(int size){\n        n=size;\n        G=vector<vector<Edge> >(n);\n    }\n    void add_edge(int from, int to, int cap){\n        Edge q={to,cap,int(G[to].size())};\n        G[from].push_back(q);\n        q={from,0,int(G[from].size()-1)};\n        G[to].push_back(q);\n    }\n    int getmaxflow(int s,int t) {//from s to t,ford_fulkerson\n        int flow=0;\n        while(1){\n            bfs(s);\n            if(level[t]<0)return flow;\n            iter=vi(n);\n            int f;\n            while((f=dfs(s,t,INF))>0)flow+=f;\n        }\n    }\nprivate:\n    void bfs(int s){\n        level=vi(n,-1);\n        queue<int>q;\n        level[s]=0;\n        q.push(s);\n        while(!q.empty()){\n            int v=q.front();q.pop();\n            for(int i=0;i<G[v].size();i++){\n                Edge &e=G[v][i];\n                if(e.cap>0&&level[e.to]<0){\n                    level[e.to]=level[v]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t, int f) {\n        if(v==t)return f;\n        for(int &i=iter[v];i<G[v].size();i++){\n            Edge &e=G[v][i];\n            if(level[v]>=level[e.to]||e.cap<=0) continue;\n            int d =dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n};\n\nlong long gcd(long long a, long long b) {return b ? gcd(b, a % b) : a;}\nlong long lcm(long long m, long long n ){if((0 == m )||( 0 == n ))return 0;\n    return ((m / gcd(m, n)) * n);\n}\nsigned main(){\n    int a,b;\n    while(cin>>a>>b,a+b){\n        Dinic hoge(a+b+2);\n        int source=a+b;\n        int sink=a+b+1;\n        vector<int>v(a);\n        vector<int>u(b);\n        rep(i,a)cin>>v[i];\n        rep(j,b)cin>>u[j];\n        rep(i,a)hoge.add_edge(source,i, 1);\n        rep(i,b)hoge.add_edge(i+a,sink, 1);\n        rep(i,a)rep(j,b){\n            if(gcd(v[i],u[j])!=1)hoge.add_edge(i, j+a, 1);\n        }\n        cout<<hoge.getmaxflow(source, sink)<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#define int long long\n#define loop(i, a, b) for(int i = a; i < b; i++)\n#define rep(i, a) loop(i, 0, a)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\nconst int MOD = 1e9 + 7, INF = 1e9;\nusing vi = vector <int>;\nusing vvi = vector <vi>;\n//g++ -std==c++14 \n#define MAX_V (1100)\n\nstruct edge{int to, cap, rev; };\n\nvector <edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f){\n    if(v == t)return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n} \n\nint gcd(int a, int b){\n\treturn (b == 0 ? a : gcd(b, a % b));\n}\n\nsigned main(){\n    int m ,n;\n    while(cin >> m >> n, n){\n        int b[m], r[n];\n        rep(i, MAX_V){\n            G[i].clear();\n            used[i] = false;\n        }\n        rep(i, m)\n            cin >> b[i];\n        rep(i, n)\n            cin >> r[i];\n        rep(i, m)rep(j, n)\n            if(gcd(b[i], r[j]) != 1)\n                add_edge(i, j + m, 1);\n        rep(i, m)\n            add_edge(n + m, i, 1);\n        rep(i, n)\n            add_edge(m + i, n + m + 1, 1);\n        cout << max_flow(n + m, m + n + 1) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct Dinic {\n    int n, s, t;\n    vector<int> level, iter, que;\n    vector<vector<Capacity>> cap, flow;\n    vector<vector<int>> g;\n    Capacity inf;\n    Dinic(int n)\n        : n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n          g(n, vector<int>()), inf(numeric_limits<Capacity>::max()/8){}\n    Dinic(const Graph &graph){\n        *this = Dinic(graph.size());\n        rep(i,n) for(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n    }\n    void addEdge(int u, int v, Capacity c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    inline Capacity residue(int u, int v){ return cap[u][v] - flow[u][v]; }\n    Capacity solve(int s, int t){\n        this->t = t, this->s = s;\n        Capacity res = 0, aug = 1;\n        while(aug > 0){\n            levelize();\n            iter.assign(n, 0);\n            res += (aug = augment(s, inf));\n        }\n        return res;\n    }\n    void levelize(){\n        level.assign(n, inf); level[s] = 0;\n        int l = 0, r = 0;\n        que.assign(n+1, 0);\n        que[r++] = s;\n        while(l != r){\n            int v = que[l++];\n            for(const int &d : g[v]){\n                if(level[d] <= level[v] + 1 || residue(v,d) == 0) continue;\n                level[d] = level[v] + 1; que[r++] = d;\n            }\n        }\n    }\n    Capacity augment(int v, Capacity lim){\n        Capacity res = 0;\n        if(v == t) return lim;\n        for(int &i = iter[v]; i < (int)g[v].size(); i++){\n            const int &d = g[v][i];\n            if(residue(v,d) == 0 || level[v] + 1 != level[d]) continue;\n            const Capacity aug = augment(d, min(lim, residue(v,d)));\n            if(aug > 0){\n                flow[v][d] += aug; flow[d][v] -= aug;\n                res += aug; lim -= aug;\n                if(lim == 0) return res;\n            }\n        }\n        return res;\n    }\n};\n\nint dp[2000][2000];\nint gcd(int a, int b){\n    return a < 2000 && b < 2000 ? dp[a][b] : b == 0 ? a : gcd(b, a%b);\n}\n\n\nint main(){\n    rep(i,2000)rep(j,i+1) if(i*j) dp[i][j] = dp[j][i] = __gcd(i,j);\n    fastios();\n    int n,m;\n    while(cin >> n >> m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        Dinic d(n+m+2);\n        int s = n+m, t = n+m+1;\n        rep(i,m) d.addEdge(i+n,t,1);\n        rep(i,n){\n            d.addEdge(s,i,1);\n            rep(j,m) if(gcd(a[i],b[j]) != 1) d.addEdge(i,n+j,1);\n        }\n        rep(i,n)rep(j,m){\n            if(d.flow[i][j+n]) dump(i,j, d.flow[i][j+m]);\n        }\n        cout << d.solve(s,t) << endl;\n    }\n}\n\n// int main(){\n//     int N,M;\n//     cin >> N >> M;\n//     Graph g(N);\n//     rep(i,M){\n//         int a,b,c;\n//         cin >> a >> b >> c;\n//         g[a].emplace_back(a,b,c);\n//     }\n//     Dinic dinic(g);\n//     cout << dinic.solve(0,N-1) << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\ntemplate <i64 p>\nclass fp {\n    public:\n    i64 x;\n    fp() : x(0) {}\n    fp(i64 x_) : x((x_ % p + p) % p) {}\n    fp operator+() const { return fp(x); }\n    fp operator-() const { return fp(-x); }\n    fp& operator+=(const fp& y) {\n        x += y.x;\n        if (x >= p) x -= p;\n        return *this;\n    }\n    fp& operator-=(const fp& y) { return *this += -y; }\n    fp& operator*=(const fp& y) {\n        x = x * y.x % p;\n        return *this;\n    }\n    fp& operator/=(const fp& y) { return *this *= fp(inverse(y.x)); }\n    fp operator+(const fp& y) const { return fp(x) += y; }\n    fp operator-(const fp& y) const { return fp(x) -= y; }\n    fp operator*(const fp& y) const { return fp(x) *= y; }\n    fp operator/(const fp& y) const { return fp(x) /= y; }\n    bool operator==(const fp& y) const { return x == y.x; }\n    bool operator!=(const fp& y) const { return !(*this == y); }\n    i64 extgcd(i64 a, i64 b, i64& x, i64& y) {\n        i64 d = a;\n        if (b != 0) {\n            d = extgcd(b, a % b, y, x);\n            y -= (a / b) * x;\n        } else {\n            x = 1;\n            y = 0;\n        }\n        return d;\n    }\n    i64 inverse(i64 a) {\n        i64 x, y;\n        extgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n};\n\ntemplate <i64 p>\ni64 abs(const fp<p>& x) { return x.x; }\n\ntemplate <i64 p>\nistream& operator>>(istream& is, fp<p>& x) {\n    is >> x.x;\n    return is;\n}\n\ntemplate <i64 p>\nostream& operator<<(ostream& os, const fp<p>& x) {\n    os << x.x;\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    os << \"[\";\n    for (const auto& v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename A, typename T, size_t size>\nvoid fill(A (&ary)[size], const T& val) {\n    fill((T*)ary, (T*)(ary + size), val);\n}\n\nconstexpr int inf = 1.01e9;\nconstexpr i64 inf64 = 4.01e18;\nconstexpr long double eps = 1e-9;\n\n// double(64bit浮動小数)のn分探索のループ回数の上限(2分探索なら50でも十分かもしれない). long double(80ビットの x87 浮動小数点型?)だと, 2分探索であってもこれだと足りないケースがある気がするので, もうちょっと余裕を持たせた方が良さそう.\nconstexpr i64 max_loop = 100;\n\n\nstruct max_flow {\n    struct edge {\n        int to;\n        i64 cap, rev;\n    };\n    vector<vector<edge>> graph;\n    vector<bool> done;\n    max_flow(int size) : graph(size), done(size) {}\n    void add_edge(int from, int to, i64 cap) {\n        graph[from].push_back(edge{to, cap, (int)graph[to].size()});\n        graph[to].push_back(edge{from, 0, (int)graph[from].size() - 1});\n    }\n    i64 dfs(int v, int t, i64 f) {\n        if (v == t) return f;\n        done[v] = true;\n        for (auto &e : graph[v]) {\n            if (done[e.to] or e.cap <= 0) continue;\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                graph[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n        return 0;\n    }\n    i64 calc_max_flow(int s, int t) {\n        i64 flow = 0;\n        while (true) {\n            fill(done.begin(), done.end(), false);\n            i64 f = dfs(s, t, inf);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nstruct bipartite_matching {\n    i64 l, r;\n    i64 s, t;\n    max_flow mf;\n    bipartite_matching(i64 l /* 左側の頂点数 */, i64 r /* 右側の頂点数 */) : l(l), r(r), mf(l + r + 2), s(l + r), t(l + r + 1) {\n        rep(i, 0, l) mf.add_edge(s, i, 1);\n        rep(i, 0, r) mf.add_edge(i + l, t, 1);\n    }\n\n    void add_edge(i64 u, i64 v) {\n        mf.add_edge(u, v + l, 1);\n    }\n\n    i64 max_matching() {\n        return mf.calc_max_flow(s, t);\n    }\n};\n\ni64 gcd(i64 a, i64 b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nvoid solve(i64 m,i64 n) {\n    //constexpr i64 mod = 1'000'000'007;\n\n    vector<i64> b(m),r(n);\n    rep(i,0,m) cin >> b[i];\n    rep(i,0,n) cin >> r[i];\n\n    bipartite_matching bm(m,n);\n    rep(i,0,m){\n        rep(j,0,n){\n            if(gcd(b[i],r[j])>1) bm.add_edge(i,j);\n        }\n    }\n\n    cout << bm.max_matching() << endl;\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    for(;;){\n        i64 m,n;\n        cin >> m >> n;\n        if(m==0 and n==0) break;\n        solve(m,n);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint m, n;\nint P[510];\nbool V[510], C[510][510];\n\nint gcd(int a, int b){\n  if(a < b) swap(a, b);\n  if(b == 0) return a;\n  return gcd(b, a % b);\n}\n\nbool match(int b){\n  if(b < 0) return true;\n  for(int i=0; i<n; ++i){\n    if(!C[b][i] || V[i]) continue;\n    V[i] = true;\n    if(match(P[i])) {\n      P[i] = b;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int blue[510], red[510];\n  //  cout << gcd(6, 15);\n  while(cin >> m >> n){\n    if(!m) return 0;\n    for(int i=0; i<m; ++i){\n      cin >> blue[i];\n    }\n    for(int i=0; i<n; ++i){\n      cin >> red[i];\n      P[i] = -1;\n    }\n\n    for(int i=0; i<m; ++i){\n      for(int j=0; j<n; ++j){\n\tC[i][j] = (gcd(blue[i], red[j]) >= 2);\n\t//\tcout << C[i][j] << \" \";\n      }\n      // cout << endl;\n    }\n\n    int count = 0;\n\n    for(int i=0; i<m; ++i){\n      for(int j=0; j<n; ++j){\n\tV[j] = 0;\n      }\n      if(match(i)) count++;\n      for(int i=0; i<n; ++i){\n\t//cout << P[i] << \" \";\n      }\n      // cout << endl;\n    }\n    cout << count << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing ull=unsigned long long;\nusing uint=unsigned int;\nusing pcc=pair<char,char>;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing pdd=pair<double,double>;\nusing tuplis=pair<ll,pll>;\nusing tuplis2=pair<pll,ll>;\ntemplate<class T> using pq=priority_queue<T,vector<T>,greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst int INF=0x3fffffff;\nconst ll MOD=1000000007;\nconst ll MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst vector<ll>four{0,1,0,-1,0};\n#define _overload4(_1,_2,_3,_4,name,...) name\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep1(n) for(ll i=0;i<n;++i)\n#define _rep2(i,n) for(ll i=0;i<n;++i)\n#define _rep3(i,a,b) for(ll i=a;i<b;++i)\n#define _rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) _overload4(__VA_ARGS__,_rep4,_rep3,_rep2,_rep1)(__VA_ARGS__)\n#define _rrep1(n) for(ll i=n-1;i>=0;i--)\n#define _rrep2(i,n) for(ll i=n-1;i>=0;i--)\n#define _rrep3(i,a,b) for(ll i=b-1;i>=a;i--)\n#define _rrep4(i,a,b,c) for(ll i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rrep(...) _overload4(__VA_ARGS__,_rrep4,_rrep3,_rrep2,_rrep1)(__VA_ARGS__)\n#define each(i,a) for(auto &i:a)\n#define sum(...) accumulate(range(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(range(__VA_ARGS__),double(0))\n#define _range(i) (i).begin(),(i).end()\n#define _range2(i,k) (i).begin(),(i).begin()+k\n#define _range3(i,a,b) (i).begin()+a,(i).begin()+b\n#define range(...) _overload3(__VA_ARGS__,_range3,_range2,_range)(__VA_ARGS__)\n#define _rrange(i) (i).rbegin(),(i).rend()\n#define _rrange2(i,k) (i).rbegin(),(i).rbegin()+k\n#define _rrange3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rrange(...) _overload3(__VA_ARGS__,_rrange3,_rrange2,_rrange)(__VA_ARGS__)\n#define elif else if\n#define unless(a) if(!(a))\n#define mp make_pair\n#define mt make_tuple\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define vec(type,name,...) vector<type> name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type> name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ninline constexpr ll gcd(ll a,ll b){if(!a||!b)return 0;while(b){ll c=b;b=a%b;a=c;}return a;}\ninline constexpr ll lcm(ll a,ll b){if(!a||!b)return 0;return a*b/gcd(a,b);}\ntemplate<class T> inline constexpr T min(vector<T> &v){return *min_element(range(v));}\ninline char min(string &v){return *min_element(range(v));}\ntemplate<class T> inline constexpr T max(vector<T> &v){return *max_element(range(v));}\ninline char max(string &v){return *max_element(range(v));}\ninline constexpr ll intpow(ll a,ll b){ll ans=1;for(ll i=1;b;i*=2){if(b&i){b^=i;ans*=a;}a*=a;}return ans;}\ninline constexpr ll modpow(ll a,ll b,ll mod = MOD){ll ans=1;for(ll i=1;b;i*=2){if(b&i){b^=i;ans*=a;ans%=mod;}a*=a;a%=mod;}return ans;}\ntemplate<typename T>\ninline constexpr bool update_min(T &mn,const T &cnt){if(mn>cnt){mn=cnt;return 1;}else return 0;}\ntemplate<typename T>\ninline constexpr bool update_max(T &mx,const T &cnt){if(mx<cnt){mx=cnt;return 1;}else return 0;}\ninline int scan(){ return getchar(); }\ninline void scan(int &a){ scanf(\"%d\", &a); }\ninline void scan(unsigned &a){ scanf(\"%u\", &a); }\ninline void scan(long &a){ scanf(\"%ld\", &a); }\ninline void scan(long long &a){ scanf(\"%lld\", &a); }\ninline void scan(unsigned long long &a){ scanf(\"%llu\", &a); }\ninline void scan(char &a){ cin >> a; }\ninline void scan(float &a){ scanf(\"%f\", &a); }\ninline void scan(double &a){ scanf(\"%lf\", &a); }\ninline void scan(long double &a){ scanf(\"%Lf\", &a); }\ninline void scan(vector<bool> &vec){ for(unsigned i = 0; i < vec.size(); i++) { int a; scan(a); vec[i] = a; } }\ninline void scan(string &a){ cin >> a; }\ntemplate<class T> inline void scan(vector<T> &vec);\ntemplate<class T, size_t size> inline void scan(array<T, size> &vec);\ntemplate<class T, class L> inline void scan(pair<T, L> &p);\ntemplate<class T, size_t size> inline void scan(T (&vec)[size]);\ntemplate<class T> inline void scan(vector<T> &vec){ for(auto &i : vec) scan(i); }\ntemplate<class T, size_t size> inline void scan(array<T, size> &vec){ for(auto &i : vec) scan(i); }\ntemplate<class T, class L> inline void scan(pair<T, L> &p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> inline void scan(T (&vec)[size]){ for(auto &i : vec) scan(i); }\ntemplate<class T> inline void scan(T &a){ cin>>a; }\ninline void in(){}\ntemplate <class Head, class... Tail> inline void in(Head &head, Tail&... tail){ scan(head); in(tail...); }\ninline void print(){ putchar('\\n'); }\ninline void print(const bool &a){ printf(\"%d\", a); }\ninline void print(const int &a){ printf(\"%d\", a); }\ninline void print(const unsigned &a){ printf(\"%u\", a); }\ninline void print(const long &a){ printf(\"%ld\", a); }\ninline void print(const long long &a){ printf(\"%lld\", a); }\ninline void print(const unsigned long long &a){ printf(\"%llu\", a); }\ninline void print(const char &a){ printf(\"%c\", a); }\ninline void print(const char a[]){ printf(\"%s\", a); }\ninline void print(const float &a){ printf(\"%.10f\", a); }\ninline void print(const double &a){ printf(\"%.10f\", a); }\ninline void print(const long double &a){ printf(\"%.10Lf\", a); }\ntemplate<class T> void print(const vector<T> &vec);\ntemplate<class T, size_t size> void print(const array<T, size> &vec);\ntemplate<class T, class L> void print(const pair<T, L> &p);\ntemplate<class T, size_t size> inline void print(const T (&vec)[size]);\ntemplate<class T> void print(const vector<T> &vec){ print(vec[0]); for(auto i = vec.begin(); ++i != vec.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size> &vec){ print(vec[0]); for(auto i = vec.begin(); ++i != vec.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L> &p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> inline void print(const T (&vec)[size]){ print(vec[0]); for(auto i = vec; ++i != end(vec); ){ putchar(' '); print(*i); } }\ntemplate<class T> inline void print(const T &a){ cout << a; }\ninline int out(){ putchar('\\n'); return 0; }\ntemplate<class T> inline int out(const T &t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> inline int out(const Head &head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\ntemplate <class T> inline void err(T t){cerr<<t<<'\\n';}\ninline void err(){cerr<<'\\n';}\ninline int yes(const bool &i){return out(i?\"yes\":\"no\");}\ninline int Yes(const bool &i){return out(i?\"Yes\":\"No\");}\ninline int YES(const bool &i){return out(i?\"YES\":\"NO\");}\ninline int Yay(const bool &i){return out(i?\"Yay!\":\":(\");}\ninline int Possible(const bool &i){return out(i?\"Possible\":\"Impossible\");}\ninline int POSSIBLE(const bool &i){return out(i?\"POSSIBLE\":\"IMPOSSIBLE\");}\ninline void Case(ll i){printf(\"Case #%lld: \",i);}\n\n\n\nstruct Dinic{\n    struct edge{ll to;ll cap;ull rev;};\n    ll n;\n    vector<vector<edge>>g;\n    vector<ll>rank,visit;\n    Dinic(ll size):n(size),g(size){}\n    void add(ll from,ll to,ll cap){\n        g[from].push_back({to,cap,g[to].size()});\n        g[to].push_back({from,0,g[from].size()-1});\n    }\n    ll bfs(ll from,ll to){\n        rank.assign(n,LINF);\n        queue<ll>q;\n        rank[from]=0;\n        q.push(from);\n        while(q.size()){\n            ll at=q.front();\n            if(at==to)return rank[to];\n            q.pop();\n            each(i,g[at])if(i.cap)if(update_min(rank[i.to],rank[at]+1))q.push(i.to);\n        }\n        return rank[to];\n    }\n    ll dfs(ll from,ll to,ll mn){\n        if(from==to)return mn;\n        each(i,g[from])if(rank[from]+1==rank[i.to]&&i.cap){\n            ll a=dfs(i.to,to,min(mn,i.cap));\n            if(a){\n                i.cap-=a;\n                g[i.to][i.rev].cap+=a;\n                return a;\n            }\n        }\n        return 0;\n    }\n    ll flow(ll from,ll to){\n        ll ans=0;\n        while(bfs(from,to)!=LINF){\n            visit.assign(n,0);\n            ll a=dfs(from,to,LINF);\n            while(a){\n                ans+=a;\n                a=dfs(from,to,LINF);\n            }\n        }\n        return ans;\n    }\n};\nint main(){\n    LL(n,m);\n    while(n){\n        VEC(ll,a,n);\n        VEC(ll,b,m);\n        Dinic g(n+m+2);\n        rep(n)rep(j,m)if(gcd(a[i],b[j])!=1)g.add(i,n+j,1);\n        rep(n)g.add(n+m,i,1);\n        rep(j,m)g.add(n+j,n+m+1,1);\n        out(g.flow(n+m,n+m+1));\n        in(n,m);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[aa]; if (aa != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)(´・ω・`)///\n\nstruct Edge { int to, cap, rev, cost; };\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct MaxFlow {\n\tGraph G;\n\tvi level, iter;\n\tMaxFlow(Graph g) {\n\t\tint n = g.size();\n\t\tlevel.resize(n);\n\t\titer.resize(n);\n\t\tG = g;\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(Edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(Edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\n\tvoid bfs(int s) {\n\t\tfill(ALL(level), -1);\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tEdge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tEdge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(ALL(iter), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nint gcd(int a, int b) {\n\tif (b == 0)return a;\n\treturn gcd(b, a%b);\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint m, n;\n\twhile (cin >> m >> n,m) {\n\t\tvi b(m), r(n);\n\t\tREP(i, m) {\n\t\t\tcin >> b[i];\n\t\t}\n\t\tREP(i, n) {\n\t\t\tcin >> r[i];\n\t\t}\n\t\tGraph g(n + m + 2);\n\t\tMaxFlow f(g);\n\t\tREP(i, m) {\n\t\t\tREP(j, n) {\n\t\t\t\tif (gcd(b[i], r[j]) != 1) {\n\t\t\t\t\tf.add_edge(i + 1, j + m + 1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, m) {\n\t\t\tf.add_edge(0, i + 1, 1);\n\t\t}\n\t\tREP(i, n) {\n\t\t\tf.add_edge(i + m + 1, m + n + 1, 1);\n\t\t}\n\t\tcout << f.max_flow(0, m + n + 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define repl(i,l,r) for(ll i=(l);i<(r);i++)\n#define per(i,n) for(ll i=n-1;i>=0;i--)\n#define perl(i,r,l) for(ll i=r-1;i>=l;i--)\n#define fi first\n#define se second\n#define pb push_back\n#define ins insert\n#define pqueue(x) priority_queue<x,vector<x>,greater<x>>\n#define all(x) (x).begin(),(x).end()\n#define CST(x) cout<<fixed<<setprecision(x)\n#define vtpl(x,y,z) vector<tuple<x,y,z>>\n#define rev(x) reverse(x);\nusing ll=long long;\nusing vl=vector<ll>;\nusing vvl=vector<vector<ll>>;\nusing pl=pair<ll,ll>;\nusing vpl=vector<pl>;\nusing vvpl=vector<vpl>;\nconst ll MOD=1000000007;\nconst ll MOD9=998244353;\nconst int inf=1e9+10;\nconst ll INF=4e18;\nconst ll dy[8]={1,0,-1,0,1,1,-1,-1};\nconst ll dx[8]={0,-1,0,1,1,-1,1,-1};\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n} \n\n \nstruct Dinic {\n  struct edge {\n    int to, cap, rever;\n    edge(int to, int cap, int rever):to(to), cap(cap), rever(rever){}\n  };\n  vector< vector<edge> > graph;\n  vector<int> level, iter;\n  Dinic(int V):graph(V), level(V), iter(V){}\n  void add_edge(int from, int to, int cap) {\n    graph[from].emplace_back(to, cap, graph[to].size());\n    graph[to].emplace_back(from, 0, graph[from].size()-1);\n  }\n  void bfs(int s) {\n    fill(all(level), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(0);\n    while(que.size()) {\n      int v = que.front(); que.pop();\n      for(edge& e : graph[v]) {\n        if(e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  int dfs(int v, int t, int f) {\n    if(v == t) return f;\n    for(int& i = iter[v]; i < graph[v].size(); i++) {\n      edge& e = graph[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n        int d = dfs(e.to, t, min(e.cap, f));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rever].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t) {\n    int flow = 0;\n    while(true) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      fill(all(iter), 0);\n      int f; while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n}; \n\nint main(){\n    while(true){\n    ll m,n;cin >>m>> n;if(m==0&&n==0)break;\n    Dinic dn(m+n+2);\n    ll s=0,t=m+n+1;\n    vl a(m),b(n);\n    rep(i,m){\n        cin  >> a[i];\n    }\n    rep(i,n){\n        cin  >> b[i];\n    }\n    rep(i,m){\n        dn.add_edge(s,i+1,1);\n    }\n    rep(i,n){\n        dn.add_edge(m+i+1,t,1);\n    }\n    rep(i,m){\n        rep(j,n){\n            if(__gcd(a[i],b[j])!=1){\n                dn.add_edge(i+1,m+1+j,1);\n            }\n        }\n    }\n    cout << dn.max_flow(s,t) <<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\nconst int INF = 1e9;\nconst int MAX_V = 300;\n\nint m, n;\nstruct Flow{\n    struct edge{\n        int to, cap, rev;\n    };\n    vector<edge> G[MAX_V];//??£??\\?????????\n    bool used[MAX_V];\n\n    void add_edge(int from, int to, int cap){\n        G[from].push_back((edge){to, cap, (int)G[to].size()});//from -> to\n        G[to].push_back((edge){from, 0, (int)G[from].size() - 1});//to -> from\n    }\n\n    //?¢???????????????¢???\n    int dfs(int v, int t, int f){\n        if(v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); ++i){\n            edge &e = G[v][i];\n            if(!used[e.to] && e.cap > 0){\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    //s??????t???????????§???\n    int max_flow(int s, int t){\n        int flow = 0;\n        while(1){\n            memset(used, 0, sizeof(used));\n            int f = dfs(s, t, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nint b[510], r[510];\nint main(void){\n\twhile(1){\n        cin >> m >> n;\n        if(m == 0 && n == 0) return 0;\n        rep(i, m) cin >> b[i];\n        rep(i, n) cin >> r[i];\n        int s = m + n, t = m + n + 1;\n        Flow mf;\n        //s -> b\n        rep(i, m){\n            mf.add_edge(s, i, 1);\n        }\n        //r -> t\n        rep(i, n){\n            mf.add_edge(m + i, t, 1);\n        }\n        //b -> r\n        rep(i, m)rep(j, n){\n            if(__gcd(b[i], r[j]) > 1){//1??\\???????´???°?????????\n                mf.add_edge(i, m + j, 1);\n            }\n        }\n        printf(\"%d\\n\", mf.max_flow(s, t));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int Int;\n\n// math\nInt gcd(Int a, Int b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\nInt lcm(Int a, Int b) {\n  return a * b / gcd(a, b);\n}\n// a x + b y = gcd(a, b)\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n  Int g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\n// Graph\ntypedef Int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\n// bipartite matching\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u], 0) );\n  return match;\n}\n\n\nint main() {\n    int m, n;\n    while ( cin >> m >> n ) {\n        if ( m == 0 && n == 0 ) break;\n\n        int B[501];\n        int R[501];\n        for ( int i = 0; i < m; i++ ) cin >> B[i];\n        for ( int i = 0; i < n; i++ ) cin >> R[i];\n        \n        Graph g(m+n);\n        for ( int i = 0; i < m; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( gcd( B[i], R[j] ) > 1 ) {\n                    g[i].push_back( Edge( i, m+j, 0 ) );\n                }\n            }\n        }\n\n        Edges edges;\n        cout << bipartiteMatching( g, m, edges ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <cstdio>\n#include <stack>\n\nusing namespace std;\n\nint gcd(int m, int n) {\n    if(m < n) return gcd(n, m);\n    while(n != 0) {\n        int tmp = m % n;\n        m = n;\n        n = tmp;\n    }\n    return m;\n}\n\n//flow_vÍÚ±zñ\n//pairÍ<s«æ, RXg>\nint maxflow(const vector<vector<pair<int, int> > > &flow_v, int s, int g) {\n    int size = flow_v.size();\n    //×ÚsñÉÏ·\n    //Å©ç×ÚsñnµÈç±±Í¢çÈ¢\n    /*****½¾µAtûüÉÌRXgªüÁÄ¢é©ÍvmF*****/\n    vector<vector<int> > capacity(size, vector<int>(size, 0));\n    for(int i = 0; i < size; ++i) {\n        for(int j = 0; j < flow_v[i].size(); ++j) {\n            int to = flow_v[i][j].first;\n            int cost = flow_v[i][j].second;\n            capacity[i][to] = cost;\n        }\n    }\n    vector<vector<int> > flow(size, vector<int>(size, 0));\n\n    int ans = 0;\n    while(true) {\n        //DæTõÅaugument flowðÝÂ¯é\n        queue<int> q;\n        vector<int> prev(size, -1);\n        prev[s] = s;\n        q.push(s);\n        while(!q.empty()) {\n            int n = q.front();\n            q.pop();\n            for(int i = 0; i < size; ++i) {\n                if(capacity[n][i]-flow[n][i] <= 0) continue;\n                if(prev[i] != -1) continue;\n                prev[i] = n;\n                q.push(i);\n                if(i == g) goto endloop;\n            }\n        }\nendloop:\n        if(prev[g] == -1) break;\n        int res = INT_MAX;\n        for(int i = g; prev[i] != i; i = prev[i]) {\n            res = min(res, capacity[prev[i]][i]-flow[prev[i]][i]);\n        }\n        for(int i = g; prev[i] != i; i = prev[i]) {\n            flow[prev[i]][i] += res;\n            flow[i][prev[i]] -= res;\n        }\n        ans += res;\n    }\n    return ans;\n}\n\n//E¶©çt[ª¬êÄ­é½ßAE©ç¶Ös­ÌÍùÉ¶ÝµÄ¢ét[Ìt¬ÌÝ\n//EæÁÄAE©ç¶ÖsÁÄA»±ÅtrueÅ~Üé±ÆÍ è¾È¢\n//@i¶¸_ÍEÖÌmatchToª èA©Â»¿çÖÍißÈ¢ÌÅK¸falseÉÈéj\n//E±ÌASYÅÍA\n//@nF¶¸_\n//@g[n][i]FE¸_\n//@matchTo[g[n][i]]F¶¸_or-1\n//@ª¬§µÄ¢é\nbool bm_helper(const vector<vector<int> > &g, vector<int> &matchTo, int n, vector<bool> &used) {\n    if(n == -1) return true;\n\n    for(int i = 0; i < g[n].size(); ++i) {\n        if(used[g[n][i]]) continue;\n        //Ç¤¹±Ì¸_ÉßÁÄ«Äàaugment pathÍ©Â©éí¯È¢ÌÅ³µÈ­Äæ¢\n        used[g[n][i]] = true;\n        if(bm_helper(g, matchTo, matchTo[g[n][i]], used)) {\n            matchTo[n] = g[n][i];\n            matchTo[g[n][i]] = n;\n            return true;\n        }\n    }\n    return false;\n}\n\n//gÍÚ±zñiN«¾µAz¢ÝÍ¢çÈ¢j\n//LÍ}b`OÌ¶¤¸_Ì«EiL¢ª¶¤j\nint bipartiteMatch(const vector<vector<int> > &g, int L) {\n    int size = g.size();\n    vector<int> match(size, -1);\n    //[³DæÅaugment pathð©Â¯é\n    //Ford FurlkersonÌASYB\n    //êñÌ¸ÅK¸t[ª1Í¦é½ßA\n    //¶¤ðSÄÈßs­µ½ ÆÍðÉÈÁÄ¢é\n    int cnt = 0;\n    for(int i = 0; i < L; ++i) {\n        vector<bool> used(g.size(), false);\n        if(bm_helper(g, match, i, used)) ++cnt; //augment pathª©Â©é->t[ª1¦é\n    }\n    return cnt;\n}\n\nint main() {\n    while(true) {\n        int m, n;\n        cin >> m >> n;\n        if(!m && !n) break;\n\n        vector<int> cards(m+n);\n        //vector<vector<pair<int, int> > > graph(m+n+2);\n        vector<vector<int> > graph(m+n);\n        //For maxflow\n        /*\n        for(int i = 0; i < m; ++i) {\n            //cin >> cards[i];\n            scanf(\"%d\", &cards[i]);\n            graph[m+n].push_back(make_pair(i, 1)); //Start node\n        }\n        for(int i = m; i < m+n; ++i) {\n            scanf(\"%d\", &cards[i]);\n            for(int j = 0; j < m; ++j) {\n                if(gcd(cards[i], cards[j]) > 1) {\n                    graph[j].push_back(make_pair(i, 1));\n                }\n            }\n            graph[i].push_back(make_pair(m+n+1, 1)); //Goal node\n        }\n        cout << maxflow(graph, m+n, m+n+1) << endl;\n        */\n    \n        //For bipartiteMatch\n        for(int i = 0; i < m; ++i) {\n            scanf(\"%d\", &cards[i]);\n        }\n        for(int i = m; i < m+n; ++i) {\n            scanf(\"%d\", &cards[i]);\n            for(int j = 0; j < m; ++j) {\n                if(gcd(cards[i], cards[j]) > 1) {\n                    graph[j].push_back(i);\n                }\n            }\n        }\n        cout << bipartiteMatch(graph, m) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstatic const int MAX_N = 1000;\n\nint N, M;\nvector<int> G[MAX_N];\nint match[MAX_N];\nbool used[MAX_N];\n\nvoid add_edge(int u, int v){\n  G[u].push_back(v);\n}\n \nbool dfs(int v){\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); i++){\n    int u = G[v][i], w = match[u];\n    if(w < 0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n \nint bipartite_matching(){\n  int res = 0;\n  fill(match, match + N + M, -1);\n  for(int v = 0; v < N + M; v++){\n    if(match[v] < 0){\n      fill(used, used + N + M, 0);\n      if(dfs(v)){\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\nint gcd(int a, int b){\n  if(b == 0) return a;\n  else return gcd(b, a % b);\n}\n \nint main(){\n  for(;;){\n    cin >> N >> M;\n    if(N == 0 && M == 0) break;\n    int b[500], r[500];\n    for(int i = 0; i < N; i++) cin >> b[i];\n    for(int i = 0; i < M; i++) cin >> r[i];\n    for(int i = 0; i < N; i++){\n      for(int j = 0; j < M; j++){\n        if(gcd(b[i], r[j]) > 1){\n          add_edge(i, j + N);\n          add_edge(j + N, i);\n        }\n      }\n    }\n    cout << bipartite_matching() << endl;\n    for(int i = 0; i < N + M; i++) G[i].clear();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\nint const inf = 1<<29;\n\nstruct MCF {\n    typedef int Weight;\n    typedef int Capacity;\n    struct Edge;\n    int n;\n    vector<vector<Edge> > g;\n    vector<int> level, iter;\n\n    struct Edge {\n        int dst;\n        Capacity cap, cap_orig;\n        int revEdge;\n        bool isRev;\n        Edge(int dst, Capacity cap, int revEdge, bool isRev)\n        :dst(dst), cap(cap), cap_orig(cap), revEdge(revEdge), isRev(isRev) {}\n    };\n\n    MCF(int n_)\n    : n(n_), g(vector<vector<Edge> >(n_)), level(n_), iter(n_) {}\n\n    void add_edge(int src, int dst, Capacity cap) {\n        g[src].emplace_back(Edge(dst, cap, g[dst].size(), false));\n        g[dst].emplace_back(Edge(src, 0, g[src].size() - 1, true));\n    }\n\n    void bfs(int s) {\n        fill(all(level), -1);\n        queue<Weight> q;\n        level[s] = 0;\n        q.emplace(s);\n        while (q.size()) {\n            int v = q.front(); q.pop();\n            for(int i = 0; i < (int)g[v].size(); i++){\n                Edge& e = g[v][i];\n                if (e.cap > 0 && level[e.dst] < 0) {\n                    level[e.dst] = level[v] + 1;\n                    q.emplace(e.dst);\n                }\n            }\n        }\n    }\n\n    Capacity dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < (int)g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (e.cap > 0 && level[v] < level[e.dst]) {\n                int d = dfs(e.dst, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.dst][e.revEdge].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    // src->dstへの最大フローを流す\n    Capacity max_flow(int src, int dst) {\n        int flow = 0;\n        while(1){\n            bfs(src);\n            if (level[dst] < 0) return flow;\n            fill(all(iter), 0);\n            int f;\n            while ((f = dfs(src, dst, inf)) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n\nint main(){\n    int n,m;\n    while(cin>>n>>m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n)cin>>a[i];\n        rep(i,m)cin>>b[i];\n        MCF mcf(n+m+2);\n        int s=n+m, t=n+m+1;\n        rep(i,m)mcf.add_edge(i+n,t,1);\n        rep(i,n){\n            mcf.add_edge(s,i,1);\n            rep(j,m)if(__gcd(a[i],b[j])!=1)mcf.add_edge(i,n+j,1);\n        }\n        cout << mcf.max_flow(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-14;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\n\nconst int VMAX = 1024;\nstruct edge { int to, cap, rev; };\nvector<edge> G[VMAX];\nbool used[VMAX];\n\nvoid add_edge(int from, int to, int cap) {\n  G[from].push_back((edge){to, cap, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n  if (v == t) return f;\n  used[v] = true;\n  for (int i = 0; i < (int)G[v].size(); i++) {\n    edge &e = G[v][i];\n    if (!used[e.to] and e.cap > 0) {\n      int d = dfs(e.to, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t) {\n  int flow = 0;\n  while (true) {\n    memset(used, 0, sizeof(used));\n    int f = dfs(s, t, INF);\n    if (f == 0) return flow;\n    flow += f;\n  }\n}\n\nint gcd(int x, int y) {\n  return (y == 0 ? x : gcd(y, x % y));\n}\n\nint main() {\n  const int SOURCE = VMAX - 2, SINK = VMAX - 1;\n  int m, n;\n  while (cin >> m >> n and m) {\n    REP(i, VMAX) { \n      G[i].clear(); \n      used[i] = false;\n    }\n    vector<int> b_(m), r_(n);\n    REP(i, m) { \n      cin >> b_[i]; \n      add_edge(SOURCE, i, 1);\n    }\n    REP(j, n) { \n      cin >> r_[j];\n      add_edge(m + j, SINK, 1);\n    }\n    REP(i, m) REP(j, n) {\n      if (gcd(b_[i], r_[j]) > 1) { add_edge(i, m + j, 1); }\n    }\n\n    cout << max_flow(SOURCE, SINK) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\ntypedef unsigned long long ull;\nusing namespace std;\n#define pb push_back\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\n#define MAX_N 500\n#define MAX_K 500\n#define MAX_V 1002\n#define INF 1000000000\n\nstruct edge { int to, cap, rev; };\nvector<edge> G[MAX_V]; // ??°???????????£??\\???????????¨???\nint V;\nint level[MAX_V]; // s??????????????¢\nint iter[MAX_V]; // ???????????§??????????????£??????\n// from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n// s????????????????????¢???BFS??§?¨??????????\nvoid bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        int v = que.front(); que.pop();\n        for (int i = 0; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n// ?¢?????????????DFS??§??¢???\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    for (int &i = iter[v]; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n\n        }\n    }\n    return 0;\n}\n// s??????t???????????§???????±???????\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        int f;\n        while ((f = dfs(s, t, INF)) > 0) {\n            flow += f;\n        }\n    }\n}\nvoid resetG(int ver){\n    V = ver;\n    REP(i,V)\n        G[i].clear();\n}\n\nint N, K;\nbool can[MAX_N][MAX_K];\nvoid solve() {\n    int s = N + K, t = s + 1;\n    for (int i = 0; i < N; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < K; i++) {\n        add_edge(N + i, t, 1);\n    }\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < K; j++) {\n            if (can[i][j]) {\n                add_edge(i, N + j, 1);\n            }\n        }\n    }\n    printf(\"%d\\n\",max_flow(s,t));\n}\n\nint gcd(int a,int b){\n    if(a < b){\n        int c = a;\n        a = b;\n        b = c;\n    }\n    if(a % b == 0)\n        return b;\n    return gcd(b,a % b);\n}\n\nint inb[500],inr[500];\n\nbool input(){\n    scanf(\"%d%d\",&N,&K);\n    if(N == 0 && K == 0)\n        return false;\n    REP(i,N)\n        scanf(\"%d\",&inb[i]);\n    REP(i,K)\n        scanf(\"%d\",&inr[i]);\n\n    memset(can,false,sizeof(can));\n    REP(i,N){\n        REP(j,K){\n            if(gcd(inb[i],inr[j]) > 1)\n                can[i][j] = true;\n        }\n    }\n    resetG(N + K + 2);\n    return true;\n}\n\nint main(){\n    while(input()){\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\n\nstruct edge{\n\tint to,co,p;\n};\n\nvector<edge> vs[1005];\n\nvoid cleae(){\n\trep(i,1005)vs[i].clear();\n}\n\nvoid adde(int a,int b,int c){\n\t//printf(\"fr %d to %d co %d\\n\",a,b,c);\n\tint sa=vs[a].size(),\n\t\tsb=vs[b].size();\n\tedge e; \n\te.co=c; e.to=b; e.p=sb; vs[a].push_back(e);\n\te.co=0; e.to=a; e.p=sa; vs[b].push_back(e);\n}\n\nint st,gl;\nint gone[1005];\nint dfs(int no,int f){\n\tif(gone[no])return 0;\n\tgone[no]=1;\n\tif(no==gl)return f;\n\trep(i,vs[no].size()){\n\t\tedge& e=vs[no][i];\n\t\tif(gone[e.to])continue;\n\t\tif(e.co>0){\n\t\t\tint gf = dfs(e.to,min(e.co,f));\n\t\t\tif(gf>0){\n\t\t\t\te.co-=gf;\n\t\t\t\tvs[e.to][e.p].co+=gf;\n\t\t\t\treturn gf;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(){\n\tint res=0;\n\tfor(;;){\n\t\tmemset(gone,0,sizeof(gone));\n\t\tint f = dfs(st,IINF);\n\t\tif(f==0)return res;\n\t\tres+=f;\n\t}\n}\n\nint na,nb;\nint da[505];\nint db[505];\nint gcd(int p,int q){\n\tif(p<q)swap(p,q);\n\tif(p%q==0)return q;\n\treturn gcd(q,p%q);\n}\n\nint main(void){\n\tfor(;;){\n\t\tscanf(\"%d%d\",&na,&nb);\n\t\tif(na==0)break;\n\t\trep(i,na)scanf(\"%d\",&da[i]);\n\t\trep(i,nb)scanf(\"%d\",&db[i]);\n\t\tcleae();\n\t\t\n\t\tst=0;\n\t\tgl=na+nb+1;\n\t\trep(i,na)adde(st,i+1,1);\n\t\trep(i,nb)adde(i+na+1,gl,1);\n\t\t\n\t\trep(i,na)rep(j,nb){\n\t\t\tif(gcd(da[i],db[j])>1)adde(i+1,j+na+1,1);\n\t\t}\n\t\tprintf(\"%d\\n\",flow());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n//typedef long long Int;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst) : src(src),dst(dst) {}\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) {}\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vec<Edge> Edges;\ntypedef vec<Edges> Graph;\n\n#define MAXMN 500\nint B[MAXMN];\nint R[MAXMN];\n\nint gcd(int a, int b)\n{   \n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  return match;\n}\n\n\nmain() {\n  int M,N;\n  Graph g; g.reserve(MAXMN+MAXMN);\n  while(cin>>M>>N,M) {\n    g.clear();\n    g.resize(M+N);\n    REP(i,M) cin>>B[i];\n    REP(i,N) cin>>R[i];\n    REP(i,M) {\n      Edges es, es2;\n      REP(j,N) {\n\tif(gcd(B[i],R[j])!=1) { es.pb(Edge(i,M+j)); es2.pb(Edge(M+j,i)); }\n      }\n      g[i] = es;\n      g[M+i] = es2;\n    }\n    cout << bipartiteMatching(g,M) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nstruct edge {\n\tint to;\n\tll cost;\n\tedge(int to, ll cost = 1) :to(to), cost(cost) {}\n};\nbool bipartite_matching_dfs(int v, vector<vector<edge>> &G, vector<int> &match, vector<bool> &used) {\n\tused[v] = true;\n\tfor (edge e : G[v]) {\n\t\tint w = match[e.to];\n\t\tif (w < 0 || !used[w] && bipartite_matching_dfs(w, G, match, used)) {\n\t\t\tmatch[v] = e.to;\n\t\t\tmatch[e.to] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint bipartite_matching(vector<vector<edge>> &G) {\n\tint N = G.size();\n\tvector<int> match(N, -1);\n\tvector<bool> used(N);\n\tint res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (match[i] < 0) {\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tif (bipartite_matching_dfs(i, G, match, used)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nll gcd(ll a, ll b) {\n\treturn b ? gcd(b, a%b) : a;\n}\nint main() {\n\tint m, n;\n\tvector<int> b(500);\n\tvector<int> r(500);\n\tvector<vector<edge>> G(1000, vector<edge>());\n\twhile (cin >> m >> n, m) {\n\t\tfor (int i = 0; i < m + n; i++) G[i].clear();\n\t\tfor (int i = 0; i < m; i++) cin >> b[i];\n\t\tfor (int i = 0; i < n; i++) cin >> r[i];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (gcd(b[i], r[j]) > 1) {\n\t\t\t\t\tG[i].emplace_back(j + m);\n\t\t\t\t\tG[j + m].emplace_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching(G) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nvector<int> blue;\nvector<int> red;\nvector<int> redpair;\nvector<int> v;\nvector<vector<int>> c;\nint m = 0;\nint n = 0;\n\n\nint gcd(int x,int y){\n    if(x % y == 0){\n        return y;\n    }\n    return gcd(y,x%y);\n}\n\nbool match(int x){\n    if(x == -1){\n        return 1;\n    }\n    for(int i = 0;i < n;i++){\n        if(c[x][i] == 1 && v[i] == 0){\n            v[i] = 1;\n            if(match(redpair[i])){\n                redpair[i] = x;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\n\nint main(){\n\n    while(cin >> m >> n){\n        if(m == 0 && n == 0){\n            break;\n        }\n        blue.clear();\n        red.clear();\n        redpair.clear();\n        v.clear();\n        c.clear();\n        for(int i = 0;i < m;i++){\n            int tmp = 0;\n            cin >> tmp;\n            blue.push_back(tmp);\n        }\n        for(int i = 0;i < n;i++){\n            int tmp = 0;\n            cin >> tmp;\n            red.push_back(tmp);\n            redpair.push_back(-1);\n            v.push_back(0);\n        }\n        for(int i = 0;i < m;i++){\n            c.push_back(vector<int>());\n            for(int j = 0;j < n;j++){\n                c[i].push_back(gcd(blue[i],red[j]) != 1);\n            }\n        }\n        int ans = 0;\n        for(int i = 0;i < m;i++){\n            for(int j = 0;j < n;j++){\n                v[j] = 0;\n            }\n            if(match(i)){ans++;}\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define INF 100000000\n \nusing namespace std;\n\nint gcd(int a,int b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\n \nint V,match[1001];\nbool used[1001];\nvector<int>G[1001];\n \nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n \nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n \nint bipartite_matching(){\n  int res=0;\n  fill(match,match+1001,-1);\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      fill(used,used+1001,false);\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n \nint main(void){\n\t\n\tint m,n;\n\t\n\twhile(cin >> m >> n,m|n){\n\t\tvector<int>b(m),r(n);\n\t\tfor(int i=0;i<1001;i++)G[i].clear();\n\t\t\n\t\tfor(int i=0;i<m;i++)cin >> b[i];\n\t\tfor(int i=0;i<n;i++)cin >> r[i];\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(gcd(b[i],r[j])!=1)add_edge(i,j+m);\n\t\t\t}\n\t\t}\n\t\tV=max(m,n);\n\t\tcout << bipartite_matching() << endl;\n\t}\n\t\nreturn 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n//Class.\nvector<int> list[1000];\nint N, M, E, P;\nint match[1000];\nbool used[1000];\nint x[1000], y[1000];\n\nbool DFS(int V) {\n\tused[V] = true;\n\tfor (int i = 0; i < list[V].size(); i++) {\n\t\tint u = list[V][i]; int w = match[u];\n\t\tif (w < 0 || !used[w] && DFS(w)) {\n\t\t\tmatch[V] = u;\n\t\t\tmatch[u] = V;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint supermatching() {\n\tint r = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int j = 0; j < P; j++) {\n\t\tif (match[j] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (DFS(j)) { r++; }\n\t\t}\n\t}\n\treturn r;\n}\n\n//main.\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 1000; i++) { list[i].clear(); }\n\t\tcin >> N >> M; if (!N) { break; }\n\t\tP = N + M;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i];\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> y[i];\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tif (__gcd(x[i], y[j]) != 1) {\n\t\t\t\t\tlist[i].push_back(j + N);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << supermatching() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <random>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\ntypedef long long ll;\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Edge {\n    int to; int cap; int rev;\n    Edge(int t, int c, int r) : to(t), cap(c), rev(r) {}\n};\n\nstruct Flow {\n    vector <vector<Edge>> G;\n    vector<bool> used;\n    Flow(int n) : G(n), used(n, false) {}\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back(Edge(to, cap, G[to].size()));\n        G[to].push_back(Edge(from, 0, G[from].size() - 1));\n    }\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            Edge &e = G[v][i];\n            if (!used[e.to] && e.cap > 0) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int max_flow(int s, int t) {\n        int flow = 0;\n        while (1) {\n            fill(used.begin(), used.end(), false);\n            int f = dfs(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint main() {\n    cin.sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n\n        Flow fl(n+m+2);\n        int a[n], b[m];\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n            fl.add_edge(n+m, i, 1);\n        }\n        for (int i = 0; i < m; i++) {\n            cin >> b[i];\n            fl.add_edge(n+i, n+m+1, 1);\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (gcd(a[i], b[j]) > 1) fl.add_edge(i, n+j, 1);\n            }\n        }\n\n        cout << fl.max_flow(n+m, n+m+1) << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,s,e) for (int i=s;i<(e);i++)\n#define All(v) (v).begin(),(v).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define int long long\nusing namespace std;\ntypedef long long llint;\ntypedef pair<int, int> P;\nconst int MOD = (int)1e9 + 7;\nconst int INF = (int)1e18 * 5;\n\nstruct Bipartite_Matching\n{\n  vector< vector< int > > G;    // 隣接リスト\n  vector< int > match, used;\n  int timestamp;\n\n  Bipartite_Matching(int n)\n  {\n    timestamp = 0;\n    G.resize(n);\n    match.assign(n, -1);\n    used.assign(n, 0);\n  }\n \n  void add_edge(int u, int v)\n  {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  // 増加路が見つかればTrue\n  bool dfs(int v)\n  {\n    used[v] = timestamp;\n    REP(i, G[v].size()) {\n      int u = G[v][i], w = match[u];\n      if(w == -1 || (used[w] != timestamp && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching()\n  {\n    int res = 0;\n    REP(i, G.size()) {\n      if(match[i] == -1) {\n        ++timestamp;\n        res += dfs(i);\n      }\n    }\n    return res;\n  }\n};\n\nint gcd(int m, int n)\n{\n    if (n == 0) return m;\n    return gcd(n, m%n);\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int m, n;\n    cin >> m >> n;\n    while(!(m == 0 && n == 0)){\n        Bipartite_Matching BM(n+m);\n        vector<int> b(m);\n        REP(i, m) cin >> b[i];\n        vector<int> r(n);\n        REP(i, n) cin >> r[i];\n        \n        REP(i, m)REP(j, n){\n            if(gcd(b[i], r[j]) != 1){\n                BM.add_edge(i, m+j);\n            }\n        }\n\n        cout << BM.bipartite_matching() << \"\\n\";\n        cin >> m >> n;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct Dinic {\n    int n, s, t;\n    vector<int> level, iter;\n    vector<vector<Capacity>> cap, flow;\n    vector<vector<int>> g;\n    Capacity inf;\n    Dinic(int n)\n        : n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n          g(n, vector<int>()), inf(numeric_limits<Capacity>::max()/8){}\n    Dinic(const Graph &graph){\n        *this = Dinic(graph.size());\n        rep(i,n) for(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n    }\n    void addEdge(int u, int v, Capacity c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    inline Capacity residue(int u, int v){ return cap[u][v] - flow[u][v]; }\n    Capacity solve(int s, int t){\n        this->t = t, this->s = s;\n        Capacity res = 0, aug = 1;\n        while(aug > 0){\n            levelize();\n            iter.assign(n, 0);\n            res += (aug = augment(s, inf));\n        }\n        return res;\n    }\n    void levelize(){\n        level.assign(n, inf); level[s] = 0;\n        int l = 0, r = 0;\n        vector<int> q(n+1);\n        q[r++] = s;\n        while(l != r){\n            int v = q[l++];\n            for(const int &d : g[v]){\n                if(level[d] <= level[v] + 1 || residue(v,d) == 0) continue;\n                level[d] = level[v] + 1; q[r++] = d;\n            }\n        }\n    }\n    Capacity augment(int v, Capacity lim){\n        Capacity res = 0;\n        if(v == t) return lim;\n        for(int &i = iter[v]; i < (int)g[v].size(); i++){\n            const int &d = g[v][i];\n            if(residue(v,d) == 0 || level[v] + 1 != level[d]) continue;\n            const Capacity aug = augment(d, min(lim, residue(v,d)));\n            if(aug > 0){\n                flow[v][d] += aug; flow[d][v] -= aug;\n                res += aug; lim -= aug;\n                if(lim == 0) return res;\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    fastios();\n    int n,m;\n    while(cin >> n >> m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        Dinic d(n+m+2);\n        int s = n+m, t = n+m+1;\n        rep(i,m) d.addEdge(i+n,t,1);\n        rep(i,n){\n            d.addEdge(s,i,1);\n            rep(j,m) if(__gcd(a[i],b[j]) != 1) d.addEdge(i,n+j,1);\n        }\n        rep(i,n)rep(j,m){\n            if(d.flow[i][j+n]) dump(i,j, d.flow[i][j+m]);\n        }\n        cout << d.solve(s,t) << endl;\n    }\n}\n\n// int main(){\n//     int N,M;\n//     cin >> N >> M;\n//     Graph g(N);\n//     rep(i,M){\n//         int a,b,c;\n//         cin >> a >> b >> c;\n//         g[a].emplace_back(a,b,c);\n//     }\n//     Dinic dinic(g);\n//     cout << dinic.solve(0,N-1) << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint gcd(int a, int b) {\n    return (a == 0) ? b : gcd(b % a, a);\n}\n\nbool used[260000];\n\nstruct Edge {\n    int to, cap, rev;\n};\n\nvoid add_edge(vector<vector<Edge>> &G, int from, int to, int cap) {\n    G[from].push_back((Edge){ to, cap, (int)G[to].size() });\n    G[to].push_back((Edge){ from, 0, (int)G[from].size()-1 });\n}\n\nint dfs(vector<vector<Edge>> &G, int v, int to, int f) {\n    used[v] = true;\n    int ret = 0;\n    if (v == to) {\n        ret = f;\n    } else {\n        for (Edge &e: G[v]) {\n            if (used[e.to] || e.cap <= 0) continue;\n            int t = dfs(G, e.to, to, min(f, e.cap));\n            if (t > 0) {\n                e.cap -= t;\n                G[e.to][e.rev].cap += t;\n                ret = t;\n                break;\n            }\n        }\n    }\n    return ret;\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int m, n;\n    while (cin >> m >> n, m) {\n        vector<int> b(m), r(n);\n        for (int i=0; i<m; ++i) cin >> b[i];\n        for (int i=0; i<n; ++i) cin >> r[i];\n\n        vector<vector<Edge>> G(m+n+2);\n        for (int i=0; i<m; ++i) {\n            for (int j=0; j<n; ++j) {\n                if (gcd(b[i], r[j]) != 1) {\n                    add_edge(G, i, m+j, 1);\n                }\n            }\n        }\n        for (int i=0; i<m; ++i) {\n            add_edge(G, m+n, i, 1);\n        }\n        for (int i=0; i<n; ++i) {\n            add_edge(G, m+i, m+n+1, 1);\n        }\n\n        int res = 0;\n        while (1) {\n            fill_n(used, m+n+2, false);\n            int f = dfs(G, m+n, m+n+1, INT_MAX);\n            if ( ! f) break;\n            res += f;\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "from collections import deque\n\ninf = 100000000000000000\n\ndef bfs(graph, s, t):\n    V = len(graph)\n    q = deque([(s, -1, -1)])\n    prev = [(-1, -1)] * V\n    visited = [False] * V\n    while len(q) > 0:\n        (v, p, e) = q.popleft()\n        if visited[v]:\n            continue\n        visited[v] = True\n        prev[v] = p, e\n        for i in range(len(graph[v])):\n            e = graph[v][i]\n            if e['cap'] > 0:\n                q.append((e['to'], v, i))\n    if not visited[t]:\n        return None\n    else:\n        return prev\n\ndef decrease_graph(graph, s, t, prev):\n    ((p, e), c) = prev[t], t\n    m = inf\n    while p != -1:\n        m = min(graph[p][e]['cap'], m)\n        ((p, e), c) = prev[p], p\n    ((p, e), c) = prev[t], t\n    while p != -1:\n        graph[p][e]['cap'] -= m\n        graph[c][graph[p][e]['rev']]['cap'] += m\n        ((p, e), c) = prev[p], p\n    return m\n\ndef maximum_flow(graph, s, t):\n    V = len(graph)\n    g = [[] for _ in range(V)]\n    for v in range(V):\n        nei = graph[v]\n        for (u, cap) in nei:\n            g[v].append({'to' : u, 'from': v, 'cap': cap, 'rev': len(g[u])})\n            g[u].append({'to' : v, 'from': u, 'cap':   0, 'rev': len(g[v]) - 1})\n    \n    sum = 0\n    while True:\n        prev = bfs(g, s, t)\n        if prev == None:\n            break\n        sum += decrease_graph(g, s, t, prev)\n    return sum\n\ndef gcd(x, y):\n    while y > 0:\n        x, y = y, x % y\n    return x\n\ndef main():\n    while True:\n        m, n = map(int, input().split())\n        if m == 0 and n == 0:\n            return\n        data = []\n        while len(data) < n + m:\n            data += list(map(int, input().split()))\n        b = data[:m]\n        r = data[m:]\n        while len(r) < n:\n            r += list(map(int, input().split()))\n        \n        g = [[] for i in range(n + m + 2)]\n        for i in range(m):\n            g[0].append((i + 1, 1))\n        for i in range(n):\n            g[m + i + 1].append((n + m + 1, 1))\n        for i in range(m):\n            for j in range(n):\n                if gcd(b[i], r[j]) > 1:\n                    g[i + 1].append((m + j + 1, 1))\n\n        print(maximum_flow(g, 0, n + m + 1))\n        \nmain()"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define pb(a) push_back(a)\n#define pr(a) cout<<(a)<<endl\n#define PR(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define F first\n#define S second\n#define ll long long\nbool check(int n,int m,int x,int y){return (x<0||x>=n||y<0||y>=m)?false:true;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\ntypedef pair<int,int> P;\n\n#define MAX_V 100001\nstruct edge{ int to,cap,rev; };  \nint V,E;\nvector<edge> G[MAX_V];\nint level[MAX_V],iter[MAX_V];\n  \nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n  \nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> Q;\n  level[s] = 0;\n  Q.push(s);\n  while(!Q.empty()){\n    int v = Q.front(); Q.pop();\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        Q.push(e.to);\n      }\n    }\n  }\n}\n  \nint dfs(int v,int t,int f){\n  if(v == t) return f;\n  for(int &i = iter[v] ; i < (int)G[v].size() ; i++){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n \nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    bfs(s);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f = dfs(s,t,MAX)) > 0){\n      flow += f;\n    }\n  }\n}\n\nint main() {\n  int n,m;\n  while(cin >> n >> m && (n||m)) {\n    rep(i,MAX_V) G[i].clear();\n    int a[n],b[m];\n    rep(i,n) cin >> a[i];\n    rep(i,m) cin >> b[i];\n    rep(i,n) {\n      rep(j,m) {\n\tif(__gcd(a[i],b[j])!=1) add_edge(i+1,j+n+1,1);\n      }\n    }\n    rep(i,n) add_edge(0,i+1,1);\n    rep(i,m) add_edge(n+1+i,n+m+1,1);\n    pr(max_flow(0,n+m+1));\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint gcd(int a,int b)\n{\n\treturn b?gcd(b,a%b):a;\n}\n\nstruct Edge{\n\tint src,dst;\n\tEdge(){}\n\tEdge(int s,int d):src(s),dst(d){}\n};\ntypedef vector<vector<Edge> > Graph;\n\nbool Augment(const Graph& g,int u,vi& vis,vi& match)\n{\n\trep(i,g[u].size()){\n\t\tint v=g[u][i].dst;\n\t\tif(vis[v]) continue;\n\t\tvis[v]=1;\n\t\tif(match[v]==-1 || Augment(g,match[v],vis,match)){\n\t\t\tmatch[u]=v;\n\t\t\tmatch[v]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint BipartiteMatching(const Graph& g,vi& match)\n{\n\tint n=g.size();\n\tmatch.assign(n,-1);\n\tint res=0;\n\trep(i,n) if(match[i]==-1){\n\t\tvi vis(n);\n\t\tres+=Augment(g,i,vis,match);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int m,n;scanf(\"%d%d\",&m,&n),m|n;){\n\t\tvi bs(m),rs(n);\n\t\trep(i,m) scanf(\"%d\",&bs[i]);\n\t\trep(i,n) scanf(\"%d\",&rs[i]);\n\t\t\n\t\tGraph g(m+n);\n\t\trep(i,m) rep(j,n) if(gcd(bs[i],rs[j])>1){\n\t\t\tg[i].push_back(Edge(i,m+j));\n\t\t\tg[m+j].push_back(Edge(m+j,i));\n\t\t}\n\t\t\n\t\tvi match;\n\t\tprintf(\"%d\\n\",BipartiteMatching(g,match));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 1500\n#define INF 1<<29\nusing namespace std;\nstruct edge{int to,cap,rev;};\nvector<edge>G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int>q;\n  level[s]=0;\n  q.push(s);\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(int i=0;i<G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n        level[e.to]=level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    bfs(s);\n    if(level[t]<0)return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\nint main(){\n  int a,b;\n  while(cin>>a>>b,a){\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n    int aa[a],bb[b];\n    for(int i=0;i<a;i++)cin>>aa[i];\n    for(int i=0;i<b;i++)cin>>bb[i];\n    for(int i=101;i<501;i++)add_edge(0,i,1);\n    for(int i=701;i<1201;i++)add_edge(i,1499,1);\n    for(int i=0;i<a;i++)\n     for(int j=0;j<b;j++)\n      if((__gcd(aa[i],bb[j]))!=1)add_edge(i+101,j+701,1);\n    cout<<max_flow(0,1499)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n//aoj 1163\nstruct edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nclass MF{//max flow\n\tpublic:\n\tint n;\n\tvector<vector<edge> >G;//[MAX];\n\tvector<bool>used;//[MAX];\n\tMF(int size){\n\t\tn=size;\n\t\tG=vector<vector<edge> >(n);\n\t}\n\tvoid add_edge(int from, int to, int cap){\n\t\tedge q={to,cap,int(G[to].size())};\n\t\tG[from].push_back(q);\n\t\tq={from,0,int(G[from].size()-1)};\n\t\tG[to].push_back(q);\n\t}\n\tint dfs(int v,int t, int f) {\n\t\tif(v==t)return f;\n\t\tused[v]=1;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(used[e.to]||e.cap<=0) continue;\n\t\t\tint d =dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint ford_fulkerson(int s,int t) {//from s to t\n\t\tint flow=0,f;\n\t\twhile(1){\n\t\t\tused=vector<bool>(n,false);\n\t\t\tf=dfs(s,t,inf);\n\t\t\tif(f==0)return flow;\n\t\t\tflow+=f;\n\t\t}\n\t}\n};\nint gcd(int a,int b){\n\tif(a<b)swap(a,b);\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\tvi a(n);\n\t\tvi b(m);\n\t\tMF mf(n+m+2);\n\t\trep(i,n)cin>>a[i];\n\t\trep(i,m)cin>>b[i];\n\t\tint s=n+m;int t=s+1;\n\t\trep(i,n)rep(j,m)if(gcd(a[i],b[j])!=1)mf.add_edge(i,n+j,1);\n\t\trep(i,n)mf.add_edge(s,i,1);\n\t\trep(i,m)mf.add_edge(n+i,t,1);\n\t\tcout<<mf.ford_fulkerson(s,t)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define DECIM8  fixed<<setprecision(8) \n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nusing namespace std;\nstruct edge { int to,cap,rev; };\nvector<vector<edge> > G;\nint gcd(int a,int b)\n{\n  if(!a||!b) return a+b;\n  return gcd(b%a,a);\n}\nvoid add_edge(int from,int to,int cap)\n{\n  G[from].PB((edge){to,cap,SZ(G[to])});\n  G[to].PB((edge){to,0,SZ(G[from])-1});\n}\nvoid flow_edge(int from,int ind,int val)\n{\n  edge &e=G[from][ind];\n  e.cap-=val;\n  G[e.to][e.rev].cap+=val;\n  //cout << from  << ' ' << e.to << endl;\n}\nvector<int> EK(int so,int si)\n{\n  set<int> already;\n  queue<pair<vector<int>,int> > bfs;\n  // path, pos\n  bfs.push(MP(vector<int>(),so));\n  while(!bfs.empty()){\n    vector<int> path;\n    int lastpos;\n    tie(path,lastpos)=bfs.front(); bfs.pop();\n    if(lastpos==si) return path;\n    if(!already.insert(lastpos).second) continue;\n    REP(i,SZ(G[lastpos])){\n      edge &e=G[lastpos][i];\n      if(e.cap<=0) continue;\n      vector<int> nextpath(path);\n      nextpath.PB(i);\n      int nextpos=e.to;\n      bfs.push(MP(nextpath,nextpos));\n    }\n  }\n  return vector<int>();\n}\nint flowpath(int so,int si)\n{\n  int answer=INT_MAX;\n  vector<int> path=EK(so,si);\n  if(path.empty()) return 0;\n  for(int i=0,pos=so;i<SZ(path);++i){\n    edge &e=G[pos][path[i]];\n    answer=min(answer,e.cap);\n    pos=e.to;\n  }\n  for(int i=0,pos=so;i<SZ(path);++i){\n    flow_edge(pos,path[i],answer);\n    pos=G[pos][path[i]].to;\n  }\n  return answer;\n}\nint mflow(int so,int si)\n{\n  int answer=0;\n  int tmp;\n  while(tmp=flowpath(so,si)) answer+=tmp;\n  return answer;\n}\nint main(void)\n{\n  for(;;){\n    int m,n;\n    cin >> m >> n;\n    if(!m&&!n) return 0;\n    vector<int> b;\n    b.reserve(m);\n    REP(i,m) cin >> b[i];\n    vector<int> r;\n    r.reserve(n);\n    REP(j,n) cin >> r[j];\n    G.reserve(m+n+2);\n    REP(i,m) add_edge(m+n,i,1);\n    REP(i,m) REP(j,n) if(gcd(b[i],r[j])!=1) add_edge(i,m+j,1);\n    REP(j,n) add_edge(m+j,m+n+1,1);\n    cout << mflow(m+n,m+n+1) << endl;\n    G.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int MAX_NM = 510 * 2;\n\nint N, M, B[MAX_NM], R[MAX_NM];\nint match[MAX_NM];\nbool used[MAX_NM];\nvector<int> G[MAX_NM];\n\nbool dfs(int v){\n  used[v] = true;\n  REP(tmp_u, G[v].size()){\n    int u = G[v][tmp_u];\n    int w = match[u];\n    if(w < 0 || (!used[w] && dfs(w))){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartiteMatching(int V){\n  memset(match, -1, sizeof(match));\n  memset(used, 0, sizeof(used));\n  int ret = 0;\n  REP(v, V){\n    if(match[v] < 0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v)) ++ret;\n    }\n  }\n  return ret;\n}\n\nint canGet(int a, int b){\n  //cout <<\"    \" <<a <<\", \" <<b <<endl;\n  if(b == 0) return a;\n  return canGet(b, a % b);\n}\n\nint main() {\n  while(cin >>M >>N && M){\n    REP(i, MAX_NM) G[i].clear();\n    //cout <<\"------------\" <<endl;\n    REP(i, M) cin >>B[i];\n    REP(i, N) cin >>R[i];\n    REP(i, M){\n      REP(j, N){\n        //int dfs = (canGet(max(B[i], R[j]), min(B[i], R[j])));\n        //cout <<\"dfs = \" <<dfs <<endl;\n        //if(B[i] == 6 && R[j] == 2) cout <<B[i] <<\", \" <<R[j] <<\", \" <<(canGet(max(B[i], R[j]), min(B[i], R[j]))) <<endl;\n        if(canGet(max(B[i], R[j]), min(B[i], R[j])) != 1){\n          G[i].push_back(M + j);\n          G[M + j].push_back(i);\n        }\n      }\n    }\n    int ans = bipartiteMatching(M + N);\n    //debug start\n    //cout <<\"BLUE \"; REP(i, M) cout <<B[i] <<\", \"; cout <<endl;\n    //cout <<\"RED \"; REP(i, N) cout <<R[i] <<\", \"; cout <<endl;\n    //REP(i, M){\n    //  cout <<B[i] <<\" : \";\n    //  REP(j, G[i].size()) cout <<R[G[i][j] - M] <<\", \";\n    //  cout <<endl;\n    //}\n    //REP(i, M) cout <<R[match[i] - M] <<\", \"; cout <<endl;\n    //debug end\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<P> vp;\ntypedef vector<ll> vll;\n\nconst int INF = 99999999;\nconst int MAX_V = 1111;\n\nstruct edge { int to, cap, rev; };\n\nvector<vector<edge>> G(MAX_V);\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].emplace_back((edge){to, cap, (int)G[to].size()});\n    G[to].emplace_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n\tfor (auto& e : G[v]) {\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    for(;;) {\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nsigned main() {\n    int M, N;\n    while (~scanf(\"%d %d\", &M, &N) && M) {\n    \tint V = M + N;\n    \tint s = V;\n    \tint t = s + 1;\n    \trep(i, M) add_edge(s, i, 1);\n    \trep(i, N) add_edge(i + M, t, 1);\n\n        vector<int> b(M);\n        rep(i, M) cin >> b[i];\n        vector<int> r(N);\n        rep(i, N) cin >> r[i];\n\n        rep(i, M) {\n            rep(j, N) {\n                if (gcd(b[i], r[j]) > 1) {\n                    add_edge(i, j + M, 1);\n                }\n            }\n        }\n\n    \tcout << max_flow(s, t) << endl;\n        G.clear();\n        G.resize(MAX_V);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n//typedef long long Int;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst) : src(src),dst(dst) {}\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) {}\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vec<Edge> Edges;\ntypedef vec<Edges> Graph;\n\n#define MAXMN 501\nint B[MAXMN];\nint R[MAXMN];\n\nint gcd(int a, int b)\n{   \n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  return match;\n}\n\n\nmain() {\n  int M,N;\n  Graph g; g.reserve(MAXMN+MAXMN);\n  while(cin>>M>>N,M) {\n    g.clear();\n    g.resize(M+N);\n    REP(i,M) cin>>B[i];\n    REP(i,N) cin>>R[i];\n    REP(i,M) {\n      Edges es, es2;\n      REP(j,N) {\n\tif(gcd(B[i],R[j])!=1) { es.pb(Edge(i,M+j)); es2.pb(Edge(M+j,i)); }\n      }\n      g[i] = es;\n      g[M+i] = es2;\n    }\n    cout << bipartiteMatching(g,M) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> g[1010];\nint n, m;\n \nvector<bool> visited, matched;\nvector<int> levels, matching;\n \nbool augment(int left) {\n  if(left == n) return true;\n  if(visited[left]) return false;\n  visited[left] = true;\n  rep(i, g[left].size()) {\n    int right = g[left][i];\n    int next = matching[right];\n    if (levels[next] > levels[left] && augment(next)) {\n      matching[right] = left;\n      return true;\n    }\n  }\n  return false;\n}\n \nint bimatch() {\n  matching.assign(m, n);\n  matched.assign(n, false);\n  int ret = 0;\n  bool cont;\n  do {\n    levels.assign(n+1, -1);\n    levels[n] = n;\n    queue<int> q;\n    rep(left, n) if (!matched[left]) {\n      q.push(left);\n      levels[left] = 0;\n    }\n    while(!q.empty()) {\n      int left = q.front();\n      q.pop();\n      rep(i, g[left].size()) {\n        int right = g[left][i];\n        int next = matching[right];\n        if (levels[next] < 0) {\n          levels[next] = levels[left] + 1;\n          q.push(next);\n        }\n      }\n    }\n    visited.assign(n, false);\n    cont = false;\n    rep(left, n) if(!matched[left] && augment(left)){\n      matched[left] = cont = true;\n      ret++;\n    }\n  } while(cont);\n\n  return ret;\n}\n\nint blue[510],red[510];\n\nint main(){\n  while(scanf(\"%d%d\",&n,&m),n|m){\n    //init\n    rep(i,n+m)g[i].clear();\n    //visited.clear();\n    //matched.clear();\n    //levels.clear();\n    //matching.clear();\n    \n    \n    \n    rep(i,n)scanf(\"%d\",blue+i);\n    //rep(i,m)scanf(\"%d\",red+i);\n    rep(i,m){\n      int a; scanf(\"%d\",&a);\n      rep(j,n)if( __gcd(blue[j],a)!=1 ){\n        g[j].push_back(n+i);\n        g[n+i].push_back(j);\n      }\n    }\n    /*\n    rep(i,n){\n      rep(j,m)if( __gcd(blue[i],red[j])!=1 ){\n        g[i].push_back(n+j);\n        g[n+j].push_back(i);\n      }\n    }\n      */\n    m += n;\n    printf(\"%d\\n\",bimatch());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Hopcroft-Karp Algorithm\n// O(|E| * |V|^(1/2))\n// http://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm\n// aoj 1163\n\n#include <vector>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\nint NIL;\nconst int inf = 1<<29;\n\ntypedef vector<int> vi;\ntypedef vector<vector<int> > Graph;\n\nbool bfs(const Graph &g,vi &dist,const vi &pair,int m) {\n    queue<int> q;\n\n    for(int i=0; i<m; ++i)\n        if(pair[i] == NIL) {\n            dist[i] = 0;\n            q.push(i);\n        }else\n            dist[i] = inf;\n    dist[NIL] = inf;\n\n    while(!q.empty()) {\n        int v = q.front(); q.pop();\n        if(v == NIL) continue;\n        for(int i=0; i<g[v].size(); ++i) {\n            int u = g[v][i];\n            if(dist[pair[u]] == inf) {\n                dist[pair[u]] = dist[v]+1;\n                q.push(pair[u]);\n            }\n        }\n    }\n    return dist[NIL] != inf;\n}\n\nbool dfs(int v,const Graph &g,vi &dist,vi &pair) {\n    if(v != NIL) {\n        for(int i=0; i<g[v].size(); ++i) {\n            int u = g[v][i];\n            if(dist[pair[u]] == dist[v]+1) {\n                if(dfs(pair[u],g,dist,pair)) {\n                    pair[u] = v, pair[v] = u;\n                    return true;\n                }\n            }\n        }\n        dist[v] = inf;\n        return false;\n    }\n    return true;\n}\n\n// 0ツつゥツづァm-1ツづ慊づづ個静淞点ツづツつゥツづァn-1ツづ慊づづ個静淞点ツづづ個催妥・ツマツッツチツδ督グツづーツ仰づ淞づゥ\nint hopcroft_karp(Graph &graph,int m) {\n    const int n = graph.size();\n    NIL = n;\n    vi pair(n+1, NIL), dist(n+1, 0);\n    int ret = 0;\n    while(bfs(graph,dist,pair,m)) {\n        for(int i=0; i<m; ++i)\n            if(pair[i] == NIL)\n                if(i == NIL || dfs(i,graph,dist,pair)) ret++;\n    }\n    return ret;\n}\n\nint gcd(int x,int y) {\n    if(y == 0) return x;\n    return gcd(y,x%y);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    int m,n;\n    while(cin>>m>>n, m|n) {\n        Graph g(m+n);\n        vector<int> b(m), r(n);\n        for(int i=0; i<m; ++i) cin>>b[i];\n        for(int i=0; i<n; ++i) cin>>r[i];\n\n        for(int i=0; i<m; ++i)\n            for(int j=0; j<n; ++j)\n                if(gcd(b[i],r[j]) > 1)\n                    g[i].push_back(j+m);\n        cout<<hopcroft_karp(g,m)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nusing ll = long long;\n\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define ALL(v) (v).begin(),(v).end()\n\ntypedef pair<int, int> P;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile (1) {\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0) return 0;\n\t\t\n\t\tint b[m], r[n];\n\t\tREP(i, m) cin >> b[i];\n\t\tREP(i, n) cin >> r[i];\n\t\t\n\t\tbool memo[m][n];\n\t\tREP(i, m) {\n\t\t\tREP(j, n) {\n\t\t\t\tif (gcd(b[i], r[j]) == 1) memo[i][j] = false;\n\t\t\t\telse memo[i][j] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt[n];\n\t\tREP(i, n) cnt[i] = 0;\n\t\t\n\t\tREP(i, m) {\n\t\t\tREP(j, n) {\n\t\t\t\tif (memo[i][j]) {\n\t\t\t\t\t++cnt[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint maxpair = 0;\n\t\tREP(i, m) {\n\t\t\tint pairindex = n;\n\t\t\tint mincnt = 505;\n\t\t\tREP(j, n) {\n\t\t\t\tif (memo[i][j]) {\n\t\t\t\t\tif (cnt[j] == 0) continue;\n\t\t\t\t\tif (cnt[j] < mincnt) {\n\t\t\t\t\t\tpairindex = j;\n\t\t\t\t\t\tmincnt = cnt[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pairindex != n) {\n\t\t\t\t++maxpair;\n\t\t\t\tcnt[pairindex] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << maxpair << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF (long long)(1e18)\n#define MOD (int)(1e9+7)\n\n#define yn(f) ((f)?\"Yes\":\"No\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n#define MAX 300\n#define MAX_V MAX\n\nstruct edge{ int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nint V, E;\nint n, m;\nint a[MAX], b;\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back((edge){to,cap,(int)G[to].size()});\n\tG[to].push_back((edge){from, 0, (int)G[from].size()-1});\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tmemset(used, 0,sizeof(used));\n\t\tint f = dfs(s,t,INF);\n\t\tif(f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(7);\n\t\n\twhile(true){\n\t\n\tcin>>m>>n;\n\t\n\tif(!n&&!m) break;\n\t\n\tfor(int i = 0; i <= n+m+1; i++) G[i].clear();\n\t\n\tfor(int i = 1; i <= m; i++){\n\t\tcin>>a[i];\n\t\tadd_edge(0,i,1);\n\t}\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tcin>>b;\n\t\tfor(int j = 1; j <= m; j++){\n\t\t\tif(__gcd(a[j],b) != 1){\n\t\t\t\tadd_edge(j,i+m,1);\n\t\t\t}\n\t\t}\n\t\tadd_edge(i+m,n+m+1,1);\n\t}\n\t\n\tcout<<max_flow(0,n+m+1)<<endl;\n\t\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint n, m;\nbool done[10];\nint map[256];\nstd::vector<char> check;\nstd::vector<std::string> list;\nbool top[256];\nint left;\nint right;\nint atom[256];\nint btom[256];\n\nint decode(const std::string & str) {\n  int time = 1;\n  int sum = 0;\n  for (int i = str.length() - 1; 0 <= i; --i) {\n    sum += map[str[i]] * time;\n    time *= 10;\n  }\n  return sum;\n}\n\nbool ok() {\n  int sum = 0;\n  for (int i = 0; i < n - 1; ++i) {\n    sum += decode(list[i]);\n  }\n  return sum == decode(list[n - 1]);\n}\n\nint dfs(int depth) {\n  if (depth == m) {\n    return left == right;\n  }\n  int cnt = 0;\n  for (int i = 0; i < 10; ++i) {\n    if (done[i]) {\n      continue;\n    }\n    if (i == 0 && top[check[depth]]) {\n      continue;\n    }\n    done[i] = true;\n    map[check[depth]] = i;\n    left += atom[check[depth]] * i;\n    right += btom[check[depth]] * i;\n    cnt += dfs(depth + 1);\n    left -= atom[check[depth]] * i;\n    right -= btom[check[depth]] * i;\n    done[i] = false;\n  }\n  return cnt;\n}\n\nint main() {\n  for (;;) {\n    std::cin >> n;\n    if (n == 0) {\n      break;\n    }\n    list.clear();\n    memset(atom, 0, sizeof(atom));\n    memset(btom, 0, sizeof(btom));\n    memset(top, 0, sizeof(top));\n    std::set<char> set;\n    for (int i = 0; i < n; ++i) {\n      std::string str;\n      std::cin >> str;\n      list.push_back(str);\n      for (char c : str) {\n        set.insert(c);\n      }\n      int time = 1;\n      for (int j = str.length() - 1; 0 <= j; --j) {\n        if (i < n - 1) {\n          atom[str[j]] += time;\n        } else {\n          btom[str[j]] += time;\n        }\n        time *= 10;\n      }\n      if (str.length() > 1) {\n        top[str[0]] = true;\n      }\n    }\n    check.clear();\n    for (char c : set) {\n      check.push_back(c);\n    }\n    m = check.size();\n    memset(done, 0, sizeof(done));\n    int ans = dfs(0);\n    std::cout << ans << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1163&lang=jp>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nll V;\nvector<vector<ll>> G;\nvector<ll> match;\nvector<int> used;\n\nvoid add_edge(ll u, ll v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\nbool dfs(ll v) {\n    used[v] = 1;\n    for (int i = 0; i < G[v].size(); i++) {\n        ll u = G[v][i], w = match[u];\n        if (w < 0 || ((used[w] == 0) && dfs(w))) {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nll bipartite_matching() {\n    ll res = 0;\n    for (int i = 0; i < (int)match.size();i++)match[i] = -1;\n    for (int v = 0;v < V;v++) {\n        if (match[v] < 0) {\n            for (int i = 0; i < (int)used.size();i++)used[i] = 0;\n            if (dfs(v))res++;\n        }\n    }\n    return res;\n}\n/*\n gcd : 最大公約数\n lcm : 最小公倍数\n */\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\n\nint m,n;\nll solve(){\n    ll res = 0;\n    V = m+n;\n    G.clear(); match.clear(); used.clear();\n    G.resize(V); match.resize(V); used.resize(V);\n    vector<int> b(m),r(n);\n    for(auto& in:b) cin >> in;\n    for(auto& in:r) cin >> in;\n    for(int i = 0; i < m;i++){\n        for(int j = 0; j < n;j++){\n            if(gcd(b[i],r[j]) == 1) continue;\n            add_edge(i,m+j);\n        }\n    }\n    res = bipartite_matching();\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> m >> n,m|n){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\n\n#define DE 1\n#define FI first\n#define SE second\n#define PB push_back\n#define MP make_pair\n#define ALL(s) (s).begin(),(s).end()\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define EACH(i,s) for (typeof((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(typeof(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\n\n\n\nconst int MAX_L = 501;\nconst int MAX_R = 501;\nstruct Graph {\n    static const int MAX_V_ = ::MAX_L;\n    vector<int> list[MAX_V_];\n    \n    void init() {for (int i = 0; i < MAX_V_; ++i) list[i].clear();}\n    inline vector<int>& operator [] (int i) {return list[i];}\n    \n    void addedge(int from, int to) {\n        list[from].push_back(to);\n    }\n} G;\n\nint L;\nbool seen[MAX_L];\nbool matched[MAX_L];\nint level[MAX_L];\nint matching[MAX_R];\n\nvoid hobfs(Graph &G) {\n    queue<int> que;\n    for (int left = 0; left < L; ++left) {\n        level[left] = -1;\n        if (!matched[left]) {\n            que.push(left);\n            level[left] = 0;\n        }\n    }\n    level[L] = L;\n    while (!que.empty()) {\n        int left = que.front();\n        que.pop();\n        for (int i = 0; i < G[left].size(); ++i) {\n            int right = G[left][i];\n            int next = matching[right];\n            if (level[next] == -1) {\n                level[next] = level[left] + 1;\n                que.push(next);\n            }\n        }\n    }\n}\n\nbool hodfs(Graph &G, int left) {\n    if (left == L) return true;\n    if (seen[left]) return false;\n    seen[left] = true;\n    for (int i = 0; i < G[left].size(); ++i) {\n        int right = G[left][i];\n        int next = matching[right];\n        if (level[next] > level[left] && hodfs(G, next)) {\n            matching[right] = left;\n            return true;\n        }\n    }\n    return false;\n}\n\nint Hopcroft_Karp(Graph &G) {\n    for (int i = 0; i < MAX_R; ++i) matching[i] = L;\n    for (int i = 0; i < L; ++i) matched[i] = false;\n    \n    int res = 0;\n    while (true) {\n        hobfs(G);\n        memset(seen, 0, sizeof(seen));\n        bool finished = true;\n        for (int left = 0; left < L; ++left) {\n            if (!matched[left] && hodfs(G, left)) {\n                matched[left] = true;\n                ++res;\n                finished = false;\n            }\n        }\n        if (finished) break;\n    }\n    return res;\n}\n\n\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint n, m;\nint b[600], r[600];\n\nint main() {\n    while (cin >> m >> n) {\n        if (m == 0) break;\n        \n        L = m;\n        \n        for (int i = 0; i < m; ++i) scanf(\"%d\", b+i);\n        for (int j = 0; j < n; ++j) scanf(\"%d\", r+j);\n        \n        G.init();\n        \n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                int left = b[i], right = r[j];\n                int d = gcd(left, right);\n                if (d > 1) G.addedge(i, j);\n            }\n        }\n\n        int res = Hopcroft_Karp(G);\n\n        cout << res << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<int> blue;\nvector<int> red;\nvector<int> redpair;\nvector<int> v;\nvector<vector<int> > c;\nint m = 0;\nint n = 0;\n\nint gcd(int x,int y){\n    if(x % y == 0){\n        return y;\n    }\n    return gcd(y,x%y);\n}\n\nbool match(int x){\n    if(x == -1){\n        return 1;\n    }\n    for(int i = 0;i < n;i++){\n        if(c[x][i] == 1 && v[i] == 0){\n            v[i] = 1;\n            if(match(redpair[i])){\n                redpair[i] = x;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nint main(){\n    while(cin >> m >> n){\n        if(m == 0 && n == 0){\n            break;\n        }\n        blue.clear();\n        red.clear();\n        redpair.clear();\n        v.clear();\n        c.clear();\n        for(int i = 0;i < m;i++){\n            int tmp;\n            cin >> tmp;\n            blue.push_back(tmp);\n        }\n        for(int i = 0;i < n;i++){\n            int tmp;\n            cin >> tmp;\n            red.push_back(tmp);\n            redpair.push_back(-1);\n            v.push_back(0);\n        }\n        for(int i = 0;i < m;i++){\n            c.push_back(vector<int>());\n            for(int j = 0;j < n;j++){\n                c[i].push_back(gcd(blue[i],red[j]) != 1);\n            }\n        }\n        int ans = 0;\n        for(int i = 0;i < m;i++){\n            for(int j = 0;j < n;j++){\n                v[j] = 0;\n            }\n            if(match(i)){\n                ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <tuple>\n#include <unordered_set>\n#include <unordered_map>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <iterator>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <random>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n\nusing namespace std;\nusing ll = long long;\n\n\nconst ll mod = 1000000007;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\n// bool debug=false;\n\n/*---------------------------------------------------*/\n\n// gcd\nint gcd(int a, int b) {\n  if (b == 0) {\n    return a;     \n  }\n  return gcd(b, a % b);\n}\n\n//lcm\nint lcm(int a,int b){\n  if ( ( 0 == a ) || ( 0 == b ) )\n    return 0;\n  \n  return ((a / gcd(a, b)) * b); \n}\n\nconst int MAX = 1005;\n\nvector<int> G[MAX];\nint match[MAX];\nbool used[MAX];\n\nvoid init() {\n  for(int i = 0; i < MAX; i++) {\n    G[i].clear();\n    match[i] = -1;\n    used[i] = false;\n  }\n}\n\nbool dfs(int v) {\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); i++) {\n    int u = G[v][i], w = match[u];\n    if(w < 0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(int& m, int& n) {\n  int ret = 0;\n  for(int v = 0; v < m + n; v++) {\n    if(match[v] < 0) {\n      memset(used, 0, sizeof(used));\n      if(dfs(v)) ret++;\n    }\n  }\n  return ret;\n}\n\nvoid solve(int& m, int& n) {\n  init();\n  vector<int> b(m), r(n);\n  for(int i = 0; i < m; i++) cin >> b[i];\n  for(int i = 0; i < n; i++) cin >> r[i];\n  for(int i = 0; i < m; i++) {\n    for(int j = 0; j < n; j++) {\n      int x = gcd(b[i], r[j]);\n      if(x != 1) {\n\tG[i].push_back(m + j);\n\tG[m + j].push_back(i);\n      }\n    }\n  }\n  cout << bipartite_matching(m, n) << endl;\n}\n\nint main(){\n  int m, n;\n  while(cin >> m >> n) {\n    if(m == 0 && n == 0) break;\n    solve(m, n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<cstdio>\n#include<queue>\n#include<cstdlib>\n#define MAX 3000\n#define F first\n#define S second\nusing namespace std;\n\nclass P{\npublic:\n  int to,rev,capacity;\n  P():to(0),rev(0),capacity(0){}\n  P(int to,int capacity,int rev):to(to),capacity(capacity),rev(rev){}\n};\n\n\ntypedef vector<int> VI;\ntypedef vector<vector<P> > VVP;\nVVP G;\nint st,ed;\nbool used[MAX];\n\nvoid add_node(int from,int to)\n{\n  G[from].push_back(P(to,1,G[to].size()));\n  G[to].push_back(P(from,0,G[from].size()-1));\n}\n\nint dfs(int now,int f)\n{\n  if(now == ed)\n    return f;\n  used[now] = true;\n\n  for(int i=0;i < G[now].size();i++)\n    {\n      P& p =  G[now][i];\n      if(used[p.to] || p.capacity <= 0)\n\tcontinue;\n\n      int res = dfs(p.to,min(f,p.capacity));\n      if(res <= 0)\n\tcontinue;\n\n      p.capacity -= res;\n      G[p.to][p.rev].capacity += res;\n      return res;\n    }\n  return 0;\n} \n\nint maximum_flow(int n)\n{\n  int res = 0;\n  for(;;)\n    {\n      for(int i=0;i<n;i++)\n\tused[i] = false;\n      int f = dfs(st,1000000000);\n      if(!f)\n\treturn res;\n      res += f;\n    }\n}\n\nint main()\n{\n\n  int b,r,bn,rn;\n\n  while(true)\n    {\n      // 0 -> start, bn+rn+1\n\n      cin >> bn >> rn;\n      if(bn+rn == 0)\n\tbreak;\n\n      st = 0,ed = bn+rn+1;\n      G.clear();\n      G.resize(2+bn+rn); \n\n      vector<int> bs;\n    \n      for(int i=0;i<bn;i++)\n\t{\n\t  cin >> b;\n\t  add_node(0,i+1);\n\t  bs.push_back(b);\n\t}\n\n      for(int i=0;i<rn;i++)\n\t{\n\t  cin >> r;\n\t  add_node(bn+i+1,ed);\n\t  for(int j=0;j<bs.size();j++)\n\t    if(__gcd(bs[j],r) != 1)\n\t\tadd_node(j+1,bn+i+1);\n\t      \n\t}\n\n      cout << maximum_flow(bn+rn+2) << endl;\n\n\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, -1, 0, 1 };\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\nvoid inputVector(vector<int> &v, int &n) {rep(i,n){v.push_back(nextInt());}}\nvoid inputVector(vector<double> &v, int &n) {rep(i,n){v.push_back(nextDouble());}}\nvoid inputVector(vector<string> &v, int &n) {rep(i,n){v.push_back(nextString());}}\n\nclass Graph {\nprivate:\n\tclass Edge {\n\tpublic:\n\t\tint to;\n\t\tint cap;\n\t\tint rev;\n\t\tEdge(int to, int cap, int rev) {\n\t\t\tthis->to = to;\n\t\t\tthis->cap = cap;\n\t\t\tthis->rev = rev;\n\t\t}\n\t};\n\n\tint calcFlow(int s, int t, int left) {\n\t\tif (s == t) return left;\n\n\t\tvisited[s] = true;\n\n\t\trep(i, nextEdges[s].size()) {\n\t\t\tEdge &edge = nextEdges[s][i];\n\t\t\tif (edge.cap == 0) continue;\n\t\t\tif (visited[edge.to]) continue;\n\t\t\tint flow = calcFlow(edge.to, t, min(left, edge.cap));\n\t\t\tif (flow > 0) {\n\t\t\t\tedge.cap -= flow;\n\t\t\t\tnextEdges[edge.to][edge.rev].cap += flow;\n\t\t\t\treturn flow;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tvector<bool> visited;\n\tvector<vector<Edge>> nextEdges, backUpNextEdges;\npublic:\n\tGraph() {}\n\tGraph(int n) {\n\t\tnextEdges.resize(n);\n\t\tvisited.resize(n);\n\t}\n\n\tvoid addEdge(int node, int to, int cap) {\n\t\tnextEdges[node].push_back(Edge(to, cap, nextEdges[to].size()));\n\t\tnextEdges[to].push_back(Edge(node, 0, nextEdges[node].size() - 1));\n\t}\n\n\tint calcMaxFlow(int s, int t) {\n\t\tbackUpNextEdges = nextEdges;\n\n\t\tint ret = 0;\n\t\twhile (true) {\n\t\t\trep(i, nextEdges.size()) visited[i] = false;\n\t\t\tint flow = calcFlow(s, t, INT_MAX);\n\t\t\tif (flow == 0) break;\n\t\t\tret += flow;\n\t\t}\n\n\t\tnextEdges = backUpNextEdges;\n\n\t\treturn ret;\n\t}\n};\n\nint gcd(int a, int b) {\n\tif (a < b) swap(a, b);\n\n\tif (a % b == 0) return b;\n\treturn gcd(b, a - b);\n}\n\nsigned main() {\n\tint m, n;\n\tcin >> m >> n;\n\n\twhile (m > 0) {\n\t\tvector<int> b, r;\n\t\tinputVector(b, m);\n\t\tinputVector(r, n);\n\n\t\tGraph g = Graph(m + n + 2);\n\n\t\trep(i, m) {\n\t\t\tg.addEdge(0, i + 1, 1);\n\n\t\t\trep(j, n) {\n\t\t\t\tif (gcd(b[i], r[j]) > 1) {\n\t\t\t\t\tg.addEdge(i + 1, m + j + 1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, n) {\n\t\t\tg.addEdge(m + i + 1, m + n + 1, 1);\n\t\t}\n\n\t\tcout << g.calcMaxFlow(0, m + n + 1) << endl;;\n\n\t\tcin >> m >> n;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n//typedef long long Int;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst) : src(src),dst(dst) {}\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) {}\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight :\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vec<Edge> Edges;\ntypedef vec<Edges> Graph;\n\n#define MAXMN 500\nint B[MAXMN];\nint R[MAXMN];\n\nint gcd(int a, int b)\n{   \n  return b != 0 ? gcd(b, a % b) : a;\n}\n\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e,g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  return match;\n}\n\n\nint main(int argc, char **argv) {\n  int M,N;\n  Graph g; g.reserve(MAXMN+MAXMN);\n  while(cin>>M>>N,M) {\n    g.clear();\n    g.resize((M+N)*2);\n    REP(i,M) cin>>B[i];\n    REP(i,N) cin>>R[i];\n    REP(i,M) {\n      Edges es, es2;\n      REP(j,N) {\n\tif(gcd(B[i],R[j])!=1) { es.pb(Edge(i,M+j)); es2.pb(Edge(M+j,i)); }\n      }\n      g[i] = es;\n      g[M+i] = es2;\n    }\n    cout << bipartiteMatching(g,M) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint gcd(int a,int b){\n\tif(a<b) swap(a,b);\n\tif(b==0) return a;\n\tgcd(b,a%b);\n}\n\nint main(){\n\n\tint n,m;\n\tint inp;\n\tint buse[500],ruse[500];\n\tvector<int> b,r;\n\tvector<int> gb[500],gr[500];\n\tbool f;\n\tint cnt;\n\n\twhile(1){\n\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0) break;\n\n\t\tif(!b.empty()) b.clear();\n\t\tif(!r.empty()) r.clear();\n\t\tfor(int i=0;i<500;i++) if(!gb[i].empty()) gb[i].clear();\n\t\tfor(int i=0;i<500;i++) if(!gr[i].empty()) gr[i].clear(); \n\t\tfor(int i=0;i<500;i++) buse[i]=0,ruse[i]=0;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>inp;\n\t\t\tb.push_back(inp);\n\t\t}\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>inp;\n\t\t\tr.push_back(inp);\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(gcd(b[i],r[j])!=1){\n\t\t\t\t\tgb[i].push_back(j);\n\t\t\t\t\tgr[j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcnt=0;\n\t\tfor(int i=1;i<500;){\n\t\t\tf=true;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(gb[j].size()==i&&buse[j]==0){\n\t\t\t\t\tfor(int k=0;k<gb[j].size();k++){\n\t\t\t\t\t\tif(ruse[gb[j][k]]==0){\n\t\t\t\t\t\t\tbuse[j]=1;\n\t\t\t\t\t\t\truse[gb[j][k]]=1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(gr[j].size()==i&&ruse[j]==0){\n\t\t\t\t\tfor(int k=0;k<gr[j].size();k++){\n\t\t\t\t\t\tif(buse[gr[j][k]]==0){\n\t\t\t\t\t\t\truse[j]=1;\n\t\t\t\t\t\t\tbuse[gr[j][k]]=1;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\tf=false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f) i++;\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct edge {\n\tint to, cap, rev;\n\tedge(int a, int b, int c) {\n\t\tto = a, cap = b, rev = c;\n\t}\n};\n\nint m, n;\nint b[500], w[500];\nvector<vector<edge>> G;\nbool used[1000 + 100];\nint INF = 100000000;\n\nvoid build_edge(int from, int to, int cap) {\n\tG[from].push_back(edge(to, cap, G[to].size()));\n\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvector<vector<int>> bpf;//b_prime_factor\nvector<vector<int>> wpf;//r_prime_factor\n\nvector<int> get_factor(int a) {\n\tvector<int> result;\n\tint p = 2;\n\twhile (p * p <= a) {\n\t\tint cnt = 0;\n\t\twhile (a % p == 0) {\n\t\t\ta /= p;\n\t\t\tcnt++;\n\t\t\tif (cnt == 1)result.push_back(p);\n\t\t}\n\t\tp++;\n\t}\n\tif(a != 1)result.push_back(a);\n\treturn result;\n}\n\nint main() {\n\n\twhile (1) {\n\t\tcin >> m >> n;\n\t\tif (!(m + n))break;\n\t\tbpf.resize(m), wpf.resize(n);\n\t\tG.resize(m + n + 2);\n\t\tfor (int i = 0; i < m; i++)cin >> b[i], bpf[i] = get_factor(b[i]);\n\t\tfor (int j = 0; j < n; j++)cin >> w[j], wpf[j] = get_factor(w[j]);\n\n\t\t//building edge by factors information\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tfor (int k = 0; k < bpf[i].size(); k++) {\n\t\t\t\t\tfor (int l = 0; l < wpf[j].size(); l++) {\n\t\t\t\t\t\tif (bpf[i][k] == wpf[j][l]) {\n\t\t\t\t\t\t\tbuild_edge(i + 1, j + m + 1, 1);\n\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tnext:;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++)build_edge(0, i + 1, 1);\n\t\tfor (int j = 0; j < n; j++)build_edge(j + m + 1, m + n + 1, 1);\n\t\t//get ans by network flow problem\n\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tfor (int i = 0; i < 1050; i++)used[i] = false;\n\t\t\tint f = dfs(0, m + n + 1, INF);\n\t\t\tif (f == 0)break;\n\t\t\tflow += f;\n\t\t}\n\t\tcout << flow << endl;\n\t\tG.clear(), bpf.clear(), wpf.clear();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n    int src, dst;\n    Edge(int f, int t) :\n        src(f), dst(t) {}\n};\nusing Edges = vector<Edge>;\nusing Graph =  vector<Edges>;\n\nbool Augment(const Graph& g, int u,\n             vector<int>& matchTo, vector<bool>& visited) {\n    if (u < 0) return true;\n\n    for (auto e : g[u])\n        if (!visited[e.dst]) {\n            visited[e.dst] = true;\n            if (Augment(g, matchTo[e.dst], matchTo, visited)) {\n                matchTo[e.src] = e.dst;\n                matchTo[e.dst] = e.src;\n                return true;\n            }\n        }\n\n    return false;\n}\n\nint BipartiteMaximumMatching(const Graph& g, int L) {\n    const int n = g.size();\n    Edges matching;\n    vector<int> matchTo(n, -1);\n    int match = 0;\n\n    for (int u = 0; u < L; ++u) {\n        vector<bool> visited(n);\n        if (Augment(g, u, matchTo, visited))\n            ++match;\n    }\n\n    for (int u = 0; u < L; ++u)\n        if (matchTo[u] >= 0) // make explicit matching\n            matching.emplace_back(Edge(u, matchTo[u]));\n\n    return match;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int m, n;\n\n    while (cin >> m >> n, m) {\n        vector<int> b(m), r(n);\n        for (auto &x : b) cin >> x;\n        for (auto &x : r) cin >> x;\n\n        Graph g(m + n);\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                if (__gcd(b[i], r[j]) != 1)\n                    g[i].emplace_back(Edge(i, j + m));\n\n        cout << BipartiteMaximumMatching(g, m) << '\\n';\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\nconst int MAXV = 100005;\nconst int MAXE = 150005;\nconst int INF = 1<<29;\n\nstruct BiparateMatching {\n    int N, M, E, match[MAXV+1], dist[MAXV+1];\n    int last[MAXE], prev[MAXE], to[MAXE];\n    BiparateMatching(int n, int m) : N(n), M(m), E(0) {\n        memset(last, -1, sizeof(last));\n    }\n    void add_edge(int x, int y) { // x \\in [0, N), y \\in [0, M)\n        to[E] = y + N; prev[E] = last[x]; last[x] = E; E++;\n    }\n    bool bfs() {\n        queue<int> q;\n        for (int i=0; i<N; ++i) {\n            if (match[i] == -1) {\n                q.push(i); dist[i] = 0;\n            } else dist[i] = INF;\n        }\n\n        bool ret = false;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = last[v]; e != -1; e = prev[e]) {\n                if (match[to[e]] == -1) ret = true;\n                else if (dist[match[to[e]]] == INF) {\n                    dist[match[to[e]]] = dist[v] + 1;\n                    q.push(match[to[e]]);\n                }\n            }\n        }\n        return ret;\n    }\n    bool dfs(int v) {\n        for (int e = last[v]; e != -1; e = prev[e]) {\n            bool update = false;\n            if (match[to[e]] == -1) {\n                match[to[e]] = v; match[v] = to[e];\n                update = true;\n            } else if (dist[match[to[e]]] == dist[v] + 1) {\n                if (dfs(match[to[e]])) {\n                    match[to[e]] = v; match[v] = to[e];\n                    update = true;\n                }\n            }\n            if (update) return true;\n        }\n        dist[v] = INF;\n        return false;\n    }\n    int matching() {\n        int ret = 0;\n        memset(match, -1, sizeof(match));\n        while(bfs()) {\n            for (int i=0; i<N; ++i)\n                if (match[i] == -1 && dfs(i)) ret++;\n        }\n        return ret;\n    }\n};\n\nint gcd(int x, int y) {\n    if (y == 0) return x;\n    return gcd(y, x%y);\n}\n\nint b[501], r[501];\nint main() {\n    int m,n;\n    while(scanf(\"%d %d\", &m, &n), m|n) {\n        BiparateMatching bm(m, n);\n        for (int i=0; i<m; ++i) scanf(\"%d\", &b[i]);\n        for (int i=0; i<n; ++i) scanf(\"%d\", &r[i]);\n        for (int i=0; i<m; ++i) {\n            for (int j=0; j<n; ++j)\n                if (gcd(b[i], r[j]) > 1) bm.add_edge(i, j);\n        }\n        printf(\"%d\\n\", bm.matching());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> g[1010];\nint n, m;\n \n//vector<bool> visited, matched;\n//vector<int> levels, matching;\nbool visited[1010],matched[1010];\nint levels[1010], matching[1010];\n \nbool augment(int left) {\n  if(left == n) return true;\n  if(visited[left]) return false;\n  visited[left] = true;\n  rep(i, g[left].size()) {\n    int right = g[left][i];\n    int next = matching[right];\n    if (levels[next] > levels[left] && augment(next)) {\n      matching[right] = left;\n      return true;\n    }\n  }\n  return false;\n}\n \nint bimatch() {\n  //matching.assign(m, n);\n  //matched.assign(n, false);\n  fill(matching, matching+m, n);\n  fill(matched, matched+n, false);\n  int ret = 0;\n  bool cont;\n  do {\n    //levels.assign(n+1, -1);\n    //memset(levels,-1,sizeof(levels));\n    fill(levels, levels+n+1, -1);\n    levels[n] = n;\n    queue<int> q;\n    rep(left, n) if (!matched[left]) {\n      q.push(left);\n      levels[left] = 0;\n    }\n    while(!q.empty()) {\n      int left = q.front();\n      q.pop();\n      rep(i, g[left].size()) {\n        int right = g[left][i];\n        int next = matching[right];\n        if (levels[next] < 0) {\n          levels[next] = levels[left] + 1;\n          q.push(next);\n        }\n      }\n    }\n    //visited.assign(n, false);\n    //memset(visit,false,sizeof(visit));\n    fill(visited, visited+n, false);\n    cont = false;\n    /*\n    rep(i,n){\n      cout << \"match:\" << i << \" : \" << matched[i] << endl;\n    }\n    rep(i,n){\n      cout << \"levels:\" << i << \" : \" << levels[i] << endl;\n    }\n      */\n    rep(left, n) if(!matched[left] && augment(left)){\n      matched[left] = cont = true;\n      ret++;\n    }\n  } while(cont);\n  //printf(\"ret:%d\\n\",ret);\n  //return count(matched.begin(), matched.end(), true);\n  return ret;\n}\n\nint blue[510],red[510];\n\nint main(){\n  while(scanf(\"%d%d\",&n,&m),n|m){\n    //init\n    rep(i,n+m)g[i].clear();\n    //visited.clear();\n    //matched.clear();\n    //levels.clear();\n    //matching.clear();\n    \n    \n    \n    rep(i,n)scanf(\"%d\",blue+i);\n    rep(i,m)scanf(\"%d\",red+i);\n\n    rep(i,n){\n      rep(j,m)if( __gcd(blue[i],red[j])!=1 ){\n        g[i].push_back(n+j);\n        g[n+j].push_back(i);\n      }\n    }\n    //\n    /*\n    rep(i,n+m){\n      printf(\"%d: \",i);\n      rep(j,g[i].size())printf(\"%d \",g[i][j]);\n      puts(\"\");\n    }\n      */\n    m += n;\n    printf(\"%d\\n\",bimatch());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,j,n) for(int i=j;i<n;++i)\n#define all(i) i.begin(),i.end()\n#define rall(i) i.rbegin(), i.rend()\n#define INF 1e9\n#define LINF 1e18\nconst int mod = 1e9 + 7;\n\ntypedef long long i64;\ntypedef pair<int, int> pi;\n\ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\n\ni64 gcd(i64 n, i64 m) {return (m == 0? n : gcd(m, n % m));}\ni64 lcd(i64 n, i64 m) {return (n / gcd(n, m) * m);}\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\n#include <vector>\n#include <cassert>\n#include <set>\n#include <queue>\n#include <functional>\n#include <algorithm>\n\nstruct edge {\n  int to;\n  int label;\n};\n\n\n::std::vector<::std::pair<int, int>> gabow_edmonds(const ::std::vector<::std::vector<int>>& gra){\n  // E0 - 初期化\n  int N = gra.size();\n  ::std::vector<::std::vector<edge>> g(N + 1);\n  ::std::vector<::std::pair<int, int>> edges;\n  {\n    int cnt = N + 1;\n    for(int i = 0;i < N;i++){\n      for(auto to : gra[i]){\n        if(i < to){\n          g[to + 1].push_back({i + 1, cnt});\n          g[i + 1].push_back({to + 1, cnt++});\n          edges.push_back({i + 1, to + 1});\n        }\n      }\n    }\n  }\n  ::std::vector<int> mate(N + 1 , 0);\n  ::std::vector<int> label(N + 1 , -1);\n  ::std::vector<int> first(N + 1 , 0);\n  ::std::queue<int> que;\n\n  // firstの遅延評価\n  ::std::function<int(int)> eval_first = [&](int x){\n    if(label[first[x]] < 0) return first[x];\n    first[x] = eval_first(first[x]);\n    return first[x];\n  };\n\n  // サブルーチンR\n  ::std::function<void(int, int)> rematch = [&](int v, int w){\n    // R1\n    int t = mate[v];\n    mate[v] = w;\n    if(mate[t] != v) return;\n    // R2\n    if(label[v] <= N){\n      mate[t] = label[v];\n      rematch(label[v] , t);\n    }\n    // R3\n    else{\n      int x = edges[label[v] - N - 1].first;\n      int y = edges[label[v] - N - 1].second;\n      rematch(x , y);\n      rematch(y , x);\n    }\n  };\n\n  ::std::function<void(int, int, int)> assignLabel = [&](int x, int y, int num){\n    // L0\n    int r = eval_first(x);\n    int s = eval_first(y);\n    int join = 0;\n    if(r == s) return;\n    // -numがフラグ\n    label[r] = -num;\n    label[s] = -num;\n    while(true){\n      // L1\n      if(s != 0) ::std::swap(r , s);\n      // L2\n      r = eval_first(label[mate[r]]);\n      if(label[r] == -num){\n        join = r;\n        break;\n      }\n      label[r] = -num;\n    }\n    // L3\n    int v = first[x];\n    // L4\n    while(v != join){\n      que.push(v);\n      label[v] = num;\n      first[v] = join;\n      v = first[label[mate[v]]];\n    }\n    // L3\n    v = first[y];\n    // L4\n    while(v != join){\n      que.push(v);\n      label[v] = num;\n      first[v] = join;\n      v = first[label[mate[v]]];\n    }\n    // L5は遅延評価しているため不要\n    // L6\n    return;\n  };\n\n  ::std::function<bool(int)> augment_check = [&](int u){\n    // E1 後半\n    first[u] = 0;\n    label[u] = 0;\n    que.push(u);\n    while(!que.empty()){\n      // E2 \n      int x = que.front();\n      que.pop();\n      for(auto e : g[x]){\n        int y = e.to;\n        // E3\n        if(mate[y] == 0 && y != u){\n          mate[y] = x;\n          rematch(x , y);\n          return true;\n        }\n        // E4\n        else if(label[y] >= 0){\n          assignLabel(x , y , e.label);\n        }\n        // E5\n        else if(label[mate[y]] < 0){\n          label[mate[y]] = x;\n          first[mate[y]] = y;\n          que.push(mate[y]);\n        }\n        // E6\n      }\n    }\n    return false;\n  };\n\n  for(int i = 1;i <= N;i++){\n    // E1\n    que = ::std::queue<int>();\n    if(mate[i] != 0) continue;\n    if(augment_check(i)){\n      // E7\n      ::std::fill(label.begin(), label.end(), -1);\n    }\n  }\n\n  ::std::vector<::std::pair<int, int>> ans;\n  for(int i = 1;i <= N;i++){\n    if(i < mate[i]){\n      ans.push_back({i , mate[i]});\n    }\n  }\n  return ans;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int m, n;\n  while(cin >> m >> n, m != 0 || n != 0) {\n    vt<int> b(m), r(n);\n    rep(i, 0, m) cin >> b[i];\n    rep(i, 0, n) cin >> r[i];\n\n    vector<vector<int>> g(n + m);\n\n    rep(i, 0, m) {\n      rep(j, 0, n) {\n        if(gcd(b[i], r[j]) != 1) {\n          g[i].push_back(j + m);\n          g[j + m].push_back(i);\n        }\n      }\n    }\n    cout << gabow_edmonds(g).size() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,n) reep((i),0,(n))\n\ntypedef vector<int> vint;\n\n\ntemplate<class V> class MaxFlow_dinic{\npublic:\n\tstruct edge{int to,reve;V cap;};\n\tstatic const int MV = 1100;\n\tvector<edge> E[MV];\n\tint itr[MV],lev[MV];\n\n\tvoid add_edge(int x,int y,V cap,bool undir=false){\n\t\tE[x].push_back((edge){y,(int)E[y].size(),cap});\n\t\tE[y].push_back((edge){x,(int)E[x].size()-1,undir?cap:0});\n\t}\t\n\tvoid bfs(int cur){\n\t\tmemset(lev,0xff,sizeof(lev));\n\t\tqueue<int> q;\n\t\tlev[cur]=0;\n\t\tq.push(cur);\n\t\twhile(q.size()){\n\t\t\tint v=q.front();\n\t\t\tq.pop();\n\t\t\tfor(__typeof(E[v].begin()) e=E[v].begin();e!=E[v].end();e++) if(e->cap>0&&lev[e->to]<0) lev[e->to]=lev[v]+1,q.push(e->to);\n\t\t}\n\t}\n\n\tV dfs(int from,int to,V cf){\n\t\tif(from==to){\n\t\t\treturn cf;\n\t\t}\n\t\tfor(;itr[from]<E[from].size();itr[from]++){\n\t\t\tedge* e=&E[from][itr[from]];\n\t\t\tif(e->cap>0&&lev[from]<lev[e->to]){\n\t\t\t\tV f=dfs(e->to,to,min(cf,e->cap));\n\t\t\t\tif(f>0){\n\t\t\t\t\te->cap-=f;\n\t\t\t\t\tE[e->to][e->reve].cap += f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tV maxflow(int from,int to){\n\t\tV fl = 0,tf;\n\t\twhile(1){\n\t\t\tbfs(from);\n\t\t\tif(lev[to]<0) return fl;\n\t\t\tmemset(itr,0,sizeof(itr));\n\t\t\twhile((tf=dfs(from,to,numeric_limits<V>::max()))>0) fl += tf;\n\t\t}\n\t}\n};\n\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\tvint a(n);\n\t\tvint b(m);\n\t\trep(i,n) cin>>a[i];\n\t\trep(i,m) cin>>b[i];\n\t\tMaxFlow_dinic<int> mf;\n\t\trep(i,n){\n\t\t\trep(j,m){\n\t\t\t\tint t = __gcd(a[i],b[j]);\n\t\t\t\tif(t==1) continue;\n\t\t\t\tmf.add_edge(i,n+j,1);\n\t\t\t}\n\t\t}\n\t\tint souce = n+m;\n\t\tint sink = n+m+1;\n\t\trep(i,n) mf.add_edge(souce,i,1);\n\t\trep(i,m) mf.add_edge(n+i,sink,1);\n\t\tint ans = 0;\n\t\tans = mf.maxflow(souce,sink);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntemplate <class T> constexpr T inf=numeric_limits<T>::max()/(T)16;\n\ntemplate <class cost_t = int_fast64_t, class cap_t = int_fast64_t>\nstruct Flow {\n    struct edge { int to; cost_t cost; cap_t cap; edge *rev; };\n    size_t V,E;\n    bool neg_edge_exist;\n    vector<vector<edge>> adj;\n\n    Flow(size_t _V) : V(_V),E(),neg_edge_exist() {\n        adj.resize(V * 2);\n        if(V <= 3e3) for(size_t v = 0; v != V * 2; ++v) adj[v].reserve(V * 2);\n    }\n\n    void add_edge(int from, int to, cost_t cost, cap_t cap) {\n        adj[from].emplace_back((edge){ to, cost, cap, nullptr });\n        adj[to].emplace_back((edge){ from, -cost, 0, nullptr });\n        adj[from].back().rev = &(adj[to].back());\n        adj[to].back().rev = &(adj[from].back());\n        ++E; if(cost < 0) neg_edge_exist = true;\n    }\n\n    vector<cost_t> Dijkstra(int s) {\n        vector<cost_t> dist(V,inf<cost_t>);\n        priority_queue<pair<cost_t,int>,vector<pair<cost_t,int>>,greater<pair<cost_t,int>>> que;\n        que.emplace(dist[s] = 0, s);\n        while(!que.empty()) {\n            auto p = que.top(); que.pop();\n            int v = p.second;\n            if(dist[v] < p.first) continue;\n            for(edge &e : adj[v]) {\n                if(e.cap > 0 && dist[v] + e.cost < dist[e.to]) que.emplace(dist[e.to] = dist[v] + e.cost, e.to);\n            } \n        }\n        return dist;\n    }\n\n    struct Fold_Fulkerson_exe {\n        Flow &F;\n        vector<bool> used;\n\n        Fold_Fulkerson_exe(Flow &_F) : F(_F) {\n            used.resize(F.V);\n        }\n\n        cap_t dfs(int v, int t, cap_t f) {\n            if(v == t) return f;\n            used[v] = true;\n            for(edge &e : F.adj[v]) {\n                if(!used[e.to] && e.cap > 0) {\n                    cap_t d = dfs(e.to,t,min(f,e.cap));\n                    if(d > 0) {\n                        e.cap -= d;\n                        e.rev->cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        cap_t max_flow(int s, int t) {\n            cap_t flow = 0,f;\n            while(true) {\n                fill(begin(used),end(used),false);\n                if((f = dfs(s,t,numeric_limits<cap_t>::max())) > 0) flow += f;\n                else break;\n            }\n            return flow;\n        }\n    };\n\n    cap_t Fold_Fulkerson(int s, int t) { return Fold_Fulkerson_exe(*this).max_flow(s,t); }\n    \n    struct Dinic_exe {\n        Flow &F;\n        vector<int> level,itr;\n\n        Dinic_exe(Flow &_F) : F(_F) {\n            level.resize(F.V), itr.resize(F.V);\n        }\n\n        void bfs(int s) {\n            fill(begin(level),end(level),-1);\n            queue<int> que;\n            level[s] = 0;\n            que.emplace(s);\n            while(!que.empty()) {\n                int v = que.front(); que.pop();\n                for(edge &e : F.adj[v]) {\n                    if(e.cap > 0 && level[e.to] < 0) {\n                        level[e.to] = level[v] + 1;\n                        que.emplace(e.to);\n                    }\n                } \n            }\n        }\n\n        cap_t dfs(int v, int t, cap_t f) {\n            if(v == t) return f;\n            for(int &i = itr[v]; i != F.adj[v].size(); ++i) {\n                edge &e = F.adj[v][i];\n                if(e.cap > 0 && level[v] < level[e.to]) {\n                    cap_t d = dfs(e.to, t, min(f,e.cap));\n                    if(d > 0) {\n                        e.cap -= d;\n                        e.rev->cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        cap_t max_flow(int s, int t) {\n            cap_t flow = 0,f;\n            while(true) {\n                bfs(s);\n                if(level[t] < 0) return flow;\n                fill(begin(itr),end(itr),0);\n                while((f = dfs(s,t,numeric_limits<cap_t>::max())) > 0) flow += f;\n            }\n        }\n    };\n\n    cap_t Dinic(int s, int t) { return Dinic_exe(*this).max_flow(s,t); }\n\n    struct Primal_Dual_exe {\n        Flow &F;\n        vector<cost_t> dist,h;\n        vector<int> prev_v;\n        vector<edge*> prev_e;\n\n        Primal_Dual_exe(Flow &_F) : F(_F) {\n            dist.resize(F.V), h.resize(F.V), prev_v.resize(F.V), prev_e.resize(F.V);\n        }\n\n        bool Dijkstra(int s, int t) {\n            priority_queue<pair<cost_t,int>,vector<pair<cost_t,int>>,greater<pair<cost_t,int>>> que;\n            fill(begin(dist),end(dist),inf<cost_t>);\n            que.emplace(dist[s] = 0, s);\n            while(!que.empty()) {\n                cost_t cs; int v;\n                tie(cs,v) = que.top();\n                que.pop();\n                if(cs > dist[v]) continue;\n                for(edge &e : F.adj[v]) {\n                    if(e.cap > 0 && dist[v] + h[v] + e.cost < dist[e.to] + h[e.to]) {\n                        que.emplace(dist[e.to] = dist[v] + h[v] - h[e.to] + e.cost, e.to);\n                        prev_v[e.to] = v;\n                        prev_e[e.to] = &e;\n                    }\n                }\n            } \n            if(dist[t] >= inf<cost_t>) return false;\n            for(int v = 0; v < F.V; ++v) h[v] += dist[v];\n            return true;\n        }\n\n        cost_t min_cost_flow(int s, int t, cap_t f) {\n            cost_t res = 0;\n            fill(begin(h),end(h),0);\n            while(f > 0) {\n                if(!Dijkstra(s,t)) return inf<cost_t>;\n                cap_t d = f;\n                for(int v = t; v != s; v = prev_v[v]) d = min(d, prev_e[v]->cap);\n                f -= d;\n                res += d * h[t];\n                for(int v = t; v != s; v = prev_v[v]) {\n                    prev_e[v]->cap -= d;\n                    prev_e[v]->rev->cap += d;\n                }\n            }\n            return res;\n        }\n    };\n\n    cost_t Primal_Dual(int s, int t, cap_t f) {\n        cost_t corr = 0;\n        if(neg_edge_exist) {\n            neg_edge_exist = false;\n            int _s = V++;\n            int _t = V++;\n            add_edge(_s,s,0,f);\n            add_edge(t,_t,0,f);\n            s = _s, t = _t;\n            for(int v = 0; v < V; ++v) {\n                for(edge &e : adj[v]) {\n                    if(e.cost < 0) {\n                        f += e.cap;\n                        add_edge(s,e.to,0,e.cap);\n                        add_edge(v,t,0,e.cap);\n                        corr += e.cap * e.cost;\n                        e.rev->cap += e.cap;\n                        e.cap = 0;\n                    }\n                }\n            }\n        }\n        return Primal_Dual_exe(*this).min_cost_flow(s,t,f) + corr;\n    } \n};\n\nlong long gcd(long long a, long long b) {\n    if(a%b) {\n        return gcd(b,a%b);\n    }\n    return b;\n}\n\nint m,n;\nint b[510],r[510];\n\n\nvoid solve() {\n    Flow<> flow(n+m+2);\n    for(int i=0; i<m; ++i) {\n        cin>>b[i];\n    }\n    for(int i=0; i<n; ++i) {\n        cin>>r[i];\n    }\n    for(int i=0; i<m; ++i) {\n        flow.add_edge(n+m,i,0,1);\n        for(int j=0; j<n; ++j) {\n            if(gcd(b[i],r[j])>1) {\n                flow.add_edge(i,j+m,0,1);\n            }\n        }\n    }\n    for(int i=0; i<n; ++i) {\n        flow.add_edge(i+m,n+m+1,0,1);\n    }\n    cout<< flow.Fold_Fulkerson(n+m,n+m+1) <<endl;\n}\n\nint main() {\n    while(1) {\n        cin>>m>>n;\n        if(!m) return 0;\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nconst int MAX = 1000;\nconst int INF = 1<<28;\n#define gcd(a,b) __gcd(a,b)\n\nstruct edge{ int to, cap, rev;};\n\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to ,cap ,G[to].size()});\n  G[to].push_back((edge){from ,0 ,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0 ; i < G[v].size() ; i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n\n  for(;;){\n    memset(used,false,sizeof(used));\n    int f = dfs(s,t,INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main(){\n  int m,n,b,r;\n  \n  while(cin >> m >> n , m + n){\n    vector<int> B,R;\n    int s = m+n,t = s+1;\n    memset(G,0,sizeof(G));\n    for(int i = 0 ; i < m ; i++){\n      cin >> b;\n      B.push_back(b);\n      add_edge(s,i,1);\n    }\n\n    for(int j = 0 ; j < n ; j++){\n      cin >> r;\n      R.push_back(r);\n      add_edge(m+j,t,1);\n    }\n \n    for(int i = 0 ; i < m ; i++){\n      for(int j = 0 ; j < n ; j++){\n\tif(gcd(B[i],R[j]) != 1){\n\t  add_edge(i,m+j,1);\n\t}\n      }\n    }\n    cout << max_flow(s,t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\n\n#define MAX_V 2222\nvector<int> v[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int a,int b){\n\tv[a].pb(b);\n\tv[b].pb(a);\n}\n\nbool matchdfs(int a)\n{\n  used[a] = true;\n  for(int i = 0;i < v[a].size();i++)\n    {\n      int u = v[a][i],w = match[u];\n      if(w < 0 || !used[w] && matchdfs(w))\n\t{\n\t  match[u] = a;\n\t  match[a] = u;\n\t  return true;\n\t}\n    }\n  return false;\n}\n\n//二部マッチング\nint two_matching_max(int l)\n{\n  int res = 0;\n  memset(match,-1,sizeof(match));\n  for(int v=0;v<l;v++)\n    {\n      if(match[v] < 0)\n\t{\n\t  memset(used,0,sizeof(used));\n\t  if(matchdfs(v))res++;\n\t}\n    }\n  return res;\n}\nint gcd(int a,int b){\n  int aa=max(a,b);\n  int bb=min(a,b);\n  int cc=aa%bb;\n  while(cc!=0){\n    int tmp=cc;\n    cc=bb%cc;\n    bb=tmp;\n  }\n  return bb;\n}\nint main(){\n  int m,n;\n  while(cin>>m>>n,m){\n    for(int i=0;i<MAX_V;i++){\n      v[i].clear();\n    }\n    vector<int>blue(m);\n    //cout<<gcd(7,10)<<endl;\n    for(int i=0;i<m;i++)\n      cin>>blue[i];\n    for(int i=0;i<n;i++){\n      int num;cin>>num;\n      for(int j=0;j<m;j++){\n\tif(gcd(num,blue[j])>1){\n\t  add_edge(i,j+n);\n\t}\n      }\n    }\n    cout<<two_matching_max(n+m)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n// max_flow\nconst int MAX_V = 510;\nclass FordFulkerson {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n        edge() {}\n        edge(int t, int c, int r) : to(t), cap(c), rev(r) {}\n    };\n    vector<edge> G[MAX_V];\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back(edge(to, cap, G[to].size()));\n        G[to].push_back(edge(from, 0, G[from].size() - 1));\n    }\n    int max_flow(int s, int t) {\n        int flow = 0;\n        while (1) {\n            for (int i = 0; i < MAX_V; i++) used[i] = false;\n            int f = dfs(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\nprivate:\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (!used[e.to] && e.cap > 0) {\n                int d = dfs(e.to, t, min(e.cap, f));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    bool used[MAX_V];\n};\n\nint b[600], r[600];\n\nint main(void) {\n    int m, n;\n    while (cin >> m >> n) {\n        if (m == 0 && n == 0) break;\n        FordFulkerson ff;\n        for (int i = 0; i < m; i++) {\n            cin >> b[i];\n        }\n        for (int i = 0; i < n; i++) {\n            cin >> r[i];\n        }\n        int s = m+n, t = s+1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (__gcd(b[i], r[j]) > 1) {\n                    ff.add_edge(i, m+j, 1);\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            ff.add_edge(s, i, 1);\n        }\n        for (int i = 0; i < n; i++) {\n            ff.add_edge(i+m, t, 1);\n        }\n        cout << ff.max_flow(s, t) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<math.h>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<complex>\n#define REP(i, N) for(ll i = 0; i < N; ++i)\n#define FOR(i, a, b) for(ll i = a; i < b; ++i)\n#define ALL(a) (a).begin(),(a).end()\n#define pb push_back\n#define INF (long long)1000000000\n#define MOD 1000000007\n#define EPS (long double) 1e-8\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nint dh[4] = {1, 0, -1, 0};\nint dw[4] = {0, 1, 0, -1};\n\nvector<int> card;\nvector<vector<int> > g;\nvector<int> match;\nvector<bool> used;\n\nbool euclid(int a, int b) {\n\tif(a < b) swap(a, b);\n\tif(a % b == 0) return !(b == 1);\n\telse {\n\t\treturn euclid(b, a % b);\n\t}\n}\n\nbool dfs(int v) {\n\tused[v] = true;\n\tREP(i, g[v].size()) {\n\t\tint u = g[v][i], w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void) {\n\twhile(true) {\n\t\tint m, n;\n\t\tcin>>m>>n;\n\t\tif(m == 0 && n == 0) break;\n\t\tcard.resize(0);\n\t\tcard.resize(m + n);\n\t\tg.resize(0);\n\t\tg.resize(m + n);\n\t\tmatch.resize(0);\n\t\tmatch.resize(m + n);\n\t\tused.resize(0);\n\t\tused.resize(m + n);\n\t\tREP(i, m) cin>>card[i];\n\t\tREP(i, n) cin>>card[m + i];\n\t\tREP(i, m) {\n\t\t\tFOR(j, m, m + n) {\n\t\t\t\tif(euclid(card[i], card[j])) g[i].pb((int)j);\n\t\t\t}\n\t\t}\n\t\tFOR(i, m, m + n) {\n\t\t\tREP(j, m) {\n\t\t\t\tif(euclid(card[i], card[j])) g[i].pb((int)j);\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tREP(i, m + n) match[i] = -1;\n\t\tREP(v, m + n) {\n\t\t\tif(match[v] < 0) {\n\t\t\t\tREP(i, m + n) used[i] = false;\n\t\t\t\tif(dfs((int)v)) {\n\t\t\t\t\t++res;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n\nstruct HopcroftKarp {\n    int sizeL, sizeR;\n    vector<vector<int> > list; // left to right\n    \n    // result\n    vector<bool> seen, matched;\n    vector<int> level, matching;\n\n    // base\n    HopcroftKarp(int l, int r) : sizeL(l), sizeR(r), list(l, vector<int>()) { }\n    inline vector<int>& operator [] (int i) { return list[i]; }\n    inline void addedge(int from, int to) { list[from].push_back(to); }\n    inline friend ostream& operator << (ostream& s, const HopcroftKarp& G) {\n        s << endl;\n        for (int i = 0; i < G.list.size(); ++i) {\n            s << i << \" : \";\n            for (int j = 0; j < G.list[i].size(); ++j) {\n                s << G.list[i][j];\n                if (j + 1 != G.list[i].size()) s << \", \";\n            }\n            s << endl;\n        }\n        return s;\n    }\n    \n    // methods\n    void hobfs() {\n        queue<int> que;\n        for (int left = 0; left < sizeL; ++left) {\n            level[left] = -1;\n            if (!matched[left]) {\n                que.push(left);\n                level[left] = 0;\n            }\n        }\n        level[sizeL] = sizeL;\n        while (!que.empty()) {\n            int left = que.front();\n            que.pop();\n            for (int i = 0; i < list[left].size(); ++i) {\n                int right = list[left][i];\n                int next = matching[right];\n                if (level[next] == -1) {\n                    level[next] = level[left] + 1;\n                    que.push(next);\n                }\n            }\n        }\n    }\n    bool hodfs(int left) {\n        if (left == sizeL) return true;\n        if (seen[left]) return false;\n        seen[left] = true;\n        for (int i = 0; i < list[left].size(); ++i) {\n            int right = list[left][i];\n            int next = matching[right];\n            if (level[next] > level[left] && hodfs(next)) {\n                matching[right] = left;\n                return true;\n            }\n        }\n        return false;\n    }\n    int solve() {\n        seen.assign(sizeL, false);\n        matched.assign(sizeL, false);\n        level.assign(sizeL+1, -1);\n        matching.assign(sizeR, sizeL);\n        int res = 0;\n        while (true) {\n            hobfs();\n            seen.assign(sizeL, false);\n            bool finished = true;\n            for (int left = 0; left < sizeL; ++left) {\n                if (!matched[left] && hodfs(left)) {\n                    matched[left] = true;\n                    ++res;\n                    finished = false;\n                }\n            }\n            if (finished) break;\n        }\n        return res;\n    }\n};\n\n\nint GCD(int a, int b) { return b ? GCD(b, a%b) : a; }\n\nint main() {\n    int N, M;\n    while (cin >> N >> M, N) {\n        HopcroftKarp G(N, M);\n        vector<int> left(N), right(M);\n        for (int i = 0; i < N; ++i) cin >> left[i];\n        for (int i = 0; i < M; ++i) cin >> right[i];\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < M; ++j) {\n                if (GCD(left[i], right[j]) > 1)\n                    G.addedge(i, j);\n            }\n        }\n        cout << G.solve() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\ntypedef vector<vector<char> > G;\n\nint flow(G &g, int s, int d){\n  int n = g.size();\n  int ans = 0;\n\n  while(true){\n    vector<int> prevs(n,-1);\n    queue<int> q;\n    bool ok = false;\n\n    prevs[s]=n;\n    q.push(s);\n    while(!q.empty()){\n      int now = q.front();\n      q.pop();\n      if(now == d){\n        ok = true;\n        break;\n      }\n      for(int i=0;i<n;i++){\n        if(g[now][i]>0){\n          if(prevs[i]==-1){\n            prevs[i]=now;\n            q.push(i);\n          }\n        }\n      }\n    }\n\n    if(!ok) return ans;\n\n    int f = 1;\n\n    int pos = d;\n    while(pos != s){\n      int pos2 = prevs[pos];\n      g[pos2][pos]-=f;\n      g[pos][pos2]+=f;\n      pos = pos2;\n    }\n    ans += f;\n  }\n}\n\nint gcd(int a, int b){\n  if(a > b) swap(a, b);\n  if(a == 0) return b;\n  return gcd(a, b%a);\n}\n\n\nint main(){\n  int m,n;\n  int r[500];\n  int b[500];\n  while((m = getInt()) + (n = getInt())){\n    vector<vector<char> > g(n+m+2, vector<char>(n+m+2, 0));\n\n    REP(i,m){\n      b[i] = getInt();\n      g[n+m][i] = 1;\n    }\n    REP(i,n){\n      r[i] = getInt();\n      g[m+i][n+m+1] = 1;\n    }\n\n    REP(i,m) REP(j,n) if(gcd(b[i], r[j]) != 1)\n      g[i][m+j] = 1;\n\n    print(flow(g, n+m, n+m+1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct edge {\n\tint to, cap, rev;\n\tedge(int t, int c, int r):to(t), cap(c), rev(r){}\n};\n\nvector<vector<edge> > G;\nvector<int> level;\nvector<int> iter;\n\nvoid init(int v) {\n\tG.clear();\n\tG.resize(v);\n\tlevel.clear();\n\tlevel.resize(v);\n\titer.clear();\n\titer.resize(v);\n}\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge(to, cap, G[to].size()));\n\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nvoid bfs(int s) {\n\tfill(level.begin(), level.end(), -1);\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\n\twhile(!que.empty()) {\n\t\tint v = que.front();\n\t\tque.pop();\n\n\t\tfor(int i = 0; i < G[v].size(); ++i) {\n\t\t\tconst edge& e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int t, int f) {\n\tif(v == t)\n\t\treturn f;\n\n\tfor(int& i = iter[v]; i < G[v].size(); ++i) {\n\t\tedge& e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint max_flow(int s, int t) {\n\tint flow = 0;\n\n\tfor(;;) {\n\t\tbfs(s);\n\t\tif(level[t] < 0)\n\t\t\treturn flow;\n\n\t\tfill(iter.begin(), iter.end(), 0);\n\t\tint f;\n\t\twhile((f = dfs(s, t, INT_MAX)) > 0)\n\t\t\tflow += f;\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int m, n; cin >> m >> n, m;) {\n\t\tint source = m + n, sink = m + n + 1;\t\n\t\tinit(m + n + 2);\n\n\t\tvector<int> b(m), r(n);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tcin >> b[i];\n\t\t\tadd_edge(source, i, 1);\n\t\t}\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> r[i];\n\t\t\tadd_edge(m + i, sink, 1);\n\t\t}\n\n\t\tfor(int i = 0; i < m; ++i)\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tif(__gcd(b[i], r[j]) > 1)\n\t\t\t\t\tadd_edge(i, j + m, 1);\n\n\t\tcout << max_flow(source, sink) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\nconst int MAXV = 1005;\nconst int MAXE = 505 * 505;\nconst int INF = 1<<29;\n\nstruct BiparateMatching {\n    int N, M, E, match[MAXV+1], dist[MAXV+1];\n    int last[MAXE], prev[MAXE], to[MAXE];\n    BiparateMatching(int n, int m) : N(n), M(m), E(0) {\n        memset(last, -1, sizeof(last));\n    }\n    void add_edge(int x, int y) { // x \\in [0, N), y \\in [0, M)\n        to[E] = y + N; prev[E] = last[x]; last[x] = E; E++;\n    }\n    bool bfs() {\n        queue<int> q;\n        for (int i=0; i<N; ++i) {\n            if (match[i] == -1) {\n                q.push(i); dist[i] = 0;\n            } else dist[i] = INF;\n        }\n\n        bool ret = false;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = last[v]; e != -1; e = prev[e]) {\n                if (match[to[e]] == -1) ret = true;\n                else if (dist[match[to[e]]] == INF) {\n                    dist[match[to[e]]] = dist[v] + 1;\n                    q.push(match[to[e]]);\n                }\n            }\n        }\n        return ret;\n    }\n    bool dfs(int v) {\n        for (int e = last[v]; e != -1; e = prev[e]) {\n            bool update = false;\n            if (match[to[e]] == -1) {\n                match[to[e]] = v; match[v] = to[e];\n                update = true;\n            } else if (dist[match[to[e]]] == dist[v] + 1) {\n                if (dfs(match[to[e]])) {\n                    match[to[e]] = v; match[v] = to[e];\n                    update = true;\n                }\n            }\n            if (update) return true;\n        }\n        dist[v] = INF;\n        return false;\n    }\n    int matching() {\n        int ret = 0;\n        memset(match, -1, sizeof(match));\n        while(bfs()) {\n            for (int i=0; i<N; ++i)\n                if (match[i] == -1 && dfs(i)) ret++;\n        }\n        return ret;\n    }\n};\n\nint gcd(int x, int y) {\n    if (y == 0) return x;\n    return gcd(y, x%y);\n}\n\nint b[501], r[501];\nint main() {\n    int m,n;\n    while(scanf(\"%d %d\", &m, &n), m|n) {\n        BiparateMatching bm(m, n);\n        for (int i=0; i<m; ++i) scanf(\"%d\", &b[i]);\n        for (int i=0; i<n; ++i) scanf(\"%d\", &r[i]);\n        for (int i=0; i<m; ++i) {\n            for (int j=0; j<n; ++j)\n                if (gcd(b[i], r[j]) > 1) bm.add_edge(i, j);\n        }\n        printf(\"%d\\n\", bm.matching());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int INF = 1e9;\n\nstruct edge{\n  int to, cap, rev;\n  edge(int t, int c, int r){\n    to = t; cap = c; rev = r;\n  }\n};\n\nvoid add_edge(int from, int to, int cap, vector< vector<edge> > &g){\n  g[from].push_back( edge(to,cap,g[to].size()) );\n  g[to].push_back( edge(from,0,g[from].size()-1) );\n}\n\nint dfs(int v,int t, int f, vector< vector<edge> > &g, vector<int> &used){\n  if(v==t)return f;\n  used[v] = 1;\n  for(edge &e : g[v]){\n    if(!used[e.to] && e.cap>0){\n      int d = dfs(e.to,t,f,g,used);\n      if(d>0){\n\te.cap -= d;\n\tg[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t, vector< vector<edge> > &g){\n  int flow = 0;\n  while(1){\n    vector<int> used(g.size(),0);\n    int f = dfs(s,t,INF,g,used);\n    if(f==0)return flow;\n    flow += f;\n  }\n}\n\nint gcd(int a,int b){\n  if(!b)return a;\n  return gcd(b,a%b);\n}\n\nint main(){\n  int m,n;\n  while(1){\n    cin >> m >> n;\n    if(!m && !n)break;\n\n    vector<int> b(m),r(n);\n    for(int i=0;i<m;i++)cin >> b[i];\n    for(int i=0;i<n;i++)cin >> r[i];\n\n    vector< vector<edge> > g(n+m+2);\n    for(int i=1;i<=m;i++)add_edge(0,i,1,g);\n    for(int i=m+1;i<=m+n;i++)add_edge(i,m+n+1,1,g);\n\n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n\tif(gcd(b[i],r[j])>1)add_edge(i+1,m+j+1,1,g);\n      }\n    }\n\n    cout << max_flow(0,m+n+1,g) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n\nint main(){\n  int m,n,mc[500],nc[500],buf,nt=0,mt=0,lop3=0,cnt,max,num;\n\n  cin>>m;\n  cin>>n;\n\n  while(m!=0 || n!=0){\n\n    for(int lop=0;lop<500;lop++){\n      mc[lop]=0;\n      nc[lop]=0;\n    }\n    nt=0;\n    mt=0;\n    lop3=0;\n    cnt=0;\n    for(int lop=0;lop<m;lop++){\n      cin>>mc[lop];\n    }\n    for(int lop=0;lop<n;lop++){\n      cin>>nc[lop];\n    }\n\n    for(int lop=0;lop<n;lop++){\n      for(int lop2=0;lop2<n-1;lop2++){\n          if(nc[lop2]<nc[lop2+1]){\n            buf=nc[lop2];\n            nc[lop2]=nc[lop2+1];\n            nc[lop2+1]=buf;\n          }\n      }\n    }\n    for(int lop=0;lop<m;lop++){\n      for(int lop2=0;lop2<m-1;lop2++){\n          if(mc[lop2]<mc[lop2+1]){\n            buf=mc[lop2];\n            mc[lop2]=mc[lop2+1];\n            mc[lop2+1]=buf;\n          }\n      }\n    }\n\n    while(m!=0 && n!=0 && mt<m && nt<n){\n      if(nc[nt]<mc[mt]){\n        for(int lop=0;lop<n;lop++){\n          if(mc[mt]==0 || nc[lop]==0){\n            break;\n          }\n          if(mc[mt]%nc[lop]==0){\n            mc[mt]=0;\n            nc[lop]=0;\n            cnt++;\n            for(int lop2=mt;lop2<m-1;lop2++){\n              mc[lop2]=mc[lop2+1];\n            }\n            m--;\n            for(int lop2=lop;lop2<n-1;lop2++){\n              nc[lop2]=nc[lop2+1];\n            }\n            n--;\n            mt--;\n            break;\n          }else{\n            num=2;\n            for(int lop2=num;lop2<=mc[mt];lop2++){\n              if(mc[mt]%lop2==0 && nc[lop]%lop2==0){\n                mc[mt]=0;\n                nc[lop]=0;\n                cnt++;\n                for(int lop2=mt;lop2<m-1;lop2++){\n                  mc[lop2]=mc[lop2+1];\n                }\n                m--;\n                for(int lop2=lop;lop2<n-1;lop2++){\n                  nc[lop2]=nc[lop2+1];\n                }\n                n--;\n                mt--;\n                break;\n              }\n            }\n          }\n        }\n        mt++;\n      }else{\n        for(int lop=0;lop<n;lop++){\n          if(nc[nt]==0 || mc[lop]==0){\n            break;\n          }\n          if(nc[nt]%mc[lop]==0){\n            nc[nt]=0;\n            mc[lop]=0;\n            cnt++;\n            for(int lop2=lop;lop2<m-1;lop2++){\n              mc[lop2]=mc[lop2+1];\n            }\n            m--;\n            for(int lop2=nt;lop2<n-1;lop2++){\n              nc[lop2]=nc[lop2+1];\n            }\n            n--;\n            nt--;\n            break;\n          }else{\n            num=2;\n            for(int lop2=num;lop2<=nc[nt];lop2++){\n              if(nc[nt]%lop2==0 && mc[lop]%lop2==0){\n                nc[nt]=0;\n                mc[lop]=0;\n                cnt++;\n                for(int lop2=lop;lop2<m-1;lop2++){\n                  mc[lop2]=mc[lop2+1];\n                }\n                m--;\n                for(int lop2=nt;lop2<n-1;lop2++){\n                  nc[lop2]=nc[lop2+1];\n                }\n                n--;\n                nt--;\n                break;\n              }\n            }\n          }\n        }\n        nt++;\n      }\n\n    }\n\n    for(int lop=0;lop<n;lop++){\n      cout<<nc[lop]<<\" \";\n    }\n    cout<<endl;\n    for(int lop=0;lop<m;lop++){\n      cout<<mc[lop]<<\" \";\n    }\n    cout<<endl;\n    cout<<cnt<<endl;\n\n    /*cout<<endl;\n    for(int lop=0;lop<n;lop++){\n      cout<<nc[lop]<<' ';\n    }\n    cout<<endl;\n    for(int lop=0;lop<m;lop++){\n      cout<<mc[lop]<<' ';\n    }\n    cout<<endl;*/\n\n    cin>>m;\n    cin>>n;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint V;\nvector<int> G[201];\nint match[201];\nbool used[201];\n\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i], w=match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int v=0;v<V;v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(true){\n\t\tint m,n;\n\t\tcin >> m >> n;\n\t\tif(m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tvector<int> b;\n\t\tvector<int> r;\n\t\tV = m+n;\n\t\tfor(int i=0;i<V;i++){\n\t\t\tvector<int> buf(0);\n\t\t\tG[i] = buf;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tb.push_back(buf);\n\t\t}\n\t\tfor(int j=0;j<n;j++){\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tr.push_back(buf);\n\t\t}\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=2;k<=min(b[i],r[j]);k++){\n\t\t\t\t\tif(b[i]%k==0&&r[j]%k==0){\n\t\t\t\t\t\tadd_edge(i,j+m);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\ntypedef vector<int> Vint;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct edge{\n  int to, cap, inv;\n};\n\nvector<edge> G[1002];\nbool vsted[1002];\nint inf = 123456789; //???????°´??????\n\nint dfs(int v, int now, int t, int w){\n  if(now == t)return w;\n  vsted[now] = true;\n  for(int i = 0;i < G[now].size();++i){\n    edge tmp = G[now][i];\n    if(!vsted[tmp.to] && tmp.cap > 0){\n      int d = dfs(v, tmp.to, t, min(w, tmp.cap));\n      if(d > 0){\n        G[now][i].cap -= d;\n        G[tmp.to][tmp.inv].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nll edmondskarp(int v, int s, int t){\n  ll res = 0;\n  for(;;){\n    for(int i = 0;i < v;++i)vsted[i] = false;\n    int x = dfs(v, s, t, inf);\n    if(x == 0)return res;\n    res += x;\n  }\n  return res;\n}\n\n#define N 10000001\nint p[N] = {0};\n\nbool isedge(int b, int r){\n  if(b == 1)return false;\n  if(b % r == 0 || r % b == 0)return true;\n  int x = p[b];\n  if(r % x == 0)return true;\n  return isedge(b / x, r);\n}\n\nsigned main(void){\n  int i, j, k;\n  for(i = 2;i * i <= N;++i)for(j = i;j < N;j+=i)if(p[j] == 0)p[j] = i;\n\n  for(;;){\n    int2(m, n);\n    if(!(m|n))break;\n    int v = m + n + 2, b[m], r[n];\n    scn(m, b); scn(n, r);\n\n    rep(i, m)rep(j, n)if(isedge(b[i], r[j])){\n      int l = i, r = j; r += m;\n      G[l].pb((edge){r, 1, G[r].size()});\n      G[r].pb((edge){l, 0, G[l].size() - 1});\n    }\n\n    rep(i, m){\n      int r = i, l = m + n;\n      G[l].pb((edge){r, 1, G[r].size()});\n      G[r].pb((edge){l, 0, G[l].size() - 1});\n    }\n    rep(i, n){\n      int l = i + m, r = m + n + 1;\n      G[l].pb((edge){r, 1, G[r].size()});\n      G[r].pb((edge){l, 0, G[l].size() - 1});\n    }\n\n    cout << edmondskarp(v, v - 2, v - 1) << endl;\n    rep(i, v)G[i].clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ntypedef struct{\n\tint to, cap, rev;\n}edge;\n\nint x[555], y[555];\nint gcd(int a, int b)\n{\n    while( 1 )\n    {\n        a = a % b;\n\t\tif( a == 0 )\n\t\t\treturn b;\n\t\tb = b % a;\n\n        if( b == 0 )\n\t\t\treturn a;\n    }\n}\n\nclass biMatch{//bipartite matching\npublic:\n\tvector<vector<edge> > g;\n\tbiMatch(int k){\n\t\tg = vector<vector<edge> >(k);\n\t}\n\tvoid add_edge(int from, int to, int cap){\n\t\tedge e;\n\t\te.to = to;\n\t\te.cap = cap;\n\t\te.rev = g[to].size();\n\t\tg[from].PB(e);\n\t\te.to = from;\n\t\te.cap = cap;\n\t\te.rev = g[from].size()-1;\n\t\tg[to].PB(e);\n\t}\n\tint DFS(int n, int f, int goal, VI &visited){\n\t\tif(n==goal)return f;\n\t\tvisited[n] = 1;\n\t\tint cnt = f;\n\t\tREP(i, g[n].size()){\n\t\t\tif(g[n][i].cap <= 0)continue;\n\t\t\tif(visited[g[n][i].to])continue;\n\t\t\tint ret = DFS(g[n][i].to, min(f, g[n][i].cap), goal, visited);\n\t\t\tint n2 = g[n][i].to;\n\t\t\tg[n][i].cap -= ret;\n\t\t\tg[n2][g[n][i].rev].cap += ret;\n\t\t\tcnt -= ret;\n\t\t\tif(cnt == 0)break;\n\t\t}\n\t\treturn f-cnt;\n\t}\n};\n\nint main(){\n\twhile(1){\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tif(m==0)return 0;\n\t\tbiMatch b(m+n+2);\n\t\tREP(i,m){\n\t\t\tscanf(\"%d\", &x[i]);\n\t\t\tb.add_edge(0, i+1, 1);\n\t\t}\n\t\tREP(i,n){\n\t\t\tscanf(\"%d\", &y[i]);\n\t\t\tb.add_edge(m+i+1, m+n+1, 1);\n\t\t}\n\t\tREP(i,m){\n\t\t\tREP(j,n){\n\t\t\t\tif(gcd(x[i], y[j]) > 1){\n\t\t\t\t\tb.add_edge(i+1, m+j+1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tVI visited(m+n+2, 0);\n\t\tcout << b.DFS(0, 10000, m+n+1, visited) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nconst int INF = 1 << 28;\n\nint main() {\n    int N, M;\n    while (cin >> N >> M, N || M) {\n        vec B(N), R(M);\n        for (auto &i : B) cin >> i;\n        for (auto &i : R) cin >> i;\n        \n        vector<set<int>> m(N + M);\n\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                if (__gcd(B[i], R[j]) > 1) {\n                    m[i].insert(j + N);\n                    m[j + N].insert(i);\n                }\n            }\n        }\n\n        int res = 0;\n\n        while (1) {\n            int min_i = INF;\n            int I;\n            for (int i = 0; i < N; i++) {\n                if (m[i].size() > 0 && min_i > m[i].size()) {\n                    min_i = m[i].size();\n                    I = i;\n                }\n            }\n\n            if (min_i == INF) break;\n\n            int min_j = INF;\n            int J;\n            for (auto j : m[I]) {\n                if (m[j].size() > 0 && m[j].size() < min_j) {\n                    min_j = m[j].size();\n                    J = j;\n                }\n            }\n\n            m[I].clear();\n            \n            if (min_j != INF) {\n                res++;\n                m[J].clear();\n            }\n        }\n\n        cout  << res << endl; \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <cassert>\n#include <exception>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef string str;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<char> vc;\ntypedef vector<str> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(int i=(a); i<(n); ++i)\n#define rrep(i,a,n) for(ll i=(a); i>(n); --i)\n#define erep(i,a,n) for(ll i=(a); i<=(n); ++i)\n#define rerep(i,a,n) for(ll i=(a); i>=(n); --i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) x.size())\n#define print(X) cout << (X) << endl\n#define _ << \" \" <<\nstatic const int INF = 1e+9+7;\n\nint V;\nvi G[2000];\nint match[2000];\nbool used[2000];\n\nvoid add_edge(int u, int v){\n  G[u].pb(v);\n  G[v].pb(u);\n}\n\n\nbool dfs(int v){\n  used[v] = true;\n  rep(i,0,(int)sz(G[v])){\n    int u = G[v][i], w = match[u];\n\n    if (w < 0 || (!used[w] && dfs(w))){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  rep(v,0,V){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)){\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\nint gcd(int x, int y){\n  if(y == 0)return x;\n  return gcd(y,x % y);\n}\n\n\nint m,n;\nint b[500],r[500];\n\nint main(){\n  while(cin >> m >> n){\n    if (m==0 && n == 0) break;\n\n    rep(i,0,m) cin >> b[i];\n    rep(i,0,n) cin >> r[i];\n\n    rep(i,0,2000) G[i].clear();\n\n    rep(i,0,m){\n      rep(j,0,n){\n        if( gcd(b[i], r[j]) > 1) add_edge(i,m+j);\n      }\n    }\n\n    V = m;\n    cout << bipartite_matching() << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_V = 1010;\nconst int INF = 1 << 29;\n\nstruct edge{int to,cap,rev;};\n \nint n[2];\nvector<int> v[2];\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n \nvoid add_edge(int from, int to, int cap){\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, 0, G[from].size()-1});\n}\n \nint dfs(int v, int t, int f){\n  if(v == t)return f;\n  used[v] = true;\n  for(int i = 0 ; i < G[v].size() ; i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n \nint max_flow(int s,int t){\n  int flow = 0;\n  while(1){\n    fill(used,used+MAX_V,false);\n    int f = dfs(s,t,INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nvoid solve(){\n  for(int i=0;i<n[0]+n[1]+2;i++) G[i].clear();\n\n  for(int i=0;i<n[0];i++) add_edge(n[0]+n[1], i, 1);\n  for(int j=0;j<n[1];j++) add_edge(n[0]+j, n[0]+n[1]+1, 1);\n\n  for(int i=0;i<n[0];i++){\n    for(int j=0;j<n[1];j++){\n      if(__gcd(v[0][i], v[1][j]) != 1){\n        add_edge(i, n[0]+j, 1);\n      }\n    }\n  }\n\n  cout << max_flow(n[0]+n[1], n[0]+n[1]+1) << endl;\n\n}\n\nint main(){\n  while(cin >> n[0] >> n[1] && (n[0]|n[1])){\n    for(int i=0;i<2;i++){\n      v[i].clear();\n      for(int j=0;j<n[i];j++){\n        int x;\n        cin >> x;\n        v[i].push_back(x);\n      }\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\nusing namespace std;\n\nstruct edge{ int to,cap,rev; };\n\nint V,E;\nint X,Y;\nvector<edge> G[1002];\nbool used[1002];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to] && e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(used,used+1002,0);\n    int f=dfs(s,t,inf);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint gcd(int a,int b){\n  if(a%b==0)return b;\n  return gcd(b,a%b);\n} \n\nint main()\n{\n  int m,n;\n  int b[500],r[500];\n  while(1){\n    cin>>m>>n;\n    if(m+n==0)break;\n    for(int i=0;i<1002;i++)G[i].clear();\n    int s=m+n,t=s+1;\n    for(int i=0;i<m;i++)cin>>b[i];\n    for(int i=0;i<n;i++)cin>>r[i];\n    \n    for(int i=0;i<m;i++){\n      add_edge(s,i,1);\n    }\n    for(int i=0;i<n;i++){\n      add_edge(m+i,t,1);\n    }\n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n\tif(gcd(b[i],r[j])!=1){\n\t  add_edge(i,m+j,1);\n\t}\n      }\n    }\n    cout<<max_flow(s,t)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> edge[1010];\nint match[1010];\nbool used[1010];\n\nbool dfs(int v){\n  used[v] = true;\n  rep(i,edge[v].size()){\n    int u = edge[v][i];\n    int w = match[u];\n    if( w<0 || !used[w]&&dfs(w) ){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\nint solve(int sz){\n  int ret = 0;\n  memset(match,-1,sizeof(match));\n  rep(i,sz)if( match[i]<0 ){\n    memset(used,false,sizeof(used));\n    if( dfs(i) )ret++;\n  }\n  return ret;\n}\n\n\nint gcd(int x, int y){\n  return y ? gcd(y,x%y) : x;\n}\n\nint main(){\n  int n,m;\n  int blue[500],red[500];\n\n  while(cin>>n>>m, n|m){\n    // init\n    rep(i,n+m+1)edge[i].clear();\n\n    \n    rep(i,n)scanf(\"%d\",&blue[i]);\n    rep(i,m)scanf(\"%d\",&red[i]);\n    rep(i,n){\n      rep(j,m){\n        if( gcd(blue[i], red[j])!=1 ){\n          edge[i].push_back(j+n);\n          edge[j+n].push_back(i);\n        }\n      }\n    }\n    cout << solve(n+m) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  return match;\n}\n\nint a[1000] , b[1000];\nint main(){\n\tint n,m;\n\t\n\twhile(cin >> n >> m && n){\n\t\tEdges hoge;\n\t\tGraph g(n+m);\n\t\tfor(int i = 0 ; i < n ; i++) cin >> a[i];\n\t\tfor(int j = 0 ; j < m ; j++) cin >> b[j];\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tfor(int j = 0 ; j < m ; j++)\n\t\t\t\tif(__gcd(a[i],b[j]) > 1){\n\t\t\t\t\t//hoge.push_back(Edge(i,j,1));\n\t\t\t\t\tg[i].push_back(Edge(i,n+j,1));\n\t\t\t\t\tg[n+j].push_back(Edge(n+j,i,1));\n\t\t\t\t}\n\t\tcout << bipartiteMatching(g,n,hoge) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct Dinic {\n    int n, s, t;\n    vector<int> level, iter, que;\n    vector<vector<Capacity>> cap, flow;\n    vector<vector<int>> g;\n    Capacity inf;\n    Dinic(int n)\n        : n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n          g(n, vector<int>()), inf(numeric_limits<Capacity>::max()/8){}\n    Dinic(const Graph &graph){\n        *this = Dinic(graph.size());\n        rep(i,n) for(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n    }\n    void addEdge(int u, int v, Capacity c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    inline Capacity residue(int u, int v){ return cap[u][v] - flow[u][v]; }\n    Capacity solve(int s, int t){\n        this->t = t, this->s = s;\n        Capacity res = 0, aug = 1;\n        while(aug > 0){\n            levelize();\n            iter.assign(n, 0);\n            res += (aug = augment(s, inf));\n        }\n        return res;\n    }\n    void levelize(){\n        level.assign(n, inf); level[s] = 0;\n        int l = 0, r = 0;\n        que.assign(n+1, 0);\n        que[r++] = s;\n        while(l != r){\n            int v = que[l++];\n            for(const int &d : g[v]){\n                if(level[d] <= level[v] + 1 || residue(v,d) == 0) continue;\n                level[d] = level[v] + 1; que[r++] = d;\n            }\n        }\n    }\n    Capacity augment(int v, Capacity lim){\n        Capacity res = 0;\n        if(v == t) return lim;\n        for(int &i = iter[v]; i < (int)g[v].size(); i++){\n            const int &d = g[v][i];\n            if(residue(v,d) == 0 || level[v] + 1 != level[d]) continue;\n            const Capacity aug = augment(d, min(lim, residue(v,d)));\n            if(aug > 0){\n                flow[v][d] += aug; flow[d][v] -= aug;\n                res += aug; lim -= aug;\n                if(lim == 0) return res;\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    fastios();\n    int n,m;\n    while(cin >> n >> m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        Dinic d(n+m+2);\n        int s = n+m, t = n+m+1;\n        rep(i,m) d.addEdge(i+n,t,1);\n        rep(i,n){\n            d.addEdge(s,i,1);\n            rep(j,m) if(__gcd(a[i],b[j]) != 1) d.addEdge(i,n+j,1);\n        }\n        rep(i,n)rep(j,m){\n            if(d.flow[i][j+n]) dump(i,j, d.flow[i][j+m]);\n        }\n        cout << d.solve(s,t) << endl;\n    }\n}\n\n// int main(){\n//     int N,M;\n//     cin >> N >> M;\n//     Graph g(N);\n//     rep(i,M){\n//         int a,b,c;\n//         cin >> a >> b >> c;\n//         g[a].emplace_back(a,b,c);\n//     }\n//     Dinic dinic(g);\n//     cout << dinic.solve(0,N-1) << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\ntemplate<class T> void vin(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n}\n\nint m, n;\nint b[501], r[501];\n\ntemplate<class T>\nclass Dinic {\nprivate:\n\n    struct edge {\n        T to, cap, rev;\n        edge(T to, T cap, T rev) :to(to), cap(cap), rev(rev) {}\n    };\n\n    T V;\n    vector<vector<edge>> g;\n    vector<T> level;      // sourceからの距離\n    vector<T> itr;        // どこまで調べ終わったか\n\npublic:\n    Dinic(T V) :V(V), g(V, vector<edge>()) {}\n\n    void add_edge(T from, T to, T cap) {\n        g[from].emplace_back(to, cap, g[to].size());\n        g[to].emplace_back(from, 0, g[from].size()-1);\n    }\n\n    // sourceからの最短路を幅優先で探索\n    void bfs(T s) {\n        level = vector<T>(V, -1);\n        queue<T> que;\n        que.push(s);\n        level[s] = 0;\n        while (que.size()) {\n            int v = que.front(); que.pop();\n            for (edge &e : g[v]) {\n                if (e.cap > 0 and level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    // v->tの増加路を探す\n    T dfs(T v, T t, T f) {\n        if (v == t) return f;\n        for (T& i = itr[v]; i < g[v].size(); ++i) {\n            edge& e = g[v][i];\n            if (e.cap > 0 and level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T max_flow(T s, T t) {\n        T flow = 0, f;\n        while (true) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            itr = vector<T>(V, 0);\n            while ((f = dfs(s, t, numeric_limits<T>::max())) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n\nint main() {\n    while (cin >> m >> n, m, n) {\n        int s = 0, t = 1;\n        Dinic<int> flow(m+n+2);\n        rep(i, m) {\n            cin >> b[i];\n            flow.add_edge(s, i+2, 1);\n        }\n        rep(i, n) {\n            cin >> r[i];\n            flow.add_edge(m+i+2, t, 1);\n        }\n        rep(i, m) rep(j, n) {\n            if (__gcd(b[i], r[j]) != 1) {\n                flow.add_edge(i+2, m+j+2, 1e8);\n            }\n        }\n        cout << flow.max_flow(s, t) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntemplate <typename T>\n\nclass dinic{\nprivate:\n\tunordered_map<int,unordered_map<int,T>> mp;\n\tunordered_map<int,int> level;\n\tunordered_set<string> visited;\npublic:\n\tvoid add_edge(int from, int to, T cap){\n\t\tmp[from][to] = cap;\n\t\tmp[to][from] = 0;\n\t}\n\n\tvoid bfs(int s){\n\t\tlevel.clear();\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\n\t\t\tint v = q.front();q.pop();\n\t\t\tfor(auto x:mp[v]){\n\t\t\t\tif(x.second > 0 && !level.count(x.first)){\n\t\t\t\t\tlevel[x.first] = level[v] + 1;\n\t\t\t\t\tq.push(x.first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tT dfs(int v, int t, T f){\n\t\tif(v == t){\n\t\t\treturn f;\n\t\t}\n\t\tfor(auto x:mp[v]){\n\t\t\tif(visited.count(to_string(v) + \":\" + to_string(x.first))) continue;\n\t\t\tvisited.insert(to_string(v) + \":\" + to_string(x.first));\n\t\t\tif(x.second > 0 && level.count(x.first) && level[v] < level[x.first]){\n\t\t\t\tT d = dfs(x.first, t, min(f, x.second));\n\t\t\t\tif(d > 0){\n\t\t\t\t\tmp[v][x.first] -= d;\n\t\t\t\t\tmp[x.first][v] += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tT max_flow(int s, int t){\n\t\tT flow = 0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(!level.count(t)) return flow;\n\t\t\tvisited.clear();\n\t\t\tT f;\n\t\t\twhile((f = dfs(s, t, numeric_limits<T>::max())) > 0){\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nint gcd(int x,int y){\n\tif(x%y == 0) return y;\n\treturn gcd(y,x%y);\n}\n\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m,n!=0&&m!=0){\n\t\tdinic<int> g;\n\t\tvector<int> vn(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> vn[i];\n\t\t\tg.add_edge(-1,i,1);\n\t\t}\n\t\tvector<int> vm(m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> vm[i];\n\t\t\tg.add_edge(i+n,-2,1);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(gcd(vn[i],vm[j]) > 1){\n\t\t\t\t\tg.add_edge(i,j+n,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << g.max_flow(-1,-2) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_V = 10000;\nconst int INF = 100000000;\n\n// ¸_\nint V;\n// OtÌXg\\»\nvector<int> G[MAX_V];\n// }b`OÌyA\nint match[MAX_V];\n// dfsÅ·ÅÉ²×½©Ç¤©ÌtO\nstatic bool used[MAX_V];\n\n// uÆvðÔÓðOtÉÇÁ\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\n// ÁpXðdfsÅT·\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i],w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// ñOtÌÅå}b`Oðßé\nint bipartite_matching(){\n\tint res = 0;\n\t//memset(match,-1,sizeof(match));\n\tfor(int i = 0; i < MAX_V; i++)\n\t\tmatch[i]=-1;\n\tfor(int v = 0; v < V; v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int a,int b){\n\tif(b==0)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\n\n\nint main(){\n\n\tint n,m;\n\twhile(cin>>m>>n&&!(m==0&&n==0)){\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\tG[i].clear();\n\n\t\tvector<int> bs,rs;\n\t\tint b,r;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin>>b;\n\t\t\tbs.push_back(b);\n\t\t\tV++;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>r;\n\t\t\trs.push_back(r);\n\t\t\tV++;\n\t\t}\n\t\tfor(int i = 0; i < rs.size(); i++){\n\t\t\tfor(int j = 0;j < bs.size(); j++){\n\t\t\t\tint res=gcd(rs[i],bs[j]);\n\t\t\t\tif(res!=1)\n\t\t\t\t\tadd_edge(i,j+rs.size());\n\t\t\t}\n\t\t}\n\t\tcout<<bipartite_matching()<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint m, n, res;\nint blue[510], red, match[510];\nbool used[510];\nvector<int> g[510];\n\nint gcd(int x, int y)\n{\n\tint t;\n\tif(x < y) swap(x, y);\n\twhile(y)\n\t\tt = x % y, x = y, y = t;\n\treturn x;\n}\n\nbool dfs(int v)\n{\n\tfor(int i = 0; i < g[v].size(); ++i)\n\t{\n\t\tint t = g[v][i];\n\t\tif(used[t]) continue;\n\t\tused[t] = true;\n\t\tif(match[t] == -1 || dfs(match[t]))\n\t\t{\n\t\t\tmatch[t] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> m >> n && m)\n\t{\n\t\tfor(int i = 0; i < m; ++i)\n\t\t\tcin >> blue[i], g[i].clear();\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tcin >> red;\n\t\t\tfor(int j = 0; j < m; ++j)\n\t\t\t\tif(gcd(blue[j], red) > 1)\n\t\t\t\t\tg[j].push_back(i);\n\t\t}\n\t\tres = 0;\n\t\tfill_n(match, n, -1);\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tfill_n(used, n, false);\n\t\t\tif(dfs(i)) ++res;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 1001\n#define MAX_N 510\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});  \n}\n\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nint N,K;\nbool can[MAX_N][MAX_N]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(){\n  //0??????N-1: ???????????\\???????????????????????????\n  //N??????N+K-1: ???????????????????????????\n  int s = N+K, t = s+1;\n  \n  //s??¨???????????\\??????????????¶\n  for(int i=0; i<N; i++) add_edge(s,i,1);\n  \n  //????????¨t?????????\n  for(int i=0; i<K; i++) add_edge(N+i,t,1);\n  \n  //???????????\\????????¨??????????????¶\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)\n      if(can[i][j]) add_edge(i, N+j , 1);\n\n  return max_flow(s,t);\n}\n\nint main(){\n  while(1){\n  int b,r,B[501],R[501];\n  cin>>b>>r;\n  if(!b&&!r)break;\n  for(int i=0;i<b;i++) cin>>B[i];\n  for(int i=0;i<r;i++) cin>>R[i];\n\n  memset(can,0,sizeof(can));\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n  N=b,K=r;\n  for(int i=0;i<b;i++)\n    for(int j=0;j<r;j++)\n      if(__gcd(B[i],R[j])>1) can[i][j]=1;\n\n  cout<<Biparite_Matching()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int INF = 1e9;\n\nstruct edge{\n  int to, cap, rev;\n  edge(int t, int c, int r){\n    to = t; cap = c; rev = r;\n  }\n};\n\nvoid add_edge(int from, int to, int cap, vector< vector<edge> > &g){\n  g[from].push_back( edge(to,cap,g[to].size()) );\n  g[to].push_back( edge(from,0,g[from].size()-1) );\n}\n\nint dfs(int v, int t, vector< vector<edge> > &g, vector<int> &used){\n  if(v==t)return INF;\n  used[v] = 1;\n  for(int i=0;i<(int)g[v].size();i++){\n    edge &e = g[v][i];\n    if(!used[e.to] && e.cap>0){\n      int d = min(e.cap, dfs(e.to,t,g,used));\n      if(d>0){\n\te.cap -= d;\n\tg[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t, vector< vector<edge> > &g){\n  int flow = 0;\n  while(1){\n    vector<int> used(g.size(),0);\n    int f = dfs(s,t,g,used);\n    if(f==0)return flow;\n    flow += f;\n  }\n}\n\nint gcd(int a,int b){\n  if(!b)return a;\n  return gcd(b,a%b);\n}\n\nint main(){\n  int m,n;\n  while(1){\n    cin >> m >> n;\n    if(!m && !n)break;\n\n    vector<int> b(m),r(n);\n    for(int i=0;i<m;i++)cin >> b[i];\n    for(int i=0;i<n;i++)cin >> r[i];\n\n    vector< vector<edge> > g(n+m+2);\n    for(int i=1;i<=m;i++)add_edge(0,i,1,g);\n    for(int i=m+1;i<=m+n;i++)add_edge(i,m+n+1,1,g);\n\n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n\tif(gcd(b[i],r[j])>1)add_edge(i+1,m+j+1,1,g);\n      }\n    }\n\n    cout << max_flow(0,m+n+1,g) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long int lint;\ntypedef pair<lint, lint> plint;\ntypedef pair<double long, double long> pld;\n#define Alint(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1ll << (n))\n#define FOR(i, begin, end) for(lint i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(lint i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first - r.first, l.second - r.second); }\nconst lint MOD = 998244353, INF = 1e9;\n\nstruct edge { lint to, cap, rev; };\n\nvector<edge> Graph[20005];\nint level[20005];\nint iter[20005];\nvoid add_edge(lint from, lint to, lint cap) {\n\tGraph[from].push_back({ to, cap, SZ(Graph[to]) });\n\tGraph[to].push_back({ from, 0, SZ(Graph[from]) - 1 });\n}\nvoid bfs(lint s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<lint> que;\n\tque.push(s);\n\tlevel[s] = 0;\n\twhile (!que.empty()) {\n\t\tlint v = que.front(); que.pop();\n\t\tREP(i, SZ(Graph[v])) {\n\t\t\tedge& e = Graph[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlint dfs(lint v, lint t, lint f) {\n\tif (v == t) return f;\n\tfor (int& i = iter[v]; i < SZ(Graph[v]); i++) {\n\t\tedge& e = Graph[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tlint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tGraph[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nlint max_flow(lint s, lint t) {\n\tlint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tlint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nlint gcd(lint a, lint b) {\n\tif (b == 0) return a;\n\telse return gcd(b, a % b);\n}\n\nlint N, M;\nint main() {\n\tcin.tie(0); ios_base::sync_with_stdio(false);\n\tcin >> N >> M;\n\tvector<lint> ans;\n\twhile (!(N == 0 && M == 0)) {\n\t\tlint b[500], r[500];\n\t\tlint s = N + M, t = s + 1;\n\t\tREP(i, t + 1) {\n\t\t\tGraph[i].clear();\n\t\t}\n\t\tREP(i, N) {\n\t\t\tcin >> b[i];\n\t\t\tadd_edge(s, i, 1);\n\t\t}\n\t\tREP(i, M) {\n\t\t\tcin >> r[i];\n\t\t\tadd_edge(i + N, t, 1);\n\t\t}\n\t\tREP(i, N) {\n\t\t\tREP(j, M) {\n\t\t\t\tif (gcd(b[i], r[j]) != 1) {\n\t\t\t\t\tadd_edge(i, j + N, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans.push_back(max_flow(s, t));\t\n\t\tcin >> N >> M;\n\t}\n\tREP(i, SZ(ans)) {\n\t\tcout << ans[i] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\nconst int MAX = 1005;\nint V;\nvector<int> G[MAX];\nint match[MAX];\nbool used[MAX];\n\nint GCD(int a, int b){\n  if(b == 0) return a;\n  return GCD(b,a%b);\n}\n\nvoid add_edge(int u, int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i = 0; i < (int)G[v].size(); i++){\n    int u = G[v][i];\n    int w = match[u];\n\n    if(w < 0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  for(int v = 0; v < V; v++){\n    if(match[v] < 0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)) res++;\n    }\n  }\n  return res;\n}\n\nvoid init(){\n  for(int i = 0; i < MAX; i++) G[i].clear();\n}\t\n\t\nvoid input(int m, int n){\n  vector<int> B(m),R(n);\n  \n  for(int i = 0; i < m; i++) cin >> B[i];\n  for(int i = 0; i < n; i++) cin >> R[i];\n\n  \n  for(int i = 0; i < (int)B.size(); i++)\n    for(int j = 0; j < (int)R.size(); j++)\n      if(GCD(B[i],R[j]) > 1) add_edge(i,m+j);\n}\n\n\nint main(){\n  int m,n;\n  while(cin >> m >> n && n+m){\n    init();\n    input(m,n);\n    V = m+n+2;\n    cout << bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\nconst int INF = 1e9;\nconst int MAX_V = 300000;\n\nint m, n;\nstruct Flow{\n    struct edge{\n        int to, cap, rev;\n    };\n    vector<edge> G[MAX_V];//??£??\\?????????\n    bool used[MAX_V];\n\n    void add_edge(int from, int to, int cap){\n        G[from].push_back((edge){to, cap, (int)G[to].size()});//from -> to\n        G[to].push_back((edge){from, 0, (int)G[from].size() - 1});//to -> from\n    }\n\n    //?¢???????????????¢???\n    int dfs(int v, int t, int f){\n        if(v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); ++i){\n            edge &e = G[v][i];\n            if(!used[e.to] && e.cap > 0){\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    //s??????t???????????§???\n    int max_flow(int s, int t){\n        int flow = 0;\n        while(1){\n            memset(used, 0, sizeof(used));\n            int f = dfs(s, t, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nint b[510], r[510];\nint main(void){\n    while(1){\n        cin >> m >> n;\n        if(m == 0 && n == 0) return 0;\n        rep(i, m) cin >> b[i];\n        rep(i, n) cin >> r[i];\n        int s = m + n, t = m + n + 1;\n        Flow mf;\n        //s -> b\n        rep(i, m){\n            mf.add_edge(s, i, 1);\n        }\n        //r -> t\n        rep(i, n){\n            mf.add_edge(m + i, t, 1);\n        }\n        //b -> r\n        rep(i, m)rep(j, n){\n            if(__gcd(b[i], r[j]) > 1){//1??\\???????´???°?????????\n                mf.add_edge(i, m + j, 1);\n            }\n        }\n        printf(\"%d\\n\", mf.max_flow(s, t));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <deque>\n#include <numeric>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n#include <chrono>\n#include <random>\n#include <limits>\n#include <iterator>\n#include <functional>\n#include <sstream>\n#include <complex>\nusing namespace std;\n\nusing ll = long long;\nusing ull = uint64_t;\nusing P = pair<int, int>;\nconstexpr double EPS = 1e-9;\nconstexpr int INF = 1001001001;\nconstexpr int mod = 1000000007;\n// constexpr int mod = 998244353;\n\ntemplate<class T>\ninline bool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\nstruct Edge{\n    int to, cap, rev;\n    Edge() = default;\n    Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    for(;;){\n        int m, n;\n        cin >> m >> n;\n        if(m == 0 && n == 0)    return 0;\n        vector<int> b(m), r(n);\n        int V = m + n + 2;\n        int s = m + n, t = s + 1;\n        for(int i = 0; i < m; ++i)  cin >> b[i];\n        for(int i = 0; i < n; ++i)  cin >> r[i];\n        vector<vector<Edge>> graph(V);\n        auto add_edge = [&](int u, int v, int cap){\n            graph[u].emplace_back(v, cap, graph[v].size());\n            graph[v].emplace_back(u, 0, (int)graph[u].size() - 1);\n            return;\n        };\n        for(int i = 0; i < m; ++i)  add_edge(s, i, 1);\n        for(int i = m; i < m + n; ++i)  add_edge(i, t, 1);\n        for(int i = 0; i < m; ++i){\n            for(int j = 0; j < n; ++j){\n                if(__gcd(b[i], r[j]) > 1)   add_edge(i, m + j, 1);\n            }\n        }\n\n        vector<int> depth(V), iter(V);\n        auto bfs = [&](int root) {\n            for(int i = 0; i < V; ++i)  depth[i] = -1;\n            depth[root] = 0;\n            queue<int> que;\n            que.emplace(root);\n            while(!que.empty()){\n                int from = que.front();\n                que.pop();\n                for(auto& e : graph[from]){\n                    if(e.cap > 0 && depth[e.to] == -1){\n                        depth[e.to] = depth[from] + 1;\n                        que.emplace(e.to);\n                    }\n                }\n            }\n            return;\n        };\n        auto dfs = [&](auto&& self, int S, int T, int flow) -> int {\n            if(S == T)  return flow;\n            for(int& i = iter[S]; i < (int)graph[S].size(); ++i){\n                auto& e = graph[S][i];\n                if(e.cap > 0 && depth[S] < depth[e.to]){\n                    int f = self(self, e.to, T, min(e.cap, flow));\n                    if(f > 0){\n                        e.cap -= f;\n                        graph[e.to][e.rev].cap += f;\n                        return f;\n                    }\n                }\n            }\n            return 0;\n        };\n        auto max_flow = [&](int S, int T) {\n            int res = 0;\n            for(;;){\n                bfs(S);\n                if(depth[T] < 0)    break;\n                for(int i = 0; i < V; ++i)  iter[i] = 0;\n                int f;\n                while((f = dfs(dfs, S, T, INF)) > 0)    res += f;\n            }\n            return res;\n        };\n\n        cout << max_flow(s, t) << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define INF 1<<30\nconstexpr int gcd(int a,int b){return b?gcd(b,a%b):a;}\nconstexpr int lcm(int a,int b){return a*b/gcd(a,b);}\n\nstruct MaxFlow{\n    struct edge{\n        int to,cap,rev;\n        edge(int t, int c, int r):to(t),cap(c),rev(r){}\n    };\n    vector<vector<edge>> g;\n    vector<bool> used;\n    MaxFlow(int n){\n        g=vector<vector<edge>>(n);\n        used=vector<bool>(n);\n    }\n    void add(int from, int to, int cap){\n        g[from].eb(to,cap,g[to].size());\n        g[to].eb(from,0,g[from].size()-1);\n    }\n    int dfs(int v, int t, int f){\n        if(v==t) return f;\n        used[v]=true;\n        rep(i,g[v].size()){\n            auto &e=g[v][i];\n            if(!used[e.to] && e.cap>0){\n                int d=dfs(e.to, t, min(f,e.cap));\n                if(d>0){\n                    e.cap=-d;\n                    g[e.to][e.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int calcMF(int s, int t){\n        int flow=0;\n        while(1){\n            fill(all(used),false);\n            int f=dfs(s,t,INF);\n            if(f==0) return flow;\n            flow+=f;\n        }\n    }\n};\n\nint main(){\n\tint m,n;\n\twhile(cin>>m>>n,n){\n\t    MaxFlow mf(m+n+2);\n\t    int s=m+n,t=s+1;\n        vi b(m),r(n);\n        rep(i,m){\n            cin>>b[i];\n            mf.add(s,i,1);\n        }\n        rep(i,n){\n            cin>>r[i];\n            mf.add(m+i,t,1);\n            rep(j,m){\n                if(gcd(b[j],r[i])!=1){\n                    mf.add(j,m+i,1);\n                }\n            }\n        }\n        cout<<mf.calcMF(s,t)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long int v;\nvector < vector< long long int > > g;\nvector< long long int > match;\nbool used[1001];\n\nbool dfs( long long int x ) {\n\n  used[x] = true;\n\n  for ( long long int i = 0; i < g[x].size(); i++ ) {\n\n    long long int k = g[x][i];\n    long long int w = match[k];\n\n    if ( w < 0 || !used[w] && dfs(w) ) {\n\n      match[x] = k;\n      match[k] = x;\n      return true;\n\n    }\n\n  }\n\n  return false;\n}\n\nint main() {\n\n  bool so[10000] = {};\n  vector< long long int > sosu;\n\n  for ( long long int i = 2; i < 10000; i++ ) {\n    if ( so[i] == false ) {\n      sosu.push_back( i );\n      for ( long long int j = 2; j * i < 10000; j++ ) {\n\tso[j*i] = true;\n      }\n    }\n  }\n\n  while( true ) {\n\n    long long int m, n;\n    cin >> m >> n;\n    if ( m == 0 ) break;\n    v = m + n;\n\n    vector< long long int > b, r;\n\n    for ( long long int i = 0; i < m; i++ ) {\n      long long int in;\n      cin >> in;\n      b.push_back( in );\n    }\n\n    for ( long long int i = 0; i < n; i++ ) {\n      long long int in;\n      cin >> in;\n      r.push_back( in );\n    }\n\n    g.clear();\n    for ( long long int i = 0; i < v; i++ ) {\n      vector< long long int > vec;\n      g.push_back( vec );\n    }\n\n    for ( long long int i = 0; i < m; i++ ) {\n      for ( long long int j = 0; j < n; j++ ) {\n\tbool f = false;\n\tfor ( long long int k = 0; k < sosu.size(); k++ ) {\n\t  if ( ( b[i] % sosu[k] ) == 0 && ( r[j] % sosu[k] ) == 0 ) {\n\t    f = true;\n\t    break;\n\t  }\n\t}\n\tif ( f == true ) {\n\t  g[i].push_back( j+m );\n\t  g[j+m].push_back( i );\n\t}\n      }\n    }\n\n    long long int ans = 0;\n\n    match.clear();\n    for ( long long int i = 0; i < v; i++ ) {\n      match.push_back( -1 );\n    }\n\n    for ( long long int x = 0; x < v; x++ ) {\n\n      if ( match[x] < 0 ) {\n\n\tfor ( long long int j = 0; j < v; j++ ) {\n\t  used[j] = false;\n\t}\n\n\tif ( dfs( x ) == true ) {\n\t  ans++;\n\t}\n\n      }\n\n    }\n\n    cout << ans << endl;\n\n  /*\n  for ( long long int i = 0; i < m; i++ ) {\n    g[i].push_back( m+n );\n  }\n  for ( long long int i = 0; i < n; i++ ) {\n    g[m+i].push_back( m+n+1 );\n  }\n  */\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<cstring>\nusing namespace std;\n\nint V;\nvector<int> G[1001];\nint match[1001];\nbool used[1001];\n\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i], w=match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int v=0;v<V;v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int a,int b){\n\tif(a%b == 0){\n\t\treturn b;\n\t}else{\n\t\treturn gcd(b,a%b);\n\t}\n}\n\n\nint main(){\n\twhile(true){\n\t\tint m,n;\n\t\tcin >> m >> n;\n\t\tif(m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tvector<int> b;\n\t\tvector<int> r;\n\t\tV = m+n;\n\t\tfor(int i=0;i<1001;i++){\n\t\t\tvector<int> buf;\n\t\t\tG[i] = buf;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tb.push_back(buf);\n\t\t}\n\t\tfor(int j=0;j<n;j++){\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tr.push_back(buf);\n\t\t}\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(gcd(b[i],r[j]) != 1){\n\t\t\t\t\tadd_edge(i,j+m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 500\nusing namespace std;\n\nint m,n,b[MAX],r[MAX];\nint match[MAX+MAX];\nbool used[MAX+MAX];\nvector<int> e[MAX+MAX];\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<e[v].size();i++){\n    int u=e[v][i],w=match[u];\n    if(w<0||(!used[w]&&dfs(w))){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int i=0;i<MAX+MAX;i++){\n    if(match[i]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(i))res++;\n    }\n  }\n  return res;\n}\n\nint gcd(int a,int b){\n  if(b==0)return a;\n  return gcd(b,a%b);\n}\n\nint main(){\n  while(1){\n    cin>>m>>n;\n    if(!m&&!n)break;\n    for(int i=0;i<m;i++)cin>>b[i];\n    for(int i=0;i<n;i++)cin>>r[i];\n    for(int i=0;i<m;i++)\n      for(int j=0;j<n;j++)\n\tif(gcd(b[i],r[j])>1){\n\t  e[i].push_back(j+m);\n\t  e[j+m].push_back(i);\n\t}\n    cout<<bipartite_matching()<<endl;\n    for(int i=0;i<MAX;i++)e[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint gcd(int m, int n){\n\tif(m < n){ return gcd(n, m); }\n\tif(n == 0){ return m; }\n\tif(m % n == 0){ return n; }\n\treturn gcd(n, m % n);\n}\n\nbool bipartite_matching_dfs(\n\tint v, const vector< vector<int> > &conn,\n\tvector<bool> &used, vector<int> &match)\n{\n\tused[v] = true;\n\tfor(int i = 0; i < conn[v].size(); ++i){\n\t\tint u = conn[v][i], w = match[u];\n\t\tif(w < 0 || !used[w] && bipartite_matching_dfs(w, conn, used, match)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint bipartite_matching(const vector< vector<int> > &conn){\n\tint res = 0;\n\tvector<int> match(conn.size(), -1);\n\tvector<bool> used(conn.size(), false);\n\tfor(int v = 0; v < conn.size(); ++v){\n\t\tif(match[v] < 0){\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tif(bipartite_matching_dfs(v, conn, used, match)){ ++res; }\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(true){\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tif(m == 0 && n == 0){ break; }\n\t\tvector<int> cards(m + n);\n\t\tfor(int i = 0; i < m + n; ++i){ cin >> cards[i]; }\n\t\tvector< vector<int> > conn(m + n);\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tif(gcd(cards[i], cards[j + m]) > 1){\n\t\t\t\t\tconn[i].push_back(j + m);\n\t\t\t\t\tconn[j + m].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching(conn) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#define REP(i,n) for (int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int MAX_V = 1010;\nvector<vector<int> > G(MAX_V); //??°???????????£??\\???????????¨???\nbool used[MAX_V]; //DFS??§??¢???????????????????????????????????°\nint match[MAX_V]; //??????????????°????????¢\n\nvoid init(int n){\n\tfor(int i = 0;i < n;i++)G[i].clear();\n}\n\nvoid add_edge(int from, int to){\n\tG[from].push_back(to);\n\tG[to].push_back(from);\n}\n\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i],w = match[u];\n\t\tif(w < 0 || (!used[w] && dfs(w))){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(int V){\n\tint res = 0;\n\tfill(match, match + V,-1);\n\tfor(int v = 0;v < V;v++){\n\t\tif(match[v] < 0){\n\t\t\tfill(used, used + V, false);\n\t\t\tif(dfs(v))res++;\n\t\t}\n\t}\n\t/*\n\t//??????????????????\n\tREP(i,V){\n\t\tif(match[i] >= 0) cout << i << ' ' << match[i] << endl;\n\t\t}*/\n\treturn res;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\tint m,n;\n\twhile(cin >> m >> n,m){\n\t\t//\t\tint s = m + n,t = s + 1;\n\t\tinit(m+n);\n\t\tvector<int> b(m),r(n);\n\t\tREP(i,m){\n\t\t\tcin >> b[i];\n\t\t\t//\t\t\tadd_edge(s,i);//????????§????§??????????????????¶\n\t\t}\n\t\tREP(i,n){\n\t\t\tcin >> r[i];\n\t\t\t//\t\t\tadd_edge(i + m,t);//????????§???????????????????????¶\n\t\t}\n\t\tREP(i,m){\n\t\t\tREP(j,n){\n\t\t\t\tif(__gcd(b[i],r[j]) != 1){\n\t\t\t\t\tadd_edge(i,j + m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching(m+n) << endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nconst int MAX_N=1001;\nint n;\nvector<int> g[MAX_N];\nint match[MAX_N];\nint used[MAX_N];\nvoid add_edge(int src,int dst){\n    g[src].pb(dst);\n    g[dst].pb(src);\n}\nbool dfs(int v){\n    used[v]=true;\n    rep(i,g[v].size()){\n        int u=g[v][i],w=match[u];\n        if(w<0||!used[w]&&dfs(w)){\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(){\n    int res=0;\n    memset(match,-1,sizeof(match));\n    rep(i,n){\n        if(match[i]<0){\n            memset(used,0,sizeof(used));\n            if(dfs(i)) ++res;\n        }\n    }\n    return res;\n}\n\nint a[1001];\nint main(){\n    int m;\n    while(cin>>n>>m,n|m){\n        rep(i,1001) g[i].clear();\n        rep(i,n) cin>>a[i];\n        rep(i,m) cin>>a[i+n];\n        rep(i,n)FOR(j,n,n+m){\n            if(__gcd(a[i],a[j])!=1) add_edge(i,j);\n        }\n        n+=m;\n        cout<<bipartite_matching()<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <utility>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Edge{\n\tint src,dst;\n\tEdge(){}\n\tEdge(int s,int d):src(s),dst(d){}\n};\ntypedef vector<vector<Edge> > Graph;\n\nbool DFS(const Graph& g,int cur,vi& vis,vi& match)\n{\n\tforeach(e,g[cur]){\n\t\tif(vis[e->dst])\n\t\t\tcontinue;\n\t\tvis[e->dst]=1;\n\t\tif(match[e->dst]==-1 || DFS(g,match[e->dst],vis,match)){\n\t\t\tmatch[e->src]=e->dst;\n\t\t\tmatch[e->dst]=e->src;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint BipertiteMatching(const Graph& _g)\n{\n\tint size=_g.size();\n\tGraph g=_g;\n\trep(i,size) foreach(e,_g[i])\n\t\tg[e->dst].push_back(Edge(e->dst,e->src));\n\t\n\tvi vis(size),match(size,-1);\n\tint res=0;\n\trep(i,size)\n\t\tif(match[i]==-1){\n\t\t\tfill(all(vis),0);\n\t\t\tres+=DFS(g,i,vis,match);\n\t\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int m,n;~scanf(\"%d%d\",&m,&n) && m|n;){\n\t\tvi rs(m),bs(n);\n\t\trep(i,m) scanf(\"%d\",&rs[i]);\n\t\trep(i,n) scanf(\"%d\",&bs[i]);\n\t\t\n\t\tGraph g(m+n);\n\t\trep(i,m) rep(j,n) if(__gcd(rs[i],bs[j])>1)\n\t\t\tg[i].push_back(Edge(i,m+j));\n\t\tint res=BipertiteMatching(g);\n\t\tprintf(\"%d\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, a, n) for(int i=(a); i<(n); i++)\n\nint gcd(int a, int b) {\n    if(a < b) swap(a, b);\n    return (b == 0)? a : gcd(b, a % b);\n}\n\nint b[501], r[501];\nbool row[501], col[501];\n\nint main(){\n\twhile(1) {\n\t\tint m, n; cin >> m >> n;\n\t\tif(m==0 && n==0) break;\n\t\trep(i, m) cin >> b[i];\n\t\trep(j, n) cin >> r[j];\n\t\t\n\t\tmemset(row, false, m);\n\t\tmemset(col, false, n);\n\t\t\n\t\trep(i, m) {\n\t\t\trep(j, n) {\n\t\t\t\tif(gcd(b[i], r[j])>1) {\n\t\t\t\t\trow[i] = true;\n\t\t\t\t\tcol[j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << min(accumulate(row, row+m, 0),\n\t\t            accumulate(col, col+n, 0)) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<math.h>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cstdio>\n#include<utility>\n#include<set>\n#include<list>\n#include<cmath>\n#include<stdio.h>\n#include<string.h>\n#include<iomanip>\nusing namespace std;\n#define FOR(i, a, b) for (int i = (a); i <= (b); i++)\n#define REP(i, n) FOR(i, 0, n - 1)\n#define NREP(i, n) FOR(i, 1, n)\nusing ll = long long;\nusing pii = pair<int, int>;\nusing piii = pair<pii, pii>;\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\nconst int INF = 1e9 + 7;\nint gcd(int x, int y) {\n\tif (x < y)swap(x, y);\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b) { if (a>b)a = b; }\n\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b) { if (a<b)a = b; }\ntemplate<class T>\nvoid Add(T &a, const T &b, const T &mod = 1000000007) {\n\tint val = ((a % mod) + (b % mod)) % mod;\n\tif (val < 0) { val += mod; }\n\ta = val;\n}\n////////////////////////////////////////\nint X, Y;\nint b[510];\nint r[510];\nvector<int>G[510];\nint match[510];\nint visited[510];\nbool dfs(int v, int cnt) {\n\tif (visited[v] == cnt) {\n\t\treturn false;\n\t}\n\tvisited[v] = cnt;\n\tfor (int x : G[v]) {\n\t\tif (match[x] == -1) {\n\t\t\tmatch[x] = v;\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tif (dfs(match[x], cnt)) {\n\t\t\t\tmatch[x] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\twhile (cin >> X >> Y,X||Y) {\n\t\tREP(i, 510)G[i].clear();\n\t\tREP(i, 510)visited[i] = 0;\n\t\tREP(i, X)cin >> b[i];\n\t\tREP(i, Y)cin >> r[i];\n\t\tREP(i, X) {\n\t\t\tREP(j, Y) {\n\t\t\t\tif (gcd(b[i], r[j]) > 1) {\n\t\t\t\t\tG[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, 510)match[i] = -1;\n\t\tint num = 0;\n\t\tREP(i, X) {\n\t\t\tif (dfs(i, i + 1))num++;\n\t\t}\n\t\tcout << num << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// MEMO\n//\n// O(VE)\n\n// THE BEGINNING OF THE LIBRARY.\n\nstruct BipartiteMatching {\n\tusing UnWeightedGraph=vector< vector<int> >;\n\n\tint n;\n\tUnWeightedGraph G;\n\tvector<int> match,used;\n\n\tBipartiteMatching() {}\n\tBipartiteMatching(int sz):n(sz),G(sz),match(sz),used(sz) {}\n\n\tvoid add_edge(int u,int v) {\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tbool dfs(int v) {\n\t\tused[v]=true;\n\t\tfor(auto u:G[v]) {\n\t\t\tint w=match[u];\n\t\t\tif(w<0||(!used[w]&&dfs(w))) {\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint bipartite_matching() {\n\t\tint res=0;\n\t\tfill(match.begin(),match.end(),-1);\n\t\tfor(int v=0;v<n;v++) {\n\t\t\tif(match[v]<0) {\n\t\t\t\tfill(used.begin(),used.end(),0);\n\t\t\t\tif(dfs(v)) res++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint gcd(int a,int b) {\n\tif(a<b) swap(a,b);\n\tint r;\n\twhile(a%b!=0) {\n\t\tr=b;b=a%b;a=r;\n\t}\n\treturn b;\n}\n\n// THE ENDING OF THE LIBRARY.\n// THE FOLLOWING IS AN EXAMPLE OF USE.\n\nint main() {\n\n\tint m,n;\n\tcin>>m>>n;\n\tvector<int> a(m),b(n);\n\tfor(int i=0;i<m;i++) cin>>a[i];\n\tfor(int i=0;i<n;i++) cin>>b[i];\n\tBipartiteMatching bimatch(m+n);\n\tfor(int i=0;i<m;i++) {\n\t\tfor(int j=0;j<n;j++) {\n\t\t\tif(gcd(a[i],b[j])>1) bimatch.add_edge(i,j+m);\n\t\t}\n\t}\n\tcout<<bimatch.bipartite_matching()<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\n#define INF 999999999\n\nclass Node\n{\npublic:\n\tvector<int> to;\n};\n\nint flow[1002][1002];\n\nbool dfs(int p, int T, int mf, vector<Node>& graph, vector<int>& level, vector<bool>& finished)\n{\n\tif(p==T) return true;\n\tif(finished[p]) return false;\n\t\n\tfinished[p]=true;\n\t\n\tfor(int i=0; i<graph[p].to.size(); i++)\n\t{\n\t\tint next=graph[p].to[i];\n\t\tif(level[p] >= level[next]) continue;\n\t\tif(flow[p][next]) continue;\n\t\n\t\tif(dfs(next, T, 1, graph, level, finished))\n\t\t{\n\t\t\tfinished[p]=false;\n\t\t\tflow[p][next]+=1;\n\t\t\tflow[next][p]-=1;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint HopcroftKarp(int S, int T, vector<Node>& graph)\n{\n\tbool end=false;\n\tint total=0;\n\twhile(!end)\n\t{\n\t\tend=true;\n\t\tvector<int> level(graph.size(), -1);\n\t\tlevel[S]=0;\n\t\t\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint n=q.front(); q.pop();\n\t\t\tfor(int i=0; i<graph[n].to.size(); i++)\n\t\t\t{\n\t\t\t\tint next=graph[n].to[i];\n\t\t\t\tif(level[next]!=-1) continue;\n\t\t\t\tif(flow[n][next]) continue;\n\t\t\t\tlevel[next]=level[n]+1;\n\t\t\t\tq.push(next);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(level[T]==-1) break;\n\t\t\n\t\tvector<bool> finished(graph.size());\n\t\twhile(dfs(S, T, INF, graph, level, finished))\n\t\t{\n\t\t\ttotal++;\n\t\t\tend=false;\n\t\t}\n\t}\n\t\n\treturn total;\n}\n\nint gcd(int a, int b)\n{\n\treturn (b!=0?gcd(b,a%b):a);\n}\n\nint main()\n{\n\tint M,N;\n\twhile(scanf(\"%d%d\", &M, &N), (M||N))\n\t{\n\t\tvector<int> red(N), blue(M);\n\t\tvector<Node> graph(N+M+2);\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tblue[i]=t;\n\t\t}\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tint t;\n\t\t\tscanf(\"%d\", &t);\n\t\t\tred[i]=t;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tgraph[0].to.push_back(i+2);\n\t\t\tflow[0][i+2]=0;\n\t\t\tflow[i+2][0]=1;\n\t\t}\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tgraph[M+i+2].to.push_back(1);\n\t\t\tflow[M+i+2][1]=0;\n\t\t\tflow[1][M+i+2]=1;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<M; j++)\n\t\t{\n\t\t\tif(gcd(red[i], blue[j]) >= 2)\n\t\t\t{\n\t\t\t\tgraph[j+2].to.push_back(M+i+2);\n\t\t\t\tgraph[M+i+2].to.push_back(j+2);\n\n\t\t\t\tflow[j+2][M+i+2]=0;\n\t\t\t\tflow[M+i+2][j+2]=1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", HopcroftKarp(0,1,graph));\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n \nclass bipartite_matching {\npublic:\n    int n;\n    vector<vector<int>> g;\n    vector<int> match;\n \n    bipartite_matching(int n_) : n(n_), g(n_), match(n_), used(n_) {}\n \n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n \n    int maximum_matching(void) {\n        int res = 0;\n        fill(begin(match), end(match), -1);\n        for (int v = 0; v < n; ++v) {\n            if (match[v] == -1) {\n                fill(begin(used), end(used), false);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n \nprivate:\n    vector<int> used;\n    bool dfs(int v) {\n        used[v] = true;\n        for (int u : g[v]) {\n            int w = match[u];\n            if (w == -1 || (!used[w] && dfs(w))) {\n                match[v] = u; match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n};\n \nint gcd(int a, int b) {\n    return b ? gcd(b, a%b) : a;\n}\n \nint n, m;\nint a[500], b[500];\n \nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n \n    while (cin >> n >> m && n) {\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        for (int i = 0; i < m; i++) {\n            cin >> b[i];\n        }\n \n        bipartite_matching bm(n + m);\n \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (gcd(a[i], b[j]) != 1) {\n                    bm.add_edge(i, n + j);\n                }\n            }\n        }\n \n        cout << bm.maximum_matching() << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nusing namespace std;\n\nbool coprime(int a,int b){\n\tfor(int t;b;t=a,a=b,b=t)\ta%=b;\n\treturn a==1;\n}\n\nint capa[1002][1002],flow[1002][1002],src,snk,sz;\n\nbool findAugPath(int u,int *path,int &len,bool *visited,int i=0){\n\tpath[i]=u;\n\tvisited[u]=true;\n\tif(u==snk){ len=i+1; return true; }\n\tfor(int v=0;v<sz;v++){\n\t\tif(!visited[v] && capa[u][v]-flow[u][v]>0){\n\t\t\tbool b=findAugPath(v,path,len,visited,i+1);\n\t\t\tif(b)\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(int m,n;scanf(\"%d%d\",&m,&n),m;){\n\t\tstatic int blue[500],red[500];\n\t\tfor(int i=0;i<m;i++)\tscanf(\"%d\",blue+i);\n\t\tfor(int j=0;j<n;j++)\tscanf(\"%d\",red+j);\n\n\t\tsrc=0,snk=m+n+1,sz=m+n+2;\n\t\tfor(int i=0;i<sz;i++)for(int j=0;j<sz;j++){\n\t\t\tcapa[i][j]=0;\n\t\t\tflow[i][j]=0;\n\t\t}\n\n\t\tfor(int i=0;i<m;i++)\tcapa[src][1+i]=1;\n\t\tfor(int i=0;i<m;i++)for(int j=0;j<n;j++){\n\t\t\tif(!coprime(blue[i],red[j]))\tcapa[1+i][1+m+j]=1;\n\t\t}\n\t\tfor(int j=0;j<n;j++)\tcapa[1+m+j][snk]=1;\n\n\t\tstatic int path[1002],len;\n\t\tstatic bool visited[1002];\n\t\twhile(1){\n\t\t\tfor(int u=0;u<sz;u++)\tvisited[u]=false;\n\t\t\tif(!findAugPath(src,path,len,visited))\tbreak;\n\t\t\tfor(int i=1,u=path[0];i<len;i++){\n\t\t\t\tint v=path[i];\n\t\t\t\tflow[u][v]++;\n\t\t\t\tflow[v][u]--;\n\t\t\t\tu=v;\n\t\t\t}\n\t\t}\n\n\t\tint maxmatch=0;\n\t\tfor(int i=0;i<m;i++)for(int j=0;j<n;j++){\n\t\t\tif(flow[1+i][1+m+j]==1)\tmaxmatch++;\n\t\t}\n\t\tprintf(\"%d\\n\",maxmatch);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\n//int gcd( int m, int n ){\n//\twhile( m != n ){\n//\t\tif ( m > n ) m = m - n;\n//\t\telse         n = n - m;\n//\t}\n//\treturn m;\n//}\n\nint gcd(int x, int y)\n{\n    int t;\n    if(x < y) swap(x, y);\n    while(y)\n        t = x % y, x = y, y = t;\n    return x;\n}\n\nint maximum_matching(int m, int n, int graph[1009][1009], int now ,int flag){\n    if(now==m+n)return 1;\n    if(now==m+n+1){\n        int sum=0;\n        for(int i=0; i<m; i++){\n            if(graph[now][i]==0)sum++;\n            else if(maximum_matching(m, n, graph, i, flag)==1)sum++;\n        }\n        return sum;\n    }\n    if(now<m){\n        for(int i=m; i<m+n; i++){\n            if(graph[now][i]==1){\n                if(maximum_matching(m, n, graph, i, flag)==1){\n                    graph[now][i]=0;\n                    graph[i][now]=1;\n                    return 1;\n                }\n            }\n        }\n        return 0;\n    }\n    if(m<=now&&now<m+n){\n        if(flag==0){\n            if(graph[now][m+n]==1){\n                graph[now][m+n]=0;\n                return 1;\n            }else{\n                for(int i=0; i<m; i++){\n                    if(graph[now][i]==1){\n                        if(maximum_matching(m, n, graph, i, 1)==1){\n                            graph[now][i]=0;\n                            //graph[i][now]=1;\n                            return 1;\n                        }\n                    }\n                }\n            }\n            return 0;\n        }else{\n            if(graph[now][m+n]==1){\n                graph[now][m+n]=0;\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n    }\n    cout<<\"error\"<<endl;\n    return -1;\n}\n\n\n\nint main(){\n    int m,n;\n    while(1){\n        cin>>m>>n;\n        if(m==0&&n==0)break;\n        int b[509]={0};\n        int r[509]={0};\n        for(int i=0; i<m; i++){\n            cin>>b[i];\n\n        }\n        for(int i=0; i<n; i++){\n            cin>>r[i];\n        }\n        int graph[1009][1009]={0};\n        for(int i=0; i<m; i++){\n            for(int j=0; j<n; j++){\n                if(gcd(b[i],r[j])!=1)graph[i][m+j]=1;\n            }\n        }\n        for(int i=0; i<m; i++)graph[m+n+1][i]=1;//s-b\n        for(int i=0; i<n; i++)graph[m+i][m+n]=1;//r-t\n        \n        \n        \n        for(int i=0; i<m; i++){\n            for(int j=0; j<n; j++){\n                if(graph[m+n+1][i]==1&&graph[i][j]==1&&graph[j][m+n]==1){\n                    graph[m+n+1][i]=0;\n                    graph[i][j]=0;\n                    graph[j][i]=1;\n                    graph[j][m+n]=0;\n                }\n            }\n        }\n        \n        \n        \n        int sum=maximum_matching(m, n, graph, m+n+1, 0);\n        //int sum=m;\n        //for(int i=0; i<m; i++)sum-=graph[m+n+1][i];\n        cout<<sum<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,j,n) for(int i=j;i<n;++i)\n#define all(i) i.begin(),i.end()\n#define rall(i) i.rbegin(), i.rend()\n#define INF 1e9\n#define LINF 1e18\nconst int mod = 1e9 + 7;\n\ntypedef long long i64;\ntypedef pair<int, int> pi;\n\ntemplate <class T> using vt = vector<T>;\ntemplate <class T> using vvt = vector<vector<T>>;\n\ni64 gcd(i64 n, i64 m) {return (m == 0? n : gcd(m, n % m));}\ni64 lcd(i64 n, i64 m) {return (n / gcd(n, m) * m);}\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nstruct BipartiteMatching {\n  vector<vector<int>> graph;\n  vector<int> match, alive, used;\n  int timestamp;\n\n  BipartiteMatching(int n) : graph(n), alive(n, 1), used(n, 0), match(n, -1), timestamp(0) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int idx) {\n    used[idx] = timestamp;\n    for(auto &to : graph[idx]) {\n      int to_match = match[to];\n      if(alive[to] == 0) continue;\n      if(to_match == -1 || (used[to_match] != timestamp && dfs(to_match))) {\n        match[idx] = to;\n        match[to] = idx;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    for(int i = 0; i < graph.size(); i++) {\n      if(alive[i] == 0) continue;\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return ret;\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int m, n;\n  while(cin >> m >> n, m != 0 || n != 0) {\n    vt<int> b(m), r(n);\n    rep(i, 0, m) cin >> b[i];\n    rep(i, 0, n) cin >> r[i];\n\n    BipartiteMatching bm(m + n);\n    rep(i, 0, m) {\n      rep(j, 0, n) {\n        if(gcd(b[i], r[j]) != 1) bm.add_edge(i, j + m);\n      }\n    }\n    cout << bm.bipartite_matching() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n/*bipartite_matching(二部グラフの最大マッチングを求める)*/\n\nconst int MAX_V = 1500;\nint V;//頂点数\nvector<int> G[MAX_V];//グラフの隣接リスト表現\nint match[MAX_V];//マッチングのペア\nbool used[MAX_V];//DFSですでに調べたかのフラグ\n//uとvを結ぶ辺をグラフに追加する\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n//増加パスをDFSで探す\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tint u = G[v][i];\n\t\tint w = match[u];\n\t\tif(w < 0||!used[w]&&dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n//二部グラフの最大マッチングを求める\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match,-1,sizeof(used));\n\tfor(int v = 0;v < V;v++){\n\t\tif(match[v]<0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\tint blue[n];//青のカード\n\t\tint red[m];//赤のカード\n\t\tV = n+m;//頂点数は合計\n\t\trep(i,V){\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tcin>>blue[i];\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tcin>>red[i];\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j =0;j < m;j++){\n\t\t\t\tif(__gcd(blue[i],red[j])==1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tadd_edge(i,j+n);//0~n-1を青,n~m-1を赤とする\n\t\t\t}\n\t\t}\n\t\tcout <<bipartite_matching()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 6/16 10:05\n */\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#define MAX_V 1001\n\nusing namespace std;\n\n// init\n// fe[u\nbool isPrime[10000020]; // 9692 ÔÚÌf = 101197\nint prime[664580]; // 9,592(10,000,000 ¢ÌfÌ) + 100(iP ÌÅål)\nint primeN;\n\n// input\nint iM; // 1 <= M <= 500\nint iN; // 1 <= N <= 500\nint iB[501];\nint iR[501];\n\n// manage\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\n// ú»\nvoid init() {\n  // fe[uðì¬\n  int i, j;\n\n  primeN = 0;\n  fill(isPrime, isPrime + 10000020, true);\n  isPrime[0] = isPrime[1] = false;\n\n  for (i = 2; i < 10000020; i++) {\n    if (isPrime[i]) {\n      prime[primeN++] = i;\n      for (j = 2; i * j < 10000020; j++) {\n        isPrime[i * j] = false;\n      }\n      //if (primeN == 664580) {\n        //break;\n      //}\n    }\n  }\n  //printf(\"primeN = %d i = %d\\n\", primeN, i);\n}\n\n// üÍ\nbool input() {\n  int i;\n\n  scanf(\"%d %d\", &iM, &iN);\n  if (iM == 0 && iN == 0) return false;\n  for (i = 0; i < iM; i++) {\n    scanf(\"%d\", &iB[i]);\n  }\n  for (i = 0; i < iN; i++) {\n    scanf(\"%d\", &iR[i]);\n  }\n  return true;\n}\n\nvoid add_edge(int u, int v) {\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v) {\n  int i;\n  used[v] = true;\n  for (i = 0; i < (int)G[v].size(); i++) {\n    int u = G[v][i], w = match[u];\n    if (w < 0 || !used[w] && dfs(w)) {\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching() {\n  int res = 0, v;\n  fill(match, match + MAX_V, -1);\n  for (v = 0; v < V; v++) {\n    if (match[v] < 0) {\n      fill(used, used + MAX_V, false);\n      if (dfs(v)) {\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\n// \nvoid manage(){\n  int i, j, k;\n  V = iM + iN;\n  for (i = 0; i < V; i++) {\n    G[i].clear();\n  }\n  for (i = 0; i < iM; i++) {\n    for (j = 0; j < iN; j++) {\n      for (k = 0; k < primeN; k++) {\n        if (iB[i] % prime[k] == 0 && iR[j] % prime[k] == 0) {\n          //printf(\"%d %d %d\\n\", iB[i], iR[j], prime[k]);\n          add_edge(i, j + iM);\n        } else {\n          if (iB[i] < prime[k] || iR[j] < prime[k]) {\n            break;\n          }\n        }\n      }\n    }\n  }\n}\n\n// oÍ\nvoid output(){\n  printf(\"%d\\n\", bipartite_matching());\n}\n\n// mizoSâ¤Ê\nint main() {\n  init(); // ú»\n  while(1) {\n    if (!input()) break; // üÍ + I¹»è\n    manage(); // \n    output(); // oÍ\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n\n//constant\nconst int MOD = 1000000009;\nconst int INF = INT_MAX / 3;\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\n\nstruct edge { int to, cap, rev, cost; };\n\nconstexpr int MAX_V = 1002;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost = 0) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,cost });\n}\n\nvoid bfs(int s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\t\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tint f;\n\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\ntypedef pair<int, int> P;\nint V;\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nint min_cost_flow(int s, int t, int f) {\n\tint res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tfill_n(dist, V, numeric_limits<int>::max());\n\t\tdist[s] = 0;\n\t\tque.push({ 0,s });\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint v = p.second;\n\t\t\tif (dist[v] < p.first)continue;\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d*h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int x, int y) {\n\tif (y == 0 || x == 0)\n\t\treturn max(x, y);\n\ty = y - (y / x)*x;\n\treturn gcd(y, x);\n\n}\nint main() {\n\tint m, n;\n\tvector<int> prime;\n\tvector<int> isprime(50000, 1);\n\tisprime[0] = isprime[1] = 0;\n\tfor (int i = 0; i < 50000; i++)\n\t\tif (isprime[i]) {\n\t\t\tprime.push_back(i);\n\t\t\tfor (int j = i * 2; j < 50000; j += i)\n\t\t\t\tisprime[j] = 0;\n\n\n\t\t}\n\twhile (cin >> m >> n, m) {\n\t\tfor (int i = 0; i < MAX_V; i++)\n\t\t\tG[i].clear();\n\t\tvector<int> b(m);\n\t\tvector<int> r(n);\n\t\tREP(i, m)\n\t\t\tcin >> b[i];\n\t\tREP(i, n)\n\t\t\tcin >> r[i];\n\t\tREP(i, m) {\n\t\t\tadd_edge(n + m, i, 1);\n\n\t\t}\n\t\tREP(j, n) {\n\t\t\tadd_edge(j + m, m + n + 1, 1);\n\t\t}\n\t\tREP(i, m)\n\t\t\tREP(j, n) {\n\t\t\tif (gcd(b[i], r[j]) != 1)\n\t\t\t\tadd_edge(i, j + m, 1);\n\t\t}\n\t\tcout << max_flow(n + m, n + m + 1) << endl;\n\t}\n\t\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nint bipartiteMaximumMatchings(const vector<vector<bool> >& graph)\n{\n    int answer = 0;\n    int n = graph.size();\n    int m = graph[0].size();\n    vector<int> selectN(n, -1);\n    vector<int> selectM(m, -1);\n\n    for(int i=0; i<n; ++i){\n        vector<bool> visitedN(n, false);\n        vector<bool> visitedM(m, false);\n        visitedN[i] = true;\n        vector<int> path(min(n,m)*2, -1);\n\n        path[0] = i;\n        int index = 1;\n        for(;;){\n            while(++path[index] < m && (!graph[path[index-1]][path[index]] || selectN[path[index-1]]==path[index] || visitedM[path[index]]));\n            if(path[index] < m){\n                if(selectM[path[index]] == -1){\n                    for(int j=0; j<index; j+=2){\n                        selectN[path[j]] = path[j+1];\n                        selectM[path[j+1]] = path[j];\n                    }\n                    ++ answer;\n                    break;\n                }\n                if(!visitedN[selectM[path[index]]]){\n                    path[index+1] = selectM[path[index]];\n                    visitedM[path[index]] = true;\n                    visitedN[path[index+1]] = true;\n                    index += 2;\n                }\n            }\n            else{\n                path[index] = -1;\n                index -= 2;\n                if(index < 0)\n                    break;\n            }\n        }\n    }\n\n    return answer;\n}\n\nvoid solve(const vector<int>& blue, const vector<int>& red)\n{\n\tvector<vector<bool> > graph(blue.size(), vector<bool>(red.size(), false));\n\tfor(unsigned i=0; i<blue.size(); ++i){\n\t\tvector<int> num;\n\t\tint a = blue[i];\n\t\tint b = 2;\n\t\twhile(a > 1){\n\t\t\tif(a % b == 0){\n\t\t\t\tnum.push_back(b);\n\t\t\t\twhile(a % b == 0)\n\t\t\t\t\ta /= b;\n\t\t\t}\n\t\t\t++ b;\n\t\t}\n\n\t\tfor(unsigned j=0; j<red.size(); ++j){\n\t\t\tfor(unsigned k=0; k<num.size(); ++k){\n\t\t\t\tif(red[j] % num[k] == 0){\n\t\t\t\t\tgraph[i][j] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << bipartiteMaximumMatchings(graph) << endl;\n}\n\nint main()\n{\n    for(;;){\n        int m, n;\n        cin >> m >> n;\n        if(m == 0 && n == 0)\n            break;\n\n\t\tvector<int> blue(m);\n\t\tvector<int> red(n);\n\t\tfor(int i=0; i<m; ++i)\n\t\t\tcin >> blue[i];\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tcin >> red[i];\n\n        solve(blue, red);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[200010];\n                int inv[200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n//    mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\nstruct bi_match{\n\tprivate:\n\tpublic:\n\t\n\t// 頂点は0以上V未満\n\t// 各頂点がどっち側かは意識しなくていい\n\t// 多重辺はダメ\n\t\n\tvector<vector<int>> Graph;\n\tint V;\n\tvector<int> match,used;\n\tbi_match(int V){ // 入力サイズ \n\t\tthis->V=V;\n\t\tGraph.resize(V);\n\t\tmatch.resize(V,-1);\n\t\tused.resize(V,-1);\n\t}\n\t\n\tvoid add_edge(int u,int v){\n\t\t\n\t\tGraph[u].pb(v);\n\t\tGraph[v].pb(u);\t\t\n\t}\n\t\n\tbool dfs_bi(int v,int num){\n\t\tused[v] = num;\n  \t\tfor(int u:Graph[v]){\n    \t\tint w=match[u];\n    \t\tif(w<0 || used[w]<num && dfs_bi(w,num)){\n      \t\t\tmatch[v]=u;\n      \t\t\tmatch[u]=v;\n      \t\t\treturn true;\n    \t\t}\n  \t\t}\n  \t\treturn false;\n\t}\n\t\n\tint solve(){\n \t\tint res=0;\n  \t\tfor(int v=0;v<V;v++){\n    \t\tif(match[v]<0){\n      \t\t\tif(dfs_bi(v,v)){\n       \t\t\t\t res++;\n      \t\t\t}\n    \t\t}\n  \t\t}\n \t\treturn res;\n\t}\n};\n\n signed main(){\n \t\n \n    \t       cin.tie(0);\n   \t\tios::sync_with_stdio(false);\n \tint n,m;\n \tint a[510],b[510];\n    while(1){\n         \n        cin>>n>>m;\n        if(n==0) break;\n    \tbi_match bi(n+m);\n        for(int i=0;i<n;i++) cin>>a[i];\n        for(int j=0;j<m;j++) cin>>b[j];\n         \n        for(int i=0;i<n;i++)for(int j=0;j<m;j++){\n            if(gcd(a[i],b[j])!=1){\n                bi.add_edge(i,n+j); \n    //          cout<<i<<\" \"<<j<<endl;\n            }\n    //  cout<<i<<\" \"<<j<<endl;\n        }\n    //  cout<<n<<\" \"<<m<<endl;\n        cout<<bi.solve()<<endl;\n    }\n    return 0;\n \treturn 0;\n\n \t\n \t\n }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\n/*\ntypedef int weight;\nstruct edge\n{\n\tint from, to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n*/\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\ntypedef int Weight;\ntypedef int Flow;\n\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int src, int dest, Flow cap)\n{\n\tg[src].push_back(Edge{ src, dest, (int)g[dest].size(), cap, 0 });\n\tg[dest].push_back(Edge{ dest, src, (int)g[src].size() - 1, 0, 0 });\n}\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f)\n{\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (Edge& e : g[v])\n\t{\n\t\tif (!used[e.dest] && e.cap > 0)\n\t\t{\n\t\t\tFlow d = dfs(g, used, e.dest, t, min(f, e.cap));\n\t\t\tif (d > 0)\n\t\t\t{\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.dest][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nFlow ford_fulkerson(Graph &g, int s, int t)\n{\n\tFlow flow = 0;\n\tfor (;;)\n\t{\n\t\tvector<bool> used(g.size(), false);\n\t\tFlow f = dfs(g, used, s, t, INF);\n\t\tif (f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\nint gcd(int a, int b)\n{\n\tif (a < b) swap(a, b);\n\treturn (a%b ? gcd(a%b, b) : b);\n}\n\nint lcm(int a, int b)\n{\n\treturn a / gcd(a, b)*b;\n}\n\nint main()\n{\n\tint m, n;\n\twhile (cin >> m >> n, m)\n\t{\n\t\tGraph g(m + n + 2);\n\t\tREP(i, m) add_edge(g, 0, i + 2, 1);\n\t\tREP(i, n) add_edge(g, m + i + 2, 1, 1);\n\t\tint blue[501], red[501];\n\t\tREP(i, m) cin >> blue[i];\n\t\tREP(i, n) cin >> red[i];\n\t\tREP(i, m)REP(j, n)\n\t\t{\n\t\t\tif (gcd(blue[i], red[j]) > 1) add_edge(g, 2 + i, 2 + m + j, 1);\n\t\t}\n\t\tcout << ford_fulkerson(g, 0, 1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 6/16 10:05\n */\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#define MAX_V 1001\n\nusing namespace std;\n\n// init\n// fe[u\nbool isPrime[10000020]; // 9692 ÔÚÌf = 101197\nint prime[664580]; // 9,592(10,000,000 ¢ÌfÌ) + 100(iP ÌÅål)\nint primeN;\n\n// input\nint iM; // 1 <= M <= 500\nint iN; // 1 <= N <= 500\nint iB[501];\nint iR[501];\n\n// manage\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\n// ú»\nvoid init() {\n  // fe[uðì¬\n  int i, j;\n\n  primeN = 0;\n  fill(isPrime, isPrime + 10000020, true);\n  isPrime[0] = isPrime[1] = false;\n\n  for (i = 2; i < 10000020; i++) {\n    if (isPrime[i]) {\n      prime[primeN++] = i;\n      for (j = 2; i * j < 10000020; j++) {\n        isPrime[i * j] = false;\n      }\n      //if (primeN == 664580) {\n        //break;\n      //}\n    }\n  }\n  //printf(\"primeN = %d i = %d\\n\", primeN, i);\n}\n\n// üÍ\nbool input() {\n  int i;\n\n  scanf(\"%d %d\", &iM, &iN);\n  if (iM == 0 && iN == 0) return false;\n  for (i = 0; i < iM; i++) {\n    scanf(\"%d\", &iB[i]);\n  }\n  for (i = 0; i < iN; i++) {\n    scanf(\"%d\", &iR[i]);\n  }\n  return true;\n}\n\nvoid add_edge(int u, int v) {\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v) {\n  int i;\n  used[v] = true;\n  for (i = 0; i < (int)G[v].size(); i++) {\n    int u = G[v][i], w = match[u];\n    if (w < 0 || !used[w] && dfs(w)) {\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching() {\n  int res = 0, v;\n  fill(match, match + MAX_V, -1);\n  for (v = 0; v < V; v++) {\n    if (match[v] < 0) {\n      fill(used, used + MAX_V, false);\n      if (dfs(v)) {\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\n// \nvoid manage(){\n  int i, j, k;\n  V = iM + iN;\n  for (i = 0; i < V; i++) {\n    G[i].clear();\n  }\n  /*\n  for (i = 0; i < iM; i++) {\n    printf(\"%d\\n\", i);\n    for (j = 0; j < iN; j++) {\n      for (k = 0; k < primeN; k++) {\n        //printf(\"%d %d %d\\n\", iB[i], iR[j], prime[k]);\n        if (iB[i] % prime[k] == 0 && iR[j] % prime[k] == 0) {\n          add_edge(i, j + iM);\n        } else {\n          if (iB[i] < prime[k] || iR[j] < prime[k]) {\n            break;\n          }\n        }\n      }\n    }\n  }\n  */\n  for (i = 0; i < primeN; i++) {\n    //printf(\"%d\\n\", i);\n    for (j = 0; j < iM; j++) {\n      //printf(\"%d\\n\", j);\n      if (iB[j] % prime[i] != 0 || iB[j] < prime[i]) continue;\n      for (k = 0; k < iN; k++) {\n        if (iR[k] % prime[i] != 0 || iR[k] < prime[i]) continue;\n        //printf(\"%d %d %d\\n\", iB[j], iR[k], prime[i]);\n        add_edge(j, k + iM);\n      }\n    }\n  }\n}\n\n// oÍ\nvoid output(){\n  printf(\"%d\\n\", bipartite_matching());\n}\n\n// mizoSâ¤Ê\nint main() {\n  init(); // ú»\n  while(1) {\n    if (!input()) break; // üÍ + I¹»è\n    manage(); // \n    output(); // oÍ\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n//typedef long long Int;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst) : src(src),dst(dst) {}\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) {}\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vec<Edge> Edges;\ntypedef vec<Edges> Graph;\n\n#define MAXMN 500\nint B[MAXMN];\nint R[MAXMN];\n\nint gcd(int a, int b)\n{   \n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\n\n\nmain() {\n  int M,N;\n  Graph g;\n  while(cin>>M>>N,M) {\n    g.clear();\n    g.resize(M+N+2);\n    REP(i,M) cin>>B[i];\n    REP(i,N) cin>>R[i];\n    REP(i,M) {\n      Edges es, es2;\n      REP(j,N) {\n\tif(gcd(B[i],R[j])!=1) { es.pb(Edge(i,M+j)); es2.pb(Edge(M+j,i)); }\n      }\n      g[i] = es;\n      g[M+i] = es2;\n    }\n    Edges matching;\n    cout << bipartiteMatching(g,M,matching) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nstruct Edge {\n    int src, dst;\n    Edge(int src, int dst): src(src), dst(dst) {}\n};\nusing Vertex = vector<Edge>;\nusing Graph = vector<Vertex>;\n\nvoid add_edge(Graph& graph, int src, int dst) {\n    graph[src].emplace_back(src, dst);\n    graph[dst].emplace_back(dst, src);\n}\n\nbool augment(const Graph& graph, vector<bool>& visited, vector<int>& match, int u) {\n    if (u == -1) return true;\n    for (auto& e : graph[u]) {\n        if (!visited[e.dst]) {\n            visited[e.dst] = true;\n            if (augment(graph, visited, match, match[e.dst])) {\n                match[e.src] = e.dst;\n                match[e.dst] = e.src;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint bipartie_matching(const Graph& graph, int n_left) {\n    vector<int> match(graph.size(), -1);\n    int n_match = 0;\n    REP(u, n_left) {\n        vector<bool> visited(graph.size());\n        if (augment(graph, visited, match, u)) ++n_match;\n    }\n    return n_match;\n}\n\nint gcd(int a, int b) { return (b == 0) ? a : gcd(b, a%b); }\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int m, n;\n    while (cin>>m>>n, m|n) {\n        vector<int> blue(m), red(n);\n        REP(i, m) cin >> blue[i];\n        REP(i, n) cin >> red[i];\n\n        Graph graph(m+n);\n        REP(i, m) REP(j, n) {\n            if (gcd(blue[i], red[j]) > 1)\n                add_edge(graph, i, m+j);\n        }\n\n        cout << bipartie_matching(graph, m) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 4444\nvector<int> v[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int a,int b){\n\tv[a].PB(b);\n\tv[b].PB(a);\n}\n\nbool matchdfs(int a){\n\tused[a] = true;\n\tfor(int i = 0;i < v[a].size();i++)\t{\n\t\tint u = v[a][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w)){\n\t\t\tmatch[u] = a;\n\t\t\tmatch[a] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//二部マッチング\nint two_matching_max(int l){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<int> prime;\n#define HOGE 5000000\nbool isp[HOGE];\nvoid f(){\n\tREP(i,HOGE)isp[i] = true;\n\tisp[0] = isp[1] = false;\n\tfor(int i = 2;i < HOGE;i++){\n\t\tif(isp[i]){\n\t\t\tprime.PB(i);\n\t\t\tfor(int j = i;j < HOGE;j+=i)isp[j] = false;\n\t\t}\n\t}\n}\n\t\n#define HALF 1000\nint main(){\n\tf();\n\tint n,m;\n\twhile(cin >> m >> n,n|m){\n\t\tREP(i,MAX_V)v[i].clear();\n\t\tvector<ll> a(m);REP(i,m)cin >> a[i];\n\t\tvector<ll> b(n);REP(i,n)cin >> b[i];\n\t\tREP(i,m){\n\t\t\tvector<ll> tmp;\n\t\t\tREP(j,prime.size()){\n\t\t\t\tif(a[i] % prime[j] == 0)tmp.PB(prime[j]);\n\t\t\t}\n\t\t\tREP(j,n){\n\t\t\t\tREP(k,tmp.size()){\n\t\t\t\t\tif(b[j] % tmp[k] == 0){\n\t\t\t\t\t\tadd_edge(i,j + 1000);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << two_matching_max(MAX_V) << endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int INF=1000;\nstruct edge{\n    int to,cap,rev;\n};\nvector<edge> graph[1010];\nbool used[1010];\nvoid add_edge(int from,int to,int cap){\n    graph[from].push_back((edge){to,cap,static_cast<int>(graph[to].size())});\n    graph[to].push_back((edge){from,0,static_cast<int>(graph[from].size()-1)});\n}\nint dfs(int at,int t,int f){\n    if(at==t) return f;\n    used[at]=true;\n    for(int i=0;i<graph[at].size();i++){\n        edge &now=graph[at][i];\n        if(!used[now.to] && now.cap>0){\n            int d=dfs(now.to,t,min(f,now.cap));\n            if(d>0){\n                now.cap-=d;\n                graph[now.to][now.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s,int t,int V){\n    int flow=0;\n    for(;;){\n        for(int i=0;i<V;i++){\n            used[i]=false;\n        }\n        int f=dfs(s,t,INF);\n        if(f==0) return flow;\n        flow+=f;\n    }\n}\n\nint b[510],r[510];\nint main(){\n    int m,n;\n    for(;;){\n        scanf(\"%d%d\",&m,&n);\n        if(m==0 && n==0) break;\n        fill(graph,graph+m+n+2,vector<edge>());\n        for(int i=0;i<m;i++){\n            add_edge(m+n,i,1);\n            scanf(\"%d\",&b[i]);\n        }\n        for(int i=0;i<n;i++){\n            add_edge(i+m,m+n+1,1);\n            scanf(\"%d\",&r[i]);\n        }\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(__gcd(b[i],r[j])>1) add_edge(i,j+m,1);\n            }\n        }\n        printf(\"%d\\n\",max_flow(m+n,m+n+1,m+n+2));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\ntypedef long long Int;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst) : src(src),dst(dst) {}\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) {}\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vec<Edge> Edges;\ntypedef vec<Edges> Graph;\n\n#define MAXMN 500\nint B[MAXMN];\nint R[MAXMN];\n\nInt gcd(Int a, Int b)\n{   \n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\n\n\nmain() {\n  int M,N;\n  Graph g;\n  while(cin>>M>>N,M) {\n    g.clear();\n    g.resize(M+N+2);\n    REP(i,M) cin>>B[i];\n    REP(i,N) cin>>R[i];\n    REP(i,M) {\n      Edges es, es2;\n      REP(j,N) {\n\tif(gcd(B[i],R[j])!=1) { es.pb(Edge(i,M+j)); es2.pb(Edge(M+j,i)); }\n      }\n      g[i] = es;\n      g[M+i] = es2;\n    }\n    Edges matching;\n    cout << bipartiteMatching(g,M,matching) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < n; i++)\nusing namespace std;\n\nint M,N;\nint V = 1010;//頂点数\nconst int MAX_V = 1010;\nint B[505];\nint R[505];\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v) {\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 or !used[w] and dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipairetite_matching() {\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; v++) {\n\t\tif (match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int a, int b) {\n\tif (a < b) swap(a,b);\n\twhile (b) {\n\t\ta = a % b;\n\t\tswap(a,b);\n\t}\n\treturn a;\n}\n\nint main() {\n\twhile(cin >> M >> N, M) {\n\t\trep(i, 1010) G[i].clear();\n\t\trep(i, M) {\n\t\t\tcin >> B[i];\n\t\t}\n\t\trep(i, N) {\n\t\t\tcin >> R[i];\n\t\t}\n\t\trep(m, M) {\n\t\t\trep(n, N) {\n\t\t\t\tif (gcd(B[m], R[n]) > 1) {\n\t\t\t\t\tadd_edge(m, n + M);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipairetite_matching() << endl;\n\t}\n}\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\n#define MAX_V 1002\nusing namespace std;\nstruct edge {\n\tint to, cap, rev;\n\tedge(int to_, int cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {};\n};\n\nint V;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nint GCD(int a, int b) {\n\treturn b ? GCD(b, a % b) : a;\n}\n\nvoid AddEdge(int from, int to, int cap) {\n\tG[from].push_back(edge(to, cap, G[to].size()));\n\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nvoid BFS(int s) {\n\tfill(level, level + V, -1);\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tfor (size_t i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint DFS(int v, int t, int f) {\n\tif (v == t) return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = DFS(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint Dinic(int s, int t) {\n\tint flow = 0;\n\twhile (true) {\n\t\tBFS(s);\n\t\tif (level[t] < 0) return flow;\n\t\tfill(iter, iter + V, 0);\n\t\tint f;\n\t\twhile ((f = DFS(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint m, n;\n\twhile (cin >> m >> n, m || n) {\n\t\tvector<int> b(m), r(n);\n\t\tV = m + n + 2;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> b[i];\n\t\t\tAddEdge(m + n, i, 1);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> r[i];\n\t\t\tAddEdge(m + i, m + n + 1, 1);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (GCD(b[i], r[j]) != 1) {\n\t\t\t\t\tAddEdge(i, m + j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << Dinic(m + n, m + n + 1) << endl;\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1163&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\n\n/* MAX_FLOW */\n\n#define MAX_V 1010\nstruct edge {\n\tint to; int cap; int rev;\n\tedge() {}\n\tedge(int to, int cap, int rev) :to(to), cap(cap), rev(rev) {}\n};\nvector<edge> G[MAX_V];\n\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge(to, cap, (int)G[to].size()));\n\tG[to].push_back(edge(from, 0, (int)G[from].size() - 1));\n}\n\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\n\tfor (int i = 0; i < (int)G[v].size();i++) {\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, INF);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n\treturn -1;\n}\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\n\tint m, n;\n\twhile (cin >> m >> n, m | n) {\n\t\tfor (int i = 0; i < MAX_V;i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t\tvector<int> b(m + 1);\n\t\tvector<int> r(n + 1);\n\t\tfor (int i = 1; i <= m;i++) {\n\t\t\tcin >> b[i];\n\t\t\tadd_edge(0, i, 1);\n\t\t}\n\t\tfor (int i = 1; i <= n;i++) {\n\t\t\tcin >> r[i];\n\t\t\tadd_edge(m + i, m + n + 1, 1);\n\t\t}\n\n\t\tfor (int i = 1; i <= m;i++) {\n\t\t\tfor (int j = 1;j <= n;j++) {\n\t\t\t\tif (gcd(b[i], r[j]) == 1) continue;\n\t\t\t\tadd_edge(i, m + j, 1);\n\t\t\t}\n\t\t}\n\n\t\tcout << max_flow(0, m + n + 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> L[2000];int N,M,E,match[2000],x[2000],y[2000];bool used[2000];\nbool DFS(int V){\n    used[V]=true;\n    for(int i=0;i<L[V].size();i++){\n        int u=L[V][i],w=match[u];\n        if(w<0||!used[w]&&DFS(w)){\n            match[V]=u;\n            match[u]=V;\n            return 1;\n        }\n    }\n    return 0;\n}\nint SM(){\n    int r=0;\n    memset(match,-1,sizeof(match));\n    for(int j=0;j<N+M;j++){\n        if(match[j]<0){\n            memset(used,0,sizeof(used));\n            if(DFS(j)){r++;}\n        }\n    }\n    return r;\n}\nint main(){\n    while(1){\n        for(int i=0;i<2000;i++){L[i].clear();}\n        cin>>N>>M;if(!N){break;}\n        for(int i=0;i<N;i++){\n            cin>>x[i];\n        }\n        for(int i=0;i<M;i++){\n            cin>>y[i];\n        }\n        for(int i=0;i<N;i++){\n            for(int j=0;j<M;j++){\n                if(__gcd(x[i],y[j])>1){\n                    L[i].push_back(j+N);\n                }\n            }\n        }\n        cout<<SM()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> L[2000];int N,M,E,i,j,match[2000],x[2000],y[2000];bool used[2000];\nbool DFS(int V){\n    used[V]=true;\n    for (i = 0; i < L[V].size(); i++) {\n        int u = L[V][i]; int w = match[u];\n        if (w < 0 || !used[w] && DFS(w)) {\n            match[V] = u;\n            match[u] = V;\n            return true;\n        }\n    }\n    return false;\n}\nint SM() {\n    int r = 0;\n    memset(match, -1, sizeof(match));\n    for (j = 0; j < N + M; j++) {\n        if (match[j] < 0) {\n            memset(used, 0, sizeof(used));\n            if (DFS(j)) { r++; }\n        }\n    }\n    return r;\n}\n \n//main.\nint main() {\n    while (true) {\n        for (i = 0; i < 2000; i++) { L[i].clear(); }\n        cin >> N >> M; if (!N) { break; }\n        for (i = 0; i < N; i++) {\n            cin >> x[i];\n        }\n        for (i = 0; i < M; i++) {\n            cin >> y[i];\n        }\n        for (i = 0; i < N; i++) {\n            for (j = 0; j < M; j++) {\n                if (__gcd(x[i], y[j]) != 1) {\n                    L[i].push_back(j + N);\n                }\n            }\n        }\n        cout << SM() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include \"push_relabel.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n  each(x,vec) is >> x;\n  return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n  rep(i,vec.size()) {\n    if (i) os << \" \";\n    os << vec[i];\n  }\n  return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n  rep(i,vec.size()) {\n    if (i) os << endl;\n    os << vec[i];\n  }\n  return os;\n}\n\nclass PushRelabel {\n  struct Edge {\n    int to, cap, rev;\n  };\n  int fsum;\n  std::vector<std::vector<Edge>> G;\n  std::vector<int> h, f;\n  void relabel(int v);\n  bool push(int v);\n  Edge& rev(const Edge& e);\npublic:\n  PushRelabel(int node_count);\n  void add(int from, int to, int cap);\n  int flow(int s, int t);\n};\nPushRelabel::PushRelabel(int node_count) : fsum(0), G(node_count), h(node_count, 0), f(node_count, 0) {}\nvoid PushRelabel::add(int from, int to, int cap) {\n  G[from].pb({to, cap, int(G[to].size())});\n  G[to].pb({from, 0, int(G[from].size())-1});\n}\nint PushRelabel::flow(int s, int t) {\n  const int n = G.size();\n  h[s] = n+2, h[t] = 0;\n  f[s] = int(1e9);\n  push(s);\n  while (true) {\n    bool is_updated = false;\n    rep(i, n) {\n      if (i == s || i == t) continue;\n      if (f[i] > 0) {\n        if (!push(i)) {\n          relabel(i);\n          push(i);\n          is_updated = true;\n        }\n      }\n    }\n    if (!is_updated) break;\n  }\n  return f[t];\n}\nbool PushRelabel::push(int v) {\n  bool res = false;\n  each(e, G[v]) {\n    if (h[v] == h[e.to] + 1 && e.cap > 0) {\n      ll use = min(e.cap, f[v]);\n      e.cap -= use;\n      rev(e).cap -= use;\n      f[e.to] += use;\n      f[v] -= use;\n      res = true;\n    }\n  }\n  return res;\n}\nvoid PushRelabel::relabel(int v) {\n  each(e, G[v]) {\n    chmax(h[v], h[e.to]+1);\n  }\n}\nPushRelabel::Edge& PushRelabel::rev(const Edge& e) {\n  return G[e.to][e.rev];\n}\n\n\nclass MaxFlow {\npublic:\n  struct Edge {\n    ll to, cap, rev;\n  };\n  vector<vector<Edge>> G;\n  vector<ll> iter;\nprivate:\n  bool is_debug;\n  ll V;\n  vector<ll> bfs(ll s) {\n    vector<ll> dist(V, linf);\n    dist[s] = 0;\n    queue<ll> Q; Q.push(s);\n    while ( !Q.empty() ) {\n      ll v = Q.front(); Q.pop();\n      each(e, G[v]) {\n        if (e.cap > 0 && dist[e.to] == linf) {\n          dist[e.to] = dist[v]+1;\n          Q.push(e.to);\n        }\n      }\n    }\n    return dist;\n  }\n  ll dfs(ll v, ll t, ll f, const vector<ll>& dist, vector<bool>& used) {\n    if (v == t) return f;\n    if (used[v]) return 0;\n    used[v] = true;\n    for (ll& i = iter[v]; i < G[v].size(); ++i) {\n      Edge& e = G[v][i];\n      if (e.cap > 0 && dist[e.to] == dist[v]+1) {\n        ll d = dfs(e.to, t, min(f, e.cap), dist, used);\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\npublic:\n  const vector<vector<Edge>>& Graph() {\n    return G;\n  }\n  MaxFlow(ll V, bool is_debug=false) : V(V), G(V), is_debug(is_debug) {}\n  void init(ll n) {\n    V = n;\n    G.assign(V, vector<Edge>());\n  }\n  void add(ll from, ll to, ll cap) {\n    if (is_debug) cout << \"ADD: \" << from << \" \" << to << \" \" << cap << endl;\n    assert(V > 0);\n    G[from].pb({to, cap, (ll)G[to].size()});\n    G[to].pb({from, 0, (ll)G[from].size()-1});\n  }\n  // S -> s, T -> t に inf は自力で\n  void add(ll from, ll to, ll min_flow, ll cap, ll S, ll T) {\n    if (is_debug) cout << endl << \"ADD_MIN:\" << from << \" \" << to << \" \" << min_flow << \" \" << cap << endl;\n    add(from, to, cap-min_flow);\n    add(S, to, min_flow);\n    add(from, T, cap);\n    if (is_debug) cout << endl;\n  }\n  ll flow(ll s, ll t, ll f=linf) {\n    ll res = 0;\n    while (f > 0) {\n      vector<ll> dist = bfs(s);\n      if (dist[t] == linf) break;\n      iter.assign(G.size(), 0);\n      while (f > 0) {\n        vector<bool> used(V, false);\n        ll df = dfs(s, t, f, dist, used);\n        if (df == 0) break;\n        f -= df;\n        res += df;\n      }\n    }\n    return res;\n  }\n};\n\nll gcd(ll a, ll b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  ll n, m;\n  while (cin >> n >> m, n || m) {\n    vector<ll> a(n), b(m); cin >> a >> b;\n    ll s = n + m, t = s + 1;\n    MaxFlow pr(t+1);\n    rep(i, n) rep(j, m) {\n      if (gcd(a[i], b[j]) > 1) {\n        pr.add(i, n+j, 1);\n      }\n    }\n    rep(i, n) pr.add(s, i, 1);\n    rep(i, m) pr.add(n+i, t, 1);\n    cout << pr.flow(s, t) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MAX_V (2000)\n\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    int u = G[v][i], w = match[u];\n    if( w < 0 ||  !used[w] && dfs(w) ){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res  = 0;\n  memset(match,-1,sizeof(match));\n  for(int v=0;v<V;v++){\n    if( match[v] < 0 ) {\n      memset(used,0,sizeof(used));\n      if( dfs(v) ) {\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint M,N;\nint B[555],R[555];\n\nint main(){\n\n  while(cin >> M >> N && (M||N) ){\n    for(int i=0;i<M;i++) cin >> B[i];\n    for(int i=0;i<N;i++) cin >> R[i];\n\n    V = M + N;\n\n    for(int i=0;i<M;i++){\n      for(int j=0;j<N;j++){\n\tif( __gcd(B[i],R[j]) != 1 ){\n\t  add_edge(i,j+M);\n\t}\n      }\n    }\n\n    cout << bipartite_matching() << endl;\n    for(int i=0;i<V;i++) G[i].clear();\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string.h>\n#include <queue>\nusing namespace std;\nstruct edge{int to, cap, rev;};\nint INF = 10000000;\nint iter[1002];\nint level[1002];\n\nvoid bfs(vector< vector<edge> > &G, int s){\n  memset(level,-1,sizeof(level));\n  level[s] = 0;\n  queue<int> que;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i = 0; i < G[v].size(); ++i){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n\tlevel[e.to] = level[v] + 1;\n\tque.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(vector< vector<edge> > &G, int v, int t, int f){\n  if(v == t) return f;\n  for(int &i = iter[v]; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(G,e.to,t,min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(vector< vector<edge> > &G, int s, int t){\n  int flow = 0;\n  for(;;){\n    bfs(G,s);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f = dfs(G,s,t,INF)) > 0){\n      flow += f;\n    }\n  }\n}\n\nint gcd(int a, int b){\n  if(a < b) swap(a,b);\n  if(a % b) return gcd(b,a%b);\n  return b;\n}\n\nint main(){\n  int m, n;\n  while(cin >> m >> n, m){\n    int b[m], r[n];\n    vector< vector<edge> > G(n+m+2);\n    for(int i = 0; i < m; ++i)\n      cin >> b[i];\n    for(int i = 0; i < n; ++i)\n      cin >> r[i];\n    for(int i = 0; i < m; ++i){\n      for(int j = 0; j < n; ++j){\n\tif(gcd(b[i],r[j]) != 1){\n\t  G[i].push_back((edge){j+m,1,G[j+m].size()});\n\t  G[j+m].push_back((edge){i,0,G[i].size()-1});\n\t}\n      }\n    }\n    int s = n + m, t = n + m + 1;\n    for(int i = 0; i < m; ++i){\n      G[s].push_back((edge){i,1,G[i].size()});\n      G[i].push_back((edge){s,0,G[s].size()-1});\n    }\n    for(int i = 0; i < n; ++i){\n      G[i+m].push_back((edge){t,1,G[t].size()});\n      G[t].push_back((edge){i+m,0,G[i+m].size()});\n    }\n    cout << max_flow(G,s,t) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "from fractions import gcd\n\nV = 1003\nG = []\nvisited = []\nmatch = []\n\ndef add_edge(u,v):\n    G[u].append(v)\n    G[v].append(u)\n\ndef dfs(v):\n    visited[v] = True\n    for u in G[v]:\n        w = match[u]\n        if w < 0 or not visited[w] and dfs(w):\n            match[v] = u\n            match[u] = v\n            return True\n\ndef bipartite_matching():\n    global match,visited\n    res = 0\n    match = [-1]*V\n    for v in xrange(V):\n        if match[v] < 0:\n            visited = [False]*V\n            if dfs(v):\n                res += 1\n    return res\n\nwhile True:\n    m,n = map(int,raw_input().split())\n    if m|n == 0:\n        break\n    V = m+n+2\n    G = [[] for _ in xrange(V)]\n    visited = [True] * V\n    data = []\n    while len(data) < n+m:\n        data += map(int,raw_input().split())\n    for i,b in enumerate(data[:m]):\n        for j,r in enumerate(data[m:],m):\n            if gcd(b,r) != 1:\n                add_edge(i,j)\n    print bipartite_matching()"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nstruct Edge {\n    int src, dst, capacity;\n    Edge(int src, int dst, int capacity): src(src), dst(dst), capacity(capacity) {}\n};\nusing Vertex = vector<Edge>;\nusing Graph = vector<Vertex>;\n\nvoid add_edge(Graph& graph, int src, int dst, int capacity) {\n    graph[src].emplace_back(src, dst, capacity);\n    graph[dst].emplace_back(dst, src, 0);\n}\n\nint edmonds_karp(Graph& graph, int source, int sink) {\n    vector<vector<int>> flow(graph.size(), vector<int>(graph.size()));\n    Edge dummy(-1, -1, -1);\n    int total = 0;\n    for (;;) {\n        // find path\n        queue<int> Q; Q.push(source);\n        vector<Edge*> prev(graph.size()); prev[source] = &dummy;\n        while (!Q.empty() && prev[sink] == nullptr) {\n            int u = Q.front(); Q.pop();\n            for (auto& e : graph[u]) {\n                if (prev[e.dst] == nullptr && e.capacity - flow[e.src][e.dst] > 0) {\n                    prev[e.dst] = &e;\n                    Q.push(e.dst);\n                }\n            }\n        }\n        if (prev[sink] == nullptr) return total;\n\n        // augment flow\n        int f = INT_MAX;\n        for (int u = sink; prev[u] != &dummy; u = prev[u]->src) {\n            Edge* e = prev[u];\n            f = min(f, e->capacity - flow[e->src][e->dst]);\n        }\n        for (int u = sink; prev[u] != &dummy; u = prev[u]->src) {\n            Edge* e = prev[u];\n            flow[e->src][e->dst] += f;\n            flow[e->dst][e->src] -= f;\n        }\n        total += f;\n    }\n}\n\nint gcd(int a, int b) { return (b == 0) ? a : gcd(b, a%b); }\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int m, n;\n    while (cin>>m>>n, m|n) {\n        vector<int> blue(m), red(n);\n        REP(i, m) cin >> blue[i];\n        REP(i, n) cin >> red[i];\n\n        Graph graph(m+n+2);\n        REP(i, m) REP(j, n) {\n            if (gcd(blue[i], red[j]) > 1)\n                add_edge(graph, i, m+j, 1);\n        }\n        REP(i, m) add_edge(graph, m+n, i, 1);\n        REP(j, n) add_edge(graph, m+j, m+n+1, 1);\n\n        cout << edmonds_karp(graph, m+n, m+n+1) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct Dinic {\n    int n, s, t;\n    vector<int> level, iter, que;\n    vector<vector<Capacity>> cap, flow;\n    vector<vector<int>> g;\n    Capacity inf;\n    Dinic(int n)\n        : n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n          g(n, vector<int>()), inf(numeric_limits<Capacity>::max()/8){}\n    Dinic(const Graph &graph){\n        *this = Dinic(graph.size());\n        rep(i,n) for(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n    }\n    void addEdge(int u, int v, Capacity c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    inline Capacity residue(int u, int v){ return cap[u][v] - flow[u][v]; }\n    Capacity solve(int s, int t){\n        this->t = t, this->s = s;\n        Capacity res = 0, aug = 1;\n        while(aug > 0){\n            levelize();\n            iter.assign(n, 0);\n            res += (aug = augment(s, inf));\n        }\n        return res;\n    }\n    void levelize(){\n        level.assign(n, inf); level[s] = 0;\n        int l = 0, r = 0;\n        que.assign(n+1, 0);\n        que[r++] = s;\n        while(l != r){\n            int v = que[l++];\n            for(const int &d : g[v]){\n                if(level[d] <= level[v] + 1 || residue(v,d) == 0) continue;\n                level[d] = level[v] + 1; que[r++] = d;\n            }\n        }\n    }\n    Capacity augment(int v, Capacity lim){\n        Capacity res = 0;\n        if(v == t) return lim;\n        for(int &i = iter[v]; i < (int)g[v].size(); i++){\n            const int &d = g[v][i];\n            if(residue(v,d) == 0 || level[v] + 1 != level[d]) continue;\n            const Capacity aug = augment(d, min(lim, residue(v,d)));\n            if(aug > 0){\n                flow[v][d] += aug; flow[d][v] -= aug;\n                res += aug; lim -= aug;\n                if(lim == 0) break;\n            }\n        }\n        return res;\n    }\n};\n\nint dp[500][500];\nint gcd(int a, int b){\n    return a < 500 && b < 500 ? dp[a][b] : b == 0 ? a : gcd(b, a%b);\n}\n\n\nint main(){\n    rep(i,500)rep(j,i+1) dp[i][j] = dp[j][i] = __gcd(i,j);\n    fastios();\n    int n,m;\n    while(cin >> n >> m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        Dinic d(n+m+2);\n        int s = n+m, t = n+m+1;\n        rep(i,m) d.addEdge(i+n,t,1);\n        rep(i,n){\n            d.addEdge(s,i,1);\n            rep(j,m) if(gcd(a[i],b[j]) != 1) d.addEdge(i,n+j,1);\n        }\n        rep(i,n)rep(j,m){\n            if(d.flow[i][j+n]) dump(i,j, d.flow[i][j+m]);\n        }\n        cout << d.solve(s,t) << endl;\n    }\n}\n\n// int main(){\n//     int N,M;\n//     cin >> N >> M;\n//     Graph g(N);\n//     rep(i,M){\n//         int a,b,c;\n//         cin >> a >> b >> c;\n//         g[a].emplace_back(a,b,c);\n//     }\n//     Dinic dinic(g);\n//     cout << dinic.solve(0,N-1) << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nconst int MAX = 3000;\nconst int INF = 1e8;\n#define gcd(a,b) __gcd(a,b)\n\nstruct edge{ \n  int to, cap, rev;\n};\n\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to ,cap ,G[to].size()});\n  G[to].push_back((edge){from ,0 ,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0 ; i < G[v].size() ; i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n\n  for(;;){\n    memset(used,false,sizeof(used));\n    int f = dfs(s,t,INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main(){\n  int m,n,b,r;\n  \n  while(cin >> m >> n , m + n){\n    vector<int> B,R;\n    int s = m+n,t = s+1;\n    memset(G,0,sizeof(G));\n    for(int i = 0 ; i < m ; i++){\n      cin >> b;\n      B.push_back(b);\n      add_edge(s,i,1);\n    }\n\n    for(int j = 0 ; j < n ; j++){\n      cin >> r;\n      R.push_back(r);\n      add_edge(m+j,t,1);\n    }\n \n    for(int i = 0 ; i < m ; i++){\n      for(int j = 0 ; j < n ; j++){\n\tif(gcd(B[i],R[j]) != 1){\n\t  add_edge(i,m+j,1);\n\t}\n      }\n    }\n    cout << max_flow(s,t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬╬╬██╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓▓█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n#define INF 1LL<<60\n#define fs first\n#define sc second\n#define pb push_back\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) (a)<=(i) && (i)<(b)\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\ntypedef pair<int,int> P;\n\nconst int MAX_V = 3e5;\nint V;\nvector<int> G[MAX_V],match,used(MAX_V,0);\n\nvoid add_edge(int u, int v){\n  G[u].pb(v);\n  G[v].pb(u);\n}\n\nbool dfs(int v){\n  used[v]++;\n  REP(i,G[v].size()){\n    int u = G[v][i], w = match[u];\n    if(w < 0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n      }\n    }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  match.assign(V,-1);\n  REP(s,V){\n    if(match[s] < 0){\n      used.assign(V,0);\n      if(dfs(s)) res++;\n      }\n    }\n  return res;\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);  \n\n  int n,m;\n  cin >> n >> m;\n\n  while(n && m){\n    V = n+m;\n\n    vector<int> a(n);\n    REP(i,n) cin >> a[i];\n    \n    vector<int> b(m);\n    REP(i,m) cin >> b[i];\n    \n    REP(i,MAX_V) G[i].clear();\n\n    REP(i,n){\n      REP(j,m){\n        if(__gcd(a[i],b[j]) > 1) add_edge(i,n+j);\n      }\n    }\n\n    cout << bipartite_matching() << endl;\n\n    cin >> n >> m;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\nconst int MAX_V=505;\nconst int INF=1<<25;\nstruct edge{int to,cap,rev;};\nvector<edge>G[MAX_V];\nint level[MAX_V],iter[MAX_V];\nint N,M,B[MAX_V],R[MAX_V];\n\nint yuc(int a,int b)\n{\n\tif(a%b==0)return b;\n\treturn yuc(b,a%b);\n}\n\n\nvoid add_edge(int from,int to,int cap)\n{\n\tedge ins={to,cap,G[to].size()};\n\tG[from].push_back(ins);\n\tins.to=from;ins.cap=0;ins.rev=G[from].size()-1;\n\tG[to].push_back(ins);\n}\n\nvoid bfs(int s)\n{\n\tmemset(level,-1,sizeof(level));\n\tqueue<int>Q;\n\tlevel[s]=0;\n\tQ.push(s);\n\twhile(!Q.empty())\n\t{\n\t\tint v=Q.front();Q.pop();\n\t\tfor(int i=0;i<G[v].size();i++)\n\t\t{\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0&&level[e.to]<0)\n\t\t\t{\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tQ.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v,int t,int f)\n{\n\tif(v==t)return f;\n\tfor(int &i=iter[v];i<G[v].size();i++)\n\t{\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0&&level[v]<level[e.to])\n\t\t{\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0)\n\t\t\t{\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t)\n{\n\tint flow=0;\n\tfor(;;)\n\t{\n\t\tbfs(s);\n\t\tif(level[t]<0)return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,INF))>0)\n\t\t\tflow+=f;\n\t}\n}\n\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&M),N+M;)\n\t{\n\t\tfor(int i=0;i<MAX_V;i++)G[i].clear();\n\t\tint s=0,t=N+M+1;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&B[i]);\n\t\t\tadd_edge(s,i+1,1);\n\t\t}\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&R[i]);\n\t\t\tadd_edge(N+i+1,t,1);\n\t\t}\n\t\tfor(int i=0;i<N;i++)\n\t\t\tfor(int j=0;j<M;j++)\n\t\t\t{\n\t\t\t\tif(yuc(max(B[i],R[j]),min(B[i],R[j]))!=1)\n\t\t\t\t\tadd_edge(i+1,j+N+1,1);\n\t\t\t}\n\t\tprintf(\"%d\\n\",max_flow(s,t));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 10000000;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\ntypedef pair<int, int> P;\n\n\n/** Problem1163 : Cards **/\n// 二部マッチング\nconst int MAX_V = 1010;\n\nclass Flow {\npublic:\n\tstruct edge { int to, cap, rev; };\n\tvector<edge> G[MAX_V];\n\tbool used[MAX_V];\n\t\n\tvoid add_edge(int from, int to, int cap) {\n\t\tG[from].push_back((edge){to, cap, (int)G[to].size()});\n\t\tG[to].push_back((edge){from, 0, (int)G[from].size()-1});\n\t}\n\t\n\tint dfs(int v, int t, int f) {\n\t\tif (v==t) return f;\n\t\tused[v] = true;\n\t\tfor (int i=0; i<G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (!used[e.to] && e.cap>0) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d>0) {\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint max_flow(int s, int t) {\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tint f = dfs(s, t, INF);\n\t\t\tif (f==0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n};\n\n// 最大公約数を求める\nint GCD(int a, int b)\n{\n    int temp;\n\t\n    if( a < b ) { temp = a; a = b; b = temp; }\n    if( b < 1 ) return -1;\n\t\n    if( a % b == 0 ) return b;\n    return GCD( b, a % b );\n}\n\nint main()\n{\n\tint m, n;\n\t// 0 ~ m-1 : blue\n\t// m ~ m+n-1 : red\n\t// m+n : s\n\t// m+n+1 : g\n\t\n\twhile (cin>>m>>n, m||n) {\n\t\tvector<int> blue, red;\n\t\tint s=m+n, t=s+1;\n\t\tFlow F;\n\t\t\n\t\trep(i, m) {\n\t\t\tint t; cin>>t;\n\t\t\tblue.push_back(t);\n\t\t}\n\t\t\n\t\trep(i, n) {\n\t\t\tint t; cin>>t;\n\t\t\tred.push_back(t);\n\t\t}\n\t\t\n\t\trep(i, m) {\n\t\t\tF.add_edge(s, i, 1);\n\t\t}\n\t\t\n\t\trep(i, n) {\n\t\t\tF.add_edge(m+i, t, 1);\n\t\t}\n\t\t\n\t\trep(b, m) {\n\t\t\trep(r, n) {\n\t\t\t\tif (GCD(blue[b], red[r])>1) {\n\t\t\t\t\tF.add_edge(b, m+r, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << F.max_flow(s, t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n//Class.\nvector<int> list[100000];\nint N, M, E;\nint match[100000];\nbool used[100000];\nint x[10000], y[10000];\n\nbool DFS(int V) {\n\tused[V] = true;\n\tfor (int i = 0; i < list[V].size(); i++) {\n\t\tint u = list[V][i]; int w = match[u];\n\t\tif (w < 0 || !used[w] && DFS(w)) {\n\t\t\tmatch[V] = u;\n\t\t\tmatch[u] = V;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint supermatching() {\n\tint r = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int j = 0; j < N + M; j++) {\n\t\tif (match[j] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (DFS(j)) { r++; }\n\t\t}\n\t}\n\treturn r;\n}\n\n//main.\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 100000; i++) { list[i].clear(); }\n\t\tcin >> N >> M; if (!N) { break; }\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i];\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> y[i];\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (__gcd(x[i], y[j]) != 1) {\n\t\t\t\t\tlist[i].push_back(j + N);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << supermatching() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n  \n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define SORT(c) sort((c).begin(),(c).end())\n#define IINF INT_MAX\n#define LLINF LLONG_MAX\n  \ntypedef long long ll;\ntypedef pair<int, int> ii;\n \n#define DEBUG false\n \n#define MAX_V 1100\n \nint V;\nvector<vector<int>> G(1100);\nint match[MAX_V];\nbool used[MAX_V];\n \nbool dfs(int v){\n    used[v] = true;\n    rep(i, G[v].size()){\n        int u = G[v][i], w = match[u];\n        if(w < 0 || !used[w] && dfs(w)){\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n \nll solve(){\n    ll ret = 0;\n    memset(match, -1, sizeof(match));\n    rep(v, V){\n        if(match[v] < 0){\n            memset(used, 0, sizeof(used));\n            if(dfs(v)) ret++;\n        }\n    }\n    return ret;\n}\n \nint main(){\n \n    ll n, m;\n    /*\n    vector<int> prime;\n    vector<bool> used(10000001);\n    REP(i, 2, 10000001){\n        if(!used[i]) prime.push_back(i);\n        for(int j = 2; i * j < 10000001; j++) used[i*j] = true;\n    }\n    */\n     \n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n         \n        rep(i, MAX_V) G[i].clear();\n        V = n + m;\n        vector<ll> b(n), r(m);\n        rep(i, n) cin >> b[i];\n        rep(i, m) cin >> r[i];\n         \n        rep(i, n){\n            rep(j, m){\n                if(__gcd(b[i], r[j]) != 1){\n                        G[i].push_back(n+j);\n                        G[n+j].push_back(i);\n                }\n            }\n        }\n     \n        cout << solve() << endl;\n     \n         \n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a[505], b[505];\nint V;\nvector<int> g[1010];\nint match[1010];\nbool used[1010];\n\nvoid add_edge(int u, int v) {\n  g[u].push_back(v);\n  g[v].push_back(u);\n}\n\nbool dfs(int v) {\n  used[v] = true;\n  for(int i=0; i<(int)g[v].size(); ++i) {\n    int u = g[v][i], w = match[u];\n    if(w < 0 || (!used[w] && dfs(w))) {\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching() {\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  for(int v = 0; v < V; ++v) {\n    if(match[v] < 0) {\n      memset(used, 0, sizeof(used));\n      if(dfs(v)) {\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\nint main() {\n  while(true) {\n    int m, n;\n    cin >> m >> n;\n    if(!m && !n) break;\n    for(int i=0; i<m; ++i) cin >> a[i];\n    for(int j=0; j<n; ++j) cin >> b[j];\n\n    V = m+n;\n    for(int i=0; i<V; ++i) g[i].clear();\n    for(int i=0; i<m; ++i) {\n      for(int j=0; j<n; ++j) {\n        if(__gcd(a[i], b[j]) != 1) {\n          add_edge(i, j+m);\n        }\n      }\n    }\n    /*for(int i=0; i<m; ++i) {\n      cout << i << \" \" << a[i] << \":\";\n      for(int j: g[i]) {\n        cout << \"(\" << j << \",\" << b[j-m] << \") \";\n      }\n      cout << endl;\n    }*/\n    cout << bipartite_matching() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n    Author:zeke\n    \n    pass System Test!\n    GET AC!!\n*/\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <stack>\n#include <deque>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <stack>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define rep3(var, min, max) for (ll (var) = (min); (var) < (max); ++(var))\n#define repi3(var, min, max) for (ll (var) = (max) - 1; (var) + 1 > (min); --(var))\n#define Mp(a,b) make_pair((a),(b))\n#define F first\n#define S second\n#define CIN(s) int (s);cin>>(s);\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef vector<V> VV;\ntypedef vector<P> VP;\nll MOD = 1e9 + 7;\nll INF =1e18;\nstruct BipartiteMatching {\n  vector< vector< int > > graph;\n  vector< int > match, alive, used;\n  int timestamp;\n\n  BipartiteMatching(int n) : graph(n), alive(n, 1), used(n, 0), match(n, -1), timestamp(0) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int idx) {\n    used[idx] = timestamp;\n    for(auto &to : graph[idx]) {\n      int to_match = match[to];\n      if(alive[to] == 0) continue;\n      if(to_match == -1 || (used[to_match] != timestamp && dfs(to_match))) {\n        match[idx] = to;\n        match[to] = idx;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    for(int i = 0; i < graph.size(); i++) {\n      if(alive[i] == 0) continue;\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      if(i < match[i]) {\n        cout << i << \"-\" << match[i] << endl;\n      }\n    }\n  }\n};\n//BipartiteMatching(n)　頂点n個\n//add_edge(s,t)\n//bipartite_matching()最大マッチング数\nlong long GCD(long long a,long long b){\n    if(b==0)return a;\n    return GCD(b,a%b);\n}\nlong long LCM(long long a,long long b){\n    return a*b/GCD(a,b);\n}\nint main(){\n  int a,b;\n   while(1){\n        cin>>a>>b;\n        if(a==0&&b==0)break;\n        BipartiteMatching match(a+b+1);\n        V vec(a);\n        V vec1(b);\n        rep(i,a)cin>>vec[i];\n        rep(i,b)cin>>vec1[i];\n        rep(i,a){\n            rep(j,b){\n                if(GCD(vec[i],vec1[j])!=1){\n                    match.add_edge(i,a+j);\n                    //cout<<vec[i]<<\" \"<<vec1[j]<<endl;\n                }\n            }\n        }\n        cout<<match.bipartite_matching()<<endl;\n   }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\ntemplate< typename flow>\nstruct max_flow {\n    struct edge {\n        int to;\n        flow cap;\n        int rev; };\n    int V;\n    vector<vector<edge>> G;\n    vector<int> itr, level;\n\n    max_flow(int V) : V(V) { G.assign(V,vector<edge>()); }\n\n    void add_edge(int from, int to, flow cap) {\n        G[from].push_back((edge) {to, cap, (int) G[to].size()});\n        G[to].push_back((edge) {from, 0, (int) G[from].size()-1});\n    }\n\n    void bfs(int s) {\n        level.assign(V,-1);\n        queue<int> q;\n        level[s] = 0; q.push(s);\n        while (!q.empty()) {\n            int v = q.front(); q.pop();\n            for(auto &e: G[v]){\n                if (e.cap > 0 and level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    flow dfs(int v, int t, flow f) {\n        if (v == t) return f;\n        for (int& i = itr[v]; i < (int) G[v].size(); ++i) {\n            edge& e = G[v][i];\n            if (e.cap > 0 and level[v] < level[e.to]) {\n                flow d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    flow run(int s, int t) {\n        flow ret = 0, f;\n        while (bfs(s), level[t] >= 0) {\n            itr.assign(V,0);\n            while ((f = dfs(s, t, INF)) > 0) ret += f;\n        }\n        return ret;\n    }\n};\n\nint gcd(int a, int b) {\n    if(a < b) swap(a, b);\n    if(a % b == 0) return b;\n    return gcd(b, a % b);\n}\n\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        int n, m;\n        cin >> m >> n;\n        if(n == 0) break;\n        max_flow<int> graph(2001);\n        int a[505], b[505];\n        for(int i = 1; i <= m; i++) {\n            cin >> a[i];\n            graph.add_edge(0, i, 1);\n        }\n        for(int i = 1; i <= n; i++) {\n            cin >> b[i];\n            graph.add_edge(i + 1000, 2000, 1);\n        }\n        for(int i = 1; i <= m; i++) {\n            for(int j = 1; j <= n; j++) {\n                if(gcd(b[j], a[i]) != 1) graph.add_edge(i, j + 1000, 1);\n            }\n        }\n        cout << graph.run(0, 2000) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n#define SET(a,c) memset(a,c,sizeof(a))\n\n#define DEBUG(x) cout<<\"#x\"<<\": \"<<x<<endl\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nconst ll INF = INT_MAX/3;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-14;\nconst int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n\nstruct edge{ int to;int cap;int rev; };\nint m,n;\n\nvector<edge> G[1002];\nbool used[260002];\n\nvoid add_edge(int from,int to){\n    G[from].PB( (edge){to,1,(int)G[to].size()} );\n    G[to].PB( (edge){from,0,(int)G[to].size()-1} );\n}\n\nint dfs(int v,int t,int f){\n    if( v == t) return f;\n    used[v] = true;\n    REP(i,G[v].size()){\n\tedge &e = G[v][i];\n\tif(!used[e.to] && e.cap > 0){\n\t    int d = dfs(e.to,t,min(f,e.cap));\n\t    if(d > 0){\n\t\te.cap -= d;\n\t\tG[e.to][e.rev].cap += d;\n\t\treturn d;\n\t    }\n\t}\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int flow = 0;\n    while(true){\n\tSET(used,false);\n\tint f = dfs(s,t,INF);\n\tif(f == 0)return flow;\n\tflow += f;\n    }\n    return -1;\n}\n\nint gcd(int a,int b){ return a % b == 0 ? b : gcd(b,a%b); }\n\nint main(){\n\n    while(true){\n\tm,n;\n\tcin >> m >> n;\n\tif(m == 0 && n == 0) break;\n\tREP(i,1002) G[i].clear();\n\tSET(used,false);\n\tint a[501],b[501];\n\tREP(i,m) {\n\t    cin >> a[i];\n\t    add_edge(0,i+1);\n\t}\n\tREP(i,n) {\n\t    cin >> b[i];\n\t    add_edge(i+1+m,n+m+1);\n\t}\n\tREP(i,m){\n\t    REP(j,n){\n\t\tif(gcd(a[i],b[j]) > 1){\n\t\t    add_edge(i+1,m+j+1);\n\t\t}\n\t    }\n\t}\n\tcout << max_flow(0,n+m+1) << endl;;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct Dinic {\n    int n, s, t;\n    vector<int> level, iter;\n    vector<vector<Capacity>> cap, flow;\n    vector<vector<int>> g;\n    Capacity inf;\n    Dinic(int n)\n        : n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n          g(n, vector<int>()), inf(numeric_limits<Capacity>::max()/8){}\n    Dinic(const Graph &graph){\n        *this = Dinic(graph.size());\n        rep(i,n) for(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n    }\n    void addEdge(int u, int v, Capacity c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    Capacity residue(int u, int v){\n        return cap[u][v] - flow[u][v];\n    }\n    Capacity solve(int s, int t){\n        this->t = t, this->s = s;\n        Capacity res = 0, aug = 1;\n        while(aug > 0){\n            levelize();\n            iter.assign(n, 0);\n            aug = augment(s, inf);\n            res += aug;\n        }\n        return res;\n    }\n    void levelize(){\n        level.assign(n, inf); level[s] = 0;\n        queue<int> q; q.emplace(s);\n        while(q.size()){\n            int v = q.front(); q.pop();\n            for(const int &d : g[v]){\n                if(level[d] <= level[v] + 1 || residue(v,d) == 0) continue;\n                level[d] = level[v] + 1; q.emplace(d);\n            }\n        }\n    }\n    Capacity augment(int v, Capacity lim){\n        Capacity res = 0;\n        if(v == t) return lim;\n        for(int &i = iter[v]; i < (int)g[v].size(); i++){\n            const int &d = g[v][i];\n            if(residue(v,d) == 0 || level[v] + 1 != level[d]) continue;\n            Capacity aug = augment(d, min(lim, residue(v,d)));\n            if(aug > 0){\n                lim -= aug;\n                flow[v][d] += aug; flow[d][v] -= aug;\n                res += aug;\n                if(lim == 0) return res;\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    fastios();\n    int n,m;\n    while(cin >> n >> m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        Dinic d(n+m+2);\n        int s = n+m, t = n+m+1;\n        rep(i,m) d.addEdge(i+n,t,1);\n        rep(i,n){\n            d.addEdge(s,i,1);\n            rep(j,m) if(__gcd(a[i],b[j]) != 1) d.addEdge(i,n+j,1);\n        }\n        rep(i,n)rep(j,m){\n            if(d.flow[i][j+n]) dump(i,j, d.flow[i][j+m]);\n        }\n        cout << d.solve(s,t) << endl;\n    }\n}\n\n// int main(){\n//     int N,M;\n//     cin >> N >> M;\n//     Graph g(N);\n//     rep(i,M){\n//         int a,b,c;\n//         cin >> a >> b >> c;\n//         g[a].emplace_back(a,b,c);\n//     }\n//     Dinic dinic(g);\n//     cout << dinic.solve(0,N-1) << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int INF = 1e9;\n\nstruct edge{\n  int to, cap, rev;\n  edge(int t, int c, int r){\n    to = t; cap = c; rev = r;\n  }\n};\n\nvoid add_edge(int from, int to, int cap, vector< vector<edge> > &g){\n  g[from].push_back( edge(to,cap,g[to].size()) );\n  g[to].push_back( edge(from,0,g[from].size()-1) );\n}\n\nint dfs(int v,int t, int f, vector< vector<edge> > &g, vector<int> &used){\n  //cout << v << \" \" << f << endl;\n  if(v==t)return f;\n  used[v] = 1;\n  //for(edge &e : g[v]){\n  for(int i=0;i<(int)g[v].size();i++){\n    edge &e = g[v][i];\n    if(!used[e.to] && e.cap>0){\n      int d = min(e.cap, dfs(e.to,t,f,g,used));\n      if(d>0){\n\te.cap -= d;\n\tg[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t, vector< vector<edge> > &g){\n  int flow = 0;\n  while(1){\n    vector<int> used(g.size(),0);\n    int f = dfs(s,t,INF,g,used);\n    //cout << \"---\" << f << \"---\" << endl;\n    if(f==0)return flow;\n    flow += f;\n  }\n}\n\nint gcd(int a,int b){\n  if(!b)return a;\n  return gcd(b,a%b);\n}\n\nint main(){\n  int m,n;\n  while(1){\n    cin >> m >> n;\n    if(!m && !n)break;\n\n    vector<int> b(m),r(n);\n    for(int i=0;i<m;i++)cin >> b[i];\n    for(int i=0;i<n;i++)cin >> r[i];\n\n    vector< vector<edge> > g(n+m+2);\n    for(int i=1;i<=m;i++)add_edge(0,i,1,g);\n    for(int i=m+1;i<=m+n;i++)add_edge(i,m+n+1,1,g);\n\n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n\tif(gcd(b[i],r[j])>1)add_edge(i+1,m+j+1,1,g);\n      }\n    }\n\n    cout << max_flow(0,m+n+1,g) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint m,n;\nint b[510],r[510];\nvector<int> G[1010];\nbool v[1010];\nint f[1010];\n\nbool dfs(int t){\n  v[t] = true;\n  for(int i=0;i<G[t].size();i++){\n    int u = G[t][i], o = f[u];\n    if(o<0 || !v[o] && dfs(o)){\n      f[t] = u;\n      f[u] = t;\n      return true;\n    }\n  }\n}\n\nint bi_matching(void){\n  int res = 0;\n  memset(f,-1,sizeof(f));\n  for(int i=0;i<m+n;i++){\n    if(f[i] < 0){\n      memset(v,0,sizeof(v));\n      if(dfs(i))res++;\n    }\n  }\n  return res;\n}\nint main(){\n  while(cin >> m >> n , m||n){\n    for(int i=0;i<m;i++)cin >> b[i];\n    for(int i=0;i<n;i++)cin >> r[i];\n\n    for(int i=0;i<m+n;i++)G[i].clear();\n \n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n\tif(__gcd(b[i],r[j])>1){\n\t  G[i].push_back(m+j);\n\t  G[m+j].push_back(i);\n\t}\n      }\n    }\n\n    cout << bi_matching() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n#define SET(a,c) memset(a,c,sizeof(a))\n\n#define DEBUG(x) cout<<\"#x\"<<\": \"<<x<<endl\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nconst ll INF = INT_MAX/3;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-14;\nconst int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n\nstruct edge{ int to;int cap;int rev; };\nint m,n;\n\nvector<edge> G[1002];\nbool used[1002];\nint a[501],b[501];\n\nvoid add_edge(int from,int to){\n    G[from].PB( (edge){to,1,(int)G[to].size()} );\n    G[to].PB( (edge){from,0,(int)G[to].size()-1} );\n}\n\nint dfs(int v,int t,int f){\n    if( v == t) return f;\n    used[v] = true;\n    REP(i,G[v].size()){\n\tedge &e = G[v][i];\n\tif(!used[e.to] && e.cap > 0){\n\t    int d = dfs(e.to,t,min(f,e.cap));\n\t    if(d > 0){\n\t\te.cap -= d;\n\t\tG[e.to][e.rev].cap += d;\n\t\treturn d;\n\t    }\n\t}\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int flow = 0;\n    while(true){\n\tSET(used,false);\n\tint f = dfs(s,t,INF);\n\tif(f == 0)return flow;\n\tflow += f;\n    }\n    return -1;\n}\n\nint gcd(int a,int b){ return a % b == 0 ? b : gcd(b,a%b); }\n\nint main(){\n\n    while(true){\n\tm,n;\n\tcin >> m >> n;\n\tif(m == 0 && n == 0) break;\n\tREP(i,1002) G[i].clear();\n\tSET(used,false);\n\tREP(i,m) {\n\t    cin >> a[i];\n\t    add_edge(0,i+1);\n\t}\n\tREP(i,n) {\n\t    cin >> b[i];\n\t    add_edge(i+1+m,n+m+1);\n\t}\n\tREP(i,m){\n\t    REP(j,n){\n\t\tif(gcd(a[i],b[j]) > 1){\n\t\t    add_edge(i+1,m+j+1);\n\t\t}\n\t    }\n\t}\n\tcout << max_flow(0,n+m+1) << endl;;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bipartite_Matching\n{\n  vector< vector< int > > graph;\n  vector< int > match, alive, used;\n  int timestamp;\n\n  Bipartite_Matching(int n)\n  {\n    timestamp = 0;\n    graph.resize(n);\n    alive.assign(n, 1);\n    used.assign(n, 0);\n    match.assign(n, -1);\n  }\n\n  void add_edge(int u, int v)\n  {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int v)\n  {\n    used[v] = timestamp;\n    for(int i = 0; i < graph[v].size(); i++) {\n      int u = graph[v][i], w = match[u];\n      if(alive[u] == 0) continue;\n      if(w == -1 || (used[w] != timestamp && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching()\n  {\n    int ret = 0;\n    for(int i = 0; i < graph.size(); i++) {\n      if(alive[i] == 0) continue;\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return (ret);\n  }\n};\n\nint dp[3000][3000];\n\nint gcd(int x, int y)\n{\n  if(x < 3000) {\n    if(~dp[x][y]) return (dp[x][y]);\n    int r = x % y;\n    if(r == 0) return dp[x][y] = y;\n    return dp[x][y] = gcd(y, r);\n  } else {\n    int r = x % y;\n    if(r == 0) return y;\n    return gcd(y, r);\n  }\n}\n\nint main()\n{\n  memset(dp, -1, sizeof(dp));\n\n  int M, N, B[500], R[500];\n  while(scanf(\"%d %d\", &M, &N), M) {\n    Bipartite_Matching flow(M + N);\n    for(int i = 0; i < M; i++) scanf(\"%d\", &B[i]);\n    for(int i = 0; i < N; i++) scanf(\"%d\", &R[i]);\n    for(int i = 0; i < M; i++) {\n      for(int j = 0; j < N; j++) {\n        if(__gcd(B[i], R[j]) > 1) flow.add_edge(i, j + M);\n      }\n    }\n    printf(\"%d\\n\", flow.bipartite_matching());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> L[2000];int N,M,E,C[2000],x[2000],y[2000];bool U[2000];\nbool DFS(int V){\nU[V]=true;\nfor(int i=0;i<L[V].size();i++){\nint u=L[V][i],w=C[u];\nif(w<0||!U[w]&&DFS(w)){\nC[V]=u;\nC[u]=V;\nreturn 1;\n}\n}\nreturn 0;\n}\nint SM(){\nint r=0;\nmemset(C,-1,8000);\nfor(int j=0;j<N+M;j++){\nif(C[j]<0){\nmemset(U,0,8000);\nif(DFS(j)){r++;}\n}\n}\nreturn r;\n}\nint main(){\nwhile(1){\nfor(int i=0;i<2000;i++){L[i].clear();}\ncin>>N>>M;if(!N){break;}\nfor(int i=0;i<N;i++){\ncin>>x[i];\n}\nfor(int i=0;i<M;i++){\ncin>>y[i];\n}\nfor(int i=0;i<N;i++){\nfor(int j=0;j<M;j++){\nif(__gcd(x[i],y[j])>1){\nL[i].push_back(j+N);\n}\n}\n}\ncout<<SM()<<endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\nint M, N, B[500], R[500], P[500];\nbool C[500][500], V[500];\n\nbool match(int i) {\n\tif (i < 0) return true;\n\tfor (int j = 0; j < N; j++) {\n\t\tif (!C[i][j] || V[j]) continue;\n\t\tV[j] = true;\n\t\tif (match(P[j])) {\n\t\t\tP[j] = i;\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\treturn false;\n\n}\nint main() {\n\twhile (cin >> M >> N && M) {\n\t\tfor (int i = 0; i < M; i++)\n\t\t\tcin >> B[i];\n\t\tfor (int j = 0; j < N; j++)\n\t\t\tcin >> R[j];\n\t\tfill(P, P + M, -1);\n\t\tfor (int i = 0; i < M; i++)\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\tC[i][j] = (__gcd(B[i], R[j]) >= 2);\n\t\tint count = 0;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tfill(V, V + N, false);\n\t\t\tif (match(i)) ++count;\n\n\t\t}\n\t\tcout << count << endl;// count?????????;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <tuple>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e12;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll sq(ll num) { return num*num; }\nll mod_pow(ll x, ll n) {\n\tif (n == 0)return 1;\n\tif (n == 1)return x%MOD;\n\tll res = sq(mod_pow(x, n / 2));\n\tres %= MOD;\n\tif (n % 2 == 1) {\n\t\tres *= x;\n\t\tres %= MOD;\n\t}\n\treturn res;\n}\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll m, n;\nll b[1000], r[1000];\n\nstruct edge { ll to, cap, rev; };\n\nvector<edge> G[2000];\nll level[2000];\t//sからの距離\nll iter[2000];\t//どこまで調べ終わったか\n\nvoid add_edge(ll from, ll to, ll cap) {\n\tG[from].push_back({ to,cap,(ll)G[to].size() });\n\tG[to].push_back({ from,0,(ll)G[from].size() - 1 });\n}\n\nvoid bfs(ll s) {\n\tfill(level, level + 2000, -1);\n\tqueue<ll> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tll v = que.front();\n\t\tque.pop();\n\t\tfor (ll i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nll dfs(ll v, ll t, ll f) {\n\tif (v == t)return f;\n\tfor (ll &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tll d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nll max_flow(ll s, ll t) {\n\tll flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill(iter, iter + 2000, 0);\n\t\tll f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0)return a;\n\treturn gcd(b, a%b);\n}\n\nint main() {\n\twhile (cin >> m >> n&&m + n) {\n\t\trep(i, 2000)G[i].clear();\n\t\trep(i, m) {\n\t\t\tadd_edge(0, i + 1, 1);\n\t\t\tcin >> b[i];\n\t\t}\n\t\trep(i, n) {\n\t\t\tadd_edge(m + 1 + i, m + n + 1, 1);\n\t\t\tcin >> r[i];\n\t\t}\n\t\trep(i, m) {\n\t\t\trep(j, n) {\n\t\t\t\tif (gcd(b[i], r[j]) != 1) {\n\t\t\t\t\tadd_edge(i + 1, m + j + 1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//rep(i, m + n + 2) {\n\t\t//\tcout << \"!\" << i << endl;\n\t\t//\trep(j, G[i].size()) {\n\t\t//\t\tcout << G[i][j].to << \" \" << G[i][j].cap << \" \" << G[i][j].rev << \" \" << endl;\n\t\t//\t}\n\t\t//}\n\t\tcout << max_flow(0, m + n + 1) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, rev;\n};\n\n#define INF 1e9\n\nint iter[1000];\nint level[1000];\nvector< vector<Edge> > G;\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back( (Edge){to, cap, G[to].size()} );\n\tG[to].push_back( (Edge){from, 0, G[from].size()-1} );\n}\nvoid bfs(int s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<int> Q;\n\tlevel[s] = 0;\n\tQ.push(s);\n\twhile ( !Q.empty() ) {\n\t\tint v = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\t\tEdge& e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v]+1;\n\t\t\t\tQ.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v, int t, int f) {\n\tif (v == t) return f;\n\tfor (int &i = iter[v]; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t) {\n\tint flow = 0;\n\twhile (1) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint gcd(int a, int b) {\n\treturn b == 0 ? a : gcd(b, a%b);\n}\n\nint main() {\n\tint M, N;\n\twhile ( cin >> M >> N, M || N ) {\n\t\tvector<int> v1(M), v2(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tcin >> v1[i];\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> v2[i];\n\t\t}\n\t\tint s = M+N, t = M+N+1;\n\t\tG.clear(); G.resize(t+1);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (gcd(v1[i], v2[j]) > 1) {\n\t\t\t\t\tadd_edge(i, M+j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tadd_edge(s, i, 1);\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tadd_edge(M+i, t, 1);\n\t\t}\n\t\tcout << max_flow(s, t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight=1) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  return match;\n}\n\nint main(){\n\tint n,m;\n\twhile( cin >> n >> m and n){\n\t\tGraph g(n+m);\n\t\tint A[510],B[510];\n\t\tfor(int i = 0 ; i < n ; i++) cin >> A[i];\n\t\tfor(int i = 0 ; i < m ; i++) cin >> B[i];\n\t\tfor(int i = 0 ; i < n ; i++)\n\t\t\tfor(int j = 0 ; j < m ; j++)\n\t\t\t\tif( __gcd(A[i],B[j]) != 1 )\n\t\t\t\t\tg[i].push_back(Edge(i,n+j)),\n\t\t\t\t\tg[n+j].push_back(Edge(n+j,i));\n\n\t\tcout << bipartiteMatching(g,n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint V;\nvector<int> G[1200];\nint match[1200];\nbool used[1200];\n\nvoid add_edge(int u, int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n\treturn;\n}\n\nbool dfs(int v){\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; v++){\n\t\tif (match[v] < 0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\n\tint m, n;\n\n\twhile (cin >> m >> n, m, n){\n\t\tvector< set<int> > divisor(m + n);\n\t\tvector<int> mcard, ncard;\n\n\t\tV = m + n;\n\t\tfor (int i = 0; i < m + n; i++){\n\t\t\tG[i].clear();\n\t\t\tmatch[i] = 0;\n\t\t\tused[i] = false;\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint buff; cin >> buff;\n\t\t\tmcard.push_back(buff);\n\t\t\tdivisor[i].insert(buff);\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint buff; cin >> buff;\n\t\t\tncard.push_back(buff);\n\t\t\tdivisor[m + i].insert(buff);\n\t\t}\n\n\t\tfor (int i = 2; i <= 3162; i++){\n\t\t\tint pos = 0;\n\t\t\tfor (vector<int>::iterator it = mcard.begin(); it != mcard.end(); ++it){\n\t\t\t\tif (*it % i == 0){\n\t\t\t\t\tint pos2 = m;\n\t\t\t\t\tfor (vector<int>::iterator it2 = ncard.begin(); it2 != ncard.end(); ++it2){\n\t\t\t\t\t\tif (*it2 % i == 0) {\n\t\t\t\t\t\t\tadd_edge(pos, pos2);\n\t\t\t\t\t\t\t//cout << pos << \"\\t\" << pos2 << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((*it / i != 1) && (*it2 % (*it / i) == 0)){\n\t\t\t\t\t\t\tadd_edge(pos, pos2);\n\t\t\t\t\t\t\t//cout << pos << \"\\t\" << pos2 << endl;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpos2++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor (vector<int>::iterator it = ncard.begin(); it != ncard.end(); ++it){\n\t\t\t\tif (*it % i == 0){\n\t\t\t\t\tdivisor[pos].insert(i);\n\t\t\t\t\tif (*it / i != 1) divisor[pos].insert(*it / i);\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\n\t\tcout << bipartite_matching() << endl;\n\n\n\t}\n\n\treturn 0;\n}\n\n/*\nfor(i=0;i<N;i++){\ncin >> X[i];\n}\n\n\nfor(i=0;i<N;i++){\nfor(j=0;j<N;j++){\ncin >> X[i][j];\n}\n}\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\n//a<b\nlong pgcd(long a,long b){\n  if(a==0)\n    return b;\n  else\n    return pgcd(b%a,a);\n}\n\nlong gcd(long a, long b){\n  return pgcd(min(a,b), max(a,b));\n}\n\nint m,n;//blue,red\nint c[500][500];\nlong b[500], r[500];\nbool v[500];\nint p[500];\n\nbool match(int b){\n  // printf(\"match b:=%d\\n\", b);\n  if(b<0) return true;\n  rep(j,n){\n    if(!c[b][j] || v[j]) continue;\n    // printf(\"v[%d]=true;\\n\",j);\n    v[j]=true;\n    if(match(p[j])) {\n      p[j]=b;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  while(scanf(\"%d %d\", &m, &n),m+n) {\n    rep(i,m) scanf(\" %ld\", b+i);\n    rep(j,n) scanf(\" %ld\", r+j);\n    \n    rep(i,m) rep(j,n) c[i][j]=gcd(b[i],r[j]) > 1 ? 1 : 0;\n    \n    // rep(i,m) {\n    //   rep(j,n) printf(c[i][j] ? \" o\" : \" x\");\n    //   printf(\"\\n\");\n    // }\n    \n    rep(j,n) p[j]=-1;\n    \n    int count=0;\n    rep(i,m){\n      // rep(j,n) printf(\"p[%d]=%d\\n\",j,p[j]);\n      // printf(\"\\n\");\n      rep(j,n) v[j]=false;\n      if(match(i)) count++;\n    }\n    printf(\"%d\\n\",count);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nconst int MAX_V=1000;\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\nint gcd(int a,int b){\n\tif(a>b) swap(a,b);\n\tif(a==0) return b;\n\treturn gcd(b%a,a);\n}\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\nbool dfs(int v){\n\tused[v]=true;\n\trep(i,G[v].size()){\n\t\tint u=G[v][i],w=match[u];\n\t\tif(w<0 || (!used[w] && dfs(w))){\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint nibu(){\n\tint res=0;\n\tmemset(match,-1,sizeof(match));\n\trep(v,V){\n\t\tif(match[v]<0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)) res++;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\twhile(true){\n\t\tint m,n,b[500],r[500];\n\t\tcin>>m>>n;\n\t\tif(m==0) break;\n\t\trep(i,m) cin >> b[i];\n\t\trep(i,n) cin >> r[i];\n\t\tV=m+n;\n\t\trep(i,V) G[i].clear();\n\t\trep(i,m) rep(j,n) if(gcd(b[i],r[j])>1) add_edge(i,j+m);\n\t\tcout << nibu() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator& itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator& begin() {return i;}\n  Iterator& end() {return n;}\n};\n\ntemplate<class T> inline T at(const vector<T> &v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n\ntemplate<class T> inline bool is_max(T &a, const T &b) {return a < b ? a = b, true : false;}\ntemplate<class T> inline bool is_min(T &a, const T &b) {return a > b ? a = b, true : false;}\n\nclass BipMatch {\nprivate:\n  vector<vector<int>> g;\n  vector<int> match;\n  vector<bool> used;\n  \n  bool dfs(int v) {\n    used[v] = true;\n    for (int u : g[v]) {\n      int w = match[u];\n      if (w < 0 || (!used[w] && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n  \npublic:\n  int next() {\n    g.emplace_back(vector<int>());\n    return g.size() - 1;\n  }\n  \n  void add_edge(int u, int v) {\n    g[u].emplace_back(v);\n    g[v].emplace_back(u);\n  }\n  \n  int run() {\n    match = vector<int>(g.size(), 0);\n    used = vector<bool>(g.size(), false);\n    int res = 0;\n    fill(match.begin(), match.end(), -1);\n    for (int i : range(g.size())) if (match[i] < 0) {\n      fill(used.begin(), used.end(), 0);\n      if (dfs(i)) res++;\n    }\n    return res;\n  }\n};\n\nint main() {\n  while (true) {\n    int m, n;\n    cin >> m >> n;\n    if (m == 0 && n == 0) break;\n    int b[m], r[n];\n    for (int i : range(m)) cin >> b[i];\n    for (int i : range(n)) cin >> r[i];\n    BipMatch bm;\n    int bi[m], ri[n];\n    for (int i : range(m)) bi[i] = bm.next();\n    for (int i : range(n)) ri[i] = bm.next();\n    for (int i : range(m)) for (int j : range(n)) if (__gcd(b[i], r[j]) > 1) bm.add_edge(bi[i], ri[j]);\n    cout << bm.run() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// ?¢?????????????DFS??§??¢???\nbool dfs(int v, vector<vector<int> >& G, vector<int>& match, vector<bool>& used){\n  // ??????????????¨???????????????\n  used[v] = true;\n  for(size_t i = 0; i < G[v].size(); i++){\n    int u = G[v][i];\n    int w = match[u];\n    // w?????????????????¨????????? or (w???????????¨ && ?????????????°´??????????????´???)\n    if(w < 0 || (!used[w] && dfs(w, G, match, used))){\n      // v??¨u??????????????????\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\n// ?????¨??°??????????????§??????????????°????±???????\n// ?????????: (??????????????°??°, ??????????????°?????????)\npair<int, vector<int> > BipartiteMatching(vector<vector<int> >& G){\n  int V = G.size();\n  int res = 0;\n  vector<int> match(V, -1);\n  // ?????????????????????\n  for(int v = 0; v < V; v++){\n    // v???????????????????????£???????????????????????°??§??????????????? \n    if(match[v] < 0){\n      vector<bool> used(V, false);\n      if(dfs(v, G, match, used)){ res++; }\n    }\n  }\n  return make_pair(res, match);\n}\n\n\nint gcd(int a, int b){\n  if(b == 0){ return a; }\n  return gcd(b, a % b);\n}\n\n\nint main(void){\n  while(true){\n    int m, n;\n    cin >> m >> n;\n    if(m == 0 && n == 0){ break; }\n    vector<int> b(m), r(n);\n    for(int i = 0; i < m; i++){ cin >> b[i]; }\n    for(int i = 0; i < n; i++){ cin >> r[i]; }\n\n    vector<vector<int> > adjlist(m + n);\n    for(int i = 0; i < m; i++){\n      for(int j = 0; j < n; j++){\n        if(gcd(b[i], r[j]) > 1){\n          adjlist[i].push_back(m + j);\n          adjlist[m + j].push_back(i);\n        }        \n      }\n    }\n\n    int result = BipartiteMatching(adjlist).first;\n    cout << result << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<cstring>\n#include<queue>\n#include<functional>\n#include<cstdio>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define MaxCards 1000\nusing namespace std;\nint\tb, r, V;\nint blue[MaxCards], red[MaxCards];\nvector<int> G[MaxCards];\nint match[MaxCards]; // マッチングのペア\nbool used[MaxCards]; // DFSですでに調べたかのフラグ\n\n\n// uからvを結ぶ辺をグラフに追加する\nvoid add_edge(int u, int v) {\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\n// 増加パスをDFSで探す\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i<G[v].size(); i++) {\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// 二部グラフの最大マッチングを求める\nint bipartite_matching() {\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; v++) {\n\t\tif (match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nint gcd(int n1, int n2){\n\tif (n1%n2 == 0) return n2;\n\treturn gcd(n2, n1%n2);\n}\nint main(){\n\twhile (true){\n\t\tmemset(blue, 0, sizeof(blue));\n\t\tmemset(red, 0, sizeof(red));\n\t\tfor (int i = 0; i<MaxCards; i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tcin >> b >> r;\n\t\tV = b + r;\n\t\tif (b == 0)\n\t\t\tbreak;\n\t\tint idx = 0;\n\t\tfor (int i = 0; i<b; i++){\n\t\t\tcin >> blue[i];\n\t\t}\n\t\tfor (int i = 0; i<r; i++){\n\t\t\tcin >> red[i];\n\t\t}\n\t\tfor (int i = 0; i<b; i++){\n\t\t\tfor (int j = 0; j<r; j++){\n\t\t\t\tif (blue[i]>red[j]){\n\t\t\t\t\tif (gcd(blue[i], red[j]) != 1){\n\t\t\t\t\t\tadd_edge(i, b + j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (gcd(red[j], blue[i]) != 1){\n\t\t\t\t\tadd_edge(i, b + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 4444\nvector<int> v[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int a,int b){\n\tv[a].PB(b);\n\tv[b].PB(a);\n}\n\nbool matchdfs(int a){\n\tused[a] = true;\n\tfor(int i = 0;i < v[a].size();i++)\t{\n\t\tint u = v[a][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w)){\n\t\t\tmatch[u] = a;\n\t\t\tmatch[a] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//二部マッチング\nint two_matching_max(int l){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<int> prime;\n#define HOGE 111111\nbool isp[HOGE];\nvoid f(){\n\tREP(i,HOGE)isp[i] = true;\n\tisp[0] = isp[1] = false;\n\tfor(int i = 2;i < HOGE;i++){\n\t\tif(isp[i]){\n\t\t\tprime.PB(i);\n\t\t\tfor(int j = i;j < HOGE;j+=i)isp[j] = false;\n\t\t}\n\t}\n}\n\t\n#define HALF 1000\nint main(){\n\tf();\n\tint n,m;\n\twhile(cin >> m >> n,n|m){\n\t\tREP(i,MAX_V)v[i].clear();\n\t\tvector<ll> a(m);REP(i,m)cin >> a[i];\n\t\tvector<ll> b(n);REP(i,n)cin >> b[i];\n\t\tREP(i,m){\n\t\t\tvector<ll> tmp;\n\t\t\tREP(j,prime.size()){\n\t\t\t\tif(a[i] % prime[j] == 0)tmp.PB(prime[j]);\n\t\t\t}\n\t\t\tREP(j,n){\n\t\t\t\tREP(k,tmp.size()){\n\t\t\t\t\tif(b[j] % tmp[k] == 0){\n\t\t\t\t\t\tadd_edge(i,j + 1000);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << two_matching_max(MAX_V) << endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#define REP(i,n) for (int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int MAX_V = 1010;\nstruct edge{ int to,cap,rev;edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}};\n\nvector<vector<edge> > G(MAX_V); //??°???????????£??\\???????????¨???\nbool used[MAX_V]; //DFS??§??¢???????????????????????????????????°\n\nvoid init(int n){\n\tfor(int i = 0;i < n;i++)G[i].clear();\n}\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back(edge(to,cap,G[to].size()));\n\tG[to].push_back(edge(from,0,G[from].size() - 1));\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif( !used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -=d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tfill(used,used + MAX_V,false);\n\t\tint f = dfs(s,t,INF);\n\t\tif(f == 0)return flow;\n\t\tflow += f;\n\t}\n}\n\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\tint m,n;\n\twhile(cin >> m >> n,m){\n\t\tint s = m + n,t = s + 1;\n\t\tinit(t);\n\t\tvector<int> b(m),r(n);\n\t\tREP(i,m){\n\t\t\tcin >> b[i];\n\t\t\tadd_edge(s,i,1);//????????§????§??????????????????¶\n\t\t}\n\t\tREP(i,n){\n\t\t\tcin >> r[i];\n\t\t\tadd_edge(i + m,t,1);//????????§???????????????????????¶\n\t\t}\n\t\tREP(i,m){\n\t\t\tREP(j,n){\n\t\t\t\tif(__gcd(b[i],r[j]) != 1){\n\t\t\t\t\tadd_edge(i,j + m,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << max_flow(s,t) << endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000000;\n\nclass MaxFlow {\n\tstruct edge {\n\t\tint to, cap, rev;\n\t\tedge(int to_, int cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {};\n\t};\n\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> level;\n\tvector<int> iter;\n\n\tvoid BFS(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (size_t i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint DFS(int v, int t, int f) {\n\t\tif (v == t) return f;\n\t\tfor (int &i = iter[v]; i < (int)G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = DFS(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\npublic:\n\tMaxFlow(int _V) : V(_V), G(_V), level(_V), iter(_V) {}\n\tvoid add(int from, int to, int cap) {\n\t\tG[from].push_back(edge(to, cap, G[to].size()));\n\t\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n\t}\n\tint Dinic(int s, int t) {\n\t\tint flow = 0;\n\t\twhile (true) {\n\t\t\tBFS(s);\n\t\t\tif (level[t] < 0) return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = DFS(s, t, INF)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main()\n{\n\tint m, n;\n\twhile (cin >> m >> n, m | n) {\n\t\tvector<int> b(m), r(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> b[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> r[i];\n\t\t}\n\t\tMaxFlow mf(m + n + 2);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tmf.add(m + n, i, 1);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmf.add(m + i, m + n + 1, 1);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (__gcd(b[i], r[j]) > 1) {\n\t\t\t\t\tmf.add(i, m + j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mf.Dinic(m + n, m + n + 1) << '\\n';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<n; ++i)\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\nusing namespace std;\nusing ll = int64_t;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vs = vector<string>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQG = priority_queue<T, vector<T>, greater<T> >;\nconst int INF = 100010001;\nconst ll LINF = (ll)INF*INF*10;\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) {return a < b && (a = b, true);}\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) {return a > b && (a = b, true);}\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second;}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << ' ' << p.second;}\n\nstruct BM {\n  int V;\n  vector<vector<int > > G;\n  vector<int> match;\n  vector<bool> used;\n  BM(int n=0) : V(n), G(n), match(n, -1), used(n) {}\n  inline void add(int u, int v) {\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n  bool dfs(int v) {\n    used[v] = true;\n    for(int u:G[v]) {\n      int w = match[u];\n      if(w < 0 or (!used[w] and dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n  int bipartite_matching() {\n    int res = 0;\n    rep(v, V) {\n      if(match[v] < 0) {\n        rep(i, v) used[i] = 0;\n        if(dfs(v)) res++;\n      }\n    }\n    return res;\n  }\n};\n\nint64_t gcd(int64_t a, int64_t b) {return b?gcd(b, a%b):a;}\nint64_t lcm(int64_t a, int64_t b) {return a/gcd(a,b)*b;}\nint64_t extgcd(int64_t a, int64_t b, int64_t &x, int64_t &y) { // ax+by=gcd(a, b)の解を与える\n  int64_t d = a;\n  if(b) {\n    d = extgcd(b, a%b, y, x);\n    y -= (a/b)*x;\n  } else {\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nconst int N = 500;\n\n//head\n\nint m, n;\nint b[N], r[N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> m >> n;\n  while(m) {\n    BM bpm(n+m);\n    rep(i, m) cin >> b[i];\n    rep(i, n) cin >> r[i];\n    rep(i, m) rep(j, n) {\n      if(gcd(b[i], r[j]) != 1) {\n        bpm.add(i, j+m);\n      }\n    }\n    cout << bpm.bipartite_matching() << '\\n';\n    cin >> m >> n;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nvector<int> blue,red,redpair,v;\nvector<vector<int> >c;\n/*blue[i]??§i?????????????????????????????°???,red[i]??§i?????????????????????????????°???,redpair[i]??§i??????????????????????????¨?????¢????????????????????????????????????????????????,v[i]??§i??????????????????????????????????????????????????????(1:?????????0:??????)\nc[i][j]??§blue[i]??¨red[j]????????¢?????§???????????¨???*/\nint m=0,n=0;\n\nint gcd(int x,int y){\n\tif(x%y==0){return y;}\n\treturn gcd(y,x%y);\n}\n\nbool match(int x){\n\tif(x==-1)return 1;\n\tfor(int i=0;i<n;i++){\n\t\tif(c[x][i]==1 && v[i]==0){\n\t\t\tv[i]=1;\n\t\t\tif(match(redpair[i])){\n\t\t\t\tredpair[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(cin>>m>>n){\n\t\tif(m==0 && n==0){break;}\n\t\tblue.clear();\n\t\tred.clear();\n\t\tredpair.clear();\n\t\tv.clear();\n\t\tc.clear();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint tmp=0;\n\t\t\tcin>>tmp;\n\t\t\tblue.push_back(tmp);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmp=0;\n\t\t\tcin>>tmp;\n\t\t\tred.push_back(tmp);\n\t\t\tredpair.push_back(-1);//-1??§?????¢??????????????¶????????¨???\n\t\t\tv.push_back(0);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tc.push_back(vector<int>());\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tc[i].push_back(gcd(blue[i],red[j])!=1);\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tv[j]=0;\n\t\t\t}\n\t\t\tif(match(i)){ans++;}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nstruct edge { int to, cap, rev; };\nvector<edge> G[300000];\nbool used[300000];\nvoid init(int V) {\n\trep(i, V) {\n\t\tG[i].clear();\n\t}\n}\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size() });\n\tG[to].push_back(edge{ from, 0, (int)G[from].size() - 1 });\n}\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, (int)MOD);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n}\nint gcd(int x, int y) {\n\tif (x < y)swap(x, y);\n\twhile (y > 0) {\n\t\tint r = x % y; x = y; y = r;\n\t}\n\treturn x;\n}\nint main() {\n\tint m; int n;\n\twhile (cin >> m >> n, m) {\n\t\tinit(300000);\n\t\tint a[501], b[501];\n\t\trep1(i, m) {\n\t\t\tcin >> a[i];\n\t\t\tadd_edge(0, i, 1);\n\t\t}\n\t\trep1(i, n) {\n\t\t\tcin >> b[i];\n\t\t\tadd_edge(i + m, 1 + m + n, 1);\n\t\t}\n\t\trep1(i, m) {\n\t\t\trep1(j, n) {\n\t\t\t\tif (gcd(a[i], b[j]) > 1) {\n\t\t\t\t\tadd_edge(i, m + j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << max_flow(0, 1 + m + n) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <map>\n#include <ctime>\n#include <cstdlib>\n#include <cstdio>\n \nusing namespace std;\n \ntypedef pair<int, int> P;\ntypedef vector<double> array;\ntypedef vector<array> matrix;\nconst double EPS = 1e-8;\n\nint gcd(int a, int b){ return (b == 0 ? a : gcd(b, a%b)); }\n\n \nint rank(matrix &A){\n\tint n = A.size();\n  int res = 0;\n\tmatrix B(n, array(n+1,1));\n  for(int i=0;i<n;i++) for(int j=0;j<n;j++) B[i][j] = A[i][j];\n    \n  for(int i=0;i<n;i++){\n    int pivot = i;\n    for(int j=i;j<n;j++){\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n    }\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i]) > EPS) res++;\n    if(abs(B[i][i]) > EPS){\n      for(int j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n      for(int j=0;j<n;j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tfor(int k=i+1;k<=n;k++) B[j][k] -= B[j][i] * B[i][k];\n\t\t\t\t}\n      }\n    }\n  }\n  return res;\n}\n\n\n/*\nint rank(matrix A) {\n  const int n = A.size(), m = A[0].size();\n  int r = 0;\n  for (int i = 0; r < n && i < m; ++i) {\n    int pivot = r;\n    for (int j = r+1; j < n; ++j)\n      if (abs(A[j][i]) > abs(A[pivot][i])) pivot = j;\n    swap(A[pivot], A[r]);\n    if (abs(A[r][i]) < EPS) continue;\n    for (int k = m-1; k >= i; --k)\n      A[r][k] /= A[r][i];\n    for(int j = r+1; j < n; ++j)\n      for(int k = i; k < m; ++k)\n        A[j][k] -= A[r][k] * A[j][i];\n    ++r;\n  }\n  return r;\n}\n*/\n\nint main(){\n\tsrand((unsigned)time(NULL));\n\tint n, m;\n\twhile(1){\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(n == 0 && m == 0) break;\n\t\tvector<int> A(n), B(m);\n\t\tfor(int i=0;i<n;i++) scanf(\"%d\", &A[i]);\n\t\tfor(int i=0;i<m;i++) scanf(\"%d\", &B[i]);\n\t\tvector<P> edge;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(gcd(A[i], B[j]) > 1){\n\t\t\t\t\tedge.push_back(make_pair(i, n + j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int k=0;k<1;k++){\n\t\t\tmatrix mat(n+m, array(n+m, 0));\n\t\t\tfor(int i=0;i<edge.size();i++){\n\t\t\t\tint a = edge[i].first, b = edge[i].second;\n\t\t\t\tint tmp = rand();\n\t\t\t\tmat[a][b] = tmp;\n\t\t\t\tmat[b][a] = -tmp;\n\t\t\t}\n\t\t\tans = max(ans, rank(mat) / 2);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\nusing ll = long long;\n\n/**\n * ?????¨?????§??????????????°\n *\n * O(EV)\n */\ntemplate<int V>\nstruct BitMatching {\n    vector<int> G[2*V];\n    int match[2*V];\n    bool used[2*V];\n    /// ?????????\n    void init() {\n        for (int i = 0; i < 2*V; i++) {\n            G[i].clear();\n        }\n    }\n    /// ?????´???a????????¨?????´???b?????????????????????\n    void add(int a, int b) {\n        G[a].push_back(b+V);\n        G[b+V].push_back(a);\n    }\n\n    bool dfs(int v) {\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            int u = G[v][i], w = match[u];\n            if (w < 0 || (!used[w] && dfs(w))) {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n    /// ?????§??????????????°?????¬??°???????????????\n    int exec() {\n        int res = 0;\n        memset(match, -1, sizeof(match));\n        for (int v = 0; v < V; v++) {\n            if (match[v] < 0) {\n                memset(used, 0, sizeof(used));\n                if (dfs(v)) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n};\n\nconst int MN = 520;\nBitMatching<MN> bm;\nll gcd(ll a, ll b) {\n    if (b == 0) return a;\n    return gcd(b, a%b);\n}\nint main() {\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (!n) break;\n        bm.init();\n        int a[n], b[m];\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        for (int i = 0; i < m; i++) {\n            cin >> b[i];\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (gcd(a[i], b[j]) != 1) {\n                    bm.add(i, j);\n                }\n            }\n        }\n        cout << bm.exec() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <cstdio>\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n#define REV(s) (s).rbegin(), (s).rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\n// FordFulkerson:Verified: POJ 1274\n// Dinic:Verified: POJ 1274, 3469\n\nclass Flow{\n\tstruct edge{\n\t\tint to, rev, cap, cost;\n\t\tedge(){}\n\t\tedge(int to, int rev, int cap, int cost) :to(to), rev(rev), cap(cap), cost(cost){}\n\t};\n\tvector<vector<edge> > Graph;\n\tvector<int> used, level, iter;\n\tint V;\n\tstatic const int INF = 1 << 30;\npublic:\n\tFlow(int size) :V(size){\n\t\tGraph.resize(V);\n\t\titer.resize(V, 0);\n\t\tlevel.resize(V);\n\t\tused.resize(V, 0);\n\t}\n\tvoid add(int from, int to, int cap, int cost = 0){\n\t\tGraph[from].push_back(edge(to, Graph[to].size(), cap, cost));\n\t\tGraph[to].push_back(edge(from, Graph[from].size() - 1, 0, -cost));\n\t}\n\n\t/* ford_fulkerson */\n\tint dfs(int s, int t, int f){\n\t\tif (s == t) return f;\n\t\tused[s] = 1;\n\t\tfor (int i = 0; i < Graph[s].size(); i++){\n\t\t\tedge &e = Graph[s][i];\n\t\t\tif (used[e.to] || e.cap <= 0) continue;\n\t\t\tint res = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (res > 0){\n\t\t\t\te.cap -= res;\n\t\t\t\tGraph[e.to][e.rev].cap += res;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint ford_fulkerson(int s, int t){\n\t\tint res = 0;\n\t\twhile (1){\n\t\t\tfill(used.begin(), used.end(), 0);\n\t\t\tint f = dfs(s, t, INF);\n\t\t\tif (!f) break;\n\t\t\tres += f;\n\t\t}\n\t\treturn res;\n\t}\n\n\t/* Dinic */\n\tvoid dinic_bfs(int s){\n\t\tfill(level.begin(), level.end(), -1);\n\n\t\tqueue<int> q;\n\t\tq.push(s);\n\t\tlevel[s] = 0;\n\t\twhile (!q.empty()){\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (int i = 0; i < Graph[v].size(); i++){\n\t\t\t\tedge &e = Graph[v][i];\n\t\t\t\tif (e.cap <= 0 || level[e.to] >= 0) continue;\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\n\tint dinic_dfs(int s, int t, int f){\n\t\tif (s == t) return f;\n\t\tfor (int &i = iter[s]; i < Graph[s].size(); i++){\n\t\t\tedge &e = Graph[s][i];\n\t\t\tif (e.cap <= 0 || level[e.to] <= level[s]) continue;\n\t\t\tint res = dinic_dfs(e.to, t, min(f, e.cap));\n\t\t\tif (res > 0){\n\t\t\t\te.cap -= res;\n\t\t\t\tGraph[e.to][e.rev].cap += res;\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint dinic(int s, int t){\n\t\tint res = 0;\n\t\twhile (1){\n\t\t\tdinic_bfs(s);\n\t\t\tif (level[t] < 0) break;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile (f = dinic_dfs(s, t, INF)){\n\t\t\t\tres += f;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint max_flow(int s, int t, bool DINIC = true){\n\t\tif (DINIC) return dinic(s, t);\n\t\treturn ford_fulkerson(s, t);\n\t}\n};\n\nll gcd(ll m, ll n){\n\treturn n ? gcd(n, m%n) : m;\n}\n\nint main(){\n\tint m, n;\n\twhile (cin >> m >> n, m | n){\n\t\tFlow f(m + n + 2);\n\t\tconst int SRC = m + n, SNK = SRC + 1;\n\n\t\tvector<int> a(m), b(n);\n\t\trep(i, m){\n\t\t\tcin >> a[i];\n\t\t\tf.add(SRC, i, 1);\n\t\t}\n\t\trep(j, n){\n\t\t\tcin >> b[j];\n\t\t\tf.add(m + j, SNK, 1);\n\t\t}\n\n\t\trep(i, m) rep(j, n){\n\t\t\tif (gcd(a[i], b[j]) != 1) f.add(i, m + j, 1);\n\t\t}\n\t\t//cout << \"***\";\n\t\tcout << f.max_flow(SRC, SNK) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 10000\nusing namespace std;\n\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i=0; i<G[v].size(); i++){\n    int u = G[v][i], w = match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint Bipartite_Matching(){\n  int res=0;\n  memset(match, -1, sizeof(match));\n  for(int v=0; v<V; v++){\n    if(match[v] < 0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)) res++;\n    }\n  }\n  return res;\n}\n\n\nint main(){\n  int n,m,b[500],r[500];\n  while(cin>>m>>n,m){\n    for(int i=0;i<V;i++)G[i].clear();\n    for(int i=0;i<m;i++)cin>>b[i];\n    for(int i=0;i<n;i++)cin>>r[i];\n    for(int i=0;i<m;i++)\n      for(int j=0;j<n;j++)\n\tif(__gcd(b[i],r[j])!=1)add_edge(i,m+j);\n    V=n+m;\n    cout <<Bipartite_Matching()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 1000000\n#define INF 1e9\n\nint gcd(int a, int b){\n\n    if(b == 0) return a;\n    else return gcd(b, (a % b));\n}\n\n//辺を表す構造体　(行先、容量、逆辺の場所)\nstruct edge{\n    int to, cap, rev;\n};\n\nvector<vector<edge> > G(MAX_V);       //グラフの隣接リスト表現\nbool used[MAX_V];                    //DFSですでに調べたかのグラフ\n\n\n// from から to へ向かう容量 cap の辺をグラフに張る\nvoid add_edge(int from, int to, int cap){\n\n    edge F;\n    edge T;\n    F.to = to;\n    F.cap = cap;\n    F.rev = G[to].size();\n    G[from].push_back(F);\n\n    T.to = from;\n    T.cap = 0;\n    T.rev = G[from].size() - 1;\n    G[to].push_back(T);    \n}\n\n//増加パスをDFSで探す\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        edge &e = G[v][i];                          //すごい\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;            //もっとすごい\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n//s から t への最大流を求める\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(){\n    \n    while(1){\n        int m, n; cin >> m >> n;\n        if(!m) break;\n        vector<int> b(m);\n        vector<int> r(n);\n        for(int i = 0; i < m; i++) cin >> b[i];\n        for(int i = 0; i < n; i++) cin >> r[i];\n\n        //入力\n        //xはuに属する\n        //yはvに属する\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(gcd(b[i], r[j]) != 1){\n                    int x = i + 1;\n                    int y = j + 1;\n                    y += m;\n                    add_edge(x, y, 1);\n                }\n            }\n        }\n\n        for(int i = 1; i <= m; i++) add_edge(0, i, 1);\n        for(int i = m + 1; i <= m + n; i++) add_edge(i, m + n + 1, 1);\n        \n        cout << max_flow(0, m + n + 1) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define REPD(i,n) for(int i=(int)(n); i-->0;)\n#define REPI(i,a,b) for(int i=(int)(a); i<=(int)(b); i++)\n#define ALL(a) (a).begin(),(a).end()\n#define mp make_pair\n#define fst first\n#define snd second\n\n#define INFTY 1000000000\n#define EPS 1e-9\n#define PI 3.141592653589793\n\n#define INF (INFTY/3)\n\n#define rev(s) (string((s).rbegin(), (s).rend()))\n\ntypedef long long Int;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<double,double> pdd;\n\nvoid debug(vi v){ REP(i,v.size()) cout<<v[i]<<\" \"; cout<<endl; }\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\nEdge(int src, int dst) : src(src),dst(dst) {}\nEdge(int src, int dst, Weight weight) :\n  src(src), dst(dst), weight(weight) {}\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vec<Edge> Edges;\ntypedef vec<Edges> Graph;\n\ntypedef vec<Weight> Array;\ntypedef vec<Array> Matrix;\n#define MAXMN 500\n#define Int long long\nint B[MAXMN];\nint R[MAXMN];\n\nInt gcd(Int a, Int b)\n{   \n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\n\n\nmain() {\n  int M,N;\n  Graph g;\n  while(cin>>M>>N,M) {\n    g.clear();\n    g.resize(M+N+2);\n    REP(i,M) cin>>B[i];\n    REP(i,N) cin>>R[i];\n    REP(i,M) {\n      Edges es, es2;\n      REP(j,N) {\n\tif(gcd(B[i],R[j])!=1) { es.pb(Edge(i,M+j)); es2.pb(Edge(M+j,i)); }\n      }\n      g[i] = es;\n      g[M+i] = es2;\n    }\n    Edges matching;\n    cout << bipartiteMatching(g,M,matching) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\n\nstruct Edge {\n\tint src, dst, flow, rev;\n\tEdge() { }\n\tEdge(int src, int dst, int flow, int rev) {\n\t\tthis->src = src;\n\t\tthis->dst = dst;\n\t\tthis->flow = flow;\n\t\tthis->rev = rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int s, int t, int flow) {\n\tg[s].push_back(Edge(s, t, flow, g[t].size()));\n\tg[t].push_back(Edge(t, s, 0, g[s].size() - 1));\n}\n\nint dfs(Graph &g, int s, int t, vector<int> &level, vector<int> &iter, int f) {\n\tif (s == t) return f;\n\t\n\tfor (int &i = iter[s]; i < g[s].size(); i++) {\n\t\tEdge e = g[s][i];\n\t\tif (e.flow <= 0) continue;\n\t\tif (level[e.dst] != level[s] + 1) continue;\n\t\t\n\t\tint res = dfs(g, e.dst, t, level, iter, min(f, e.flow));\n\t\tif (res == 0) continue;\n\t\t\n\t\t//s -> e.dst\n\t\tg[s][i].flow -= res;\n\t\tg[e.dst][g[s][i].rev].flow += res;\n\t\treturn res;\n\t}\n\treturn 0;\n}\n\nint maxflow(Graph g, int s, int t) {\n\tint n = g.size();\n\tvector<int> level(n);\n\t\n\tint ret = 0;\n\twhile (true) {\n\t\tint i;\n\t\trep(i, n) level[i] = -1;\n\t\t\n\t\tqueue<int> que;\n\t\tque.push(s);\n\t\tlevel[s] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\trep(i, g[v].size()) {\n\t\t\t\tEdge e = g[v][i];\n\t\t\t\tif (e.flow <= 0) continue;\n\t\t\t\tif (level[e.dst] == -1) {\n\t\t\t\t\tlevel[e.dst] = level[v] + 1;\n\t\t\t\t\tque.push(e.dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (level[t] == -1) break;\n\t\t\n\t\tvector<int> iter(n, 0);\n\t\twhile (true) {\n\t\t\tint flow = dfs(g, s, t, level, iter, 1e+8);\n\t\t\tif (flow == 0) break;\n\t\t\tret += flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint m, n;\nint b[500];\nint r[500];\n\nint main() {\n\twhile (cin >> m >> n) {\n\t\tif (!m) break;\n\t\tint i, j;\n\t\trep(i, m) cin >> b[i];\n\t\trep(i, n) cin >> r[i];\n\t\t\n\t\tGraph g;\n\t\t\n\t\tg.resize(m + n + 2);\n\t\trep(i, m) add_edge(g, 0, i + 1, 1);\n\t\trep(i, m) {\n\t\t\trep(j, n) {\n\t\t\t\tif (gcd(b[i], r[j]) > 1) {\n\t\t\t\t\tadd_edge(g, i + 1, m + 1 + j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, n) {\n\t\t\tadd_edge(g, m + 1 + i, m + 1 + n, 1);\n\t\t}\n\t\t\n\t\tint res = maxflow(g, 0, m + n + 1);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _USE_MATH_DEFINES\nusing namespace std;\n \n \n#define li\t\t\tlong long int\n#define rep(i,to)\tfor(li i=0;i<((li)(to));i++)\n#define repp(i,start,to)\tfor(li i=(li)(start);i<((li)(to));i++)\n#define pb\t\t\tpush_back\n#define sz(v)\t\t((li)(v).size())\n#define bgn(v)\t\t((v).begin())\n#define eend(v)\t\t((v).end())\n#define allof(v)\t(v).begin(), (v).end()\n#define dodp(v,n)\t\tmemset(v,(li)n,sizeof(v))\n#define bit(n)\t\t(1ll<<(li)(n))\n#define mp(a,b)\t\tmake_pair(a,b)\n#define rin\trep(i,n)\n#define rjm\trep(j,m)\n#define VV\t\t\tvector\n\n\n#define DBGP 1\n\n\n#define idp if(DBGP)\n#define F first\n#define S second\n#define p2(a,b)\t\tidp cout<<a<<\"\\t\"<<b<<endl\n#define p3(a,b,c)\t\tidp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<endl\n#define p4(a,b,c,d)\t\tidp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<endl\n#define p5(a,b,c,d,e)\t\tidp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<endl\n#define p6(a,b,c,d,e,f)\t\tidp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<endl\n#define p7(a,b,c,d,e,f,g)\t\tidp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<\"\\t\"<<g<<endl\n#define p8(a,b,c,d,e,f,g,h)\t\tidp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<\"\\t\"<<g<<\"\\t\"<<h<<endl\n#define p9(a,b,c,d,e,f,g,h,i)\t\tidp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<\"\\t\"<<g<<\"\\t\"<<h<<\"\\t\"<<i<<endl\n#define p10(a,b,c,d,e,f,g,h,i,j)\t\tidp cout<<a<<\"\\t\"<<b<<\"\\t\"<<c<<\"\\t\"<<d<<\"\\t\"<<e<<\"\\t\"<<f<<\"\\t\"<<g<<\"\\t\"<<h<<\"\\t\"<<i<<\"\\t\"<<j<<endl\n#define foreach(it,v)\tfor(__typeof((v).begin()) it=(v).begin(); it!=(v).end(); ++it)\n#define p2p(x)\t\tidp p2((x).F, (x).S)\n#define dump(x,n)\tidp{rep(i,n){cout<<x[i]<<\" \";}puts(\"\");}\n#define dump2(x,n)\tidp{rep(i,n){cout<<\"[\"<<x[i].F<<\" , \"<<x[i].S<<\"] \";}puts(\"\");}\n#define dumpi(x)\tidp{foreach(it, x){cout<<(*it)<<\" \";}puts(\"\");}\n#define dumpi2(x)\tidp{foreach(it, x){cout<<\"[\"<<(it)->F<<\" , \"<<(it)->S<<\"] \";}puts(\"\");}\n\n\n\n#define EPS 1e-10\n#define ETOL 1e-8\n#define MOD 1000000007\n\n#define PRIME_MAX 1000001\n\ntypedef pair<li, li> PI;\n\nli m,n;\n\nli a[555], b[555];\n\nvector<li> bipartite_match[1555];\nli match_to[1555];\nbool used[1555];\n\nbool dfs(li now){\n\tused[now]=true;\n\trep(i,sz(bipartite_match[now])){\n\t\tli next = bipartite_match[now][i];\n\t\tli next_next = match_to[next];\n\t\tif(next_next < 0 || (!used[next_next] && dfs(next_next))){\n\t\t\tmatch_to[now]=next;\n\t\t\tmatch_to[next]=now;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(int argc, char *argv[]){\n\twhile(1){\n\t\tcin>>m>>n;\n\t\tif(min(m,n)<=0)break;\n\n\t\trep(i,m)cin>>a[i];\n\t\trep(i,n)cin>>b[i];\n\n\t\t// construct graph\n\t\trep(i,1500)bipartite_match[i].clear();\n\t\trep(i,1555){\n\t\t\tmatch_to[i]=-1;\n\t\t}\n\t\trep(i,m){\n\t\t\trep(j,n){\n\t\t\t\tif(__gcd(a[i], b[j])>1){\n\t\t\t\t\tbipartite_match[i].pb(m+j);\n\t\t\t\t\tbipartite_match[m+j].pb(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\t// do matching\n\t\tli res=0;\n\t\trep(i,m){\n\t\t\tif(match_to[i]<0){\n\t\t\t\tmemset(used, false, 1555);\n\t\t\t\tif(dfs(i))res++;\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n/*#include <iostream>\n#include <vector>\n#include <map>\n#include <utility>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <numeric>\n#include <complex>\n#include <bitset>\n#include <functional>\n#include <stack>\n#include <regex>\n#include <tuple>\n#include <iomanip>\n*/\n#define int long long\n#define REP(i,a,n) for(int i=a;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define REV(i,a,n) for(int i=n;i>=a;--i)\n#define all(e) e.begin(),e.end()\n#define rall(e) e.rbegin(),e.rend()\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define show(n) cerr<<#n<<\" = \"<<n<<endl\n#define showp(n) cerr<<n.fs<<\", \"<<n.sc<<endl\n#define shows(n) for(auto z:n){cerr<<z<<\", \";}cerr<<endl\n#define showsp(n) for(auto z:n){cerr<<z.fs<<\" \"<<z.sc<<\", \"}cerr<<endl\n\n#define yes puts(\"Yes\")\n#define no puts(\"No\")\n#define case(i) printf(\"Case #%lld: \",i)\n\nusing namespace std;\n\nusing vi=vector<int>;\nusing pint=pair<int,int>;\n\ninline void io(){cin.tie(0);ios::sync_with_stdio(false);cout.tie(0);cout<<fixed<<setprecision(20);}\ninline int   in(){int n;scanf(\"%lld\",&n);return n;}\ninline void out(int n){printf(\"%lld\\n\",n);}\n\nconst int INF=1LL<<55;\nconst int MOD=1000000007;\nconst double EPS=1e-8;\n\nconst int MAX_V = 1010;\n\nint m,n;\nint V;\nvi G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u,int v) {\n    G[u].pb(v);\n    G[v].pb(u);\n}\n\nbool dfs(int v){\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        int u=G[v][i],w=match[u];\n        if(w<0 || !used[w] && dfs(w)){\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(){\n    int res=0;\n    memset(match,-1,sizeof(match));\n    for(int v=0;v<V;v++){\n        if(match[v]<0){\n            memset(used,0,sizeof(used));\n            if(dfs(v)){\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nvoid init(){\n    V=m+n;\n    rep(i,MAX_V){\n        G[i].erase(all(G[i]));\n    }\n}\n\nvoid solve(){\n    init();\n    vi blue(m);\n    vi red(n);\n    rep(i,m) blue[i]=in();\n    rep(i,n) red[i]=in();\n    rep(i,m){\n        rep(j,n){\n            if(gcd(blue[i],red[j])>1){\n                add_edge(i,m+j);\n            }\n        }\n    }\n    printf(\"%lld\\n\",bipartite_matching());\n}\n\nsigned main() {\n    io();\n\n    while(cin>>m>>n,n){\n        solve();\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\nint const inf = 1<<29;\n\nstruct MCF {\n    typedef int Weight;\n    typedef int Capacity;\n    struct Edge;\n    int n;\n    vector<vector<Edge> > g;\n    vector<int> level, iter;\n\n    struct Edge {\n        int dst;\n        Capacity cap, cap_orig;\n        int revEdge;\n        bool isRev;\n        Edge(int dst, Capacity cap, int revEdge, bool isRev)\n        :dst(dst), cap(cap), cap_orig(cap), revEdge(revEdge), isRev(isRev) {}\n    };\n\n    MCF(int n_)\n    : n(n_), g(vector<vector<Edge> >(n_)), level(n_), iter(n_) {}\n\n    void add_edge(int src, int dst, Capacity cap) {\n        g[src].push_back(Edge(dst, cap, g[dst].size(), false));\n        g[dst].push_back(Edge(src, 0, g[src].size() - 1, true));\n    }\n\n    void bfs(int s) {\n        fill(all(level), -1);\n        queue<Weight> q;\n        level[s] = 0;\n        q.push(s);\n        while (q.size()) {\n            int v = q.front(); q.pop();\n            for(int i = 0; i < (int)g[v].size(); i++){\n                Edge& e = g[v][i];\n                if (e.cap > 0 && level[e.dst] < 0) {\n                    level[e.dst] = level[v] + 1;\n                    q.push(e.dst);\n                }\n            }\n        }\n    }\n\n    Capacity dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < (int)g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (e.cap > 0 && level[v] < level[e.dst]) {\n                int d = dfs(e.dst, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.dst][e.revEdge].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    // src->dstへの最大フローを流す\n    Capacity max_flow(int src, int dst) {\n        int flow = 0;\n        while(1){\n            bfs(src);\n            if (level[dst] < 0) return flow;\n            fill(all(iter), 0);\n            int f;\n            while ((f = dfs(src, dst, inf)) > 0) {\n                flow += f;\n            }\n        }\n    }\n\n    // 現在の容量を表示\n    // フローを流した分だけ容量が減る実装になっている\n    void view(){\n        for(int i=0;i<g.size();i++){\n            for(int j=0;j<g[i].size();j++){\n                Edge & e=g[i][j];\n                if(!e.isRev) printf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap);\n            }\n        }\n    }\n\n    // 流れたフロー=元々の容量-現在の容量を表示\n    void view_flow(){\n        for(int i=0;i<g.size();i++){\n            for(int j=0;j<g[i].size();j++)if(!g[i][j].isRev){\n                Edge& e = g[i][j];\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.dst, e.cap_orig - e.cap);\n            }\n        }\n    }\n};\n\nint main(){\n    int n,m;\n    while(cin>>n>>m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n)cin>>a[i];\n        rep(i,m)cin>>b[i];\n        MCF mcf(n+m+2);\n        int s=n+m, t=n+m+1;\n        rep(i,m)mcf.add_edge(i+n,t,1);\n        rep(i,n){\n            mcf.add_edge(s,i,1);\n            rep(j,m)if(__gcd(a[i],b[j])!=1)mcf.add_edge(i,n+j,1);\n        }\n        cout << mcf.max_flow(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\n#define ALL(x) x.begin(), x.end()\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\nusing namespace std;\nrandom_device rnd;\nmt19937 mt(rnd());\nusing ll = long long;\nusing lld = long double;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<ll>;\nusing VVL = vector<VL>;\nusing PII = pair<int, int>;\nconst int IINF = 1 << 26;\nconst ll INF = 1ll << 60;\nconst ll MOD = 1000000007;\n\nint V;\nvector<int> G[1024];\n\nint gcd(int a, int b)\n{\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\nint match[1024];\nbool used[1024];\nvoid add_edge(int u, int v)\n{\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\nbool dfs(int v)\n{\n    used[v] = true;\n    rep(i, G[v].size())\n    {\n        int u = G[v][i];\n        int w = match[u];\n        if (w < 0 || !used[w] && dfs(w))\n        {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching()\n{\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    rep(v, V)\n    {\n        if (match[v] < 0)\n        {\n            memset(used, 0, sizeof(used));\n            if (dfs(v))\n                res++;\n        }\n    }\n    return res;\n}\n\nvoid solve(int m, int n)\n{\n    V = n + m;\n    rep(i, 1024)\n    {\n        G[i].clear();\n    }\n    vector<int> blue(m);\n    vector<int> red(n);\n    rep(i, m) cin >> blue[i];\n    rep(i, n) cin >> red[i];\n    rep(i, n) rep(j, m)\n    {\n        if (gcd(blue[j], red[i]) != 1)\n        {\n            //  cerr << i << \" \" << n + j << endl;\n            add_edge(i, n + j);\n        }\n    }\n    cout << bipartite_matching() << endl;\n}\n\nint main()\n{\n    int m, n;\n    while (cin >> m >> n, n)\n    {\n        solve(m, n);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\n//a<b\nlong pgcd(long a,long b){\n  if(a==0)\n    return b;\n  else\n    return pgcd(b%a,a);\n}\n\nlong gcd(long a, long b){\n  return pgcd(min(a,b), max(a,b));\n}\n\nint m,n;//blue,red\nint c[500][500];\nlong b[500], r[500];\nbool v[500];\nint p[500];\nbool match(int b){\n  if(b<0) return true;\n  rep(j,n){\n    if(!c[b][j] || v[j]) continue;\n    v[j]=true;\n    if(match(p[j])) {\n      p[j]=b;\n      return true;\n    }\n  }\n  return false;\n}\n\n\n\nint main(){\n  scanf(\"%d %d\", &m, &n);\n  rep(i,m) scanf(\" %ld\", b+i);\n  rep(j,n) scanf(\" %ld\", r+j);\n\n  rep(i,m) rep(j,n) c[i][j]=gcd(b[i],r[j]) > 1 ? 1 : 0;\n\n  rep(j,n) v[j]=-1;\n\n  int count=0;\n  rep(i,m){\n    rep(j,n) v[j]=false;\n    if(match(i)) count++;\n  }\n  printf(\"%d\",count);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAX_V = 1000;\nconst int INF = 10000000;\n\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap)\n{\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f)\n{\n  if(v == t) return f;\n\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n\n  return 0;\n}\n\nint max_flow(int s, int t)\n{\n  int flow = 0;\n  for(;;){\n    fill(used, used + MAX_V, false);\n    int f = dfs(s, t, INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main()\n{\n  while(1){\n    int m, n;\n    cin >> m >> n;\n    if(m == 0 && n == 0) break;\n    int b[m], r[n];\n    for(int i = 0; i < m; i++)\n      cin >> b[i];\n    for(int i = 0; i < n; i++)\n      cin >> r[i];\n    for(int i = 0; i < m; i++){\n      for(int j = 0; j < n; j++){\n        if(__gcd(b[i], r[j]) != 1){\n          add_edge(i+2, j+m+2, 1);\n        }\n      }\n    }\n    for(int i = 2; i < m + 2; i++)\n      add_edge(0, i, 1);\n    for(int i = m+2; i < m+n+2; i++)\n      add_edge(i, 1, 1);\n    cout << max_flow(0, 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\ntypedef pair<ll,ll> pll;\nconst ll mod=1e9+7;\n\ntemplate<typename T,bool directed>\nstruct Fordfulkerson{\n  struct edge{\n    ll to,cap,rev;\n    edge(){}\n    edge(ll to,ll cap,ll rev):to(to),cap(cap),rev(rev){}\n  };\n\n  vector<vector<edge> > G;\n  vector<ll> used;\n\n  Fordfulkerson(){}\n  Fordfulkerson(ll n):G(n),used(n){}\n\n  void add_edge(ll from,ll to,T cap){\n    G[from].emplace_back(to,cap,G[to].size());\n    G[to].emplace_back(from,directed?0:cap,G[from].size()-1);\n  }\n\n  T dfs(ll v,ll t,T f){\n    if(v==t) return f;\n    used[v]=true;\n    for(ll i=0;i<(ll)G[v].size();i++){\n      edge &e = G[v][i];\n      if(!used[e.to]&&e.cap>0){\n        T d=dfs(e.to,t,min(f,e.cap));\n        if(d>0){\n          e.cap-=d;\n          G[e.to][e.rev].cap+=d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  ll flow(ll s,ll t,T lim){\n    T fl=0;\n    while(1){\n      fill(used.begin(),used.end(),0);\n      T f=dfs(s,t,lim);\n      if(f==0) break;\n      fl+=f;\n      lim-=f;\n    }\n    return fl;\n  }\n\n  ll flow(ll s,ll t){\n    return flow(s,t,numeric_limits<T>::max()/2);\n  }\n\n};\n\nll gcd(ll a,ll b) {\n  if(b==0) {\n    return a;\n  }\n  else {\n    return gcd(b,a%b);\n  }\n}\n\nint main() {\n  while(1) {\n    ll m,n;\n    cin >> m >> n;\n    if(m==0&&n==0) return 0;\n    vec b(m),r(n);\n    Fordfulkerson<ll,true> G(m+n+2);\n    for(ll i=0;i<m;i++) {\n      cin >> b[i];\n      G.add_edge(m+n,i,1);\n    }\n    for(ll i=0;i<n;i++) {\n      cin >> r[i];\n      G.add_edge(m+i,m+n+1,1);\n    }\n    for(ll i=0;i<m;i++) {\n      for(ll j=0;j<n;j++) {\n        if(gcd(b[i],r[j])!=1) {\n          G.add_edge(i,m+j,1);\n        }\n      }\n    }\n    cout << G.flow(m+n,m+n+1) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nint V;\nvector<vector<int>> G;\nvector<int> match;\nvector<bool> used;\n\nvoid add_edge(int u, int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\nbool dfs(int v){\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        int u = G[v][i];\n        int u_pair = match[u];\n        if(u_pair < 0 || !used[u_pair] && dfs(u_pair)){\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(){\n    int res = 0;\n    match.assign(V, -1);\n    for(int v = 0; v < V; v++){\n        if(match[v] < 0){\n            used.assign(V, false);\n            if(dfs(v)){\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(true){\n        int m, n;\n        cin >> m >> n;\n        if(m == 0) break;\n\n        vector<int> b(m), r(n);\n        for(int i=0;i<m;i++){\n            cin >> b[i];\n        }\n        for(int i=0;i<n;i++){\n            cin >> r[i];\n        }\n\n        V = n + m;\n        G.assign(V, {});\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(__gcd(b[i], r[j]) != 1){\n                    add_edge(i, j + m);\n                }\n            }\n        }\n\n        cout << bipartite_matching() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nusing weight = int;\n\nstruct edge {\n    int to;\n    weight cap;\n    int rev;\n};\n\nusing edges = std::vector<edge>;\nusing graph = std::vector<edges>;\n\nvoid add_edge(graph& g, int from, int to, weight cap) {\n    g[from].push_back(edge{to, cap, static_cast<int>(g[to].size())});\n    g[to].push_back(edge{from, 0, static_cast<int>(g[from].size()-1)});\n}\n\nvoid bfs(graph& g, std::vector<int>& level, int s) {\n    for(int i=0; i<level.size(); ++i) {\n        level[i] = -1;\n    }\n    level[s] = 0;\n    std::queue<weight> que;\n    que.push(s);\n    while(!que.empty()) {\n        int v = que.front(); que.pop();\n        for(int i=0; i<g[v].size(); ++i) {\n            edge& e = g[v][i];\n            if(e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nweight dfs(graph& g, std::vector<int>& level, std::vector<int>& iter, int v, int t, weight f) {\n    if(v == t) {\n        return f;\n    }\n    for(int& i=iter[v]; i<g[v].size(); ++i) {\n        edge& e = g[v][i];\n        if(e.cap > 0 && level[v] < level[e.to]) {\n            int d = dfs(g, level, iter, e.to, t, std::min(f, e.cap));\n            if(d > 0) {\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nweight max_flow(graph& g, int s, int t) {\n    weight flow = 0;\n    std::vector<int> level(g.size(), -1);\n    std::vector<int> iter(g.size(), 0);\n    int INF = 1e9;\n    while(true) {\n        bfs(g, level, s);\n        if(level[t] < 0) {\n            return flow;\n        }\n        for(int i=0; i<iter.size(); ++i) {\n            iter[i] = 0;\n        }\n        weight f;\n        while((f = dfs(g, level, iter, s, t, INF)) > 0) {\n            flow += f;\n        }\n    }\n}\n\nint gcd(int m, int n) {\n    if((m == 0 || n == 0)) {\n        return 0;\n    }\n    while(m != n) {\n        if(m > n) m = m-n;\n        else      n = n - m;\n    }\n    return m;\n}\n\nint main() {\n    int m, n;\n    while(cin >> m >> n, m) {\n        vector<int> b(m), r(n);\n        graph g(m+n+2);\n        for(int i=0; i<m; ++i) {\n            cin >> b[i];\n        }\n        for(int i=0; i<n; ++i) {\n            cin >> r[i];\n        }\n        for(int i=0; i<m; ++i) {\n            add_edge(g, 0, i+1, 1);\n        }\n        for(int i=0; i<n; ++i) {\n            add_edge(g, m+i+1, m+n+1, 1);\n        }\n        for(int i=0; i<m; ++i) {\n            for(int j=0; j<n; ++j) {\n                if(gcd(b[i], r[j]) != 1) {\n                    add_edge(g, i+1, m+j+1, 1);\n                }\n            }\n        }\n        cout << max_flow(g, 0, m+n+1) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for((i)=0;(i)<(int)n;(i)++)\n#define foreach(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n\nconst int SIZE = 1002;\nint V;\nvector<int> G[1002];\nint match[1002];\nbool used[1002];\n\nvoid init(int v) {\n  int i;\n  fill(used, used + SIZE, false);\n  fill(match, match + SIZE, 0);\n  rep (i, SIZE) G[i].clear();\n  V = v;\n}\n\nvoid add_edge(int u, int v) {\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v) {\n  int i;\n  used[v] = true;\n  rep(i,G[v].size()) {\n    int u = G[v][i], w = match[u];\n    if (w < 0 || !used[w] && dfs(w)) {\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching() {\n  int v, res = 0;\n  memset(match, -1, sizeof match);\n  rep(v,V) {\n    if (match[v] < 0) {\n      memset(used, 0, sizeof used);\n      if (dfs(v)) {\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\nint m, n;\nint b[502], r[502];\nconst int MAX_N = 10000000;\n//  但多\nbool check[MAX_N];\nvector<int> prime;\n\nint main() {\n  int i, j, k;\n  // 但多\n  fill(check, check + MAX_N, true);\n  for (i=4; i<MAX_N; i+=2) check[i] = false;\n  prime.push_back(2);\n  for (i=3; i<MAX_N; i+=2) if (check[i]) {\n    prime.push_back(i);\n    for (j=i+i; j<MAX_N; j+=i) check[j] = false;\n  }\n  \n  while (scanf(\"%d%d\", &m, &n), m|n) {\n    rep (i, m) scanf(\"%d\", &b[i]);\n    rep (i, n) scanf(\"%d\", &r[i]);\n\n    init(m+n);    \n    rep (i, m) {\n      rep (j, n) {\n        for (k=0; prime[k]<=b[i] && prime[k]<=r[j]; k++) {\n          if (b[i] % prime[k] == 0 && r[j] % prime[k] == 0) {\n            add_edge(i, m+j);\n            //printf(\"%d %d\\n\", i, j);\n            break;\n          }\n        }\n      }\n    }\n    \n    printf(\"%d\\n\", bipartite_matching());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<functional>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define MaxCards 1000\nusing namespace std;\nint\tb,r,V;\nint blue[MaxCards],red[MaxCards];\nvector<int> G[MaxCards];\nint match[MaxCards]; \nbool used[MaxCards];\n\n\n\nvoid add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\n// 増加パスをDFSで探す\nbool dfs(int v) {\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++) {\n        int u = G[v][i], w = match[u];\n        if (w < 0 || !used[w] && dfs(w)) {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching() {\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for(int v = 0; v < V; v++) {\n        if (match[v] < 0) {\n            memset(used, 0, sizeof(used));\n            if (dfs(v)) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\nint gcd(int n1,int n2){\n\tif(n1%n2==0) return n2;\n\treturn gcd(n2,n1%n2);\n}\nint main(){\n\n\twhile(true){\n\t\tmemset(blue,0,sizeof(blue));\n\t\tmemset(red,0,sizeof(red));\n\t\tfor(int i=0;i<MaxCards;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tcin>>b>>r;\n\t\tV=b+r;\n\t\tif(b==0)\n\t\t\tbreak;\n\t\tint idx=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tcin >> blue[i];\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin >> red[i];\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tfor(int j=0;j<r;j++){\n\t\t\t\tif(blue[i]>red[j]){\n\t\t\t\t\tif(gcd(blue[i],red[j])!=1){\n\t\t\t\t\t\tadd_edge(i,b+j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(gcd(red[j],blue[i])!=1){\n\t\t\t\t\tadd_edge(i,b+j);\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, a, n) for(int i=(a); i<(n); i++)\n\ntemplate <typename T>\nclass dinic{\nprivate:\n\tunordered_map<int,unordered_map<int,T>> mp;\n\tunordered_map<int,int> level;\n\tunordered_set<string> visited;\npublic:\n\tvoid add_edge(int from, int to, T cap){\n\t\tmp[from][to] = cap;\n\t\tmp[to][from] = 0;\n\t}\n\n\tvoid bfs(int s){\n\t\tlevel.clear();\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\n\t\t\tint v = q.front();q.pop();\n\t\t\tfor(auto x:mp[v]){\n\t\t\t\tif(x.second > 0 && !level.count(x.first)){\n\t\t\t\t\tlevel[x.first] = level[v] + 1;\n\t\t\t\t\tq.push(x.first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tT dfs(int v, int t, T f){\n\t\tif(v == t){\n\t\t\treturn f;\n\t\t}\n\t\tfor(auto x:mp[v]){\n\t\t\tif(visited.count(to_string(v) + \":\" + to_string(x.first))) continue;\n\t\t\tvisited.insert(to_string(v) + \":\" + to_string(x.first));\n\t\t\tif(x.second > 0 && level.count(x.first) && level[v] < level[x.first]){\n\t\t\t\tT d = dfs(x.first, t, min(f, x.second));\n\t\t\t\tif(d > 0){\n\t\t\t\t\tmp[v][x.first] -= d;\n\t\t\t\t\tmp[x.first][v] += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tT max_flow(int s, int t){\n\t\tT flow = 0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(!level.count(t)) return flow;\n\t\t\tvisited.clear();\n\t\t\tT f;\n\t\t\twhile((f = dfs(s, t, numeric_limits<T>::max())) > 0){\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\ntemplate <typename T>\nT gcd(T a, T b) {\n    if(a < b) swap(a, b);\n    return (b == 0)? a : gcd(b, a % b);\n}\n\nint r[501];\n\nint main() {\n    while(1) {\n        int m, n; cin >> m >> n;\n        if(m==0 && n==0) break;\n        \n        dinic<int> g;\n        rep(i, m) {\n            cin >> r[i];\n            g.add_edge(-1, i, 1);\n        }\n        rep(j, n) {\n            int b; cin >> b;\n            g.add_edge(m+j, -2, 1);\n            rep(i, m) {\n                if(gcd(b, r[i])>1)\n                    g.add_edge(i, m+j, 1);\n            }\n        }\n        cout << g.max_flow(-1, -2) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\n\nstruct Edge{\n    int to,cap,rev;\n    Edge(int to,int cap,int rev) : to(to),cap(cap),rev(rev) {};\n};\n\nvoid add_edge(vector<vector<Edge> >& E,int from,int to,int cap){\n    E[from].push_back(Edge(to,cap,E[to].size()));\n    E[to].push_back(Edge(from,0,E[from].size()-1));\n}\n\nvector<int> levels(vector<vector<Edge> > &E,int s){\n    vector<int> level(E.size(),-1);\n    level[s] = 0;\n    queue<int> Q;\n    Q.push(s);\n    while(!Q.empty()){\n        int v = Q.front();\n        Q.pop();\n        for(int i=0;i<E[v].size();i++){\n            Edge &e = E[v][i];\n            if(e.cap > 0 and level[e.to] == -1){\n                level[e.to] = level[v]+1;\n                Q.push(e.to);\n            }\n        }\n    }\n    return level;\n}\n\nint good_path(vector<vector<Edge> > &E,\n        vector<int> &iter,\n        vector<int> &level,\n        int v,int t,int f){\n    if(v == t) return f;\n    for(int &i=iter[v];i<E[v].size();i++){\n        Edge &e = E[v][i];\n        if(e.cap > 0 and level[v] < level[e.to]){\n            int d = good_path(E,iter,level,e.to,t,min(f,e.cap));\n            if(d > 0){\n                e.cap -= d;\n                E[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(vector<vector<Edge> > E,int s,int t){\n    int flow = 0;\n    const int INF = 1 << 30;\n    while(true){\n        vector<int> level = levels(E,s);\n        if(level[t] < 0) return flow;\n        vector<int> iter(E.size());\n        int f;\n        while((f=good_path(E,iter,level,s,t,INF)) > 0){\n            flow += f;\n        }\n    }\n}\n\n\nll gcd(ll a,ll b){\n    return b==0 ? a : gcd(b,a%b);\n}\n\nint main(){\n    while(true){\n        int m,n;\n        cin >> m >> n;\n        if(m == 0 and n == 0) break;\n\n        vector<int> b(m);\n        vector<int> r(n);\n        for(int i=0;i<m;i++) cin >> b[i];\n        for(int i=0;i<n;i++) cin >> r[i];\n\n        vector<vector<Edge> > E(n+m+2);\n        // 0 is start. 1 is end.\n        int start = 0,end = 1;\n        int blue_start = 2,red_start=2+m;\n\n        for(int i=0;i<m;i++){\n            add_edge(E,start,blue_start+i,1);\n        }\n        for(int i=0;i<n;i++){\n            add_edge(E,red_start+i,end,1);\n        }\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(gcd(b[i],r[j]) != 1){\n                    add_edge(E,blue_start+i,red_start+j,1);\n                }\n            }\n        }\n        cout << max_flow(E,start,end) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 1000000007;\n\n// greatest common divisor and least common multiple\n// gcd is calculated by Euclidean Algorithm\n// lcm = m * n / gcd(m,n)\ntemplate <typename T = int>\nT gcd(T a, T b) {\n    if (a < b)\n        return gcd(b, a);\n    if (b == 0)\n        return a;\n    T r;\n    while ((r = a % b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\ntemplate <typename T = int>\nT lcm(T m, T n) {\n    if ((0 == m) || (0 == n))\n        return 0;\n    return ((m / gcd(m, n)) * n);\n}\n\n// ref: https://github.com/beet-aizu/library/blob/master/flow/dinic.cpp\ntemplate <typename T, bool directed>\nstruct Dinic {\n    struct edge {\n        int to;\n        T cap;   // capacity of the edge\n        int rev; // index for to->from edge\n        edge() {}\n        edge(int to_, T cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {}\n    };\n    T inf = numeric_limits<T>::max();\n    vector<vector<edge>> G;\n    vector<int> level, iter;\n    Dinic(int n) : G(n), level(n), iter(n) {}\n\n    void addEdge(int from, int to, T cap) {\n        G[from].emplace_back(to, cap, G[to].size());\n        G[to].emplace_back(from, directed ? 0 : cap, G[from].size() - 1);\n    }\n    void bfs(int s) {\n        fill(level.begin(), level.end(), -1);\n        queue<int> que;\n        level[s] = 0;\n        que.emplace(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (edge &e : G[v]) {\n                if (e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.emplace(e.to);\n                }\n            }\n        }\n    }\n    T dfs(int v, int t, T f) {\n        if (v == t)\n            return f;\n        for (int i = iter[v]; i < int(G[v].size()); ++i) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[v] < level[e.to]) {\n                T d = dfs(e.to, t, min(f, e.cap));\n                if (d == 0)\n                    continue;\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n        return 0;\n    }\n    T maxFlow(int s, int t, T lim) {\n        T fl = 0;\n        while (true) {\n            bfs(s);\n            if (level[t] < 0 || lim == 0)\n                break;\n            fill(iter.begin(), iter.end(), 0);\n            while (true) {\n                T f = dfs(s, t, lim);\n                if (f == 0)\n                    break;\n                fl += f;\n                lim -= f;\n            }\n        }\n        return fl;\n    }\n    // returns maximum flow from s to t\n    T maxFlow(int s, int t) { return maxFlow(s, t, inf); }\n};\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    while (true) {\n        int m, n;\n        cin >> m >> n;\n        if (m == 0)\n            return 0;\n        vector<int> b(m), r(n);\n        for (int i = 0; i < m; ++i) {\n            cin >> b[i];\n        }\n        for (int i = 0; i < n; ++i) {\n            cin >> r[i];\n        }\n        Dinic<int, true> dinic(m + n + 2);\n        int s = m + n, t = m + n + 1;\n        for (int i = 0; i < m; ++i) {\n            dinic.addEdge(s, i, 1);\n        }\n        for (int i = 0; i < n; ++i) {\n            dinic.addEdge(i + m, t, 1);\n        }\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (gcd(b[i], r[j]) != 1)\n                    dinic.addEdge(i, m + j, 1);\n            }\n        }\n        cout << dinic.maxFlow(s, t) << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include \"push_relabel.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n  each(x,vec) is >> x;\n  return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n  rep(i,vec.size()) {\n    if (i) os << \" \";\n    os << vec[i];\n  }\n  return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n  rep(i,vec.size()) {\n    if (i) os << endl;\n    os << vec[i];\n  }\n  return os;\n}\n\nclass MaxFlow {\npublic:\n  struct Edge {\n    ll to, cap, dcap, rev;\n    void update() {\n      cap += dcap;\n      dcap = 0;\n    }\n    ll capacity() const {\n      return cap + dcap;\n    }\n  };\n  vector<vector<Edge>> G;\nprivate:\n  bool is_debug;\n  ll V;\n  vector<ll> bfs(ll s) {\n    vector<ll> dist(V, linf);\n    dist[s] = 0;\n    queue<ll> Q; Q.push(s);\n    while ( !Q.empty() ) {\n      ll v = Q.front(); Q.pop();\n      each(e, G[v]) {\n        if (e.cap > 0 && dist[e.to] == linf) {\n          dist[e.to] = dist[v]+1;\n          Q.push(e.to);\n        }\n      }\n    }\n    return dist;\n  }\n  vector<ll> rbfs(ll s) {\n    vector<ll> dist(V, linf);\n    dist[s] = 0;\n    queue<ll> Q; Q.push(s);\n    while ( !Q.empty() ) {\n      ll v = Q.front(); Q.pop();\n      each(e, G[v]) {\n        if (rev(e).cap > 0 && dist[e.to] == linf) {\n          dist[e.to] = dist[v]+1;\n          Q.push(e.to);\n        }\n      }\n    }\n    return dist;\n  }\npublic:\n  const vector<vector<Edge>>& Graph() {\n    return G;\n  }\n  MaxFlow(ll V, bool is_debug=false) : V(V), G(V), is_debug(is_debug) {}\n  void init(ll n) {\n    V = n;\n    G.assign(V, vector<Edge>());\n  }\n  void add(ll from, ll to, ll cap) {\n    if (is_debug) cout << \"ADD: \" << from << \" \" << to << \" \" << cap << endl;\n    assert(V > 0);\n    G[from].pb({to, cap, 0, (ll)G[to].size()});\n    G[to].pb({from, 0, 0, (ll)G[from].size()-1});\n  }\n  // S -> s, T -> t に inf は自力で\n  void add(ll from, ll to, ll min_flow, ll cap, ll S, ll T) {\n    if (is_debug) cout << endl << \"ADD_MIN:\" << from << \" \" << to << \" \" << min_flow << \" \" << cap << endl;\n    add(from, to, cap-min_flow);\n    add(S, to, min_flow);\n    add(from, T, cap);\n    if (is_debug) cout << endl;\n  }\n  Edge& rev(const Edge& e) {\n    return G[e.to][e.rev];\n  }\n  ll flow(ll s, ll t, ll f=linf) {\n    ll res = 0;\n    vector<ll> d;\n    while (f > 0) {\n      vector<ll> dist = bfs(s), rdist = rbfs(t);\n      d.pb(*max_element(all(dist)));\n      if (dist[t] == linf) break;\n      vector<vector<ll>> dist_to_nodes(V+1);\n      rep(i, V) {\n        if (dist[i] < linf) {\n          dist_to_nodes[dist[i]].pb(i);\n        }\n      }\n      vector<ll> f(V, 0);\n      f[s] = linf;\n      rep(i, V+1) each(v, dist_to_nodes[i]) each(e, G[v]) {\n        if (rdist[e.to] != rdist[v] - 1) continue;\n        if (dist[e.to] != dist[v] + 1) continue;\n        if (e.capacity() == 0) continue;\n        ll use = min(e.capacity(), f[v]);\n        f[v] -= use, f[e.to] += use;\n        e.dcap -= use, rev(e).dcap += use;\n      }\n      // cout << \"1: \" << f << endl;\n      // assert(f[t] > 0);\n      if (f[t] == 0) break;\n      res += f[t];\n      f[t] = 0;\n      rrep(i, 1, V+1) each(v, dist_to_nodes[i]) each(e, G[v]) {\n        if (rdist[e.to] != rdist[v] + 1) continue;\n        if (dist[e.to] != dist[v] - 1) continue;\n        if (e.dcap <= 0) continue;\n        ll use = min(e.dcap, f[v]);\n        f[v] -= use, f[e.to] += use;\n        e.dcap -= use, rev(e).dcap += use;\n      }\n      // cout << \"2: \" << f << endl;\n      rep(v, V) if (v != s) assert(f[v] == 0);\n      rep(v, V) each(e, G[v]) e.update();\n    }\n    return res;\n  }\n};\n\nll gcd(ll a, ll b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  ll n, m;\n  while (cin >> n >> m, n || m) {\n    vector<ll> a(n), b(m); cin >> a >> b;\n    ll s = n + m, t = s + 1;\n    MaxFlow mf(t+1);\n    rep(i, n) rep(j, m) {\n      if (gcd(a[i], b[j]) > 1) {\n        mf.add(i, n+j, 1);\n      }\n    }\n    rep(i, n) mf.add(s, i, 1);\n    rep(i, m) mf.add(n+i, t, 1);\n    cout << mf.flow(s, t) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint V;\nvector<int> G[1001];\nint match[1001];\nbool used[1001];\n\nvector<int> prime;\n\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i], w=match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int v=0;v<V;v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid primesolve(){\n\tprime.push_back(2);\n\tprime.push_back(3);\n\n\tfor(int i=4;i<1000000;i++){\n\t\tbool flag = true;\n\t\tfor(int k=0;k<prime.size();k++){\n\t\t\tif(i%prime[k] == 0){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tprime.push_back(i);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tint m,n;\n\t\tcin >> m >> n;\n\t\tif(m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tvector<int> b;\n\t\tvector<int> r;\n\t\tV = m+n;\n\t\tprimesolve();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tb.push_back(buf);\n\t\t}\n\t\tfor(int j=0;j<n;j++){\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tr.push_back(buf);\n\t\t}\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<prime.size();k++){\n\t\t\t\t\tif(b[i]%prime[k]==0&&r[j]%prime[k]==0){\n\t\t\t\t\t\tadd_edge(i,j+m);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(min(b[i],r[j]) < prime[k]){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define MyDebug\n#include <bits/stdc++.h>\n\n#define rep(i, from, to) for(int i = from; i < to; ++i)\n#define REP(i, from, to) for(int i = from; i <= to; ++i)\n\n#ifdef MyDebug\n#define debug(x) cerr << #x << \" : \"<< x << endl;\n#else\n#define debug(x)\n#endif\nstruct edge {\n\tint to, cap, rev;\n};\n\nusing namespace std;\nconst int MAX_V = 1002;\nconst int INF = (int)1e9;\n//a < b\nvector<edge> g[MAX_V];\nbool used[MAX_V];\n\n\nvoid add_edge(int from, int to, int cap) {\n\tg[from].push_back((edge){to, cap, (int)g[to].size()});\n\tg[to].push_back((edge){from, 0, (int)(g[from].size() - 1)});\n}\n\nint dfs(int v, int t, int f) {\n\tif (v == t) return f;\n\tused[v] = true;\n\trep(i, 0, (int)g[v].size()) {\n\t\tedge &e = g[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t) {\n\tint flow = 0;\n\twhile(true) {\n\t\tfill(used, used + MAX_V, false);\n\t\tint f = dfs(s, t, INF);\n\t\tif (f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nvoid init() {\n\trep(i, 0, MAX_V) {\n\t\tg[i] = vector<edge>();\n\t}\n}\n\nint m, n;\nint b[500], r[500];\nvoid solve() {\n\twhile(cin >> m >> n, m != 0 || n != 0) {\n\t\tinit();\n\t\trep (i, 0, m) {\n\t\t\tcin >> b[i];\n\t\t}\n\t\trep (i, 0, n) {\n\t\t\tcin >> r[i];\n\t\t}\n\t\tint s = m + n;\n\t\tint t = s + 1;\n\t\trep (i, 0, m) add_edge(s, i, 1);\n\t\trep (i, m, m + n) add_edge(i, t, 1);\n\t\trep (i, 0, m) {\n\t\t\trep (j, 0, n) {\n\t\t\t\tint tmp = gcd(b[i], r[j]);\n\t\t\t\tif (tmp != 1) {\n\t\t\t\t\tadd_edge(i, m + j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << max_flow(s, t) << endl;\n\t}\n}\n\nvoid test() {\n\tcerr << gcd(92, 20) << endl;\n}\n\nint main() {\n\tsolve();\n\t//test();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nstruct Bipartite_Matching\n{\n  vector< vector< int > > graph;\n  vector< int > dist, match;\n  vector< bool > used, vv;\n\n  Bipartite_Matching(int n, int m)\n  {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, false);\n  }\n\n  void add_edge(int u, int v)\n  {\n    graph[u].push_back(v);\n  }\n\n  void bfs()\n  {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a)\n  {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching()\n  {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nint dp[3000][3000];\n\nint gcd(int x, int y)\n{\n  if(x < 3000) {\n    if(~dp[x][y]) return (dp[x][y]);\n    int r = x % y;\n    if(r == 0) return dp[x][y] = y;\n    return dp[x][y] = gcd(y, r);\n  } else {\n    int r = x % y;\n    if(r == 0) return y;\n    return gcd(y, r);\n  }\n}\n\nint main()\n{\n  memset(dp, -1, sizeof(dp));\n\n  int M, N, B[500], R[500];\n  while(scanf(\"%d %d\", &M, &N), M) {\n    Bipartite_Matching flow(M, N);\n    for(int i = 0; i < M; i++) scanf(\"%d\", &B[i]);\n    for(int i = 0; i < N; i++) scanf(\"%d\", &R[i]);\n    for(int i = 0; i < M; i++) {\n      for(int j = 0; j < N; j++) {\n        if(__gcd(B[i], R[j]) > 1) flow.add_edge(i, j);\n      }\n    }\n    printf(\"%d\\n\", flow.bipartite_matching());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n//typedef long long Int;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst) : src(src),dst(dst) {}\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) {}\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vec<Edge> Edges;\ntypedef vec<Edges> Graph;\n\n#define MAXMN 500\nint B[MAXMN];\nint R[MAXMN];\n\nint gcd(int a, int b)\n{   \n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\n\n\nmain() {\n  int M,N;\n  Graph g; g.reserve(MAXMN+MAXMN);\n  while(cin>>M>>N,M) {\n    g.clear();\n    g.resize(M+N);\n    REP(i,M) cin>>B[i];\n    REP(i,N) cin>>R[i];\n    REP(i,M) {\n      Edges es, es2;\n      REP(j,N) {\n\tif(gcd(B[i],R[j])!=1) { es.pb(Edge(i,M+j)); es2.pb(Edge(M+j,i)); }\n      }\n      g[i] = es;\n      g[M+i] = es2;\n    }\n    Edges matching;\n    cout << bipartiteMatching(g,M,matching) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\n\nstruct Edge{int to,from,cost;};\n\n#define debug cout\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) debug << *i << \" \"; debug << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define SS stringstream\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nint m,n,b[510],r[510],V;\nvint G[1010];\nint match[1010];\nbool used[1010];\n\nint gcd(int a,int b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\n\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v){\n\tused[v]=true;\n\trep(i,sz(G[v])){\n\t\tint u=G[v][i],w=match[u];\n\t\tif(w<0||!used[w]&&dfs(w)){\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res=0;\n\tmemset(match,-1,sizeof(match));\n\trep(v,V){\n\t\tif(match[v]<0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v))++res;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tIL{\n\t\tcin>>m>>n;\n\t\tif(m==0&&n==0)break;\n\t\trep(i,m)cin>>b[i];\n\t\trep(i,n)cin>>r[i];\n\t\tV=m+n;\n\t\trep(i,1010)G[i].clear();\n\t\trep(i,m)rep(j,n)if(gcd(b[i],r[j])>1)add_edge(i,j+m);\n\t\tcout<<bipartite_matching()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n#define INF 10000000\n\nint gcd(int a, int b){ return a%b ? gcd(b, a%b) : b; }//Ååöñ\n\nstruct edge{\n\tint to,cap,rev;\n\tedge(int t,int c,int r){\n\t\tto=t;cap=c,rev=r;\n\t}\n};\n\nvector<vector<edge> > G;\nint level[100000];\nint iter[100000];\n\nvoid add_edge(int from,int to,int cap){\n\tG[from].push_back(edge(to,cap,G[to].size()));\n\tG[to].push_back(edge(from,0,G[from].size()-1));\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();que.pop();\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(true){\n\t\tbfs(s);\n\t\tif(level[t]<0) return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,INF))>0){\n\t\t\tflow+=f;\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tint n,m;\n\twhile(cin>>n>>m && n>0){\n\t\tG.clear();\n\t\tG.resize(n+m+2);\n\t\tvector<int> red,blue;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tred.push_back(t);\n\t\t\tadd_edge(0,1+i,1);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tblue.push_back(t);\n\t\t\tadd_edge(n+i+1,n+m+1,1);\n\t\t}\n\t\tfor(int r=0;r<n;r++){\n\t\t\tfor(int b=0;b<m;b++){\n\t\t\t\tif(gcd(red[r],blue[b])>1){\n\t\t\t\t\tadd_edge(r+1,n+b+1,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<max_flow(0,n+m+1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define LOOP(i,x,n) for(int i=x;i<n;i++)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define MP make_pair\n#define FIR first\n#define SEC second\n#define int long long\nusing namespace std;\nconst int MOD=1000000007;\nconst int INF=1000000009;\n\ntypedef int Flow;\nstruct Edge{\n  int src;int dst;int rev;\n  Flow cap;\n  Edge(int s=0,int d=0,Flow c=0,int r=0):\n  src(s),dst(d),cap(c),rev(r){}\n};\nusing Graph = vector<vector<Edge>>;\nGraph g;\nbool used[100000];\nint m,n;\n\nvoid add(int src,int dst,int cap){\n  g[src].emplace_back(src,dst,cap,g[dst].size());\n  g[dst].emplace_back(dst,src,0,g[src].size()-1);\n}\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  REP(i,g[v].size()){\n    Edge &e=g[v][i];\n    if(!used[e.dst]&&e.cap>0){\n      int d=dfs(e.dst,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        g[e.dst][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint maximum_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(used,used+1111,0);\n    int f=dfs(s,t,INF);\n    if(!f)return flow;\n    flow+=f;\n  }\n}\n\nint gcd(int a,int b){\n  if(a<b)swap(a,b);\n  if(b==0)return a;\n  return gcd(b,a%b);\n}\n\nsigned main(){\n  while(cin>>m>>n,m){\n    g=Graph(1111);\n\n    vector<pair<int,int>> B(m),R(n);\n    REP(i,m){\n      int b;\n      cin>>b;\n      B[i]=MP(b,i+1);\n    }\n    REP(i,n){\n      int r;\n      cin>>r;\n      R[i]=MP(r,i+1+m);\n    }\n    REP(i,m)add(0,i+1,1);\n    REP(i,n)add(m+i+1,n+m+1,1);\n\n    REP(i,m){\n      REP(j,n){\n        if(gcd(B[i].FIR,R[j].FIR)>1){\n          add(B[i].SEC,R[j].SEC,1);\n        }\n      }\n    }\n    cout<<maximum_flow(0,n+m+1)<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// ford-fulkerson\nstruct edge {\n    int to, cap, rev;\n};\n\nusing edges = std::vector<edge>;\nusing graph = std::vector<edges>;\n\nvoid add_edge(graph& g, int from, int to, int cap) {\n    g[from].push_back(edge{to, cap, static_cast<int>(g[to].size())});\n    g[to].push_back(edge{from, 0, static_cast<int>(g[from].size()-1)});\n}\n\nint dfs(graph& g, std::vector<bool>& used, int v, int t, int f) {\n    if(v == t) {\n        return f;\n    }\n    used[v] = true;\n    for(int i=0; i<g[v].size(); ++i) {\n        edge& e = g[v][i];\n        if(!used[e.to] && e.cap > 0) {\n            int d = dfs(g, used, e.to, t, std::min(f, e.cap));\n            if(d > 0) {\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(graph& g, int s, int t) {\n    int flow = 0;\n    int INF = 1e9;\n    std::vector<bool> used(g.size(), false);\n    while(true) {\n        std::fill(used.begin(), used.end(), false);\n        int f = dfs(g, used, s, t, INF);\n        if(f == 0) {\n            return flow;\n        }\n        flow += f;\n    }\n\n}\n\nint main() {\n    int m, n;\n    while(cin >> m >> n, m) {\n        vector<int> b(m), r(n);\n        for(int i = 0; i < m; ++i) {\n            cin >> b[i];\n        }\n        for(int i = 0; i < n; ++i) {\n            cin >> r[i];\n        }\n        graph g(n + m + 2);\n        int const source = n + m;\n        int const sink = source + 1;\n        for(int i = 0; i < m; ++i) {\n            add_edge(g, source, i, 1);\n            for(int j = 0; j < n; ++j) {\n                if(__gcd(b[i], r[j]) != 1) {\n                    add_edge(g, i, j + m, 1);\n                }\n            }\n        }\n        for(int i = 0; i < n; ++i) {\n            add_edge(g, i + m, sink, 1);\n        }\n        cout << max_flow(g, source, sink) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a%b);\n}\n\nll lcm(ll a, ll b){\n    return a*b/gcd(a,b);\n}\n\nll extgcd(ll a, ll b, ll &x, ll &y){\n    ll d = a;\n    if(b == 0) x = 1, y = 0;\n    else{\n        d = extgcd(b, a%b, y, x);\n        y -= (a/b)*x;\n    }\n    return d;\n}\n\ntemplate<typename T>\nstruct Max_Flow{\n    struct edge{\n        int to; T cap; int rev;\n        edge(int to, T cap, int rev) : to(to), cap(cap), rev(rev) {}\n    };\n\n    vector<vector<edge>> es;\n    vector<bool> used;\n    const T INF_T;\n\n    Max_Flow(int n) : INF_T(numeric_limits<T>::max()){\n        es.resize(n), used.resize(n);\n    }\n\n    void add_edge(int from, int to, T cap, bool directed = true){\n        es[from].eb(to, cap, sz(es[to]));\n        es[to].eb(from, directed? 0 : cap, sz(es[from])-1);\n    }\n\n    T dfs(int now, int t, T flow){\n        if(now == t) return flow;\n        used[now] = true;\n        for(auto &e: es[now]){\n            if(!used[e.to] && e.cap > 0){\n                T f = dfs(e.to, t, min(flow, e.cap));\n                if(f > 0){\n                    e.cap -= f;\n                    es[e.to][e.rev].cap += f;\n                    return f;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T max_flow(int s, int t){\n        T flow = 0;\n        for(;;){\n            fill(all(used), false);\n            T f = dfs(s, t, INF_T);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nint main(){\n    while(true){\n        int N, M;\n        cin >> N >> M;\n        if(N == 0) break;\n        int b[N], r[M];\n        rep(i, N) cin >> b[i];\n        rep(i, M) cin >> r[i];\n        Max_Flow<int> G(N+M+2);\n        int s = N+M, t = N+M+1;\n        rep(i, N) G.add_edge(s, i, 1);\n        rep(i, M) G.add_edge(N+i, t, 1);\n        rep(i, N){\n            rep(j, M){\n                if(gcd(b[i], r[j]) > 1) G.add_edge(i, N+j, 1);\n            }\n        }\n        cout << G.max_flow(s, t) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int MAX_V = 100;\nconst int INF = 10000000;\n\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap)\n{\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f)\n{\n  if(v == t) return f;\n\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n\n  return 0;\n}\n\nint max_flow(int s, int t)\n{\n  int flow = 0;\n  for(;;){\n    fill(used, used + MAX_V, false);\n    int f = dfs(s, t, INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint gcd(int a, int b)\n{\n  int c;\n  if (a < b) {\n    a+=b; b=a-b; a-=b;\n  }\n  while (b != 0) {\n    c = a % b;\n    a = b;\n    b = c;\n  }\n  return a;\n}\n\nint main()\n{\n  int m, n;\n  cin >> m >> n;\n  int b[m], r[n];\n  for(int i = 0; i < m; i++)\n    cin >> b[i];\n  for(int i = 0; i < n; i++)\n    cin >> r[i];\n  for(int i = 0; i < m; i++){\n    for(int j = 0; j < n; j++){\n      if(gcd(b[i], r[j]) != 1){\n        add_edge(i+2, j+m+2, 1);\n      }\n    }\n  }\n  for(int i = 2; i < m + 2; i++)\n    add_edge(0, i, 1);\n  for(int i = m+2; i < m+n+2; i++)\n    add_edge(i, 1, 1);\n  cout << max_flow(0, 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nclass MaxFlow {\npublic:\n    typedef long long Int;\n    static const Int INF = 1LL << 60;\n    \n    struct edge{Int to, cap, rev;};\n    \n    Int N;\n    vector<vector<edge> > G;\n    vector<Int> level;\n    vector<Int> iter;\n    \n    MaxFlow(Int N) {\n        this->N = N;\n        G = vector<vector<edge> >(N);\n        level = vector<Int>(N);\n        iter = vector<Int>(N);\n    }\n    \n    void add_edge(Int from, Int to, Int cap) {\n        G[from].push_back((edge){to, cap, G[to].size()});\n        G[to].push_back((edge){from, 0, G[from].size() - 1});\n    }\n    \n    void bfs(Int s) {\n        fill(level.begin(), level.end(), -1);\n        queue<Int> que;\n        level[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            Int v = que.front(); que.pop();\n            for (Int i = 0; i < (Int)G[v].size(); i++) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    \n    Int dfs(Int v, Int t, Int f) {\n        if (v == t) return f;\n        for (Int &i = iter[v]; i < (Int)G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[v] < level[e.to]) {\n                Int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \n    Int run(Int s, Int t) {\n        Int flow = 0;\n        for (;;) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            fill(iter.begin(), iter.end(), 0);\n            Int f;\n            while((f = dfs(s, t, INF)) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n\nint main() {\n    int m, n;\n\n    while (cin >> m >> n, m) {\n        vector<int> b(m), r(n);\n\n        for (int i = 0; i < m; i++) {\n            cin >> b[i];\n        }\n\n        for (int i = 0; i < n; i++) {\n            cin >> r[i];\n        }\n\n        MaxFlow flow(m + n + 2);\n        int source = m + n, sink = m + n + 1;\n        for (int i = 0; i < m; i++) {\n            flow.add_edge(source, i, 1);\n        }\n\n        for (int i = 0; i < n; i++) {\n            flow.add_edge(m + i, sink, 1);\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (__gcd(b[i], r[j]) != 1) {\n                    flow.add_edge(i, m + j, 1);\n                }\n            }\n        }\n\n        cout << flow.run(source, sink) << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\n#define MAX_V 1010\n\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i];\n    int w=match[u];\n    if(w<0||!used[w]&&dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  //memset(match,-1,sizeof(match));\n  for(int i=0;i<=V;i++) match[i]=-1;\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      //memset(used,0,sizeof(used));\n      for(int j=0;j<=V;j++) used[j]=false;\n      if(dfs(v)) res++;\n    }\n  }\n  return res;\n}\n\nint N,M;\n\nint gcd(int x,int y){\n    return y==0?x:gcd(y,x%y);\n}\n\nvoid solve(){\n    vector<int> A(N);\n    vector<int> B(M);\n    for(int i=0;i<N;i++) cin>>A[i];\n    for(int i=0;i<M;i++) cin>>B[i];\n\n    for(int i=0;i<=N+M;i++){\n        used[i]=false;\n        G[i].clear();\n    }\n    V=N+M;\n\n    for(int i=0;i<N;i++){\n        for(int j=0;j<M;j++){\n            int z=gcd(A[i],B[j]);\n            if(z>1) add_edge(i,j+N);\n        }\n    }\n    cout<<bipartite_matching()<<endl;\n}\n\nint main(){\n  while (1){\n      cin>>N>>M;\n      if(N==0) break;\n      solve();\n  }\n  \n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data);\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for (const T &x : vec) os << x << \" \";\n    return os;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\n//const int dx[] = {-1, 0, 1, 0};\n//const int dy[] = {0, 1, 0, -1};\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n        T d = EXTGCD(-a, b, x, y);\n        x = -x;\n        return d;\n    }\n    if (b < 0) {\n        T d = EXTGCD(a, -b, x, y);\n        y = -y;\n        return d;\n    }\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    } else {\n        T d = EXTGCD(b, a % b, x, y);\n        T t = x;\n        x = y;\n        y = t - (a / b) * y;\n        return d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T) (SQR(i)) < b; i++) {\n        if (small[i]) {\n            for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n                prime[j - a] = false;\n            }\n        }\n    }\n\n    return prime;\n}\n\n//約数\ntemplate<class T>\n//vector<T> DIVISOR(T n) {\n//    vector<T> v;\n//    for (int i = 1; i * i <= n; ++i) {\n//        if (n % i == 0) {\n//            v.push_back(i);\n//            if (i != n / i) {\n//                v.push_back(n / i);\n//            }\n//        }\n//    }\n//    sort(v.begin(), v.end());\n//    return v;\n//}\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//組み合わせ個数\ntemplate<typename T>\nT NCR(T n, T r) {\n    T ans = 1;\n    REPLL(i, r) {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//行列\nint MATRIZ_CHAIN(VI &p, VVI &s) {\n    const static int INF = 1 << 20;\n    const int n = p.size() - 1;\n    VVI X(n, VI(n, INF));\n    s.resize(n, VI(n));\n    for (int i = 0; i < n; ++i) X[i][i] = 0;\n    for (int w = 1; w < n; ++w)\n        for (int i = 0, j; j = i + w, j < n; ++i)\n            for (int k = i; k < j; ++k) {\n                int f = p[i] * p[k + 1] * p[j + 1];\n                if (X[i][k] + X[k + 1][j] + f < X[i][j]) {\n                    X[i][j] = X[i][k] + X[k + 1][j] + f;\n                    s[i][j] = k;\n                }\n            }\n    return X[0][n - 1];\n}\n\n//最長増加部分列\nVI LIS(const VI &a) {\n    const static int INF = 99999999;\n    const int n = a.size();\n    VI A(n, INF);\n    VI id(n);\n    for (int i = 0; i < n; ++i) {\n        id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n        A[id[i]] = a[i];\n    }\n    int m = *max_element(id.begin(), id.end());\n    VI b(m + 1);\n    for (int i = n - 1; i >= 0; --i)\n        if (id[i] == m) b[m--] = a[i];\n    return b;\n}\n\n//最長共通部分列 string->toVC\ntemplate<typename T>\nvector<T> LCS(const vector<T> &a, const vector<T> &b) {\n    const int n = a.size(), m = b.size();\n    vector<VI> X(n + 1, VI(m + 1));\n    vector<VI> Y(n + 1, VI(m + 1));\n    REP(i, n) {\n        REP(j, m) {\n            if (a[i] == b[j]) {\n                X[i + 1][j + 1] = X[i][j] + 1;\n                Y[i + 1][j + 1] = 0;\n            } else if (X[i + 1][j] < X[i][j + 1]) {\n                X[i + 1][j + 1] = X[i][j + 1];\n                Y[i + 1][j + 1] = +1;\n            } else {\n                X[i + 1][j + 1] = X[i + 1][j];\n                Y[i + 1][j + 1] = -1;\n            }\n        }\n    }\n    vector<T> c;\n    for (int i = n, j = m; i > 0 && j > 0;) {\n        if (Y[i][j] > 0) --i;\n        else if (Y[i][j] < 0) --j;\n        else {\n            c.PB(a[i - 1]);\n            --i;\n            --j;\n        }\n    }\n    REVERSE(c);\n    return c;\n}\n\n//コイン C総額 cs使用できるコインの種類\nVI money_change(int C, VI &cs) {\n    const int INF = 99999999;\n    int n = cs.size();\n    VI xs(C + 1, INF);\n    VI ys(C + 1);\n    xs[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int c = 0; c + cs[i] <= C; ++c) {\n            if (xs[c + cs[i]] > xs[c] + 1) {\n                xs[c + cs[i]] = xs[c] + 1;\n                ys[c + cs[i]] = c;\n            }\n        }\n    }\n    VI zs;\n    for (int c = C; c > 0; c = ys[c]) {\n        zs.push_back(c - ys[c]);\n    }\n    return zs;\n}\n\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\n#define MAX_V 400\n#define INF (1<<20)\n\nstruct Edge {\n    int to;\n    int cap;\n    int rev;\n};\n\nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((Edge) {to, cap, (int) G[to].size()});\n    G[to].push_back((Edge) {from, 0, (int) G[from].size()});\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n\n    used[v] = true;\n\n    for (int i = 0; i < G[v].size(); i++) {\n        Edge &e = G[v][i];\n\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(e.cap, f));\n\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n\n        }\n\n    }\n\n\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (true) {\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0) {\n            return flow;\n        }\n        flow += f;\n    }\n}\n\n\nint main() {\n\n    while (true) {\n        int m, n;\n        cin >> m >> n;\n\n        if (m == 0 && n == 0) break;\n\n        for (int i = 0; i < MAX_V; i++) {\n            G[i] = vector<Edge>();\n        }\n\n        VI b(m);\n        for (int i = 0; i < m; i++) cin >> b[i];\n        VVI blueDivisor(m);\n        for (int i = 0; i < m; i++) blueDivisor[i] = DIVISOR(b[i]), blueDivisor[i].erase(blueDivisor[i].begin());\n\n        VI r(n);\n        for (int i = 0; i < n; i++) cin >> r[i];\n        VVI redDivisor(n);\n        for (int i = 0; i < n; i++) redDivisor[i] = DIVISOR(r[i]), redDivisor[i].erase(redDivisor[i].begin());\n\n        int s = 0;\n        int t = m + n + 1;\n\n        for (int i = 0; i < m; i++) {\n            add_edge(s, i + 1, 1);\n        }\n        for (int i = 0; i < n; i++) {\n            add_edge(i + m + 1, t, 1);\n        }\n\n        for (int i = 0; i < m; i++) {\n            VI blue = blueDivisor[i];\n            for (int j = 0; j < n; j++) {\n                VI red = redDivisor[j];\n                bool exist = false;\n                for (int k = 0; k < blue.size(); k++) {\n                    if (VECTOR_EXISTS(red, blue[k])) exist = true;\n                }\n                if (exist) {\n                    int left = s + i + 1;\n                    int right = s + j + m + 1;\n                    add_edge(left, right, 1);\n                }\n            }\n        }\n\n        int ans = max_flow(s, t);\n\n        OUT_L(ans);\n\n    }\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nclass MF{//max flow\n\tpublic:\n\tint n;\n\tvector<vector<edge> >G;//[MAX];\n\tvector<bool>used;//[MAX];\n\tMF(int size){\n\t\tn=size;\n\t\tG=vector<vector<edge> >(n);\n\t}\n\tvoid add_edge(int from, int to, int cap){\n\t\tedge q={to,cap,int(G[to].size())};\n\t\tG[from].push_back(q);\n\t\tq={from,0,int(G[from].size()-1)};\n\t\tG[to].push_back(q);\n\t}\n\tint dfs(int v,int t, int f) {\n\t\tif(v==t)return f;\n\t\tused[v]=1;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(used[e.to]||e.cap<=0) continue;\n\t\t\tint d =dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint mf(int s,int t) {//from s to t,ford_fulkerson\n\t\tint flow=0,f;\n\t\twhile(1){\n\t\t\tused=vector<bool>(n,false);\n\t\t\tf=dfs(s,t,inf);\n\t\t\tif(f==0)return flow;\n\t\t\tflow+=f;\n\t\t}\n\t}\n};\nll gcd(ll a,ll b){\n\treturn (b==0?a:gcd(b,a%b));\n}\nsigned main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tMF mf(n+m+2);\n\t\tint s=n+m,t=s+1;\n\t\trep(i,n)mf.add_edge(s,i,1);\n\t\trep(i,m)mf.add_edge(n+i,t,1);\n\t\tvi in1(n),in2(m);\n\t\trep(i,n)cin>>in1[i];\n\t\trep(i,m)cin>>in2[i];\n\t\trep(i,n)rep(j,m)if(gcd(in1[i],in2[j])-1)mf.add_edge(i,n+j,1);\n\t\tcout<<mf.mf(s,t)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n//Class.\nvector<int> list[100000];\nint N, M, E;\nint match[100000];\nbool used[100000];\nint x[10000], y[10000];\n\nbool DFS(int V) {\n\tused[V] = true;\n\tfor (int i = 0; i < list[V].size(); i++) {\n\t\tint u = list[V][i]; int w = match[u];\n\t\tif (w < 0 || !used[w] && DFS(w)) {\n\t\t\tmatch[V] = u;\n\t\t\tmatch[u] = V;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint supermatching() {\n\tint r = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int j = 0; j < N + M; j++) {\n\t\tif (match[j] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (DFS(j)) { r++; }\n\t\t}\n\t}\n\treturn r;\n}\n\n//main.\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> x[i];\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> y[i];\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (__gcd(N, M) != 1) {\n\t\t\t\tlist[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << supermatching() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <map>\n#include <ctime>\n#include <cstdlib>\n \nusing namespace std;\n \ntypedef long long lli;\ntypedef pair<lli, lli> P;\ntypedef vector<double> array;\ntypedef vector<array> matrix;\nconst double EPS = 1e-8;\n\nlli gcd(lli a, lli b){\n\treturn (b == 0 ? a : gcd(b, a%b));\n}\n \nlli rank(matrix &A){\n\tlli n = A.size();\n  lli res = 0;\n\tmatrix B(n, array(n+1,1));\n  for(lli i=0;i<n;i++) for(lli j=0;j<n;j++) B[i][j] = A[i][j];\n    \n  for(lli i=0;i<n;i++){\n    lli pivot = i;\n    for(lli j=i;j<n;j++){\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n    }\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i]) > EPS) res++;\n    if(abs(B[i][i]) > EPS){\n      for(lli j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n      for(lli j=0;j<n;j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tfor(lli k=i+1;k<=n;k++) B[j][k] -= B[j][i] * B[i][k];\n\t\t\t\t}\n      }\n    }\n  }\n  return res;\n}\n \nint main(){\n\tsrand((unsigned)time(NULL));\n\tlli n, m;\n\twhile(cin >> n >> m && (n|m)){\n\t\tvector<int> A(n), B(m);\n\t\tfor(int i=0;i<n;i++) cin >> A[i];\n\t\tfor(int i=0;i<m;i++) cin >> B[i];\n\t\tvector<P> edge;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(gcd(A[i], B[j]) > 1){\n\t\t\t\t\tedge.push_back(make_pair(i, n+j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlli ans = 0;\n\t\tfor(lli k=0;k<1;k++){\n\t\t\tmatrix A(n+m, array(n+m, 0));\n\t\t\tfor(lli i=0;i<edge.size();i++){\n\t\t\t\tlli tmp = rand() + 10;\n\t\t\t\tlli a = edge[i].first, b = edge[i].second;\n\t\t\t\tA[a][b] = tmp;\n\t\t\t\tA[b][a] = -tmp;\n\t\t\t}\n\t\t\tans = max(ans, rank(A) / 2);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef vector<int> Node;\ntypedef vector<Node> Graph;\nint V1, V2;\nGraph G;\nint dist[1002];\nint match[1002];\nconst int NIL = 1001;\nbool BFS(){\n  queue<int> que;\n  REP(v, V1){\n    if(match[v] == NIL){\n      dist[v] = 0;\n      que.push(v);\n    }else{\n      dist[v] = INF;\n    }\n  }\n  dist[NIL] = INF;\n  while(!que.empty()){\n    int v = que.front(); que.pop();\n    if(dist[v] < dist[NIL]){\n      for(int i = 0; i < G[v].size(); i++){\n        int u = G[v][i];\n        if(dist[match[u]] == INF){\n          dist[match[u]] = dist[v] + 1;\n          que.push(match[u]);\n        }\n      }\n    }\n  }\n  return dist[NIL] != INF;\n}\n\nbool DFS(int v){\n  if(v != NIL){\n    for(int i = 0; i < G[v].size(); i++){\n      int u = G[v][i];\n      if(dist[match[u]] == dist[v] + 1 && DFS(match[u])){\n        match[u] = v;\n        match[v] = u;\n        return true;\n      }\n    }\n    dist[v] = INF;\n    return false;\n  }\n  return true;\n}\n\nint Hopcroft_Karp(){\n  REP(v, G.size()) match[v] = NIL;\n  int matching = 0;\n  while(BFS()){\n    REP(v, V1){\n      if(match[v] == NIL && DFS(v)){\n        matching ++;\n      }\n    }\n  }\n  return matching;\n}\nint main(){\n  while(scanf(\"%d %d\", &V1, &V2) && (V1 != 0 || V2 != 0)){\n    G = Graph(V1 + V2);\n    static int blue[500];\n    static int red[500];\n    if(V1 < V2){\n      REP(i, V1) scanf(\"%d\", blue + i);\n      REP(i, V2) scanf(\"%d\", red + i);\n      REP(u, V1) REP(v, V2){\n        if(__gcd(blue[u], red[v]) != 1) {\n          G[u].push_back(V1 + v);\n          //G[V1 + v].push_back(u);\n        }\n      }\n    }else{\n      swap(V1, V2);\n      REP(i, V2) scanf(\"%d\", blue + i);\n      REP(i, V1) scanf(\"%d\", red + i);\n      REP(v, V2) REP(u, V1){\n        if(__gcd(blue[v], red[u]) != 1) {\n          G[u].push_back(V1 + v);\n          //G[V1 + v].push_back(u);\n        }\n      }\n    }\n    printf(\"%d\\n\", Hopcroft_Karp());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint e, v;\n\nclass pass\n{\npublic:\n\tint t;\n\tint c;\n\tint p;\n};\n\npass p[250000];\n\nint noded[1000];\npair<int, int> nodef[1000];\nvector<int> node[1000];\n\nvoid add(int f, int t, int c)\n{\n\tp[e].t = t;\n\tp[e].c = c;\n\tp[e].p = e + 1;\n\tp[e + 1].t = f;\n\tp[e + 1].c = 0;\n\tp[e + 1].p = e;\n\tnode[f].push_back(e);\n\tnode[t].push_back(e + 1);\n\te += 2;\n}\n\nvoid push()\n{\n\tpriority_queue<pair<int, int>> q;\n\tfor (int i = 0; i < v; i++)\n\t{\n\t\tnoded[i] = 0;\n\t\tnodef[i] = make_pair(0, 0);\n\t}\n\tnoded[0] = v;\n\tfor (auto i : node[0])\n\t{\n\t\tif (p[i].c > 0)\n\t\t{\n\t\t\tp[p[i].p].c += p[i].c;\n\t\t\tnodef[p[i].t].first += p[i].c;\n\t\t\tnodef[0].second += p[i].c;\n\t\t\tp[i].c = 0;\n\t\t\tq.push(make_pair(0, p[i].t));\n\t\t}\n\t}\n\tnodef[v - 1].second = (1 << 20);\n\twhile (!q.empty())\n\t{\n\t\tint np = q.top().second;\n\t\tq.pop();\n\t\twhile (1)\n\t\t{\n\t\t\tfor (auto i : node[np])\n\t\t\t{\n\t\t\t\tif (p[i].c > 0)\n\t\t\t\t{\n\t\t\t\t\tint t = p[i].t;\n\t\t\t\t\tif (noded[np] == noded[t] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tint kae = min(p[i].c, nodef[np].first - nodef[np].second);\n\t\t\t\t\t\tp[i].c -= kae;\n\t\t\t\t\t\tp[p[i].p].c += kae;\n\t\t\t\t\t\tnodef[np].second += kae;\n\t\t\t\t\t\tbool w = (nodef[t].first <= nodef[t].second);\n\t\t\t\t\t\tnodef[t].first += kae;\n\t\t\t\t\t\tif (w && nodef[t].first > nodef[t].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tq.push(make_pair(noded[t], t));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nodef[np].first <= nodef[np].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nodef[np].first > nodef[np].second && np != 0)\n\t\t\t{\n\t\t\t\tint minw = (1 << 20);\n\t\t\t\tfor (auto i : node[np])\n\t\t\t\t{\n\t\t\t\t\tif (p[i].c > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tminw = min(minw, noded[p[i].t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnoded[np] = minw + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dn[1000];\nint dm[1000];\n\nint gcd(int a, int b)\n{\n\tif (a % b == 0)\n\t{\n\t\treturn b;\n\t}\n\treturn gcd(b, a % b);\n}\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tint n, m;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tv = n + m + 2;\n\t\tfor (int i = 0; i < v; i++)\n\t\t{\n\t\t\tnode[i].clear();\n\t\t}\n\t\te = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &dn[i]);\n\t\t\tadd(0, 1 + i, 1);\n\t\t}\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &dm[i]);\n\t\t\tadd(n + 1 + i, n + m + 1, 1);\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int ii = 0; ii < m; ii++)\n\t\t\t{\n\t\t\t\tif (1 < gcd(dn[i], dm[ii]))\n\t\t\t\t{\n\t\t\t\t\tadd(1 + i, n + 1 + ii, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpush();\n\t\tint all = 0;\n\t\tfor (auto i : node[0])\n\t\t{\n\t\t\tif (i % 2 == 0)\n\t\t\t{\n\t\t\t\tall += p[p[i].p].c;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", all);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n\n#define MAX_L 50000\n#define MAX_R 50000\n#define MAX_E 150000\n\nusing namespace std;\n\nint n1,n2;//（左、右）の頂点数\nint edges;//辺の本数\nint last[MAX_L];\nint preve[MAX_E];\nint head[MAX_E];\nint match[MAX_R],dist[MAX_L],que[MAX_L];\n\nvoid init(int _n1, int _n2){\n  n1=_n1,n2=_n2,edges=0;\n  fill(last,last+n1,-1);\n}\n\nvoid add_edge(int u, int v){\n  head[edges]=v;\n  preve[edges]=last[u];\n  last[u]=edges++;\n}\n\nbool used[MAX_L];\n\nvoid bfs(){\n  fill(dist,dist+n1,-1);\n  int sz=0;\n  for(int u=0;u<n1;u++)\n    if(!used[u])que[sz++]=u,dist[u]=0;\n \n  for(int i=0;i<sz;i++){\n    int u1=que[i];\n    for(int e=last[u1];e>=0;e=preve[e]){\n      int u2=match[head[e]];\n      if(u2>=0 && dist[u2]<0){\n\tdist[u2]=dist[u1]+1;\n\tque[sz++]=u2;\n      }\n    }\n  }\n}\n\nbool vis[MAX_L];\n\nbool dfs(int u1){\n  vis[u1]=true;\n  for(int e=last[u1];e>=0;e=preve[e]){\n    int v=head[e],u2=match[v];\n    if(u2<0 || (!vis[u2] && dist[u2]==dist[u1]+1 && dfs(u2))){\n      match[v]=u1;\n      return used[u1]=true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  fill(used,used+n1,false);\n  fill(match,match+n2,-1);\n  int flow=0;\n  for(;;){\n    bfs();\n    fill(vis,vis+n1,false);\n    int f=0;\n    for(int u=0;u<n1;u++)\n      if(!used[u] && dfs(u))f++;\n    \n    if(!f)return flow;\n    flow+=f;\n  }\n}\n\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\n\nint main(void){\n  \n  int m,n;\n  \n  while(cin >> m >> n,m|n){\n \n    init(m,n);\n    \n    vector<int>b(m),r(n);\n    for(int i=0;i<m;i++)cin >> b[i];\n    for(int i=0;i<n;i++)cin >> r[i];\n    \n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n\tif(gcd(b[i],r[j])!=1)add_edge(i,j);\n      }\n    }\n\n    cout << bipartite_matching() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass pass\n{\npublic:\n\tll t;\n\tll c;\n\tll p;\n};\n\nclass dinic\n{\nprivate:\n\tll v, e;\n\n\tpass* p;\n\n\tvector<pair<ll, ll>>* node;\n\n\tll* jun;\n\n\tvoid bfs()\n\t{\n\t\tqueue<ll> q;\n\t\tstack<ll> st;\n\t\tfor (ll i = 0; i < v; i++)\n\t\t{\n\t\t\tjun[i] = -1;\n\t\t}\n\t\tq.push(0);\n\t\tjun[0] = 0;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tll np = q.front();\n\t\t\tq.pop();\n\t\t\tst.push(np);\n\t\t\tfor (int i = 1; i < node[np].size(); i++)\n\t\t\t{\n\t\t\t\tll w = node[np][i].second;\n\t\t\t\tif (p[w].c > 0 && jun[p[w].t] < 0)\n\t\t\t\t{\n\t\t\t\t\tq.push(p[w].t);\n\t\t\t\t\tjun[p[w].t] = jun[np] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!st.empty())\n\t\t{\n\t\t\tll np = st.top();\n\t\t\tst.pop();\n\t\t\tll mae = 0;\n\t\t\tfor (ll i = 1; i < node[np].size(); i++)\n\t\t\t{\n\t\t\t\tll w = node[np][i].second;\n\t\t\t\tif (p[w].c > 0 && jun[p[w].t] == jun[np] + 1 && (p[w].t == v - 1 || node[p[w].t][0].first > 0))\n\t\t\t\t{\n\t\t\t\t\tnode[np][mae].first = i;\n\t\t\t\t\tmae = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnode[np][mae].first = -1;\n\t\t}\n\t}\n\n\tpair<bool, ll> dfs(ll n, ll s)\n\t{\n\t\tif (n == v - 1)\n\t\t{\n\t\t\treturn make_pair(false, s);\n\t\t}\n\t\tll mae = 0;\n\t\tll now = node[n][0].first;\n\t\tll all = 0;\n\t\twhile (now > 0 && s - all > 0)\n\t\t{\n\t\t\tll w = node[n][now].second;\n\t\t\tauto r = dfs(p[w].t, min(p[w].c, s - all));\n\t\t\tp[p[w].p].c += r.second;\n\t\t\tp[w].c -= r.second;\n\t\t\tall += r.second;\n\t\t\tif (p[w].c == 0)\n\t\t\t{\n\t\t\t\tr.first = true;\n\t\t\t}\n\t\t\tif (r.first)\n\t\t\t{\n\t\t\t\tnode[n][mae].first = node[n][now].first;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmae = now;\n\t\t\t}\n\t\t\tnow = node[n][now].first;\n\t\t}\n\t\tnode[n][mae].first = -1;\n\t\tif (mae == 0)\n\t\t{\n\t\t\treturn make_pair(true, all);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn make_pair(false, all);\n\t\t}\n\t}\npublic:\n\tvoid set(ll vw, ll ew)\n\t{\n\t\tv = vw;\n\t\tp = new pass[ew * 2];\n\t\tnode = new vector<pair<ll, ll>>[v];\n\t\tjun = new ll[v];\n\t\te = 0;\n\t\tfor (ll i = 0; i < v; i++)\n\t\t{\n\t\t\tnode[i].push_back(make_pair(0, 0));\n\t\t}\n\t}\n\n\tvoid add(ll f, ll t, ll c)\n\t{\n\t\tp[e].t = t;\n\t\tp[e].c = c;\n\t\tp[e].p = e + 1;\n\t\tp[e + 1].t = f;\n\t\tp[e + 1].c = 0;\n\t\tp[e + 1].p = e;\n\t\tnode[f].push_back(make_pair(0, e));\n\t\tnode[t].push_back(make_pair(0, e + 1));\n\t\te += 2;\n\t}\n\n\tll solve()\n\t{\n\t\twhile (1)\n\t\t{\n\t\t\tbfs();\n\t\t\tif (node[0][0].first < 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdfs(0, ((ll)1 << 50));\n\t\t}\n\t\tll all = 0;\n\t\tfor (int i = 1; i < node[0].size(); i++)\n\t\t{\n\t\t\tauto w = node[0][i];\n\t\t\tif (w.second % 2 == 0)\n\t\t\t{\n\t\t\t\tall += p[p[w.second].p].c;\n\t\t\t}\n\t\t}\n\t\treturn all;\n\t}\n\n\tvoid del()\n\t{\n\t\tdelete[] p;\n\t\tdelete[] node;\n\t\tdelete[] jun;\n\t}\n};\n\nll dn[2000];\nll dm[2000];\n\nll gcd(ll a, ll b)\n{\n\tif (a % b == 0)\n\t{\n\t\treturn b;\n\t}\n\treturn gcd(b, a % b);\n}\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tdinic a;\n\t\tll n, m;\n\t\tscanf(\"%lld%lld\", &n, &m);\n\t\tif (n == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\ta.set(n + m + 2, n * m * 2);\n\t\tfor (ll i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%lld\", &dn[i]);\n\t\t\ta.add(0, 1 + i, 1);\n\t\t}\n\t\tfor (ll i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%lld\", &dm[i]);\n\t\t\ta.add(n + 1 + i, n + m + 1, 1);\n\t\t}\n\t\tfor (ll i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (ll ii = 0; ii < m; ii++)\n\t\t\t{\n\t\t\t\tif (1 < gcd(dn[i], dm[ii]))\n\t\t\t\t{\n\t\t\t\t\ta.add(1 + i, n + 1 + ii, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", a.solve());\n\t\ta.del();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst int64_t LINF=8931145141919364364,LMOD=998244353;\n// const int dx[]={1,0,-1,0,1,1,-1,-1},dy[]={0,-1,0,1,1,-1,-1,1};\n\ntemplate<typename T>\nstruct Dinic {\n    struct Edge {\n        int to, cap, rev;\n    };\n    const int V;\n    static constexpr T INF = numeric_limits<T>::max();\n    // graph[from][num] := fromから出るnum番目の辺\n    vector<vector<Edge>> graph;\n    Dinic(const int V) :\n        V(V)\n        {\n            graph.resize(V);\n        }\n    void addEdge(const int from, const int to, const int cap) {\n        graph[from].emplace_back((Edge){to, cap, (int)graph[to].size()});\n        graph[to].emplace_back((Edge){from, 0, (int)graph[from].size() - 1});\n    }\n    T flow(const int start, const int goal) {\n        T ans = 0;\n        vector<int> level(V);\n        while(bfs(start, goal, level)) {\n            vector<int> checked(V);\n            while(true) {\n                T fmax = dfs(start, goal, level, checked, INF);\n                if(fmax <= 0) break;\n                ans += fmax;\n            }\n        }\n        return ans;\n    }\n    bool bfs(const int start, const int goal, vector<int> &level) {\n        for(int i = 0; i < V; ++i) level[i] = -1;\n        queue<int> que;\n        level[start] = 0;\n        que.push(start);\n        while(que.size() and level[goal] == -1) {\n            int from = que.front();\n            que.pop();\n            for(Edge e : graph[from]) {\n                if(e.cap > 0 and level[e.to] == -1) {\n                    level[e.to] = level[from] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n        return level[goal] != -1;\n    }\n    T dfs(const int from, const int goal, vector<int> &level, vector<int> &checked, T fmax) {\n        if(from == goal) return fmax;\n        for(int &id = checked[from]; id < (int)graph[from].size(); ++id) {\n            Edge &e = graph[from][id];\n            if(level[e.to] <= level[from]) continue;\n            if(e.cap <= 0) continue;\n            T f = dfs(e.to, goal, level, checked, min(e.cap, fmax));\n            if(f <= 0) continue;\n            e.cap -= f;\n            graph[e.to][e.rev].cap += f;\n            return f;\n        }\n        return 0;\n    }\n};\n\nint main() {\n    int m, n;\n    while(cin>>m>>n&&m>0){\n        int b[m]; rep(i,m) cin>>b[i];\n        int r[n]; rep(i,n) cin>>r[i];\n        int V = m + n + 2;\n        const int start = m + n;\n        const int goal = start + 1;\n        Dinic<int> dinic(V);\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(__gcd(b[i],r[j])!=1){\n                    dinic.addEdge(i, m+j, 1);\n                }\n            }\n        }\n        for(int i=0;i<m;i++) dinic.addEdge(start, i, 1);\n        for(int j=0;j<n;j++) dinic.addEdge(m+j, goal, 1);\n        cout << dinic.flow(start, goal) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define M_MAX 500\n#include <functional>\nusing namespace std;\n\nint m, n;\nint b[M_MAX], r[M_MAX];\n\nbool G[M_MAX][M_MAX];\n\nint gcd(int a, int b) {\n  if(b == 0) return a;\n  return gcd(b, a%b);\n}\n\nvoid make() {\n  for(int i = 0; i < m; ++i) {\n    for(int j = 0; j < n; ++j) {\n      if(gcd(b[i], r[j]) == 1) G[i][j] = false;\n      else                     G[i][j] = true;\n    }\n  }\n}\n\nbool isUsedR[M_MAX];\n\nint maxa;\nbool flag;\nint d;\n\nint rec(int pb, int a) {\n  if(pb == m) {\n    maxa = max(maxa, a);\n    flag = true;\n    return 0;\n  }\n\n  for(int j = 0; j < n; ++j) {\n    if(isUsedR[j]) continue;\n    if(G[(pb+d)%m][j]) {\n      isUsedR[j] = true;\n      rec(pb+1, a+1);\n      isUsedR[j] = false;\n      if(flag) return 0;\n    }\n  }\n  rec(pb+1, a);\n  return 0;\n}\n\nvoid solve() {\n  sort(b, b+m, greater<int>());\n  sort(r, r+n);\n  make();\n  maxa = 0;\n  for(d = 0; d < m; ++d) {\n    fill(isUsedR, isUsedR + n, false);\n    flag = false; rec(0,0);\n  }\n  cout << maxa << endl;\n}\n\nmain() {\n  while((cin >> m >> n) && (m || n)) {\n    if(m > n) {\n      for(int i = 0; i < m; ++i) cin >> r[i];\n      for(int i = 0; i < n; ++i) cin >> b[i];\n      swap(m, n);\n    } else {\n      for(int i = 0; i < m; ++i) cin >> b[i];\n      for(int i = 0; i < n; ++i) cin >> r[i];\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define fi first\n#define se second\n// #define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1e9;\n\n//?????§?????????\nconst int MAX_N = 510, MAX_K = 510;\nconst int MAX_V = 510 * 510;\n\nstruct edge{\n    int to, cap, rev;\n};\n\n// vector<edge> G[MAX_N];\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\n//?????¨??????????????°\nint N, K;\nbool can[MAX_N][MAX_K];\n\nint solve(){\n    int s = N + K, t = s + 1;\n    for(int i = 0; i < N; i++){\n        add_edge(s, i, 1);\n    }\n    for(int i = 0; i < K; i++){\n        add_edge(N + i, t, 1);\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < K; j++){\n            if(can[i][j]){\n                add_edge(i, N + j, 1);\n            }\n        }\n    }\n    return max_flow(s, t);\n}\n\nsigned main(){\n    int m, n;\n    while(cin >> m >> n, m + n){\n        memset(can, 0, sizeof(can));\n        rep(i, 0, MAX_V) G[i].clear(), used[i] = false;\n        vector<int> b(m), r(n);\n        rep(i, 0, m) cin >> b[i];\n        rep(i, 0, n) cin >> r[i];\n        N = m; K = n;\n        set<int> bs[510], rs[510];\n        rep(i, 0, m){\n            for(int j = 2; j * j <= b[i]; j++){\n                if(b[i] % j == 0) bs[i].insert(j);\n                while(b[i] % j == 0){\n                    b[i] /= j;\n                }\n            }\n            if(b[i] != 1) bs[i].insert(b[i]);\n        }\n        rep(i, 0, n){\n            for(int j = 2; j * j <= r[i]; j++){\n               if(r[i] % j == 0) rs[i].insert(j);\n                while(r[i] % j == 0){\n                    r[i] /= j;\n                }\n            }\n            if(r[i] != 1) rs[i].insert(r[i]);\n        }\n        \n        rep(i, 0, m){\n            rep(j, 0, n){\n                for(auto& k : bs[i]){\n                    if(rs[j].count(k)){\n                        can[i][j] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        \n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#define int long long\n#define loop(i, a, b) for(int i = a; i < b; i++)\n#define rep(i, a) loop(i, 0, a)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\nconst int MOD = 1e9 + 7, INF = 1e9;\nusing vi = vector <int>;\nusing vvi = vector <vi>;\n//g++ -std==c++14 \n#define MAX_V (1100)\n\nstruct edge{int to, cap, rev; };\n\nvector <edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f){\n    if(v == t)return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n} \n\nint gcd(int a, int b){\n\treturn (b == 0 ? a : gcd(b, a % b));\n}\n\nsigned main(){\n    int m ,n;\n    while(cin >> m >> n, n){\n        int b[m], r[n];\n        rep(i, MAX_V){\n            G[i].clear();\n            used[i] = false;\n        }\n        rep(i, m)\n            cin >> b[i];\n        rep(i, n)\n            cin >> r[i];\n        rep(i, m)rep(j, n)\n            if(gcd(b[i], r[j]) != 1)\n                add_edge(i, j + m, 1);\n        rep(i, m)\n            add_edge(n + m, i, 1);\n        rep(i, n)\n            add_edge(m + i, n + m + 1, 1);\n        cout << max_flow(n + m, m + n + 1) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nvector<int> blue,red,redpair,v;\nvector<vector<int>>c;\n/*blue[i]??§i?????????????????????????????°???,red[i]??§i?????????????????????????????°???,redpair[i]??§i??????????????????????????¨?????¢????????????????????????????????????????????????,v[i]??§i??????????????????????????????????????????????????????(1:?????????0:??????)\nc[i][j]??§blue[i]??¨red[j]????????¢?????§???????????¨???*/\nint m=0,n=0;\n\nint gcd(int x,int y){\n\tif(x%y==0){return y;}\n\treturn gcd(y,x%y);\n}\n\nbool match(int x){\n\tif(x==-1)return 1;\n\tfor(int i=0;i<n;i++){\n\t\tif(c[x][i]==1 && v[i]==0){\n\t\t\tv[i]=1;\n\t\t\tif(match(redpair[i])){\n\t\t\t\tredpair[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(cin>>m>>n){\n\t\tif(m==0 && n==0){break;}\n\t\tblue.clear();\n\t\tred.clear();\n\t\tredpair.clear();\n\t\tv.clear();\n\t\tc.clear();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint tmp=0;\n\t\t\tcin>>tmp;\n\t\t\tblue.push_back(tmp);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmp=0;\n\t\t\tcin>>tmp;\n\t\t\tred.push_back(tmp);\n\t\t\tredpair.push_back(-1);//-1??§?????¢??????????????¶????????¨???\n\t\t\tv.push_back(0);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tc.push_back(vector<int>());\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tc[i].push_back(gcd(blue[i],red[j])!=1);\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tv[j]=0;\n\t\t\t}\n\t\t\tif(match(i)){ans++;}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct edge{\n\tint to, cap, rev;\n\tedge(int a, int b, int c){\n\t\tto = a, cap = b, rev = c;\n\t}\n};\n\nint V, S, T;\nint m, n;\nint b[505], r[505];\nvector<edge> G[1005];\nbool used[1005];\n\nvoid addedge(int s, int t)\n{\n\tG[s].push_back( edge(t, 1, G[t].size()) );\n\tG[t].push_back( edge(s, 0, G[s].size() - 1) );\n}\n\nint gcd(int a, int b)\n{\n\tif(b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\nint dfs(int v, int t, int c)\n{\n\tif(v == t) return c;\n\tused[v] = true;\n\t\n\tint ret;\n\tfor(int i = 0; i < (int)G[v].size(); i++){\n\t\tif(used[G[v][i].to] || G[v][i].cap == 0) continue;\n\t\tret = dfs(G[v][i].to, t, min(c, G[v][i].cap));\n\t\tif(ret > 0){\n\t\t\tG[v][i].cap -= ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap += ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> m >> n;\n\t\tif(m == 0 && n == 0) break;\n\t\tV = m + n;\n\t\tS = 0, T = V+1;\n\t\t\n\t\tfor(int i = 1; i <= m; i++) cin >> b[i];\n\t\tfor(int i = 1; i <= n; i++) cin >> r[i];\n\t\t\n\t\tfor(int i = 0; i <= T; i++) G[i].clear();\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\taddedge(S, i); \n\t\t\taddedge(i, S); \n\t\t}\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\taddedge(m+i, T);\n\t\t\taddedge(T, m+i);\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tif(gcd(b[i], r[j]) == 1) continue;\n\t\t\t\taddedge(i, m+j);\n\t\t\t\taddedge(m+j, i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret, ans = 0;\n\t\twhile(1){\n\t\t\tfor(int i = 0; i <= T; i++) used[i] = false;\n\t\t\tret = dfs(S, T, inf);\n\t\t\tif(ret == 0) break;\n\t\t\tans += ret;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 1000\n#define MAX_N 1000\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});  \n}\n\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nint N,K;\nbool can[MAX_N][MAX_N]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(){\n  //0??????N-1: ???????????\\???????????????????????????\n  //N??????N+K-1: ???????????????????????????\n  int s = N+K, t = s+1;\n  \n  //s??¨???????????\\??????????????¶\n  for(int i=0; i<N; i++) add_edge(s,i,1);\n  \n  //????????¨t?????????\n  for(int i=0; i<K; i++) add_edge(N+i,t,1);\n  \n  //???????????\\????????¨??????????????¶\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)\n      if(can[i][j]) add_edge(i, N+j , 1);\n\n  return max_flow(s,t);\n}\n\nint main(){\n  while(1){\n  int b,r,B[501],R[501];\n  cin>>b>>r;\n  if(!b&&!r)break;\n  for(int i=0;i<b;i++) cin>>B[i];\n  for(int i=0;i<r;i++) cin>>R[i];\n\n  memset(can,0,sizeof(can));\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n  N=b,K=r;\n  for(int i=0;i<b;i++)\n    for(int j=0;j<r;j++)\n      if(__gcd(B[i],R[j])>1) can[i][j]=1;\n\n  cout<<Biparite_Matching()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nstruct edge\n{\n  int to;\n  int from;\n  int cap;\n  int rev;\n};\n\nint s=0, t;\nbool visited[1000];\nvector<edge> g[1000];\nint red_card[500], blue_card[500];\n\nint max_flow();\nint get_card();\nvoid print_g();\nint dfs(int node, int f);\n\nint main()\n{\n  while(true)\n    {\n      if(get_card()==-1)\n\t{\n\t  break;\n\t}\n  cout << max_flow() << endl;\n  //print_g();\n    }\n  return 0;\n}\n  \nvoid print_g()\n{\n  for(int i=0;i<=t;i++)\n    {\n      for(int j=0;j<g[i].size();j++)\n\t{\n\t  if(g[i][j].cap!=0)\n\t    {\n\t  cout << \"{\" << g[i][j].from << g[i][j].to << g[i][j].cap << g[i][j].rev << \"}\";\n\t    }\n\t}\n      cout << endl;\n    }\n}\n\nint max_flow()\n{\n  int sum = 0, f=0;\n  \n  while(1)\n    {\n      fill(visited ,visited+1000, false);\n      f = dfs(s, INT_MAX/3);\n      \n      if(f==0)\n\t{\n\t  break;\n\t}\n      sum += f;\n    }\n  return sum;\n}\n\n\nint dfs(int node, int f)\n{\n  //  cout << \"node:\" <<node << \" f:\" << f;\n  int d = 0;\n \n  if(node == t)//goal\n    {\n      //  cout <<\"f:\"<< f << endl;\n      return f;\n    }\n  else if(visited[node]==true)// if visited\n    {\n      return -1;\n    }\n  else\n    {\n      visited[node]=true;//visited\n    }\n\n  for(int i=0;i<g[node].size();i++)//root form node\n    {\n      edge& e = g[node][i];\n      // cout <<\" e,to:\"  <<e.to <<endl;\n      if(e.cap != 0)\n\t{\n\t  d = dfs(e.to, min(f, e.cap));\n\t  /*if(dfs(g[node][i].to, f) == 1)\n\t    {\n\t    return 1;\n\t    }*/\n\t  //   cout << \"node:\" << node << \" f:\" << f << \" d:\" << d << endl;      \n\t  if(d>0)\n\t    {\n\t      e.cap -= d;\n\t      g[e.to][e.rev].cap += d;\n\t      \n\t      return d;\n\t    }\n\t}\n\n    }\n  return 0;\n}\n\n\nvoid add_edge(int i, int j)\n{\n  g[i].push_back({j, i, 1, (int)g[j].size()});\n  g[j].push_back({i, j, 0, (int)g[i].size()-1});\n}\n\nint get_card()\n{\n  int red, blue;\n  cin >> blue >> red;\n  if(blue == 0)\n    {\n      return -1;\n    }\n  for(int i=0;i<blue;i++)\n    {\n      cin >> blue_card[i];\n    }\n  for(int i=0;i<red;i++)\n    {\n      cin >> red_card[i];\n    }\n  \n  \n  for(int i=0;i<blue;i++)\n    {\n      for(int j=0;j<red;j++)\n\t{\n\t  if(__gcd(blue_card[i], red_card[j])!=1)\n\t    {// to from cap rev\n\t      add_edge(i+1, j+blue+1);\n\t      //g[i+1].push_back({j+blue+1, i+1, 1,(int)g[j+1].size()});\n\t      //g[j+1].push_back({i+1, j+blue+1, 0, (int)g[i+1].size()-1});\n\t    }\n\t}\n    }\n\n   for(int i=1;i<=blue;i++)\n    {\n      add_edge(0, i);\n      //g[0].push_back({i, 0, 1, (int)g[i].size()});\n      //g[i].push_back({0, i, 0, (int)g[0].size()-1});\n    }\n\n   t = blue+red+1;\n   for(int i=blue+1;i<t;i++)\n     {\n       add_edge(i, t);\n       //g[i].push_back({t, i, 1, (int)g[t].size()});\n       // g[t].push_back({i, t, 0, (int)g[i].size()-1});\n     }\n\n   /*  for(int i=0;i<=t;i++)\n    {\n      for(int j=0;j<g[i].size();j++)\n\t{\n\t  cout << \"{\" << g[i][j].from << g[i][j].to << g[i][j].cap << g[i][j].rev << \"}\";\n\t}\n      cout << endl;\n    }\n   */return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nstruct Bipartite_Matching\n{\n  vector< vector< int > > graph;\n  vector< int > dist, match;\n  vector< bool > used, vv;\n\n  Bipartite_Matching(int n, int m)\n  {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, false);\n  }\n\n  void add_edge(int u, int v)\n  {\n    graph[u].push_back(v);\n  }\n\n  void bfs()\n  {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a)\n  {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching()\n  {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nint dp[1000][1000];\n\nint gcd(int x, int y)\n{\n  if(x < 1000) {\n    if(~dp[x][y]) return (dp[x][y]);\n    int r = x % y;\n    if(r == 0) return dp[x][y] = y;\n    return dp[x][y] = gcd(y, r);\n  } else {\n    int r = x % y;\n    if(r == 0) return y;\n    return gcd(y, r);\n  }\n}\n\nint main()\n{\n  memset(dp, -1, sizeof(dp));\n\n  int M, N, B[500], R[500];\n  while(scanf(\"%d %d\", &M, &N), M) {\n    Bipartite_Matching flow(M, N);\n    for(int i = 0; i < M; i++) scanf(\"%d\", &B[i]);\n    for(int i = 0; i < N; i++) scanf(\"%d\", &R[i]);\n    for(int i = 0; i < M; i++) {\n      for(int j = 0; j < N; j++) {\n        if(gcd(min(B[i], R[j]), max(B[i], R[j])) > 1) flow.add_edge(i, j);\n      }\n    }\n    printf(\"%d\\n\", flow.bipartite_matching());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#define MAX_V 500*500+1\n#define INF 501\n\nusing namespace std;\n\n\n\nstruct edge{int to,cap,rev;};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f=dfs(s,t,INF);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint lcm(int m,int n){\n  int tmp;\n  while (m % n != 0)\n    {\n      tmp = n;\n      n = m % n;\n      m = tmp;\n    }\n  return n;\n}\n\n\n\nint main()\n{\n  for(;;){\n    for(int i=0;i<MAX_V;i++){\n      G[i].clear();\n    }\n    int m,n;\n    cin >> m >> n;\n    if(m==0)return 0;\n    int br[m+n];\n    for(int i=0;i<m+n;i++)cin >> br[i];\n\n    for(int i=0;i<m;i++){\n      for(int j=m;j<m+n;j++){\n\t//cout << br[i] << \",\" << br[j]<< \";\" << lcm(br[i],br[j]) <<endl;\n\tif(lcm(br[i],br[j])!=1){\n\t  add_edge(i,j,1);\n\t}\n      }\n    }\n    for(int i=0;i<m;i++)\n      add_edge(n+m+1,i,1);\n \n    for(int i=0;i<n;i++)\n      add_edge(m+i,n+m+2,1);\n\n    cout << max_flow(n+m+1,n+m+2) << endl;\n  }\n}\n\n      "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define INF 100000000\n \nusing namespace std;\n\nint gcd(int a,int b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\n \nint V,match[501];\nbool used[501];\nvector<int>G[501];\n \nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n \nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n \nint bipartite_matching(){\n  int res=0;\n  fill(match,match+501,-1);\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      fill(used,used+501,false);\n      if(dfs(v))res++;\n    }\n  }\n  return res;\n}\n \nint main(void){\n\t\n\tint m,n;\n\t\n\twhile(cin >> m >> n,m|n){\n\t\tvector<int>b(m),r(n);\n\t\tfor(int i=0;i<501;i++)G[i].clear();\n\t\t\n\t\tfor(int i=0;i<m;i++)cin >> b[i];\n\t\tfor(int i=0;i<n;i++)cin >> r[i];\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(gcd(b[i],r[j])!=1)add_edge(i,j+m);\n\t\t\t}\n\t\t}\n\t\tV=max(m,n);\n\t\tcout << bipartite_matching() << endl;\n\t}\n\t\nreturn 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n//Ford-Fulkerson's algorithm\nstruct edge{int to,cap,rev;};\nconst int INF=1e9;\n\nvoid addEdge(vector<vector<edge> > &g,int from,int to,int cap){\n    g[from].push_back((edge){to,cap,(int)g[to].size()});\n    g[to].push_back((edge){from,0,(int)g[from].size()-1});\n}\n\nint dfs(vector<vector<edge> > &g,vector<bool> &used,int v,int t,int f){\n    if(v==t) return f;\n    used[v]=true;\n    for(int i=0;i<(int)g[v].size();i++){\n        edge& e=g[v][i];\n        if(!used[e.to] && e.cap>0){\n            int d=dfs(g,used,e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                g[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint FordFulkerson(vector<vector<edge> > &g,int s,int t){\n    int flow=0;\n    for(;;){\n        vector<bool> used(g.size(),false);\n        int f=dfs(g,used,s,t,INF);\n        if(f==0) return flow;\n        flow+=f;\n    }\n}\n//\n\nint main() {\n\tint m, n;\n\twhile ( cin >> m >> n, m || n ) {\n\t\tvector<int> a(m);\n\t\tvector<int> b(n);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tcin >> a[i];\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tcin >> b[i];\n\t\t}\n\n\t\tint N = m + n + 2;\n\t\tint s = m + n, t = m + n + 1;\n\t\tvector< vector<edge> > g(N);\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\taddEdge(g, s, i, 1);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\taddEdge(g, m+i, t, 1);\n\t\t}\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tint A = a[i], B = b[j];\n\t\t\t\tfor (int k = 2; k <= min(A, B); ++k) {\n\t\t\t\t\tif (A % k == 0 && B % k == 0) {\n\t\t\t\t\t\taddEdge(g, i, m+j, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = FordFulkerson(g, s, t);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n#define SET(a,c) memset(a,c,sizeof(a))\n\n#define DEBUG(x) cout<<\"#x\"<<\": \"<<x<<endl\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nconst ll INF = INT_MAX/3;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-14;\nconst int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n\nstruct edge{ int to;int cap;int rev; };\ntypedef struct edge edge;\n\nint m,n;\n\nvector<edge> G[502];\nint used[250002];\n\nvoid add_edge(int from,int to){\n    G[from].PB( (edge){to,1,(int)G[to].size()} );\n    G[to].PB( (edge){from,0,(int)G[to].size()-1} );\n}\n\nint dfs(int v,int t,int f){\n    if( v == t) return f;\n    used[v] = true;\n    REP(i,G[v].size()){\n\tedge &e = G[v][i];\n\tif(!used[e.to] && e.cap > 0){\n\t    int d = dfs(e.to,t,min(f,e.cap));\n\t    if(d > 0){\n\t\te.cap -= d;\n\t\tG[e.to][e.rev].cap += d;\n\t\treturn d;\n\t    }\n\t}\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int flow = 0;\n    while(true){\n\tSET(used,false);\n\tint f = dfs(s,t,INF);\n\tif(f == 0)return flow;\n\tflow += f;\n    }\n    return -1;\n}\n\nint gcd(int a,int b){ return a % b == 0 ? b : gcd(b,a%b); }\n\nint main(){\n\n    while(true){\n\tm,n;\n\tcin >> m >> n;\n\tif(m == 0 && n == 0) break;\n\tREP(i,502) G[i].clear();\n\tSET(used,false);\n\tint a[501],b[501];\n\tREP(i,m) {\n\t    cin >> a[i];\n\t    add_edge(0,i+1);\n\t}\n\tREP(i,n) {\n\t    cin >> b[i];\n\t    add_edge(i+1+m,n+m+1);\n\t}\n\tREP(i,m){\n\t    REP(j,n){\n\t\tif(gcd(a[i],b[j]) > 1){\n\t\t    add_edge(i+1,m+j+1);\n\t\t}\n\t    }\n\t}\n\tcout << max_flow(0,n+m+1) << endl;;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#define SIZE 1000\n\nusing namespace std;\n\nint m, n, b[501], r[501];\nint match[SIZE];\nbool used[SIZE];\nvector<int> G[SIZE];\n\nbool dfs(int v){\n\tused[v]=1;\n\tfor(int i=0; i<G[v].size(); i++){\n\t\tint u=G[v][i], w=match[u];\n\t\tif(w<0||!used[w]&&dfs(w)){\n\t\t\tmatch[v]=u, match[u]=v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid solve(){\n\tint res=0;\n\tmemset(match, -1, sizeof(match));\n\tfor(int v=0; v<m+n; v++){\n\t\tif(match[v]<0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif(dfs(v)) res++;\n\t\t}\n\t}\n\tcout<<res<<endl;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n && !m) break;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> b[i];\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcin >> r[i];\n\t\t}\n\t\tfor(int i=0; i<SIZE; i++) G[i].clear();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tint a=b[i], c=r[j];\n\t\t\t\twhile(c){\n\t\t\t\t\ta%=c;\n\t\t\t\t\tswap(a, c);\n\t\t\t\t}\n\t\t\t\tif(a!=1)G[i].push_back(j+n), G[n+j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include <map>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string.h>\n#include\"time.h\"\nusing namespace std;\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n\n/*\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tFlow cap;\n\tEdge() : src(0), dst(0), weight(0) {}\n\tEdge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n\tg[a].emplace_back(a, b, w);\n\tg[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\n*/\n\nclass bipartite_matching {\npublic:\n\tint n;\n\tstd::vector<std::vector<int>> g;\n\tstd::vector<int> match;\n\n\tbipartite_matching(int n_) : n(n_), g(n_), match(n_), used(n_) {}\n\n\tvoid add_edge(int u, int v) {\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\n\tint maximum_matching(void) {\n\t\tint res = 0;\n\t\tfill(begin(match), end(match), -1);\n\t\tfor (int v = 0; v < n; ++v) {\n\t\t\tif (match[v] == -1) {\n\t\t\t\tfill(begin(used), end(used), false);\n\t\t\t\tif (dfs(v)) res++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\nprivate:\n\tstd::vector<int> used;\n\tbool dfs(int v) {\n\t\tused[v] = true;\n\t\tfor (int u : g[v]) {\n\t\t\tint w = match[u];\n\t\t\tif (w == -1 || (!used[w] && dfs(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\n\n//?????????????????´???\n#define NM_MAX 500\n\n\n//??????????????¨??????\nint m,n;\nint b[NM_MAX];\nint r[NM_MAX];\n\n//b,r????????????????´??????°\nset<int> primeB[NM_MAX];\nset<int> primeR[NM_MAX];\n\n\nint main() {\n\twhile(1){\n\t\t//?????????\n\t\tCLR(b);\n\t\tCLR(r);\n\t\tREP(i, NM_MAX)primeB[i].clear();\n\t\tREP(i, NM_MAX)primeR[i].clear();\n\n\t\t//??\\???????????????\n\t\tcin>>m>>n;\n\t\tif(m==0 && n==0)break;\n\t\tREP(i, m)cin >> b[i];\n\t\tREP(i, n)cin >> r[i];\n\n\t\t//?´??????°????§£\n\t\tint prime;\n\t\tREP(i, m) {\n\t\t\tprime=2;\n\t\t\twhile (prime <= sqrt(b[i])) {\n\t\t\t\t//cout<<prime<<\"  \"<<b[i]<<endl;\n\t\t\t\tif (b[i] % prime == 0) {\n\t\t\t\t\tb[i]/=prime;\n\n\t\t\t\t\tprimeB[i].insert(prime);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprime++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprimeB[i].insert(b[i]);\n\n\t\t}\t\n\n\t\tREP(i, n) {\n\t\t\tprime = 2;\n\t\t\twhile (prime <= sqrt(r[i])) {\n\n\t\t\t\tif (r[i] % prime == 0) {\n\t\t\t\t\tr[i] /= prime;\n\t\t\t\t\tprimeR[i].insert(prime);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprime++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprimeR[i].insert(r[i]);\n\t\t}\n\n\t\t//???????????£?????????\n\t\tbipartite_matching bm = bipartite_matching(m + n + 1);\n\t\tbool okFlag;//???????????????????????????\n\t\tREP(i, m)REP(j, n) {\n\t\t\tokFlag=false;\n\n\t\t\tfor (set<int>::iterator it = primeB[i].begin(); it != primeB[i].end(); it++) {\n\n\t\t\t\t//?????´??????????´?????????£?????´???\n\t\t\t\tif (primeR[j].find(*it) != primeR[j].end()) {\n\t\t\t\t\tokFlag=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(okFlag)bm.add_edge(i,m+j);\n\t\t}\n\n\t\t//??????????????§??????????????°????±?????????????\n\t\tint ans=bm.maximum_matching();\n\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint gcd(int x,int y){\n    if(x % y == 0){\n        return y;\n    }\n    return gcd(y,x%y);\n}\n\nbool match(int x){\n    if(x == -1){\n        return 1;\n    }\n    for(int i = 0;i < n;i++){\n        if(c[x][i] == 1 && v[i] == 0){\n            v[i] = 1;\n            if(match(redpair[i])){\n                redpair[i] = x;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\n\nint main(){\n    vector<int> blue;\n    vector<int> red;\n    vector<int> redpair;\n    vector<int> v;\n    vector<vector<int> > c;\n\n    int m = 0;\n    int n = 0;\n\n    while(cin >> m >> n){\n        if(m == 0 && n == 0){\n            break;\n        }\n        blue.clear();\n        red.clear();\n        redpair.clear();\n        v.clear();\n        c.clear();\n        for(int i = 0;i < m;i++){\n            int tmp = 0;\n            cin >> tmp;\n            blue.push_back(tmp);\n        }\n        for(int i = 0;i < n;i++){\n            int tmp = 0;\n            cin >> tmp;\n            red.push_back(tmp);\n            redpair.push_back(-1);\n            v.push_back(0);\n        }\n        for(int i = 0;i < m;i++){\n            c.push_back(vector<int>());\n            for(int j = 0;j < n;j++){\n                c[i].push_back(gcd(blue[i],red[j]) != 1);\n            }\n        }\n        int ans = 0;\n        for(int i = 0;i < m;i++){\n            for(int j = 0;j < n;j++){\n                v[j] = 0;\n            }\n            if(match(i)){ans++;}\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include<vector>\n#include<algorithm>\n#include<map>\n#include<iomanip>\n#include<set>\n#include<queue>\n#include<deque>\n#include<iomanip>\n#include<sstream>\n#include<cmath>\n#include<bitset>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define req(i,n) for(ll i = 1;i <=  n; i++)\n#define rreq(i,n) for(ll i = n;i >= 1;i--)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(a) rbegin(a),rend(a)\ntypedef long long int ll;\ntypedef long double ld;\nconst ll INF = 1e18;\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T & val) {\n    std::fill((T*)array, (T*)(array + N), val);\n}\nconst int MOD = 1000000007;\nstruct Dinic {\n    struct edge {\n        int to, cap, rever;\n        edge(int to, int cap, int rever) :to(to), cap(cap), rever(rever) {}\n    };\n    vector< vector<edge> > graph;\n    vector<int> level, iter;\n    Dinic(int V) :graph(V), level(V), iter(V) {}\n    void add_edge(int from, int to, int cap) {\n        graph[from].emplace_back(to, cap, graph[to].size());\n        graph[to].emplace_back(from, 0, graph[from].size() - 1);\n    }\n    void bfs(int s) {\n        fill(ALL(level), -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(0);\n        while (que.size()) {\n            int v = que.front(); que.pop();\n            for (edge& e : graph[v]) {\n                if (e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int& i = iter[v]; i < graph[v].size(); i++) {\n            edge& e = graph[v][i];\n            if (e.cap > 0 && level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(e.cap, f));\n                if (d > 0) {\n                    e.cap -= d;\n                    graph[e.to][e.rever].cap += d;\n                    return d;\n                }\n            }\n        }return 0;\n    }\n    int max_flow(int s, int t) {\n        int flow = 0;\n        while (1) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            fill(ALL(iter), 0);\n            int f; while ((f = dfs(s, t, 1e9)) > 0) flow += f;\n        }\n    }\n};\nint n, m;\nint dx[4] = { 0,0,1,-1 }, dy[4] = { 1,-1,0,0 };\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\nint main(void) {\n    while (cin >> n >> m, n, m) {\n        Dinic dn(n + m + 2);\n        vector<int> a(n), b(m);\n        rep(i, n) cin >> a[i],dn.add_edge(0,i+1,1);\n        rep(i, m) cin >> b[i],dn.add_edge(i+n+1,n+m+1,1);\n        rep(i, n) {\n            rep(j, m) {\n                if (gcd(a[i], b[j]) > 1) {\n                    dn.add_edge(i + 1, j + n+1, 1);\n                }\n            }\n        }cout << dn.max_flow(0, n + m+1) << endl;\n     }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nlong long e, v;\n\nclass pass\n{\npublic:\n\tlong long t;\n\tlong long c;\n\tlong long p;\n};\n\npass p[250000];\n\nlong long noded[2000];\npair<long long, long long> nodef[2000];\nvector<long long> node[2000];\n\nvoid add(long long f, long long t, long long c)\n{\n\tp[e].t = t;\n\tp[e].c = c;\n\tp[e].p = e + 1;\n\tp[e + 1].t = f;\n\tp[e + 1].c = 0;\n\tp[e + 1].p = e;\n\tnode[f].push_back(e);\n\tnode[t].push_back(e + 1);\n\te += 2;\n}\n\nvoid push()\n{\n\tqueue<long long> q;\n\tfor (int i = 0; i < v; i++)\n\t{\n\t\tnoded[i] = 0;\n\t\tnodef[i] = make_pair(0, 0);\n\t}\n\tnoded[0] = v;\n\tfor (auto i : node[0])\n\t{\n\t\tif (p[i].c > 0)\n\t\t{\n\t\t\tp[p[i].p].c += p[i].c;\n\t\t\tnodef[p[i].t].first += p[i].c;\n\t\t\tnodef[0].second += p[i].c;\n\t\t\tp[i].c = 0;\n\t\t\tq.push(p[i].t);\n\t\t}\n\t}\n\tnodef[v - 1].second = (1 << 20);\n\twhile (!q.empty())\n\t{\n\t\tlong long np = q.front();\n\t\tq.pop();\n\t\twhile (1)\n\t\t{\n\t\t\tfor (auto i : node[np])\n\t\t\t{\n\t\t\t\tif (p[i].c > 0)\n\t\t\t\t{\n\t\t\t\t\tlong long t = p[i].t;\n\t\t\t\t\tif (noded[np] == noded[t] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long kae = min(p[i].c, nodef[np].first - nodef[np].second);\n\t\t\t\t\t\tp[i].c -= kae;\n\t\t\t\t\t\tp[p[i].p].c += kae;\n\t\t\t\t\t\tnodef[np].second += kae;\n\t\t\t\t\t\tbool w = (nodef[t].first <= nodef[t].second);\n\t\t\t\t\t\tnodef[t].first += kae;\n\t\t\t\t\t\tif (w && nodef[t].first > nodef[t].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tq.push(t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nodef[np].first <= nodef[np].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nodef[np].first > nodef[np].second && np != 0)\n\t\t\t{\n\t\t\t\tlong long minw = (1 << 20);\n\t\t\t\tfor (auto i : node[np])\n\t\t\t\t{\n\t\t\t\t\tif (p[i].c > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tminw = min(minw, noded[p[i].t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnoded[np] = minw + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long dn[2000];\nlong long dm[2000];\n\nlong long gcd(long long a, long long b)\n{\n\tif (a % b == 0)\n\t{\n\t\treturn b;\n\t}\n\treturn gcd(b, a % b);\n}\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tlong long n, m;\n\t\tscanf(\"%lld%lld\", &n, &m);\n\t\tif (n == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tv = n + m + 2;\n\t\te = 0;\n\t\tfor (long long i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%lld\", &dn[i]);\n\t\t\tadd(0, 1 + i, 1);\n\t\t}\n\t\tfor (long long i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%lld\", &dm[i]);\n\t\t\tadd(n + 1 + i, n + m + 1, 1);\n\t\t}\n\t\tfor (long long i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (long long ii = 0; ii < m; ii++)\n\t\t\t{\n\t\t\t\tif (1 < gcd(dn[i], dm[ii]))\n\t\t\t\t{\n\t\t\t\t\tadd(1 + i, n + 1 + ii, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpush();\n\t\tlong long all = 0;\n\t\tfor (auto i : node[0])\n\t\t{\n\t\t\tif (i % 2 == 0)\n\t\t\t{\n\t\t\t\tall += p[p[i].p].c;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", all);\n\t\tfor (long long i = 0; i < v; i++)\n\t\t{\n\t\t\tnode[i].clear();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\nconst int MAX_V=1100;\nconst int INF=1<<25;\nstruct edge{int to,cap,rev;};\nvector<edge>G[MAX_V];\nint level[MAX_V],iter[MAX_V];\nint N,M,B[MAX_V],R[MAX_V];\n\nint yuc(int a,int b)\n{\n\tif(a%b==0)return b;\n\treturn yuc(b,a%b);\n}\n\n\nvoid add_edge(int from,int to,int cap)\n{\n\tedge ins={to,cap,G[to].size()};\n\tG[from].push_back(ins);\n\tins.to=from;ins.cap=0;ins.rev=G[from].size()-1;\n\tG[to].push_back(ins);\n}\n\nvoid bfs(int s)\n{\n\tmemset(level,-1,sizeof(level));\n\tqueue<int>Q;\n\tlevel[s]=0;\n\tQ.push(s);\n\twhile(!Q.empty())\n\t{\n\t\tint v=Q.front();Q.pop();\n\t\tfor(int i=0;i<G[v].size();i++)\n\t\t{\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0&&level[e.to]<0)\n\t\t\t{\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tQ.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v,int t,int f)\n{\n\tif(v==t)return f;\n\tfor(int &i=iter[v];i<G[v].size();i++)\n\t{\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0&&level[v]<level[e.to])\n\t\t{\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0)\n\t\t\t{\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t)\n{\n\tint flow=0;\n\tfor(;;)\n\t{\n\t\tbfs(s);\n\t\tif(level[t]<0)return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,INF))>0)\n\t\t\tflow+=f;\n\t}\n}\n\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&M),N+M;)\n\t{\n\t\tfor(int i=0;i<MAX_V;i++)G[i].clear();\n\t\tint s=0,t=N+M+1;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&B[i]);\n\t\t\tadd_edge(s,i+1,1);\n\t\t}\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tscanf(\"%d\",&R[i]);\n\t\t\tadd_edge(N+i+1,t,1);\n\t\t}\n\t\tfor(int i=0;i<N;i++)\n\t\t\tfor(int j=0;j<M;j++)\n\t\t\t{\n\t\t\t\tif(yuc(max(B[i],R[j]),min(B[i],R[j]))!=1)\n\t\t\t\t\tadd_edge(i+1,j+N+1,1);\n\t\t\t}\n\t\tprintf(\"%d\\n\",max_flow(s,t));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\nint gcd(int a, int b) {\n\tif (a < b) {\n\t\tswap(a, b);\n\t}\n\twhile (b != 0) {\n\t\ta = a%b;\n\t\tswap(a, b);\n\t}\n\treturn a;\n}\nint main() {\n\tint blue_size, red_size;\n\twhile (cin >> blue_size >> red_size, red_size) {\n\t\tvector<int> blue(blue_size);\n\t\tREP(i, blue_size)\n\t\t\tcin >> blue[i];\n\t\tvector<int> red(red_size);\n\t\tREP(i, red_size)\n\t\t\tcin >> red[i];\n\t\tSORT(blue);\n\t\tSORT(red);\n\t\tvb blueu(blue.size(), false);\n\t\tvb redu(red.size(), false);\n\t\tvvi bluec(blue.size());\n\t\tvvi redc(red.size());\n\t\tset<pii> connect;//blue red\n\t\tREP(i, blue.size()) {\n\t\t\tREP(j, red.size()) {\n\t\t\t\tif (gcd(blue[i], red[j]) != 1) {\n\t\t\t\t\tbluec[i].push_back(j);\n\t\t\t\t\tredc[j].push_back(i);\n\t\t\t\t\tif (!blueu[i] && !redu[j]) {\n\t\t\t\t\t\tblueu[i] = true;\n\t\t\t\t\t\tredu[j] = true;\n\t\t\t\t\t\tconnect.insert({ i,j });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, blue.size()) {\n\t\t\tif (!blueu[i]) {\n\t\t\t\tstack<pii> route;\n\t\t\t\troute.push({ i,0 });\n\t\t\t\tvb bluev(blue.size(), false);\n\t\t\t\tvb redv(red.size(), false);\n\t\t\t\tbluev[i] = true;\n\t\t\t\twhile (!route.empty()) {\nwf:\n\t\t\t\t\tpii st = route.top();\n\t\t\t\t\tif (st.second == 1 && !redu[st.first]) {\n\t\t\t\t\t\twhile (route.size() > 1) {\n\t\t\t\t\t\t\tif (route.size() % 2 == 0) {\n\t\t\t\t\t\t\t\tpii st2 = route.top();\n\t\t\t\t\t\t\t\troute.pop();\n\t\t\t\t\t\t\t\tconnect.insert({ route.top().first,st2.first });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tpii st2 = route.top();\n\t\t\t\t\t\t\t\troute.pop();\n\t\t\t\t\t\t\t\tconnect.erase({ st2.first,route.top().first });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (st.second == 0) {\n\t\t\t\t\t\tREP(j, bluec[st.first].size()) {\n\t\t\t\t\t\t\tif (!redv[bluec[st.first][j]]) {\n\t\t\t\t\t\t\t\tredv[bluec[st.first][j]] = true;\n\t\t\t\t\t\t\t\troute.push({j,1});\n\t\t\t\t\t\t\t\tgoto wf;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tREP(j, redc[st.first].size()) {\n\t\t\t\t\t\t\tif (!bluev[redc[st.first][j]]) {\n\t\t\t\t\t\t\t\tbluev[redc[st.first][j]] = true;\n\t\t\t\t\t\t\t\troute.push({ j,0 });\n\t\t\t\t\t\t\t\tgoto wf;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\troute.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << connect.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint V1, V2;\nint size[1002];\nint to[1002][1002];\nint dist[1002];\nint match[1002];\nconst int NIL = 1001;\nbool BFS(){\n  queue<int> que;\n  REP(v, V1){\n    if(match[v] == NIL){\n      dist[v] = 0;\n      que.push(v);\n    }else{\n      dist[v] = INF;\n    }\n  }\n  dist[NIL] = INF;\n  while(!que.empty()){\n    int v = que.front(); que.pop();\n    if(dist[v] < dist[NIL]){\n      for(int i = 0; i < size[v]; i++){\n        int u = to[v][i];\n        if(dist[match[u]] == INF){\n          dist[match[u]] = dist[v] + 1;\n          que.push(match[u]);\n        }\n      }\n    }\n  }\n  return dist[NIL] != INF;\n}\n\nbool DFS(int v){\n  if(v != NIL){\n    for(int i = 0; i < size[v]; i++){\n      int u = to[v][i];\n      if(dist[match[u]] == dist[v] + 1 && DFS(match[u])){\n        match[u] = v;\n        match[v] = u;\n        return true;\n      }\n    }\n    dist[v] = INF;\n    return false;\n  }\n  return true;\n}\n\nint Hopcroft_Karp(){\n  REP(v, V1 + V2) match[v] = NIL;\n  int matching = 0;\n  while(BFS()){\n    REP(v, V1){\n      if(match[v] == NIL && DFS(v)){\n        matching ++;\n      }\n    }\n  }\n  return matching;\n}\nint memo[5000][5000];\nint gcd(int x, int y){\n  if(x < 5000){\n    if(memo[x][y] != -1) return memo[x][y];\n    int r = x % y;\n    if(r == 0) return memo[x][y] = y;\n    return memo[x][y] = gcd(y, r);\n  }else{\n    int r = x % y;\n    if(r == 0) return y;\n    return gcd(y, r);\n  }\n}\nint main(){\n  memset(memo, -1, sizeof(memo));\n  while(scanf(\"%d %d\", &V1, &V2) && (V1 != 0 || V2 != 0)){\n    REP(i, V1) size[i] = 0;\n    static int blue[500];\n    static int red[500];\n    REP(i, V1) scanf(\"%d\", blue + i);\n    REP(i, V2) scanf(\"%d\", red + i);\n    REP(u, V1) REP(v, V2){\n      if(gcd(blue[u], red[v]) != 1) {\n        to[u][size[u]++] = V1 + v;\n        //G[u].push_back(V1 + v);\n        //G[V1 + v].push_back(u);\n      }\n    }\n    printf(\"%d\\n\", Hopcroft_Karp());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define repit(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nconst int MAX_V = 1024;\nint  V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\nbool dfs(int v){\n    used[v] = 1;\n    rep(i,G[v].size()){\n        int u = G[v][i], w = match[u];\n        if(w < 0 || !used[w] && dfs(w)){\n            match[v] = u;\n            match[u] = v;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint bi_matching(){\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    rep(v,V) if(match[v] < 0){\n        memset(used, 0, sizeof(used));\n        if(dfs(v)) res++;\n    }\n    return res;\n}\n\nint b[512], r[512], n, m;\n\nint solve(){\n    rep(i,m) rep(j,n) if(__gcd(b[i],r[j]) > 1) add_edge(i,m+j);\n        \n    return bi_matching();\n}\n\nint main()\n{\n    while(cin >> m >> n, m or n){\n        rep(i,m) cin >> b[i];\n        rep(i,n) cin >> r[i];\n        V = m+n;\n        rep(i,MAX_V) G[i].clear();\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_V = 10000;\nconst int INF = 100000000;\n\n// &#65533;&#65533;&#65533;_&#65533;&#65533;\nint V;\n// &#65533;O&#65533;&#65533;&#65533;t&#65533;&#771;&#65533;&#65533;X&#65533;g&#65533;\\&#65533;&#65533;\nvector<int> G[MAX_V];\n// &#65533;}&#65533;b&#65533;`&#65533;&#65533;&#65533;O&#65533;&#771;y&#65533;A\nint match[MAX_V];\n// dfs&#65533;&#322;&#65533;&#65533;&#322;&#594;&#65533;&#65533;&#1474;&#65533;&#65533;&#65533;&#65533;&#450;&#65533;&#65533;&#65533;&#65533;&#771;t&#65533;&#65533;&#65533;O\nstatic bool used[MAX_V];\n\n// u&#65533;&#65533;v&#65533;&#65533;&#1301;&#1218;&#65533;O&#65533;&#65533;&#65533;t&#65533;&#594;&#457;&#65533;\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\n// &#65533;&#65533;&#65533;&#65533;p&#65533;X&#65533;&#65533;dfs&#65533;&#338;T&#65533;&#65533;\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i],w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// &#65533;&#349443;O&#65533;&#65533;&#65533;t&#65533;&#781;&#337;&#65533;}&#65533;b&#65533;`&#65533;&#65533;&#65533;O&#65533;&#65533;&#1986;&#65533;\nint bipartite_matching(){\n\tint res = 0;\n\t//memset(match,-1,sizeof(match));\n\tfor(int i = 0; i < MAX_V; i++)\n\t\tmatch[i]=-1;\n\tfor(int v = 0; v < V; v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int a,int b){\n\tif(b==0)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\n\n\nint main(){\n\n\tint n,m;\n\twhile(cin>>m>>n&&!(m==0&&n==0)){\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\tG[i].clear();\n\n\t\tvector<int> bs,rs;\n\t\tint b,r;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin>>b;\n\t\t\tbs.push_back(b);\n\t\t\tV++;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>r;\n\t\t\trs.push_back(r);\n\t\t\tV++;\n\t\t}\n\t\tfor(int i = 0; i < rs.size(); i++){\n\t\t\tfor(int j = 0;j < bs.size(); j++){\n\t\t\t\tint res=gcd(rs[i],bs[j]);\n\t\t\t\tif(res>1)\n\t\t\t\t\tadd_edge(i,j+rs.size());\n\t\t\t}\n\t\t}\n\t\tcout<<bipartite_matching()<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(a)  (a).begin(),(a).end()\n#define sz(x) int(x.size())\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<long long, long long> Pll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<long long> vll;\ntypedef vector<vector<long long>> vvll;\ntemplate <typename T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate <typename T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst long long INF = 1LL << 60;\nconst int INT_INF = 1 << 30;\nconst double PI = acos(-1.0);\n#define MOD 1000000007LL\n#define endl \"\\n\"\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  while(true){\n    int m, n;\n    cin >> m >> n;\n    if(m == 0 && n == 0) break;\n    vi b(m+n);\n    vector<set<int>> factor(m+n);\n    for(int i = 0; i < m+n; i++){\n      cin >> b.at(i);\n      for(int j = 2; j*j <= b.at(i); j++){\n        if(b.at(i) % j == 0){\n          factor.at(i).insert(j);\n          while(b.at(i) % j == 0) b.at(i) /= j;\n        }\n      }\n      if(b.at(i) != 1) factor.at(i).insert(b.at(i));\n    }\n    vvi G(n+m, vi(0));\n    for(int i = 0; i < m; i++){\n      for(int j = 0; j < n; j++){\n        set<int> se = factor.at(i);\n        int num = se.size();\n        for(auto ite = factor.at(m+j).begin(); ite != factor.at(m+j).end(); ite++){\n          se.insert(*ite);\n        }\n        if(sz(se) != num + sz(factor.at(m+j))){\n          G.at(i).push_back(m+j);\n          G.at(m+j).push_back(i);\n        }\n      }\n    }\n    vi match(m+n, -1);\n    vi flag(m+n, 0);\n    /*for(int i = 0; i < m; i++){\n      for(auto x: G.at(i)) cout<< i << ' ' << x << endl;\n      //for(auto x: factor.at(i)) cout<< i << ' ' << x << endl;\n    }*/\n    function<bool(int)> dfs = [&](int v){\n      flag.at(v) = 1;\n      for(int i = 0; i < sz(G.at(v)); i++){\n        int u = G.at(v).at(i);\n        int w = match.at(u);\n        if(flag.at(u)) continue;\n        if(w == -1 || (!flag.at(w) && dfs(w))){\n          match.at(v) = u;\n          match.at(u) = v;\n          return true;\n        }\n      }\n      return false;\n    };\n    int ans = 0;\n    for(int i = 0; i < m; i++){\n      if(match.at(i) != -1) continue;\n      fill(ALL(flag), 0);\n      if(dfs(i)) ans++;\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int>L[1000];int N,M,E,i,jmatch[1000],x[1000],y[1000];bool used[1000];\nbool DFS(int V){\n\tused[V]=true;\n\tfor(i=0;i<L[V].size();i++){\n\t\tint u=L[V][i],w=match[u];\n\t\tif(w<0||!used[w]&&DFS(w)){\n\t\t\tmatch[V]=u;\n\t\t\tmatch[u]=V;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint SM(){\n\tint r=0;\n\tmemset(match,-1,sizeof(match));\n\tfor(j=0;j<N+M;j++){\n\t\tif(match[j]<0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(DFS(j)){r++;}\n\t\t}\n\t}\n\treturn r;\n}\nint main(){\n\twhile(1){\n\t\tfor(i=0;i<1000;i++){L[i].clear();}\n\t\tcin>>N>>M;if(!N){break;}\n\t\tfor(i=0;i<N;i++){\n\t\t\tcin>>x[i];\n\t\t}\n\t\tfor(i=0;i<M;i++){\n\t\t\tcin>>y[i];\n\t\t}\n\t\tfor(i=0;i<N;i++){\n\t\t\tfor(j=0;j<M;j++){\n\t\t\t\tif(__gcd(x[i],y[j])>1){\n\t\t\t\t\tL[i].push_back(j+N);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<SM()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define ALL(obj) (obj).begin(),(obj).end()\n#define RALL(obj) (obj).rbegin(),(obj).rend()\n#define REP(i, n) for(int i = 0; i < int(n); i++)\n#define FOR(i,n,m) for(int i = int(n); i < int(m); i++)\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1e9 + 7;\nconst int INF = MOD - 1;\nconst ll LLINF = 4e18;\n\n// 最大流O(V^2E)\nstruct Dinic {\nprivate:\n    struct edge {\n        int to;\n        ll cap;\n        int rev;\n        bool isrev;\n        int idx;\n    };\n\n    vector< vector< edge > > graph;\n    vector< int > min_cost, iter;\n\n\n    bool bfs(int s, int t) {\n        min_cost.assign(graph.size(), -1);\n        queue< int > que;\n        min_cost[s] = 0;\n        que.push(s);\n        while (!que.empty() && min_cost[t] == -1) {\n            int p = que.front();\n            que.pop();\n            for (auto &e : graph[p]) {\n                if (e.cap > 0 && min_cost[e.to] == -1) {\n                    min_cost[e.to] = min_cost[p] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n        return min_cost[t] != -1;\n    }\n\n    ll dfs(int idx, const int t, ll flow) {\n        if (idx == t) return flow;\n        for (int &i = iter[idx]; i < graph[idx].size(); i++) {\n            edge &e = graph[idx][i];\n            if (e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n                ll d = dfs(e.to, t, min(flow, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    graph[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\npublic:\n\n    Dinic(int V) : graph(V) {}\n\n    void add_edge(int from, int to, ll cap, int idx = -1) {\n        graph[from].push_back({to, cap, (int)graph[to].size(), false, idx});\n        graph[to].push_back({from, 0, (int)graph[from].size() - 1, true, idx});\n    }\n\n\n    // from s to t\n    ll max_flow(int s, int t) {\n        ll flow = 0;\n        while (bfs(s, t)) {\n            iter.assign(graph.size(), 0);\n            ll f = 0;\n            while ((f = dfs(s, t, INF)) > 0) flow += f;\n        }\n        return flow;\n    }\n\n    void output() {\n        for (int i = 0; i < graph.size(); i++) {\n            for (auto &e : graph[i]) {\n                if (e.isrev) continue;\n                auto &rev_e = graph[e.to][e.rev];\n                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << e.cap + rev_e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n\n//gcd\ntemplate<typename T>\nT gcd(T a, T b) {\n    return b ? gcd(b, a%b) : a;\n}\n\nint main() {\n    int n, m;\n    while (true) {\n        scanf(\"%d %d\", &n, &m);\n        if (n == 0 && m == 0) break;\n        vector<int> a(n), b(m);\n        REP(i, n) scanf(\"%d\", &a[i]);\n        REP(i, m) scanf(\"%d\", &b[i]);\n        Dinic din(n + m + 2);\n        REP(i, n) {\n            din.add_edge(n + m, i, 1);\n            REP(j, m) {\n                if (gcd(a[i], b[j]) > 1) {\n                    din.add_edge(i, j + n, 1);\n                }\n            }\n        }\n        REP(i, m) din.add_edge(i + n, n + m + 1, 1);\n        printf(\"%lld\\n\",din.max_flow(n + m, n + m + 1));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// ?????§????§£????????????????????????\nclass MaxFlow{\nprivate:\n  // edge: ??£??\\??????????????? (to: ?????????, cap: ??????, rev: ???????????????(G[to][rev]?????????))\n  // G: ??£??\\?????????, used: ?????¨???????????????\n  struct edge{\n    int to, cap, rev;\n    edge(int to_, int cap_, int rev_){ to = to_; cap = cap_; rev = rev_; }\n  };\n  vector<vector<edge> > G;\n  vector<bool> used;\n  int dfs(int v, int t, int f);\npublic:\n  // ?????????????????????\n  MaxFlow(int size){\n    G = vector<vector<edge> >(size);\n    used = vector<bool>(size);\n  }\n  void add_edge(int from, int to, int cap);\n  int flow(int s, int t);\n};\n\n// ????????????\nvoid MaxFlow::add_edge(int from, int to, int cap){\n  G[from].push_back(edge(to, cap, G[to].size()));\n  G[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\n// ??±???????????¢?´¢??§?¢???????????????¢???\n// v: ?????¨??°???, t: ??????, f: ???????????????\nint MaxFlow::dfs(int v, int t, int f){\n  if(v == t){ return f; }\n  used[v] = true;\n\n  for(int i = 0; i < G[v].size(); i++){\n    edge &e = G[v][i];\n    // ???????????????????????????????????????????????????????????????????????????????????£????????????\n    if(!used[e.to] && e.cap > 0){\n      // ????????????????????°??????dfs\n      int d = dfs(e.to, t, ((f < e.cap) ? f : e.cap));\n      // ??????1ml??§??????????????????????????????\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  \n  return 0;\n}\n\n// s??????t?????§????????§???????±???????\nint MaxFlow::flow(int s, int t){\n  int flow = 0;\n  while(true){\n    for(int i = 0; i < used.size(); i++)\n      used[i] = false;\n    int f = dfs(s, t, 1e9);\n    if(f == 0){ return flow; }\n    flow += f;\n  }\n}\n\nint gcd(int a, int b){\n  if(b == 0){ return a; }\n  return gcd(b, a % b);\n}\n\n\nint main(void){\n  while(true){\n    int m, n;\n    cin >> m >> n;\n    if(m == 0 && n == 0){ break; }\n\n    // ??????????????£?¨?\n    MaxFlow f(m + n + 2);\n\n    // ???????????????????????????????????????\n    vector<int> b(m);\n    for(int i = 0; i < m; i++){\n      cin >> b[i];\n      // ?§?????????????????????????????????°???\n      f.add_edge(0, 1 + i, 1);\n    }\n\n    // ???????????????????????????????????????\n    int r;\n    for(int i = 0; i < n; i++){\n      cin >> r;\n      for(int j = 0; j < m; j++){\n        // ???????????§??¬?´???°???1????????§???????????°?????????????????????????????????????????°???\n        if(gcd(r, b[j]) > 1){ f.add_edge(1 + j, 1 + m + i, 1); }\n      }\n      // ???????????????????????????????????°???\n      f.add_edge(1 + m + i, 1 + m + n, 1);\n    }\n\n    // ?????§???????±?????????????\n    cout << f.flow(0, 1 + m + n) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <utility>\nusing namespace std;\n\nint m, n, B[500], R[500], P[500], C[500][500];\n\n// P[] カード赤とペアになっている青のカード番号 割り当てなしで -1\n// B[i] と R[j] がマッチ可能なとき C[i][j] = 1 不可能なとき 0\n\nbool V[500];\n// true ならカード赤に新しい割り当て先はない false なら不明\n\nint gcd( int a, int b ) {\n\n\tint c;\n\t\n\twhile ( a != 0 ) {\n\t\n\t\tc = a;\n\t\ta = b % a;\n\t\tb = c;\n\n\t}\n\n\treturn b;\n\n}\n\nint judge( int i, int j ) {\n\n\tif ( gcd( B[i], R[j] ) >= 2 ) { return 1; }\n\telse { return 0; }\n\n}\n\nbool match( int i ) {\n\n\tif ( i < 0 ) { return true; }\n\t\n\tfor ( int j = 0; j < n; j++ ) {\n\t\n\t\tif ( C[i][j] == 0 || V[j] ) { continue; }\n\t\t\n\t\tV[j] = true;\n\t\t\n\t\tif ( match( P[j] ) ) {\n\t\t\t\n\t\t\tP[j] = i;\n\t\t\treturn true;\n\t\t\t\n\t\t}\n\t\n\t}\n\t\n\treturn false;\n\n}\n\nint main() {\n\n\twhile ( cin >> m >> n && m != 0 && n != 0 ) {\n\t\n\t\tfor ( int i = 0; i < m; i++ ) { cin >> B[i]; }\n\t\tfor ( int i = 0; i < n; i++ ) { cin >> R[i]; }\n\t\t\n\t\t\n\t\tfor ( int i = 0; i < n; i++ ) { P[i] = -1; }\n\t\t\n\t\tfor ( int i = 0; i < m; i++ ) { for ( int j = 0; j < n; j++ ) { C[i][j] = judge( i, j ); } }\n\t\t\n\t\tint count = 0;\n\t\t\n\t\tfor ( int i = 0; i < m; i++ ) {\n\t\t\n\t\t\tfor ( int i = 0; i < n; i++ ) { V[i] = false; }\n\t\t\t\n\t\t\tif ( match( i ) ) { count++; }\n\t\t\t\n\t\t}\n\t\t\n\t\tcout << count << endl;\n\t\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nstruct HopcroftKarp {\n  vector< vector< int > > graph;\n  vector< int > dist, match;\n  vector< bool > used, vv;\n  HopcroftKarp(int n, int m) : graph(n), match(m, -1), used(n) {}\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n  }\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n  void output() {\n    for(int i = 0; i < match.size(); i++) {\n      if(~match[i]) {\n        cout << match[i] << \"-\" << i << endl;\n      }\n    }\n  }\n};\nint gcd(int a, int b) {\n  if(b == 0) return a;\n  else return gcd(b, a%b);\n}\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n, m; cin >> n >> m;\n    if(n == 0) break;\n    vector<int> b(n), r(m);\n    for(int i=0;i<n;++i) {\n      cin >> b[i];\n    }\n    for(int i=0;i<m;++i) {\n      cin >> r[i];\n    }\n    HopcroftKarp hk(n, m);\n    for(int i=0;i<n;++i) {\n      for(int j=0;j<m;++j) {\n        if(gcd(b[i], r[j]) != 1) {\n          hk.add_edge(i, j);\n        }\n      }\n    }\n    cout << hk.bipartite_matching() << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\n#define MAX_V 1002\nusing namespace std;\nstruct edge {\n\tint to, cap, rev;\n\tedge(int to_, int cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {};\n};\n\nint V;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nint GCD(int a, int b) {\n\treturn b ? GCD(b, a % b) : a;\n}\n\nvoid AddEdge(int from, int to, int cap) {\n\tG[from].push_back(edge(to, cap, G[to].size()));\n\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nvoid BFS(int s) {\n\tfill(level, level + V, -1);\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tfor (size_t i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint DFS(int v, int t, int f) {\n\tif (v == t) return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = DFS(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint Dinic(int s, int t) {\n\tint flow = 0;\n\twhile (true) {\n\t\tBFS(s);\n\t\tif (level[t] < 0) return flow;\n\t\tfill(iter, iter + V, 0);\n\t\tint f;\n\t\twhile ((f = DFS(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint m, n;\n\twhile (cin >> m >> n, m || n) {\n\t\tvector<int> b(m), r(n);\n\t\tV = m + n + 2;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> b[i];\n\t\t\tAddEdge(m + n, i, 1);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> r[i];\n\t\t\tAddEdge(m + i, m + n + 1, 1);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (GCD(b[i], r[j]) != 1) {\n\t\t\t\t\tAddEdge(i, m + j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << Dinic(m + n, m + n + 1) << endl;\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#define INF 1000000000\n#define MAX_V 1000\n#define MAX 10000000\nusing namespace std;\n\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nbool prime[MAX+1];\n\nvoid eratos(){\n  int n=MAX;\n  for(int i=0;i<=n;i++) prime[i]=false;\n  for(int i=3;i<=n;i+=2) prime[i]=true;\n  prime[2]=true;\n  int limit=(int)sqrt((double)n)+1;\n  for(int i=3;i<=limit;i+=2){\n    if(!prime[i]) continue;\n    for(int j=i+i;j<=n;j+=i)\n      prime[j]=false;\n  }\n}\n\nvoid add_edge(int u, int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i], w=match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  memset(match, -1, sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v)){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nmain(){\n  eratos();\n  int primdata[664580];\n  for(int i=0, j=0;i<=MAX;i++){\n    if(prime[i]) primdata[j++]=i;\n  }\n  primdata[664579]=-1;\n  int m, n;\n  while(1){\n    cin >> m >> n;\n    if(m==0 && n==0) break;\n    for(int i=0;i<m+n;i++){\n      G[i].clear();\n    }\n    int in1[500], in2[500];\n    for(int i=0;i<m;i++){\n      cin >> in1[i];\n    }\n    for(int i=0;i<n;i++){\n      cin >> in2[i];\n    }\n    bool can[500][500];\n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n\tcan[i][j]=false;\n\tfor(int k=0;;k++){\n\t  if(primdata[k]==-1) break;\n\t  if(primdata[k]>in1[i] || primdata[k]>in2[j]) break;\n\t  if(in1[i]%primdata[k]==0 && in2[j]%primdata[k]==0) can[i][j]=true;\n\t}\n      }\n    }\n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n\tif(can[i][j]){\n\t  add_edge(i, m+j);\n\t}\n      }\n    }\n    V=m+n;\n    cout << bipartite_matching() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <set>\n#define X first\n#define Y second\n\nusing namespace std;\n\nstruct link{\n\tint dest;\n\tlink *ne;\n\tlink(int n=0){\n\t\tdest=n;\n\t\tne=NULL;\n\t}\n};\n\nint gcd(int a,int b){\n\tif(a%b==0)return b;\n\treturn(gcd(b,a%b));\n}\n\nint n, m, a[510], b[510], used[510], ans;\nlink *last[510], *t;\n\nbool dfs(int x){\n\tlink *t=last[x];\n\twhile(t){\n\t\tif(!used[t->dest]){\n\t\t\tused[t->dest]=1;\n\t\t\tif(b[t->dest]==0||dfs(b[t->dest])){\n\t\t\t\tb[t->dest]=x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tt=t->ne;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin>>n>>m;\n\twhile(n+m>0){\n\t\tans=0;\n\t\tfor(int i=1;i<=n;i++) cin>>a[i];\n\t\tfor(int i=1;i<=m;i++) cin>>b[i];\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t\tif(gcd(a[i],b[j])>1){\n\t\t\t\t\tt=new link(j);\n\t\t\t\t\tt->ne=last[i];\n\t\t\t\t\tlast[i]=t;\n\t\t\t\t}\n\t\tmemset(b,0,sizeof(b));\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(i)) ans++;\n\t\t}\n\t\tcout<<ans<<endl;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tt=last[i];\n\t\t\twhile(last[i]){\n\t\t\t\tt=last[i]->ne;\n\t\t\t\tdelete last[i];\n\t\t\t\tlast[i]=t;\n\t\t\t}\n\t\t}\n\t\tcin>>n>>m;\t\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n\nvoid add_edge(VVI& graph, int u, int v){\n  graph[u].push_back(v);\n  graph[v].push_back(u);\n}\n\nbool dfs(VVI& biG, VI& match, int v, vector<bool>& used){\n  used[v] = true;\n  for(int i=0;i<biG[v].size();++i){\n\tint u = biG[v][i], w = match[u];\n\tif(w < 0 || (!used[w] && dfs(biG, match, w, used))){\n\t  match[v] = u;\n\t  match[u] = v;\n\t  return true;\n\t}\n  }\n  return false;\n}\n\nint bipartite_matching(VVI& biG, VI& match){\n  int res = 0;\n  int V = SZ(biG);\n  fill(ALL(match), -1);\n  for(int v=0;v<V;++v){\n\tif(match[v] < 0){\n\t  vector<bool> used(V, false);\n\t  if(dfs(biG, match, v, used))\n\t\t++res;\n\t}\n  }\n  return res;\n}\n\nint gcd(int x, int y){\n  if(y == 0) return x;\n  return gcd(y, x%y);\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int M,N;\n  while(cin>>M>>N,M){\n\tVI b(M), r(N);\n\tREP(i,M) cin >> b[i];\n\tREP(i,N) cin >> r[i];\n\n\tVVI biG(M+N);\n\tfor(int i=0;i<M;++i)\n\t  for(int j=0;j<N;++j)\n\t\tif(gcd(b[i], r[j]) > 1)\n\t\t  add_edge(biG, i, j+M);\n\t\n\tVI match(M+N);\n\tcout << bipartite_matching(biG, match) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\ntypedef vector<int> Vint;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct edge{\n  int to, cap, inv;\n};\n\nvector<edge> G[1002];\nbool vsted[1002];\nint inf = 123456789; //???????°´??????\n\nint dfs(int v, int now, int t, int w){\n  if(now == t)return w;\n  vsted[now] = true;\n  for(int i = 0;i < G[now].size();++i){\n    edge tmp = G[now][i];\n    if(!vsted[tmp.to] && tmp.cap > 0){\n      int d = dfs(v, tmp.to, t, min(w, tmp.cap));\n      if(d > 0){\n        G[now][i].cap -= d;\n        G[tmp.to][tmp.inv].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint edmondskarp(int v, int s, int t){\n  int res = 0;\n  for(;;){\n    for(int i = 0;i < v;++i)vsted[i] = false;\n    int x = dfs(v, s, t, inf);\n    if(x == 0)return res;\n    res += x;\n  }\n  return res;\n}\n\n#define N 10000001\nint p[N] = {0}, b[501], r[501];\n\nbool isedge(int b, int r){\n  if(b == 1)return false;\n  if(b % r == 0 || r % b == 0)return true;\n  int x = p[b];\n  if(x == 0)return false;\n  if(r % x == 0)return true;\n  return isedge(b / x, r);\n}\n\nsigned main(void){\n  int i, j, k;\n  for(i = 2;i * i <= N;++i)for(j = i;j < N;j+=i)if(p[j] == 0)p[j] = i;\n\n  for(;;){\n    int2(m, n);\n    if(!(m|n))break;\n    int v = m + n + 2;\n    scn(m, b); scn(n, r);\n    rep(i, m)rep(j, n)if(isedge(b[i], r[j])){\n      int l = i, r = j; r += m;\n      G[l].pb((edge){r, 1, G[r].size()});\n      G[r].pb((edge){l, 0, G[l].size() - 1});\n    }\n    rep(i, m){\n      int r = i, l = m + n;\n      G[l].pb((edge){r, 1, G[r].size()});\n      G[r].pb((edge){l, 0, G[l].size() - 1});\n    }\n    rep(i, n){\n      int l = i + m, r = m + n + 1;\n      G[l].pb((edge){r, 1, G[r].size()});\n      G[r].pb((edge){l, 0, G[l].size() - 1});\n    }\n\n    cout << edmondskarp(v, v - 2, v - 1) << endl;\n    rep(i, v)G[i].clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin() i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n//typedef long long Int;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst) : src(src),dst(dst) {}\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) {}\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vec<Edge> Edges;\ntypedef vec<Edges> Graph;\n\n#define MAXMN 500\nint B[MAXMN];\nint R[MAXMN];\n\nint gcd(int a, int b)\n{   \n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  return match;\n}\n\n\nint main(int argc, char **argv) {\n  int M,N;\n  Graph g; g.reserve(MAXMN+MAXMN);\n  while(cin>>M>>N,M) {\n    g.clear();\n    g.resize(M+N);\n    REP(i,M) cin>>B[i];\n    REP(i,N) cin>>R[i];\n    REP(i,M) {\n      Edges es, es2;\n      REP(j,N) {\n\tif(gcd(B[i],R[j])!=1) { es.pb(Edge(i,M+j)); es2.pb(Edge(M+j,i)); }\n      }\n      g[i] = es;\n      g[M+i] = es2;\n    }\n    cout << bipartiteMatching(g,M) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\nstruct edge{int to,cap,rev;};\n\nvector<edge> G[1000000];\nbool used[1000000];\nvoid add_edge(int from,int to,int cap){\n    G[from].pb((edge){to,cap,(int)G[to].size()});\n    G[to].pb((edge){from,0,(int)(G[from].size())-1});\n}\n\n// テ・ツ「ツ療・ツ環?」ツδ妥」ツつケテ」ツつ奪FSテ」ツ?ァテヲツ篠「テ」ツ??\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap)); if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n// sテ」ツ?凝」ツつ液テ」ツ?クテ」ツ?ョテヲツ慊?・ツ、ツァテヲツオツ?」ツつ津ヲツアツづ」ツつ?」ツつ?\nint max_flow(int s, int t) {\n    int flow = 0; for (;;) {\n        memset(used, 0, sizeof(used)); int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\n\n\nint main(){\n    int m,n;\n    while(cin>>n>>m){\n        if(n==0&&m==0)break;\n        int x[600];\n        int y[600];\n        rep(i,n) cin>>x[i];\n        rep(i,m) cin>>y[i];\n        \n        rep(i,n){\n            rep(j,m){\n                if(__gcd(x[i],y[j])>1){\n                    add_edge(i,n+j,1);\n                }\n            }\n        }\n        int s=n+m,t=s+1;\n        rep(i,n){\n            add_edge(s,i,1);\n        }\n        rep(i,m){\n            add_edge(n+i,t,1);\n        }\n        cout<<max_flow(s,t)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nvector<int> blue,red,redpair,v;\nvector<vector<int> >c;\n\nint m=0,n=0;\n\nint gcd(int x,int y){\n    if(x%y==0){return y;}\n    return gcd(y,x%y);\n}\n\nbool match(int x){\n    if(x==-1){\n        return 1;\n    }\n    for(int i=0;i<n;i++){\n        if(c[x][i]==1 && v[i]==0){\n\t\t\tv[i]=1;\n\t\t\tif(match(redpair[i])){\n\t\t\t\tredpair[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main(){\n    while(cin >> m >> n){\n        if(m == 0 && n == 0){\n            break;\n        }\n        blue.clear();\n        red.clear();\n        redpair.clear();\n        v.clear();\n        c.clear();\n        for(int i = 0;i < m;i++){\n            int tmp = 0;\n            cin >> tmp;\n            blue.push_back(tmp);\n        }\n        for(int i = 0;i < n;i++){\n            int tmp = 0;\n            cin >> tmp;\n            red.push_back(tmp);\n            redpair.push_back(-1);//-1??§?????¢??????????????¶????????¨???\n            v.push_back(0);\n        }\n        for(int i = 0;i < m;i++){\n            c.push_back(vector<int>());\n            for(int j = 0;j < n;j++){\n                c[i].push_back(gcd(blue[i],red[j]) != 1);\n            }\n        }\n        int ans = 0;\n        for(int i = 0;i < m;i++){\n            for(int j = 0;j < n;j++){\n                v[j] = 0;\n            }\n            if(match(i)){ans++;}\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n#define pb push_back\nint n,m;\nconst int MAX_N = 10000000;\nbool sieve[MAX_N];\nbool used[2][500];\n \nbool have_same_prime(int i, int j) {\n  if (i == j || i == 1 || j == 1) return true;\n  if (i % 2 == 0 && j % 2 == 0) return true;\n  \n  int bigger = (i > j) ? i : j ;\n  for (int z = 3; z <= bigger; z += 2)\n  if (sieve[z]) {\n    if (i % z == 0 && j % z == 0) return true;\n  }\n  \n  return false;\n}\n \nvoid solve() {\n  memset(used, false, sizeof used);\n  \n  vector<int> blue(n), red(m);\n  for(int i=0;i<n;i++) cin>>blue[i];\n  for(int i=0;i<m;i++) cin>>red[i];\n  \n  sort(blue.begin(), blue.end());\n  sort(red.begin(), red.end());\n  \n  int res = 0;\n  for (int i = 0; i < n; i += 1) {\n    for (int j = 0; j < m; j += 1) {\n      if (used[0][i] || used[1][j]) continue;\n      if (have_same_prime(blue[i], red[j])) {\n        used[0][i] = true;\n        used[1][j] = true;\n        res++;\n        break;\n      }\n    }\n  }\n  cout<<res<<endl;\n}\n \nint main (int argc, char const* argv[]) {\n  // set sieve\n  memset(sieve, true, sizeof sieve);\n  \n  for(int i=4;i<MAX_N;i+=2) {\n    sieve[i] = false;\n  }\n  \n  for(int i=3;i<MAX_N;i+=2) {\n    if(sieve[i]) {\n      for(int j=i+i;j<MAX_N;j+=i) {\n        sieve[j] = false;\n      }\n    }\n  }\n  // solve\n  while (cin>>n>>m, n||m) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\nusing namespace std;\n\n#define INF 2000000000\n\nclass max_flow {\nprivate:\n\tstruct edge { int to, cap, rev; };\n\tint v;\n\tvector<vector<edge>>G;\n\tvector<int>itr, level;\npublic:\n\tmax_flow(int v) :v(v) { G.assign(v, vector<edge>()); }\n\n\tvoid add_edge(int from, int to, int cap) {\n\t\tG[from].push_back(edge { to, cap, (int)G[to].size() });\n\t\tG[to].push_back(edge { from, 0, (int)G[from].size() - 1 });\n\t}\n\n\tvoid bfs(int s) {\n\t\tlevel.assign(v, -1);\n\t\tqueue<int>q;\n\t\tlevel[s] = 0; q.push(s);\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (auto &e : G[v]) {\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int& i = itr[v]; i < (int)G[v].size(); ++i) {\n\t\t\tedge& e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint run(int s, int t) {\n\t\tint ret = 0, f;\n\t\twhile (bfs(s), level[t] >= 0) {\n\t\t\titr.assign(v, 0);\n\t\t\twhile ((f = dfs(s, t, INF)) > 0)ret += f;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint gcd(int a, int b) {\n\tif (b == 0)return a;\n\telse return gcd(b, a%b);\n}\n\nint main() {\n\tint m,n;\n\twhile (1) {\n\t\tcin >> m >> n;\n\t\tif (m == 0)break;\n\t\tmax_flow max_flow(m + n + 2);\n\t\tvector<int>b, r;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tb.push_back(buf);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tr.push_back(buf);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tmax_flow.add_edge(m + n, i, 1);\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (gcd(b[i], r[j]) != 1)max_flow.add_edge(i, m + j, 1);\n\t\t\t\tif (i == 0)max_flow.add_edge(m + j, m + n + 1, 1);\n\t\t\t}\n\t\t}\n\t\tint ans = max_flow.run(m + n, m + n + 1);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//Max-Flow,?????§???\ntemplate<int V>\nstruct MaxFlow {\n\tusing T = double;\n\tconst T INF = 1<<28;\n\n\tstruct Edge {\n\t\tint to,rev;\n\t\tT cap;\n\t};\n\n\tvector<Edge> g[V];\n\tint level[V];\n\tint iter[V];\n\n\tvoid add(int from, int to, T cap) {\n\t\tg[from].push_back(Edge{to, (int)g[to].size(), cap});\n\t\tg[to].push_back(Edge{from, (int)g[from].size()-1, 0});\n\t}\n\tvoid add_multi(int from, int to, T cap) {\n\t\tg[from].push_back(Edge{to, (int)g[to].size(), cap});\n\t\tg[to].push_back(Edge{from, (int)g[from].size()-1, cap});\n\t}\n\n\tvoid bfs(int s) {\n\t\tfill_n(level,V,-1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()) {\n\t\t\tint v = que.front();\n\t\t\tque.pop();\n\t\t\tfor(Edge e: g[v]) {\n\t\t\t\tif(e.cap <= 0)continue;\n\t\t\t\tif(level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tT dfs(int v,int t,T f) {\n\t\tif(v == t)return f;\n\t\tfor(int &i = iter[v]; i < g[v].size(); i++) {\n\t\t\tEdge &e = g[v][i];\n\t\t\tif(e.cap <= 0)continue;\n\t\t\tif(level[v] < level[e.to]) {\n\t\t\t\tT d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d <= 0)continue;\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tT exec(int s,int t) {\n\t\tT flow = 0;\n\t\twhile(true) {\n\t\t\tbfs(s);\n\t\t\tif(level[t] < 0)return flow;\n\t\t\tfill_n(iter,V,0);\n\t\t\tT f;\n\t\t\twhile((f = dfs(s,t,INF)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nbool solve(){\n\tint m,n;\n\tcin >> m >> n;\n\tif(m == 0 && n == 0)return false;\n\n\tvector<int> b(m),r(n);\n\tfor(int i=0;i<m;i++)\n\t\tcin >> b[i];\n\tfor(int i=0;i<n;i++)\n\t\tcin >> r[i];\n\n\tMaxFlow<1001> mf;\n\tfor(int i=0;i<m;i++){\n\t\tmf.add(0,i+1,1);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tmf.add(i+m+1,m+n+1,1);\n\t}\n\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(__gcd(b[i],r[j]) > 1){\n\t\t\t\tmf.add(i+1,j+m+1,1);\n\t\t\t\t// cerr << b[i] << \" \" << r[j] << \" \" << __gcd(b[i],r[j]) << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << mf.exec(0,m+n+1) << endl;\n\n\treturn true;\n}\n\nint main(void){\n\twhile(solve()){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b){\n\tif(b==0) return a;\n\treturn gcd(b, a % b);\n}\n\nconst int MAX_V = 1010;\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v){\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i){\n\t\tint u = G[v][i], w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; ++v){\n\t\tif (match[v] < 0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint m, n;\n\twhile (cin >> m >> n, V=m+n) {\n\t\tfor (int i = 0; i < V; ++i) G[i].clear();\n\t\tvector<int> b(m), r(n);\n\t\tfor (int i = 0; i < m; ++i) cin >> b[i];\n\t\tfor (int i = 0; i < n; ++i) cin >> r[i];\n\t\tfor (int i = 0; i < m; ++i){\n\t\t\tfor (int j = 0; j < n; ++j){\n\t\t\t\tif (gcd(b[i], r[j]) != 1){\n\t\t\t\t\tadd_edge(i, j+m);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <map>\n#include <ctime>\n#include <cstdlib>\n#include <cstdio>\n \nusing namespace std;\n \ntypedef pair<int, int> P;\ntypedef vector<double> array;\ntypedef vector<array> matrix;\nconst double EPS = 1e-8;\n\nint gcd(int a, int b){ return (b == 0 ? a : gcd(b, a%b)); }\n \nint rank(matrix &A){\n\tint n = A.size();\n  int res = 0;\n\tmatrix B(n, array(n+1,1));\n  for(int i=0;i<n;i++) for(int j=0;j<n;j++) B[i][j] = A[i][j];\n    \n  for(int i=0;i<n;i++){\n    int pivot = i;\n    for(int j=i;j<n;j++){\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n    }\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i]) > EPS) res++;\n    if(abs(B[i][i]) > EPS){\n      for(int j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n      for(int j=0;j<n;j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tfor(int k=i+1;k<=n;k++) B[j][k] -= B[j][i] * B[i][k];\n\t\t\t\t}\n      }\n    }\n  }\n  return res;\n}\n \nint main(){\n\tsrand((unsigned)time(NULL));\n\tint n, m;\n\twhile(1){\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(n == 0 && m == 0) break;\n\t\tvector<int> A(n), B(m);\n\t\tfor(int i=0;i<n;i++) scanf(\"%d\", &A[i]);\n\t\tfor(int i=0;i<m;i++) scanf(\"%d\", &B[i]);\n\t\tmatrix mat(n+m, array(n+m, 0));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(gcd(A[i], B[j]) > 1){\n\t\t\t\t\tint tmp = rand();\n\t\t\t\t\tmat[i][n+j] = tmp;\n\t\t\t\t\tmat[n+j][i] = -tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", rank(mat) / 2);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <map>\n#include <ctime>\n#include <cstdlib>\n \nusing namespace std;\n \ntypedef int lli;\ntypedef pair<lli, lli> P;\ntypedef vector<double> array;\ntypedef vector<array> matrix;\nconst double EPS = 1e-8;\n\nlli gcd(lli a, lli b){\n\treturn (b == 0 ? a : gcd(b, a%b));\n}\n \nlli rank(matrix &A){\n\tlli n = A.size();\n  lli res = 0;\n\tmatrix B(n, array(n+1,1));\n  for(lli i=0;i<n;i++) for(lli j=0;j<n;j++) B[i][j] = A[i][j];\n    \n  for(lli i=0;i<n;i++){\n    lli pivot = i;\n    for(lli j=i;j<n;j++){\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n    }\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i]) > EPS) res++;\n    if(abs(B[i][i]) > EPS){\n      for(lli j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n      for(lli j=0;j<n;j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tfor(lli k=i+1;k<=n;k++) B[j][k] -= B[j][i] * B[i][k];\n\t\t\t\t}\n      }\n    }\n  }\n  return res;\n}\n \nint main(){\n\tsrand((unsigned)time(NULL));\n\tlli n, m;\n\twhile(cin >> n >> m && (n|m)){\n\t\tvector<int> A(n), B(m);\n\t\tfor(int i=0;i<n;i++) cin >> A[i];\n\t\tfor(int i=0;i<m;i++) cin >> B[i];\n\t\tvector<P> edge;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(gcd(A[i], B[j]) > 1){\n\t\t\t\t\tedge.push_back(make_pair(i, n+j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlli ans = 0;\n\t\tmatrix mat(n+m, array(n+m, 0));\n\t\tfor(lli i=0;i<edge.size();i++){\n\t\t\tlli tmp = rand() + 10;\n\t\t\tlli a = edge[i].first, b = edge[i].second;\n\t\t\tmat[a][b] = tmp;\n\t\t\tmat[b][a] = -tmp;\n\t\t}\n\t\tcout << rank(mat) / 2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_V = 2000;\nconst int INF = 100000000;\n\n// &#65533;&#65533;&#65533;_&#65533;&#65533;\nint V;\n// &#65533;O&#65533;&#65533;&#65533;t&#65533;&#771;&#65533;&#65533;X&#65533;g&#65533;\\&#65533;&#65533;\nvector<int> G[MAX_V];\n// &#65533;}&#65533;b&#65533;`&#65533;&#65533;&#65533;O&#65533;&#771;y&#65533;A\nint match[MAX_V];\n// dfs&#65533;&#322;&#65533;&#65533;&#322;&#594;&#65533;&#65533;&#1474;&#65533;&#65533;&#65533;&#65533;&#450;&#65533;&#65533;&#65533;&#65533;&#771;t&#65533;&#65533;&#65533;O\nstatic bool used[MAX_V];\n\n// u&#65533;&#65533;v&#65533;&#65533;&#1301;&#1218;&#65533;O&#65533;&#65533;&#65533;t&#65533;&#594;&#457;&#65533;\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\n// &#65533;&#65533;&#65533;&#65533;p&#65533;X&#65533;&#65533;dfs&#65533;&#338;T&#65533;&#65533;\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i],w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// &#65533;&#349443;O&#65533;&#65533;&#65533;t&#65533;&#781;&#337;&#65533;}&#65533;b&#65533;`&#65533;&#65533;&#65533;O&#65533;&#65533;&#1986;&#65533;\nint bipartite_matching(){\n\tint res = 0;\n\t//memset(match,-1,sizeof(match));\n\tfor(int i = 0; i < MAX_V; i++)\n\t\tmatch[i]=-1;\n\tfor(int v = 0; v < V; v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int a,int b){\n\tif(b==0)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\n\n\nint main(){\n\n\tint n,m;\n\tvector<int> bs,rs;\n\tint b,r;\n\n\twhile(cin>>m>>n&&!(m==0&&n==0)){\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\tG[i].clear();\n\n\t\tV=n+m;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin>>b;\n\t\t\tbs.push_back(b);\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>r;\n\t\t\trs.push_back(r);\n\t\t}\n\t\tfor(int i = 0; i < rs.size(); i++){\n\t\t\tfor(int j = 0;j < bs.size(); j++){\n\t\t\t\tint res=gcd(rs[i],bs[j]);\n\t\t\t\tif(res>1)\n\t\t\t\t\tadd_edge(i,j+rs.size());\n\t\t\t}\n\t\t}\n\t\tcout<<bipartite_matching()<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main() {\n\tint m, n, red[500], blue[500], num[10];\n\tcin >> m >> n;\n\n\n\tfor (int i = 0; i < m; i++) {\n\t\t//cout << \"redcardテ・ツ?、テ」ツつ津・ツ?・テ・ツ環崚」ツ?療」ツ?ヲテ」ツ?湘」ツ??」ツ?陛」ツ?? << endl;\n\t\tcin >> red[i];\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\t//cout << \"bluecardテ」ツ?ョテ・ツ?、テ」ツつ津・ツ?・テ・ツ環崚」ツ?療」ツ?ヲテ」ツ?湘」ツ??」ツ?陛」ツ?? << endl;\n\t\tcin >> blue[i];\n\t}\n\n\tint a;\n\tfor (int j = 0; j < m; j++) {\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (red[i] < red[i + 1]) {\n\t\t\t\ta = red[i];\n\t\t\t\tred[i] = red[i + 1];\n\t\t\t\tred[i + 1] = a;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tint b;\n\tfor (int j = 0; j < n; j++) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (blue[i] < blue[i + 1]) {\n\t\t\t\tb = blue[i];\n\t\t\t\tblue[i] = blue[i + 1];\n\t\t\t\tblue[i + 1] = b;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t////////////////////テ」ツつステ」ツδシテ」ツδ暗・ツョツ古、ツコツ?\n\n\tint x=0, ans;\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (red[i] == blue[j]) {\n\t\t\t\tcout << red[i] << \"テ・ツ青古」ツ?佚・ツ?、\" << endl;\n\t\t\t\tblue[j] = 0;\n\t\t\t\tx++;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tif (red[i] < blue[j]) {\n\t\t\t\t\tfor (int k = i; k <= 1000; k++) {\n\t\t\t\t\t\tans = red[i] * k;\n\t\t\t\t\t\tif (ans == blue[j]){\n\t\t\t\t\t\t\tcout << \"red= \" << red[i] << \"blue=\" << blue[j] << endl;\n\t\t\t\t\t\t\tblue[j] = 0;\n\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\telse if (red[i] > blue[j]) {\n\t\t\t\t\tfor (int k = i; k <= 1000; k++) {\n\t\t\t\t\t\tans = blue[j] * k;\n\t\t\t\t\t\tif (ans == red[j]) {\n\t\t\t\t\t\t\tcout << \"red=\" << red[i] << \"blue=\" << blue[j];\n\t\t\t\t\t\t\tblue[j] = 0;\n\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}break;\n\n\t\t\t}\n\n\t\t}\n\t}\n\tcout << x << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\nconst int INF = 1000000000;\n\ntypedef pair<int,int> pii;\n\nclass Edge{\n\tpublic:\n\tint a,b,c,f;\n\tEdge(int a,int b,int c,int f):a(a),b(b),c(c),f(f){}\n};\n\nclass Flow{\n\tpublic:\n\tstatic const int N = 1111;\n\tstatic const int INF = 1000000000;\n\t\n\tvector<Edge> e[N];\n\tvector<pii> r[N];\n\t\n\tvoid addEdge(int a,int b,int c){\n\t\te[a].push_back(Edge(a,b,c,0));\n\t\tr[b].push_back(pii(a,e[a].size()-1));\n\t}\n\tint visit[N];\n\tint flow(int p, int f, int end){\n\t\tif(p==end)return f;\n\t\tif(visit[p]==1)return 0;\n\t\tvisit[p]=1;\n\t\t\n\t\trep(i,e[p].size()){\n\t\t\tint d = e[p][i].c - e[p][i].f;\n\t\t\tif(d > 0){\n\t\t\t\tint val = flow(e[p][i].b, min(f,d), end);\n\t\t\t\tif(val!=0){\n\t\t\t\t\te[p][i].f += val;\n\t\t\t\t\treturn val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,r[p].size()){\n\t\t\tint r1 = r[p][i].first;\n\t\t\tint r2 = r[p][i].second;\n\t\t\tint d = e[r1][r2].f;\n\t\t\tif(d > 0){\n\t\t\t\tint val = flow(e[r1][r2].a, min(f,d), end);\n\t\t\t\tif(val!=0){\n\t\t\t\t\te[r1][r2].f -= val;\n\t\t\t\t\treturn val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint solve(int start, int end){\n\t\tint ans = 0;\n\t\twhile(1){\n\t\t\trep(i,N)visit[i]=0;\n\t\t\tint val = flow(start, INF, end);\n\t\t\tif(val==0)break;\n\t\t\tans += val;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nconst int S = 4000;\nint sosu[S];\nvector<int> prime;\nint sosuInit(){\n\tsosu[0]=sosu[1]=1;\n\trep(i,S){\n\t\tif(sosu[i]==1)continue;\n\t\tfor(int j=i*2;j<S;j+=i)sosu[j]=1;\n\t\tprime.push_back(i);\n\t}\n}\n\nmap<int, vector<int> > canop;\n\nint main(){\n\tsosuInit();\n\t\n\tA:;\n\t\n\tcanop.clear();\n\t\n\tint n,m;\n\tcin>>n>>m;\n\t\n\tif(n==0 && m==0)return 0;\n\t\n\tFlow flow;\n\t\n\trep(i,n){\n\t\tint a;\n\t\tcin>>a;\n\t\trep(j,prime.size()){\n\t\t\tif(a%prime[j]==0){\n\t\t\t\tcanop[prime[j]].push_back(i+1);\n\t\t\t\ta/=prime[j];\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\tif(a!=1)canop[a].push_back(i+1);\n\t\tflow.addEdge(0,i+1,1);\n\t}\n\t\n\trep(i,m){\n\t\tint b;\n\t\tcin>>b;\n\t\trep(j,prime.size()){\n\t\t\tif(b%prime[j]==0){\n\t\t\t\trep(k,canop[prime[j]].size()){\n\t\t\t\t\tflow.addEdge(canop[prime[j]][k], i+n+1, 1);\n\t\t\t\t}\n\t\t\t\tb/=prime[j];\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\tif(b!=1){\n\t\t\trep(k,canop[b].size()){\n\t\t\t\tflow.addEdge(canop[b][k], i+n+1, 1);\n\t\t\t}\n\t\t}\n\t\tflow.addEdge(i+n+1, n+m+1, 1);\n\t}\n\t\n\tint ans = flow.solve(0, n+m+1);\n\tprintf(\"%d\\n\",ans);\n\t\n\tgoto A;\n}\n/*\n\n4 3\n2 6 6 15\n2 3 5\n0 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nvector<int> blue;\nvector<int> red;\nvector<int> redpair;\nvector<int> v;\nvector<vector<int> > c;\n\nint m = 0;\nint n = 0;\n\nint gcd(int x,int y){\n    if(x % y == 0){\n        return y;\n    }\n    return gcd(y,x%y);\n}\n\nbool match(int x){\n    if(x == -1){\n        return 1;\n    }\n    for(int i = 0;i < n;i++){\n        if(c[x][i] == 1 && v[i] == 0){\n            v[i] = 1;\n            if(match(redpair[i])){\n                redpair[i] = x;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\n\nint main(){\n    while(cin >> m >> n){\n        if(m == 0 && n == 0){\n            break;\n        }\n        blue.clear();\n        red.clear();\n        redpair.clear();\n        v.clear();\n        c.clear();\n        for(int i = 0;i < m;i++){\n            int tmp = 0;\n            cin >> tmp;\n            blue.push_back(tmp);\n        }\n        for(int i = 0;i < n;i++){\n            int tmp = 0;\n            cin >> tmp;\n            red.push_back(tmp);\n            redpair.push_back(-1);\n            v.push_back(0);\n        }\n        for(int i = 0;i < m;i++){\n            c.push_back(vector<int>());\n            for(int j = 0;j < n;j++){\n                c[i].push_back(gcd(blue[i],red[j]) != 1);\n            }\n        }\n        int ans = 0;\n        for(int i = 0;i < m;i++){\n            for(int j = 0;j < n;j++){\n                v[j] = 0;\n            }\n            if(match(i)){ans++;}\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define INF 1e9\n\nint gcd(int a,int b){return b==0 ? a : gcd(b,a%b);}\n\nvector<vector<int>> g;\n\nbool dfs(int v,vector<int> &match,vector<bool> &used){\n    used[v] = true;\n    for(int u : g[v]){\n        int w = match[u];\n        if(w<0 || (!used[w] && dfs(w,match,used))){\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n \nint bipartite_matching() {\n    int res = 0;\n    int V = g.size();\n    vector<int> match(V, -INF);\n    rep(v,V){\n        if(match[v] < 0){\n            vector<bool> used(V, false);\n            if(dfs(v,match,used)){\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nint main(void){\n    int m,n;\n    while(cin>>m>>n, n|m){\n        vector<int> b(m),r(n);\n        g.clear();\n        g.resize(m+n);\n        rep(i,m) cin>>b[i];\n        rep(i,n) cin>>r[i];\n\n        rep(i,m)rep(j,n){\n            if(gcd(b[i],r[j]) > 1){\n                g[i].push_back(m+j);\n                g[m+j].push_back(i);\n            }\n        }\n        cout<<bipartite_matching()<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint V;\nvector<int> G[2000];\nint match[2000];\nbool used[2000];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<(int)G[v].size();i++){\n    int u=G[v][i],w=match[u];\n\n    if( w<0 || !used[w] && dfs(w) ){\n\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\n\nint m,n;\nint b[500],r[500];\n\nint main(){\n  while(cin>>m>>n){\n    if(m==0&&n==0)break;\n\n    for(int i=0;i<m;i++)cin>>b[i];\n    for(int i=0;i<n;i++)cin>>r[i];\n\n    for(int i=0;i<2000;i++)G[i].clear();\n\n    //for(int i=0;i<m;i++)add_edge(n+m,i);\n    //for(int i=0;i<n;i++)add_edge(m+i,n+m+1);\n\n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n\tif( __gcd(b[i],r[j])> 1 )add_edge(i,m+j);\n      }\n    }\n\n    V=m;\n    cout<<bipartite_matching()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nstruct edge\n{\n  int to;\n  int from;\n  int cap;\n  int rev;\n};\n\nint s=0, t;\nbool visited[1010];\nvector<edge> g[1010];\nint red_card[510], blue_card[510];\n\nint max_flow();\nint get_card();\nvoid print_g();\nint dfs(int node, int f);\n\nvoid clear()\n{\n  for(int i=0;i<1000;i++)\n    {\n      g[i].clear();\n    }\n}\n\nint main()\n{\n  while(true)\n    {\n      clear();\n      if(get_card()==-1)\n\t{\n\t  break;\n\t}\n  cout << max_flow() << endl;\n  //print_g();\n    }\n  return 0;\n}\n  \nvoid print_g()\n{\n  for(int i=0;i<=t;i++)\n    {\n      for(int j=0;j<g[i].size();j++)\n\t{\n\t  if(g[i][j].cap!=0)\n\t    {\n\t  cout << \"{\" << g[i][j].from << g[i][j].to << g[i][j].cap << g[i][j].rev << \"}\";\n\t    }\n\t}\n      cout << endl;\n    }\n}\n\nint max_flow()\n{\n  int sum = 0, f=0;\n  \n  while(1)\n    {\n      fill(visited ,visited+1000, false);\n      f = dfs(s, INT_MAX/3);\n      \n      if(f==0)\n\t{\n\t  break;\n\t}\n      sum += f;\n    }\n  return sum;\n}\n\n\nint dfs(int node, int f)\n{\n  //  cout << \"node:\" <<node << \" f:\" << f;\n  int d = 0;\n \n  if(node == t)//goal\n    {\n      //  cout <<\"f:\"<< f << endl;\n      return f;\n    }\n  else if(visited[node]==true)// if visited\n    {\n      return -1;\n    }\n  else\n    {\n      visited[node]=true;//visited\n    }\n\n  for(int i=0;i<g[node].size();i++)//root form node\n    {\n      edge& e = g[node][i];\n      // cout <<\" e,to:\"  <<e.to <<endl;\n      if(e.cap != 0)\n\t{\n\t  d = dfs(e.to, min(f, e.cap));\n\t  /*if(dfs(g[node][i].to, f) == 1)\n\t    {\n\t    return 1;\n\t    }*/\n\t  //   cout << \"node:\" << node << \" f:\" << f << \" d:\" << d << endl;      \n\t  if(d>0)\n\t    {\n\t      e.cap -= d;\n\t      g[e.to][e.rev].cap += d;\n\t      \n\t      return d;\n\t    }\n\t}\n\n    }\n  return 0;\n}\n\n\nvoid add_edge(int i, int j)\n{\n  g[i].push_back({j, i, 1, (int)g[j].size()});\n  g[j].push_back({i, j, 0, (int)g[i].size()-1});\n}\n\nint get_card()\n{\n  int red, blue;\n  cin >> blue >> red;\n  if(blue == 0)\n    {\n      return -1;\n    }\n  for(int i=0;i<blue;i++)\n    {\n      cin >> blue_card[i];\n    }\n  for(int i=0;i<red;i++)\n    {\n      cin >> red_card[i];\n    }\n  \n  \n  for(int i=0;i<blue;i++)\n    {\n      for(int j=0;j<red;j++)\n\t{\n\t  if(__gcd(blue_card[i], red_card[j])!=1)\n\t    {// to from cap rev\n\t      add_edge(i+1, j+blue+1);\n\t      //g[i+1].push_back({j+blue+1, i+1, 1,(int)g[j+1].size()});\n\t      //g[j+1].push_back({i+1, j+blue+1, 0, (int)g[i+1].size()-1});\n\t    }\n\t}\n    }\n\n   for(int i=1;i<=blue;i++)\n    {\n      add_edge(0, i);\n      //g[0].push_back({i, 0, 1, (int)g[i].size()});\n      //g[i].push_back({0, i, 0, (int)g[0].size()-1});\n    }\n\n   t = blue+red+1;\n   for(int i=blue+1;i<t;i++)\n     {\n       add_edge(i, t);\n       //g[i].push_back({t, i, 1, (int)g[t].size()});\n       // g[t].push_back({i, t, 0, (int)g[i].size()-1});\n     }\n\n   /*  for(int i=0;i<=t;i++)\n    {\n      for(int j=0;j<g[i].size();j++)\n\t{\n\t  cout << \"{\" << g[i][j].from << g[i][j].to << g[i][j].cap << g[i][j].rev << \"}\";\n\t}\n      cout << endl;\n    }\n   */return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint V;\nvector<int> G[1010];\nint match[1010];\nbool used[1010];\n\nvoid add_edge(int u, int v) {\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tint u = G[v][i];\n\t\tint w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching() {\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; v++) {\n\t\tif (match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nlong long int gcd(long long int a, long long int b) {\n\tif (b == 0) {\n\t\treturn a;\n\t}\n\telse {\n\t\treturn gcd(b, a%b);\n\t}\n}\n\nint main() {\n\tint m, n;\n\twhile (cin >> m >> n) {\n\t\tif (m == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 1010; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t\tV = m + n;\n\t\tvector<long long int> b(m);\n\t\tvector<long long int> r(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> b[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> r[i];\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (gcd(b[i], r[j]) != 1) {\n\t\t\t\t\tadd_edge(i, m+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nusing namespace std;\n\nbool coprime(int a,int b){\n\tfor(int t;b;t=a,a=b,b=t)\ta%=b;\n\treturn a==1;\n}\n\nint capa[1002][1002],flow[1002][1002],src,snk,sz;\n\nbool findAugPath(int u,int *path,int &len,bool *visited,int i=0){\n//if(i>10){puts(\"error\");return false;}\n//for(int j=0;j<i;j++)putchar(' ');printf(\"%d\\n\",u);\n\tpath[i]=u;\n\tvisited[u]=true;\n\tif(u==snk){ len=i+1; return true; }\n\tfor(int v=0;v<sz;v++){\n\t\tif(!visited[v] && capa[u][v]-flow[u][v]>0){\n//\t\t\tvisited[v]=true;\n\t\t\tbool b=findAugPath(v,path,len,visited,i+1);\n//\t\t\tvisited[v]=false;\n\t\t\tif(b)\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tfor(int m,n;scanf(\"%d%d\",&m,&n),m;){\n\t\tstatic int blue[500],red[500];\n\t\tfor(int i=0;i<m;i++)\tscanf(\"%d\",blue+i);\n\t\tfor(int j=0;j<n;j++)\tscanf(\"%d\",red+j);\n\n\t\tsrc=0,snk=m+n+1,sz=m+n+2;\n\t\tfor(int i=0;i<sz;i++)for(int j=0;j<sz;j++){\n\t\t\tcapa[i][j]=0;\n\t\t\tflow[i][j]=0;\n\t\t}\n\n\t\tfor(int i=0;i<m;i++)\tcapa[src][1+i]=1;\n\t\tfor(int i=0;i<m;i++)for(int j=0;j<n;j++){\n\t\t\tif(!coprime(blue[i],red[j]))\tcapa[1+i][1+m+j]=1;\n\t\t}\n\t\tfor(int j=0;j<n;j++)\tcapa[1+m+j][snk]=1;\n\n//for(int i=0;i<sz;i++){for(int j=0;j<sz;j++)printf(\"%2d \",capa[i][j]);puts(\"\");}puts(\"\");\n\t\tstatic int path[1002],len;\n\t\tstatic bool visited[1002];\n\t\twhile(1){\n\t\t\tfor(int u=0;u<sz;u++)\tvisited[u]=false;\n\t\t\tif(!findAugPath(src,path,len,visited))\tbreak;\n\t\t\tfor(int i=1,u=path[0];i<len;i++){\n\t\t\t\tint v=path[i];\n\t\t\t\tflow[u][v]++;\n\t\t\t\tflow[v][u]--;\n\t\t\t\tu=v;\n\t\t\t}\n//for(int i=0;i<sz;i++){for(int j=0;j<sz;j++)printf(\"%2d\",flow[i][j]);puts(\"\");}puts(\"\");\n\t\t}\n\n\t\tint maxmatch=0;\n\t\tfor(int i=0;i<m;i++)for(int j=0;j<n;j++){\n\t\t\tif(flow[1+i][1+m+j]==1)\tmaxmatch++;\n\t\t}\n\t\tprintf(\"%d\\n\",maxmatch);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n\ntypedef long long lint;\ntypedef pair<int, int> pii;\n\nint n, m;\nint b[550], r[550];\n\nint gcd(int _a, int _b) {\n\treturn _b != 0 ? gcd(_b, _a % _b) : _a;\n}\n\ntypedef int flow_type;\n\nstruct DN_Edge {\n\tint to; flow_type cost; int rev;\n\tDN_Edge(int _to, flow_type _cost, int _rev) : to(_to), cost(_cost), rev(_rev) {}\n};\n\nstruct Dinic {\n\tint V;\n\tvector< vector< DN_Edge > > edges;\n\tvector<int> level, iter;\n\t\n\tDinic(int _n) : V(_n), edges(_n, vector<DN_Edge>()), level(_n, -1), iter(_n, 0) {}\n\t\n\tvoid add_edge(int _f, int _t, flow_type _c) {\n\t\tedges[_f].push_back(DN_Edge(_t, _c, size_of(edges[_t])));\n\t\tedges[_t].push_back(DN_Edge(_f, 0, size_of(edges[_f]) - 1));\n\t}\n\t\n\tvoid bfs(int _s) {\n\t\tfill(allof(level), -1);\n\t\tqueue<int> q; q.push(_s);\n\t\tlevel[_s] = 0;\n\t\t\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tint e_size = size_of(edges[v]);\n\t\t\t\n\t\t\tfor_(i,0,e_size) {\n\t\t\t\tDN_Edge e = edges[v][i];\n\t\t\t\tif (e.cost > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tflow_type dfs(int _v, int _t, flow_type _f) {\n\t\tif (_v == _t) return _f;\n\t\tint e_size = size_of(edges[_v]);\n\t\t\n\t\tfor (int &i = iter[_v]; i < e_size; ++i) {\n\t\t\tDN_Edge &e = edges[_v][i];\n\t\t\t\n\t\t\tif (e.cost > 0 && level[_v] < level[e.to]) {\n\t\t\t\tflow_type d = dfs(e.to, _t, min(_f, e.cost));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cost -= d;\n\t\t\t\t\tedges[e.to][e.rev].cost += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tflow_type max_flow(int _s, int _t) {\n\t\tflow_type flow = flow_type();\n\t\twhile (1) {\n\t\t\tbfs(_s);\n\t\t\tif (level[_t] < 0) return flow;\n\t\t\tfill(allof(iter), 0);\n\t\t\tflow_type f;\n\t\t\twhile ((f = dfs(_s, _t, (int)1e9)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nvoid solve() {\n\tDinic dinic(n + m + 10);\n\tfor_(i,0,m) dinic.add_edge(n + m + 1, i, 1);\n\tfor_(i,0,n) dinic.add_edge(m + i, n + m + 2, 1);\n\tfor_(i,0,m) for_(j,0,n) if (gcd(b[i], r[j]) != 1) dinic.add_edge(i, m + j, 1);\n\t\n\tcout << dinic.max_flow(n + m + 1, n + m + 2) << endl;\n}\n\nint main() {\n\twhile (cin >> m >> n, n) {\n\t\tfor_(i,0,m) cin >> b[i];\n\t\tfor_(i,0,n) cin >> r[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_V = 10000;\nconst int INF = 100000000;\n\n// ¸_\nint V;\n// OtÌXg\\»\nvector<int> G[MAX_V];\n// }b`OÌyA\nint match[MAX_V];\n// dfsÅ·ÅÉ²×½©Ç¤©ÌtO\nstatic bool used[MAX_V];\n\n// uÆvðÔÓðOtÉÇÁ\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\n// ÁpXðdfsÅT·\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i],w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// ñOtÌÅå}b`Oðßé\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\t//for(int i = 0; i < sizeof(match); i++){\n\t//\tif(i==sizeof(match)-1){\n\t//\t\tcout<<endl;\n\t//\t}\n\t//\tmatch[i] = -1;\n\t//}\n\tfor(int v = 0; v < V; v++){\n\t\tif(match[v] < 0){\n\t\t\tfor(int i = 0; i < sizeof(used); i++)\n\t\t\t\tused[i] = 0;\n//\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int a,int b){\n\tif(b==0)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\n\n\nint main(){\n\n\tint n,m;\n\twhile(cin>>m>>n&&!(m==0&&n==0)){\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\tG[i].clear();\n\n\t\tvector<int> bs,rs;\n\t\tint b,r;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin>>b;\n\t\t\tbs.push_back(b);\n\t\t\tV++;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>r;\n\t\t\trs.push_back(r);\n\t\t\tV++;\n\t\t}\n\t\tfor(int i = 0; i < rs.size(); i++){\n\t\t\tfor(int j = 0;j < bs.size(); j++){\n\t\t\t\tint res=gcd(rs[i],bs[j]);\n\t\t\t\tif(res!=1)\n\t\t\t\t\tadd_edge(i,j+rs.size());\n\t\t\t}\n\t\t}\n\t\tcout<<bipartite_matching()<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nint gcd(int a, int b) {\n    return b ? gcd(b, a % b) : a;\n}\n\nnamespace Flow {\n    struct Edge {\n        int to, capacity, cost, reverse;\n        Edge(int to, int capacity, int cost, int reverse) :\n            to(to), capacity(capacity), cost(cost), reverse(reverse) {}\n    };\n    template <int MaxN> class PrimalDual {\n        int n = MaxN;\n        vector<Edge> g[MaxN];\n    public:\n        void clear(int n) {\n            this->n = n;\n            for (int i = 0; i < n; ++i)\n                g[i].clear();\n        }\n        void push(int from, int to, int capacity = 1, int cost = 0) {\n            g[from].emplace_back(to, capacity, cost, g[to].size());\n            g[to].emplace_back(from, 0, -cost, g[from].size() - 1);\n        }\n        pair<int, int> flow(int s, int t, int f = 1 << 30) {\n            int flow = f, cost = 0;\n            static int prevv[MaxN], preve[MaxN], dist[MaxN], h[MaxN];\n            fill(h, h + n, 0);\n            while (flow > 0) {\n                fill(dist, dist + n, 1 << 30);\n                dist[s] = 0;\n                using P = pair<int, int>;\n                priority_queue<P, vector<P>, greater<P>> q;\n                for (q.emplace(0, s); q.size(); ) {\n                    auto p = q.top();\n                    q.pop();\n                    int v = p.second;\n                    if (dist[v] < p.first) continue;\n                    for (auto& e : g[v]) {\n                        int d = dist[v] + e.cost + h[v] - h[e.to];\n                        if (e.capacity > 0 && dist[e.to] > d) {\n                            dist[e.to] = d;\n                            prevv[e.to] = v;\n                            preve[e.to] = &e - &g[v][0];\n                            q.emplace(d, e.to);\n                        }\n                    }\n                }\n                if (dist[t] == 1 << 30) break;\n                for (int v = 0; v < n; ++v)\n                    h[v] += dist[v];\n                int d = flow;\n                for (int v = t; v != s; v = prevv[v])\n                    d = min(d, g[prevv[v]][preve[v]].capacity);\n                flow -= d;\n                cost += d * h[t];\n                for (int v = t; v != s; v = prevv[v]) {\n                    auto& e = g[prevv[v]][preve[v]];\n                    e.capacity -= d;\n                    g[v][e.reverse].capacity += d;\n                }\n            }\n            return { f - flow, cost };\n        }\n    };\n}\n\nint main() {\n    Flow::PrimalDual<1002> pd;\n    for (int m, n; cin >> m >> n, m && n; ) {\n        vector<int> a(m), b(n);\n        for (int& i : a)\n            cin >> i;\n        for (int& i : b)\n            cin >> i;\n        pd.clear(m + n + 2);\n        for (int i = 0; i < m; ++i)\n            pd.push(m + n, i);\n        for (int i = 0; i < n; ++i)\n            pd.push(i + m, m + n + 1);\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (gcd(a[i], b[j]) > 1)\n                    pd.push(i, j + m);\n            }\n        }\n        cout << pd.flow(m + n, m + n + 1).first << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<list>\n//GCD\nint F(int x,int y)\n{\n\tif(!y)return x;\n\treturn F(y,x%y);\n}\ntypedef std::list<int>L;\nL e[1002];\nint m,n;\nbool f[1002];\nint G(int s,int d)\n{\n\tif(s==d)return 1;\n\tif(f[s])return 0;\n\tf[s]=1;\n\tint res=0;\n\tfor(L::iterator i=e[s].begin();i!=e[s].end();++i)\n\t{\n\t\tif(G(*i,d))\n\t\t{\n\t\t\te[*i].push_back(s);\n\t\t\te[s].erase(i);\n\t\t\tres=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tf[s]=0;\n\treturn res;\n}\nint main()\n{\n\tint a[100],i,j,x;\n\twhile(scanf(\"%d%d\",&m,&n),m)\n\t{\n\t\tfor(i=0;i<m+n+2;++i)e[i].clear();\n\t\tfor(i=0;i<m;++i)scanf(\"%d\",&a[i]),e[m+n].push_back(i);\n\t\tfor(j=0;j<n;++j)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tfor(i=0;i<m;++i)if(F(a[i],x)>1)e[i].push_back(m+j);\n\t\t\te[m+j].push_back(m+n+1);\n\t\t}\n\t\tfor(x=0;G(m+n,m+n+1);)++x;\n\t\tprintf(\"%d\\n\",x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX_V 1010\n\nconst int INF = 1e9;\n\nstruct edge{ int to, cap, rev; };\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0 ; i < (int)G[v].size() ; i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t){\n  int flow = 0;\n  for(; ;){\n    memset(used, 0, sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nvoid init(){\n  for(int i = 0 ; i < MAX_V ; i++) G[i].clear();\n  memset(used, 0, sizeof(used));\n}\n\nbool ok(int a, int b){\n  return __gcd(a, b) != 1;\n}\n\nint main(){\n  int N, M;\n  while(cin >> N >> M, N|M){\n    init();\n    \n    int source = M+N;\n    int tink = source + 1;\n    \n    vector<int> A(N), B(M);\n    for(int i = 0 ; i < N ; i++) cin >> A[i];\n    for(int i = 0 ; i < M ; i++) cin >> B[i];\n    \n    for(int i = 0 ; i < N ; i++){\n      for(int j = 0 ; j < M ; j++){\n\tif( ok(A[i], B[j]) ) add_edge(i, N+j, 1);\n      }\n    }\n    \n    for(int i = 0 ; i < N ; i++) add_edge(source, i, 1);\n    for(int i = 0 ; i < M ; i++) add_edge(N+i, tink, 1);\n    \n    cout << max_flow(source, tink) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define DECIM8  fixed<<setprecision(8) \n#define SZ(a) int((a).size())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nusing namespace std;\nstruct edge { int to,cap,rev; };\nvector<vector<edge> > G;\nint gcd(int a,int b)\n{\n  if(!a||!b) return a+b;\n  return gcd(b%a,a);\n}\nvoid add_edge(int from,int to,int cap)\n{\n  G[from].PB((edge){to,cap,SZ(G[to])});\n  G[to].PB((edge){to,0,SZ(G[from])-1});\n}\nvoid flow_edge(int from,int ind,int val)\n{\n  edge &e=G[from][ind];\n  e.cap-=val;\n  G[e.to][e.rev].cap+=val;\n  //cout << from  << ' ' << e.to << endl;\n}\nvector<int> EK(int so,int si)\n{\n  set<int> already;\n  queue<pair<vector<int>,int> > bfs;\n  // path, pos\n  bfs.push(MP(vector<int>(),so));\n  while(!bfs.empty()){\n    vector<int> path;\n    int lastpos;\n    tie(path,lastpos)=bfs.front(); bfs.pop();\n    if(lastpos==si) return path;\n    if(!already.insert(lastpos).second) continue;\n    REP(i,SZ(G[lastpos])){\n      edge &e=G[lastpos][i];\n      if(e.cap<=0) continue;\n      vector<int> nextpath(path);\n      nextpath.PB(i);\n      int nextpos=e.to;\n      bfs.push(MP(nextpath,nextpos));\n    }\n  }\n  return vector<int>();\n}\nint flowpath(int so,int si)\n{\n  int answer=INT_MAX;\n  vector<int> path=EK(so,si);\n  if(path.empty()) return 0;\n  for(int i=0,pos=so;i<SZ(path);++i){\n    edge &e=G[pos][path[i]];\n    answer=min(answer,e.cap);\n    pos=e.to;\n  }\n  for(int i=0,pos=so;i<SZ(path);++i){\n    flow_edge(pos,path[i],answer);\n    pos=G[pos][path[i]].to;\n  }\n  return answer;\n}\nint mflow(int so,int si)\n{\n  int answer=0;\n  int tmp;\n  while(tmp=flowpath(so,si)) answer+=tmp;\n  return answer;\n}\nint main(void)\n{\n  for(;;){\n    int m,n;\n    cin >> m >> n;\n    if(!m&&!n) return 0;\n    vector<int> b;\n    b.reserve(m);\n    REP(i,m) cin >> b[i];\n    vector<int> r;\n    r.reserve(n);\n    REP(j,n) cin >> r[j];\n    G.reserve(m+n+2);\n    REP(i,m) add_edge(m+n,i,1);\n    REP(i,m) REP(j,n) if(gcd(b[i],r[j])!=1) add_edge(i,m+j,1);\n    REP(j,n) add_edge(m+j,m+n+1,1);\n    cout << mflow(m+n,m+n+1) << endl;\n    G.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst int MAX_V = 1000;\nint V; //????????°\nvector<int> G[MAX_V]; //??°??????\nint match[MAX_V]; // ??????????????°????????¢\nbool used[MAX_V]; // dfs??§??¢???????????????\n\nvoid add_edge(int u, int v){\n    G[u].push_back(v); G[v].push_back(u);\n}\n\n// ?¢???????????????¢?´¢\nbool bp_dfs(int v){\n    used[v]=true;\n    rep(i,G[v].size()){\n        int u=G[v][i], w=match[u];\n        if(w<0 || (!used[w]&&bp_dfs(w))){\n            match[v]=u; match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(){\n    int ret=0;\n    memset(match,-1,sizeof(match));\n    rep(i,V){\n        if(match[i]<0){\n            memset(used,0,sizeof(used));\n            if(bp_dfs(i)) ++ret;\n        }\n    }\n    return ret;\n}\n\nvector<int> divisor(int n)\n{\n    vector<int> ret;\n    for(int i=1; i*i<=n; ++i)\n    {\n        if(n%i==0)\n        {\n            ret.pb(i);\n            if(i != n/i) ret.pb(n/i);\n        }\n    }\n    sort(all(ret));\n    return ret;\n}\n\nbool same_factor(const vector<int>& a, const vector<int>& b)\n{\n    int A=a.size(), B=b.size();\n    int x=1, y=1;\n\n    while(x<A && y<B)\n    {\n        if(a[x]>b[y]) ++y;\n        else if(a[x]<b[y]) ++x;\n        else return true;\n    }\n\n    return false;\n}\n\nint main()\n{\n    int m,n;\n    while(scanf(\" %d %d\",&m,&n),m)\n    {\n        vector<int> b(m),r(n);\n        rep(i,m) scanf(\" %d\", &b[i]);\n        rep(i,n) scanf(\" %d\", &r[i]);\n\n        vector<int> B[500],R[500];\n        rep(i,m) B[i] = divisor(b[i]);\n        rep(i,n) R[i] = divisor(r[i]);\n\n        V = n+m;\n        rep(i,MAX_V) G[i].clear();\n\n        rep(i,m)rep(j,n)\n        {\n            if(same_factor(B[i],R[j])) add_edge(i,m+j);\n        }\n\n        printf(\"%d\\n\", bipartite_matching());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-11;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nclass Graph{\n\tprivate:\n\tint n;\n\tvvi g;\n\tpublic:\n\tvi match,used;\n\tbool BM_dfs(int v){\n\t\tused[v]=1;\n\t\tfor(auto u:g[v]){\n\t\t\tint w=match[u];\n\t\t\tif(w<0||!used[w]&&BM_dfs(w)){\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint BM(){\n\t\tint res=0;\n\t\tmatch=vi(n,-1);\n\t\tfor(int i=0;i<n;i++) if(match[i]<0){\n\t\t\tused=vi(n);\n\t\t\tif(BM_dfs(i)) res++;\n\t\t}\n\t\treturn res;\n\t}\n\tGraph(int v){\n\t\tn=v;\n\t\tg=vvi(v);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tg[s].push_back(t);\n\t\tg[t].push_back(s);\n\t}\n};\n\n\nll gcd(ll a,ll b){\n\tif(!b) return a;\n\treturn gcd(b,a%b);\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\twhile(1){\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\tGraph g(n+m);\n\t\tvi a(n),b(m);\n\t\tfor(int i=0;i<n;i++) cin>>a[i];\n\t\tfor(int i=0;i<m;i++) cin>>b[i];\n\t\tfor(int i=0;i<n;i++) for(int j=0;j<m;j++) if(gcd(a[i],b[j])>1) g.add_edge(i,n+j);\n\t\tcout<<g.BM()<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint gcd(int a, int b){\n  if (b == 0){\n    return a;\n  } else {\n    return gcd(b, a % b);\n  }\n}\nint main(){\n  while (1){\n    int m, n;\n    cin >> m >> n;\n    if (m == 0 && n == 0){\n      break;\n    }\n    vector<int> b(m);\n    for (int i = 0; i < m; i++){\n      cin >> b[i];\n    }\n    vector<int> r(n);\n    for (int i = 0; i < n; i++){\n      cin >> r[i];\n    }\n    int V = m + n + 2;\n    vector<set<int>> E(V);\n    for (int i = 0; i < m; i++){\n      for (int j = 0; j < n; j++){\n        if (gcd(b[i], r[j]) > 1){\n          E[i].insert(m + j);\n        }\n      }\n    }\n    for (int i = 0; i < m; i++){\n      E[V - 2].insert(i);\n    }\n    for (int j = 0; j < n; j++){\n      E[m + j].insert(V - 1);\n    }\n    int ans = 0;\n    while (1){\n      vector<int> prev(V, -1);\n      vector<bool> used(V, false);\n      used[V - 2] = true;\n      queue<int> Q;\n      Q.push(V - 2);\n      while (!Q.empty()){\n        int v = Q.front();\n        Q.pop();\n        for (int w : E[v]){\n          if (!used[w]){\n            used[w] = true;\n            prev[w] = v;\n            Q.push(w);\n          }\n        }\n      }\n      if (!used[V - 1]){\n        break;\n      } else {\n        int c = V - 1;\n        while (c != V - 2){\n          E[prev[c]].erase(c);\n          E[c].insert(prev[c]);\n          c = prev[c];\n        }\n        ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\n\ntemplate< typename flow_t >\nstruct FordFulkerson {\n  struct edge {\n    int to;\n    flow_t cap;\n    int rev;\n    bool isrev;\n  };\n\n  vector< vector< edge > > graph;\n  vector< int > used;\n  const flow_t INF;\n  int timestamp;\n\n  FordFulkerson(int n) : INF(numeric_limits< flow_t >::max()), timestamp(0) {\n    graph.resize(n);\n    used.assign(n, -1);\n  }\n\n  void add_edge(int from, int to, flow_t cap) {\n//  \tprintf(\"(from, to) = (%d, %d)\\n\", from, to);\n    graph[from].emplace_back((edge) {to, cap, (int) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, (int) graph[from].size() - 1, true});\n  }\n\n  flow_t dfs(int idx, const int t, flow_t flow) {\n    if(idx == t) return flow;\n    used[idx] = timestamp;\n    for(auto &e : graph[idx]) {\n      if(e.cap > 0 && used[e.to] != timestamp) {\n        flow_t d = dfs(e.to, t, min(flow, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  flow_t max_flow(int s, int t) {\n    flow_t flow = 0;\n    for(flow_t f; (f = dfs(s, t, INF)) > 0; timestamp++) {\n      flow += f;\n    }\n    return flow;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << e.cap + rev_e.cap << \")\" << endl;\n      }\n    }\n  }\n};\n\nint gcd(int a, int b){\n\tif(b == 0){\n\t\treturn a;\n\t}\n\telse{\n\t\treturn gcd(b, a % b);\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint M, N, i, j;\n\t\tscanf(\"%d%d\", &M, &N);\n\t\tif(N == 0 && M == 0){\n\t\t\treturn 0;\n\t\t}\n\t\tvector<int> b(M), r(N);\n\t\tfor(i = 0; i < M; i++){\n\t\t\tscanf(\"%d\", &b[i]);\n\t\t}\n\t\tfor(i = 0; i < N; i++){\n\t\t\tscanf(\"%d\", &r[i]);\n\t\t}\n\t\tFordFulkerson<int> g(N + M + 2);\n\t\tfor(i = 1; i <= M; i++){\n\t\t\tg.add_edge(0, i, 1);\n\t\t}\n\t\tfor(i = M + 1; i <= M + N; i++){\n\t\t\tg.add_edge(i, M + N + 1, 1);\n\t\t}\n\t\tfor(i = 0; i < M; i++){\n\t\t\tfor(j = 0; j < N; j++){\n\t\t\t\tif(gcd(b[i], r[j]) > 1){\n\t\t\t\t\tg.add_edge(1 + i, M + 1 + j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", g.max_flow(0, N + M + 1));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\n\n#define _GLIBCXX_DEBUG\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\n//const int INF = 2147483647;\n//const long long int L_INF = 9223372036854775807;\n\ntypedef int Weight;\n\nconst Weight INF = 1e9;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_, const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n\n//テヲツオツ?ゥツ??テ」ツ?ョテゥツ??ィツセツコテ」ツつづ・ツシツオテ」ツつ嘉」ツ?ェテ」ツ??」ツ?ィテヲツュツ」テ」ツ?療」ツ?湘ヲツアツづ」ツ?セテ」ツつ嘉」ツ?ェテ」ツ??」ツ?ョテ」ツ?ァテヲツウツィテヲツ??\nWeight maximumFlow(const Graph &ag, int s, int t) {\n\n\tGraph g(ag);\n\tfor (int i = 0; i < ag.size(); ++i) {\n\t\tfor (int j = 0; j < ag[i].size(); ++j) {\n\t\t\tint d = ag[i][j].dst;\n\t\t\tint s = ag[i][j].src;\n\n\t\t\tbool ok = false;\n\t\t\tfor (int k = 0; k < ag[d].size(); ++k) {\n\t\t\t\tif (ag[d][k].src == s) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tg[d].push_back(Edge(d, s, ZERO));\n\t\t\t}\n\t\t}\n\t}\n\tint n = g.size();\n\tMatrix flow(n, Array(n,ZERO)), capacity(n, Array(n,ZERO));\n\tREP(u, n) FOR(e, g[u]) capacity[e->src][e->dst] =capacity[e->src][e->dst]+ e->weight;\n\n\n\tWeight total = ZERO;\n\twhile (1) {\n\t\tqueue<int> Q; Q.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile (!Q.empty() && prev[t] < 0) {\n\t\t\tint u = Q.front(); Q.pop();\n\t\t\tFOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > ZERO) {\n\t\t\t\tprev[e->dst] = u;\n\t\t\t\tQ.push(e->dst);\n\t\t\t}\n\t\t}\n\t\tif (prev[t] < 0)break; // prev[x] == -1 <=> t-side\n\t\tWeight inc = INF;\n\t\tfor (int j = t; prev[j] != j; j = prev[j]){\n\t\t\tauto v(RESIDUE(prev[j], j));\n\t\t\tif (inc > v) {\n\t\t\t\tinc = v;\n\t\t\t}\n\t\t}\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tflow[prev[j]][j] =flow[prev[j]][j]+inc, flow[j][prev[j]] =flow[j][prev[j]]- inc;;\n\t\ttotal += inc;\n\t}\n\n\treturn total;\n}\n\nlong long int gcd(long long int l, long long int r) {\n\tassert(l > 0 && r > 0);\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tconst long long int num = r%l;\n\t\tif (num) {\n\t\t\treturn gcd(l, num);\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (1) {\n\t\tint M, N; cin >> M >> N;\n\t\tif (!M)break;\n\t\tvector<int>as(M), bs(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tcin >> as[i];\n\t\t}\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tcin >> bs[j];\n\t\t}\n\n\t\tconst int start = 0;\n\t\tconst int blue = 1;\n\t\tconst int red = blue + M;\n\t\tconst int goal = red + N;\n\t\tGraph g(goal + 1);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tg[start].push_back(Edge(start, blue + i, 1));\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (gcd(as[i],bs[j])!=1) {\n\t\t\t\t\tg[blue + i].push_back(Edge(blue + i, red + j, 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tg[red + i].push_back(Edge(red + i, goal, 1));\n\t\t}\n\t\tint ans = maximumFlow(g, start, goal);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*                                                                                 `\n                                                                                ``  `\n                                                                          . `   .g,`\n                   Welcome To My Coding Space!                          .MMe  `(F(#~ `.J,\n                                                                       `.M/7b. dD.N; (#=#:\n                                                                     ``  db (m.#` Wl(@ jF    `\n                                            ``    `  `          `   ..+kMMN;_(Y> `(TD  d$..gHN_\n                                     `   ``   ......   `  `  ` `..gMB61+1+dK `- `.    .TM@^(d%\n                               `` `` ..JggHHMMHHYYTHMMMNmgJ.. .kB6z?1+z1+<dD ..` .  ``.` `.V'\n                              ``..+HMBYC1?1+???=?====????1vTHMNe+1+dMB\"BMMM% .`je. `.. ..+@`\n                            `..gM9C1+?==??==?==?=?===??=??=?1?zTMNeJTHg..``...`.,S._`.` d$  `\n                      ` ` .(kBY1+==????=?=??=?=??=???=?=?=?=????+zTMm+?TMm..   ` d[ .``.M}\n                       `.(M9++?=????==???=?=??=?=?=?=?=?=?=?===?==1+7Mmx?MN,``..._^`.. (F      `\n     ` ` ` ` `  `      (M8++z11==?==??==??=?==?=?=?==??=??=??==??==?=+7Mm<dNg, ` .`.. (#!   `\n   ` `    ..(JgH@MMMMMMB1+=??=??=?????==11??1=1?1?=1+=11?1==?=1=??=??11+WNJdMt .``.` J#! `\n      .(HHYYC?1+??z>+H8+=??=?=?=???=?=?=z1&z1?==?1<dNs111?==1ux?==?=?==1zdNcW%  ..`. J#~`\n     `.WNx<?1?==1=zdMD+=?==?===?=?==?===<dNNx1z??==+WMN+g&&&xdMk1??=1===???MN}`.`.`. J#` `\n  `     ?MNc1=1?z?jH8+==?=?==??=jQ21=?=?(M$?WNx<1=zudMMMszOCvTHMmx+?1?z+1?zd#:..`.`. J@       `\n     `` .M81==?==>dM<??===?=?=?+dNy+?=?jM@ ` ?WNe+zO>dNcHmJ1+1JMMR1?z??Ne1<d#~.`..`. dF\n       (M3+1+?==?jMD+=?z1&&?v1+jMMb+=?1d#!`..``?HNx+?+HR ?Mm+1<dMMp?==<dNc<d#_.`..`.`dF  `\n      ,MHmax111=<dNC?=?=(M#ugH9M#W#6+?(M'`.`.... ?WNe<dM: .TNm<dN?Nm<=zzMR+M@` .``.. dF `\n   ` ``  _CM$+??1d#<==?=>dM9+?(MF(MI+jMf .`.``.`.. (TNaHr`.`.TNmN:(MR+?zMK(M$` `.`.``dF        `\n          J#<=1<jME+1?=1d9Mn1<jN! qN(d@_.`..`.`.`.```-7Y5.....,TB! (MmJ+MH(M: ...`.`.d$`\n     `   .M$iggWWMR+1?<dDjMNxjMB  .NgN``..``.`.``....`.d#Y\"\"\"YWNg.  .WNxW#J@ .`.`.``.H: `\n         _Y\"\"!  .M$jm+?1zd#TNzM}.. ?M% .`..`.`..``.`..  .+NMNg,.?Mm._ ?NMNM$ ..`..``.#    `\n                .HPj#z=?<d#_WM#:.JgHH6 .  `.`.`..``.`.`jMMF`.MMN..TN,  ?@jM}`..`.`.`JD   `\n           ` `   dbjMI?=+MF`.7XME^_.--,. ..`.``.`..`.`.M#XNgjNdMR. ?N-.  (#~``.``.. d%\n              `  d#<WR1z(Mt` (#' (MMBTHNe.`..`..`.`.` .M#UMMMM#W#_. zN.  dF`.`...`..H}  `\n                 ?MO(N+?jM:`.M!`.M9N+.-MMR `..`..`.`.`_?MmTMMMwM#~...H: .H}`..`..` (#`\n          `  `  ` WNJMR<dN_ JB  dNwMMMMNdM[`.`.`.`.`..  ,TNNggMB! .` ~ `(M `.`.``. dF\n                 `.MdMNoW@ `JP `(MKdMMNMdM}`.`..`.`.`.... .??!`.`.`..`..dD .`....`.W'\n                   ?MMMMMP `(R`..?MmyUWQMB ..`..`.`.`..`..`..`.`.`_`-.gM#!.`.``.``.@\n             `   `` _7NTMN.`.H/`. ,TMMB\"! .``.`.`..`.``.``.`..`.`. .,NIdb` .`..`  j$\n          `           Wm.M;`._!..`.`...`_`...``..   ...(+ga,`.....``(NjMr`..`... .#:\n                      .MpdN_.`. ``.``.`..`..(-JggkWY9YC<>;?Wp .``.` J#>dN, ..``.`dF`\n                      `_UmMn .`..`..`..`. JMYT1<;;;>>>>>;>>?Wo ..`. dK1=dN,`..``.MN+\n                        .dMMe .`.``.`.`.` d#<;>>>>;>>>>;>>>>(N,`.. -MK1llvWm.   JM?Mp. ` `\n                     ` .M9+?Me`.`..`.`.`` JN(>;>>;>>;>>>;>>><db` (kH5lllllzXMm.-NNszWm ` `\n                `     (#1+???Hm, ..`..`..`(N:>>>>>;>>>>>;>>><d@_.JNZIlllllllzvTWB6zlJMp      `\n                ` `` j@1+==?1zvHm.`...`....Hc<>>>>>>>>>>>>><(W$(M8TIllllllllllllllllzvMo ` `   `\n                    (#1?==1?===z?TNa,.` `` (Ne<<>>>>><;><;jgMMY1HK1lllllllllllllllllllJMp `\n                   .Ne&g&x1=?=?==?1zTHNmJ-...dNgJ++++&ggMH9=~ .M9Izlllllllllllllllllll1WF    `\n                `   _???MK<=??=??1z?(MM@!d#M#Y\"\"\"\"=<!!~```  .d8Illllllll=lll=lllllllzudY `     `\n                `       dH<?+uev?=1uMM^  d@vN&.`...`.`.`.-JH91zzl=llllllllllll=lzllzd#'  `  `\n                        ,MNMBHNIvjdB(D ` d#=zTNm.....JgHM9Izlllludk=zl=ll=llllllvug#^\n                     ` `    `.MmgM=+M$ ` d#zzO1vUUUU9TI=lllzzO1dKT#zOlllll=llll=dM=\n                         `   `(Y^ JBdr ` dNmxzIlllllllllllz1ug#= .My1llllllllllzdD `\n                           `     j@1dR ``(#~THaxl=lzzlzzzugW\"!` ``,Nzlzz=lllllzd#:  `\n                            ` ` .#z=d# ``(#_` .7THWQkWHB\"^ ` `   ` ?NsIzzlll=ljM\\\n                       `   ``  (M6zldN_` .M| `    ``    `           .WezllzllzH% `` `\n                     `    `  .+#Czl=dM;`  dR                    `     4m+zll1dD\n                        `  `.d@1llzvdMb   ,#   `                   `   ?Wmxzdf                     */\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\ntemplate<class V> struct MaxFlow {\n    struct edge { int to, reve; V cap; edge(int t, int r, V c) : to(t), reve(r), cap(c) {} };\n    int MV; vector<vector<edge>> E; vector<int> itr, lev;\n    MaxFlow() {} MaxFlow(int n) { init(n); }\n    void init(int n) { MV = n; itr = vector<int>(MV), lev = vector<int>(MV); E = vector<vector<edge>>(MV); }\n    void add_edge(int x, int y, V cap, bool undir = false) { E[x].push_back(edge(y, (int)E[y].size(), cap));\n        E[y].push_back(edge(x, (int)E[x].size() - 1, undir ? cap : 0)); }\n    void bfs(int cur) { rep(i, 0, MV) lev[i] = -1; queue<int> q; lev[cur] = 0; q.push(cur);\n        while (q.size()) { int v = q.front(); q.pop();\n        for(auto e : E[v]) if (e.cap>0 && lev[e.to]<0) lev[e.to] = lev[v] + 1, q.push(e.to); } }\n    V dfs(int from, int to, V cf) { if (from == to) return cf;\n        for (; itr[from]<E[from].size(); itr[from]++) {\n            edge* e = &E[from][itr[from]]; if (e->cap>0 && lev[from]<lev[e->to]) { \n                V f = dfs(e->to, to, min(cf, e->cap));\n                if (f>0) { e->cap -= f; E[e->to][e->reve].cap += f; return f; }\n            } } return 0; }\n    V maxflow(int from, int to) { V fl = 0, tf;\n        while (1) { bfs(from); if (lev[to]<0) return fl;\n            rep(i, 0, MV) itr[i] = 0; while ((tf = dfs(from, to, numeric_limits<V>::max()))>0) fl += tf;\n        }\n    }\n};\nstruct BipartiteMatching {\n    int N, M; MaxFlow<int> mf;\n    BipartiteMatching(int n, int m) : N(n), M(m) { mf.init(n + m + 2); }\n    void add_edge(int a, int b) { mf.add_edge(a, N + b, 1); }\n    int match() {\n        rep(a, 0, N) mf.add_edge(N + M, a, 1);\n        rep(b, 0, M) mf.add_edge(N + b, N + M + 1, 1);\n        return mf.maxflow(N + M, N + M + 1); }\n};\n//---------------------------------------------------------------------------------------------------\nint gcd(int a, int b) { return a ? gcd(b%a, a) : b; }\n\n\n\n\n\nint M, N, B[505], R[505];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    while (cin >> M >> N) {\n        if (M == 0) return;\n\n        rep(i, 0, M) cin >> B[i];\n        rep(i, 0, N) cin >> R[i];\n\n        BipartiteMatching bm(M, N);\n        rep(b, 0, M) rep(r, 0, N) if (gcd(B[b], R[r]) != 1) {\n            bm.add_edge(b, r);\n        }\n        cout << bm.match() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\ntypedef struct {int to,cap,rev;} edge;\n// edge e, G[e.to][e.rev].to=e\nvector<int> blue,red;\nvector<vector<edge> > G;\nvoid addflow(int from,int to,int cap)\n{\n  int a=G[from].size(),b=G[to].size();\n  G[from].push_back((edge){to,cap,b});\n  G[to].push_back((edge){from,0,a});\n}\nint flow(vector<int> trace)\n{\n  int answer=1048576;\n  REP(i,trace.size()-1) REP(j,G[trace[i]].size())\n    if(G[trace[i]][j].to==trace[i+1]) answer=min(answer,G[trace[i]][j].cap);\n  REP(i,trace.size()-1) REP(j,G[trace[i]].size())\n    if(G[trace[i]][j].to==trace[i+1]) G[trace[i]][j].cap-=answer,G[G[trace[i]][j].to][G[trace[i]][j].rev].cap+=answer;\n  return answer;\n}\nint EK(int so,int si)\n{\n  queue<vector<int> > bfs;\n  vector<int> start;\n  set<int> already;\n  start.push_back(so);\n  bfs.push(start);\n  while(!bfs.empty()){\n    vector<int> trace(bfs.front());\n    bfs.pop();\n    int tmp=trace.back();\n    if(tmp==si) return flow(trace);\n    if(!already.insert(tmp).second) continue;\n    REP(i,G[tmp].size()){\n      if(!G[tmp][i].cap) continue;\n      vector<int> nexttrace(trace);\n      nexttrace.push_back(G[tmp][i].to);\n      bfs.push(nexttrace);\n    }\n  }\n  return 0;\n}\nint maxflow(int so,int si)\n{\n  int answer=0;\n  while(int tmp=EK(so,si)) answer+=tmp;\n  return answer;\n}\nint gcd(int a,int b){ return b?gcd(b,a%b):a; }\nint main(void)\n{\n  for(;;){\n    int m,n;\n    cin >> m >> n;\n    if(!m&&!n) return 0;\n    blue.resize(m);\n    REP(i,m) cin >> blue[i];\n    red.resize(n);\n    REP(i,n) cin >> red[i];\n    G.assign(m+n+2,vector<edge>());\n    REP(i,m) addflow(m+n,i,1);\n    REP(i,m) REP(j,n) if(gcd(blue[i],red[j])!=1) addflow(i,m+j,1);\n    REP(j,n) addflow(m+j,m+n+1,1);\n    cout << maxflow(m+n,m+n+1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nclass FordFulkerson{\npublic:\n\tstruct edge {\n\t\tedge(int t, int c, int r) : to(t), cap(c), rev(r) { };\n\t\tint to, cap, rev;\n\t};\n\n\tint V;\n\t\n\tvector< vector<edge> > G;\n\tvector<bool> used;\n\n\tFordFulkerson(int v) {\n\t\tthis->V = v;\n\t\tG = vector< vector<edge> >(v);\n\t\tused = vector<bool>(v);\n\t}\n\n\tvoid addEdge(int from, int to, int cap) {\n\t\tG[from].push_back( edge(to, cap, G[to].size()) );\n\t\tG[to].push_back( edge(from, 0, G[from].size() - 1) );\n\t}\n\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t) return f;\n\n\t\tused[v] = true;\n\n\t\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tint maxFlow(int s, int t) {\n\t\tint flow = 0;\n\t\twhile (true) {\n\t\t\tused = vector<bool>(V, 0);\n\t\t\tint f = dfs(s, t, INT_MAX);\n\t\t\tif (f == 0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n};\n\nint solve(int bn, int rn, VI &bs, VI &rs) {\n\tconst int v = bn + rn + 2;\n\tconst int s = 0, t = 1;\n\tconst int offset_b = 2;\n\tconst int offset_r = 2 + bn;\n\n\tFordFulkerson ff(v);\n\n\t// s -> bs[i]\n\tfor (int i = 0; i < bn; i++) {\n\t\tff.addEdge(s, i + offset_b, 1);\n\t}\n\n\t// rs[i] -> t\n\tfor (int i = 0; i < rn; i++) {\n\t\tff.addEdge(i + offset_r, t, 1);\n\t}\n\n\t// bs[i] -> rs[j]\n\tfor (int i = 0; i < bn; i++) {\n\t\tfor (int j = 0; j < rn; j++) {\n\t\t\tif (__gcd(bs[i], rs[j]) != 1) {\n\t\t\t\tff.addEdge(i + offset_b, j + offset_r, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ff.maxFlow(s, t);\n}\n\nint main(void) {\n\tint bn, rn;\n\twhile (cin >> bn >> rn, bn) {\n\t\tVI bs(bn), rs(rn);\n\t\tfor (auto &b : bs) cin >> b;\n\t\tfor (auto &r : rs) cin >> r;\n\t\tcout << solve(bn, rn, bs, rs) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 502\nusing namespace std;\n \nint m,n,b[MAX],r[MAX];\nint match[MAX+MAX];\nbool used[MAX+MAX];\nvector<int> e[MAX+MAX];\n \nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<e[v].size();i++){\n    int u=e[v][i],w=match[u];\n    if(w<0||(!used[w]&&dfs(w))){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n \nint bipartite_matching(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int i=0;i<MAX+MAX;i++){\n    if(match[i]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(i))res++;\n    }\n  }\n  return res;\n}\n \nint gcd(int a,int b){\n  if(b==0)return a;\n  return gcd(b,a%b);\n}\n \nint main(){\n  while(1){\n    cin>>m>>n;\n    if(!m&&!n)break;\n    for(int i=0;i<m;i++)cin>>b[i];\n    for(int i=0;i<n;i++)cin>>r[i];\n    for(int i=0;i<m;i++)\n      for(int j=0;j<n;j++)\n    if(gcd(b[i],r[j])>1){\n      e[i].push_back(j+m);\n      e[j+m].push_back(i);\n    }\n    cout<<bipartite_matching()<<endl;\n    for(int i=0;i<MAX+MAX;i++)e[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define INF 999999\n#define MAX_V 10000\nusing namespace std;\n\ntypedef struct edge{\n  int to,cap,rev;\n}edge;\n\nint val[MAX_V];\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nbool gcd(int a,int b){\n  int r=a%b;\n  while(r>0){\n    a=b;\n    b=r;\n    r=a%b;\n  }\n  if(b!=1)return true;\n  else return false;\n}\n\nvoid makeG(int m,int n){\n  memset(G,0,sizeof(G));\n  int to;\n  for(int i=0;i<m+n;i++){\n    cin>>val[i];\n  }\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++){\n      if(gcd(val[i],val[m+j])==true){\n\tG[i].push_back((edge){m+j,1,G[m+j].size()});\n\tG[m+j].push_back((edge){i,0,G[i].size()-1});\n      }\n    }\n  }\n  val[m+n]=val[m+n+1]=1;\n  for(int i=0;i<m;i++){\n    G[m+n].push_back((edge){i,1,G[i].size()});\n    G[i].push_back((edge){m+n,0,G[i].size()-1});\n  }\n  for(int i=m;i<m+n;i++){\n    G[i].push_back((edge){m+n+1,1,G[m+n+1].size()});\n    G[m+n+1].push_back((edge){i,0,G[i].size()-1});\n  }\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f=dfs(s,t,INF);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint main(){\n  int m,n;\n  while(cin>>m>>n,n){\n    makeG(m,n);\n    cout << max_flow(m+n,m+n+1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cassert>\n#include<cctype>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<iomanip>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<vector>\n#include<set>\n#include<string>\n#include<stack>\n#include<sstream>\n#include<complex>\n\n#define pb push_back\n#define clr clear()\n#define sz size()\n#define fs first\n#define sc second\n\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define rrep(i,a) for(int i=(int)(a)−1;i>=0;i−−)\n#define all(a) (a).begin(),(a).end()\n#define EQ(a,b) (abs((a)−(b)) < EPS)\n#define INIT(a) memset(a,0,sizeof(a))\n\nusing namespace std;\ntypedef double D;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst D EPS = 1e-8;\nconst int INF = 1e8;\nconst D PI = acos(-1);\n\nint v; //ク&#12441;ラフの頂点数\nvector<int> G[1100]; //ク&#12441;ラフの隣接リスト表現\nint match[1100]; //マッチンク&#12441;のヘ&#12442;ア\nbool use[1100];\nbool dfs(int u){\n  use[u] = true;\n  rep(i,G[u].sz){\n    int t = G[u][i], w = match[t];\n    if(w<0 || (!use[w] && dfs(w))){\n      match[u] = t;\n      match[t] = u;\n      return true;\n    }\n  }\n  return false;\n}\n\nint biparticle_matching(){\n  int res = 0;\n  memset(match,-1,sizeof(match));\n  rep(u,v){\n    if(match[u]<0){\n      INIT(use);\n      if(dfs(u))res++;\n    }\n  }\n  return res;\n}\n\nll gcd(ll a, ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a, ll b){return a/gcd(a,b)*b;}\n\nint m,n;\nint b[1000],r[1000];\n\nint main(){\n  while(cin >> m >> n, m){\n    rep(i,m)G[i].clr, cin >> b[i];\n    rep(i,n)G[m+i].clr, cin >> r[i];\n\n    rep(i,m){\n      rep(j,n){\n\tif(gcd(b[i],r[j]) != 1){\n\t  G[i].pb(m+j); G[m+j].pb(i);\n\t}\n      }\n    }\n\n    v = m+n;\n    cout << biparticle_matching() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nvector<int> blue,red,redpair,v;\nvector<vector<int> >c;\n/*blue[i]??§i?????????????????????????????°???,red[i]??§i?????????????????????????????°???,redpair[i]??§i??????????????????????????¨?????¢????????????????????????????????????????????????,v[i]??§i??????????????????????????????????????????????????????(1:?????????0:??????)\nc[i][j]??§blue[i]??¨red[j]????????¢?????§???????????¨???*/\nint m=0,n=0;\n\nint gcd(int x,int y){\n\tif(x%y==0){return y;}\n\treturn gcd(y,x%y);\n}\n\nbool match(int x){\n\tif(x==-1)return 1;\n\tfor(int i=0;i<n;i++){\n\t\tif(c[x][i]==1 && v[i]==0){\n\t\t\tv[i]=1;\n\t\t\tif(match(redpair[i])){\n\t\t\t\tredpair[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(cin>>m>>n){\n\t\tif(m==0 && n==0){break;}\n\t\tblue.clear();\n\t\tred.clear();\n\t\tredpair.clear();\n\t\tv.clear();\n\t\tc.clear();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint tmp=0;\n\t\t\tcin>>tmp;\n\t\t\tblue.push_back(tmp);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmp=0;\n\t\t\tcin>>tmp;\n\t\t\tred.push_back(tmp);\n\t\t\tredpair.push_back(-1);//-1??§?????¢??????????????¶????????¨???\n\t\t\tv.push_back(0);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tc.push_back(vector<int>());\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tc[i].push_back(gcd(blue[i],red[j])!=1);\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tv[j]=0;\n\t\t\t}\n\t\t\tif(match(i)){ans++;}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nvector<int> blue,red,redpair,v;\n//blue[i]??§i?????????????????????????????°???,red[i]??§i?????????????????????????????°???,redpair[i]??§i??????????????????????????¨?????¢????????????????????????????????????????????????,v[i]??§i????????????????????????????????????????????????????????¨???(1:?????????0:??????)\nint m=0,n=0;\n\nint gcd(int x,int y){\n\tif(x%y==0){return y;}\n\treturn gcd(y,x%y);\n}\n\nbool match(int x){\n\tif(x==-1)return 1;\n\tfor(int i=0;i<n;i++){\n\t\tif(gcd(blue[x],red[i])!=1 && v[i]==0){\n\t\t\tv[i]=1;\n\t\t\tif(match(redpair[i])){\n\t\t\t\tredpair[i]=x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tv[i]=0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(cin>>m>>n){\n\t\tif(m==0 && n==0){break;}\n\t\tblue=vector<int>();\n\t\tred=vector<int>();\n\t\tredpair=vector<int>();\n\t\tv=vector<int>();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint tmp=0;\n\t\t\tcin>>tmp;\n\t\t\tblue.push_back(tmp);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint tmp=0;\n\t\t\tcin>>tmp;\n\t\t\tred.push_back(tmp);\n\t\t\tredpair.push_back(-1);//-1??§?????¢??????????????¶????????¨???\n\t\t\tv.push_back(0);\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(match(i)){ans++;}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int MAX_V = 100000;\nconst int INF = 10000000;\n\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap)\n{\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f)\n{\n  if(v == t) return f;\n\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n\n  return 0;\n}\n\nint max_flow(int s, int t)\n{\n  int flow = 0;\n  for(;;){\n    fill(used, used + MAX_V, false);\n    int f = dfs(s, t, INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint gcd(int a, int b)\n{\n  int c;\n  if (a < b) {\n    a+=b; b=a-b; a-=b;\n  }\n  while (b != 0) {\n    c = a % b;\n    a = b;\n    b = c;\n  }\n  return a;\n}\n\nint main()\n{\n  while(1){\n    int m, n;\n    cin >> m >> n;\n    if(m == 0 && n == 0) break;\n    int b[m], r[n];\n    for(int i = 0; i < m; i++)\n      cin >> b[i];\n    for(int i = 0; i < n; i++)\n      cin >> r[i];\n    for(int i = 0; i < m; i++){\n      for(int j = 0; j < n; j++){\n        if(gcd(b[i], r[j]) != 1){\n          add_edge(i+2, j+m+2, 1);\n        }\n      }\n    }\n    for(int i = 2; i < m + 2; i++)\n      add_edge(0, i, 1);\n    for(int i = m+2; i < m+n+2; i++)\n      add_edge(i, 1, 1);\n    cout << max_flow(0, 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vin=vector<int>;\nusing vll=vector<long long>;\nusing vvin=vector<vector<int>>;\nusing vvll=vector<vector<long long>>;\nusing vstr=vector<string>;\nusing vvstr=vector<vector<string>>;\nusing vch=vector<char>;\nusing vvch=vector<vector<char>>;\nusing vbo=vector<bool>;\nusing vvbo=vector<vector<bool>>;\nusing vpii=vector<pair<int,int>>;\nusing pqsin=priority_queue<int,vector<int>,greater<int>>;\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep2(i,s,n) for(int i=(s);i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define decp(n) cout<<fixed<<setprecision((int)n)\nconst int inf=1e9+7;\nconst ll INF=1e18;\n\nint MAX_V=1020;\n\nvvin g(MAX_V);//グラフの隣接リスト表現\nvin match(MAX_V);//マッチングのペア\nvbo used(MAX_V);\n\nvoid add_edge(int u,int v){\n    g[u].push_back(v);\n    g[v].push_back(u);\n}\n\n//増加パスをdfsで探す\nbool dfs(int v){\n    used[v]=true;\n    for(auto u:g[v]){\n        int w=match[u];\n        if(w<0||(!used[w]&&dfs(w))){\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\n//二部グラフの最大マッチングを求める\nint max_matching(int v){//vは頂点数\n    int res=0;\n    fill(all(match),-1);\n    rep(i,v){\n        if(match[i]<0){\n            fill(all(used),false);\n            if(dfs(i))res++;\n        }\n    }\n    return res;\n}\n\nvin b(510),r(510);\n\nint solve(int m,int n){\n    rep(i,MAX_V)g[i].clear();\n    rep(i,m)cin>>b[i];\n    rep(i,n)cin>>r[i];\n    rep(i,m)rep(j,n){\n        if(__gcd(b[i],r[j])!=1)add_edge(i,j+m);\n    }\n    return max_matching(m+n);\n}\n\nint main(){\n    vin ans;\n    while(1){\n        int m,n;cin>>m>>n;\n        if(m==0)break;\n        ans.push_back(solve(m,n));\n    }\n    rep(i,ans.size())cout<<ans[i]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<algorithm>\n#include<vector>\nstruct bimatch{\n\tint n;\n\tvector<vector<int> >G;\n\tvector<int>match;\n\tvector<bool>used;\n\tbimatch(int _n=0):n(_n),G(n),match(n),used(n){}\n\tvoid add_edge(int u,int v)\n\t{\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tbool dfs(int v)\n\t{\n\t\tused[v]=true;\n\t\tfor(int u:G[v])\n\n\t\t{\n\t\t\tint w=match[u];\n\t\t\tif(w<0||!used[w]&&dfs(w))\n\t\t\t{\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint count()\n\t{\n\t\tint ans=0;\n\t\tfill(match.begin(),match.end(),-1);\n\t\tfor(int v=0;v<n;v++)\n\t\t{\n\t\t\tif(match[v]<0)\n\t\t\t{\n\t\t\t\tfill(used.begin(),used.end(),false);\n\t\t\t\tif(dfs(v))ans++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};\nint n,m;\nint g(int a,int b){return b?g(b,a%b):a;}\nmain()\n{\n\twhile(cin>>n>>m,n)\n\t{\n\t\tvector<int>a(n),b(m);\n\t\tfor(int i=0;i<n;i++)cin>>a[i];\n\t\tfor(int i=0;i<m;i++)cin>>b[i];\n\t\tbimatch P(n+m);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tif(g(a[i],b[j])>1)P.add_edge(i,n+j);\n\t\t\t}\n\t\t}\n\t\tcout<<P.count()<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define foreach(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nusing namespace std;\n\n//±ÒØ\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  foreach(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  rep(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  rep(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u], 1) );\n  return match;\n}\n\nint gcd(int x, int y){\n\treturn y?gcd(y, x%y):x;\n}\nint main(){\n\tint m, n;\n\twhile(cin>>m>>n, m||n){\n\t\tvector<int> blue(m), red(n);\n\t\trep(i, m)cin>>blue[i];\n\t\trep(i, n)cin>>red[i];\n\t\t\n\t\tGraph g;\n\t\tEdges egs;\n\t\trep(i, m){\n\t\t\tEdges es;\n\t\t\trep(j, n){\n\t\t\t\tif(gcd(blue[i], red[j])==1)continue;\n\t\t\t\tEdge e(i, j+m, 1);\n\t\t\t\tes.push_back(e);\n\t\t\t\tegs.push_back(e);\n\t\t\t}\n\t\t\tg.push_back(es);\n\t\t}\n\t\trep(i, n){\n\t\t\tEdges es;\n\t\t\trep(j, m){\n\t\t\t\tif(gcd(red[i], blue[j])==1)continue;\n\t\t\t\tEdge e(i+m, j, 1);\n\t\t\t\tes.push_back(e);\n\t\t\t\tegs.push_back(e);\n\t\t\t}\n\t\t\tg.push_back(es);\n\t\t}\n\t\tcout<<bipartiteMatching(g, m, egs)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n#define SET(a,c) memset(a,c,sizeof(a))\n\n#define DEBUG(x) cout<<\"#x\"<<\": \"<<x<<endl\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nconst ll INF = INT_MAX/3;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-14;\nconst int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n\nstruct edge{ int to;int cap;int rev; };\nint m,n;\n\nvector<edge> G[1002];\nbool used[1002];\n\nvoid add_edge(int from,int to){\n    G[from].PB( (edge){to,1,(int)G[to].size()} );\n    G[to].PB( (edge){from,0,(int)G[to].size()-1} );\n}\n\nint dfs(int v,int t,int f){\n    if( v == t) return f;\n    used[v] = true;\n    REP(i,G[v].size()){\n\tedge &e = G[v][i];\n\tif(!used[e.to] && e.cap > 0){\n\t    int d = dfs(e.to,t,min(f,e.cap));\n\t    if(d > 0){\n\t\te.cap -= d;\n\t\tG[e.to][e.rev].cap += d;\n\t\treturn d;\n\t    }\n\t}\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int flow = 0;\n    while(true){\n\tSET(used,false);\n\tint f = dfs(s,t,INF);\n\tif(f == 0)return flow;\n\tflow += f;\n    }\n    return -1;\n}\n\nint gcd(int a,int b){ return a % b == 0 ? b : gcd(b,a%b); }\n\nint main(){\n\n    while(true){\n\tm,n;\n\tcin >> m >> n;\n\tif(m == 0 && n == 0) break;\n\tREP(i,1002) G[i].clear();\n\tSET(used,false);\n\tint a[501],b[501];\n\tREP(i,m) {\n\t    cin >> a[i];\n\t    add_edge(0,i+1);\n\t}\n\tREP(i,n) {\n\t    cin >> b[i];\n\t    add_edge(i+1+m,n+m+1);\n\t}\n\tREP(i,m){\n\t    REP(j,n){\n\t\tif(gcd(a[i],b[j]) > 1){\n\t\t    add_edge(i+1,m+j+1);\n\t\t}\n\t    }\n\t}\n\tcout << max_flow(0,n+m+1) << endl;;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef vector<int> Node;\ntypedef vector<Node> Graph;\nint V1, V2;\nGraph G;\nint dist[1002];\nint match[1002];\nconst int NIL = 1001;\nbool BFS(){\n  queue<int> que;\n  REP(v, V1){\n    if(match[v] == NIL){\n      dist[v] = 0;\n      que.push(v);\n    }else{\n      dist[v] = INF;\n    }\n  }\n  dist[NIL] = INF;\n  while(!que.empty()){\n    int v = que.front(); que.pop();\n    if(dist[v] < dist[NIL]){\n      for(int i = 0; i < G[v].size(); i++){\n        int u = G[v][i];\n        if(dist[match[u]] == INF){\n          dist[match[u]] = dist[v] + 1;\n          que.push(match[u]);\n        }\n      }\n    }\n  }\n  return dist[NIL] != INF;\n}\n\nbool DFS(int v){\n  if(v != NIL){\n    for(int i = 0; i < G[v].size(); i++){\n      int u = G[v][i];\n      if(dist[match[u]] == dist[v] + 1 && DFS(match[u])){\n        match[u] = v;\n        match[v] = u;\n        return true;\n      }\n    }\n    dist[v] = INF;\n    return false;\n  }\n  return true;\n}\n\nint Hopcroft_Karp(){\n  REP(v, G.size()) match[v] = NIL;\n  int matching = 0;\n  while(BFS()){\n    REP(v, V1){\n      if(match[v] == NIL && DFS(v)){\n        matching ++;\n      }\n    }\n  }\n  return matching;\n}\nint main(){\n  while(scanf(\"%d %d\", &V1, &V2) && (V1 != 0 || V2 != 0)){\n    G = Graph(V1 + V2);\n    static int blue[500];\n    static int red[500];\n    if(V1 > V2){\n      REP(i, V1) scanf(\"%d\", blue + i);\n      REP(i, V2) scanf(\"%d\", red + i);\n      REP(u, V1) REP(v, V2){\n        if(__gcd(blue[u], red[v]) != 1) {\n          G[u].push_back(V1 + v);\n          //G[V1 + v].push_back(u);\n        }\n      }\n    }else{\n      swap(V1, V2);\n      REP(i, V2) scanf(\"%d\", blue + i);\n      REP(i, V1) scanf(\"%d\", red + i);\n      REP(v, V2) REP(u, V1){\n        if(__gcd(blue[v], red[u]) != 1) {\n          G[u].push_back(V1 + v);\n          //G[V1 + v].push_back(u);\n        }\n      }\n    }\n    printf(\"%d\\n\", Hopcroft_Karp());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> edge[1010];\nint match[1010];\nbool used[1010];\n\nbool dfs(int v){\n  used[v] = true;\n  rep(i,edge[v].size()){\n    int u = edge[v][i];\n    int w = match[u];\n    if( w<0 || !used[w]&&dfs(w) ){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\nint solve(int sz){\n  int ret = 0;\n  memset(match,-1,sizeof(match));\n  rep(i,sz)if( match[i]<0 ){\n    memset(used,false,sizeof(used));\n    if( dfs(i) )ret++;\n  }\n  return ret;\n}\n\n\nint gcd(int x, int y){\n  return y ? gcd(y,x%y) : x;\n}\n\nint main(){\n  int n,m;\n  int blue[500],red[500];\n\n  while(cin>>n>>m, n|m){\n    // init\n    rep(i,1010)edge[i].clear();\n\n    \n    rep(i,n)cin>>blue[i];\n    rep(i,m)cin>>red[i];\n    rep(i,n){\n      rep(j,m){\n        if( gcd(blue[i], red[j])!=1 ){\n          edge[i].push_back(j+n);\n          edge[j+n].push_back(i);\n        }\n      }\n    }\n    cout << solve(n+m) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define size_of(a) (int)a.size()\n#define allof(a) (a).begin(),(a).end()\n\nclass BibMatch {\nprivate:\n\tint V;\n\tvector< vector< int > > adj;\n\tvector< int > match;\n\tvector< bool > used;\n\t\npublic:\n\tBibMatch(int n_) : V(n_), adj(n_, vector< int >()), match(n_, -1), used(n_, 0) {}\n\t\n\tvoid addEdge(int u, int v) {\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\t\n\tbool dfs(int v) {\n\t\tused[v] = 1;\n\t\t\n\t\tfor_(i,0,size_of(adj[v])) {\n\t\t\tint u = adj[v][i], w = match[u];\n\t\t\t\n\t\t\tif (w < 0 || (!used[w] && dfs(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tint bibMatch() {\n\t\tint res = 0;\n\t\tfill(allof(match), -1);\n\t\t\n\t\tfor_(v,0,V) {\n\t\t\tif (match[v] < 0) {\n\t\t\t\tfill(allof(used), 0);\n\t\t\t\tif (dfs(v)) ++res;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n};\n\nint gcd(int _a, int _b) {\n\treturn _b != 0 ? gcd(_b, _a % _b) : _a;\n}\n\nint m, n;\n\nint main() {\n\twhile (cin >> m >> n, m) {\n\t\tBibMatch bib(n + m);\n\t\t\n\t\tvector< int > b(m), r(n);\n\t\tfor_(i,0,m) cin >> b[i];\n\t\tfor_(i,0,n) cin >> r[i];\n\t\t\n\t\tfor_(i,0,m) for_(j,0,n) if (gcd(b[i], r[j]) > 1) bib.addEdge(i, j + m);\n\t\t\n\t\tcout << bib.bibMatch() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 501\n#define MAX_N 501\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});  \n}\n\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nint N,K;\nbool can[MAX_N][MAX_N]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(){\n  //0??????N-1: ???????????\\???????????????????????????\n  //N??????N+K-1: ???????????????????????????\n  int s = N+K, t = s+1;\n  \n  //s??¨???????????\\??????????????¶\n  for(int i=0; i<N; i++) add_edge(s,i,1);\n  \n  //????????¨t?????????\n  for(int i=0; i<K; i++) add_edge(N+i,t,1);\n  \n  //???????????\\????????¨??????????????¶\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)\n      if(can[i][j]) add_edge(i, N+j , 1);\n\n  return max_flow(s,t);\n}\n\nint main(){\n  while(1){\n  int b,r,B[501],R[501];\n  cin>>b>>r;\n  if(!b&&!r)break;\n  for(int i=0;i<b;i++) cin>>B[i];\n  for(int i=0;i<r;i++) cin>>R[i];\n\n  memset(can,0,sizeof(can));\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n  N=b,K=r;\n  for(int i=0;i<b;i++)\n    for(int j=0;j<r;j++)\n      if(__gcd(B[i],R[j])>1) can[i][j]=1;\n\n  cout<<Biparite_Matching()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // {{{\n\n#define GET_MACRO(a, b, c, d, NAME, ...) NAME\n#define REP(...) GET_MACRO(__VA_ARGS__, REP4, REP3, REP2)(__VA_ARGS__)\n#define REP2(i, a) REP3(i, 0, a)\n#define REP3(i, a, b) REP4(i, a, b, 1)\n#define REP4(i, a, b, s) for (int i = (a); i < (int)(b); i += (s))\n#define REPR(...) GET_MACRO(__VA_ARGS__, REPR4, REPR3, REPR2)(__VA_ARGS__)\n#define REPR2(i, a) REPR3(i, 0, a)\n#define REPR3(i, a, b) REPR4(i, a, b, 1)\n#define REPR4(i, a, b, s) for (int i = (b)-1; i >= (int)(a); i -= (s))\n#define ALL(c) (c).begin(), (c).end()\n#define DUMP(x) (std::cerr << #x << ':' << ' ' << x << '\\n')\n#define TMPL_T template <typename T>\n#define TMPL_TU template <typename T, typename U>\n#define mut auto\n#define let const auto\n\nusing Int = long long;\n// clang-format off\nnamespace extio {\nstd::string delimiter=\" \",pdelimiter=\" \";\nstd::string bracket_b=\"\",bracket_e=\"\";\nvoid chdelim(const std::string&s){delimiter=s;}\nvoid chpdelim(const std::string&s){pdelimiter=s;}\nvoid chbracket(const std::string&b,const std::string&e){bracket_b=b,bracket_e=e;}\nTMPL_T  void pcont(std::ostream&os,const T&x){int c=0;for(const auto&a:x){if(c++)os<<delimiter;os<<a;}}\nTMPL_TU void ppair(std::ostream&os,const std::pair<T,U>&p){os<<bracket_b<<p.first<<pdelimiter<<p.second<<bracket_e;}\n}\nnamespace std {\nTMPL_T ostream& operator<<(ostream&os,const vector<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const set<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const multiset<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const deque<T>&x){extio::pcont(os,x);return os;}\nTMPL_TU ostream& operator<<(ostream&os,const map<T,U>&x){extio::pcont(os,x);return os;}\nTMPL_TU ostream& operator<<(ostream&os,const pair<T,U>&x){extio::ppair(os,x);return os;}\n}\nTMPL_TU inline bool chmax(T&x,U a){return x<a&&(x=a,1);}\nTMPL_TU inline bool chmin(T&x,U a){return a<x&&(x=a,1);}\n\ninline int in(){int x;std::cin>>x;return x;}\n\nstruct Initializer_ {\n  Initializer_(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(0);\n    std::cout << std::setprecision(10);\n    std::cerr << std::setprecision(10);\n  }\n} precalc;\n// clang-format on\n// }}}\n\n// {{{ orliv::graph::max_flow::FordFulkerson\n// verify AOJ GRL_6_A\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\nnamespace orliv {\nnamespace graph {\nnamespace max_flow {\nnamespace fordfulkerson {\nnamespace internal {\nstruct BoolArray {\n  int X;\n  std::vector<int> flags;\n  BoolArray(std::size_t N) : flags(N), X(0) {}\n  void clear() { ++X; }\n  bool get(int x) const { return flags[x] == X; }\n  void set(int x) { flags[x] = X; }\n};\n}\n}\nstruct FordFulkerson {\n  struct Edge {\n    int to;\n    int cap;\n    int rev;\n    Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n  };\n  std::vector<std::vector<Edge>> G;\n  fordfulkerson::internal::BoolArray used;\n  FordFulkerson(int V) : G(V), used(V) {}\n  void addEdge(int from, int to, int cap) {\n    G[from].emplace_back(to, cap, G[to].size());\n    G[to].emplace_back(from, 0, G[from].size() - 1);\n  }\n  int dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used.set(v);\n    for (auto &e : G[v]) {\n      if (used.get(e.to)) continue;\n      if (e.cap <= 0) continue;\n      int d = dfs(e.to, t, std::min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n    return 0;\n  }\n  int getFlow(int s, int t) {\n    int flow = 0;\n    while (1) {\n      used.clear();\n      int f = dfs(s, t, 1 << 29);\n      if (f == 0) return flow;\n      flow += f;\n    }\n  }\n};\n}\n}\n}\n// }}}\n\nusing namespace std;\n\nsigned main() {\n  int M, N;\n  while (M = in(), N = in(), M || N) {\n    vector<int> A, B;\n    A.reserve(M);\n    B.reserve(N);\n    REP(i, M) { A.emplace_back(in()); }\n    REP(i, N) { B.emplace_back(in()); }\n    orliv::graph::max_flow::FordFulkerson g(M + N + 2);\n    REP(i, M) { g.addEdge(0, i + 1, 1); }\n    REP(i, N) { g.addEdge(M + i + 1, M + N + 1, 1); }\n    REP(i, M) REP(j, N) {\n      if (__gcd(A[i], B[j]) != 1) { g.addEdge(i + 1, M + j + 1, 1); }\n    }\n    cout << g.getFlow(0, M + N + 1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> g[1010];\nint n, m;\n \nvector<bool> visited, matched;\nvector<int> levels, matching;\n \nbool augment(int left) {\n  if(left == n) return true;\n  if(visited[left]) return false;\n  visited[left] = true;\n  rep(i, g[left].size()) {\n    int right = g[left][i];\n    int next = matching[right];\n    if (levels[next] > levels[left] && augment(next)) {\n      matching[right] = left;\n      return true;\n    }\n  }\n  return false;\n}\n \nint bimatch() {\n  matching.assign(m, n);\n  matched.assign(n, false);\n  int ret = 0;\n  bool cont;\n  do {\n    levels.assign(n+1, -1);\n    levels[n] = n;\n    queue<int> q;\n    rep(left, n) if (!matched[left]) {\n      q.push(left);\n      levels[left] = 0;\n    }\n    while(!q.empty()) {\n      int left = q.front();\n      q.pop();\n      rep(i, g[left].size()) {\n        int right = g[left][i];\n        int next = matching[right];\n        if (levels[next] < 0) {\n          levels[next] = levels[left] + 1;\n          q.push(next);\n        }\n      }\n    }\n    visited.assign(n, false);\n    cont = false;\n    /*\n    rep(i,n){\n      cout << \"match:\" << i << \" : \" << matched[i] << endl;\n    }\n    rep(i,n){\n      cout << \"levels:\" << i << \" : \" << levels[i] << endl;\n    }\n      */\n    rep(left, n) if(!matched[left] && augment(left)){\n      matched[left] = cont = true;\n      ret++;\n    }\n  } while(cont);\n  //printf(\"ret:%d\\n\",ret);\n  //return count(matched.begin(), matched.end(), true);\n  return ret;\n}\n\nint blue[510],red[510];\n\nint main(){\n  while(scanf(\"%d%d\",&n,&m),n|m){\n    //init\n    rep(i,n+m)g[i].clear();\n    //visited.clear();\n    //matched.clear();\n    //levels.clear();\n    //matching.clear();\n    \n    \n    \n    rep(i,n)scanf(\"%d\",blue+i);\n    rep(i,m)scanf(\"%d\",red+i);\n\n    rep(i,n){\n      rep(j,m)if( __gcd(blue[i],red[j])!=1 ){\n        g[i].push_back(n+j);\n        g[n+j].push_back(i);\n      }\n    }\n    //\n    /*\n    rep(i,n+m){\n      printf(\"%d: \",i);\n      rep(j,g[i].size())printf(\"%d \",g[i][j]);\n      puts(\"\");\n    }\n      */\n    m += n;\n    printf(\"%d\\n\",bimatch());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\t\n\nint main(){\n\twhile(1){\n\t\tint m,n,count=0,Ab=0;\n\t\tstd::cin>>m>>n;\n\t\tif(m==0&&n==0)break;\n\t\tstd::vector<int>red(m);\n\t\tstd::vector<int>blue(n);\n\t\tstd::vector<int>Ablue;\n\t\tfor(int i=0;i<m;i++)std::cin>>red[i];\n\t\tfor(int i=0;i<n;i++)std::cin>>blue[i];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint k=2;\n\t\t\twhile(blue[i]!=1){\n\t\t\t\tif(blue[i]%k==0){\n\t\t\t\t\tblue[i]=blue[i]/k;\n\t\t\t\t\tAblue.push_back(1);\n\t\t\t\t\tAblue[Ab]=k;\n\t\t\t\t\tAb++;\n\t\t\t\t}\n\t\t\t\tif(blue[i]%k!=0)k++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=m-1;i>=0;i--){\n\t\t\tint k=2;\n\t\t\twhile(red[i]!=1){\n\t\t\t\tfor(int j=Ablue.size()-1;j>=0;j--){\n\t\t\t\t\tif(red[i]==Ablue[j]){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tAblue[j]=-1;\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(red[i]%k==0)red[i]=red[i]/k;\n\t\t\t\telse k++;\n\t\t\t}\n\t\t\tend:;\n\t\t}\n\t\tstd::cout<<count<<std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\ntypedef long long ll;\n\nclass pass\n{\npublic:\n\tll t;\n\tll c;\n\tll p;\n};\n\nclass scale\n{\nprivate:\n\tll v, e;\n\n\tpass* p;\n\n\tvector<ll>* node;\n\tbool* used;\n\tll* nowin;\npublic:\n\tvoid set(ll vw, ll ew)\n\t{\n\t\tv = vw;\n\t\tp = new pass[ew * 2];\n\t\tnode = new vector<ll>[v];\n\t\tused = new bool[v];\n\t\tnowin = new ll[v];\n\t\te = 0;\n\t}\n\n\tvoid add(ll f, ll t, ll c)\n\t{\n\t\tp[e].t = t;\n\t\tp[e].c = c;\n\t\tp[e].p = e + 1;\n\t\tp[e + 1].t = f;\n\t\tp[e + 1].c = 0;\n\t\tp[e + 1].p = e;\n\t\tnode[f].push_back(e);\n\t\tnode[t].push_back(e + 1);\n\t\te += 2;\n\t}\n\n\tll solve()\n\t{\n\t\tll nn = 0;\n\t\tfor (auto i : node[0])\n\t\t{\n\t\t\tnn = max(nn, p[i].c);\n\t\t}\n\t\twhile (nn > 0)\n\t\t{\n\t\t\tstack<ll> st;\n\t\t\tqueue<ll> q;\n\t\t\tfor (ll i = 0; i < v; i++)\n\t\t\t{\n\t\t\t\tused[i] = false;\n\t\t\t\tnowin[i] = 0;\n\t\t\t}\n\t\t\tq.push(0);\n\t\t\tused[0] = true;\n\t\t\twhile (!q.empty())\n\t\t\t{\n\t\t\t\tll np = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tst.push(np);\n\t\t\t\tfor (auto i : node[np])\n\t\t\t\t{\n\t\t\t\t\tif (p[i].c > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tll t = p[i].t;\n\t\t\t\t\t\tnowin[t] += p[i].c;\n\t\t\t\t\t\tif (nowin[t] >= nn && !used[t])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (t == v - 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tst.push(t);\n\t\t\t\t\t\t\t\tgoto aa;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tq.push(t);\n\t\t\t\t\t\t\tused[t] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\taa:\n\t\t\tif (st.top() != v - 1)\n\t\t\t{\n\t\t\t\tnn /= 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (!q.empty())\n\t\t\t{\n\t\t\t\tused[q.front()] = false;\n\t\t\t\tq.pop();\n\t\t\t}\n\t\t\tfor (int i = 0; i < v; i++)\n\t\t\t{\n\t\t\t\tnowin[i] = 0;\n\t\t\t}\n\t\t\tnowin[v - 1] = nn;\n\t\t\twhile (st.size() > 1)\n\t\t\t{\n\t\t\t\tll np = st.top();\n\t\t\t\tst.pop();\n\t\t\t\tfor (auto i : node[np])\n\t\t\t\t{\n\t\t\t\t\tll h = p[i].p;\n\t\t\t\t\tif (used[p[i].t] && p[h].c > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tll w = min(p[h].c, nowin[np]);\n\t\t\t\t\t\tp[h].c -= w;\n\t\t\t\t\t\tp[i].c += w;\n\t\t\t\t\t\tnowin[np] -= w;\n\t\t\t\t\t\tnowin[p[i].t] += w;\n\t\t\t\t\t\tif (nowin[np] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tused[np] = false;\n\t\t\t}\n\t\t}\n\t\tll all = 0;\n\t\tfor (auto i : node[0])\n\t\t{\n\t\t\tif (i % 2 == 0)\n\t\t\t{\n\t\t\t\tall += p[p[i].p].c;\n\t\t\t}\n\t\t}\n\t\treturn all;\n\t}\n\n\tvoid del()\n\t{\n\t\tdelete[] p;\n\t\tdelete[] node;\n\t\tdelete[] used;\n\t\tdelete[] nowin;\n\t}\n};\n\nll dn[2000];\nll dm[2000];\n\nll gcd(ll a, ll b)\n{\n\tif (a % b == 0)\n\t{\n\t\treturn b;\n\t}\n\treturn gcd(b, a % b);\n}\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tscale a;\n\t\tll n, m;\n\t\tscanf(\"%lld%lld\", &n, &m);\n\t\tif (n == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\ta.set(n + m + 2, n * m * 2);\n\t\tfor (ll i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%lld\", &dn[i]);\n\t\t\ta.add(0, 1 + i, 1);\n\t\t}\n\t\tfor (ll i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%lld\", &dm[i]);\n\t\t\ta.add(n + 1 + i, n + m + 1, 1);\n\t\t}\n\t\tfor (ll i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (ll ii = 0; ii < m; ii++)\n\t\t\t{\n\t\t\t\tif (1 < gcd(dn[i], dm[ii]))\n\t\t\t\t{\n\t\t\t\t\ta.add(1 + i, n + 1 + ii, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", a.solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define pb push_back\n#define mp make_pair\n#define SZ(a) ((int)(a.size()))\n#define F first\n#define S second\ntypedef long long ll;\ntypedef pair<int,int> PI;\n\nconst int MAX_N=600;\nint a[MAX_N];\nint b[MAX_N];\nbool vis[MAX_N];\nint match[MAX_N];\nint n,m;\n\nint gcd[500][500];\nvector<int> G[500];\n\nbool aug(int cv){\n  vis[cv] = 1;\n  for(auto j : G[cv]){\n    if(match[j] == -1 ||\n       (!vis[match[j]] && aug(match[j]))){\n      match[j] = cv;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> m >> n, n){\n    rep(i,500) G[i].clear();\n    rep(i,m) cin >> a[i];\n    rep(j,n) cin >> b[j];\n    rep(i,m)rep(j,n)\n      if(1 != __gcd(a[i],b[j]))\n        G[i].pb(j);\n    \n    memset(match,-1,sizeof(match));\n    int ans = 0;\n    rep(i,m){\n      memset(vis,0,sizeof(vis));\n      ans += aug(i);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\ntypedef int Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight == rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nWeight augment(Graph &g, Matrix &capacity, const vector<int> &level, vector<bool> &finished, int from, int t, Weight cur) {\n  if (from == t || cur == 0) { return cur; }\n  if (finished[from]) { return 0; }\n  for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n    int to = it->dest;\n    if (level[to] <= level[from]) { continue; }\n    Weight f = augment(g, capacity, level, finished, to, t, min(cur, capacity[from][to]));\n    if (f > 0) {\n      capacity[from][to] -= f;\n      capacity[to][from] += f;\n      return f;\n    }\n  }\n  finished[from] = true;\n  return 0;\n}\n\nWeight MaxFlow(Graph &g, int s, int t) {\n  int n = g.size();\n  Matrix capacity(n, Array(n));\n  for (int from = 0; from < n; from++) {\n    for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n      int to = it->dest;\n      capacity[from][to] += it->weight;\n    }\n  }\n  int ans = 0;\n  while (true) {\n    vector<int> level(n, -1);\n    level[s] = 0;\n    queue<int> que;\n    que.push(s);\n    for (int d = n; !que.empty() && level[que.front()] < d; ) {\n      int from = que.front();\n      que.pop();\n      if (from == t) { d = level[from]; }\n      for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n        int to = it->dest;\n        if (capacity[from][to] > 0 && level[to] == -1) {\n          que.push(to);\n          level[to] = level[from] + 1;\n        }\n      }\n    }\n    vector<bool> finished(n);\n    bool end = true;\n    while (true) {\n      Weight f = augment(g, capacity, level, finished, s, t, 1000000000);\n      if (f == 0) { break; }\n      ans += f;\n      end = false;\n    }\n    if (end) { break; }\n  }\n  return ans;\n}\n\nint maxFlow(const Graph &g, int s, int t) {\n  const int n = g.size();\n  Matrix capacity(n, Array(n, 0));\n  for (int i = 0; i < n; i++) {\n    for (Edges::const_iterator it = g[i].begin(); it != g[i].end(); it++) {\n      capacity[it->src][it->dest] = it->weight;\n    }\n  }\n  int ret = 0;\n  vector<int> parent(n);\n  while (true) {\n    fill(parent.begin(), parent.end(), -1);\n    priority_queue<Edge> que;\n    que.push(Edge(s, s, 0));\n    while (!que.empty()) {\n      Edge node = que.top();\n      que.pop();\n      if (parent[node.dest]) { continue; }\n      parent[node.dest] = node.src;\n      if (node.dest == t) { break; }\n      int from = node.dest;\n      for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n        int to = it->dest;\n        if (capacity[from][to] == 0 || parent[to] != -1) { continue; }\n        que.push(Edge(from, to, 0));\n      }\n    }\n    if (parent[t] == -1) { break; }\n    Weight flow = 2000000000;\n    int from = parent[t];\n    int to = t;\n    while (from != to) {\n      flow = min(flow, capacity[from][to]);\n      from = parent[from];\n      to = parent[to];\n    }\n    from = parent[t];\n    to = t;\n    while (from != to) {\n      capacity[from][to] -= flow;\n      capacity[to][from] += flow;\n      from = parent[from];\n      to = parent[to];\n    }\n    ret += flow;\n  }\n  return ret;\n}\n\n\n\nint gcd(int a, int b) {\n  if (b == 0) { return a; }\n  return gcd(b, a % b);\n}\n\nint m, n;\nint blue[501];\nint red[501];\n\nint BLUE(int x) { return x; }\nint RED(int x) { return m + x; }\nint SOURCE() { return m + n; }\nint DEST() { return m + n + 1; }\nint SIZE() { return m + n + 2; }\n\nint main() {\n  while (scanf(\"%d %d\", &m, &n), m|n) {\n    Graph g(SIZE());\n    REP(b, m) {\n      scanf(\"%d\", &blue[b]);\n      g[SOURCE()].push_back(Edge(SOURCE(), BLUE(b), 1));\n      g[BLUE(b)].push_back(Edge(BLUE(b), SOURCE(), 0));\n    }\n    REP(r, n) {\n      scanf(\"%d\", &red[r]);\n      g[RED(r)].push_back(Edge(RED(r), DEST(), 1));\n      g[DEST()].push_back(Edge(DEST(), RED(r), 0));\n    }\n    REP(b, m) {\n      REP(r, n) {\n        if (gcd(blue[b], red[r]) != 1) {\n          g[BLUE(b)].push_back(Edge(BLUE(b), RED(r), 1));\n          g[RED(r)].push_back(Edge(RED(r), BLUE(b), 0));\n        }\n      }\n    }\n    assert(MaxFlow(g, SOURCE(), DEST() == maxFlow(g, SOURCE(), DEST()));\n    int ans = MaxFlow(g, SOURCE(), DEST());\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n#define pb push_back\n#define eb emplace_back\n#define INF 1<<30\nconstexpr int gcd(int a,int b){return b?gcd(b,a%b):a;}\nconstexpr int lcm(int a,int b){return a*b/gcd(a,b);}\n\nstruct MaxFlow{\n    struct edge{\n        int to,cap,rev;\n        edge(int t, int c, int r):to(t),cap(c),rev(r){}\n    };\n    vector<vector<edge>> g;\n    vector<bool> used;\n    MaxFlow(int n){\n        g=vector<vector<edge>>(n);\n        used=vector<bool>(n);\n    }\n    void add(int from, int to, int cap){\n        g[from].eb(to,cap,g[to].size());\n        g[to].eb(from,0,g[from].size()-1);\n    }\n    int dfs(int v, int t, int f){\n        if(v==t) return f;\n        used[v]=true;\n        rep(i,g[v].size()){\n            auto &e=g[v][i];\n            if(!used[e.to] && e.cap>0){\n                int d=dfs(e.to, t, min(f,e.cap));\n                if(d>0){\n                    e.cap=-d;\n                    g[e.to][e.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int calcMF(int s, int t){\n        int flow=0;\n        while(1){\n            fill(all(used),false);\n            int f=dfs(s,t,INF);\n            if(f==0) return flow;\n            flow+=f;\n        }\n    }\n};\n\nint main(){\n\tint m,n;\n\twhile(cin>>m>>n,n){\n\t    MaxFlow mf(m+n+2);\n\t    int s=m+n,t=s+1;\n        vi b(m),r(n);\n        rep(i,m){\n            cin>>b[i];\n            mf.add(s,i,1);\n        }\n        rep(i,n){\n            cin>>r[i];\n            mf.add(m+i,t,1);\n            rep(j,m){\n                if(gcd(b[j],r[i])!=1){\n                    mf.add(j,m+i,1);\n                }\n            }\n        }\n        cout<<mf.calcMF(s,t)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\nusing namespace std;\n\n#define INF 2000000000\n\nclass max_flow {\nprivate:\n\tstruct edge { int to, cap, rev; };\n\tint v;\n\tvector<vector<edge>>G;\n\tvector<int>itr, level;\npublic:\n\tmax_flow(int v) :v(v) { G.assign(v, vector<edge>()); }\n\n\tvoid add_edge(int from, int to, int cap) {\n\t\tG[from].push_back(edge { to, cap, (int)G[to].size() });\n\t\tG[to].push_back(edge { from, 0, (int)G[from].size() - 1 });\n\t}\n\n\tvoid bfs(int s) {\n\t\tlevel.assign(v, -1);\n\t\tqueue<int>q;\n\t\tlevel[s] = 0; q.push(s);\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (auto &e : G[v]) {\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int& i = itr[v]; i < (int)G[v].size(); ++i) {\n\t\t\tedge& e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint run(int s, int t) {\n\t\tint ret = 0, f;\n\t\twhile (bfs(s), level[t] >= 0) {\n\t\t\titr.assign(v, 0);\n\t\t\twhile ((f = dfs(s, t, INF)) > 0)ret += f;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint gcd(int a, int b) {\n\tif (b == 0)return a;\n\telse return gcd(b, a%b);\n}\n\nint main() {\n\tint m,n;\n\twhile (1) {\n\t\tcin >> m >> n;\n\t\tif (m == 0)break;\n\t\tmax_flow max_flow(m + n + 2);\n\t\tvector<int>b, r;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tb.push_back(buf);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tr.push_back(buf);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tmax_flow.add_edge(m + n, i, 1);\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (gcd(b[i], r[j]) != 1)max_flow.add_edge(i, m + j, 1);\n\t\t\t\tif (i == 0)max_flow.add_edge(m + j, m + n + 1, 1);\n\t\t\t}\n\t\t}\n\t\tint ans = max_flow.run(m + n, m + n + 1);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<queue>\n#include<iostream>\nusing namespace std;\n\n#define INF 2000000000\n\nclass max_flow {\nprivate:\n\tstruct edge { int to, cap, rev; };\n\tint v;\n\tvector<vector<edge>>G;\n\tvector<int>itr, level;\npublic:\n\tmax_flow(int v) :v(v) { G.assign(v, vector<edge>()); }\n\n\tvoid add_edge(int from, int to, int cap) {\n\t\tG[from].push_back(edge { to, cap, (int)G[to].size() });\n\t\tG[to].push_back(edge { from, 0, (int)G[from].size() - 1 });\n\t}\n\n\tvoid bfs(int s) {\n\t\tlevel.assign(v, -1);\n\t\tqueue<int>q;\n\t\tlevel[s] = 0; q.push(s);\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (auto &e : G[v]) {\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int& i = itr[v]; i < (int)G[v].size(); ++i) {\n\t\t\tedge& e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint run(int s, int t) {\n\t\tint ret = 0, f;\n\t\twhile (bfs(s), level[t] >= 0) {\n\t\t\titr.assign(v, 0);\n\t\t\twhile ((f = dfs(s, t, INF)) > 0)ret += f;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint gcd(int a, int b) {\n\tif (b == 0)return a;\n\telse return gcd(b, a%b);\n}\n\nint main() {\n\tint m,n;\n\twhile (1) {\n\t\tcin >> m >> n;\n\t\tif (m == 0)break;\n\t\tmax_flow max_flow(m + n + 2);\n\t\tvector<int>b, r;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tb.push_back(buf);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tr.push_back(buf);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tmax_flow.add_edge(m + n, i, 1);\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (gcd(b[i], r[j]) != 1)max_flow.add_edge(i, m + j, 1);\n\t\t\t\tif (i == 0)max_flow.add_edge(m + j, m + n + 1, 1);\n\t\t\t}\n\t\t}\n\t\tint ans = max_flow.run(m + n, m + n + 1);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing vi = std::vector<int>;\n\nclass Matching\n{\npublic:\n\tstd::vector<vi> edge;\n\tstd::vector<bool> visited;\n\n\tvoid add_edge(const int from, const int to)\n\t{\n\t\tedge[from][to] = 1;\n\t}\n\n\tint dfs(const int index, const int sink, const int flow)\n\t{\n\t\tif (index == sink)\n\t\t\treturn flow;\n\t\tvisited[index] = true;\n\t\tfor (unsigned int next{}; next < edge.size(); next++)\n\t\t{\n\t\t\tif (visited[next] || !edge[index][next])\n\t\t\t\tcontinue;\n\t\t\tint ret{dfs(next, sink, std::min(flow, edge[index][next]))};\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tedge[index][next] -= ret;\n\t\t\tedge[next][index] += ret;\n\t\t\treturn ret;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint max_flow(const int source, const int sink)\n\t{\n\t\tint flow_sum{};\n\t\twhile (true)\n\t\t{\n\t\t\tstd::fill(visited.begin(), visited.end(), false);\n\t\t\tconst int flow{dfs(source, sink, 1 << 30)};\n\t\t\tif (flow == 0)\n\t\t\t\treturn flow_sum;\n\t\t\tflow_sum += flow;\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nint gcd(int a, int b)\n{\n\twhile (a)\n\t{\n\t\tb %= a;\n\t\tstd::swap(a, b);\n\t}\n\treturn b;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint m, n;\n\t\tscanf(\"%d%d\", &m, &n);\n\t\tif (m == 0 && n == 0) break;\n\n\t\tstd::vector<int> blue(m), red(n);\n\t\tfor (auto &e : blue)\n\t\t\tscanf(\"%d\", &e);\n\t\tfor (auto &e : red)\n\t\t\tscanf(\"%d\", &e);\n\n\t\tMatching mt;\n\t\tmt.edge.resize(n + m + 2, vi(n + m + 2));\n\t\tfor (int i{}; i < m; i++)\n\t\t\tmt.add_edge(n + m, i);\n\t\tfor (int i{}; i < n; i++)\n\t\t\tmt.add_edge(m + i, n + m + 1);\n\t\tfor (int i{}; i < m; i++)\n\t\t{\n\t\t\tfor (int j{}; j < n; j++)\n\t\t\t{\n\t\t\t\tif (gcd(blue[i], red[j]) != 1)\n\t\t\t\t{\n\t\t\t\t\tmt.add_edge(i, m + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmt.visited.resize(m + n + 2);\n\t\tprintf(\"%d\\n\", mt.max_flow(n + m, n + m + 1));\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<n;i++)\n#define loop(i,a,n) for(i=a;i<n;i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\n#define MAX_V 1000\nstruct edge{int to,cap,rev;};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  int i;\n  if(v==t)return f;\n  used[v]=true;\n  rep(i,G[v].size()){\n    edge &e=G[v][i];\n    if(!used[e.to] && e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    memset(used,0,sizeof(used));\n    int f=dfs(s,t,INF);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint main(void) {\n  int i,j;\n  int m,n;\n  while(1){\n    memset(G,0,sizeof(G));\n\n    cin>>m>>n;\n    if(n+m==0)break;\n    vi b(m),r(n);\n    rep(i,m){\n      cin>>b[i];\n      add_edge(0,1+i,1);\n      //cout<<0<<\" \"<<1+i<<endl;\n    }\n    rep(i,n){\n      cin>>r[i];\n      add_edge(1+m+i,1+m+n,1);\n      //      cout<<1+m+i<<\" \"<<1+m+n<<endl;\n    }\n    rep(i,m) rep(j,n) if(__gcd(b[i],r[j])>1) add_edge(1+i,1+m+j,1);\n    \n    cout<<max_flow(0,1+m+n)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <string>\n#include <string.h>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ff first\n#define ss second\n\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\n\nconst int MAX_V = 1010;\nconst int INF = 0x3f3f3f3f;\n\nint M, N;\n\n// 辺を表す構造体（行き先、容量、逆辺）\nstruct edge { int to, cap, rev; };\n\nclass MF {\npublic:\n  vector<edge> G[MAX_V];  // グラフの隣接リスト表現\n  bool used[MAX_V];   // DFSですでに調べたかのフラグ\n\n  // fromからtoへ向かう容量capの辺をグラフに追加する\n  void add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, 0, G[from].size() - 1});\n  }\n\n  // 増加パスをDFSで探す\n  int dfs(int v, int t, int f) {\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++) {\n      edge &e = G[v][i];\n      if(!used[e.to] && e.cap > 0) {\n        int d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  int max_flow(int s, int t) {\n    int flow = 0;\n    for(;;) {\n      memset(used, 0, sizeof(used));\n      int f = dfs(s, t, INF);\n      if(f == 0) return flow;\n      flow += f;\n    }\n  }\n};\n\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a%b);\n}\n\nint main() {\n  while (true) {\n    vi Bs, Rs;\n    cin >> M >> N;\n    if (M==0 && N==0) {\n      break;\n    }\n    MF mf;\n    for (int i = 0; i < M; i++) {\n      int b; cin >> b;\n      Bs.pb(b);\n      mf.add_edge(0, i+1, 1);\n    }\n    for (int i = 0; i < N; i++) {\n      int r; cin >> r;\n      Rs.pb(r);\n      mf.add_edge(i+M+1, M+N+1, 1);\n    }\n    for (int i = 0; i < M; i++) {\n      for (int j = 0; j < N; j++) {\n        if (gcd(Bs[i], Rs[j]) != 1) {\n          // cout << i+1 << \", \" << j+1 << endl;\n          mf.add_edge(i+1, j+M+1, 1);\n        }\n      }\n    }\n    cout << mf.max_flow(0, M+N+1) << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#define rep(i, n) for(int i = 0; i < (int)n; ++i)\nusing namespace std;\n\n#define MAX_V 1004\n\nstruct Edge { int to, cap, rev; };\nint m, n, b[500], r[500];\nvector< Edge > E[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n  E[from].push_back((Edge){to, cap, E[to].size()});\n  E[to].push_back((Edge){from, 0, E[from].size()-1});\n}\n\nint gcd(int a, int b) {\n  if(b == 0) return a;\n  return gcd(b, a%b);\n}\n\nvoid make() {\n  rep(i, MAX_V) {\n    E[i].clear();\n  }\n  rep(i, m) {\n    rep(j, n) {\n      if(gcd(b[i], r[j]) > 1) {\n\tadd_edge(i, m+j, 1);\n      }\n    }\n  }\n  rep(i, m) add_edge(m+n, i, 1);\n  rep(j, n) add_edge(m+j, m+n+1, 1);\n}\n\nint dfs(int pos) {\n  if(pos == m+n+1) {\n    return 1;\n  }\n  used[pos] = true;\n  rep(i, E[pos].size()) {\n    Edge &e = E[pos][i];\n    if(!used[e.to] && e.cap > 0) {\n      int d = dfs(e.to);\n      if(d > 0) {\n\te.cap -= d;\n\tE[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nvoid solve() {\n  make();\n  int ans = 0;\n  while(true) {\n    fill(used, used+MAX_V, false);\n    int res = dfs(m+n);\n    if(res == 0) break;\n    ++ans;\n  }\n  cout << ans << endl;\n}\n\nmain() {\n  while((cin >> m >> n) && (m || n)) {\n    rep(i, m) cin >> b[i];\n    rep(i, n) cin >> r[i];\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 1000\n#define MAX_N 1000\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});  \n}\n\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nint N,K;\nbool can[MAX_N][MAX_N]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(){\n  //0??????N-1: ???????????\\???????????????????????????\n  //N??????N+K-1: ???????????????????????????\n  int s = N+K, t = s+1;\n  \n  //s??¨???????????\\??????????????¶\n  for(int i=0; i<N; i++) add_edge(s,i,1);\n  \n  //????????¨t?????????\n  for(int i=0; i<K; i++) add_edge(N+i,t,1);\n  \n  //???????????\\????????¨??????????????¶\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)\n      if(can[i][j]) add_edge(i, N+j , 1);\n\n  return max_flow(s,t);\n}\n\nint main(){\n  while(1){\n  int b,r,B[501],R[501];\n  cin>>b>>r;\n  if(!b&&!r)break;\n  for(int i=0;i<b;i++) cin>>B[i];\n  for(int i=0;i<r;i++) cin>>R[i];\n\n  memset(can,0,sizeof(can));\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n  N=b,K=r;\n  for(int i=0;i<b;i++)\n    for(int j=0;j<r;j++)\n      if(__gcd(B[i],R[j])>1) can[i][j]=1;\n\n  cout<<Biparite_Matching()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_V = 10000;\nconst int INF = 100000000;\n\n// &#65533;&#65533;&#65533;_&#65533;&#65533;\nint V;\n// &#65533;O&#65533;&#65533;&#65533;t&#65533;&#771;&#65533;&#65533;X&#65533;g&#65533;\\&#65533;&#65533;\nvector<int> G[MAX_V];\n// &#65533;}&#65533;b&#65533;`&#65533;&#65533;&#65533;O&#65533;&#771;y&#65533;A\nint match[MAX_V];\n// dfs&#65533;&#322;&#65533;&#65533;&#322;&#594;&#65533;&#65533;&#1474;&#65533;&#65533;&#65533;&#65533;&#450;&#65533;&#65533;&#65533;&#65533;&#771;t&#65533;&#65533;&#65533;O\nstatic bool used[MAX_V];\n\n// u&#65533;&#65533;v&#65533;&#65533;&#1301;&#1218;&#65533;O&#65533;&#65533;&#65533;t&#65533;&#594;&#457;&#65533;\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\n// &#65533;&#65533;&#65533;&#65533;p&#65533;X&#65533;&#65533;dfs&#65533;&#338;T&#65533;&#65533;\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i],w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// &#65533;&#349443;O&#65533;&#65533;&#65533;t&#65533;&#781;&#337;&#65533;}&#65533;b&#65533;`&#65533;&#65533;&#65533;O&#65533;&#65533;&#1986;&#65533;\nint bipartite_matching(){\n\tint res = 0;\n\t//memset(match,-1,sizeof(match));\n\tfor(int i = 0; i < MAX_V; i++)\n\t\tmatch[i]=-1;\n\tfor(int v = 0; v < V; v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int a,int b){\n\tif(b==0)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\n\n\nint main(){\n\n\tint n,m;\n\tvector<int> bs,rs;\n\tint b,r;\n\n\twhile(cin>>m>>n&&!(m==0&&n==0)){\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\tG[i].clear();\n\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin>>b;\n\t\t\tbs.push_back(b);\n\t\t\tV++;\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>r;\n\t\t\trs.push_back(r);\n\t\t\tV++;\n\t\t}\n\t\tfor(int i = 0; i < rs.size(); i++){\n\t\t\tfor(int j = 0;j < bs.size(); j++){\n\t\t\t\tint res=gcd(rs[i],bs[j]);\n\t\t\t\tif(res>1)\n\t\t\t\t\tadd_edge(i,j+rs.size());\n\t\t\t}\n\t\t}\n\t\tcout<<bipartite_matching()<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint m, n, t, res;\nint blue[510], red[510], match[510];\nbool used[510];\nvector<int> g[510];\n\nint gcd(int x, int y)\n{\n\tif(x < y) swap(x, y);\n\twhile(y)\n\t\tt = x % y, x = y, y = t;\n\treturn x;\n}\n\nbool dfs(int v)\n{\n\tfor(int i = 0; i < g[v].size(); ++i)\n\t{\n\t\tt = g[v][i];\n\t\tif(used[t]) continue;\n\t\tused[t] = true;\n\t\tif(match[t] == -1 || dfs(match[t]))\n\t\t{\n\t\t\tmatch[t] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> m >> n && m)\n\t{\n\t\tfor(int i = 0; i < m; ++i)\n\t\t\tcin >> blue[i], g[i].clear();\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tcin >> red[i];\n\t\tfor(int i = 0; i < m; ++i)\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tif(gcd(blue[i], red[j]) > 1)\n\t\t\t\t\tg[i].push_back(j);\n\t\tres = 0;\n\t\tfill_n(match, n, -1);\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tfill_n(used, n, false);\n\t\t\tif(dfs(i)) ++res;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n//二部マッチング\n//ライブラリげー\n\nint gcd(int a, int b){ \n    if(b == 0) return a;\n    else return gcd(b, (a % b));\n}\n\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n\nconst long long INF = (1ll << 50);\nstruct Dinic {\n  typedef long long flow_type;\n  struct edge {\n    int src, dst;\n    flow_type capacity, flow;\n    size_t rev;\n  };\n  int n;\n  vector<vector<edge>> adj;\n  Dinic(int n) : n(n), adj(n) { }\n  void add_edge(int src, int dst, flow_type capacity) {\n    adj[src].push_back({src, dst, capacity, 0, adj[dst].size()});\n    adj[dst].push_back({dst, src, 0, 0, adj[src].size()-1});\n  }\n  flow_type max_flow(int s, int t) {\n    vector<int> level(n), iter(n);\n    function<int(void)> levelize = [&]() { // foward levelize\n      level.assign(n, -1); level[s] = 0;\n      queue<int> Q; Q.push(s);\n      while (!Q.empty()) {\n        int u = Q.front(); Q.pop();\n        if (u == t) break;\n        for (auto &e: adj[u]) {\n          if (e.capacity > e.flow && level[e.dst] < 0) {\n            Q.push(e.dst);\n            level[e.dst] = level[u] + 1;\n          }\n        }\n      }\n      return level[t];\n    };\n    function<flow_type(int, flow_type)> augment = [&](int u, flow_type cur) {\n      if (u == t) return cur;\n      for (int &i = iter[u]; i < adj[u].size(); ++i) {\n        edge &e = adj[u][i], &r = adj[e.dst][e.rev];\n        if (e.capacity > e.flow && level[u] < level[e.dst]) {\n          flow_type f = augment(e.dst, min(cur, e.capacity - e.flow));\n          if (f > 0) {\n            e.flow += f;\n            r.flow -= f;\n            return f;\n          }\n        }\n      }\n      return flow_type(0);\n    };\n    for (int u = 0; u < n; ++u) // initialize\n      for (auto &e: adj[u]) e.flow = 0;\n\n    flow_type flow = 0;\n    while (levelize() >= 0) {\n      fill(all(iter), 0);\n      for (flow_type f; (f = augment(s, INF)) > 0; )\n        flow += f;\n    }\n    return flow;\n  }\n};\n\nint main(){\n    \n    while(1){\n\n        int m, n; cin >> m >> n;\n        if(!n) break;\n        vector<int> b(m);\n        vector<int> r(n);\n        for(int i = 0; i < m; i++) cin >> b[i];\n        for(int i = 0; i < n; i++) cin >> r[i];\n        \n        //0 := start, [1, m] := blue, [m + 1, m + n] := red, m + n + 1 := goal\n        Dinic G(n + m + 2);\n\n        for(int i = 1; i <= m; i++) G.add_edge(0, i, 1);\n        for(int i = m + 1; i <= m + n; i++) G.add_edge(i, m + n + 1, 1);\n\n        //辺を張る\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(gcd(b[i], r[j]) > 1){\n                    G.add_edge(i + 1, m + j + 1, 1);    \n  \n                }\n            }\n        }\n\n        cout << G.max_flow(0, m + n + 1) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n+m){\n\t\tvector<pair<int, int> > a(n), b(m);\n\t\tfor(int i=0; i< n; i++){int p; cin >> p; a[i] = make_pair(0, p);}\n\t\tfor(int i=0; i< m; i++){int p; cin >> p; b[i] = make_pair(0, p);}\n\n\t\tfor(int i=0; i< n; i++)for(int j=0; j < m; j++){\n\t\t\tif(__gcd(a[i].second, b[j].second) != 1){a[i].first++; b[j].first++;}\n\t\t}\n\t\tsort(a.begin(), a.end()); sort(b.begin(), b.end());\n\n\t\tbool ba[500] = {false}, bb[500] = {false};\n\t\tint ret = 0;\n\t\tfor(int i=0; i< n; i++)for(int j=0; j< m; j++){\n\t\t\tif(!ba[i] && !bb[j] && __gcd(a[i].second, b[j].second) != 1){\n\t\t\t\tret++;\n\t\t\t\tba[i] = true; bb[j] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <cmath>\n#include <map>\n#include <cstring>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for (int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define Cout(obj) cout << obj << endl\n#define Size(obj) (int)(obj).size()\n#define fcout cout << fixed << setprecision(10)\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nconst int MaxV = 10000;\n\nvector<int> graph[MaxV];\nint match[MaxV];\nbool used[MaxV];\n\nvoid addEdge(int u, int v)\n{\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n}\n\nbool dfs(int v)\n{\n    used[v] = true;\n\n    for (auto &e : graph[v])\n    {\n        int u = e, w = match[u];\n\n        if (w < 0 || !used[w] && dfs(w))\n        {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint bipartiteMatcing()\n{\n    int res = 0;\n\n    memset(match, -1, sizeof(match));\n\n    REP(v, MaxV)\n    {\n        if (match[v] < 0)\n        {\n            memset(used, 0, sizeof(used));\n\n            if (dfs(v))\n            {\n                res++;\n            }\n        }\n    }\n\n    return res;\n}\n\nint gcd(int a, int b)\n{\n    if(a < b)\n    {\n        gcd(b, a);\n    }\n\n    if(b == 0)\n    {\n        return a;\n    }\n\n    return gcd(b, a % b);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int M, N;\n    while(cin >> M >> N && M)\n    {\n        vector<int> B(M), R(N);\n\n        REP(i, 1010)\n        {\n            graph[i].clear();\n            match[i] = 0;\n            used[i] = false;\n        }\n\n        REP(i, M)\n        {\n            cin >> B[i];\n        }\n\n        REP(i, N)\n        {\n            cin >> R[i];\n        }\n\n        REP(i, M)\n        {\n            REP(j, N)\n            {\n                if(gcd(B[i], R[j]) == 1) continue;\n                \n                addEdge(i, j + M);\n                   \n            }\n        }\n\n         Cout(bipartiteMatcing());\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint b[501] = {0}, r[501] = {0};\n\nbool augment(const vector<int> g[], int src,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (src < 0) return true;\n  for(auto dst : g[src]) if (!visited[dst]) {\n    visited[dst] = true;\n    if (augment(g, matchTo[dst], matchTo, visited)) {\n      matchTo[src] = dst;\n      matchTo[dst] = src;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartiteMatching(const vector<int> g[], int m, int n) {\n  vector<int> matchTo(m + n, -1);\n  int match = 0;\n  for(int u=0;u<m;++u) {\n    vector<bool> visited(m + n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n\n  return match;\n}\n\nint gcd(int a, int b){\n    return (b != 0 ? gcd(b, a % b) : a);\n}\n\nint main(){\n    int m, n;\n    while(cin >> m >> n, m != 0 || n != 0){\n        for(int i=0;i<m;++i)cin >> b[i];\n        for(int i=0;i<n;++i)cin >> r[i];\n        vector<int> g[m+n];\n        for(int i=0;i<m;++i){\n            for(int j=0;j<n;++j){\n                if(gcd(b[i], r[j]) != 1){\n                    g[i].push_back(m + j);\n                    g[m + j].push_back(i);\n                }\n            }\n        }\n        int ans = bipartiteMatching(g, m, n);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 2222\nvector<int> v[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int a,int b){\n\tv[a].PB(b);\n\tv[b].PB(a);\n}\n\nbool matchdfs(int a){\n\tused[a] = true;\n\tfor(int i = 0;i < v[a].size();i++)\t{\n\t\tint u = v[a][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w)){\n\t\t\tmatch[u] = a;\n\t\t\tmatch[a] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//二部マッチング\nint two_matching_max(int l){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<int> prime;\nbool isp[22222];\nvoid f(){\n\tREP(i,22222)isp[i] = true;\n\tisp[0] = isp[1] = false;\n\tfor(int i = 2;i < 22222;i++){\n\t\tif(isp[i]){\n\t\t\tprime.PB(i);\n\t\t\tfor(int j = i;j < 22222;j+=i)isp[j] = false;\n\t\t}\n\t}\n}\n\t\n#define HALF 1000\nint main(){\n\tf();\n\tint n,m;\n\twhile(cin >> n >> m,n|m){\n\t\tREP(i,MAX_V)v[i].clear();\n\t\tvector<int> a(n);REP(i,n)cin >> a[i];\n\t\tvector<int> b(m);REP(i,m)cin >> b[i];\n\t\tREP(i,n){\n\t\t\tvector<int> tmp;\n\t\t\tREP(j,prime.size()){\n\t\t\t\tif(a[i] % prime[j] == 0)tmp.PB(prime[j]);\n\t\t\t}\n\t\t\tREP(j,m){\n\t\t\t\tREP(k,tmp.size()){\n\t\t\t\t\tif(b[j] % tmp[k] == 0){\n\t\t\t\t\t\tadd_edge(i,j + 1000);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << two_matching_max(MAX_V) << endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<functional>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define MaxCards 1000\nusing namespace std;\nint\tb,r,V;\nint blue[MaxCards],red[MaxCards];\nvector<int> G[MaxCards];\nint match[MaxCards]; \nbool used[MaxCards];\n\n\n\nvoid add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\n// 増加パスをDFSで探す\nbool dfs(int v) {\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++) {\n        int u = G[v][i], w = match[u];\n        if (w < 0 || !used[w] && dfs(w)) {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching() {\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for(int v = 0; v < V; v++) {\n        if (match[v] < 0) {\n            memset(used, 0, sizeof(used));\n            if (dfs(v)) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\nint gcd(int n1,int n2){\n\tif(n1%n2==0) return n2;\n\treturn gcd(n2,n1%n2);\n}\nint main(){\n\n\twhile(true){\n\t\tmemset(blue,0,sizeof(blue));\n\t\tmemset(red,0,sizeof(red));\n\t\tfor(int i=0;i<MaxCards;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tcin>>b>>r;\n\t\tV=b+r;\n\t\tif(b==0)\n\t\t\tbreak;\n\t\tint idx=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tcin >> blue[i];\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin >> red[i];\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tfor(int j=0;j<r;j++){\n\t\t\t\tif(blue[i]>red[j]){\n\t\t\t\t\tif(gcd(blue[i],red[j])!=1){\n\t\t\t\t\t\tadd_edge(i,b+j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(gcd(red[j],blue[i])!=1){\n\t\t\t\t\tadd_edge(i,b+j);\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\ntypedef vector<vector<int> > G;\n\nint flow(G &g, int s, int d){\n  int n = g.size();\n  int ans = 0;\n\n  while(true){\n    vector<int> prevs(n,-1);\n    queue<int> q;\n    bool ok = false;\n\n    prevs[s]=n;\n    q.push(s);\n    while(!q.empty()){\n      int now = q.front();\n      q.pop();\n      if(now == d){\n        ok = true;\n        break;\n      }\n      for(int i=0;i<n;i++){\n        if(g[now][i]>0){\n          if(prevs[i]==-1){\n            prevs[i]=now;\n            q.push(i);\n          }\n        }\n      }\n    }\n\n    if(!ok) return ans;\n\n    int f = 1;\n\n    int pos = d;\n    while(pos != s){\n      int pos2 = prevs[pos];\n      g[pos2][pos]-=f;\n      g[pos][pos2]+=f;\n      pos = pos2;\n    }\n    ans += f;\n  }\n}\n\nint gcd(int a, int b){\n  if(a > b) swap(a, b);\n  if(a == 0) return b;\n  return gcd(a, b%a);\n}\n\n\nint main(){\n  int m,n;\n  int r[500];\n  int b[500];\n  while((m = getInt()) + (n = getInt())){\n    vector<vector<int> > g(n+m+2, vector<int>(n+m+2, 0));\n\n    REP(i,m){\n      b[i] = getInt();\n      g[n+m][i] = 1;\n    }\n    REP(i,n){\n      r[i] = getInt();\n      g[m+i][n+m+1] = 1;\n    }\n\n    REP(i,m) REP(j,n) if(gcd(b[i], r[j]) != 1)\n      g[i][m+j] = 1;\n\n    print(flow(g, n+m, n+m+1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef long double ld;\ntypedef vector<ld> vd;\ntypedef bool bl;\ntypedef vector<bl> vb;\ntypedef unordered_map<ll,unordered_map<ll,ll>> graph;\n\nconst ll e5 = 1 << 20;\nconst ll mod = 1000000007;\nconst ll e3 = 1 << 13;\nconst ll INF = 1ll << 60;\n\nll n,m;\ngraph g;\ngraph r;\nll s,t;\nll vis[e5];\nll level[e5];\nll idx;\nll ans = 0;\nvl anss;\n\n\nll dfs(ll x,ll c){\n  vis[x]++;\n  if(x == t) return c;\n  for(auto y : g[x]){\n    if(vis[y.first] == 1) continue;\n    if(y.second == 0) continue;\n    ll z = dfs(y.first, min(c,y.second));\n    if(z > 0){\n      g[x][y.first] -= z;\n      r[y.first][x] += z;\n      return z;\n    }\n  }\n  for(auto y : r[x]){\n    if(vis[y.first] == 1) continue;\n    if(y.second == 0) continue;\n    ll z = dfs(y.first, min(c,y.second));\n    if(z > 0){\n      r[x][y.first] -= z;\n      g[y.first][x] += z;\n      return z;\n    }\n  }\n  return 0;\n}\n\nll gcd(ll a,ll b){\n  while(a > 0){\n    b = b%a;\n    swap(a,b);\n  }\n  return b;\n}\n\nint main(){\n  while(true){\n    cin >> n >> m;\n    if(n == 0 && m == 0) break;\n    vl b(n+1);\n    vl c(m+1);\n    for(ll i = 1;i <= n;i++) cin >> b[i];\n    for(ll j = 1;j <= m;j++) cin >> c[j];\n    g = graph();\n    r = graph();\n    s = 0;\n    t = n+m+1;\n    ans = 0;\n    for(ll i = 1;i <= n;i++){\n      for(ll j = 1;j <= m;j++){\n        if(gcd(b[i],c[j]) > 1){\n          g[i][n+j] = 1;\n          r[n+j][i] = 0;\n        }\n      }\n    }\n\n    for(ll i = 1;i <= n;i++){\n      g[s][i] = 1;\n      r[i][s] = 0;\n    }\n    for(ll j = 1;j <= m;j++){\n      g[n+j][t] = 1;\n      r[t][n+j] = 0;\n    }\n    idx = t;\n    for(;;){\n      fill(vis,vis+(idx+1),0ll);\n      ll z = dfs(s, INF);\n      // cerr << z << endl;\n      if(z <= 0) break;\n      ans += z;\n    }\n    cout << ans << endl;\n    // anss.push_back(ans);\n  }\n  //\n  // for(ll x : anss){\n  //   cout << ans << endl;\n  // }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst int MAX_V = 1000;\nint V; //????????°\nvector<int> G[MAX_V]; //??°??????\nint match[MAX_V]; // ??????????????°????????¢\nbool used[MAX_V]; // dfs??§??¢???????????????\n\nvoid add_edge(int u, int v){\n    G[u].push_back(v); G[v].push_back(u);\n}\n\n// ?¢???????????????¢?´¢\nbool bp_dfs(int v){\n    used[v]=true;\n    rep(i,G[v].size()){\n        int u=G[v][i], w=match[u];\n        if(w<0 || (!used[w]&&bp_dfs(w))){\n            match[v]=u; match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(){\n    int ret=0;\n    memset(match,-1,sizeof(match));\n    rep(i,V){\n        if(match[i]<0){\n            memset(used,0,sizeof(used));\n            if(bp_dfs(i)) ++ret;\n        }\n    }\n    return ret;\n}\n\nconst int N=3170;\nbool prime[N+1];\nvector<int> p;\n\nint main()\n{\n    fill(prime,prime+N+1,true);\n    prime[0]=prime[1]=false;\n    for(int i=2; i<=N; ++i)\n    {\n        if(prime[i])for(int j=i*2; j<=N; j+=i) prime[j]=false;\n    }\n\n    rep(i,N)if(prime[i]) p.pb(i);\n\n    // printf(\"size %d\\n\", p.size());\n\n    int m,n;\n    while(scanf(\" %d %d\",&m,&n),m)\n    {\n        vector<int> b(m),r(n);\n        rep(i,m) scanf(\" %d\", &b[i]);\n        rep(i,n) scanf(\" %d\", &r[i]);\n\n        V = n+m;\n        rep(i,MAX_V) G[i].clear();\n\n        rep(i,m)rep(j,n)\n        {\n            if(b[i]==r[j]) add_edge(i,m+j);\n        }\n\n        rep(k,p.size())\n        {\n            int d=p[k];\n            rep(i,m)rep(j,n)\n            {\n                if(b[i]%d==0 && r[j]%d==0) add_edge(i,m+j);\n            }\n        }\n\n        printf(\"%d\\n\", bipartite_matching());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nstruct edge{\n\tint to,cap,rev;\n};\n\nvector<edge> g[1024];\nint a[575],b[575];\nbool visited[1024];\n\nvoid make_edge(int u, int v){\n\tedge e;\n\te.to = v; e.cap = 1; e.rev = g[v].l_ength();\n\tg[u].push_back(e);\n\te.to = u; e.cap = 0; e.rev = g[u].l_ength()-1;\n\tg[v].push_back(e); \n}\n\nint gcd(int x, int y){\n\treturn ((y)?gcd(y,x%y):x);\n}\n\nint dfs(int s, int t, int f){\n\tint i,ret;\n\tif(s==t){\n\t\treturn f;\n\t}\n\tvisited[s] = true;\n\tfor(i=(g[s].l_ength()-1); i>=0; --i){\n\t\tif(visited[g[s][i].to]){\n\t\t\tcontinue;\n\t\t}\n\t\tif(!g[s][i].cap){\n\t\t\tcontinue;\n\t\t}\n\t\tret = dfs(g[s][i].to,t,min(f,g[s][i].cap));\n\t\tif(ret > 0){\n\t\t\tg[s][i].cap -= ret;\n\t\t\tg[g[s][i].to][g[s][i].rev].cap += ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void){\n\tint n,m,i,j,f,ans;\n\tcin >> n >> m;\n\twhile(n && m){\n\t\tans = 0;\n\t\tfor(i=0; i<n; ++i){\n\t\t\tmake_edge(n+m,i);\n\t\t\tcin >> a[i];\n\t\t}\n\t\tfor(j=0; j<m; ++j){\n\t\t\tmake_edge(n+j,n+m+1);\n\t\t\tcin >> b[j];\n\t\t}\n\t\tfor(i=0; i<n; ++i){\n\t\t\tfor(j=0; j<m; ++j){\n\t\t\t\tif(gcd(a[i],b[j])>1){\n\t\t\t\t\tmake_edge(i,n+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(true){\n\t\t\tfill(visited,visited+1024,false);\n\t\t\tf = dfs(n+m,n+m+1,INF);\n\t\t\tif(!f){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tans += f;\n\t\t}\n\t\tcout << ans << endl;\n\t\tfor(i=n+m+1; i>=0; --i){\n\t\t\tg[i].clear();\n\t\t}\n\t\tcin >> n >> m;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef int Capacity;\nstruct Dinic {\n    int n, s, t;\n    vector<int> level, progress, que;\n    vector<vector<Capacity>> cap, flow;\n    vector<vector<int>> g;\n    Capacity inf;\n    Dinic(int n)\n        : n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n          g(n, vector<int>()), inf(numeric_limits<Capacity>::max()/8){}\n    Dinic(const Graph &graph){\n        *this = Dinic(graph.size());\n        for(int i = 0; i < n; i++) for(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n    }\n    void addEdge(int u, int v, Capacity c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    inline Capacity residue(int u, int v){ return cap[u][v] - flow[u][v]; }\n    Capacity solve(int s, int t){\n        this->t = t, this->s = s;\n        que.resize(n+1);\n        Capacity res = 0;\n        while(levelize()){\n            progress.assign(n, 0);\n            res += augment(s, inf);\n        }\n        return res;\n    }\n    bool levelize(){\n        int l = 0, r = 0;\n        level.assign(n, -1); level[s] = 0;\n        que[r++] = s;\n        while(l != r){\n            int v = que[l++];\n            if(v == t) break;\n            for(const int &d : g[v]){\n                if((level[d] != -1 && level[d] <= level[v] + 1) || residue(v,d) == 0) continue;\n                level[d] = level[v] + 1; que[r++] = d;\n            }\n        }\n        return level[t] != -1;\n    }\n    Capacity augment(int v, Capacity lim){\n        Capacity res = 0;\n        if(v == t) return lim;\n        for(int &i = progress[v]; i < (int)g[v].size(); i++){\n            const int &d = g[v][i];\n            if(residue(v,d) == 0 || level[v] >= level[d]) continue;\n            const Capacity aug = augment(d, min(lim, residue(v,d)));\n            flow[v][d] += aug; flow[d][v] -= aug;\n            res += aug; lim -= aug;\n            if(lim == 0) break;\n        }\n        return res;\n    }\n};\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nint dp[500][500];\nint gcd(int a, int b){\n    return a < 500 && b < 500 ? dp[a][b] : b == 0 ? a : gcd(b, a%b);\n}\n\n\nint main(){\n    rep(i,500)rep(j,i+1) dp[i][j] = dp[j][i] = __gcd(i,j);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    #define endl \"\\n\"\n    int n,m;\n    while(cin >> n >> m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        Dinic d(n+m+2);\n        int s = n+m, t = n+m+1;\n        rep(i,m) d.addEdge(i+n,t,1);\n        rep(i,n){\n            d.addEdge(s,i,1);\n            rep(j,m) if(gcd(a[i],b[j]) != 1) d.addEdge(i,n+j,1);\n        }\n        cout << d.solve(s,t) << endl;\n    }\n}\n\n// int main(){\n//     int N,M;\n//     cin >> N >> M;\n//     Graph g(N);\n//     rep(i,M){\n//         int a,b,c;\n//         cin >> a >> b >> c;\n//         g[a].emplace_back(a,b,c);\n//     }\n//     Dinic dinic(g);\n//     cout << dinic.solve(0,N-1) << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <complex>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define endl \"\\n\"\n#define print(X) cout << (X) << \"\\n\"\n#define input(X) getline(cin,X)\n// static const int INF = 1e+9+7;\n// static const ll INFL = 1e+18+7;\nll n,m,l;\nint p;\nstring s,t;\nll d[200010],dp[300][300];\nchar field[200][200];\n\nstatic const int MAX = 10000;\nint V;\nvector<int> graph[MAX];\nint match[MAX];\nbool used[MAX];\nbool use_a[MAX];\nbool use_b[MAX];\n\nvoid add_edge(int u,int v){\n  graph[u].push_back(v);\n  graph[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i = 0;i < graph[v].size();i++){\n    int u = graph[v][i] , w = match[u];\n    if(w < 0 || (!used[w] && dfs(w))){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  memset(match,-1,sizeof(match));\n  for(int v = 0;v < V;v++){\n    if(match[v] < 0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)){\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\nint gcd(int x,int y){\n  if(y == 0)return x;\n  return gcd(y,x % y);\n}\n\nvoid init(){\n  rep(i,0,MAX){\n    graph[i].clear();\n  }\n  clr(match,0);\n  clr(used,0);\n  clr(use_a,0);\n  clr(use_b,0);\n  V = 0;\n}\n\nint main(){\n  while(cin >> n >> m,(n + m)){\n    init();\n    vi a(n);\n    vi b(m);\n    rep(i,0,n)cin >> a[i];\n    rep(i,0,m)cin >> b[i];\n\n    rep(i,0,n){\n      rep(j,0,m){\n        if(gcd(a[i],b[j]) > 1){\n          use_a[i] = true;\n          use_b[j] = true;\n          add_edge(i,n+j);\n        }\n      }\n    }\n    rep(i,0,n)V += use_a[i];\n    rep(i,0,m)V += use_b[i];\n    V += n;\n    print(bipartite_matching());\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<utility>\n#include<ctype.h>\n\n#define FOR(i,n) for(int i=0;i<n;++i)\nlong long int  memo[100001] = {};\nconst int inf = 1 << 30;\n//互除法でやる！\nbool gcd(int a, int b) {\n\tif (a < b) std::swap(a, b);\n\tint r;\n\twhile (r = a%b) {\n\t\ta = b;\n\t\tb = r;\n\t\tif (r == 1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn (r== 0 ? true : false);\n}\n\nint main() {\n\n\tint n, m;\n\twhile (true) {\n\t\tstd::cin >> n >> m;\n\t\tif (!n) {\n\t\t\tbreak;\n\t\t}\n\t\tint a[500], b[500], ct = 0;\n\t\tbool aa[500], bb[500];\n\t\t\n\t\tFOR(i, (n >= m ? n:m))std::cin >> a[i];\n\t\tFOR(i, (m<=n?m:n))std::cin >> b[i];\n\t\tstd::sort(a, a + 500);\n\t\tstd::sort(b, b + 500);\n\t\tFOR(i, (n>=m?n:m)) {\n\t\t\tFOR(j, (m<=n?m:n)) {\n\t\t\t\tif ( (!aa[i]  && !bb[j] )&& gcd(a[i], b[j])) {//\n\t\t\t\t\t++ct;\n\t\t\t\t\tbb[j] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << ct << std::endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef int Capacity;\nstruct Dinic {\n    int n, s, t;\n    vector<int> level, iter, que;\n    vector<vector<Capacity>> cap, flow;\n    vector<vector<int>> g;\n    Capacity inf;\n    Dinic(int n)\n        : n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n          g(n, vector<int>()), inf(numeric_limits<Capacity>::max()/8){}\n    Dinic(const Graph &graph){\n        *this = Dinic(graph.size());\n        for(int i = 0; i < n; i++) for(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n    }\n    void addEdge(int u, int v, Capacity c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    inline Capacity residue(int u, int v){ return cap[u][v] - flow[u][v]; }\n    Capacity solve(int s, int t){\n        this->t = t, this->s = s;\n        que.resize(n+1);\n        Capacity res = 0;\n        while(levelize()){\n            iter.assign(n, 0);\n            res += augment(s, inf);\n        }\n        return res;\n    }\n    bool levelize(){\n        int l = 0, r = 0;\n        level.assign(n, -1); level[s] = 0;\n        que[r++] = s;\n        while(l != r){\n            int v = que[l++];\n            for(const int &d : g[v]){\n                if((level[d] != -1 && level[d] <= level[v] + 1) || residue(v,d) == 0) continue;\n                level[d] = level[v] + 1; que[r++] = d;\n            }\n        }\n        return level[t] != -1;\n    }\n    Capacity augment(int v, Capacity lim){\n        Capacity res = 0;\n        if(v == t) return lim;\n        for(int &i = iter[v]; i < (int)g[v].size(); i++){\n            const int &d = g[v][i];\n            if(residue(v,d) == 0 || level[v] >= level[d]) continue;\n            const Capacity aug = augment(d, min(lim, residue(v,d)));\n            flow[v][d] += aug; flow[d][v] -= aug;\n            res += aug; lim -= aug;\n            if(lim == 0) break;\n        }\n        return res;\n    }\n};\n\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n\nint dp[500][500];\nint gcd(int a, int b){\n    return a < 500 && b < 500 ? dp[a][b] : b == 0 ? a : gcd(b, a%b);\n}\n\n\nint main(){\n    rep(i,500)rep(j,i+1) dp[i][j] = dp[j][i] = __gcd(i,j);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    #define endl \"\\n\"\n    int n,m;\n    while(cin >> n >> m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        Dinic d(n+m+2);\n        int s = n+m, t = n+m+1;\n        rep(i,m) d.addEdge(i+n,t,1);\n        rep(i,n){\n            d.addEdge(s,i,1);\n            rep(j,m) if(gcd(a[i],b[j]) != 1) d.addEdge(i,n+j,1);\n        }\n        cout << d.solve(s,t) << endl;\n    }\n}\n\n// int main(){\n//     int N,M;\n//     cin >> N >> M;\n//     Graph g(N);\n//     rep(i,M){\n//         int a,b,c;\n//         cin >> a >> b >> c;\n//         g[a].emplace_back(a,b,c);\n//     }\n//     Dinic dinic(g);\n//     cout << dinic.solve(0,N-1) << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// MEMO\n//\n// O(VE)\n\n// THE BEGINNING OF THE LIBRARY.\n\nstruct BipartiteMatching {\n\tusing UnWeightedGraph=vector< vector<int> >;\n\n\tint n;\n\tUnWeightedGraph G;\n\tvector<int> match,used;\n\n\tBipartiteMatching() {}\n\tBipartiteMatching(int sz):n(sz),G(sz),match(sz),used(sz) {}\n\n\tvoid add_edge(int u,int v) {\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tbool dfs(int v) {\n\t\tused[v]=true;\n\t\tfor(auto u:G[v]) {\n\t\t\tint w=match[u];\n\t\t\tif(w<0||(!used[w]&&dfs(w))) {\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint bipartite_matching() {\n\t\tint res=0;\n\t\tfill(match.begin(),match.end(),-1);\n\t\tfor(int v=0;v<n;v++) {\n\t\t\tif(match[v]<0) {\n\t\t\t\tfill(used.begin(),used.end(),0);\n\t\t\t\tif(dfs(v)) res++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint gcd(int a,int b) {\n\tif(a<b) swap(a,b);\n\tint r;\n\twhile(a%b!=0) {\n\t\tr=b;b=a%b;a=r;\n\t}\n\treturn b;\n}\n\n// THE ENDING OF THE LIBRARY.\n// THE FOLLOWING IS AN EXAMPLE OF USE.\n\nint main() {\n\n\tint m,n;\n\tcin>>m>>n;\n\tvector<int> a(m),b(n);\n\tfor(int i=0;i<m;i++) cin>>a[i];\n\tfor(int i=0;i<n;i++) cin>>b[i];\n\tBipartiteMatching bimatch(m+n);\n\tfor(int i=0;i<m;i++) {\n\t\tfor(int j=0;j<n;j++) {\n\t\t\tif(gcd(a[i],b[j])!=1) bimatch.add_edge(i,j+m);\n\t\t}\n\t}\n\tcout<<bimatch.bipartite_matching()<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <functional>\n\n#define REP(i, a, b) for (int i = int(a); i < int(b); i++)\n#define dump(val) cerr << __LINE__ << \":\\t\" << #val << \" = \" << (val) << endl\n\nusing namespace std;\n\ntypedef long long int lli;\n\ntemplate<typename T>\nvector<T> make_v(size_t a, T b) {\n    return vector<T>(a, b);\n}\n\ntemplate<typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v(ts...))>(a, make_v(ts...));\n}\n\nstruct Edge {\n    int to, cap, rev;\n    Edge(int t, int c, int r)\n        : to(t), cap(c), rev(r) {}\n    Edge() {}\n};\n\nint gcd(int a, int b) {\n    if (b == 0) {\n        return a;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\nint main() {\n    int m, n;\n    while (cin >> m >> n, m + n) {\n        vector<int> cards(m + n);\n        REP(i, 0, m) {\n            cin >> cards[i];\n        }\n        REP(i, 0, n) {\n            cin >> cards[i + m];\n        }\n        vector<vector<Edge>> G(m + n + 2);\n        auto add_edge = [&](int from, int to, int cap) {\n            G[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n            G[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n        };\n        REP(i, 0, m) {\n            REP(j, 0, n) {\n                if (gcd(cards[i], cards[j + m]) != 1) {\n                    add_edge(i, j + m, 1);\n                }\n            }\n        }\n        REP(i, 0, m) {\n            add_edge(m + n, i, 1);\n        }\n        REP(i, 0, n) {\n            add_edge(i + m, m + n + 1, 1);\n        }\n        vector<bool> used(m + n + 2);\n        function<int(int, int, int)> dfs = [&](int v, int t, int f) -> int {\n            if (v == t) return f;\n            used[v] = true;\n            REP(i, 0, G[v].size()) {\n                Edge &e = G[v][i];\n                if (!used[e.to] && e.cap > 0) {\n                    int d = dfs(e.to, t, min(f, e.cap));\n                    if (d > 0) {\n                        e.cap -= d;\n                        G[e.to][e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        };\n        int ans = 0;\n        while (true) {\n            used.assign(m + n + 2, false);\n            int f = dfs(m + n, m + n + 1, 1 << 29);\n            if (f == 0) break;\n            ans += f;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n//Class.\nvector<int> list[100000];\nint N, M, E;\nint match[100000];\nbool used[100000];\nint x[10000], y[10000];\n\nbool DFS(int V) {\n\tused[V] = true;\n\tfor (int i = 0; i < list[V].size(); i++) {\n\t\tint u = list[V][i]; int w = match[u];\n\t\tif (w < 0 || !used[w] && DFS(w)) {\n\t\t\tmatch[V] = u;\n\t\t\tmatch[u] = V;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint supermatching() {\n\tint r = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int j = 0; j < N + M; j++) {\n\t\tif (match[j] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (DFS(j)) { r++; }\n\t\t}\n\t}\n\treturn r;\n}\n\n//main.\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 100000; i++) { list[i].clear(); }\n\t\tcin >> N >> M; if (!N) { break; }\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i];\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> y[i];\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tif (__gcd(x[i], y[j]) != 1) {\n\t\t\t\t\tlist[i].push_back(j + N);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << supermatching() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing Flow = int;\nstruct FlowEdge {\n  int src, dst, rev;\n  Flow cap;\n  FlowEdge(const int s = 0, const int d = 0, const Flow c = 0, const int r = 0) : src(s), dst(d), cap(c), rev(r) {}\n};\n\nusing FlowEdges = std::vector<FlowEdge>;\n\nclass FlowGraph {\n  std::vector<FlowEdges> g;\n\npublic:\n  FlowGraph(const int size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  FlowEdges &operator[](const int i) & { return g[i]; }\n\n  void addEdge(const int src, const int dst, const Flow c = 1) {\n    g[src].emplace_back(src, dst, c, g[dst].size());\n    g[dst].emplace_back(dst, src, 0, g[src].size() - 1);\n  }\n};\n\n// Change it to 'FlowGraph &g' when you need a residual network\ntemplate<Flow inf = std::numeric_limits<Flow>::max() / 8> Flow dinic(FlowGraph g, const int source, const int sink) {\n  std::vector<int> level(g.size()), iter(g.size());\n  auto bfs = [&] {\n    std::fill(level.begin(), level.end(), -1);\n    std::queue<int> q;\n    level[source] = 0;\n    q.push(source);\n    while (q.size()) {\n      int v = q.front();\n      q.pop();\n      for (auto &e : g[v]) {\n        if (level[e.dst] >= 0 || e.cap <= 0) continue;\n        level[e.dst] = level[v] + 1;\n        q.push(e.dst);\n      }\n    }\n    return level[sink] >= 0;\n  };\n  std::function<Flow(int, Flow)> dfs = [&](int v, Flow f) -> Flow {\n    if (v == sink) return f;\n    Flow s = 0;\n    for (; iter[v] < g[v].size(); iter[v]++) {\n      auto &e = g[v][iter[v]];\n      if (level[v] >= level[e.dst] || e.cap <= 0) continue;\n      Flow d = dfs(e.dst, min(f, e.cap));\n      e.cap -= d;\n      g[e.dst][e.rev].cap += d;\n      s += d;\n      f -= d;\n      if (f == 0) break;\n    }\n    return s;\n  };\n  Flow s = 0;\n  while (bfs()) {\n    std::fill(iter.begin(), iter.end(), 0);\n    s += dfs(source, inf);\n  }\n  return s;\n}\n\nconstexpr int gcd(int a, int b) {\n  while (b) b ^= a ^= b ^= a %= b;\n  return a;\n}\n\nmain {\n  int m, n;\n  while (cin >> m >> n, m || n) {\n    vi b(m), r(n);\n    cin >> b >> r;\n    FlowGraph g(m + n + 2);\n    rep(i, m) g.addEdge(m + n, i);\n    rep(i, n) g.addEdge(m + i, m + n + 1);\n    rep(i, m) rep(j, n) if (gcd(b[i], r[j]) > 1) g.addEdge(i, m + j);\n    cout << dinic(g, m + n, m + n + 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define INF 10000000\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define MAX_V 1003\n#define MAX_N 501\n#define MAX_M 501\nusing namespace std;\nstruct edge{\n\tint to,cap,rev;\n};\nbool used[MAX_V];\nbool can[MAX_N][MAX_M];\nvector<edge> G[MAX_V];\nvoid add_edge(int from,int to,int cap){\n\tedge pre;\n\tpre.to=to;pre.cap=cap;pre.rev=G[to].size();\n\tG[from].push_back(pre);\n\tpre.to=from;pre.cap=0;pre.rev=G[from].size()-1;\n\tG[to].push_back(pre);\n}\nint N,M;\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to]&&e.cap>0){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f=dfs(s,t,INF);\n\t\tif(f==0)return flow;\n\t\tflow+=f;\n\t}\n}\nvoid solve(){\n\tint s=N+M,t=s+1;\n\tfor(int i=0;i<M;i++){\n\t\tadd_edge(s,i,1);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tadd_edge(M+i,t,1);\n\t}\n\tfor(int i=0;i<M;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tif(can[i][j]){\n\t\t\t\tadd_edge(i,M+j,1);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<max_flow(s,t)<<endl;\n}\nint main(){\n\tint n[501],m[501];\n\twhile(cin>>M>>N,N||M){\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>m[i];\n\t\t}\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tcin>>n[i];\n\t\t}\n\t\tfor(int i=0;i<M;i++)\n\t\tfor(int j=0;j<N;j++){\n\t\t\tcan[i][j]=0;\n\t\t\tif(__gcd(m[i],n[j])>1){\n\t\t\t\tcan[i][j]=1;\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t\tfor(int i=0;i<=M+N+1;i++)\n\t\tG[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define fi first\n#define se second\n#define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1e9;\n\n//?????§?????????\nconst int MAX_N = 510, MAX_K = 510;\nconst int MAX_V = 510 * 510;\n\nstruct edge{\n    int to, cap, rev;\n};\n\n// vector<edge> G[MAX_N];\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\n//?????¨??????????????°\nint N, K;\nbool can[MAX_N][MAX_K];\n\nint solve(){\n    int s = N + K, t = s + 1;\n    for(int i = 0; i < N; i++){\n        add_edge(s, i, 1);\n    }\n    for(int i = 0; i < K; i++){\n        add_edge(N + i, t, 1);\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < K; j++){\n            if(can[i][j]){\n                add_edge(i, N + j, 1);\n            }\n        }\n    }\n    return max_flow(s, t);\n}\n\nsigned main(){\n    int m, n;\n    while(cin >> m >> n, m + n){\n        memset(can, 0, sizeof(can));\n        rep(i, 0, MAX_V) G[i].clear(), used[i] = false;\n        vector<int> b(m), r(n);\n        rep(i, 0, m) cin >> b[i];\n        rep(i, 0, n) cin >> r[i];\n        N = m; K = n;\n        set<int> bs[510], rs[510];\n        rep(i, 0, m){\n            for(int j = 2; j * j <= b[i]; j++){\n                if(b[i] % j == 0) bs[i].insert(j);\n                while(b[i] % j == 0){\n                    b[i] /= j;\n                }\n            }\n            if(b[i] != 1) bs[i].insert(b[i]);\n        }\n        rep(i, 0, n){\n            for(int j = 2; j * j <= r[i]; j++){\n               if(r[i] % j == 0) rs[i].insert(j);\n                while(r[i] % j == 0){\n                    r[i] /= j;\n                }\n            }\n            if(r[i] != 1) rs[i].insert(r[i]);\n        }\n        \n        rep(i, 0, m){\n            rep(j, 0, n){\n                for(auto& k : bs[i]){\n                    if(rs[j].count(k)){\n                        can[i][j] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        \n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint m, n;\nint blue[505];\nint red[505];\n\nbool bluematch[505];\nint redpair[30];\n\nint path[505][505];\n\nint gcd(int a, int b)\n{\n    int m;\n    \n    while(1){\n        m = a%b;\n        if(m==0)\n            return b;\n        a = b;\n        b = m;\n    }\n    return 1;\n}\n\nbool match(int x){\n    if(x<0) return true;\n    \n    if(bluematch[x]){\n        return false;\n    }\n    bluematch[x]=true;\n    \n    for(int y=0; y<n; y++){\n        if(!path[x][y]) continue;\n        if(match(redpair[y])){\n            redpair[y]=x;\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    \n    int i, j, cnt;\n    while(1){\n        cin >> m >> n;\n        if(m==0 || n==0)\n            break;\n        \n        for(i=0;i<m;i++){\n            cin >> blue[i];\n        }\n        \n        for(i=0;i<n;i++){\n            cin >> red[i];\n        }\n        \n        for(i=0; i<m; i++){\n            for(j=0; j<n; j++){\n                if(gcd(blue[i],red[j])!=1){\n                    path[i][j]=1;\n                }\n                else{\n                    path[i][j]=0;\n                }\n            }\n        }\n        \n        fill(redpair, redpair+n, -1);\n        cnt=0;\n        for(i=0; i<m; i++){\n            fill(bluematch, bluematch+m, 0);\n            if(match(i)){\n                cnt++;\n            }\n        }\n        cout << cnt << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for((i)=0;(i)<(int)n;(i)++)\n#define foreach(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a%b);\n}\n\nconst int SIZE = 1002;\nint V;\nvector<int> G[1002];\nint match[1002];\nbool used[1002];\n\nvoid init(int v) {\n  int i;\n  fill(used, used + SIZE, false);\n  fill(match, match + SIZE, 0);\n  rep (i, SIZE) G[i].clear();\n  V = v;\n}\n\nvoid add_edge(int u, int v) {\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v) {\n  int i;\n  used[v] = true;\n  rep(i,G[v].size()) {\n    int u = G[v][i], w = match[u];\n    if (w < 0 || !used[w] && dfs(w)) {\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching() {\n  int v, res = 0;\n  memset(match, -1, sizeof match);\n  rep(v,V) {\n    if (match[v] < 0) {\n      memset(used, 0, sizeof used);\n      if (dfs(v)) {\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\nint m, n;\nint b[502], r[502];\nconst int MAX_N = 10000000;\n\nint main() {\n  int i, j, k;\n    \n  while (scanf(\"%d%d\", &m, &n), m|n) {\n    rep (i, m) scanf(\"%d\", &b[i]);\n    rep (i, n) scanf(\"%d\", &r[i]);\n\n    init(m+n);    \n    rep (i, m) {\n      rep (j, n) {\n        if (gcd(b[i], r[j]) != 1) add_edge(i, m+j);\n      }\n    }\n    \n    printf(\"%d\\n\", bipartite_matching());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint gcd(int p,int q){\n  int s;\n  while(q){\n    p%=q;\n    s=p;\n    p=q;\n    q=s;\n  }\n  return p;\n}\nint c[500][500],d[500],e[500];\nint m,n;\nvoid fn(int p,int q,int r){\n  int i;\n  if(r){\n    if(d[p]==-1){\n      d[p]=q;\n      for(i=0;i<n;i++){\n\tif(c[p][i]==0)\n\t  fn(i,q,0);\n      }\n    }\n  }else{\n    if(e[p]==-1){\n      e[p]=q;\n      for(i=0;i<m;i++){\n\tif(c[i][p]==0)\n\t  fn(i,q,1);\n      }\n    }\n  }\n  return;\n}\nint main(){\n  int i,j;\n  while(cin>>m>>n&&(m||n)){\n    int a[500],b[500];\n    for(i=0;i<m;i++)\n      cin>>a[i];\n    for(i=0;i<n;i++)\n      cin>>b[i];\n    memset(c,-1,sizeof(c));\n    for(i=0;i<m;i++){\n      for(j=0;j<n;j++){\n\tif(gcd(a[i],b[j])!=1)\n\t  c[i][j]=0;\n      }\n    }\n    memset(d,-1,sizeof(d));\n    memset(e,-1,sizeof(e));\n    int q=0;\n    for(i=0;i<m;i++){\n      if(d[i]==-1){\n\tfn(i,q,1);\n\tq++;\n      }\n    }\n    int f[501],g[501];\n    memset(f,0,sizeof(f));\n    memset(g,0,sizeof(g));\n    for(i=0;i<m;i++)\n      f[d[i]+1]++;\n    for(i=0;i<n;i++)\n      g[e[i]+1]++;\n    int sm=0;\n    for(i=1;i<q+1;i++)\n      sm+=min(f[i],g[i]);\n    cout<<sm<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(int i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<ll,ll> Pi;\nconst int INF=(ll)(1LL<<30)-1;\nconst double INFd=100000000000.0;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\nint dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint V;\nvector<int> G[1100];\nint match[1100];\nbool used[1100];\n\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i],w=match[u];\n\t\tif(w<0|| !used[w]&&dfs(w)){\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res=0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int v=0;v<V;v++){\n\t\tif(match[v]<0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint m,n;\nint b[510],r[510];\nint main(){\n\twhile(1){\n\t\tcin>>m>>n;\n\t\tV=m+n;\n\t\tif(m==0&&n==0)break;\n\t\tREP(i,1100)G[i].clear();\n\t\tREP(i,m)\n\t\t\tcin>>b[i];\n\t\tREP(i,n)\n\t\t\tcin>>r[i];\n\t\tREP(i,m)\n\t\t\tREP(j,n){\n\t\t\t\tif(gcd(b[i],r[j])>1){\n\t\t\t\t\tadd_edge(i,j+501);\n\t\t\t\t}\n\t\t\t}\n\t\tcout<<bipartite_matching()<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define INF 1e9\n\nint gcd(int a,int b){return b==0 ? a : gcd(b,a%b);}\n\nbool dfs(int v,vector<vector<int>> &g,\n    vector<int> &match,vector<bool> &used){\n\n    used[v] = true;\n    for(int u : g[v]){\n        int w = match[u];\n        if(w<0 || (!used[w] && dfs(w,g,match,used))){\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n \nint bipartite_matching(vector<vector<int>> &g){\n    int res = 0;\n    int V = g.size();\n    vector<int> match(V, -INF);\n    rep(v,V){\n        if(match[v] < 0){\n            vector<bool> used(V, false);\n            if(dfs(v,g,match,used)){\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nint main(void){\n    int m,n;\n    while(cin>>m>>n, n|m){\n        vector<int> b(m),r(n);\n        rep(i,m) cin>>b[i];\n        rep(i,n) cin>>r[i];\n\n        vector<vector<int>> g(m+n);\n        rep(i,m)rep(j,n){\n            if(gcd(b[i],r[j]) > 1){\n                g[i].push_back(m+j);\n                g[m+j].push_back(i);\n            }\n        }\n        cout<<bipartite_matching(g)<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct Dinic {\n    int n, s, t;\n    vector<int> level, iter, que;\n    vector<vector<Capacity>> cap, flow;\n    vector<vector<int>> g;\n    Capacity inf;\n    Dinic(int n)\n        : n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n          g(n, vector<int>()), inf(numeric_limits<Capacity>::max()/8){}\n    Dinic(const Graph &graph){\n        *this = Dinic(graph.size());\n        rep(i,n) for(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n    }\n    void addEdge(int u, int v, Capacity c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    inline Capacity residue(int u, int v){ return cap[u][v] - flow[u][v]; }\n    Capacity solve(int s, int t){\n        this->t = t, this->s = s;\n        Capacity res = 0, aug = 1;\n        while(aug > 0){\n            levelize();\n            iter.assign(n, 0);\n            res += (aug = augment(s, inf));\n        }\n        return res;\n    }\n    void levelize(){\n        level.assign(n, inf); level[s] = 0;\n        int l = 0, r = 0;\n        que.assign(n+1, 0);\n        que[r++] = s;\n        while(l != r){\n            int v = que[l++];\n            for(const int &d : g[v]){\n                if(level[d] <= level[v] + 1 || residue(v,d) == 0) continue;\n                level[d] = level[v] + 1; que[r++] = d;\n            }\n        }\n    }\n    Capacity augment(int v, Capacity lim){\n        Capacity res = 0;\n        if(v == t) return lim;\n        for(int &i = iter[v]; i < (int)g[v].size(); i++){\n            const int &d = g[v][i];\n            if(residue(v,d) == 0 || level[v] + 1 != level[d]) continue;\n            const Capacity aug = augment(d, min(lim, residue(v,d)));\n            if(aug > 0){\n                flow[v][d] += aug; flow[d][v] -= aug;\n                res += aug; lim -= aug;\n                if(lim == 0) return res;\n            }\n        }\n        return res;\n    }\n};\n\nint dp[2000][2000];\nint gcd(int a, int b){\n    return a < 2000 && b < 2000 ? dp[a][b] : __gcd(a,b);\n}\n\n\nint main(){\n    rep(i,2000)rep(j,i+1) if(i*j) dp[i][j] = dp[j][i] = __gcd(i,j);\n    fastios();\n    int n,m;\n    while(cin >> n >> m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        Dinic d(n+m+2);\n        int s = n+m, t = n+m+1;\n        rep(i,m) d.addEdge(i+n,t,1);\n        rep(i,n){\n            d.addEdge(s,i,1);\n            rep(j,m) if(gcd(a[i],b[j]) != 1) d.addEdge(i,n+j,1);\n        }\n        rep(i,n)rep(j,m){\n            if(d.flow[i][j+n]) dump(i,j, d.flow[i][j+m]);\n        }\n        cout << d.solve(s,t) << endl;\n    }\n}\n\n// int main(){\n//     int N,M;\n//     cin >> N >> M;\n//     Graph g(N);\n//     rep(i,M){\n//         int a,b,c;\n//         cin >> a >> b >> c;\n//         g[a].emplace_back(a,b,c);\n//     }\n//     Dinic dinic(g);\n//     cout << dinic.solve(0,N-1) << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <queue>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cap, rev;\n\tedge(llint a, llint b, llint c){\n\t\tto = a, cap = b, rev = c;\n\t}\n};\n\nllint m, n;\nllint b[505], r[505];\n\nvector<edge> G[1005];\nllint S, T;\nllint level[1005], iter[1005];\n\nvoid bfs(llint s)\n{\n\tfor(int i = 1; i <= T; i++) level[i] = inf;\n\tlevel[s] = 0;\n\t\n\tqueue<int> Q;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v = Q.front();\n\t\tQ.pop();\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tint u = G[v][i].to;\n\t\t\tif(G[v][i].cap <= 0 || level[u] < inf) continue;\n\t\t\tlevel[u] = level[v] + 1;\n\t\t\tQ.push(u);\n\t\t}\n\t}\n}\n\nllint dfs(int v, llint f)\n{\n\tif(v == T) return f;\n\t\n\tllint ret;\n\tfor(llint &i = iter[v]; i < G[v].size(); i++){\n\t\tif(level[v] >= level[G[v][i].to] || G[v][i].cap <= 0) continue;\n\t\tret = dfs(G[v][i].to, min(f, G[v][i].cap));\n\t\tif(ret > 0){\n\t\t\tG[v][i].cap -= ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap += ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid add_edge(int s, int t, llint cap)\n{\n\tG[s].push_back(edge(t, cap, G[t].size()));\n\tG[t].push_back(edge(s, 0, G[s].size()-1));\n}\n\nllint gcd(llint a, llint b)\n{\n\tif(b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> m >> n;\n\t\tif(n == 0 || m == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= m; i++) cin >> b[i];\n\t\tfor(int i = 1; i <= n; i++) cin >> r[i];\n\t\t\n\t\tS = n+m+1, T = n+m+2;\n\t\tfor(int i = 1; i <= T; i++) G[i].clear();\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tif(gcd(b[i], r[j]) > 1) add_edge(i, m+j, 1);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= m; i++) add_edge(S, i, 1);\n\t\tfor(int i = 1; i <= n; i++) add_edge(m+i, T, 1);\n\t\t\n\t\tllint ans = 0, flow;\n\t\twhile(1){\n\t\t\tbfs(S);\n\t\t\tif(level[T] >= inf) break;\n\t\t\tfor(int i = 1; i <= T; i++) iter[i] = 0;\n\t\t\twhile(1){\n\t\t\t\tflow = dfs(S, inf);\n\t\t\t\tif(flow <= 0) break;\n\t\t\t\tans += flow;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint e, v;\n\nclass pass\n{\npublic:\n\tint t;\n\tint c;\n\tint p;\n};\n\npass p[250000];\n\nint noded[1000];\npair<int, int> nodef[1000];\nvector<int> node[1000];\n\nvoid add(int f, int t, int c)\n{\n\tp[e].t = t;\n\tp[e].c = c;\n\tp[e].p = e + 1;\n\tp[e + 1].t = f;\n\tp[e + 1].c = 0;\n\tp[e + 1].p = e;\n\tnode[f].push_back(e);\n\tnode[t].push_back(e + 1);\n\te += 2;\n}\n\nvoid push()\n{\n\tpriority_queue<pair<int, int>> q;\n\tfor (int i = 0; i < v; i++)\n\t{\n\t\tnoded[i] = 0;\n\t\tnodef[i] = make_pair(0, 0);\n\t}\n\tnoded[0] = v;\n\tfor (auto i : node[0])\n\t{\n\t\tif (p[i].c > 0)\n\t\t{\n\t\t\tp[p[i].p].c += p[i].c;\n\t\t\tnodef[p[i].t].first += p[i].c;\n\t\t\tnodef[0].second += p[i].c;\n\t\t\tp[i].c = 0;\n\t\t\tq.push(make_pair(0, p[i].t));\n\t\t}\n\t}\n\tnodef[v - 1].second = (1 << 20);\n\twhile (!q.empty())\n\t{\n\t\tint np = q.top().second;\n\t\tq.pop();\n\t\twhile (1)\n\t\t{\n\t\t\tfor (auto i : node[np])\n\t\t\t{\n\t\t\t\tif (p[i].c > 0)\n\t\t\t\t{\n\t\t\t\t\tint t = p[i].t;\n\t\t\t\t\tif (noded[np] == noded[t] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tint kae = min(p[i].c, nodef[np].first - nodef[np].second);\n\t\t\t\t\t\tp[i].c -= kae;\n\t\t\t\t\t\tp[p[i].p].c += kae;\n\t\t\t\t\t\tnodef[np].second += kae;\n\t\t\t\t\t\tbool w = (nodef[t].first <= nodef[t].second);\n\t\t\t\t\t\tnodef[t].first += kae;\n\t\t\t\t\t\tif (w && nodef[t].first > nodef[t].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tq.push(make_pair(noded[t], t));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nodef[np].first <= nodef[np].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nodef[np].first > nodef[np].second && np != 0)\n\t\t\t{\n\t\t\t\tint minw = (1 << 20);\n\t\t\t\tfor (auto i : node[np])\n\t\t\t\t{\n\t\t\t\t\tif (p[i].c > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tminw = min(minw, noded[p[i].t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnoded[np] = minw + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dn[1000];\nint dm[1000];\n\nint gcd(int a, int b)\n{\n\tif (a % b == 0)\n\t{\n\t\treturn b;\n\t}\n\treturn gcd(b, a % b);\n}\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tint n, m;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tv = n + m + 2;\n\t\tfor (int i = 0; i < v; i++)\n\t\t{\n\t\t\tnode[i].clear();\n\t\t}\n\t\te = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &dn[i]);\n\t\t\tadd(0, 1 + i, 1);\n\t\t}\n\t\tfor (int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &dm[i]);\n\t\t\tadd(n + 1 + i, n + m + 1, 1);\n\t\t}\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int ii = 0; ii < m; ii++)\n\t\t\t{\n\t\t\t\tif (1 < gcd(dn[i], dm[ii]))\n\t\t\t\t{\n\t\t\t\t\tadd(1 + i, n + 1 + ii, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpush();\n\t\tint all = 0;\n\t\tfor (auto i : node[0])\n\t\t{\n\t\t\tif (i % 2 == 0)\n\t\t\t{\n\t\t\t\tall += p[p[i].p].c;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", all);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\n\nstruct edge{\n\tint to,co,p;\n};\n\nvector<edge> vs[505];\n\nvoid cleae(){\n\trep(i,505)vs[i].clear();\n}\n\nvoid adde(int a,int b,int c){\n\t//printf(\"fr %d to %d co %d\\n\",a,b,c);\n\tint sa=vs[a].size(),\n\t\tsb=vs[b].size();\n\tedge e; e.co=c;\n\te.to=b; e.p=sb; vs[a].push_back(e);\n\te.to=a; e.p=sa; vs[b].push_back(e);\n}\n\nint st,gl;\nint gone[505];\nint dfs(int no,int f){\n\tif(gone[no])return 0;\n\tgone[no]=1;\n\tif(no==gl)return f;\n\trep(i,vs[no].size()){\n\t\tedge& e=vs[no][i];\n\t\tif(gone[e.to])continue;\n\t\tif(e.co>0){\n\t\t\tint gf = dfs(e.to,min(e.co,f));\n\t\t\tif(gf>0){\n\t\t\t\te.co-=gf;\n\t\t\t\tvs[e.to][e.p].co+=gf;\n\t\t\t\treturn gf;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(){\n\tint res=0;\n\tfor(;;){\n\t\tmemset(gone,0,sizeof(gone));\n\t\tint f = dfs(st,IINF);\n\t\tif(f==0)return res;\n\t\tres+=f;\n\t}\n}\n\nint na,nb;\nint da[505];\nint db[505];\nint gcd(int p,int q){\n\tif(p<q)swap(p,q);\n\tif(p%q==0)return q;\n\treturn gcd(q,p%q);\n}\n\nint main(void){\n\tfor(;;){\n\t\tscanf(\"%d%d\",&na,&nb);\n\t\tif(na==0)break;\n\t\trep(i,na)scanf(\"%d\",&da[i]);\n\t\trep(i,nb)scanf(\"%d\",&db[i]);\n\t\tcleae();\n\t\t\n\t\tst=0;\n\t\tgl=na+nb+1;\n\t\trep(i,na)adde(st,i+1,1);\n\t\trep(i,nb)adde(i+na+1,gl,1);\n\t\t\n\t\trep(i,na)rep(j,nb){\n\t\t\tif(gcd(da[i],db[j])>1)adde(i+1,j+na+1,1);\n\t\t}\n\t\tprintf(\"%d\\n\",flow());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n//typedef long long Int;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst) : src(src),dst(dst) {}\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) {}\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vec<Edge> Edges;\ntypedef vec<Edges> Graph;\n\n#define MAXMN 500\nint B[MAXMN];\nint R[MAXMN];\n\nint gcd(int a, int b)\n{   \n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  return match;\n}\n\n\nint main(int argc, char **argv) {\n  int M,N;\n  Graph g; g.reserve(MAXMN+MAXMN);\n  while(cin>>M>>N,M) {\n    g.clear();\n    g.resize(M+N);\n    REP(i,M) cin>>B[i];\n    REP(i,N) cin>>R[i];\n    REP(i,M) {\n      Edges es, es2;\n      REP(j,N) {\n\tif(gcd(B[i],R[j])!=1) { es.pb(Edge(i,M+j)); es2.pb(Edge(M+j,i)); }\n      }\n      g[i] = es;\n      g[M+i] = es2;\n    }\n    cout << bipartiteMatching(g,M) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nlong long e, v;\n\nclass pass\n{\npublic:\n\tlong long t;\n\tlong long c;\n\tlong long p;\n};\n\npass p[250000];\n\nlong long noded[1000];\npair<long long, long long> nodef[1000];\nvector<long long> node[1000];\n\nvoid add(long long f, long long t, long long c)\n{\n\tp[e].t = t;\n\tp[e].c = c;\n\tp[e].p = e + 1;\n\tp[e + 1].t = f;\n\tp[e + 1].c = 0;\n\tp[e + 1].p = e;\n\tnode[f].push_back(e);\n\tnode[t].push_back(e + 1);\n\te += 2;\n}\n\nvoid push()\n{\n\tpriority_queue<pair<long long, long long>> q;\n\tfor (long long i = 0; i < v; i++)\n\t{\n\t\tnoded[i] = 0;\n\t\tnodef[i] = make_pair(0, 0);\n\t}\n\tnoded[0] = v;\n\tfor (auto i : node[0])\n\t{\n\t\tif (p[i].c > 0)\n\t\t{\n\t\t\tp[p[i].p].c += p[i].c;\n\t\t\tnodef[p[i].t].first += p[i].c;\n\t\t\tnodef[0].second += p[i].c;\n\t\t\tp[i].c = 0;\n\t\t\tq.push(make_pair(0, p[i].t));\n\t\t}\n\t}\n\tnodef[v - 1].second = ((long long)1 << 50);\n\twhile (!q.empty())\n\t{\n\t\tlong long np = q.top().second;\n\t\tq.pop();\n\t\twhile (1)\n\t\t{\n\t\t\tfor (auto i : node[np])\n\t\t\t{\n\t\t\t\tif (p[i].c > 0)\n\t\t\t\t{\n\t\t\t\t\tlong long t = p[i].t;\n\t\t\t\t\tif (noded[np] == noded[t] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long kae = min(p[i].c, nodef[np].first - nodef[np].second);\n\t\t\t\t\t\tp[i].c -= kae;\n\t\t\t\t\t\tp[p[i].p].c += kae;\n\t\t\t\t\t\tnodef[np].second += kae;\n\t\t\t\t\t\tbool w = (nodef[t].first <= nodef[t].second);\n\t\t\t\t\t\tnodef[t].first += kae;\n\t\t\t\t\t\tif (w && nodef[t].first > nodef[t].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tq.push(make_pair(noded[t], t));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nodef[np].first <= nodef[np].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nodef[np].first > nodef[np].second && np != 0)\n\t\t\t{\n\t\t\t\tlong long minw = ((long long)1 << 50);\n\t\t\t\tfor (auto i : node[np])\n\t\t\t\t{\n\t\t\t\t\tif (p[i].c > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tminw = min(minw, noded[p[i].t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnoded[np] = minw + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long dn[1000];\nlong long dm[1000];\n\nlong long gcd(long long a, long long b)\n{\n\tif (a % b == 0)\n\t{\n\t\treturn b;\n\t}\n\treturn gcd(b, a % b);\n}\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tlong long n, m;\n\t\tscanf(\"%lld%lld\", &n, &m);\n\t\tif (n == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tv = n + m + 2;\n\t\te = 0;\n\t\tfor (long long i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%lld\", &dn[i]);\n\t\t\tadd(0, 1 + i, 1);\n\t\t}\n\t\tfor (long long i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%lld\", &dm[i]);\n\t\t\tadd(n + 1 + i, n + m + 1, 1);\n\t\t}\n\t\tfor (long long i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (long long ii = 0; ii < m; ii++)\n\t\t\t{\n\t\t\t\tif (1 < gcd(dn[i], dm[ii]))\n\t\t\t\t{\n\t\t\t\t\tadd(1 + i, n + 1 + ii, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpush();\n\t\tlong long all = 0;\n\t\tfor (auto i : node[0])\n\t\t{\n\t\t\tif (i % 2 == 0)\n\t\t\t{\n\t\t\t\tall += p[p[i].p].c;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", all);\n\t\tfor (long long i = 0; i < v; i++)\n\t\t{\n\t\t\tnode[i].clear();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> L[2000];int N,M,E,C[2000],x[2000],y[2000];bool U[2000];\nbool DFS(int V){\n    U[V]=true;\n    for(int i=0;i<L[V].size();i++){\n        int u=L[V][i],w=C[u];\n        if(w<0||!U[w]&&DFS(w)){\n            C[V]=u;\n            C[u]=V;\n            return 1;\n        }\n    }\n    return 0;\n}\nint SM(){\n    int r=0;\n    memset(C,-1,8000);\n    for(int j=0;j<N+M;j++){\n        if(C[j]<0){\n            memset(U,0,8000);\n            if(DFS(j)){r++;}\n        }\n    }\n    return r;\n}\nint main(){\n    while(1){\n        for(int i=0;i<2000;i++){L[i].clear();}\n        cin>>N>>M;if(!N){break;}\n        for(int i=0;i<N;i++){\n            cin>>x[i];\n        }\n        for(int i=0;i<M;i++){\n            cin>>y[i];\n        }\n        for(int i=0;i<N;i++){\n            for(int j=0;j<M;j++){\n                if(__gcd(x[i],y[j])>1){\n                    L[i].push_back(j+N);\n                }\n            }\n        }\n        cout<<SM()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, m, n) for(int i=(m); i<(n); ++i)\n#define rrep(i, n) for(int i=(n)-1; i>=0; --i)\n#define rfor(i, m, n) for(int i=(m); i>=(n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing LL = long long;\t\tusing ld = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<LL>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<double>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<LL, LL>;\tusing VPL = vector<PLL>;\ntemplate<class T>using Grid = vector<vector<T>>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr LL inf_ll = (LL)1e18, MOD = 1000000007;\nconstexpr ld PI = M_PI, EPS = 1e-12;\n\ntemplate<class T>inline void Sort(T& a)noexcept { sort(all(a)); }\ntemplate<class T>inline void RSort(T& a)noexcept { sort(rall(a)); }\ntemplate<class T>inline void Reverse(T& a)noexcept { reverse(all(a)); }\ntemplate<class T>inline void Unique(T& a)noexcept { a.erase(unique(all(a)), a.end()); }\ntemplate<class T>inline T Sorted(T a)noexcept { Sort(a); return a; }\ntemplate<class T>inline T RSorted(T a)noexcept { RSort(a); return a; }\ntemplate<class T>inline T Reversed(T a)noexcept { Reverse(a); return a; }\ntemplate<class T>inline T Uniqued(T a)noexcept { Unique(a); return a; }\ntemplate<class T>inline auto Max(const T& a)noexcept { return *max_element(all(a)); }\ntemplate<class T>inline auto Min(const T& a)noexcept { return *min_element(all(a)); }\ntemplate<class T>inline int MaxPos(const T& a)noexcept { return max_element(all(a)) - a.begin(); }\ntemplate<class T>inline int MinPos(const T& a)noexcept { return min_element(all(a)) - a.begin(); }\ntemplate<class T, class U>inline int Count(const T& a, const  U& v)noexcept { return count(all(a), v); }\ntemplate<class T, class U>inline int Find(const T& a, const U& v)noexcept { auto pos = find(all(a), v); return pos == a.end() ? -1 : pos - a.begin(); }\ntemplate<class T, class U>inline U Sum(const T& a, const U& v)noexcept { return accumulate(all(a), v); }\ntemplate<class T, class U>inline int Lower(const T& a, const U& v)noexcept { return lower_bound(all(a), v) - a.begin(); }\ntemplate<class T, class U>inline int Upper(const T& a, const U& v)noexcept { return upper_bound(all(a), v) - a.begin(); }\ntemplate<class T, class P>inline void RemoveIf(T& a, P f)noexcept { a.erase(remove_if(all(a), f), a.end()); }\ntemplate<class T>inline T Age(T n, T m)noexcept { return (n + m - 1) / m; }\ntemplate<class T>inline T Age2(T n, T m)noexcept { return Age(n, m) * m; }\ntemplate<class T>inline T Tri(T n)noexcept { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\ntemplate<class T = long long>inline T BIT(int b)noexcept { return T{ 1 } << b; }\ntemplate<class T>inline T Gcd(T n, T m)noexcept { return m ? Gcd(m, n % m) : n; }\ntemplate<class T>inline T Lcm(T n, T m)noexcept { return n / Gcd(n, m) * m; }\ntemplate<class T>inline T Pow(T a, T n)noexcept { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; }return r; }\ntemplate<class T>inline T Powmod(T a, T n, T m = MOD)noexcept { T r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r; }\ntemplate<class T>inline bool chmax(T& a, const T& b)noexcept { if (a < b) { a = b; return true; } return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b)noexcept { if (a > b) { a = b; return true; } return false; }\ntemplate<class T>inline bool inRange(const T& v, const T& min, const T& max)noexcept { return min <= v && v <= max; }\ninline string operator*(string s, int n)noexcept { string ret; rep(i, n)ret += s; return ret; }\n\n// --- input --- //\n#if defined(_WIN32) || defined(ONLINE_JUDGE)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\ninline int gc()noexcept { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v)noexcept { cin >> v; }\ninline void InputF(char& v)noexcept { while (isspace(v = gc())); }\ninline void InputF(string& v)noexcept {\n\tchar c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (LL)(c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v)noexcept {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v)noexcept {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v)noexcept {\n\tfor (auto& e : v)InputF(e);\n}\ntemplate<class T>inline T input() { T v; InputF(v); return v; }\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>()noexcept {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>()noexcept {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T()noexcept { return input<T>(); }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n)noexcept { return InputV(n); }\n\tInputV operator[](pair<int, int> n)noexcept { return InputV(n); }\n\tvoid operator()() {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tInputF(h); operator()(forward<T>(t)...);\n\t}\n\ttemplate<class T, size_t W>array<vector<T>, W> get(int H) {\n\t\tarray<vector<T>, W> ret;\n\t\trep(i, H)rep(j, W) { T x = *this; ret[j].push_back(x); }\n\t\treturn ret;\n\t}\n}in;\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc }; bool isPrint = true;\n\tvoid p(double v) { printf(\"%.20f\", v); } void p(long double v) { printf(\"%.20Lf\", v); }\n\tvoid p(int v) { printf(\"%d\", v); }\tvoid p(LL v) { printf(\"%lld\", v); }\n\tvoid p(char v) { putchar(v); }\t\tvoid p(bool v) { printf(\"%s\", v ? B.t : B.f); }\n\ttemplate<class T>void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); printf(\"%s\", D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.l); p(v[i]); } }\n\tvoid p(const BoolStr& v) { B = v; isPrint = false; } void p(const DivStr& v) { D = v; isPrint = false; }\npublic:\n\tvoid operator()() { printf(\"%s\", D.l); }\n\ttemplate<class H>void operator()(H&& h) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.l); isPrint = true;\n\t}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.d); isPrint = true; operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...); std::exit(EXIT_SUCCESS);\n\t}\n}out;\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) (void(0))\n#endif\n\n// ---------------------------------------------------------------- //\n\nusing FLOW = long long;\nconstexpr FLOW INF_FLOW = numeric_limits<FLOW>::max();\nstruct EdgeF {\n\tint to, rev; FLOW cap;\n\tEdgeF() :to(-1), rev(-1), cap(-1) {}\n\tEdgeF(int t, int r, FLOW c) :to(t), rev(r), cap(c) {}\n};\n\nclass Dinic {\n\tint V;\n\tvector<vector<EdgeF>> G;\n\tvector<int> level, iter;\n\npublic:\n\tDinic(int v) :V(v), G(v), level(v), iter(v) {}\n\tvoid add(int from, int to, FLOW cap) {\n\t\tG[from].emplace_back(to, G[to].size(), cap);\n\t\tG[to].emplace_back(from, G[from].size() - 1, 0);\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1); level[s] = 0;\n\t\tqueue<int> q; q.push(s);\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (auto& e : G[v]) {\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tFLOW dfs(int v, int t, FLOW f) {\n\t\tif (v == t)return f;\n\t\tfor (int i = iter[v]; i < G[v].size(); ++i) {\n\t\t\tauto& e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tFLOW d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tFLOW operator()(int s, int t) {\n\t\tFLOW res = 0;\n\t\twhile (true) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return res;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tFLOW f;\n\t\t\twhile ((f = dfs(s, t, INF_FLOW)) > 0)res += f;\n\t\t}\n\t}\n};\n\nint main() {\n\tfor (int n, m; cin >> n >> m && n;) {\n\t\tVI a = in[n], b = in[m];\n\t\tDinic flow(n + m + 2);\n\t\tint s = n + m, t = n + m + 1;\n\t\trep(i, n) {\n\t\t\tflow.add(s, i, 1);\n\t\t}\n\t\trep(i, m) {\n\t\t\tflow.add(n + i, t, 1);\n\t\t}\n\t\trep(i, n)rep(j, m) {\n\t\t\tif (Gcd(a[i], b[j]) != 1) {\n\t\t\t\tflow.add(i, n + j, 1);\n\t\t\t}\n\t\t}\n\t\tout(flow(s, t));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); ++i)\n#define rep(i,n) REP(i,0,n)\n\nvector<int> g[1010];\nint n, m;\n \nvector<bool> visited, matched;\nvector<int> levels, matching;\n \nbool augment(int left) {\n  if(left == n) return true;\n  if(visited[left]) return false;\n  visited[left] = true;\n  rep(i, g[left].size()) {\n    int right = g[left][i];\n    int next = matching[right];\n    if (levels[next] > levels[left] && augment(next)) {\n      matching[right] = left;\n      return true;\n    }\n  }\n  return false;\n}\n \nint bimatch() {\n  matching.assign(m, n);\n  matched.assign(n, false);\n  //int ret = 0;\n  bool cont;\n  do {\n    levels.assign(n+1, -1);\n    levels[n] = n;\n    queue<int> q;\n    rep(left, n) if (!matched[left]) {\n      q.push(left);\n      levels[left] = 0;\n    }\n    while(!q.empty()) {\n      int left = q.front();\n      q.pop();\n      rep(i, g[left].size()) {\n        int right = g[left][i];\n        int next = matching[right];\n        if (levels[next] < 0) {\n          levels[next] = levels[left] + 1;\n          q.push(next);\n        }\n      }\n    }\n    visited.assign(n, false);\n    cont = false;\n    /*\n    rep(i,n){\n      cout << \"match:\" << i << \" : \" << matched[i] << endl;\n    }\n    rep(i,n){\n      cout << \"levels:\" << i << \" : \" << levels[i] << endl;\n    }\n      */\n    rep(left, n) if(!matched[left] && augment(left)){\n      matched[left] = cont = true;\n      //ret++;\n    }\n  } while(cont);\n  //printf(\"ret:%d\\n\",ret);\n  return count(matched.begin(), matched.end(), true);\n}\n\nint blue[510],red[510];\n\nint main(){\n  while(scanf(\"%d%d\",&n,&m),n|m){\n    //init\n    rep(i,1010)g[i].clear();\n    visited.clear();\n    matched.clear();\n    levels.clear();\n    matching.clear();\n    \n    \n    \n    rep(i,n)scanf(\"%d\",blue+i);\n    rep(i,m)scanf(\"%d\",red+i);\n\n    rep(i,n){\n      rep(j,m)if( __gcd(blue[i],red[j])!=1 ){\n        g[i].push_back(n+j);\n        g[n+j].push_back(i);\n      }\n    }\n    //\n    /*\n    rep(i,n+m){\n      printf(\"%d: \",i);\n      rep(j,g[i].size())printf(\"%d \",g[i][j]);\n      puts(\"\");\n    }\n      */\n    m += n;\n    printf(\"%d\\n\",bimatch());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_V 1111\n\n//// gcd\nll gcd(ll a,ll b){\n\treturn b?gcd(b,a%b):a;\n}\n\n//// bipartite_match\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid init(int v){\n\tV=v;\n\tfor(int i=0;i<V;i++)G[i].clear();\n}\n\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v){\n\tused[v]=true;\n\tfor(int i=0; i<G[v].size();i++){\n\t\tint u=G[v][i],w=match[u];\n\t\tif(w<0||(!used[w]&&dfs(w))){\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_match(){\n\tint res=0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int v=0; v<V;v++){\n\t\tif(match[v]<0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint n,m;\nint b[555],r[555];\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>m>>n;\n\t\tif(n==0)break;\n\t\trep(i,m)cin>>b[i];\n\t\trep(i,n)cin>>r[i];\n\t\tinit(n+m);\n\t\trep(i,m)rep(j,n){\n\t\t\tif(gcd(b[i],r[j])!=1)add_edge(i,j+m);\n\t\t}\n\t\tcout<<bipartite_match()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntemplate<typename T>\nstruct hungarian{//n<=m\n\tconst T inf=numeric_limits<T>::max();\n\tint n, m, max_match, root;\n\tT max_cost;\n\tvector<vector<T>> cost;\n\tvector<T> lx, ly, slack;\n\tvector<int> xy, yx, prev, slackx;\n\tvector<bool> s, t;\n\tvoid update_labels(){\n\t\tT delta=inf;\n\t\tfor(int y=0; y<m; y++) if(!t[y]) delta=min(delta, slack[y]);\n\t\tfor(int x=0; x<n; x++) if(s[x]) lx[x]-=delta;\n\t\tfor(int y=0; y<m; y++) if(t[y]) ly[y]+=delta;\n\t\tfor(int y=0; y<m; y++) if(!t[y]) slack[y]-=delta;\n\t}\n\tvoid add_to_tree(int x, int prevx){\n\t\ts[x]=true;\n\t\tprev[x]=prevx;\n\t\tfor(int y=0; y<m; y++){\n\t\t\tif(lx[x]+ly[y]-cost[x][y]<slack[y]){\n\t\t\t\tslack[y]=lx[x]+ly[y]-cost[x][y];\n\t\t\t\tslackx[y]=x;\n\t\t\t}\n\t\t}\n\t}\n\tvoid augment(){\n\t\tif(max_match==n) return;\n\t\tfill(s.begin(), s.end(), false);\n\t\tfill(t.begin(), t.end(), false);\n\t\tfill(prev.begin(), prev.end(), -1);\n\t\tqueue<int> que;\n\t\tfor(int x=0; x<n; x++){\n\t\t\tif(xy[x]==-1){\n\t\t\t\troot=x;\n\t\t\t\tque.push(x);\n\t\t\t\tprev[x]=-2;\n\t\t\t\ts[x]=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int y=0; y<m; y++){\n\t\t\tslack[y]=lx[root]+ly[y]-cost[root][y];\n\t\t\tslackx[y]=root;\n\t\t}\n\t\tint x, y;\n\t\twhile(1){\n\t\t\twhile(!que.empty()){\n\t\t\t\tx=que.front(); que.pop();\n\t\t\t\tfor(y=0; y<m; y++){\n\t\t\t\t\tif(cost[x][y]==lx[x]+ly[y] && !t[y]){\n\t\t\t\t\t\tif(yx[y]==-1) break;\n\t\t\t\t\t\tt[y]=true;\n\t\t\t\t\t\tque.push(yx[y]);\n\t\t\t\t\t\tadd_to_tree(yx[y], x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(y<m) break;\n\t\t\t}\n\t\t\tif(y<m) break;\n\t\t\tupdate_labels();\n\t\t\tfor(y=0; y<m; y++){\n\t\t\t\tif(!t[y] && slack[y]==0){\n\t\t\t\t\tif(yx[y]==-1){\n\t\t\t\t\t\tx=slackx[y];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tt[y]=true;\n\t\t\t\t\t\tque.push(yx[y]);\n\t\t\t\t\t\tadd_to_tree(yx[y], slackx[y]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(y<m) break;\n\t\t}\n\t\tif(y<m){\n\t\t\tmax_match++;\n\t\t\tfor(int cx=x, cy=y, ty; cx!=-2; cx=prev[cx], cy=ty){\n\t\t\t\tty=xy[cx];\n\t\t\t\tyx[cy]=cx, xy[cx]=cy;\n\t\t\t}\n\t\t\taugment();\n\t\t}\n\t}\n\thungarian(const vector<vector<T>> &cost):max_match(0), max_cost(0), cost(cost), n(cost.size()), m(cost[0].size()), lx(n, -inf), ly(m), xy(n, -1), yx(m, -1), s(n), t(m), prev(n), slack(m), slackx(m){\n\t\tfor(int x=0; x<n; x++) for(int y=0; y<m; y++) lx[x]=max(lx[x], cost[x][y]);\n\t\taugment();\n\t\tfor(int x=0; x<n; x++) max_cost+=cost[x][xy[x]];\n\t}\n};\nint gcd(int a, int b){\n\tif(b==0) return a;\n\treturn gcd(b, a%b);\n}\nint main()\n{\n\twhile(1){\n\t\tint m, n;\n\t\tcin>>m>>n;\n\t\tif(m==0) return 0;\n\t\tint b[505], r[505];\n\t\tfor(int i=0; i<m; i++) cin>>b[i];\n\t\tfor(int i=0; i<n; i++) cin>>r[i];\n\t\tif(m>n) swap(m, n), swap(b, r);\n\t\tvector<vector<int>> a(m, vector<int>(n));\n\t\tfor(int i=0; i<m; i++) for(int j=0; j<n; j++) if(gcd(b[i], r[j])>1) a[i][j]++;\n\t\thungarian<int> h(a);\n\t\tprintf(\"%d\\n\", h.max_cost);\n\t}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define Rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n\nint gcd(int a, int b){ return b?gcd(b,a%b):a; }\n\nint V;\nvector<int> g[1010];\nint match[1010];\nbool use[1010];\n\nbool dfs(int v){\n  use[v] = true;\n  for(int u : g[v]){\n    int w = match[u];\n    if(w<0 || (!use[w] && dfs(w))){\n      match[u] = v;\n      match[v] = u;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  memset(match,-1,sizeof(match));\n  for(int i=0;i<V;i++){\n    if(match[i]<0){\n      memset(use,0,sizeof(use));\n      if(dfs(i))res++;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int m,n;\n  while(cin >> m >> n){\n    if(m==0 && n==0)break;\n    V = m+n;\n    rep(i,V)g[i].clear();\n\n    vector<int> a(m),b(n);\n    rep(i,m)cin >> a[i];\n    rep(i,n)cin >> b[i];\n\n    rep(i,m)rep(j,n){\n      if(gcd(a[i],b[j])!=1){\n\tg[i].push_back(j+m);\n\tg[j+m].push_back(i);\n      }\n    }\n   \n    cout << bipartite_matching() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint gcd(int a,int b)\n{\n\treturn b?gcd(b,a%b):a;\n}\n\nstruct Edge{\n\tint src,dst;\n\tEdge(){}\n\tEdge(int s,int d):src(s),dst(d){}\n};\ntypedef vector<vector<Edge> > Graph;\n\nbool BFS(const Graph& g,int left,const vi& match,vi& level)\n{\n\tint n=g.size();\n\tlevel.assign(n,n);\n\t\n\tqueue<pii> q;\n\trep(i,left) if(match[i]==-1)\n\t\tq.push(mp(i,0));\n\tbool res=false;\n\twhile(!q.empty()){\n\t\tpii cur=q.front(); q.pop();\n\t\tint u=cur.first,l=cur.second;\n\t\tif(level[u]<=l) continue;\n\t\tlevel[u]=l;\n\t\trep(i,g[u].size()){\n\t\t\tint v=g[u][i].dst;\n\t\t\tif(match[v]==-1)\n\t\t\t\tres=true;\n\t\t\telse\n\t\t\t\tq.push(mp(match[v],l+2));\n\t\t}\n\t}\n\treturn res;\n}\n\nbool DFS(const Graph& g,int left,int u,vi& match,vi& level)\n{\n\trep(i,g[u].size()){\n\t\tint v=g[u][i].dst;\n\t\tif(level[v]==-1) continue;\n\t\tlevel[v]=-1;\n\t\tif(match[v]==-1 || level[v]>level[u] && DFS(g,left,match[v],match,level)){\n\t\t\tmatch[u]=v;\n\t\t\tmatch[v]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint HopcroftKarp(const Graph& g,int left,vi& match)\n{\n\tint n=g.size();\n\tmatch.assign(n,-1);\n\tint res=0;\n\tfor(vi level;BFS(g,left,match,level);)\n\t\trep(i,left)\n\t\t\tres+=DFS(g,left,i,match,level);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int m,n;scanf(\"%d%d\",&m,&n),m|n;){\n\t\tvi bs(m),rs(n);\n\t\trep(i,m) scanf(\"%d\",&bs[i]);\n\t\trep(i,n) scanf(\"%d\",&rs[i]);\n\t\t\n\t\tGraph g(m+n);\n\t\trep(i,m) rep(j,n) if(gcd(bs[i],rs[j])>1){\n\t\t\tg[i].push_back(Edge(i,m+j));\n\t\t\tg[m+j].push_back(Edge(m+j,i));\n\t\t}\n\t\t\n\t\tvi match;\n\t\tprintf(\"%d\\n\",HopcroftKarp(g,m,match));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(x) cout << (x) << '\\n'\n#define Int int64_t\n#define fi first\n#define se second\n#define all(x) (x).begin(), (x).end()\n\nInt INF = 1e18;\nint inf = 1e9;\nInt mod = 1e9+7;\n\nint V;\nvector<int> G[1001];\nint match[1001];\nbool used[1001];\n\nbool dfs(int v) {\n    used[v] = true;\n    for (int i = 0; i < (int)G[v].size(); i++) {\n        int u = G[v][i], w = match[u];\n        if (w < 0 or not used[w] and dfs(w)) {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching() {\n    int ret = 0;\n    memset(match, -1, sizeof(match));\n    for (int i = 0; i < V; i++) {\n        if (match[i] < 0) {\n            for (int j = 0; j < V; j++) {\n                used[j] = false;\n            }\n            if (dfs(i)) {\n                ret++;\n            }\n        }\n    }\n    return ret;\n}\n\nint gcd(int x, int y) {\n    int n = max(x, y);\n    int m = min(x, y);\n    return m == 0 ? n : gcd(m, n % m);\n}\n\nint main() {\n    vector<int> res;\n    while (true) {\n        int m, n;\n        cin >> m >> n;\n        V = m + n;\n        if (m == 0) break;\n        vector<int> b(m), r(n);\n        for (int i = 0; i < m; i++) {\n            cin >> b[i];\n        }\n        for (int i = 0; i < n; i++) {\n            cin >> r[i];\n        }\n        vector<int> new_G[1001];\n        for (int i = 0; i <= 1000; i++) {\n            G[i] = new_G[i];\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (gcd(b[i], r[j]) >= 2) {\n                    G[i].push_back(m + j);\n                    G[m + j].push_back(i);\n                }\n            }\n        }\n        res.push_back(bipartite_matching());\n    }\n    for (int i = 0; i < (int)res.size(); i++) {\n        dump(res[i]);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint n,m,E,last[500],next[250000],to[250000];\nint q[500],head,tail;\n\nvoid add_edge(int u, int v){\n    to[E] = v; next[E] = last[u]; last[u] = E++;\n}\n\nint l[500],r[500],dl[500],dr[500];\nbool visited[500];\n\nbool bfs(){\n    memset(dl,-1,sizeof dl);\n    memset(dr,-1,sizeof dr);\n    head = tail = 0;\n    \n    bool found = false;\n    \n    for(int i = 0;i < n;++i){\n        if(r[i] == -1){\n            q[tail++] = i;\n            dl[i] = 0;\n        }\n    }\n    \n    while(head < tail){\n        int cur = q[head++];\n        \n        for(int e = last[cur];e != -1;e = next[e]){\n            if(to[e] != r[cur] && dr[ to[e] ] == -1){\n                dr[ to[e] ] = dl[cur] + 1;\n                \n                if(l[ to[e] ] == -1) found = true;\n                \n                if(l[ to[e] ] != -1 && dl[ l[ to[e] ] ] == -1){\n                    q[tail++] = l[ to[e] ];\n                    dl[ l[ to[e] ] ] = dl[cur] + 2;\n                }\n            }\n        }\n    }\n    \n    return found;\n}\n\nbool dfs(int pos){\n    if(visited[pos]) return 0;\n    visited[pos] = 1;\n    \n    for(int e = last[pos];e != -1;e = next[e]){\n        if(dr[ to[e] ] == dl[pos] + 1 && (l[ to[e] ] == -1 || dfs(l[ to[e] ]))){\n            r[pos] = to[e];\n            l[ to[e] ] = pos;\n            return 1;\n        }\n    }\n    \n    return 0;\n}\n\nint main(){\n    int a[500],b[500];\n    \n    while(true){\n        scanf(\"%d %d\",&n,&m);\n        \n        if(n == 0) break;\n        \n        for(int i = 0;i < n;++i) scanf(\"%d\",&a[i]);\n        for(int i = 0;i < m;++i) scanf(\"%d\",&b[i]);\n        \n        memset(last,-1,sizeof last);\n        E = 0;\n        \n        for(int i = 0;i < n;++i)\n            for(int j = 0;j < m;++j)\n                if(__gcd(a[i],b[j]) > 1)\n                    add_edge(i,j);\n        \n        memset(l,-1,sizeof l);\n        memset(r,-1,sizeof r);\n        \n        int ans = 0;\n        bool change = true;\n        \n        while(bfs()){\n            memset(visited,0,sizeof visited);\n            \n            for(int i = 0;i < n;++i)\n                if(r[i] == -1)\n                    change |= dfs(i);\n        }\n        \n        for(int i = 0;i < n;++i)\n            if(r[i] != -1) ++ans;\n        \n        printf(\"%d\\n\",ans);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\nint const inf = 1<<29;\n\nstruct MCF {\n    typedef int Weight;\n    typedef int Capacity;\n    struct Edge;\n    int n;\n    vector<vector<Edge> > g;\n    vector<int> level, iter;\n\n    struct Edge {\n        int dst;\n        Capacity cap, cap_orig;\n        int revEdge;\n        bool isRev;\n        Edge(int dst, Capacity cap, int revEdge, bool isRev)\n        :dst(dst), cap(cap), cap_orig(cap), revEdge(revEdge), isRev(isRev) {}\n    };\n\n    MCF(int n_)\n    : n(n_), g(vector<vector<Edge> >(n_)), level(n_), iter(n_) {}\n\n    void add_edge(int src, int dst, Capacity cap) {\n        g[src].push_back(Edge(dst, cap, g[dst].size(), false));\n        g[dst].push_back(Edge(src, 0, g[src].size() - 1, true));\n    }\n\n    void bfs(int s) {\n        fill(all(level), -1);\n        queue<Weight> q;\n        level[s] = 0;\n        q.push(s);\n        while (q.size()) {\n            int v = q.front(); q.pop();\n            for(int i = 0; i < (int)g[v].size(); i++){\n                Edge& e = g[v][i];\n                if (e.cap > 0 && level[e.dst] < 0) {\n                    level[e.dst] = level[v] + 1;\n                    q.push(e.dst);\n                }\n            }\n        }\n    }\n\n    Capacity dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < (int)g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (e.cap > 0 && level[v] < level[e.dst]) {\n                int d = dfs(e.dst, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.dst][e.revEdge].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    // src->dstへの最大フローを流す\n    Capacity max_flow(int src, int dst) {\n        int flow = 0;\n        while(1){\n            bfs(src);\n            if (level[dst] < 0) return flow;\n            fill(all(iter), 0);\n            int f;\n            while ((f = dfs(src, dst, inf)) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n\nint main(){\n    int n,m;\n    while(cin>>n>>m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n)cin>>a[i];\n        rep(i,m)cin>>b[i];\n        MCF mcf(n+m+2);\n        int s=n+m, t=n+m+1;\n        rep(i,m)mcf.add_edge(i+n,t,1);\n        rep(i,n){\n            mcf.add_edge(s,i,1);\n            rep(j,m)if(__gcd(a[i],b[j])!=1)mcf.add_edge(i,n+j,1);\n        }\n        cout << mcf.max_flow(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define Rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\n\nint gcd(int a, int b){ return b?gcd(b,a%b):a; }\n\nint V;\nvector<int> g[1010];\nint match[1010];\nbool use[1010];\n\nbool dfs(int v){\n  use[v] = true;\n  for(int u : g[v]){\n    int w = match[u];\n    if(w<0 || (!use[w] && dfs(w))){\n      match[u] = v;\n      match[v] = u;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  memset(match,-1,sizeof(match));\n  for(int i=0;i<V;i++){\n    if(match[i]<0){\n      memset(use,0,sizeof(use));\n      if(dfs(i))res++;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int m,n;\n  while(cin >> m >> n){\n    if(m==0 && n==0)break;\n    V = m+n;\n    rep(i,V)g[i].clear();\n\n    vector<int> a(m),b(n);\n    rep(i,m)cin >> a[i];\n    rep(i,n)cin >> b[i];\n\n    rep(i,m)rep(j,n){\n      if(gcd(a[i],b[j])!=1){\n\tg[i].push_back(j+m);\n\tg[j+m].push_back(i);\n      }\n    }\n   \n    cout << bipartite_matching() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n//#define int long long\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n\n\nstruct edge {\n    int to, cap, rev;\n    edge (int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\n\nvoid add_edge(int from, int to, int cap, vector<vector<edge>>& G) {\n    G[from].emplace_back(to, cap, G[to].size());\n    G[to].emplace_back(from, 0, G[from].size() - 1);\n}\n\nint dfs(int v, int t, int f, vector<bool>& used, vector<vector<edge>>& G) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap), used, G);\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t, vector<bool>& used, vector<vector<edge>>& G) {\n    int flow = 0;\n    for(;;) {\n        fill(used.begin(), used.end(), false);\n        int f = dfs(s, t, INT_MAX, used, G);\n        if (f == 0) return flow;\n        flow += f;\n    }\n    return flow;\n}\n\nmap<int, int> primefactor(int x) {\n    map<int, int> fac;\n    for (int i = 2; i * i <= x; i++){\n        while (x % i == 0) {\n            fac[i]++;\n            x = x / i;\n        }\n    }\n    if (x != 1) fac[x] += 1;\n    return fac;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0) break;\n        int a[505] = {};\n        int b[505] = {};\n        vector<map<int, int>> mp1;\n        vector<map<int, int>> mp2;\n        rep(i, n) {\n            cin >> a[i];\n            map<int, int> tmp = primefactor(a[i]);\n            mp1.push_back(tmp);\n        }\n        rep(i, m) {\n            cin >> b[i];\n            map<int, int> tmp = primefactor(b[i]);\n            mp2.push_back(tmp);\n        }\n        vector<vector<edge>> G(1005);\n        vector<bool> used(1005);\n        int st = n + m, ed = n + m + 1;\n        rep(i, n) add_edge(st, i, 1, G);\n        rep(j, m) add_edge(n + j, ed, 1, G);\n\n        bool check[505][505] = {};\n        rep(i, n) {\n            for (auto p : mp1[i]) {\n                rep(j, m) {\n                    if (!check[i][j] && mp2[j][p.fi] >= 1) {\n                        check[i][j] = true;\n                        add_edge(i, n + j, 1, G);\n                        continue;\n                    }\n                }\n            }\n        }\n        cout << max_flow(st, ed, used, G) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int MAX_V = 1000;\nconst int INF = 10000000;\n\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap)\n{\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f)\n{\n  if(v == t) return f;\n\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n\n  return 0;\n}\n\nint max_flow(int s, int t)\n{\n  int flow = 0;\n  for(;;){\n    fill(used, used + MAX_V, false);\n    int f = dfs(s, t, INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main()\n{\n  while(1){\n    int m, n;\n    cin >> m >> n;\n    if(m == 0 && n == 0) break;\n    for(int i = 0; i < MAX_V; i++)\n      G[i].clear();\n    int b[m], r[n];\n    for(int i = 0; i < m; i++)\n      cin >> b[i];\n    for(int i = 0; i < n; i++)\n      cin >> r[i];\n    for(int i = 0; i < m; i++){\n      for(int j = 0; j < n; j++){\n        if(__gcd(b[i], r[j]) != 1){\n          add_edge(i+2, j+m+2, 1);\n        }\n      }\n    }\n    for(int i = 2; i < m + 2; i++)\n      add_edge(0, i, 1);\n    for(int i = m+2; i < m+n+2; i++)\n      add_edge(i, 1, 1);\n    cout << max_flow(0, 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nstruct edge {\n\tint to;\n\tll cost;\n\tedge(int to, ll cost = 1) :to(to), cost(cost) {}\n};\nbool bipartite_matching_dfs(int v, vector<vector<edge>> &G, vector<int> &match, vector<bool> &used) {\n\tused[v] = true;\n\tfor (edge e : G[v]) {\n\t\tint w = match[e.to];\n\t\tif (w < 0 || !used[w] && bipartite_matching_dfs(w, G, match, used)) {\n\t\t\tmatch[v] = e.to;\n\t\t\tmatch[e.to] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint bipartite_matching(vector<vector<edge>> &G) {\n\tint N = G.size();\n\tvector<int> match(N, -1);\n\tvector<bool> used(N, false);\n\tint res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (match[i] < 0) {\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tif (bipartite_matching_dfs(i, G, match, used)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nll gcd(ll a, ll b) {\n\treturn b ? gcd(b, a%b) : a;\n}\nint main() {\n\tint m, n;\n\tvector<int> b(500);\n\tvector<int> r(500);\n\tvector<vector<edge>> G(1000, vector<edge>());\n\twhile (cin >> m >> n, m) {\n\t\tfor (int i = 0; i < m; i++) G[i].clear();\n\t\tfor (int i = 0; i < m; i++) cin >> b[i];\n\t\tfor (int i = 0; i < n; i++) cin >> r[i];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (gcd(b[i], r[j]) > 1) {\n\t\t\t\t\tG[i].emplace_back(j + m);\n\t\t\t\t\tG[j + m].emplace_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching(G) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nint match[510];\nbool used[510];\nvector<int> g[510];\n\nint gcd(int x, int y)\n{\n    return y != 0 ? gcd(y, x % y) : x;\n}\n\nbool dfs(int v)\n{\n    for(int i = 0; i < g[v].size(); ++i)\n    {\n        int t = g[v][i];\n        if(used[t]) continue;\n        used[t] = true;\n        if(match[t] == -1 || dfs(match[t])) {\n            match[t] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main()\n{\n    int m, n, blue[510], red;\n    while(cin >> m >> n && m)\n    {\n        rep(i, m)\n            cin >> blue[i], g[i].clear();\n        rep(i, n) {\n            cin >> red;\n            for(int j = 0; j < m; ++j)\n                if(gcd(blue[j], red) > 1)\n                    g[j].push_back(i);\n        }\n    \tint res = 0;\n        fill_n(match, n, -1);\n        rep(i, m) {\n            fill_n(used, n, false);\n            if(dfs(i)) ++res;\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define MP make_pair\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STRING(x) string x;cin>>x;\n# define STR(x) STRING(x);\n# define DOUBLE(x) double x;cin>>x;\n# define DBL(x) DOUBLE(x); \n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl\n# define INIT(a) memset(a,-1,sizeof a)\n# define CLR(a) memset(a,0,sizeof a)\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\n//const int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n//const int M = 1000000007;\ntemplate<class T> void debug(T a) { for ( auto i : a )cout << i << endl; }\n\nstruct edge { int to, cap, rev; edge(int to, int cap, int rev) :to(to), cap(cap), rev(rev) {} };\nvector<edge> G[1200];\nbool used[1200];\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back(edge(to, cap, G[to].size()));\n\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nint dfs(int v, int t, int f)\n{\n\tif ( v == t )return f;\n\tused[v] = true;\n\tFOR(i, G[v].size())\n\t{\n\t\tedge &e = G[v][i];\n\t\tif ( !used[e.to] && e.cap > 0 )\n\t\t{\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif ( d > 0 )\n\t\t\t{\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t)\n{\n\tint flow = 0;\n\twhile ( true )\n\t{\n\t\tCLR(used);\n\t\tint f = dfs(s, t, INF);\n\t\tif ( f == 0 )return flow;\n\t\tflow += f;\n\t}\n}\nint gcd(int a, int b)\n{\n\tif ( a < b )swap(a, b);\n\tif ( b == 0 )return a;\n\treturn gcd(b, a%b);\n}\nint main()\n{\n\twhile ( true )\n\t{\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tif ( !m&&!n )break;\n\t\tint s = m + n, t = s + 1;\n\t\tvi b, r;\n\t\tFOR(i, 1200)G[i].clear();\n\t\tFOR(i, m)\n\t\t{\n\t\t\tINT(x);\n\t\t\tb.push_back(x);\n\t\t\tadd_edge(s, i, 1);\n\t\t}\n\n\t\tFOR(i, n)\n\t\t{\n\t\t\tINT(x);\n\t\t\tr.push_back(x);\n\t\t\tadd_edge(m + i, t, 1);\n\t\t}\n\n\t\tFOR(i, m)\n\t\t{\n\t\t\tFOR(j, n)\n\t\t\t{\n\t\t\t\tif ( gcd(b[i], r[j]) != 1 )\n\t\t\t\t{\n\t\t\t\t\tadd_edge(i, j + m, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << max_flow(s, t) << endl;\n\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_V 1010\n\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v)\n{\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\nbool dfs(int v)\n{\n    used[v] = true;\n    for (int i = 0; i < (int)G[v].size(); i++) {\n\tint u = G[v][i], w = match[u];\n\tif (w < 0 || (!used[w] && dfs(w))) {\n\t    match[v] = u;\n\t    match[u] = v;\n\t    return true;\n\t}\n    }\n    return false;\n}\n\nint bipartite_matching()\n{\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for (int v = 0; v < V; v++) {\n\tif (match[v] < 0) {\n\t    memset(used, false, sizeof(used));\n\t    if (dfs(v)) {\n                res++;\n            }\n\t}\n    }\n    return res;\n}\n\nvoid init()\n{\n    for (int i = 0; i < MAX_V; i++) {\n        G[i].clear();\n    }\n}\n\nint main()\n{\n    int N, M;\n    while (cin >> N >> M, N) {\n        vector<int> b(N), r(M);\n        for (int i = 0; i < N; i++) {\n            cin >> b[i];\n        }\n        for (int i = 0; i < M; i++) {\n            cin >> r[i];\n        }\n        init();\n        V = N + M;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M; j++) {\n                int gcd = __gcd(b[i], r[j]);\n                if (gcd != 1) {\n                    add_edge(i, j + N);\n                }\n            }\n        }\n        cout << bipartite_matching() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <string.h>\nusing namespace std;\n\nvector<int> G[1010];\nbool used[1010];\nint match[1010];\nint N,M;\n\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u = G[v][i],w = match[u];\n\t\tif(w<0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint mat(){\n\tint ans = 0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int v=1;v<=N+M;v++){\n\t\tif(match[v]<0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint gcd(int n,int m){\n    if(n%m==0) return m;\n    else return gcd(m,n%m);\n}\n\nint main(){\n    while(cin >> M >> N && M>0){\n        for(int i=1;i<=N+M;i++){\n            used[i] = 0;\n            match[i] = 0;\n            G[i].clear();\n        }\n        vector<int> R(N+1),B(M+1);\n        for(int i=1;i<=M;i++){\n            cin >> B[i];\n        }\n        for(int i=1;i<=N;i++){\n            cin >> R[i];\n        }\n        for(int i=1;i<=M;i++){\n            for(int j=1;j<=N;j++){\n                if(gcd(B[i],R[j])!=1){\n                    G[i].push_back(j+M);\n                    G[j+M].push_back(i);\n                }\n            }\n        }\n        cout << mat() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_V = 1100;\nconst int INF = 100000000;\n\n// &#65533;&#65533;&#65533;_&#65533;&#65533;\nint V;\n// &#65533;O&#65533;&#65533;&#65533;t&#65533;&#771;&#65533;&#65533;X&#65533;g&#65533;\\&#65533;&#65533;\nvector<int> G[MAX_V];\n// &#65533;}&#65533;b&#65533;`&#65533;&#65533;&#65533;O&#65533;&#771;y&#65533;A\nint match[MAX_V];\n// dfs&#65533;&#322;&#65533;&#65533;&#322;&#594;&#65533;&#65533;&#1474;&#65533;&#65533;&#65533;&#65533;&#450;&#65533;&#65533;&#65533;&#65533;&#771;t&#65533;&#65533;&#65533;O\nstatic bool used[MAX_V];\n\n// u&#65533;&#65533;v&#65533;&#65533;&#1301;&#1218;&#65533;O&#65533;&#65533;&#65533;t&#65533;&#594;&#457;&#65533;\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\n// &#65533;&#65533;&#65533;&#65533;p&#65533;X&#65533;&#65533;dfs&#65533;&#338;T&#65533;&#65533;\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i],w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// &#65533;&#349443;O&#65533;&#65533;&#65533;t&#65533;&#781;&#337;&#65533;}&#65533;b&#65533;`&#65533;&#65533;&#65533;O&#65533;&#65533;&#1986;&#65533;\nint bipartite_matching(){\n\tint res = 0;\n\t//memset(match,-1,sizeof(match));\n\tfor(int i = 0; i < MAX_V; i++)\n\t\tmatch[i]=-1;\n\tfor(int v = 0; v < V; v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int a,int b){\n\tif(b==0)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\n\n\nint main(){\n\n\tint n,m;\n\tvector<int> bs,rs;\n\tint b,r;\n\n\twhile(cin>>m>>n&&!(m==0&&n==0)){\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\tG[i].clear();\n\n\t\tV=n+m;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin>>b;\n\t\t\tbs.push_back(b);\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>r;\n\t\t\trs.push_back(r);\n\t\t}\n\t\tfor(int i = 0; i < rs.size(); i++){\n\t\t\tfor(int j = 0;j < bs.size(); j++){\n\t\t\t\tint res=gcd(rs[i],bs[j]);\n\t\t\t\tif(res>1)\n\t\t\t\t\tadd_edge(i,j+rs.size());\n\t\t\t}\n\t\t}\n\t\tcout<<bipartite_matching()<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 10000\nusing namespace std;\n\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i=0; i<G[v].size(); i++){\n    int u = G[v][i], w = match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint Bipartite_Matching(){\n  int res=0;\n  memset(match, -1, sizeof(match));\n  for(int v=0; v<V; v++){\n    if(match[v] < 0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)) res++;\n    }\n  }\n  return res;\n}\n\n\nint main(){\n  int n,m,b[500],r[500];\n  while(cin>>m>>n,m){\n    for(int i=0;i<V;i++)G[i].clear();\n    memset(match,0,sizeof(match));\n    memset(used,0,sizeof(used));\n    for(int i=0;i<m;i++)cin>>b[i];\n    for(int i=0;i<n;i++)cin>>r[i];\n    for(int i=0;i<m;i++)\n      for(int j=0;j<n;j++)\n\tif(__gcd(b[i],r[i])!=1)add_edge(i,n+j);\n    V=n+m;\n    cout <<Bipartite_Matching()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\n\n#define rep(i,n) for(int i = 0; i < n; ++i)\n#define X first\n#define Y second\n#define MP(x,y) make_pair(x,y)\nusing namespace std;\n\n\nconst int  MAX_V = 2000;\n\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v) {\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v) {\n  // cout << \"dfs\" << endl;\n  used[v] = true;\n  rep(i,G[v].size()){\n    int u = G[v][i], w = match[u];\n    if( w < 0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bi(){\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  rep(v, V){\n    if(match[v] < 0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v)){\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\nint b[1000];\nint r[1000];\n\nbool is_p(int x){\n  if(x <= 1) return false;\n  for(int i = 2; i*i <= x; ++i){\n    if(x % i == 0){\n      return false;\n    }\n  }\n  return true;\n}\n\nvector<int> primes[1280000];\n\nint main(void){\n  int n,m;\n\n  while(cin >> n>> m, n){\n    rep (i, MAX_V) G[i].clear();\n    V = 2000;\n    rep(i,n)cin >> b[i];\n    rep(j,m)cin >> r[j];\n    rep(i,n)rep(j,m){\n      if(__gcd(b[i], r[j]) != 1){\n        // cout << i << \" <-> \" << j  << endl;\n        // cout << i << \" <-> \" << j + 1000 << endl;\n        add_edge(i,j+1000);\n      }\n    }\n    cout << bi() << endl;;\n\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef struct{\n\tint t;\n\tint c;\n\tint r;\n} edge;\n\nvector<edge> g[1002];\n\nvoid add_edge(int from,int to,int cap){\n\tedge e1 = {to,cap,g[to].size()};\n\tg[from].push_back(e1);\n\tedge e2 = {from,0,g[from].size() - 1};\n\tg[to].push_back(e2);\n}\n\n\nint gcd(int x,int y){\n\tif(!y) return x;\n\treturn gcd(y,x % y);\n}\n\nint uv[1002];\n\nint dfs(int v,int t,int f){\n\tint i;\n\tif(v == t) return f;\n\tuv[v] = 0;\n\tfor(i = 0;i < g[v].size();i++){\n\t\tif(uv[g[v][i].t] && g[v][i].c > 0){\n\t\t\tint d = dfs(g[v][i].t,t,min(f,g[v][i].c));\n\t\t\tif(d > 0){\n\t\t\t\tg[v][i].c -= d;\n\t\t\t\tg[g[v][i].t][g[v][i].r].c += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint maxflow(int s,int t){\n\tint f, res = 0;\n\twhile(1){\n\t\tmemset(uv,-1,sizeof(uv));\n\t\tf = 0;\n\t\tf += dfs(s,t,2);\n\t\tif(f == 0) return res;\n\t\tres += f;\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint m, n, b[500], r[500], i, j;\n\twhile(1){\n\t\tscanf(\"%d%d\",&m,&n);\n\t\tif(m + n == 0) break;\n\t\tfor(i = 0;i < m;i++)\n\t\t\tscanf(\"%d\",&b[i]);\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d\",&r[i]);\n\t\tfor(i = 0;i < m;i++)\n\t\t\tadd_edge(0,i + 1,1);\n\t\tfor(i = 0;i < m;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tif(gcd(b[i],r[j]) != 1){\n\t\t\t\t\tadd_edge(i + 1,m + j + 1,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < n;i++)\n\t\t\tadd_edge(m + i + 1,m + n + 1,1);\n\t\tprintf(\"%d\\n\",maxflow(0,m + n + 1));\n\t\tfor(i = 0;i < m + n + 2;i++)\n\t\t\twhile(g[i].size()) g[i].pop_back();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int Int;\n\n// math\nInt gcd(Int a, Int b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\nInt lcm(Int a, Int b) {\n  return a * b / gcd(a, b);\n}\n// a x + b y = gcd(a, b)\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n  Int g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\n// Graph\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\n// bipartite matching\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u], 0) );\n  return match;\n}\n\n\nint main() {\n    int m, n;\n    while ( cin >> m >> n ) {\n        if ( m == 0 && n == 0 ) break;\n        int B[501];\n        int R[501];\n        for ( int i = 0; i < m; i++ ) cin >> B[i];\n        for ( int i = 0; i < n; i++ ) cin >> R[i];\n        \n        Graph g(2*m);\n        for ( int i = 0; i < m; i++ ) {\n            for ( int j = 0; j < n; j++ ) {\n                if ( gcd( B[i], R[j] ) > 1 ) {\n                    g[i].push_back( Edge( i, m+j, 1 ) );\n                }\n            }\n        }\n\n        Edges edges;\n        cout << bipartiteMatching( g, m, edges ) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\ntypedef struct {int to,cap,rev;} edge;\n// edge e, G[e.to][e.rev].to=e\nvector<int> blue,red;\nvector<vector<edge> > G;\nvoid addflow(int from,int to,int cap)\n{\n  int a=G[from].size(),b=G[to].size();\n  G[from].push_back((edge){to,cap,b});\n  G[to].push_back((edge){from,0,a});\n}\nint flow(vector<int> trace)\n{\n  int answer=1048576;\n  REP(i,trace.size()-1) REP(j,G[trace[i]].size())\n    if(G[trace[i]][j].to==trace[i+1]) answer=min(answer,G[trace[i]][j].cap);\n  REP(i,trace.size()-1) REP(j,G[trace[i]].size())\n    if(G[trace[i]][j].to==trace[i+1]) G[trace[i]][j].cap-=answer,G[G[trace[i]][j].to][G[trace[i]][j].rev].cap+=answer;\n  return answer;\n}\nint EK(int so,int si)\n{\n  queue<vector<int> > bfs;\n  vector<int> start;\n  set<int> already;\n  start.push_back(so);\n  bfs.push(start);\n  while(!bfs.empty()){\n    vector<int> trace(bfs.front());\n    bfs.pop();\n    int tmp=trace.back();\n    if(tmp==si) return flow(trace);\n    if(!already.insert(tmp).second) continue;\n    REP(i,G[tmp].size()){\n      if(!G[tmp][i].cap) continue;\n      vector<int> nexttrace(trace);\n      nexttrace.push_back(G[tmp][i].to);\n      bfs.push(nexttrace);\n    }\n  }\n  return 0;\n}\nint maxflow(int so,int si)\n{\n  int answer=0;\n  while(int tmp=EK(so,si)) answer+=tmp;\n  return answer;\n}\nint gcd(int a,int b){ return b?gcd(b,a%b):a; }\nint main(void)\n{\n  for(;;){\n    int m,n;\n    cin >> m >> n;\n    if(!m&&!n) return 0;\n    blue.resize(m);\n    REP(i,m) cin >> blue[i];\n    red.resize(n);\n    REP(i,n) cin >> red[i];\n    G.assign(m+n+2,vector<edge>());\n    REP(i,m) addflow(m+n,i,1);\n    REP(i,m) REP(j,n) if(gcd(blue[i],red[j])!=1) addflow(i,m+j,1);\n    REP(j,n) addflow(m+j,m+n+1,1);\n    cout << maxflow(m+n,m+n+1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <complex>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n#define repLRE(i, l, r) for (ll i = (l); i <= (r); ++i)\n#define rrepLRE(i, l, r) for (ll i = (l); i >= (r); --i)\n#define Sort(v) sort(v.begin(), v.end())\n#define rSort(v) sort(v.rbegin(), v.rend())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define Lower_bound(v, x) \\\n  distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) \\\n  distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\nusing T = tuple<ll, ll, ll>;\nusing vll = vector<ll>;\nusing vP = vector<P>;\nusing vT = vector<T>;\nusing vvll = vector<vector<ll>>;\nusing vvP = vector<vector<P>>;\nusing dqll = deque<ll>;\n\nll dx[9] = {-1, 1, 0, 0, -1, -1, 1, 1, 0};\nll dy[9] = {0, 0, -1, 1, -1, 1, -1, 1, 0};\n\n/* Macros reg. ends here */\n\nconst ll INF = 1LL << 50;\n\nstruct edge {\n  ll to, cap, rev;\n};\n\nvector<vector<edge>> to;\nvector<bool> used;\nvoid addE(ll u, ll v, ll w) {\n  to[u].push_back({v, w, (ll)to[v].size()});\n  to[v].push_back({u, 0, (ll)to[u].size() - 1});\n}\n\nll dfs(ll u, ll t, ll f) {\n  assert(f > 0);\n  if (u == t) return f;\n  used[u] = true;\n  for (edge& e : to[u]) {\n    if (used[e.to] || e.cap <= 0) continue;\n    ll d = dfs(e.to, t, min(f, e.cap));\n    if (d == 0) continue;\n    e.cap -= d;\n    to[e.to][e.rev].cap += d;\n    return d;\n  }\n  return 0;\n}\n\nint main() {\n  // ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cout << fixed << setprecision(15);\n\n  while (true) {\n    ll m, n;\n    cin >> m >> n;\n    if (m == 0 && n == 0) break;\n    vll bs(m), rs(n);\n    rep(i, m) cin >> bs[i];\n    rep(i, n) cin >> rs[i];\n\n    to.assign(m + n + 2, vector<edge>());\n    rep(i, m) rep(j, n) {\n      bool ok = __gcd(bs[i], rs[j]) > 1;\n      if (ok) {\n        addE(i, m + j, 1);\n      }\n    }\n    rep(i, m) addE(m + n, i, 1);\n    rep(j, n) addE(m + j, m + n + 1, 1);\n\n    ll ans = 0;\n    while (true) {\n      used.assign(m + n + 2, false);\n      ll add = dfs(m + n, m + n + 1, INF);\n      if (add == 0) {\n        cout << ans << endl;\n        break;\n      } else\n        ans += add;\n    }\n  } // while true\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ntypedef struct{\n\tint to, cap, rev;\n}edge;\n\nint x[555], y[555];\nint gcd(int a, int b)\n{\n    while( 1 )\n    {\n        a = a % b;\n\t\tif( a == 0 )\n\t\t\treturn b;\n\t\tb = b % a;\n\n        if( b == 0 )\n\t\t\treturn a;\n    }\n}\n\nclass biMatch{//bipartite matching\npublic:\n\tvector<vector<edge> > g;\n\tbiMatch(int k){\n\t\tg = vector<vector<edge> >(k);\n\t}\n\tvoid add_edge(int from, int to, int cap){\n\t\tedge e;\n\t\te.to = to;\n\t\te.cap = cap;\n\t\te.rev = g[to].size();\n\t\tg[from].PB(e);\n\t\te.to = from;\n\t\te.cap = cap;\n\t\te.rev = g[from].size()-1;\n\t\tg[to].PB(e);\n\t}\n\tint DFS(int n, int f, int goal, VI &visited){\n\t\tif(n==goal)return f;\n\t\tvisited[n] = 1;\n\t\tint cnt = f;\n\t\tREP(i, g[n].size()){\n\t\t\tif(g[n][i].cap <= 0)continue;\n\t\t\tif(visited[g[n][i].to])continue;\n\t\t\tint ret = DFS(g[n][i].to, min(f, g[n][i].cap), goal, visited);\n\t\t\tint n2 = g[n][i].to;\n\t\t\tg[n][i].cap -= ret;\n\t\t\tg[n2][g[n][i].rev].cap += ret;\n\t\t\tcnt -= ret;\n\t\t\tif(cnt == 0)break;\n\t\t}\n\t\treturn f-cnt;\n\t}\n};\n\nint main(){\n\twhile(1){\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tif(m==0)return 0;\n\t\tbiMatch b(m+n+2);\n\t\tREP(i,m){\n\t\t\tscanf(\"%d\", &x[i]);\n\t\t\tb.add_edge(0, i+1, 1);\n\t\t}\n\t\tREP(i,n){\n\t\t\tscanf(\"%d\", &y[i]);\n\t\t\tb.add_edge(m+i+1, m+n+1, 1);\n\t\t}\n\t\tREP(i,m){\n\t\t\tREP(j,n){\n\t\t\t\tif(gcd(x[i], y[j]) > 1||x[i]==1||y[j]==1){\n\t\t\t\t\tb.add_edge(i+1, m+j+1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\twhile(1){\n\t\t\tVI visited(m+n+2, 0);\n\t\t\tint tmp = b.DFS(0, 1, m+n+1, visited);\n\t\t\tif(tmp == 0)break;\n\t\t\tret += tmp;\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n// ------ Variable ------ //\n\nint N, M;\n\n\n// ------ Greatest Common Divisor ------ //\n\nint GCD(int a, int b)\n{\n\tif (a % b == 0) { return b; }\n\tif (b % a == 0) { return a; }\n\n\tif (a > b) { return GCD(a % b, b); }\n\tif (b > a) { return GCD(b % a, a); }\n}\n\n\n// ------ Bipartite Matching ------ //\n\nvector<vector<int> > Graph;\n\nvector<int> match;\n\nvector<bool> used;\n\nbool dfs(int v)\n{\n\tused[v] = true;\n\n\tfor (int i = 0; i < Graph[v].size(); i++)\n\t{\n\t\tint u = Graph[v][i], w = match[u];\n\n\t\tif (w < 0 || !used[w] && dfs(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint Bipartite_Matching()\n{\n\tint Ans = 0;\n\n\tmatch = vector<int>(max(N, M), -1);\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (match[i] < 0)\n\t\t{\n\t\t\tused = vector<bool>(max(N, M), 0);\n\n\t\t\tif (dfs(i))\n\t\t\t{\n\t\t\t\tAns++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Ans;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> N >> M;\n\n\t\tif (N == 0 && M == 0) { break; }\n\n\t\tGraph = vector<vector<int> >(N, vector<int>());\n\n\t\tvector<int> A(N);\n\t\tvector<int> B(M);\n\n\t\tfor (int i = 0; i < N; i++) { cin >> A[i]; }\n\t\tfor (int i = 0; i < M; i++) { cin >> B[i]; }\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < M; j++)\n\t\t\t{\n\t\t\t\tif (GCD(A[i], B[j]) != 1)\n\t\t\t\t{\n\t\t\t\t\tGraph[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << Bipartite_Matching() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n#define INF 1<<29\n\ntemplate <typename T>\nstruct BipartiteMatching {\n  struct Edge {\n    int to, rev; T cap;\n    Edge(int to, int rev, T cap) : to(to), rev(rev), cap(cap) { }\n  };\n\n  typedef vector<Edge> Edges;\n  vector<Edges> G;\n  int V, source, sink;\n  vector<int> level, iter;\n  \n  BipartiteMatching(int V1, int V2) {\n    V = V1 + V2 + 2, source = V-2, sink = V-1;\n    G.resize(V);\n    add_sink_source(V1, V2);\n  }\n\n  void add_edge(int from, int to) {\n    G[from].push_back(Edge(to, (int)G[to].size(), 1));\n    G[to].push_back(Edge(from, (int)G[from].size()-1, 0));\n  }\n\n  void add_sink_source(int V1, int V2) {\n    for (int i = 0; i < V1; i++) add_edge(source, i);\n    for (int i = V1; i < V1+V2; i++) add_edge(i, sink);\n  }\n\n  void bfs(int source) {\n    level.assign(V, -1);\n    queue<int> que;\n    que.push(source);\n    level[source] = 0;\n    while (!que.empty()) {\n      int v = que.front(); que.pop();\n      for (int i = 0; i < (int)G[v].size(); i++) {\n\tEdge &e = G[v][i];\n\tif (e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n\n  T dfs(int v, int sink, T flow) {\n    if (v == sink) return flow;\n    for (int &i = iter[v]; i < (int)G[v].size(); i++) {\n      Edge &e = G[v][i];\n      if (e.cap > 0 && level[v] < level[e.to]) {\n\tT d = dfs(e.to, sink, min(e.cap, flow));\n\tif (d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n\n  T dinic() {\n    T flow = 0;\n    while (true) {\n      bfs(source);\n      if (level[sink] < 0) return flow;\n      iter.assign(V, 0);\n      T f;\n      while ((f = dfs(source, sink, INF)) > 0) {\n\tflow += f;\n      }\n    }\n  }\n};\n\n\nint main() {\n  // use scanf in CodeForces!\n\n  while (true) {\n    int M, N;\n    scanf(\"%d %d\", &M, &N);\n    if (M == 0 && N == 0) break;\n    BipartiteMatching<int> bp(M, N);\n    int blue[501], red[501];\n    REP(i, M) scanf(\"%d\", blue+i);\n    REP(i, N) scanf(\"%d\", red+i);\n    REP(i, M) REP(j, N) {\n      if (__gcd(blue[i], red[j]) > 1) {\n\tbp.add_edge(i, M+j);\n      }\n    }\n    printf(\"%d\\n\", bp.dinic());\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool bipartite_matching_dfs(\n\tint v, const vector< vector<int> > &conn,\n\tvector<bool> &used, vector<int> &match)\n{\n\tused[v] = true;\n\tfor(int i = 0; i < conn[v].size(); ++i){\n\t\tint u = conn[v][i], w = match[u];\n\t\tif(w < 0 || !used[w] && bipartite_matching_dfs(w, conn, used, match)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint bipartite_matching(const vector< vector<int> > &conn){\n\tint res = 0;\n\tvector<int> match(conn.size(), -1);\n\tvector<bool> used(conn.size(), false);\n\tfor(int v = 0; v < conn.size(); ++v){\n\t\tif(match[v] < 0){\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tif(bipartite_matching_dfs(v, conn, used, match)){ ++res; }\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int a,int b){\n\treturn b>0?gcd(b,a%b):a;\n}\n\nint main(){\n\tint m, n;\n\twhile(cin >> n >> m, n||m){\n\t\tvector<int> a(n);\n\t\tfor(int i = 0; i < n; ++i){ cin >> a[i]; }\n\t\tvector<int> b(m);\n\t\tfor(int i = 0; i < m; ++i){ cin >> b[i]; }\n\t\tvector< vector<int> > conn(n + m);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tif(gcd(a[i], b[j]) != 1){\n\t\t\t\t\tconn[i].push_back(j + n);\n\t\t\t\t\tconn[j + n].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching(conn) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint m,n,b[500],r[500],p[1000],v[1000];\nvector<vector<int> >e;\nbool match(int s){\n\tif(s<0)return 1;\n\trep(i,e[s].size())if(!v[e[s][i]]){\n\t\tv[e[s][i]]=1;\n\t\tif(match(p[e[s][i]]))return p[s]=e[s][i],p[e[s][i]]=s,1;\n\t}\n\treturn 0;\n}\nint main(){\n\twhile(cin>>m>>n,m){\n\t\trep(i,m)cin>>b[i];rep(i,n)cin>>r[i];\n\t\t\n\t\te.clear();e.resize(m+n);\n\t\trep(i,m)rep(j,n)if(__gcd(b[i],r[j])>1)e[i].push_back(m+j),e[m+j].push_back(i);\n\t\t\n\t\tint ans=0;rep(i,m+n)p[i]=-1;\n\t\trep(i,m){\n\t\t\trep(j,m+n)v[j]=0;\n\t\t\tif(match(i))ans++;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=1005;\nconst ll INF=1LL<<60;\nint V,match[MAX];//V=マッチングの左側\nvector<int> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n}//add_edge(u,100+v)のようにする\n\nbool DFS(int v){\n    used[v]=1;\n    for(int i=0;i<G[v].size();i++){\n        int u=G[v][i],w=match[u];\n        if(w<0||(!used[w]&&DFS(w))){\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(){\n    int res=0;\n    memset(match,-1,sizeof(match));\n    for(int v=0;v<V;v++){\n        if(match[v]<0){\n            memset(used,0,sizeof(used));\n            if(DFS(v)) res++;\n        }\n    }\n    return res;\n}\n\nvoid init(int si){\n    for(int i=0;i<si;i++) G[i].clear();\n    memset(used,0,si);\n}\n\nll gcd(ll a,ll b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N,M;cin>>N>>M;\n        if(N+M==0) break;\n        V=N;\n        init(N+M);\n        \n        vector<int> A(N),B(M);\n        for(int i=0;i<N;i++){\n            cin>>A[i];\n        }\n        for(int i=0;i<M;i++){\n            cin>>B[i];\n        }\n        \n        for(int i=0;i<N;i++){\n            for(int j=0;j<M;j++){\n                if(gcd(A[i],B[j])>1) add_edge(i,N+j);\n            }\n        }\n        \n        cout<<bipartite_matching()<<endl;\n    }\n    \n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX_V = 10000;\nconst int INF = 100000000;\n\n// &#65533;&#65533;&#65533;_&#65533;&#65533;\nint V;\n// &#65533;O&#65533;&#65533;&#65533;t&#65533;&#771;&#65533;&#65533;X&#65533;g&#65533;\\&#65533;&#65533;\nvector<int> G[MAX_V];\n// &#65533;}&#65533;b&#65533;`&#65533;&#65533;&#65533;O&#65533;&#771;y&#65533;A\nint match[MAX_V];\n// dfs&#65533;&#322;&#65533;&#65533;&#322;&#594;&#65533;&#65533;&#1474;&#65533;&#65533;&#65533;&#65533;&#450;&#65533;&#65533;&#65533;&#65533;&#771;t&#65533;&#65533;&#65533;O\nstatic bool used[MAX_V];\n\n// u&#65533;&#65533;v&#65533;&#65533;&#1301;&#1218;&#65533;O&#65533;&#65533;&#65533;t&#65533;&#594;&#457;&#65533;\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\n// &#65533;&#65533;&#65533;&#65533;p&#65533;X&#65533;&#65533;dfs&#65533;&#338;T&#65533;&#65533;\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i],w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// &#65533;&#349443;O&#65533;&#65533;&#65533;t&#65533;&#781;&#337;&#65533;}&#65533;b&#65533;`&#65533;&#65533;&#65533;O&#65533;&#65533;&#1986;&#65533;\nint bipartite_matching(){\n\tint res = 0;\n\t//memset(match,-1,sizeof(match));\n\tfor(int i = 0; i < MAX_V; i++)\n\t\tmatch[i]=-1;\n\tfor(int v = 0; v < V; v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int a,int b){\n\tif(b==0)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\n\n\nint main(){\n\n\tint n,m;\n\tvector<int> bs,rs;\n\tint b,r;\n\n\twhile(cin>>m>>n&&!(m==0&&n==0)){\n\t\tfor(int i = 0; i < MAX_V; i++)\n\t\t\tG[i].clear();\n\n\t\tV=n+m;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin>>b;\n\t\t\tbs.push_back(b);\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>r;\n\t\t\trs.push_back(r);\n\t\t}\n\t\tfor(int i = 0; i < rs.size(); i++){\n\t\t\tfor(int j = 0;j < bs.size(); j++){\n\t\t\t\tint res=gcd(rs[i],bs[j]);\n\t\t\t\tif(res!=1)\n\t\t\t\t\tadd_edge(i,j+rs.size());\n\t\t\t}\n\t\t}\n\t\tcout<<bipartite_matching()<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<cstdio>\n#include<queue>\n#include<cstdlib>\n#define MAX 3000\n#define F first\n#define S second\nusing namespace std;\n\nclass P{\npublic:\n  int to,rev,capacity;\n  P():to(0),rev(0),capacity(0){}\n  P(int to,int capacity,int rev):to(to),capacity(capacity),rev(rev){}\n};\n\ntypedef pair<int,vector<int> > IVI;\n\ntypedef vector<int> VI;\ntypedef vector<vector<P> > VVP;\nmap<int,map<int,bool> > exist;\nVVP G;\nint st,ed;\nbool used[MAX];\n\nvoid add_node(int from,int to)\n{\n  G[from].push_back(P(to,1,G[to].size()));\n  G[to].push_back(P(from,0,G[from].size()-1));\n}\n\nint dfs(int now,int f)\n{\n  if(now == ed)\n    return f;\n  used[now] = true;\n\n  for(int i=0;i < G[now].size();i++)\n    {\n      P& p =  G[now][i];\n      if(used[p.to] || p.capacity <= 0)\n\tcontinue;\n\n      int res = dfs(p.to,min(f,p.capacity));\n      if(res <= 0)\n\tcontinue;\n\n      p.capacity -= res;\n      G[p.to][p.rev].capacity += res;\n      return res;\n    }\n  return 0;\n} \n\nint maximum_flow(int n)\n{\n  int res = 0;\n  for(;;)\n    {\n      for(int i=0;i<n;i++)\n\tused[i] = false;\n      int f = dfs(st,1000000000);\n      if(!f)\n\treturn res;\n      res += f;\n    }\n}\n\n\nmap<int,bool> decomp(int v)\n{\n  if(exist.count(v) > 0)\n    return exist[v];\n\n  int index = v;\n  map<int,bool> vi;\n  for(int i=2;i<=sqrt(v);i++)\n    {\n      if(!(v%i))\n\t{\n\t  vi[i] = true;\n\t  while(!(v%i))\n\t    v /= i;\n\t  if(v == 1)\n\t    break;\n\t}\n    }\n  if(v != 1)\n    vi[v] = true;\n\n  exist[index] = vi;\n  return vi;\n}\n\n\nint main()\n{\n\n\n  int b,r,bn,rn;\n\n  while(true)\n    {\n      // 0 -> start, bn+rn+1\n\n      cin >> bn >> rn;\n      if(bn+rn == 0)\n\tbreak;\n\n      st = 0,ed = bn+rn+1;\n      G.clear();\n      G.resize(2+bn+rn);\n  \n\n      vector<map<int,bool> > bs;\n      bs.resize(bn+1);\n    \n      for(int i=0;i<bn;i++)\n\t{\n\t  cin >> b;\n\t  add_node(0,i+1);\n\t  bs[i] = decomp(b);\n\t}\n\n      for(int i=0;i<rn;i++)\n\t{\n\t  cin >> r;\n\t  add_node(bn+i+1,ed);\n\t  map<int,bool> vi = decomp(r);\n\t  for(int k=0;k<bn;k++)\n\t    {\n\t      for(map<int,bool>::iterator it = bs[k].begin();it != bs[k].end();it++)\n\t\t{\n\t\t \n\t\t  if(vi[(*it).F])\n\t\t    {\n\t\t    \n\t\t      add_node(k+1,bn+i+1);\n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n      /*\n      for(int i=0;i<=ed;i++)\n\t{\n\t  cout << \"i = \" << i << endl;\n\t  for(int j=0;j<G[i].size();j++)\n\t    {\n\t      cout << G[i][j].to << \" \";\n\t    }\n\t  cout << endl;\n\t}\n      */\n      cout << maximum_flow(bn+rn+2) << endl;\n\n\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 1010\n#define MAX_N 1001\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});  \n}\n\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nint N,K;\nbool can[MAX_N][MAX_N]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(){\n  //0??????N-1: ???????????\\???????????????????????????\n  //N??????N+K-1: ???????????????????????????\n  int s = N+K, t = s+1;\n  \n  //s??¨???????????\\??????????????¶\n  for(int i=0; i<N; i++) add_edge(s,i,1);\n  \n  //????????¨t?????????\n  for(int i=0; i<K; i++) add_edge(N+i,t,1);\n  \n  //???????????\\????????¨??????????????¶\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)\n      if(can[i][j]) add_edge(i, N+j , 1);\n\n  return max_flow(s,t);\n}\n\nint main(){\n  while(1){\n  int b,r,B[501],R[501];\n  cin>>b>>r;\n  if(!b&&!r)break;\n  for(int i=0;i<b;i++) cin>>B[i];\n  for(int i=0;i<r;i++) cin>>R[i];\n\n  memset(can,0,sizeof(can));\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n  N=b,K=r;\n  for(int i=0;i<b;i++)\n    for(int j=0;j<r;j++)\n      if(__gcd(B[i],R[j])>1) can[i][j]=1;\n\n  cout<<Biparite_Matching()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\nnamespace boost {template <class T>struct integer_iterator {T a;bool operator != (integer_iterator const & it) const { return a != it.a; }T operator * () const { return a; }integer_iterator & operator ++ () { ++ a; return *this; }integer_iterator operator ++ (int) { return { a ++ }; }};template <class T>struct integer_range {T l, r;typedef integer_iterator<T> iterator;iterator begin() const { return { l }; }iterator end  () const { return { r }; }};template <class T>integer_range<T> irange(T l, T r) { return { l, r }; }template <class T>struct integer_iterator_with_step {T a, d, i;bool operator != (integer_iterator_with_step const & it) const { return a != it.a or d != it.d or i != it.i; }T operator * () const { return a+d*i; }integer_iterator_with_step & operator ++ () { ++ i; return *this; }integer_iterator_with_step operator ++ (int) { return { a, d, i ++ }; }};template <class T>struct strided_integer_range {T l, r, s;typedef integer_iterator_with_step<T> iterator;iterator begin() const { return { l, s, 0 }; }iterator end  () const { return { l, s, (r - l) / s + 1 }; }};template <class T>strided_integer_range<T> irange(T l, T r, T s) { return { l, r, s }; }}\ntemplate <typename T>class ford_fulkerson {public:struct edge_t { int to; T cap; int rev; };static T infinity;ford_fulkerson(int n) : graph(n) {}std::vector<std::vector<edge_t> > graph; // adjacency list\nvoid add_edge(int from, int to, T cap) {graph[from].push_back((edge_t){   to, cap, (int)graph[  to].size() });graph[  to].push_back((edge_t){ from,   0, (int)graph[from].size() - 1 });}std::vector<bool> used;T run_destructive(int s, int t) {T flow = 0;used.resize(graph.size());while (true) {std::fill(used.begin(), used.end(), false);T f = dfs(s, t, infinity);if (f == 0) return flow;flow += f;}}// search for augmenting pathes from `v' to `t', returns the volume of water `f'\nT dfs(int v, int t, T f) {if (v == t) return f; // base case\nused[v] = true;for (int i : boost::irange<int>(0,graph[v].size())) { // for each adjacent nodes which are not used and able to flow\nedge_t & e = graph[v][i];const int w = e.to;if (not used[w] and 0 < e.cap) {T d = dfs(w, t, std::min(f, e.cap)); // v -> w ->> t\nif (0 < d) { // let flow and make reverse capacity\ne.cap -= d;graph[w][e.rev].cap += d;return d;}}}return 0; // path not found\n}};template<> int ford_fulkerson<int>::infinity = 1<<28;template<> long long ford_fulkerson<long long>::infinity = 1ll<<58;template<> double ford_fulkerson<double>::infinity = 1/(double)0;\nnamespace boost {namespace math {template <typename T>T gcd(T a, T b) {if (b <= a) std::swap(a,b);while (a) {T a0 = a;a = b % a0;b = a0;}return b;}template <typename T>T lcm(T a, T b) {return (a * b) / gcd(a,b);}}}\n#define repeat(i,n) for (int i = 0; (i) < (int)(n); ++(i))\n#define repeat_from(i,m,n) for (int i = (m); (i) < (int)(n); ++(i))\nusing namespace std;\nint main() {\n    while (true) {\n        int m, n; cin >> m >> n;\n        if (m == 0 and n == 0) break;\n        vector<int> b(m), r(n);\n        repeat (i,m) cin >> b[i];\n        repeat (i,n) cin >> r[i];\n        ford_fulkerson<int> g(m+n+2);\n        repeat (i,m) g.add_edge(m+n,i,1);\n        repeat (i,n) g.add_edge(m+i,m+n+1,1);\n        repeat (i,m) repeat (j,n) {\n            if (boost::math::gcd(b[i], r[j]) != 1) {\n                g.add_edge(i,m+j,1);\n            }\n        }\n        cout << g.run_destructive(m+n,m+n+1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n\tif(b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nconst int MAX_V = 1000;\n\nint V;\nbool G[MAX_V][MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nbool dfs(int v) {\n\tused[v] = true;\n\tfor(int i = 0; i < V; i++) {\n\t\tif(!G[v][i]) continue;\n\t\tint u = i, w = match[u];\n\t\tif(w < 0 || (!used[w] && dfs(w))) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching() {\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor(int v = 0; v < V; v++) {\n\t\tif(match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif(dfs(v)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint b[500];\nint r[500];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint m, n;\n\twhile(cin >> m >> n, m + n) {\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tcin >> b[i];\n\t\t}\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> r[i];\n\t\t}\n\t\tV = m + n;\n\t\tmemset(G, 0, sizeof G);\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\tif(gcd(b[i], r[j]) > 1) {\n\t\t\t\t\tG[i][j + m] = G[j + m][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << bipartite_matching() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\nusing namespace std;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Capacity> Array;\ntypedef vector<Array> Matrix;\n\nconst int inf = 1e8;\n\nstruct FordFulkerson {\n    typedef vector<vector<Capacity>> Matrix;\n    int n, t;\n    vector<bool> vis;\n    Matrix cap, flow;\n    vector<vector<int>> g;\n    FordFulkerson(int n){ *this = FordFulkerson(Graph(n)); }\n    FordFulkerson(const Graph &graph)\n        : n(graph.size()), cap(n, Array(n)),\n          flow(n, Array(n)), g(n, vector<int>()){\n        rep(i,n)\n            for(const Edge &e : graph[i])\n                add_edge(e.src, e.dst, e.cap);\n    }\n    void add_edge(int u, int v, Capacity c){\n        cap[u][v] += c;\n        cap[v][u] += c;\n        flow[v][u] += c;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    Capacity solve(int s, int t){\n        this->t = t;\n        Capacity res = 0, f = -1;\n        while(f){\n            vis.assign(n,false);\n            res += (f = augment(s,inf));\n        }\n        return res;\n    }\n    Capacity augment(int v, Capacity lim){\n        vis[v] = true;\n        if(v == t) return lim;\n        for(const int &i : g[v]){\n            if(vis[i] || flow[v][i] == cap[v][i]) continue;\n            Capacity f = augment(i, min(lim, cap[v][i] - flow[v][i]));\n            flow[v][i] += f;\n            flow[i][v] -= f;\n            if(f) return f;\n        }\n        return 0;\n    }\n};\n\nint gcd(int a, int b){\n    return b == 0 ? a : gcd(b,a%b);\n}\n\nint main(){\n    int n,m;\n    while(cin >> n >> m && n){\n        Graph g(1002);\n        int s = 1000, t = 1001;\n        int a[555], b[555];\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        rep(i,n)rep(j,m){\n            if(gcd(a[i],b[j]) != 1){\n                g[i].emplace_back(i,j+500,1);\n            }\n        }\n        rep(i,n) g[s].emplace_back(s,i,1);\n        rep(i,m) g[i+500].emplace_back(i+500,t,1);\n        cout << FordFulkerson(g).solve(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_V = 1000;\n\nint match[MAX_V];\nbool used[MAX_V];\nvector<int> G[MAX_V];\n\nvoid add_edge(int u, int v)\n{\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v)\n{\n  used[v] = true;\n  for (int i = 0; i < G[v].size(); ++i) {\n    int u = G[v][i], w = match[u];\n    if (w < 0 || !used[w] && dfs(w)) {\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(int V)\n{\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  for (int v = 0; v < V; ++v) {\n    if (match[v] < 0) {\n      memset(used, 0, sizeof(used));\n      if (dfs(v))\n\t++res;\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  int m, n;\n  while (~scanf(\"%d %d\", &m, &n)) {\n    if ((m|n) == 0)\n      break;\n\n    for (int i = 0; i < MAX_V; ++i)\n      G[i].clear();\n\n    vector<int> b(m), r(n);\n    for (int i = 0; i < m; ++i)\n      scanf(\"%d\", &b[i]);\n    for (int i = 0; i < n; ++i)\n      scanf(\"%d\", &r[i]);\n\n    for (int i = 0; i < m; ++i) {\n      for (int j = 0; j < n; ++j) {\n\tif (__gcd(b[i], r[j]) != 1)\n\t  add_edge(i, m+j);\n      }\n    }\n\n    printf(\"%d\\n\", bipartite_matching(n+m));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\ntypedef int Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight == rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nWeight augment(Graph &g, Matrix &capacity, const vector<int> &level, vector<bool> &finished, int from, int t, Weight cur) {\n  if (from == t || cur == 0) { return cur; }\n  if (finished[from]) { return 0; }\n  for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n    int to = it->dest;\n    if (level[to] <= level[from]) { continue; }\n    Weight f = augment(g, capacity, level, finished, to, t, min(cur, capacity[from][to]));\n    if (f > 0) {\n      capacity[from][to] -= f;\n      capacity[to][from] += f;\n      return f;\n    }\n  }\n  finished[from] = true;\n  return 0;\n}\n\nWeight MaxFlow(Graph &g, int s, int t) {\n  int n = g.size();\n  Matrix capacity(n, Array(n));\n  for (int from = 0; from < n; from++) {\n    for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n      int to = it->dest;\n      capacity[from][to] += it->weight;\n    }\n  }\n  int ans = 0;\n  while (true) {\n    vector<int> level(n, -1);\n    level[s] = 0;\n    queue<int> que;\n    que.push(s);\n    for (int d = n; !que.empty() && level[que.front()] < d; ) {\n      int from = que.front();\n      que.pop();\n      if (from == t) { d = level[from]; }\n      for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n        int to = it->dest;\n        if (capacity[from][to] > 0 && level[to] == -1) {\n          que.push(to);\n          level[to] = level[from] + 1;\n        }\n      }\n    }\n    vector<bool> finished(n);\n    bool end = true;\n    while (true) {\n      Weight f = augment(g, capacity, level, finished, s, t, 1000000000);\n      if (f == 0) { break; }\n      ans += f;\n      end = false;\n    }\n    if (end) { break; }\n  }\n  return ans;\n}\n\nint maxFlow(const Graph &g, int s, int t) {\n  const int n = g.size();\n  Matrix capacity(n, Array(n, 0));\n  for (int i = 0; i < n; i++) {\n    for (Edges::const_iterator it = g[i].begin(); it != g[i].end(); it++) {\n      capacity[it->src][it->dest] = it->weight;\n    }\n  }\n  int ret = 0;\n  vector<int> parent(n);\n  while (true) {\n    fill(parent.begin(), parent.end(), -1);\n    priority_queue<Edge> que;\n    que.push(Edge(s, s, 0));\n    while (!que.empty()) {\n      Edge node = que.top();\n      que.pop();\n      if (parent[node.dest]) { continue; }\n      parent[node.dest] = node.src;\n      if (node.dest == t) { break; }\n      int from = node.dest;\n      for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n        int to = it->dest;\n        if (capacity[from][to] == 0 || parent[to] != -1) { continue; }\n        que.push(Edge(from, to, 0));\n      }\n    }\n    if (parent[t] == -1) { break; }\n    Weight flow = 2000000000;\n    int from = parent[t];\n    int to = t;\n    while (from != to) {\n      flow = min(flow, capacity[from][to]);\n      from = parent[from];\n      to = parent[to];\n    }\n    from = parent[t];\n    to = t;\n    while (from != to) {\n      capacity[from][to] -= flow;\n      capacity[to][from] += flow;\n      from = parent[from];\n      to = parent[to];\n    }\n    ret += flow;\n  }\n  return ret;\n}\n\n\n\nint gcd(int a, int b) {\n  if (b == 0) { return a; }\n  return gcd(b, a % b);\n}\n\nint m, n;\nint blue[501];\nint red[501];\n\nint BLUE(int x) { return x; }\nint RED(int x) { return m + x; }\nint SOURCE() { return m + n; }\nint DEST() { return m + n + 1; }\nint SIZE() { return m + n + 2; }\n\nint main() {\n  while (scanf(\"%d %d\", &m, &n), m|n) {\n    Graph g(SIZE());\n    REP(b, m) {\n      scanf(\"%d\", &blue[b]);\n      g[SOURCE()].push_back(Edge(SOURCE(), BLUE(b), 1));\n      g[BLUE(b)].push_back(Edge(BLUE(b), SOURCE(), 0));\n    }\n    REP(r, n) {\n      scanf(\"%d\", &red[r]);\n      g[RED(r)].push_back(Edge(RED(r), DEST(), 1));\n      g[DEST()].push_back(Edge(DEST(), RED(r), 0));\n    }\n    REP(b, m) {\n      REP(r, n) {\n        if (gcd(blue[b], red[r]) != 1) {\n          g[BLUE(b)].push_back(Edge(BLUE(b), RED(r), 1));\n          g[RED(r)].push_back(Edge(RED(r), BLUE(b), 0));\n        }\n      }\n    }\n    int ans = maxFlow(g, SOURCE(), DEST());\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 5000000000000000000\n#define ll long long\n#define pll pair<ll, ll>\nusing namespace std;\n\n//=============ford_fulkerson============================\nll MAX_V = 2510;\nstruct edge {ll to, cap, rev;};\nvector<vector<edge>> G(MAX_V);\nvector<bool> used(MAX_V, false);\n\nvoid reset() {\n  G = vector<vector<edge>>(MAX_V);\n  used = vector<bool>(MAX_V, false);\n}\n\nvoid add_edge(ll from, ll to, ll cap) {\n  G.at(from).push_back((edge){to, cap, (ll)G.at(to).size()});\n  G.at(to).push_back((edge){from, 0ll, (ll)G.at(from).size() - 1});\n}\n\nll dfs(ll v, ll t, ll f) {\n  if (v == t) {\n    return f;\n  }\n  used.at(v) = true;\n  for (ll i = 0; i < G.at(v).size(); ++i) {\n    edge &e = G.at(v).at(i);\n    if (!used.at(e.to) && e.cap > 0) {\n      ll d = dfs(e.to, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        G.at(e.to).at(e.rev).cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nll max_flow(ll s, ll t) {\n  ll flow = 0;\n  while (true) {\n    used = vector<bool>(MAX_V, false);\n    ll f = dfs(s, t, INF);\n    if (f == 0) {\n      return flow;\n    }\n    flow += f;\n  }\n}\n//=================================================\n\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  while (true) {\n    ll m, n;\n    cin >> m >> n;\n    if (m == 0 && n == 0) {\n      break;\n    }\n    reset();\n    vector<ll> b(m), r(n);\n    for (ll i = 0; i < m; ++i) {\n      cin >> b.at(i);\n      add_edge(0, i + 2, 1);\n    }\n    for (ll i = 0; i < n; ++i) {\n      cin >> r.at(i);\n      add_edge(i + m + 2, 1, 1);\n    }\n    for (ll i = 0; i < m; ++i) {\n      for (ll j = 0; j < n; ++j) {\n        if (__gcd(b.at(i), r.at(j)) != 1) {\n          add_edge(i + 2, j + m + 2, 1);\n        }\n      }\n    }\n    cout << max_flow(0, 1) << \"\\n\";\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)n; ++i)\nusing namespace std;\n\nint m, n;\nint b[500], r[500];\nint INF = (1<<30);\n\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[1100];\nint level[1100];\nint iter[1100];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nvoid bfs(int s){\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()){\n        int v = que.front(); que.pop();\n        for(int i=0; i<(int)G[v].size(); i++){\n            edge &e = G[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v, int t, int f){\n    if(v==t) return f;\n    for(int &i = iter[v]; i<(int)G[v].size(); i++){\n        edge &e = G[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            int d=dfs(e.to, t, min(f, e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        bfs(s);\n        if(level[t]<0) return flow;\n        memset(iter, 0, sizeof(iter));\n        int f;\n        while((f=dfs(s, t, INF)) > 0){\n            flow += f;\n        }\n    }\n}\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b, a%b);\n}\n\nint main(){\n    while(true){\n        cin>>m>>n;\n        if(m==0) break;\n\n        int s1=m+n, s2=s1+1, t=s2+1;\n        memset(G, 0, sizeof(G));\n        memset(level, 0, sizeof(level));\n        memset(iter, 0, sizeof(iter));\n\n        REP(i,m) cin>>b[i];\n        REP(j,n) cin>>r[j];\n\n        add_edge(s1, s2, m);\n        REP(i,m) add_edge(s2, i, 1);\n        REP(j,n) add_edge(m+j, t, 1);\n\n        REP(i,m)REP(j,n){\n            if(gcd(b[i], r[j])>1){\n                add_edge(i, m+j, 1);\n            }\n        }\n\n        int ans = max_flow(s1, t);\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1000\n\nint V,num_BLUE,num_RED;\nvector<int> G[NUM];\nint match[NUM],red[NUM],blue[NUM];\nbool used[NUM];\n\n\nint calc(int x,int y){\n\tif(y == 0){\n\t\treturn x;\n\t}else{\n\t\treturn calc(y,x%y);\n\t}\n}\nvoid add_edge(int from,int to){\n\tG[from].push_back(to);\n\tG[to].push_back(from);\n}\n\nint dfs(int node_id){\n\tused[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tint adj_node_id = G[node_id][i],pair_id = match[adj_node_id];\n\t\tif((pair_id < 0)||(used[pair_id] == false && dfs(pair_id) == true)){\n\t\t\tmatch[node_id] = adj_node_id;\n\t\t\tmatch[adj_node_id] = node_id;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint bipartie_matching(){\n\tint ret = 0;\n\tfor(int i = 0; i < V; i++)match[i] = -1;\n\tfor(int node_id = 0; node_id < V; node_id++){\n\t\tif(match[node_id] < 0){\n\t\t\tfor(int i = 0; i < V; i++)used[i] = false;\n\t\t\tif(dfs(node_id)){\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid func(){\n\n\tV = num_BLUE+num_RED;\n\tfor(int i = 0; i < V; i++)G[i].clear();\n\n\tfor(int i = 0; i < num_BLUE; i++)scanf(\"%d\",&blue[i]);\n\tfor(int i = 0; i < num_RED; i++)scanf(\"%d\",&red[i]);\n\n\tint common;\n\n\tfor(int i = 0; i < num_BLUE; i++){\n\t\tfor(int k = 0; k < num_RED; k++){\n\t\t\tif(blue[i] >= red[k]){\n\t\t\t\tcommon = calc(blue[i],red[k]);\n\t\t\t}else{\n\t\t\t\tcommon = calc(red[k],blue[i]);\n\t\t\t}\n\t\t\tif(common > 1){\n\t\t\t\tadd_edge(i,num_BLUE+k);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",bipartie_matching());\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&num_BLUE,&num_RED);\n\t\tif(num_BLUE == 0 && num_RED == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\n#define MAX_V 2000\n\nstruct edge{\n\tlong long int to, cap, rev; // 行き先、容量、逆辺\n};\n\nvector<edge> G[MAX_V] = {};\nbool used[MAX_V];\n\n// from から to へ向かう容量 cap の辺を張る\nvoid add_edge(long long int from, long long int to, long long int cap){\n\tG[from].push_back((edge){to, cap, G[to].size()});\n\tG[to].push_back((edge){from, 0, G[from].size() - 1}); // 有向辺\n\t// G[to].push_back((edge){from, cap, G[from].size() - 1}); // 無向辺\n}\n\n// 増加パスを dfs で探す\nlong long int dfs(int v, int t, long long int f){\n\tif(v == t){\n\t\treturn f;\n\t}\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tlong long int d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n// s から t への最大流を求める\nlong long int max_flow(int s, int t){\n\tlong long int flow = 0;\n\twhile(true){\n\t\tfill(used, used + MAX_V, 0);\n\t\tlong long int f = dfs(s, t, INF);\n\t\tif(f == 0){\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nlong long int GCD(long long int a, long long int b){\n\tlong long int dummy1, dummy2, dummy;\n\tdummy1 = max(a, b);\n\tdummy2 = min(a, b);\n\twhile(true){\n\t\tdummy = dummy1 % dummy2;\n\t\tdummy1 = dummy2;\n\t\tdummy2 = dummy;\n\t\tif(dummy == 0){\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dummy1;\n}\n\nint main(){\n\t\n\twhile(true){\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\t\n\t\tif(m + n == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < MAX_V; i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\t\n\t\tlong long int b[1000], r[1000];\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tadd_edge(0, i + 1, 1);\n\t\t\tcin >> b[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tadd_edge(m + i + 1, m + n + 1, 1);\n\t\t\tcin >> r[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(GCD(b[i], r[j]) != 1){\n\t\t\t\t\tadd_edge(i + 1, m + j + 1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << max_flow(0, n + m + 1) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<29\n\nusing namespace std;\n\nconst int MAX_V = 1005;\n// 辺を表す構造体（行き先、容量、逆辺）\nstruct edge{ int to, cap, rev; };\n\nvector<edge> G[MAX_V];\t// グラフの隣接リスト表現\nbool used[MAX_V];\t\t\t// DFS ですでに調べたかのフラグ\n\n// from から to へ向かう容量 cap の辺をグラフに追加する\nvoid add_edge (int from, int to, int cap ){\n\tG[from].push_back ((edge){to, cap, G[to].size() } );\n\tG[to].push_back ((edge){from, 0, G[from].size()-1 } );\n}\n\n// 増加バスを DFS で探す\nint dfs (int v, int t, int f ){\n\tif (v == t ) return f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++ ){\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0 ){\n\t\t\tint d = dfs (e.to, t, min (f, e.cap ) );\n\t\t\tif (d > 0 ){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t} // end if\n\t\t} // end if\n\t} // end for\n\n\treturn 0;\n}\n\n// s から t への最大流を求める\nint max_flow (int s, int t ){\n\tint flow = 0;\n\tfor (;; ){\n\t\tmemset (used, false, sizeof (used ) );\n\t\tint f = dfs (s, t, INF );\n\t\tif (f == 0 ) return flow;\n\t\tflow += f;\n\t} // end for\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.1163\", \"r\", stdin );\n\tint n, m;\n\twhile (scanf (\"%d %d\", &n, &m ), n, m ){\n\t\trep (i, MAX_V ) G[i].clear();\n\t\t// 0 〜 n-1: bule card n〜n+m-1: red card\n\t\t// n+m : source n+m+1: sink\n\t\tvector<int> cards (n+m, 0 );\n\t\trep (i, n ){\n\t\t\tscanf (\"%d\", &cards[i] );\n\t\t\tadd_edge(n+m, i, 1 );\n\t\t} // end rep\n\t\trep (j, m ){\n\t\t\tscanf (\"%d\", &cards[n+j] );\n\t\t\tadd_edge(n+j, n+m+1, 1 );\n\t\t} // end rep\n\n\t\trep (i, n ){\n\t\t\trep (j, m ){\n\t\t\t\tif (__gcd (cards[i], cards[n+j] ) != 1 ){\n\t\t\t\t\tadd_edge (i, n+j, 1 );\n\t\t\t\t} // end if\n\t\t\t} // end rep\n\t\t} // end rep\n\t\tint res = max_flow (n+m, n+m+1 );\n\t\tprintf (\"%d\\n\", res );\n\t} // end while\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    EACH(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n    REP(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n    REP(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nstruct Edge {\n    ll to, cap, rev;\n};\n\nvector< vector<Edge> > G;\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].pb({to, cap, (ll)G[to].size()});\n    G[to].pb({from, 0, (ll)G[from].size()-1});\n}\n\nll dfs(ll v, ll t, ll f, vector<bool>& used) {\n    if (v == t) return f;\n    if (used[v]) return 0;\n    used[v] = true;\n    EACH(e, G[v]) {\n        if (e.cap > 0) {\n            ll d = dfs(e.to, t, min(f, e.cap), used);\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t) {\n    ll res = 0;\n    while (1) {\n        vector<bool> used(G.size(), false);\n        ll f = dfs(s, t, inf, used);\n        if (f == 0) break;\n        res += f;\n    }\n    return res;\n}\n\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a%b);\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    int m, n;\n    while (cin >> m >> n, m || n) {\n        vector<int> b(m), r(n); cin >> b >> r;\n        vector<int> bid(m), rid(n);\n        REP(i, m) bid[i] = i;\n        REP(i, n) rid[i] = m+i;\n        int s = m+n, t = s+1;\n        G.clear();\n        G.resize(t+1);\n        REP(i, m) REP(j, n) {\n            if ( gcd(b[i], r[j]) > 1 ) {\n                add_edge(bid[i], rid[j], 1);\n            }\n        }\n        REP(i, m) add_edge(s, bid[i], 1);\n        REP(i, n) add_edge(rid[i], t, 1);\n        cout << max_flow(s, t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max() / 2;\nconst int NEG_INF = numeric_limits<int>::min() / 2;\n\nconst int MAX_V = 10e4;\n\nstruct edge{int to,cap,rev;};\n\nstd::vector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  used[v]= true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow =0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f=dfs(s,t,INF);\n    if(f==0) return flow;\n    flow += f;\n  }\n}\n\nint gcd(int a,int b){\n  if(b==0) return a;\n  return gcd(b,a%b);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true){\n  for(int i=0;i<MAX_V;i++) {\n    G[i].erase(G[i].begin(), G[i].end());\n    used[i]=false;\n  }\n  int m,n;\n  cin >> m >> n;\n  if(m==0 && n==0) break;\n  bool can[1000][1000];//can[i][j]:b[i]???r[j]?????????????????????\n  int b[1000],r[1000];\n  for(int i=1;i<=m;i++) cin >> b[i];\n  for(int i=1;i<=n;i++) cin >> r[i];\n  for(int i=1;i<=m;i++){\n    for(int j=1;j<=n;j++){\n      can[i][j] = (gcd(b[i],r[j])>1);\n    }\n  }\n  int s=m+n+1,t=s+1;\n\n  for(int i=1;i<=m;i++){\n    add_edge(s,i,1);\n  }\n\n  for(int i=1;i<=n;i++){\n    add_edge(m+i,t,1);\n  }\n\n  for(int i=1;i<=m;i++){\n    for(int j=1;j<=n;j++){\n      if(can[i][j]){\n        add_edge(i,m+j,1);\n      }\n    }\n  }\n  cout << max_flow(s,t) << endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 4444\nvector<int> v[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int a,int b){\n\tv[a].PB(b);\n\tv[b].PB(a);\n}\n\nbool matchdfs(int a){\n\tused[a] = true;\n\tfor(int i = 0;i < v[a].size();i++)\t{\n\t\tint u = v[a][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w)){\n\t\t\tmatch[u] = a;\n\t\t\tmatch[a] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//二部マッチング\nint two_matching_max(int l){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<int> prime;\n#define HOGE 11111111\nbool isp[HOGE];\nvoid f(){\n\tREP(i,HOGE)isp[i] = true;\n\tisp[0] = isp[1] = false;\n\tfor(int i = 2;i < HOGE;i++){\n\t\tif(isp[i]){\n\t\t\tprime.PB(i);\n\t\t\tfor(int j = i;j < HOGE;j+=i)isp[j] = false;\n\t\t}\n\t}\n}\n\t\n#define HALF 1000\nint main(){\n\tf();\n\tint n,m;\n\twhile(cin >> m >> n,n|m){\n\t\tREP(i,MAX_V)v[i].clear();\n\t\tvector<ll> a(m);REP(i,m)cin >> a[i];\n\t\tvector<ll> b(n);REP(i,n)cin >> b[i];\n\t\tREP(i,m){\n\t\t\tvector<ll> tmp;\n\t\t\tREP(j,prime.size()){\n\t\t\t\tif(a[i] % prime[j] == 0)tmp.PB(prime[j]);\n\t\t\t}\n\t\t\tREP(j,n){\n\t\t\t\tREP(k,tmp.size()){\n\t\t\t\t\tif(b[j] % tmp[k] == 0){\n\t\t\t\t\t\tadd_edge(i,j + 1000);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << two_matching_max(MAX_V) << endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 2013/07/05 Tazoe\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint euclid(int a, int b)\n{\n\tif(a%b==0)\n\t\treturn b;\n\n\treturn euclid(b, a%b);\n}\t\n\nbool dfs(int v, vector<int> G[], int match[], bool used[])\n{\n\tused[v] = true;\n\n\tfor(int i=0; i<G[v].size(); i++){\n\t\tint u = G[v][i];\n\t\tint w = match[u];\n\n\t\tif(w<0 || (!used[w] && dfs(w, G, match, used))){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\twhile(true){\n\t\tint m, n;\n\t\tcin >> m >> n;\n\n\t\tif(m==0 && n==0)\n\t\t\tbreak;\n\n\t\tint b[500];\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcin >> b[i];\n\t\t}\n\n\t\tint r[500];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> r[i];\n\t\t}\n\n\t\tint V = m+n;\n\n\t\tvector<int> G[1000];\n\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(euclid(b[i], r[j])>1){\n\t\t\t\t\tG[i].push_back(m+j);\n\t\t\t\t\tG[m+j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\t\tfor(int i=0; i<V; i++){\n\t\t\tfor(int j=0; j<G[i].size(); j++){\n\t\t\t\tcout << G[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n*/\n\n\t\tint res = 0;\n\n\t\tint match[1000];\n\t\tfor(int i=0; i<1000; i++)\n\t\t\tmatch[i] = -1;\n\n\t\tfor(int v=0; v<V; v++){\n\t\t\tif(match[v]<0){\n\n\t\t\t\tbool used[1000];\n\t\t\t\tfor(int i=0; i<1000; i++)\n\t\t\t\t\tused[v] = false;\n\n\t\t\t\tif(dfs(v, G, match, used)){\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <set>\n#define X first\n#define Y second\n\nusing namespace std;\n\nstruct link{\n\tint dest;\n\tlink *ne;\n\tlink(int n=0){\n\t\tdest=n;\n\t\tne=NULL;\n\t}\n};\n\nint gcd(int a,int b){\n\tif(a%b==0)return b;\n\treturn(gcd(b,a%b));\n}\n\nint n, m, a[510], b[510], used[510], ans;\nlink *last[510], *t;\n\nbool dfs(int x){\n\tlink *t=last[x];\n\twhile(t){\n\t\tif(!used[t->dest]){\n\t\t\tused[t->dest]=1;\n\t\t\tif(b[t->dest]==0||dfs(b[t->dest])){\n\t\t\t\tb[t->dest]=x;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tt=t->ne;\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin>>n>>m;\n\twhile(n+m>0){\n\t\tans=0;\n\t\tfor(int i=1;i<=n;i++) cin>>a[i];\n\t\tfor(int i=1;i<=m;i++) cin>>b[i];\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=m;j++)\n\t\t\t\tif(gcd(a[i],b[j])>1){\n\t\t\t\t\tt=new link(j);\n\t\t\t\t\tt->ne=last[i];\n\t\t\t\t\tlast[i]=t;\n\t\t\t\t}\n\t\tmemset(b,0,sizeof(b));\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(i)) ans++;\n\t\t}\n\t\tcout<<ans<<endl;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tt=last[i];\n\t\t\twhile(last[i]){\n\t\t\t\tt=last[i]->ne;\n\t\t\t\tdelete last[i];\n\t\t\t\tlast[i]=t;\n\t\t\t}\n\t\t}\n\t\tcin>>n>>m;\t\t\t\n\t}\n\treturn 0;\n}\n&#171; Back"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n#define INF 1000000000\n#define MAX_V 3000\n\n#define rep(i,a) for(int i=0;i<a;i++)\nstruct edge{int to, cap, rev;};\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i<G[v].size();i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint N, K;\nbool can[MAX_V][MAX_V];\n\nvoid solve(){\n    int s = N + K, t = s + 1;\n    for(int i = 0; i < N; i++){\n        add_edge(s, i, 1);\n    }\n    for(int i = 0; i < K; i++){\n        add_edge(N+i, t, 1);\n    }\n\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < K; j++){\n            if(can[i][j]){\n                add_edge(i, N + j, 1);\n            }\n        }\n    }\n    cout << max_flow(s, t) << endl;\n}\n\nint main(){\n    while(cin>>N>>K,N||K){\n        rep(i, MAX_V) G[i].clear();\n        vector<int> b(N);\n        vector<int> r(K);\n        rep(i, N) cin >> b[i];\n        rep(i, K) cin >> r[i];\n        memset(can, 0, sizeof(can));\n        rep(i, N){\n            rep(j, K){\n                if(__gcd(b[i], r[j]) > 1){\n                    can[i][j] = true;\n                }\n            }\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint M,N;\nint b[512], r[512];\n\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[1024];\nbool used[1024];\n\nvoid add_edge(int from, int to, int cap){\n  G[from].push_back((edge){to, cap, G[to].size()});\n  G[to].push_back((edge){from, 0, G[from].size()-1});\n}\n\nint dfs(int v, int t, int f){\n  //  cout << v << \" \" << t << \" \" << f << endl;\n  if(v==t) return f;\n  used[v] = true;\n  rep(i,G[v].size()){\n    edge &e = G[v][i];\n    //    cout << \"next \" << e.to << \" \" << used[e.to] << \" \" << e.cap << endl;\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t){\n  int flow = 0;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    int f = dfs(s, t, INF);\n    //    cout << f << endl;\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main(){\n  while(scanf(\"%d%d\", &M,&N) && M+N){\n    rep(i,1024) G[i].clear();\n    rep(i,M) scanf(\"%d\", b+i);\n    rep(i,N) scanf(\"%d\", r+i);\n    // 0~N-1 red\n    // N~N+M-1 blue\n    int s = M+N, t = s+1;\n    rep(i,N) add_edge(s, i, 1);\n    rep(i,M) add_edge(N+i, t, 1);\n    rep(i,M) rep(j,N){\n      if(__gcd(r[j], b[i]) != 1) add_edge(j, N+i, 1);\n    }\n    /*    rep(i,N+M+2){\n      cout << G[i].size() << endl;\n      rep(j,G[i].size()) cout << G[i][j].to << \" \" << G[i][j].cap <<  \"  \"; cout << endl;\n      }*/\n    printf(\"%d\\n\", max_flow(s, t));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint m,n;\nint b[510],r[510];\nvector<int> G[1010];\nbool v[1010];\nint f[1010];\n\nbool dfs(int t){\n  v[t] = true;\n  for(int i=0;i<(int)G[t].size();i++){\n    int u = G[t][i], o = f[u];\n    if(o<0 || !v[o] && dfs(o)){\n      f[t] = u;\n      f[u] = t;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bi_matching(void){\n  int res = 0;\n  memset(f,-1,sizeof(f));\n  for(int i=0;i<m+n;i++){\n    if(f[i] < 0){\n      memset(v,0,sizeof(v));\n      if(dfs(i))res++;\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> m >> n , m||n){\n    for(int i=0;i<m;i++)cin >> b[i];\n    for(int i=0;i<n;i++)cin >> r[i];\n\n    for(int i=0;i<m+n;i++)G[i].clear();\n    \n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n\tif(__gcd(b[i],r[j])>1){\n\t  G[i].push_back(m+j);\n\t  G[m+j].push_back(i);\n\t}\n      }\n    }\n\n    cout << bi_matching() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j;\n  int m,n;\n  while(cin>>m>>n,m||n){\n    int a[500],b[500];\n    for(i=0;i<m;i++)\n      cin>>a[i];\n    for(i=0;i<n;i++)\n      cin>>b[i];\n    int c[500][500]={};\n    for(i=0;i<m;i++){\n      for(j=0;j<n;j++){\n\tif(__gcd(a[i],b[j])!=1)\n\t  c[i][j]=-1;\n      }\n    }\n    int d[500],e[500];\n    memset(d,-1,sizeof(d));\n    memset(e,-1,sizeof(e));\n    for(i=0;i<m;i++){\n      if(d[i]==-1){\n\tqueue<pair<int,int> > f;\n\tf.push(make_pair(i,0));\n\twhile(f.empty()==0){\n\t  if(f.front().second){\n\t    for(j=0;j<m;j++){\n\t      if(c[j][f.front().first]&&d[j]==-1){\n\t\td[j]=i;\n\t\tf.push(make_pair(j,0));\n\t      }\n\t    }\n\t  }else{\n\t    for(j=0;j<n;j++){\n\t      if(c[f.front().first][j]&&e[j]==-1){\n\t\te[j]=i;\n\t\tf.push(make_pair(j,1));\n\t      }\n\t    }\n\t  }\n\t  f.pop();\n\t}\n      }\n    }\n    int g[500]={},h[500]={};\n    for(i=0;i<m;i++){\n      if(d[i]!=-1)\n\tg[d[i]]++;\n    }\n    for(i=0;i<n;i++){\n      if(e[i]!=-1)\n\th[e[i]]++;\n    }\n    int sm=0;\n    for(i=0;i<m;i++)\n      sm+=min(g[i],h[i]);\n    cout<<sm<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nconst int MAX_N=1001;\nint n;\nvector<int> g[MAX_N];\nint match[MAX_N];\nint used[MAX_N];\nvoid add_edge(int src,int dst){\n    g[src].pb(dst);\n    g[dst].pb(src);\n}\nbool dfs(int v){\n    used[v]=true;\n    rep(i,g[v].size()){\n        int u=g[v][i],w=match[u];\n        if(w<0||!used[w]&&dfs(w)){\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(){\n    int res=0;\n    memset(match,-1,sizeof(match));\n    rep(i,n){\n        if(match[i]<0){\n            memset(used,0,sizeof(used));\n            if(dfs(i)) ++res;\n        }\n    }\n    return res;\n}\n\nint a[1001];\nint main(){\n    int m;\n    while(cin>>n>>m,n|m){\n        rep(i,1001) g[i].clear();\n        rep(i,n) cin>>a[i];\n        rep(i,m) cin>>a[i+n];\n        rep(i,n)FOR(j,n,n+m){\n            if(__gcd(a[i],a[j])!=1) add_edge(i,j);\n        }\n        cout<<bipartite_matching()<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint main() {\n\tint m, n, red[500], blue[500], num[10];\n\tcin >> m >> n;\n\n\twhile (m != 0 && n != 0) {\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\t//cout << \"redcardテ・ツ?、テ」ツつ津・ツ?・テ・ツ環崚」ツ?療」ツ?ヲテ」ツ?湘」ツ??」ツ?陛」ツ?? << endl;\n\t\t\tcin >> red[i];\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t//cout << \"bluecardテ」ツ?ョテ・ツ?、テ」ツつ津・ツ?・テ・ツ環崚」ツ?療」ツ?ヲテ」ツ?湘」ツ??」ツ?陛」ツ?? << endl;\n\t\t\tcin >> blue[i];\n\t\t}\n\n\t\tint a;\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (red[i] < red[i + 1]) {\n\t\t\t\t\ta = red[i];\n\t\t\t\t\tred[i] = red[i + 1];\n\t\t\t\t\tred[i + 1] = a;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tint b;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (blue[i] < blue[i + 1]) {\n\t\t\t\t\tb = blue[i];\n\t\t\t\t\tblue[i] = blue[i + 1];\n\t\t\t\t\tblue[i + 1] = b;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t////////////////////テ」ツつステ」ツδシテ」ツδ暗・ツョツ古、ツコツ?\n\n\t\tint x = 0, ans;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (red[i] == blue[j]) {\n\t\t\t\t\t//cout << red[i] << \"テ・ツ青古」ツ?佚・ツ?、\" << endl;\n\t\t\t\t\tblue[j] = 0;\n\t\t\t\t\tx++;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\telse {\n\t\t\t\t\tif (red[i] < blue[j]) {\n\t\t\t\t\t\tfor (int k = i; k <= 1000; k++) {\n\t\t\t\t\t\t\tans = red[i] * k;\n\t\t\t\t\t\t\tif (ans == blue[j]) {\n\t\t\t\t\t\t\t\t//cout << \"red= \" << red[i] << \"blue=\" << blue[j] << endl;\n\t\t\t\t\t\t\t\tblue[j] = 0;\n\t\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\telse if (red[i] > blue[j]) {\n\t\t\t\t\t\tfor (int k = i; k <= 1000; k++) {\n\t\t\t\t\t\t\tans = blue[j] * k;\n\t\t\t\t\t\t\tif (ans == red[j]) {\n\t\t\t\t\t\t\t\t//cout << \"red=\" << red[i] << \"blue=\" << blue[j];\n\t\t\t\t\t\t\t\tblue[j] = 0;\n\t\t\t\t\t\t\t\tx++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}break;\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tcout << x << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n#define SET(a,c) memset(a,c,sizeof(a))\n\n#define DEBUG(x) cout<<\"#x\"<<\": \"<<x<<endl\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nconst ll INF = INT_MAX/3;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-14;\nconst int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n\nstruct edge{ int to;int cap;int rev; };\ntypedef struct edge edge;\n\nint m,n;\n\nvector<edge> G[1002];\nint used[250002];\n\nvoid add_edge(int from,int to){\n    G[from].PB( (edge){to,1,(int)G[to].size()} );\n    G[to].PB( (edge){from,0,(int)G[to].size()-1} );\n}\n\nint dfs(int v,int t,int f){\n    if( v == t) return f;\n    used[v] = true;\n    REP(i,G[v].size()){\n\tedge &e = G[v][i];\n\tif(!used[e.to] && e.cap > 0){\n\t    int d = dfs(e.to,t,min(f,e.cap));\n\t    if(d > 0){\n\t\te.cap -= d;\n\t\tG[e.to][e.rev].cap += d;\n\t\treturn d;\n\t    }\n\t}\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int flow = 0;\n    while(true){\n\tSET(used,false);\n\tint f = dfs(s,t,INF);\n\tif(f == 0)return flow;\n\tflow += f;\n    }\n    return -1;\n}\n\nint gcd(int a,int b){ return a % b == 0 ? b : gcd(b,a%b); }\n\nint main(){\n\n    while(true){\n\tm,n;\n\tcin >> m >> n;\n\tif(m == 0 && n == 0) break;\n\tREP(i,1002) G[i].clear();\n\tSET(used,false);\n\tint a[501],b[501];\n\tREP(i,m) {\n\t    cin >> a[i];\n\t    add_edge(0,i+1);\n\t}\n\tREP(i,n) {\n\t    cin >> b[i];\n\t    add_edge(i+1+m,n+m+1);\n\t}\n\tREP(i,m){\n\t    REP(j,n){\n\t\tif(gcd(a[i],b[j]) > 1){\n\t\t    add_edge(i+1,m+j+1);\n\t\t}\n\t    }\n\t}\n\tcout << max_flow(0,n+m+1) << endl;;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <limits>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\n\nclass Flow\n{\npublic:\n    using T = ll;\n    struct Edge {\n        Edge(const int from_, const int to_, const int reverse_, const T capacity_, bool is_reverse = false) : from{from_}, to{to_}, reverse{reverse_}, capacity{capacity_}, flow{0}, is_reverse(is_reverse) {}\n        int from;\n        int to;\n        int reverse;\n        T capacity;\n        T flow;\n        bool is_reverse;\n    };\n\n    Flow(const int v) : V{v}\n    {\n        edge.resize(v);\n    }\n    void addEdge(const int from, const int to, const T capacity)\n    {\n        edge[from].push_back(Edge{from, to, (int)edge[to].size(), capacity, false});\n        edge[to].push_back(Edge{to, from, (int)edge[from].size() - 1, 0, true});\n    }\n\n    T FordFulkerson(const int s, const int t)\n    {\n        vector<bool> checked(V);\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < V; i++) {\n                checked[i] = false;\n            }\n            const T f = dfs_ff(s, t, INF<T>, checked);\n            if (f == 0) {\n                break;\n            }\n            flow += f;\n        }\n        return flow;\n    }\n\n    const int V;\n    vector<vector<Edge>> edge;\n\nprivate:\n    T dfs_ff(const int pos, const int t, const T flow, vector<bool>& checked)\n    {\n        if (pos == t) {\n            return flow;\n        }\n        checked[pos] = true;\n        for (auto& e : edge[pos]) {\n            if (not checked[e.to]) {\n                const T res = e.capacity - e.flow;\n                if (res > 0) {\n                    const T d = dfs_ff(e.to, t, min(flow, res), checked);\n                    if (d > 0) {\n                        e.flow += min(d, res);\n                        edge[e.to][e.reverse].flow -= min(d, res);\n                        return d;\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n};\n\ntemplate <typename T>\nT gcd(const T a, const T b)\n{\n    return (b != 0) ? gcd(b, a % b) : a;\n}\n\n\nint main()\n{\n    while (true) {\n        int m, n;\n        cin >> m >> n;\n        if (m == 0 and n == 0) {\n            break;\n        }\n        Flow flow(m + n + 2);\n        vector<ll> b(m);\n        for (int i = 0; i < m; i++) {\n            flow.addEdge(m + n, i, 1);\n            cin >> b[i];\n        }\n        vector<ll> r(n);\n        for (int i = 0; i < n; i++) {\n            flow.addEdge(i + m, m + n + 1, 1);\n            cin >> r[i];\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (gcd(b[i], r[j]) > 1) {\n                    flow.addEdge(i, m + j, 1);\n                }\n            }\n        }\n        cout << flow.FordFulkerson(m + n, m + n + 1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<string>\n#include<cmath>\n#include<cassert>\n#include<map>\n  using namespace std;\n\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ (i)=0;(i)<(j);(i)++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);(i)++)\n#define all(v) begin(v),end(v)\n\n#define MAX_N 1010\nclass maxFlow\n{\npublic:\n  int N;//???????????°\n  int G[MAX_N][MAX_N];//G[i][j] :=???i??????j????????§?????????\n  bool is_visited[MAX_N];\n\n  maxFlow(int n)\n  {\n    N=n;\n    //?????????????????¨????????°???????????§??????\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tG[i][j]=0;\n  }\n\n  //n1->n2???arc?????????\n  void add_arc(int n1,int n2,int capacity)\n  {\n    G[n1][n2]+=capacity;//????????§?????±???\n  }\n\n  //??´???????????§???????????¢?´¢\n  int dfs(int now,int end,int min_capacity)\n  {\n    if(now==end)return min_capacity;\n    if(!is_visited[now])\n      {\n\tis_visited[now]=true;\n\tfor(int i=0;i<N;i++){\n\t  if(G[now][i]>0){//now??????i????????§??????????????????????????°????????§??????\n\t    int ret=dfs(i,end,min(min_capacity,G[now][i]));\n\t    if(ret>0){//??´???????????????????????????????????§?¢???????????????????????????????????????´??°\n\t      G[now][i]-=ret;\n\t      G[i][now]+=ret;\n\t      return ret;\n\t    }\n\t  }\n\t}\n\treturn -2;//??´????????????????????????????????£???\n      }\n    else return -1;//?????§????¨???????????????£???\n  }\n  \n  int get_maxFlow(int start,int end)\n  {\n    int temp,ans=0;\n    //??´???????????????????????????????????§????????????????????????????????????????´¢\n    while(true){\n      for(int i=0;i<N;i++)is_visited[i]=false;\n      temp=dfs(start,end,100);\n      if(temp>0)ans+=temp;\n      else break;\n    }\n    return ans;\n  }\n  \n};\n\nint gcd(int a,int b){\n  if(b==0)return a;\n  return gcd(b,a%b);\n}\n\nint main()\n{\n  int n,m;\n\n  while(true){\n    cin>>m>>n;\n    if(m==0&&n==0)break;\n    maxFlow G(m+n+2);\n    vector<int> b(m);\n    vector<int> r(n);\n    rep(i,m){\n      cin>>b[i];\n      G.add_arc(m+n, i, 1);\n    }\n    rep(i,n){\n      cin>>r[i];\n      G.add_arc(m+i, m+n+1 , 1);\n    }\n    \n    rep(i,m){\n      rep(j,n){\n        if(gcd(b[i],r[j])!=1){\n          G.add_arc(i, m+j, 1);\n        }\n      }\n    }\n\n    cout<<G.get_maxFlow(m+n, m+n+1)<<endl;\n    \n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<list>\nint F(int x,int y)\n{\n\tif(!y)return x;\n\treturn F(y,x%y);\n}\ntypedef std::list<int>L;\nL e[1002];\nint m,n;\nbool f[1002];\nint G(int s,int d)\n{\n\tif(s==d)return 1;\n\tif(f[s])return 0;\n\tf[s]=1;\n\tfor(L::iterator i=e[s].begin();i!=e[s].end();++i)\n\t{\n\t\tif(G(*i,d))\n\t\t{\n\t\t\te[*i].push_back(s);\n\t\t\te[s].erase(i);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint a[500],i,j,x;\n\twhile(scanf(\"%d%d\",&m,&n),m)\n\t{\n\t\tfor(i=0;i<m+n+2;++i)e[i].clear();\n\t\tfor(i=0;i<m;++i)scanf(\"%d\",&a[i]),e[m+n].push_back(i);\n\t\tfor(j=0;j<n;++j)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tfor(i=0;i<m;++i)if(F(a[i],x)>1)e[i].push_back(m+j);\n\t\t\te[m+j].push_back(m+n+1);\n\t\t}\n\t\tfor(x=0;memset(f,0,sizeof(f)),G(m+n,m+n+1);)++x;\n\t\tprintf(\"%d\\n\",x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0,i##_cond=(n);i<i##_cond;++i)\n#define FOR(i,a,b) for(int i=(a),i##_cond(b);i<i##_cond;++i)\n#define sz(x) ((int)(x).size())\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\n#define inf 1<<30\n\nvector<int> prime(int n){\n  // n以下の素数を要素に持つviを返す\n  // 時間 O(n ln ln n)\n  // 答えのサイズ n / ln n\n\n  vector<bool> isprime(n+1,true);\n  vector<int> ans;\n  isprime[0] = isprime[1] = false;\n  FOR(i,2,n+1)\n    if(isprime[i]){\n      ans.push_back(i);\n      for(int j = 2 * i; j <= n; j += i) isprime[j] = false;\n    }\n  return ans;\n}\n\n// dinic\nstruct max_flow {\n    struct edge { int to, cap, rev; };\n    int V;\n    vector<vector<edge>> G;\n    vector<int> itr, level;\n\n    max_flow(int _V) : V(_V) { G.assign(_V,vector<edge>()); }\n\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back((edge) {to, cap, (int) G[to].size()});\n        G[to].push_back((edge) {from, 0, (int) G[from].size()-1});\n    }\n\n    void bfs(int s) {\n        level.assign(V,-1);\n        queue<int> q;\n        level[s] = 0; q.push(s);\n        while (!q.empty()) {\n            int v = q.front(); q.pop();\n            for(auto &e: G[v]){\n                if (e.cap > 0 and level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int& i = itr[v]; i < (int) G[v].size(); ++i) {\n            edge& e = G[v][i];\n            if (e.cap > 0 and level[v] < level[e.to]) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int run(int s, int t) {\n        int ret = 0, f;\n        while (bfs(s), level[t] >= 0) {\n            itr.assign(V,0);\n            while ((f = dfs(s, t, inf)) > 0) ret += f;\n        }\n        return ret;\n    }\n};\n\nint main(){  \n  vi p = prime(10000000);\n  \n  while(1){\n    // input\n    int m, n; cin >> m >> n; if(m == 0) break;\n    vi b(m); rep(i,m) cin >> b[i];\n    vi r(n); rep(i,n) cin >> r[i];\n\n    // フロー初期化\n    struct max_flow f(n+m+2); // 左右+1+1\n    rep(i,m) f.add_edge(0,i+1,1); // sから左側\n    rep(i,n) f.add_edge(m+i+1,m+n+1,1); // 右側からt\n\n    // 同じ素因数を持つとき辺を追加\n    rep(i,m) rep(j,sz(p)) if(b[i] % p[j] == 0)\n      rep(k,n) if(r[k] % p[j] == 0)\n\tf.add_edge(i+1,m+k+1,1);\n\n    // フローを流す\n    int ans = f.run(0,n+m+1);\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint gcd(int a, int b) {\n\tif (!b)return a;\n\treturn gcd(b, a%b);\n}\nint b[500], r[500];\nvector<int>E[1000];\nbool used[1000];\nint match[1000];\n\nbool dfs(int u) {\n\tused[u] = true;\n\tfor (int v : E[u]) {\n\t\tint w = match[v];\n\t\tif (w == -1 || (!used[w] && dfs(w))) {\n\t\t\tmatch[u] = v; match[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tint m, n;\n\twhile (scanf(\"%d%d\", &m, &n), m) {\n\t\trep(i, 1000)E[i].clear();\n\t\trep(i, m)scanf(\"%d\", &b[i]);\n\t\trep(i, n)scanf(\"%d\", &r[i]);\n\t\trep(i, m)rep(j, n) {\n\t\t\tif (gcd(b[i], r[j]) != 1)E[i].push_back(m + j);\n\t\t}\n\t\tmemset(match, -1, sizeof(match));\n\t\tint ans = 0;\n\t\trep(i, m) {\n\t\t\tif (match[i] == -1) {\n\t\t\t\tmemset(used, 0, sizeof(used));\n\t\t\t\tif (dfs(i))ans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<map>\n#include<unordered_map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<sstream>\n#include<iomanip>\n\n#define reps(i,j,k) for(int i=(j);i<(k);i++)\n#define rep(i,j) reps(i,0,j)\n#define fs first\n#define sc second\n#define pb push_back\n#define mk make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntemplate<class S,class T>\nostream &operator<<(ostream &out, const pair<S,T> p){\n\treturn out << \"(\" << p.fs << \", \" << p.sc << \")\";\n}\n\ntemplate<class T>\nostream &operator<<(ostream &out, const vector<T> &v){\n\tout << \"{\";\n\trep(i,v.size()) out << v[i] << \", \";\n\treturn out << \"}\" << endl;\n}\nint c[50][50];\nint gcd(int x, int y){\n\tif(!y) return x;\n\treturn gcd(y, x%y);\n}\n#define N 1000\nvi g[N];\nint used[N];\nint match[N];\nvoid add_edge(int i, int j){\n\tg[i].pb(j);\n\tg[j].pb(i);\n}\nbool dfs(int v){\n\tused[v] = 1;\n\trep(i,g[v].size()){\n\t\tint u = g[v][i], w = match[u];\n\t\tif(w < 0 || (!used[w] && dfs(w))){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tint n,m;\n\twhile(cin >> m >> n, n){\n\t\tvi r(n), b(m);\n\t\trep(i,m) cin >> b[i];\n\t\trep(i,n) cin >> r[i];\n\t\tint t = n + m;\n\t\tfill(match, match+N, -1);\n\t\tfill(used, used + N, 0);\n\t\trep(i,t) g[i].clear();\n\t\trep(i,m){\n\t\t\trep(j,n){\n\t\t\t\tif(gcd(b[i], r[j]) > 1){\n\t\t\t\t\tadd_edge(i,m+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\trep(v, t){\n\t\t\tif(match[v]<0){\n\t\t\t\tfill(used, used + N, 0);\n\t\t\t\tif(dfs(v)){\n\t\t\t\t\tans ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iomanip>\n\n#define REP(i,n) for(i=0; i < (n); i++)\n#define REPONE(i, n) for(i=1; i <= (n); i++)\n#define LOOP(n) for(int loopCount=1; loopCount <= (n); loopCount++)\n#define ITER(c) __typeof((c).begin())\n#define EACH(c,it) for(ITER(c) it =(c).begin(); it!=(c).end(); it++)\n#define SZ(c) ((int) (c).size())\n#define ALL(c) c.begin(), c.end()\n#define SUM(c) accumulate(ALL(c), 0)\n#define EXIST(c,v) (find(ALL(c), (v)) != (c).end())\n#define PB push_back\n#define MP make_pair\n\nusing namespace std;\nstatic const double EPS = 1e-9;\nstatic const double PI = 3.141592653589793238462643383279;\ntypedef long long ll;\n\ntemplate<typename T>\nT FordFulkersonByMatrix(vector< vector<T> > &matrix, int source, int sink){\n    int n = matrix.size();\n    T maxCost = (T)0;\n    vector< vector<T> > flowMat(n, vector<T>(n,0)), resMat = matrix;\n    for(int i=0; i<n; i++)for(int j=0; j<n; j++)\n        maxCost = max(maxCost,matrix[i][j]);\n\n    while(1){\n        stack<int> st;\n        vector<int> parent(n,-1);\n        st.push(source);\n        while(!st.empty() && parent[sink] == -1){\n            int tp = st.top(); st.pop();\n            for(int i=0; i<n; i++){\n                if(parent[i] == -1 && resMat[tp][i] > 0){\n                    st.push(i);\n                    parent[i] = tp;\n                }\n            }\n        }\n        if(parent[sink] == -1) break;\n        T minCost = maxCost;\n        for(int i=sink; i!=source; i = parent[i]){\n            minCost = min(minCost, resMat[parent[i]][i]);\n        }\n        for(int i=sink; i!=source ; i = parent[i]){\n            flowMat[parent[i]][i] += minCost;\n            flowMat[i][parent[i]] -= minCost;\n            resMat[parent[i]][i] -= minCost;\n            resMat[i][parent[i]] += minCost;\n        }\n    }\n\n    return accumulate(flowMat[source].begin(), flowMat[source].end(), (T)0);\n}\n\nint BipartiteMatchingByList(vector< vector<int> > &bigraph){\n    int n=bigraph.size(), m;\n    m = 0;\n    for(int i=0; i<n; i++){\n        for(int j=0; j<(int)bigraph[i].size(); j++){\n            m = max(m, bigraph[i][j]);\n        }\n    }\n    m++;\n    vector< vector<int> > matrix(n+m+2, vector<int>(n+m+2,0));\n    for(int i=0; i<n; i++){\n        for(int j=0; j<(int)bigraph[i].size(); j++){\n            matrix[i][n+bigraph[i][j]] = 1;\n        }\n    }\n    for(int i=0; i<m; i++){\n        matrix[n+i][n+m+1] = 1;\n    }\n    for(int j=0; j<n; j++){\n        matrix[n+m][j] = 1;\n    }\n\n    return FordFulkersonByMatrix(matrix, n+m, n+m+1);\n}\n\nint main(){\n    int m, n, i, j;\n    int blues[502], reds[502];\n\n    while(scanf(\"%d%d\",&m,&n)){\n        if(!(n||m))break;\n        REP(i,m)scanf(\"%d\",blues+i);\n        REP(i,n)scanf(\"%d\",reds+i);\n        vector< vector<int> > bigraph(m);\n        REP(i,m)REP(j,n)if(__gcd(blues[i], reds[j]) > 1)\n            bigraph[i].PB(j);\n        printf(\"%d\\n\", BipartiteMatchingByList(bigraph));\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long int v;\nvector < vector< long long int > > g;\nvector< long long int > match;\nbool used[1001];\n\nlong long int gcd( long long int x, long long int y ) {\n\n  if ( y > x ) swap( x, y );\n\n  while( y > 0 ) {\n\n    long long int k = x % y;\n    x = y;\n    y = k;\n\n  }\n\n  return x;\n\n}\n\nbool dfs( long long int x ) {\n\n  used[x] = true;\n\n  for ( long long int i = 0; i < g[x].size(); i++ ) {\n\n    long long int k = g[x][i];\n    long long int w = match[k];\n\n    if ( w < 0 || !used[w] && dfs(w) ) {\n\n      match[x] = k;\n      match[k] = x;\n      return true;\n\n    }\n\n  }\n\n  return false;\n}\n\nint main() {\n\n  while( true ) {\n\n    long long int m, n;\n    cin >> m >> n;\n    if ( m == 0 ) break;\n    v = m + n;\n\n    vector< long long int > b, r;\n\n    for ( long long int i = 0; i < m; i++ ) {\n      long long int in;\n      cin >> in;\n      b.push_back( in );\n    }\n\n    for ( long long int i = 0; i < n; i++ ) {\n      long long int in;\n      cin >> in;\n      r.push_back( in );\n    }\n\n    g.clear();\n    for ( long long int i = 0; i < v; i++ ) {\n      vector< long long int > vec;\n      g.push_back( vec );\n    }\n\n    for ( long long int i = 0; i < m; i++ ) {\n      for ( long long int j = 0; j < n; j++ ) {\n\tif ( gcd( b[i], r[j] ) > 1 ) {\n\t  g[i].push_back( j+m );\n\t  g[j+m].push_back( i );\n\t}\n      }\n    }\n\n    long long int ans = 0;\n\n    match.clear();\n    for ( long long int i = 0; i < v; i++ ) {\n      match.push_back( -1 );\n    }\n\n    for ( long long int x = 0; x < v; x++ ) {\n\n      if ( match[x] < 0 ) {\n\n\tfor ( long long int j = 0; j < v; j++ ) {\n\t  used[j] = false;\n\t}\n\n\tif ( dfs( x ) == true ) {\n\t  ans++;\n\t}\n\n      }\n\n    }\n\n    cout << ans << endl;\n\n  /*\n  for ( long long int i = 0; i < m; i++ ) {\n    g[i].push_back( m+n );\n  }\n  for ( long long int i = 0; i < n; i++ ) {\n    g[m+i].push_back( m+n+1 );\n  }\n  */\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nstruct edge { int to, cap, rev; };\nvector<edge> G[300000];\nbool used[300000];\nvoid init(int V) {\n\trep(i, V) {\n\t\tG[i].clear();\n\t}\n}\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, (int)G[to].size() });\n\tG[to].push_back(edge{ from, 0, (int)G[from].size() - 1 });\n}\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, (int)MOD);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n}\nint gcd(int x, int y) {\n\tif (x < y)swap(x, y);\n\twhile (y > 0) {\n\t\tint r = x % y; x = y; y = r;\n\t}\n\treturn x;\n}\nint main() {\n\tint m; int n;\n\twhile (cin >> m >> n, m) {\n\t\tinit(300000);\n\t\tint a[501], b[501];\n\t\trep1(i, m) {\n\t\t\tcin >> a[i];\n\t\t\tadd_edge(0, i, 1);\n\t\t}\n\t\trep1(i, n) {\n\t\t\tcin >> b[i];\n\t\t\tadd_edge(i + m, 1 + m + n, 1);\n\t\t}\n\t\trep1(i, m) {\n\t\t\trep1(j, n) {\n\t\t\t\tif (gcd(a[i], b[j]) > 1) {\n\t\t\t\t\tadd_edge(i, m + j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << max_flow(0, 1 + m + n) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<n; i++)\n\nint m, n;\nint b[555];\nint r[555];\nint V;\nvector<int> G[555*555];\nint match[555*555];\nint used[555*555];\n\ninline int gcd(int a, int b)\n{\n  int t;\n  while(b){\n    t = a;\n    a = b;\n    b = t % b;\n  }\n  return a;\n}\n\nbool dfs(int v)\n{\n  used[v] = true;\n  rep(i, G[v].size()){\n    int u = G[v][i], w = match[u];\n    if(w < 0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint matching()\n{\n  int res = 0;\n  rep(i, 555) match[i] = -1;\n  rep(v, V){\n    if(match[v] < 0){\n      rep(i, 555) used[i] = 0;\n      if(dfs(v)) res += 1;\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  while(cin >> m >> n, m){\n    rep(i, m) cin >> b[i];\n    rep(i, n) cin >> r[i];\n    V = m * n;\n    rep(i, V) G[i].clear();\n\n    rep(i, m) rep(j, n) if(gcd(b[i], r[j]) > 1){\n      G[i].push_back(j + m);\n      G[m + j].push_back(i);\n    }\n\n    cout << matching() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n//typedef long long Int;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst) : src(src),dst(dst) {}\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) {}\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vec<Edge> Edges;\ntypedef vec<Edges> Graph;\n\n#define MAXMN 500\nint B[MAXMN];\nint R[MAXMN];\n\nint gcd(int a, int b)\n{   \n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\n\n\nmain() {\n  int M,N;\n  Graph g;\n  while(cin>>M>>N,M) {\n    g.clear();\n    g.resize(M+N);\n    REP(i,M) cin>>B[i];\n    REP(i,N) cin>>R[i];\n    REP(i,M) {\n      Edges es, es2;\n      REP(j,N) {\n\tif(gcd(B[i],R[j])!=1) { es.pb(Edge(i,M+j)); es2.pb(Edge(M+j,i)); }\n      }\n      g[i] = es;\n      g[M+i] = es2;\n    }\n    Edges matching;\n    cout << bipartiteMatching(g,M,matching) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\n\n#define MAX_V 10000\n#define INF 1e9\n\nstruct edge{\n    int to, cap, rev;\n};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size()-1});\n}\n\nint dfs(int v, int t, int f){\n    if (v==t) return f;\n    used[v] = 1;\n    REP(i,G[v].size()){\n        edge &e = G[v][i];\n        if (!used[e.to] && e.cap>0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f==0) return flow;\n        flow += f;\n    }\n}\n\nint gcd(int x, int y){\n    if (y == 0) return x;\n    return gcd(y, x % y);\n}\n\nint main() {\n    int n, m;\n    while (cin >> n >> m && n){\n        VI b(n), r(m);\n        REP(i,n) cin >> b[i];\n        REP(i,m) cin >> r[i];\n        int start = 1010, goal = 1011;\n        REP(i,n) add_edge(start, i, 1);\n        REP(i,m) add_edge(n+i, goal, 1);\n        REP(i,n) REP(j,m){\n            if (gcd(b[i], r[j]) > 1)\n                add_edge(i, j+n, 1);\n        }\n        cout << max_flow(start, goal) << endl;\n\n        REP(i,MAX_V){\n            G[i].clear();\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ntypedef struct{\n\tint to, cap, rev;\n}edge;\n\nint x[555], y[555];\nint gcd(int a, int b)\n{\n    while( 1 )\n    {\n        a = a % b;\n\t\tif( a == 0 )\n\t\t\treturn b;\n\t\tb = b % a;\n\n        if( b == 0 )\n\t\t\treturn a;\n    }\n}\n\nclass biMatch{//bipartite matching\npublic:\n\tvector<vector<edge> > g;\n\tbiMatch(int k){\n\t\tg = vector<vector<edge> >(k);\n\t}\n\tvoid add_edge(int from, int to, int cap){\n\t\tedge e;\n\t\te.to = to;\n\t\te.cap = cap;\n\t\te.rev = g[to].size();\n\t\tg[from].PB(e);\n\t\te.to = from;\n\t\te.cap = cap;\n\t\te.rev = g[from].size()-1;\n\t\tg[to].PB(e);\n\t}\n\tint DFS(int n, int f, int goal, VI &visited){\n\t\tif(n==goal)return f;\n\t\tvisited[n] = 1;\n\t\tint cnt = f;\n\t\tREP(i, g[n].size()){\n\t\t\tif(g[n][i].cap <= 0)continue;\n\t\t\tif(visited[g[n][i].to])continue;\n\t\t\tint ret = DFS(g[n][i].to, min(f, g[n][i].cap), goal, visited);\n\t\t\tint n2 = g[n][i].to;\n\t\t\tg[n][i].cap -= ret;\n\t\t\tg[n2][g[n][i].rev].cap += ret;\n\t\t\tcnt -= ret;\n\t\t\tif(cnt == 0)break;\n\t\t}\n\t\treturn f-cnt;\n\t}\n};\n\nint main(){\n\twhile(1){\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tif(m==0)return 0;\n\t\tbiMatch b(m+n+2);\n\t\tREP(i,m){\n\t\t\tscanf(\"%d\", &x[i]);\n\t\t\tb.add_edge(0, i+1, 1);\n\t\t}\n\t\tREP(i,n){\n\t\t\tscanf(\"%d\", &y[i]);\n\t\t\tb.add_edge(m+i+1, m+n+1, 1);\n\t\t}\n\t\tREP(i,m){\n\t\t\tREP(j,n){\n\t\t\t\tif(gcd(x[i], y[j]) > 1){\n\t\t\t\t\tb.add_edge(i+1, m+j+1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\twhile(1){\n\t\t\tVI visited(m+n+2, 0);\n\t\t\tint tmp = b.DFS(0, 1, m+n+1, visited);\n\t\t\tif(tmp == 0)break;\n\t\t\tret += tmp;\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <map>\n#include <ctime>\n#include <cstdlib>\n \nusing namespace std;\n \ntypedef pair<int, int> P;\ntypedef vector<double> array;\ntypedef vector<array> matrix;\nconst double EPS = 1e-8;\n\nint gcd(int a, int b){ return (b == 0 ? a : gcd(b, a%b)); }\n \nint rank(matrix &A){\n\tint n = A.size();\n  int res = 0;\n\tmatrix B(n, array(n+1,1));\n  for(int i=0;i<n;i++) for(int j=0;j<n;j++) B[i][j] = A[i][j];\n    \n  for(int i=0;i<n;i++){\n    int pivot = i;\n    for(int j=i;j<n;j++){\n      if(abs(B[j][i]) > abs(B[pivot][i])) pivot = j;\n    }\n    swap(B[i],B[pivot]);\n    if(abs(B[i][i]) > EPS) res++;\n    if(abs(B[i][i]) > EPS){\n      for(int j=i+1;j<=n;j++) B[i][j] /= B[i][i];\n      for(int j=0;j<n;j++){\n\t\t\t\tif(i != j){\n\t\t\t\t\tfor(int k=i+1;k<=n;k++) B[j][k] -= B[j][i] * B[i][k];\n\t\t\t\t}\n      }\n    }\n  }\n  return res;\n}\n \nint main(){\n\tsrand((unsigned)time(NULL));\n\tint n, m;\n\twhile(cin >> n >> m && (n|m)){\n\t\tvector<int> A(n), B(m);\n\t\tfor(int i=0;i<n;i++) cin >> A[i];\n\t\tfor(int i=0;i<m;i++) cin >> B[i];\n\t\tmatrix mat(n+m, array(n+m, 0));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(gcd(A[i], B[j]) > 1){\n\t\t\t\t\tint tmp = rand();\n\t\t\t\t\tmat[i][n+j] = tmp;\n\t\t\t\t\tmat[n+j][i] = -tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << rank(mat) / 2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint V;\nvector<int> G[1010];\nint match[1010];\nbool used[1010];\n\nvoid add_edge(int u, int v) {\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tint u = G[v][i];\n\t\tint w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching() {\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; v++) {\n\t\tif (match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nlong long int gcd(long long int a, long long int b) {\n\tif (b == 0) {\n\t\treturn a;\n\t}\n\telse {\n\t\treturn gcd(b, a%b);\n\t}\n}\n\nint main() {\n\tint m, n;\n\twhile (cin >> m >> n) {\n\t\tif (m == 0 && n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < 1010; i++) {\n\t\t\tG[i].clear();\n\t\t}\n\t\tV = m + n;\n\t\tvector<long long int> b(m);\n\t\tvector<long long int> r(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> b[i];\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> r[i];\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (gcd(b[i], r[j]) != 1) {\n\t\t\t\t\tadd_edge(i, m+j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\ntypedef int Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight == rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nWeight augment(Graph &g, Matrix &capacity, const vector<int> &level, vector<bool> &finished, int from, int t, Weight cur) {\n  if (from == t || cur == 0) { return cur; }\n  if (finished[from]) { return 0; }\n  for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n    int to = it->dest;\n    if (level[to] <= level[from]) { continue; }\n    Weight f = augment(g, capacity, level, finished, to, t, min(cur, capacity[from][to]));\n    if (f > 0) {\n      capacity[from][to] -= f;\n      capacity[to][from] += f;\n      return f;\n    }\n  }\n  finished[from] = true;\n  return 0;\n}\n\nWeight MaxFlow(Graph &g, int s, int t) {\n  int n = g.size();\n  Matrix capacity(n, Array(n));\n  for (int from = 0; from < n; from++) {\n    for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n      int to = it->dest;\n      capacity[from][to] += it->weight;\n    }\n  }\n  int ans = 0;\n  while (true) {\n    vector<int> level(n, -1);\n    level[s] = 0;\n    queue<int> que;\n    que.push(s);\n    for (int d = n; !que.empty() && level[que.front()] < d; ) {\n      int from = que.front();\n      que.pop();\n      if (from == t) { d = level[from]; }\n      for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n        int to = it->dest;\n        if (capacity[from][to] > 0 && level[to] == -1) {\n          que.push(to);\n          level[to] = level[from] + 1;\n        }\n      }\n    }\n    vector<bool> finished(n);\n    bool end = true;\n    while (true) {\n      Weight f = augment(g, capacity, level, finished, s, t, 1000000000);\n      if (f == 0) { break; }\n      ans += f;\n      end = false;\n    }\n    if (end) { break; }\n  }\n  return ans;\n}\n\nint maxFlow(const Graph &g, int s, int t) {\n  const int n = g.size();\n  Matrix capacity(n, Array(n, 0));\n  for (int i = 0; i < n; i++) {\n    for (Edges::const_iterator it = g[i].begin(); it != g[i].end(); it++) {\n      capacity[it->src][it->dest] = it->weight;\n    }\n  }\n  int ret = 0;\n  vector<int> parent(n);\n  while (true) {\n    fill(parent.begin(), parent.end(), -1);\n    priority_queue<Edge> que;\n    que.push(Edge(s, s, 0));\n    while (!que.empty()) {\n      Edge node = que.top();\n      que.pop();\n      if (parent[node.dest]) { continue; }\n      parent[node.dest] = node.src;\n      if (node.dest == t) { break; }\n      int from = node.dest;\n      for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n        int to = it->dest;\n        if (capacity[from][to] == 0 || parent[to] != -1) { continue; }\n        que.push(Edge(from, to, 0));\n      }\n    }\n    if (parent[t] == -1) { break; }\n    Weight flow = 2000000000;\n    int from = parent[t];\n    int to = t;\n    while (from != to) {\n      flow = min(flow, capacity[from][to]);\n      from = parent[from];\n      to = parent[to];\n    }\n    from = parent[t];\n    to = t;\n    while (from != to) {\n      capacity[from][to] -= flow;\n      capacity[to][from] += flow;\n      from = parent[from];\n      to = parent[to];\n    }\n    ret += flow;\n  }\n  return ret;\n}\n\n\n\nint gcd(int a, int b) {\n  if (b == 0) { return a; }\n  return gcd(b, a % b);\n}\n\nint m, n;\nint blue[501];\nint red[501];\n\nint BLUE(int x) { return x; }\nint RED(int x) { return m + x; }\nint SOURCE() { return m + n; }\nint DEST() { return m + n + 1; }\nint SIZE() { return m + n + 2; }\n\nint main() {\n  while (scanf(\"%d %d\", &m, &n), m|n) {\n    Graph g(SIZE());\n    REP(b, m) {\n      scanf(\"%d\", &blue[b]);\n      g[SOURCE()].push_back(Edge(SOURCE(), BLUE(b), 1));\n      g[BLUE(b)].push_back(Edge(BLUE(b), SOURCE(), 0));\n    }\n    REP(r, n) {\n      scanf(\"%d\", &red[r]);\n      g[RED(r)].push_back(Edge(RED(r), DEST(), 1));\n      g[DEST()].push_back(Edge(DEST(), RED(r), 0));\n    }\n    REP(b, m) {\n      REP(r, n) {\n        if (gcd(blue[b], red[r]) != 1) {\n          g[BLUE(b)].push_back(Edge(BLUE(b), RED(r), 1));\n          g[RED(r)].push_back(Edge(RED(r), BLUE(b), 0));\n        }\n      }\n    }\n    assert(MaxFlow(g, SOURCE(), DEST() == maxFlow(g, SOURCE(), DEST());\n    int ans = MaxFlow(g, SOURCE(), DEST());\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n\tint to, cap, rev;\n};\n\n#define INF 1e9\n\nbool used[1000];\nint dist[1000];\nvector< vector<Edge> > G;\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back( (Edge){to, cap, G[to].size()} );\n\tG[to].push_back( (Edge){from, 0, G[from].size()-1} );\n}\nvoid bfs(int s, int t, int step) {\n\tfill(dist, dist+1000, -1);\n\tdist[s] = 0;\n\n\tqueue<int> Q; Q.push(s);\n\twhile ( !Q.empty() ) {\n\t\tint v = Q.front(); Q.pop();\n\t\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\t\tEdge& e = G[v][i];\n\t\t\tif ( dist[e.to] < 0 && e.cap > 0 ) {\n\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\tQ.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int s, int t, int f) {\n\tif (s == t) return f;\n\tfor (int i = 0; i < G[s].size(); ++i) {\n\t\tEdge& e = G[s][i];\n\t\tif ( dist[e.to] > dist[s] && e.cap > 0 ) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t) {\n\tint res = 0;\n\twhile (1) {\n\t\tbfs(s, t, 0);\n\t\tif (dist[t] < 0) break;\n\t\tint f;\n\t\twhile ( (f = dfs(s, t, INF)) > 0 ) {\n\t\t\tres += f;\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int a, int b) {\n\treturn b == 0 ? a : gcd(b, a%b);\n}\n\nint main() {\n\tint M, N;\n\twhile ( cin >> M >> N, M || N ) {\n\t\tvector<int> v1(M), v2(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tcin >> v1[i];\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> v2[i];\n\t\t}\n\t\tint s = M+N, t = M+N+1;\n\t\tG.clear(); G.resize(t+1);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (gcd(v1[i], v2[j]) > 1) {\n\t\t\t\t\tadd_edge(i, M+j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tadd_edge(s, i, 1);\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tadd_edge(M+i, t, 1);\n\t\t}\n\t\tcout << max_flow(s, t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n \nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return abs(a);\n\telse return gcd(b, a % b);\n}\n\nstruct flow_network {\n\tint n;\n\tstruct edge { int v; ll c; int rev; };\n\tvector< vector<edge> > G;\n\tflow_network(int _n) : n(_n), G(_n) {}\n\tvoid add_edge(int u, int v, ll c) {\n\t\tedge e = {v, c, (int)G[v].size()}, _e = {u, 0, (int)G[u].size()};\n\t\tG[u].push_back(e); G[v].push_back(_e);\n\t}\n\tll dfs(int u, int t, ll f, vector<bool>& vis) {\n\t\tif (u == t) return f;\n\t\tvis[u] = true;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge& e = G[u][i];\n\t\t\tif (vis[e.v] || e.c == 0) continue;\n\t\t\tll d = min(e.c, dfs(e.v, t, min(f, e.c), vis));\n\t\t\tif (d == 0) continue;\n\t\t\te.c -= d;\n\t\t\tG[e.v][e.rev].c += d;\n\t\t\treturn d;\n\t\t}\n\t\treturn 0;\n\t}\n\tll max_flow(int s, int t) {\n\t\tll res = 0;\n\t\tfor (;;) {\n\t\t\tvector<bool> vis(n);\n\t\t\tll f = dfs(s, t, LLONG_MAX, vis);\n\t\t\tif (f == 0) return res;\n\t\t\tres += f;\n\t\t}\n\t}\n};\n\nint main() {\n\tfor (;;) {\n\t\tint n, m; cin >> n >> m;\n\t\tif (n == 0 && m == 0) break;\n\t\tvector<int> a(n), b(m);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcin >> a[i];\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tcin >> b[j];\n\t\tflow_network fn(n + m + 2);\n\t\tint s = n + m, t = n + m + 1;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfn.add_edge(s, i, 1);\n\t\tfor (int j = 0; j < m; j++)\n\t\t\tfn.add_edge(n + j, t, 1);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tif (gcd(a[i], b[j]) != 1)\n\t\t\t\t\tfn.add_edge(i, n + j, 1);\n\t\tcout << fn.max_flow(s, t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\ntemplate<int NN> class BipartiteMatch\n{\n\tpublic:\n\tBipartiteMatch()\n\t{\n\t\tmemset(matchedTo, -1, sizeof(matchedTo));\n\t}\n\tvector<int> edge[NN];\n\tvoid add(int a, int b)\n\t{\n\t\tedge[a].push_back(b);\n\t\tedge[b].push_back(a);\n\t\t//cout << a << \", \" << b << endl;\n\t}\n\tint matchedTo[NN];\n\tbool augment(int s)\n\t{\n\t\tmemset(visited, 0, sizeof(visited));\n\t\treturn aug(s);\n\t}\n\tbool visited[NN];\n\tprivate:\n\tbool aug(int s)\n\t{\n\t\tif(s<0){\n\t\t\treturn true;\n\t\t}\n\t\tfor(int i=0;i<edge[s].size();i++){\n\t\t\tint t=edge[s][i];\n\t\t\tif(!visited[t]){\n\t\t\t\tvisited[t]=true;\n\t\t\t\tif (aug(matchedTo[t])){\n\t\t\t\t\tmatchedTo[t]=s;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint gcd(int a,int b){\n\twhile(b){\n\t\tint r=a%b;\n\t\ta=b;\n\t\tb=r;\n\t}\n\treturn a;\n}\nint m,n;\nint b[500];\nint r[500];\nint main() {\n\twhile(1){\n\tcin >> m >> n;\n\tif(m==0&&n==0)return 0;\n\tBipartiteMatch<1000> bm;\n\tfor(int i=0;i<m;i++){\n\t\tcin >> b[i];\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcin >> r[i];\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(gcd(r[i],b[j])>1){\n\t\t\t\tbm.add(i+m,j);\n\t\t\t}\n\t\t}\n\t}\n\tint ret=0;\n\tfor(int i=0;i<m;i++){\n\t\tif(bm.augment(i)){\n\t\t\tret++;\n\t\t}\n\t}\n\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <cmath>\n#include <map>\n#include <cstring>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for (int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define Cout(obj) cout << obj << endl\n#define Size(obj) (int)(obj).size()\n#define fcout cout << fixed << setprecision(10)\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nconst int MaxV = 10000;\n\nvector<int> graph[MaxV];\nint match[MaxV];\nbool used[MaxV];\n\nvoid addEdge(int u, int v)\n{\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n}\n\nbool dfs(int v)\n{\n    used[v] = true;\n\n    for (auto &e : graph[v])\n    {\n        int u = e, w = match[u];\n\n        if (w < 0 || !used[w] && dfs(w))\n        {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint bipartiteMatcing()\n{\n    int res = 0;\n\n    memset(match, -1, sizeof(match));\n\n    REP(v, MaxV)\n    {\n        if (match[v] < 0)\n        {\n            memset(used, 0, sizeof(used));\n\n            if (dfs(v))\n            {\n                res++;\n            }\n        }\n    }\n\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int M, N;\n    while(cin >> M >> N && M)\n    {\n        vector<int> B(M), R(N);\n\n        REP(i, 1010)\n        {\n            graph[i].clear();\n            match[i] = 0;\n            used[i] = false;\n        }\n\n        REP(i, M)\n        {\n            cin >> B[i];\n        }\n\n        REP(i, N)\n        {\n            cin >> R[i];\n        }\n\n        REP(i, M)\n        {\n            REP(j, N)\n            {\n                if(max(B[i], R[j]) % min(B[i], R[j]) == 0)\n                {\n                    addEdge(i, j + M);\n                }   \n            }\n        }\n\n         Cout(bipartiteMatcing());\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nstruct edge\n{\n  int to;\n  int from;\n  int cap;\n  int rev;\n};\n\nint s=0, t;\nbool visited[1010];\nvector<edge> g[1010];\nint red_card[510], blue_card[510];\n\nint max_flow();\nint get_card();\nvoid print_g();\nint dfs(int node, int f);\n\nvoid clear()\n{\n  for(int i=0;i<1000;i++)\n    {\n      g[i].clear();\n    }\n}\n\nint main()\n{\n  while(true)\n    {\n      clear();\n      if(get_card()==-1)\n\t{\n\t  break;\n\t}\n  cout << max_flow() << endl;\n  //print_g();\n    }\n  return 0;\n}\n  \nvoid print_g()\n{\n  for(int i=0;i<=t;i++)\n    {\n      for(int j=0;j<g[i].size();j++)\n\t{\n\t  if(g[i][j].cap!=0)\n\t    {\n\t  cout << \"{\" << g[i][j].from << g[i][j].to << g[i][j].cap << g[i][j].rev << \"}\";\n\t    }\n\t}\n      cout << endl;\n    }\n}\n\nint max_flow()\n{\n  int sum = 0, f=0;\n  \n  while(1)\n    {\n      fill(visited ,visited+1010, false);\n      f = dfs(s, INT_MAX/3);\n      \n      if(f==0)\n\t{\n\t  break;\n\t}\n      sum += f;\n    }\n  return sum;\n}\n\n\nint dfs(int node, int f)\n{\n  //  cout << \"node:\" <<node << \" f:\" << f;\n  int d = 0;\n \n  if(node == t)//goal\n    {\n      //  cout <<\"f:\"<< f << endl;\n      return f;\n    }\n  else if(visited[node]==true)// if visited\n    {\n      return -1;\n    }\n  else\n    {\n      visited[node]=true;//visited\n    }\n\n  for(int i=0;i<g[node].size();i++)//root form node\n    {\n      edge& e = g[node][i];\n      // cout <<\" e,to:\"  <<e.to <<endl;\n      if(e.cap != 0)\n\t{\n\t  d = dfs(e.to, min(f, e.cap));\n\t  /*if(dfs(g[node][i].to, f) == 1)\n\t    {\n\t    return 1;\n\t    }*/\n\t  //   cout << \"node:\" << node << \" f:\" << f << \" d:\" << d << endl;      \n\t  if(d>0)\n\t    {\n\t      e.cap -= d;\n\t      g[e.to][e.rev].cap += d;\n\t      \n\t      return d;\n\t    }\n\t}\n\n    }\n  return 0;\n}\n\n\nvoid add_edge(int i, int j)\n{\n  g[i].push_back({j, i, 1, (int)g[j].size()});\n  g[j].push_back({i, j, 0, (int)g[i].size()-1});\n}\n\nint get_card()\n{\n  int red, blue;\n  cin >> blue >> red;\n  if(blue == 0)\n    {\n      return -1;\n    }\n  for(int i=0;i<blue;i++)\n    {\n      cin >> blue_card[i];\n    }\n  for(int i=0;i<red;i++)\n    {\n      cin >> red_card[i];\n    }\n  \n  \n  for(int i=0;i<blue;i++)\n    {\n      for(int j=0;j<red;j++)\n\t{\n\t  if(__gcd(blue_card[i], red_card[j])!=1)\n\t    {// to from cap rev\n\t      add_edge(i+1, j+blue+1);\n\t    }\n\t}\n    }\n\n   for(int i=1;i<=blue;i++)\n    {\n      add_edge(0, i);\n    }\n\n   t = blue+red+1;\n   for(int i=blue+1;i<t;i++)\n     {\n       add_edge(i, t);\n     }\n\n     for(int i=0;i<=t;i++)\n    {\n      for(int j=0;j<g[i].size();j++)\n\t{\n\t  cout << \"{\" << g[i][j].from << g[i][j].to << g[i][j].cap << g[i][j].rev << \"}\";\n\t}\n      cout << endl;\n    }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nstruct edge\n{\n  int to;\n  int from;\n  int cap;\n  int rev;\n};\n\nint s=0, t;\nbool visited[1010];\nvector<edge> g[1010];\nint red_card[510], blue_card[510];\n\nint max_flow();\nint get_card();\nvoid print_g();\nint dfs(int node, int f);\n\nvoid clear()\n{\n  for(int i=0;i<1000;i++)\n    {\n      g[i].clear();\n    }\n}\n\nint main()\n{\n  while(true)\n    {\n      clear();\n      if(get_card()==-1)\n\t{\n\t  break;\n\t}\n  cout << max_flow() << endl;\n  //print_g();\n    }\n  return 0;\n}\n  \nvoid print_g()\n{\n  for(int i=0;i<=t;i++)\n    {\n      for(int j=0;j<g[i].size();j++)\n\t{\n\t  if(g[i][j].cap!=0)\n\t    {\n\t  cout << \"{\" << g[i][j].from << g[i][j].to << g[i][j].cap << g[i][j].rev << \"}\";\n\t    }\n\t}\n      cout << endl;\n    }\n}\n\nint max_flow()\n{\n  int sum = 0, f=0;\n  \n  while(1)\n    {\n      fill(visited ,visited+1010, false);\n      f = dfs(s, INT_MAX/3);\n      \n      if(f==0)\n\t{\n\t  break;\n\t}\n      sum += f;\n    }\n  return sum;\n}\n\n\nint dfs(int node, int f)\n{\n  //  cout << \"node:\" <<node << \" f:\" << f;\n  int d = 0;\n \n  if(node == t)//goal\n    {\n      //  cout <<\"f:\"<< f << endl;\n      return f;\n    }\n  else if(visited[node]==true)// if visited\n    {\n      return -1;\n    }\n  else\n    {\n      visited[node]=true;//visited\n    }\n\n  for(int i=0;i<g[node].size();i++)//root form node\n    {\n      edge& e = g[node][i];\n      // cout <<\" e,to:\"  <<e.to <<endl;\n      if(e.cap != 0)\n\t{\n\t  d = dfs(e.to, min(f, e.cap));\n\t  /*if(dfs(g[node][i].to, f) == 1)\n\t    {\n\t    return 1;\n\t    }*/\n\t  //   cout << \"node:\" << node << \" f:\" << f << \" d:\" << d << endl;      \n\t  if(d>0)\n\t    {\n\t      e.cap -= d;\n\t      g[e.to][e.rev].cap += d;\n\t      \n\t      return d;\n\t    }\n\t}\n\n    }\n  return 0;\n}\n\n\nvoid add_edge(int i, int j)\n{\n  g[i].push_back({j, i, 1, (int)g[j].size()});\n  g[j].push_back({i, j, 0, (int)g[i].size()-1});\n}\n\nint get_card()\n{\n  int red, blue;\n  cin >> blue >> red;\n  if(blue == 0)\n    {\n      return -1;\n    }\n  for(int i=0;i<blue;i++)\n    {\n      cin >> blue_card[i];\n    }\n  for(int i=0;i<red;i++)\n    {\n      cin >> red_card[i];\n    }\n  \n  \n  for(int i=0;i<blue;i++)\n    {\n      for(int j=0;j<red;j++)\n\t{\n\t  if(__gcd(blue_card[i], red_card[j])!=1)\n\t    {// to from cap rev\n\t      add_edge(i+1, j+blue+1);\n\t    }\n\t}\n    }\n\n   for(int i=1;i<=blue;i++)\n    {\n      add_edge(0, i);\n    }\n\n   t = blue+red+1;\n   for(int i=blue+1;i<t;i++)\n     {\n       add_edge(i, t);\n     }\n\n   /*     for(int i=0;i<=t;i++)\n    {\n      for(int j=0;j<g[i].size();j++)\n\t{\n\t  cout << \"{\" << g[i][j].from << g[i][j].to << g[i][j].cap << g[i][j].rev << \"}\";\n\t}\n      cout << endl;\n      }*/\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n#define MAX_V 1000010\n\nstruct Edge\n{\n\tint to, cap, rev;\n\tEdge(){};\n\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev){};\n};\n\nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back({to, cap, (int)G[to].size()});\n\tG[to].push_back({from, 0, (int)G[from].size()-1});\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tEdge& e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){//O(FE);\n\tint flow = 0;\n\twhile(1){\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, INF);\n\t\tif(f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m && n && m) {\n\t\tfor(int i = 0; i < MAX_V; i++) G[i].clear(), used[i] = false;\n\t\tvector<int> b(n), r(m);\n\t\trep(i, n) cin >> b[i];\n\t\trep(i, m) cin >> r[i];\n\t\tset<int> bst[510], rst[510];\n\t\trep(i, n) {\n\t\t\tfor(int j = 2; (ll)(j*j) <= b[i]; j++){\n\t\t\t\tif(b[i]%j == 0) bst[i].insert(j);\n\t\t\t\twhile(b[i]%j == 0) b[i] /= j;\n\t\t\t}\n\t\t\tif(b[i] != 1) bst[i].insert(b[i]);\n\t\t}\n\t\trep(i, m) {\n\t\t\tfor(int j = 2; (ll)(j*j) <= r[i]; j++){\n\t\t\t\tif(r[i]%j == 0) rst[i].insert(j);\n\t\t\t\twhile(r[i]%j == 0) r[i] /= j;\n\t\t\t}\n\t\t\tif(r[i] != 1) rst[i].insert(r[i]);\n\t\t}\n\t\tint s = n + m, t = n + m + 1;\n\t\trep(i, n) add_edge(s, i, 1);\n\t\trep(i, m) add_edge(n + i, t, 1); \n\t\trep(i, n) rep(j, m) {\n\t\t\tfor(auto& p : bst[i]) {\n\t\t\t\tif(rst[j].count(p)) {\n\t\t\t\t\tadd_edge(i, n + j, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << max_flow(s, t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint m, n;\nint P[510];\nbool V[510], C[510][510];\n\nint gcd(int a, int b){\n  if(a < b) swap(a, b);\n  if(b == 0) return a;\n  return gcd(b, a % b);\n}\n\nbool match(int b){\n  if(b < 0) return true;\n  for(int i=0; i<n; ++i){\n    if(!C[b][i] || V[i]) continue;\n    V[i] = true;\n    if(match(P[i])) {\n      P[i] = b;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int blue[510], red[510];\n  //  cout << gcd(6, 15);\n  while(cin >> m >> n){\n    for(int i=0; i<m; ++i){\n      cin >> blue[i];\n    }\n    for(int i=0; i<n; ++i){\n      cin >> red[i];\n      P[i] = -1;\n    }\n\n    for(int i=0; i<m; ++i){\n      for(int j=0; j<n; ++j){\n\tC[i][j] = (gcd(blue[i], red[j]) >= 2);\n\t//\tcout << C[i][j] << \" \";\n      }\n      // cout << endl;\n    }\n\n    int count = 0;\n\n    for(int i=0; i<m; ++i){\n      for(int j=0; j<n; ++j){\n\tV[j] = 0;\n      }\n      if(match(i)) count++;\n      for(int i=0; i<n; ++i){\n\t//cout << P[i] << \" \";\n      }\n      // cout << endl;\n    }\n    cout << count << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct Dinic {\n    int n, s, t;\n    vector<int> level, iter, que;\n    vector<vector<Capacity>> cap, flow;\n    vector<vector<int>> g;\n    Capacity inf;\n    Dinic(int n)\n        : n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n          g(n, vector<int>()), inf(numeric_limits<Capacity>::max()/8){}\n    Dinic(const Graph &graph){\n        *this = Dinic(graph.size());\n        rep(i,n) for(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n    }\n    void addEdge(int u, int v, Capacity c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    inline Capacity residue(int u, int v){ return cap[u][v] - flow[u][v]; }\n    Capacity solve(int s, int t){\n        this->t = t, this->s = s;\n        Capacity res = 0, aug = 1;\n        while(aug > 0){\n            levelize();\n            iter.assign(n, 0);\n            res += (aug = augment(s, inf));\n        }\n        return res;\n    }\n    void levelize(){\n        level.assign(n, inf); level[s] = 0;\n        int l = 0, r = 0;\n        que.assign(n+1, 0);\n        que[r++] = s;\n        while(l != r){\n            int v = que[l++];\n            for(const int &d : g[v]){\n                if(level[d] <= level[v] + 1 || residue(v,d) == 0) continue;\n                level[d] = level[v] + 1; que[r++] = d;\n            }\n        }\n    }\n    Capacity augment(int v, Capacity lim){\n        Capacity res = 0;\n        if(v == t) return lim;\n        for(int &i = iter[v]; i < (int)g[v].size(); i++){\n            const int &d = g[v][i];\n            if(residue(v,d) == 0 || level[v] + 1 != level[d]) continue;\n            const Capacity aug = augment(d, min(lim, residue(v,d)));\n            if(aug > 0){\n                flow[v][d] += aug; flow[d][v] -= aug;\n                res += aug; lim -= aug;\n                if(lim == 0) return res;\n            }\n        }\n        return res;\n    }\n};\n\nint dp[500][500];\nint gcd(int a, int b){\n    return a < 500 && b < 500 ? dp[a][b] : b == 0 ? a : gcd(b, a%b);\n}\n\n\nint main(){\n    rep(i,500)rep(j,i+1) dp[i][j] = dp[j][i] = __gcd(i,j);\n    fastios();\n    int n,m;\n    while(cin >> n >> m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        Dinic d(n+m+2);\n        int s = n+m, t = n+m+1;\n        rep(i,m) d.addEdge(i+n,t,1);\n        rep(i,n){\n            d.addEdge(s,i,1);\n            rep(j,m) if(gcd(a[i],b[j]) != 1) d.addEdge(i,n+j,1);\n        }\n        rep(i,n)rep(j,m){\n            if(d.flow[i][j+n]) dump(i,j, d.flow[i][j+m]);\n        }\n        cout << d.solve(s,t) << endl;\n    }\n}\n\n// int main(){\n//     int N,M;\n//     cin >> N >> M;\n//     Graph g(N);\n//     rep(i,M){\n//         int a,b,c;\n//         cin >> a >> b >> c;\n//         g[a].emplace_back(a,b,c);\n//     }\n//     Dinic dinic(g);\n//     cout << dinic.solve(0,N-1) << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n//Class.\nvector<int> list[100000];\nint N, M, E;\nint match[100000];\nbool used[100000];\nint x[10000], y[10000];\n\nbool DFS(int V) {\n\tused[V] = true;\n\tfor (int i = 0; i < list[V].size(); i++) {\n\t\tint u = list[V][i]; int w = match[u];\n\t\tif (w < 0 || !used[w] && DFS(w)) {\n\t\t\tmatch[V] = u;\n\t\t\tmatch[u] = V;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint supermatching() {\n\tint r = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int j = 0; j < N + M; j++) {\n\t\tif (match[j] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (DFS(j)) { r++; }\n\t\t}\n\t}\n\treturn r;\n}\n\n//main.\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 100000; i++) { list[i].clear(); }\n\t\tcin >> N >> M;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i];\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> y[i];\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (__gcd(x[i], y[j]) != 1) {\n\t\t\t\t\tlist[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << supermatching() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint m, n;\nint blue[505];\nint red[505];\n\nbool bluematch[505];\nint redpair[30];\n\nint path[505][505];\n\nint gcd(int a, int b)\n{\n    int m;\n    \n    while(1){\n        m = a%b;\n        if(m==0)\n            return b;\n        a = b;\n        b = m;\n    }\n    return 1;\n}\n\nbool match(int x){\n    if(x<0) return true;\n    \n    if(bluematch[x]){\n        return false;\n    }\n    bluematch[x]=true;\n    \n    for(int y=0; y<n; y++){\n        if(!path[x][y]) continue;\n        if(match(redpair[y])){\n            redpair[y]=x;\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    \n    int i, j, cnt;\n    while(1){\n        cin >> m >> n;\n        if(m==0 || n==0)\n            return 0;\n        \n        for(i=0;i<m;i++){\n            cin >> blue[i];\n        }\n        \n        for(i=0;i<n;i++){\n            cin >> red[i];\n        }\n        \n        for(i=0; i<m; i++){\n            for(j=0; j<n; j++){\n                if(gcd(blue[i],red[j])!=1){\n                    path[i][j]=1;\n                }\n                else{\n                    path[i][j]=0;\n                }\n            }\n        }\n        \n        fill(redpair, redpair+n, -1);\n        cnt=0;\n        for(i=0; i<m; i++){\n            fill(bluematch, bluematch+m, 0);\n            if(match(i)){\n                cnt++;\n            }\n        }\n        cout << cnt << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\nconst int INF = 1000000000;\n\ntypedef pair<int,int> pii;\n\nclass Edge{\n\tpublic:\n\tint a,b,c,f;\n\tEdge(int a,int b,int c,int f):a(a),b(b),c(c),f(f){}\n};\n\nclass Flow{\n\tpublic:\n\tstatic const int N = 1111;\n\tstatic const int INF = 1000000000;\n\t\n\tvector<Edge> e[N];\n\tvector<pii> r[N];\n\t\n\tvoid addEdge(int a,int b,int c){\n\t\te[a].push_back(Edge(a,b,c,0));\n\t\tr[b].push_back(pii(a,e[a].size()-1));\n\t}\n\tint visit[N];\n\tint flow(int p, int f, int end){\n\t\tif(p==end)return f;\n\t\tif(visit[p]==1)return 0;\n\t\tvisit[p]=1;\n\t\t\n\t\trep(i,e[p].size()){\n\t\t\tint d = e[p][i].c - e[p][i].f;\n\t\t\tif(d > 0){\n\t\t\t\tint val = flow(e[p][i].b, min(f,d), end);\n\t\t\t\tif(val!=0){\n\t\t\t\t\te[p][i].f += val;\n\t\t\t\t\treturn val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,r[p].size()){\n\t\t\tint r1 = r[p][i].first;\n\t\t\tint r2 = r[p][i].second;\n\t\t\tint d = e[r1][r2].f;\n\t\t\tif(d > 0){\n\t\t\t\tint val = flow(e[r1][r2].a, min(f,d), end);\n\t\t\t\tif(val!=0){\n\t\t\t\t\te[r1][r2].f -= val;\n\t\t\t\t\treturn val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint solve(int start, int end){\n\t\tint ans = 0;\n\t\twhile(1){\n\t\t\trep(i,N)visit[i]=0;\n\t\t\tint val = flow(start, INF, end);\n\t\t\tif(val==0)break;\n\t\t\tans += val;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nconst int S = 1111111;\nint sosu[S];\nvector<int> prime;\nint sosuInit(){\n\tsosu[0]=sosu[1]=1;\n\trep(i,S){\n\t\tif(sosu[i]==1)continue;\n\t\tfor(int j=i*2;j<S;j+=i)sosu[j]=1;\n\t\tprime.push_back(i);\n\t}\n}\n\nvector<int> canop[S];\n\nint main(){\n\tsosuInit();\n\t\n\tA:;\n\t\n\trep(i,S)canop[i].clear();\n\t\n\tint n,m;\n\tcin>>n>>m;\n\t\n\tif(n==0 && m==0)return 0;\n\t\n\tFlow flow;\n\t\n\trep(i,n){\n\t\tint a;\n\t\tcin>>a;\n\t\trep(j,prime.size()){\n\t\t\tif(a%prime[j]==0){\n\t\t\t\tcanop[prime[j]].push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tflow.addEdge(0,i+1,1);\n\t}\n\t\n\trep(i,m){\n\t\tint b;\n\t\tcin>>b;\n\t\trep(j,prime.size()){\n\t\t\tif(b%prime[j]==0){\n\t\t\t\trep(k,canop[prime[j]].size()){\n\t\t\t\t\tflow.addEdge(canop[prime[j]][k], i+n+1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tflow.addEdge(i+n+1, n+m+1, 1);\n\t}\n\t\n\tint ans = flow.solve(0, n+m+1);\n\tprintf(\"%d\\n\",ans);\n\t\n\tgoto A;\n}\n/*\n\n4 3\n2 6 6 15\n2 3 5\n0 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint m,n,b[501],r[501];\nvector<int> G[1000];\nint match[1000];\nbool used[1000];\n\nbool dfs(int v){\n\tused[v]=1;\n\trep(i,G[v].size()){\n\t\tint u=G[v][i],w=match[u];\n\t\tif(w<0||!used[w]&&dfs(w)){\n\t\t\tmatch[v]=u,match[u]=v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid solve(){\n\trep(i,n) cin>>b[i];\n\trep(i,m) cin>>r[i];\n\trep(i,1000)G[i].clear();\n\trep(i,n) rep(j,m){\n\t\tint a=b[i],c=r[j];\n\t\twhile(c){\n\t\t\ta%=c;\n\t\t\tswap(a,c);\n\t\t}\n\t\tif(a!=1)G[i].push_back(j+n),G[n+j].push_back(i);\n\t}\n\tint res=0;\n\tmemset(match,-1,sizeof(match));\n\trep(v,m+n){\n\t\tif(match[v]<0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)) res++;\n\t\t}\n\t}\n\tcout<<res<<endl;\n}\n\nint main(){\n\twhile(cin>>n>>m,n||m)solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\n#define MAX_V 1111\nstruct edge {\n  int to,cap,rev;\n};\nconst int inf = 1<<21;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int f,int t,int cap)\n{\n  G[f].push_back((edge){t,cap,(int)G[t].size()});\n  G[t].push_back((edge){f,0,(int)G[f].size()-1});\n}\n\n void bfs(int s)\n{\n  memset(level,-1,sizeof(level));\n  queue<int> q;\n  level[s] = 0;\n  q.push(s);\n  while( !q.empty() ) {\n    int v = q.front(); q.pop();\n    for( int i = 0; i < int(G[v].size()); i++ ) {\n      edge& e = G[v][i];\n      if( e.cap > 0 && level[e.to] < 0 ) {\n        level[e.to] = level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f)\n{\n  if( v == t ) return f;\n  for( int &i = iter[v]; i < int(G[v].size()); i++ ) {\n    edge& e = G[v][i];\n    if( e.cap > 0 && level[v] < level[e.to] ) {\n      int d  = dfs(e.to,t,min(f,e.cap));\n      if( d > 0 ) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t)\n{\n  int flow = 0;\n  for(;;) {\n    bfs(s);\n    if( level[t] < 0 ) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while( (f = dfs(s,t,inf)) > 0 ) {\n      flow += f;\n    }\n  }\n}\n\nint main(void)\n{\n  int m,n;\n  int a[555],b[555];\n  for(;;) {\n    scanf(\"%d%d\",&m,&n); if( m+n == 0 ) break;\n    for( int i = 0; i < m+n+2; i++ ) G[i].clear();\n    for( int i = 0; i < m; i++ ) scanf(\"%d\", a+i);\n    for( int i = 0; i < n; i++ ) scanf(\"%d\", b+i);\n    for( int i = 0; i < m; i++ ) {\n      add_edge(0,i+1,1);\n    }\n    for( int i = 0; i < m; i++ ) {\n      for( int j = 0; j < n; j++ ) {\n        if( __gcd(a[i],b[j]) != 1 ) {\n          add_edge(i+1,n+1+j,1);\n        }\n      }\n    }\n    for( int i = 0; i < n; i++ ) {\n      add_edge(n+1+i,n+m+1,1);\n    }\n    printf(\"%d\\n\",max_flow(0,n+m+1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long Int;\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst) :\n    src(src), dst(dst) { }\n    Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nbool augment(const Graph& g, int u,\n             vector<int>& matchTo, vector<bool>& visited) {\n    if (u < 0) return true;\n    FOR(e, g[u]) if (!visited[e->dst]) {\n        visited[e->dst] = true;\n        if (augment(g, matchTo[e->dst], matchTo, visited)) {\n            matchTo[e->src] = e->dst;\n            matchTo[e->dst] = e->src;\n            return true;\n        }\n    }\n    return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n    const int n = g.size();\n    vector<int> matchTo(n, -1);\n    int match = 0;\n    REP(u, L) {\n        vector<bool> visited(n);\n        if (augment(g, u, matchTo, visited)) ++match;\n    }\n    REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n        matching.push_back( Edge(u, matchTo[u]) );\n    return match;\n}\n\nInt gcd(Int a, Int b) {\n    return b != 0 ? gcd(b, a % b) : a;\n}\nInt lcm(Int a, Int b) {\n    return a * b / gcd(a, b);\n}\n\nint main(){\n    while (true) {\n        int m, n, b[510], r[510];\n        cin >> m >> n;\n        if (!n) break;\n\n        Graph g(m + n);\n\n        REP(i, m){\n            cin >> b[i];\n        }\n        REP(i, n){\n            cin >> r[i];\n            REP(j, m){\n                if (gcd(b[j], r[i]) > 1) {\n                    g[j].push_back(Edge(j, m + i));\n                    g[m + i].push_back(Edge(m + i, j));\n                }\n            }\n        }\n        Edges match;\n        cout << bipartiteMatching(g, m, match) << \"\\n\";\n\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nconst int MAX = 501;\nconst int INF = 1<<28;\n#define gcd(a,b) __gcd(a,b)\n\nstruct edge{ int to, cap, rev;};\n\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to ,cap ,G[to].size()});\n  G[to].push_back((edge){from ,0 ,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0 ; i < G[v].size() ; i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n\n  for(;;){\n    memset(used,false,sizeof(used));\n    int f = dfs(s,t,INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main(){\n  int m,n,b,r;\n  \n  while(cin >> m >> n , m + n){\n    vector<int> B,R;\n    int s = m+n,t = s+1;\n    memset(G,0,sizeof(G));\n    for(int i = 0 ; i < m ; i++){\n      cin >> b;\n      B.push_back(b);\n      add_edge(s,i,1);\n    }\n\n    for(int j = 0 ; j < n ; j++){\n      cin >> r;\n      R.push_back(r);\n      add_edge(m+j,t,1);\n    }\n \n    for(int i = 0 ; i < m ; i++){\n      for(int j = 0 ; j < n ; j++){\n\tif(gcd(B[i],R[j]) != 1){\n\t  add_edge(i,m+j,1);\n\t}\n      }\n    }\n    cout << max_flow(s,t) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <complex>\nusing namespace std;\ntypedef complex<double> P;\n\n#define EPS (1e-10)\n#define REP(i,n) for(int i = 0; i < (int)(n); i++)\n#define FOR(it,c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\n\ntypedef double Weight;\nconst Weight WEIGHT_INFTY = numeric_limits<Weight>::max() / 4;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n\t\tEdge(int a,int b){\n\t\t\tsrc = a;\n\t\t\tdst = b;\n\t\t}\n};\nbool operator<(const Edge& a, const Edge& b) {\n    return (a.weight < b.weight);\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\n \nint gcd(int x,int y){\n\treturn y ? gcd(y,x%y) : x ;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tvector<int> l,r;\n\t\tGraph g;\n\t\tREP(i,n){ int a; cin>>a; l.push_back(a); }\n\t\tREP(i,m){ int a; cin>>a; r.push_back(a); }\n\t\t\n\t\tREP(i,l.size()){\n\t\t\tvector<Edge> node;\n\t\t\tREP(j,r.size())if( gcd(l[i],r[j])>1 ){\n\t\t\t\tnode.push_back( Edge(i,j+n) );\n\t\t\t}\n\t\t\tg.push_back( node );\n\t\t}\n\t\tREP(i,r.size()){\n\t\t\tvector<Edge> node;\n\t\t\tREP(j,l.size())if(gcd(r[i],l[j])>1){\n\t\t\t\tnode.push_back( Edge(i+n,j) );\n\t\t\t}\n\t\t\tg.push_back( node );\n\t\t}\n\t\t/*\n\t\tREP(i,g.size()){\n\t\t\tREP(j,g[i].size()){\n\t\t\t\tprintf(\"%d:(%d,%d)\\n\",i,g[i][j].src,g[i][j].dst);\n\t\t\t}\n\t\t}*/\n\t\tEdges ed;\n\t\tint ret = bipartiteMatching(g, n, ed);\n\t\t/*\n\t\tREP(i,ed.size()){\n\t\t\tprintf(\"%d -> %d\\n\",ed[i].src,ed[i].dst);\n\t\t}\n\t\t*/\n\t\tprintf(\"%d\\n\",ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\nconst int MAXV = 2005;\nconst int MAXE = MAXV * MAXV;\nconst int INF = 1<<29;\n\nstruct BiparateMatching {\n    int N, M, E, match[MAXV+1], dist[MAXV+1];\n    int last[MAXE], prev[MAXE], to[MAXE];\n    BiparateMatching(int n, int m) : N(n), M(m), E(0) {\n        memset(last, -1, sizeof(last));\n    }\n    void add_edge(int x, int y) { // x \\in [0, N), y \\in [0, M)\n        to[E] = y + N; prev[E] = last[x]; last[x] = E; E++;\n    }\n    bool bfs() {\n        queue<int> q;\n        for (int i=0; i<N; ++i) {\n            if (match[i] == -1) {\n                q.push(i); dist[i] = 0;\n            } else dist[i] = INF;\n        }\n\n        bool ret = false;\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for (int e = last[v]; e != -1; e = prev[e]) {\n                if (match[to[e]] == -1) ret = true;\n                else if (dist[match[to[e]]] == INF) {\n                    dist[match[to[e]]] = dist[v] + 1;\n                    q.push(match[to[e]]);\n                }\n            }\n        }\n        return ret;\n    }\n    bool dfs(int v) {\n        for (int e = last[v]; e != -1; e = prev[e]) {\n            bool update = false;\n            if (match[to[e]] == -1) {\n                match[to[e]] = v; match[v] = to[e];\n                update = true;\n            } else if (dist[match[to[e]]] == dist[v] + 1) {\n                if (dfs(match[to[e]])) {\n                    match[to[e]] = v; match[v] = to[e];\n                    update = true;\n                }\n            }\n            if (update) return true;\n        }\n        dist[v] = INF;\n        return false;\n    }\n    int matching() {\n        int ret = 0;\n        memset(match, -1, sizeof(match));\n        while(bfs()) {\n            for (int i=0; i<N; ++i)\n                if (match[i] == -1 && dfs(i)) ret++;\n        }\n        return ret;\n    }\n};\n\nint gcd(int x, int y) {\n    if (y == 0) return x;\n    return gcd(y, x%y);\n}\n\nint b[501], r[501];\nint main() {\n    int m,n;\n    while(scanf(\"%d %d\", &m, &n), m|n) {\n        BiparateMatching bm(m, n);\n        for (int i=0; i<m; ++i) scanf(\"%d\", &b[i]);\n        for (int i=0; i<n; ++i) scanf(\"%d\", &r[i]);\n        for (int i=0; i<m; ++i) {\n            for (int j=0; j<n; ++j)\n                if (gcd(b[i], r[j]) > 1) bm.add_edge(i, j);\n        }\n        printf(\"%d\\n\", bm.matching());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//Max-Flow,?????§???\ntemplate<int V>\nstruct MaxFlow {\n\tusing T = double;\n\tconst T INF = 1<<28;\n\n\tstruct Edge {\n\t\tint to,rev;\n\t\tT cap;\n\t};\n\n\tvector<Edge> g[V];\n\tint level[V];\n\tint iter[V];\n\n\tvoid add(int from, int to, T cap) {\n\t\tg[from].push_back(Edge{to, (int)g[to].size(), cap});\n\t\tg[to].push_back(Edge{from, (int)g[from].size()-1, 0});\n\t}\n\tvoid add_multi(int from, int to, T cap) {\n\t\tg[from].push_back(Edge{to, (int)g[to].size(), cap});\n\t\tg[to].push_back(Edge{from, (int)g[from].size()-1, cap});\n\t}\n\n\tvoid bfs(int s) {\n\t\tfill_n(level,V,-1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()) {\n\t\t\tint v = que.front();\n\t\t\tque.pop();\n\t\t\tfor(Edge e: g[v]) {\n\t\t\t\tif(e.cap <= 0)continue;\n\t\t\t\tif(level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tT dfs(int v,int t,T f) {\n\t\tif(v == t)return f;\n\t\tfor(int &i = iter[v]; i < g[v].size(); i++) {\n\t\t\tEdge &e = g[v][i];\n\t\t\tif(e.cap <= 0)continue;\n\t\t\tif(level[v] < level[e.to]) {\n\t\t\t\tT d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d <= 0)continue;\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tT exec(int s,int t) {\n\t\tT flow = 0;\n\t\twhile(true) {\n\t\t\tbfs(s);\n\t\t\tif(level[t] < 0)return flow;\n\t\t\tfill_n(iter,V,0);\n\t\t\tT f;\n\t\t\twhile((f = dfs(s,t,INF)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nbool solve(){\n\tint m,n;\n\tcin >> m >> n;\n\tif(m == 0 && n == 0)return false;\n\n\tvector<int> b(m),r(n);\n\tfor(int i=0;i<m;i++)\n\t\tcin >> b[i];\n\tfor(int i=0;i<n;i++)\n\t\tcin >> r[i];\n\n\tMaxFlow<1100> mf;\n\tfor(int i=0;i<m;i++){\n\t\tmf.add(0,i+1,1);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tmf.add(i+m+1,m+n+1,1);\n\t}\n\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(__gcd(b[i],r[j]) > 1){\n\t\t\t\tmf.add(i+1,j+m+1,1);\n\t\t\t\t// cerr << b[i] << \" \" << r[j] << \" \" << __gcd(b[i],r[j]) << endl;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << mf.exec(0,m+n+1) << endl;\n\n\treturn true;\n}\n\nint main(void){\n\twhile(solve()){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 1500\n#define INF 1<<29\nusing namespace std;\nstruct edge{int to,cap,rev;};\nvector<edge>G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int>q;\n  level[s]=0;\n  q.push(s);\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(int i=0;i<G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n        level[e.to]=level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    bfs(s);\n    if(level[t]<0)return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\nint main(){\n  int a,b;\n  while(cin>>a>>b,a+b){\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n    int aa[a],bb[b];\n    for(int i=0;i<a;i++)cin>>aa[i];\n    for(int i=0;i<b;i++)cin>>bb[i];\n    for(int i=101;i<601;i++)add_edge(0,i,1);\n    for(int i=701;i<1201;i++)add_edge(i,1499,1);\n    for(int i=0;i<a;i++)\n     for(int j=0;j<b;j++)\n      if((__gcd(aa[i],bb[j]))!=1)add_edge(i+101,j+701,1);\n    cout<<max_flow(0,1499)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 10000\n#define MAX_N 1000\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});  \n}\n\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nint N,K;\nbool can[MAX_N][MAX_N]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(){\n  //0??????N-1: ???????????\\???????????????????????????\n  //N??????N+K-1: ???????????????????????????\n  int s = N+K, t = s+1;\n  \n  //s??¨???????????\\??????????????¶\n  for(int i=0; i<N; i++) add_edge(s,i,1);\n  \n  //????????¨t?????????\n  for(int i=0; i<K; i++) add_edge(N+i,t,1);\n  \n  //???????????\\????????¨??????????????¶\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)\n      if(can[i][j]) add_edge(i, N+j , 1);\n\n  return max_flow(s,t);\n}\n\nint main(){\n  while(1){\n  int b,r,B[501],R[501];\n  cin>>b>>r;\n  if(!b&&!r)break;\n  for(int i=0;i<b;i++) cin>>B[i];\n  for(int i=0;i<r;i++) cin>>R[i];\n\n  memset(can,0,sizeof(can));\n  N=b,K=r;\n  for(int i=0;i<b;i++)\n    for(int j=0;j<r;j++)\n      if(__gcd(B[i],R[j])>1) can[i][j]=1;\n\n  cout<<Biparite_Matching()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n#define MAX_V 1000010\n\nstruct Edge\n{\n\tint to, cap, rev;\n\tEdge(){};\n\tEdge(int to, int cap, int rev) : to(to), cap(cap), rev(rev){};\n};\n\nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back({to, cap, (int)G[to].size()});\n\tG[to].push_back({from, 0, (int)G[from].size()-1});\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tEdge& e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t){//O(FE);\n\tint flow = 0;\n\twhile(1){\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, INF);\n\t\tif(f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m && n && m) {\n\t\tfor(int i = 0; i < MAX_V; i++) G[i].clear(), used[i] = false;\n\t\tvector<int> b(n), r(m);\n\t\trep(i, n) cin >> b[i];\n\t\trep(i, m) cin >> r[i];\n\t\tset<int> bst[510], rst[510];\n\t\trep(i, n) {\n\t\t\tfor(int j = 2; j < b[i]; j++){\n\t\t\t\tif(b[i]%j == 0) bst[i].insert(j);\n\t\t\t\twhile(b[i]%j == 0) b[i] /= j;\n\t\t\t}\n\t\t\tif(b[i] != 1) bst[i].insert(b[i]);\n\t\t}\n\t\trep(i, m) {\n\t\t\tfor(int j = 2; j < r[i]; j++){\n\t\t\t\tif(r[i]%j == 0) rst[i].insert(j);\n\t\t\t\twhile(r[i]%j == 0) r[i] /= j;\n\t\t\t}\n\t\t\tif(r[i] != 1) rst[i].insert(r[i]);\n\t\t}\n\t\tint s = n + m, t = n + m + 1;\n\t\trep(i, n) add_edge(s, i, 1);\n\t\trep(i, m) add_edge(n + i, t, 1); \n\t\trep(i, n) rep(j, m) {\n\t\t\tfor(auto& p : bst[i]) {\n\t\t\t\tif(rst[j].count(p)) {\n\t\t\t\t\tadd_edge(i, n + j, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << max_flow(s, t) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<ll, ll> pll;\n\n#define FOR(i, n, m) for(ll (i)=(m);(i)<(n);++(i))\n#define REP(i, n) FOR(i,n,0)\n#define OF64 std::setprecision(10)\n\nconst ll MOD = 1000000007;\nconst ll INF = (ll) 1e15;\n\nstruct Flow {\n    explicit Flow(int n) {\n        mVertices.resize(n);\n        mDir.assign(n, 0);\n        mIter.assign(n, 0);\n    }\n\n    void addEdge(int from, int to, long long int cap) {\n        mVertices[from].edge.emplace_back(Edge{to, cap, static_cast<int>(mVertices[to].edge.size())});\n        mVertices[to].edge.emplace_back(Edge{from, 0, static_cast<int>(mVertices[from].edge.size())});\n    }\n\n    long long int maxFlow(int s, int t) {\n        long long int retValue = 0;\n        while (true) {\n            bfs(s);\n            if (mDir[t] == MAX_VALUE)\n                break;\n            fill(mIter.begin(), mIter.end(), 0);\n            long long int flow = 0;\n            while ((flow = dfs(s, t, INF_VALUE)) > 0)\n                retValue += flow;\n        }\n        return retValue;\n    }\n\n    void bfs(int s) {\n        fill(mDir.begin(), mDir.end(), MAX_VALUE);\n        queue<int> q;\n        q.push(s);\n        mDir[s] = 0;\n        while (!q.empty()) {\n            int t = q.front();\n            q.pop();\n            int cost = mDir[t] + 1;\n            for (const auto &e:mVertices[t].edge) {\n                if (mDir[e.to] <= cost || e.capacity <= 0)\n                    continue;\n                mDir[e.to] = cost;\n                q.push(e.to);\n            }\n        }\n    }\n\n    long long int dfs(int s, int t, long long int f) {\n        if (s == t)\n            return f;\n        for (int &i = mIter[s]; i < mVertices[s].edge.size(); ++i) {\n            Edge &e = mVertices[s].edge[i];\n            if (e.capacity <= 0 || mDir[s] >= mDir[e.to])\n                continue;\n            long long int d = dfs(e.to, t, std::min(f, e.capacity));\n            if (d > 0) {\n                e.capacity -= d;\n                mVertices[e.to].edge[e.rev].capacity += d;\n                return d;\n            }\n        }\n        return 0;\n    }\n\n    struct Edge {\n        int to;\n        long long int capacity;\n        int rev;\n    };\n    struct Vertex {\n        vector<Edge> edge;\n    };\n    vector<Vertex> mVertices;\n    vector<int> mDir;\n    vector<int> mIter;\n\n    const int MAX_VALUE = 1e9;\n    long long int INF_VALUE = (long long int) 1e15;\n};\n\nll gcd(ll a, ll b) {\n    if (a < b)\n        swap(a, b);\n    ll c = a % b;\n    if (c == 0)\n        return b;\n    return gcd(b, c);\n}\n\nll A[505], B[505];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        ll N, M;\n        cin >> N >> M;\n        if (N == 0 && M == 0)\n            break;\n        Flow flow(N + M + 2);\n        REP(i, N) {\n            cin >> A[i];\n        }\n        REP(i, M) {\n            cin >> B[i];\n        }\n\n        REP(i, N) {\n            REP(j, M) {\n                if (gcd(A[i], B[j]) > 1)\n                    flow.addEdge(i + 1, N + j + 1, 1);\n            }\n        }\n        REP(i, N) {\n            flow.addEdge(0, i + 1, 1);\n        }\n        REP(i, M) {\n            flow.addEdge(N + 1 + i, N + M + 1, 1);\n        }\n\n        cout << flow.maxFlow(0, N + M + 1) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n// #define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// #define int ll\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) begin(c), end(c)\n#define range(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) range(i,0,b)\n#define rangei(i,a,b) for(ll a=a;i<=ll(b);i++)\n#define repi(i,b) rangei(i,1,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> ostream & operator << (ostream &os, vector<T> const &);\ntemplate<int n, class...T>\ntypename enable_if<(n>=sizeof...(T))>::type\n_ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T>\ntypename enable_if<(n< sizeof...(T))>::type\n_ot(ostream &os, tuple<T...> const &t){\n    os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t);\n}\ntemplate<class...T>\nostream & operator << (ostream &os, tuple<T...> const &t){\n    _ot<0>(os, t); return os;\n}\ntemplate<class T, class U>\nostream & operator<<(ostream &os, pair<T,U> const &p){\n    return os << \"(\" << p.first << \", \" << p.second << \") \";\n}\ntemplate<class T>\nostream & operator<<(ostream &os, vector<T> const &v){\n    rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os;\n}\n#ifdef DEBUG\n#define dump(...) (cerr << #__VA_ARGS__ << \" = \" << mt(__VA_ARGS__) \\\n                   << \" [\" << __LINE__ << \"]\" << endl)\n#else\n#define dump(...)\n#endif\nvoid fastios(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n#define endl '\\n'\n}\ntemplate<class T>\nsize_t uniq(vector<T> &v){\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v.size();\n}\ntemplate<class T>\nsize_t uniq(T *l, size_t n){\n    sort(l,l+n);\n    return unique(l,l+n) - l;\n}\n#define mems(arr,val) memset(arr,val,sizeof(arr));\nint const mod = 1000000007;\nint const inf = numeric_limits<int>::max()/8;\n\ntypedef int Capacity;\nstruct Edge {\n    int src, dst;\n    Capacity cap;\n    Edge(int src_, int dst_, Capacity cap_) :\n        src(src_), dst(dst_), cap(cap_) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct Dinic {\n    int n, s, t;\n    vector<int> level, iter, que;\n    vector<vector<Capacity>> cap, flow;\n    vector<vector<int>> g;\n    Capacity inf;\n    Dinic(int n)\n        : n(n), cap(n, vector<Capacity>(n)), flow(n, vector<Capacity>(n)),\n          g(n, vector<int>()), inf(numeric_limits<Capacity>::max()/8){}\n    Dinic(const Graph &graph){\n        *this = Dinic(graph.size());\n        rep(i,n) for(auto &e : graph[i]) addEdge(e.src, e.dst, e.cap);\n    }\n    void addEdge(int u, int v, Capacity c){\n        cap[u][v] += c; cap[v][u] += c; flow[v][u] += c;\n        g[u].push_back(v); g[v].push_back(u);\n    }\n    inline Capacity residue(int u, int v){ return cap[u][v] - flow[u][v]; }\n    Capacity solve(int s, int t){\n        this->t = t, this->s = s;\n        Capacity res = 0, aug = 1;\n        while(aug > 0){\n            levelize();\n            iter.assign(n, 0);\n            res += (aug = augment(s, inf));\n        }\n        return res;\n    }\n    void levelize(){\n        level.assign(n, inf); level[s] = 0;\n        int l = 0, r = 0;\n        que.assign(n+1, 0);\n        que[r++] = s;\n        while(l != r){\n            int v = que[l++];\n            for(const int &d : g[v]){\n                if(level[d] <= level[v] + 1 || residue(v,d) == 0) continue;\n                level[d] = level[v] + 1; que[r++] = d;\n            }\n        }\n    }\n    Capacity augment(int v, Capacity lim){\n        Capacity res = 0;\n        if(v == t) return lim;\n        for(int &i = iter[v]; i < (int)g[v].size(); i++){\n            const int &d = g[v][i];\n            if(residue(v,d) == 0 || level[v] + 1 != level[d]) continue;\n            const Capacity aug = augment(d, min(lim, residue(v,d)));\n            if(aug > 0){\n                flow[v][d] += aug; flow[d][v] -= aug;\n                res += aug; lim -= aug;\n                if(lim == 0) return res;\n            }\n        }\n        return res;\n    }\n};\n\nint dp[2000][2000];\nint gcd(int a, int b){\n    return a < 2000 && b < 2000 ? dp[a][b] : gcd(b, a%b);\n}\n\n\nint main(){\n    rep(i,2000)rep(j,i+1) if(i*j) dp[i][j] = dp[j][i] = __gcd(i,j);\n    fastios();\n    int n,m;\n    while(cin >> n >> m && n|m){\n        vector<int> a(n), b(m);\n        rep(i,n) cin >> a[i];\n        rep(i,m) cin >> b[i];\n        Dinic d(n+m+2);\n        int s = n+m, t = n+m+1;\n        rep(i,m) d.addEdge(i+n,t,1);\n        rep(i,n){\n            d.addEdge(s,i,1);\n            rep(j,m) if(gcd(a[i],b[j]) != 1) d.addEdge(i,n+j,1);\n        }\n        rep(i,n)rep(j,m){\n            if(d.flow[i][j+n]) dump(i,j, d.flow[i][j+m]);\n        }\n        cout << d.solve(s,t) << endl;\n    }\n}\n\n// int main(){\n//     int N,M;\n//     cin >> N >> M;\n//     Graph g(N);\n//     rep(i,M){\n//         int a,b,c;\n//         cin >> a >> b >> c;\n//         g[a].emplace_back(a,b,c);\n//     }\n//     Dinic dinic(g);\n//     cout << dinic.solve(0,N-1) << endl;\n// }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec; typedef pair<int, int> pi;\nint dd[] = { 0, 1, 0, -1, 0 };\n#define pb push_back\n#define MAX 10000000\n#define MAX_V 500\n\nivec G[MAX_V * 2];\nint m, n;\nint match[MAX_V * 2];\nbool used[MAX_V * 2];\n\nint gcd(int x, int y)\n{\n  if(x < y)swap(x, y);\n  while(y > 0)\n    {\n      int r = x % y;\n      x = y;\n      y = r;\n    }\n  return x;\n}\nbool dfs(int v)\n{\n  used[v] = true;\n  rep(i,G[v].size())\n    {\n      int u = G[v][i];\n      int w = match[u];\n      if(w < 0 || !used[w] && dfs(w))\n\t{\n\t  match[v] = u;\n\t  match[u] = v;\n\t  return true;\n\t}\n    }\n  return false;\n}\n\n\nint main()\n{\n\n  while(true)\n    {\n      scanf(\"%d%d\", &m,&n);\n      if(m==0&&n==0)break;\n        int B[MAX_V], C[MAX_V];\n      rep(i,m)scanf(\"%d\",&B[i]);\n      rep(i,n)scanf(\"%d\",&C[i]);     \n      rep(i,MAX_V*2)G[i].clear();\n  rep(i,m)\n    {\n      rep(j,n)\n\t{\n\t  if(gcd(B[i],C[j])!=1)\n\t    {\n\t      G[i].pb(j+MAX_V);\n\t      G[j+MAX_V].pb(i);\n\t    }\n\t}\n    }\n\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  rep(v, MAX_V*2)\n    {\n      if(match[v]<0)\n\t{\n\t  memset(used,0,sizeof(used));\n\t  if(dfs(v))\n\t    {\n\t      res++;\n\t    }\n\t     \n\t}\n    }\n       printf(\"%d\\n\", res);\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n\nint main(){\n  int m,n,mc[500],nc[500],buf,nt=0,mt=0,lop3=0,cnt;\n\n  cin>>m;\n  cin>>n;\n\n  while(m!=0 || n!=0){\n\n    for(int lop=0;lop<500;lop++){\n      mc[lop]=0;\n      nc[lop]=0;\n    }\n    nt=0;\n    mt=0;\n    lop3=0;\n    cnt=0;\n    for(int lop=0;lop<m;lop++){\n      cin>>mc[lop];\n    }\n    for(int lop=0;lop<n;lop++){\n      cin>>nc[lop];\n    }\n\n    for(int lop=0;lop<n;lop++){\n      for(int lop2=0;lop2<n-1;lop2++){\n          if(nc[lop2]<nc[lop2+1]){\n            buf=nc[lop2];\n            nc[lop2]=nc[lop2+1];\n            nc[lop2+1]=buf;\n          }\n      }\n    }\n    for(int lop=0;lop<m;lop++){\n      for(int lop2=0;lop2<m-1;lop2++){\n          if(mc[lop2]<mc[lop2+1]){\n            buf=mc[lop2];\n            mc[lop2]=mc[lop2+1];\n            mc[lop2+1]=buf;\n          }\n      }\n    }\n\n    while(m!=0 && n!=0 && mt<m && nt<n){\n      if(nc[nt]<mc[mt]){\n        for(int lop=0;lop<n;lop++){\n          if(mc[mt]==0 || nc[lop]==0){\n            break;\n          }\n          if(mc[mt]%nc[lop]==0){\n            mc[mt]=0;\n            nc[lop]=0;\n            cnt++;\n            for(int lop2=mt;lop2<m-1;lop2++){\n              mc[lop2]=mc[lop2+1];\n            }\n            m--;\n            for(int lop2=lop;lop2<n-1;lop2++){\n              nc[lop2]=nc[lop2+1];\n            }\n            n--;\n            mt--;\n            break;\n          }\n        }\n        mt++;\n      }else{\n        for(int lop=0;lop<n;lop++){\n          if(nc[nt]==0 || mc[lop]==0){\n            break;\n          }\n          if(nc[nt]%mc[lop]==0){\n            nc[nt]=0;\n            mc[lop]=0;\n            cnt++;\n            for(int lop2=lop;lop2<m-1;lop2++){\n              mc[lop2]=mc[lop2+1];\n            }\n            m--;\n            for(int lop2=nt;lop2<n-1;lop2++){\n              nc[lop2]=nc[lop2+1];\n            }\n            n--;\n            nt--;\n            break;\n          }\n        }\n        nt++;\n      }\n\n    }\n    cout<<cnt<<endl;\n\n    /*cout<<endl;\n    for(int lop=0;lop<n;lop++){\n      cout<<nc[lop]<<' ';\n    }\n    cout<<endl;\n    for(int lop=0;lop<m;lop++){\n      cout<<mc[lop]<<' ';\n    }\n    cout<<endl;*/\n\n    cin>>m;\n    cin>>n;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\n//const ll inf=(ll)1e14;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\nint n,m,h,w;\nstring s;\n\n//Dinic\n//最大流を高速に求めることが出来ます\n//二部マッチングにも使ってください\nclass Dinic{\npublic:\n\n    //引数はありうる頂点の最大の数を入れてください\n    explicit Dinic(int v):vertex(static_cast<unsigned int>(v)){\n        G.resize(vertex+10);\n    }\n\n    //頂点fromからtoへの流せる量の最大がcapのとき、add_edge(int from,int to,ll cap)\n    //\n    //二部マッチングのときは、capは1にしてください\n    //二部マッチングのとき、意図的に、与えられる頂点以外に２つ頂点を作ってください\n    //それをs,tとしてsからtへの最大流を求めてください\n    void add_edge(int from,int to,ll cap){\n        G[from].push_back((edge){to, cap, static_cast<int>(G[to].size())});\n        G[to].push_back((edge){from, 0, static_cast<int>(G[from].size() - 1)});\n    }\n\n    ll max_flow(int s,int t){//s->start , t->end\n        ll flow=0;\n        for(;;){\n            bfs(s);\n            if(level[t]<0)return flow;\n            iter.clear();\n            iter.resize(vertex+10,0);\n            ll f;\n            while((f=dfs(s,t,INF))>0)flow+=f;\n        }\n    }\nprivate:\n    unsigned int vertex;\n    struct edge{\n        int to;\n        ll cap;\n        int rev;\n    };\n    vector<vector<edge> > G;\n    vector<int> level;\n    vector<int> iter;\n    ll INF=(ll)1e16;\n    void bfs(int start){\n        level.clear();\n        level.resize(vertex+10,-1);\n        queue<int> q;\n        q.push(start);\n        level[start]=0;\n        while(!q.empty()){\n            int now=q.front();\n            q.pop();\n            for(int i=0;i<(int)G[now].size();i++) {\n                if(G[now][i].cap>0 && level[G[now][i].to]<0){\n                    level[G[now][i].to]=level[now]+1;\n                    q.push(G[now][i].to);\n                }\n            }\n        }\n    }\n    ll dfs(int now,int t,ll f){\n        if(now==t)return f;\n        for(int &i=iter[now];i<(int)G[now].size();i++){\n            edge &e=G[now][i];\n            if(e.cap>0 && level[now]<level[e.to]){\n                ll d=dfs(e.to,t,min(f,e.cap));\n                if(d>0){\n                    e.cap-=d;\n                    G[e.to][e.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n};\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  while(cin>>n>>m,n){\n    int blue[501],red[501];\n    for(int i=0;i<n;i++){\n      cin>>blue[i];\n    }\n    for(int i=0;i<m;i++){\n      cin>>red[i];\n    }\n    Dinic d(1011);\n    int s=n+m;\n    int t=s+1;\n    for(int i=0;i<n;i++){\n      d.add_edge(s,i,1);\n    }\n    for(int i=0;i<m;i++){\n      d.add_edge(n+i,t,1);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n        if(__gcd(blue[i],red[j])!=1){\n          d.add_edge(i,n+j,1);\n        }\n      }\n    }\n    ll ans=d.max_flow(s,t);\n    cout<<ans<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E) REPS(i, S, E)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S) DEPS(i, S, E)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll Size(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<1000000007LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\n\nclass DinicMethod{\npublic:\n\tstruct Edge{ ll to, cap, rev; };\n\tvector<vector<Edge>> G;\nprivate:\n\tvll level;\n\tvll iter;\npublic:\n\tDinicMethod(ll nodeNum): G(nodeNum){}\n\n\tvoid Link(ll v, ll u, ll cap, ll rcap = 0){//v→uに重みcapで張る、逆辺も張る\n\t\tthis->G[v].push_back({u,  cap, (ll)this->G[u].size()});\n\t\tthis->G[u].push_back({v, rcap, (ll)this->G[v].size()-1});\n\t}\n\n\tll MaxFlow(ll s, ll t){//s→tの最大流を求める\n\t\tll f, flow = 0;\n\t\twhile (true){\n\t\t\tthis->BfsLevelRenew(s);\n\t\t\tif (this->level[t] < 0) return flow;\n\t\t\titer.assign(this->G.size(), 0);\n\t\t\twhile ((f = this->DfsFindPath(s, t, INF)) > 0) { flow += f; }\n\t\t}\n\t}\n\nprivate:\n\tvoid BfsLevelRenew(ll s) {\n\t\tthis->level.assign(this->G.size(), -1);\n\t\tthis->level[s] = 0;\n\t\tqueue<ll> que;\n\t\tque.push(s);\n\t\twhile (!que.empty()){\n\t\t\tll from = que.front(); que.pop();\n\t\t\tEACH(e, this->G[from]){\n\t\t\t\tif (e.cap > 0 && this->level[e.to] < 0){\n\t\t\t\t\tthis->level[e.to] = this->level[from] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll DfsFindPath(ll v, ll t, ll f){\n\t\tif (v == t) return f;\n\n\t\tfor (ll &i = iter[v]; i < (ll)this->G[v].size(); i++){\n\t\t\tEdge &e = this->G[v][i];\n\t\t\tif (e.cap > 0  &&  this->level[v] < this->level[e.to]){\n\t\t\t\tll d = this->DfsFindPath(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tthis->G[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n};\n\n\nclass DinicMatching{\nprivate:\n\tDinicMethod dm;\n\tll sNum, tNum, s, t;\npublic:\n\tDinicMatching(ll sNum, ll tNum): dm(sNum+tNum+2), sNum(sNum), tNum(tNum),\n\t\ts(sNum+tNum), t(sNum+tNum+1)\n\t{\n\t\tREP(i, sNum){ dm.Link(this->s, i, 1); }\n\t\tREP(i, tNum){ dm.Link(i+sNum, this->t, 1); }\n\t}\n\n\tvoid Link(ll sIdx, ll tIdx){ dm.Link(sIdx, tIdx + this->sNum, 1); }\n\n\tvector<pair<ll, ll>> GetMatch(){ //最大マッチングを得る\n\t\tll matchNum = dm.MaxFlow(this->s, this->t);\n\t\tvector<pair<ll, ll>> matches;\n\t\tREP(v, this->sNum){//ソース側ノードをなめる\n\t\t\tEACH(e, dm.G[v]){\n\t\t\t\tif (e.cap == 0 && e.to != this->s){\n\t\t\t\t\tmatches.emplace_back(v, e.to - sNum);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn move(matches);\n\t}\n};\n\n\nvoid solve()\n{\n\twhile (true){\n\t\tll M, N;  cin >> M >> N;\n\t\tif (M==0 && N==0) break;\n\n\t\tvector<ll> B = cinv<ll>(M);\n\t\tvector<ll> R = cinv<ll>(N);\n\n\t\tDinicMatching dm(M, N);\n\t\trep(i, 0, M-1)rep(j, 0, N-1){\n\t\t\tif (Gcd(B[i], R[j]) >= 2){\n\t\t\t\tdm.Link(i, j);\n\t\t\t}\n\t\t}\n\t\tauto matches = dm.GetMatch();\n\t\tll ans = Size(matches);\n\t\tcout << ans << '\\n';\n\t}\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nclass Increase {\npublic:\n  int n, flowMax = 1000000;\n  vector<vector<int>> p;\n  vector<int> parent;\n\n  Increase(int n, vector<vector<int>> p) : n(n), p(p) { parent.resize(n); }\n\n  int dfs(int id, int from, int flow) {\n    if (parent[id] != id)\n      return 0;\n    parent[id] = from;\n    if (id == n - 1)\n      return flow;\n    for (int i = 0; i < n; i++)\n      if (p[id][i] > 0) {\n        int next = dfs(i, id, min(flow, p[id][i]));\n        if (next > 0)\n          return next;\n      }\n    return 0;\n  }\n\n  int solve() {\n    int ret = 0, flow;\n    for (int i = 0; i < n; i++)\n      parent[i] = i;\n\n    while ((flow = dfs(0, -1, flowMax)) > 0) {\n      int now = n - 1;\n      ret += flow;\n      while (parent[now] >= 0) {\n        p[parent[now]][now] -= flow;\n        p[now][parent[now]] += flow;\n        now = parent[now];\n      }\n      for (int i = 0; i < n; i++)\n        parent[i] = i;\n    }\n    return ret;\n  }\n};\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (n == 0)\n      break;\n    vector<int> b(n), r(m);\n    for (int i = 0; i < n; i++)\n      cin >> b[i];\n    for (int i = 0; i < m; i++)\n      cin >> r[i];\n    int s = 0, t = n + m + 1;\n\n    vector<vector<int>> p(n + m + 2, vector<int>(n + m + 2));\n    for (int i = 0; i < n; i++)\n      p[s][i + 1] = 1;\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < m; j++)\n        if (__gcd(b[i], r[j]) > 1)\n          p[i + 1][n + 1 + j] = 1;\n    for (int i = 0; i < m; i++)\n      p[n + 1 + i][t] = 1;\n    Increase sol(n + m + 2, p);\n    cout << sol.solve() << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nstruct Edge {\n    int src, dst;\n    int capacity, flow;\n    Edge* rev;\n    Edge(int src, int dst, int capacity): src(src), dst(dst), capacity(capacity), flow(0), rev(nullptr) {}\n};\nusing Vertex = deque<Edge>;\nusing Graph = vector<Vertex>;\n\ninline int residue(const Edge& edge) { return edge.capacity - edge.flow; }\n\nint edmonds_karp(Graph& graph, int source, int sink) {\n    Edge dummy(-1, -1, -1);\n    int total = 0;\n    for (;;) {\n        // find path\n        queue<int> Q; Q.push(source);\n        vector<Edge*> prev(graph.size()); prev[source] = &dummy;\n        while (!Q.empty() && prev[sink] == nullptr) {\n            int u = Q.front(); Q.pop();\n            for (auto& e : graph[u]) {\n                if (prev[e.dst] == nullptr && residue(e) > 0) {\n                    prev[e.dst] = &e;\n                    Q.push(e.dst);\n                }\n            }\n        }\n        if (prev[sink] == nullptr) return total;\n\n        // augment flow\n        int flow = INT_MAX;\n        for (int u = sink; prev[u] != &dummy; u = prev[u]->src)\n            flow = min(flow, residue(*prev[u]));\n        for (int u = sink; prev[u] != &dummy; u = prev[u]->src) {\n            prev[u]->flow += flow;\n            prev[u]->rev->flow -= flow;\n        }\n        total += flow;\n    }\n}\n\nvoid add_edge(Graph& graph, int src, int dst, int capacity) {\n    graph[src].emplace_back(src, dst, capacity);\n    graph[dst].emplace_back(dst, src, 0);\n    graph[src].back().rev = &graph[dst].back();\n    graph[dst].back().rev = &graph[src].back();\n}\n\nint gcd(int a, int b) { return (b == 0) ? a : gcd(b, a%b); }\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int m, n;\n    while (cin>>m>>n, m|n) {\n        vector<int> blue(m), red(n);\n        REP(i, m) cin >> blue[i];\n        REP(i, n) cin >> red[i];\n\n        Graph graph(m+n+2);\n        REP(i, m) REP(j, n) {\n            if (gcd(blue[i], red[j]) > 1)\n                add_edge(graph, i, m+j, 1);\n        }\n        REP(i, m) add_edge(graph, m+n, i, 1);\n        REP(j, n) add_edge(graph, m+j, m+n+1, 1);\n\n        cout << edmonds_karp(graph, m+n, m+n+1) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 501;\nconst int MAX_V = 2000;\n// 赤と青のカード\nint b[MAX_N],r[MAX_N];\n// 頂点数\nint V;\n// グラフ\nvector<int> G[MAX_V];\n// マッチングのペア\nint match[MAX_V];\n// すでに調べたかどうか\nbool used[MAX_V];\n\n// aとbの最大公約数を返す(ユークリッドの互除法)\nint gcd(int a, int b){\n    return (b>0)? gcd( b , a%b ) : a ;\n}\n\n// 辺の追加.\nvoid add_edge(int u, int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\n// 増加path を DFSで探す.\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i=0 ; i < G[v].size() ; i++ ){\n\t\tint u = G[v][i];\n\t\tint w = match[u];\n\t\tif( w < 0 || !used[w] && dfs(w) ){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n// 二部グラフの最大マッチングを求める.\nint solve(){\n\tint res = 0;\n\tfor(int v=0 ; v < V ; v++ ){\n\t\tif( match[v] < 0 ){\n\t\t\t// 初期化\n\t\t\tfor(int i=0 ; i < V ; i++ ){\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t\tif( dfs(v) ){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n// 初期化\nvoid init(){\n\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\tG[i].clear();\n\t\tmatch[i] = -1;\n\t}\n}\n\nint main(){\n\tint m, n;\n\twhile( cin >> m >> n , m || n ){\n\t\t// 初期化\n\t\tV = n + m;\n\t\tinit();\n\t\t\n\t\t// 入力\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tcin >> b[i];\n\t\t}\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tcin >> r[i];\n\t\t}\n\t\t\n\t\t// ペアを探して辺を追加しておく\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tfor(int j=0 ; j < n ; j++ ){\n\t\t\t\tif( gcd(b[i], r[j]) >= 2 ){\n\t\t\t\t\tint u = i;\n\t\t\t\t\tint v = j + m;\n\t\t\t\t\tadd_edge(u,v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = solve();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint n,m;\nint b[500],r[500],p[500];\nbool f[500],c[500][500];\n\nint gcd(int a,int b){\n\tif(a < b) swap(a,b);\n\tif(a%b == 0) return b;\n\telse return gcd(b,a%b);\n}\nbool match(int u){\n\tfor(int i = 0; i < n; ++i){\n\t\tif(f[i] || !c[u][i]) continue;\n\t\tf[i] = true;\n\t\tif(p[i] == -1 || match(p[i])){\n\t\t\tp[i] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\twhile(cin >> m >> n,m){\n\t\tfor(int i = 0; i < m; ++i) cin >> b[i];\n\t\tfor(int i = 0; i < n; ++i) cin >> r[i];\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tp[i] = -1;\n\t\t}\n\t\tfor(int i = 0; i < m;++i)for(int j = 0; j < n;++j){\n\t\t\tc[i][j] = gcd(b[i],r[j]) > 1;\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tfor(int j = 0; j < n; ++j) f[j] = false;\n\t\t\tif(match(i)) ++sum;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define N 505\nint A[N],B[N],g[N][N],n,k,mt[N],used[N];\nint inline gcd(int a, int b) {while (b) {int c=a%b;a=b,b=c;} return a;}\nint kuhn(int v) {if (used[v]) return 0;used[v]=1;for (int i=g[v][0]-1;i;i--) {int to=g[v][i];if (mt[to]==-1 || kuhn(mt[to])) {mt[to]=v;return 1;}}return 0;}\nint main() {\n\tint i,j;while (scanf(\"%d %d\",&n,&k)!=EOF && (n || k)) {\n\t\tfor (i=0;i<k;mt[i++]=-1);\n\t\tfor (i=0;i<n;g[i][0]=1,scanf(\"%d\",&A[i++]));for (i=0;i<k;scanf(\"%d\",&B[i++]));\n\t\tfor (i=0;i<n;i++) for (j=0;j<k;j++) if (gcd(A[i],B[j])>1) g[i][g[i][0]++]=j;\n\t\tfor (i=0;i<n;i++) {for (j=0;j<n;used[j++]=0);kuhn(i);}\n\t\tfor (i=0,j=0;i<k;j+=(mt[i]!=-1),i++);printf(\"%d\\n\",j);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nlong long e, v;\n\nclass pass\n{\npublic:\n\tlong long t;\n\tlong long c;\n\tlong long p;\n};\n\npass p[250000];\n\nlong long noded[2000];\npair<long long, long long> nodef[2000];\nvector<long long> node[2000];\n\nvoid add(long long f, long long t, long long c)\n{\n\tp[e].t = t;\n\tp[e].c = c;\n\tp[e].p = e + 1;\n\tp[e + 1].t = f;\n\tp[e + 1].c = 0;\n\tp[e + 1].p = e;\n\tnode[f].push_back(e);\n\tnode[t].push_back(e + 1);\n\te += 2;\n}\n\nvoid push()\n{\n\tpriority_queue<pair<long long, long long>> q;\n\tfor (long long i = 0; i < v; i++)\n\t{\n\t\tnoded[i] = 0;\n\t\tnodef[i] = make_pair(0, 0);\n\t}\n\tnoded[0] = v;\n\tfor (auto i : node[0])\n\t{\n\t\tif (p[i].c > 0)\n\t\t{\n\t\t\tp[p[i].p].c += p[i].c;\n\t\t\tnodef[p[i].t].first += p[i].c;\n\t\t\tnodef[0].second += p[i].c;\n\t\t\tp[i].c = 0;\n\t\t\tq.push(make_pair(0, p[i].t));\n\t\t}\n\t}\n\tnodef[v - 1].second = ((long long)1 << 50);\n\twhile (!q.empty())\n\t{\n\t\tlong long np = q.top().second;\n\t\tq.pop();\n\t\twhile (1)\n\t\t{\n\t\t\tfor (auto i : node[np])\n\t\t\t{\n\t\t\t\tif (p[i].c > 0)\n\t\t\t\t{\n\t\t\t\t\tlong long t = p[i].t;\n\t\t\t\t\tif (noded[np] == noded[t] + 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tlong long kae = min(p[i].c, nodef[np].first - nodef[np].second);\n\t\t\t\t\t\tp[i].c -= kae;\n\t\t\t\t\t\tp[p[i].p].c += kae;\n\t\t\t\t\t\tnodef[np].second += kae;\n\t\t\t\t\t\tbool w = (nodef[t].first <= nodef[t].second);\n\t\t\t\t\t\tnodef[t].first += kae;\n\t\t\t\t\t\tif (w && nodef[t].first > nodef[t].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tq.push(make_pair(noded[t], t));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nodef[np].first <= nodef[np].second)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nodef[np].first > nodef[np].second && np != 0)\n\t\t\t{\n\t\t\t\tlong long minw = ((long long)1 << 50);\n\t\t\t\tfor (auto i : node[np])\n\t\t\t\t{\n\t\t\t\t\tif (p[i].c > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tminw = min(minw, noded[p[i].t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnoded[np] = minw + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long dn[2000];\nlong long dm[2000];\n\nlong long gcd(long long a, long long b)\n{\n\tif (a % b == 0)\n\t{\n\t\treturn b;\n\t}\n\treturn gcd(b, a % b);\n}\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tlong long n, m;\n\t\tscanf(\"%lld%lld\", &n, &m);\n\t\tif (n == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tv = n + m + 2;\n\t\te = 0;\n\t\tfor (long long i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%lld\", &dn[i]);\n\t\t\tadd(0, 1 + i, 1);\n\t\t}\n\t\tfor (long long i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%lld\", &dm[i]);\n\t\t\tadd(n + 1 + i, n + m + 1, 1);\n\t\t}\n\t\tfor (long long i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (long long ii = 0; ii < m; ii++)\n\t\t\t{\n\t\t\t\tif (1 < gcd(dn[i], dm[ii]))\n\t\t\t\t{\n\t\t\t\t\tadd(1 + i, n + 1 + ii, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpush();\n\t\tlong long all = 0;\n\t\tfor (auto i : node[0])\n\t\t{\n\t\t\tif (i % 2 == 0)\n\t\t\t{\n\t\t\t\tall += p[p[i].p].c;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", all);\n\t\tfor (long long i = 0; i < v; i++)\n\t\t{\n\t\t\tnode[i].clear();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <list>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <tuple>\n#include <deque>\n#include <complex>\n\nusing namespace std;\n\n/*\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n*/\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef pair<long long, long long> pll;\ntypedef vector<pll> vpll;\n\ntypedef long double ld;\ntypedef vector<ld> vld;\n\ntypedef vector<bool> vb;\n\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define reps(i, n) for (ll i = 1; i <= (n); i++)\n#define rrep(i, n) for (ll i = (n) - 1; i >= 0; i--)\n#define rreps(i, n) for (ll i = (n); i >= 1; i--)\n#define all(v) (v).begin(), (v).end()\n\ntemplate <class T> void chmin(T& a, T b) { a = min(a, b);}\ntemplate <class T> void chmax(T& a, T b) { a = max(a, b);}\n\nconstexpr int INF = 1 << 30;\nconstexpr ll INFL = 1LL << 60;\nconstexpr ll MOD = 1000000007;\nconstexpr ld EPS = 1e-12;\nld PI = acos(-1.0);\n\nstruct Edge {\n    ll rev, from, to;\n    ll cap, original_cap;\n    Edge(ll r, ll f, ll t, ll c) : rev(r), from(f), to(t), cap(c), original_cap(c) {};\n};\n\nstruct Graph {\n    vector<vector<Edge>> g;\n    Graph(ll n) { g = vector<vector<Edge>>(n); };\n    vector<Edge>& operator[](ll i) { return g[i]; }\n    size_t size() {return g.size(); }\n    Edge& redge(Edge e) {\n        return g[e.to][e.rev];\n    }\n    void add_edge(ll from, ll to, ll cap) {\n        g[from].push_back(Edge(g[to].size(), from, to, cap));\n        g[to].push_back(Edge(g[from].size() - 1, to, from, 0));\n    }\n};\n\nstruct FordFulkerson {\n    vector<bool> used;\n    Graph& G;\n    FordFulkerson(Graph& g) : G(g) {};\n    ll dfs(ll v, ll t, ll f) {\n        if(v == t) return f;\n        used[v] = true;\n        for(auto& e : G[v]) {\n            if(used[e.to] || e.cap <= 0) continue;\n            ll d = dfs(e.to, t, min(f, e.cap));\n            if(d <= 0) continue;\n            e.cap -= d;\n            G.redge(e).cap += d;\n            return d;\n        }\n        return 0;\n    }\n    ll max_flow(ll s, ll t) {\n        ll flow = 0;\n        while(true) {\n            used.assign(G.size(), false);\n            ll f = dfs(s, t, INFL);\n            if(f == 0) return flow;\n            else flow += f;\n        }\n        return 0;\n    }\n};\n\nvoid solve() {\n    vll ans;\n    while(true) {\n        ll n, m;\n        cin >> n >> m;\n        if(n == 0 && m == 0) break;\n        vll b(n), r(m);\n        Graph g(n + m + 2);\n        for(ll i = 0; i < n; i++) {\n            cin >> b[i];\n            g.add_edge(0, i + 1, 1);\n        }\n        for(ll i = 0; i < m; i++) {\n            cin >> r[i];\n            g.add_edge(i + n + 1, n + m + 1, 1);\n        }\n        for(ll i = 0; i < n; i++) {\n            for(ll j = 0; j < m; j++) {\n                if(__gcd(b[i], r[j]) > 1) {\n                    g.add_edge(i + 1, j + n + 1, 1);\n                }\n            }\n        }\n        FordFulkerson f(g);\n        ans.push_back(f.max_flow(0, n + m + 1));\n    }\n    for(auto i : ans) cout << i << endl;\n    return;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> G[10000];\nint match[10000];\nbool used[10000];\n\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tint u = G[v][i],w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bi_match(int V){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int v = 0;v < V;v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint gcd(int a,int b){\n\tif(a < b) swap(a,b);\n\tif(!b) return a;\n\treturn gcd(b,a % b);\n}\n\nint main(){\n\tint m,n,b[500],r[500];\n\twhile(cin >> m >> n,m){\n\t\tfor(int i = 0;i < m;i++) cin >> b[i];\n\t\tfor(int i = 0;i < n;i++) cin >> r[i];\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(gcd(b[i],r[j]) != 1) add_edge(i,m + j);\n\t\t\t}\n\t\t}\n\t\tcout << bi_match(n + m) << endl;\n\t\tfor(int i = 0;i < n + m;i++) G[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing vec = vector<ll>;\nusing vect = vector<double>;\nusing Graph = vector<vector<ll>>;\n#define loop(i, n) for (ll i = 0; i < n; i++)\n#define Loop(i, m, n) for (ll i = m; i < n; i++)\n#define pool(i, n) for (ll i = n; i >= 0; i--)\n#define Pool(i, m, n) for (ll i = n; i >= m; i--)\n#define mod 1000000007ll\n#define setbit bitset<8>\n#define flagcount __builtin_popcount\n#define flag(x) (1 << x)\n#define flagadd(bit, x) bit |= flag(x)\n#define flagpop(bit, x) bit &= ~flag(x)\n#define flagon(bit, i) bit &flag(i)\n#define flagoff(bit, i) !(bit & (1 << i))\n#define all(v) v.begin(), v.end()\n#define low2way(v, x) lower_bound(all(v), x)\n#define high2way(v, x) upper_bound(all(v), x)\n#define count2way(v, x) high2way(v, x) - low2way(v, x)\n#define lower(v, x) low2way(v, x) - v.begin()       //1番左が0、もし見つから無いならｎを出力\n#define higher(v, x) high2way(v, x) - v.begin() - 1 //1番左が0、もし見つからないならn-1を出力（注意）\n#define putout(a) cout << a << endl\n#define putout2(a, b) \\\n    putout(a);        \\\n    putout(b)\n#define putout3(a, b, c) \\\n    putout(a);           \\\n    putout(b);           \\\n    putout(c)\n#define putout4(a, b, c, d) \\\n    putout(a);              \\\n    putout(b);              \\\n    putout(c);              \\\n    putout(d)\n#define putout5(a, b, c, d, e) \\\n    putout(a);                 \\\n    putout(b);                 \\\n    putout(c);                 \\\n    putout(d);                 \\\n    putout(e)\n#define Gput(a, b) G[a].push_back(b)\n#define cin1(a) cin >> a\n#define cin2(a, b) cin >> a >> b\n#define cin3(a, b, c) cin >> a >> b >> c\n#define cin4(a, b, c, d) cin >> a >> b >> c >> d\n#define cin5(a, b, c, d, e) cin >> a >> b >> c >> d >> e\n#define Sum(v) accumulate(all(v), 0ll)\n#define gcd(x, y) __gcd(x, y)\nll ctoi(char c)\n{\n    if (c >= '0' && c <= '9')\n    {\n        return c - '0';\n    }\n    return 0;\n}\ntemplate <typename T>\nT lcm(T x, T y)\n{\n    T z = gcd(x, y);\n    return x * y / z;\n}\ntemplate <typename T>\nbool primejudge(T n)\n{\n    if (n < 2)\n        return false;\n    else if (n == 2)\n        return true;\n    else if (n % 2 == 0)\n        return false;\n    double sqrtn = sqrt(n);\n    for (T i = 3; i < sqrtn + 1; i++)\n    {\n        if (n % i == 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\ntemplate <typename T>\nT modinv(T a, T m)\n{\n    T b = m, u = 1, v = 0;\n    while (b)\n    {\n        T t = a / b;\n        a -= t * b;\n        swap(a, b);\n        u -= t * v;\n        swap(u, v);\n    }\n    u %= m;\n    if (u < 0)\n        u += m;\n    return u;\n}\n//場合によって使い分ける\n//const ll dx[4]={1,0,-1,0};\n//const ll dy[4]={0,1,0,-1};\nconst ll dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n//多次元配列の宣言法\n//vector<vector<ll>> field(h, vector<ll>(w));\ntemplate <class T>\ninline void chmax(T &a, T b)\n{\n    if (a < b)\n        a = b;\n}\ntemplate <class T>\ninline void chmin(T &a, T b)\n{\n    if (a > b)\n        a = b;\n}\n/*\nライブラリをここに置いてコメントを削除\n*/\n#define fst first\n#define snd second\nconst long long INF = (1ll << 50);\nstruct graph\n{\n    typedef long long flow_type;\n    struct edge\n    {\n        int src, dst;\n        flow_type capacity, flow;\n        size_t rev;\n    };\n    int n;\n    vector<vector<edge>> adj;\n    graph(int n) : n(n), adj(n) {}\n    void add_edge(int src, int dst, flow_type capacity)\n    {\n        adj[src].push_back({src, dst, capacity, 0, adj[dst].size()});\n        adj[dst].push_back({dst, src, 0, 0, adj[src].size() - 1});\n    }\n    flow_type max_flow(int s, int t)\n    {\n        vector<int> level(n), iter(n);\n        function<int(void)> levelize = [&]() { // foward levelize\n            level.assign(n, -1);\n            level[s] = 0;\n            queue<int> Q;\n            Q.push(s);\n            while (!Q.empty())\n            {\n                int u = Q.front();\n                Q.pop();\n                if (u == t)\n                    break;\n                for (auto &e : adj[u])\n                {\n                    if (e.capacity > e.flow && level[e.dst] < 0)\n                    {\n                        Q.push(e.dst);\n                        level[e.dst] = level[u] + 1;\n                    }\n                }\n            }\n            return level[t];\n        };\n        function<flow_type(int, flow_type)> augment = [&](int u, flow_type cur) {\n            if (u == t)\n                return cur;\n            for (int &i = iter[u]; i < adj[u].size(); ++i)\n            {\n                edge &e = adj[u][i], &r = adj[e.dst][e.rev];\n                if (e.capacity > e.flow && level[u] < level[e.dst])\n                {\n                    flow_type f = augment(e.dst, min(cur, e.capacity - e.flow));\n                    if (f > 0)\n                    {\n                        e.flow += f;\n                        r.flow -= f;\n                        return f;\n                    }\n                }\n            }\n            return flow_type(0);\n        };\n        for (int u = 0; u < n; ++u) // initialize\n            for (auto &e : adj[u])\n                e.flow = 0;\n\n        flow_type flow = 0;\n        while (levelize() >= 0)\n        {\n            fill(all(iter), 0);\n            for (flow_type f; (f = augment(s, INF)) > 0;)\n                flow += f;\n        }\n        return flow;\n    }\n};\n/*\n    graph g(n);\n    //g.add_edge(u, v, w);\n    g.add_edge(u-1, v-1, w);\n    g.max_flow(0, n-1)\n*/\nint main()\n{\n    cout << fixed << setprecision(30);\n    while (\"解けた！を世界に届けたい。AtCoderは、世界最高峰の競技プログラミングサイトです。リアルタイムのオンラインコンテストで競い合うことや、3,000以上の過去問にいつでもチャレンジすることができます。\")\n    {\n        ll m, n;\n        cin >> m >> n;\n        if (m == 0)\n            return 0;\n        vec b(m), r(n);\n        loop(i, m) cin >> b[i];\n        loop(i, n) cin >> r[i];\n        graph g(m + n + 2);\n        loop(i, m) g.add_edge(0, 1 + i, 1);\n        loop(i, n) g.add_edge(m + 1 + i, m + n + 1, 1);\n        loop(i, m)\n        {\n            loop(j, n)\n            {\n                if (gcd(b[i], r[j]) != 1)\n                    g.add_edge(1 + i, m + 1 + j, 1);\n            }\n        }\n        putout(g.max_flow(0, m + n + 1));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\n#define PRINT(v) for (auto x : (v)) cout <<x <<\" \" ; cout <<endl;\nusing namespace std;\nusing ll = long long;\nusing Graph = vector<vector<int>>;\nusing mat = vector<vector<ll>>;\nconst ll MOD = 1000000007;\nconst ll INF = 10000000000000000;\nvector<int> x4 = {0, 1, 0, -1}, x8 = {0, 1, 1, 1, 0, -1, -1, -1};\nvector<int> y4 = {1, 0, -1, 0}, y8 = {1, 1, 0, -1, -1, -1, 0, 1};\ntemplate<class T> inline bool chmin(T& a, T b){if (a>b){a = b; return true;}return false;}\ntemplate<class T> inline bool chmax(T& a, T b){if (a<b){a = b; return true;}return false;}\ntemplate<class T> inline T powerM(T a,T b){if (b==0) return 1;\nT tmp = powerM(a,b/2); if (b%2==0) return tmp*tmp%MOD; else return tmp*tmp%MOD*a%MOD; }\ntemplate<class T> inline T power(T a,T b,T m){ if (b==0) return 1;\n  T tmp = power(a,b/2,m); if (b%2==0) return tmp*tmp%m; else return tmp*tmp%m*a%m; }\ntemplate<class T> inline T gcd(T a, T b){if (b==0) return a; return gcd(b, a%b);}\ntemplate<class T> inline T lcm(T a, T b){return a / gcd(a,b) * b;}\n// ax+by=gcd(a,b)を解く\ntemplate<class T> inline T extgcd(T a,T b,T &x,T &y){if (b==0){x=1; y=0; return a;} T d=extgcd(b,a%b,y,x); y -= a/b*x; return d;}\nvoid hey(){ cout <<\"hey\" <<endl; }\n\ntemplate<class T> struct edge { int to; T cost;};\n\n\n// 二部マッチング：構造体--------------------------------------\n// 二部グラフ。容量が全て1である最大流問題に帰着できる。\n// がここではsupersourceとsupersinkを追加する必要はない\n// verifyはここ <http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_7_A&lang=jp>\n\nstruct Bipartite_Matching {\n  int V;                 // 頂点数\n  vector<vector<int>> G; // グラフの隣接リスト表現\n  vector<int> match;     // マッチングのペア\n  vector<bool> used;     // DFSで既に調べたかのフラグ\n\n  Bipartite_Matching(int n) : V(n), G(n), match(n, -1), used(n, false) {}\n\n  // uとvを結ぶ辺をグラフに追加する\n  void add_edge(int u, int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  // 増加パスをDFSで探す\n  bool dfs(int v){\n    used[v] = true;\n    for (int i=0; i<G[v].size(); i++){\n      int u = G[v][i], w = match[u];\n      if (w < 0 || !used[w] && dfs(w)){\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // 二部グラフの最大マッチングを求める\n  int bipartite_matching() {\n    int res = 0;\n    match.assign(match.size(), -1);\n    for (int v=0; v<V; v++){\n      if (match[v] < 0){\n        used.assign(used.size(), false);\n        if (dfs(v)) res++;\n      }\n    }\n    return res;\n  }\n};\n\nvoid solve(int M, int N){\n  Bipartite_Matching bm(M+N);\n  vector<int> b(M); rep(i, M) cin >>b[i];\n  rep(j, N){\n    int red = M+j;\n    int r; cin >>r;\n    rep(i, M){\n      int blue = i;\n      if (gcd(b[i], r) > 1) bm.add_edge(blue, red);\n    }\n  }\n  int res = bm.bipartite_matching();\n  cout <<res <<endl;\n}\n\nint main() {\n  int M,N; cin >>M >>N;\n  while (M > 0 && N > 0){\n    solve(M, N);\n    cin >>M >>N;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define pb push_back\n#define mp make_pair\n#define SZ(a) ((int)(a.size()))\n#define F first\n#define S second\ntypedef long long ll;\ntypedef pair<int,int> PI;\n\nconst int MAX_N=600;\nint a[MAX_N];\nint b[MAX_N];\nbool vis[MAX_N];\nint match[MAX_N];\nint n,m;\n\nbool aug(int cv){\n  vis[cv] = 1;\n  rep(j,n){\n    if(__gcd(a[cv],b[j]) == 1) continue;\n    if(match[j] == -1 ||\n       (!vis[match[j]] && aug(match[j]))){\n      match[j] = cv;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> m >> n, n){\n    rep(i,m) cin >> a[i];\n    rep(j,n) cin >> b[j];\n    memset(match,-1,sizeof(match));\n    int ans = 0;\n    rep(i,m){\n      memset(vis,0,sizeof(vis));\n      ans += aug(i);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint m, n, res;\nint blue[510], red, match[510];\nbool used[510];\nvector<int> g[510];\n\nint gcd(int x, int y)\n{\n\tint t;\n\tif(x < y) swap(x, y);\n\twhile(y)\n\t\tt = x % y, x = y, y = t;\n\treturn x;\n}\n\nbool dfs(int v)\n{\n\tfor(int i = 0; i < g[v].size(); ++i)\n\t{\n\t\tint t = g[v][i];\n\t\tif(used[t]) continue;\n\t\tused[t] = true;\n\t\tif(match[t] == -1 || dfs(match[t]))\n\t\t{\n\t\t\tmatch[t] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> m >> n && m)\n\t{\n\t\tfor(int i = 0; i < m; ++i)\n\t\t\tcin >> blue[i], g[i].clear();\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tcin >> red;\n\t\t\tfor(int j = 0; j < m; ++j)\n\t\t\t\tif(gcd(blue[j], red) > 1)\n\t\t\t\t\tg[j].push_back(i);\n\t\t}\n\t\tres = 0;\n\t\tfill_n(match, n, -1);\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tfill_n(used, n, false);\n\t\t\tif(dfs(i)) ++res;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int INF = (int)1e9;\n\nstruct Edge {\n  int to, cap, rev;\n  Edge(int to_, int cap_, int rev_) :\n    to(to_), cap(cap_), rev(rev_) { }\n};\n\nstruct FordFulkerson {\n  const int V;\n  vector<vector<Edge> > G;\n  vector<bool> used;\n  FordFulkerson(int v) : V(v), G(v), used(v) { }\n  void add_edge(int from, int to, int cap) {\n    G[from].emplace_back(to, cap, G[to].size());\n    G[to].emplace_back(from, 0, G[from].size() - 1);\n  }\n  int find_flow(int v, int t, int f) {\n    if(v == t) return f;\n    used[v] = true;\n    for(Edge &e : G[v]) {\n      if(used[e.to] == false && e.cap > 0) {\n        int d = find_flow(e.to, t, min(f, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t) {\n    int flow = 0;\n    while(true) {\n      used.assign(V, false);\n      int f = find_flow(s, t, INF);\n      if(f == 0) return flow;\n      flow += f;\n    }\n  }\n};\n\nint main() {\n  while(true) {\n    int m, n; cin >> m >> n;\n    if(m == 0 && n == 0) break;\n    int blue[m], red[n];\n    for(int i = 0; i < m; i++) cin >> blue[i];\n    for(int i = 0; i < n; i++) cin >> red[i];\n    FordFulkerson flow(m+n+2);\n    for(int i = 0; i < m; i++) {\n      for(int j = 0; j < n; j++) {\n        if(__gcd(blue[i], red[j]) != 1) {\n          flow.add_edge(i, m + j, 1);\n        }\n      }\n    }\n    for(int i = 0; i < m; i++) flow.add_edge(m+n, i, 1);\n    for(int i = 0; i < n; i++) flow.add_edge(m+i, m+n+1, 1);\n    cout << flow.max_flow(m+n, m+n+1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\nint INF = 10e8;\nint m, n;\nint b[500];\nint r[500];\n\nvector<int> bd[500];\nvector<int> rd[500];\n\nstruct edge{\n    int to, cap, rev;\n};\nbool used[500];\nvector<edge> g[500];\n\nint s, t;\n\nvoid add_edge(int from, int to, int cap){\n    g[from].push_back((edge){to, cap, g[to].size()});\n    g[to].push_back((edge){from, 0, g[from].size()-1});\n}\n\nint dfs(int v, int t, int f){\n    if(v==t) return f;\n    used[v] = true;\n    REP(i, g[v].size()){\n        edge &e = g[v][i];\n        if(!used[e.to] && e.cap>0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d>0){\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f==0) return flow;\n        flow += f;\n    }\n}\n\nbool euclid(int x, int y){\n    if(x<y){\n        int tmp = x;\n        x = y;\n        y = tmp;\n    }\n\n    int r = x % y;\n    while(r!=0){\n        x = y;\n        y = r;\n        r = x % y;\n    }\n\n    if(y>1){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main(){\n    while(1){\n        cin >> m >> n;\n\n        if(m==0) break;\n\n        REP(i, m) cin >> b[i];\n        REP(i, n) cin >> r[i];\n\n        int s = m+n, t = s+1;\n\n        REP(i, 500) g[i].clear();\n\n        REP(i, m){\n            REP(j, n){\n                if(euclid(b[i], r[j])){\n                    add_edge(i, m+j, 1);\n                }\n            }\n        }\n\n        REP(i, m) add_edge(s, i, 1);\n        REP(i, n) add_edge(m+i, t, 1);\n\n        int output = max_flow(s, t);\n        cout << output << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\nint INF = 10e8;\nint m, n;\nint b[500];\nint r[500];\n\nvector<int> bd[500];\nvector<int> rd[500];\n\nstruct edge{\n    int to, cap, rev;\n};\nbool used[500];\nvector<edge> g[500];\n\nint s, t;\n\nvoid add_edge(int from, int to, int cap){\n    g[from].push_back((edge){to, cap, g[to].size()});\n    g[to].push_back((edge){from, 0, g[from].size()-1});\n}\n\nint dfs(int v, int t, int f){\n    if(v==t) return f;\n    used[v] = true;\n    REP(i, g[v].size()){\n        edge &e = g[v][i];\n        if(!used[e.to] && e.cap>0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d>0){\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f==0) return flow;\n        flow += f;\n    }\n}\n\nbool euclid(int x, int y){\n    if(x<y){\n        int tmp = x;\n        x = y;\n        y = tmp;\n    }\n\n    int r = x % y;\n    while(r!=0){\n        x = y;\n        y = r;\n        r = x % y;\n    }\n\n    if(y>1){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main(){\n    cin >> m >> n;\n    REP(i, m) cin >> b[i];\n    REP(i, n) cin >> r[i];\n\n    int s = m+n, t = s+1;\n\n    REP(i, m){\n        REP(j, n){\n            if(euclid(b[i], r[j])){\n                add_edge(i, m+j, 1);\n            }\n        }\n    }\n\n    REP(i, m) add_edge(s, i, 1);\n    REP(i, n) add_edge(m+i, t, 1);\n\n    int output = max_flow(s, t);\n    cout << output << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<long long> VL;\ntypedef vector<vector<long long>> VVL;\ntypedef vector<string> VS;\ntypedef pair<int, int> P;\ntypedef tuple<int,int,int> tpl;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define SORT(c) sort((c).begin(),(c).end())\n#define REVERSE(c) reverse((c).begin(),(c).end())\n#define EXIST(m,v) (m).find((v)) != (m).end()\n#define LB(a,x) lower_bound((a).begin(), (a).end(), x) - (a).begin()\n#define UB(a,x) upper_bound((a).begin(), (a).end(), x) - (a).begin()\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define RFOR(i,a,b) for(int i=(a)-1;i>=(b);--i)\n#define RREP(i,n) RFOR(i,n,0)\n\n#define en \"\\n\"\n\nconstexpr double EPS = 1e-9;\nconstexpr double PI  = 3.1415926535897932;\nconstexpr int INF = 2147483647;\nconstexpr long long LINF = 1LL<<60;\nconstexpr long long MOD = 1000000007; // 998244353;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nlong long gcd(long long x, long long y){return x % y == 0 ? y : gcd(y, x%y);}\n\nstruct MaxFlow{\n    int n;\n    struct edge{\n        int to, cap, rev;\n        edge(int to, int cap, int rev):to(to), cap(cap), rev(rev) {}\n    };\n    vector<vector<edge>> G;\n    vector<int> level, iter;\n\n    MaxFlow(int N): n(N){\n        G.resize(N);\n        level.resize(N);\n        iter.resize(N);\n    }\n\n    void add_edge(int from, int to, int cap){\n        G[from].emplace_back(to, cap, G[to].size());\n        G[to].emplace_back(from, 0, G[from].size()-1);\n    }\n\n    void bfs(int s){\n        level.assign(n, -1);\n        queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while(!q.empty()){\n            int v = q.front(); q.pop();\n            for(int i=0; i<G[v].size(); i++){\n                edge& e = G[v][i];\n                if(0 < e.cap && level[e.to] < 0){\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    int dfs(int v, int t, int f){\n        if(v == t) return f;\n        for(int& i = iter[v]; i<G[v].size(); i++){\n            edge& e = G[v][i];\n            if(0 < e.cap && level[v] < level[e.to]){\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int max_flow(int s, int t){\n        // O(|E||V|^2)\n        int flow = 0;\n        for(;;){\n            bfs(s);\n            if(level[t] < 0) return flow;\n            iter.assign(n, 0);\n            int f;\n            while((f = dfs(s, t, INF)) > 0){\n                flow += f;\n            }\n        }\n    }\n};\n\nint m,n;\n\nvoid Main(){\n    VI b(m), r(n);\n    REP(i,m) cin >> b[i]; REP(i,n) cin >> r[i];\n\n    MaxFlow mf(n+m+2);\n\n    REP(i,m)REP(j,n){\n        int g = gcd(b[i],r[j]);\n        if(g>1) mf.add_edge(i,j+m,1);\n    }\n\n    REP(i,m) mf.add_edge(n+m,i,1);\n    REP(i,n) mf.add_edge(i+m,n+m+1,1);\n\n    int ans = mf.max_flow(n+m,n+m+1);\n    cout << ans << en;\n    return;\n}\n\nint main(void){\n    cin.tie(0);cout.tie(0);ios_base::sync_with_stdio(0);cout<<fixed<<setprecision(15);\n    m = n = 1;\n    while(1){\n        cin >> m >> n;\n        if(m==0 && n==0) break;\n        Main();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint m, n;\nint blue[505];\nint red[505];\n\nbool bluematch[505];\nint redpair[505];\n\nint path[505][505];\n\nint gcd(int a, int b)\n{\n    int m;\n    \n    while(1){\n        m = a%b;\n        if(m==0)\n            return b;\n        a = b;\n        b = m;\n    }\n    return 1;\n}\n\nbool match(int x){\n    if(x<0) return true;\n    \n    if(bluematch[x]){\n        return false;\n    }\n    bluematch[x]=true;\n    \n    for(int y=0; y<n; y++){\n        if(!path[x][y]) continue;\n        if(match(redpair[y])){\n            redpair[y]=x;\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    \n    int i, j, cnt;\n    while(1){\n        cin >> m >> n;\n        if(m==0)\n            return 0;\n        \n        for(i=0;i<m;i++){\n            cin >> blue[i];\n        }\n        \n        for(i=0;i<n;i++){\n            cin >> red[i];\n        }\n        \n        for(i=0; i<m; i++){\n            for(j=0; j<n; j++){\n                if(gcd(blue[i],red[j])!=1){\n                    path[i][j]=1;\n                }\n                else{\n                    path[i][j]=0;\n                }\n            }\n        }\n        \n        fill(redpair, redpair+n, -1);\n        cnt=0;\n        for(i=0; i<m; i++){\n            fill(bluematch, bluematch+m, 0);\n            if(match(i)){\n                cnt++;\n            }\n        }\n        cout << cnt << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint m, n;\n\ntypedef int Weight;\ntypedef int Flow;\nstruct Edge {\n\tint src, dest, rev;\n\tFlow cap;\n\tWeight cost;\n\tbool operator < (const Edge &rhs) const\n\t{\n\t\treturn cost > rhs.cost;\n\t}\n\tEdge(int s, int d) : src(s), dest(d) { ; }\n\tEdge(int s, int d, int c) : src(s), dest(d), cost(c) { ; }\n\tEdge(int s, int d, int r, Flow cp, Weight cst) : src(s), dest(d), rev(r), cap(cp), cost(cst) { ; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int src, int dest, Flow cap)\n{\n\tg[src].push_back(Edge{ src, dest, (int)g[dest].size(), cap, 0 });\n\tg[dest].push_back(Edge{ dest, src, (int)g[src].size() - 1, 0, 0 });\n}\n\nvoid add_edge(Graph &g, int from, int to, Flow cap, Weight cost)\n{\n\tg[from].push_back(Edge(from, to, (int)g[to].size(), cap, cost));\n\tg[to].push_back(Edge(to, from, (int)g[from].size() - 1, 0, -cost));\n}\n\nFlow dfs(Graph &g, vector<bool> &used, int v, int t, Flow f)\n{\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (Edge& e : g[v])\n\t{\n\t\tif (!used[e.dest] && e.cap > 0)\n\t\t{\n\t\t\tFlow d = dfs(g, used, e.dest, t, min(f, e.cap));\n\t\t\tif (d > 0)\n\t\t\t{\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.dest][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nFlow ford_fulkerson(Graph &g, int s, int t)\n{\n\tFlow flow = 0;\n\tfor (;;)\n\t{\n\t\tvector<bool> used(g.size(), false);\n\t\tFlow f = dfs(g, used, s, t, INF);\n\t\tif (f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\nll gcd(ll a, ll b)\n{\n\tif (a < b) swap(a, b);\n\treturn (a%b ? gcd(a%b, b) : b);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\twhile (cin >> m >> n, m)\n\t{\n\t\tGraph g(m + n + 2);\n\t\tint src = m + n, sink = m + n + 1;\n\t\tREP(i, m) add_edge(g, src, i, 1);\n\t\tREP(i, n) add_edge(g, i + m, sink, 1);\n\t\tvi a(m), b(n);\n\t\tREP(i, m) cin >> a[i];\n\t\tREP(i, n) cin >> b[i];\n\t\tREP(i, m)REP(j, n)\n\t\t{\n\t\t\tif (gcd(a[i], b[j]) != 1) add_edge(g, i, j + m, 1);\n\t\t}\n\t\tcout << ford_fulkerson(g, src, sink) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\nint INF = INT_MAX / 6;\nconst int MAX_V = 1003;\n\n// ????????¨????§??????? (???????????????????????????)\nstruct edge { int to, cap, rev; };\nvector<edge> G[MAX_V]; // ??°???????????£??\\???????????¨???\nint level[MAX_V]; // s??????????????¢\nint iter[MAX_V]; // ???????????§??????????????£??????\n\t\t\t\t // from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge( int from, int to, int cap ) {\n\tedge a;\n\ta.to = to;\n\ta.cap = cap;\n\ta.rev = G[to].size();\n\tG[from].push_back( a );\n\tedge b;\n\tb.to = from;\n\tb.cap = 0;\n\tb.rev = G[from].size() - 1;\n\tG[to].push_back( b );\n}\n// s????????????????????¢???BFS??§?¨??????????\nvoid bfs( int s ) {\n\tmemset( level, -1, sizeof( level ) );\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push( s );\n\twhile( !que.empty() ) {\n\t\tint v = que.front(); que.pop();\n\t\tfor( int i = 0; i < G[v].size(); i++ ) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif( e.cap > 0 && level[e.to] < 0 ) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push( e.to );\n\t\t\t}\n\t\t}\n\t}\n}\n// ?¢?????????????DFS??§??¢???\nint dfs( int v, int t, int f ) {\n\tif( v == t ) return f;\n\tfor( int &i = iter[v]; i < G[v].size(); i++ ) {\n\t\tedge &e = G[v][i];\n\t\tif( e.cap > 0 && level[v] < level[e.to] ) {\n\t\t\tint d = dfs( e.to, t, min( f, e.cap ) );\n\t\t\tif( d > 0 ) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n// s??????t???????????§???????±???????\nint max_flow( int s, int t ) {\n\tint flow = 0;\n\tfor( ;;) {\n\t\tbfs( s );\n\t\tif( level[t] < 0 ) return flow;\n\t\tmemset( iter, 0, sizeof( iter ) );\n\t\tint f;\n\t\twhile( ( f = dfs( s, t, INF ) ) > 0 ) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint gcd( int a, int b ) {\n\tif( a < b ) {\n\t\treturn gcd( b, a );\n\t}\n\tif( b == 0 ) {\n\t\treturn a;\n\t}\n\treturn gcd( b, a%b );\n}\n\nint main() {\n\twhile( true ) {\n\t\tlong long int N, M;\n\t\tcin >> N >> M;\n\t\tif( N == 0 && M == 0 ) {\n\t\t\tbreak;\n\t\t}\n\t\tfor( size_t i = 0; i < MAX_V; i++ ) {\n\t\t\tG[i].clear();\n\t\t}\n\t\tvector<int>B( N ), R( M );\n\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\tcin >> B[i];\n\t\t\tadd_edge( N + M + 1, i, 1 );\n\t\t}\n\t\tfor( size_t j = 0; j < M; j++ ) {\n\t\t\tint r;\n\t\t\tcin >> r;\n\t\t\tfor( size_t i = 0; i < N; i++ ) {\n\t\t\t\tif( gcd( r, B[i] ) != 1 ) {\n\t\t\t\t\tadd_edge( i, j + N, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t\tadd_edge( j + N, N + M + 2, 1 );\n\t\t}\n\t\tcout << max_flow( N + M + 1, N + M + 2 ) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 30000000000000LL\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 998244353LL\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\nlong long powering(long long now,long long now_go){\n\tlong long ans = 1;\n\twhile (now_go != 0) {\n\t\tif (now_go % 2 == 1) {\n\t\t\tans *= now;\n\t\t\tans %= MAX_MOD;\n\t\t}\n\t\tnow *= now;\n\t\tnow %= MAX_MOD;\n\t\tnow_go /= 2;\n\t}\n\treturn ans;\n}\nvector<long long> calc(vector<long long> a, vector<long long> b) {\n\tlong long k = sqrt(a.size());\n\tvector<long long> ans;\n\tfor (int i = 0; i < k; ++i) {\n\t\tfor (int q = 0; q < k; ++q) {\n\t\t\t//ans[i][q]を計算する\n\t\t\tlong long geko = 0;\n\t\t\tfor (int t = 0; t < k; ++t) {\n\t\t\t\tgeko += a[i * k + t] * b[t * k + q];\n\t\t\t\tgeko %= MAX_MOD;\n \t\t\t}\n\t\t\tans.push_back(geko);\n\t\t}\n\t}\n\treturn ans;\n}\nvector<long long> powered(vector<long long> a, long long n) {\n\tvector<long long> ans = a;\n\tn--;\n\twhile (n != 0) {\n\t\tif (n % 2 == 1) {\n\t\t\tans = calc(ans, a);\n\t\t}\n\t\ta = calc(a, a);\n\t\tn /= 2;\n\t}\n\treturn ans;\n}\nlong long inv(long long now) {\n\treturn powering(now, MAX_MOD - 2LL);\n}\nlong long dping[1002][1002] = {};\nvector<int>  dp_move[1002];\nint visited[1002] = {};\nint solve(int now) {\n\tif (now == 1001) return 1;\n\tfor (int i = 0; i < dp_move[now].size(); ++i) {\n\t\tif (visited[dp_move[now][i]] == 0) {\n\t\t\tif (dping[now][dp_move[now][i]] > 0) {\n\t\t\t\tvisited[dp_move[now][i]] = 1;\n\t\t\t\tint geko = solve(dp_move[now][i]);\n\t\t\t\tif (geko == 1) {\n\t\t\t\t\tdping[now][dp_move[now][i]]--;\n\t\t\t\t\tif(now != 1000)\n\t\t\t\t\tdping[dp_move[now][i]][now]++;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nint main(){\n#define int long long\n\twhile (true) {\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif (n == 0) return 0;\n\t\tvector<int> a, b;\n\t\tREP(i, n) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\ta.push_back(c);\n\t\t}\n\t\tREP(i, m) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tb.push_back(c);\n\t\t}\n\t\tREP(i, 1002) {\n\t\t\tdp_move[i].clear();\n\t\t}\n\t\tREP(i, 1002) {\n\t\t\tREP(q, 1002) {\n\t\t\t\tdping[i][q] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int q = 0; q < m; ++q) {\n\t\t\t\tif (gcd(a[i],b[q]) > 1) {\n\t\t\t\t\tdp_move[i].push_back(500 + q);\n\t\t\t\t\tdp_move[500 + q].push_back(i);\n\t\t\t\t\tdping[i][500 + q] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdping[1000][i] = 1;\n\t\t\tdp_move[1000].push_back(i);\n\t\t\tdp_move[i].push_back(1000);\n\t\t}\n\t\tREP(i, m) {\n\t\t\tdping[i + 500][1001] = 1;\n\t\t\tdp_move[i + 500].push_back(1001);\n\t\t}\n\t\tREP(i, 1002) {\n\t\t\tvisited[i] = 0;\n\t\t}\n\t\tvisited[1000] = 1;\n\t\tint ans = 0;\n\t\twhile (solve(1000)) {\n\t\t\tREP(i, 1002) {\n\t\t\t\tvisited[i] = 0;\n\t\t\t}\n\t\t\tvisited[1000] = 1;\n\t\t\tans++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < int(Y);++(X))\n#define peat(X,Y) for (;(X) < int(Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nint INF=1e5;\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\nWeight augment(const Graph &g, const Matrix &capacity, Matrix &flow,\n    const vector<int> &level, vector<bool> &finished, int u, int t, Weight cur) {\n  if (u == t || cur == 0) return cur;\n  if (finished[u]) return 0;\n  finished[u] = true;\n  FOR(e, g[u]) if (level[e->dst] > level[u]) {\n    Weight f = augment(g, capacity, flow, level, finished,\n        e->dst, t, min(cur, RESIDUE(u, e->dst)));\n    if (f > 0) {\n      flow[u][e->dst] += f; flow[e->dst][u] -= f;\n      finished[u] = false;\n      return f;\n    }\n  }\n  return 0;\n}\nWeight maximumFlow(const Graph &g, int s, int t) {\n  int n = g.size();\n  Matrix flow(n, Array(n)), capacity(n, Array(n)); // adj. matrix\n  REP(u,n) FOR(e,g[u]) capacity[e->src][e->dst] += e->weight;\n\n  Weight total = 0;\n  for (bool cont = true; cont; ) {\n    cont = false;\n    vector<int> level(n, -1); level[s] = 0; // make layered network\n    queue<int> Q; Q.push(s);\n    for (int d = n; !Q.empty() && level[Q.front()] < d; ) {\n      int u = Q.front(); Q.pop();\n      if (u == t) d = level[u];\n      FOR(e, g[u]) if (RESIDUE(u,e->dst) > 0 && level[e->dst] == -1)\n        Q.push(e->dst), level[e->dst] = level[u] + 1;\n    }\n    vector<bool> finished(n); // make blocking flows\n    for (Weight f = 1; f > 0; ) {\n      f = augment(g, capacity, flow, level, finished, s, t, INF);\n      if (f == 0) break;\n      total += f; cont = true;\n    }\n  }\n  return total;\n}\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int i,j,k;\n  int n,m;\n  while(1){\n    cin>>n>>m;\n    if(!n)break;\n    vector<int> b(n),r(m);\n    rep(i,n)\n      cin>>b[i];\n    rep(i,m)\n      cin>>r[i];\n    Graph g(n+m+2);\n    rep(i,n)\n      g[0].pb(Edge(0,i+2,1));\n    rep(i,m)\n      g[i+n+2].pb(Edge(i+n+2,1,1));\n    rep(i,n)\n      rep(j,m)\n        if(__gcd(b[i],r[j])>1){\n          g[i+2].pb(Edge(i+2,j+n+2,1));\n          g[j+n+2].pb(Edge(j+n+2,i+2,0));\n        }\n    cout<<maximumFlow(g,0,1)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\ntypedef pair<int,vector<int> > piv;\ntypedef vector< vector<int> > vvi;\n\nint g[1002][1002];\nint s, t;\nvector<int> res;\nbool visit[1002];\nint m, n;\n\nbool dfs(int p) {\n\tif(p == t) {\n\t\tres.push_back(p);\n\t\treturn true;\n\t}\n\trep(i, n+m+2) {\n\t\tif( !visit[i] && g[p][i] ) {\n\t\t\tvisit[i] = true;\n\t\t\tif( dfs(i) ) {\n\t\t\t\tres.push_back(p);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\twhile(cin >> m >> n, m) {\n\t\tmemset(g, 0, sizeof(g));\n\t\tvector<int> b(m), r(n);\n\t\trep(i,m) {\n\t\t\tcin >> b[i];\n\t\t}\n\t\trep(i,n) {\n\t\t\tcin >> r[i];\n\t\t}\n\t\trep(i, m) {\n\t\t\trep(j, n) {\n\t\t\t\tg[i][j+m] = ( __gcd(b[i], r[j]) > 1 ? 1 : 0);\n\t\t\t\tg[j+m][i] = 0;\n\t\t\t}\n\t\t}\n\t\ts = m+n;\n\t\tt = m+n+1;\n\t\trep(i, m) {\n\t\t\tg[s][i] = 1;\n\t\t}\n\t\trep(i, n) {\n\t\t\tg[i+m][t] = 1;\n\t\t}\n\t\twhile(1) {\n\t\t\tmemset(visit, 0, sizeof(visit));\n\t\t\tres.clear();\n\t\t\tif( dfs(s) ) {\n\t\t\t\treverse(res.begin(), res.end());\n\t\t\t\trep(i, res.size()-1) {\n\t\t\t\t\tg[res[i]][res[i+1]] = 0;\n\t\t\t\t\tg[res[i+1]][res[i]] = 1;\n\t\t\t\t}\n\t\t\t} else break;\n\t\t}\n\t\tint cnt = 0;\n\t\trep(i, m) {\n\t\t\trep(j, n) {\n\t\t\t\tif( g[j+m][i] ) {\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// MEMO\n//\n// O(VE)\n\n// THE BEGINNING OF THE LIBRARY.\n\nstruct BipartiteMatching {\n\tusing UnWeightedGraph=vector< vector<int> >;\n\n\tint n;\n\tUnWeightedGraph G;\n\tvector<int> match,used;\n\n\tBipartiteMatching() {}\n\tBipartiteMatching(int sz):n(sz),G(sz),match(sz),used(sz) {}\n\n\tvoid add_edge(int u,int v) {\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\n\tbool dfs(int v) {\n\t\tused[v]=true;\n\t\tfor(auto u:G[v]) {\n\t\t\tint w=match[u];\n\t\t\tif(w<0||(!used[w]&&dfs(w))) {\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint bipartite_matching() {\n\t\tint res=0;\n\t\tfill(match.begin(),match.end(),-1);\n\t\tfor(int v=0;v<n;v++) {\n\t\t\tif(match[v]<0) {\n\t\t\t\tfill(used.begin(),used.end(),0);\n\t\t\t\tif(dfs(v)) res++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint gcd(int a,int b) {\n\tif(a<b) swap(a,b)\n\tint r;\n\twhile(a%b!=0) {\n\t\tr=b;b=a%b;a=r;\n\t}\n\treturn b;\n}\n\n// THE ENDING OF THE LIBRARY.\n// THE FOLLOWING IS AN EXAMPLE OF USE.\n\nint main() {\n\n\tint m,n;\n\tcin>>m>>n;\n\tvector<int> a(m),b(n);\n\tfor(int i=0;i<m;i++) cin>>a[i];\n\tfor(int i=0;i<n;i++) cin>>b[i];\n\tBipartiteMatching bimatch(m+n);\n\tfor(int i=0;i<m;i++) {\n\t\tfor(int j=0;j<n;j++) {\n\t\t\tif(gcd(a[i],b[j])!=1) bimatch.add_edge(i,j+m);\n\t\t}\n\t}\n\tcout<<bimatch.bipartite_matching()<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define uint unsigned int\n#define dotimes(i, n) for (int i = 0, i##max__ = (n); i < i##max__; i++)\n#define whole(x, f, ...) ([&](decltype((x)) c__) { return (f)(begin(c__), end(c__), ## __VA_ARGS__); })(x)\n\nint rint() { int x; scanf(\"%lld\", &x); return x; }\nvoid wint(int x) { printf(\"%lld\\n\", x); }\n\ntemplate<typename T> int size(T const& c) { return static_cast<int>(c.size()); }\ntemplate<typename T> bool maxs(T& a, T const& b) { return a < b ? a = b, true : false; }\ntemplate<typename T> bool mins(T& a, T const& b) { return a > b ? a = b, true : false; }\ninline int lg(int x) { return 63 - __builtin_clzll(static_cast<unsigned int>(x)); }\n\n#ifdef EBUG\n#define INT_WIDTH \"\"\n#include \"debug.h\"\n#else\n#define inspect(...) do {} while (0)\n#define debugf(...) do {} while (0)\n#define debugv(...) do {} while (0)\n#endif\n\nint dinic(const int s, const int t, vector<vector<tuple<int, int&, int&>>>& capacities) {\n  const int n = ::size(capacities);\n  int r = 0;\n  queue<int> q;\n  vector<int> levels, progresses;\n  for (;;) {\n    // BFS\n    levels.assign(n, -1);\n    q.emplace(s);\n    levels[s] = 0;\n    while (!q.empty()) {\n      const int u = q.front(), l = levels[u] + 1;\n      q.pop();\n      for (auto&& p : capacities[u]) {\n        int v = get<0>(p);\n        if (levels[v] < 0 && get<1>(p) > 0) {\n          levels[v] = l;\n          q.emplace(v);\n        }\n      }\n    }\n    if (levels[t] < 0)\n      break;\n    // DFS\n    progresses.assign(n, 0);\n    function<int(int, int)> rec;\n    rec = [&](int u, int f) {\n      if (u == s)\n        return f;\n      const int l = ::size(capacities[u]);\n      int r = 0;\n      for (int& progress = progresses[u]; progress < l; progress++) {\n        auto&& p = capacities[u][progress];\n        int v = get<0>(p);\n        if (get<2>(p) > 0 && levels[v] < levels[u]) {\n          int x = rec(v, min(get<2>(p), f));\n          if (x > 0) {\n            get<1>(p) += x;\n            get<2>(p) -= x;\n            f -= x;\n            r += x;\n            if (f == 0)\n              break;\n          }\n        }\n      }\n      return r;\n    };\n    r += rec(t, 1LL << 61);\n  }\n  return r;\n}\n\ntemplate<typename T>\nint dinic(const int n, const int s, const int t, T const& edges) {\n  vector<vector<tuple<int, int&, int&>>> capacities(n);\n  vector<pair<int, int>> underlying_capacities;\n  underlying_capacities.reserve(edges.size());\n  // p = ((u, v), (capacity of u -> v, capacity of v -> u))\n  for (pair<pair<int, int>, pair<int, int>> const& p : edges) {\n    underlying_capacities.push_back(p.second);\n    auto& uc = underlying_capacities.back();\n    capacities[p.first.first].emplace_back(p.first.second, uc.first, uc.second);\n    capacities[p.first.second].emplace_back(p.first.first, uc.second, uc.first);\n  }\n  return dinic(s, t, capacities);\n}\n\nsigned main() {\n  for (;;) {\n    const int m = rint();\n    const int n = rint();\n    if (!m && !n)\n      break;\n    vector<pair<pair<int, int>, pair<int, int>>> edges;\n    vector<int> blues, reds;\n    dotimes(i, m) {\n      blues.emplace_back(rint());\n      edges.emplace_back(make_pair(0, i+2), make_pair(1, 0));\n    }\n    dotimes(i, n) {\n      reds.emplace_back(rint());\n      edges.emplace_back(make_pair(1, i+m+2), make_pair(0, 1));\n    }\n    dotimes(i, m)\n      dotimes(j, n)\n        if (__gcd(blues[i], reds[j]) > 1)\n          edges.emplace_back(make_pair(i+2, j+m+2), make_pair(1, 0));\n    wint(dinic(m+n+2, 0, 1, edges));\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\nconst int INF = 1e9;\nconst int MAX_V = 300000;\n\nint m, n;\nstruct Flow{\n    struct edge{\n        int to, cap, rev;\n    };\n    vector<edge> G[MAX_V];//??£??\\?????????\n    bool used[MAX_V];\n\n    void add_edge(int from, int to, int cap){\n        G[from].push_back((edge){to, cap, (int)G[to].size()});//from -> to\n        G[to].push_back((edge){from, 0, (int)G[from].size() - 1});//to -> from\n    }\n\n    //?¢???????????????¢???\n    int dfs(int v, int t, int f){\n        if(v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); ++i){\n            edge &e = G[v][i];\n            if(!used[e.to] && e.cap > 0){\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    //s??????t???????????§???\n    int max_flow(int s, int t){\n        int flow = 0;\n        while(1){\n            memset(used, 0, sizeof(used));\n            int f = dfs(s, t, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nint b[510], r[510];\nint main(void){\n\twhile(1){\n        cin >> m >> n;\n        if(m == 0 && n == 0) return 0;\n        rep(i, m) cin >> b[i];\n        rep(i, n) cin >> r[i];\n        int s = m + n, t = m + n + 1;\n        Flow mf;\n        //s -> b\n        rep(i, m){\n            mf.add_edge(s, i, 1);\n        }\n        //r -> t\n        rep(i, n){\n            mf.add_edge(m + i, t, 1);\n        }\n        //b -> r\n        rep(i, m)rep(j, n){\n            if(__gcd(b[i], r[j]) > 1){//1??\\???????´???°?????????\n                mf.add_edge(i, m + j, 1);\n            }\n        }\n        printf(\"%d\\n\", mf.max_flow(s, t));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<string>\n#include<cmath>\n#include<cassert>\n#include<map>\n  using namespace std;\n\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ (i)=0;(i)<(j);(i)++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);(i)++)\n#define all(v) begin(v),end(v)\n\n#define MAX_N 510\nclass maxFlow\n{\npublic:\n  int N;//???????????°\n  int G[MAX_N][MAX_N];//G[i][j] :=???i??????j????????§?????????\n  bool is_visited[MAX_N];\n\n  maxFlow(int n)\n  {\n    N=n;\n    //?????????????????¨????????°???????????§??????\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tG[i][j]=0;\n  }\n\n  //n1->n2???arc?????????\n  void add_arc(int n1,int n2,int capacity)\n  {\n    G[n1][n2]+=capacity;//????????§?????±???\n  }\n\n  //??´???????????§???????????¢?´¢\n  int dfs(int now,int end,int min_capacity)\n  {\n    if(now==end)return min_capacity;\n    if(!is_visited[now])\n      {\n\tis_visited[now]=true;\n\tfor(int i=0;i<N;i++){\n\t  if(G[now][i]>0){//now??????i????????§??????????????????????????°????????§??????\n\t    int ret=dfs(i,end,min(min_capacity,G[now][i]));\n\t    if(ret>0){//??´???????????????????????????????????§?¢???????????????????????????????????????´??°\n\t      G[now][i]-=ret;\n\t      G[i][now]+=ret;\n\t      return ret;\n\t    }\n\t  }\n\t}\n\treturn -2;//??´????????????????????????????????£???\n      }\n    else return -1;//?????§????¨???????????????£???\n  }\n  \n  int get_maxFlow(int start,int end)\n  {\n    int temp,ans=0;\n    //??´???????????????????????????????????§????????????????????????????????????????´¢\n    while(true){\n      for(int i=0;i<N;i++)is_visited[i]=false;\n      temp=dfs(start,end,100);\n      if(temp>0)ans+=temp;\n      else break;\n    }\n    return ans;\n  }\n  \n};\n\nint gcd(int a,int b){\n  if(b==0)return a;\n  return gcd(b,a%b);\n}\n\nint main()\n{\n  int n,m;\n\n  while(true){\n    cin>>m>>n;\n    if(m==0&&n==0)break;\n    maxFlow G(m+n+2);\n    vector<int> b(m);\n    vector<int> r(n);\n    rep(i,m){\n      cin>>b[i];\n      G.add_arc(m+n, i, 1);\n    }\n    rep(i,n){\n      cin>>r[i];\n      G.add_arc(m+i, m+n+1 , 1);\n    }\n    \n    rep(i,m){\n      rep(j,n){\n        if(gcd(b[i],r[j])!=1){\n          G.add_arc(i, m+j, 1);\n        }\n      }\n    }\n\n    cout<<G.get_maxFlow(m+n, m+n+1)<<endl;\n    \n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define inf 1000000000\n\nusing namespace std;\n\nstruct edge{\n\tint to, cap, rev;\n\tedge(int a, int b, int c){\n\t\tto = a, cap = b, rev = c;\n\t}\n};\n\nint V, S, T;\nint m, n;\nint b[505], r[505];\nvector<edge> G[1005];\nbool used[1005];\n\nvoid addedge(int s, int t)\n{\n\tG[s].push_back( edge(t, 1, G[t].size()) );\n\tG[t].push_back( edge(s, 0, G[s].size() - 1) );\n}\n\nint gcd(int a, int b)\n{\n\tif(b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\nint dfs(int v, int t, int c)\n{\n\tif(v == t) return c;\n\tused[v] = true;\n\t\n\tint ret;\n\tfor(int i = 0; i < (int)G[v].size(); i++){\n\t\tif(used[G[v][i].to] || G[v][i].cap == 0) continue;\n\t\tret = dfs(G[v][i].to, t, min(c, G[v][i].cap));\n\t\tif(ret > 0){\n\t\t\tG[v][i].cap -= ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap += ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> m >> n;\n\t\tif(m == 0 && n == 0) break;\n\t\tV = m + n;\n\t\tS = 0, T = V+1;\n\t\t\n\t\tfor(int i = 1; i <= m; i++) cin >> b[i];\n\t\tfor(int i = 1; i <= n; i++) cin >> r[i];\n\t\t\n\t\tfor(int i = 0; i <= T; i++) G[i].clear();\n\t\tfor(int i = 1; i <= m; i++) addedge(S, i); \n\t\tfor(int i = 1; i <= n; i++) addedge(m+i, T);\n\t\t\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tif(gcd(b[i], r[j]) == 1) continue;\n\t\t\t\taddedge(i, m+j);\n\t\t\t\taddedge(m+j, i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ret, ans = 0;\n\t\twhile(1){\n\t\t\tfor(int i = 0; i <= T; i++) used[i] = false;\n\t\t\tret = dfs(S, T, inf);\n\t\t\tif(ret == 0) break;\n\t\t\tans += ret;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\nint gcd(int m, int n) {\n    if(m < n) return gcd(n, m);\n    while(n != 0) {\n        int tmp = m % n;\n        m = n;\n        n = tmp;\n    }\n    return m;\n}\n\n//flow_vÍÚ±zñ\n//pairÍ<s«æ, RXg>\nint maxflow(const vector<vector<pair<int, int> > > &flow_v, int s, int g) {\n    int size = flow_v.size();\n    //×ÚsñÉÏ·\n    //Å©ç×ÚsñnµÈç±±Í¢çÈ¢\n    /*****½¾µAtûüÉÌRXgªüÁÄ¢é©ÍvmF*****/\n    vector<vector<int> > capacity(size, vector<int>(size, 0));\n    for(int i = 0; i < size; ++i) {\n        for(int j = 0; j < flow_v[i].size(); ++j) {\n            int to = flow_v[i][j].first;\n            int cost = flow_v[i][j].second;\n            capacity[i][to] = cost;\n        }\n    }\n    vector<vector<int> > flow(size, vector<int>(size, 0));\n\n    int ans = 0;\n    while(true) {\n        //DæTõÅaugument flowðÝÂ¯é\n        queue<int> q;\n        vector<int> prev(size, -1);\n        prev[s] = s;\n        q.push(s);\n        while(!q.empty()) {\n            int n = q.front();\n            q.pop();\n            for(int i = 0; i < size; ++i) {\n                if(capacity[n][i]-flow[n][i] <= 0) continue;\n                if(prev[i] != -1) continue;\n                prev[i] = n;\n                q.push(i);\n                if(i == g) goto endloop;\n            }\n        }\nendloop:\n        if(prev[g] == -1) break;\n        int res = INT_MAX;\n        for(int i = g; prev[i] != i; i = prev[i]) {\n            res = min(res, capacity[prev[i]][i]-flow[prev[i]][i]);\n        }\n        for(int i = g; prev[i] != i; i = prev[i]) {\n            flow[prev[i]][i] += res;\n            flow[i][prev[i]] -= res;\n        }\n        ans += res;\n    }\n    return ans;\n}\n\nint main() {\n    while(true) {\n        int m, n;\n        cin >> m >> n;\n        if(!m && !n) break;\n\n        vector<int> cards(m+n);\n        vector<vector<pair<int, int> > > graph(m+n+2);\n        for(int i = 0; i < m; ++i) {\n            cin >> cards[i];\n            graph[m+n].push_back(make_pair(i, 1)); //Start node\n        }\n        for(int i = m; i < m+n; ++i) {\n            cin >> cards[i];\n            for(int j = 0; j < m; ++j) {\n                if(gcd(cards[i], cards[j]) > 1) {\n                    graph[j].push_back(make_pair(i, 1));\n                }\n            }\n            graph[i].push_back(make_pair(m+n+1, 1)); //Goal node\n        }\n        cout << maxflow(graph, m+n, m+n+1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nstruct edge\n{\n    int to,cap,rev;\n};\n\nclass BM {\nprivate:\n    vector<vector<edge> > G;\n    vector<int> level;\n    vector<int> iter;\n    int u,v;\n\npublic:\n    BM(vector<int> a,vector<int> b){\n        u = (int)a.size(),v = (int)b.size();\n        G.resize(u+v+2);\n        level.resize(u+v+2);\n        iter.resize(u+v+2);\n        rep(i,a.size()){\n            init_edge(0,i+1);\n        }\n        rep(i,b.size()){\n            init_edge(u+i+1,u+v+1);\n        }\n    }\n\n    void init_edge(int from,int to)\n    {\n        G[from].pb((edge){to,1,G[to].size()});\n    \tG[to].pb((edge){from,0,G[from].size()-1});\n    }\n\n    void add_edge(int from,int to)\n    {\n        from += 1,to += u+1;\n    \tG[from].pb((edge){to,INF,G[to].size()});\n    \tG[to].pb((edge){from,0,G[from].size()-1});\n    }\n\n    void bfs(int s)\n    {\n        fill(all(level),-1);\n    \tqueue<int> que;\n    \tlevel[s] = 0;\n    \tque.push(s);\n    \twhile(!que.empty()){\n    \t\tint v = que.front();\n    \t\tque.pop();\n    \t\trep(i,G[v].size()){\n    \t\t\tedge &e = G[v][i];\n    \t\t\tif(e.cap > 0 && level[e.to] < 0){\n    \t\t\t\tlevel[e.to] = level[v] + 1;\n    \t\t\t\tque.push(e.to);\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n\n    int dfs(int v,int t,int f)\n    {\n    \tif(v==t){\n    \t\treturn f;\n    \t}\n    \tfor(int &i = iter[v];i<G[v].size();i++){\n    \t\tedge &e = G[v][i];\n    \t\tif(e.cap > 0 && level[v] < level[e.to]){\n    \t\t\tint d = dfs(e.to,t,min(f,e.cap));\n    \t\t\tif(d>0){\n    \t\t\t\te.cap -= d;\n    \t\t\t\tG[e.to][e.rev].cap += d;\n    \t\t\t\treturn d;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn 0;\n    }\n\n    int max_flow()\n    {\n    \tint flow = 0;\n        int s=0,t=u+v+1;\n    \tfor(;;){\n    \t\tbfs(s);\n    \t\tif(level[t]<0){\n    \t\t\treturn flow;\n    \t\t}\n            fill(all(iter),0);\n    \t\tint f;\n    \t\twhile((f=dfs(s,t,INF)) > 0){\n    \t\t\tflow += f;\n    \t\t}\n    \t}\n    }\n};\n\nint gcd(int x,int y)\n{\n    if(x % y == 0){\n        return y;\n    }else{\n        return gcd(y,x%y);\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int m,n;\n        cin >> m >> n;\n        if(m == 0 && n == 0){\n            break;\n        }\n        vector<int> a(m),b(n);\n        rep(i,m){\n            cin >> a[i];\n        }\n        rep(i,n){\n            cin >> b[i];\n        }\n        BM bm(a,b);\n        rep(i,m){\n            rep(j,n){\n                if(gcd(a[i],b[j]) > 1){\n                    bm.add_edge(i,j);\n                }\n            }\n        }\n        cout << bm.max_flow() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <list>\n#include <assert.h>\n#include <math.h>\n#include <valarray>\n#include <stdio.h>\n#include <algorithm>\n#include <set>\n#include <complex>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\nstruct edge { LL to, cap, rev, cost; };\n\nconstexpr LL MAX_V = 1200;\nvector<edge> G[MAX_V];\nLL level[MAX_V];\nLL iter[MAX_V];\n\nvoid add_edge(LL from, LL to, LL cap, LL cost = 0) {\n\tG[from].push_back(edge{ to, cap, (LL)G[to].size(),cost });\n\tG[to].push_back(edge{ from,0,(LL)G[from].size() - 1,cost });\n}\n\nvoid bfs(LL s) {\n\tfill_n(level, MAX_V, -1);\n\tqueue<LL> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tLL v = que.front(); que.pop();\n\t\tfor (LL i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nLL dfs(LL v, LL t, LL f) {\n\tif (v == t)return f;\n\tfor (LL &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tLL d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nLL max_flow(LL s, LL t) {\n\tLL flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfill_n(iter, MAX_V, 0);\n\t\tLL f;\n\t\twhile ((f = dfs(s, t, numeric_limits<LL>::max()))>0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\ntypedef pair<LL, LL> P;\nLL V;\nLL h[MAX_V];\nLL dist[MAX_V];\nLL prevv[MAX_V], preve[MAX_V];\n\nLL min_cost_flow(LL s, LL t, LL f) {\n\tLL res = 0;\n\tfill_n(h, V, 0);\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tfill_n(dist, V, numeric_limits<LL>::max());\n\t\tdist[s] = 0;\n\t\tque.push({ 0,s });\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tLL v = p.second;\n\t\t\tif (dist[v] < p.first)continue;\n\t\t\tfor (LL i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == numeric_limits<LL>::max()) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (LL v = 0; v < V; v++)h[v] += dist[v];\n\n\t\tLL d = f;\n\t\tfor (LL v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d*h[t];\n\t\tfor (LL v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tG[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nbool hoge(LL s, LL t) {\n\tif (s%t == 0 || t%s == 0) { return true; }else\n\t\tif (s%t == 1 || t%s == 1) { return false; }\n\t\telse {\n\t\t\treturn hoge(s%t, t%s);\n\t\t}\n}\n\nint main()\n{\n\twhile (true) {\n\t\tREP(i, MAX_V) {\n\t\t\tG[i].erase(G[i].begin(), G[i].end());\n\t\t}\n\t\tLL m, n;\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0) { break; }\n\t\tvector<LL>b(m + 1);\n\t\tvector<LL>r(n + 1);\n\t\tREP(i, m) {\n\t\t\tcin >> b[i];\n\t\t\tadd_edge(0, i + 1, 1);\n\t\t}\n\t\tREP(j, n) {\n\t\t\tcin >> r[j];\n\t\t\tadd_edge(m+j+1, n+m + 1, 1);\n\t\t\tREP(i, m) {\n\t\t\t\tif (hoge(b[i], r[j])) {\n\t\t\t\t\tadd_edge(i + 1, m + j + 1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << max_flow(0, n + m + 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include \"push_relabel.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n  each(x,vec) is >> x;\n  return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n  rep(i,vec.size()) {\n    if (i) os << \" \";\n    os << vec[i];\n  }\n  return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n  rep(i,vec.size()) {\n    if (i) os << endl;\n    os << vec[i];\n  }\n  return os;\n}\n\nclass MaxFlow {\npublic:\n  struct Edge {\n    ll to, cap, dcap, rev;\n    void update() {\n      cap += dcap;\n      dcap = 0;\n    }\n    ll capacity() const {\n      return cap + dcap;\n    }\n  };\n  vector<vector<Edge>> G;\nprivate:\n  bool is_debug;\n  ll V;\n  vector<ll> bfs(ll s) {\n    vector<ll> dist(V, linf);\n    dist[s] = 0;\n    queue<ll> Q; Q.push(s);\n    while ( !Q.empty() ) {\n      ll v = Q.front(); Q.pop();\n      each(e, G[v]) {\n        if (e.cap > 0 && dist[e.to] == linf) {\n          dist[e.to] = dist[v]+1;\n          Q.push(e.to);\n        }\n      }\n    }\n    return dist;\n  }\n  vector<ll> rbfs(ll s) {\n    vector<ll> dist(V, linf);\n    dist[s] = 0;\n    queue<ll> Q; Q.push(s);\n    while ( !Q.empty() ) {\n      ll v = Q.front(); Q.pop();\n      each(e, G[v]) {\n        if (rev(e).cap > 0 && dist[e.to] == linf) {\n          dist[e.to] = dist[v]+1;\n          Q.push(e.to);\n        }\n      }\n    }\n    return dist;\n  }\npublic:\n  const vector<vector<Edge>>& Graph() {\n    return G;\n  }\n  MaxFlow(ll V, bool is_debug=false) : V(V), G(V), is_debug(is_debug) {}\n  void init(ll n) {\n    V = n;\n    G.assign(V, vector<Edge>());\n  }\n  void add(ll from, ll to, ll cap) {\n    if (is_debug) cout << \"ADD: \" << from << \" \" << to << \" \" << cap << endl;\n    assert(V > 0);\n    G[from].pb({to, cap, 0, (ll)G[to].size()});\n    G[to].pb({from, 0, 0, (ll)G[from].size()-1});\n  }\n  // S -> s, T -> t に inf は自力で\n  void add(ll from, ll to, ll min_flow, ll cap, ll S, ll T) {\n    if (is_debug) cout << endl << \"ADD_MIN:\" << from << \" \" << to << \" \" << min_flow << \" \" << cap << endl;\n    add(from, to, cap-min_flow);\n    add(S, to, min_flow);\n    add(from, T, cap);\n    if (is_debug) cout << endl;\n  }\n  Edge& rev(const Edge& e) {\n    return G[e.to][e.rev];\n  }\n  ll flow(ll s, ll t, ll f=linf) {\n    ll res = 0;\n    while (f > 0) {\n      vector<ll> dist = rbfs(t);\n      if (dist[t] == linf) break;\n      vector<vector<ll>> dist_to_nodes(V+1);\n      rep(i, V) {\n        if (dist[i] < linf) {\n          dist_to_nodes[dist[i]].pb(i);\n        }\n      }\n      vector<ll> f(V, 0);\n      f[s] = linf;\n      rrep(i, V+1) each(v, dist_to_nodes[i]) each(e, G[v]) {\n        if (dist[e.to] != dist[v] - 1) continue;\n        if (e.capacity() == 0) continue;\n        ll use = min(e.capacity(), f[v]);\n        f[v] -= use, f[e.to] += use;\n        e.dcap -= use, rev(e).dcap += use;\n      }\n      // cout << \"1: \" << f << endl;\n      // assert(f[t] > 0);\n      if (f[t] == 0) break;\n      res += f[t];\n      f[t] = 0;\n      rep(i, 1, V+1) each(v, dist_to_nodes[i]) each(e, G[v]) {\n        if (dist[e.to] != dist[v] + 1) continue;\n        if (e.dcap <= 0) continue;\n        ll use = min(e.dcap, f[v]);\n        f[v] -= use, f[e.to] += use;\n        e.dcap -= use, rev(e).dcap += use;\n      }\n      // cout << \"2: \" << f << endl;\n      rep(v, V) if (v != s) assert(f[v] == 0);\n      rep(v, V) each(e, G[v]) e.update();\n    }\n    return res;\n  }\n};\n\nll gcd(ll a, ll b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  ll n, m;\n  while (cin >> n >> m, n || m) {\n    vector<ll> a(n), b(m); cin >> a >> b;\n    ll s = n + m, t = s + 1;\n    MaxFlow mf(t+1);\n    rep(i, n) rep(j, m) {\n      if (gcd(a[i], b[j]) > 1) {\n        mf.add(i, n+j, 1);\n      }\n    }\n    rep(i, n) mf.add(s, i, 1);\n    rep(i, m) mf.add(n+i, t, 1);\n    cout << mf.flow(s, t) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string.h>\nusing namespace std;\n\nint V;\nvector<int> G[2000];\nint match[2000];\nbool used[2000];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<(int)G[v].size();i++){\n    int u=G[v][i],w=match[u];\n\n    if( w<0 || !used[w] && dfs(w) ){\n\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\n\nint m,n;\nint b[500],r[500];\n\nint main(){\n  while(cin>>m>>n){\n    if(m==0&&n==0)break;\n\n    for(int i=0;i<m;i++)cin>>b[i];\n    for(int i=0;i<n;i++)cin>>r[i];\n\n    for(int i=0;i<2000;i++)G[i].clear();\n\n    //for(int i=0;i<m;i++)add_edge(n+m,i);\n    //for(int i=0;i<n;i++)add_edge(m+i,n+m+1);\n\n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n\tif( __gcd(b[i],r[j])> 1 )add_edge(i,m+j);\n      }\n    }\n\n    V=m;\n    cout<<bipartite_matching()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nVI visit;\n\ntypedef struct{\n\tint to, rev, cap;\n}edge;\nvoid add_edge(vector<vector<edge> > &g, int s, int e){\n\tedge e1 = {e, g[e].size(), 1};\n\tedge e2 = {s, g[s].size(), 0};\n\tg[s].PB(e1);\n\tg[e].PB(e2);\n}\nint gcd(int a, int b)\n{\n    while( 1 )\n    {\n        a = a % b;\n\t\tif( a == 0 )\n\t\t\treturn b;\n\t\tb = b % a;\n\n        if( b == 0 )\n\t\t\treturn a;\n    }\n}\n\nint dfs(vector<vector<edge> > &g, int s, int t, int f){\n\tif(s==t)return f;\n\tvisit[s] = 1;\n\tREP(i, g[s].size()){\n\t\tedge &e = g[s][i];\n\t\tif(!visit[e.to] && e.cap>0){\n\t\t\tint d = dfs(g, e.to, t, min(f, e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\t\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin >> n>>m;\n\t\tif(n==0)break;\n\t\tvector<vector<edge> > g(n+m+2);\n\t\tVI va(n), vb(m);\n\t\tREP(i,n)cin>>va[i];\n\t\tREP(i,m)cin>>vb[i];\n\t\tREP(i,n){\n\t\t\tREP(j,m){\n\t\t\t\tif(gcd(va[i], vb[j]) > 1){\n\t\t\t\t\tadd_edge(g, i+1, n+j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i,n)add_edge(g, 0, i+1);\n\t\tREP(i,m)add_edge(g, n+i+1, n+m+1);\n\t\tint mf = 0;\n\t\twhile(1){\n\t\t\tint ret = 0;\n\t\t\tvisit = VI(n+m+2, 0);\n\t\t\tret = dfs(g, 0, n+m+1, 1);\n\t\t\tif(ret == 0)break;\n\t\t\tmf += ret;\n\t\t}\n\t\tcout << mf << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n#define V_MAX 1100\n#define INF (1<<25)\n#define pb push_back\n#define sz size()\n#define clr clear()\n\nstruct edge{int f,t,cost,cap,rev;};\n\nvector<edge> G[V_MAX];\nbool use[V_MAX];\nint m,n;\nint b[500],r[500];\n\n\nvoid AddEdge(int from,int to,int cap){\n  G[from].push_back((edge){from,to,0,cap,G[to].size()});\n  G[to].push_back((edge){to,from,0,0,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  use[v] = true;\n  for(int i=0;i<(int)G[v].size();i++){\n    edge &e  = G[v][i];\n    if(!use[e.t] && e.cap > 0){\n      int d = dfs(e.t, t,min(f,e.cap));\n      if(d>0){\n\te.cap -= d;\n\tG[e.t][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint FordFullkerson(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(use,0,sizeof(use));\n    int tmp = dfs(s,t,INF);\n    if(!tmp)return flow;\n    flow += tmp;\n  }\n} \n\nint gcd(int a,int b){\n  if(!b)return a;\n  return gcd(b,a%b);\n}\n\nint main(){\n  while(1){\n    cin >> m >> n;\n    if(!m && !n)break;\n\n    for(int i=0;i<m;i++)cin >> b[i];\n    for(int i=0;i<n;i++)cin >> r[i];\n\n    for(int i=0;i<=m+n+1;i++)G[i].clr;\n    for(int i=1;i<=m;i++)AddEdge(0,i,1);\n    for(int i=m+1;i<=m+n;i++)AddEdge(i,m+n+1,1);\n\n    for(int i=0;i<m;i++)\n      for(int j=0;j<n;j++)\n\tif(gcd(b[i],r[j])>1)AddEdge(i+1,m+j+1,1);\n\n    cout << FordFullkerson(0,m+n+1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\n\nstruct Maxflow {\n\tstruct edge { int to, cap, rev; edge(int t, int c, int r) { to = t; cap = c; rev = r; } };\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> itr, level;\n\n\tMaxflow(int V) : V(V) { G.assign(V, vector<edge>()); }\n\n\tvoid add_edge(int from, int to, int cap) {\n\t\tG[from].push_back(edge(to, cap, (int)G[to].size()));\n\t\tG[to].push_back(edge(from, 0, (int)G[from].size() - 1));\n\t}\n\n\tvoid bfs(int s) {\n\t\tlevel.assign(V, -1);\n\t\tqueue<int> q;\n\t\tlevel[s] = 0; q.push(s);\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (auto &e : G[v]) {\n\t\t\t\tif (e.cap > 0 and level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t) return f;\n\t\tfor (int& i = itr[v]; i < (int)G[v].size(); ++i) {\n\t\t\tedge& e = G[v][i];\n\t\t\tif (e.cap > 0 and level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint run(int s, int t) {\n\t\tint ret = 0, f;\n\t\twhile (bfs(s), level[t] >= 0) {\n\t\t\titr.assign(V, 0);\n\t\t\twhile ((f = dfs(s, t, INF)) > 0) ret += f;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint M, N;\nint B[500], R[500];\n\nint gcd(int a, int b) { return a ? gcd(b%a, a) : b; }\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile (cin >> M >> N)\n\t{\n\t\tif (M == 0) return 0;\n\t\trep(i, 0, M) cin >> B[i];\n\t\trep(i, 0, N) cin >> R[i];\n\n\t\tMaxflow mf(1 + M + N + 1);\n\t\trep(i, 0, M) mf.add_edge(0, i + 1, 1);\n\t\trep(i, 0, M) rep(j, 0, N)\n\t\t{\n\t\t\tif (gcd(B[i], R[j]) != 1) mf.add_edge(1 + i, 1 + M + j, 1);\n\t\t}\n\t\trep(i, 0, N) mf.add_edge(1 + M + i, 1 + N + M, 1);\n\n\t\tcout << mf.run(0, 1 + N + M) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n    each(x,vec) is >> x;\n    return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    rep(i,vec.size()) {\n        if (i) os << \" \";\n        os << vec[i];\n    }\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n    rep(i,vec.size()) {\n        if (i) os << endl;\n        os << vec[i];\n    }\n    return os;\n}\nclass MaxFlow {\npublic:\n    struct Edge {\n        ll to, cap, rev;\n    };\n    vector<vector<Edge>> G;\n    vector<ll> iter;\nprivate:\n    bool is_debug;\n    ll V;\n    vector<ll> bfs(ll s) {\n        vector<ll> dist(V, linf);\n        dist[s] = 0;\n        queue<ll> Q; Q.push(s);\n        while ( !Q.empty() ) {\n            ll v = Q.front(); Q.pop();\n            each(e, G[v]) {\n                if (e.cap > 0 && dist[e.to] == linf) {\n                    dist[e.to] = dist[v]+1;\n                    Q.push(e.to);\n                }\n            }\n        }\n        return dist;\n    }\n    ll dfs(ll v, ll t, ll f, const vector<ll>& dist, vector<bool>& used) {\n        if (v == t) return f;\n        if (used[v]) return 0;\n        used[v] = true;\n        for (ll& i = iter[v]; i < G[v].size(); ++i) {\n            Edge& e = G[v][i];\n            if (e.cap > 0 && dist[e.to] == dist[v]+1) {\n                ll d = dfs(e.to, t, min(f, e.cap), dist, used);\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\npublic:\n    const vector<vector<Edge>> Graph() {\n        return G;\n    }\n    MaxFlow(ll V, bool is_debug=false) : V(V), G(V), is_debug(is_debug) {}\n    void init(ll n) {\n        V = n;\n        G.assign(V, vector<Edge>());\n    }\n    void add(ll from, ll to, ll cap) {\n        if (is_debug) cout << \"ADD: \" << from << \" \" << to << \" \" << cap << endl;\n        assert(V > 0);\n        G[from].pb({to, cap, (ll)G[to].size()});\n        G[to].pb({from, 0, (ll)G[from].size()-1});\n    }\n    // S -> s, T -> t ??? inf ???????????§\n    void add(ll from, ll to, ll min_flow, ll cap, ll S, ll T) {\n        if (is_debug) cout << endl << \"ADD_MIN:\" << from << \" \" << to << \" \" << min_flow << \" \" << cap << endl;\n        add(from, to, cap-min_flow);\n        add(S, to, min_flow);\n        add(from, T, cap);\n        if (is_debug) cout << endl;\n    }\n    ll flow(ll s, ll t, ll f=linf) {\n        ll res = 0;\n        while (f > 0) {\n            vector<ll> dist = bfs(s);\n            if (dist[t] == linf) break;\n            iter.assign(G.size(), 0);\n            while (f > 0) {\n                vector<bool> used(V, false);\n                ll df = dfs(s, t, f, dist, used);\n                if (df == 0) break;\n                f -= df;\n                res += df;\n            }\n        }\n        return res;\n    }\n};\nvector<ll> prime_divisors(ll n) {\n    vector<ll> res;\n    for (ll i = 2; i*i <= n; ++i) {\n        if (n % i != 0) continue;\n        res.pb(i);\n        while (n % i == 0) n /= i;\n    }\n    if (n > 1) res.pb(n);\n    return res;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    ll n, m;\n    while (cin >> n >> m, n || m) {\n        vector<ll> a(n), b(m); cin >> a >> b;\n        vector<vector<ll>> ad(n), bd(m);\n        map<ll,ll> id;\n        rep(i, n) ad[i] = prime_divisors(a[i]);\n        rep(i, m) bd[i] = prime_divisors(b[i]);\n        rep(i, n) each(x, ad[i]) id[x];\n        rep(i, m) each(x, bd[i]) id[x];\n        ll ids = 0;\n        each(p, id) p.second = ids++;\n        ll s = n+m+ids, t = s+1;\n        MaxFlow mf(t+1);\n        rep(i, n) mf.add(s, i, 1);\n        rep(i, m) mf.add(n+i, t, 1);\n        rep(i, n) each(x, ad[i]) mf.add(i, n+m+id[x], 1);\n        rep(i, m) each(x, bd[i]) mf.add(n+m+id[x], n+i, 1);\n        cout << mf.flow(s, t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 4444\nvector<int> v[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int a,int b){\n\tv[a].PB(b);\n\tv[b].PB(a);\n}\n\nbool matchdfs(int a){\n\tused[a] = true;\n\tfor(int i = 0;i < v[a].size();i++)\t{\n\t\tint u = v[a][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w)){\n\t\t\tmatch[u] = a;\n\t\t\tmatch[a] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//二部マッチング\nint two_matching_max(int l){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<int> prime;\n#define HOGE 444444\nbool isp[HOGE];\nvoid f(){\n\tREP(i,HOGE)isp[i] = true;\n\tisp[0] = isp[1] = false;\n\tfor(int i = 2;i < HOGE;i++){\n\t\tif(isp[i]){\n\t\t\tprime.PB(i);\n\t\t\tfor(int j = i;j < HOGE;j+=i)isp[j] = false;\n\t\t}\n\t}\n}\n\t\n#define HALF 1000\nint main(){\n\tf();\n\tint n,m;\n\twhile(cin >> m >> n,n|m){\n\t\tREP(i,MAX_V)v[i].clear();\n\t\tvector<ll> a(m);REP(i,m)cin >> a[i];\n\t\tvector<ll> b(n);REP(i,n)cin >> b[i];\n\t\tREP(i,m){\n\t\t\tvector<ll> tmp;\n\t\t\tREP(j,prime.size()){\n\t\t\t\tif(a[i] % prime[j] == 0)tmp.PB(prime[j]);\n\t\t\t}\n\t\t\tREP(j,n){\n\t\t\t\tREP(k,tmp.size()){\n\t\t\t\t\tif(b[j] % tmp[k] == 0){\n\t\t\t\t\t\tadd_edge(i,j + 1000);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << two_matching_max(MAX_V) << endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n// ------ Variable ------ //\n\nint N, M;\n\n\n// ------ Greatest Common Divisor ------ //\n\nint GCD(int a, int b)\n{\n\tif (a % b == 0) { return b; }\n\tif (b % a == 0) { return a; }\n\n\tif (a > b) { return GCD(a % b, b); }\n\tif (b > a) { return GCD(b % a, a); }\n}\n\n\n// ------ Bipartite Matching ------ //\n\nvector<vector<int> > Graph;\n\nvector<int> match;\n\nvector<bool> used;\n\nbool dfs(int v)\n{\n\tused[v] = true;\n\n\tfor (int i = 0; i < Graph[v].size(); i++)\n\t{\n\t\tint u = Graph[v][i], w = match[u];\n\n\t\tif (w < 0 || !used[w] && dfs(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint Bipartite_Matching()\n{\n\tint Ans = 0;\n\n\tmatch = vector<int>(N + M, -1);\n\n\tfor (int i = 0; i < N + M; i++)\n\t{\n\t\tif (match[i] < 0)\n\t\t{\n\t\t\tused = vector<bool>(N + M, 0);\n\n\t\t\tif (dfs(i))\n\t\t\t{\n\t\t\t\tAns++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Ans;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> N >> M;\n\n\t\tif (N == 0 && M == 0) { break; }\n\n\t\tGraph = vector<vector<int> >(N + M, vector<int>());\n\n\t\tvector<int> A(N);\n\t\tvector<int> B(M);\n\n\t\tfor (int i = 0; i < N; i++) { cin >> A[i]; }\n\t\tfor (int i = 0; i < M; i++) { cin >> B[i]; }\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < M; j++)\n\t\t\t{\n\t\t\t\tif (GCD(A[i], B[j]) != 1)\n\t\t\t\t{\n\t\t\t\t\tGraph[i].push_back(N + j);\n\t\t\t\t\tGraph[N + j].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << Bipartite_Matching() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <utility>\nusing namespace std;\n\nint m, n, B[500], R[500], P[500];\n\n// P[] カード赤とペアになっている青のカード番号 割り当てなしで -1\n\nbool V[500];\n// true ならカード赤に新しい割り当て先はない false なら不明\n\nint gcd( int a, int b ) {\n\n\tint c;\n\t\n\twhile ( a != 0 ) {\n\t\n\t\tc = a;\n\t\ta = b % a;\n\t\tb = c;\n\n\t}\n\n\treturn b;\n\n}\n\nint judge( int i, int j ) {\t// B[i] と R[j] がマッチ可能なとき judge( i, j ) = 1 不可能なとき 0\n\n\tif ( gcd( B[i], R[j] ) >= 2 ) { return 1; }\n\telse { return 0; }\n\n}\n\nbool match( int i ) {\n\n\tif ( i < 0 ) { return true; }\n\t\n\tfor ( int j = 0; j < n; j++ ) {\n\t\n\t\tif ( judge( i, j ) == 0 || V[j] ) { continue; }\n\t\t\n\t\tV[j] = true;\n\t\t\n\t\tif ( match( P[j] ) ) {\n\t\t\t\n\t\t\tP[j] = i;\n\t\t\treturn true;\n\t\t\t\n\t\t}\n\t\n\t}\n\t\n\treturn false;\n\n}\n\nint main() {\n\n\twhile ( cin >> m >> n && m != 0 && n != 0 ) {\n\t\n\t\tfor ( int i = 0; i < m; i++ ) { cin >> B[i]; }\n\t\tfor ( int i = 0; i < n; i++ ) { cin >> R[i]; }\n\t\t\n\t\tfor ( int i = 0; i < n; i++ ) { P[i] = -1; }\n\t\t\n\t\tint count = 0;\n\t\t\n\t\tfor ( int i = 0; i < m; i++ ) {\n\t\t\n\t\t\tfor ( int i = 0; i < n; i++ ) { V[i] = false; }\n\t\t\t\n\t\t\tif ( match( i ) ) { count++; }\n\t\t\t\n\t\t}\n\t\t\n\t\tcout << count << endl;\n\t\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <cmath>\n#include <map>\n#include <cstring>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for (int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define Cout(obj) cout << obj << endl\n#define Size(obj) (int)(obj).size()\n#define fcout cout << fixed << setprecision(10)\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nconst int MaxV = 10000;\n\nvector<int> graph[MaxV];\nint match[MaxV];\nbool used[MaxV];\n\nvoid addEdge(int u, int v)\n{\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n}\n\nbool dfs(int v)\n{\n    used[v] = true;\n\n    for (auto &e : graph[v])\n    {\n        int u = e, w = match[u];\n\n        if (w < 0 || !used[w] && dfs(w))\n        {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint bipartiteMatcing()\n{\n    int res = 0;\n\n    memset(match, -1, sizeof(match));\n\n    REP(v, MaxV)\n    {\n        if (match[v] < 0)\n        {\n            memset(used, 0, sizeof(used));\n\n            if (dfs(v))\n            {\n                res++;\n            }\n        }\n    }\n\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int M, N;\n    while(cin >> M >> N && M)\n    {\n        vector<int> B(M), R(N);\n\n        REP(i, 1010)\n        {\n            graph[i].clear();\n            match[i] = 0;\n            used[i] = false;\n        }\n\n        REP(i, M)\n        {\n            cin >> B[i];\n        }\n\n        REP(i, N)\n        {\n            cin >> R[i];\n        }\n\n        REP(i, M)\n        {\n            REP(j, N)\n            {\n                if(max(B[i], R[j]) % min(B[i], R[j]) == 0)\n                {\n                    addEdge(i, j + M);\n                }   \n            }\n        }\n\n         Cout(bipartiteMatcing());\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define inf 1000000007\n#define rep(i, n) for(int i = 0; i < n; i++)\n\ntypedef long long ll;\n\nclass path {\npublic:\n  int t;\n  ll c;\n  int p;\n};\n\nclass dinic {\npublic:\n  int n;\n  vector<path> p;\n  vector<int>* v;\n  int* l;\n  int* o;\n  dinic(int nw) {\n    n = nw;\n    v = new vector<int>[n];\n    l = new int[n];\n    o = new int[n];\n  }\n  void add(int from, int to, ll cap) {\n    path w1, w2;\n    w1.t = to;\n    w1.c = cap;\n    w1.p = p.size() + 1;\n    v[from].push_back(p.size());\n    w2.t = from;\n    w2.c = 0;\n    w2.p = p.size();\n    v[to].push_back(p.size() + 1);\n    p.push_back(w1);\n    p.push_back(w2);\n  }\n  void dics(int from) {\n    rep(i, n) {\n      l[i] = inf;\n    }\n    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;\n    pq.push(make_pair(0, from));\n    while(!pq.empty()) {\n      int k = pq.top().first;\n      int m = pq.top().second;\n      pq.pop();\n      if(l[m] > k) {\n        l[m] = k;\n        rep(i, v[m].size()) {\n          int x = v[m][i];\n          if(p[x].c > 0) {\n            pq.push(make_pair(k + 1, p[x].t));\n          }\n        }\n      }\n    }\n  }\n  ll dfs(int now, int to, ll mi) {\n    if(now == to) {\n      return mi;\n    }\n    ll all = 0;\n    while(o[now] < v[now].size()) {\n      int x = v[now][o[now]];\n      ll w = dfs(p[x].t, min(mi - all, p[x].c), to);\n      p[x].c -= w;\n      p[p[x].p].c += w;\n      all += w;\n      if(mi - all == 0) {\n        break;\n      }\n      o[now]++;\n    }\n    return all;\n  }\n  ll solve(int from, int to) {\n    ll all = 0;\n    while(1) {\n      dics(from);\n      rep(i, n) {\n        o[i] = 0;\n      }\n      int w = dfs(from, to, inf);\n      all += w;\n      if(w == 0) {\n        break;\n      }\n    }\n    return all;\n  }\n  ~dinic() {\n    delete[] v;\n    delete[] l;\n    delete[] o;\n  }\n};\n\nll gcd(ll a, ll b) {\n  if(a > b) {\n    return gcd(b, a);\n  }\n  if(b % a == 0) {\n    return a;\n  }\n  else {\n    return gcd(b % a, a);\n  }\n}\n\nll nd[1000], md[1000];\n\nint main() {\n  while(1) {\n    int n, m;\n    scanf(\"%d%d\",&n,&m);\n    if(n == 0) {\n      break;\n    }\n    rep(i, n) {\n      scanf(\"%lld\", nd + i);\n    }\n    rep(i, m) {\n      scanf(\"%lld\", md + i);\n    }\n    dinic s(2 + n + m);\n    rep(i, n) {\n      s.add(n + m, i, 1);\n    }\n    rep(i, m) {\n      s.add(n + i, n + m + 1, 1);\n    }\n    rep(i, n) {\n      rep(j, m) {\n        if(gcd(nd[i], md[j]) > 1) {\n          s.add(i, n + j, 1);\n        }\n      }\n    }\n    printf(\"%lld\\n\", s.solve(n + m, n + m + 1));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<utility>\n#include<ctype.h>\n\n#define FOR(i,n) for(int i=0;i<n;++i)\nlong long int  memo[100001] = {};\nconst int inf = 1 << 30;\n//互除法でやる！\nbool gcd(int a, int b) {\n\tif (a < b) std::swap(a, b);\n\tint r;\n\twhile (r = a%b) {\n\t\ta = b;\n\t\tb = r;\n\t\tif (r == 1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn (r== 0 ? true : false);\n}\n\nint main() {\n\n\tint n, m;\n\twhile (true) {\n\t\tstd::cin >> n >> m;\n\t\tif (!n) {\n\t\t\tbreak;\n\t\t}\n\t\tint a[500], b[500], ct = 0;\n\t\tbool aa[500], bb[500];\n\t\t\n\t\tFOR(i, (n >= m ? n:m))std::cin >> a[i];\n\t\tFOR(i, (m<=n?m:n))std::cin >> b[i];\n\t\tstd::sort(a, a + 500);\n\t\tstd::sort(b, b + 500);\n\t\tFOR(i, (n>=m?n:m)) {\n\t\t\tFOR(j, (m<=n?m:n)) {\n\t\t\t\tif ( (!aa[i]  && !b[j] )&& gcd(a[i], b[j])) {//\n\t\t\t\t\t++ct;\n\t\t\t\t\tbb[j] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << ct << std::endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nint V;\nvector<vector<int>> G;\nvector<int> match;\nvector<bool> used;\n\nvoid add_edge(int u, int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\nbool dfs(int v){\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        int u = G[v][i];\n        int u_pair = match[u];\n        if(u_pair < 0 || !used[u_pair] && dfs(u_pair)){\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(){\n    int res = 0;\n    match.assign(V, -1);\n    for(int v = 0; v < V; v++){\n        if(match[v] < 0){\n            used.assign(V, false);\n            if(dfs(v)){\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(true){\n        int m, n;\n        cin >> m >> n;\n        if(m == 0) break;\n\n        vector<int> b(m), r(n);\n        for(int i=0;i<m;i++){\n            cin >> b[i];\n        }\n        for(int i=0;i<n;i++){\n            cin >> r[i];\n        }\n\n        V = n + m;\n        G.assign(V, {});\n\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(__gcd(b[i], r[j]) != 1){\n                    add_edge(i, j + m);\n                }\n            }\n        }\n\n        cout << bipartite_matching() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <queue>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\ntypedef int Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight == rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nWeight augment(Graph &g, Matrix &capacity, const vector<int> &level, vector<bool> &finished, int from, int t, Weight cur) {\n  if (from == t || cur == 0) { return cur; }\n  if (finished[from]) { return 0; }\n  for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n    int to = it->dest;\n    if (level[to] <= level[from]) { continue; }\n    Weight f = augment(g, capacity, level, finished, to, t, min(cur, capacity[from][to]));\n    if (f > 0) {\n      capacity[from][to] -= f;\n      capacity[to][from] += f;\n      return f;\n    }\n  }\n  finished[from] = true;\n  return 0;\n}\n\nWeight MaxFlow(Graph &g, int s, int t) {\n  int n = g.size();\n  Matrix capacity(n, Array(n));\n  for (int from = 0; from < n; from++) {\n    for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n      int to = it->dest;\n      capacity[from][to] += it->weight;\n    }\n  }\n  int ans = 0;\n  while (true) {\n    vector<int> level(n, -1);\n    level[s] = 0;\n    queue<int> que;\n    que.push(s);\n    for (int d = n; !que.empty() && level[que.front()] < d; ) {\n      int from = que.front();\n      que.pop();\n      if (from == t) { d = level[from]; }\n      for (Edges::iterator it = g[from].begin(); it != g[from].end(); it++) {\n        int to = it->dest;\n        if (capacity[from][to] > 0 && level[to] == -1) {\n          que.push(to);\n          level[to] = level[from] + 1;\n        }\n      }\n    }\n    vector<bool> finished(n);\n    bool end = true;\n    while (true) {\n      Weight f = augment(g, capacity, level, finished, s, t, 1000000000);\n      if (f == 0) { break; }\n      ans += f;\n      end = false;\n    }\n    if (end) { break; }\n  }\n  return ans;\n}\n\nint maxFlow(const Graph &g, int s, int t) {\n  const int n = g.size();\n  Matrix capacity(n, Array(n, 0));\n  for (int i = 0; i < n; i++) {\n    for (Edges::const_iterator it = g[i].begin(); it != g[i].end(); it++) {\n      capacity[it->src][it->dest] = it->weight;\n    }\n  }\n  int ret = 0;\n  vector<int> parent(n);\n  while (true) {\n    fill(parent.begin(), parent.end(), -1);\n    priority_queue<Edge> que;\n    que.push(Edge(s, s, 0));\n    while (!que.empty()) {\n      Edge node = que.top();\n      que.pop();\n      if (parent[node.dest]) { continue; }\n      parent[node.dest] = node.src;\n      if (node.dest == t) { break; }\n      int from = node.dest;\n      for (Edges::const_iterator it = g[from].begin(); it != g[from].end(); it++) {\n        int to = it->dest;\n        if (capacity[from][to] == 0 || parent[to] != -1) { continue; }\n        que.push(Edge(from, to, 0));\n      }\n    }\n    if (parent[t] == -1) { break; }\n    Weight flow = 2000000000;\n    int from = parent[t];\n    int to = t;\n    while (from != to) {\n      flow = min(flow, capacity[from][to]);\n      from = parent[from];\n      to = parent[to];\n    }\n    from = parent[t];\n    to = t;\n    while (from != to) {\n      capacity[from][to] -= flow;\n      capacity[to][from] += flow;\n      from = parent[from];\n      to = parent[to];\n    }\n    ret += flow;\n  }\n  return ret;\n}\n\n\n\nint gcd(int a, int b) {\n  if (b == 0) { return a; }\n  return gcd(b, a % b);\n}\n\nint m, n;\nint blue[501];\nint red[501];\n\nint BLUE(int x) { return x; }\nint RED(int x) { return m + x; }\nint SOURCE() { return m + n; }\nint DEST() { return m + n + 1; }\nint SIZE() { return m + n + 2; }\n\nint main() {\n  while (scanf(\"%d %d\", &m, &n), m|n) {\n    Graph g(SIZE());\n    REP(b, m) {\n      scanf(\"%d\", &blue[b]);\n      g[SOURCE()].push_back(Edge(SOURCE(), BLUE(b), 1));\n      g[BLUE(b)].push_back(Edge(BLUE(b), SOURCE(), 0));\n    }\n    REP(r, n) {\n      scanf(\"%d\", &red[r]);\n      g[RED(r)].push_back(Edge(RED(r), DEST(), 1));\n      g[DEST()].push_back(Edge(DEST(), RED(r), 0));\n    }\n    REP(b, m) {\n      REP(r, n) {\n        if (gcd(blue[b], red[r]) != 1) {\n          g[BLUE(b)].push_back(Edge(BLUE(b), RED(r), 1));\n          g[RED(r)].push_back(Edge(RED(r), BLUE(b), 0));\n        }\n      }\n    }\n    assert(MaxFlow(g, SOURCE(), DEST()) == maxFlow(g, SOURCE(), DEST()));\n    int ans = MaxFlow(g, SOURCE(), DEST());\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst int INF = 1e8;\nconst int MAX_V = 10005;\n\nclass Edge{\n    public:\n        int to, cap, rev;\n        Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nclass Flow{\n    private:\n        vector<Edge> G[MAX_V];\n        bool used[MAX_V];\n        int level[MAX_V]; //s??????????????¢\n        int iter[MAX_V]; //???????????§??????????????£??????\n        int dfs(int v, int t, int f){\n            if(v == t) return f;\n            used[v] = true;\n            rep(i,G[v].size()){\n                Edge &e = G[v][i];\n                if(not used[e.to] && e.cap > 0){\n                    int d = dfs(e.to, t, min(f, e.cap));\n                    if(d > 0){\n                        e.cap -= d;\n                        G[e.to][e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n        int dfs_(int v, int t, int f){\n            if(v == t) return f;\n            for(int &i = iter[v]; i < G[v].size(); i++){\n                Edge &e = G[v][i];\n                if(e.cap > 0 && level[v] < level[e.to]){\n                    int d = dfs_(e.to, t, min(f, e.cap));\n                    if(d > 0){\n                        e.cap -= d;\n                        G[e.to][e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n        void bfs(int s){\n            memset(level, -1, sizeof(level));\n            queue<int> que;\n            level[s] = 0;\n            que.push(s);\n            while(not que.empty()){\n                int v = que.front(); que.pop();\n                rep(i,G[v].size()){\n                    Edge &e = G[v][i];\n                    if(e.cap > 0 && level[e.to] < 0){\n                        level[e.to] = level[v] + 1;\n                        que.push(e.to);\n                    }\n                }\n            }\n        }\n    public:\n        void addEdge(int from, int to, int cap){\n            G[from].push_back(Edge(to, cap, static_cast<int>(G[to].size())));\n            G[to].push_back(Edge(from, 0, static_cast<int>(G[from].size() - 1)));\n        }\n        int fordFulkerson(int s, int t){\n            int flow = 0;\n            while(true){\n                memset(used, 0, sizeof(used));\n                int f = dfs(s, t, INF);\n                if(f == 0) return flow;\n                flow += f;\n            }\n        }\n        int dinic(int s, int t){\n            int flow = 0;\n            while(true){\n                bfs(s);\n                if(level[t] < 0) return flow;\n                memset(iter, 0, sizeof(iter));\n                int f;\n                while( (f = dfs_(s, t, INF)) > 0){\n                    flow += f;\n                }\n            }\n        }\n};\n\nconst int kN = 600;\nvector<int> primeNumber(bool prime[kN]){\n    vector<int> ret;\n    rep(i,kN) prime[i] = 1;\n    prime[0] = prime[1] = 0;\n    rep(i,kN){\n        if(prime[i]){\n            ret.emplace_back(i);\n            for(int j = i + i; j < kN; j+=i){\n                prime[j] = 0;\n            }\n        }\n    }\n    return ret;\n}\n\nbool isCoprime(int a, int b, vector<int> p){\n    for(auto it:p){\n        if(a % it == 0 && b % it == 0) return false;\n    }\n    return true;\n}\n\nint main(){\n    bool used[kN];\n    vector<int> prime = primeNumber(used);\n\n    int m,n;\n    while(cin >> m >> n,m){\n        int b[505], r[505];\n        rep(i,m) cin >> b[i];\n        rep(i,n) cin >> r[i];\n\n        //0~m-1, m~m+n-1, m+n, m+n+1\n        Flow ob;\n        rep(i,m){\n            rep(j,n){\n                if(not isCoprime(b[i], r[j], prime)){\n                    ob.addEdge(i,m + j,1);\n                }\n            }\n        }\n\n        int s = m + n, t = s + 1;\n        rep(i,m) ob.addEdge(s,i,1);\n        rep(i,n) ob.addEdge(m + i,t,1);\n\n        cout << ob.fordFulkerson(s,t) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt __builtin_popcount\n#define SZ(x) ((ll)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CINT(...)                                                              \\\n    int __VA_ARGS__;                                                           \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef vector<ll> VL;\ntypedef pair<ll, ll> PL;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst double PI = atan(1.0) * 4.0;\n// const int MOD = 998244353;\nconst ll LINF = 9e18;\nconst ll dx[] = {1, 0, -1, 0};\nconst ll dy[] = {0, 1, 0, -1};\n\nvoid cinfast() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nstruct edge {\n    ll to, cap, rev;\n};\n\nstruct Mflow {\n    vector<vector<edge>> G;\n    VL level, iter;\n    ll N;\n\n    Mflow(ll size) : N(size) { init(size); };\n\n    void init(ll size) { G.resize(N); }\n\n    void add_edge(ll from, ll to, ll cap) {\n        G[from].push_back({to, cap, (ll)G[to].size()});\n        G[to].push_back({from, 0, (ll)G[from].size() - 1});\n    }\n    void bfs(ll s) {\n        level.assign(N, -1);\n        queue<ll> q;\n        level[s] = 0;\n        q.push(s);\n        while(!q.empty()) {\n            ll now = q.front();\n            q.pop();\n            FOREACH(e, G[now]) {\n                if(e.cap > 0 && level[e.to] == -1) {\n                    level[e.to] = level[now] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    ll dfs(ll now, ll t, ll f) {\n        if(now == t) return f;\n        for(ll &i = iter[now]; i < G[now].size(); i++) {\n            edge &e = G[now][i];\n            if(e.cap > 0 && level[now] < level[e.to]) {\n                ll d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    ll max_flow(ll s, ll t) {\n        ll flow = 0;\n        while(1) {\n            bfs(s);\n            if(level[t] < 0) return flow;\n            iter.assign(N, 0);\n            ll f;\n            while((f = dfs(s, t, LINF)) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n\nll m, n;\n\nll gcd(ll a, ll b) {\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nsigned main() {\n    while(cin >> m >> n && m && n) {\n        Mflow mf(m + n + 2);\n        REP(i, m) mf.add_edge(m + n, i, 1);\n        REP(i, n) mf.add_edge(m + i, m + n + 1, 1);\n        VL b(m), r(n);\n        VECCIN(b);\n        VECCIN(r);\n        REP(i, m) REP(j, n) {\n            if(gcd(b[i], r[j]) > 1) {\n                mf.add_edge(i, m + j, 1);\n            }\n        }\n        cout << mf.max_flow(m + n, m + n + 1) << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define clr(n)\tmemset(n,0,sizeof(n));\nconst int INF = 1e9;\n\nint gcd(int a, int b) {\n\treturn b ? gcd(b, a%b) : a; \n}\n\nstruct edge { int to, cap, rev; };\nvector<edge> G[1001];\nbool used[1001];\n\nvoid clear() {\n\trep(i, 1001) {\n\t\tG[i].clear();\n\t\tused[i] = false;\n\t}\n}\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap, int(G[to].size()) });\n\tG[to].push_back(edge{ from, 0, int(G[from].size()) - 1 });\n}\n\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\trep(i, G[v].size()) {\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tclr(used);\n\t\tint f = dfs(s, t, INF);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n}\n\nint main() {\n\tint m, n;\n\n\twhile (cin >> m >> n && m) {\n\t\tvector<int> r(m), b(n);\n\t\tclear();\n\t\trep(i, m) {\n\t\t\tcin >> r[i];\n\t\t\tadd_edge(m + n, i, 1);\n\t\t}\n\t\trep(i, n) {\n\t\t\tcin >> b[i];\n\t\t\tadd_edge( m + i, m + n + 1, 1);\n\t\t}\n\t\trep(i, m)rep(j, n) {\n\t\t\tif (gcd(r[i], b[j]) != 1) {\n\t\t\t\tadd_edge(i, m + j, 1);\n\t\t\t}\n\t\t}\n\n\t\tcout << max_flow(m + n, m + n + 1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<string>\n#include<cmath>\n#include<cassert>\n#include<map>\n  using namespace std;\n\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ (i)=0;(i)<(j);(i)++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);(i)++)\n#define all(v) begin(v),end(v)\n\n#define MAX_N 501\nclass maxFlow\n{\npublic:\n  int N;//???????????°\n  int G[MAX_N][MAX_N];//G[i][j] :=???i??????j????????§?????????\n  bool is_visited[MAX_N];\n\n  maxFlow(int n)\n  {\n    N=n;\n    //?????????????????¨????????°???????????§??????\n    for(int i=0;i<N;i++)\n      for(int j=0;j<N;j++)\n\tG[i][j]=0;\n  }\n\n  //n1->n2???arc?????????\n  void add_arc(int n1,int n2,int capacity)\n  {\n    G[n1][n2]+=capacity;//????????§?????±???\n  }\n\n  //??´???????????§???????????¢?´¢\n  int dfs(int now,int end,int min_capacity)\n  {\n    if(now==end)return min_capacity;\n    if(!is_visited[now])\n      {\n\tis_visited[now]=true;\n\tfor(int i=0;i<N;i++){\n\t  if(G[now][i]>0){//now??????i????????§??????????????????????????°????????§??????\n\t    int ret=dfs(i,end,min(min_capacity,G[now][i]));\n\t    if(ret>0){//??´???????????????????????????????????§?¢???????????????????????????????????????´??°\n\t      G[now][i]-=ret;\n\t      G[i][now]+=ret;\n\t      return ret;\n\t    }\n\t  }\n\t}\n\treturn -2;//??´????????????????????????????????£???\n      }\n    else return -1;//?????§????¨???????????????£???\n  }\n  \n  int get_maxFlow(int start,int end)\n  {\n    int temp,ans=0;\n    //??´???????????????????????????????????§????????????????????????????????????????´¢\n    while(true){\n      for(int i=0;i<N;i++)is_visited[i]=false;\n      temp=dfs(start,end,100);\n      if(temp>0)ans+=temp;\n      else break;\n    }\n    return ans;\n  }\n  \n};\n\nint gcd(int a,int b){\n  if(b==0)return a;\n  return gcd(b,a%b);\n}\n\nint main()\n{\n  int n,m;\n\n  while(true){\n    cin>>m>>n;\n    if(m==0&&n==0)break;\n    maxFlow G(m+n+2);\n    vector<int> b(m);\n    vector<int> r(n);\n    rep(i,m){\n      cin>>b[i];\n      G.add_arc(m+n, i, 1);\n    }\n    rep(i,n){\n      cin>>r[i];\n      G.add_arc(m+i, m+n+1 , 1);\n    }\n    \n    rep(i,m){\n      rep(j,n){\n        if(gcd(b[i],r[j])!=1){\n          G.add_arc(i, m+j, 1);\n        }\n      }\n    }\n\n    cout<<G.get_maxFlow(m+n, m+n+1)<<endl;\n    \n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <forward_list>\n#include <functional>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n\nint gcd(int n, int m) { return n ? gcd(m % n, n) : m; }\n\nstruct edge {\n    int src;\n    int dst;\n    int cap;\n    int flow;\n};\n\ntypedef vector<vector<reference_wrapper<edge>>> graph;\n\nvoid add_edge(graph& g, forward_list<edge>& edges, edge e)\n{\n    edges.push_front(e);\n    g[e.src].push_back(edges.front());\n    g[e.dst].push_back(edges.front());\n}\n\ninline int opposite(const edge& e, int v) { return (e.dst == v) ? e.src : e.dst; }\ninline int residue(const edge& e, int dst) { return (e.dst == dst) ? e.cap - e.flow : e.flow; }\ninline void augment(edge& e, int dst, int delta) { e.flow += (e.dst == dst) ? delta : -delta; }\n\nint max_flow(graph& g, int src, int sink)\n{\n    edge dummy = { 0, 0, 0, 0 };\n    int f = 0;\n    for (;;) {\n        vector<edge*> prev(g.size(), nullptr);\n        vector<int> stack;\n        stack.push_back(src);\n        prev[src] = &dummy;\n        while (!stack.empty()) {\n            int v = stack.back(); stack.pop_back();\n            if (v == sink)\n                break;\n            for (edge& e : g[v]) {\n                int w = opposite(e, v);\n                if (residue(e, w) > 0 && prev[w] == nullptr) {\n                    prev[w] = &e;\n                    stack.push_back(w);\n                }\n            }\n        }\n        if (prev[sink] == nullptr)\n            return f;\n        int delta = 1e9;\n        for (int v = sink; prev[v] != &dummy; v = opposite(*prev[v], v))\n            delta = min(delta, residue(*prev[v], v));\n        for (int v = sink; prev[v] != &dummy; v = opposite(*prev[v], v))\n            augment(*prev[v], v, delta);\n        f += delta;\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int m, n;\n    while (cin >> m >> n, m) {\n        vector<int> bs(m), rs(n);\n        rep(i, m) cin >> bs[i];\n        rep(i, n) cin >> rs[i];\n\n        forward_list<edge> edges;\n        graph g(n + m + 2);\n        rep(i, m) rep(j, n) {\n            if (gcd(bs[i], rs[j]) > 1) {\n                add_edge(g, edges, { i, m + j, 1, 0 });\n            }\n        }\n        rep(i, m) add_edge(g, edges, { m + n, i, 1, 0 });\n        rep(j, n) add_edge(g, edges, { m + j, m + n + 1, 1, 0 });\n\n        int f = max_flow(g, m + n, m + n + 1);\n        cout << f << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nstruct Bipartite_Matching\n{\n  vector< vector< int > > graph;\n  vector< int > dist, match;\n  vector< bool > used, vv;\n\n  Bipartite_Matching(int n, int m)\n  {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, false);\n  }\n\n  void add_edge(int u, int v)\n  {\n    graph[u].push_back(v);\n  }\n\n  void bfs()\n  {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a)\n  {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching()\n  {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nint dp[1000][1000];\n\nint gcd(int x, int y)\n{\n  if(x < 1000) {\n    if(~dp[x][y]) return (dp[x][y]);\n    int r = x % y;\n    if(r == 0) return dp[x][y] = y;\n    return dp[x][y] = gcd(y, r);\n  } else {\n    int r = x % y;\n    if(r == 0) return y;\n    return gcd(y, r);\n  }\n}\n\nint main()\n{\n  memset(dp, -1, sizeof(dp));\n\n  int M, N, B[500], R[500];\n  while(scanf(\"%d %d\", &M, &N), M) {\n    Bipartite_Matching flow(M, N);\n    for(int i = 0; i < M; i++) scanf(\"%d\", &B[i]);\n    for(int i = 0; i < N; i++) scanf(\"%d\", &R[i]);\n    for(int i = 0; i < M; i++) {\n      for(int j = 0; j < N; j++) {\n        if(gcd(B[i], R[j]) > 1) flow.add_edge(i, j);\n      }\n    }\n    printf(\"%d\\n\", flow.bipartite_matching());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef pair<LL, LL> PLL;\n\nint gcd(int x, int y) {\n    if (x < y) {\n        return gcd(y, x);\n    }\n\n    if (y == 0) {\n        return x;\n    }\n\n    return gcd(y, x % y);\n}\n\nint M, N;\nint b[505], r[505];\n\nint g[505][505];\nchar visited[505];\nint matcha[505], matchb[505];\n\nbool rec(int u) {\n    if (u == -1) return true;\n    for (int j = 0; j < N; ++j) {\n        if (!visited[j] && g[u][j] == 1) {\n            visited[j] = true;\n            bool t = rec(matchb[j]);\n            if (t) {\n                matcha[u] = j;\n                matchb[j] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool solve() {\n    cin >> M >> N;\n    if (M == 0 && N == 0) {\n        return false;\n    }\n    for (int j = 0; j < M; ++j) {\n        cin >> b[j];\n    }\n    for (int j = 0; j < N; ++j) {\n        cin >> r[j];\n    }\n\n    fill(matcha, matcha+M, -1);\n    fill(matchb, matchb+N, -1);\n\n    for (int j = 0; j < M; ++j) {\n        for (int k = 0; k < N; ++k) {\n            g[j][k] = gcd(b[j], r[k]) > 1 ? 1 : 0;\n        }\n    }\n\n    for (int j = 0; j < M; ++j) {\n        fill(visited, visited+N, 0);\n        rec(j);\n    }\n\n    int ret = 0;\n    for (int j = 0; j < M; ++j) {\n        if (matcha[j] >= 0) {\n            ++ret;\n        }\n    }\n\n    cout << ret << endl;\n\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#define rep(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define REP(i,a) rep((i),0,(a)) \n#define ull unsigned long long \nusing namespace std;\n//global\n\null gcd(ull n, ull m){\n\treturn(m==0?n:gcd(m, n%m));\n} \n\nvector<int>G[1010];\null card[1001];\nint match[1010];\nint N, M;\nbool used[1010];\nbool dfs(int v){\n\tused[v] = true;\n\trep( i,0, (int)G[v].size()){\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint bm(){\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\trep(v, 0, 1000){\n\t\tif (match[v] < 0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(void){\n\twhile (true){\n\t\tcin >> N >> M;\n\t\tif (N==0)return(0);\n\n\n\t\trep(i, 0, N)cin >> card[i];\n\t\trep(i, 500, 500+M){\n\t\t\tcin >> card[i];\n\t\t\trep(j, 0, N)\n\t\t\t\tif (gcd(card[i], card[j]) != 1){\n\t\t\t\t\tG[i].push_back(j);\n\t\t\t\t\tG[j].push_back(i);\n\t\t\t\t}\n\t\t}\n\t\tcout << bm() << endl;\n\t\trep(i, 0, 1010){\n\t\t\tG[i].clear();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<string.h>\nusing namespace std;\n#define INF 10000000\n\nint gcd(int a, int b){ return a%b ? gcd(b, a%b) : b; }//Ååöñ\n\nstruct edge{\n\tint to,cap,rev;\n\tedge(int t,int c,int r){\n\t\tto=t;cap=c,rev=r;\n\t}\n};\n\nvector<vector<edge>> G;\nint level[100000];\nint iter[100000];\n\nvoid add_edge(int from,int to,int cap){\n\tG[from].push_back(edge(to,cap,G[to].size()));\n\tG[to].push_back(edge(from,0,G[from].size()-1));\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s]=0;\n\tque.push(s);\n\twhile(!que.empty()){\n\t\tint v=que.front();que.pop();\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\tedge &e=G[v][i];\n\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow=0;\n\twhile(true){\n\t\tbfs(s);\n\t\tif(level[t]<0) return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tint f;\n\t\twhile((f=dfs(s,t,INF))>0){\n\t\t\tflow+=f;\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\tint n,m;\n\twhile(cin>>n>>m && n>0){\n\t\tG.clear();\n\t\tG.resize(n+m+2);\n\t\tvector<int> red,blue;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tred.push_back(t);\n\t\t\tadd_edge(0,1+i,1);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tblue.push_back(t);\n\t\t\tadd_edge(n+i+1,n+m+1,1);\n\t\t}\n\t\tfor(int r=0;r<n;r++){\n\t\t\tfor(int b=0;b<m;b++){\n\t\t\t\tif(gcd(red[r],blue[b])>1){\n\t\t\t\t\tadd_edge(r+1,n+b+1,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<max_flow(0,n+m+1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "include<iostream>\n#include<vector>\n#include<string.h>\n\nusing namespace std;\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\nint INF = 10e8;\nint m, n;\nint b[501];\nint r[501];\n\nvector<int> bd[501];\nvector<int> rd[501];\n\nstruct edge{\n    int to, cap, rev;\n};\nbool used[501];\nvector<edge> g[501];\n\nint s, t;\n\nvoid add_edge(int from, int to, int cap){\n    g[from].push_back((edge){to, cap, g[to].size()});\n    g[to].push_back((edge){from, 0, g[from].size()-1});\n}\n\nint dfs(int v, int t, int f){\n    if(v==t) return f;\n    used[v] = true;\n    REP(i, g[v].size()){\n        edge &e = g[v][i];\n        if(!used[e.to] && e.cap>0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d>0){\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f==0) return flow;\n        flow += f;\n    }\n}\n\nbool euclid(int x, int y){\n    if(x<y){\n        int tmp = x;\n        x = y;\n        y = tmp;\n    }\n\n    int r = x % y;\n    while(r!=0){\n        x = y;\n        y = r;\n        r = x % y;\n    }\n\n    if(y>1){\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main(){\n    while(1){\n        cin >> m >> n;\n\n        if(m==0) break;\n\n        REP(i, m) cin >> b[i];\n        REP(i, n) cin >> r[i];\n\n        int s = m+n, t = s+1;\n\n        REP(i, 501) g[i].clear();\n\n        REP(i, m){\n            REP(j, n){\n                if(euclid(b[i], r[j])){\n                    add_edge(i, m+j, 1);\n                }\n            }\n        }\n\n        REP(i, m) add_edge(s, i, 1);\n        REP(i, n) add_edge(m+i, t, 1);\n\n        int output = max_flow(s, t);\n        cout << output << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nstruct BiMatch{\n  int n;\n  vector<vector<int> > G;\n  vector<int> match,used;\n  \n  BiMatch(){}\n  BiMatch(int sz):n(sz),G(sz),match(sz),used(sz){}\n  \n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  bool dfs(int v){\n    used[v]=true;\n    for(int i=0;i<(int)G[v].size();i++){\n      int u=G[v][i],w=match[u];\n      if(w<0||(!used[w]&&dfs(w))){\n        match[v]=u;\n        match[u]=v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int build(){\n    int res=0;\n    fill(match.begin(),match.end(),-1);\n    for(int v=0;v<n;v++){\n      if(match[v]<0){\n        fill(used.begin(),used.end(),0);\n        if(dfs(v)){\n          res++;\n        }\n      }\n    }\n    return res;\n  }\n};\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int N, M;\n  while ( cin >> N >> M, N ) {\n\n    BiMatch bm(N+M+2);\n    vector<int> a(N), b(M);\n    for ( int i = 0; i < N; i++ ) cin >> a[i];\n    for ( int i = 0; i < M; i++ ) cin >> b[i];\n\n    for ( int i = 0; i < N; i++ ) {\n      for ( int j = 0; j < M; j++ ) {\n\tif ( __gcd(a[i], b[j]) > 1 ) bm.add_edge(i, N+j);      \n      }\n    }\n\n    cout << bm.build() << endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define REPD(i,n) for(int i=(int)(n); i-->0;)\n#define REPI(i,a,b) for(int i=(int)(a); i<=(int)(b); i++)\n#define ALL(a) (a).begin(),(a).end()\n#define mp make_pair\n#define fst first\n#define snd second\n\n#define INFTY 1000000000\n#define EPS 1e-9\n#define PI 3.141592653589793\n\n#define INF (INFTY/3)\n\n#define rev(s) (string((s).rbegin(), (s).rend()))\n\ntypedef long long Int;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<double,double> pdd;\n\nvoid debug(vi v){ REP(i,v.size()) cout<<v[i]<<\" \"; cout<<endl; }\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\nEdge(int src, int dst) : src(src),dst(dst) {}\nEdge(int src, int dst, Weight weight) :\n  src(src), dst(dst), weight(weight) {}\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vec<Edge> Edges;\ntypedef vec<Edges> Graph;\n\ntypedef vec<Weight> Array;\ntypedef vec<Array> Matrix;\n#define MAXMN 500\n#define Int long long\nint B[MAXMN];\nint R[MAXMN];\n\nInt gcd(Int a, Int b)\n{   \n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\n\n\nint main() {\n  int M,N;\n  Graph g;\n  while(cin>>M>>N,M) {\n    g.clear();\n    g.resize(M+N+2);\n    REP(i,M) cin>>B[i];\n    REP(i,N) cin>>R[i];\n    REP(i,M) {\n      Edges es, es2;\n      REP(j,N) {\n\tif(gcd(B[i],R[j])!=1) { es.pb(Edge(i,M+j)); es2.pb(Edge(M+j,i)); }\n      }\n      g[i] = es;\n      g[M+i] = es2;\n    }\n    Edges matching;\n    cout << bipartiteMatching(g,M,matching) << endl;\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <limits>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nusing ll = long long;\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 100;\n\nclass Flow\n{\npublic:\n    using T = ll;\n    struct Edge {\n        Edge(const int from_, const int to_, const int reverse_, const T capacity_, bool is_reverse = false) : from{from_}, to{to_}, reverse{reverse_}, capacity{capacity_}, flow{0}, is_reverse(is_reverse) {}\n        int from;\n        int to;\n        int reverse;\n        T capacity;\n        T flow;\n        bool is_reverse;\n    };\n\n    Flow(const int v) : V{v}\n    {\n        edge.resize(v);\n    }\n    void addEdge(const int from, const int to, const T capacity)\n    {\n        edge[from].push_back(Edge{from, to, (int)edge[to].size(), capacity, false});\n        edge[to].push_back(Edge{to, from, (int)edge[from].size() - 1, 0, true});\n    }\n\n    T FordFulkerson(const int s, const int t)\n    {\n        vector<bool> checked(V);\n        T flow = 0;\n        while (true) {\n            for (int i = 0; i < V; i++) {\n                checked[i] = false;\n            }\n            const T f = dfs_ff(s, t, INF<T>, checked);\n            if (f == 0) {\n                break;\n            }\n            flow += f;\n        }\n        return flow;\n    }\n\n    const int V;\n    vector<vector<Edge>> edge;\n\nprivate:\n    T dfs_ff(const int pos, const int t, const T flow, vector<bool>& checked)\n    {\n        if (pos == t) {\n            return flow;\n        }\n        checked[pos] = true;\n        for (auto& e : edge[pos]) {\n            if (not checked[e.to]) {\n                const T res = e.capacity - e.flow;\n                if (res > 0) {\n                    const T d = dfs_ff(e.to, t, min(flow, res), checked);\n                    if (d > 0) {\n                        e.flow += min(d, res);\n                        edge[e.to][e.reverse].flow -= min(d, res);\n                        return d;\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n};\n\ntemplate <typename T>\nT gcd(const T a, const T b)\n{\n    return (b != 0) ? gcd(b, a % b) : a;\n}\n\n\nint main()\n{\n    while (true) {\n        int m, n;\n        cin >> m >> n;\n        if (m == 0 and n == 0) {\n            break;\n        }\n        Flow flow(m + n + 2);\n        vector<ll> b(m);\n        for (int i = 0; i < m; i++) {\n            flow.addEdge(m + n, i, 1);\n            cin >> b[i];\n        }\n        vector<ll> r(m);\n        for (int i = 0; i < n; i++) {\n            flow.addEdge(i + m, m + n + 1, 1);\n            cin >> r[i];\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (gcd(b[i], r[j]) > 1) {\n                    flow.addEdge(i, m + j, 1);\n                }\n            }\n        }\n        cout << flow.FordFulkerson(m + n, m + n + 1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nbool augment(const Graph& g, int u,\n\t\t\t vector<int>& matchTo, vector<bool>& visited) {\n  if(u < 0) return true;\n  FOR(e, g[u]) if(!visited[e->dst]) {\n\tvisited[e->dst] = true;\n\tif(augment(g, matchTo[e->dst], matchTo, visited)) {\n\t  matchTo[e->src] = e->dst;\n\t  matchTo[e->dst] = e->src;\n\t  return true;\n\t}\n  }\n  return false;\n}\n\nint bipartiteMatching(const Graph& g, int L) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n\tvector<bool> visited(n);\n\tif(augment(g, u, matchTo, visited)) ++ match;\n  }\n\n  return match;\n}\n\nint main() {\n  int blue[500], red[500];\n  int m, n;\n  \n  while(cin >> m >> n && (m|n)) {\n\tGraph g(m+n);\n\tREP(i, m) cin >> blue[i];\n\tREP(i, n) cin >> red[i];\n\t\n\tREP(i, m) REP(j, n) {\n\t  if(__gcd(blue[i], red[j]) > 1) {\n\t\tg[i].push_back(Edge(i, m+j, 1));\n\t\tg[m+j].push_back(Edge(m+j, i, 1));\n\t  }\n\t}\n\t\n\tcout << bipartiteMatching(g, m) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <map>\n#define _USE_MATH_DEFINES\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 30;\nconst double EPS = 1e-9;\n\nint n, m;\nint V;\nchar area[100][100];\nbool can[100][100];\nbool used[10000];\nint match[10000];\nvector<int> G[10000];\nint dy[] = {\n\t0, 0, 1, 1\n};\nint dx[] = {\n\t1, -1, 1, -1\n};\n\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i = 0; i < (int)G[v].size(); i++){\n\t\tint u = G[v][i], w = match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint matching(){\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor(int v = 0; v < V; v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used, false, sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid add_edge(int from, int to){\n\tG[to].push_back(from);\n\tG[from].push_back(to);\n}\n\nint gcd(int u, int v){\n\tint t;\n\twhile(u > 0){\n\t\tif(u < v){\n\t\t\tt = u;\n\t\t\tu = v;\n\t\t\tv = t;\n\t\t}\n\t\tu %= v;\n\t}\n\treturn v;\n}\n\nint b[1000];\nint r[1000];\n\nint main(){\n\tint m, n;\n\twhile(cin >> m >> n && (m || n)){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> b[i];\t\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> r[i];\n\t\t}\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(gcd(b[i], r[j]) > 1){\n\t\t\t\t\tadd_edge(i, m + j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tV = n + m;\n\t\tcout << matching() << endl;\n\n\t\tfor(int i = 0; i < V; i++) G[i].clear();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n\n/**\n * ?????¨?????§??????????????°\n *\n * O(EV)\n */\ntemplate<int V>\nstruct BitMatching {\n    vector<int> G[2*V];\n    int match[2*V];\n    bool used[2*V];\n    /// ?????????\n    void init() {\n        for (int i = 0; i < 2*V; i++) {\n            G[i].clear();\n        }\n    }\n    /// ?????´???a????????¨?????´???b?????????????????????\n    void add(int a, int b) {\n        G[a].push_back(b+V);\n        G[b+V].push_back(a);\n    }\n\n    bool dfs(int v) {\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            int u = G[v][i], w = match[u];\n            if (w < 0 || (!used[w] && dfs(w))) {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n    /// ?????§??????????????°?????¬??°???????????????\n    int exec() {\n        int res = 0;\n        memset(match, -1, sizeof(match));\n        for (int v = 0; v < V; v++) {\n            if (match[v] < 0) {\n                memset(used, 0, sizeof(used));\n                if (dfs(v)) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n};\n\nconst int MN = 520;\nBitMatching<MN> bm;\nll gcd(ll a, ll b) {\n    if (b == 0) return a;\n    return gcd(b, a%b);\n}\nint main() {\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (!n) break;\n        bm.init();\n        int a[n], b[m];\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        for (int i = 0; i < m; i++) {\n            cin >> b[i];\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (gcd(a[i], b[j]) != 1) {\n                    bm.add(i, j);\n                }\n            }\n        }\n        cout << bm.exec() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1e9;\n\n//テヲツ慊?・ツ、ツァテ」ツδ陛」ツδュテ」ツδシ\nconst int MAX_N = 510, MAX_K = 510;\nconst int MAX_V = 510 * 510;\n\nstruct edge{\n    int to, cap, rev;\n};\n\n//vector<edge> G[MAX_N];\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\n//テ、ツコツ古ゥツδィテ」ツδ榲」ツδε」ツδ?」ツδウテ」ツつー\nint N, K;\nbool can[MAX_N][MAX_K];\n\nint solve(){\n    int s = N + K, t = s + 1;\n    for(int i = 0; i < N; i++){\n        add_edge(s, i, 1);\n    }\n    for(int i = 0; i < K; i++){\n        add_edge(N + i, t, 1);\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < K; j++){\n            if(can[i][j]){\n                add_edge(i, N + j, 1);\n            }\n        }\n    }\n    return max_flow(s, t);\n}\n\nvector<int> prime_factor(int n){\n\tvector<int> res;\n\tfor(int i=2;i*i<=n;i++){\n        if(n % i == 0) res. push_back(i);\n\t\twhile(n%i==0){\n\t\t\tn/=i;\n\t\t}\n\t}\n\tif(n!=1) res. push_back(n);\n\treturn res;\n}\n\nint gcd(int a, int b){\n    if(a < b) swap(a, b);\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\nsigned main(){\n    int m, n;\n    while(1){\n        cin >> m >> n;\n        N = m; K = n;\n        if(m + n == 0) break;\n        // vector<edge> G[MAX_V];\n        rep(i, 0, MAX_V) G[i].clear();\n        rep(i, 0, 510) rep(j, 0, 510) can[i][j] = false;\n        int b[510], r[510];\n        // vector<int> bp[510], rp[510];\n        rep(i, 0, m){\n            cin >> b[i];\n            // bp[i] = prime_factor(b[i]);\n        }\n        rep(i, 0, n){\n            cin >> r[i];\n            // rp[i] = prime_factor(r[i]);\n        }\n        rep(i, 0, m){\n            // set<int> st;\n            // rep(j, 0, bp[i].size()) st.insert(bp[i][j]);\n            rep(j, 0, n){\n                if(gcd(b[i], r[j]) != 1){\n                    can[i][j] = true;\n                    // can[j][i] = true;\n                }\n                // rep(k, 0, rp[j].size()){\n                //     if(st.count(rp[j][k])){\n                //         can[i][j] = true;\n                //         break;\n                //     }\n                // }\n            }\n        }\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define rep(i,a) for(int i = 0;i < (a); i++)\n#define repi(i,a,b) for(int i = (a); i < (b); i++)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n#define MAX 510\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\nstruct edge{ int to, cap, rev; };\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].pb((edge){to, cap, G[to].size()});\n    G[to].pb((edge){from, 0, G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    rep(i, G[v].size()){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\nint N, K;\nint main() {\n    while(cin >> N >> K, N||K){\n        vector<int> b(N), r(K);\n        rep(i, N) cin >> b[i];\n        rep(i, K) cin >> r[i];\n        rep(i, MAX) G[i].clear();\n        int s = N+K, t = s+1;\n        rep(i, N) add_edge(s, i, 1);\n        rep(i, K) add_edge(N+i, t, 1);\n        rep(i, N) rep(j, K) if(__gcd(b[i], r[j]) > 1) add_edge(i, N+j, 1);\n        cout << max_flow(s, t) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nbool augment(vvi& E, int from, vi& match_to, vb& visited) {\n    if (from < 0) return true;\n    for (int to : E[from]) {\n        if (!visited[to]) {\n            visited[to] = true;\n            if (augment(E, match_to[to], match_to, visited)) {\n                match_to[from] = to;\n                match_to[to] = from;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(vvi& E, int M, int N) {\n    vi match_to(M+N, -1);\n    int match = 0;\n    REP(u, M) {\n        vb visited(M+N);\n        if (augment(E, u, match_to, visited)) match++;\n    }\n//    REP(u, L) if (matchTo[u] >= 0) matching.push_back({u, matchTo[u], 0});\n    return match;\n}\n\nint main() {\n    int M, N;\n    while (cin >> M >> N, M | N) {\n        vi b(M), r(N);\n        REP(i, M) cin >> b[i];\n        REP(i, N) cin >> r[i];\n\n        vvi E(M+N);\n\n        REP(i, M) {\n            REP(j, N) {\n                int e = __gcd(b[i], r[j]);\n                if (e > 1) {\n                    E[i].push_back(M+j);\n                }\n            }\n        }\n        cout << bipartite_matching(E, M, N) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n \n#define rep(i, n) for(int i = 0; i < (n); ++i)\n \nusing namespace std;\n\nconst int inf = 1e4;\n\nstruct E{\n    E(int to, int cap, int rev): to(to), cap(cap), rev(rev){}\n\n    int to, cap, rev;\n};\n\nint n, m;\nint b[500];\nint r[500];\nvector<E> g[1002];\nbool used[1002];\n\nvoid add_edge(int from, int to, int cap){\n    g[from].push_back(E(to, cap, g[to].size()));\n    g[to].push_back(E(from, 0, g[from].size() - 1));\n}\n\nint dfs(int v, int t, int f){\n    if(v == t){\n        return f;\n    }\n    used[v] = true;\n    for(E& e: g[v]){\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        fill_n(used, n + m + 2, false);\n        int f = dfs(s, t, inf);\n        if(!f){\n            break;\n        }\n        flow += f;\n    }\n    return flow;\n}\n\nint gcd(int a, int b){\n    return b ? gcd(b, a % b) : a;\n}\n\nint main(){\n    while(1){\n        cin >> n >> m;\n        if(!n){\n            break;\n        }\n\n        rep(i, n + m + 2){\n            g[i].clear();\n        }\n\n        rep(i, n){\n            cin >> b[i];\n            add_edge(n + m, i, 1);\n        }\n        rep(i, m){\n            cin >> r[i];\n            add_edge(n + i, n + m + 1, 1);\n        }\n        rep(i, n){\n            rep(j, m){\n                if(gcd(b[i], r[j]) > 1){\n                    add_edge(i, n + j, 1);\n                }\n            }\n        }\n\n        cout << max_flow(n + m, n + m + 1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\nconst int INF = 100000000;\n\nstruct Edge {\n  int to;\n  int cap;\n  int rev;\n  Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvoid add_edge(Graph& g, int from, int to, int cap) {\n  g[from].push_back(Edge(to, cap, g[to].size()));\n  g[to].push_back(Edge(from, 0, g[from].size() - 1));\n}\n\n// 幅優先探索で増加道を探す\nvector<Edge*> compute_augmented_path(Graph& g, int s, int t) {\n  int n = g.size();\n\n  // ある頂点の　「直前の頂点」と「直前の辺のインデックス」を格納しておく配列\n  vector<int> prevv(n, -1);  // まだ訪れていないなら-1\n  vector<int> preve(n);\n\n  queue<int> que;\n  que.push(s);\n  prevv[s] = -2;  // スタート時点より前はないのでダミーで-2とする\n\n  while (!que.empty()) {\n    int v = que.front();\n    que.pop();\n    rep(ei, g[v].size()) {\n      Edge& e = g[v][ei];\n      if (e.cap > 0 && prevv[e.to] == -1) {\n        // 容量に余裕があり、e.to が未訪問なら記録しつつキューに入れる\n        prevv[e.to] = v;\n        preve[e.to] = ei;\n        que.push(e.to);\n      }\n    }\n  }\n\n  // 逆順に増加道を格納していく。\n  // 後に容量を更新したい & 参照型のvectorは作れない　ため、エッジへのポインタのvectorを作る\n  vector<Edge*> ret;\n  if (prevv[t] == -1) return ret;  // 増加道がない\n\n  for (int v = t; prevv[v] != -2; v = prevv[v]) {\n    Edge* e = &g[prevv[v]][preve[v]];\n    ret.push_back(e);\n  }\n  return ret;\n}\n\n// gのsからtの最大流を求める。\n// gは破壊される（残余ネットワークとなる）。\nint max_flow(Graph& g, int s, int t) {\n  int f = 0;  // 現在の最大フロー　初期値0\n\n  while (1) {\n    // 増加道を探す。増加道がなければその時点のfが最大フローである\n    vector<Edge*> augpath = compute_augmented_path(g, s, t);\n    if (augpath.empty()) break;\n\n    // 増加道に流れるフローを求め、最大フローに加える\n    int inc = INF;\n    rep(i, augpath.size()) inc = min(inc, augpath[i]->cap);\n    f += inc;\n\n    rep(i, augpath.size()) {\n      Edge* e = augpath[i];\n      Edge& rev_e = g[e->to][e->rev];\n      // 増加道の辺eの容量をincだけ減らし、eの逆辺の容量をincだけ増やす\n      e->cap -= inc;\n      rev_e.cap += inc;\n    }\n  }\n\n  return f;\n}\n\n\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nint solve(int m, int n) {\n  vector<int> b(m);\n  vector<int> r(n);\n\n  rep(i, m) cin >> b[i];\n  rep(i, n) cin >> r[i];\n\n  // グラフを構築　各頂点の意味は以下の通り\n  // 0: 始点\n  // 1 + i: i番目の青のカード\n  // 1 + m + i: i番目の赤のカード\n  // 1 + m + n: 終点\n  int gn = 1 + m + n + 1;\n  Graph g(gn);\n  rep(mi, m) rep(ni, n) {\n    if (gcd(b[mi], r[ni]) > 1) {\n      add_edge(g, 1 + mi, 1 + m + ni, 1);\n    }\n  }\n  rep(mi, m) add_edge(g, 0, 1 + mi, 1);\n  rep(ni, n) add_edge(g, 1 + m + ni, 1 + m + n, 1);\n\n  return max_flow(g, 0, 1 + m + n);\n}\n\nint main() {\n  int m, n;\n  while (cin >> m >> n, n||m) cout << solve(m, n) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nstruct edge {\n\tint to;\n\tll cost;\n\tedge(int to, ll cost = 1) :to(to), cost(cost) {}\n};\nbool bipartite_matching_dfs(int v, vector<vector<edge>> &G, vector<int> &match, vector<bool> &used) {\n\tused[v] = true;\n\tfor (edge e : G[v]) {\n\t\tint w = match[e.to];\n\t\tif (w < 0 || !used[w] && bipartite_matching_dfs(w, G, match, used)) {\n\t\t\tmatch[v] = e.to;\n\t\t\tmatch[e.to] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint bipartite_matching(vector<vector<edge>> &G, int V) {\n\tvector<int> match(V, -1);\n\tvector<bool> used(V);\n\tint res = 0;\n\tfor (int i = 0; i < V; i++) {\n\t\tif (match[i] < 0) {\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tif (bipartite_matching_dfs(i, G, match, used)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nll gcd(ll a, ll b) {\n\treturn b ? gcd(b, a%b) : a;\n}\nint main() {\n\tint m, n;\n\tvector<int> b(500);\n\tvector<int> r(500);\n\tvector<vector<edge>> G(1000, vector<edge>());\n\twhile (cin >> m >> n, m) {\n\t\tfor (int i = 0; i < m + n; i++) G[i].clear();\n\t\tfor (int i = 0; i < m; i++) cin >> b[i];\n\t\tfor (int i = 0; i < n; i++) cin >> r[i];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (gcd(b[i], r[j]) > 1) {\n\t\t\t\t\tG[i].emplace_back(j + m);\n\t\t\t\t\tG[j + m].emplace_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching(G, m + n) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <cassert>\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n\nclass bipartite_matching {\npublic:\n    int n;\n    vector<vector<int>> g;\n    vector<int> match;\n\n    bipartite_matching(int n_) : n(n_), g(n_), match(n_), used(n_) {}\n\n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    int maximum_matching(void) {\n        int res = 0;\n        fill(begin(match), end(match), -1);\n        for (int v = 0; v < n; ++v) {\n            if (match[v] == -1) {\n                fill(begin(used), end(used), false);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    vector<int> used;\n    bool dfs(int v) {\n        used[v] = true;\n        for (int u : g[v]) {\n            int w = match[u];\n            if (w == -1 || (!used[w] && dfs(w))) {\n                match[v] = u; match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nint gcd(int a, int b) {\n    return b ? gcd(b, a%b) : a;\n}\n\nint n, m;\nint a[500], b[500];\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    while (cin >> n >> m && n) {\n        for (int i = 0; i < n; i++) {\n            cin >> a[i];\n        }\n        for (int i = 0; i < m; i++) {\n            cin >> b[i];\n        }\n\n        bipartite_matching bm(n + m);\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (gcd(a[i], b[j]) != 1) {\n                    bm.add_edge(i, n + j);\n                }\n            }\n        }\n\n        cout << bm.maximum_matching() << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 510\n#define MAX_N 510\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});  \n}\n\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nint N,K;\nbool can[MAX_N][MAX_N]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(){\n  //0??????N-1: ???????????\\???????????????????????????\n  //N??????N+K-1: ???????????????????????????\n  int s = N+K, t = s+1;\n  \n  //s??¨???????????\\??????????????¶\n  for(int i=0; i<N; i++) add_edge(s,i,1);\n  \n  //????????¨t?????????\n  for(int i=0; i<K; i++) add_edge(N+i,t,1);\n  \n  //???????????\\????????¨??????????????¶\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)\n      if(can[i][j]) add_edge(i, N+j , 1);\n\n  return max_flow(s,t);\n}\n\nint main(){\n  while(1){\n  int b,r,B[501],R[501];\n  cin>>b>>r;\n  if(!b&&!r)break;\n  for(int i=0;i<b;i++) cin>>B[i];\n  for(int i=0;i<r;i++) cin>>R[i];\n\n  memset(can,0,sizeof(can));\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n  N=b,K=r;\n  for(int i=0;i<b;i++)\n    for(int j=0;j<r;j++)\n      if(__gcd(B[i],R[j])>1) can[i][j]=1;\n\n  cout<<Biparite_Matching()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// テ・ツ淞コテヲツ慊ャテ」ツδ?」ツδウテ」ツδ療」ツδャテ」ツδシテ」ツδ?(テァツクツョテ・ツーツ湘ァツ可?\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint M, N;\nvector<int> B, R;\n\nint gcd(int a, int b) {\n    if(b > a) swap(a, b);\n    return (b == 0 ? a : gcd(b, a%b));\n}\n\n// テ、ツコツ古ゥツδィテ」ツδ榲」ツδε」ツδ?」ツδウテ」ツつー (テヲツ慊?・ツ、ツァテヲツオツ?」ツつ津、ツスツソテ」ツ?」テ」ツ?ヲティツァツ」テ」ツ??\n// テ」ツδサテヲツ卍ョテゥツ?堙」ツ?ォティツセツコテ」ツつ津・ツシツオテ」ツつ凝、ツサツ姪」ツ?ォテ」ツ??ィツ?ェテ・ツ按?」ツ?ァテ・ツ按・テ」ツ?ォテゥツ?づァツつケテ」ツつ?2 テ」ツ?、テァツ板ィテヲツ?湘」ツ?凖」ツつ?\n\ntemplate <typename T>\nstruct Edge {\n    int to; T cap, cost; int rev;\n    Edge(int t, T c, int r) : to(t), cap(c), rev(r) {}\n    Edge(int t, T ca, T co, int r) : to(t), cap(ca), cost(co), rev(r) {}\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\nstruct BipartiteMatching {\n    int S, T, E, a, b;\n    vector< vector< Edge<int> > > G;\n    vector<int> used;\n    BipartiteMatching(int x, int y, int z) : S(x), T(y), E(z) {\n        G.resize(S+T+2);\n        used.resize(S+T+2);\n        a = S + T, b = a + 1;\n    }\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back(Edge<int>(to  , cap, G[to  ].size()    ));\n        G[to  ].push_back(Edge<int>(from, 0  , G[from].size() - 1));\n    }\n    void readGraph() {\n        for(int i=0; i<M; i++) {\n            for(int j=0; j<N; j++) {\n                if(gcd(B[i], R[j]) != 1) {\n                    add_edge(i, S+j, 1);\n                }\n            }\n        }\n        for(int i=0; i<S; i++) add_edge(a  , i, 1);\n        for(int i=0; i<T; i++) add_edge(i+S, b, 1);\n    }\n    int dfs(int v, int t, int f) {\n        if(v == t) return f;\n        used[v] = true;\n        for(size_t i=0; i<G[v].size(); i++) {\n            Edge<int> &e = G[v][i];\n            if(!used[e.to] && e.cap > 0) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int solve() {\n        int flow = 0;\n        while(1) {\n            fill(used.begin(), used.end(), 0);\n            int f = dfs(a, b, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nsigned main() {\n    while(cin >> M >> N, M || N) {\n        BipartiteMatching fl(M, N, 0);\n        B.resize(M); R.resize(N);\n        rep(i,0,M) cin >> B[i];\n        rep(i,0,N) cin >> R[i];\n        fl.readGraph();\n        cout << fl.solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nusing ll = long long;\n\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define ALL(v) (v).begin(),(v).end()\n\ntypedef pair<int, int> P;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main(void) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile (1) {\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tif (m == 0 && n == 0) return 0;\n\t\t\n\t\tint b[m], r[n];\n\t\tREP(i, m) cin >> b[i];\n\t\tREP(i, n) cin >> r[i];\n\t\t\n\t\tbool memo[m][n];\n\t\tREP(i, m) {\n\t\t\tREP(j, n) {\n\t\t\t\tif (gcd(b[i], r[j]) == 1) memo[i][j] = false;\n\t\t\t\telse memo[i][j] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt[n];\n\t\tREP(i, n) cnt[i] = 0;\n\t\t\n\t\tREP(i, m) {\n\t\t\tREP(j, n) {\n\t\t\t\tif (memo[i][j]) {\n\t\t\t\t\t++cnt[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint maxpair = 0;\n\t\tREP(i, m) {\n\t\t\tint pairindex = n;\n\t\t\tint mincnt = 505;\n\t\t\tREP(j, n) {\n\t\t\t\tif (memo[i][j]) {\n\t\t\t\t\tif (cnt[j] == 0) continue;\n\t\t\t\t\tif (cnt[j] < mincnt) {\n\t\t\t\t\t\tpairindex = j;\n\t\t\t\t\t\tmincnt = cnt[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pairindex != n) {\n\t\t\t\t++maxpair;\n\t\t\t\tcnt[pairindex] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << maxpair << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n#include <complex>\n#include <regex>\n\nusing namespace std;\n\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\n#define MAX_N 1200\n#define INF 10000000\n\nstruct edge {\n    int to;\n    int cap;\n    int rev;\n};\n\n\nvector<vector<edge>> G;\nvector<bool> used;\n\nvoid add_edge(int from, int to, int cost) {\n    G[from].push_back((edge) {to, cost, (int) G[to].size()});\n    G[to].push_back((edge) {from, 0, (int) G[from].size() - 1});\n}\n\nint dash_flow(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && !used[e.to]) {\n            int d = dash_flow(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (true) {\n        used = vector<bool>(MAX_N, false);\n        int f = dash_flow(s, t, INF);\n        if (f == 0)return flow;\n        flow += f;\n    }\n}\n\nint gcd(int x, int y) {\n    return y == 0 ? x : gcd(y, x % y);\n}\n\nint main() {\n\n    while (true) {\n\n        int M, N;\n        cin >> M >> N;\n\n        if (M == 0 && N == 0) break;\n\n        G = vector<vector<edge>>(MAX_N);\n\n        vector<int> b(M);\n        for (int i = 0; i < M; i++)cin >> b[i];\n\n        vector<int> r(N);\n        for (int i = 0; i < N; i++) cin >> r[i];\n\n        int s = 0;\n        int t = N + M + 1;\n\n        for (int i = 0; i < M; i++) add_edge(s, i + 1, 1);\n        for (int i = 0; i < N; i++) add_edge(M + i + 1, t, 1);\n\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N; j++) {\n                if (gcd(b[i], r[j]) > 1) {\n                    add_edge(i + 1, M + j + 1, 1);\n                }\n            }\n        }\n\n        int ans = max_flow(s, t);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 2222\nvector<int> v[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int a,int b){\n\tv[a].PB(b);\n\tv[b].PB(a);\n}\n\nbool matchdfs(int a){\n\tused[a] = true;\n\tfor(int i = 0;i < v[a].size();i++)\t{\n\t\tint u = v[a][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w)){\n\t\t\tmatch[u] = a;\n\t\t\tmatch[a] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//二部マッチング\nint two_matching_max(int l){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<int> prime;\nbool isp[11111];\nvoid f(){\n\tREP(i,11111)isp[i] = true;\n\tisp[0] = isp[1] = false;\n\tfor(int i = 2;i < 11111;i++){\n\t\tif(isp[i]){\n\t\t\tprime.PB(i);\n\t\t\tfor(int j = i;j < 11111;j+=i)isp[j] = false;\n\t\t}\n\t}\n}\n\t\n#define HALF 1000\nint main(){\n\tf();\n\tint n,m;\n\twhile(cin >> n >> m,n|m){\n\t\tREP(i,MAX_V)v[i].clear();\n\t\tvector<int> a(n);REP(i,n)cin >> a[i];\n\t\tvector<int> b(m);REP(i,m)cin >> b[i];\n\t\tREP(i,n){\n\t\t\tvector<int> tmp;\n\t\t\tREP(j,prime.size()){\n\t\t\t\tif(a[i] % prime[j] == 0)tmp.PB(prime[j]);\n\t\t\t}\n\t\t\tREP(j,m){\n\t\t\t\tREP(k,tmp.size()){\n\t\t\t\t\tif(b[j] % tmp[k] == 0){\n\t\t\t\t\t\tadd_edge(i,j + 1000);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << two_matching_max(MAX_V) << endl;\n\t}\n\t\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 999999\n#define MAX_V 10000\nusing namespace std;\n\ntypedef struct edge{\n  int to,cap,rev;\n}edge;\n\nint val[MAX_V];\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nbool gcd(int a,int b){\n  int r=a%b;\n  while(r>0){\n    a=b;\n    b=r;\n    r=a%b;\n  }\n  if(b!=1)return true;\n  else return false;\n}\n\nvoid makeG(int m,int n){\n  memset(G,0,sizeof(G));\n  int to;\n  for(int i=0;i<m+n;i++){\n    cin>>val[i];\n  }\n  for(int i=0;i<m;i++){\n    for(int j=0;j<n;j++){\n      if(gcd(val[i],val[m+j])==true){\n\tG[i].push_back((edge){m+j,1,G[m+j].size()});\n\tG[m+j].push_back((edge){i,0,G[i].size()-1});\n      }\n    }\n  }\n  val[m+n]=val[m+n+1]=1;\n  for(int i=0;i<m;i++){\n    G[m+n].push_back((edge){i,1,G[i].size()});\n    G[i].push_back((edge){m+n,0,G[i].size()-1});\n  }\n  for(int i=m;i<m+n;i++){\n    G[i].push_back((edge){m+n+1,1,G[m+n+1].size()});\n    G[m+n+1].push_back((edge){i,0,G[i].size()-1});\n  }\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f=dfs(s,t,INF);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint main(){\n  int m,n;\n  while(cin>>m>>n,n){\n    makeG(m,n);\n    cout << max_flow(m+n,m+n+1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<n;i++)\n#define loop(i,a,n) for(i=a;i<n;i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\n#define MAX_V 2000\nstruct edge{int to,cap,rev;};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  int i;\n  if(v==t)return f;\n  used[v]=true;\n  rep(i,G[v].size()){\n    edge &e=G[v][i];\n    if(!used[e.to] && e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    memset(used,0,sizeof(used));\n    int f=dfs(s,t,INF);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint main(void) {\n  int i,j;\n  int m,n;\n  while(1){\n    memset(G,0,sizeof(G));\n\n    cin>>m>>n;\n    if(n+m==0)break;\n    vi b(m),r(n);\n    rep(i,m){\n      cin>>b[i];\n      add_edge(0,1+i,1);\n      //cout<<0<<\" \"<<1+i<<endl;\n    }\n    rep(i,n){\n      cin>>r[i];\n      add_edge(1+m+i,1+m+n,1);\n      //      cout<<1+m+i<<\" \"<<1+m+n<<endl;\n    }\n    rep(i,m) rep(j,n) if(__gcd(b[i],r[j])>1) add_edge(1+i,1+m+j,1);\n    \n    cout<<max_flow(0,1+m+n)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\n\nstruct edge{\n\tint to,co,p;\n};\n\nvector<edge> vs[1005];\n\nvoid cleae(){\n\trep(i,1005)vs[i].clear();\n}\n\nvoid adde(int a,int b,int c){\n\t//printf(\"fr %d to %d co %d\\n\",a,b,c);\n\tint sa=vs[a].size(),\n\t\tsb=vs[b].size();\n\tedge e; e.co=c;\n\te.to=b; e.p=sb; vs[a].push_back(e);\n\te.to=a; e.p=sa; vs[b].push_back(e);\n}\n\nint st,gl;\nint gone[1005];\nint dfs(int no,int f){\n\tif(gone[no])return 0;\n\tgone[no]=1;\n\tif(no==gl)return f;\n\trep(i,vs[no].size()){\n\t\tedge& e=vs[no][i];\n\t\tif(gone[e.to])continue;\n\t\tif(e.co>0){\n\t\t\tint gf = dfs(e.to,min(e.co,f));\n\t\t\tif(gf>0){\n\t\t\t\te.co-=gf;\n\t\t\t\tvs[e.to][e.p].co+=gf;\n\t\t\t\treturn gf;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint flow(){\n\tint res=0;\n\tfor(;;){\n\t\tmemset(gone,0,sizeof(gone));\n\t\tint f = dfs(st,IINF);\n\t\tif(f==0)return res;\n\t\tres+=f;\n\t}\n}\n\nint na,nb;\nint da[505];\nint db[505];\nint gcd(int p,int q){\n\tif(p<q)swap(p,q);\n\tif(p%q==0)return q;\n\treturn gcd(q,p%q);\n}\n\nint main(void){\n\tfor(;;){\n\t\tscanf(\"%d%d\",&na,&nb);\n\t\tif(na==0)break;\n\t\trep(i,na)scanf(\"%d\",&da[i]);\n\t\trep(i,nb)scanf(\"%d\",&db[i]);\n\t\tcleae();\n\t\t\n\t\tst=0;\n\t\tgl=na+nb+1;\n\t\trep(i,na)adde(st,i+1,1);\n\t\trep(i,nb)adde(i+na+1,gl,1);\n\t\t\n\t\trep(i,na)rep(j,nb){\n\t\t\tif(gcd(da[i],db[j])>1)adde(i+1,j+na+1,1);\n\t\t}\n\t\tprintf(\"%d\\n\",flow());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint gcd(int x, int y) {\n  while(y) {\n    int t = x%y;\n    x = y;\n    y = t;\n  }\n  return x;\n}\n\nint main() {\n  for(int tci = 0; ; tci++) {\n    int M,N; scanf(\"%d%d\", &M, &N); if(M==0) break;\n    static int BC[500],RC[500];\n    for(int i = 0; i < M; i++) {\n      scanf(\"%d\", BC+i);\n    }\n    for(int i = 0; i < N; i++) {\n      scanf(\"%d\", RC+i);\n    }\n    static int capa[1002][1002];\n    for(int i = 0; i < M+N+2; i++) {\n      for(int j = 0; j < M+N+2; j++) {\n        capa[i][j] = 0;\n      }\n    }\n    for(int i = 0; i < M; i++) {\n      capa[M+N][i] = 1;\n    }\n    for(int i = 0; i < N; i++) {\n      capa[M+i][M+N+1] = 1;\n    }\n    for(int i = 0; i < M; i++) {\n      for(int j = 0; j < N; j++) {\n        capa[i][M+j] = (gcd(BC[i],RC[j])>1) ? 1 : 0;\n      }\n    }\n    int flow = 0;\n    while(true) {\n      vector<int> stk; stk.reserve(M+N+2);\n      vector<char> vis(M+N+2, 0);\n      vector<int> par(M+N+2);\n      stk.push_back(M+N);\n      vis[M+N] = 1;\n      while(!stk.empty()) {\n        int v = stk.back(); stk.pop_back();\n        if(v==M+N+1) {\n          for(int w = v; w != M+N; w = par[w]) {\n            capa[par[w]][w]--;\n            capa[w][par[w]]++;\n          }\n          flow++;\n          goto cont;\n        }\n        for(int w = 0; w < M+N+2; w++) {\n          if(capa[v][w]==1 && !vis[w]) {\n            vis[w] = 1;\n            par[w] = v;\n            stk.push_back(w);\n          }\n        }\n      }\n      break;\n  cont:continue;\n    }\n    printf(\"%d\\n\", flow);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, 1, 0, -1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\nstruct Edge {\n    int to, cap, rev;\n    Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {\n        assert(this->cap >= 0);\n    }\n};\n\n// 最大流問題をO(F|E|)で解く\nclass FordFulkerson {\npublic:\n    unsigned int num_of_node = 0;   // ノード数\n    map<int, vector<Edge>> G;       // グラフの隣接リスト表現\n    vector<bool> used;              // DFSですでに調べたかのフラグ\n\n    FordFulkerson(unsigned int num_of_node) : num_of_node(num_of_node){\n    }\n\n    // fromからtoへ向かう容量capの辺とその逆辺をグラフに追加する\n    void add_edge(int from, int to, int cap) {\n        this->G[from].push_back(Edge(to, cap, (int)this->G[to].size()));        // 辺\n        this->G[to].push_back(Edge(from, 0, (int)this->G[from].size() - 1));    // 逆辺\n    }\n\n    // sからtへの最大流を求める O(F|E|)\n    int max_flow(int s, int t) {\n        int flow = 0;\n        while (true) {\n            this->used = vector<bool>(this->num_of_node, 0);\n            int f = dfs(s, t, INT_MAX);\n            if (f == 0) { return flow; }\n            flow += f;\n        }\n    }\n\nprivate:\n    // vからtへf流したときの流れた量\n    int dfs(int v, int t, int f) {\n        if (v == t) { return f; }\n        used[v] = true;\n        for (Edge &e : G[v]) {\n            if (!used[e.to] && e.cap > 0) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;                 // 辺\n                    G[e.to][e.rev].cap += d;    // 逆辺\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n};\n\n// aとbの最大公約数\nint gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int M, N;\n        cin >> M >> N;\n        if (M == 0 and N == 0) { break; }\n\n        V<int> blue(M), red(N);\n        FOR(i, 0, M) {\n            cin >> blue[i];\n        }\n        FOR(i, 0, N) {\n            cin >> red[i];\n        }\n\n        int source = M + N;\n        int sink = source + 1;\n        FordFulkerson ff(M + N + 2);\n        FOR(i, 0, blue.size()) {\n            FOR(j, 0, red.size()) {\n                if (gcd(blue[i], red[j]) != 1) {\n                    ff.add_edge(i, blue.size() + j, 1);\n                }\n            }\n        }\n\n        FOR(i, 0, blue.size()) {\n            ff.add_edge(source, i, 1);\n        }\n        FOR(j, 0, red.size()) {\n            ff.add_edge(blue.size() + j, sink, 1);\n        }\n\n        print(ff.max_flow(source, sink));\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nconst int max_v=1002;\nstruct edge{int to,cap,rev;};\nvector<edge> graph[max_v];\nbool used[max_v];\n\nvoid add_edge(int from,int to,int cap){\n    graph[from].push_back(edge{to,cap,int(graph[to].size())});\n    graph[to].push_back(edge{from,0,int(graph[from].size()-1)});\n}\n\nint ford_fulkerson_dfs(int v,int t,int f){\n    if(v==t) return f;\n    used[v]=true;\n    for(auto &e:graph[v]){\n        if(used[e.to] or e.cap<=0) continue;\n        int d=ford_fulkerson_dfs(e.to,t,min(f,e.cap));\n        if(d>0){\n            e.cap-=d;\n            graph[e.to][e.rev].cap+=d;\n            return d;\n        }\n    }\n    return 0;\n}\n\nint ford_fulkerson(int s,int t){\n    int flow=0,f;\n    while(true){\n        fill_n((bool*)used,max_v,false);\n        f=ford_fulkerson_dfs(s,t,inf);\n        if(f==0) return flow;\n        flow+=f;\n    }\n}\n\nint gcd(int x,int y){\n     if(y==0) return x;\n     return gcd(y,x%y);\n}\n\nvoid solve(){\n    int m,n;\n    while(true){\n        cin >> m >> n;\n        if(m==0 and n==0) break;\n        \n        for(auto &v:graph) v.clear();\n        \n        vector<int> b(m),r(n);\n        for(int &x:b) cin >> x;\n        for(int &x:r) cin >> x;\n        \n        rep(i,0,m){\n            rep(j,0,n){\n                if(gcd(b[i],r[j])>1) add_edge(i,m+j,1);\n            }\n        }\n        \n        rep(i,0,m) add_edge(m+n,i,1);\n        rep(i,0,n) add_edge(m+i,m+n+1,1);\n        \n        cout << ford_fulkerson(m+n,m+n+1) << endl;\n    }\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint biMatch(const vector<vector<int>>& adj, int ln) { // adj: [0,ln)->inL [ln,n)->inR\n    int n = adj.size();\n    vector<int> matchTo(n, -1);\n    vector<bool> used(n, false);\n    function<bool(int)> dfs = [&](int v) {\n        for(int nv : adj[v]) if(!used[nv]) {\n            used[nv] = true;\n            if(matchTo[nv] < 0 || dfs(matchTo[nv])) {\n                matchTo[v] = nv;\n                matchTo[nv] = v;\n                return true;\n            }\n        }\n        return false;\n    };\n    int ans = 0;\n    for(int v : in(ln)) if(matchTo[v] < 0) {\n        used.assign(n, false);\n        if(dfs(v)) ++ans;\n    }\n    return ans;\n}\ntemplate<typename T>\nT gcd(T a, T b) {\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, m;\n    while(cin >> n >> m && n) {\n        vector<int> a(n), b(m);\n        for(int& x : a) cin >> x;\n        for(int& x : b) cin >> x;\n        vector<vector<int>> adj(n + m);\n        for(int i : in(n)) for(int j : in(m)) {\n            if(gcd(a[i], b[j]) > 1) {\n                int v = i, u = j + n;\n                adj[v].emplace_back(u);\n                adj[u].emplace_back(v);\n            }\n        }\n        cout << biMatch(adj, n) << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\nint n,m;\nbool V[1000];\nbool C[1000][1000];\nint P[1000];\n\nint gcd(int a,int b);\nbool match(int a);\n\nint main(){\n\n\n  while(cin >> n >> m && (n>0 || m>0) ){\n    int blue[n],red[m];\n    \n    for(int i=0;i<n;i++){\n      cin >> blue[i];\n    }\n    for(int i=0;i<m;i++){\n      cin >> red[i];\n      P[i]=-1;\n      V[i]=false;\n    }\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++){\n\tif(gcd(blue[i],red[j])>1)C[i][j]=1;\n\telse C[i][j]=0;\n      }\n    }\n    int ans=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<m;j++)V[j]=false;\n      if(match(i)) ans++;\n    }\n    \n    cout << ans << endl;\n  }\n}\n\nint gcd(int a,int b){\n  if(a<b){\n    int temp=b;\n    b=a;\n    a=temp;\n  }\n\n  if(a%b==0) return b;\n  else return gcd(b,a%b);\n}\n\nbool match(int a){\n   if(a<0)return true;\n\n   for(int j=0;j<m;j++){\n     if(!C[a][j] || V[j] )continue;\n     V[j]=true;\n     if(match(P[j])){\n       P[j]=a;\n       return true;\n     }\n   }\n   return false;\n }\n\n   "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\nint V;\nvector<int> G[1001];\nint match[1001];\nbool used[1001];\n\nvector<int> prime;\n\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i], w=match[u];\n\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int v=0;v<V;v++){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid primesolve(){\n\tprime.push_back(2);\n\tprime.push_back(3);\n\n\tfor(int i=4;i<1000000;i++){\n\t\tbool flag = true;\n\t\tfor(int k=2;k*k<=i;k++){\n\t\t\tif(i%k == 0){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag){\n\t\t\tprime.push_back(i);\n\t\t}\n\t}\n}\n\nint main(){\n\tprimesolve();\n\twhile(true){\n\t\tint m,n;\n\t\tcin >> m >> n;\n\t\tif(m == 0){\n\t\t\tbreak;\n\t\t}\n\t\tvector<int> b;\n\t\tvector<int> r;\n\t\tV = m+n;\n\t\tfor(int i=0;i<1001;i++){\n\t\t\tvector<int> buf;\n\t\t\tG[i] = buf;\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tb.push_back(buf);\n\t\t}\n\t\tfor(int j=0;j<n;j++){\n\t\t\tint buf;\n\t\t\tcin >> buf;\n\t\t\tr.push_back(buf);\n\t\t}\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<prime.size();k++){\n\t\t\t\t\tif(b[i]%prime[k]==0&&r[j]%prime[k]==0){\n\t\t\t\t\t\tadd_edge(i,j+m);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(min(b[i],r[j]) < prime[k]){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bipartite_matching() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000007\n#define MAX_V 1010\nstruct edge{int to,cap,rev;};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++){\n    G[i].clear();\n    used[i]=0;\n  }\n}\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f=dfs(s,t,INF);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint main(){\n  int m,n;\n  int b[500],r[500];\n  while(cin>>m>>n,n){\n    init();\n    for(int i=0;i<m;i++)cin>>b[i],add_edge(1001,i,1);\n    for(int i=0;i<n;i++)cin>>r[i],add_edge(i+500,1002,1);\n    for(int i=0;i<m;i++)\n      for(int j=0;j<n;j++){\n\tif(__gcd(b[i],r[j])>1){\n\t  add_edge(i,j+500,1);\n\t}\n      }\n    cout<<max_flow(1001,1002)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define fi first\n#define se second\n// #define int long long\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 1e9;\n\n//?????§?????????\nconst int MAX_N = 510, MAX_K = 510;\nconst int MAX_V = 510 * 510;\n\nstruct edge{\n    int to, cap, rev;\n};\n\n// vector<edge> G[MAX_N];\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\n//?????¨??????????????°\nint N, K;\nbool can[MAX_N][MAX_K];\n\nint solve(){\n    int s = N + K, t = s + 1;\n    for(int i = 0; i < N; i++){\n        add_edge(s, i, 1);\n    }\n    for(int i = 0; i < K; i++){\n        add_edge(N + i, t, 1);\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < K; j++){\n            if(can[i][j]){\n                add_edge(i, N + j, 1);\n            }\n        }\n    }\n    return max_flow(s, t);\n}\n\nsigned main(){\n    int m, n;\n    while(cin >> m >> n, m + n){\n        memset(can, 0, sizeof(can));\n        rep(i, 0, MAX_V) G[i].clear(), used[i] = false;\n        vector<int> b(m), r(n);\n        rep(i, 0, m) cin >> b[i];\n        rep(i, 0, n) cin >> r[i];\n        N = m; K = n;\n        set<int> bs[510], rs[510];\n        rep(i, 0, m){\n            for(int j = 2; j * j <= b[i]; j++){\n                if(b[i] % j == 0) bs[i].insert(j);\n                while(b[i] % j == 0){\n                    b[i] /= j;\n                }\n            }\n            if(b[i] != 1) bs[i].insert(b[i]);\n        }\n        rep(i, 0, n){\n            for(int j = 2; j * j <= r[i]; j++){\n               if(r[i] % j == 0) rs[i].insert(j);\n                while(r[i] % j == 0){\n                    r[i] /= j;\n                }\n            }\n            if(r[i] != 1) rs[i].insert(r[i]);\n        }\n        \n        rep(i, 0, m){\n            rep(j, 0, n){\n                for(auto& k : bs[i]){\n                    if(rs[j].count(k)){\n                        can[i][j] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        \n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e9\n#define MAX_V 500\n#define MAX_N 500\nusing namespace std;\n\n/*?????§?????¢?????´?????????(Ford_Fulerson????????¨)???O(F|E|)*/\n\n//????????¨????§???????(???????????????????????????)\nstruct edge{int to, cap, rev;};\n\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});  \n}\n\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\nint N,K;\nbool can[MAX_N][MAX_N]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nint Biparite_Matching(){\n  //0??????N-1: ???????????\\???????????????????????????\n  //N??????N+K-1: ???????????????????????????\n  int s = N+K, t = s+1;\n  \n  //s??¨???????????\\??????????????¶\n  for(int i=0; i<N; i++) add_edge(s,i,1);\n  \n  //????????¨t?????????\n  for(int i=0; i<K; i++) add_edge(N+i,t,1);\n  \n  //???????????\\????????¨??????????????¶\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)\n      if(can[i][j]) add_edge(i, N+j , 1);\n\n  return max_flow(s,t);\n}\n\nint main(){\n  while(1){\n  int b,r,B[501],R[501];\n  cin>>b>>r;\n  if(!b&&!r)break;\n  for(int i=0;i<b;i++) cin>>B[i];\n  for(int i=0;i<r;i++) cin>>R[i];\n\n  memset(can,0,sizeof(can));\n  for(int i=0;i<MAX_V;i++) G[i].clear();\n  N=b,K=r;\n  for(int i=0;i<b;i++)\n    for(int j=0;j<r;j++)\n      if(__gcd(B[i],R[j])>1) can[i][j]=1;\n\n  cout<<Biparite_Matching()<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ntypedef struct{\n\tint to, cap, rev;\n}edge;\n\nint x[555], y[555];\nint gcd(int a, int b)\n{\n    while( 1 )\n    {\n        a = a % b;\n\t\tif( a == 0 )\n\t\t\treturn b;\n\t\tb = b % a;\n\n        if( b == 0 )\n\t\t\treturn a;\n    }\n}\n\nclass biMatch{//bipartite matching\npublic:\n\tvector<vector<edge> > g;\n\tbiMatch(int k){\n\t\tg = vector<vector<edge> >(k);\n\t}\n\tvoid add_edge(int from, int to, int cap){\n\t\tedge e;\n\t\te.to = to;\n\t\te.cap = cap;\n\t\te.rev = g[to].size();\n\t\tg[from].PB(e);\n\t\te.to = from;\n\t\te.cap = cap;\n\t\te.rev = g[from].size()-1;\n\t\tg[to].PB(e);\n\t}\n\tint DFS(int n, int f, int goal, VI &visited){\n\t\tif(n==goal)return f;\n\t\tvisited[n] = 1;\n\t\tint cnt = f;\n\t\tREP(i, g[n].size()){\n\t\t\tif(g[n][i].cap <= 0)continue;\n\t\t\tif(visited[g[n][i].to])continue;\n\t\t\tint ret = DFS(g[n][i].to, min(f, g[n][i].cap), goal, visited);\n\t\t\tint n2 = g[n][i].to;\n\t\t\tg[n][i].cap -= ret;\n\t\t\tg[n2][g[n][i].rev].cap += ret;\n\t\t\tcnt -= ret;\n\t\t\tif(cnt == 0)break;\n\t\t}\n\t\treturn f-cnt;\n\t}\n};\n\nint main(){\n\twhile(1){\n\t\tint m, n;\n\t\tcin >> m >> n;\n\t\tif(m==0)return 0;\n\t\tbiMatch b(m+n+2);\n\t\tREP(i,m){\n\t\t\tscanf(\"%d\", &x[i]);\n\t\t\tb.add_edge(0, i+1, 1);\n\t\t}\n\t\tREP(i,n){\n\t\t\tscanf(\"%d\", &y[i]);\n\t\t\tb.add_edge(m+i+1, m+n+1, 1);\n\t\t}\n\t\tREP(i,m){\n\t\t\tREP(j,n){\n\t\t\t\tif(gcd(x[i], y[j]) > 1){\n\t\t\t\t\tb.add_edge(i+1, m+j+1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\twhile(1){\n\t\t\tVI visited(m+n+2, 0);\n\t\t\tint tmp = b.DFS(0, 1, m+n+1, visited);\n\t\t\tif(tmp == 0)break;\n\t\t\tret += tmp;\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <climits>\n#include <set>\n#include <numeric>\n#include <iomanip>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nvector <int> edges[1000];\nint match[1000];\nbool used[1000];\n\nvoid add_edge(int u, int v){\n    edges[u].push_back(v);\n    edges[v].push_back(u);\n}\n\nbool dfs(int v){\n    used[v] = true;\n    for(int i = 0; i < edges[v].size(); i++){\n        int u = edges[v][i];\n        int w = match[u];\n        if(w < 0 || (!used[w] && dfs(w))){\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(int N){\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for(int v = 0; v < N; v++){\n        if(match[v] < 0){\n            memset(used, 0, sizeof(used));\n            if(dfs(v)){\n                res ++;\n            }\n        }\n    }\n    return res;\n}\n\nvoid init(int N){\n    for(int i = 0; i < N; i++){\n        edges[i].clear();\n        match[i] = 0;\n        used[i] = false;\n    }\n}\n\nint gcd(int m, int n){\n    if(m < n){\n        return gcd(n, m);\n    }\n    if(n == 0){\n        return m;\n    } \n    return gcd(n, m % n);\n}\n\nint b[500];\nint r[500];\nint main(void){\n    int m;\n    int n;\n    while(true){\n        cin >> m >> n;\n        if(m == 0 && n == 0){\n            break;\n        }\n        for(int i = 0; i < m; i++){\n            cin >> b[i];\n        }\n        for(int i = 0; i < n; i++){\n            cin >> r[i];\n        }\n\n        init(m + n);\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(gcd(b[i], r[j]) != 1){\n                    add_edge(i, m + j);\n                }\n            }\n        }\n        cout << bipartite_matching(m) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nstruct E {\n  int to, cost, cap, rev;\n  E(int to, int cost, int cap, int rev)\n    : to(to), cost(cost), cap(cap), rev(rev) {}\n  E() {}\n};\n\ntypedef vector<vector<E> > G;\n\nvoid addEdgeF(int from, int to, int cost, int cap, G &g) {\n  g[from].push_back(E(to,cost,cap,g[to].size()));\n  g[to].push_back(E(from,cost,0,(int)g[from].size()-1));\n}\n\nint dfsF(int v, int t, int f, bool *used, G &g) {\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < g[v].size(); ++i) {\n    E &e = g[v][i];\n    if(!used[e.to] && e.cap > 0) {\n      int d = dfsF(e.to, t, min(f, e.cap), used, g);\n      if(d > 0) {\n        e.cap -= d;\n        g[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int s, int t, G g) {\n  int flow = 0;\n  bool used[g.size()];\n  while(1) {\n    memset(used, 0, sizeof(used));\n    int f = dfsF(s, t, INF, used, g);\n    if(f == 0) break;\n    flow += f;\n  }\n  return flow;\n}\n\nint gcd(int a, int b) {\n  return b == 0 ? a : gcd(b, a%b);\n}\n\nint main() {\n  int m, n, tmp;\n  vector<int> b, r;\n  G g;\n  while(cin >> m >> n && (m|n)) {\n    b.resize(m);\n    r.resize(n);\n    for(int i = 0; i < m; ++i) {\n      cin >> b[i];\n    }\n    for(int i = 0; i < n; ++i) {\n      cin >> r[i];\n    }\n\n    g = G(m+n+2);\n    for(int i = 0; i < m; ++i) {\n      addEdgeF(m+n, i, 0, 1, g);\n    }\n    for(int i = 0; i < m; ++i) {\n      for(int j = 0; j < n; ++j) {\n        if(gcd(b[i], r[j]) != 1) {\n          addEdgeF(i, m+j, 0, 1, g);\n        }\n      }\n    }\n    for(int i = 0; i < n; ++i) {\n      addEdgeF(m+i, m+n+1, 0, 1, g);\n    }\n    cout << maxFlow(m+n, m+n+1, g) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//52行目から編集\n#include <iostream>\n#include <limits.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <unordered_set>\n#include <cassert>\n\nusing namespace std;\n#define rep(i,n) for(int (i) = 0;(i) < (n);(i)++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<ll> > vvl;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\n\ntemplate<class T> bool chmin(T& a,T b){if(a > b){a = b;return true;}else return false;}\ntemplate<class T> bool chmax(T& a,T b){if(a < b){a = b;return true;}else return false;}\n///////////////////////////////////////////////////////////\nclass BM {\nprivate:\n    struct edge {\n        int to,cap,rev;\n    };\n    int U,V;\n    vector<vector<edge> > G;\n    vector<int> level;\n    vector<int> iter;\n \npublic:\n    BM(int u,int v) : U(u), V(v), G(U+V+2){\n        for(int i = 0; i < U; i++){\n            init_edge(0,i+1);\n        }\n        for(int i = 0; i < V; i++){\n            init_edge(U+i+1,U+V+1);\n        }\n    }\n    void init_edge(int from,int to) {\n        G[from].push_back((edge){to,1,(int)G[to].size()});\n    \tG[to].push_back((edge){from,0,(int)G[from].size()-1});\n    }\n    void add_edge(int from,int to) {\n        from += 1,to += U+1;\n    \tG[from].push_back((edge){to,1,(int)G[to].size()});\n    \tG[to].push_back((edge){from,0,(int)G[from].size()-1});\n    }\n    void bfs(int s) {\n        fill(level.begin(),level.end(),-1);\n    \tqueue<int> que;\n    \tlevel[s] = 0;\n    \tque.push(s);\n    \twhile(!que.empty()){\n            int v = que.front();\n            que.pop();\n            for(auto& e : G[v]){\n                if(e.cap > 0 && level[e.to] < 0){\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t,int f) {\n        if(v==t){\n            return f;\n        }\n        for(int &i = iter[v];i<(int)G[v].size();i++){\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]){\n                int d = dfs(e.to,t,min(f,e.cap));\n                if(d>0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int solve() {\n        level.resize(U+V+2), iter.resize(U+V+2);\n        int flow = 0;\n        int s=0,t=U+V+1;\n        for(;;){\n            bfs(s);\n            if(level[t] < 0) return flow;\n            fill(iter.begin(),iter.end(),0);\n            int f;\n            while((f=dfs(s,t,numeric_limits<int>::max())) > 0){\n                flow += f;\n            }\n        }\n    }\n    vector<int> allocate() {\n        vector<int> res(U, -1);\n        for(int i = 0; i < U; i++){\n            for(auto& e : G[i+1]){\n                if(e.cap == 0 && e.to != 0){\n                    res[i] = e.to-U-1;\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n};\n\nlong long gcd(long long a, long long b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\nlong long lcm(long long a, long long b) {\n  return a * b / gcd(a, b);\n}\n// a x + b y = gcd(a, b)\nlong long extgcd(long long a, long long b, long long &x, long long &y) {\n  long long g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //cout << fixed << setprecision(20);\n    while(true){\n        int m,n;cin >> m >> n;\n        if(!m and !n)break;\n        vector<int> a(m),b(n);\n        rep(i,m)cin >> a[i];\n        rep(i,n)cin >> b[i];\n        BM G(m,n);\n        rep(i,m){\n            rep(j,n){\n                if(gcd(a[i],b[j]) != 1){\n                    G.add_edge(i,j);\n                }\n            }\n        }\n        cout << G.solve() << '\\n';\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <cstdio>\n\nusing namespace std;\n\nint gcd(int m, int n) {\n    if(m < n) return gcd(n, m);\n    while(n != 0) {\n        int tmp = m % n;\n        m = n;\n        n = tmp;\n    }\n    return m;\n}\n\n//flow_vÍÚ±zñ\n//pairÍ<s«æ, RXg>\nint maxflow(const vector<vector<pair<int, int> > > &flow_v, int s, int g) {\n    int size = flow_v.size();\n    //×ÚsñÉÏ·\n    //Å©ç×ÚsñnµÈç±±Í¢çÈ¢\n    /*****½¾µAtûüÉÌRXgªüÁÄ¢é©ÍvmF*****/\n    vector<vector<int> > capacity(size, vector<int>(size, 0));\n    for(int i = 0; i < size; ++i) {\n        for(int j = 0; j < flow_v[i].size(); ++j) {\n            int to = flow_v[i][j].first;\n            int cost = flow_v[i][j].second;\n            capacity[i][to] = cost;\n        }\n    }\n    vector<vector<int> > flow(size, vector<int>(size, 0));\n\n    int ans = 0;\n    while(true) {\n        //DæTõÅaugument flowðÝÂ¯é\n        queue<int> q;\n        vector<int> prev(size, -1);\n        prev[s] = s;\n        q.push(s);\n        while(!q.empty()) {\n            int n = q.front();\n            q.pop();\n            for(int i = 0; i < size; ++i) {\n                if(capacity[n][i]-flow[n][i] <= 0) continue;\n                if(prev[i] != -1) continue;\n                prev[i] = n;\n                q.push(i);\n                if(i == g) goto endloop;\n            }\n        }\nendloop:\n        if(prev[g] == -1) break;\n        int res = INT_MAX;\n        for(int i = g; prev[i] != i; i = prev[i]) {\n            res = min(res, capacity[prev[i]][i]-flow[prev[i]][i]);\n        }\n        for(int i = g; prev[i] != i; i = prev[i]) {\n            flow[prev[i]][i] += res;\n            flow[i][prev[i]] -= res;\n        }\n        ans += res;\n    }\n    return ans;\n}\n\nint main() {\n    while(true) {\n        int m, n;\n        cin >> m >> n;\n        if(!m && !n) break;\n\n        vector<int> cards(m+n);\n        vector<vector<pair<int, int> > > graph(m+n+2);\n        for(int i = 0; i < m; ++i) {\n            //cin >> cards[i];\n            scanf(\"%d\", &cards[i]);\n            graph[m+n].push_back(make_pair(i, 1)); //Start node\n        }\n        for(int i = m; i < m+n; ++i) {\n            scanf(\"%d\", &cards[i]);\n            for(int j = 0; j < m; ++j) {\n                if(gcd(cards[i], cards[j]) > 1) {\n                    graph[j].push_back(make_pair(i, 1));\n                }\n            }\n            graph[i].push_back(make_pair(m+n+1, 1)); //Goal node\n        }\n        cout << maxflow(graph, m+n, m+n+1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, -1, 0, 1 };\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\nvoid inputVector(vector<int> &v, int &n) {rep(i,n){v.push_back(nextInt());}}\nvoid inputVector(vector<double> &v, int &n) {rep(i,n){v.push_back(nextDouble());}}\nvoid inputVector(vector<string> &v, int &n) {rep(i,n){v.push_back(nextString());}}\n\nclass Graph {\nprivate:\n\tclass Edge {\n\tpublic:\n\t\tint to;\n\t\tint cap;\n\t\tint rev;\n\t\tEdge(int to, int cap, int rev) {\n\t\t\tthis->to = to;\n\t\t\tthis->cap = cap;\n\t\t\tthis->rev = rev;\n\t\t}\n\t};\n\n\tint calcFlow(int s, int t, int left) {\n\t\tif (s == t) return left;\n\n\t\tvisited[s] = true;\n\n\t\trep(i, nextEdges[s].size()) {\n\t\t\tEdge &edge = nextEdges[s][i];\n\t\t\tif (edge.cap == 0) continue;\n\t\t\tif (visited[edge.to]) continue;\n\t\t\tint flow = calcFlow(edge.to, t, min(left, edge.cap));\n\t\t\tif (flow > 0) {\n\t\t\t\tedge.cap -= flow;\n\t\t\t\tnextEdges[edge.to][edge.rev].cap += flow;\n\t\t\t\treturn flow;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tvector<bool> visited;\n\tvector<vector<Edge>> nextEdges, backUpNextEdges;\npublic:\n\tGraph() {}\n\tGraph(int n) {\n\t\tnextEdges.resize(n);\n\t\tvisited.resize(n);\n\t}\n\n\tvoid addEdge(int node, int to, int cap) {\n\t\tnextEdges[node].push_back(Edge(to, cap, nextEdges[to].size()));\n\t\tnextEdges[to].push_back(Edge(node, 0, nextEdges[node].size() - 1));\n\t}\n\n\tint calcMaxFlow(int s, int t) {\n\t\tbackUpNextEdges = nextEdges;\n\n\t\tint ret = 0;\n\t\twhile (true) {\n\t\t\trep(i, nextEdges.size()) visited[i] = false;\n\t\t\tint flow = calcFlow(s, t, INT_MAX);\n\t\t\tif (flow == 0) break;\n\t\t\tret += flow;\n\t\t}\n\n\t\tnextEdges = backUpNextEdges;\n\n\t\treturn ret;\n\t}\n};\n\nsigned main() {\n\tint m, n;\n\tcin >> m >> n;\n\n\tbool isPrime[501];\n\trep(i, 500) isPrime[i] = true;\n\n\tvector<int> primes;\n\tfor (int i = 2; i < 500; i++) {\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j < 500; j += i) {\n\t\t\tisPrime[j] = false;\n\t\t}\n\t}\n\n\twhile (m > 0) {\n\t\tvector<int> b, r;\n\t\tinputVector(b, m);\n\t\tinputVector(r, n);\n\n\t\tGraph g = Graph(m + n + 2);\n\n\t\trep(i, m) {\n\t\t\tg.addEdge(0, i + 1, 1);\n\n\t\t\trep(j, n) {\n\t\t\t\trep(k, primes.size()) {\n\t\t\t\t\tif (b[i] % primes[k] == 0 && r[j] % primes[k] == 0) {\n\t\t\t\t\t\tg.addEdge(i + 1, m + j + 1, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, n) {\n\t\t\tg.addEdge(m + i + 1, m + n + 1, 1);\n\t\t}\n\n\t\tcout << g.calcMaxFlow(0, m + n + 1) << endl;;\n\n\t\tcin >> m >> n;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<complex>\n#include<numeric>\n#include<bitset>\n\nusing namespace std;\ntypedef vector<int> vint;\ntypedef vector<vint> vvint;\ntypedef pair<int,int> pint;\n\n//GCD\nint gcd(int a,int b){\n\treturn b!=0 ? gcd(b,a%b) : a;\n}\n\nint N=500;\nvvint g(N,(vint(N,0)));\nvint prev(N,-1),f(N);\nint nibu_match(int s){\n\tif(s==-1) return 1;\n\tfor(int i=0;i<N;i++){\n\t\tif(g[s][i]==0 || f[i]==1) continue;\n\t\tf[i]=1;\n\t\tif(nibu_match(prev[i])){\n\t\t\tprev[i]=s;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint main()\n{\n\tint m,n;\n\twhile(1){\n\t\tg = vvint(N,(vint(N,0)));\n\t\tprev = vint(N,-1);\n\t\tscanf(\"%d %d\",&m,&n);\n\t\tif(m==0 && n==0) break;\n\t\tvint b(m),r(n);\n\t\tfor(int i=0;i<m;i++) scanf(\"%d\",&b[i]);\n\t\tfor(int i=0;i<n;i++) scanf(\"%d\",&r[i]);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(gcd(b[i],r[j])>1) g[i][j]=1;\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<N;j++) f[j]=0;\n\t\t\tans+=nibu_match(i);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint m, n, t, res;\nint blue[510], red[510], match[510];\nbool used[510];\nvector<int> g[510];\n\nint gcd(int x, int y)\n{\n\tif(x < y) swap(x, y);\n\twhile(y)\n\t\tt = x % y, x = y, y = t;\n\treturn x;\n}\n\nbool dfs(int v)\n{\n\tfor(int i = 0; i < g[v].size(); ++i)\n\t{\n\t\tt = g[v][i];\n\t\tif(used[t]) continue;\n\t\tused[t] = true;\n\t\tif(match[t] == -1 || dfs(match[t]))\n\t\t{\n\t\t\tmatch[t] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile(cin >> m >> n && m)\n\t{\n\t\tfor(int i = 0; i < m; ++i)\n\t\t\tcin >> blue[i], g[i].clear();\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tcin >> red[i];\n\t\tfor(int i = 0; i < m; ++i)\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\tif(gcd(blue[i], red[j]) > 1)\n\t\t\t\t\tg[i].push_back(j);\n\t\tres = 0;\n\t\tfill_n(match, n, -1);\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tfill_n(used, n, false);\n\t\t\tif(dfs(i)) ++res;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<queue>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\nconst int INF = 1000000000;\n\ntypedef pair<int,int> pii;\n\nclass Edge{\n\tpublic:\n\tint a,b,c,f;\n\tEdge(int a,int b,int c,int f):a(a),b(b),c(c),f(f){}\n};\n\nclass Flow{\n\tpublic:\n\tstatic const int N = 555;\n\tstatic const int INF = 1000000000;\n\t\n\tvector<Edge> e[N];\n\tvector<pii> r[N];\n\t\n\tvoid addEdge(int a,int b,int c){\n\t\te[a].push_back(Edge(a,b,c,0));\n\t\tr[b].push_back(pii(a,e[a].size()-1));\n\t}\n\tint visit[N];\n\tint flow(int p, int f, int end){\n\t\tif(p==end)return f;\n\t\tif(visit[p]==1)return 0;\n\t\tvisit[p]=1;\n\t\t\n\t\trep(i,e[p].size()){\n\t\t\tint d = e[p][i].c - e[p][i].f;\n\t\t\tif(d > 0){\n\t\t\t\tint val = flow(e[p][i].b, min(f,d), end);\n\t\t\t\tif(val!=0){\n\t\t\t\t\te[p][i].f += val;\n\t\t\t\t\treturn val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,r[p].size()){\n\t\t\tint r1 = r[p][i].first;\n\t\t\tint r2 = r[p][i].second;\n\t\t\tint d = e[r1][r2].f;\n\t\t\tif(d > 0){\n\t\t\t\tint val = flow(e[r1][r2].a, min(f,d), end);\n\t\t\t\tif(val!=0){\n\t\t\t\t\te[r1][r2].f -= val;\n\t\t\t\t\treturn val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint solve(int start, int end){\n\t\tint ans = 0;\n\t\twhile(1){\n\t\t\trep(i,N)visit[i]=0;\n\t\t\tint val = flow(start, INF, end);\n\t\t\tif(val==0)break;\n\t\t\tans += val;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nconst int S = 1111111;\nint sosu[S];\nvector<int> prime;\nint sosuInit(){\n\tsosu[0]=sosu[1]=1;\n\trep(i,S){\n\t\tif(sosu[i]==1)continue;\n\t\tfor(int j=i*2;j<S;j+=i)sosu[j]=1;\n\t\tprime.push_back(i);\n\t}\n}\n\nvector<int> canop[S];\n\nint main(){\n\tsosuInit();\n\t\n\tA:;\n\t\n\trep(i,S)canop[i].clear();\n\t\n\tint n,m;\n\tcin>>n>>m;\n\t\n\tif(n==0 && m==0)return 0;\n\t\n\tFlow flow;\n\t\n\trep(i,n){\n\t\tint a;\n\t\tcin>>a;\n\t\trep(j,prime.size()){\n\t\t\tif(a%prime[j]==0){\n\t\t\t\tcanop[prime[j]].push_back(i+1);\n\t\t\t}\n\t\t}\n\t\tflow.addEdge(0,i+1,1);\n\t}\n\t\n\trep(i,m){\n\t\tint b;\n\t\tcin>>b;\n\t\trep(j,prime.size()){\n\t\t\tif(b%prime[j]==0){\n\t\t\t\trep(k,canop[prime[j]].size()){\n\t\t\t\t\tflow.addEdge(canop[prime[j]][k], i+n+1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tflow.addEdge(i+n+1, n+m+1, 1);\n\t}\n\t\n\tint ans = flow.solve(0, n+m+1);\n\tprintf(\"%d\\n\",ans);\n\t\n\tgoto A;\n}\n/*\n\n4 3\n2 6 6 15\n2 3 5\n0 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n\nint bipartiteMaximumMatchings(const vector<vector<bool> >& graph)\n{\n    int answer = 0;\n    int n = graph.size();\n    int m = graph[0].size();\n    vector<int> selectN(n, -1);\n    vector<int> selectM(m, -1);\n\n    for(int i=0; i<n; ++i){\n        vector<bool> visitedN(n, false);\n        vector<bool> visitedM(m, false);\n        visitedN[i] = true;\n        vector<int> path(min(n,m)*2, -1);\n\n        path[0] = i;\n        int index = 1;\n        for(;;){\n            while(++path[index] < m && (!graph[path[index-1]][path[index]] || selectN[path[index-1]]==path[index] || visitedM[path[index]]));\n            if(path[index] < m){\n                if(selectM[path[index]] == -1){\n                    for(int j=0; j<index; j+=2){\n                        selectN[path[j]] = path[j+1];\n                        selectM[path[j+1]] = path[j];\n                    }\n                    ++ answer;\n                    break;\n                }\n                if(!visitedN[selectM[path[index]]]){\n                    path[index+1] = selectM[path[index]];\n                    visitedM[path[index]] = true;\n                    visitedN[path[index+1]] = true;\n                    index += 2;\n                }\n            }\n            else{\n                path[index] = -1;\n                index -= 2;\n                if(index < 0)\n                    break;\n            }\n        }\n    }\n\n    return answer;\n}\n\nvoid solve(const vector<int>& blue, const vector<int>& red)\n{\n\tvector<vector<bool> > graph(blue.size(), vector<bool>(red.size(), false));\n\tfor(unsigned i=0; i<blue.size(); ++i){\n\t\tvector<int> num;\n\t\tint a = blue[i];\n\t\tint b = 2;\n\t\twhile(a >= b*b){\n\t\t\tif(a % b == 0){\n\t\t\t\tnum.push_back(b);\n\t\t\t\twhile(a % b == 0)\n\t\t\t\t\ta /= b;\n\t\t\t}\n\t\t\t++ b;\n\t\t}\n\t\tif(a > 1)\n\t\t\tnum.push_back(a);\n\n\t\tfor(unsigned j=0; j<red.size(); ++j){\n\t\t\tfor(unsigned k=0; k<num.size(); ++k){\n\t\t\t\tif(red[j] % num[k] == 0){\n\t\t\t\t\tgraph[i][j] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << bipartiteMaximumMatchings(graph) << endl;\n}\n\nint main()\n{\n    for(;;){\n        int m, n;\n        cin >> m >> n;\n        if(m == 0 && n == 0)\n            break;\n\n\t\tvector<int> blue(m);\n\t\tvector<int> red(n);\n\t\tfor(int i=0; i<m; ++i)\n\t\t\tcin >> blue[i];\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tcin >> red[i];\n\n        solve(blue, red);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<vector>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define REP(i,a,n) for(int i = a ; i < n  ;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX 1010\ntypedef long long ll;\n\nint V;\nvector<int> G[MAX];\nint match[MAX];\nbool used[MAX];\n\nvoid add_edge(int u, int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i=0;i<G[v].size();i++){\n    int u = G[v][i], w = match[u];\n    if(w < 0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bm(){\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v] < 0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v)) res ++;\n    }\n  }\n  return res;\n}\n\nvoid solve(){\n}\nint main(){\n  int n,m;\n  while(cin>>n>>m && (n||m)){\n    rep(i,MAX)G[i].clear();\n    vector<int> r;\n    vector<int> b;\n    rep(i,n){\n      int t;\n      cin>>t;\n      r.push_back(t);\n    }\n\n    rep(i,m){\n      int t;\n      cin>>t;\n      b.push_back(t);\n    }\n\n    V = n+m;\n\n    rep(i,n){\n      rep(j,m){\n        if(__gcd(r[i] , b[j]) !=1){\n          add_edge(i,j+n);\n        }\n      }\n    }\n    /*\n    rep(i,V){\n      cout<<i<<\":\";\n      rep(j,G[i].size()){\n        cout<<G[i][j]<<\" \";\n      }\n      cout<<endl;\n    }\n    */\n\n    cout<<bm()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bipartite_Matching\n{\n  vector< vector< int > > graph;\n  vector< int > match, alive, used;\n  int timestamp;\n\n  Bipartite_Matching(int n)\n  {\n    timestamp = 0;\n    graph.resize(n);\n    alive.assign(n, 1);\n    used.assign(n, 0);\n    match.assign(n, -1);\n  }\n\n  void add_edge(int u, int v)\n  {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int v)\n  {\n    used[v] = timestamp;\n    for(int i = 0; i < graph[v].size(); i++) {\n      int u = graph[v][i], w = match[u];\n      if(alive[u] == 0) continue;\n      if(w == -1 || (used[w] != timestamp && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching()\n  {\n    int ret = 0;\n    for(int i = 0; i < graph.size(); i++) {\n      if(alive[i] == 0) continue;\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return (ret);\n  }\n};\n\nint main()\n{\n  int M, N, B[500], R[500];\n  while(scanf(\"%d %d\", &M, &N), M) {\n    Bipartite_Matching flow(M + N);\n    for(int i = 0; i < M; i++) scanf(\"%d\", &B[i]);\n    for(int i = 0; i < N; i++) scanf(\"%d\", &R[i]);\n    for(int i = 0; i < M; i++) {\n      for(int j = 0; j < N; j++) {\n        if(__gcd(B[i], R[j]) > 1) flow.add_edge(i, j + M);\n      }\n    }\n    printf(\"%d\\n\", flow.bipartite_matching());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n\nusing namespace std;\n\ntypedef struct{\n\tint t;\n\tint c;\n\tint r;\n} edge;\n\nvector<edge> g[502];\n\nvoid add_edge(int from,int to,int cap){\n\tedge e1 = {to,cap,g[to].size()};\n\tg[from].push_back(e1);\n\tedge e2 = {from,0,g[from].size() - 1};\n\tg[to].push_back(e2);\n}\n\n\nint gcd(int x,int y){\n\tif(!y) return x;\n\treturn gcd(y,x % y);\n}\n\nint uv[502];\n\nint dfs(int v,int t,int f){\n\tint i;\n\tif(v == t) return f;\n\tuv[v] = 0;\n\tfor(i = 0;i < g[v].size();i++){\n\t\tif(uv[g[v][i].t] && g[v][i].c > 0){\n\t\t\tint d = dfs(g[v][i].t,t,min(f,g[v][i].c));\n\t\t\tif(d > 0){\n\t\t\t\tg[v][i].c -= d;\n\t\t\t\tg[g[v][i].t][g[v][i].r].c += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint maxflow(int s,int t){\n\tint f, res = 0;\n\twhile(1){\n\t\tmemset(uv,-1,sizeof(uv));\n\t\tf = 0;\n\t\tf += dfs(s,t,2);\n\t\tif(f == 0) return res;\n\t\tres += f;\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint m, n, b[500], r[500], i, j;\n\twhile(1){\n\t\tscanf(\"%d%d\",&m,&n);\n\t\tif(m + n == 0) break;\n\t\tfor(i = 0;i < m;i++)\n\t\t\tscanf(\"%d\",&b[i]);\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d\",&r[i]);\n\t\tfor(i = 0;i < m;i++)\n\t\t\tadd_edge(0,i + 1,1);\n\t\tfor(i = 0;i < m;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tif(gcd(b[i],r[j]) != 1){\n\t\t\t\t\tadd_edge(i + 1,m + j + 1,1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < n;i++)\n\t\t\tadd_edge(m + i + 1,m + n + 1,1);\n\t\tprintf(\"%d\\n\",maxflow(0,m + n + 1));\n\t\tfor(i = 0;i < m + n + 2;i++)\n\t\t\twhile(g[i].size()) g[i].pop_back();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define vec vector\n#define pb push_back\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n//typedef long long Int;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst) : src(src),dst(dst) {}\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) {}\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vec<Edge> Edges;\ntypedef vec<Edges> Graph;\n\n#define MAXMN 500\nint B[MAXMN];\nint R[MAXMN];\n\nint gcd(int a, int b)\n{   \n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nbool augment(const Graph& g, int u,\n\t     vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u]) );\n  return match;\n}\n\n\nmain() {\n  int M,N;\n  Graph g;\n  while(cin>>M>>N,M) {\n    g.clear();\n    g.resize(M+N+100);\n    REP(i,M) cin>>B[i];\n    REP(i,N) cin>>R[i];\n    REP(i,M) {\n      Edges es, es2;\n      REP(j,N) {\n\tif(gcd(B[i],R[j])!=1) { es.pb(Edge(i,M+j)); es2.pb(Edge(M+j,i)); }\n      }\n      g[i] = es;\n      g[M+i] = es2;\n    }\n    Edges matching;\n    cout << bipartiteMatching(g,M,matching) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include \"push_relabel.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\n#define each(i,a) for (auto&& i : a)\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\n\nconst ll linf = 1e18;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n  each(x,vec) is >> x;\n  return is;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n  rep(i,vec.size()) {\n    if (i) os << \" \";\n    os << vec[i];\n  }\n  return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector< vector<T> >& vec) {\n  rep(i,vec.size()) {\n    if (i) os << endl;\n    os << vec[i];\n  }\n  return os;\n}\n\nclass PushRelabel {\n  struct Edge {\n    int to, cap, rev;\n  };\n  int fsum;\n  std::vector<std::vector<Edge>> G;\n  std::vector<int> h, f;\n  void relabel(int v);\n  bool push(int v, bool force=false);\n  Edge& rev(const Edge& e);\npublic:\n  PushRelabel(int node_count);\n  void add(int from, int to, int cap);\n  int flow(int s, int t);\n};\nPushRelabel::PushRelabel(int node_count) : fsum(0), G(node_count), h(node_count, 0), f(node_count, 0) {}\nvoid PushRelabel::add(int from, int to, int cap) {\n  G[from].pb({to, cap, int(G[to].size())});\n  G[to].pb({from, 0, int(G[from].size())-1});\n}\nint PushRelabel::flow(int s, int t) {\n  const int n = G.size();\n  h[s] = n+2, h[t] = 0;\n  f[s] = int(1e9);\n  push(s, true);\n  while (true) {\n    // cout << h << endl;\n    // cout << f << endl;\n    // cout << endl;\n    bool is_updated = false;\n    rep(i, n) {\n      if (i == s || i == t) continue;\n      if (f[i] > 0) {\n        if (!push(i)) {\n          relabel(i);\n          push(i);\n        }\n        is_updated = true;\n      }\n    }\n    if (!is_updated) break;\n  }\n  return f[t];\n}\nbool PushRelabel::push(int v, bool force) {\n  bool res = false;\n  each(e, G[v]) {\n    if ((h[v] == h[e.to] + 1 && e.cap > 0) || force) {\n      ll use = min(e.cap, f[v]);\n      e.cap -= use;\n      rev(e).cap += use;\n      f[e.to] += use;\n      f[v] -= use;\n      res = true;\n    }\n  }\n  return res;\n}\nvoid PushRelabel::relabel(int v) {\n  int nh = int(1e9);\n  each(e, G[v]) {\n    if (e.cap > 0) chmin(nh, h[e.to]+1);\n  }\n  assert(nh > h[v]);\n  h[v] = nh;\n}\nPushRelabel::Edge& PushRelabel::rev(const Edge& e) {\n  return G[e.to][e.rev];\n}\n\nll gcd(ll a, ll b) {\n  return b == 0 ? a : gcd(b, a % b);\n}\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  ll n, m;\n  while (cin >> n >> m, n || m) {\n    vector<ll> a(n), b(m); cin >> a >> b;\n    ll s = n + m, t = s + 1;\n    PushRelabel pr(t+1);\n    rep(i, n) rep(j, m) {\n      if (gcd(a[i], b[j]) > 1) {\n        pr.add(i, n+j, 1);\n      }\n    }\n    rep(i, n) pr.add(s, i, 1);\n    rep(i, m) pr.add(n+i, t, 1);\n    cout << pr.flow(s, t) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nusing namespace std;\nint MAX_V = 1000;\n\nclass twoMatching {\nprivate:\n  vector<int> G[MAX_V];\n  int match[MAX_V];\n  bool used[MAX_V];\n  int V;\npublic:\n  twoMatching(int v) {\n    V = v;\n  }\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  bool dfs(int v) {\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n      int u = G[v][i], w = match[u];\n      if (w < 0 || !used[w] && dfs(w)) {\n\tmatch[v] = u;\n\tmatch[u] = v;\n\treturn true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching() {\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for (int v = 0; v < V; v++) {\n      if (match[v] < 0) {\n\tmemset(used, 0, sizeof(used));\n\tif (dfs(v)) res++;\n      }\n    }\n    return res;\n  }\n}\n\nint prime[1000]; // max 4000\nint primeNumber = 0;\n\nint main() {\n  int m, n;\n  int b[500], r[500];\n  for (int i = 2; i < 4000; i++) {\n    bool check = true;\n    for (int j = 0; j < primeNumber; j++) {\n      if (i % prime[j] == 0) {\n        check = false;\n        break;\n      }\n    }\n    if (check) {\n      prime[primeNumber] = i;\n      primeNumber++;\n    }\n  }\n\n  while (1) {\n    scanf(\"%d%d\", &m, &n);\n    if (m == 0) break;\n    for (int i = 0; i < m; i++) scanf(\"%d\", &b[i]);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &r[i]);\n    twoMatching t(m + n);\n    for (int i = 0; i < primeNumber; i++) {\n      for (int j = 0; j < m; j++) {\n        if (b[j] % prime[i] != 0) continue;\n        for (int k = 0; k < n; k++) {\n          if (r[k] % prime[i] != 0) continue;\n          t.add_edge(j, k + m);\n        }\n      }\n    }\n    printf(\"%d\\n\", t.bipartite_matching());\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MIN(A, B) ((A) < (B))? (A) : (B)\n\nint NextInt() { int d; scanf(\"%d\", &d); return d; }\n\ntypedef struct {\n  int length;\n  int dest[501];\n} Edge;\n\nint b[501], r[501];\nEdge e[501];\nint t[501];\nint m, n;\n\nint augment(int u, int used[]) {\n  if (u < 0) {\n    return 1;\n  }\n  for (int i = 0; i < e[u].length; i++) {\n    int d = e[u].dest[i];\n    if (!used[d]) {\n      used[d] = 1;\n      if (augment(t[d], used)) {\n        t[d] = u;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\n\nint main() {\n  while (1) {\n    m = NextInt(); n = NextInt();\n    if (m + n == 0) {\n      break;\n    }\n    for (int i = 0; i < m; i++) {\n      e[i].length = 0;\n      b[i] = NextInt();\n    }\n    for (int i = 0; i < n; i++) {\n      r[i] = NextInt();\n      t[i] = -1;\n    }\n  \n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        int m = MIN(b[i], r[j]);\n        for (int k = 2; k <= m; k++) {\n          if (b[i] % k == 0 && r[j] % k == 0) {\n            e[i].dest[e[i].length++] = j;\n          } \n        }           \n      }\n    }\n    int ans = 0;\n    for (int i = 0; i < m; i++) {\n      int used[1001] = { 0 };\n      if (augment(i, used)) {\n        ans++;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n\nll gcd(ll p,ll q){for(ll t;q;)t=p%q,p=q,q=t;return p;}\n\n\n//sからtへの最大流 O(E flow)を横着してO(VV flow)\n//*\n#define VMAX 1010\nint vcnt;\nint foodoflag[VMAX];\nint resflow[VMAX][VMAX];\n\nint foododfs(int s,int t){\n\tif(s==t)return 1;\n\tfoodoflag[s]=1;\n\trep(i,0,vcnt)if(!foodoflag[i]&&resflow[s][i]>0){\n\t\tif(foododfs(i,t)){\n\t\t\tresflow[s][i]--;\n\t\t\tresflow[i][s]++;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint foodo(int s,int t){\n\tint ans=0;\n\trep(i,0,vcnt)foodoflag[i]=0;\n\twhile(foododfs(s,t)){\n\t\tans++;\n\t\trep(i,0,vcnt)foodoflag[i]=0;\n\t}\n\treturn ans;\n}\n#undef VMAX\n//*/\n\nint a[510],b[510];\nint main(){\n\tint n,m;\n\twhile(scanf(\"%d%d\",&n,&m),n){\n\t\trep(i,0,n)scanf(\"%d\",a+i);\n\t\trep(j,0,m)scanf(\"%d\",b+j);\n\t\tvcnt=n+m+2;\n\t\trep(i,0,vcnt)rep(j,0,vcnt)resflow[i][j]=0;\n\t\trep(i,0,n)resflow[0][i+1]=1;\n\t\trep(j,0,m)resflow[j+n+1][m+n+1]=1;\n\t\trep(i,0,n)rep(j,0,m)if(gcd(a[i],b[j])!=1)resflow[i+1][j+n+1]=1;\n\t\tprintf(\"%d\\n\",foodo(0,n+m+1));\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1163: Cards\n// 2017.9.15 bal4u@uu\n// 2018.3.12\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 1004\nshort hi[MAX], to[MAX][MAX];\nchar  seen[MAX];\nshort match[MAX];\n\nint bipartiteMatching(int m, int n)\n{\n\tint u, max;\n\tint bpm(int u);\n\n\tmemset(match, -1, (m+n) << 1);\n\tmax = 0;\n\tfor (u = 0; u < m; u++) {\n\t\tmemset(seen, 0, m+n);\n\t\tif (bpm(u)) max++;\n\t}\n\treturn max;\n}\n\nint bpm(int u)\n{\n\tint i, v;\n\n\tfor (i = 0; i < hi[u]; i++) {\n\t\tv = to[u][i];\n\t\tif (seen[v]) continue;\n\t\tseen[v] = 1;\n\t\tif (match[v] < 0 || bpm(match[v])) {\n\t\t\tmatch[u] = v, match[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\nint gcd(int a, int b)\n{\n\tint r;\nif (!((a | b) & 1)) return 2;\n\twhile (b != 0) r = a % b, a = b, b = r;\n\treturn a;\n}\n\nint b[501], r[502];\n\nint main()\n{\n\tint i, j, m, n;\n\n\twhile (m = in()) {\n\t\tn = in();\n\t\tfor (i = 0; i < m; i++) b[i] = in();\n\t\tfor (j = 0; j < n; j++) r[j] = in();\n\n\t\tmemset(hi, 0, (m+n) << 2);\n\t    for (i = 0; i < m; i++) for (j = 0; j < n; j++) {\n\t\t\tif (gcd(b[i], r[j]) > 1) to[i][hi[i]++] = m + j;\n\t\t}\t\t\t\n\n\t\tprintf(\"%d\\n\", bipartiteMatching(m, n));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#define SIZE 1000\n\nusing namespace std;\n\nint m, n, b[501], r[501];\nint match[SIZE];\nbool used[SIZE];\nvector<int> G[SIZE];\n\nbool dfs(int v){\n\tused[v]=1;\n\tfor(int i=0; i<G[v].size(); i++){\n\t\tint u=G[v][i], w=match[u];\n\t\tif(w<0||!used[w]&&dfs(w)){\n\t\t\tmatch[v]=u, match[u]=v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid solve(){\n\tint res=0;\n\tmemset(match, -1, sizeof(match));\n\tfor(int v=0; v<m+n; v++){\n\t\tif(match[v]<0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif(dfs(v)) res++;\n\t\t}\n\t}\n\tcout<<res<<endl;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n && !m) break;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> b[i];\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcin >> r[i];\n\t\t}\n\t\tfor(int i=0; i<SIZE; i++) G[i].clear();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tint a=b[i], c=r[j];\n\t\t\t\twhile(c){\n\t\t\t\t\ta%=c;\n\t\t\t\t\tswap(a, c);\n\t\t\t\t}\n\t\t\t\tif(a!=1)G[i].push_back(j+n), G[n+j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MIN(A, B) ((A) < (B))? (A) : (B)\n\nint NextInt() { int d; scanf(\"%d\", &d); return d; }\n\ntypedef struct {\n  int length;\n  int dest[501];\n} Edge;\n\nint b[501], r[501];\nEdge e[501];\nint t[501];\nint m, n;\n\nint augment(int u, int used[]) {\n  if (u < 0) {\n    return 1;\n  }\n  for (int i = 0; i < e[u].length; i++) {\n    int d = e[u].dest[i];\n    if (!used[d]) {\n      used[d] = 1;\n      if (augment(t[d], used)) {\n        t[d] = u;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint gcd(int a, int b) {\n  if (a < b) {\n    return gcd(b, a);\n  }\n  if (b == 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\n\nint main() {\n  int i, j;\n  int ans;\n  while (1) {\n    m = NextInt(); n = NextInt();\n    if (m + n == 0) {\n      break;\n    }\n    for (i = 0; i < m; i++) {\n      e[i].length = 0;\n      b[i] = NextInt();\n    }\n    for (i = 0; i < n; i++) {\n      r[i] = NextInt();\n      t[i] = -1;\n    }\n  \n    for (i = 0; i < m; i++) {\n      for (j = 0; j < n; j++) {\n        if (gcd(b[i], r[j]) != 1) {\n            e[i].dest[e[i].length++] = j;\n        }\n      }\n    }\n    ans = 0;\n    for (i = 0; i < m; i++) {\n      int used[1001] = { 0 };\n      if (augment(i, used)) {\n        ans++;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#define SIZE 1000\n\nusing namespace std;\n\nint m, n, b[501], r[501];\nint match[SIZE];\nbool used[SIZE];\nvector<int> G[SIZE];\n\nbool dfs(int v){\n\tused[v]=1;\n\tfor(int i=0; i<G[v].size(); i++){\n\t\tint u=G[v][i], w=match[u];\n\t\tif(w<0||!used[w]&&dfs(w)){\n\t\t\tmatch[v]=u, match[u]=v;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid solve(){\n\tint res=0;\n\tmemset(match, -1, sizeof(match));\n\tfor(int v=0; v<m+n; v++){\n\t\tif(match[v]<0){\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif(dfs(v)) res++;\n\t\t}\n\t}\n\tcout<<res<<endl;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(!n && !m) break;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> b[i];\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcin >> r[i];\n\t\t}\n\t\tfor(int i=0; i<SIZE; i++) G[i].clear;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tint a=b[i], c=r[j];\n\t\t\t\twhile(c){\n\t\t\t\t\ta%=c;\n\t\t\t\t\tswap(a, c);\n\t\t\t\t}\n\t\t\t\tif(a!=1)G[i].push_back(j+n), G[n+j].push_back(i);\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define NODE_MAX 1002\n#define INF 100000000\n\ntypedef struct edge_t_tag {\n\tint max;\n\tint next;\n\tstruct edge_t_tag* pair;\n} edge_t;\n\nint edge_num[NODE_MAX];\nedge_t edges[NODE_MAX][NODE_MAX];\nchar visited[NODE_MAX];\n\n\nint get_one_flow(int now,int goal,int limit) {\n\tint i;\n\tif(now==goal)return limit;\n\tif(visited[now])return 0;\n\tvisited[now]=1;\n\tfor(i=0;i<edge_num[now];i++) {\n\t\tint now_flow;\n\t\tif(edges[now][i].max<=0)continue;\n\t\tnow_flow=get_one_flow(edges[now][i].next,goal,\n\t\t\tedges[now][i].max<limit?edges[now][i].max:limit);\n\t\tif(now_flow>0) {\n\t\t\tedges[now][i].max-=now_flow;\n\t\t\tedges[now][i].pair->max+=now_flow;\n\t\t\treturn now_flow;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint get_max_flow(int s,int g) {\n\tint result=0;\n\twhile(1) {\n\t\tint now;\n\t\tmemset(visited,0,sizeof(visited));\n\t\tnow=get_one_flow(s,g,INF);\n\t\tif(now==0)break;\n\t\tresult+=now;\n\t}\n\treturn result;\n}\n\nvoid flow_init(void) {\n\tmemset(edge_num,0,sizeof(edge_num));\n}\n\nvoid flow_add_edge(int s,int t,int max) {\n\tedges[s][edge_num[s]].max=max;\n\tedges[s][edge_num[s]].next=t;\n\tedges[s][edge_num[s]].pair=&edges[t][edge_num[t]];\n\tedge_num[s]++;\n\tedges[t][edge_num[t]].max=0;\n\tedges[t][edge_num[t]].next=s;\n\tedges[t][edge_num[t]].pair=&edges[s][edge_num[s]];\n\tedge_num[t]++;\n}\n\nint gcd(int a,int b) {\n\treturn b==0?a:gcd(b,a%b);\n}\n\nint main(void) {\n\tint m,n;\n\tint b[500];\n\tint r[500];\n\twhile(scanf(\"%d%d\",&m,&n)==2 && (m|n)!=0) {\n\t\tint i,j;\n\t\tfor(i=0;i<m;i++)scanf(\"%d\",&b[i]);\n\t\tfor(i=0;i<n;i++)scanf(\"%d\",&r[i]);\n\t\t/*\n\t\t\t0 : s\n\t\t\t1 : t\n\t\t\t2, ... ,m+1 : b\n\t\t\tm+2, ... , m+n+1 : r\n\t\t*/\n\t\tflow_init();\n\t\tfor(i=0;i<m;i++)flow_add_edge(0,i+2,1);\n\t\tfor(i=0;i<n;i++)flow_add_edge(m+2+i,1,1);\n\t\tfor(i=0;i<m;i++) {\n\t\t\tfor(j=0;j<n;j++) {\n\t\t\t\tif(gcd(b[i],r[j])>1)flow_add_edge(i+2,m+2+j,1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",get_max_flow(0,1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n//int ca[500],cb[500],a[500],b[500],n,m;\nint g(int t,int r){\n  int i=t;\n  if(t<r){\n    t=r;\n    r=i;\n  }\n  if(r==0)return t;\n  return g(r,t%r);\n}   \nint main(){\n  int i,j,min,mi,mj,c;\n  int a[500],b[500],n,m;\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    int d[500][500]={0};\n    int ca[500]={0};\n    int cb[500]={0};\n    for(i=c=0;i<n;i++)scanf(\"%d\",&a[i]);\n    for(j=0;j<m;j++)scanf(\"%d\",&b[j]);\n    for(i=0;i<n;i++){\n      for(j=0;j<m;j++){\n\tif(g(a[i],b[j])-1){//printf(\":%d %d\\n\",a[i],b[j]);\n\t  d[i][j]=1;\n\t  ca[i]++;\n\t  cb[j]++;\n\t}//printf(\"%d \",d[i][j]);\n      }//printf(\"\\n\");\n    }\n    //for(i=0;i<n;i++)printf(\"%d \",ca[i]);printf(\"\\n\");\n    //for(j=0;j<m;j++)printf(\"%d \",cb[j]);printf(\"\\n\");\n    while(1){\n      min=2100000000;\n      mj=-1;\n      for(i=0;i<n;i++){\n\tif(ca[i]==0)continue;\n\tif(min>ca[i]){\n\t  min=ca[i];\n\t  mi=i;\n\t}\n      }\n      for(j=0;j<m;j++){\n\tif(cb[j]==0)continue;\n\tif(min>cb[j]){\n\t  min=cb[j];\n\t  mj=j;\n\t}\n      }\n      if(mj==-1){\n\tfor(j=0;j<m;j++){\n\t  if(d[mi][j])break;\n\t}\n\tmj=j;\n      }\n      else{\n\tfor(i=0;i<n;i++){\n\t  if(d[i][mj])break;\n\t}\n\tmi=i;\n      }\n      //printf(\"%d %d\\n\",ca[mi],cb[mj]);\n      if(min==2100000000)break;\n      c++;\n      //d[mi][mj]=0;\n      for(i=0;i<n;i++){\n\tif(d[i][mj]){\n\t  d[i][mj]=0;\n\t  ca[i]--;\n\t  cb[mj]--;\n\t}\n      }\n      for(j=0;j<m;j++){\n\tif(mj==j)continue;\n\tif(d[mi][j]){\n\t  d[mi][j]=0;\n\t  ca[mi]--;\n\t  cb[j]--;\n\t}\n      }\n    }\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "int m,n,P[1000],b[500],r[500],i,j,t;\nchar C[1000][1000],V[1000];\nint h(x,y){return y?h(y,x%y):x;}\nint g(x,y){return x>y?h(x,y):h(y,x);}\nint match(s){int i=m;for(;i<m+n;i++)if(C[s][i]&&!V[i])if(V[i]=1,P[i]<0||match(P[i]))return P[s]=i,P[i]=s,1;return 0;}\nmain(){\n  for(;scanf(\"%d%d\",&m,&n),m;printf(\"%d\\n\",t)){\n    memset(&C,0,sizeof(C)),memset(&P,0xff,sizeof(P));\n    for(i=0;i<m;i++)scanf(\"%d\",b+i);\n    for(j=0;j<n;j++)scanf(\"%d\",r+j);\n    for(i=0;i<m;i++)for(j=0;j<n;j++)C[i][j+m]=C[j+m][i]=g(b[i],r[j])>=2;\n    for(t=i=0;i<m;i++)memset(&V,0,sizeof(V)),t+=match(i);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MIN(A, B) ((A) < (B))? (A) : (B)\n\nint NextInt() { int d; scanf(\"%d\", &d); return d; }\n\ntypedef struct {\n  int length;\n  int dest[501];\n} Edge;\n\nint b[501], r[501];\nEdge e[501];\nint t[501];\nint m, n;\n\nint augment(int u, int used[]) {\n  int i;\n  if (u < 0) {\n    return 1;\n  }\n  for (i = 0; i < e[u].length; i++) {\n    int d = e[u].dest[i];\n    if (!used[d]) {\n      used[d] = 1;\n      if (augment(t[d], used)) {\n        t[d] = u;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint gcd(int a, int b) {\n  if (a < b) {\n    return gcd(b, a);\n  }\n  if (b == 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\n\nint main() {\n  int i, j;\n  int ans;\n  while (1) {\n    m = NextInt(); n = NextInt();\n    if (m + n == 0) {\n      break;\n    }\n    for (i = 0; i < m; i++) {\n      e[i].length = 0;\n      b[i] = NextInt();\n    }\n    for (i = 0; i < n; i++) {\n      r[i] = NextInt();\n      t[i] = -1;\n    }\n  \n    for (i = 0; i < m; i++) {\n      for (j = 0; j < n; j++) {\n        if (gcd(b[i], r[j]) != 1) {\n            e[i].dest[e[i].length++] = j;\n        }\n      }\n    }\n    ans = 0;\n    for (i = 0; i < m; i++) {\n      int used[1001] = { 0 };\n      if (augment(i, used)) {\n        ans++;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "main(){float d,e,f,g,h,i,m,n,p;for(;~scanf(\"%f%f%f%f%f%f%f%f\",&d,&e,&f,&g,&h,&i,&m,&n);puts(p*(f-d)*(n-e)>p*(m-d)*(g-e)&&p*(d-h)*(n-i)>p*(m-h)*(e-i)?\"YES\":\"NO\"))p=(h-f)*(n-g)-(m-f)*(i-g);}"
  },
  {
    "language": "C",
    "code": "#pragma c99 on\n\n#include <stdio.h>\n\n#define MIN(A, B) ((A) < (B))? (A) : (B)\n\nint NextInt() { int d; scanf(\"%d\", &d); return d; }\n\ntypedef struct {\n  int length;\n  int dest[501];\n} Edge;\n\nint b[501], r[501];\nEdge e[501];\nint t[501];\nint m, n;\n\nint augment(int u, int used[]) {\n  if (u < 0) {\n    return 1;\n  }\n  for (int i = 0; i < e[u].length; i++) {\n    int d = e[u].dest[i];\n    if (!used[d]) {\n      used[d] = 1;\n      if (augment(t[d], used)) {\n        t[d] = u;\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nint gcd(int a, int b) {\n  if (a < b) {\n    return gcd(b, a);\n  }\n  if (b == 0) {\n    return a;\n  }\n  return gcd(b, a % b);\n}\n\nint main() {\n  int i, j;\n  int ans;\n  while (1) {\n    m = NextInt(); n = NextInt();\n    if (m + n == 0) {\n      break;\n    }\n    for (i = 0; i < m; i++) {\n      e[i].length = 0;\n      b[i] = NextInt();\n    }\n    for (i = 0; i < n; i++) {\n      r[i] = NextInt();\n      t[i] = -1;\n    }\n  \n    for (i = 0; i < m; i++) {\n      for (j = 0; j < n; j++) {\n        if (gcd(b[i], r[j]) != 1) {\n            e[i].dest[e[i].length++] = j;\n        }\n      }\n    }\n    ans = 0;\n    for (i = 0; i < m; i++) {\n      int used[1001] = { 0 };\n      if (augment(i, used)) {\n        ans++;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1163: Cards\n// 2017.9.15 bal4u@uu\n// 2018.3.12\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 1004\nint  hi[MAX], to[MAX][MAX];\nchar seen[MAX];\nint  match[MAX];\n\nint bipartiteMatching(int m, int n)\n{\n\tint u, max;\n\tint bpm(int u);\n\n\tmemset(match, -1, (m+n)*sizeof(int));\n\tmax = 0;\n\tfor (u = 0; u < m; u++) {\n\t\tmemset(seen, 0, m+n);\n\t\tif (bpm(u)) max++;\n\t}\n\treturn max;\n}\n\nint bpm(int u)\n{\n\tint i, v;\n\n\tfor (i = 0; i < hi[u]; i++) {\n\t\tv = to[u][i];\n\t\tif (seen[v]) continue;\n\t\tseen[v] = 1;\n\t\tif (match[v] < 0 || bpm(match[v])) {\n\t\t\tmatch[u] = v, match[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\nint gcd(int a, int b)\n{\n\tint r;\n\twhile (b != 0) r = a % b, a = b, b = r;\n\treturn a;\n}\n\nint b[501], r[502];\n\nint main()\n{\n\tint i, j, m, n;\n\n\twhile (m = in()) {\n\t\tn = in();\n\t\tfor (i = 0; i < m; i++) b[i] = in();\n\t\tfor (j = 0; j < n; j++) r[j] = in();\n\n\t\tmemset(hi, 0, (m+n) << 2);\n\t    for (i = 0; i < m; i++) for (j = 0; j < n; j++) {\n\t\t\tif (gcd(b[i], r[j]) > 1) to[i][hi[i]++] = m + j;\n\t\t}\t\t\t\n\n\t\tprintf(\"%d\\n\", bipartiteMatching(m, n));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1163: Cards\n// 2017.9.15 bal4u@uu\n// 2018.3.12\n \n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n \n#define MAX 1004\nshort hi[MAX], to[MAX][MAX];\nchar  seen[MAX];\nshort match[MAX];\n \nint bipartiteMatching(int m, int n)\n{\n    int u, max;\n    int bpm(int u);\n \n    memset(match, -1, (m+n) << 1);\n    max = 0;\n    for (u = 0; u < m; u++) {\n        memset(seen, 0, m+n);\n        if (bpm(u)) max++;\n    }\n    return max;\n}\n \nint bpm(int u)\n{\n    int i, v;\n \n    for (i = 0; i < hi[u]; i++) {\n        v = to[u][i];\n        if (seen[v]) continue;\n        seen[v] = 1;\n        if (match[v] < 0 || bpm(match[v])) {\n            match[u] = v, match[v] = u;\n            return 1;\n        }\n    }\n    return 0;\n}\n//#define getchar_unlocked()  getchar()\nint in()\n{\n    int n = 0, c = getchar_unlocked();\n    do n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n    return n;\n}\n \nint gcd(int a, int b)\n{\n    int r;\nif (!((a | b) & 1)) return 2;\n    while (b != 0) r = a % b, a = b, b = r;\n    return a;\n}\n \nint b[501], r[502];\n \nint cmp(int *a, int *b) { return (*a & 1) - (*b & 1); }\n\nint main()\n{\n    int i, j, m, n, bb, rr, sb, sr;\n \n    while (m = in()) {\n        n = in(); \n\t\tsb = sr = 0;\n        for (i = 0; i < m; i++) b[i] = bb = in(), sb += (bb & 1);\n        for (j = 0; j < n; j++) r[j] = rr = in(), sr += (rr & 1);\n\t\tsb = m - sb, sr = n - sr;\n\n\t\tqsort(b, m, sizeof(int), cmp);\n\t\tqsort(r, n, sizeof(int), cmp);\n\n        memset(hi, 0, (m+n) << 1);\n\t\tfor (i = 0; i < sb; i++) {\n\t\t\tfor (j = 0; j < sr; j++) to[i][hi[i]++] = m+j;\n\t\t\tfor (; j < n; j++) if (gcd(b[i], r[j]) > 1) to[i][hi[i]++] = m + j;\n\t\t}\n        for ( ; i < m; i++) for (j = 0; j < n; j++) {\n            if (gcd(b[i], r[j]) > 1) to[i][hi[i]++] = m + j;\n        }           \n \n        printf(\"%d\\n\", bipartiteMatching(m, n));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// Aizu 1163: Cards\n// 2017.9.15 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define M 502\n#define N 502\n\nint m, n;\nchar graph[M][N], seen[N];\nint matchL[M], matchR[N];\n\nint b[M], r[N];\n\nint gcd(int a, int b)\n{\n\tint r;\n\twhile (b != 0) r = a % b, a = b, b = r;\n\treturn a;\n}\n\nint bpm(int u)\n{\n\tint v;\n\n\tfor (v = 0; v < n; v++) if (graph[u][v]) {\n\t\tif (seen[v]) continue;\n\t\tseen[v] = 1;\n\t\tif (matchR[v] < 0 || bpm(matchR[v])) {\n\t\t\tmatchL[u] = v, matchR[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, cnt;\n\n\twhile (scanf(\"%d%d\", &m, &n) && m) {\n\t\tfor (i = 0; i < m; i++) scanf(\"%d\", b+i);\n\t\tfor (j = 0; j < n; j++) scanf(\"%d\", r+j);\n\t    for (i = 0; i < m; i++) for (j = 0; j < n; j++) graph[i][j] = (gcd(b[i], r[j]) > 1);\n\t\tmemset(matchL, -1, m*sizeof(matchL[0]));\n\t\tmemset(matchR, -1, n*sizeof(matchR[0]));\n\t\tfor (cnt = 0, i = 0; i < m; i++) { memset(seen, 0, n); if (bpm(i)) cnt++; }\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "int m,n,P[1000],b[500],r[500],i,j,t;\nchar C[1000][1000],V[1000];\nint h(x,y){return y?h(y,x%y):x;}\nint g(x,y){return x>y?h(x,y):h(y,x);}\nint match(s){int i=m;for(;i<m+n;i++)if(C[s][i]&&!V[i])if(V[i]=1,P[i]<0||match(P[i]))return P[s]=i,P[i]=s,1;return 0;}\nmain(){\n  for(;scanf(\"%d%d\",&m,&n),m;printf(\"%d\\n\",t)){\n    memset(&C,0,sizeof(C)),memset(&P,0xff,sizeof(P));\n    for(i=0;i<m;i++)scanf(\"%d\",b+i);\n    for(j=0;j<n;j++)scanf(\"%d\",r+j);\n    for(i=0;i<m;i++)for(j=0;j<n;j++)C[i][j+m]=C[j+m][i]=g(b[i],r[j])>=2;\n    for(t=i=0;i<m;i++)memset(&V,0,sizeof(V)),t+=match(i);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint gcd(int a,int b){\n\treturn b==0?a:gcd(b,a%b);\n}\nint n,m;\nint b[500],r[500];\nint flow[500][500];\nint sink[500];\n\nint visitb[500];\nint visitr[500];\nint blue(int i){\n\tint j;\n\tif(visitb[i]==1)return 0;\n\tvisitb[i]=1;\n\tfor(j=0;j<n;j++){\n\t\tif(flow[i][j]==0 && red(j)==1){\n\t\t\tflow[i][j] = 1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint red(int j){\n\tint i;\n\tif(visitr[j]==1)return 0;\n\tvisitr[j]=1;\n\tif(sink[j]==0){\n\t\tsink[j]=1;\n\t\treturn 1;\n\t}\n\tfor(i=0;i<n;i++){\n\t\tif(flow[i][j]==1 && blue(i)==1){\n\t\t\tflow[i][j] = 0;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint i,j;\n\tint res;\n\twhile(scanf(\"%d%d\",&m,&n)==2&&(m|n)){\n\t\tfor(i=0;i<m;i++)scanf(\"%d\",&b[i]);\n\t\tfor(i=0;i<n;i++)scanf(\"%d\",&r[i]);\n\t\tmemset(flow,0,sizeof(flow));\n\t\tmemset(sink,0,sizeof(sink));\n\t\tfor(i=0;i<m;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif(1==gcd(b[i],r[j])){\n\t\t\t\t\tflow[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres=0;\n\t\tfor(i=0;i<m;i++){\n\t\t\tmemset(visitb,0,sizeof(visitb));\n\t\t\tmemset(visitr,0,sizeof(visitr));\n\t\t\tres += blue(i);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n,m,f[1010];\nint ff(int a,int b){\n  if(a<b){\n    if(a)return ff(a,b%a);\n    return b;\n  }\n  if(b)return ff(b,a%b);\n  return a;\n}\nint g(int s,int t,char d[1010][1010]){\n  if(s==t)return 1;\n  int i;\n  for(i=0;i<n+m+2;i++){\n    if(f[i]||d[s][i]==0)continue;\n    f[i]=1;\n    if(g(i,t,d)){\n      d[s][i]=0;\n      d[i][s]=1;\n      return 1;\n    }\n  }\n  return 0;\n}\nint main(){\n  int i,j,a[510],b;\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    char d[1010][1010]={0};\n    for(i=0;i<n;i++){\n      scanf(\"%d\",&a[i]);\n      d[0][i+1]=1;\n    }\n    for(j=0;j<m;j++){\n      scanf(\"%d\",&b);\n      for(i=0;i<n;i++){\n\tif(ff(a[i],b)-1)d[i+1][n+j+1]=1;\n      }\n      d[n+j+1][n+m+1]=1;\n    }\n    for(i=0;i<n+m+2;i++)f[i]=0;\n    for(b=0;g(0,n+m+1,d);b++){\n      for(i=0;i<n+m+2;i++)f[i]=0;\n    }\n    printf(\"%d\\n\",b);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n,m,c=0;\nint fl[1010]={1};\nint f(int a,int b){\n  if(a<b){\n    if(a)return f(b%a,a);\n    return b;\n  }\n  if(b)return f(a%b,b);\n  return a;\n}\nint g(int s,int t,char d[1010][1010]){\n  int i,r;\n  if(s==t)return 1;//{printf(\"%d\\n\",++c);return 1;}\n  for(i=1;i<=n+m+1;i++){//printf(\"%d \",i);\n    if(d[s][i]==0||fl[i])continue;\n    fl[i]=1;//printf(\"%d \",i);\n    if(g(i,t,d)){\n      d[s][i]--;\n      d[i][s]++;\n      return 1;\n    }//printf(\"up\\n\");\n  }\n  return 0;\n}\nint main(){\n  int i,j,a[510],b,s;\n  while(scanf(\"%d %d\",&n,&m),n||m){\n    char d[1010][1010]={0};\n    for(i=1;i<=n;i++){\n      scanf(\"%d\",&a[i]);\n      d[0][i]=1;\n    }\n    for(s=0;i<=n+m;i++){\n      d[i][n+m+1]=1;\n      scanf(\"%d\",&b);\n      for(j=1;j<=n;j++){\n\tif(f(a[j],b)-1)d[j][i]=1;\n      }\n    }\n    /*for(i=s=0;i<=n+m+1;i++){\n      for(j=0;j<=n+m+1;j++){\n\tif(d[i][j]){\n\t  printf(\"%d %d 1\\n\",i,j);\n\t  s++;\n\t}\n      }//*/\n    //}\n    while(1){\n      for(i=1;i<=n+m+1;i++)fl[i]=0;\n      if(g(0,n+m+1,d)==0)break;\n      s++;\n    }\n    printf(\"%d\\n\",s);\n  }\n  return 0;\n}\n  \n\t"
  },
  {
    "language": "C",
    "code": "int m,n,em[500],en[500];\nchar gm[500][500],gn[500][500],vm[500],vn[500];\nchar C[1000][1000], visited[1000];\nint P[1000];\nint h(x,y){return y?h(y,x%y):x;}\nint g(x,y){return x>y?h(x,y):h(y,x);}\n\nint matchm(s){\n  int i=0;\n  for(;i<n;i++)\n    if(gm[s][i]&&!vn[i]){\n      vn[i]=1;\n      if(en[i]<0||matchn(en[i]))return em[s]=i,en[i]=s,1;\n    }\n  return 0;\n}\n\nint matchn(s){\n  int i=0;\n  for(;i<m;i++)\n    if(gn[s][i]&&!vm[i]){\n      vm[i]=1;\n      if(em[i]<0||matchm(em[i]))return en[s]=i,em[i]=s,1;\n    }\n  return 0;\n}\n\nint match(int src){\n  int i;\n  for (i=/*(src >= m) ? 0 :*/ m; i</*src >= m ? m :*/ m+n; i++)\n    if(C[src][i]&&!visited[i]){\n      visited[i] = 1;\n//if(P[i]>=0)printf(\"%d %d %d %d\\n\",P[i]>=m?2:1,src,i,P[i]);\n      if(P[i]<0||match(P[i]))return P[src] = i, P[i] = src, 1;\n    }\n  return 0;\n}\n\nmain(){\n  int b[500],r[500],i,j,t;\n  for(;scanf(\"%d%d\",&m,&n),m|n;printf(\"%d\\n\",t)){\n    memset(&gm,0,sizeof(gm));\n    memset(&gn,0,sizeof(gn));\n    memset(&C,0,sizeof(C));\n    memset(&em,0xff,sizeof(em));\n    memset(&en,0xff,sizeof(en));\n    memset(&P,0xff,sizeof(P));\n    for(t=i=0;i<m;i++)scanf(\"%d\",b+i);\n    for(i=0;i<n;i++)scanf(\"%d\",r+i);\n    for(i=0;i<m;i++)for(j=0;j<n;j++)C[i][j+m] = C[j+m][i]=gm[i][j]=gn[j][i]=g(b[i],r[j])>=2;\n    for(i=0;i<m;i++)memset(&vm,0,sizeof(vm)),memset(&vn,0,sizeof(vn)),memset(&visited,0,sizeof(visited)),t+=match(i);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1163: Cards\n// 2017.9.15 bal4u@uu\n// 2018.3.12\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 1004\nshort hi[MAX], to[MAX][MAX];\nchar  seen[MAX];\nshort match[MAX];\n\nint bipartiteMatching(int m, int n)\n{\n\tint u, max;\n\tint bpm(int u);\n\n\tmemset(match, -1, (m+n) << 1);\n\tmax = 0;\n\tfor (u = 0; u < m; u++) {\n\t\tif (match[u] < 0) {\n\t\t\tmemset(seen, 0, m+n);\n\t\t\tif (bpm(u)) max++;\n\t\t}\n\t}\n\treturn max;\n}\n\nint bpm(int u)\n{\n\tint i, v, w;\n\n\tseen[u] = 1;\n\tfor (i = 0; i < hi[u]; i++) {\n\t\tv = to[u][i], w = match[v];\n\t\tif (w < 0 || !seen[w] && bpm(w)) { match[u] = v, match[v] = u; return 1; }\n\t}\n\treturn 0;\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\nint gcd(int a, int b)\n{\n\tint r;\nif (!((a | b) & 1)) return 2;\n\twhile (b != 0) r = a % b, a = b, b = r;\n\treturn a;\n}\n\nint b[501], r[502];\n\nint main()\n{\n\tint i, j, m, n;\n\n\twhile (m = in()) {\n\t\tn = in();\n\t\tfor (i = 0; i < m; i++) b[i] = in();\n\t\tfor (j = 0; j < n; j++) r[j] = in();\n\n\t\tmemset(hi, 0, (m+n) << 2);\n\t    for (i = 0; i < m; i++) for (j = 0; j < n; j++) {\n\t\t\tif (gcd(b[i], r[j]) > 1) to[i][hi[i]++] = m + j;\n\t\t}\t\t\t\n\n\t\tprintf(\"%d\\n\", bipartiteMatching(m, n));\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic ArrayList<Integer>[] g;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif (m == 0 && n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] b = new int[m];\n\t\t\tint[] r = new int[n];\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tr[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tg = new ArrayList[n + m];\n\t\t\tfor (int i = 0; i < n + m; ++i) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\t\tif (gcd(b[i], r[j]) > 1) {\n\t\t\t\t\t\tg[i].add(m + j);\n\t\t\t\t\t\tg[m + j].add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvis = new boolean[n + m];\n\t\t\tmatchTo = new int[n + m];\n\t\t\tArrays.fill(matchTo, -1);\n\t\t\tint match = 0;\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tArrays.fill(vis, false);\n\t\t\t\tif (dfs(i)) {\n\t\t\t\t\t++match;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(match);\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic boolean[] vis;\n\tstatic int[] matchTo;\n\n\tstatic boolean dfs(int v) {\n\t\tif (v < 0)\n\t\t\treturn true;\n\t\tfor (int dst : g[v]) {\n\t\t\tif (vis[dst])\n\t\t\t\tcontinue;\n\t\t\tvis[dst] = true;\n\t\t\tif (dfs(matchTo[dst])) {\n\t\t\t\tmatchTo[v] = dst;\n\t\t\t\tmatchTo[dst] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic int gcd(int a, int b) {\n\t\tif (a > b) {\n\t\t\tint d = a;\n\t\t\ta = b;\n\t\t\tb = d;\n\t\t}\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\telse\n\t\t\treturn gcd(b % a, a);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main{\n\tstatic int[] blu = new int[500];\n\tstatic int[] red = new int[500];\n\tstatic int[][] g = new int[500][500];\n\tstatic int[] mb = new int[500];\n\tstatic int[] mr = new int[500];\n\tstatic int m,n;\n\t\n\tpublic static int chk(int i,int j){\n\t\tint a = Math.max(blu[i], red[j]);\n\t\tint b = Math.min(blu[i], red[j]);\n\t\twhile(b!=0){\n\t\t\tint tmp=b;\n\t\t\tb= a%b;\n\t\t\ta= tmp;\n\t\t}\n\t\tif(a!=1) return -1;\n\t\telse return 0;\n\t}\n\t\n\tpublic static boolean rb(int i,int j){\n\t\tfor(int ii=i;ii<m;ii++){\n\t\t\tif(g[ii][j]==-1){\n\t\t\t\tif(mb[ii]==-1){\n\t\t\t\t\tmb[ii]=j;\n\t\t\t\t\tmr[j]=ii;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int ii=i;ii<m-1;){\n\t\t\tif(g[ii][j]==-1){\n\t\t\t\tif(rb(ii+1,mb[ii])){\n\t\t\t\t\tmb[ii]=j;\n\t\t\t\t\tmr[j]=ii;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tii++;\n\t\t\t}else ii+=g[ii][j];\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String args[]) throws Exception{\n\t\tint ans;\n        Scanner cin= new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tans=0;\n\t\t\tm= cin.nextInt();\n\t\t\tn= cin.nextInt();\n\t\t\tif(m==0 && n==0) break;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tblu[i] = cin.nextInt();\n\t\t\t\tmb[i] = -1;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tred[i] = cin.nextInt();\n\t\t\t\tmr[i] = -1;\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tg[i][j] = chk(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint c=1;\n\t\t\t\tfor(int i=m-1;i>=0;i--){\n\t\t\t\t\tif(g[i][j]==-1) c=1;\n\t\t\t\t\telse{\n\t\t\t\t\t\tg[i][j]=c;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n/*\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\t\tif(g[i][j]==-1 && mb[i]==-1){\n\t\t\t\t\t\tmb[i]=j;\n\t\t\t\t\t\tmr[j]=i;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}*/\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mr[i]==-1 && rb(0,i)) ans++;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int[] blue, red;\n    boolean[] usedB;\n    boolean[] usedR;\n    int m, n, pair;\n    boolean[] prime;\n    int[][] canPair;\n\n    void run(){\n\tsetP();\n\twhile(true){\n\t    m = sc.nextInt();\n\t    n = sc.nextInt();\n\t    if(m==0 && n==0) break;\n\n\t    input();\n\t    for(int i=0; i<m; i++)\n\t\tfor(int k=0; k<n; k++){\n\t\t    pair = Math.max(solve(i, k), pair);\n\t\t    //System.out.println(\"------\");\n\t\t}\n\t    System.out.println(pair);\n\t}\n    }\n\n    void input(){\n\tblue = new int[m];\n\tred = new int[n];\n\tfor(int i=0; i<m; i++)\n\t    blue[i] = sc.nextInt();\n\tArrays.sort(blue);\n\tfor(int i=0; i<n; i++)\n\t    red[i] = sc.nextInt();\n\tArrays.sort(red);\n\tpair = 0;\n\tcanPair = new int[m][n];\n    }\n\n    int solve(int sB, int sR){\n\tint tmp = 0;\n\tusedB = new boolean[m];\n\tusedR = new boolean[n];\n\tint i = sB+1==m ? 0:sB+1;\n\tboolean visitB = false;\n\tfor(; !visitB; i++){\n\t    if(i==sB) visitB = true;\n\t    int a = blue[i];\n\n\t    int k = sR+1==n ? 0:sR+1;\n\t    boolean visitR = false;\n\t    for(; !visitR; k++){\n\t\tif(k==sR) visitR = true;\n\t\tint b = red[k];\n\t\tif(canPair[i][k]==-1 || usedR[k] || usedB[i] ||\n\t\t   Math.abs(a-b)==1 || isCont(a, b)){\n\t\t    if(k+1==n) k = -1;\n\t\t    continue;\n\t\t}\n\t\tif(canPair[i][k]==1 || div(i, k)){\n\t\t    tmp++;\n\t\t    usedR[k] = true;\n\t\t    usedB[i] = true;\n\t\t    //System.out.println(a+\" \"+b);\n\t\t    break;\n\t\t}\n\t\tif(k+1==n) k = -1;\n\t    }\n\t    if(i+1==m) i = -1;\n\t}\n\treturn tmp;\n    }\n\n    boolean isCont(int a, int b){\n\tif(a==b) return false;\n\tif(prime[a] && prime[b])\n\t    return a==b ? false : true;\n\tint d = Math.abs(a-b);\n\tif(prime[d] && a%d==0) return false;\n\tif(!prime[d]) return false;\n\treturn true;\n    }\n\n    boolean div(int i, int k){\n\tint b = blue[i];\n\tint r = red[k];\n\tint max = Math.max(b, r);\n\tint d = max;\n\twhile(d!=b*r){\n\t    if(d%b==0 && d%r==0) {\n\t\tcanPair[i][k] = 1;\n\t\tint x = i+1;\n\t\twhile(x<blue.length && blue[x]==blue[i]){\n\t\t    canPair[x][k] = 1;\n\t\t    x++;\n\t\t}\n\t\tx = i-1;\t\n\t\twhile(x>=0 && blue[x]==blue[i]){\n\t\t    canPair[x][k] = 1;\n\t\t    x--;\n\t\t}\n\t\tint y = k+1;\n\t\twhile(y<red.length && red[y]==red[k]){\n\t\t    canPair[i][y] = 1;\n\t\t    y++;\n\t\t}\n\t\ty = k-1;\n\t\twhile(y>=0 && red[y]==red[k]){\n\t\t    canPair[i][y] = 1;\n\t\t    y--;\n\t\t}\n\t\treturn true;\n\t    }\n\t    d += max;\n\t}\n\tcanPair[i][k] = -1;\n\treturn false;\n    }\n\n    void setP(){\n\tprime = new boolean[10000000];\n\tArrays.fill(prime, true);\n\tprime[0] = prime[1] = false;\n\tfor(int i=2; i<prime.length; i++)\n\t    if(prime[i])\n\t\tfor(int k=i*2; k<prime.length; k+=i)\n\t\t    prime[k] = false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class Main \n{\n\tstatic int INF = 999999999;\n\tstatic Left NIL = new Left(-1);\n\tstatic Left[] pairv;\n\t\n\tstatic boolean BFS()\n\t{\n\t\tLinkedList<Left> q = new LinkedList<>();\n\t\tfor(Left u : l)\n\t\t{\n\t\t\tif(u.pair == -1)\n\t\t\t{\n\t\t\t\tu.dist = 0;\n\t\t\t\tq.add(u);\n\t\t\t}\n\t\t\telse u.dist = INF;\n\t\t}\n\t\tNIL.dist = INF;\n\t\twhile(!q.isEmpty())\n\t\t{\n\t\t\tLeft u = q.poll();\n\t\t\tif(u.dist < NIL.dist)\n\t\t\t{\n\t\t\t\tfor(int v : u.adj)\n\t\t\t\t{\n\t\t\t\t\tif(pairv[v].dist == INF)\n\t\t\t\t\t{\n\t\t\t\t\t\tpairv[v].dist = u.dist+1;\n\t\t\t\t\t\tq.add(pairv[v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn NIL.dist != INF;\n\t}\n\t\n\tstatic boolean DFS(Left u)\n\t{\n\t\tif(u != NIL)\n\t\t{\n\t\t\tfor(int v : u.adj)\n\t\t\t\tif(pairv[v].dist == u.dist + 1)\n\t\t\t\t\tif(DFS(pairv[v]))\n\t\t\t\t\t{\n\t\t\t\t\t\tpairv[v] = u;\n\t\t\t\t\t\tu.pair = v;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\tu.dist = INF;\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic class Left\n\t{\n\t\tHashSet<Integer> adj = new HashSet<>();\n\t\tint id;\n\t\tint pair = -1;\n\t\tint dist = -1;\n\t\t\n\t\tpublic Left(int i)\n\t\t{\n\t\t\tid=i;\n\t\t}\n\t}\n\t\n\tstatic class En\n\t{\n\t\tint a;\n\t\tint b;\n\t\t\n\t\tpublic En(int a0, int b0)\n\t\t{\n\t\t\ta0 = a;\n\t\t\tb0 = b;\n\t\t}\n\t}\n\t\n\tstatic class C implements Comparator<En>\n\t{\n\n\t\t@Override\n\t\tpublic int compare(En o1, En o2) \n\t\t{\n\t\t\treturn o1.a-o2.a;\n\t\t}\n\t\t\n\t}\n\n\tstatic Left[] l;\n\t\n\tpublic static void main(String[] args) \n\t{\n\t\tint MAX = 10000000;\n\t\tint[] sieve = new int[MAX+1];\n\t\tsieve[0] = 1;\n\t\tsieve[1] = 1;\n\t\tfor(long i = 2; i <= MAX; i++)\n\t\tif(sieve[(int)i] == 0)\n\t\t{\n\t\t\tsieve[(int)i] = (int)i;\n\t\t\tfor(long j = i*i; j <= MAX; j+= i)\n\t\t\t{\n\t\t\t\tsieve[(int)j] = (int)i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n//\t\t\tSystem.out.print(i + \":\" + sieve[i]+ \". \");\n\t\t}\n\t\t\n\t\tlong timea = 0;\n\t\tlong timeb = 0;\n\t\tlong timec = 0;\n\t\tlong timed = 0;\n\t\tFastReader sc = new FastReader();\n\t\t\n\t\tint[] has = new int[MAX+1];\n\t\tint curhaser = 0;\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tlong curtime = System.currentTimeMillis();\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint[] a = new int[n];\n\t\t\tint[] b = new int[m];\n\t\t\tl = new Left[n];\n\t\t\t\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tl[i] = new Left(i);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\tfor(int i = 0; i < m; i++)\n\t\t\t\tb[i] = sc.nextInt();\n\n\n\t\t\ttimea += (System.currentTimeMillis() - curtime);\n\t\t\tcurtime = System.currentTimeMillis();\n\t\t\t\n\t\t\t\n\t\t\tC c = new C();\n\t\t\tPriorityQueue<En> pq = new PriorityQueue<En>(c);\n\t\t\t\n\t\t\tfor(int i = 0; i < MAX+1; i++)\n\t\t\t\thas[i] = -1;\n\t\t\t\n\t\t\ttimeb += (System.currentTimeMillis() - curtime);\n\t\t\tcurtime = System.currentTimeMillis();\n\t\t\t\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t{\n\t\t\t\tcurhaser++;\n\t\t\t\tint cur = b[j];\n\t\t\t\tint orcur = cur;\n\t\t\t\t\n\t\t\t\twhile(cur > 1)\n\t\t\t\t{\n\t\t\t\t\thas[sieve[cur]] = curhaser;\n//\t\t\t\t\tSystem.out.println(orcur + \" has  \" + sieve[cur]);\n\t\t\t\t\tcur /= sieve[cur];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\t{\n\t\t\t\t\tint curi = a[i];\n\t\t\t\t\twhile(curi > 1)\n\t\t\t\t\t{\n//\t\t\t\t\t\tSystem.out.println(i + \" \" + j + \" \" + curi);\n\t\t\t\t\t\tif(has[sieve[curi]] == curhaser)\n\t\t\t\t\t\t{ //found common divisor with this left-card\n\t\t\t\t\t\t\tpq.add(new En(i, j));\n\t\t\t\t\t\t\tl[i].adj.add(j);\n//\t\t\t\t\t\t\tSystem.out.println(\"Pairing \" + a[i] + \" \" + orcur + \" through \" + sieve[curi]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcuri /= sieve[curi];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"Stage 1\");\n\t\t\ttimec += (System.currentTimeMillis() - curtime);\n\t\t\tcurtime = System.currentTimeMillis();\n\t\t\t\n\t\t\tboolean[] pa = new boolean[n];\n\t\t\tboolean[] pb = new boolean[m];\n\t\t\tpairv = new Left[m];\n\t\t\tfor(int i = 0; i < m; i++)\n\t\t\t\tpairv[i] = NIL;\n\t\t\t\n\t\t\tint matching = 0;\n\t\t\tint it = 0;\n//\t\t\tSystem.out.println(\"Go\");\n\t\t\twhile(BFS())\n\t\t\t{\n\t\t\t\tit++;\n//\t\t\t\tSystem.out.println(\"it \" + it);\n\t\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\t{\n\t\t\t\t\tLeft u = l[i];\n\t\t\t\t\tif(u.pair == -1)\n\t\t\t\t\t\tif(DFS(u))\n\t\t\t\t\t\t\tmatching++;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tSystem.out.println(\"Stage 2\");\n\t\t\tsb.append(matching + \"\\n\");\n\t\t\ttimed += (System.currentTimeMillis() - curtime);\n\t\t\tcurtime = System.currentTimeMillis();\n\t\t}\n\t\tSystem.out.print(sb);\n//\t\tSystem.out.println(timea + \" \" + timeb + \" \" + timec + \" \" + timed);\n\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \t\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.util.stream.Collectors;\n\n@SuppressWarnings(\"unused\")\npublic class Main {\n\t\n\t//final boolean isDebug = true;\n\tfinal boolean isDebug = false;\n\tString fileName = \"input.txt\";\n\tFastScanner sc;\n\tPrintWriter out;\n\tfinal int MOD = (int)1e9+7;\n\tfinal int INF = Integer.MAX_VALUE / 2;\n\t\n\tvoid solve() throws Exception{\n\t\twhile(true){\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(m == 0 && n == 0) break;\n\t\t\tcalc(m, n);\n\t\t}\n\t}\n\t\n\tvoid calc(int m, int n){\n\t\tint s = 0, t = m+n+1;\n\t\tint[] b = new int[m+1];\n\t\tint[] r = new int[n+1];\n\t\tDinic dinic = new Dinic(m+n+2);\n\t\t\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tb[i] = sc.nextInt();\n\t\t\tdinic.addEdge(s, i, 1);\n\t\t}\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tr[i] = sc.nextInt();\n\t\t\tdinic.addEdge(m+i, t, 1);\n\t\t\tfor(int j = 1; j <= m; j++) if(gcd(b[j], r[i]) != 1) dinic.addEdge(j, m+i, 1);\n\t\t}\n\t\t\n\t\tSystem.out.println(dinic.maxFlow(s, t));\n\t}\n\t\n\tlong gcd(long a, long b){\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\t/* end solve */\n\t\n\t/* main */\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().m();\n\t}\n\t\n\tvoid m() throws Exception {\n\t\tlong S = System.currentTimeMillis();\n\t\tsc = (isDebug) ? new FastScanner(new FileInputStream(fileName)) : new FastScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\tif(isDebug){\n\t\t\tSystem.out.println(\"---Debug---\");\n\t\t\tSystem.out.printf(\"%8d ms\", (G-S));\n\t\t}\n\t}\n\t/* end main */\n}\n/* end Main */\n\nclass Dinic{\n\tclass Edge{\n\t\tint to;\n\t\tlong cap;\n\t\tint rev;\n\t\tboolean isRev;\n\t\tpublic Edge(int t, long c, int r, boolean i){\n\t\t\tto = t; cap = c; rev = r; isRev = i;\n\t\t}\n\t}\n\t\n\tint V;\n\tArrayList<ArrayList<Edge>> graph;\n\tint[] minCost, iter;\n\t\n\tpublic Dinic(int V){\n\t\tthis.V = V;\n\t\tgraph = new ArrayList<>();\n\t\tfor(int i = 0; i < V; i++) graph.add(new ArrayList<>());\n\t\tminCost = new int[V];\n\t\titer = new int[V];\n\t}\n\t\n\tvoid addEdge(int from, int to, long cap){\n\t\tgraph.get(from).add(new Edge(to, cap, graph.get(to).size(), false));\n\t\tgraph.get(to).add(new Edge(from, 0, graph.get(from).size()-1, true));\n\t}\n\t\n\tboolean bfs(int s, int t){\n\t\tArrays.fill(minCost, -1);\n\t\tDeque<Integer> queue = new ArrayDeque<Integer>();\n\t\tminCost[s] = 0;\n\t\tqueue.addLast(s);\n\t\twhile(!queue.isEmpty() && minCost[t] == -1){\n\t\t\tint p = queue.getFirst();\n\t\t\tqueue.pop();\n\t\t\tfor(Edge e : graph.get(p)){\n\t\t\t\tif(e.cap > 0 && minCost[e.to] == -1){\n\t\t\t\t\tminCost[e.to] = minCost[p] + 1;\n\t\t\t\t\tqueue.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn minCost[t] != -1;\n\t}\n\t\n\tlong dfs(int index, int t, long flow){\n\t\tif(index == t) return flow;\n\t\tfor(int i = iter[index]; i < graph.get(index).size(); i++){\n\t\t\tEdge e = graph.get(index).get(i);\n\t\t\tif(e.cap > 0 && minCost[index] < minCost[e.to]){\n\t\t\t\tlong d = dfs(e.to, t, Math.min(flow, e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tgraph.get(e.to).get(e.rev).cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tlong maxFlow(int s, int t){\n\t\tlong flow = 0;\n\t\twhile(bfs(s, t)){\n\t\t\tArrays.fill(iter, 0);\n\t\t\tlong f = 0;\n\t\t\twhile((f = dfs(s, t, Long.MAX_VALUE / 2)) > 0) flow += f;\n\t\t}\n\t\treturn flow;\n\t}\n\t\n\tvoid output(){\n\t\tfor(int i = 0; i < graph.size(); i++){\n\t\t\tfor(Edge e : graph.get(i)){\n\t\t\t\tif(e.isRev) continue;\n\t\t\t\tEdge revEdge = graph.get(e.to).get(e.rev);\n\t\t\t\tSystem.out.println(i + \" -> \" + e.to + \" (flow: \" + revEdge.cap + \" / \" + (e.cap + revEdge.cap) + \")\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass FastScanner {\n    private InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public FastScanner(InputStream in) {\n\t\tthis.in = in;\n\t}\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() {\n    \tif (hasNextByte()) return buffer[ptr++];\n    \telse return -1;\n    }\n    private static boolean isPrintableChar(int c){\n    \treturn 33 <= c && c <= 126;\n    }\n    public boolean hasNext() {\n    \twhile(hasNextByte() && !isPrintableChar(buffer[ptr]))\n    \t\tptr++; return hasNextByte();\n    }\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public String nextLine() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(b != 10) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tstatic int gcd(int x, int y) {\n\t\tif(x < y) {\n\t\t\tint tmp = x;\n\t\t\tx = y;\n\t\t\ty = tmp;\n\t\t}\n\t\twhile(y > 0) {\n\t\t\tint r = x % y;\n\t\t\tx = y;\n\t\t\ty = r;\n\t\t}\n\t\treturn x;\n\t}\n\t\n\tstatic int bipartiteMatching(boolean[][] can) {\n\t\t// 0..m-1 blue\n\t\t// m..m+n-1 red\n\t\tint m = can.length; // number of blue\n\t\tint n = can[0].length; // number of red\n\t\tint s = n + m, t = s+1;\n\t\tinitGraph(m+n+2);\n\t\t// s to blue\n\t\tfor(int i=0; i<m; i++) {\n\t\t\taddEdge(s, i, 1);\n\t\t}\n\t\t// red to t\n\t\tfor(int i=0; i<n; i++) {\n\t\t\taddEdge(m+i, t, 1);\n\t\t}\n\t\t// blue to red\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\tif(can[i][j]) {\n\t\t\t\t\taddEdge(i, m+j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxFlow(s, t);\n\t}\n\t\n\t// from MaxFlowFordFulkerson.java\n\tstatic int MAX_V = 2000;\n\tstatic int INF = 10000000;\n\tstatic ArrayList<ArrayList<Edge>> G = new ArrayList<ArrayList<Edge>>(MAX_V);\n\tstatic boolean[] used = new boolean[MAX_V];\n\t\n\tstatic void addEdge(int from, int to, int cap) {\n\t\tG.get(from).add(new Edge(to, cap, G.get(to).size()));\n\t\tG.get(to).add(new Edge(from, 0, G.get(from).size()-1));\n\t}\n\t\n\tstatic int dfs(int v, int t, int f) {\n\t\tif(v==t) return f;\n\t\tused[v] = true;\n\t\tfor(int i=0; i<G.get(v).size(); i++) {\n\t\t\tEdge e = G.get(v).get(i);\n\t\t\tif(!used[e.to] && e.cap > 0) {\n\t\t\t\tint d = dfs(e.to, t, Math.min(f, e.cap));\n\t\t\t\tif(d>0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG.get(e.to).get(e.rev).cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tstatic int maxFlow(int s, int t) {\n\t\tint flow = 0;\n\t\tfor(;;) {\n\t\t\tArrays.fill(used, false);\n\t\t\tint f = dfs(s, t, INF);\n\t\t\tif(f==0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n\t\n\tstatic void initGraph(int maxV) {\n\t\tfor(int i=0; i<maxV; i++) {\n\t\t\tG.add(new ArrayList<Edge>());\n\t\t}\n\t}\n\t\n\tstatic void resetGraph() {\n\t\tG = new ArrayList<ArrayList<Edge>>(MAX_V);\n\t\tused = new boolean[MAX_V];\n\t}\n\t\n\tstatic class Edge {\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) {\n\t\t\tthis.to = to; this.cap = cap; this.rev = rev;\n\t\t}\n\t}\n\t\n\tstatic public void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint m = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\tString ans = \"\";\n\t\tint cnt = 0;\n\t\twhile(!(n==0 && m==0)) {\n\t\t\tboolean[][] can = new boolean[m][n];\n\t\t\tint[] b = new int[m];\n\t\t\tint[] r = new int[n];\n\t\t\tfor(int i=0; i<m; i++) b[i] = sc.nextInt();\n\t\t\tfor(int i=0; i<n; i++) r[i] = sc.nextInt();\n\t\t\tfor(int i=0; i<m; i++) {\n\t\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\t\tif(gcd(b[i], r[j]) > 1) can[i][j] = true;\n\t\t\t\t\telse can[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += (bipartiteMatching(can)) + \"\\n\";\n\t\t\tresetGraph();\n\t\t\tm = sc.nextInt(); n = sc.nextInt(); cnt++;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\t//get the number of blue cards\n\t\t\tint bnum = sc.nextInt();\n\t\t\t//get the number of red cards\n\t\t\tint rnum = sc.nextInt();\n\t\t\tif(bnum == 0 && rnum == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//reading data\n\t\t\tint[] bmap = new int[bnum];\n\t\t\tint[] rmap = new int[rnum];\n\t\t\tfor(int i = 0; i < bmap.length; i++){\n\t\t\t\tbmap[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i = 0; i < rmap.length; i++){\n\t\t\t\trmap[i] = sc.nextInt();\n\t\t\t}\n\t\n\t\t\t//connection con[blue card] = red card\n\t\t\tint[] con = new int[bnum];\n\t\t\tArrays.fill(con, -1);\n\t\t\t\n\t\t\t//search\n\t\t\tint res = 0;\n\t\t\tfor(int i = 0; i < bmap.length; i++){\n\t\t\t\tif(isMatch(i, bmap, rmap, con, null)){\n\t\t\t\t\tres++;\n\t\t\t\t}\t\t\t\t\t\n\t\t\t}\n\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\t//spos = blue card No.\n\t//smap = blue cards data\n\t//emap = red cards data\n\t//stoe = connections\n\t//excepstoe = list of already searched blue-red connections\n\tstatic boolean isMatch(int spos, int[] smap, int[] emap, int[] stoe, boolean[][] excepstoe){\n\t\tboolean res = false;\n\t\tif(excepstoe == null){\n\t\t\texcepstoe = new boolean[smap.length][emap.length];\n\t\t}\n\n\t\t//loop in red cards\n\t\tfor(int i = 0; i < emap.length; i++){\n\t\t\t//if blue(No. = spos) and red(No. = i) can make pair and red(No. = i) is not fixed \n\t\t\tif(euclid(smap[spos], emap[i]) != 1 && !excepstoe[spos][i]){\n\t\t\t\t//if red card No.i has not been used\n\t\t\t\tif(!isExist(i, stoe)){\n\t\t\t\t\t//then connect and end function\n\t\t\t\t\tres = true;\n\t\t\t\t\tstoe[spos] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\t//if red card has been occupied\n\t\t\t\t\t//then reconnect it to blue(No. = spos)\n\t\t\t\t\t//and let blue card which used to make pair with red(No. = i) find new pair\n\t\t\t\t\t//rewrite the connections map\n\t\t\t\t\tint exstoe = stoe[spos];\n\t\t\t\t\tstoe[spos] = i;\n\n\t\t\t\t\t//mark the connection blue card (No. spos) to red card (No. i)\n\t\t\t\t\t//so as not to search repeatedly\n\t\t\t\t\texcepstoe[spos][i] = true;\n\t\t\t\t\t\n\t\t\t\t\t//find new pair\n\t\t\t\t\texcepstoe[spos][i] = true;\n\t\t\t\t\tif(isMatch(findpos(i, stoe), smap, emap, stoe, excepstoe)){\n\t\t\t\t\t\t//if new pair found\n\t\t\t\t\t\t//then save the connections and end function\n\t\t\t\t\t\tres = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//restore the stoe(connections map)\n\t\t\t\t\t\tstoe[spos] = exstoe;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t//whether the two cards can make pair\n\tstatic int euclid(int e1, int e2){\n\t\tint a = Math.min(e1, e2);\n\t\tint b = Math.max(e1, e2);\n\n\t\tint r = b % a;\n\t\tif(r != 0){\n\t\t\treturn euclid(a, r);\n\t\t}else{\n\t\t\treturn a;\n\t\t}\n\t}\n\n\tstatic boolean isExist(int v, int[] arr){\n\t\tboolean res = false;\n\t\tif (arr == null){\n\t\t\treturn false;\n\t\t}\n\n\t\tfor(int e : arr){\n\t\t\tif(v == e){\n\t\t\t\tres = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic int findpos(int v, int[] arr){\n\t\tint res = -1;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tif (v == arr[i]){\n\t\t\t\tres = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n@SuppressWarnings(\"unchecked\")\npublic class Main {\n\n    static int M;\n    static int N;\n    static int[] B;\n    static int[] R;\n\n    public static void main(String[] args) {\n        FastScanner fc = new FastScanner(System.in);\n\n        while(true) {\n            M = fc.nextInt();\n            N = fc.nextInt();\n\n            if( M == 0 && N == 0 ) break;\n\n            B = fc.nextIntArray(M);\n            R = fc.nextIntArray(N);\n            System.out.println( solve() );\n        }\n    }\n\n    static int[] P = getPrimes(10000000);\n\n    static int solve() {\n        List<Edge> es = new ArrayList<>();\n        for (int b = 0; b < M; b++) {\n            int[] factors = enumFactors(B[b]);\n\n            for (int p : factors) {\n                if( p == 0 ) continue;\n\n                for (int r = 0; r < N; r++) {\n                    if( R[r] % p == 0 ) {\n                        es.add( new Edge(b, r+M) );\n                    }\n                }\n            }\n        }\n        return matching(M+N, es);\n    }\n\n    static int[] getPrimes(int n) {\n        int root = (int)Math.sqrt(n);\n\n        boolean[] isPrime = new boolean[n+1];\n        Arrays.fill(isPrime, true);\n        for (int i = 2; i <= root; i++) {\n            if( isPrime[i] ) {\n                for (int d = 2; d*i <= n; d++) {\n                    isPrime[i*d] = false;\n                }\n            }\n        }\n\n        int cnt = 0;\n        for (int i = 2; i <= n; i++) {\n            if( isPrime[i] ) cnt++;\n        }\n\n        int[] primes = new int[cnt];\n        int j = 0;\n        for (int i = 2; i <= n; i++) {\n            if( isPrime[i] ) {\n                primes[j++] = i;\n            }\n        }\n        return primes;\n    }\n\n    static int[] enumFactors(int n) {\n        int[] fs = new int[8]; // 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 = 9699690;\n        int i = 0;\n        for (int p : P) {\n            if( n % p == 0 ) {\n                fs[i++] = p;\n                n /= p;\n                while( n % p == 0 ) {\n                    n /= p;\n                }\n            }\n        }\n        if( n != 1 ) {\n            fs[i] = n;\n        }\n        return fs;\n    }\n\n    static int matching(int V, List<Edge> E) {\n        List<Edge>[] rin = mkRin(V, E);\n\n        int res = 0;\n        int[] match = new int[V];\n        boolean[] used = new boolean[V];\n        Arrays.fill(match, -1);\n        for (int v = 0; v < V; v++) {\n            if( match[v] == -1 ) {\n                Arrays.fill(used, false);\n                if( _matching(v, rin, used, match) ) {\n                    res++;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    static List<Edge>[] mkRin(int V, List<Edge> E) {\n        //noinspection unchecked\n        List<Edge>[] rin = new List[V];\n        for (Edge e : E) {\n            if( rin[e.a] == null ) rin[e.a] = new ArrayList<>();\n            if( rin[e.b] == null ) rin[e.b] = new ArrayList<>();\n            rin[e.a].add(e);\n            rin[e.b].add(e);\n        }\n        return rin;\n    }\n\n    static boolean _matching(int v, List<Edge>[] rin, boolean[] used, int[] match) {\n        used[v] = true;\n        if( rin[v] == null ) return false;\n\n        for (Edge e : rin[v]) {\n            int u  = e.a == v ? e.b : e.a;\n            int w = match[u];\n            if( w == -1 || !used[w] && _matching(w, rin, used, match) ) {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    static class Edge {\n        int a;\n        int b;\n\n        public Edge(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        public String toString() {\n            return \"(\" + a + \",\" + b + \")\";\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        private String peeked;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        boolean hasNext() {\n            return peekLine();\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                tokenizer = new StringTokenizer(consumeLine());\n            }\n            return tokenizer.nextToken();\n        }\n\n        private boolean peekLine() {\n            try {\n                if( peeked != null ) return true;\n\n                peeked = reader.readLine();\n                return peeked != null;\n\n            } catch( IOException e ) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        private String consumeLine() {\n            if( peeked != null ) {\n                String t;\n                t = peeked;\n                peeked = null;\n                return t;\n\n            } else {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                return consumeLine();\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static int gcd(int x, int y){\n\t\tif(y == 0){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn gcd(y, x % y);\n\t\t}\n\t}\n\t\n\tpublic static boolean search_matching(int cur, int size, boolean[][] adj, boolean[] visited, LinkedList<Integer> stack){\n\t\tif(cur == size - 1){\n\t\t\tstack.add(cur);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfor(int to = 0; to < size; to++){\n\t\t\tif(!adj[cur][to]){\n\t\t\t\tcontinue;\n\t\t\t}else if(visited[to]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tvisited[to] = true;\n\t\t\t\n\t\t\tif(search_matching(to, size, adj, visited, stack)){\n\t\t\t\tstack.add(cur);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t//prev[to] = -1;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(m == 0 && n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[] blue = new int[m];\n\t\t\tint[] red = new int[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tblue[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tred[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] adj = new boolean[n + m + 2][m + n + 2];\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tadj[0][i + 1] = true;\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tadj[m + i + 1][n + m + 1] = true;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\t\n\t\t\t\t\tif(gcd(blue[i], red[j]) != 1){\n\t\t\t\t\t\tadj[i + 1][m + j + 1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint count = 0;\n\t\t\twhile(true){\n\t\t\t\tboolean[] visited = new boolean[n + m + 2];\n\t\t\t\tLinkedList<Integer> stack = new LinkedList<Integer>();\n\t\t\t\tif(!search_matching(0, n + m + 2, adj, visited, stack)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//System.out.println(stack);\n\t\t\t\t\n\t\t\t\tint prev = stack.poll();\n\t\t\t\twhile(!stack.isEmpty()){\n\t\t\t\t\tint cur = stack.poll();\n\t\t\t\t\t\n\t\t\t\t\tadj[prev][cur] = true;\n\t\t\t\t\tadj[cur][prev] = false;\n\t\t\t\t\tprev = cur;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tstatic int gcd(int x, int y) {\n\t\tif(x < y) {\n\t\t\tint tmp = x;\n\t\t\tx = y;\n\t\t\ty = tmp;\n\t\t}\n\t\twhile(y > 0) {\n\t\t\tint r = x % y;\n\t\t\tx = y;\n\t\t\ty = r;\n\t\t}\n\t\treturn x;\n\t}\n\t\n\tstatic int bipartiteMatching(boolean[][] can) {\n\t\t// 0..m-1 blue\n\t\t// m..m+n-1 red\n\t\tint m = can.length; // number of blue\n\t\tint n = can[0].length; // number of red\n\t\tint s = n + m, t = s+1;\n\t\tinitGraph(m+n+2);\n\t\t// s to blue\n\t\tfor(int i=0; i<m; i++) {\n\t\t\taddEdge(s, i, 1);\n\t\t}\n\t\t// red to t\n\t\tfor(int i=0; i<n; i++) {\n\t\t\taddEdge(m+i, t, 1);\n\t\t}\n\t\t// blue to red\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\tif(can[i][j]) {\n\t\t\t\t\taddEdge(i, m+j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxFlow(s, t);\n\t}\n\t\n\t// from MaxFlowFordFulkerson.java\n\tstatic int MAX_V = 2000;\n\tstatic int INF = 10000000;\n\tstatic ArrayList<ArrayList<Edge>> G = new ArrayList<ArrayList<Edge>>(MAX_V);\n\tstatic boolean[] used = new boolean[MAX_V];\n\t\n\tstatic void addEdge(int from, int to, int cap) {\n\t\tG.get(from).add(new Edge(to, cap, G.get(to).size()));\n\t\tG.get(to).add(new Edge(from, 0, G.get(from).size()-1));\n\t}\n\t\n\tstatic int dfs(int v, int t, int f) {\n\t\tif(v==t) return f;\n\t\tused[v] = true;\n\t\tfor(int i=0; i<G.get(v).size(); i++) {\n\t\t\tEdge e = G.get(v).get(i);\n\t\t\tif(!used[e.to] && e.cap > 0) {\n\t\t\t\tint d = dfs(e.to, t, Math.min(f, e.cap));\n\t\t\t\tif(d>0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG.get(e.to).get(e.rev).cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tstatic int maxFlow(int s, int t) {\n\t\tint flow = 0;\n\t\tfor(;;) {\n\t\t\tArrays.fill(used, false);\n\t\t\tint f = dfs(s, t, INF);\n\t\t\tif(f==0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n\t\n\tstatic void initGraph(int maxV) {\n\t\tfor(int i=0; i<maxV; i++) {\n\t\t\tG.add(new ArrayList<Edge>());\n\t\t}\n\t}\n\t\n\tstatic void resetGraph() {\n\t\tG = new ArrayList<ArrayList<Edge>>(MAX_V);\n\t\tused = new boolean[MAX_V];\n\t}\n\t\n\tstatic class Edge {\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) {\n\t\t\tthis.to = to; this.cap = cap; this.rev = rev;\n\t\t}\n\t}\n\t\n\tstatic public void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint m = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\tString ans = \"\";\n\t\tint cnt = 0;\n\t\twhile(!(n==0 && m==0)) {\n\t\t\tboolean[][] can = new boolean[m][n];\n\t\t\tint[] b = new int[m];\n\t\t\tint[] r = new int[n];\n\t\t\tfor(int i=0; i<m; i++) b[i] = sc.nextInt();\n\t\t\tfor(int i=0; i<n; i++) r[i] = sc.nextInt();\n\t\t\tfor(int i=0; i<m; i++) {\n\t\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\t\tif(gcd(b[i], r[j]) > 1) can[i][j] = true;\n\t\t\t\t\telse can[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += (bipartiteMatching(can)) + \"\\n\";\n\t\t\tresetGraph();\n\t\t\tm = sc.nextInt(); n = sc.nextInt(); cnt++;\n\t\t}\n\t\tSystem.out.print(ans);\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static int M;\n    static int N;\n    static int[] B;\n    static int[] R;\n\n    public static void main(String[] args) {\n        FastScanner fc = new FastScanner(System.in);\n\n        while(true) {\n            M = fc.nextInt();\n            N = fc.nextInt();\n\n            if( M == 0 && N == 0 ) break;\n\n            B = fc.nextIntArray(M);\n            R = fc.nextIntArray(N);\n            System.out.println( solve() );\n        }\n    }\n\n    static int[] P = getPrimes(10000000);\n\n    static int solve() {\n        List<Edge> es = new ArrayList<>();\n        for (int b = 0; b < M; b++) {\n            int[] factors = enumFactors(B[b]);\n\n            for (int p : factors) {\n                if( p == 0 ) continue;\n\n                for (int r = 0; r < N; r++) {\n                    if( R[r] % p == 0 ) {\n                        es.add( new Edge(b, r+M) );\n                    }\n                }\n            }\n        }\n        return matching(M+N, es);\n    }\n\n    static int[] getPrimes(int n) {\n        int root = (int)Math.sqrt(n);\n\n        boolean[] isPrime = new boolean[n+1];\n        Arrays.fill(isPrime, true);\n        for (int i = 2; i <= root; i++) {\n            if( isPrime[i] ) {\n                for (int d = 2; d*i <= n; d++) {\n                    isPrime[i*d] = false;\n                }\n            }\n        }\n\n        int cnt = 0;\n        for (int i = 2; i <= n; i++) {\n            if( isPrime[i] ) cnt++;\n        }\n\n        int[] primes = new int[cnt];\n        int j = 0;\n        for (int i = 2; i <= n; i++) {\n            if( isPrime[i] ) {\n                primes[j++] = i;\n            }\n        }\n        return primes;\n    }\n\n    static int[] enumFactors(int n) {\n        int[] fs = new int[8]; // 2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 = 9699690;\n        int i = 0;\n        for (int p : P) {\n            if( n % p == 0 ) {\n                fs[i++] = p;\n                n /= p;\n                while( n % p == 0 ) {\n                    n /= p;\n                }\n            }\n        }\n        if( n != 1 ) {\n            fs[i] = n;\n        }\n        return fs;\n    }\n\n    static int matching(int V, List<Edge> E) {\n        List<Edge>[] rin = mkRin(V, E);\n\n        int res = 0;\n        int[] match = new int[V];\n        boolean[] used = new boolean[V];\n        Arrays.fill(match, -1);\n        for (int v = 0; v < V; v++) {\n            if( match[v] == -1 ) {\n                Arrays.fill(used, false);\n                if( _matching(v, rin, used, match) ) {\n                    res++;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    static List<Edge>[] mkRin(int V, List<Edge> E) {\n        //noinspection unchecked\n        List<Edge>[] rin = new List[V];\n        for (Edge e : E) {\n            if( rin[e.a] == null ) rin[e.a] = new ArrayList<>();\n            if( rin[e.b] == null ) rin[e.b] = new ArrayList<>();\n            rin[e.a].add(e);\n            rin[e.b].add(e);\n        }\n        return rin;\n    }\n\n    static boolean _matching(int v, List<Edge>[] rin, boolean[] used, int[] match) {\n        used[v] = true;\n        if( rin[v] == null ) return false;\n\n        for (Edge e : rin[v]) {\n            int u  = e.a == v ? e.b : e.a;\n            int w = match[u];\n            if( w == -1 || !used[w] && _matching(w, rin, used, match) ) {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    static class Edge {\n        int a;\n        int b;\n\n        public Edge(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        public String toString() {\n            return \"(\" + a + \",\" + b + \")\";\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        private String peeked;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        boolean hasNext() {\n            return peekLine();\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                tokenizer = new StringTokenizer(consumeLine());\n            }\n            return tokenizer.nextToken();\n        }\n\n        private boolean peekLine() {\n            try {\n                if( peeked != null ) return true;\n\n                peeked = reader.readLine();\n                return peeked != null;\n\n            } catch( IOException e ) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        private String consumeLine() {\n            if( peeked != null ) {\n                String t;\n                t = peeked;\n                peeked = null;\n                return t;\n\n            } else {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                return consumeLine();\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Cards\n */\npublic class Main {\n\n\tstatic final int INF = 1 << 29;\n\n\tstatic int S, T;\n\tstatic List<List<Edge>> G;\n\tstatic boolean[] used;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tSystem.out.println(\"in: \" + line);\n\n\t\t\tint m, n;\n\t\t\tm = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tn = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((m | n) == 0) break;\n\n\t\t\tS = m + n;\n\t\t\tT = S + 1;\n\n\t\t\tint[] ms = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::valueOf).toArray();\n\t\t\tint[] ns = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::valueOf).toArray();\n\n\t\t\t//\n\t\t\tG = new ArrayList<>();\n\t\t\tused = new boolean[T + 1];\n\n\t\t\tfor (int i = 0; i <= T; i++) {\n\t\t\t\tG.add(new ArrayList<>());\n\t\t\t}\n\n\t\t\t//S -> blue\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tG.get(S).add(new Edge(i, 1, G.get(i).size()));\n\t\t\t\tG.get(i).add(new Edge(S, 0, G.get(S).size() - 1));\n\t\t\t}\n\n\t\t\t//red -> T\n\t\t\tfor (int i = m; i < m + n; i++) {\n\t\t\t\tG.get(i).add(new Edge(T, 1, G.get(T).size()));\n\t\t\t\tG.get(T).add(new Edge(i, 0, G.get(i).size() - 1));\n\t\t\t}\n\n\t\t\t//blue -> red\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (gcd(ms[i], ns[j]) > 1) {\n\t\t\t\t\t\tG.get(i).add(new Edge(m + j, 1, G.get(m + j).size()));\n\t\t\t\t\t\tG.get(m + j).add(new Edge(i, 0, G.get(i).size() - 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = 0;\n\n\t\t\twhile (true) {\n\t\t\t\tused = new boolean[T + 1];\n\t\t\t\tint f = rec(S, T, INF);\n\t\t\t\tif (f == 0) break;\n\t\t\t\tans += f;\n\t\t\t}\n\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic int rec(int u, int v, int f) {\n\n\t\tif (u == v) return f;\n\n\t\tused[u] = true;\n\n\t\tfor (Edge e : G.get(u)) {\n\t\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\t\tint d = rec(e.to, v, Math.min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG.get(e.to).get(e.rev).cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tstatic int gcd(int a, int b) {\n\t\tif (b == 0) return a;\n\t\treturn gcd(b, a % b);\n\t}\n}\n\nclass Edge {\n\tint to, cap, rev;\n\n\tpublic Edge(int to, int cap, int rev) {\n\t\tthis.to = to;\n\t\tthis.cap = cap;\n\t\tthis.rev = rev;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Cards\n */\npublic class Main {\n\n\tstatic final int INF = 1 << 29;\n\n\tstatic int S, T;\n\tstatic List<List<Edge>> G;\n\tstatic boolean[] used;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint m, n;\n\t\t\tm = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tn = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((m | n) == 0) break;\n\n\t\t\tS = m + n;\n\t\t\tT = S + 1;\n\n\t\t\tint[] ms = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::valueOf).toArray();\n\t\t\tint[] ns = Arrays.stream(br.readLine().split(\" \")).mapToInt(Integer::valueOf).toArray();\n\n\t\t\t//\n\t\t\tG = new ArrayList<>();\n\t\t\tused = new boolean[T + 1];\n\n\t\t\tfor (int i = 0; i <= T; i++) {\n\t\t\t\tG.add(new ArrayList<>());\n\t\t\t}\n\n\t\t\t//S -> blue\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tG.get(S).add(new Edge(i, 1, G.get(i).size()));\n\t\t\t\tG.get(i).add(new Edge(S, 0, G.get(S).size() - 1));\n\t\t\t}\n\n\t\t\t//red -> T\n\t\t\tfor (int i = m; i < m + n; i++) {\n\t\t\t\tG.get(i).add(new Edge(T, 1, G.get(T).size()));\n\t\t\t\tG.get(T).add(new Edge(i, 0, G.get(i).size() - 1));\n\t\t\t}\n\n\t\t\t//blue -> red\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (gcd(ms[i], ns[j]) > 1) {\n\t\t\t\t\t\tG.get(i).add(new Edge(m + j, 1, G.get(m + j).size()));\n\t\t\t\t\t\tG.get(m + j).add(new Edge(i, 0, G.get(i).size() - 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = 0;\n\n\t\t\twhile (true) {\n\t\t\t\tused = new boolean[T + 1];\n\t\t\t\tint f = rec(S, T, INF);\n\t\t\t\tif (f == 0) break;\n\t\t\t\tans += f;\n\t\t\t}\n\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic int rec(int u, int v, int f) {\n\n\t\tif (u == v) return f;\n\n\t\tused[u] = true;\n\n\t\tfor (Edge e : G.get(u)) {\n\t\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\t\tint d = rec(e.to, v, Math.min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG.get(e.to).get(e.rev).cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tstatic int gcd(int a, int b) {\n\t\tif (b == 0) return a;\n\t\treturn gcd(b, a % b);\n\t}\n}\n\nclass Edge {\n\tint to, cap, rev;\n\n\tpublic Edge(int to, int cap, int rev) {\n\t\tthis.to = to;\n\t\tthis.cap = cap;\n\t\tthis.rev = rev;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class AOJ1163 {\n\n  private static long gcd(long a, long b) {\n    return b == 0 ? a : gcd(b, a % b);\n  }\n\n  private void solve(FastScanner in, PrintWriter out) {\n    while (true) {\n      int m = in.nextInt();\n      int n = in.nextInt();\n      if (m == 0 && n == 0) {\n        break;\n      }\n      int[] b = in.nextIntArray(m);\n      int[] r = in.nextIntArray(n);\n\n      Dinitz dinitz = new Dinitz(n + m + 2);\n      int source = n + m;\n      int sink = source + 1;\n      for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n          if (gcd(b[i], r[j]) > 1) {\n            dinitz.addEdge(i, j + m, 1);\n          }\n        }\n      }\n\n      for (int i = 0; i < m; i++) {\n        dinitz.addEdge(source, i, 1);\n      }\n      for (int i = 0; i < n; i++) {\n        dinitz.addEdge(i + m, sink, 1);\n      }\n\n      out.println(dinitz.maxFlow(source, sink));\n    }\n  }\n\n  class Dinitz {\n\n    class Edge {\n\n      int to, rev;\n      long cap;\n\n      Edge(int to, long cap, int rev) {\n        this.to = to;\n        this.cap = cap;\n        this.rev = rev;\n      }\n    }\n\n    private ArrayDeque<Integer> deque = new ArrayDeque<>();\n    private ArrayList<ArrayList<Edge>> g;\n    private int[] level;\n    private int[] iter;\n\n    Dinitz(int V) {\n      g = new ArrayList<>(V);\n      for (int i = 0; i < V; i++) {\n        g.add(new ArrayList<>());\n      }\n      level = new int[V];\n      iter = new int[V];\n    }\n\n    void addEdge(int from, int to, long cap) {\n      g.get(from).add(new Edge(to, cap, g.get(to).size()));\n      g.get(to).add(new Edge(from, 0, g.get(from).size() - 1));\n    }\n\n    private long dfs(int v, int t, long f) {\n      if (v == t) {\n        return f;\n      }\n      for (; iter[v] < g.get(v).size(); iter[v]++) {\n        Edge e = g.get(v).get(iter[v]);\n        if (e.cap > 0 && level[v] < level[e.to]) {\n          long d = dfs(e.to, t, Math.min(f, e.cap));\n          if (d > 0) {\n            e.cap -= d;\n            g.get(e.to).get(e.rev).cap += d;\n            return d;\n          }\n        }\n      }\n      return 0;\n    }\n\n    private void bfs(int s) {\n      Arrays.fill(level, -1);\n      level[s] = 0;\n      deque.add(s);\n      while (!deque.isEmpty()) {\n        int v = deque.poll();\n        for (Edge e : g.get(v)) {\n          if (e.cap > 0 && level[e.to] < 0) {\n            level[e.to] = level[v] + 1;\n            deque.add(e.to);\n          }\n        }\n      }\n    }\n\n    long maxFlow(int s, int t) {\n      long flow = 0;\n      for (; ; ) {\n        bfs(s);\n        if (level[t] < 0) {\n          return flow;\n        }\n        Arrays.fill(iter, 0);\n        long f;\n        while ((f = dfs(s, t, Long.MAX_VALUE)) > 0) {\n          flow += f;\n        }\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    PrintWriter out = new PrintWriter(System.out);\n    new AOJ1163().solve(new FastScanner(), out);\n    out.close();\n  }\n\n  private static class FastScanner {\n\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) {\n        return buffer[ptr++];\n      } else {\n        return -1;\n      }\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n        ptr++;\n      }\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextInt();\n      }\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextLong();\n      }\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = next();\n      }\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) {\n        array[i] = next().toCharArray();\n      }\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint gcd(int a, int b) {\n\t\tif(a % b == 0){\n\t\t\treturn b;\n\t\t}\n\t\tif( b % a == 0){\n\t\t\treturn a;\n\t\t}\n\t\tif (a > b) {\n\t\t\treturn gcd(b, a % b);\n\t\t} else {\n\t\t\treturn gcd(a, b % a);\n\t\t}\n\t}\n\n\tclass E {\n\t\tint capacity;\n\t\tint flow;\n\n\t\tpublic E(int from, int to) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.capacity = 1;\n\t\t\tthis.flow = 0;\n\t\t}\n\n\t\tint from;\n\t\tint to;\n\t\tint weight;\n\t}\n\n\tclass Node {\n\t\tint id;\n\t\tint value;\n\n\t\tNode(int id, int value) {\n\t\t\tthis.id = id;\n\t\t\tthis.value = value;\n\t\t}\n\t}\n\n\tNode[] b;\n\tNode[] r;\n\n\tLinkedList<E> link;\n\tboolean used[];\n\n\tint dfs(int start, int goal) {\n\t\tif (goal == start) {\n\t\t\treturn 1;\n\t\t}\n//\t\tSystem.out.println(start + \" \" + goal);\n\t\tused[start] = true;\n\t\tfor (E l : link) {\n\t\t\tif (l.from == start) {\n\t\t\t\tif (!used[l.to]) {\n\t\t\t\t\tif (l.capacity - l.flow> 0) {\n\t\t\t\t\t\tint res = dfs(l.to, goal);\n\t\t\t\t\t\tif (res > 0) {\n\t\t\t\t\t\t\tl.flow += res;\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (l.to == start) {\n\t\t\t\tif (!used[l.from]) {\n\t\t\t\t\tif (l.flow > 0) {\n\t\t\t\t\t\tint res = dfs(l.from, goal);\n\t\t\t\t\t\tif (res > 0) {\n\t\t\t\t\t\t\tl.flow -= res;\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\n\t\t\tif ((m | n) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tb = new Node[m];\n\t\t\tr = new Node[n];\n\n\t\t\tint source = m + n;\n\t\t\tint sink = source + 1;\n\t\t\tlink = new LinkedList<E>();\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tb[i] = new Node(i, sc.nextInt());\n\n\t\t\t\tlink.add(new E(source, b[i].id));\n\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tr[i] = new Node(i + m, sc.nextInt());\n\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (gcd(b[j].value, r[i].value) >= 2) {\n\t\t\t\t\t\tlink.add(new E(b[j].id, r[i].id));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlink.add(new E(r[i].id, sink));\n\t\t\t}\n\n\t\t\tint ans = 0;\n\t\t\tfor (;;) {\n\t\t\t\tused = new boolean[sink + 1];\n\t\t\t\tint res = dfs(source, sink);\n\t\t\t\tif (res == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tans += res;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Scanner;\n\nclass Solve{\n\tScanner in = new Scanner(System.in);\n\t\n\tint[][] cap;\n\tint m, n;\n\tboolean solve(){\n\t\tm = in.nextInt();\n\t\tn = in.nextInt();\n\t\tif(n == 0) return false;\n\t\tNode[] b = new Node[m];\n\t\tNode[] r = new Node[n];\n\t\tcap = new int[m+n+2][m+n+2];\n\t\tNode s = new Node(n+m, 0);\n\t\tNode t = new Node(n+m+1, 0);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tb[i] = new Node(i, in.nextInt());\n\t\t\ts.createEdge(b[i]);\n\t\t\tb[i].createEdge(s);\n\t\t\tcap[s.id][b[i].id] = 1;\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tr[i] = new Node(i+m, in.nextInt());\n\t\t\tr[i].createEdge(t);\n\t\t\tt.createEdge(r[i]);\n\t\t\tcap[r[i].id][t.id] = 1;\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(gcd(b[i].val, r[j].val) == 1) continue;\n\t\t\t\tb[i].createEdge(r[j]);\n\t\t\t\tr[j].createEdge(b[i]);\n\t\t\t\tcap[i][r[j].id] = 1;\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\twhile(true){\n\t\t\tused.clear();\n\t\t\tint flow = flow(s, 1);\n\t\t\tif(flow == 0) break;\n\t\t\tres += flow;\n\t\t}\n\t\tSystem.out.println(res);\n\t\treturn true;\n\t}\n\t\n\tBitSet used = new BitSet();\n\tint flow(Node from, int flow){\n\t\tif(from.id == m+n+1) return flow;\n\t\tif(used.get(from.id)) return 0;\n\t\tused.set(from.id);\n\t\tfor(Node v: from.edge){\n\t\t\tif(cap[from.id][v.id]==0) continue;\n\t\t\tint f = flow(v, Math.min(flow, cap[from.id][v.id]));\n\t\t\tif(f == 0) continue;\n\t\t\tcap[from.id][v.id] -= f;\n\t\t\tcap[v.id][from.id] += f;\n\t\t\treturn f;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint gcd(int a, int b){\n\t\treturn b==0 ? a : gcd(b, a%b);\n\t}\n}\n\nclass Node{\n\tint id;\n\tint val;\n\tArrayList<Node> edge = new ArrayList<Node>();\n\tNode(int id, int val){\n\t\tthis.id = id;\n\t\tthis.val = val;\n\t}\n\t\n\tvoid createEdge(Node nd){\n\t\tedge.add(nd);\n\t}\n}\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tSolve slv = new Solve();\n\t\twhile(slv.solve());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main{\n\tstatic int[] blu = new int[500];\n\tstatic int[] red = new int[500];\n\tstatic int[][] g = new int[500][500];\n\tstatic int[] mb = new int[500];\n\tstatic int[] mr = new int[500];\n\tstatic int m,n;\n\t\n\tpublic static int chk(int i,int j){\n\t\tint a = Math.max(blu[i], red[j]);\n\t\tint b = Math.min(blu[i], red[j]);\n\t\twhile(b!=0){\n\t\t\tint tmp=b;\n\t\t\tb= a%b;\n\t\t\ta= tmp;\n\t\t}\n\t\tif(a!=1) return 1;\n\t\telse return 0;\n\t}\n\t\n\tpublic static boolean rb(int i,int j){\n\t\tdo{\n\t\t\tif(g[i][j]==1){\n\t\t\t\tif(mb[i]==-1 || (i+1<m && rb(i+1,mb[i]))){\n\t\t\t\t\tmb[i]=j;\n\t\t\t\t\tmr[j]=i;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}while(i<m);\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String args[]) throws Exception{\n\t\tint ans;\n        Scanner cin= new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tans=0;\n\t\t\tm= cin.nextInt();\n\t\t\tn= cin.nextInt();\n\t\t\tif(m==0 && n==0) break;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tblu[i] = cin.nextInt();\n\t\t\t\tmb[i] = -1;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tred[i] = cin.nextInt();\n\t\t\t\tmr[i] = -1;\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tg[i][j] = chk(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mr[i]==-1) if(rb(0,i)) ans++;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint m, n;\n\tint[] a, b;\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tm=sc.nextInt();\n\t\t\tn=sc.nextInt();\n\t\t\tif((m|n)==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta=new int[m];\n\t\t\tb=new int[n];\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\ta[i]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tb[i]=sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tV[] vs;\n\n\tvoid solve(){\n\t\tvs=new V[n+m+2];\n\t\tfor(int i=0; i<n+m+2; i++){\n\t\t\tvs[i]=new V();\n\t\t}\n\n\t\tint s=n+m, t=s+1;\n\n\t\tfor(int i=0; i<m; i++){\n\t\t\tvs[s].add(vs[i], 1);\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tvs[m+i].add(vs[t], 1);\n\t\t}\n\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tif(gcd(a[i], b[j])>1){\n\t\t\t\t\tvs[i].add(vs[m+j], 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintln(maxFlow(vs[s], vs[t])+\"\");\n\t}\n\n\tint maxFlow(V s, V t){\n\t\tint flow=0;\n\t\tfor(;;){\n\t\t\tfor(V v : vs){\n\t\t\t\tv.used=false;\n\t\t\t}\n\t\t\tint f=dfs(s, t, INF);\n\t\t\tif(f==0){\n\t\t\t\treturn flow;\n\t\t\t}\n\t\t\tflow+=f;\n\t\t}\n\t}\n\n\tint dfs(V v, V to, int f){\n\t\tif(v==to){\n\t\t\treturn f;\n\t\t}\n\t\tv.used=true;\n\t\tfor(E e : v.es){\n\t\t\tif(!e.to.used&&e.cap>0){\n\t\t\t\tint d=dfs(e.to, to, min(f, e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\te.rev.cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tclass V{\n\t\tLinkedList<E> es=new LinkedList<E>();\n\t\tboolean used;\n\n\t\tvoid add(V to, int cap){\n\t\t\tE e=new E(to, cap), rev=new E(this, 0);\n\t\t\te.rev=rev;\n\t\t\trev.rev=e;\n\t\t\tes.add(e);\n\t\t\tto.es.add(rev);\n\t\t}\n\t}\n\n\tclass E{\n\t\tV to;\n\t\tE rev;\n\t\tint cap;\n\n\t\tE(V to, int cap){\n\t\t\tthis.to=to;\n\t\t\tthis.cap=cap;\n\t\t}\n\t}\n\n\tint gcd(int m, int n){\n\t\tfor(; n!=0;){\n\t\t\tint t=m%n;\n\t\t\tm=n;\n\t\t\tn=t;\n\t\t}\n\t\treturn m;\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    int INF = Integer.MAX_VALUE;\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(true){\n\t    int m = sc.nextInt();\n\t    int n = sc.nextInt();\n\t    if(m==0 && n==0) break;\n\n\t    int[] b = new int[m];\n\t    int[] r = new int[n];\n\t    for(int i=0; i<m; i++) b[i] = sc.nextInt();\n\t    for(int i=0; i<n; i++) r[i] = sc.nextInt();\n\n\t    V[] graph = new V[n+m+2];\n\t    for(int i=0; i<n+m+2; i++) graph[i] = new V();\n\n\t    for(int i=0; i<m; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t    int n1 = Math.max(b[i], r[j]);\n\t\t    int n2 = Math.min(b[i], r[j]);\n\t\t    int gcd = n1;\n\t\t    while(gcd%n2!=0) gcd += n1;\n\t\t    if(gcd==0) continue;\n\t\t    int lcm = n1*n2/gcd;\n\t\t    if(lcm!=1){\n\t\t\tgraph[i].add(graph[j+m], 1);\n\t\t\t//graph[j+n].add(graph[i], 1);\n\t\t    }\n\t\t}\n\t    }\n\n\t    int s = n+m;\n\t    int t = n+m+1;\n\t    for(int i=0; i<m; i++){\n\t\tgraph[s].add(graph[i], 1);\n\t    }\n\t    for(int i=0; i<n; i++){\n\t\tgraph[m+i].add(graph[t], 1);\n\t    }\n\t    int ans = dinic(graph[s], graph[t]);\n\t    System.out.println(ans);\n\t}\n    }\n\n\n    int dinic(V s, V t){\n\tint flow = 0;\n\tfor(int p=1;  ; p++){\n\t    Queue<V> que = new LinkedList<V>();\n\t    s.level = 0;\n\t    s.p = p;\n\t    que.offer(s);\n\t    while(!que.isEmpty()){\n\t\tV v = que.poll();\n\t\tv.iter = v.es.size() - 1;\n\t\tfor(E e : v.es) if(e.to.p < p && e.cap > 0){\n\t\t\te.to.level = v.level + 1;\n\t\t\te.to.p = p;\n\t\t\tque.offer(e.to);\n\t\t    }\n\t    }\n\t    if(t.p < p) return flow;\n\t    for(int f; (f=dfs(s, t, INF)) > 0; ) flow += f;\n\t}\n    }\n\n    int dfs(V v, V t, int f){\n\tif(v==t) return f;\n\tfor(; v.iter >= 0; v.iter--){\n\t    E e = v.es.get(v.iter);\n\t    if(v.level < e.to.level && e.cap > 0){\n\t\tint d = dfs(e.to, t, Math.min(f, e.cap));\n\t\tif(d > 0){\n\t\t    e.cap -= d;\n\t\t    e.rev.cap += d;\n\t\t    return d;\n\t\t}\n\t    }\n\t}\n\treturn 0;\n    }\n\t\n    class V{\n\tArrayList<E> es = new ArrayList<E>();\n\tint level, p, iter;\n\tvoid add(V to, int cap){\n\t    E e = new E(to, cap), rev = new E(this, 0);\n\t    e.rev = rev; rev.rev = e;\n\t    es.add(e); to.es.add(rev);\n\t}\n    }\n\n    class E{\n\tV to;\n\tE rev;\n\tint cap;\n\tE(V to, int cap) {\n\t    this.to = to;\n\t    this.cap = cap;\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tint maximumFlow(int resCapacity[][], int size, int s, int t) {\n\t\tint flow = 0;\n\t\tint flowMartix[][] = new int[size][size];\n\t\tint minCapacity[] = new int[size];\n\t\tint prev[] = new int[size];\n\t\tint queue[] = new int[size];\n\t\tint first, last;\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tminCapacity[i] = Integer.MAX_VALUE;\n\t\twhile (true) {\n\t\t\tfirst = last = 0;\n\t\t\tqueue[last++] = s;\n\t\t\tArrays.fill(prev, -1);\n\t\t\tprev[s] = s;\n\t\t\twhile (first != last && prev[t] < 0) {\n\t\t\t\tint u = queue[first++];\n\t\t\t\tfor (int v = 0; v < size; v++) {\n\t\t\t\t\tif (prev[v] < 0 && 0 < resCapacity[u][v]) {\n\t\t\t\t\t\tprev[v] = u;\n\t\t\t\t\t\tqueue[last++] = v;\n\t\t\t\t\t\tminCapacity[v] = Math.min(minCapacity[u], resCapacity[u][v]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (prev[t] < 0) return flow;\n\t\t\t//if (prev[t] < 0) return flowMartix;\n\t\t\tfor (int i = t; prev[i] != i; i = prev[i]) {\n\t\t\t\tresCapacity[prev[i]][i] -= minCapacity[t];\n\t\t\t\tresCapacity[i][prev[i]] += minCapacity[t];\n\t\t\t\tflowMartix[prev[i]][i] += minCapacity[t];\n\t\t\t\tflowMartix[i][prev[i]] -= minCapacity[t];\n\t\t\t}\n\t\t\tflow += minCapacity[t];\n\t\t}\n\t}\n\n\tint gcd(int a,int b) {\n\t\tif(a<b){a^=b;b^=a;a^=b;}\n\t\treturn b!=0?gcd(b,a%b):a;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[] a = sc.nextIntArray(n);\n\t\t\tint[] b = sc.nextIntArray(m);\n\n\t\t\tint[][] g = new int[n + m + 2][n + m + 2];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (1 < gcd(a[i], b[j])) {\n\t\t\t\t\t\tint u = i + 1;\n\t\t\t\t\t\tint v = n + j + 1;\n\t\t\t\t\t\tg[u][v] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[0][i + 1] = 1;\n\t\t\t}\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tg[n + j + 1][n + m + 1] = 1;\n\t\t\t}\n\n\t\t\tSystem.out.println(maximumFlow(g, n + m + 2, 0, n + m + 1));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main{\n\tstatic int[] blu = new int[500];\n\tstatic int[] red = new int[500];\n\tstatic int[][] g = new int[500][500];\n\tstatic int[] mb = new int[500];\n\tstatic int[] mr = new int[500];\n\tstatic int m,n;\n\t\n\tpublic static int chk(int i,int j){\n\t\tint a = Math.max(blu[i], red[j]);\n\t\tint b = Math.min(blu[i], red[j]);\n\t\twhile(b!=0){\n\t\t\tint tmp=b;\n\t\t\tb= a%b;\n\t\t\ta= tmp;\n\t\t}\n\t\tif(a!=1) return -1;\n\t\telse return 0;\n\t}\n\t\n\tpublic static boolean rb(int i,int j){\n\t\tdo{\n\t\t\tif(g[i][j]==-1){\n\t\t\t\tif(mb[i]==-1 || (i+1<m && rb(i+1,mb[i]))){\n\t\t\t\t\tmb[i]=j;\n\t\t\t\t\tmr[j]=i;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}else i+=g[i][j];\n\t\t}while(i<m);\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String args[]) throws Exception{\n\t\tint ans;\n        Scanner cin= new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tans=0;\n\t\t\tm= cin.nextInt();\n\t\t\tn= cin.nextInt();\n\t\t\tif(m==0 && n==0) break;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tblu[i] = cin.nextInt();\n\t\t\t\tmb[i] = -1;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tred[i] = cin.nextInt();\n\t\t\t\tmr[i] = -1;\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tg[i][j] = chk(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint c=1;\n\t\t\t\tfor(int i=m-1;i>=0;i--){\n\t\t\t\t\tif(g[i][j]==-1) c=1;\n\t\t\t\t\telse{\n\t\t\t\t\t\tg[i][j]=c;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\t\tif(g[i][j]==-1 && mb[i]==-1){\n\t\t\t\t\t\tmb[i]=j;\n\t\t\t\t\t\tmr[j]=i;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mr[i]==-1 && rb(0,i)) ans++;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\n@SuppressWarnings(\"unchecked\")\npublic class Main {\n\n    static int M;\n    static int N;\n    static int[] B;\n    static int[] R;\n\n    public static void main(String[] args) {\n        FastScanner fc = new FastScanner(System.in);\n\n        while(true) {\n            M = fc.nextInt();\n            N = fc.nextInt();\n\n            if( M == 0 && N == 0 ) break;\n\n            B = fc.nextIntArray(M);\n            R = fc.nextIntArray(N);\n            System.out.println( solve() );\n        }\n    }\n\n    static int solve() {\n        List<Edge> es = new ArrayList<>();\n\n        for (int b = 0; b < M; b++) {\n            for (int r = 0; r < N; r++) {\n                if( gcd(B[b], R[r]) > 1 ) {\n                    es.add( new Edge(b, r+M) );\n                }\n            }\n        }\n        return matching(M+N, es);\n    }\n\n    static int gcd(int a, int b) {\n        while (b > 0) {\n            int c = a;\n            a = b;\n            b = c % b;\n        }\n        return a;\n    }\n\n    static int matching(int V, List<Edge> E) {\n        List<Edge>[] rin = mkRin(V, E);\n\n        int res = 0;\n        int[] match = new int[V];\n        boolean[] used = new boolean[V];\n        Arrays.fill(match, -1);\n        for (int v = 0; v < V; v++) {\n            if( match[v] == -1 ) {\n                Arrays.fill(used, false);\n                if( _matching(v, rin, used, match) ) {\n                    res++;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    static List<Edge>[] mkRin(int V, List<Edge> E) {\n        //noinspection unchecked\n        List<Edge>[] rin = new List[V];\n        for (Edge e : E) {\n            if( rin[e.a] == null ) rin[e.a] = new ArrayList<>();\n            if( rin[e.b] == null ) rin[e.b] = new ArrayList<>();\n            rin[e.a].add(e);\n            rin[e.b].add(e);\n        }\n        return rin;\n    }\n\n    static boolean _matching(int v, List<Edge>[] rin, boolean[] used, int[] match) {\n        used[v] = true;\n        if( rin[v] == null ) return false;\n\n        for (Edge e : rin[v]) {\n            int u  = e.a == v ? e.b : e.a;\n            int w = match[u];\n            if( w == -1 || !used[w] && _matching(w, rin, used, match) ) {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    static class Edge {\n        int a;\n        int b;\n\n        public Edge(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        public String toString() {\n            return \"(\" + a + \",\" + b + \")\";\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        private String peeked;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        boolean hasNext() {\n            return peekLine();\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                tokenizer = new StringTokenizer(consumeLine());\n            }\n            return tokenizer.nextToken();\n        }\n\n        private boolean peekLine() {\n            try {\n                if( peeked != null ) return true;\n\n                peeked = reader.readLine();\n                return peeked != null;\n\n            } catch( IOException e ) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        private String consumeLine() {\n            if( peeked != null ) {\n                String t;\n                t = peeked;\n                peeked = null;\n                return t;\n\n            } else {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                return consumeLine();\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main{\n\tstatic int[] blu = new int[500];\n\tstatic int[] red = new int[500];\n\tstatic int[][] g = new int[500][500];\n\tstatic int[] mb = new int[500];\n\tstatic int[] mr = new int[500];\n\tstatic int m,n;\n\t\n\tpublic static int chk(int i,int j){\n\t\tint a = Math.max(blu[i], red[j]);\n\t\tint b = Math.min(blu[i], red[j]);\n\t\twhile(b!=0){\n\t\t\tint tmp=b;\n\t\t\tb= a%b;\n\t\t\ta= tmp;\n\t\t}\n\t\tif(a!=1) return 1;\n\t\telse return 0;\n\t}\n\t\n\tpublic static int rb(int i,int j){\n\t\tdo{\n\t\t\tif(g[i][j]==1){\n\t\t\t\tif(mb[i]==-1 || rb(i+1,mb[i])==1){\n\t\t\t\t\tmb[i]=j;\n\t\t\t\t\tmr[j]=i;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}while(i<m);\n\t\treturn 0;\n\t}\n\tpublic static int br(int i,int j){\n\t\tdo{\n\t\t\tif(g[i][j]==1){\n\t\t\t\tif(mr[j]==-1 || br(mr[j],j+1)==1){\n\t\t\t\t\tmr[j]=i;\n\t\t\t\t\tmb[i]=j;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj++;\n\t\t}while(j<n);\n\t\treturn 0;\n\t}\n\t\n\tpublic static void main(String args[]) throws Exception{\n\t\tint ans;\n        Scanner cin= new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tans=0;\n\t\t\tm= cin.nextInt();\n\t\t\tn= cin.nextInt();\n\t\t\tif(m==0 && n==0) break;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tblu[i] = cin.nextInt();\n\t\t\t\tmb[i] = -1;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tred[i] = cin.nextInt();\n\t\t\t\tmr[i] = -1;\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tg[i][j] = chk(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mr[i]==-1) ans += rb(0,i);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.util.*;\n\npublic class Main {\n\tArrayList<ArrayList<Integer>> pass;\n\tboolean [] used;\n\tint [] match;\n\t\n\tprivate int gcd(int a, int b){\n\t\tif(b == 0){\n\t\t\treturn a;\n\t\t}\n\t\telse{\n\t\t\treturn gcd(b, a%b);\n\t\t}\n\t}\n\t\n\tprivate boolean dfs(int v){\n\t\tused[v] = true;\n\t\tfor(int i =0; i < pass.get(v).size(); i++){\n\t\t\tint u = pass.get(v).get(i);\n\t\t\tint w = match[u];\n\t\t\tif(w < 0 || !used[w] && dfs(w)){\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate void doit() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(m ==0 && n == 0) break;\n\t\t\tint [] mdata = new int[m];\n\t\t\tint [] ndata = new int[n];\n\t\t\tused = new boolean[m + n];\n\t\t\tmatch = new int[m + n];\n\t\t\t\n\t\t\tfor(int i =0; i < m; i++){\n\t\t\t\tmdata[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i =0; i < n; i++){\n\t\t\t\tndata[i] = sc.nextInt();\n\t\t\t}\n\t\t\tpass = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor(int i =0; i  < m + n; i++){\n\t\t\t\tpass.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tfor(int i=0; i < m; i++){\n\t\t\t\tfor(int j =0; j < n; j++){\n\t\t\t\t\tint  result = gcd(mdata[i], ndata[j]);\n\t\t\t\t\tif(result > 1){\n\t\t\t\t\t\tpass.get(i).add(m + j);\n\t\t\t\t\t\tpass.get(j + m).add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint ans = 0;\n\t\t\tArrays.fill(match, -1);\n\t\t\tfor(int i=0; i < n + m; i++){\n\t\t\t\tif(match[i] < 0){\n\t\t\t\t\tArrays.fill(used, false);\n\t\t\t\t\tif(dfs(i)){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.print(\"ANS= \");\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t\t//DEBUG\n//\t\t\tfor(int i =0; i < m; i++){\n//\t\t\t\tArrayList<Integer> al = pass.get(i);\n//\t\t\t\tfor(int j=0; j < al.size(); j++){\n//\t\t\t\t\tSystem.out.print(al.get(j));\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tfor(int i =0; i < match.length; i++){\n//\t\t\t\tSystem.out.println(match[i]);\n//\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic ArrayList<Integer>[] g;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif (m == 0 && n == 0)\n\t\t\t\tbreak;\n\t\t\tint[] b = new int[m];\n\t\t\tint[] r = new int[n];\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tr[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tg = new ArrayList[n + m];\n\t\t\tfor (int i = 0; i < n + m; ++i) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\t\tif (gcd(b[i], r[j]) > 1) {\n\t\t\t\t\t\tg[i].add(m + j);\n\t\t\t\t\t\tg[m + j].add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvis = new boolean[n + m];\n\t\t\tmatchTo = new int[n + m];\n\t\t\tArrays.fill(matchTo, -1);\n\t\t\tint match = 0;\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tArrays.fill(vis, false);\n\t\t\t\tif (dfs(i)) {\n\t\t\t\t\t++match;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(match);\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic boolean[] vis;\n\tstatic int[] matchTo;\n\n\tstatic boolean dfs(int v) {\n\t\tif (v < 0)\n\t\t\treturn true;\n\t\tfor (int dst : g[v]) {\n\t\t\tif (vis[dst])\n\t\t\t\tcontinue;\n\t\t\tvis[dst] = true;\n\t\t\tif (dfs(matchTo[dst])) {\n\t\t\t\tmatchTo[v] = dst;\n\t\t\t\tmatchTo[dst] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic int gcd(int a, int b) {\n\t\tif (a > b) {\n\t\t\tint d = a;\n\t\t\ta = b;\n\t\t\tb = d;\n\t\t}\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\telse\n\t\t\treturn gcd(b % a, a);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport static java.lang.System.*;\n\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic class Node {\n\t\tint id;\n\t\tList<Edge> link = new LinkedList<Edge>();\n\n\t\tNode(int _id) {\n\t\t\tid = _id;\n\t\t}\n\t}\n\n\tstatic class Edge {\n\t\tint from, to, cost;\n\n\t\tEdge(int _from, int _to, int _cost) {\n\t\t\tfrom = _from;\n\t\t\tto = _to;\n\t\t\tcost = _cost;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn from + \"->\" + to;\n\t\t}\n\t}\n\n\tboolean augment(final Node[] g, int u, int[] matchTo, boolean[] visited) {\n\t\tif (u < 0)\n\t\t\treturn true;\n\t\tfor (Edge link : g[u].link)\n\t\t\tif (!visited[link.to]) {\n\t\t\t\tvisited[link.to] = true;\n\t\t\t\tif (augment(g, matchTo[link.to], matchTo, visited)) {\n\t\t\t\t\tmatchTo[link.from] = link.to;\n\t\t\t\t\tmatchTo[link.to] = link.from;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\treturn false;\n\t}\n\n\tint bipartiteMatching(final Node[] g, int L, List<Edge> matching) {\n\t\tfinal int n = g.length;\n\t\tint[] matchTo = new int[n];\n\t\tArrays.fill(matchTo, -1);\n\t\tint match = 0;\n\t\tfor (int u = 0; u < L; u++) {\n\t\t\tboolean[] visited = new boolean[n];\n\t\t\tif (augment(g, u, matchTo, visited))\n\t\t\t\t++match;\n\t\t}\n\t\tfor (int u = 0; u < L; u++)\n\t\t\tif (matchTo[u] >= 0) // make explicit matching\n\t\t\t\tmatching.add(new Edge(u, matchTo[u], 0));\n\t\treturn match;\n\t}\n\tint gcd(int a,int b){\n\t\treturn b==0?a:gcd(b,a%b);\n\t}\n\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt(), n = sc.nextInt();\n\t\t\tif (m == 0 && n == 0)\n\t\t\t\treturn;\n\t\t\tint[] bs = new int[m];\n\t\t\tint[] rs = new int[n];\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t\tbs[i] = sc.nextInt();\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\trs[i] = sc.nextInt();\n\n\t\t\tNode[] g=new Node[n+m];\n\t\t\tfor (int i = 0; i < n+m; i++)\n\t\t\t\tg[i] =new Node(i);\n\n\n\t\t\tList<Edge> matching=new ArrayList<Edge>();\n\n\t\t\tfor(int i=0;i<m;i++)for(int j=0;j<n;j++){\n\t\t\t\tif(gcd(bs[i],rs[j])>1){\n\t\t\t\t\tg[i].link.add(new Edge(i,m+j,1));\n\t\t\t\t\tg[m+j].link.add(new Edge(i,m+j,1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tln(bipartiteMatching(g,m,matching));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tstatic Scanner sc = new Scanner(in);\n\n\t// output lib\n\tstatic final String br = System.getProperty(\"line.separator\");\n\tstatic final String[] asep = new String[] { \"\", \" \", br, br + br };\n\n\tstatic String str(Boolean o) {\n\t\treturn o ? \"YES\" : \"NO\";\n\t}\n\n\t// static String str(Double o){\n\t// return String.format(\"%.8f\",o);\n\t// }\n\tstatic <K, V> String str(Map<K, V> map) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean isFirst = true;\n\t\tfor (Entry<K, V> set : map.entrySet()) {\n\t\t\tif (!isFirst)\n\t\t\t\tsb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\")\n\t\t\t\t\t.append(str(set.getValue()));\n\t\t\tisFirst = false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic <E> String str(Collection<E> list) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean isFirst = true;\n\t\tfor (E e : list) {\n\t\t\tif (!isFirst)\n\t\t\t\tsb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst = false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o) {\n\t\tint depth = _getArrayDepth(o);\n\t\tif (depth > 0)\n\t\t\treturn _strArray(o, depth);\n\t\tClass<?> c = o.getClass();\n\t\tif (c.equals(Boolean.class))\n\t\t\treturn str((Boolean) o);\n\t\t// if(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\n\tstatic int _getArrayDepth(Object o) {\n\t\tif (!o.getClass().isArray() || Array.getLength(o) == 0)\n\t\t\treturn 0;\n\t\treturn 1 + _getArrayDepth(Array.get(o, 0));\n\t}\n\n\tstatic String _strArray(Object o, int depth) {\n\t\tif (depth == 0)\n\t\t\treturn str(o);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0, len = Array.getLength(o); i < len; i++) {\n\t\t\tif (i != 0)\n\t\t\t\tsb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o, i), depth - 1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic void pr(Object... os) {\n\t\tboolean isFirst = true;\n\t\tfor (Object o : os) {\n\t\t\tif (!isFirst)\n\t\t\t\tout.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst = false;\n\t\t}\n\t}\n\n\tstatic void ln() {\n\t\tout.println();\n\t}\n\n\tstatic void ln(Object... os) {\n\t\tfor (Object o : os) {\n\t\t\tpr(o);\n\t\t\tln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n  private static long gcd(long a, long b) {\n    return b == 0 ? a : gcd(b, a % b);\n  }\n\n  private void solve(FastScanner in, PrintWriter out) {\n    while (true) {\n      int m = in.nextInt();\n      int n = in.nextInt();\n      if (m == 0 && n == 0) {\n        break;\n      }\n      int[] b = in.nextIntArray(m);\n      int[] r = in.nextIntArray(n);\n\n      Dinitz dinitz = new Dinitz(n + m + 2);\n      int source = n + m;\n      int sink = source + 1;\n      for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n          if (gcd(b[i], r[j]) > 1) {\n            dinitz.addEdge(i, j + m, 1);\n          }\n        }\n      }\n\n      for (int i = 0; i < m; i++) {\n        dinitz.addEdge(source, i, 1);\n      }\n      for (int i = 0; i < n; i++) {\n        dinitz.addEdge(i + m, sink, 1);\n      }\n\n      out.println(dinitz.maxFlow(source, sink));\n    }\n  }\n\n  class Dinitz {\n\n    class Edge {\n\n      int to, rev;\n      long cap;\n\n      Edge(int to, long cap, int rev) {\n        this.to = to;\n        this.cap = cap;\n        this.rev = rev;\n      }\n    }\n\n    private ArrayDeque<Integer> deque = new ArrayDeque<>();\n    private ArrayList<ArrayList<Edge>> g;\n    private int[] level;\n    private int[] iter;\n\n    Dinitz(int V) {\n      g = new ArrayList<>(V);\n      for (int i = 0; i < V; i++) {\n        g.add(new ArrayList<>());\n      }\n      level = new int[V];\n      iter = new int[V];\n    }\n\n    void addEdge(int from, int to, long cap) {\n      g.get(from).add(new Edge(to, cap, g.get(to).size()));\n      g.get(to).add(new Edge(from, 0, g.get(from).size() - 1));\n    }\n\n    private long dfs(int v, int t, long f) {\n      if (v == t) {\n        return f;\n      }\n      for (; iter[v] < g.get(v).size(); iter[v]++) {\n        Edge e = g.get(v).get(iter[v]);\n        if (e.cap > 0 && level[v] < level[e.to]) {\n          long d = dfs(e.to, t, Math.min(f, e.cap));\n          if (d > 0) {\n            e.cap -= d;\n            g.get(e.to).get(e.rev).cap += d;\n            return d;\n          }\n        }\n      }\n      return 0;\n    }\n\n    private void bfs(int s) {\n      Arrays.fill(level, -1);\n      level[s] = 0;\n      deque.add(s);\n      while (!deque.isEmpty()) {\n        int v = deque.poll();\n        for (Edge e : g.get(v)) {\n          if (e.cap > 0 && level[e.to] < 0) {\n            level[e.to] = level[v] + 1;\n            deque.add(e.to);\n          }\n        }\n      }\n    }\n\n    long maxFlow(int s, int t) {\n      long flow = 0;\n      for (; ; ) {\n        bfs(s);\n        if (level[t] < 0) {\n          return flow;\n        }\n        Arrays.fill(iter, 0);\n        long f;\n        while ((f = dfs(s, t, Long.MAX_VALUE)) > 0) {\n          flow += f;\n        }\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    PrintWriter out = new PrintWriter(System.out);\n    new Main().solve(new FastScanner(), out);\n    out.close();\n  }\n\n  private static class FastScanner {\n\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int bufferLength = 0;\n\n    private boolean hasNextByte() {\n      if (ptr < bufferLength) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          bufferLength = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (bufferLength <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) {\n        return buffer[ptr++];\n      } else {\n        return -1;\n      }\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n        ptr++;\n      }\n    }\n\n    boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    long nextLong() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    double[] nextDoubleArray(int n) {\n      double[] array = new double[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextDouble();\n      }\n      return array;\n    }\n\n    double[][] nextDoubleMap(int n, int m) {\n      double[][] map = new double[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextDoubleArray(m);\n      }\n      return map;\n    }\n\n    public int nextInt() {\n      return (int) nextLong();\n    }\n\n    public int[] nextIntArray(int n) {\n      int[] array = new int[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextInt();\n      }\n      return array;\n    }\n\n    public long[] nextLongArray(int n) {\n      long[] array = new long[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = nextLong();\n      }\n      return array;\n    }\n\n    public String[] nextStringArray(int n) {\n      String[] array = new String[n];\n      for (int i = 0; i < n; i++) {\n        array[i] = next();\n      }\n      return array;\n    }\n\n    public char[][] nextCharMap(int n) {\n      char[][] array = new char[n][];\n      for (int i = 0; i < n; i++) {\n        array[i] = next().toCharArray();\n      }\n      return array;\n    }\n\n    public int[][] nextIntMap(int n, int m) {\n      int[][] map = new int[n][];\n      for (int i = 0; i < n; i++) {\n        map[i] = nextIntArray(m);\n      }\n      return map;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main{\n\tstatic int[] blu = new int[500];\n\tstatic int[] red = new int[500];\n\tstatic int[][] g = new int[500][500];\n\tstatic int[] mb = new int[500];\n\tstatic int[] mr = new int[500];\n\tstatic int m,n;\n\t\n\tpublic static int chk(int i,int j){\n\t\tint a = Math.max(blu[i], red[j]);\n\t\tint b = Math.min(blu[i], red[j]);\n\t\twhile(b!=0){\n\t\t\tint tmp=b;\n\t\t\tb= a%b;\n\t\t\ta= tmp;\n\t\t}\n\t\tif(a!=1) return 1;\n\t\telse return 0;\n\t}\n\t\n\tpublic static boolean rb(int i,int j){\n\t\tdo{\n\t\t\tif(g[i][j]==1){\n\t\t\t\tif(mb[i]==-1 || rb(i+1,mb[i])){\n\t\t\t\t\tmb[i]=j;\n\t\t\t\t\tmr[j]=i;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}while(i<m);\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String args[]) throws Exception{\n\t\tint ans;\n        Scanner cin= new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tans=0;\n\t\t\tm= cin.nextInt();\n\t\t\tn= cin.nextInt();\n\t\t\tif(m==0 && n==0) break;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tblu[i] = cin.nextInt();\n\t\t\t\tmb[i] = -1;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tred[i] = cin.nextInt();\n\t\t\t\tmr[i] = -1;\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tg[i][j] = chk(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mr[i]==-1) if(rb(0,i)) ans++;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    int INF = Integer.MAX_VALUE;\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(true){\n\t    int m = sc.nextInt();\n\t    int n = sc.nextInt();\n\t    if(m==0 && n==0) break;\n\n\t    int[] b = new int[m];\n\t    int[] r = new int[n];\n\t    for(int i=0; i<m; i++) b[i] = sc.nextInt();\n\t    for(int i=0; i<n; i++) r[i] = sc.nextInt();\n\n\t    V[] graph = new V[n+m+2];\n\t    for(int i=0; i<n+m+2; i++) graph[i] = new V();\n\n\t    for(int i=0; i<m; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t    int n1 = Math.max(b[i], r[j]);\n\t\t    int n2 = Math.min(b[i], r[j]);\n\t\t    int gcd = n1;\n\t\t    while(gcd%n2!=0) gcd += n1;\n\t\t    int lcm = n1*n2/gcd;\n\t\t    if(lcm!=1){\n\t\t\tgraph[i].add(graph[j+n], 1);\n\t\t\t//graph[j+n].add(graph[i], 1);\n\t\t    }\n\t\t}\n\t    }\n\n\t    int s = n+m;\n\t    int t = n+m+1;\n\t    for(int i=0; i<n; i++){\n\t\tgraph[s].add(graph[i], 1);\n\t    }\n\t    for(int i=0; i<m; i++){\n\t\tgraph[n+i].add(graph[t], 1);\n\t    }\n\t    int ans = dinic(graph[s], graph[t]);\n\t    System.out.println(ans);\n\t}\n    }\n\n\n    int dinic(V s, V t){\n\tint flow = 0;\n\tfor(int p=1;  ; p++){\n\t    Queue<V> que = new LinkedList<V>();\n\t    s.level = 0;\n\t    s.p = p;\n\t    que.offer(s);\n\t    while(!que.isEmpty()){\n\t\tV v = que.poll();\n\t\tv.iter = v.es.size() - 1;\n\t\tfor(E e : v.es) if(e.to.p < p && e.cap > 0){\n\t\t\te.to.level = v.level + 1;\n\t\t\te.to.p = p;\n\t\t\tque.offer(e.to);\n\t\t    }\n\t    }\n\t    if(t.p < p) return flow;\n\t    for(int f; (f=dfs(s, t, INF)) > 0; ) flow += f;\n\t}\n    }\n\n    int dfs(V v, V t, int f){\n\tif(v==t) return f;\n\tfor(; v.iter >= 0; v.iter--){\n\t    E e = v.es.get(v.iter);\n\t    if(v.level < e.to.level && e.cap > 0){\n\t\tint d = dfs(e.to, t, Math.min(f, e.cap));\n\t\tif(d > 0){\n\t\t    e.cap -= d;\n\t\t    e.rev.cap += d;\n\t\t    return d;\n\t\t}\n\t    }\n\t}\n\treturn 0;\n    }\n\t\n    class V{\n\tArrayList<E> es = new ArrayList<E>();\n\tint level, p, iter;\n\tvoid add(V to, int cap){\n\t    E e = new E(to, cap), rev = new E(this, 0);\n\t    e.rev = rev; rev.rev = e;\n\t    es.add(e); to.es.add(rev);\n\t}\n    }\n\n    class E{\n\tV to;\n\tE rev;\n\tint cap;\n\tE(V to, int cap) {\n\t    this.to = to;\n\t    this.cap = cap;\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    int INF = Integer.MAX_VALUE;\n    \n    public static void main(String[] args){\n        new Main().solve();\n    }\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n        \n        while(true){\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            if(m==0 && n==0) break;\n \n            int[] b = new int[m];\n            int[] r = new int[n];\n            for(int i=0; i<m; i++) b[i] = sc.nextInt();\n            for(int i=0; i<n; i++) r[i] = sc.nextInt();\n \n            V[] graph = new V[n+m+2];\n            for(int i=0; i<n+m+2; i++) graph[i] = new V();\n \n            for(int i=0; i<m; i++){\n                for(int j=0; j<n; j++){\n                    int n1 = Math.max(b[i], r[j]);\n                    int n2 = Math.min(b[i], r[j]);\n                    int gcd = gcd(n2, n1);\n                    if(gcd!=1) graph[i].add(graph[j+m], 1);\n                }\n            }\n \n            int s = n+m;\n            int t = n+m+1;\n            for(int i=0; i<m; i++) graph[s].add(graph[i], 1);\n            for(int i=0; i<n; i++) graph[m+i].add(graph[t], 1);\n            int ans = dinic(graph[s], graph[t]);\n            System.out.println(ans);\n        }\n    }\n \n    int gcd(int x, int y){\n        if(x==0) return y;\n        return gcd(y%x, x);\n    }\n \n    int dinic(V s, V t){\n        int flow = 0;\n        for(int p=1;  ; p++){\n            Queue<V> que = new LinkedList<V>();\n            s.level = 0;\n            s.p = p;\n            que.offer(s);\n            while(!que.isEmpty()){\n                V v = que.poll();\n                v.iter = v.es.size() - 1;\n                for(E e : v.es) if(e.to.p < p && e.cap > 0){\n                        e.to.level = v.level + 1;\n                        e.to.p = p;\n                        que.offer(e.to);\n                    }\n            }\n            if(t.p < p) return flow;\n            for(int f; (f=dfs(s, t, INF)) > 0; ) flow += f;\n        }\n    }\n \n    int dfs(V v, V t, int f){\n        if(v==t) return f;\n        for(; v.iter >= 0; v.iter--){\n            E e = v.es.get(v.iter);\n            if(v.level < e.to.level && e.cap > 0){\n                int d = dfs(e.to, t, Math.min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    e.rev.cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n     \n    class V{\n        ArrayList<E> es = new ArrayList<E>();\n        int level, p, iter;\n        void add(V to, int cap){\n            E e = new E(to, cap), rev = new E(this, 0);\n            e.rev = rev; rev.rev = e;\n            es.add(e); to.es.add(rev);\n        }\n    }\n \n    class E{\n        V to;\n        E rev;\n        int cap;\n        E(V to, int cap) {\n            this.to = to;\n            this.cap = cap;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\n\t/* ----------Bipartile Matching--------- */\n\t/* g : The graph which has elements of (n + m).*/\n\tclass BipartileMatching {\n\t\tint V;\n\t\tboolean[] used;\n\t\tint[] match;\n\t\tArrayList<Integer>[] g;\n\t\t\n\t\tBipartileMatching(ArrayList<Integer>[] g) {\n\t\t\tV = g.length;\n\t\t\tused = new boolean[V];\n\t\t\tmatch = new int[V];\n\t\t\tthis.g = g;\n\t\t}\n\t\t\n\t\tboolean dfs(int u) {\n\t\t\tused[u] = true;\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tint w = match[v];\n\t\t\t\tif (w < 0 || (!used[w] && dfs(w))) {\n\t\t\t\t\tmatch[v] = u;\n\t\t\t\t\tmatch[u] = v;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tint doit() {\n\t\t\tint res = 0;\n\t\t\tArrays.fill(match, -1);\n\t\t\tfor (int v = 0; v < V; v++) {\n\t\t\t\tif (match[v] < 0) {\n\t\t\t\t\tArrays.fill(used, false);\n\t\t\t\t\tif (dfs(v)) res++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\t\n\t/* ----------------------------- */\n\t\n\tlong gcd(long x, long y) {\n\t\tif (x == 0 || y == 0) return x + y;\n\t\treturn gcd(y, x % y);\n\t}\n\t\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt(), m = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tArrayList<Integer>[] g = new ArrayList[n+m];\n\t\t\tfor (int i = 0; i < n + m; i++) {\n\t\t\t\tg[i] = new ArrayList<Integer>();\n\t\t\t}\n\t\t\t\n\t\t\tint[] a = in.nextIntArray(n);\n\t\t\tint[] b = in.nextIntArray(m);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (gcd(a[i], b[j]) != 1) {\n\t\t\t\t\t\tg[i].add(j+n);\n\t\t\t\t\t\tg[j+n].add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tBipartileMatching bm = new BipartileMatching(g);\n\t\t\tSystem.out.println(bm.doit());\n\t\t}\t\t\n\t}\t\n\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tstatic int gcd(int x, int y) {\n\t\tif(x < y) {\n\t\t\tint tmp = x;\n\t\t\tx = y;\n\t\t\ty = tmp;\n\t\t}\n\t\twhile(y > 0) {\n\t\t\tint r = x % y;\n\t\t\tx = y;\n\t\t\ty = r;\n\t\t}\n\t\treturn x;\n\t}\n\t\n\tstatic int bipartiteMatching(boolean[][] can) {\n\t\t// 0..m-1 blue\n\t\t// m..m+n-1 red\n\t\tint m = can.length; // number of blue\n\t\tint n = can[0].length; // number of red\n\t\tint s = n + m, t = s+1;\n\t\tinitGraph(m+n+2);\n\t\t// s to blue\n\t\tfor(int i=0; i<m; i++) {\n\t\t\taddEdge(s, i, 1);\n\t\t}\n\t\t// red to t\n\t\tfor(int i=0; i<n; i++) {\n\t\t\taddEdge(m+i, t, 1);\n\t\t}\n\t\t// blue to red\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\tif(can[i][j]) {\n\t\t\t\t\taddEdge(i, m+j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxFlow(s, t);\n\t}\n\t\n\t// from MaxFlowFordFulkerson.java\n\tstatic int MAX_V = 1000;\n\tstatic int INF = 10000000;\n\tstatic ArrayList<ArrayList<Edge>> G = new ArrayList<ArrayList<Edge>>(MAX_V);\n\tstatic boolean[] used = new boolean[MAX_V];\n\t\n\tstatic void addEdge(int from, int to, int cap) {\n\t\tG.get(from).add(new Edge(to, cap, G.get(to).size()));\n\t\tG.get(to).add(new Edge(from, 0, G.get(from).size()-1));\n\t}\n\t\n\tstatic int dfs(int v, int t, int f) {\n\t\tif(v==t) return f;\n\t\tused[v] = true;\n\t\tfor(int i=0; i<G.get(v).size(); i++) {\n\t\t\tEdge e = G.get(v).get(i);\n\t\t\tif(!used[e.to] && e.cap > 0) {\n\t\t\t\tint d = dfs(e.to, t, Math.min(f, e.cap));\n\t\t\t\tif(d>0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG.get(e.to).get(e.rev).cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tstatic int maxFlow(int s, int t) {\n\t\tint flow = 0;\n\t\tfor(;;) {\n\t\t\tArrays.fill(used, false);\n\t\t\tint f = dfs(s, t, INF);\n\t\t\tif(f==0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n\t\n\tstatic void initGraph(int maxV) {\n\t\tfor(int i=0; i<maxV; i++) {\n\t\t\tG.add(new ArrayList<Edge>());\n\t\t}\n\t}\n\t\n\tstatic void resetGraph() {\n\t\tG = new ArrayList<ArrayList<Edge>>(MAX_V);\n\t\tused = new boolean[MAX_V];\n\t}\n\t\n\tstatic class Edge {\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) {\n\t\t\tthis.to = to; this.cap = cap; this.rev = rev;\n\t\t}\n\t}\n\t\n\tstatic public void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint m = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\tString ans = \"\";\n\t\tint cnt = 0;\n\t\twhile(!(n==0 && m==0)) {\n\t\t\tboolean[][] can = new boolean[m][n];\n\t\t\tint[] b = new int[m];\n\t\t\tint[] r = new int[n];\n\t\t\tfor(int i=0; i<m; i++) b[i] = sc.nextInt();\n\t\t\tfor(int i=0; i<n; i++) r[i] = sc.nextInt();\n\t\t\tfor(int i=0; i<m; i++) {\n\t\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\t\tif(gcd(b[i], r[j]) > 1) can[i][j] = true;\n\t\t\t\t\telse can[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += (bipartiteMatching(can)) + \"\\n\";\n\t\t\tresetGraph();\n\t\t\tif(cnt%30==0) System.gc();\n\t\t\tm = sc.nextInt(); n = sc.nextInt(); cnt++;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Cards\n */\npublic class Main {\n\n\tstatic final int INF = 1 << 29;\n\n\tstatic int S, T;\n\tstatic List<List<Edge>> G;\n\tstatic boolean[] used;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint m, n;\n\t\t\tm = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\tn = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((m | n) == 0) break;\n\n\t\t\tS = m + n;\n\t\t\tT = S + 1;\n\n\t\t\tint[] ms = new int[m];\n\t\t\tint[] ns = new int[n];\n\n\t\t\tfor (int i = 0; i < m; ) {\n\t\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\t\twhile (st.hasMoreTokens()) {\n\t\t\t\t\tms[i] = parseInt(st.nextToken());\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; ) {\n\t\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\t\twhile (st.hasMoreTokens()) {\n\t\t\t\t\tns[i] = parseInt(st.nextToken());\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\t\t\tG = new ArrayList<>();\n\t\t\tused = new boolean[T + 1];\n\n\t\t\tfor (int i = 0; i <= T; i++) {\n\t\t\t\tG.add(new ArrayList<>());\n\t\t\t}\n\n\t\t\t//S -> blue\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tG.get(S).add(new Edge(i, 1, G.get(i).size()));\n\t\t\t\tG.get(i).add(new Edge(S, 0, G.get(S).size() - 1));\n\t\t\t}\n\n\t\t\t//red -> T\n\t\t\tfor (int i = m; i < m + n; i++) {\n\t\t\t\tG.get(i).add(new Edge(T, 1, G.get(T).size()));\n\t\t\t\tG.get(T).add(new Edge(i, 0, G.get(i).size() - 1));\n\t\t\t}\n\n\t\t\t//blue -> red\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (gcd(ms[i], ns[j]) > 1) {\n\t\t\t\t\t\tG.get(i).add(new Edge(m + j, 1, G.get(m + j).size()));\n\t\t\t\t\t\tG.get(m + j).add(new Edge(i, 0, G.get(i).size() - 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = 0;\n\n\t\t\twhile (true) {\n\t\t\t\tused = new boolean[T + 1];\n\t\t\t\tint f = rec(S, T, INF);\n\t\t\t\tif (f == 0) break;\n\t\t\t\tans += f;\n\t\t\t}\n\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic int rec(int u, int v, int f) {\n\n\t\tif (u == v) return f;\n\n\t\tused[u] = true;\n\n\t\tfor (Edge e : G.get(u)) {\n\t\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\t\tint d = rec(e.to, v, Math.min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG.get(e.to).get(e.rev).cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tstatic int gcd(int a, int b) {\n\t\tif (b == 0) return a;\n\t\treturn gcd(b, a % b);\n\t}\n}\n\nclass Edge {\n\tint to, cap, rev;\n\n\tpublic Edge(int to, int cap, int rev) {\n\t\tthis.to = to;\n\t\tthis.cap = cap;\n\t\tthis.rev = rev;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main{\n\tstatic int[] blu = new int[500];\n\tstatic int[] red = new int[500];\n\tstatic int[][] g = new int[500][500];\n\tstatic int[] mb = new int[500];\n\tstatic int[] mr = new int[500];\n\tstatic int m,n;\n\t\n\tpublic static int chk(int i,int j){\n\t\tint a = Math.max(blu[i], red[j]);\n\t\tint b = Math.min(blu[i], red[j]);\n\t\twhile(b!=0){\n\t\t\tint tmp=b;\n\t\t\tb= a%b;\n\t\t\ta= tmp;\n\t\t}\n//\t\tSystem.out.printf(\"%d %d -> %d\", blu[i],red[j],a);\n//\t\tSystem.out.println();\n\t\tif(a!=1) return 1;\n\t\telse return 0;\n\t}\n\t\n\tpublic static int rb(int i,int j){\n\t\tmr[j]=-2;\n\t\tdo{\n\t\t\tif(g[i][j]==1){\n\t\t\t\tif(mb[i]==-1 || rb(i+1,mb[i])==1){\n\t\t\t\t\tmb[i]=j;\n\t\t\t\t\tmr[j]=i;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t}while(i<m);\n\t\tmr[j]=-1;\n\t\treturn 0;\n\t}\n\tpublic static int br(int i,int j){\n\t\tmb[i]=-2;\n\t\tdo{\n\t\t\tif(g[i][j]==1){\n\t\t\t\tif(mr[j]==-1 || br(mr[j],j+1)==1){\n\t\t\t\t\tmr[j]=i;\n\t\t\t\t\tmb[i]=j;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj++;\n\t\t}while(j<n);\n\t\tmb[i]=-1;\n\t\treturn 0;\n\t}\n\t\n\tpublic static void main(String args[]) throws Exception{\n\t\tint ans;\n        Scanner cin= new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tans=0;\n\t\t\tm= cin.nextInt();\n\t\t\tn= cin.nextInt();\n\t\t\tif(m==0 && n==0) break;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tblu[i] = cin.nextInt();\n\t\t\t\tmb[i] = -1;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tred[i] = cin.nextInt();\n\t\t\t\tmr[i] = -1;\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tg[i][j] = chk(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mr[i]==-1) ans += rb(0,i);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint m, n;\n\tboolean map[][];\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tm = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\tint[] b = new int[m];\n\t\t\tint[] r = new int[n];\n\t\t\tfor(int i=0;i<m;i++) b[i] = sc.nextInt();\n\t\t\tfor(int j=0;j<n;j++) r[j] = sc.nextInt();\n\t\t\tmap = new boolean[m][n];\n\t\t\tfor(int i=0;i<m;i++) for(int j=0;j<n;j++) {\n\t\t\t\tmap[i][j] = gcd( b[i], r[j] );\n\t\t\t}\n\t\t\tSystem.out.println(matching());\n\t\t}\n\t}\n\t\n\tboolean augument(int u, int[] matchTo, boolean[] visited) {\n\t\tif( u < 0 ) return true;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(map[u][i] & !visited[i]) {\n\t\t\t\tvisited[i] = true;\n\t\t\t\tif( augument(matchTo[i], matchTo, visited) ) {\n\t\t\t\t\tmatchTo[i] = u;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tint matching() {\n\t\tint[] matchTo = new int[n];\n\t\tfill(matchTo, -1);\n\t\tint match = 0;\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tboolean[] visited = new boolean[n];\n\t\t\tif(augument(i, matchTo, visited)) match++;\n\t\t}\n\t\t\n\t\treturn match;\n\t}\n\t\n\tboolean gcd(int x, int y) {\n\t\tif(y==0) {\n\t\t\treturn x != 1;\n\t\t}\n\t\telse return gcd(y, x%y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tint gcd(int a, int b) {\n\t\tif (a > b) {\n\t\t\tint c = a % b;\n\t\t\tif (c == 0) {\n\t\t\t\treturn b;\n\t\t\t} else {\n\t\t\t\treturn gcd(b, c);\n\t\t\t}\n\t\t} else {\n\t\t\tint c = b % a;\n\t\t\tif (c == 0) {\n\t\t\t\treturn a;\n\t\t\t} else {\n\t\t\t\treturn gcd(a, c);\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tNode to;\n\t\tint cap;\n\t\tint flow;\n\n\t\tEdge g;\n\t\tEdge(Node to, int cap, int flow) {\n\t\t\tthis.to = to;\n\t\t\tthis.cap = cap;\n\t\t\tthis.flow = flow;\n\t\t}\n\t\t\n\t\tvoid rrf(int f){\n\t\t\tif(g ==null){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tg.flow -= f;\n\t\t}\n\t}\n\n\tclass Node {\n\t\tint id;\n\n\t\tLinkedList<Edge> e;\n\n\t\tNode(int id) {\n\t\t\tthis.id = id;\n\t\t\te = new LinkedList<Edge>();\n\t\t}\n\t}\n\n\tNode[] all;\n\tboolean[] used;\n\n\tint dfs(Node s,Node t){\n\t\tif(s==t){\n\t\t\treturn 1;\n\t\t}\n\t\tused[s.id] = true;\n\t\t\n\t\tfor(Edge e: s.e){\n\t\t\tif(!used[e.to.id]){\n\t\t\t\tif(e.cap - e.flow >0){\n\t\t\t\t\tint res = dfs(e.to,t);\n\t\t\t\t\tif(res >0){\n\t\t\t\t\t\te.flow++;\n\t\t\t\t\t\te.rrf(1);\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tpublic void run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tNode[] r = new Node[n];\n\t\t\tNode[] b = new Node[m];\n\t\t\tNode source = new Node(n + m);\n\t\t\tNode sink = new Node(n + m + 1);\n\n\t\t\tall = new Node[n + m + 2];\n\t\t\tall[n + m] = source;\n\t\t\tall[n + m + 1] = sink;\n\t\t\tint[] red = new int[n];\n\t\t\tint[] blue = new int[m];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tred[i] = sc.nextInt();\n\t\t\t\tr[i] = new Node(i);\n\n\t\t\t\tall[i] = r[i];\n\t\t\t\tsource.e.add(new Edge(r[i], 1, 0));\n\t\t\t}\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tblue[j] = sc.nextInt();\n\t\t\t\tb[j] = new Node(n + j);\n\n\t\t\t\tall[n + j] = b[j];\n\t\t\t\tb[j].e.add(new Edge(sink, 1, 0));\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (gcd(red[i], blue[j]) >= 2) {\n\t\t\t\t\t\tEdge rb = new Edge(b[j], 1, 0);\n\t\t\t\t\t\tEdge br = new Edge(r[i], 1, 1);\n\t\t\t\t\t\trb.g = br;\n\t\t\t\t\t\tbr.g = rb;\n\t\t\t\t\t\tr[i].e.add(rb);\n\t\t\t\t\t\tb[j].e.add(br);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint sum = 0;\n\t\t\tfor (;;) {\n\t\t\t\tused = new boolean[all.length];\n\t\t\t\tint res = dfs(source,sink);\n\t\t\t\tif (res == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tsum += res;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\n\tpublic static void main(String a[]) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\n\t/* ----------Bipartile Matching--------- */\n\t/* g : The graph which has elements of (n + m).*/\n\tclass BipartileMatching {\n\t\tint V;\n\t\tboolean[] used;\n\t\tint[] match;\n\t\tArrayList<Integer>[] g;\n\t\t\n\t\tBipartileMatching(ArrayList<Integer>[] g) {\n\t\t\tV = g.length;\n\t\t\tused = new boolean[V];\n\t\t\tmatch = new int[V];\n\t\t\tthis.g = g;\n\t\t}\n\t\t\n\t\tboolean dfs(int u) {\n\t\t\tused[u] = true;\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tint w = match[v];\n\t\t\t\tif (w < 0 || (!used[w] && dfs(w))) {\n\t\t\t\t\tmatch[v] = u;\n\t\t\t\t\tmatch[u] = v;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tint doit() {\n\t\t\tint res = 0;\n\t\t\tArrays.fill(match, -1);\n\t\t\tfor (int v = 0; v < V; v++) {\n\t\t\t\tif (match[v] < 0) {\n\t\t\t\t\tArrays.fill(used, false);\n\t\t\t\t\tif (dfs(v)) res++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\t\n\t/* ----------------------------- */\n\t\n\tlong gcd(long x, long y) {\n\t\tif (x == 0 || y == 0) return x + y;\n\t\treturn gcd(y, x % y);\n\t}\n\t\n\tpublic void solve() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt(), m = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tArrayList<Integer>[] g = new ArrayList[n+m];\n\t\t\tfor (int i = 0; i < n + m; i++) {\n\t\t\t\tg[i] = new ArrayList<Integer>();\n\t\t\t}\n\t\t\t\n\t\t\tint[] a = in.nextIntArray(n);\n\t\t\tint[] b = in.nextIntArray(m);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (gcd(a[i], b[j]) != 1) {\n\t\t\t\t\t\tg[i].add(j+n);\n\t\t\t\t\t\tg[j+n].add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tBipartileMatching bm = new BipartileMatching(g);\n\t\t\tSystem.out.println(bm.doit());\n\t\t}\t\t\n\t}\t\n\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO ????????????????????? catch ????????????\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  // constant\n  static final int INF = 1 << 30;\n\n  // subroutines\n  static int gcd(int a, int b) {\n    if (a < b) {\n      int tmp = a; a = b; b = tmp;\n    }\n\n    while (b > 0) {\n      int r = a % b;\n      a = b;\n      b = r;\n    }\n    return a;\n  }\n\n  // main\n  public static final void main(String[] args) throws Exception {\n    Scanner sc = new Scanner(System.in);\n\n    for (;;) {\n      int m = sc.nextInt();\n      int n = sc.nextInt();\n      if ((m | n) == 0) break;\n\n      int[] cbs = new int[m];\n      for (int i = 0; i < m; i++) cbs[i] = sc.nextInt();\n\n      int[] crs = new int[n];\n      for (int i = 0; i < n; i++) crs[i] = sc.nextInt();\n\n      int vn = m + n + 2;\n      int st = m + n;\n      int gl = m + n + 1;\n\n      int[][] edges = new int[vn][vn];\n      int[][] fs = new int[vn][vn];\n      for (int i = 0; i < vn; i++)\n\tfor (int j = 0; j < vn; j++)\n\t  edges[i][j] = fs[i][j] = 0;\n\n      ArrayList<ArrayList<Integer>> nbrs = new ArrayList<ArrayList<Integer>>();\n      for (int i = 0; i < vn; i++)\n\tnbrs.add(new ArrayList<Integer>());\n  \n      for (int i = 0; i < m; i++)\n\tfor (int j = 0; j < n; j++)\n\t  if (gcd(cbs[i], crs[j]) > 1) {\n\t    edges[i][m + j] = 1;\n\t    nbrs.get(i).add(m + j);\n\t    nbrs.get(m + j).add(i);\n\t  }\n\n      for (int i = 0; i < m; i++) {\n\tedges[st][i] = 1;\n\tnbrs.get(st).add(i);\n      }\n\n      for (int j = 0; j < n; j++) {\n\tedges[m + j][gl] = 1;\n\tnbrs.get(m + j).add(gl);\n      }\n\n      int[] prevs = new int[vn];\n      int[] dists = new int[vn];\n      \n      for (;;) {\n\tfor (int i = 0; i < vn; i++) {\n\t  prevs[i] = -1;\n\t  dists[i] = INF;\n\t}\n\tdists[st] = 0;\n\n\tArrayList<Integer> q = new ArrayList<Integer>();\n\tq.add(st);\n\n\twhile (! q.isEmpty()) {\n\t  int u = q.remove(0);\n\t  if (u == gl) break;\n\n\t  for (int v: nbrs.get(u)) {\n\t    if (fs[u][v] == edges[u][v]) continue;\n\t    int vd = dists[u] + 1;\n\t    if (dists[v] > vd) {\n\t      dists[v] = vd;\n\t      prevs[v] = u;\n\t      q.add(v);\n\t    }\n\t  }\n\t}\n\tif (dists[gl] >= INF) break;\n    \n\tArrayList<Integer> path = new ArrayList<Integer>();\n\tint u = gl;\n\twhile (prevs[u] >= 0) {\n\t  path.add(0, u);\n\t  u = prevs[u];\n\t}\n    \n\tint min_c = INF;\n\tu = st;\n\tfor (int v: path) {\n\t  int cf = edges[u][v] - fs[u][v];\n\t  if (min_c > cf) min_c = cf;\n\t  u = v;\n\t}\n\n\tu = st;\n\tfor (int v: path) {\n\t  fs[u][v] += min_c;\n\t  fs[v][u] -= min_c;\n\t  u = v;\n\t}\n      }\n\n      int sum = 0;\n      for (int i = 0; i < m; i++) sum += fs[st][i];\n      System.out.println(sum);\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int[] blue, red;\n    boolean[] usedB;\n    boolean[] usedR;\n    int m, n, pair;\n    boolean[] prime;\n    int[][] canPair;\n\n    void run(){\n\tsetP();\n\twhile(true){\n\t    m = sc.nextInt();\n\t    n = sc.nextInt();\n\t    if(m==0 && n==0) break;\n\n\t    input();\n\t    for(int i=0; i<m; i++)\n\t\tfor(int k=0; k<n; k++){\n\t\t    pair = Math.max(solve(i, k), pair);\n\t\t    //System.out.println(\"------\");\n\t\t}\n\t    System.out.println(pair);\n\t}\n    }\n\n    void input(){\n\tblue = new int[m];\n\tred = new int[n];\n\tfor(int i=0; i<m; i++)\n\t    blue[i] = sc.nextInt();\n\tArrays.sort(blue);\n\tfor(int i=0; i<n; i++)\n\t    red[i] = sc.nextInt();\n\tArrays.sort(red);\n\tpair = 0;\n\tcanPair = new int[m][n];\n    }\n\n    int solve(int sB, int sR){\n\tint tmp = 0;\n\tusedB = new boolean[m];\n\tusedR = new boolean[n];\n\tint i = sB+1==m ? 0:sB+1;\n\tboolean visitB = false;\n\tfor(; !visitB; i++){\n\t    if(i==sB) visitB = true;\n\t    int a = blue[i];\n\n\t    int k = sR+1==n ? 0:sR+1;\n\t    boolean visitR = false;\n\t    for(; !visitR; k++){\n\t\tif(k==sR) visitR = true;\n\t\tint b = red[k];\n\t\tif(canPair[i][k]==-1 || usedR[k] || usedB[i] ||\n\t\t   Math.abs(a-b)==1 || isCont(a, b)){\n\t\t    if(k+1==n) k = -1;\n\t\t    continue;\n\t\t}\n\t\tif(canPair[i][k]==1 || div(i, k)){\n\t\t    tmp++;\n\t\t    usedR[k] = true;\n\t\t    usedB[i] = true;\n\t\t    //System.out.println(a+\" \"+b);\n\t\t    break;\n\t\t}\n\t\tif(k+1==n) k = -1;\n\t    }\n\t    if(i+1==m) i = -1;\n\t}\n\treturn tmp;\n    }\n\n    boolean isCont(int a, int b){\n\tif(a==b) return false;\n\tif(prime[a] && prime[b])\n\t    return a==b ? false : true;\n\tint d = Math.abs(a-b);\n\tif(prime[d] && a%d==0) return false;\n\tif(!prime[d]) return false;\n\treturn true;\n    }\n\n    boolean div(int i, int k){\n\tint b = blue[i];\n\tint r = red[k];\n\tint max = Math.max(b, r);\n\tint d = max;\n\twhile(d!=b*r){\n\t    if(d%b==0 && d%r==0) {\n\t\tcanPair[i][k] = 1;\n\t\treturn true;\n\t    }\n\t    d += max;\n\t}\n\tcanPair[i][k] = -1;\n\treturn false;\n    }\n\n    void setP(){\n\tprime = new boolean[10000000];\n\tArrays.fill(prime, true);\n\tprime[0] = prime[1] = false;\n\tfor(int i=2; i<prime.length; i++)\n\t    if(prime[i])\n\t\tfor(int k=i*2; k<prime.length; k+=i)\n\t\t    prime[k] = false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main{\n\tstatic int[] blu = new int[500];\n\tstatic int[] red = new int[500];\n\tstatic int[][] g = new int[500][500];\n\tstatic int[] mb = new int[500];\n\tstatic int[] mr = new int[500];\n\tstatic int m,n;\n\t\n\tpublic static int chk(int i,int j){\n\t\tint a = Math.max(blu[i], red[j]);\n\t\tint b = Math.min(blu[i], red[j]);\n\t\twhile(b!=0){\n\t\t\tint tmp=b;\n\t\t\tb= a%b;\n\t\t\ta= tmp;\n\t\t}\n\t\tif(a!=1) return -1;\n\t\telse return 0;\n\t}\n\t\n\tpublic static boolean rb(int i,int j){\n\t\tdo{\n\t\t\tif(g[i][j]==-1){\n\t\t\t\tif(mb[i]==-1 || (i+1<m && rb(i+1,mb[i]))){\n\t\t\t\t\tmb[i]=j;\n\t\t\t\t\tmr[j]=i;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}else i+=g[i][j];\n\t\t}while(i<m);\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String args[]) throws Exception{\n\t\tint ans;\n        Scanner cin= new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tans=0;\n\t\t\tm= cin.nextInt();\n\t\t\tn= cin.nextInt();\n\t\t\tif(m==0 && n==0) break;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tblu[i] = cin.nextInt();\n\t\t\t\tmb[i] = -1;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tred[i] = cin.nextInt();\n\t\t\t\tmr[i] = -1;\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tg[i][j] = chk(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint c=1;\n\t\t\t\tfor(int i=m-1;i>=0;i--){\n\t\t\t\t\tif(g[i][j]==-1) c=1;\n\t\t\t\t\telse{\n\t\t\t\t\t\tg[i][j]=c;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mr[i]==-1) if(rb(0,i)) ans++;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport static java.lang.System.*;\n\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\n\npublic class Main {\n\n\tstatic class Node {\n\t\tint id;\n\t\tList<Node> link = new LinkedList<Node>();\n\n\t\tNode(int _id) {\n\t\t\tid = _id;\n\t\t}\n\t}\n\tboolean augment(final Node[] g, int u, int[] matchTo, boolean[] visited) {\n\t\tif (u < 0)\n\t\t\treturn true;\n\t\tfor (Node link : g[u].link)\n\t\t\tif (!visited[link.id]) {\n\t\t\t\tvisited[link.id] = true;\n\t\t\t\tif (augment(g, matchTo[link.id], matchTo, visited)) {\n\t\t\t\t\tmatchTo[u] = link.id;\n\t\t\t\t\tmatchTo[link.id] =u;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\treturn false;\n\t}\n\n\tint bipartiteMatching(final Node[] g, int L) {\n\t\tfinal int n = g.length;\n\t\tint[] matchTo = new int[n];\n\t\tArrays.fill(matchTo, -1);\n\t\tint match = 0;\n\t\tfor (int u = 0; u < L; u++) {\n\t\t\tboolean[] visited = new boolean[n];\n\t\t\tif (augment(g, u, matchTo, visited))\n\t\t\t\t++match;\n\t\t}\n\t\treturn match;\n\t}\n\tint gcd(int a,int b){\n\t\treturn b==0?a:gcd(b,a%b);\n\t}\n\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint m = sc.nextInt(), n = sc.nextInt();\n\t\t\tif (m == 0 && n == 0)return;\n\t\t\tint[] bs = new int[m],rs = new int[n];\n\t\t\tfor (int i = 0; i < m; i++)bs[i] = sc.nextInt();\n\t\t\tfor (int i = 0; i < n; i++)rs[i] = sc.nextInt();\n\n\t\t\tNode[] g=new Node[n+m];\n\t\t\tfor (int i = 0; i < n+m; i++)g[i] =new Node(i);\n\n\t\t\tfor(int i=0;i<m;i++)for(int j=0;j<n;j++){\n\t\t\t\tif(gcd(bs[i],rs[j])>1){\n\t\t\t\t\tg[i].link.add(g[m+j]);\n\t\t\t\t\tg[m+j].link.add(g[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tln(bipartiteMatching(g,m));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tstatic Scanner sc = new Scanner(in);\n\n\t// output lib\n\tstatic final String br = System.getProperty(\"line.separator\");\n\tstatic final String[] asep = new String[] { \"\", \" \", br, br + br };\n\n\tstatic String str(Boolean o) {\n\t\treturn o ? \"YES\" : \"NO\";\n\t}\n\n\t// static String str(Double o){\n\t// return String.format(\"%.8f\",o);\n\t// }\n\tstatic <K, V> String str(Map<K, V> map) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean isFirst = true;\n\t\tfor (Entry<K, V> set : map.entrySet()) {\n\t\t\tif (!isFirst)\n\t\t\t\tsb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\")\n\t\t\t\t\t.append(str(set.getValue()));\n\t\t\tisFirst = false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic <E> String str(Collection<E> list) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean isFirst = true;\n\t\tfor (E e : list) {\n\t\t\tif (!isFirst)\n\t\t\t\tsb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst = false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o) {\n\t\tint depth = _getArrayDepth(o);\n\t\tif (depth > 0)\n\t\t\treturn _strArray(o, depth);\n\t\tClass<?> c = o.getClass();\n\t\tif (c.equals(Boolean.class))\n\t\t\treturn str((Boolean) o);\n\t\t// if(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\n\tstatic int _getArrayDepth(Object o) {\n\t\tif (!o.getClass().isArray() || Array.getLength(o) == 0)\n\t\t\treturn 0;\n\t\treturn 1 + _getArrayDepth(Array.get(o, 0));\n\t}\n\n\tstatic String _strArray(Object o, int depth) {\n\t\tif (depth == 0)\n\t\t\treturn str(o);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0, len = Array.getLength(o); i < len; i++) {\n\t\t\tif (i != 0)\n\t\t\t\tsb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o, i), depth - 1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic void pr(Object... os) {\n\t\tboolean isFirst = true;\n\t\tfor (Object o : os) {\n\t\t\tif (!isFirst)\n\t\t\t\tout.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst = false;\n\t\t}\n\t}\n\n\tstatic void ln() {\n\t\tout.println();\n\t}\n\n\tstatic void ln(Object... os) {\n\t\tfor (Object o : os) {\n\t\t\tpr(o);\n\t\t\tln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tstatic int gcd(int x, int y) {\n\t\tif(x < y) {\n\t\t\tint tmp = x;\n\t\t\tx = y;\n\t\t\ty = tmp;\n\t\t}\n\t\twhile(y > 0) {\n\t\t\tint r = x % y;\n\t\t\tx = y;\n\t\t\ty = r;\n\t\t}\n\t\treturn x;\n\t}\n\t\n\tstatic int bipartiteMatching(boolean[][] can) {\n\t\t// 0..m-1 blue\n\t\t// m..m+n-1 red\n\t\tint m = can.length; // number of blue\n\t\tint n = can[0].length; // number of red\n\t\tint s = n + m, t = s+1;\n\t\tinitGraph(m+n+2);\n\t\t// s to blue\n\t\tfor(int i=0; i<m; i++) {\n\t\t\taddEdge(s, i, 1);\n\t\t}\n\t\t// red to t\n\t\tfor(int i=0; i<n; i++) {\n\t\t\taddEdge(m+i, t, 1);\n\t\t}\n\t\t// blue to red\n\t\tfor(int i=0; i<m; i++) {\n\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\tif(can[i][j]) {\n\t\t\t\t\taddEdge(i, m+j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxFlow(s, t);\n\t}\n\t\n\t// from MaxFlowFordFulkerson.java\n\tstatic int MAX_V = 1000;\n\tstatic int INF = 10000000;\n\tstatic ArrayList<ArrayList<Edge>> G = new ArrayList<ArrayList<Edge>>(MAX_V);\n\tstatic boolean[] used = new boolean[MAX_V];\n\t\n\tstatic void addEdge(int from, int to, int cap) {\n\t\tG.get(from).add(new Edge(to, cap, G.get(to).size()));\n\t\tG.get(to).add(new Edge(from, 0, G.get(from).size()-1));\n\t}\n\t\n\tstatic int dfs(int v, int t, int f) {\n\t\tif(v==t) return f;\n\t\tused[v] = true;\n\t\tfor(int i=0; i<G.get(v).size(); i++) {\n\t\t\tEdge e = G.get(v).get(i);\n\t\t\tif(!used[e.to] && e.cap > 0) {\n\t\t\t\tint d = dfs(e.to, t, Math.min(f, e.cap));\n\t\t\t\tif(d>0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG.get(e.to).get(e.rev).cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tstatic int maxFlow(int s, int t) {\n\t\tint flow = 0;\n\t\tfor(;;) {\n\t\t\tArrays.fill(used, false);\n\t\t\tint f = dfs(s, t, INF);\n\t\t\tif(f==0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n\t\n\tstatic void initGraph(int maxV) {\n\t\tfor(int i=0; i<maxV; i++) {\n\t\t\tG.add(new ArrayList<Edge>());\n\t\t}\n\t}\n\t\n\tstatic void resetGraph() {\n\t\tG = new ArrayList<ArrayList<Edge>>(MAX_V);\n\t\tused = new boolean[MAX_V];\n\t}\n\t\n\tstatic class Edge {\n\t\tint to, cap, rev;\n\t\tEdge(int to, int cap, int rev) {\n\t\t\tthis.to = to; this.cap = cap; this.rev = rev;\n\t\t}\n\t}\n\t\n\tstatic public void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint m = sc.nextInt();\n\t\tint n = sc.nextInt();\n\t\tString ans = \"\";\n\t\twhile(!(n==0 && m==0)) {\n\t\t\tboolean[][] can = new boolean[m][n];\n\t\t\tint[] b = new int[m];\n\t\t\tint[] r = new int[n];\n\t\t\tfor(int i=0; i<m; i++) b[i] = sc.nextInt();\n\t\t\tfor(int i=0; i<n; i++) r[i] = sc.nextInt();\n\t\t\tfor(int i=0; i<m; i++) {\n\t\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\t\tif(gcd(b[i], r[j]) > 1) can[i][j] = true;\n\t\t\t\t\telse can[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += (bipartiteMatching(can)) + \"\\n\";\n\t\t\tresetGraph();\n\t\t\tm = sc.nextInt(); n = sc.nextInt();\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void run() {\n    for (; ; ) {\n      int m = ni();\n      int n = ni();\n      if (n == 0) {\n        break;\n      }\n      ArrayList<HashSet<Integer>> blueSet = new ArrayList<>();\n      ArrayList<HashSet<Integer>> redSet = new ArrayList<>();\n      for (int i = 0; i < m; ++i) {\n        blueSet.add(new HashSet<>());\n      }\n      for (int i = 0; i < n; ++i) {\n        redSet.add(new HashSet<>());\n      }\n      int[] blue = new int[m];\n      for (int i = 0; i < m; ++i) {\n        blue[i] = ni();\n      }\n      int[] red = new int[n];\n      for (int i = 0; i < n; ++i) {\n        red[i] = ni();\n      }\n      for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n          if (gcd(blue[i], red[j]) > 1) {\n            blueSet.get(i).add(j);\n            redSet.get(j).add(i);\n          }\n        }\n      }\n      ArrayList<Node> redList = new ArrayList<>();\n      for (int i = 0; i < n; ++i) {\n        Node node = new Node();\n        node.index = i;\n        node.size = redSet.get(i).size();\n        if(node.size == 0) {\n          node.size = INF;\n        }\n        redList.add(node);\n      }\n      ArrayList<Node> blueList = new ArrayList<>();\n      for (int i = 0; i < m; ++i) {\n        Node node = new Node();\n        node.index = i;\n        node.size = blueSet.get(i).size();\n        if(node.size == 0) {\n          node.size = INF;\n        }\n        blueList.add(node);\n      }\n      Comparator<Node> comp = Comparator.comparingInt(a -> a.size);\n      redList.sort(comp);\n      blueList.sort(comp);\n      int cnt = 0;\n      // min(n, m)\n      for (; ; ) {\n        Node left = redList.get(0);\n        Node right = blueList.get(0);\n        if (left.size == INF && right.size == INF) {\n          break;\n        }\n        if (left.size < right.size) {\n          int index = -1;\n          int min = INF;\n          for (Integer i : redSet.get(left.index)) {\n            if (blueSet.get(i).size() < min) {\n              min = blueSet.get(i).size();\n              index = i;\n            }\n          }\n          for (HashSet<Integer> set : redSet) {\n            set.remove(index);\n          }\n          redSet.get(left.index).clear();\n          for (HashSet<Integer> set : blueSet) {\n            set.remove(left.index);\n          }\n          blueSet.get(index).clear();\n        } else {\n          int index = -1;\n          int min = INF;\n          for (Integer i : blueSet.get(right.index)) {\n            if (redSet.get(i).size() < min) {\n              min = redSet.get(i).size();\n              index = i;\n            }\n          }\n          for (HashSet<Integer> set : redSet) {\n            set.remove(right.index);\n          }\n          redSet.get(index).clear();\n          for (HashSet<Integer> set : blueSet) {\n            set.remove(index);\n          }\n          blueSet.get(right.index).clear();\n        }\n        ++cnt;\n\n        redList = new ArrayList<>();\n        for (int i = 0; i < n; ++i) {\n          Node node = new Node();\n          node.index = i;\n          node.size = redSet.get(i).size();\n          if(node.size == 0) {\n            node.size = INF;\n          }\n          redList.add(node);\n        }\n        blueList = new ArrayList<>();\n        for (int i = 0; i < m; ++i) {\n          Node node = new Node();\n          node.index = i;\n          node.size = blueSet.get(i).size();\n          if(node.size == 0) {\n            node.size = INF;\n          }\n          blueList.add(node);\n        }\n        redList.sort(comp);\n        blueList.sort(comp);\n      }\n      System.out.println(cnt);\n    }\n  }\n\n  class Node {\n    int index;\n    int size;\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\t//get the number of blue cards\n\t\t\tint bnum = sc.nextInt();\n\t\t\t//get the number of red cards\n\t\t\tint rnum = sc.nextInt();\n\t\t\tif(bnum == 0 && rnum == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//reading data\n\t\t\tint[] bmap = new int[bnum];\n\t\t\tint[] rmap = new int[rnum];\n\t\t\tfor(int i = 0; i < bmap.length; i++){\n\t\t\t\tbmap[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i = 0; i < rmap.length; i++){\n\t\t\t\trmap[i] = sc.nextInt();\n\t\t\t}\n\t\n\t\t\t//connection con[blue card] = red card\n\t\t\tint[] con = new int[bnum];\n\t\t\tArrays.fill(con, -1);\n\t\t\t\n\t\t\t//search\n\t\t\tint res = 0;\n\t\t\tfor(int i = 0; i < bmap.length; i++){\n\t\t\t\tif(isMatch(i, bmap, rmap, con, null)){\n\t\t\t\t\tres++;\n\t\t\t\t}\t\t\t\t\t\n\t\t\t}\n\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\t//spos = blue card No.\n\t//smap = blue cards data\n\t//emap = red cards data\n\t//stoe = connections\n\t//excepstoe = list of already searched blue-red connections\n\tstatic boolean isMatch(int spos, int[] smap, int[] emap, int[] stoe, boolean[][] excepstoe){\n\t\tboolean res = false;\n\t\tif(excepstoe == null){\n\t\t\texcepstoe = new boolean[smap.length][emap.length];\n\t\t}\n\n\t\t//loop in red cards\n\t\tfor(int i = 0; i < emap.length; i++){\n\t\t\t//if blue(No. = spos) and red(No. = i) can make pair and red(No. = i) is not fixed \n\t\t\tif(euclid(smap[spos], emap[i]) != 1 && !excepstoe[spos][i]){\n\t\t\t\t//if red card No.i has not been used\n\t\t\t\tif(!isExist(i, stoe)){\n\t\t\t\t\t//then connect and end function\n\t\t\t\t\tres = true;\n\t\t\t\t\tstoe[spos] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\t//if red card has been occupied\n\t\t\t\t\t//then reconnect it to blue(No. = spos)\n\t\t\t\t\t//and let blue card which used to make pair with red(No. = i) find new pair\n\t\t\t\t\t//rewrite the connections map\n\t\t\t\t\tint exstoe = stoe[spos];\n\t\t\t\t\tstoe[spos] = i;\n\n\t\t\t\t\t//mark the connection blue card (No. spos) to red card (No. i)\n\t\t\t\t\t//so as not to search repeatedly\n\t\t\t\t\texcepstoe[spos][i] = true;\n\t\t\t\t\t\n\t\t\t\t\t//find new pair\n\t\t\t\t\texcepstoe[spos][i] = true;\n\t\t\t\t\tif(isMatch(findpos(i, stoe), smap, emap, stoe, excepstoe)){\n\t\t\t\t\t\t//if new pair found\n\t\t\t\t\t\t//then save the connections and end function\n\t\t\t\t\t\tres = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t//restore the stoe(connections map)\n\t\t\t\t\t\tstoe[spos] = exstoe;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\t//whether the two cards can make pair\n\tstatic int euclid(int e1, int e2){\n\t\tint a = Math.min(e1, e2);\n\t\tint b = Math.max(e1, e2);\n\n\t\tint r = b % a;\n\t\tif(r != 0){\n\t\t\treturn euclid(a, r);\n\t\t}else{\n\t\t\treturn a;\n\t\t}\n\t}\n\n\tstatic boolean isExist(int v, int[] arr){\n\t\tboolean res = false;\n\t\tif (arr == null){\n\t\t\treturn false;\n\t\t}\n\n\t\tfor(int e : arr){\n\t\t\tif(v == e){\n\t\t\t\tres = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tstatic int findpos(int v, int[] arr){\n\t\tint res = -1;\n\t\tfor(int i = 0; i < arr.length; i++){\n\t\t\tif (v == arr[i]){\n\t\t\t\tres = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.util.stream.Collectors;\n\n@SuppressWarnings(\"unused\")\npublic class Main {\n\t\n\t//final boolean isDebug = true;\n\tfinal boolean isDebug = false;\n\tString fileName = \"input.txt\";\n\tFastScanner sc;\n\tPrintWriter out;\n\tfinal int MOD = (int)1e9+7;\n\tfinal int INF = Integer.MAX_VALUE / 2;\n\t\n\tvoid solve() throws Exception{\n\t\twhile(true){\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(m == 0 && n == 0) break;\n\t\t\tcalc(m, n);\n\t\t}\n\t}\n\t\n\tvoid calc(int m, int n){\n\t\tint s = 0, t = m+n+1;\n\t\tint[] b = new int[m+1];\n\t\tint[] r = new int[n+1];\n\t\tDinic dinic = new Dinic(m+n+2);\n\t\t\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tb[i] = sc.nextInt();\n\t\t\tdinic.addEdge(s, i, 1);\n\t\t}\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tr[i] = sc.nextInt();\n\t\t\tdinic.addEdge(m+i, t, 1);\n\t\t\tfor(int j = 1; j <= m; j++) if(gcd(b[j], r[i]) != 1) dinic.addEdge(j, m+i, 1);\n\t\t}\n\t\t\n\t\tSystem.out.println(dinic.maxFlow(s, t));\n\t}\n\t\n\tlong gcd(long a, long b){\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\t/* end solve */\n\t\n\t/* main */\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().m();\n\t}\n\t\n\tvoid m() throws Exception {\n\t\tlong S = System.currentTimeMillis();\n\t\tsc = (isDebug) ? new FastScanner(new FileInputStream(fileName)) : new FastScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\tif(isDebug){\n\t\t\tSystem.out.println(\"---Debug---\");\n\t\t\tSystem.out.printf(\"%8d ms\", (G-S));\n\t\t}\n\t}\n\t/* end main */\n}\n/* end Main */\n\nclass Dinic{\n\tclass Edge{\n\t\tint to;\n\t\tlong cap;\n\t\tint rev;\n\t\tboolean isRev;\n\t\tpublic Edge(int t, long c, int r, boolean i){\n\t\t\tto = t; cap = c; rev = r; isRev = i;\n\t\t}\n\t}\n\t\n\tint V;\n\tArrayList<ArrayList<Edge>> graph;\n\tint[] minCost, iter;\n\t\n\tpublic Dinic(int V){\n\t\tthis.V = V;\n\t\tgraph = new ArrayList<>();\n\t\tfor(int i = 0; i < V; i++) graph.add(new ArrayList<>());\n\t\tminCost = new int[V];\n\t\titer = new int[V];\n\t}\n\t\n\tvoid addEdge(int from, int to, long cap){\n\t\tgraph.get(from).add(new Edge(to, cap, graph.get(to).size(), false));\n\t\tgraph.get(to).add(new Edge(from, 0, graph.get(from).size()-1, true));\n\t}\n\t\n\tboolean bfs(int s, int t){\n\t\tArrays.fill(minCost, -1);\n\t\tDeque<Integer> queue = new ArrayDeque<Integer>();\n\t\tminCost[s] = 0;\n\t\tqueue.addLast(s);\n\t\twhile(!queue.isEmpty() && minCost[t] == -1){\n\t\t\tint p = queue.getFirst();\n\t\t\tqueue.pop();\n\t\t\tfor(Edge e : graph.get(p)){\n\t\t\t\tif(e.cap > 0 && minCost[e.to] == -1){\n\t\t\t\t\tminCost[e.to] = minCost[p] + 1;\n\t\t\t\t\tqueue.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn minCost[t] != -1;\n\t}\n\t\n\tlong dfs(int index, int t, long flow){\n\t\tif(index == t) return flow;\n\t\tfor(int i = iter[index]; i < graph.get(index).size(); i++){\n\t\t\tEdge e = graph.get(index).get(i);\n\t\t\tif(e.cap > 0 && minCost[index] < minCost[e.to]){\n\t\t\t\tlong d = dfs(e.to, t, Math.min(flow, e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tgraph.get(e.to).get(e.rev).cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tlong maxFlow(int s, int t){\n\t\tlong flow = 0;\n\t\twhile(bfs(s, t)){\n\t\t\tArrays.fill(iter, 0);\n\t\t\tlong f = 0;\n\t\t\twhile((f = dfs(s, t, Long.MAX_VALUE / 2)) > 0) flow += f;\n\t\t}\n\t\treturn flow;\n\t}\n\t\n\tvoid output(){\n\t\tfor(int i = 0; i < graph.size(); i++){\n\t\t\tfor(Edge e : graph.get(i)){\n\t\t\t\tif(e.isRev) continue;\n\t\t\t\tEdge revEdge = graph.get(e.to).get(e.rev);\n\t\t\t\tSystem.out.println(i + \" -> \" + e.to + \" (flow: \" + revEdge.cap + \" / \" + (e.cap + revEdge.cap) + \")\");\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass FastScanner {\n    private InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    public FastScanner(InputStream in) {\n\t\tthis.in = in;\n\t}\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() {\n    \tif (hasNextByte()) return buffer[ptr++];\n    \telse return -1;\n    }\n    private static boolean isPrintableChar(int c){\n    \treturn 33 <= c && c <= 126;\n    }\n    public boolean hasNext() {\n    \twhile(hasNextByte() && !isPrintableChar(buffer[ptr]))\n    \t\tptr++; return hasNextByte();\n    }\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public String nextLine() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(b != 10) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n    public double nextDouble() {\n    \treturn Double.parseDouble(next());\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n\t\n\tMyScanner sc;\n\tPrintWriter writer;\n\t\n\tclass DirectedGraph {\n\t\tList<Vertex> vertices;\n\t\tpublic DirectedGraph(int num) {\n\t\t\tvertices = new ArrayList<Vertex>(num);\n\t\t\tfor (int i = 0; i < num; i++) {\n\t\t\t\tvertices.add(new Vertex(i));\n\t\t\t}\n\t\t}\n\t\tpublic void addEdge(int from, int to, int capacity) {\n\t\t\tvertices.get(from).addEdge(vertices.get(to), capacity);\n\t\t}\n\t\tprivate List<Edge> path;\n\t\tprivate boolean[] searched;\n\t\tprivate boolean findAugmentedPath(Vertex v, Vertex sink) {\n\t\t\tif (v == sink) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tsearched[v.key] = true;\n\t\t\tfor (Edge e : v.edges) {\n\t\t\t\tif (e.residual > 0 && !searched[e.to.key]) {\n\t\t\t\t\tif (findAugmentedPath(e.to, sink)) {\n\t\t\t\t\t\tpath.add(e);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tprivate int augmentedPathFlow() {\n\t\t\tint flow = Integer.MAX_VALUE;\n\t\t\tfor (Edge e : path) {\n\t\t\t\tflow = Math.min(flow, e.residual);\n\t\t\t}\n\t\t\tfor (Edge e : path) {\n\t\t\t\te.residual -= flow;\n\t\t\t\te.reverse.residual += flow;\n\t\t\t}\n\t\t\treturn flow;\n\t\t}\n\t\tpublic int maxFlow(Vertex source, Vertex sink) {\n\t\t\tint flow = 0;\n\t\t\tpath = new ArrayList<Edge>();\n\t\t\tsearched = new boolean[vertices.size()];\n\t\t\twhile (findAugmentedPath(source, sink)) {\n\t\t\t\tflow += augmentedPathFlow();\n\t\t\t\tpath = new ArrayList<Edge>();\n\t\t\t\tsearched = new boolean[vertices.size()];\n\t\t\t}\n\t\t\treturn flow;\n\t\t}\n\t}\n\n\tclass Vertex {\n\t\tint key;\n\t\tList<Edge> edges;\n\t\tpublic Vertex() {\n\t\t\tedges = new ArrayList<Edge>();\n\t\t}\n\t\tpublic Vertex(int key) {\n\t\t\tthis.key = key;\n\t\t\tedges = new ArrayList<Edge>();\n\t\t}\n\t\tpublic void addEdge(Vertex to, int capacity) {\n\t\t\tEdge e1 = new Edge(this, to, capacity);\n\t\t\tEdge e2 = new Edge(to, this, 0);\n\t\t\te1.reverse = e2;\n\t\t\te2.reverse = e1;\n\t\t\tedges.add(e1);\n\t\t\tto.edges.add(e2);\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tVertex from, to;\n\t\tint capacity, flow, residual;\n\t\tEdge reverse;\n\t\tpublic Edge(Vertex from, Vertex to, int capacity) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.capacity = capacity;\n\t\t\tresidual = capacity;\n\t\t\tflow = 0;\n\t\t}\n\t}\n\n\t\n\tprivate int gcd(int a, int b) {\n\t\tint max = Math.max(a, b);\n\t\tint min = Math.min(a, b);\n\t\tif (min == 1) {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (max % min == 0) {\n\t\t\t\treturn min;\n\t\t\t} else {\n\t\t\t\treturn gcd(min, max % min);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void solve() {\n\t\twhile(true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif (m == 0 && n == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[] b = sc.nextIntArray(m);\n\t\t\tint[] r = sc.nextIntArray(n);\n\t\t\tDirectedGraph graph = new DirectedGraph(m + n + 2);\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tgraph.addEdge(m + n, i, 1); // from the source to the blues\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (gcd(b[i], r[j]) > 1) {\n\t\t\t\t\t\tgraph.addEdge(i, m + j, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tgraph.addEdge(m + i, m + n + 1, 1); // from the reds to the terminal\n\t\t\t}\n\t\t\twriter.println(graph.maxFlow(graph.vertices.get(m + n), graph.vertices.get(m + n + 1)));\n\t\t}\n\t}\n\n\tpublic Main() {\n\t\tsc = new MyScanner(System.in);\n\t\twriter = new PrintWriter(System.out);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.solve();\n\t\tm.writer.flush();\n\t}\n\n\tclass MyScanner {\n\t\tInputStream is;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int bufferPointer = 0;\n\t\tprivate int bufferLength = 0;\n\n\t\tMyScanner(InputStream is) {\n\t\t\tthis.is = is;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (bufferLength == -1) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (bufferPointer >= bufferLength) {\n\t\t\t\tbufferPointer = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbufferLength = is.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (bufferLength <= -1) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tString next() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (isChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\tint b = skip();\n\t\t\treturn (char) b;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tint nextInt() {\n\t\t\tint num = 0;\n\t\t\tint b;\n\t\t\tboolean negative = false;\n\t\t\twhile ((b = readByte()) != -1 && !isDigit(b) && b != '-')\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tnegative = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif (isDigit(b)) {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn negative ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int length) {\n\t\t\tint[] array = new int[length];\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tarray[i] = sc.nextInt();\n\t\t\t}\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\tlong num = 0;\n\t\t\tint b;\n\t\t\tboolean negative = false;\n\t\t\twhile ((b = readByte()) != -1 && !isDigit(b) && b != '-')\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tnegative = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif (isDigit(b)) {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn negative ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\t// from '!' to '~'\n\t\tprivate boolean isChar(int b) {\n\t\t\treturn b >= 33 && b <= 126;\n\t\t}\n\n\t\tprivate boolean isDigit(int b) {\n\t\t\treturn b >= '0' && b <= '9';\n\t\t}\n\n\t\tprivate int skip() {\n\t\t\tint b;\n\t\t\twhile ((b = readByte()) != -1 && !isChar(b))\n\t\t\t\t;\n\t\t\treturn b;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Scanner;\n\nclass Solve{\n\tScanner in = new Scanner(System.in);\n\t\n\tint[][] cap;\n\tint m, n;\n\tboolean solve(){\n\t\tm = in.nextInt();\n\t\tn = in.nextInt();\n\t\tif(n == 0) return false;\n\t\tNode[] b = new Node[m];\n\t\tNode[] r = new Node[n];\n\t\tcap = new int[m+n+2][m+n+2];\n\t\tNode s = new Node(n+m, 0);\n\t\tNode t = new Node(n+m+1, 0);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tb[i] = new Node(i, in.nextInt());\n\t\t\ts.createEdge(b[i]);\n\t\t\tcap[s.id][b[i].id] = 1;\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tr[i] = new Node(i+m, in.nextInt());\n\t\t\tr[i].createEdge(t);\n\t\t\tcap[r[i].id][t.id] = 1;\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(gcd(b[i].val, r[j].val) == 1) continue;\n\t\t\t\tb[i].createEdge(r[j]);\n\t\t\t\tcap[i][r[j].id] = 1;\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\twhile(true){\n\t\t\tused.clear();\n\t\t\tint flow = flow(s, 10000);\n\t\t\tif(flow == 0) break;\n\t\t\tres += flow;\n\t\t}\n\t\tSystem.out.println(res);\n\t\treturn true;\n\t}\n\t\n\tBitSet used = new BitSet();\n\tint flow(Node from, int flow){\n\t\tif(from.id == m+n+1) return flow;\n\t\tif(used.get(from.id)) return 0;\n\t\tused.set(from.id);\n\t\tfor(Node v: from.edge){\n\t\t\tif(cap[from.id][v.id]==0) continue;\n\t\t\tint f = flow(v, Math.min(flow, cap[from.id][v.id]));\n\t\t\tif(f == 0) continue;\n\t\t\tcap[from.id][v.id] -= f;\n\t\t\tcap[v.id][from.id] += f;\n\t\t\treturn f;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint gcd(int a, int b){\n\t\treturn b==0 ? a : gcd(b, a%b);\n\t}\n}\n\nclass Node{\n\tint id;\n\tint val;\n\tArrayList<Node> edge = new ArrayList<Node>();\n\tNode(int id, int val){\n\t\tthis.id = id;\n\t\tthis.val = val;\n\t}\n\t\n\tvoid createEdge(Node nd){\n\t\tedge.add(nd);\n\t}\n}\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tSolve slv = new Solve();\n\t\twhile(slv.solve());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint M = sc.nextInt();\n\t\t\tif (M == 0) break;\n\t\t\tint N = sc.nextInt();\n\t\t\tint[] B = new int[M];\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tB[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint[] R = new int[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tR[i] = sc.nextInt();\n\t\t\t}\n\t\t\tBiMatching bm = new BiMatching(M, N);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tif (gcd(B[i], R[j]) != 1) bm.addEdge(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(bm.matching());\n\t\t}\n\t}\n\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\n\tstatic class BiMatching {\n\t\tArrayList<ArrayList<Integer>> left = new ArrayList<ArrayList<Integer>>();\n\t\tArrayList<ArrayList<Integer>> right = new ArrayList<ArrayList<Integer>>();\n\t\tint[] l2r, r2l;\n\n\t\tBiMatching(int n, int m) {\n\t\t\tl2r = new int[n];\n\t\t\tr2l = new int[m];\n\t\t\tArrays.fill(l2r, -1);\n\t\t\tArrays.fill(r2l, -1);\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tleft.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tright.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t}\n\n\t\tvoid addEdge(int ln, int rn) {\n\t\t\tleft.get(ln).add(rn);\n\t\t\tright.get(rn).add(ln);\n\t\t}\n\n\t\tint matching() {\n\t\t\tint res = 0;\n\t\t\tfor (int i = 0; i < left.size(); ++i) {\n\t\t\t\tif (l2r[i] != -1) continue;\n\t\t\t\tboolean[] visited = new boolean[right.size()];\n\t\t\t\tfor (int j = 0; j < left.get(i).size(); ++j) {\n\t\t\t\t\tif (dfs(left.get(i).get(j), visited)) {\n\t\t\t\t\t\tl2r[i] = left.get(i).get(j);\n\t\t\t\t\t\tr2l[left.get(i).get(j)] = i;\n\t\t\t\t\t\t++res;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tboolean dfs(int rn, boolean[] visited) {\n\t\t\tint l = r2l[rn];\n\t\t\tif (l == -1) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvisited[rn] = true;\n\t\t\tfor (int i = 0; i < left.get(l).size(); ++i) {\n\t\t\t\tint r = left.get(l).get(i);\n\t\t\t\tif (visited[r]) continue;\n\t\t\t\tif (dfs(r, visited)) {\n\t\t\t\t\tr2l[r] = l;\n\t\t\t\t\tl2r[l] = r;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Cards\npublic class Main{\n\n\tstatic int[] bipartiteMatching(boolean[][] graph) {\n\t\tint n = graph.length;\n\t\tif(n==0)return new int[0];\n\t\tint m = graph[0].length;\n\t\tint[] match = new int[m];\n\t\tArrays.fill(match, -1);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tboolean[] visited = new boolean[m];\n\t\t\tif (go(i,graph,visited,match)) res++;\n\t\t}\n\t\treturn match;\n\t}\n\tstatic boolean go(int v,boolean[][] graph,boolean[] visited,int[] match) {\n\t\tint m = graph[0].length;\n\t\tfor (int i = 0; i < m; i++)  if (!visited[i] && graph[v][i] && match[i] == -1) {\n\t\t\tvisited[i] = true;\n\t\t\tmatch[i] = v;\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i = 0; i < m; i++) if (!visited[i] && graph[v][i]) {\n\t\t\tvisited[i] = true;\n\t\t\tif (go(match[i],graph,visited,match)) {\n\t\t\t\tmatch[i] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic static long gcd(long a, long b){\n\t\tif(a < b){\n\t\t\tlong tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t\twhile(b!=0){\n\t\t\tlong r = a%b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tint[] blue = new int[n];\n\t\t\tint[] red = new int[m];\n\t\t\tfor(int i=0;i<n;i++)blue[i]=sc.nextInt();\n\t\t\tfor(int j=0;j<m;j++)red[j]=sc.nextInt();\n\t\t\tboolean[][] match = new boolean[n][m];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t\tmatch[i][j] = gcd(blue[i], red[j]) >= 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] r = bipartiteMatching(match);\n\t\t\tint s = 0;\n\t\t\tfor(int i:r)s+=i==-1?0:1;\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    int INF = Integer.MAX_VALUE;\n\n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\n\twhile(true){\n\t    int m = sc.nextInt();\n\t    int n = sc.nextInt();\n\t    if(m==0 && n==0) break;\n\n\t    int[] b = new int[m];\n\t    int[] r = new int[n];\n\t    for(int i=0; i<m; i++) b[i] = sc.nextInt();\n\t    for(int i=0; i<n; i++) r[i] = sc.nextInt();\n\n\t    V[] graph = new V[n+m+2];\n\t    for(int i=0; i<n+m+2; i++) graph[i] = new V();\n\n\t    for(int i=0; i<m; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t    int n1 = Math.max(b[i], r[j]);\n\t\t    int n2 = Math.min(b[i], r[j]);\n\t\t    int gcd = n1;\n\t\t    while(gcd%n2!=0) gcd += n1;\n\t\t    int lcm = n1*n2/gcd;\n\t\t    if(lcm!=1){\n\t\t\tgraph[i].add(graph[j+m], 1);\n\t\t\t//graph[j+n].add(graph[i], 1);\n\t\t    }\n\t\t}\n\t    }\n\n\t    int s = n+m;\n\t    int t = n+m+1;\n\t    for(int i=0; i<m; i++){\n\t\tgraph[s].add(graph[i], 1);\n\t    }\n\t    for(int i=0; i<n; i++){\n\t\tgraph[m+i].add(graph[t], 1);\n\t    }\n\t    int ans = dinic(graph[s], graph[t]);\n\t    System.out.println(ans);\n\t}\n    }\n\n\n    int dinic(V s, V t){\n\tint flow = 0;\n\tfor(int p=1;  ; p++){\n\t    Queue<V> que = new LinkedList<V>();\n\t    s.level = 0;\n\t    s.p = p;\n\t    que.offer(s);\n\t    while(!que.isEmpty()){\n\t\tV v = que.poll();\n\t\tv.iter = v.es.size() - 1;\n\t\tfor(E e : v.es) if(e.to.p < p && e.cap > 0){\n\t\t\te.to.level = v.level + 1;\n\t\t\te.to.p = p;\n\t\t\tque.offer(e.to);\n\t\t    }\n\t    }\n\t    if(t.p < p) return flow;\n\t    for(int f; (f=dfs(s, t, INF)) > 0; ) flow += f;\n\t}\n    }\n\n    int dfs(V v, V t, int f){\n\tif(v==t) return f;\n\tfor(; v.iter >= 0; v.iter--){\n\t    E e = v.es.get(v.iter);\n\t    if(v.level < e.to.level && e.cap > 0){\n\t\tint d = dfs(e.to, t, Math.min(f, e.cap));\n\t\tif(d > 0){\n\t\t    e.cap -= d;\n\t\t    e.rev.cap += d;\n\t\t    return d;\n\t\t}\n\t    }\n\t}\n\treturn 0;\n    }\n\t\n    class V{\n\tArrayList<E> es = new ArrayList<E>();\n\tint level, p, iter;\n\tvoid add(V to, int cap){\n\t    E e = new E(to, cap), rev = new E(this, 0);\n\t    e.rev = rev; rev.rev = e;\n\t    es.add(e); to.es.add(rev);\n\t}\n    }\n\n    class E{\n\tV to;\n\tE rev;\n\tint cap;\n\tE(V to, int cap) {\n\t    this.to = to;\n\t    this.cap = cap;\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    int[] blue, red;\n    boolean[] usedB;\n    boolean[] usedR;\n    int m, n, pair;\n    boolean[] prime;\n    int[][] canPair;\n\n    void run(){\n\tsetP();\n\twhile(true){\n\t    m = sc.nextInt();\n\t    n = sc.nextInt();\n\t    if(m==0 && n==0) break;\n\n\t    input();\n\t    for(int i=0; i<m; i++)\n\t\tfor(int k=0; k<n; k++){\n\t\t    pair = Math.max(solve(i, k), pair);\n\t\t    //System.out.println(\"------\");\n\t\t}\n\t    System.out.println(pair);\n\t}\n    }\n\n    void input(){\n\tblue = new int[m];\n\tred = new int[n];\n\tfor(int i=0; i<m; i++)\n\t    blue[i] = sc.nextInt();\n\tArrays.sort(blue);\n\tfor(int i=0; i<n; i++)\n\t    red[i] = sc.nextInt();\n\tArrays.sort(red);\n\tpair = 0;\n\tcanPair = new int[m][n];\n    }\n\n    int solve(int sB, int sR){\n\tint tmp = 0;\n\tusedB = new boolean[m];\n\tusedR = new boolean[n];\n\tint i = sB+1==m ? 0:sB+1;\n\tboolean visitB = false;\n\tfor(; !visitB; i++){\n\t    if(i==sB) visitB = true;\n\t    int a = blue[i];\n\n\t    int k = sR+1==n ? 0:sR+1;\n\t    boolean visitR = false;\n\t    for(; !visitR; k++){\n\t\tif(k==sR) visitR = true;\n\t\tint b = red[k];\n\t\tif(canPair[i][k]==-1 || usedR[k] || usedB[i] ||\n\t\t   Math.abs(a-b)==1 || isCont(a, b)){\n\t\t    if(k+1==n) k = -1;\n\t\t    continue;\n\t\t}\n\t\tif(canPair[i][k]==1 || div(i, k)){\n\t\t    tmp++;\n\t\t    usedR[k] = true;\n\t\t    usedB[i] = true;\n\t\t    //System.out.println(a+\" \"+b);\n\t\t    break;\n\t\t}\n\t\tif(k+1==n) k = -1;\n\t    }\n\t    if(i+1==m) i = -1;\n\t}\n\treturn tmp;\n    }\n\n    boolean isCont(int a, int b){\n\tif(a==b) return false;\n\tif(prime[a] && prime[b])\n\t    return a==b ? false : true;\n\tint d = Math.abs(a-b);\n\tif(prime[d] && a%d==0) return false;\n\tif(!prime[d]) return false;\n\treturn true;\n    }\n\n    boolean div(int i, int k){\n\tint b = blue[i];\n\tint r = red[k];\n\tint max = Math.max(b, r);\n\tint d = max;\n\twhile(d!=b*r){\n\t    if(d%b==0 && d%r==0) {\n\t\tcanPair[i][k] = 1;\n\t\tint x = i+1;\n\t\twhile(x<blue.length && blue[x]==blue[i]){\n\t\t    canPair[x][k] = 1;\n\t\t    x++;\n\t\t}\n\t\t/*\n\t\tx = i-1;\t\n\t\twhile(x>=0 && blue[x]==blue[i]){\n\t\t    canPair[x][k] = 1;\n\t\t    x--;\n\t\t}\n\t\t*/\n\t\tint y = k+1;\n\t\twhile(y<red.length && red[y]==red[k]){\n\t\t    canPair[i][y] = 1;\n\t\t    y++;\n\t\t}\n\t\t/*\n\t\ty = k-1;\n\t\twhile(y>=0 && red[y]==red[k]){\n\t\t    canPair[i][y] = 1;\n\t\t    y--;\n\t\t}\n\t\t*/\n\t\treturn true;\n\t    }\n\t    d += max;\n\t}\n\tcanPair[i][k] = -1;\n\treturn false;\n    }\n\n    void setP(){\n\tprime = new boolean[10000000];\n\tArrays.fill(prime, true);\n\tprime[0] = prime[1] = false;\n\tfor(int i=2; i<prime.length; i++)\n\t    if(prime[i])\n\t\tfor(int k=i*2; k<prime.length; k+=i)\n\t\t    prime[k] = false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigDecimal;\nimport java.util.*;\n\n\npublic class Main {\n\tpublic static void main(String[] args) {\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tint m = sc.nextInt();\n\t\t\tint n = sc.nextInt();\n\t\t\tif(m == 0 && n == 0) break;\n\t\t\tint[] b = new int[m];\n\t\t\tint[] r = new int[n];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tr[i] = sc.nextInt();\n\t\t\t}\n\t\t\tMaximumFlow mf = new MaximumFlow(m+n+2,m+n,m+n+1);\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tmf.addEdge(m+n, i, 1);\n\t\t\t}\n\t\t\tfor(int i = m; i < m + n; i++) {\n\t\t\t\tmf.addEdge(i, m+n+1, 1);\n\t\t\t}\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tboolean ok = gcd(b[i],r[j])==1?false:true;\n\t\t\t\t\tif(ok) {\n\t\t\t\t\t\tmf.addEdge(i, m + j, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = mf.fordFulkerson();\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\t\n\t}\n\tstatic int gcd(int a, int b) {\n\t\tif(a < b) return gcd(b,a);\n\t\tif(b == 0) return a;\n\t\treturn gcd(b,a%b);\n\t}\n\t\n}\nclass MaximumFlow {\n\tpublic static final int INF = 100000000;\n\n\tint V;\n\tint source;\n\tint sink;\n\n\tjava.util.ArrayList<Edge>[] graph;\n\tboolean[] used;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic MaximumFlow(int V, int source, int sink) {\n\t\tthis.V = V;\n\t\tthis.source = source;\n\t\tthis.sink = sink;\n\t\tgraph = new java.util.ArrayList[V];\n\t\tfor (int i = 0; i < V; i++) {\n\t\t\tgraph[i] = new java.util.ArrayList<Edge>();\n\t\t}\n\t\tused = new boolean[V];\n\t}\n\n\tpublic void addEdge(int from, int to, int cap) {\n\t\tgraph[from].add(new Edge(to, cap, graph[to].size()));\n\t\tgraph[to].add(new Edge(from, 0, graph[from].size() - 1));\n\t}\n\n\tpublic int fordFulkerson() {\n\t\tint flow = 0;\n\t\twhile (true) {\n\t\t\tjava.util.Arrays.fill(used, false);\n\t\t\tint f = dfsFF(source, sink, INF);\n\t\t\tif (f == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflow += f;\n\t\t}\n\t\treturn flow;\n\t}\n\n\tprivate int dfsFF(int from, int to, int flow) {\n\t\tif (from == to) {\n\t\t\treturn flow;\n\t\t}\n\t\tused[from] = true;\n\n\t\tfor (Edge edge : graph[from]) {\n\t\t\tif (used[edge.to] || edge.cap <= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint d = dfsFF(edge.to, to, Math.min(flow, edge.cap));\n\t\t\tif (d > 0) {\n\t\t\t\tedge.cap -= d;\n\t\t\t\tgraph[edge.to].get(edge.rev).cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tclass Edge {\n\t\tint to;\n\t\tint cap;\n\t\tint rev;\n\n\t\tpublic Edge(int to, int cap, int rev) {\n\t\t\tthis.to = to;\n\t\t\tthis.cap = cap;\n\t\t\tthis.rev = rev;\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.*;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main{\n\tstatic int[] blu = new int[500];\n\tstatic int[] red = new int[500];\n\tstatic int[][] g = new int[500][500];\n\tstatic int[] mb = new int[500];\n\tstatic int[] mr = new int[500];\n\tstatic int m,n;\n\t\n\tpublic static int chk(int i,int j){\n\t\tint a = Math.max(blu[i], red[j]);\n\t\tint b = Math.min(blu[i], red[j]);\n\t\twhile(b!=0){\n\t\t\tint tmp=b;\n\t\t\tb= a%b;\n\t\t\ta= tmp;\n\t\t}\n\t\tif(a!=1) return -1;\n\t\telse return 0;\n\t}\n\t\n\tpublic static boolean rb(int i,int j){\n\t\tfor(int ii=i;ii<m;ii++){\n\t\t\tif(g[ii][j]==-1){\n\t\t\t\tif(mb[ii]==-1){\n\t\t\t\t\tmb[ii]=j;\n\t\t\t\t\tmr[j]=ii;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdo{\n\t\t\tif(g[i][j]==-1){\n\t\t\t\tif(mb[i]==-1 || (i+1<m && rb(i+1,mb[i]))){\n\t\t\t\t\tmb[i]=j;\n\t\t\t\t\tmr[j]=i;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t}else i+=g[i][j];\n\t\t}while(i<m);\n\t\treturn false;\n\t}\n\t\n\tpublic static void main(String args[]) throws Exception{\n\t\tint ans;\n        Scanner cin= new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tans=0;\n\t\t\tm= cin.nextInt();\n\t\t\tn= cin.nextInt();\n\t\t\tif(m==0 && n==0) break;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tblu[i] = cin.nextInt();\n\t\t\t\tmb[i] = -1;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tred[i] = cin.nextInt();\n\t\t\t\tmr[i] = -1;\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tg[i][j] = chk(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tint c=1;\n\t\t\t\tfor(int i=m-1;i>=0;i--){\n\t\t\t\t\tif(g[i][j]==-1) c=1;\n\t\t\t\t\telse{\n\t\t\t\t\t\tg[i][j]=c;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n/*\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\t\tif(g[i][j]==-1 && mb[i]==-1){\n\t\t\t\t\t\tmb[i]=j;\n\t\t\t\t\t\tmr[j]=i;\n\t\t\t\t\t\tans++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}*/\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(mr[i]==-1 && rb(0,i)) ans++;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\nimport java.util.Collections;\nimport java.util.Arrays;\n\npublic class Main {\n\tpublic static class Dinic {\n\t\tpublic int N;\n\t\tpublic int INF = 1 << 29;\n\t\tpublic int[] eadj, eprev, elast;\n\t\tpublic int eidx;\n\t\tprivate int[] flow, capa, now;\n\n\t\tpublic void init(int _N, int M) {\n\t\t\tN = _N;\n\t\t\teadj  = new int[M];\n\t\t\teprev = new int[M];\n\t\t\telast = new int[N];\n\t\t\tflow  = new int[M];\n\t\t\tcapa  = new int[M];\n\t\t\tnow   = new int[N];\n\t\t\tlevel = new int[N];\n\t\t\teidx  = 0;\n\t\t\tArrays.fill(elast, -1);\n\t\t}\n\n\t\tprivate void add_edge(int a, int b, int c) {\n\t\t\teadj[eidx] = b;\n\t\t\tflow[eidx] = 0;\n\t\t\tcapa[eidx] = c;\n\t\t\teprev[eidx] = elast[a];\n\t\t\telast[a] = eidx++;\n\t\t\teadj[eidx] = a;\n\t\t\tflow[eidx] = c;\n\t\t\tcapa[eidx] = c;\n\t\t\teprev[eidx] = elast[b];\n\t\t\telast[b] = eidx++;\n\t\t}\n\n\t\tpublic int dinic(int source, int sink) {\n\t\t\tint res, flow = 0;\n\t\t\twhile(bfs(source, sink)) {\n\t\t\t\tSystem.arraycopy(elast, 0, now, 0, N);\n\t\t\t\twhile((res = dfs(source, INF, sink)) > 0) flow+=res;\n\t\t\t}\n\t\t\treturn flow;\n\t\t}\n\n\t\tprivate int[] level;\n\n\t\tprivate boolean bfs(int source, int sink) {\n\t\t\tArrays.fill(level, -1);\n\t\t\tint front = 0;\n\t\t\tint back = 0;\n\t\t\tint[] queue = new int[N];\n\t\t\tlevel[source] = 0;\n\t\t\tqueue[back++] = source;\n\t\t\twhile(front < back && level[sink] == -1) {\n\t\t\t\tint node = queue[front++];\n\t\t\t\tfor(int e=elast[node]; e!=-1; e=eprev[e]) {\n\t\t\t\t\tint to = eadj[e];\n\t\t\t\t\tif (level[to]==-1 && flow[e] < capa[e]) {\n\t\t\t\t\t\tlevel[to] = level[node]+1;\n\t\t\t\t\t\tqueue[back++] = to;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn level[sink]!=-1;\n\t\t}\n\n\t\tprivate int dfs(int cur, int curflow, int goal) {\n\t\t\tif(cur==goal) return curflow;\n\t\t\tfor(int e=now[cur]; e!=-1; now[cur]=e=eprev[e]) {\n\t\t\t\tif(level[eadj[e]]>level[cur] && flow[e] < capa[e]) {\n\t\t\t\t\tint res = dfs(eadj[e], Math.min(curflow, capa[e]-flow[e]), goal);\n\t\t\t\t\tif(res>0) {\n\t\t\t\t\t\tflow[e]+=res;\n\t\t\t\t\t\tflow[e^1]-=res;\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\twhile(true) {\n\t\t\tint c = a % b;\n\t\t\tif(c==0) return b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFS fs = new FS();\n\t\twhile(true) {\n\t\t\tint m = fs.nextInt();\n\t\t\tint n = fs.nextInt();\n\t\t\tif(m==0) break;\n\t\t\tint[] b = new int[m];\n\t\t\tint[] r = new int[n];\n\t\t\tfor(int i=0; i<m; i++) {\n\t\t\t\tb[i] = fs.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\tr[i] = fs.nextInt();\n\t\t\t}\n\t\t\t// 0         : start\n\t\t\t// 1 - m     : blue\n\t\t\t// m+1 - m+n : red\n\t\t\t// m+n+1     : end\n\t\t\tDinic d = new Dinic();\n\t\t\td.init(n+m+2, (n*m+n+m)*2);\n\t\t\tfor(int i=0; i<m; i++) {\n\t\t\t\td.add_edge(0, i+1, 1);\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\td.add_edge(m+1+i, m+n+1, 1);\n\t\t\t}\n\t\t\tfor(int i=0 ;i<m; i++) {\n\t\t\t\tfor(int j=0; j<n; j++) {\n\t\t\t\t\tif(gcd(b[i], r[j]) > 1) {\n\t\t\t\t\t\td.add_edge(i+1,m+1+j, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(d.dinic(0, m+n+1));\n\n\t\t}\n\t}\n\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass Segtree<T>\n{\n    int n;\n    T[] tree;\n    Func<T, T, T> f;\n    T exnum;\n    public Segtree(int m, Func<T, T, T> f, T ex)\n    {\n        this.f = f;\n        this.exnum = ex;\n        n = 1;\n        while (n < m) n <<= 1;\n\n        tree = new T[(n << 1) - 1];\n        for (int i = 0; i < tree.Length; i++) tree[i] = ex;\n    }\n    public Segtree(int m, T ini, Func<T, T, T> f, T ex)\n    {\n        this.f = f;\n        this.exnum = ex;\n        n = 1;\n        while (n < m) n <<= 1;\n\n        tree = new T[(n << 1) - 1];\n        for (int i = 0; i < tree.Length; i++) tree[i] = ini;\n        for (int i = 0; i < m; ++i) update(i, ini);\n    }\n    public void update(int j, T x)\n    {\n        int i = j + n - 1;\n        tree[i] = x;\n        while (i > 0)\n        {\n            i = (i - 1) >> 1;\n            tree[i] = f(tree[(i << 1) + 1], tree[(i << 1) + 2]);\n        }\n    }\n    public T look(int i) { return tree[i + n - 1]; }\n\n    // [s, t]\n    public T run(int s, int t) { return query(s, t + 1, 0, 0, n); }\n    T query(int s, int t, int k, int l, int r)\n    {\n        if (r <= s || t <= l) return exnum;\n        if (s <= l && r <= t) return tree[k];\n\n        return f(query(s, t, (k << 1) + 1, l, (l + r) >> 1), query(s, t, (k + 1) << 1, (l + r) >> 1, r));\n    }\n}\n\nclass PriorityQueue<T>\n{\n    private Comparison<T> comp;\n    private List<T> list;\n    private int count;\n    public PriorityQueue() : this((x, y) => ((IComparable<T>)x).CompareTo(y)) { }\n    public PriorityQueue(Comparison<T> comparison)\n    {\n        comp = comparison;\n        list = new List<T>();\n        count = 0;\n    }\n    public void Enqueue(T x)\n    {\n        var pos = count++;\n        list.Add(x);\n        while (pos > 0)\n        {\n            var p = (pos - 1) / 2;\n            if (comp(list[p], x) <= 0) break;\n            list[pos] = list[p];\n            pos = p;\n        }\n        list[pos] = x;\n    }\n    public T Dequeue()\n    {\n        var value = list[0];\n        var x = list[--count];\n        list.RemoveAt(count);\n        if (count == 0) return value;\n        var pos = 0;\n        while (pos * 2 + 1 < count)\n        {\n            var a = 2 * pos + 1;\n            var b = 2 * pos + 2;\n            if (b < count && comp(list[b], list[a]) < 0) a = b;\n            if (comp(list[a], x) >= 0) break;\n            list[pos] = list[a];\n            pos = a;\n        }\n        list[pos] = x;\n        return value;\n    }\n    public T Peek() { return list[0]; }\n    public bool Any() { return count > 0; }\n    public int Count() { return count; }\n}\n\nnamespace Codeforces\n{\n    class Program\n    {\n        class mymath\n        {\n            static int Mod = 1000000007;\n            public void setMod(int m) { Mod = m; }\n            public bool isprime(long a)\n            {\n                if (a < 2) return false;\n                for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n                return true;\n            }\n            public bool[] sieve(int n)\n            {\n                var isp = new bool[n + 1];\n                for (int i = 2; i <= n; i++) isp[i] = true;\n                for (int i = 2; i * i <= n; i++) if (isp[i]) for (int j = i * i; j <= n; j += i) isp[j] = false;\n                return isp;\n            }\n            public List<int> getprimes(int n)\n            {\n                var prs = new List<int>();\n                var isp = sieve(n);\n                for (int i = 2; i <= n; i++) if (isp[i]) prs.Add(i);\n                return prs;\n            }\n            public long[][] E(int n)\n            {\n                var ret = new long[n][];\n                for (int i = 0; i < n; i++)\n                {\n                    ret[i] = new long[n];\n                    ret[i][i] = 1;\n                }\n                return ret;\n            }\n            public long[][] powmat(long[][] A, long n)\n            {\n                if (n == 0) return E(A.Length);\n                var t = powmat(A, n / 2);\n                if ((n & 1) == 0) return mulmat(t, t);\n                return mulmat(mulmat(t, t), A);\n            }\n            public long[] mulmat(long[][] A, long[] x)\n            {\n                int n = A.Length, m = x.Length;\n                var ans = new long[n];\n                for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) ans[i] = (ans[i] + x[j] * A[i][j]) % Mod;\n                return ans;\n            }\n            public long[][] mulmat(long[][] A, long[][] B)\n            {\n                int n = A.Length, m = B[0].Length, l = B.Length;\n                var ans = new long[n][];\n                for (int i = 0; i < n; i++)\n                {\n                    ans[i] = new long[m];\n                    for (int j = 0; j < m; j++) for (int k = 0; k < l; k++) ans[i][j] = (ans[i][j] + A[i][k] * B[k][j]) % Mod;\n                }\n                return ans;\n            }\n            public long[] addmat(long[] x, long[] y)\n            {\n                int n = x.Length;\n                var ans = new long[n];\n                for (int i = 0; i < n; i++) ans[i] = (x[i] + y[i]) % Mod;\n                return ans;\n            }\n            public long[][] addmat(long[][] A, long[][] B)\n            {\n                int n = A.Length, m = A[0].Length;\n                var ans = new long[n][];\n                for (int i = 0; i < n; i++) ans[i] = addmat(A[i], B[i]);\n                return ans;\n            }\n            public long powmod(long a, long b)\n            {\n                if (a >= Mod) return powmod(a % Mod, b);\n                if (a == 0) return 0;\n                if (b == 0) return 1;\n                var t = powmod(a, b / 2);\n                if ((b & 1) == 0) return t * t % Mod;\n                return t * t % Mod * a % Mod;\n            }\n            public long inv(long a) { return powmod(a, Mod - 2); }\n            public long gcd(long a, long b)\n            {\n                while (b > 0) { var t = a % b; a = b; b = t; }\n                return a;\n            }\n            public long lcm(long a, long b) { return a * (b / gcd(a, b)); }\n            public long Comb(int n, int r)\n            {\n                if (n < 0 || r < 0 || r > n) return 0;\n                if (n - r < r) r = n - r;\n                if (r == 0) return 1;\n                if (r == 1) return n;\n                var numerator = new int[r];\n                var denominator = new int[r];\n                for (int k = 0; k < r; k++)\n                {\n                    numerator[k] = n - r + k + 1;\n                    denominator[k] = k + 1;\n                }\n                for (int p = 2; p <= r; p++)\n                {\n                    int pivot = denominator[p - 1];\n                    if (pivot > 1)\n                    {\n                        int offset = (n - r) % p;\n                        for (int k = p - 1; k < r; k += p)\n                        {\n                            numerator[k - offset] /= pivot;\n                            denominator[k] /= pivot;\n                        }\n                    }\n                }\n                long result = 1;\n                for (int k = 0; k < r; k++) if (numerator[k] > 1) result = result * numerator[k] % Mod;\n                return result;\n            }\n        }\n\n        const long InfL = 4011686018427387913L;\n        static char[] sep = new char[] { ' ', '/' };\n\n\n        //static int[] dx = { -1, 0, 1, -1, 1, -1, 0, -1 };\n        //static int[] dy = { 1, 1, 1, 0, 0, -1, -1, -1 };\n\n        static int[] dx = { -1, 0, 0, 1 };\n        static int[] dy = { 0, 1, -1, 0 };\n\n\n        /// <summary>\n        /// basic dfs function\n        /// </summary>\n        /// \n        /* public class List_of_List<T> : List<List<T>> { }\n        static int result = 0;\n\n        static List<bool> visited = new List<bool>();\n        static List_of_List<int> adj = new List_of_List<int>();\n\n        static void dfs(int here)\n        {\n            if (here == n * m - 1)\n            {\n                result++;\n                return;\n            }\n            visited[here] = true;\n\n            for(int i = 0; i<adj[here].Count; i++)\n            {\n                int there = adj[here][i];\n                if (!visited[there])\n                    dfs(there);\n                visited[there] = false;   \n            }\n        }\n\n        static void dfsAll()\n        {\n            for(int i = 0; i<adj.Count; i++)\n            {\n                dfs(i);\n            }\n        }\n\n\n        /* static int getInt => int.Parse(Console.ReadLine());\n        static int[] getIntArr => Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToArray();\n        static List<int> getIntList => Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToList<int>();\n        static string getString => Console.ReadLine().Trim();\n        static string[] getStrArr => Console.ReadLine().Trim().Split(sep);\n        static List<string> getStrList => Console.ReadLine().Trim().Split(sep).ToList<string>();\n        */\n        static int m;\n        static int n;\n        static int[] board;\n        static int[] cache;\n        static int[] input = new int[100001];\n        static int[,] capacity;\n        static int[,] flow;\n        static bool[,] adj;\n        static List<bool> visited;\n        static List<int> m_match;\n        static List<int> n_match;\n\n        static void Main(string[] args)\n        {\n            string[] str_input = Console.ReadLine().Split(' ');\n            int[] input = new int[str_input.Count()];\n            input[0] = int.Parse(str_input[0]);\n            input[1] = int.Parse(str_input[1]);\n\n            while (true)\n            {\n                mymath math = new mymath();\n                capacity = new int[502, 502];\n                flow = new int[502, 502];\n\n                m = input[0];\n                n = input[1];\n                int[] m_arr = new int[m];\n                int[] n_arr = new int[n];\n                for(int i = 0; i< (m-1)/10 + 1; i++)\n                {\n                    string[] m_input = Console.ReadLine().Split(' ');\n                    for(int j = 0; j< m_input.Count(); j++)\n                    {\n                        m_arr[i * 10 + j] = int.Parse(m_input[j]);\n                    }\n                }\n                for (int i = 0; i < (n-1)/10 + 1; i++)\n                {\n                    string[] n_input = Console.ReadLine().Split(' ');\n                    for (int j = 0; j < n_input.Count(); j++)\n                    {\n                        n_arr[i * 10 + j] = int.Parse(n_input[j]);\n                    }\n                }\n\n                adj = new bool[m,n];\n\n                m_match = new List<int>();\n                n_match = new List<int>();\n\n                m_match.Capacity = m;\n\n                for(int i = 0; i<m; i++)\n                {\n                    for(int j = 0; j<n; j++)\n                    {\n                        if (math.gcd(m_arr[i], n_arr[j]) > 1)\n                        {\n                            adj[i, j] = true;\n                        }\n                    }\n                }\n\n\n                Console.WriteLine(bipartite_match());\n\n                str_input = Console.ReadLine().Split(' ');\n                input = new int[str_input.Count()];\n                input[0] = int.Parse(str_input[0]);\n                input[1] = int.Parse(str_input[1]);\n                if (input[0] == 0 && input[1] == 0) break;\n            }\n        }\n\n        static bool dfs(int a)\n        {\n            if (visited[a]) return false;\n            visited[a] = true;\n            for(int b = 0; b < n; b++)\n            {\n                if (adj[a, b])\n                {\n                    if(n_match[b] == -1 || dfs(n_match[b]))\n                    {\n                        m_match[a] = b;\n                        n_match[b] = a;\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        static int bipartite_match()\n        {\n            m_match = new List<int>();\n            for(int i = 0; i<m; i++)\n            {\n                m_match.Add(-1);\n            }\n            n_match = new List<int>();\n            for(int i = 0; i<n; i++)\n            {\n                n_match.Add(-1);\n            }\n\n            int size = 0;\n            for (int start = 0; start < m; start++)\n            {\n                visited = new List<bool>();\n                visited.Capacity = m;\n                for (int i = 0; i < m; i++) visited.Add(false);\n\n                if (dfs(start)) size++;\n            }\n            return size;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\n#pragma warning disable\n\nclass Segtree<T>\n{\n    int n;\n    T[] tree;\n    Func<T, T, T> f;\n    T exnum;\n    public Segtree(int m, Func<T, T, T> f, T ex)\n    {\n        this.f = f;\n        this.exnum = ex;\n        n = 1;\n        while (n < m) n <<= 1;\n\n        tree = new T[(n << 1) - 1];\n        for (int i = 0; i < tree.Length; i++) tree[i] = ex;\n    }\n    public Segtree(int m, T ini, Func<T, T, T> f, T ex)\n    {\n        this.f = f;\n        this.exnum = ex;\n        n = 1;\n        while (n < m) n <<= 1;\n\n        tree = new T[(n << 1) - 1];\n        for (int i = 0; i < tree.Length; i++) tree[i] = ini;\n        for (int i = 0; i < m; ++i) update(i, ini);\n    }\n    public void update(int j, T x)\n    {\n        int i = j + n - 1;\n        tree[i] = x;\n        while (i > 0)\n        {\n            i = (i - 1) >> 1;\n            tree[i] = f(tree[(i << 1) + 1], tree[(i << 1) + 2]);\n        }\n    }\n    public T look(int i) { return tree[i + n - 1]; }\n\n    // [s, t]\n    public T run(int s, int t) { return query(s, t + 1, 0, 0, n); }\n    T query(int s, int t, int k, int l, int r)\n    {\n        if (r <= s || t <= l) return exnum;\n        if (s <= l && r <= t) return tree[k];\n\n        return f(query(s, t, (k << 1) + 1, l, (l + r) >> 1), query(s, t, (k + 1) << 1, (l + r) >> 1, r));\n    }\n}\n\nclass PriorityQueue<T>\n{\n    private Comparison<T> comp;\n    private List<T> list;\n    private int count;\n    public PriorityQueue() : this((x, y) => ((IComparable<T>)x).CompareTo(y)) { }\n    public PriorityQueue(Comparison<T> comparison)\n    {\n        comp = comparison;\n        list = new List<T>();\n        count = 0;\n    }\n    public void Enqueue(T x)\n    {\n        var pos = count++;\n        list.Add(x);\n        while (pos > 0)\n        {\n            var p = (pos - 1) / 2;\n            if (comp(list[p], x) <= 0) break;\n            list[pos] = list[p];\n            pos = p;\n        }\n        list[pos] = x;\n    }\n    public T Dequeue()\n    {\n        var value = list[0];\n        var x = list[--count];\n        list.RemoveAt(count);\n        if (count == 0) return value;\n        var pos = 0;\n        while (pos * 2 + 1 < count)\n        {\n            var a = 2 * pos + 1;\n            var b = 2 * pos + 2;\n            if (b < count && comp(list[b], list[a]) < 0) a = b;\n            if (comp(list[a], x) >= 0) break;\n            list[pos] = list[a];\n            pos = a;\n        }\n        list[pos] = x;\n        return value;\n    }\n    public T Peek() { return list[0]; }\n    public bool Any() { return count > 0; }\n    public int Count() { return count; }\n}\n\nnamespace Codeforces\n{\n    class Program\n    {\n        class mymath\n        {\n            static int Mod = 1000000007;\n            public void setMod(int m) { Mod = m; }\n            public bool isprime(long a)\n            {\n                if (a < 2) return false;\n                for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n                return true;\n            }\n            public bool[] sieve(int n)\n            {\n                var isp = new bool[n + 1];\n                for (int i = 2; i <= n; i++) isp[i] = true;\n                for (int i = 2; i * i <= n; i++) if (isp[i]) for (int j = i * i; j <= n; j += i) isp[j] = false;\n                return isp;\n            }\n            public List<int> getprimes(int n)\n            {\n                var prs = new List<int>();\n                var isp = sieve(n);\n                for (int i = 2; i <= n; i++) if (isp[i]) prs.Add(i);\n                return prs;\n            }\n            public long[][] E(int n)\n            {\n                var ret = new long[n][];\n                for (int i = 0; i < n; i++)\n                {\n                    ret[i] = new long[n];\n                    ret[i][i] = 1;\n                }\n                return ret;\n            }\n            public long[][] powmat(long[][] A, long n)\n            {\n                if (n == 0) return E(A.Length);\n                var t = powmat(A, n / 2);\n                if ((n & 1) == 0) return mulmat(t, t);\n                return mulmat(mulmat(t, t), A);\n            }\n            public long[] mulmat(long[][] A, long[] x)\n            {\n                int n = A.Length, m = x.Length;\n                var ans = new long[n];\n                for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) ans[i] = (ans[i] + x[j] * A[i][j]) % Mod;\n                return ans;\n            }\n            public long[][] mulmat(long[][] A, long[][] B)\n            {\n                int n = A.Length, m = B[0].Length, l = B.Length;\n                var ans = new long[n][];\n                for (int i = 0; i < n; i++)\n                {\n                    ans[i] = new long[m];\n                    for (int j = 0; j < m; j++) for (int k = 0; k < l; k++) ans[i][j] = (ans[i][j] + A[i][k] * B[k][j]) % Mod;\n                }\n                return ans;\n            }\n            public long[] addmat(long[] x, long[] y)\n            {\n                int n = x.Length;\n                var ans = new long[n];\n                for (int i = 0; i < n; i++) ans[i] = (x[i] + y[i]) % Mod;\n                return ans;\n            }\n            public long[][] addmat(long[][] A, long[][] B)\n            {\n                int n = A.Length, m = A[0].Length;\n                var ans = new long[n][];\n                for (int i = 0; i < n; i++) ans[i] = addmat(A[i], B[i]);\n                return ans;\n            }\n            public long powmod(long a, long b)\n            {\n                if (a >= Mod) return powmod(a % Mod, b);\n                if (a == 0) return 0;\n                if (b == 0) return 1;\n                var t = powmod(a, b / 2);\n                if ((b & 1) == 0) return t * t % Mod;\n                return t * t % Mod * a % Mod;\n            }\n            public long inv(long a) { return powmod(a, Mod - 2); }\n            public long gcd(long a, long b)\n            {\n                while (b > 0) { var t = a % b; a = b; b = t; }\n                return a;\n            }\n            public long lcm(long a, long b) { return a * (b / gcd(a, b)); }\n            public long Comb(int n, int r)\n            {\n                if (n < 0 || r < 0 || r > n) return 0;\n                if (n - r < r) r = n - r;\n                if (r == 0) return 1;\n                if (r == 1) return n;\n                var numerator = new int[r];\n                var denominator = new int[r];\n                for (int k = 0; k < r; k++)\n                {\n                    numerator[k] = n - r + k + 1;\n                    denominator[k] = k + 1;\n                }\n                for (int p = 2; p <= r; p++)\n                {\n                    int pivot = denominator[p - 1];\n                    if (pivot > 1)\n                    {\n                        int offset = (n - r) % p;\n                        for (int k = p - 1; k < r; k += p)\n                        {\n                            numerator[k - offset] /= pivot;\n                            denominator[k] /= pivot;\n                        }\n                    }\n                }\n                long result = 1;\n                for (int k = 0; k < r; k++) if (numerator[k] > 1) result = result * numerator[k] % Mod;\n                return result;\n            }\n        }\n\n        const long InfL = 4011686018427387913L;\n        static char[] sep = new char[] { ' ', '/' };\n\n\n        //static int[] dx = { -1, 0, 1, -1, 1, -1, 0, -1 };\n        //static int[] dy = { 1, 1, 1, 0, 0, -1, -1, -1 };\n\n        static int[] dx = { -1, 0, 0, 1 };\n        static int[] dy = { 0, 1, -1, 0 };\n\n\n        /// <summary>\n        /// basic dfs function\n        /// </summary>\n        /// \n        /* public class List_of_List<T> : List<List<T>> { }\n        static int result = 0;\n\n        static List<bool> visited = new List<bool>();\n        static List_of_List<int> adj = new List_of_List<int>();\n\n        static void dfs(int here)\n        {\n            if (here == n * m - 1)\n            {\n                result++;\n                return;\n            }\n            visited[here] = true;\n\n            for(int i = 0; i<adj[here].Count; i++)\n            {\n                int there = adj[here][i];\n                if (!visited[there])\n                    dfs(there);\n                visited[there] = false;   \n            }\n        }\n\n        static void dfsAll()\n        {\n            for(int i = 0; i<adj.Count; i++)\n            {\n                dfs(i);\n            }\n        }\n\n\n        /* static int getInt => int.Parse(Console.ReadLine());\n        static int[] getIntArr => Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToArray();\n        static List<int> getIntList => Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToList<int>();\n        static string getString => Console.ReadLine().Trim();\n        static string[] getStrArr => Console.ReadLine().Trim().Split(sep);\n        static List<string> getStrList => Console.ReadLine().Trim().Split(sep).ToList<string>();\n        */\n        static int m;\n        static int n;\n        static int[] input = new int[100001];\n        static int[,] capacity;\n        static int[,] flow;\n        static bool[,] adj;\n        static List<bool> visited;\n        static List<int> m_match;\n        static List<int> n_match;\n\n        static void Main(string[] args)\n        {\n            string[] str_input = Console.ReadLine().Split(' ');\n            int[] input = new int[str_input.Count()];\n            input[0] = int.Parse(str_input[0]);\n            input[1] = int.Parse(str_input[1]);\n\n            while (true)\n            {\n                mymath math = new mymath();\n                capacity = new int[502, 502];\n                flow = new int[502, 502];\n\n                m = input[0];\n                n = input[1];\n                int[] m_arr = new int[m];\n                int[] n_arr = new int[n];\n                for(int i = 0; i< (m-1)/10 + 1; i++)\n                {\n                    string[] m_input = Console.ReadLine().Split(' ');\n                    for(int j = 0; j< m_input.Count(); j++)\n                    {\n                        m_arr[i * 10 + j] = int.Parse(m_input[j]);\n                    }\n                }\n                for (int i = 0; i < (n-1)/10 + 1; i++)\n                {\n                    string[] n_input = Console.ReadLine().Split(' ');\n                    for (int j = 0; j < n_input.Count(); j++)\n                    {\n                        n_arr[i * 10 + j] = int.Parse(n_input[j]);\n                    }\n                }\n\n                adj = new bool[m,n];\n\n                m_match = new List<int>();\n                n_match = new List<int>();\n\n                m_match.Capacity = m;\n\n                for(int i = 0; i<m; i++)\n                {\n                    for(int j = 0; j<n; j++)\n                    {\n                        if (math.gcd(m_arr[i], n_arr[j]) > 1)\n                        {\n                            adj[i, j] = true;\n                        }\n                    }\n                }\n\n                Console.WriteLine(bipartite_match());\n\n                str_input = Console.ReadLine().Split(' ');\n                input = new int[str_input.Count()];\n                input[0] = int.Parse(str_input[0]);\n                input[1] = int.Parse(str_input[1]);\n                if (input[0] == 0 && input[1] == 0) break;\n            }\n        }\n\n        static bool dfs(int a)\n        {\n            if (visited[a]) return false;\n            visited[a] = true;\n            for(int b = 0; b < n; b++)\n            {\n                if (adj[a, b])\n                {\n                    if(n_match[b] == -1 || dfs(n_match[b]))\n                    {\n                        m_match[a] = b;\n                        n_match[b] = a;\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        static int bipartite_match()\n        {\n            m_match = new List<int>();\n            for(int i = 0; i<m; i++)\n            {\n                m_match.Add(-1);\n            }\n            n_match = new List<int>();\n            for(int i = 0; i<n; i++)\n            {\n                n_match.Add(-1);\n            }\n\n            int size = 0;\n            for (int start = 0; start < m; start++)\n            {\n                visited = new List<bool>();\n                visited.Capacity = m;\n                for (int i = 0; i < m; i++) visited.Add(false);\n\n                if (dfs(start)) size++;\n            }\n            return size;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Read read = new Read();\n        string s;\n\n        while ((s = Console.ReadLine()) != \"0 0\")\n        {\n            int[] t = Array.ConvertAll(s.Split(), int.Parse);\n            int A = t[0];\n            int B = t[1];\n            int[] a = new int[A];\n            int[] b = new int[B];\n            for (int i = 0; i < A; i++) { a[i] = read.NextInt(); }\n            for (int i = 0; i < B; i++) { b[i] = read.NextInt(); }\n\n            int S = A + B;\n            List<Edge>[] edges = Enumerable.Range(0, S + 2).Select(i => new List<Edge>()).ToArray();\n            for (int i = 0; i < A; i++) { Edge.Add(edges, S, i, 1); }\n            for (int i = 0; i < B; i++) { Edge.Add(edges, A + i, S + 1, 1); }\n            for (int i = 0; i < A; i++)\n            {\n                for (int j = 0; j < B; j++)\n                {\n                    if (GCD(a[i], b[j]) > 1)\n                    {\n                        Edge.Add(edges, i, A + j, 1);\n                    }\n                }\n            }\n\n            int ans = new MaxFlow().Run(edges, S, S + 1);\n            Console.WriteLine(ans);\n        }\n\n        Console.ReadLine();\n    }\n\n    static long GCD(long i, long j)\n    {\n        while (j != 0) { long t = i % j; i = j; j = t; }\n        return i;\n    }\n\n    class Edge\n    {\n        public int to, capacity, reverse;\n        public Edge(int to, int capacity, int reverse)\n        {\n            this.to = to;\n            this.capacity = capacity;\n            this.reverse = reverse;\n        }\n        public static void Add(List<Edge>[] Edges, int from, int to, int capacity)\n        {\n            Edges[from].Add(new Edge(to, capacity, Edges[to].Count));\n            Edges[to].Add(new Edge(from, 0, Edges[from].Count - 1));\n        }\n    }\n\n    class MaxFlow\n    {\n        readonly int INF = (int)1e9;\n        List<Edge>[] Edges;\n        int T;\n        bool[] used;\n\n        public int Run(List<Edge>[] edges, int s, int t)\n        {\n            Edges = edges;\n            T = t;\n            int res = 0;\n            while (true)\n            {\n                used = new bool[Edges.Length];\n                int f = DFS(s, INF);\n                if (f == 0) return res;\n                res += f;\n            }\n        }\n\n        int DFS(int v, int flow)\n        {\n            if (v == T) return flow;\n            used[v] = true;\n            for (int i = 0; i < Edges[v].Count; i++)\n            {\n                Edge e = Edges[v][i];\n                if (!used[e.to] && e.capacity > 0)\n                {\n                    int d = DFS(e.to, Math.Min(flow, e.capacity));\n                    if (d > 0)\n                    {\n                        e.capacity -= d;\n                        Edges[e.to][e.reverse].capacity += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n    }\n\n\n\n    class Read\n    {\n        Queue<string> que = new Queue<string>();\n        \n        public int NextInt()\n        {\n            if (que.Count == 0) { Enqueue(); }\n            return int.Parse(que.Dequeue());\n        }\n\n        private void Enqueue()\n        {\n            foreach (string s in Console.ReadLine().Split())\n            {\n                que.Enqueue(s);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AOJ_1163\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int M = NextInt();\n                int N = NextInt();\n\n                if (M == 0 && N == 0) break;\n\n                var B = NextInt(M);\n                var R = NextInt(N);\n\n                FordFulkerson fd = new FordFulkerson(M + N + 2);\n                for (int i = 0; i < M; i++)\n                {\n                    for (int j = 0; j < N; j++)\n                    {\n                        if (Gcd(B[i], R[j]) > 1) fd.AddEdge(i + 2, j + M + 2, 1);\n                    }\n                }\n                for (int i = 0; i < M; i++)\n                {\n                    fd.AddEdge(0, i + 2, 1);\n                }\n                for (int i = 0; i < N; i++)\n                {\n                    fd.AddEdge(i + M + 2, 1, 1);\n                }\n\n                var ans = fd.MaxFlow(0, 1);\n\n                Console.WriteLine(ans);\n            }\n\n            Console.ReadKey();\n        }\n\n        static List<string> line = new List<string>();\n        static int index = 0;\n        static String ReadNext()\n        {\n            if (line.Count <= index) line.AddRange(Console.ReadLine().Split());\n            return line[index++];\n        }\n        static int NextInt() { return int.Parse(ReadNext()); }\n        static int[] NextInt(int N) { int[] ret = new int[N]; for (int i = 0; i < N; i++) ret[i] = int.Parse(ReadNext()); return ret; }\n        static long NextLong() { return long.Parse(ReadNext()); }\n        static long[] NextLong(int N) { long[] ret = new long[N]; for (int i = 0; i < N; i++) ret[i] = long.Parse(ReadNext()); return ret; }\n\n\n        /// <summary>\n        /// 最大公約数\n        /// </summary>\n        /// <param name=\"a\"></param>\n        /// <param name=\"b\"></param>\n        /// <returns></returns>\n        public static int Gcd(int a, int b)\n        {\n            if (a < b)\n                // 引数を入替えて自分を呼び出す\n                return Gcd(b, a);\n            while (b != 0)\n            {\n                var remainder = a % b;\n                a = b;\n                b = remainder;\n            }\n            return a;\n        }\n    }\n\n    /// <summary>\n    /// 最大流　容量に注意\n    /// </summary>\n    class FordFulkerson\n    {\n        public struct Edge\n        {\n            public int to, cap, rev;\n        }\n\n        public List<Edge>[] G;\n        bool[] used;\n        int INF = 1000000009;\n\n        public FordFulkerson(int V) //頂点数\n        {\n            G = new List<Edge>[V].Select(x => new List<Edge>()).ToArray();\n            used = new bool[V];\n        }\n\n        public void AddEdge(int from, int to, int cap)\n        {\n            G[from].Add(new Edge() { to = to, cap = cap, rev = G[to].Count });\n            G[to].Add(new Edge() { to = from, cap = 0, rev = G[from].Count - 1 });\n        }\n\n        int Dfs(int v, int t, int f)\n        {\n            if (v == t)\n                return f;\n            used[v] = true;\n\n            for (int i = 0; i < G[v].Count; i++)\n            {\n                var e = G[v][i];\n                if (!used[e.to] && e.cap > 0)\n                {\n                    int d = Dfs(e.to, t, Math.Min(f, e.cap));\n                    if (d > 0)\n                    {\n                        e.cap -= d;\n                        G[v][i] = e;\n\n                        var temp = G[e.to][e.rev];\n                        temp.cap += d;\n                        G[e.to][e.rev] = temp;\n\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        public int MaxFlow(int s, int t)\n        {\n            int flow = 0;\n            while (true)\n            {\n                used = new bool[used.Length];\n                int f = Dfs(s, t, INF);\n                if (f == 0) return flow;\n                flow += f;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass Segtree<T>\n{\n    int n;\n    T[] tree;\n    Func<T, T, T> f;\n    T exnum;\n    public Segtree(int m, Func<T, T, T> f, T ex)\n    {\n        this.f = f;\n        this.exnum = ex;\n        n = 1;\n        while (n < m) n <<= 1;\n\n        tree = new T[(n << 1) - 1];\n        for (int i = 0; i < tree.Length; i++) tree[i] = ex;\n    }\n    public Segtree(int m, T ini, Func<T, T, T> f, T ex)\n    {\n        this.f = f;\n        this.exnum = ex;\n        n = 1;\n        while (n < m) n <<= 1;\n\n        tree = new T[(n << 1) - 1];\n        for (int i = 0; i < tree.Length; i++) tree[i] = ini;\n        for (int i = 0; i < m; ++i) update(i, ini);\n    }\n    public void update(int j, T x)\n    {\n        int i = j + n - 1;\n        tree[i] = x;\n        while (i > 0)\n        {\n            i = (i - 1) >> 1;\n            tree[i] = f(tree[(i << 1) + 1], tree[(i << 1) + 2]);\n        }\n    }\n    public T look(int i) { return tree[i + n - 1]; }\n\n    // [s, t]\n    public T run(int s, int t) { return query(s, t + 1, 0, 0, n); }\n    T query(int s, int t, int k, int l, int r)\n    {\n        if (r <= s || t <= l) return exnum;\n        if (s <= l && r <= t) return tree[k];\n\n        return f(query(s, t, (k << 1) + 1, l, (l + r) >> 1), query(s, t, (k + 1) << 1, (l + r) >> 1, r));\n    }\n}\n\nclass PriorityQueue<T>\n{\n    private Comparison<T> comp;\n    private List<T> list;\n    private int count;\n    public PriorityQueue() : this((x, y) => ((IComparable<T>)x).CompareTo(y)) { }\n    public PriorityQueue(Comparison<T> comparison)\n    {\n        comp = comparison;\n        list = new List<T>();\n        count = 0;\n    }\n    public void Enqueue(T x)\n    {\n        var pos = count++;\n        list.Add(x);\n        while (pos > 0)\n        {\n            var p = (pos - 1) / 2;\n            if (comp(list[p], x) <= 0) break;\n            list[pos] = list[p];\n            pos = p;\n        }\n        list[pos] = x;\n    }\n    public T Dequeue()\n    {\n        var value = list[0];\n        var x = list[--count];\n        list.RemoveAt(count);\n        if (count == 0) return value;\n        var pos = 0;\n        while (pos * 2 + 1 < count)\n        {\n            var a = 2 * pos + 1;\n            var b = 2 * pos + 2;\n            if (b < count && comp(list[b], list[a]) < 0) a = b;\n            if (comp(list[a], x) >= 0) break;\n            list[pos] = list[a];\n            pos = a;\n        }\n        list[pos] = x;\n        return value;\n    }\n    public T Peek() { return list[0]; }\n    public bool Any() { return count > 0; }\n    public int Count() { return count; }\n}\n\nnamespace Codeforces\n{\n    class Program\n    {\n        class mymath\n        {\n            static int Mod = 1000000007;\n            public void setMod(int m) { Mod = m; }\n            public bool isprime(long a)\n            {\n                if (a < 2) return false;\n                for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n                return true;\n            }\n            public bool[] sieve(int n)\n            {\n                var isp = new bool[n + 1];\n                for (int i = 2; i <= n; i++) isp[i] = true;\n                for (int i = 2; i * i <= n; i++) if (isp[i]) for (int j = i * i; j <= n; j += i) isp[j] = false;\n                return isp;\n            }\n            public List<int> getprimes(int n)\n            {\n                var prs = new List<int>();\n                var isp = sieve(n);\n                for (int i = 2; i <= n; i++) if (isp[i]) prs.Add(i);\n                return prs;\n            }\n            public long[][] E(int n)\n            {\n                var ret = new long[n][];\n                for (int i = 0; i < n; i++)\n                {\n                    ret[i] = new long[n];\n                    ret[i][i] = 1;\n                }\n                return ret;\n            }\n            public long[][] powmat(long[][] A, long n)\n            {\n                if (n == 0) return E(A.Length);\n                var t = powmat(A, n / 2);\n                if ((n & 1) == 0) return mulmat(t, t);\n                return mulmat(mulmat(t, t), A);\n            }\n            public long[] mulmat(long[][] A, long[] x)\n            {\n                int n = A.Length, m = x.Length;\n                var ans = new long[n];\n                for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) ans[i] = (ans[i] + x[j] * A[i][j]) % Mod;\n                return ans;\n            }\n            public long[][] mulmat(long[][] A, long[][] B)\n            {\n                int n = A.Length, m = B[0].Length, l = B.Length;\n                var ans = new long[n][];\n                for (int i = 0; i < n; i++)\n                {\n                    ans[i] = new long[m];\n                    for (int j = 0; j < m; j++) for (int k = 0; k < l; k++) ans[i][j] = (ans[i][j] + A[i][k] * B[k][j]) % Mod;\n                }\n                return ans;\n            }\n            public long[] addmat(long[] x, long[] y)\n            {\n                int n = x.Length;\n                var ans = new long[n];\n                for (int i = 0; i < n; i++) ans[i] = (x[i] + y[i]) % Mod;\n                return ans;\n            }\n            public long[][] addmat(long[][] A, long[][] B)\n            {\n                int n = A.Length, m = A[0].Length;\n                var ans = new long[n][];\n                for (int i = 0; i < n; i++) ans[i] = addmat(A[i], B[i]);\n                return ans;\n            }\n            public long powmod(long a, long b)\n            {\n                if (a >= Mod) return powmod(a % Mod, b);\n                if (a == 0) return 0;\n                if (b == 0) return 1;\n                var t = powmod(a, b / 2);\n                if ((b & 1) == 0) return t * t % Mod;\n                return t * t % Mod * a % Mod;\n            }\n            public long inv(long a) { return powmod(a, Mod - 2); }\n            public long gcd(long a, long b)\n            {\n                while (b > 0) { var t = a % b; a = b; b = t; }\n                return a;\n            }\n            public long lcm(long a, long b) { return a * (b / gcd(a, b)); }\n            public long Comb(int n, int r)\n            {\n                if (n < 0 || r < 0 || r > n) return 0;\n                if (n - r < r) r = n - r;\n                if (r == 0) return 1;\n                if (r == 1) return n;\n                var numerator = new int[r];\n                var denominator = new int[r];\n                for (int k = 0; k < r; k++)\n                {\n                    numerator[k] = n - r + k + 1;\n                    denominator[k] = k + 1;\n                }\n                for (int p = 2; p <= r; p++)\n                {\n                    int pivot = denominator[p - 1];\n                    if (pivot > 1)\n                    {\n                        int offset = (n - r) % p;\n                        for (int k = p - 1; k < r; k += p)\n                        {\n                            numerator[k - offset] /= pivot;\n                            denominator[k] /= pivot;\n                        }\n                    }\n                }\n                long result = 1;\n                for (int k = 0; k < r; k++) if (numerator[k] > 1) result = result * numerator[k] % Mod;\n                return result;\n            }\n        }\n\n        const long InfL = 4011686018427387913L;\n        static char[] sep = new char[] { ' ', '/' };\n\n\n        //static int[] dx = { -1, 0, 1, -1, 1, -1, 0, -1 };\n        //static int[] dy = { 1, 1, 1, 0, 0, -1, -1, -1 };\n\n        static int[] dx = { -1, 0, 0, 1 };\n        static int[] dy = { 0, 1, -1, 0 };\n\n\n        /// <summary>\n        /// basic dfs function\n        /// </summary>\n        /// \n        /* public class List_of_List<T> : List<List<T>> { }\n        static int result = 0;\n\n        static List<bool> visited = new List<bool>();\n        static List_of_List<int> adj = new List_of_List<int>();\n\n        static void dfs(int here)\n        {\n            if (here == n * m - 1)\n            {\n                result++;\n                return;\n            }\n            visited[here] = true;\n\n            for(int i = 0; i<adj[here].Count; i++)\n            {\n                int there = adj[here][i];\n                if (!visited[there])\n                    dfs(there);\n                visited[there] = false;   \n            }\n        }\n\n        static void dfsAll()\n        {\n            for(int i = 0; i<adj.Count; i++)\n            {\n                dfs(i);\n            }\n        }\n\n\n        /* static int getInt => int.Parse(Console.ReadLine());\n        static int[] getIntArr => Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToArray();\n        static List<int> getIntList => Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToList<int>();\n        static string getString => Console.ReadLine().Trim();\n        static string[] getStrArr => Console.ReadLine().Trim().Split(sep);\n        static List<string> getStrList => Console.ReadLine().Trim().Split(sep).ToList<string>();\n        */\n        static int m;\n        static int n;\n        static int[] board;\n        static int[] cache;\n        static int[] input = new int[100001];\n        static int[,] capacity;\n        static int[,] flow;\n        static bool[,] adj;\n        static List<bool> visited;\n        static List<int> m_match;\n        static List<int> n_match;\n\n        static void Main(string[] args)\n        {\n            string[] str_input = Console.ReadLine().Split(' ');\n            int[] input = new int[str_input.Count()];\n            input[0] = int.Parse(str_input[0]);\n            input[1] = int.Parse(str_input[1]);\n\n            while (true)\n            {\n                mymath math = new mymath();\n                capacity = new int[502, 502];\n                flow = new int[502, 502];\n\n                m = input[0];\n                n = input[1];\n                int[] m_arr = new int[m];\n                int[] n_arr = new int[n];\n                for(int i = 0; i< (m-1)/10 + 1; i++)\n                {\n                    string[] m_input = Console.ReadLine().Split(' ');\n                    for(int j = 0; j< m_input.Count(); j++)\n                    {\n                        m_arr[i * 10 + j] = int.Parse(m_input[j]);\n                    }\n                }\n                for (int i = 0; i < (n-1)/10 + 1; i++)\n                {\n                    string[] n_input = Console.ReadLine().Split(' ');\n                    for (int j = 0; j < n_input.Count(); j++)\n                    {\n                        n_arr[i * 10 + j] = int.Parse(n_input[j]);\n                    }\n                }\n\n                adj = new bool[m,n];\n\n                m_match = new List<int>();\n                n_match = new List<int>();\n\n                m_match.Capacity = m;\n\n                for(int i = 0; i<m; i++)\n                {\n                    for(int j = 0; j<n; j++)\n                    {\n                        if (math.gcd(m_arr[i], n_arr[j]) > 1)\n                        {\n                            adj[i, j] = true;\n                        }\n                    }\n                }\n\n\n                Console.WriteLine(bipartite_match());\n\n                str_input = Console.ReadLine().Split(' ');\n                input = new int[str_input.Count()];\n                input[0] = int.Parse(str_input[0]);\n                input[1] = int.Parse(str_input[1]);\n                if (input[0] == 0 && input[1] == 0) break;\n            }\n        }\n\n        static bool dfs(int a)\n        {\n            if (visited[a]) return false;\n            visited[a] = true;\n            for(int b = 0; b < n; b++)\n            {\n                if (adj[a, b])\n                {\n                    if(n_match[b] == -1 || dfs(n_match[b]))\n                    {\n                        m_match[a] = b;\n                        n_match[b] = a;\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        static int bipartite_match()\n        {\n            m_match = new List<int>();\n            for(int i = 0; i<m; i++)\n            {\n                m_match.Add(-1);\n            }\n            n_match = new List<int>();\n            for(int i = 0; i<n; i++)\n            {\n                n_match.Add(-1);\n            }\n\n            int size = 0;\n            for (int start = 0; start < m; start++)\n            {\n                visited = new List<bool>();\n                visited.Capacity = m;\n                for (int i = 0; i < m; i++) visited.Add(false);\n\n                if (dfs(start)) size++;\n            }\n            return size;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Read read = new Read();\n        string s;\n\n        while ((s = Console.ReadLine()) != \"0 0\")\n        {\n            int[] t = Array.ConvertAll(s.Split(), int.Parse);\n            int A = t[0];\n            int B = t[1];\n            int S = A + B;\n            int[] a = new int[A];\n            int[] b = new int[B];\n            var G = Enumerable.Range(0, S + 2).Select(i => new List<Edge>()).ToArray();\n            for (int i = 0; i < A; i++) { a[i] = read.NextInt(); Edge.Add(G, S, i, 1); }\n            for (int i = 0; i < B; i++) { b[i] = read.NextInt(); Edge.Add(G, A + i, S + 1, 1); }\n\n            for (int i = 0; i < A; i++)\n            {\n                for (int j = 0; j < B; j++)\n                {\n                    if (GCD(a[i], b[j]) > 1)\n                    {\n                        Edge.Add(G, i, A + j, 1);\n                    }\n                }\n            }\n            int ans = new Dinic(G).MaxFlow(S, S + 1);\n            Console.WriteLine(ans);\n        }\n\n        Console.ReadLine();\n    }\n\n    static long GCD(long i, long j)\n    {\n        while (j != 0) { long t = i % j; i = j; j = t; }\n        return i;\n    }\n\n    class Edge\n    {\n        public int to, capacity, reverse;\n        public Edge(int to, int capacity, int reverse)\n        {\n            this.to = to;\n            this.capacity = capacity;\n            this.reverse = reverse;\n        }\n        public static void Add(List<Edge>[] Edges, int from, int to, int capacity)\n        {\n            Edges[from].Add(new Edge(to, capacity, Edges[to].Count));\n            Edges[to].Add(new Edge(from, 0, Edges[from].Count - 1));\n        }\n    }\n\n    class Dinic\n    {\n        readonly int INF = (int)1e9;\n        List<Edge>[] G;\n        int[] level;\n        int[] iter;\n\n        public Dinic(List<Edge>[] G)\n        {\n            this.G = G;\n        }\n\n        public int MaxFlow(int s, int t)\n        {\n            int flow = 0;\n            while (true)\n            {\n                BFS(s);\n                if (level[t] < 0) return flow;\n                iter = new int[G.Length];\n                int f;\n                while ((f = DFS(s, t, INF)) > 0) { flow += f; }\n            }\n        }\n\n        private void BFS(int s)\n        {\n            level = Enumerable.Repeat(-1, G.Length).ToArray();\n            Queue<int> que = new Queue<int>();\n            que.Enqueue(s);\n            level[s] = 0;\n            while (que.Count > 0)\n            {\n                int v = que.Dequeue();\n                foreach (Edge e in G[v].Where(e => e.capacity > 0 && level[e.to] < 0))\n                {\n                    level[e.to] = level[v] + 1;\n                    que.Enqueue(e.to);\n                }\n            }\n        }\n\n        private int DFS(int v, int t, int flow)\n        {\n            if (v == t) return flow;\n            while (iter[v] < G[v].Count)\n            {\n                Edge e = G[v][iter[v]];\n                if (e.capacity > 0 && level[v] < level[e.to])\n                {\n                    int d = DFS(e.to, t, Math.Min(flow, e.capacity));\n                    if (d > 0)\n                    {\n                        e.capacity -= d;\n                        G[e.to][e.reverse].capacity += d;\n                        return d;\n                    }\n                }\n                iter[v]++;\n            }\n            return 0;\n        }\n    }\n\n    class Read\n    {\n        Queue<string> que = new Queue<string>();\n        \n        public int NextInt()\n        {\n            if (que.Count == 0) { Enqueue(); }\n            return int.Parse(que.Dequeue());\n        }\n\n        private void Enqueue()\n        {\n            foreach (string s in Console.ReadLine().Split())\n            {\n                que.Enqueue(s);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\n\nclass Segtree<T>\n{\n    int n;\n    T[] tree;\n    Func<T, T, T> f;\n    T exnum;\n    public Segtree(int m, Func<T, T, T> f, T ex)\n    {\n        this.f = f;\n        this.exnum = ex;\n        n = 1;\n        while (n < m) n <<= 1;\n\n        tree = new T[(n << 1) - 1];\n        for (int i = 0; i < tree.Length; i++) tree[i] = ex;\n    }\n    public Segtree(int m, T ini, Func<T, T, T> f, T ex)\n    {\n        this.f = f;\n        this.exnum = ex;\n        n = 1;\n        while (n < m) n <<= 1;\n\n        tree = new T[(n << 1) - 1];\n        for (int i = 0; i < tree.Length; i++) tree[i] = ini;\n        for (int i = 0; i < m; ++i) update(i, ini);\n    }\n    public void update(int j, T x)\n    {\n        int i = j + n - 1;\n        tree[i] = x;\n        while (i > 0)\n        {\n            i = (i - 1) >> 1;\n            tree[i] = f(tree[(i << 1) + 1], tree[(i << 1) + 2]);\n        }\n    }\n    public T look(int i) { return tree[i + n - 1]; }\n\n    // [s, t]\n    public T run(int s, int t) { return query(s, t + 1, 0, 0, n); }\n    T query(int s, int t, int k, int l, int r)\n    {\n        if (r <= s || t <= l) return exnum;\n        if (s <= l && r <= t) return tree[k];\n\n        return f(query(s, t, (k << 1) + 1, l, (l + r) >> 1), query(s, t, (k + 1) << 1, (l + r) >> 1, r));\n    }\n}\n\nclass PriorityQueue<T>\n{\n    private Comparison<T> comp;\n    private List<T> list;\n    private int count;\n    public PriorityQueue() : this((x, y) => ((IComparable<T>)x).CompareTo(y)) { }\n    public PriorityQueue(Comparison<T> comparison)\n    {\n        comp = comparison;\n        list = new List<T>();\n        count = 0;\n    }\n    public void Enqueue(T x)\n    {\n        var pos = count++;\n        list.Add(x);\n        while (pos > 0)\n        {\n            var p = (pos - 1) / 2;\n            if (comp(list[p], x) <= 0) break;\n            list[pos] = list[p];\n            pos = p;\n        }\n        list[pos] = x;\n    }\n    public T Dequeue()\n    {\n        var value = list[0];\n        var x = list[--count];\n        list.RemoveAt(count);\n        if (count == 0) return value;\n        var pos = 0;\n        while (pos * 2 + 1 < count)\n        {\n            var a = 2 * pos + 1;\n            var b = 2 * pos + 2;\n            if (b < count && comp(list[b], list[a]) < 0) a = b;\n            if (comp(list[a], x) >= 0) break;\n            list[pos] = list[a];\n            pos = a;\n        }\n        list[pos] = x;\n        return value;\n    }\n    public T Peek() { return list[0]; }\n    public bool Any() { return count > 0; }\n    public int Count() { return count; }\n}\n\nnamespace Codeforces\n{\n    class Program\n    {\n        class mymath\n        {\n            static int Mod = 1000000007;\n            public void setMod(int m) { Mod = m; }\n            public bool isprime(long a)\n            {\n                if (a < 2) return false;\n                for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n                return true;\n            }\n            public bool[] sieve(int n)\n            {\n                var isp = new bool[n + 1];\n                for (int i = 2; i <= n; i++) isp[i] = true;\n                for (int i = 2; i * i <= n; i++) if (isp[i]) for (int j = i * i; j <= n; j += i) isp[j] = false;\n                return isp;\n            }\n            public List<int> getprimes(int n)\n            {\n                var prs = new List<int>();\n                var isp = sieve(n);\n                for (int i = 2; i <= n; i++) if (isp[i]) prs.Add(i);\n                return prs;\n            }\n            public long[][] E(int n)\n            {\n                var ret = new long[n][];\n                for (int i = 0; i < n; i++)\n                {\n                    ret[i] = new long[n];\n                    ret[i][i] = 1;\n                }\n                return ret;\n            }\n            public long[][] powmat(long[][] A, long n)\n            {\n                if (n == 0) return E(A.Length);\n                var t = powmat(A, n / 2);\n                if ((n & 1) == 0) return mulmat(t, t);\n                return mulmat(mulmat(t, t), A);\n            }\n            public long[] mulmat(long[][] A, long[] x)\n            {\n                int n = A.Length, m = x.Length;\n                var ans = new long[n];\n                for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) ans[i] = (ans[i] + x[j] * A[i][j]) % Mod;\n                return ans;\n            }\n            public long[][] mulmat(long[][] A, long[][] B)\n            {\n                int n = A.Length, m = B[0].Length, l = B.Length;\n                var ans = new long[n][];\n                for (int i = 0; i < n; i++)\n                {\n                    ans[i] = new long[m];\n                    for (int j = 0; j < m; j++) for (int k = 0; k < l; k++) ans[i][j] = (ans[i][j] + A[i][k] * B[k][j]) % Mod;\n                }\n                return ans;\n            }\n            public long[] addmat(long[] x, long[] y)\n            {\n                int n = x.Length;\n                var ans = new long[n];\n                for (int i = 0; i < n; i++) ans[i] = (x[i] + y[i]) % Mod;\n                return ans;\n            }\n            public long[][] addmat(long[][] A, long[][] B)\n            {\n                int n = A.Length, m = A[0].Length;\n                var ans = new long[n][];\n                for (int i = 0; i < n; i++) ans[i] = addmat(A[i], B[i]);\n                return ans;\n            }\n            public long powmod(long a, long b)\n            {\n                if (a >= Mod) return powmod(a % Mod, b);\n                if (a == 0) return 0;\n                if (b == 0) return 1;\n                var t = powmod(a, b / 2);\n                if ((b & 1) == 0) return t * t % Mod;\n                return t * t % Mod * a % Mod;\n            }\n            public long inv(long a) { return powmod(a, Mod - 2); }\n            public long gcd(long a, long b)\n            {\n                while (b > 0) { var t = a % b; a = b; b = t; }\n                return a;\n            }\n            public long lcm(long a, long b) { return a * (b / gcd(a, b)); }\n            public long Comb(int n, int r)\n            {\n                if (n < 0 || r < 0 || r > n) return 0;\n                if (n - r < r) r = n - r;\n                if (r == 0) return 1;\n                if (r == 1) return n;\n                var numerator = new int[r];\n                var denominator = new int[r];\n                for (int k = 0; k < r; k++)\n                {\n                    numerator[k] = n - r + k + 1;\n                    denominator[k] = k + 1;\n                }\n                for (int p = 2; p <= r; p++)\n                {\n                    int pivot = denominator[p - 1];\n                    if (pivot > 1)\n                    {\n                        int offset = (n - r) % p;\n                        for (int k = p - 1; k < r; k += p)\n                        {\n                            numerator[k - offset] /= pivot;\n                            denominator[k] /= pivot;\n                        }\n                    }\n                }\n                long result = 1;\n                for (int k = 0; k < r; k++) if (numerator[k] > 1) result = result * numerator[k] % Mod;\n                return result;\n            }\n        }\n\n        const long InfL = 4011686018427387913L;\n        static char[] sep = new char[] { ' ', '/' };\n\n\n        //static int[] dx = { -1, 0, 1, -1, 1, -1, 0, -1 };\n        //static int[] dy = { 1, 1, 1, 0, 0, -1, -1, -1 };\n\n        static int[] dx = { -1, 0, 0, 1 };\n        static int[] dy = { 0, 1, -1, 0 };\n\n\n        /// <summary>\n        /// basic dfs function\n        /// </summary>\n        /// \n        /* public class List_of_List<T> : List<List<T>> { }\n        static int result = 0;\n\n        static List<bool> visited = new List<bool>();\n        static List_of_List<int> adj = new List_of_List<int>();\n\n        static void dfs(int here)\n        {\n            if (here == n * m - 1)\n            {\n                result++;\n                return;\n            }\n            visited[here] = true;\n\n            for(int i = 0; i<adj[here].Count; i++)\n            {\n                int there = adj[here][i];\n                if (!visited[there])\n                    dfs(there);\n                visited[there] = false;   \n            }\n        }\n\n        static void dfsAll()\n        {\n            for(int i = 0; i<adj.Count; i++)\n            {\n                dfs(i);\n            }\n        }\n\n\n        /* static int getInt => int.Parse(Console.ReadLine());\n        static int[] getIntArr => Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToArray();\n        static List<int> getIntList => Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToList<int>();\n        static string getString => Console.ReadLine().Trim();\n        static string[] getStrArr => Console.ReadLine().Trim().Split(sep);\n        static List<string> getStrList => Console.ReadLine().Trim().Split(sep).ToList<string>();\n        */\n        static int m;\n        static int n;\n        static int[] board;\n        static int[] cache;\n        static int[] input = new int[100001];\n        static int[,] capacity;\n        static int[,] flow;\n        static bool[,] adj;\n        static List<bool> visited;\n        static List<int> m_match;\n        static List<int> n_match;\n\n        static void Main(string[] args)\n        {\n            string[] str_input = Console.ReadLine().Split(' ');\n            int[] input = new int[str_input.Count()];\n            input[0] = int.Parse(str_input[0]);\n            input[1] = int.Parse(str_input[1]);\n\n            while (true)\n            {\n                mymath math = new mymath();\n                capacity = new int[502, 502];\n                flow = new int[502, 502];\n\n                m = input[0];\n                n = input[1];\n                int[] m_arr = new int[m];\n                int[] n_arr = new int[n];\n                for(int i = 0; i< (m-1)/10 + 1; i++)\n                {\n                    string[] m_input = Console.ReadLine().Split(' ');\n                    for(int j = 0; j< m_input.Count(); j++)\n                    {\n                        m_arr[i * 10 + j] = int.Parse(m_input[j]);\n                    }\n                }\n                for (int i = 0; i < (n-1)/10 + 1; i++)\n                {\n                    string[] n_input = Console.ReadLine().Split(' ');\n                    for (int j = 0; j < n_input.Count(); j++)\n                    {\n                        n_arr[i * 10 + j] = int.Parse(n_input[j]);\n                    }\n                }\n\n                adj = new bool[m,n];\n\n                m_match = new List<int>();\n                n_match = new List<int>();\n\n                m_match.Capacity = m;\n\n                for(int i = 0; i<m; i++)\n                {\n                    for(int j = 0; j<n; j++)\n                    {\n                        if (math.gcd(m_arr[i], n_arr[j]) > 1)\n                        {\n                            adj[i, j] = true;\n                        }\n                    }\n                }\n\n\n                Console.WriteLine(bipartite_match());\n\n                str_input = Console.ReadLine().Split(' ');\n                input = new int[str_input.Count()];\n                input[0] = int.Parse(str_input[0]);\n                input[1] = int.Parse(str_input[1]);\n                if (input[0] == 0 && input[1] == 0) break;\n            }\n        }\n\n        static bool dfs(int a)\n        {\n            if (visited[a]) return false;\n            visited[a] = true;\n            for(int b = 0; b < n; b++)\n            {\n                if (adj[a, b])\n                {\n                    if(n_match[b] == -1 || dfs(n_match[b]))\n                    {\n                        m_match[a] = b;\n                        n_match[b] = a;\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        static int bipartite_match()\n        {\n            m_match = new List<int>();\n            for(int i = 0; i<m; i++)\n            {\n                m_match.Add(-1);\n            }\n            n_match = new List<int>();\n            for(int i = 0; i<n; i++)\n            {\n                n_match.Add(-1);\n            }\n\n            int size = 0;\n            for (int start = 0; start < m; start++)\n            {\n                visited = new List<bool>();\n                visited.Capacity = m;\n                for (int i = 0; i < m; i++) visited.Add(false);\n\n                if (dfs(start)) size++;\n            }\n            return size;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\n\nclass Segtree<T>\n{\n    int n;\n    T[] tree;\n    Func<T, T, T> f;\n    T exnum;\n    public Segtree(int m, Func<T, T, T> f, T ex)\n    {\n        this.f = f;\n        this.exnum = ex;\n        n = 1;\n        while (n < m) n <<= 1;\n\n        tree = new T[(n << 1) - 1];\n        for (int i = 0; i < tree.Length; i++) tree[i] = ex;\n    }\n    public Segtree(int m, T ini, Func<T, T, T> f, T ex)\n    {\n        this.f = f;\n        this.exnum = ex;\n        n = 1;\n        while (n < m) n <<= 1;\n\n        tree = new T[(n << 1) - 1];\n        for (int i = 0; i < tree.Length; i++) tree[i] = ini;\n        for (int i = 0; i < m; ++i) update(i, ini);\n    }\n    public void update(int j, T x)\n    {\n        int i = j + n - 1;\n        tree[i] = x;\n        while (i > 0)\n        {\n            i = (i - 1) >> 1;\n            tree[i] = f(tree[(i << 1) + 1], tree[(i << 1) + 2]);\n        }\n    }\n    public T look(int i) { return tree[i + n - 1]; }\n\n    // [s, t]\n    public T run(int s, int t) { return query(s, t + 1, 0, 0, n); }\n    T query(int s, int t, int k, int l, int r)\n    {\n        if (r <= s || t <= l) return exnum;\n        if (s <= l && r <= t) return tree[k];\n\n        return f(query(s, t, (k << 1) + 1, l, (l + r) >> 1), query(s, t, (k + 1) << 1, (l + r) >> 1, r));\n    }\n}\n\nclass PriorityQueue<T>\n{\n    private Comparison<T> comp;\n    private List<T> list;\n    private int count;\n    public PriorityQueue() : this((x, y) => ((IComparable<T>)x).CompareTo(y)) { }\n    public PriorityQueue(Comparison<T> comparison)\n    {\n        comp = comparison;\n        list = new List<T>();\n        count = 0;\n    }\n    public void Enqueue(T x)\n    {\n        var pos = count++;\n        list.Add(x);\n        while (pos > 0)\n        {\n            var p = (pos - 1) / 2;\n            if (comp(list[p], x) <= 0) break;\n            list[pos] = list[p];\n            pos = p;\n        }\n        list[pos] = x;\n    }\n    public T Dequeue()\n    {\n        var value = list[0];\n        var x = list[--count];\n        list.RemoveAt(count);\n        if (count == 0) return value;\n        var pos = 0;\n        while (pos * 2 + 1 < count)\n        {\n            var a = 2 * pos + 1;\n            var b = 2 * pos + 2;\n            if (b < count && comp(list[b], list[a]) < 0) a = b;\n            if (comp(list[a], x) >= 0) break;\n            list[pos] = list[a];\n            pos = a;\n        }\n        list[pos] = x;\n        return value;\n    }\n    public T Peek() { return list[0]; }\n    public bool Any() { return count > 0; }\n    public int Count() { return count; }\n}\n\nnamespace Codeforces\n{\n    class Program\n    {\n        class mymath\n        {\n            static int Mod = 1000000007;\n            public void setMod(int m) { Mod = m; }\n            public bool isprime(long a)\n            {\n                if (a < 2) return false;\n                for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n                return true;\n            }\n            public bool[] sieve(int n)\n            {\n                var isp = new bool[n + 1];\n                for (int i = 2; i <= n; i++) isp[i] = true;\n                for (int i = 2; i * i <= n; i++) if (isp[i]) for (int j = i * i; j <= n; j += i) isp[j] = false;\n                return isp;\n            }\n            public List<int> getprimes(int n)\n            {\n                var prs = new List<int>();\n                var isp = sieve(n);\n                for (int i = 2; i <= n; i++) if (isp[i]) prs.Add(i);\n                return prs;\n            }\n            public long[][] E(int n)\n            {\n                var ret = new long[n][];\n                for (int i = 0; i < n; i++)\n                {\n                    ret[i] = new long[n];\n                    ret[i][i] = 1;\n                }\n                return ret;\n            }\n            public long[][] powmat(long[][] A, long n)\n            {\n                if (n == 0) return E(A.Length);\n                var t = powmat(A, n / 2);\n                if ((n & 1) == 0) return mulmat(t, t);\n                return mulmat(mulmat(t, t), A);\n            }\n            public long[] mulmat(long[][] A, long[] x)\n            {\n                int n = A.Length, m = x.Length;\n                var ans = new long[n];\n                for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) ans[i] = (ans[i] + x[j] * A[i][j]) % Mod;\n                return ans;\n            }\n            public long[][] mulmat(long[][] A, long[][] B)\n            {\n                int n = A.Length, m = B[0].Length, l = B.Length;\n                var ans = new long[n][];\n                for (int i = 0; i < n; i++)\n                {\n                    ans[i] = new long[m];\n                    for (int j = 0; j < m; j++) for (int k = 0; k < l; k++) ans[i][j] = (ans[i][j] + A[i][k] * B[k][j]) % Mod;\n                }\n                return ans;\n            }\n            public long[] addmat(long[] x, long[] y)\n            {\n                int n = x.Length;\n                var ans = new long[n];\n                for (int i = 0; i < n; i++) ans[i] = (x[i] + y[i]) % Mod;\n                return ans;\n            }\n            public long[][] addmat(long[][] A, long[][] B)\n            {\n                int n = A.Length, m = A[0].Length;\n                var ans = new long[n][];\n                for (int i = 0; i < n; i++) ans[i] = addmat(A[i], B[i]);\n                return ans;\n            }\n            public long powmod(long a, long b)\n            {\n                if (a >= Mod) return powmod(a % Mod, b);\n                if (a == 0) return 0;\n                if (b == 0) return 1;\n                var t = powmod(a, b / 2);\n                if ((b & 1) == 0) return t * t % Mod;\n                return t * t % Mod * a % Mod;\n            }\n            public long inv(long a) { return powmod(a, Mod - 2); }\n            public long gcd(long a, long b)\n            {\n                while (b > 0) { var t = a % b; a = b; b = t; }\n                return a;\n            }\n            public long lcm(long a, long b) { return a * (b / gcd(a, b)); }\n            public long Comb(int n, int r)\n            {\n                if (n < 0 || r < 0 || r > n) return 0;\n                if (n - r < r) r = n - r;\n                if (r == 0) return 1;\n                if (r == 1) return n;\n                var numerator = new int[r];\n                var denominator = new int[r];\n                for (int k = 0; k < r; k++)\n                {\n                    numerator[k] = n - r + k + 1;\n                    denominator[k] = k + 1;\n                }\n                for (int p = 2; p <= r; p++)\n                {\n                    int pivot = denominator[p - 1];\n                    if (pivot > 1)\n                    {\n                        int offset = (n - r) % p;\n                        for (int k = p - 1; k < r; k += p)\n                        {\n                            numerator[k - offset] /= pivot;\n                            denominator[k] /= pivot;\n                        }\n                    }\n                }\n                long result = 1;\n                for (int k = 0; k < r; k++) if (numerator[k] > 1) result = result * numerator[k] % Mod;\n                return result;\n            }\n        }\n\n        const long InfL = 4011686018427387913L;\n        static char[] sep = new char[] { ' ', '/' };\n\n\n        //static int[] dx = { -1, 0, 1, -1, 1, -1, 0, -1 };\n        //static int[] dy = { 1, 1, 1, 0, 0, -1, -1, -1 };\n\n        static int[] dx = { -1, 0, 0, 1 };\n        static int[] dy = { 0, 1, -1, 0 };\n\n\n        /// <summary>\n        /// basic dfs function\n        /// </summary>\n        /// \n        /* public class List_of_List<T> : List<List<T>> { }\n        static int result = 0;\n\n        static List<bool> visited = new List<bool>();\n        static List_of_List<int> adj = new List_of_List<int>();\n\n        static void dfs(int here)\n        {\n            if (here == n * m - 1)\n            {\n                result++;\n                return;\n            }\n            visited[here] = true;\n\n            for(int i = 0; i<adj[here].Count; i++)\n            {\n                int there = adj[here][i];\n                if (!visited[there])\n                    dfs(there);\n                visited[there] = false;   \n            }\n        }\n\n        static void dfsAll()\n        {\n            for(int i = 0; i<adj.Count; i++)\n            {\n                dfs(i);\n            }\n        }\n\n\n        /* static int getInt => int.Parse(Console.ReadLine());\n        static int[] getIntArr => Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToArray();\n        static List<int> getIntList => Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToList<int>();\n        static string getString => Console.ReadLine().Trim();\n        static string[] getStrArr => Console.ReadLine().Trim().Split(sep);\n        static List<string> getStrList => Console.ReadLine().Trim().Split(sep).ToList<string>();\n        */\n        static int m;\n        static int n;\n        static int[] board;\n        static int[] cache;\n        static int[] input = new int[100001];\n        static int[,] capacity;\n        static int[,] flow;\n        static bool[,] adj;\n        static List<bool> visited;\n        static List<int> m_match;\n        static List<int> n_match;\n\n        static void Main(string[] args)\n        {\n            string[] str_input = Console.ReadLine().Split(' ');\n            int[] input = new int[str_input.Count()];\n            input[0] = int.Parse(str_input[0]);\n            input[1] = int.Parse(str_input[1]);\n\n            while (true)\n            {\n                mymath math = new mymath();\n                capacity = new int[502, 502];\n                flow = new int[502, 502];\n\n                m = input[0];\n                n = input[1];\n                int[] m_arr = new int[m];\n                int[] n_arr = new int[n];\n                for(int i = 0; i< (m-1)/10 + 1; i++)\n                {\n                    string[] m_input = Console.ReadLine().Split(' ');\n                    for(int j = 0; j< m_input.Count(); j++)\n                    {\n                        m_arr[i * 10 + j] = int.Parse(m_input[j]);\n                    }\n                }\n                for (int i = 0; i < (n-1)/10 + 1; i++)\n                {\n                    string[] n_input = Console.ReadLine().Split(' ');\n                    for (int j = 0; j < n_input.Count(); j++)\n                    {\n                        n_arr[i * 10 + j] = int.Parse(n_input[j]);\n                    }\n                }\n\n                adj = new bool[m,n];\n\n                m_match = new List<int>();\n                n_match = new List<int>();\n\n                m_match.Capacity = m;\n\n                for(int i = 0; i<m; i++)\n                {\n                    for(int j = 0; j<n; j++)\n                    {\n                        if (math.gcd(m_arr[i], n_arr[j]) > 1)\n                        {\n                            adj[i, j] = true;\n                        }\n                    }\n                }\n\n\n                Console.WriteLine(bipartite_match());\n\n                str_input = Console.ReadLine().Split(' ');\n                input = new int[str_input.Count()];\n                input[0] = int.Parse(str_input[0]);\n                input[1] = int.Parse(str_input[1]);\n                if (input[0] == 0 && input[1] == 0) break;\n            }\n        }\n\n        static bool dfs(int a)\n        {\n            if (visited[a]) return false;\n            visited[a] = true;\n            for(int b = 0; b < n; b++)\n            {\n                if (adj[a, b])\n                {\n                    if(n_match[b] == -1 || dfs(n_match[b]))\n                    {\n                        m_match[a] = b;\n                        n_match[b] = a;\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        static int bipartite_match()\n        {\n            m_match = new List<int>();\n            for(int i = 0; i<m; i++)\n            {\n                m_match.Add(-1);\n            }\n            n_match = new List<int>();\n            for(int i = 0; i<n; i++)\n            {\n                n_match.Add(-1);\n            }\n\n            int size = 0;\n            for (int start = 0; start < m; start++)\n            {\n                visited = new List<bool>();\n                visited.Capacity = m;\n                for (int i = 0; i < m; i++) visited.Add(false);\n\n                if (dfs(start)) size++;\n            }\n            return size;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing Number = System.Int64;\nusing C = System.Int32;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n\n            for (;;)\n            {\n                var n = ri;\n                var m = ri;\n                if (n == 0) return;\n                var a = Enumerate(n, x => ri);\n                var b = Enumerate(m, x => ri);\n                var G = new MaxFlow(n + m + 2);\n                var src = n + m;\n                var sink = src + 1;\n                for (int i = 0; i < n; i++)\n                {\n                    G.AddDirectedEdge(src, i, 1);\n                    for (int j = 0; j < m; j++)\n                        if (gcd(a[i], b[j]) != 1)\n                            G.AddDirectedEdge(i, j + n, 1);\n                }\n                for (int i = 0; i < m; i++)\n                    G.AddDirectedEdge(i + n, sink, 1);\n\n                IO.Printer.Out.WriteLine(G.Execute(src, sink));\n            }\n        }\n        int gcd(int x, int y)\n        {\n            if (x == 0) return y;\n            if (y == 0) return x;\n            return gcd(y, x % y);\n        }\n\n        const long INF = 1L << 60;\n        //int[] dx = { -1, 0, 1, 0 };\n        //int[] dy = { 0, 1, 0, -1 };\n        //*\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        //*/\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \")\n    {\n        return string.Join(st, ie.Select(x => x.ToString()).ToArray());\n        //return string.Join(st, ie);\n    }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n\n\n\n\n#region MaxFlow\npublic partial class MaxFlow\n{\n    public readonly List<Edge>[] G;\n    readonly int[] lv, iter;\n    public MaxFlow(int V)\n    {\n        G = new List<Edge>[V];\n        lv = new int[V];\n        iter = new int[V];\n        for (int i = 0; i < G.Length; i++)\n            G[i] = new List<Edge>();\n    }\n\n    public void AddDirectedEdge(int from, int to, C cap)\n    {\n        addEdge(from, to, cap, 0);\n    }\n\n    public void AddUndirectedEdge(int from, int to, C cap)\n    {\n        addEdge(from, to, cap, cap);\n    }\n    void addEdge(int f, int t, C c1, C c2)\n    {\n        var a = new Edge(t, c1);\n        var b = new Edge(f, c2);\n        Edge.Link(a, b);\n        G[f].Add(a);\n        G[t].Add(b);\n    }\n\n\n    public C Execute(int src, int sink, C f = -1)\n    {\n        C flow = 0;\n        if (f < 0) f = C.MaxValue;\n        while (f > 0)\n        {\n            bfs(src);\n            if (lv[sink] == 0) return flow;\n            Array.Clear(iter, 0, iter.Length);\n            C df;\n            while ((df = dfs(src, sink, f)) > 0) { flow += df; f -= df; }\n        }\n        return flow;\n    }\n\n    void bfs(int s)\n    {\n        Array.Clear(lv, 0, lv.Length);\n        var q = new Queue<int>();\n        lv[s] = 1;\n        q.Enqueue(s);\n        while (q.Count > 0)\n        {\n            var v = q.Dequeue();\n            foreach (var e in G[v])\n                if (e.Cap > 0 && lv[e.To] == 0)\n                {\n                    lv[e.To] = lv[v] + 1;\n                    q.Enqueue(e.To);\n                }\n        }\n\n    }\n    C dfs(int v, int t, C f)\n    {\n        if (v == t) return f;\n        C ret = 0;\n        for (; iter[v] < G[v].Count; iter[v]++)\n        {\n            var e = G[v][iter[v]];\n            if (e.Cap <= 0 || lv[v] >= lv[e.To]) continue;\n            C df = dfs(e.To, t, Math.Min(f, e.Cap));\n            if (df <= 0) continue;\n            e.Cap -= df;\n            e.Rev.Cap += df;\n            ret += df; f -= df;\n            if (f == 0) break;\n        }\n        return ret;\n\n    }\n}\npublic class Edge\n{\n    public static void Link(Edge e1, Edge e2)\n    {\n        e1.Rev = e2; e2.Rev = e1;\n    }\n    public int To { get; private set; }\n    public Edge Rev { get; private set; }\n    public C Cap { get; set; }\n    public Edge(int t, C c)\n    {\n        To = t;\n        Cap = c;\n    }\n    public override string ToString()\n    {\n        return string.Format(\"to: {0}, cap: {1}\", To, Cap);\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Read read = new Read();\n        string s;\n\n        while ((s = Console.ReadLine()) != \"0 0\")\n        {\n            int[] t = Array.ConvertAll(s.Split(), int.Parse);\n            int A = t[0];\n            int B = t[1];\n            int[] a = new int[A];\n            int[] b = new int[B];\n            for (int i = 0; i < A; i++) { a[i] = read.NextInt(); }\n            for (int i = 0; i < B; i++) { b[i] = read.NextInt(); }\n\n            int S = A + B;\n            List<Edge>[] edges = Enumerable.Range(0, S + 2).Select(i => new List<Edge>()).ToArray();\n            for (int i = 0; i < A; i++) { Edge.Add(edges, S, i, 1); }\n            for (int i = 0; i < B; i++) { Edge.Add(edges, A + i, S + 1, 1); }\n            for (int i = 0; i < A; i++)\n            {\n                for (int j = 0; j < B; j++)\n                {\n                    if (BigInteger.GreatestCommonDivisor(a[i], b[j]) > 1)\n                    {\n                        Edge.Add(edges, i, A + j, 1);\n                    }\n                }\n            }\n\n            int ans = new MaxFlow().Run(edges, S, S + 1);\n            Console.WriteLine(ans);\n        }\n\n        Console.ReadLine();\n    }\n\n    class Edge\n    {\n        public int to, capacity, reverse;\n        public Edge(int to, int capacity, int reverse)\n        {\n            this.to = to;\n            this.capacity = capacity;\n            this.reverse = reverse;\n        }\n        public static void Add(List<Edge>[] Edges, int from, int to, int capacity)\n        {\n            Edges[from].Add(new Edge(to, capacity, Edges[to].Count));\n            Edges[to].Add(new Edge(from, 0, Edges[from].Count - 1));\n        }\n    }\n\n    class MaxFlow\n    {\n        readonly int INF = (int)1e9;\n        List<Edge>[] Edges;\n        int T;\n        bool[] used;\n\n        public int Run(List<Edge>[] edges, int s, int t)\n        {\n            Edges = edges;\n            T = t;\n            int res = 0;\n            while (true)\n            {\n                used = new bool[Edges.Length];\n                int f = DFS(s, INF);\n                if (f == 0) return res;\n                res += f;\n            }\n        }\n\n        int DFS(int v, int flow)\n        {\n            if (v == T) return flow;\n            used[v] = true;\n            for (int i = 0; i < Edges[v].Count; i++)\n            {\n                Edge e = Edges[v][i];\n                if (!used[e.to] && e.capacity > 0)\n                {\n                    int d = DFS(e.to, Math.Min(flow, e.capacity));\n                    if (d > 0)\n                    {\n                        e.capacity -= d;\n                        Edges[e.to][e.reverse].capacity += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n    }\n\n\n\n    class Read\n    {\n        Queue<string> que = new Queue<string>();\n        \n        public int NextInt()\n        {\n            if (que.Count == 0) { Enqueue(); }\n            return int.Parse(que.Dequeue());\n        }\n\n        private void Enqueue()\n        {\n            foreach (string s in Console.ReadLine().Split())\n            {\n                que.Enqueue(s);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\n\nclass Segtree<T>\n{\n    int n;\n    T[] tree;\n    Func<T, T, T> f;\n    T exnum;\n    public Segtree(int m, Func<T, T, T> f, T ex)\n    {\n        this.f = f;\n        this.exnum = ex;\n        n = 1;\n        while (n < m) n <<= 1;\n\n        tree = new T[(n << 1) - 1];\n        for (int i = 0; i < tree.Length; i++) tree[i] = ex;\n    }\n    public Segtree(int m, T ini, Func<T, T, T> f, T ex)\n    {\n        this.f = f;\n        this.exnum = ex;\n        n = 1;\n        while (n < m) n <<= 1;\n\n        tree = new T[(n << 1) - 1];\n        for (int i = 0; i < tree.Length; i++) tree[i] = ini;\n        for (int i = 0; i < m; ++i) update(i, ini);\n    }\n    public void update(int j, T x)\n    {\n        int i = j + n - 1;\n        tree[i] = x;\n        while (i > 0)\n        {\n            i = (i - 1) >> 1;\n            tree[i] = f(tree[(i << 1) + 1], tree[(i << 1) + 2]);\n        }\n    }\n    public T look(int i) { return tree[i + n - 1]; }\n\n    // [s, t]\n    public T run(int s, int t) { return query(s, t + 1, 0, 0, n); }\n    T query(int s, int t, int k, int l, int r)\n    {\n        if (r <= s || t <= l) return exnum;\n        if (s <= l && r <= t) return tree[k];\n\n        return f(query(s, t, (k << 1) + 1, l, (l + r) >> 1), query(s, t, (k + 1) << 1, (l + r) >> 1, r));\n    }\n}\n\nclass PriorityQueue<T>\n{\n    private Comparison<T> comp;\n    private List<T> list;\n    private int count;\n    public PriorityQueue() : this((x, y) => ((IComparable<T>)x).CompareTo(y)) { }\n    public PriorityQueue(Comparison<T> comparison)\n    {\n        comp = comparison;\n        list = new List<T>();\n        count = 0;\n    }\n    public void Enqueue(T x)\n    {\n        var pos = count++;\n        list.Add(x);\n        while (pos > 0)\n        {\n            var p = (pos - 1) / 2;\n            if (comp(list[p], x) <= 0) break;\n            list[pos] = list[p];\n            pos = p;\n        }\n        list[pos] = x;\n    }\n    public T Dequeue()\n    {\n        var value = list[0];\n        var x = list[--count];\n        list.RemoveAt(count);\n        if (count == 0) return value;\n        var pos = 0;\n        while (pos * 2 + 1 < count)\n        {\n            var a = 2 * pos + 1;\n            var b = 2 * pos + 2;\n            if (b < count && comp(list[b], list[a]) < 0) a = b;\n            if (comp(list[a], x) >= 0) break;\n            list[pos] = list[a];\n            pos = a;\n        }\n        list[pos] = x;\n        return value;\n    }\n    public T Peek() { return list[0]; }\n    public bool Any() { return count > 0; }\n    public int Count() { return count; }\n}\n\nnamespace Codeforces\n{\n    class Program\n    {\n        class mymath\n        {\n            static int Mod = 1000000007;\n            public void setMod(int m) { Mod = m; }\n            public bool isprime(long a)\n            {\n                if (a < 2) return false;\n                for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n                return true;\n            }\n            public bool[] sieve(int n)\n            {\n                var isp = new bool[n + 1];\n                for (int i = 2; i <= n; i++) isp[i] = true;\n                for (int i = 2; i * i <= n; i++) if (isp[i]) for (int j = i * i; j <= n; j += i) isp[j] = false;\n                return isp;\n            }\n            public List<int> getprimes(int n)\n            {\n                var prs = new List<int>();\n                var isp = sieve(n);\n                for (int i = 2; i <= n; i++) if (isp[i]) prs.Add(i);\n                return prs;\n            }\n            public long[][] E(int n)\n            {\n                var ret = new long[n][];\n                for (int i = 0; i < n; i++)\n                {\n                    ret[i] = new long[n];\n                    ret[i][i] = 1;\n                }\n                return ret;\n            }\n            public long[][] powmat(long[][] A, long n)\n            {\n                if (n == 0) return E(A.Length);\n                var t = powmat(A, n / 2);\n                if ((n & 1) == 0) return mulmat(t, t);\n                return mulmat(mulmat(t, t), A);\n            }\n            public long[] mulmat(long[][] A, long[] x)\n            {\n                int n = A.Length, m = x.Length;\n                var ans = new long[n];\n                for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) ans[i] = (ans[i] + x[j] * A[i][j]) % Mod;\n                return ans;\n            }\n            public long[][] mulmat(long[][] A, long[][] B)\n            {\n                int n = A.Length, m = B[0].Length, l = B.Length;\n                var ans = new long[n][];\n                for (int i = 0; i < n; i++)\n                {\n                    ans[i] = new long[m];\n                    for (int j = 0; j < m; j++) for (int k = 0; k < l; k++) ans[i][j] = (ans[i][j] + A[i][k] * B[k][j]) % Mod;\n                }\n                return ans;\n            }\n            public long[] addmat(long[] x, long[] y)\n            {\n                int n = x.Length;\n                var ans = new long[n];\n                for (int i = 0; i < n; i++) ans[i] = (x[i] + y[i]) % Mod;\n                return ans;\n            }\n            public long[][] addmat(long[][] A, long[][] B)\n            {\n                int n = A.Length, m = A[0].Length;\n                var ans = new long[n][];\n                for (int i = 0; i < n; i++) ans[i] = addmat(A[i], B[i]);\n                return ans;\n            }\n            public long powmod(long a, long b)\n            {\n                if (a >= Mod) return powmod(a % Mod, b);\n                if (a == 0) return 0;\n                if (b == 0) return 1;\n                var t = powmod(a, b / 2);\n                if ((b & 1) == 0) return t * t % Mod;\n                return t * t % Mod * a % Mod;\n            }\n            public long inv(long a) { return powmod(a, Mod - 2); }\n            public long gcd(long a, long b)\n            {\n                while (b > 0) { var t = a % b; a = b; b = t; }\n                return a;\n            }\n            public long lcm(long a, long b) { return a * (b / gcd(a, b)); }\n            public long Comb(int n, int r)\n            {\n                if (n < 0 || r < 0 || r > n) return 0;\n                if (n - r < r) r = n - r;\n                if (r == 0) return 1;\n                if (r == 1) return n;\n                var numerator = new int[r];\n                var denominator = new int[r];\n                for (int k = 0; k < r; k++)\n                {\n                    numerator[k] = n - r + k + 1;\n                    denominator[k] = k + 1;\n                }\n                for (int p = 2; p <= r; p++)\n                {\n                    int pivot = denominator[p - 1];\n                    if (pivot > 1)\n                    {\n                        int offset = (n - r) % p;\n                        for (int k = p - 1; k < r; k += p)\n                        {\n                            numerator[k - offset] /= pivot;\n                            denominator[k] /= pivot;\n                        }\n                    }\n                }\n                long result = 1;\n                for (int k = 0; k < r; k++) if (numerator[k] > 1) result = result * numerator[k] % Mod;\n                return result;\n            }\n        }\n\n        const long InfL = 4011686018427387913L;\n        static char[] sep = new char[] { ' ', '/' };\n\n\n        //static int[] dx = { -1, 0, 1, -1, 1, -1, 0, -1 };\n        //static int[] dy = { 1, 1, 1, 0, 0, -1, -1, -1 };\n\n        static int[] dx = { -1, 0, 0, 1 };\n        static int[] dy = { 0, 1, -1, 0 };\n\n\n        /// <summary>\n        /// basic dfs function\n        /// </summary>\n        /// \n        /* public class List_of_List<T> : List<List<T>> { }\n        static int result = 0;\n\n        static List<bool> visited = new List<bool>();\n        static List_of_List<int> adj = new List_of_List<int>();\n\n        static void dfs(int here)\n        {\n            if (here == n * m - 1)\n            {\n                result++;\n                return;\n            }\n            visited[here] = true;\n\n            for(int i = 0; i<adj[here].Count; i++)\n            {\n                int there = adj[here][i];\n                if (!visited[there])\n                    dfs(there);\n                visited[there] = false;   \n            }\n        }\n\n        static void dfsAll()\n        {\n            for(int i = 0; i<adj.Count; i++)\n            {\n                dfs(i);\n            }\n        }\n\n\n        /* static int getInt => int.Parse(Console.ReadLine());\n        static int[] getIntArr => Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToArray();\n        static List<int> getIntList => Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToList<int>();\n        static string getString => Console.ReadLine().Trim();\n        static string[] getStrArr => Console.ReadLine().Trim().Split(sep);\n        static List<string> getStrList => Console.ReadLine().Trim().Split(sep).ToList<string>();\n        */\n        static int m;\n        static int n;\n        static int[] board;\n        static int[] cache;\n        static int[] input = new int[100001];\n        static int[,] capacity;\n        static int[,] flow;\n        static bool[,] adj;\n        static List<bool> visited;\n        static List<int> m_match;\n        static List<int> n_match;\n\n        static void Main(string[] args)\n        {\n            int[] input = Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToArray();\n\n            while (true)\n            {\n                mymath math = new mymath();\n                capacity = new int[502, 502];\n                flow = new int[502, 502];\n\n                m = input[0];\n                n = input[1];\n                int[] m_arr = new int[m];\n                int[] n_arr = new int[n];\n                for(int i = 0; i< (m-1)/10 + 1; i++)\n                {\n                    int[] input_arr = Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToArray();\n                    for(int j = 0; j<input_arr.Count(); j++)\n                    {\n                        m_arr[i * 10 + j] = input_arr[j];\n                    }\n                }\n                for (int i = 0; i < (n-1)/10 + 1; i++)\n                {\n                    int[] input_arr = Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToArray();\n                    for (int j = 0; j < input_arr.Count(); j++)\n                    {\n                        n_arr[i * 10 + j] = input_arr[j];\n                    }\n                }\n\n                adj = new bool[m,n];\n\n                m_match = new List<int>();\n                n_match = new List<int>();\n\n                m_match.Capacity = m;\n\n                for(int i = 0; i<m; i++)\n                {\n                    for(int j = 0; j<n; j++)\n                    {\n                        if (math.gcd(m_arr[i], n_arr[j]) > 1)\n                        {\n                            adj[i, j] = true;\n                        }\n                    }\n                }\n\n\n                Console.WriteLine(bipartite_match());\n\n                input = Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToArray();\n                if (input[0] == 0 && input[1] == 0) break;\n            }\n        }\n\n        static bool dfs(int a)\n        {\n            if (visited[a]) return false;\n            visited[a] = true;\n            for(int b = 0; b < n; b++)\n            {\n                if (adj[a, b])\n                {\n                    if(n_match[b] == -1 || dfs(n_match[b]))\n                    {\n                        m_match[a] = b;\n                        n_match[b] = a;\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        static int bipartite_match()\n        {\n            m_match = new List<int>();\n            for(int i = 0; i<m; i++)\n            {\n                m_match.Add(-1);\n            }\n            n_match = new List<int>();\n            for(int i = 0; i<n; i++)\n            {\n                n_match.Add(-1);\n            }\n\n            int size = 0;\n            for (int start = 0; start < m; start++)\n            {\n                visited = new List<bool>();\n                visited.Capacity = m;\n                for (int i = 0; i < m; i++) visited.Add(false);\n\n                if (dfs(start)) size++;\n            }\n            return size;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\n#pragma warning disable\n\nclass Segtree<T>\n{\n    int n;\n    T[] tree;\n    Func<T, T, T> f;\n    T exnum;\n    public Segtree(int m, Func<T, T, T> f, T ex)\n    {\n        this.f = f;\n        this.exnum = ex;\n        n = 1;\n        while (n < m) n <<= 1;\n\n        tree = new T[(n << 1) - 1];\n        for (int i = 0; i < tree.Length; i++) tree[i] = ex;\n    }\n    public Segtree(int m, T ini, Func<T, T, T> f, T ex)\n    {\n        this.f = f;\n        this.exnum = ex;\n        n = 1;\n        while (n < m) n <<= 1;\n\n        tree = new T[(n << 1) - 1];\n        for (int i = 0; i < tree.Length; i++) tree[i] = ini;\n        for (int i = 0; i < m; ++i) update(i, ini);\n    }\n    public void update(int j, T x)\n    {\n        int i = j + n - 1;\n        tree[i] = x;\n        while (i > 0)\n        {\n            i = (i - 1) >> 1;\n            tree[i] = f(tree[(i << 1) + 1], tree[(i << 1) + 2]);\n        }\n    }\n    public T look(int i) { return tree[i + n - 1]; }\n\n    // [s, t]\n    public T run(int s, int t) { return query(s, t + 1, 0, 0, n); }\n    T query(int s, int t, int k, int l, int r)\n    {\n        if (r <= s || t <= l) return exnum;\n        if (s <= l && r <= t) return tree[k];\n\n        return f(query(s, t, (k << 1) + 1, l, (l + r) >> 1), query(s, t, (k + 1) << 1, (l + r) >> 1, r));\n    }\n}\n\nclass PriorityQueue<T>\n{\n    private Comparison<T> comp;\n    private List<T> list;\n    private int count;\n    public PriorityQueue() : this((x, y) => ((IComparable<T>)x).CompareTo(y)) { }\n    public PriorityQueue(Comparison<T> comparison)\n    {\n        comp = comparison;\n        list = new List<T>();\n        count = 0;\n    }\n    public void Enqueue(T x)\n    {\n        var pos = count++;\n        list.Add(x);\n        while (pos > 0)\n        {\n            var p = (pos - 1) / 2;\n            if (comp(list[p], x) <= 0) break;\n            list[pos] = list[p];\n            pos = p;\n        }\n        list[pos] = x;\n    }\n    public T Dequeue()\n    {\n        var value = list[0];\n        var x = list[--count];\n        list.RemoveAt(count);\n        if (count == 0) return value;\n        var pos = 0;\n        while (pos * 2 + 1 < count)\n        {\n            var a = 2 * pos + 1;\n            var b = 2 * pos + 2;\n            if (b < count && comp(list[b], list[a]) < 0) a = b;\n            if (comp(list[a], x) >= 0) break;\n            list[pos] = list[a];\n            pos = a;\n        }\n        list[pos] = x;\n        return value;\n    }\n    public T Peek() { return list[0]; }\n    public bool Any() { return count > 0; }\n    public int Count() { return count; }\n}\n\nnamespace Codeforces\n{\n    class Program\n    {\n        class mymath\n        {\n            static int Mod = 1000000007;\n            public void setMod(int m) { Mod = m; }\n            public bool isprime(long a)\n            {\n                if (a < 2) return false;\n                for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n                return true;\n            }\n            public bool[] sieve(int n)\n            {\n                var isp = new bool[n + 1];\n                for (int i = 2; i <= n; i++) isp[i] = true;\n                for (int i = 2; i * i <= n; i++) if (isp[i]) for (int j = i * i; j <= n; j += i) isp[j] = false;\n                return isp;\n            }\n            public List<int> getprimes(int n)\n            {\n                var prs = new List<int>();\n                var isp = sieve(n);\n                for (int i = 2; i <= n; i++) if (isp[i]) prs.Add(i);\n                return prs;\n            }\n            public long[][] E(int n)\n            {\n                var ret = new long[n][];\n                for (int i = 0; i < n; i++)\n                {\n                    ret[i] = new long[n];\n                    ret[i][i] = 1;\n                }\n                return ret;\n            }\n            public long[][] powmat(long[][] A, long n)\n            {\n                if (n == 0) return E(A.Length);\n                var t = powmat(A, n / 2);\n                if ((n & 1) == 0) return mulmat(t, t);\n                return mulmat(mulmat(t, t), A);\n            }\n            public long[] mulmat(long[][] A, long[] x)\n            {\n                int n = A.Length, m = x.Length;\n                var ans = new long[n];\n                for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) ans[i] = (ans[i] + x[j] * A[i][j]) % Mod;\n                return ans;\n            }\n            public long[][] mulmat(long[][] A, long[][] B)\n            {\n                int n = A.Length, m = B[0].Length, l = B.Length;\n                var ans = new long[n][];\n                for (int i = 0; i < n; i++)\n                {\n                    ans[i] = new long[m];\n                    for (int j = 0; j < m; j++) for (int k = 0; k < l; k++) ans[i][j] = (ans[i][j] + A[i][k] * B[k][j]) % Mod;\n                }\n                return ans;\n            }\n            public long[] addmat(long[] x, long[] y)\n            {\n                int n = x.Length;\n                var ans = new long[n];\n                for (int i = 0; i < n; i++) ans[i] = (x[i] + y[i]) % Mod;\n                return ans;\n            }\n            public long[][] addmat(long[][] A, long[][] B)\n            {\n                int n = A.Length, m = A[0].Length;\n                var ans = new long[n][];\n                for (int i = 0; i < n; i++) ans[i] = addmat(A[i], B[i]);\n                return ans;\n            }\n            public long powmod(long a, long b)\n            {\n                if (a >= Mod) return powmod(a % Mod, b);\n                if (a == 0) return 0;\n                if (b == 0) return 1;\n                var t = powmod(a, b / 2);\n                if ((b & 1) == 0) return t * t % Mod;\n                return t * t % Mod * a % Mod;\n            }\n            public long inv(long a) { return powmod(a, Mod - 2); }\n            public long gcd(long a, long b)\n            {\n                while (b > 0) { var t = a % b; a = b; b = t; }\n                return a;\n            }\n            public long lcm(long a, long b) { return a * (b / gcd(a, b)); }\n            public long Comb(int n, int r)\n            {\n                if (n < 0 || r < 0 || r > n) return 0;\n                if (n - r < r) r = n - r;\n                if (r == 0) return 1;\n                if (r == 1) return n;\n                var numerator = new int[r];\n                var denominator = new int[r];\n                for (int k = 0; k < r; k++)\n                {\n                    numerator[k] = n - r + k + 1;\n                    denominator[k] = k + 1;\n                }\n                for (int p = 2; p <= r; p++)\n                {\n                    int pivot = denominator[p - 1];\n                    if (pivot > 1)\n                    {\n                        int offset = (n - r) % p;\n                        for (int k = p - 1; k < r; k += p)\n                        {\n                            numerator[k - offset] /= pivot;\n                            denominator[k] /= pivot;\n                        }\n                    }\n                }\n                long result = 1;\n                for (int k = 0; k < r; k++) if (numerator[k] > 1) result = result * numerator[k] % Mod;\n                return result;\n            }\n        }\n\n        const long InfL = 4011686018427387913L;\n        static char[] sep = new char[] { ' ', '/' };\n\n\n        //static int[] dx = { -1, 0, 1, -1, 1, -1, 0, -1 };\n        //static int[] dy = { 1, 1, 1, 0, 0, -1, -1, -1 };\n\n        static int[] dx = { -1, 0, 0, 1 };\n        static int[] dy = { 0, 1, -1, 0 };\n\n\n        /// <summary>\n        /// basic dfs function\n        /// </summary>\n        /// \n        /* public class List_of_List<T> : List<List<T>> { }\n        static int result = 0;\n\n        static List<bool> visited = new List<bool>();\n        static List_of_List<int> adj = new List_of_List<int>();\n\n        static void dfs(int here)\n        {\n            if (here == n * m - 1)\n            {\n                result++;\n                return;\n            }\n            visited[here] = true;\n\n            for(int i = 0; i<adj[here].Count; i++)\n            {\n                int there = adj[here][i];\n                if (!visited[there])\n                    dfs(there);\n                visited[there] = false;   \n            }\n        }\n\n        static void dfsAll()\n        {\n            for(int i = 0; i<adj.Count; i++)\n            {\n                dfs(i);\n            }\n        }\n\n\n        /* static int getInt => int.Parse(Console.ReadLine());\n        static int[] getIntArr => Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToArray();\n        static List<int> getIntList => Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToList<int>();\n        static string getString => Console.ReadLine().Trim();\n        static string[] getStrArr => Console.ReadLine().Trim().Split(sep);\n        static List<string> getStrList => Console.ReadLine().Trim().Split(sep).ToList<string>();\n        */\n        static int m;\n        static int n;\n        static int[] input = new int[100001];\n        static int[,] capacity;\n        static int[,] flow;\n        static bool[,] adj;\n        static List<bool> visited;\n        static List<int> m_match;\n        static List<int> n_match;\n\n        static void Main(string[] args)\n        {\n            string[] str_input = Console.ReadLine().Split(' ');\n            int[] input = new int[str_input.Count()];\n            input[0] = int.Parse(str_input[0]);\n            input[1] = int.Parse(str_input[1]);\n\n            while (true)\n            {\n                mymath math = new mymath();\n                capacity = new int[502, 502];\n                flow = new int[502, 502];\n\n                m = input[0];\n                n = input[1];\n                int[] m_arr = new int[m];\n                int[] n_arr = new int[n];\n                for(int i = 0; i< (m-1)/10 + 1; i++)\n                {\n                    string[] m_input = Console.ReadLine().Split(' ');\n                    for(int j = 0; j< m_input.Count(); j++)\n                    {\n                        m_arr[i * 10 + j] = int.Parse(m_input[j]);\n                    }\n                }\n                for (int i = 0; i < (n-1)/10 + 1; i++)\n                {\n                    string[] n_input = Console.ReadLine().Split(' ');\n                    for (int j = 0; j < n_input.Count(); j++)\n                    {\n                        n_arr[i * 10 + j] = int.Parse(n_input[j]);\n                    }\n                }\n\n                adj = new bool[m,n];\n\n                m_match = new List<int>();\n                n_match = new List<int>();\n\n                m_match.Capacity = m;\n\n                for(int i = 0; i<m; i++)\n                {\n                    for(int j = 0; j<n; j++)\n                    {\n                        if (math.gcd(m_arr[i], n_arr[j]) > 1)\n                        {\n                            adj[i, j] = true;\n                        }\n                    }\n                }\n\n                Console.WriteLine(bipartite_match());\n\n                str_input = Console.ReadLine().Split(' ');\n                input = new int[str_input.Count()];\n                input[0] = int.Parse(str_input[0]);\n                input[1] = int.Parse(str_input[1]);\n                if (input[0] == 0 && input[1] == 0) break;\n            }\n        }\n\n        static bool dfs(int a)\n        {\n            if (visited[a]) return false;\n            visited[a] = true;\n            for(int b = 0; b < n; b++)\n            {\n                if (adj[a, b])\n                {\n                    if(n_match[b] == -1 || dfs(n_match[b]))\n                    {\n                        m_match[a] = b;\n                        n_match[b] = a;\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        static int bipartite_match()\n        {\n            m_match = new List<int>();\n            for(int i = 0; i<m; i++)\n            {\n                m_match.Add(-1);\n            }\n            n_match = new List<int>();\n            for(int i = 0; i<n; i++)\n            {\n                n_match.Add(-1);\n            }\n\n            int size = 0;\n            for (int start = 0; start < m; start++)\n            {\n                visited = new List<bool>();\n                visited.Capacity = m;\n                for (int i = 0; i < m; i++) visited.Add(false);\n\n                if (dfs(start)) size++;\n            }\n            return size;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass Segtree<T>\n{\n    int n;\n    T[] tree;\n    Func<T, T, T> f;\n    T exnum;\n    public Segtree(int m, Func<T, T, T> f, T ex)\n    {\n        this.f = f;\n        this.exnum = ex;\n        n = 1;\n        while (n < m) n <<= 1;\n\n        tree = new T[(n << 1) - 1];\n        for (int i = 0; i < tree.Length; i++) tree[i] = ex;\n    }\n    public Segtree(int m, T ini, Func<T, T, T> f, T ex)\n    {\n        this.f = f;\n        this.exnum = ex;\n        n = 1;\n        while (n < m) n <<= 1;\n\n        tree = new T[(n << 1) - 1];\n        for (int i = 0; i < tree.Length; i++) tree[i] = ini;\n        for (int i = 0; i < m; ++i) update(i, ini);\n    }\n    public void update(int j, T x)\n    {\n        int i = j + n - 1;\n        tree[i] = x;\n        while (i > 0)\n        {\n            i = (i - 1) >> 1;\n            tree[i] = f(tree[(i << 1) + 1], tree[(i << 1) + 2]);\n        }\n    }\n    public T look(int i) { return tree[i + n - 1]; }\n\n    // [s, t]\n    public T run(int s, int t) { return query(s, t + 1, 0, 0, n); }\n    T query(int s, int t, int k, int l, int r)\n    {\n        if (r <= s || t <= l) return exnum;\n        if (s <= l && r <= t) return tree[k];\n\n        return f(query(s, t, (k << 1) + 1, l, (l + r) >> 1), query(s, t, (k + 1) << 1, (l + r) >> 1, r));\n    }\n}\n\nclass PriorityQueue<T>\n{\n    private Comparison<T> comp;\n    private List<T> list;\n    private int count;\n    public PriorityQueue() : this((x, y) => ((IComparable<T>)x).CompareTo(y)) { }\n    public PriorityQueue(Comparison<T> comparison)\n    {\n        comp = comparison;\n        list = new List<T>();\n        count = 0;\n    }\n    public void Enqueue(T x)\n    {\n        var pos = count++;\n        list.Add(x);\n        while (pos > 0)\n        {\n            var p = (pos - 1) / 2;\n            if (comp(list[p], x) <= 0) break;\n            list[pos] = list[p];\n            pos = p;\n        }\n        list[pos] = x;\n    }\n    public T Dequeue()\n    {\n        var value = list[0];\n        var x = list[--count];\n        list.RemoveAt(count);\n        if (count == 0) return value;\n        var pos = 0;\n        while (pos * 2 + 1 < count)\n        {\n            var a = 2 * pos + 1;\n            var b = 2 * pos + 2;\n            if (b < count && comp(list[b], list[a]) < 0) a = b;\n            if (comp(list[a], x) >= 0) break;\n            list[pos] = list[a];\n            pos = a;\n        }\n        list[pos] = x;\n        return value;\n    }\n    public T Peek() { return list[0]; }\n    public bool Any() { return count > 0; }\n    public int Count() { return count; }\n}\n\nnamespace Codeforces\n{\n    class Program\n    {\n        class mymath\n        {\n            static int Mod = 1000000007;\n            public void setMod(int m) { Mod = m; }\n            public bool isprime(long a)\n            {\n                if (a < 2) return false;\n                for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n                return true;\n            }\n            public bool[] sieve(int n)\n            {\n                var isp = new bool[n + 1];\n                for (int i = 2; i <= n; i++) isp[i] = true;\n                for (int i = 2; i * i <= n; i++) if (isp[i]) for (int j = i * i; j <= n; j += i) isp[j] = false;\n                return isp;\n            }\n            public List<int> getprimes(int n)\n            {\n                var prs = new List<int>();\n                var isp = sieve(n);\n                for (int i = 2; i <= n; i++) if (isp[i]) prs.Add(i);\n                return prs;\n            }\n            public long[][] E(int n)\n            {\n                var ret = new long[n][];\n                for (int i = 0; i < n; i++)\n                {\n                    ret[i] = new long[n];\n                    ret[i][i] = 1;\n                }\n                return ret;\n            }\n            public long[][] powmat(long[][] A, long n)\n            {\n                if (n == 0) return E(A.Length);\n                var t = powmat(A, n / 2);\n                if ((n & 1) == 0) return mulmat(t, t);\n                return mulmat(mulmat(t, t), A);\n            }\n            public long[] mulmat(long[][] A, long[] x)\n            {\n                int n = A.Length, m = x.Length;\n                var ans = new long[n];\n                for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) ans[i] = (ans[i] + x[j] * A[i][j]) % Mod;\n                return ans;\n            }\n            public long[][] mulmat(long[][] A, long[][] B)\n            {\n                int n = A.Length, m = B[0].Length, l = B.Length;\n                var ans = new long[n][];\n                for (int i = 0; i < n; i++)\n                {\n                    ans[i] = new long[m];\n                    for (int j = 0; j < m; j++) for (int k = 0; k < l; k++) ans[i][j] = (ans[i][j] + A[i][k] * B[k][j]) % Mod;\n                }\n                return ans;\n            }\n            public long[] addmat(long[] x, long[] y)\n            {\n                int n = x.Length;\n                var ans = new long[n];\n                for (int i = 0; i < n; i++) ans[i] = (x[i] + y[i]) % Mod;\n                return ans;\n            }\n            public long[][] addmat(long[][] A, long[][] B)\n            {\n                int n = A.Length, m = A[0].Length;\n                var ans = new long[n][];\n                for (int i = 0; i < n; i++) ans[i] = addmat(A[i], B[i]);\n                return ans;\n            }\n            public long powmod(long a, long b)\n            {\n                if (a >= Mod) return powmod(a % Mod, b);\n                if (a == 0) return 0;\n                if (b == 0) return 1;\n                var t = powmod(a, b / 2);\n                if ((b & 1) == 0) return t * t % Mod;\n                return t * t % Mod * a % Mod;\n            }\n            public long inv(long a) { return powmod(a, Mod - 2); }\n            public long gcd(long a, long b)\n            {\n                while (b > 0) { var t = a % b; a = b; b = t; }\n                return a;\n            }\n            public long lcm(long a, long b) { return a * (b / gcd(a, b)); }\n            public long Comb(int n, int r)\n            {\n                if (n < 0 || r < 0 || r > n) return 0;\n                if (n - r < r) r = n - r;\n                if (r == 0) return 1;\n                if (r == 1) return n;\n                var numerator = new int[r];\n                var denominator = new int[r];\n                for (int k = 0; k < r; k++)\n                {\n                    numerator[k] = n - r + k + 1;\n                    denominator[k] = k + 1;\n                }\n                for (int p = 2; p <= r; p++)\n                {\n                    int pivot = denominator[p - 1];\n                    if (pivot > 1)\n                    {\n                        int offset = (n - r) % p;\n                        for (int k = p - 1; k < r; k += p)\n                        {\n                            numerator[k - offset] /= pivot;\n                            denominator[k] /= pivot;\n                        }\n                    }\n                }\n                long result = 1;\n                for (int k = 0; k < r; k++) if (numerator[k] > 1) result = result * numerator[k] % Mod;\n                return result;\n            }\n        }\n\n        const long InfL = 4011686018427387913L;\n        static char[] sep = new char[] { ' ', '/' };\n\n\n        //static int[] dx = { -1, 0, 1, -1, 1, -1, 0, -1 };\n        //static int[] dy = { 1, 1, 1, 0, 0, -1, -1, -1 };\n\n        static int[] dx = { -1, 0, 0, 1 };\n        static int[] dy = { 0, 1, -1, 0 };\n\n\n        /// <summary>\n        /// basic dfs function\n        /// </summary>\n        /// \n        /* public class List_of_List<T> : List<List<T>> { }\n        static int result = 0;\n\n        static List<bool> visited = new List<bool>();\n        static List_of_List<int> adj = new List_of_List<int>();\n\n        static void dfs(int here)\n        {\n            if (here == n * m - 1)\n            {\n                result++;\n                return;\n            }\n            visited[here] = true;\n\n            for(int i = 0; i<adj[here].Count; i++)\n            {\n                int there = adj[here][i];\n                if (!visited[there])\n                    dfs(there);\n                visited[there] = false;   \n            }\n        }\n\n        static void dfsAll()\n        {\n            for(int i = 0; i<adj.Count; i++)\n            {\n                dfs(i);\n            }\n        }\n\n\n        /* static int getInt => int.Parse(Console.ReadLine());\n        static int[] getIntArr => Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToArray();\n        static List<int> getIntList => Console.ReadLine().Trim().Split(sep).Select(a => int.Parse(a)).ToList<int>();\n        static string getString => Console.ReadLine().Trim();\n        static string[] getStrArr => Console.ReadLine().Trim().Split(sep);\n        static List<string> getStrList => Console.ReadLine().Trim().Split(sep).ToList<string>();\n        */\n        static int m;\n        static int n;\n        static int[] board;\n        static int[] cache;\n        static int[] input = new int[100001];\n        static int[,] capacity;\n        static int[,] flow;\n        static bool[,] adj;\n        static List<bool> visited;\n        static List<int> m_match;\n        static List<int> n_match;\n\n        static void Main(string[] args)\n        {\n            string[] str_input = Console.ReadLine().Split(' ');\n            int[] input = new int[str_input.Count()];\n            input[0] = int.Parse(str_input[0]);\n            input[1] = int.Parse(str_input[1]);\n\n            while (true)\n            {\n                mymath math = new mymath();\n                capacity = new int[502, 502];\n                flow = new int[502, 502];\n\n                m = input[0];\n                n = input[1];\n                int[] m_arr = new int[m];\n                int[] n_arr = new int[n];\n                for(int i = 0; i< (m-1)/10 + 1; i++)\n                {\n                    string[] m_input = Console.ReadLine().Split(' ');\n                    for(int j = 0; j< m_input.Count(); j++)\n                    {\n                        m_arr[i * 10 + j] = int.Parse(m_input[j]);\n                    }\n                }\n                for (int i = 0; i < (n-1)/10 + 1; i++)\n                {\n                    string[] n_input = Console.ReadLine().Split(' ');\n                    for (int j = 0; j < n_input.Count(); j++)\n                    {\n                        n_arr[i * 10 + j] = int.Parse(n_input[j]);\n                    }\n                }\n\n                adj = new bool[m,n];\n\n                m_match = new List<int>();\n                n_match = new List<int>();\n\n                m_match.Capacity = m;\n\n                for(int i = 0; i<m; i++)\n                {\n                    for(int j = 0; j<n; j++)\n                    {\n                        if (math.gcd(m_arr[i], n_arr[j]) > 1)\n                        {\n                            adj[i, j] = true;\n                        }\n                    }\n                }\n\n\n                Console.WriteLine(bipartite_match());\n\n                str_input = Console.ReadLine().Split(' ');\n                input = new int[str_input.Count()];\n                input[0] = int.Parse(str_input[0]);\n                input[1] = int.Parse(str_input[1]);\n                if (input[0] == 0 && input[1] == 0) break;\n            }\n        }\n\n        static bool dfs(int a)\n        {\n            if (visited[a]) return false;\n            visited[a] = true;\n            for(int b = 0; b < n; b++)\n            {\n                if (adj[a, b])\n                {\n                    if(n_match[b] == -1 || dfs(n_match[b]))\n                    {\n                        m_match[a] = b;\n                        n_match[b] = a;\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        static int bipartite_match()\n        {\n            m_match = new List<int>();\n            for(int i = 0; i<m; i++)\n            {\n                m_match.Add(-1);\n            }\n            n_match = new List<int>();\n            for(int i = 0; i<n; i++)\n            {\n                n_match.Add(-1);\n            }\n\n            int size = 0;\n            for (int start = 0; start < m; start++)\n            {\n                visited = new List<bool>();\n                visited.Capacity = m;\n                for (int i = 0; i < m; i++) visited.Add(false);\n\n                if (dfs(start)) size++;\n            }\n            return size;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Read read = new Read();\n        string s;\n\n        while ((s = Console.ReadLine()) != \"0 0\")\n        {\n            int[] t = Array.ConvertAll(s.Split(), int.Parse);\n            int A = t[0];\n            int B = t[1];\n            int[] a = new int[A];\n            int[] b = new int[B];\n            for (int i = 0; i < A; i++) { a[i] = read.NextInt(); }\n            for (int i = 0; i < B; i++) { b[i] = read.NextInt(); }\n            BipartiteMatching bm = new BipartiteMatching(A + B);\n\n            for (int i = 0; i < A; i++)\n            {\n                for (int j = 0; j < B; j++)\n                {\n                    if (GCD(a[i], b[j]) > 1)\n                    {\n                        bm.AddEdge(i, A + j);\n                    }\n                }\n            }\n            int ans = bm.Run();\n            Console.WriteLine(ans);\n        }\n\n        Console.ReadLine();\n    }\n\n    static long GCD(long i, long j)\n    {\n        while (j != 0) { long t = i % j; i = j; j = t; }\n        return i;\n    }\n\n    class BipartiteMatching\n    {\n        readonly int V;\n        List<int>[] edges;\n        bool[] used;\n        int[] match;\n\n        public BipartiteMatching(int V)\n        {\n            this.V = V;\n            match = Enumerable.Repeat(-1, V).ToArray();\n            edges = Enumerable.Range(0, V).Select(i => new List<int>()).ToArray();\n        }\n\n        public void AddEdge(int a, int b)\n        {\n            edges[a].Add(b);\n            edges[b].Add(a);\n        }\n\n        public int Run()\n        {\n            int res = 0;\n            for (int i = 0; i < V; i++)\n            {\n                if (match[i] < 0)\n                {\n                    used = new bool[V];\n                    if (DFS(i)) { res++; }\n                }\n            }\n            return res;\n        }\n\n        private bool DFS(int i)\n        {\n            used[i] = true;\n            foreach (int j in edges[i])\n            {\n                int k = match[j];\n                if (k < 0 || !used[k] && DFS(k))\n                {\n                    match[i] = j;\n                    match[j] = i;\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n\n    class Read\n    {\n        Queue<string> que = new Queue<string>();\n        \n        public int NextInt()\n        {\n            if (que.Count == 0) { Enqueue(); }\n            return int.Parse(que.Dequeue());\n        }\n\n        private void Enqueue()\n        {\n            foreach (string s in Console.ReadLine().Split())\n            {\n                que.Enqueue(s);\n            }\n        }\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "def path(edge, start, goal)\n  q = [[[start], []]]\n  until q.empty?\n    p, used = q.shift\n    return p if p.last == goal\n    next if used[p.last]\n    used[p.last] = true\n    edge[p.last].each do |v|\n      q << [p + [v], used]\n    end\n  end\n  nil\nend\n\ndef FordFulkerson(edge, m, n)\n  source = m + n\n  sink = m + n + 1\n\n  result = 0\n\n  while p = path(edge, source, sink)\n    result += 1\n    p.each_cons(2) do |u, v|\n      edge[u].delete(v)\n      edge[v] << u\n    end\n  end\n\n  result\nend\n\nuntil (m, n = gets.split.map(&:to_i)).all?(&:zero?)\n  source = m + n\n  sink = m + n + 1\n  size = m + n + 2\n\n  b = Array.new\n  r = Array.new\n  b += gets.split.map(&:to_i) until b.size == m\n  r += gets.split.map(&:to_i) until r.size == n\n\n  edge = Array.new(size){Array.new}\n  m.times do |u|\n    n.times do |v|\n      edge[u] << m + v unless b[u].gcd(r[v]) == 1\n    end\n  end\n  m.times do |u| edge[source] << u end\n  n.times do |v| edge[m + v] << sink end\n\n  p FordFulkerson(edge, m, n)\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'prime'\n\nmodule Graphical\n\trequire 'set'\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [] if s == t\n\t\ts.out_edges.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nclass Digraph < Graph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_out_edge(e)\n\t\tv.add_in_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node < Graph::Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :in_edges, :out_edges\n\tend\n\n\tclass Edge < Graph::Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.out_edges.each{|e|\n\t\t\tyield [e.to, e.length]\n\t\t}\n\tend\n\n\tdef each_in_connection_of(v)\n\t\tv.in_edges.each{|e|\n\t\t\tyield [e.from, e.length]\n\t\t}\n\tend\n\n#----------------------------------------------------------\n\n\tdef get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\nend\n\nloop {\n\tn, m = gets.split.map &:to_i\n\tbreak if n == 0\n\n\ta = gets.split.map &:to_i\n\tb = gets.split.map &:to_i\n\n\tg = Digraph.new\n\tleft_nodes = a.map{|x|\n\t\tg.add_node({:facts => Prime.prime_division(x).map(&:first)})\n\t}\n\tright_nodes = b.map{|x|\n\t\tg.add_node({:facts => Prime.prime_division(x).map(&:first)})\n\t}\n\n\tleft_nodes.each{|u|\n\t\tright_nodes.each{|v|\n\t\t\tg.add_edge(u, v) unless (u.property[:facts] & v.property[:facts]).empty?\n\t\t}\n\t}\n\n\ts = g.add_node\n\tt = g.add_node\n\n\tleft_nodes.each{|v| g.add_edge(s, v)}\t\n\tright_nodes.each{|v| g.add_edge(v, t)}\t\n\t\n\tc = 0\n\twhile path = g.get_path_by_dfs(s, t)\n\t\tc += 1\n\t\tpath.each{|e|\n\t\t\tg.del_edge(e)\n\t\t\tg.add_edge(e.to, e.from)\n\t\t}\n\tend\n\tp c\n}"
  },
  {
    "language": "Ruby",
    "code": "def path(edge, start, goal)\n  q = [[[start], []]]\n  until q.empty?\n    p, used = q.shift\n    return p if p.last == goal\n    edge[p.last].each do |v|\n      next if used[v]\n      used[v] = true\n      q << [p + [v], used]\n    end\n  end\n  nil\nend\n\ndef FordFulkerson(edge, m, n)\n  source = m + n\n  sink = m + n + 1\n\n  result = 0\n\n  while p = path(edge, source, sink)\n    result += 1\n    p.each_cons(2) do |u, v|\n      edge[u].delete(v)\n      edge[v] << u\n    end\n  end\n\n  result\nend\n\nuntil (m, n = gets.split.map(&:to_i)).all?(&:zero?)\n  source = m + n\n  sink = m + n + 1\n  size = m + n + 2\n\n  b = Array.new\n  r = Array.new\n  b += gets.split.map(&:to_i) until b.size == m\n  r += gets.split.map(&:to_i) until r.size == n\n\n  edge = Array.new(size){Array.new}\n  m.times do |u|\n    n.times do |v|\n      edge[u] << m + v unless b[u].gcd(r[v]) == 1\n    end\n  end\n  m.times do |u| edge[source] << u end\n  n.times do |v| edge[m + v] << sink end\n\n  p FordFulkerson(edge, m, n)\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'prime'\n\nmodule Graphical\n\trequire 'set'\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [] if s == t\n\t\ts.out_edges.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nclass Digraph < Graph\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_out_edge(e)\n\t\tv.add_in_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.from, e.to\n\t\tu.out_edges.delete(e)\n\t\tv.in_edges.delete(e)\n\t\te\n\tend\n\n\tclass Node < Graph::Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@out_edges = Set.new\n\t\t\t@in_edges = Set.new\n\t\tend\n\n\t\tdef add_out_edge(e)\n\t\t\t@out_edges << e\n\t\tend\n\n\t\tdef del_out_edge(e)\n\t\t\t@out_edges.delete(e)\n\t\tend\n\n\t\tdef add_in_edge(e)\n\t\t\t@in_edges << e\n\t\tend\n\n\t\tdef del_in_edge(e)\n\t\t\t@in_edges.delete(e)\n\t\tend\n\n\t\tattr_reader :in_edges, :out_edges\n\tend\n\n\tclass Edge < Graph::Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@from = u\t\n\t\t\t@to = v\n\t\t\t@property = property\n\t\tend\n\n\t\tattr_reader :from, :to\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.out_edges.each{|e|\n\t\t\tyield [e.to, e.length]\n\t\t}\n\tend\n\n\tdef each_in_connection_of(v)\n\t\tv.in_edges.each{|e|\n\t\t\tyield [e.from, e.length]\n\t\t}\n\tend\n\n#----------------------------------------------------------\n\n\tdef get_path_bfs(s, t)\n\t\tpath_edge = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\tu.outgoings.each{|e|\n\t\t\t\tv = e.to\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tpath_edge[v] = e\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = []\n\t\t\t\t\twhile e = path_edge[v]\n\t\t\t\t\t\tpath.unshift e\n\t\t\t\t\t\tv = e.from\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_dfs(s, t, reached = Set.new)\n\t\treached << s\t\n\t\ts.outgoings.each{|e|\n\t\t\tv = e.to\n\t\t\tnext if reached.include?(v)\n\t\t\treturn [e] if v == t\n\t\t\t\n\t\t\tpath = get_path_dfs(v, t, reached) \n\t\t\treturn [e] + path if path\n\t\t}\n\t\tnil\n\tend\n\nend\n\nloop {\n\tn, m = gets.split.map &:to_i\n\tbreak if n == 0\n\n\ta = []\n\ta += gets.split.map &:to_i until a.size == n\n\tb = []\n\tb += gets.split.map &:to_i until b.size == m\n\n\tg = Digraph.new\n\tleft_nodes = a.map{|x|\n\t\tg.add_node({:facts => Prime.prime_division(x).map(&:first)})\n\t}\n\tright_nodes = b.map{|x|\n\t\tg.add_node({:facts => Prime.prime_division(x).map(&:first)})\n\t}\n\n\tleft_nodes.each{|u|\n\t\tright_nodes.each{|v|\n\t\t\tg.add_edge(u, v) unless (u.property[:facts] & v.property[:facts]).empty?\n\t\t}\n\t}\n\n\ts = g.add_node\n\tt = g.add_node\n\n\tleft_nodes.each{|v| g.add_edge(s, v)}\t\n\tright_nodes.each{|v| g.add_edge(v, t)}\t\n\t\n\tc = 0\n\twhile path = g.get_path_by_dfs(s, t)\n\t\tc += 1\n\t\tpath.each{|e|\n\t\t\tg.del_edge(e)\n\t\t\tg.add_edge(e.to, e.from)\n\t\t}\n\tend\n\tp c\n}"
  },
  {
    "language": "Ruby",
    "code": "### constants\n\nINF = 1 << 30\n\n### main\n\nloop do\n  m, n = gets.split.map(&:to_i)\n  break if (m | n) == 0\n\n  cbs = gets.split.map(&:to_i).sort\n  crs = gets.split.map(&:to_i).sort\n  #p [cbs, crs]\n\n  vn = m + n + 2\n  st = m + n\n  gl = m + n + 1\n\n  edges = vn.times.map{vn.times.map{0}}\n  nbrs = vn.times.map{[]}\n  \n  for i in (0...m)\n    for j in (0...n)\n      if cbs[i].gcd(crs[j]) > 1\n        edges[i][m + j] = 1\n        nbrs[i] << m + j\n        nbrs[m + j] << i\n      end\n    end\n  end\n\n  (0...m).each{|i| edges[st][i] = 1; nbrs[st] << i}\n  (0...n).each{|j| edges[m + j][gl] = 1; nbrs[m + j] << gl}\n\n  fs = vn.times.map{vn.times.map{0}}\n\n  loop do\n    prevs = vn.times.map{nil}\n    dists = vn.times.map{INF}\n    dists[st] = 0\n    q = [st]\n\n    while ! q.empty?\n      u = q.shift\n      break if u == gl\n\n      for v in nbrs[u]\n        next if fs[u][v] == edges[u][v]\n        vd = dists[u] + 1\n        if dists[v] > vd\n          dists[v] = vd\n          prevs[v] = u\n          q << v\n        end\n      end\n    end\n    break if dists[gl] >= INF\n    \n    path = []\n    u = gl\n    while prevs[u]\n      path.unshift(u)\n      u = prevs[u]\n    end\n    #p path\n    \n    min_c = INF\n    u = st\n    for v in path\n      #p [u, v, edges[u][v], fs[u][v]]\n      cf = edges[u][v] - fs[u][v]\n      min_c = cf if min_c > cf\n      u = v\n    end\n\n    u = st\n    for v in path\n      fs[u][v] += min_c\n      fs[v][u] -= min_c\n      u = v\n    end\n  end\n\n  sum = 0\n  (0...m).each{|i| sum += fs[st][i]}\n  puts sum\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.stdio;\n\nint solve() {\n    auto s = readln.split.map!(to!int);\n    int M = s[0];\n    int N = s[1];\n    if (M == 0) return -1;\n    auto A = readln.split.map!(to!int);\n    auto B = readln.split.map!(to!int);\n\n    \n    auto source = M + N;\n    auto sink = M + N + 1;\n    auto ff = new FordFulkerson(M+N+2, source, sink);\n    \n    foreach (i; 0..M) ff.add_edge(source, i, 1);\n    foreach (i; 0..N) ff.add_edge(i+M, sink, 1);\n    \n    foreach (i; 0..M)\n        foreach (j; 0..N)\n            if (gcd(A[i], B[j]) > 1)\n                ff.add_edge(i, j+M, 1);\n\n    return ff.run;\n}\n\nvoid main() {\n    while (true) {\n        auto ans = solve;\n        if (ans == -1) break;\n        ans.writeln;\n    }\n}\n\nclass FordFulkerson {\n    int N, source, sink;\n    int[][] adj;\n    int[][] flow;\n    bool[] used;\n\n    this(int n, int s, int t) {\n        N = n;\n        source = s;\n        sink = t;\n        assert (s >= 0 && s < N && t >= 0 && t < N);\n        adj = new int[][](N);\n        flow = new int[][](N, N);\n        used = new bool[](N);\n    }\n\n    void add_edge(int from, int to, int cap) {\n        adj[from] ~= to;\n        adj[to] ~= from;\n        flow[from][to] = cap;\n    }\n\n    int dfs(int v, int min_cap) {\n        if (v == sink)\n            return min_cap;\n        if (used[v])\n            return 0;\n        used[v] = true;\n        foreach (to; adj[v]) {\n            if (!used[to] && flow[v][to] > 0) {\n                auto bottleneck = dfs(to, min(min_cap, flow[v][to]));\n                if (bottleneck == 0) continue;\n                flow[v][to] -= bottleneck;\n                flow[to][v] += bottleneck;\n                return bottleneck;\n            }\n        }\n        return 0;\n    }\n\n    int run() {\n        int ret = 0;\n        while (true) {\n            foreach (i; 0..N) used[i] = false;\n            int f = dfs(source, int.max);\n            if (f > 0)\n                ret += f;\n            else\n                return ret;\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.stdio;\n\nint solve() {\n    auto s = readln.split.map!(to!int);\n    int M = s[0];\n    int N = s[1];\n    if (M == 0) return -1;\n    auto A = new int[](M);\n    auto B = new int[](N);\n    int a, b;\n    while (a < M) {\n        auto T = readln.split.map!(to!int);\n        foreach (t; T) A[a++] = t;\n    }\n    while (b < N) {\n        auto T = readln.split.map!(to!int);\n        foreach (t; T) B[b++] = t;\n    }\n\n    \n    auto source = M + N;\n    auto sink = M + N + 1;\n    auto ff = new FordFulkerson(M+N+2, source, sink);\n    \n    foreach (i; 0..M) ff.add_edge(source, i, 1);\n    foreach (i; 0..N) ff.add_edge(i+M, sink, 1);\n    \n    foreach (i; 0..M)\n        foreach (j; 0..N)\n            if (gcd(A[i], B[j]) > 1)\n                ff.add_edge(i, j+M, 1);\n\n    return ff.run;\n}\n\nvoid main() {\n    while (true) {\n        auto ans = solve;\n        if (ans == -1) break;\n        ans.writeln;\n    }\n}\n\nclass FordFulkerson {\n    int N, source, sink;\n    int[][] adj;\n    int[][] flow;\n    bool[] used;\n\n    this(int n, int s, int t) {\n        N = n;\n        source = s;\n        sink = t;\n        assert (s >= 0 && s < N && t >= 0 && t < N);\n        adj = new int[][](N);\n        flow = new int[][](N, N);\n        used = new bool[](N);\n    }\n\n    void add_edge(int from, int to, int cap) {\n        adj[from] ~= to;\n        adj[to] ~= from;\n        flow[from][to] = cap;\n    }\n\n    int dfs(int v, int min_cap) {\n        if (v == sink)\n            return min_cap;\n        if (used[v])\n            return 0;\n        used[v] = true;\n        foreach (to; adj[v]) {\n            if (!used[to] && flow[v][to] > 0) {\n                auto bottleneck = dfs(to, min(min_cap, flow[v][to]));\n                if (bottleneck == 0) continue;\n                flow[v][to] -= bottleneck;\n                flow[to][v] += bottleneck;\n                return bottleneck;\n            }\n        }\n        return 0;\n    }\n\n    int run() {\n        int ret = 0;\n        while (true) {\n            foreach (i; 0..N) used[i] = false;\n            int f = dfs(source, int.max);\n            if (f > 0)\n                ret += f;\n            else\n                return ret;\n        }\n    }\n}"
  },
  {
    "language": "Python",
    "code": "from fractions import gcd\n\n\ndef add_edge(u, v):\n    G[u].append(v)\n    G[v].append(u)\n\n\ndef dfs(v):\n    used[v] = True\n    for u in G[v]:\n        w = match[u]\n        if w < 0 or not used[w] and dfs(w):\n            match[v] = u\n            match[u] = v\n            return True\n    else:\n        return False\n\n\ndef bipartite_matching():\n    result = 0\n    match[:] = [-1] * (numv)\n    for v in range(numv):\n        if match[v] < 0:\n            used[:] = [False] * numv\n            if dfs(v):\n                result += 1\n    return result\n\n\nwhile True:\n    m, n = map(int, input().split())\n    if (m, n) == (0, 0):\n        break\n    numv = m + n\n    cards = []\n    while len(cards) < numv:\n        cards.extend(map(int, input().split()))\n    blues = cards[:m]\n    reds = cards[m:]\n    G = [[] for i in range(numv)]\n    used = [False] * numv\n    match = [-1] * numv\n    for i, b in enumerate(blues):\n        for j, r in enumerate(reds, m):\n            if gcd(b, r) > 1:\n                add_edge(i, j)\n\n    print(bipartite_matching())"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\nclass Dinic(object):\n    __slots__ = [\"inf\", \"v_count\", \"edges\", \"iter\", \"level\"]\n\n    def __init__(self, v_count: int, edges: list):\n        self.inf = 10**9\n        self.v_count = v_count\n        self.edges = [[] for _ in [0]*v_count]\n        self.iter = [0]*v_count\n        self.level = None\n        self._create_graph(edges)\n\n    def _create_graph(self, _edges):\n        edges = self.edges\n        for origin, dest, cap in _edges:\n            edges[origin].append([dest, cap, len(edges[dest])])\n            edges[dest].append([origin, 0, len(edges[origin])-1])\n\n    def solve(self, source: int, sink: int):\n        max_flow = 0\n\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return max_flow\n\n            self.iter = [0]*self.v_count\n            flow = self.dfs(source, sink, self.inf)\n\n            while flow > 0:\n                max_flow += flow\n                flow = self.dfs(source, sink, self.inf)\n\n    def bfs(self, source: int):\n        level, edges = [-1]*self.v_count, self.edges\n        level[source] = 0\n        dq = deque([source])\n        popleft, append = dq.popleft, dq.append\n\n        while dq:\n            v = popleft()\n            for dest, cap, _rev in edges[v]:\n                if cap > 0 > level[dest]:\n                    level[dest] = level[v] + 1\n                    append(dest)\n\n        self.level = level\n\n    def dfs(self, source: int, sink: int, flow: int) -> int:\n        if source == sink:\n            return flow\n        while self.iter[source] < len(self.edges[source]):\n            dest, cap, rev = edge = self.edges[source][self.iter[source]]\n            if cap > 0 and self.level[source] < self.level[dest]:\n                flowed = self.dfs(dest, sink, flow if flow < cap else cap)\n                if flowed > 0:\n                    edge[1] -= flowed\n                    self.edges[dest][rev][1] += flowed\n                    return flowed\n            self.iter[source] += 1\n\n        return 0\n\n\ndef get_prime_set(ub):\n    from itertools import chain\n    from math import sqrt\n\n    if ub < 4:\n        return ({}, {}, {2}, {2, 3})[ub]\n\n    ub, ub_sqrt = ub+1, int(sqrt(ub))+1\n    primes = {2, 3} | set(chain(range(5, ub, 6), range(7, ub, 6)))\n    du = primes.difference_update\n    for n in chain(range(5, ub_sqrt, 6), range(7, ub_sqrt, 6)):\n        if n in primes:\n            du(range(n*3, ub, n*2))\n\n    return primes\n\n\nif __name__ == \"__main__\":\n    from math import sqrt\n    from collections import defaultdict\n    primes = get_prime_set(int(sqrt(10**7))+1)\n    answer = []\n    append_answer = answer.append\n\n    while True:\n        M, N = map(int, input().split())\n        if not M*N:\n            break\n\n        source, sink = M+N, M+N+1\n        edges, blue, red = [], [], []\n        for i in range(M):\n            edges.append((i, sink, 1))\n        for i in range(M, M+N):\n            edges.append((source, i, 1))\n        divisors = defaultdict(set)\n        index = 0\n\n        # blue\n        while index < M:\n            for num in map(int, input().split()):\n                for p in filter(lambda x: num % x == 0, primes):\n                    divisors[p].add(index)\n                    while num % p == 0:\n                        num //= p\n                if num > 1:\n                    divisors[num].add(index)\n                index += 1\n\n        # red\n        while index < M+N:\n            for num in map(int, input().split()):\n                neighbors = set()\n                update = neighbors.update\n                for p in filter(lambda x: num % x == 0, primes):\n                    update(divisors[p])\n                    while num % p == 0:\n                        num //= p\n                if num > 1:\n                    update(divisors[num])\n\n                for dest in neighbors:\n                    edges.append((index, dest, 1))\n\n                index += 1\n\n        dinic = Dinic(sink+1, edges)\n        append_answer(dinic.solve(source, sink))\n\n    print(*answer, sep=\"\\n\")\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass Flow():\n    def __init__(self, e, N):\n        self.E = e\n        self.N = N\n\n    def max_flow(self, s, t):\n        r = 0\n        e = self.E\n\n        def f(c):\n            v = self.v\n            v[c] = 1\n            if c == t:\n                return 1\n            for i in range(self.N):\n                if v[i] == 0 and e[c][i] > 0 and f(i) > 0:\n                    e[c][i] -= 1\n                    e[i][c] += 1\n                    return 1\n            return 0\n\n        while True:\n            self.v = [0] * self.N\n            if f(s) == 0:\n                break\n            r += 1\n\n        return r\n\ndef main():\n    rr = []\n\n    def f(m, n):\n        b = LI()\n        while len(b) < m:\n            b += LI()\n        r = LI()\n        while len(r) < n:\n            r += LI()\n        s = m + n + 2\n        e = [[0] * s for _ in range(s)]\n        for i in range(m):\n            e[0][i+1] = 1\n        for i in range(n):\n            e[m+i+1][s-1] = 1\n\n        for i in range(m):\n            for j in range(n):\n                if fractions.gcd(b[i], r[j]) > 1:\n                    e[i+1][m+j+1] = 1\n\n        fl = Flow(e, s)\n\n        return fl.max_flow(0, s-1)\n\n    while True:\n        m, n = LI()\n        if m == 0 and n == 0:\n            break\n        rr.append(f(m,n))\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import sys,queue,math,copy,itertools,bisect,collections,heapq\n\ndef main():\n    LI = lambda : [int(x) for x in sys.stdin.readline().split()]\n\n    while True:\n        m,n = LI()\n        if m + n == 0: return\n\n        goal = m + n + 1\n        b = []\n        r = []\n        for _ in range((m-1)//10+1):\n            b.extend(LI())\n        for _ in range((n-1)//10+1):\n            r.extend(LI())\n\n        edge = [set() for _ in range(goal+1)]\n        for i in range(1,m+1):\n            edge[0].add(i)\n        for i in range(m+1,goal+1):\n            edge[i].add(goal)\n        for i in range(m):\n            for j in range(n):\n                if math.gcd(b[i],r[j]) > 1:\n                    edge[i+1].add(j+m+1)\n\n        ans = 0\n        while True:\n            node = [-1] * (goal+1)\n            q = collections.deque()\n            node[0] = 0\n            q.append(0)\n            while q:\n                u = q.pop()\n                for v in edge[u]:\n                    if node[v] >= 0: continue\n                    node[v] = u\n                    if v == goal:\n                        ans += 1\n                        break\n                    q.append(v)\n                else:\n                    continue\n                break\n            else:\n                break\n            v = goal\n            while v > 0:\n                u = node[v]\n                edge[u].remove(v)\n                edge[v].add(u)\n                v = u\n        print(ans)\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from fractions import gcd\n\nINF = 2 << 30\nV = 1002\nG = [[] for _ in xrange(V)]\nvisited = [False]*V\n\ndef add_edge(fro, to, cap):\n    G[fro].append([to,cap,len(G[to])])\n    G[to].append([fro,0,len(G[fro])-1])\n\ndef dfs(v,t,f):\n    if v == t:\n        return f\n    visited[v] = True\n    for i,(to,cap,rev) in enumerate((G[v])):\n        if visited[to] or cap == 0:            \n            continue        \n        d = dfs(to,t,min(f,cap))\n        if d > 0:\n            G[v][i][1] -= d\n            G[to][rev][1] += d\n            return d\n    return 0\n\ndef max_flow(s,t):\n    flow = 0\n    while True:\n        for i in xrange(V):\n            visited[i] = False\n        f = dfs(s,t,INF)\n        if f == 0:\n            return flow\n        flow += f\n\nwhile True:\n    m,n = map(int,raw_input().split())\n    if m|n == 0:\n        break\n    V = m+n+2\n    G = [[] for _ in xrange(V)]\n    data = []\n    while len(data) < n+m:\n        data += map(int,raw_input().split())            \n    blue = data[:m]\n    red = data[m:]\n    for i in xrange(m):\n        add_edge(V-2,i,1)\n    for i in xrange(m,m+n):\n        add_edge(i,V-1,1)\n    for i,b in enumerate(blue):\n        for j,r in enumerate(red,m):\n            if gcd(b,r) != 1:\n                add_edge(i,j,1)\n    print max_flow(V-2,V-1)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nCards\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1163&lang=jp\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import namedtuple, deque\nfrom math import gcd\ninput = stdin.readline\n\nedge = namedtuple('edge', ['to', 'cap', 'rev'])\n\n\ndef add_edge(G, f, t, c):\n    G[f].append(edge(t, c, len(G[t])))\n    G[t].append(edge(f, 0, len(G[f]) - 1))\n\n\ndef bfs(G, level, s):\n    for i in range(len(level)):\n        level[i] = -1\n    que = deque()\n    level[s] = 0\n    que.append(s)\n    while que:\n        v = que.popleft()\n        for e in G[v]:\n            if e.cap > 0 and level[e.to] < 0:\n                level[e.to] = level[v] + 1\n                que.append(e.to)\n\n\ndef dfs(G, iter, level, v, t, f):\n    if v == t:\n        return f\n    for i in range(iter[v], len(G[v])):\n        e = G[v][i]\n        if e.cap > 0 and level[v] < level[e.to]:\n            d = dfs(G, iter, level, e.to, t, min(f, e.cap))\n            if d > 0:\n                G[v][i] = edge(e.to, e.cap - d, e.rev)\n                G[e.to][e.rev] = edge(G[e.to][e.rev].to, G[e.to][e.rev].cap + d, G[e.to][e.rev].rev)\n                return d\n    return 0\n\ndef max_flow(G, V, s, t):\n    level = [0] * V\n    flow = 0\n    while True:\n        bfs(G, level, s)\n        if level[t] < 0:\n            return flow\n        iter = [0] * V\n        while True:\n            f = dfs(G, iter, level, s, t, float('inf'))\n            if f > 0:\n                flow += f\n            else:\n                break\n\n\ndef main(args):\n    \"\"\"\n    0: ソース\n    1〜m: 青\n    m+1〜m+n: 赤\n    m+n+1: シンク\n    \"\"\"\n    while True:\n        m, n = map(int, input().split())\n        if m == 0 and n == 0:\n            break\n\n        blue_cards = []\n        red_cards = []\n        while True:\n            blue_cards.extend([int(b) for b in input().split()])\n            if len(blue_cards) == m:\n                break\n        while True:\n            red_cards.extend([int(r) for r in input().split()])\n            if len(red_cards) == n:\n                break\n\n        G = [[] for _ in range(m+n+2)]\n\n        for b in range(1, m+1):\n            add_edge(G, 0, b, 1)\n        for r in range(m+1, m+n+1):\n            add_edge(G, r, m+n+1, 1)\n\n        for bi, b in enumerate(blue_cards, start=1):\n            for ri, r in enumerate(red_cards, start=m+1):\n                if gcd(b, r) != 1:\n                    add_edge(G, bi, ri, 1)\n\n        ans = max_flow(G, m+n+2, 0, m+n+1)\n        print(ans)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n"
  },
  {
    "language": "Python",
    "code": "from fractions import gcd\n\nINF = 2 << 30\nV = 1003\nG = [[] for _ in xrange(V)]\nvisited = [False]*V\n\ndef add_edge(fro, to, cap):\n    G[fro].append([to,cap,len(G[to])])\n    G[to].append([fro,0,len(G[fro])-1])\n\ndef dfs(v,t,f):\n    if v == t:\n        return f\n    visited[v] = True\n    for i,(to,cap,rev) in enumerate((G[v])):\n        if visited[to] or cap <= 0:            \n            continue        \n        d = dfs(to,t,min(f,cap))\n        if d > 0:\n            G[v][i][1] -= d\n            G[to][rev][1] += d\n            return d\n    return 0\n\ndef max_flow(s,t):\n    flow = 0\n    while True:\n        for i in xrange(V):\n            visited[i] = False\n        f = dfs(s,t,INF)\n        if f == 0:\n            return flow\n        flow += f\n\nwhile True:\n    m,n = map(int,raw_input().split())\n    if m|n == 0:\n        break\n    V = m+n+2\n    G = [[] for _ in xrange(V)]\n    data = []\n    while len(data) < n+m:\n        data += map(int,raw_input().split())            \n    blue = data[:m]\n    red = data[m:]\n    for i,b in enumerate(blue):\n        add_edge(V-2,i,1)\n    for i,r in enumerate(red):\n        add_edge(i+m,V-1,1)\n    for i in xrange(m):\n        for j in xrange(n):\n            if gcd(blue[i],red[j]) != 1:\n                add_edge(i,j+m,1)\n    print max_flow(V-2,V-1)"
  },
  {
    "language": "Python",
    "code": "from fractions import gcd\n\nV = 1003\nG = []\nvisited = []\nmatch = []\n\ndef add_edge(u,v):\n    G[u].append(v)\n    G[v].append(u)\n\ndef dfs(v):\n    visited[v] = True\n    for u in G[v]:\n        w = match[u]\n        if w < 0 or not visited[w] and dfs(w):\n            match[v] = u\n            match[u] = v\n            return True\n\ndef bipartite_matching():\n    global match,visited\n    res = 0\n    match = [-1]*V\n    for v in xrange(V):\n        if match[v] < 0:\n            visited = [False]*V\n            if dfs(v):\n                res += 1\n    return res\n\nwhile True:\n    m,n = map(int,raw_input().split())\n    if m|n == 0:\n        break\n    V = m+n+2\n    G = [[] for _ in xrange(V)]\n    visited = [True] * V\n    data = []\n    while len(data) < n+m:\n        data += map(int,raw_input().split())\n    for i,b in enumerate(data[:m]):\n        for j,r in enumerate(data[m:],m):\n            if gcd(b,r) != 1:\n                add_edge(i,j)\n    print bipartite_matching()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nfrom fractions import gcd\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass BipartiteMatching:\n    \"\"\"\n    XとYの二部グラフの最大マッチング X={0,1,2,...|X|-1} Y={0,1,2,...,|Y|-1}\n    edges[x]: xとつながるYの頂点のset\n    match1[x]: xとマッチングされたYの頂点\n    match2[y]: yとマッチングされたXの頂点\n    \"\"\"\n\n    def __init__(self, n, m):\n        self.n = n\n        self.m = m\n        self.edges = [set() for _ in range(n)]\n        self.match1 = [-1] * n\n        self.match2 = [-1] * m\n \n    def dfs(self, v, visited):\n        \"\"\"\n        :param v: X側の未マッチングの頂点の1つ\n        :param visited: 空のsetを渡す（外部からの呼び出し時）\n        :return: 増大路が見つかればTrue\n        \"\"\"\n        for u in self.edges[v]:\n            if u in visited:\n                continue\n            visited.add(u)\n            if self.match2[u] == -1 or self.dfs(self.match2[u], visited):\n                self.match2[u] = v\n                self.match1[v] = u\n                return True\n        return False\n    \n    def add(self, a, b):\n        self.edges[a].add(b)\n\n    def whois1(self, a):\n        \"\"\" :param: グループ1の頂点 :return: ペアになるグループ2の頂点 \"\"\"\n        return self.match1[a]\n\n    def whois2(self, a):\n        \"\"\" :param: グループ2の頂点 :return: ペアになるグループ1の頂点 \"\"\"\n        return self.match2[a]\n\n    def solve(self):\n        # 増大路発見に成功したらTrue(=1)。合計することでマッチング数となる\n        return sum(self.dfs(i, set()) for i in range(self.n))\n\nwhile True:\n    N, M = MAP()\n    if N == M == 0:\n        break\n    A = []\n    B = []\n    for _ in range(ceil(N, 10)):\n        A += LIST()\n    for _ in range(ceil(M, 10)):\n        B += LIST()\n\n    bm = BipartiteMatching(N, M)\n    for i, a in enumerate(A):\n        for j, b in enumerate(B):\n            if gcd(a, b) != 1:\n                bm.add(i, j)\n    ans = bm.solve()\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import collections\nimport math\n\n\nclass Dinic:\n    \"\"\"Dinic Algorithm: find max-flow\n       complexity: O(EV^2)\n       used in GRL6A(AOJ)\n    \"\"\"\n    class edge:\n        def __init__(self, to, cap, rev):\n            self.to, self.cap, self.rev = to, cap, rev\n\n    def __init__(self, V, E, source, sink):\n        \"\"\" V: the number of vertexes\n            E: adjacency list\n            source: start point\n            sink: goal point\n        \"\"\"\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        for fr in range(V):\n            for to, cap in E[fr]:\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr])-1))\n        self.maxflow = self.dinic(source, sink)\n\n    def dinic(self, source, sink):\n        \"\"\"find max-flow\"\"\"\n        INF = float('inf')\n        maxflow = 0\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = [0] * self.V\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > 0:\n                    maxflow += flow\n                else:\n                    break\n\n    def dfs(self, vertex, sink, flow):\n        \"\"\"find augmenting path\"\"\"\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if e.cap > 0 and self.level[vertex] < self.level[e.to]:\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n                if d > 0:\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return 0\n\n    def bfs(self, start):\n        \"\"\"find shortest path from start\"\"\"\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if e.cap > 0 and self.level[e.to] < 0:\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\n\nwhile True:\n    M, N = map(int, input().split())\n    if M == 0 and N == 0:\n        break\n    blue, red = [], []\n    while True:\n        for x in input().split():\n            blue.append(int(x))\n        if len(blue) == M:\n            break\n    while True:\n        for x in input().split():\n            red.append(int(x))\n        if len(red) == N:\n            break\n    V = M + N + 2\n    edge = [set() for _ in range(V)]\n    for i, b in enumerate(blue):\n        if b != 1:\n            for j, r in enumerate(red):\n                if r % b == 0:\n                    edge[i].add((M+j, 1))\n        for j in range(2, int(math.sqrt(b)) + 1):\n            if b % j == 0:\n                for k, r in enumerate(red):\n                    if r % j == 0 or r % (b // j) == 0:\n                        edge[i].add((M+k, 1))\n    for i in range(M):\n        edge[M+N].add((i, 1))\n    for j in range(N):\n        edge[M+j].add((M+N+1, 1))\n    d = Dinic(V, edge, M+N, M+N+1)\n    print(d.maxflow)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom fractions import gcd\n\nINF = 2 << 30\nMAX_V = 1002\nG = [[] for _ in xrange(MAX_V)]\nvisited = [False]*MAX_V\n\ndef add_edge(fro, to, cap):\n    G[fro].append([to,cap,len(G[to])])\n    G[to].append([fro,0,len(G[fro])-1])\n\ndef dfs(v,t,f):\n    global visited\n    if v == t:\n        return f\n    visited[v] = True\n    for i,(to,cap,rev) in enumerate((G[v])):\n        if visited[to] or cap == 0:            \n            continue        \n        d = dfs(to,t,min(f,cap))\n        if d > 0:\n            G[v][i][1] -= d\n            G[to][rev][1] += d\n            return d\n    return 0\n\ndef max_flow(s,t):\n    global visited\n    flow = 0\n    while True:\n        visited = [False]*MAX_V\n        f = dfs(s,t,INF)\n        if f == 0:\n            return flow\n        flow += f\n\nwhile True:\n    m,n = map(int,raw_input().split())\n    if m|n == 0:\n        break\n    G = [[] for _ in xrange(MAX_V)]\n    data = []\n    while len(data) < n+m:\n        data += map(int,raw_input().split())    \n    blue = data[:m]\n    red = data[m:]\n    for i,b in enumerate(blue):\n        add_edge(MAX_V-2,i,1)\n    for i,r in enumerate(red):\n        add_edge(i+m,MAX_V-1,1)\n    for i in xrange(m):\n        for j in xrange(n):\n            if gcd(blue[i],red[j]) != 1:\n                add_edge(i,j+m,1)\n    print max_flow(MAX_V-2,MAX_V-1)"
  },
  {
    "language": "Python",
    "code": "from fractions import gcd\n\n\ndef add_edge(u, v):\n    G[u].append(v)\n    G[v].append(u)\n\n\ndef dfs(v):\n    used[v] = True\n    for u in G[v]:\n        w = match[u]\n        if w < 0 or not used[w] and dfs(w):\n            match[v] = u\n            match[u] = v\n            return True\n    else:\n        return False\n\n\ndef bipartite_matching():\n    result = 0\n    match[:] = [-1] * (numv)\n    for v in range(numv):\n        if match[v] < 0:\n            used[:] = [False] * numv\n            if dfs(v):\n                result += 1\n    return result\n\n\nwhile True:\n    m, n = map(int, input().split())\n    if (m, n) == (0, 0):\n        break\n    numv = m + n\n    cards = []\n    while len(cards) < numv:\n        cards.extend(map(int, input().split()))\n    blues = cards[:m]\n    reds = cards[m:]\n    G = [[] for i in range(numv)]\n    used = [False] * numv\n    match = [-1] * numv\n    for i, b in enumerate(blues):\n        for j, r in enumerate(reds, m):\n            if gcd(b, r) > 1:\n                add_edge(i, j)\n\n    print(bipartite_matching())"
  },
  {
    "language": "Python",
    "code": "from fractions import gcd\n\nINF = 2 << 30\nV = 1002\nG = [[] for _ in xrange(V)]\nvisited = [False]*V\n\ndef add_edge(fro, to, cap):\n    G[fro].append([to,cap,len(G[to])])\n    G[to].append([fro,0,len(G[fro])-1])\n\ndef dfs(v,t,f):\n    if v == t:\n        return f\n    visited[v] = True\n    for i,(to,cap,rev) in enumerate((G[v])):\n        if visited[to] or cap == 0:\n            continue        \n        d = dfs(to,t,min(f,cap))\n        if d > 0:\n            G[v][i][1] -= d\n            G[to][rev][1] += d\n            return d\n    return 0\n\ndef max_flow(s,t):\n    flow = 0\n    while True:\n        for i in xrange(V):\n            visited[i] = False\n        f = dfs(s,t,INF)\n        if f == 0:\n            return flow\n        flow += f\n\nwhile True:\n    m,n = map(int,raw_input().split())\n    if (m,n) == (0,0):\n        break\n    V = m+n+2\n    G = [[] for _ in xrange(V)]\n    visited = [True] * V\n    data = []\n    while len(data) < n+m:\n        data += map(int,raw_input().split())\n    blue = data[:m]\n    red = data[m:]\n    for i in xrange(m):\n        add_edge(V-2,i,1)\n    for i in xrange(m,m+n):\n        add_edge(i,V-1,1)\n    for i,b in enumerate(blue):\n        for j,r in enumerate(red,m):\n            if gcd(b,r) != 1:\n                add_edge(i,j,1)\n    print max_flow(V-2,V-1)"
  },
  {
    "language": "Python",
    "code": "# https://tjkendev.github.io/procon-library/python/max_flow/dinic.html\nimport sys\ndef input():\n\treturn sys.stdin.readline()[:-1]\nfrom math import gcd\nfrom collections import deque\nclass Dinic:\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.g = [[] for i in range(n)]\n\n\tdef add_edge(self, fr, to, cap):\n\t\t#[to, cap, rev]\n\t\tforward = [to, cap, None]\n\t\tforward[2] = backward = [fr, 0, forward]\n\t\tself.g[fr].append(forward)\n\t\tself.g[to].append(backward)\n\n\tdef add_bidirectional_edge(self, v1, v2, cap1, cap2):\n\t\tedge1 = [v2, cap1, None]\n\t\tedge1[2] = edge2 = [v1, cap2, edge1]\n\t\tself.g[v1].append(edge1)\n\t\tself.g[v2].append(edge2)\n\n\tdef bfs(self, s, t):\n\t\tself.level = level = [None]*self.n\n\t\tdeq = deque([s])\n\t\tlevel[s] = 0\n\t\tg = self.g\n\t\twhile deq:\n\t\t\tv = deq.popleft()\n\t\t\tlv = level[v] + 1\n\t\t\tfor w, cap, _ in g[v]:\n\t\t\t\tif cap and level[w] is None:\n\t\t\t\t\tlevel[w] = lv\n\t\t\t\t\tdeq.append(w)\n\t\treturn level[t] is not None\n\n\tdef dfs(self, v, t, f):\n\t\tif v == t:\n\t\t\treturn f\n\t\tlevel = self.level\n\t\tfor e in self.it[v]:\n\t\t\tw, cap, rev = e\n\t\t\tif cap and level[v] < level[w]:\n\t\t\t\td = self.dfs(w, t, min(f, cap))\n\t\t\t\tif d:\n\t\t\t\t\te[1] -= d\n\t\t\t\t\trev[1] += d\n\t\t\t\t\treturn d\n\t\treturn 0\n\n\tdef flow(self, s, t):\n\t\tflow = 0\n\t\tINF = 10**30\n\t\tg = self.g\n\t\twhile self.bfs(s, t):\n\t\t\t#*self.it, = map(iter, self.g)\n\t\t\tself.it = list(map(iter, self.g))\n\t\t\tf = INF\n\t\t\twhile f:\n\t\t\t\tf = self.dfs(s, t, INF)\n\t\t\t\tflow += f\n\t\treturn flow\n\nwhile True:\n\tn, m = map(int, input().split())\n\tif n == 0:\n\t\tbreak\n\tb = []\n\tr = []\n\twhile len(b) < n:\n\t\tb += list(map(int, input().split()))\n\twhile len(r) < m:\n\t\tr += list(map(int, input().split()))\n\tdinic = Dinic(n+m+2)\n\tfor i, x in enumerate(b):\n\t\tdinic.add_edge(n+m, i, 1)\n\t\tfor j, y in enumerate(r):\n\t\t\tif gcd(x, y) > 1:\n\t\t\t\tdinic.add_edge(i, n+j, 1)\n\tfor j in range(m):\n\t\tdinic.add_edge(n+j, n+m+1, 1)\n\tprint(dinic.flow(n+m, n+m+1))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom fractions import gcd\n\nINF = 2 << 30\nMAX_V = 1002\nG = [[] for _ in xrange(MAX_V)]\nvisited = [False]*MAX_V\n\ndef add_edge(fro, to, cap):\n    G[fro].append([to,cap,len(G[to])])\n    G[to].append([fro,0,len(G[fro])-1])\n\ndef dfs(v,t,f):\n    global visited\n    if v == t:\n        return f\n    visited[v] = True\n    for i,(to,cap,rev) in enumerate((G[v])):\n        if visited[to] or cap == 0:            \n            continue        \n        d = dfs(to,t,min(f,cap))\n        if d > 0:\n            G[v][i][1] -= d\n            G[to][rev][1] += d\n            return d\n    return 0\n\ndef max_flow(s,t):\n    global visited\n    flow = 0\n    while True:\n        visited = [False]*MAX_V\n        f = dfs(s,t,INF)\n        if f == 0:\n            return flow\n        flow += f\n\nwhile True:\n    m,n = map(int,raw_input().split())\n    if m|n == 0:\n        break\n    G = [[] for _ in xrange(MAX_V)]\n    data = []\n    while len(data) < n+m:\n        data += map(int,raw_input().split())    \n    blue = data[:m]\n    red = data[m:]\n    for i,b in enumerate(blue):\n        add_edge(MAX_V-2,i,1)\n    for i,r in enumerate(red):\n        add_edge(i+m,MAX_V-1,1)\n    for i in xrange(m):\n        for j in xrange(n):\n            if gcd(blue[i],red[j]) != 1:\n                add_edge(i,j+m,1)\n    print max_flow(MAX_V-2,MAX_V-1)"
  },
  {
    "language": "Python",
    "code": "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, gcd\nfrom itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nclass Dinic:\n    def __init__(self, n):\n        self.n = n\n        self.g = [[] for i in range(n)]\n\n    def add_edge(self, fr, to, cap):\n        #[to, cap, rev]\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.g[fr].append(forward)\n        self.g[to].append(backward)\n\n    def add_bidirectional_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.g[v1].append(edge1)\n        self.g[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.n\n        deq = deque([s])\n        level[s] = 0\n        g = self.g\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in g[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**30\n        g = self.g\n        while self.bfs(s, t):\n            self.it = list(map(iter, self.g))\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\nans = []\nwhile 1:\n    m, n = MAP()\n    if m == 0:\n        break\n    D = Dinic(m+n+2)\n    B = LIST()\n    while len(B) < m:\n        B += LIST()\n\n    R = LIST()\n    while len(R) < n:\n        R += LIST()\n    s = m+n\n    t = s+1\n\n    for i in range(m):\n        D.add_edge(s, i, 1)\n\n    for i in range(n):\n        D.add_edge(m+i, t, 1)\n\n    for i, x in enumerate(B):\n        for j, y in enumerate(R):\n            if gcd(x, y) != 1:\n                D.add_edge(i, m+j, 1)\n\n    ans.append(D.flow(s, t))\nprint(*ans, sep=\"\\n\")\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ninf = 100000000000000000\n\ndef dfs(graph, s, t):\n    V = len(graph)\n    prev = [(-1, -1)] * V\n    visited = [False] * V\n    visited[0] = True\n    def iter(cur):\n        if cur == t:\n            return True\n        for i in range(len(graph[cur])):\n            e = graph[cur][i]\n            if not visited[e['to']] and e['cap'] > 0 :\n                prev[e['to']] = (cur, i)\n                visited[e['to']] = True\n                if iter(e['to']):\n                    return True\n        return False\n        \n    iter(s)\n    if not visited[t]:\n        return None\n    else:\n        return prev\n\ndef decrease_graph(graph, s, t, prev):\n    ((p, e), c) = prev[t], t\n    m = inf\n    while p != -1:\n        m = min(graph[p][e]['cap'], m)\n        ((p, e), c) = prev[p], p\n    ((p, e), c) = prev[t], t\n    while p != -1:\n        graph[p][e]['cap'] -= m\n        graph[c][graph[p][e]['rev']]['cap'] += m\n        ((p, e), c) = prev[p], p\n    return m\n\ndef maximum_flow(graph, s, t):\n    V = len(graph)\n    g = [[] for _ in range(V)]\n    for v in range(V):\n        nei = graph[v]\n        for (u, cap) in nei:\n            g[v].append({'to' : u, 'from': v, 'cap': cap, 'rev': len(g[u])})\n            g[u].append({'to' : v, 'from': u, 'cap':   0, 'rev': len(g[v]) - 1})\n    \n    sum = 0\n    while True:\n        prev = dfs(g, s, t)\n        if prev == None:\n            break\n        sum += decrease_graph(g, s, t, prev)\n    return sum\n\ndef gcd(x, y):\n    while y > 0:\n        x, y = y, x % y\n    return x\n\ndef main():\n    while True:\n        m, n = map(int, input().split())\n        if m == 0 and n == 0:\n            return\n        data = []\n        while len(data) < n + m:\n            data += list(map(int, input().split()))\n        b = data[:m]\n        r = data[m:]\n        while len(r) < n:\n            r += list(map(int, input().split()))\n        \n        g = [[] for i in range(n + m + 2)]\n        for i in range(m):\n            g[0].append((i + 1, 1))\n        for i in range(n):\n            g[m + i + 1].append((n + m + 1, 1))\n        for i in range(m):\n            for j in range(n):\n                if gcd(b[i], r[j]) > 1:\n                    g[i + 1].append((m + j + 1, 1))\n\n        print(maximum_flow(g, 0, n + m + 1))\n        \nmain()"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom fractions import gcd\n\nINF = 2 << 30\nMAX_V = 1003\nG = [[] for _ in xrange(MAX_V)]\nvisited = [False]*MAX_V\n\ndef add_edge(fro, to, cap):\n    G[fro].append([to,cap,len(G[to])])\n    G[to].append([fro,0,len(G[fro])-1])\n\ndef dfs(v,t,f):\n    global visited\n    if v == t:\n        return f\n    visited[v] = True\n    for i,(to,cap,rev) in enumerate((G[v])):\n        if visited[to] or cap == 0:            \n            continue        \n        d = dfs(to,t,min(f,cap))\n        if d > 0:\n            G[v][i][1] -= d\n            G[to][rev][1] += d\n            return d\n    return 0\n\ndef max_flow(s,t):\n    global visited\n    flow = 0\n    while True:\n        visited = [False]*MAX_V\n        f = dfs(s,t,INF)\n        if f == 0:\n            return flow\n        flow += f\n\nwhile True:\n    m,n = map(int,raw_input().split())\n    if m|n == 0:\n        break\n    G = [[] for _ in xrange(MAX_V)]\n    data = []\n    while len(data) < n+m:\n        data += map(int,raw_input().split())    \n    blue = data[:m]\n    red = data[m:]\n    for i,b in enumerate(blue):\n        add_edge(MAX_V-2,i,1)\n    for i,r in enumerate(red):\n        add_edge(i+m,MAX_V-1,1)\n    for i in xrange(m):\n        for j in xrange(n):\n            if gcd(blue[i],red[j]) != 1:\n                add_edge(i,j+m,1)\n    print max_flow(MAX_V-2,MAX_V-1)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ninf = 100000000000000000\n\ndef bfs(graph, s, t):\n    V = len(graph)\n    q = deque([(s, -1, -1)])\n    prev = [(-1, -1)] * V\n    visited = [False] * V\n    while len(q) > 0:\n        (v, p, e) = q.popleft()\n        if visited[v]:\n            continue\n        visited[v] = True\n        prev[v] = p, e\n        for i in range(len(graph[v])):\n            e = graph[v][i]\n            if e['cap'] > 0:\n                q.append((e['to'], v, i))\n    if not visited[t]:\n        return None\n    else:\n        return prev\n\ndef decrease_graph(graph, s, t, prev):\n    ((p, e), c) = prev[t], t\n    m = inf\n    while p != -1:\n        m = min(graph[p][e]['cap'], m)\n        ((p, e), c) = prev[p], p\n    ((p, e), c) = prev[t], t\n    while p != -1:\n        graph[p][e]['cap'] -= m\n        graph[c][graph[p][e]['rev']]['cap'] += m\n        ((p, e), c) = prev[p], p\n    return m\n\ndef maximum_flow(graph, s, t):\n    V = len(graph)\n    g = [[] for _ in range(V)]\n    for v in range(V):\n        nei = graph[v]\n        for (u, cap) in nei:\n            g[v].append({'to' : u, 'from': v, 'cap': cap, 'rev': len(g[u])})\n            g[u].append({'to' : v, 'from': u, 'cap':   0, 'rev': len(g[v]) - 1})\n    \n    sum = 0\n    while True:\n        prev = bfs(g, s, t)\n        if prev == None:\n            break\n        sum += decrease_graph(g, s, t, prev)\n    return sum\n\ndef gcd(x, y):\n    while y > 0:\n        x, y = y, x % y\n    return x\n\ndef main():\n    while True:\n        m, n = map(int, input().split())\n        if m == 0 and n == 0:\n            return\n        b = []\n        while len(b) < m:\n            b += list(map(int, input().split()))\n        r = []\n        while len(r) < n:\n            r += list(map(int, input().split()))\n        \n        g = [[] for i in range(n + m + 2)]\n        for i in range(m):\n            g[0].append((i + 1, 1))\n        for i in range(n):\n            g[m + i + 1].append((n + m + 1, 1))\n        for i in range(m):\n            for j in range(n):\n                if gcd(b[i], r[j]) > 1:\n                    g[i + 1].append((m + j + 1, 1))\n\n        print(maximum_flow(g, 0, n + m + 1))\n        \nmain()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ninf = 1000000000\n\ndef bfs(graph, s, t):\n    V = len(graph)\n    q = deque([(s, -1, -1)])\n    prev = [(-1, -1)] * V\n    visited = [False] * V\n    while len(q) > 0:\n        (v, p, e) = q.popleft()\n        if visited[v]:\n            continue\n        visited[v] = True\n        prev[v] = p, e\n        for i in range(len(graph[v])):\n            e = graph[v][i]\n            if e['cap'] > 0:\n                q.append((e['to'], v, i))\n    if not visited[t]:\n        return None\n    else:\n        return prev\n\ndef decrease_graph(graph, s, t, prev):\n    ((p, e), c) = prev[t], t\n    m = inf\n    while p != -1:\n        m = min(graph[p][e]['cap'], m)\n        ((p, e), c) = prev[p], p\n    ((p, e), c) = prev[t], t\n    while p != -1:\n        graph[p][e]['cap'] -= m\n        graph[c][graph[p][e]['rev']]['cap'] += m\n        ((p, e), c) = prev[p], p\n    return m\n\ndef maximum_flow(graph, s, t):\n    V = len(graph)\n    g = [[] for _ in range(V)]\n    for v in range(V):\n        nei = graph[v]\n        for (u, cap) in nei:\n            g[v].append({'to' : u, 'from': v, 'cap': cap, 'rev': len(g[u])})\n            g[u].append({'to' : v, 'from': u, 'cap':   0, 'rev': len(g[v]) - 1})\n    \n    sum = 0\n    while True:\n        prev = bfs(g, s, t)\n        if prev == None:\n            break\n        sum += decrease_graph(g, s, t, prev)\n    return sum\n\ndef gcd(x, y):\n    while y > 0:\n        x, y = y, x % y\n    return x\n\ndef main():\n    while True:\n        m, n = map(int, input().split())\n        if m == 0 and n == 0:\n            return\n        b = []\n        while len(b) < m:\n            b += list(map(int, input().split()))\n        r = []\n        while len(r) < n:\n            r += list(map(int, input().split()))\n        \n        g = [[] for i in range(n + m + 2)]\n        for i in range(m):\n            g[0].append((i + 1, 1))\n        for i in range(n):\n            g[m + i + 1].append((n + m + 1, 1))\n        for i in range(m):\n            for j in range(n):\n                if gcd(b[i], r[j]) > 1:\n                    g[i + 1].append((m + j + 1, 1))\n\n        print(maximum_flow(g, 0, n + m + 1))\n        \nmain()"
  },
  {
    "language": "Python",
    "code": "from fractions import gcd\n\nV = 1001\nG = []\nvisited = []\nmatch = []\n\ndef add_edge(u,v):\n    G[u].append(v)\n    G[v].append(u)\n\ndef dfs(v):\n    visited[v] = True\n    for u in G[v]:\n        w = match[u]\n        if w < 0 or not visited[w] and dfs(w):\n            match[v] = u\n            match[u] = v\n            return True\n\ndef bipartite_matching():\n    global match,visited\n    res = 0\n    match = [-1]*V\n    for v in xrange(V):\n        if match[v] < 0:\n            visited = [False]*V\n            if dfs(v):\n                res += 1\n    return res\n\nwhile True:\n    m,n = map(int,raw_input().split())\n    V = m+n\n    if V == 0:\n        break\n    G = [[] for _ in xrange(V)]\n    data = []\n    while len(data) < V:\n        data += map(int,raw_input().split())\n    for i,b in enumerate(data[:m]):\n        for j,r in enumerate(data[m:],m):\n            if gcd(b,r) != 1:\n                add_edge(i,j)\n    print bipartite_matching()"
  },
  {
    "language": "Python",
    "code": "#ARC092-C 2D Plane 2N Points\n\"\"\"\n重みなし2部マッチング問題\n\"\"\"\nimport sys\nreadline = sys.stdin.buffer.readline\ndef even(n): return 1 if n%2==0 else 0\n\n#ネットワークフロー\n#最大流,最小カット\nimport queue\nclass Dinic():\n    #Dinic法,O(|E||V|**2) ※但し、実際にはもっと高速な動作\n\n    def __init__(self, v, inf = 10**10):\n        # v:頂点数\n        # G:辺情報.各頂点に対し、[行き先,重み,(この辺を含めず)既に存在する行き先の辺数]\n        # level:startからの距離(これはcapacityを考慮しない) bfsで毎回リセットされる\n        # iter:各頂点について、どこまで調べ終わったかを記録する\n        self.V = v\n        self.inf = inf\n        self.G = [[] for _ in range(v)]\n        self.level = [0 for _ in range(v)]\n        self.iter = [0 for _ in range(v)]\n\n    def add_edge(self, from_, to, cap):\n        # to: 行き先, cap: 容量, rev: 反対側の辺\n\n        # 無向グラフの場合、G[to]の方のcapを0→capにする必要があるので注意.('rev'はそのままで良い)\n\n        self.G[from_].append({'to':to, 'cap':cap, 'rev':len(self.G[to])})\n        self.G[to].append({'to':from_, 'cap':0, 'rev':len(self.G[from_])-1})\n\n    # sからの最短距離をbfsで計算\n    def bfs(self, s):\n        self.level = [-1 for _ in range(self.V)]\n        self.level[s] = 0\n        que = queue.Queue()\n        que.put(s)\n        while not que.empty():\n            v = que.get()\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if e['cap'] > 0 and self.level[e['to']] < 0:\n                    self.level[e['to']] = self.level[v] + 1\n                    que.put(e['to'])\n\n    # 増加パスをdfsで探す\n    def dfs(self, v, t, f):\n        if v == t: return f\n        for i in range(self.iter[v], len(self.G[v])):\n            self.iter[v] = i\n            e = self.G[v][i]\n            if e['cap'] > 0 and self.level[v] < self.level[e['to']]: #流れているかつ、levelが大きいなら\n                d = self.dfs(e['to'], t, min(f, e['cap'])) # d:流量\n                if d > 0:\n                    e['cap'] -= d #使用済みの分だけcapから引く\n                    self.G[e['to']][e['rev']]['cap'] += d\n                    return d\n\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s) #levelの更新\n            # bfsでtに到達不可なら終了\n            if self.level[t] < 0 : return flow\n            #イテレータの初期化(イテレータ：各頂点に対し、どこまで調べ終わったか)\n            self.iter = [0 for _ in range(self.V)]\n            f = self.dfs(s, t, self.inf) #f:そのパスの流量\n            while f > 0:\n                flow += f\n                f = self.dfs(s,t, self.inf)\n\n\"\"\"素因数分解\"\"\"\ndef factrize(n):\n    b = 2\n    fct = []\n    while b*b <= n:\n        while n % b == 0:\n            n //= b\n            #もし素因数を重複させたくないならここを加えてfct.append(b)を消す\n            if not b in fct:\n                fct.append(b)\n        b = b+1\n    if n > 1:\n        fct.append(n)\n    return fct #リストが帰る\ndef gcd(a,b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b,a%b)\ndef lcm(a,b):\n    return (a//gcd(a,b)*b)\nwhile True:\n    m,n = map(int,readline().split())\n    if m == 0 and n == 0:\n        break\n\n    network = Dinic(m+n+2)\n    source = 0\n    sink = m+n+1\n    blue = []\n    red = []\n    while len(blue) < m:\n        blue += list(map(int,readline().split()))\n    while len(red) < n:\n        red += list(map(int,readline().split()))\n    \n    for i in range(m):\n        for j in range(n):\n            if gcd(blue[i],red[j]) > 1:\n                network.add_edge(i+1,m+j+1,1)\n    for i in range(m):\n        network.add_edge(source,i+1,1)\n    for i in range(n):\n        network.add_edge(m+i+1,sink,1)\n    print(network.max_flow(source,sink))\n        \n\n    \n\n    \n    \n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from fractions import gcd\n\nINF = 2 << 30\nV = 1002\nG = [[] for _ in xrange(V)]\nvisited = [False]*V\n\ndef add_edge(fro, to, cap):\n    G[fro].append([to,cap,len(G[to])])\n    G[to].append([fro,0,len(G[fro])-1])\n\ndef dfs(v,t,f):\n    if v == t:\n        return f\n    visited[v] = True\n    for i,(to,cap,rev) in enumerate((G[v])):\n        if visited[to] or cap == 0:            \n            continue        \n        d = dfs(to,t,min(f,cap))\n        if d > 0:\n            G[v][i][1] -= d\n            G[to][rev][1] += d\n            return d\n    return 0\n\ndef max_flow(s,t):\n    flow = 0\n    while True:\n        for i in xrange(V):\n            visited[i] = False\n        f = dfs(s,t,INF)\n        if f == 0:\n            return flow\n        flow += f\n\nwhile True:\n    m,n = map(int,raw_input().split())\n    if m|n == 0:\n        break\n    V = m+n+2\n    G = [[] for _ in xrange(V)]\n    visited = [True] * V\n    data = []\n    dbg = 0\n    while len(data) < n+m:\n        dbg += 1\n        data += map(int,raw_input().split())            \n        if dbg >= 1500:\n            break\n    blue = data[:m]\n    red = data[m:]\n    for i in xrange(m):\n        add_edge(V-2,i,1)\n    for i in xrange(m,m+n):\n        add_edge(i,V-1,1)\n    for i,b in enumerate(blue):\n        for j,r in enumerate(red,m):\n            if gcd(b,r) != 1:\n                add_edge(i,j,1)\n    print max_flow(V-2,V-1)"
  },
  {
    "language": "Python",
    "code": "import collections\nimport fractions\n\n\nclass Dinic:\n    \"\"\"Dinic Algorithm: find max-flow\n       complexity: O(EV^2)\n       used in GRL6A(AOJ)\n    \"\"\"\n    class edge:\n        def __init__(self, to, cap, rev):\n            self.to, self.cap, self.rev = to, cap, rev\n\n    def __init__(self, V, E, source, sink):\n        \"\"\" V: the number of vertexes\n            E: adjacency list\n            source: start point\n            sink: goal point\n        \"\"\"\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        for fr in range(V):\n            for to, cap in E[fr]:\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr])-1))\n        self.maxflow = self.dinic(source, sink)\n\n    def dinic(self, source, sink):\n        \"\"\"find max-flow\"\"\"\n        INF = float('inf')\n        maxflow = 0\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = [0] * self.V\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > 0:\n                    maxflow += flow\n                else:\n                    break\n\n    def dfs(self, vertex, sink, flow):\n        \"\"\"find augmenting path\"\"\"\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if e.cap > 0 and self.level[vertex] < self.level[e.to]:\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n                if d > 0:\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return 0\n\n    def bfs(self, start):\n        \"\"\"find shortest path from start\"\"\"\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if e.cap > 0 and self.level[e.to] < 0:\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\n\nwhile True:\n    M, N = map(int, input().split())\n    if M == 0 and N == 0:\n        break\n    blue, red = [], []\n    while True:\n        for x in input().split():\n            blue.append(int(x))\n        if len(blue) == M:\n            break\n    while True:\n        for x in input().split():\n            red.append(int(x))\n        if len(red) == N:\n            break\n    V = M + N + 2\n    edge = [[] for _ in range(V)]\n    for i, b in enumerate(blue):\n        for j, r in enumerate(red):\n            if fractions.gcd(b, r) != 1:\n                edge[i].append((M+j, 1))\n    for i in range(M):\n        edge[M+N].append((i, 1))\n    for j in range(N):\n        edge[M+j].append((M+N+1, 1))\n    print(Dinic(V, edge, M+N, M+N+1).maxflow)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nCards\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1163&lang=jp\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import namedtuple\nfrom fractions import gcd\ninput = stdin.readline\n\nedge = namedtuple('edge', ['to', 'cap', 'rev'])\n\ndef add_edge(G, f, t, c):\n    G[f].append(edge(t, c, len(G[t])))\n    G[t].append(edge(f, 0, len(G[f]) - 1))\n\n\ndef dfs(G, used, v, t, f):\n    if v == t:\n        return f\n    used[v] = True\n    for i in range(len(G[v])):\n        e = G[v][i]\n        if (not used[e.to]) and (e.cap > 0):\n            d = dfs(G, used, e.to, t, min(f, e.cap))\n            if d > 0:\n                G[v][i] = edge(e.to, e.cap - d, e.rev)\n                G[e.to][e.rev] = edge(G[e.to][e.rev].to, G[e.to][e.rev].cap + d, G[e.to][e.rev].rev)\n                return d\n    return 0\n\n\ndef max_flow(G, V,s, t):\n    used = [False] * V\n    flow = 0\n    while True:\n        for i in range(len(used)):\n            used[i] = False\n        f = dfs(G, used, s, t, float('inf'))\n        if f == 0:\n            return flow\n        flow += f\n\n\ndef main(args):\n    \"\"\"\n    0: ソース\n    1〜m: 青\n    m+1〜m+n: 赤\n    m+n+1: シンク\n    \"\"\"\n    while True:\n        m, n = map(int, input().split())\n        if m == 0 and n == 0:\n            break\n\n        blue_cards = []\n        red_cards = []\n        while True:\n            blue_cards.extend([int(b) for b in input().split()])\n            if len(blue_cards) == m:\n                break\n        while True:\n            red_cards.extend([int(r) for r in input().split()])\n            if len(red_cards) == n:\n                break\n\n        G = [[] for _ in range(m+n+2)]\n\n        for b in range(1, m+1):\n            add_edge(G, 0, b, 1)\n        for r in range(m+1, m+n+1):\n            add_edge(G, r, m+n+1, 1)\n\n        for bi, b in enumerate(blue_cards, start=1):\n            for ri, r in enumerate(red_cards, start=m+1):\n                if gcd(b, r) != 1:\n                    add_edge(G, bi, ri, 1)\n\n        ans = max_flow(G, m+n+2, 0, m+n+1)\n        print(ans)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n\n"
  },
  {
    "language": "Python",
    "code": "\nfrom fractions import gcd\n\n\ndef add_edge(u, v):\n    G[u].append(v)\n    G[v].append(u)\n\n\ndef dfs(v):\n    used[v] = True\n    for u in G[v]:\n        w = match[u]\n        if w < 0 or not used[w] and dfs(w):\n            match[v] = u\n            match[u] = v\n            return True\n    else:\n        return False\n\n\ndef bipartite_matching():\n    result = 0\n    match[:] = [-1] * (numv)\n    for v in range(numv):\n        if match[v] < 0:\n            used[:] = [False] * numv\n            if dfs(v):\n                result += 1\n    return result\n\n\nwhile True:\n    m, n = map(int, input().split())\n    if (m, n) == (0, 0):\n        break\n    numv = m + n\n    cards = []\n    while len(cards) < numv:\n        cards.extend(map(int, input().split()))\n    blues = cards[:m]\n    reds = cards[m:]\n    G = [[] for i in range(numv)]\n    used = [False] * numv\n    match = [-1] * numv\n    for i, b in enumerate(blues):\n        for j, r in enumerate(reds, m):\n            if gcd(b, r) > 1:\n                add_edge(i, j)\n\n    print(bipartite_matching())"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom fractions import gcd\n\nclass Dinic:\n    class Edge:\n        def __init__(self, to, cap, rev):\n            self.to = to\n            self.cap = cap\n            self.rev = rev\n        \n        def __repr__(self):\n            return \"(to: {0} cap: {1} rev: {2})\".format(self.to, self.cap, self. rev)\n\n    def __init__(self,V):\n        self.V = V\n        self.size = [0 for i in range(V)]\n        self.G = [[] for i in range(V)]\n\n    def add_edge(self, _from, to, cap):\n        self.G[_from].append(self.Edge(to, cap, self.size[to]))\n        self.G[to].append(self.Edge(_from, 0, self.size[_from]))\n        self.size[_from] += 1\n        self.size[to] += 1\n\n    def bfs(self,s):\n        level = [-1 for i in range(self.V)]\n        level[s] = 0\n        q = []\n        q.append(s)\n        while q != []:\n            v = q.pop(0)\n            for u in self.G[v]:\n                if u.cap > 0 and level[u.to] < 0:\n                    level[u.to] = level[v] + 1\n                    q.append(u.to)\n        return level\n\n    def dfs(self, v, t, f):\n        if v == t: return f\n        for i in range(self.iterator[v],self.size[v]):\n            self.iterator[v] = i\n            edge = self.G[v][i]\n            if edge.cap > 0 and self.level[v] < self.level[edge.to]:\n                d = self.dfs(edge.to, t, f if f < edge.cap else edge.cap)\n                if d > 0:\n                    self.G[v][i].cap -= d\n                    self.G[edge.to][edge.rev].cap += d\n                    return d\n        return 0\n\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.level = self.bfs(s)\n            if self.level[t] < 0:\n                return flow\n            self.iterator = [0 for i in range(self.V)]\n            while True:\n                f = self.dfs(s, t, float('inf'))\n                if f == 0:\n                    break\n                flow += f\n\nwhile True:\n    m,n = map(int,input().split())\n    if (m,n) == (0,0):\n        break\n    B = []\n    R = []\n\n    while True:\n        for x in map(int, input().split()):\n            B.append(x)\n        if len(B) ==m:\n            break\n\n    while True:\n        for x in map(int, input().split()):\n            R.append(x)\n        if len(R) == n:\n            break\n    dinic = Dinic(2 + m + n)\n    \n    _b = 1\n    _r = 1 + m\n    for b_idx, b in enumerate(B):\n        for r_idx, r in enumerate(R):\n            if gcd(b,r) > 1:\n                dinic.add_edge(_b + b_idx, _r + r_idx, 1)\n        dinic.add_edge(0, b_idx + _b, 1)\n    for r_idx, r in enumerate(R):\n        dinic.add_edge(r_idx + _r, 1 + m + n, 1)\n    dinic.max_flow(0, 1+m+n)\n    ans = 0\n    for rev in dinic.G[1+m+n]:\n        ans += rev.cap\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ninf = 100000000000000000\n\ndef bfs(graph, s, t):\n    V = len(graph)\n    q = deque([(s, -1, -1)])\n    prev = [(-1, -1)] * V\n    visited = [False] * V\n    while len(q) > 0:\n        (v, p, e) = q.popleft()\n        if visited[v]:\n            continue\n        visited[v] = True\n        prev[v] = p, e\n        for i in range(len(graph[v])):\n            e = graph[v][i]\n            if e['cap'] > 0:\n                q.append((e['to'], v, i))\n    if not visited[t]:\n        return None\n    else:\n        return prev\n\ndef decrease_graph(graph, s, t, prev):\n    ((p, e), c) = prev[t], t\n    m = inf\n    while p != -1:\n        m = min(graph[p][e]['cap'], m)\n        ((p, e), c) = prev[p], p\n    ((p, e), c) = prev[t], t\n    while p != -1:\n        graph[p][e]['cap'] -= m\n        graph[c][graph[p][e]['rev']]['cap'] += m\n        ((p, e), c) = prev[p], p\n    return m\n\ndef maximum_flow(graph, s, t):\n    V = len(graph)\n    g = [[] for _ in range(V)]\n    for v in range(V):\n        nei = graph[v]\n        for (u, cap) in nei:\n            g[v].append({'to' : u, 'from': v, 'cap': cap, 'rev': len(g[u])})\n            g[u].append({'to' : v, 'from': u, 'cap':   0, 'rev': len(g[v]) - 1})\n    \n    sum = 0\n    while True:\n        prev = bfs(g, s, t)\n        if prev == None:\n            break\n        sum += decrease_graph(g, s, t, prev)\n    return sum\n\ndef gcd(x, y):\n    while y > 0:\n        x, y = y, x % y\n    return x\n\ndef main():\n    while True:\n        m, n = map(int, input().split())\n        if m == 0 and n == 0:\n            return\n        data = []\n        while len(data) < n + m:\n            data += list(map(int, input().split()))\n        b = data[:m]\n        r = data[m:]\n        while len(r) < n:\n            r += list(map(int, input().split()))\n        \n        g = [[] for i in range(n + m + 2)]\n        for i in range(m):\n            g[0].append((i + 1, 1))\n        for i in range(n):\n            g[m + i + 1].append((n + m + 1, 1))\n        for i in range(m):\n            for j in range(n):\n                if gcd(b[i], r[j]) > 1:\n                    g[i + 1].append((m + j + 1, 1))\n\n        print(maximum_flow(g, 0, n + m + 1))\n        \nmain()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ninf = 100000000000000000\n\ndef bfs(graph, s, t):\n    V = len(graph)\n    q = deque([(s, -1, -1)])\n    prev = [(-1, -1)] * V\n    visited = [False] * V\n    while len(q) > 0:\n        (v, p, e) = q.popleft()\n        if visited[v]:\n            continue\n        visited[v] = True\n        prev[v] = p, e\n        for i in range(len(graph[v])):\n            e = graph[v][i]\n            if e['cap'] > 0:\n                q.append((e['to'], v, i))\n    if not visited[t]:\n        return None\n    else:\n        return prev\n\ndef decrease_graph(graph, s, t, prev):\n    ((p, e), c) = prev[t], t\n    m = inf\n    while p != -1:\n        m = min(graph[p][e]['cap'], m)\n        ((p, e), c) = prev[p], p\n    ((p, e), c) = prev[t], t\n    while p != -1:\n        graph[p][e]['cap'] -= m\n        graph[c][graph[p][e]['rev']]['cap'] += m\n        ((p, e), c) = prev[p], p\n    return m\n\ndef maximum_flow(graph, s, t):\n    V = len(graph)\nh    g = [[] for _ in range(V)]\n    for v in range(V):\n        nei = graph[v]\n        for (u, cap) in nei:\n            g[v].append({'to' : u, 'from': v, 'cap': cap, 'rev': len(g[u])})\n            g[u].append({'to' : v, 'from': u, 'cap':   0, 'rev': len(g[v]) - 1})\n    \n    sum = 0\n    while True:\n        prev = bfs(g, s, t)\n        if prev == None:\n            break\n        sum += decrease_graph(g, s, t, prev)\n    return sum\n\ndef gcd(x, y):\n    while y > 0:\n        x, y = y, x % y\n    return x\n\ndef main():\n    while True:\n        m, n = map(int, input().split())\n        if m == 0 and n == 0:\n            return\n        b = []\n        b += list(map(int, input().split()))\n        r = []\n        r += list(map(int, input().split()))\n        \n        g = [[] for i in range(n + m + 2)]\n        for i in range(m):\n            g[0].append((i + 1, 1))\n        for i in range(n):\n            g[m + i + 1].append((n + m + 1, 1))\n        for i in range(m):\n            for j in range(n):\n                if gcd(b[i], r[j]) > 1:\n                    g[i + 1].append((m + j + 1, 1))\n\n        print(maximum_flow(g, 0, n + m + 1))\n        \nmain()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = map(iter, self.G)\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\ndef gcd(a,b):\n    while b!=0:\n        a,b = b,a%b\n    return a\n\nres = []\nwhile True:\n    m,n = map(int, input().split())\n    if m==0 and n==0:\n        break\n\n    bl = []\n    while len(bl)<m:\n        bl.extend(list(map(int, input().split())))\n    rl = []\n    while len(rl)<n:\n        rl.extend(list(map(int, input().split())))\n\n    dinic = Dinic(m+n+2)\n    s = n+m\n    t = n+m+1\n    for i in range(m):\n        for j in range(n):\n            if gcd(bl[i],rl[j])>1:\n                dinic.add_edge(i,m+j,1)\n    for i in range(m):\n        dinic.add_edge(s,i,1)\n    for j in range(m,n+m):\n        dinic.add_edge(j,t,1)\n    res.append(dinic.flow(s,t))\n\nfor r in res:\n    print(r)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nINF = float(\"inf\")\nTO = 0;  CAP = 1;  REV = 2\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.V = [[] for _ in range(N)]  # to, cap, rev\n        # 辺 e = V[n][m] の逆辺は V[e[TO]][e[REV]]\n        self.level = [0] * N\n\n    def add_edge(self, u, v, cap):\n        self.V[u].append([v, cap, len(self.V[v])])\n        self.V[v].append([u, 0, len(self.V[u])-1])\n\n    def add_edge_undirected(self, u, v, cap):  # 未検証\n        self.V[u].append([v, cap, len(self.V[v])])\n        self.V[v].append([u, cap, len(self.V[u])-1])\n\n    def bfs(self, s: int) -> bool:\n        self.level = [-1] * self.N\n        self.level[s] = 0\n        q = deque()\n        q.append(s)\n        while len(q) != 0:\n            v = q.popleft()\n            for e in self.V[v]:\n                if e[CAP] > 0 and self.level[e[TO]] == -1:  # capが1以上で未探索の辺\n                    self.level[e[TO]] = self.level[v] + 1\n                    q.append(e[TO])\n        return True if self.level[self.g] != -1 else False  # 到達可能\n\n    def dfs(self, v: int, f) -> int:\n        if v == self.g:\n            return f\n        for i in range(self.ite[v], len(self.V[v])):\n            self.ite[v] = i\n            e = self.V[v][i]\n            if e[CAP] > 0 and self.level[v] < self.level[e[TO]]:\n                d = self.dfs(e[TO], min(f, e[CAP]))\n                if d > 0:  # 増加路\n                    e[CAP] -= d  # cap を減らす\n                    self.V[e[TO]][e[REV]][CAP] += d  # 反対方向の cap を増やす\n                    return d\n        return 0\n\n    def solve(self, s, g):\n        self.g = g\n        flow = 0\n        while self.bfs(s):  # 到達可能な間\n            self.ite = [0] * self.N\n            f = self.dfs(s, INF)\n            while f > 0:\n                flow += f\n                f = self.dfs(s, INF)\n        return flow\n\nfrom fractions import gcd\nwhile True:\n    m, n = map(int, input().split())\n    if m==n==0:\n        break\n    B = []\n    while len(B)!=m:\n        B += list(map(int, input().split()))\n    R = []\n    while len(R)!=n:\n        R += list(map(int, input().split()))\n    dinic = Dinic(m+n+2)\n    s, g = m+n, m+n+1\n    for i in range(m):\n        dinic.add_edge(s, i, 1)\n    for i in range(m, m+n):\n        dinic.add_edge(i, g, 1)\n\n    for i, r in enumerate(B):\n        for j, b in enumerate(R, m):\n            if gcd(r, b) > 1:\n                dinic.add_edge(i, j, 1)\n    print(dinic.solve(s, g))\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nclass HopcroftKarp:\n    def __init__(self, N0, N1):\n        self.N0 = N0\n        self.N1 = N1\n        self.N = N = 2+N0+N1\n        self.G = [[] for i in range(N)]\n        for i in range(N0):\n            forward = [2+i, 1, None]\n            forward[2] = backward = [0, 0, forward]\n            self.G[0].append(forward)\n            self.G[2+i].append(backward)\n        self.backwards = bs = []\n        for i in range(N1):\n            forward = [1, 1, None]\n            forward[2] = backward = [2+N0+i, 0, forward]\n            bs.append(backward)\n            self.G[2+N0+i].append(forward)\n            self.G[1].append(backward)\n\n    def add_edge(self, fr, to):\n        #assert 0 <= fr < self.N0\n        #assert 0 <= to < self.N1\n        v0 = 2 + fr\n        v1 = 2 + self.N0 + to\n        forward = [v1, 1, None]\n        forward[2] = backward = [v0, 0, forward]\n        self.G[v0].append(forward)\n        self.G[v1].append(backward)\n\n    def bfs(self):\n        G = self.G\n        level = [None]*self.N\n        deq = deque([0])\n        level[0] = 0\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        self.level = level\n        return level[1] is not None\n\n    def dfs(self, v, t):\n        if v == t:\n            return 1\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w] and self.dfs(w, t):\n                e[1] = 0\n                rev[1] = 1\n                return 1\n        return 0\n\n    def flow(self):\n        flow = 0\n        G = self.G\n        bfs = self.bfs; dfs = self.dfs\n        while bfs():\n            *self.it, = map(iter, G)\n            while dfs(0, 1):\n                flow += 1\n        return flow\n\n    def matching(self):\n        return [cap for _, cap, _ in self.backwards]\n\ndef gcd(m, n):\n    r = m % n\n    return gcd(n, r) if r else n\n\nwhile 1:\n    M, N = map(int, input().split())\n    if M == N == 0:\n        break\n    B = []\n    while len(B) < M:\n        B.extend(map(int, input().split()))\n    R = []\n    while len(R) < N:\n        R.extend(map(int, input().split()))\n    hk = HopcroftKarp(M, N)\n    for i in range(M):\n        for j in range(N):\n            if gcd(B[i], R[j]) > 1:\n                hk.add_edge(i, j)\n    print(hk.flow())\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ninf = 100000000000000000\n\ndef bfs(graph, s, t):\n    V = len(graph)\n    q = deque([(s, -1, -1)])\n    prev = [(-1, -1)] * V\n    visited = [False] * V\n    while len(q) > 0:\n        (v, p, e) = q.popleft()\n        if visited[v]:\n            continue\n        visited[v] = True\n        prev[v] = p, e\n        for i in range(len(graph[v])):\n            e = graph[v][i]\n            if e['cap'] > 0:\n                q.append((e['to'], v, i))\n    if not visited[t]:\n        return None\n    else:\n        return prev\n\ndef decrease_graph(graph, s, t, prev):\n    ((p, e), c) = prev[t], t\n    m = inf\n    while p != -1:\n        m = min(graph[p][e]['cap'], m)\n        ((p, e), c) = prev[p], p\n    ((p, e), c) = prev[t], t\n    while p != -1:\n        graph[p][e]['cap'] -= m\n        graph[c][graph[p][e]['rev']]['cap'] += m\n        ((p, e), c) = prev[p], p\n    return m\n\ndef maximum_flow(graph, s, t):\n    V = len(graph)\nh    g = [[] for _ in range(V)]\n    for v in range(V):\n        nei = graph[v]\n        for (u, cap) in nei:\n            g[v].append({'to' : u, 'from': v, 'cap': cap, 'rev': len(g[u])})\n            g[u].append({'to' : v, 'from': u, 'cap':   0, 'rev': len(g[v]) - 1})\n    \n    sum = 0\n    while True:\n        prev = bfs(g, s, t)\n        if prev == None:\n            break\n        sum += decrease_graph(g, s, t, prev)\n    return sum\n\ndef gcd(x, y):\n    while y > 0:\n        x, y = y, x % y\n    return x\n\ndef main():\n    while True:\n        m, n = map(int, input().split())\n        if m == 0 and n == 0:\n            return\n        b = []\n        while len(b) < m:\n            b += list(map(int, input().split()))\n        r = []\n        while len(r) < n:\n            r += list(map(int, input().split()))\n        \n        g = [[] for i in range(n + m + 2)]\n        for i in range(m):\n            g[0].append((i + 1, 1))\n        for i in range(n):\n            g[m + i + 1].append((n + m + 1, 1))\n        for i in range(m):\n            for j in range(n):\n                if gcd(b[i], r[j]) > 1:\n                    g[i + 1].append((m + j + 1, 1))\n\n        print(maximum_flow(g, 0, n + m + 1))\n        \nmain()"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nCards\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1163&lang=jp\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import namedtuple\nfrom math import gcd\ninput = stdin.readline\n\nedge = namedtuple('edge', ['to', 'cap', 'rev'])\n\ndef add_edge(G, f, t, c):\n    G[f].append(edge(t, c, len(G[t])))\n    G[t].append(edge(f, 0, len(G[f]) - 1))\n\n\ndef dfs(G, used, v, t, f):\n    if v == t:\n        return f\n    used[v] = True\n    for i in range(len(G[v])):\n        e = G[v][i]\n        if (not used[e.to]) and (e.cap > 0):\n            d = dfs(G, used, e.to, t, min(f, e.cap))\n            if d > 0:\n                G[v][i] = edge(e.to, e.cap - d, e.rev)\n                G[e.to][e.rev] = edge(G[e.to][e.rev].to, G[e.to][e.rev].cap + d, G[e.to][e.rev].rev)\n                return d\n    return 0\n\n\ndef max_flow(G, V,s, t):\n    used = [False] * V\n    flow = 0\n    while True:\n        for i in range(len(used)):\n            used[i] = False\n        f = dfs(G, used, s, t, float('inf'))\n        if f == 0:\n            return flow\n        flow += f\n\n\ndef main(args):\n    \"\"\"\n    0: ソース\n    1〜m: 青\n    m+1〜m+n: 赤\n    m+n+1: シンク\n    \"\"\"\n    while True:\n        m, n = map(int, input().split())\n        if m == 0 and n == 0:\n            break\n\n        blue_cards = []\n        red_cards = []\n        while True:\n            blue_cards.extend([int(b) for b in input().split()])\n            if len(blue_cards) == m:\n                break\n        while True:\n            red_cards.extend([int(r) for r in input().split()])\n            if len(red_cards) == n:\n                break\n\n        G = [[] for _ in range(m+n+2)]\n\n        for b in range(1, m+1):\n            add_edge(G, 0, b, 1)\n        for r in range(m+1, m+n+1):\n            add_edge(G, r, m+n+1, 1)\n\n        for bi, b in enumerate(blue_cards, start=1):\n            for ri, r in enumerate(red_cards, start=m+1):\n                if gcd(b, r) != 1:\n                    add_edge(G, bi, ri, 1)\n\n        ans = max_flow(G, m+n+2, 0, m+n+1)\n        print(ans)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n\n"
  },
  {
    "language": "Python",
    "code": "import collections\nimport math\nrange = xrange; input = raw_input\n\n\nclass Dinic:\n    \"\"\"Dinic Algorithm: find max-flow\n       complexity: O(EV^2)\n       used in GRL6A(AOJ)\n    \"\"\"\n    class edge:\n        def __init__(self, to, cap, rev):\n            self.to, self.cap, self.rev = to, cap, rev\n\n    def __init__(self, V, E, source, sink):\n        \"\"\" V: the number of vertexes\n            E: adjacency list\n            source: start point\n            sink: goal point\n        \"\"\"\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        for fr in range(V):\n            for to, cap in E[fr]:\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr])-1))\n        self.maxflow = self.dinic(source, sink)\n\n    def dinic(self, source, sink):\n        \"\"\"find max-flow\"\"\"\n        INF = float('inf')\n        maxflow = 0\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = [0] * self.V\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > 0:\n                    maxflow += flow\n                else:\n                    break\n\n    def dfs(self, vertex, sink, flow):\n        \"\"\"find augmenting path\"\"\"\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if e.cap > 0 and self.level[vertex] < self.level[e.to]:\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n                if d > 0:\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return 0\n\n    def bfs(self, start):\n        \"\"\"find shortest path from start\"\"\"\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if e.cap > 0 and self.level[e.to] < 0:\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\n\nwhile True:\n    M, N = map(int, input().split())\n    if M == 0 and N == 0:\n        break\n    blue, red = [], []\n    while True:\n        for x in input().split():\n            blue.append(int(x))\n        if len(blue) == M:\n            break\n    while True:\n        for x in input().split():\n            red.append(int(x))\n        if len(red) == N:\n            break\n    V = M + N + 2\n    edge = [set() for _ in range(V)]\n    for i, b in enumerate(blue):\n        if b != 1:\n            for j, r in enumerate(red):\n                if r % b == 0:\n                    edge[i].add((M+j, 1))\n        for j in range(2, int(math.sqrt(b)) + 1):\n            if b % j == 0:\n                for k, r in enumerate(red):\n                    if r % j == 0 or r % (b // j) == 0:\n                        edge[i].add((M+k, 1))\n    for i in range(M):\n        edge[M+N].add((i, 1))\n    for j in range(N):\n        edge[M+j].add((M+N+1, 1))\n    d = Dinic(V, edge, M+N, M+N+1)\n    print(d.maxflow)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.buffer.readline\nsys.setrecursionlimit(10 ** 7)\n\n\ndef gcd(x, y):\n    if y == 0:\n        return x\n    return gcd(y, x % y)\n\n\nclass BipartiteMatching:\n    def __init__(self, N, M):\n        self.N = N\n        self.M = M\n        self.pairA = [-1] * N\n        self.pairB = [-1] * M\n        self.edge = [[] for _ in range(N)]\n        self.was = [0] * N\n        self.iter = 0\n\n    def add(self, s, t):\n        self.edge[s].append(t)\n\n    def _DFS(self, s):\n        self.was[s] = self.iter\n        for t in self.edge[s]:\n            if self.pairB[t] == -1:\n                self.pairA[s] = t\n                self.pairB[t] = s\n                return True\n        for t in self.edge[s]:\n            if self.was[self.pairB[t]] != self.iter and self._DFS(self.pairB[t]):\n                self.pairA[s] = t\n                self.pairB[t] = s\n                return True\n        return False\n\n    def solve(self):\n        res = 0\n        while True:\n            self.iter += 1\n            found = 0\n            for i in range(self.N):\n                if self.pairA[i] == -1 and self._DFS(i):\n                    found += 1\n            if not found:\n                break\n            res += found\n        return res\n\n\ndef inp(num):\n    it = (num + 9) // 10\n    res = []\n    for _ in range(it):\n        res.extend(list(map(int, input().split())))\n    return res\n\n\nif __name__ == \"__main__\":\n    ans = []\n    while True:\n        M, N = map(int, input().split())\n        if M == 0 and N == 0:\n            break\n        match = BipartiteMatching(M, N)\n        Blue = inp(M)\n        Red = inp(N)\n        for i, b in enumerate(Blue):\n            for j, r in enumerate(Red):\n                if gcd(b, r) != 1:\n                    match.add(i, j)\n        ans.append(match.solve())\n\n    print(*ans, sep=\"\\n\")\n\n"
  },
  {
    "language": "Python",
    "code": "from fractions import gcd\n\nV = 1003\nG = []\nvisited = []\nmatch = []\n\ndef add_edge(u,v):\n    G[u].append(v)\n    G[v].append(u)\n\ndef dfs(v):\n    visited[v] = True\n    for u in G[v]:\n        w = match[u]\n        if w < 0 or not visited[w] and dfs(w):\n            match[v] = u\n            match[u] = v\n            return True\n\ndef bipartite_matching():\n    global match,visited\n    res = 0\n    match = [-1]*V\n    for v in xrange(V):\n        if match[v] < 0:\n            visited = [False]*V\n            if dfs(v):\n                res += 1\n    return res\n\nwhile True:\n    m,n = map(int,raw_input().split())\n    if (m,n) == (0,0):\n        break\n    V = m+n+2\n    G = [[] for _ in xrange(V)]\n    visited = [True] * V\n    data = []\n    while len(data) < n+m:\n        data += map(int,raw_input().split())\n    blue = data[:m]\n    red = data[m:]\n    for i,b in enumerate(blue):\n        for j,r in enumerate(red,m):\n            if gcd(b,r) != 1:\n                add_edge(i,j)\n    print bipartite_matching()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ninf = 100000000000000000\n\ndef bfs(graph, s, t):\n    V = len(graph)\n    q = deque([(s, -1, -1)])\n    prev = [(-1, -1)] * V\n    visited = [False] * V\n    while len(q) > 0:\n        (v, p, e) = q.popleft()\n        if visited[v]:\n            continue\n        visited[v] = True\n        prev[v] = p, e\n        for i in range(len(graph[v])):\n            e = graph[v][i]\n            if e['cap'] > 0:\n                q.append((e['to'], v, i))\n    if not visited[t]:\n        return None\n    else:\n        return prev\n\ndef decrease_graph(graph, s, t, prev):\n    ((p, e), c) = prev[t], t\n    m = inf\n    while p != -1:\n        m = min(graph[p][e]['cap'], m)\n        ((p, e), c) = prev[p], p\n    ((p, e), c) = prev[t], t\n    while p != -1:\n        graph[p][e]['cap'] -= m\n        graph[c][graph[p][e]['rev']]['cap'] += m\n        ((p, e), c) = prev[p], p\n    return m\n\ndef maximum_flow(graph, s, t):\n    V = len(graph)\n    g = [[] for _ in range(V)]\n    for v in range(V):\n        nei = graph[v]\n        for (u, cap) in nei:\n            g[v].append({'to' : u, 'from': v, 'cap': cap, 'rev': len(g[u])})\n            g[u].append({'to' : v, 'from': u, 'cap':   0, 'rev': len(g[v]) - 1})\n    \n    sum = 0\n    while True:\n        prev = bfs(g, s, t)\n        if prev == None:\n            break\n        sum += decrease_graph(g, s, t, prev)\n    return sum\n\ndef gcd(x, y):\n    while y > 0:\n        x, y = y, x % y\n    return x\n\ndef main():\n    while True:\n        m, n = map(int, input().split())\n        if m == 0 and n == 0:\n            return\n        b = []\n        b += list(map(int, input().split()))\n        r = []\n        r += list(map(int, input().split()))\n        \n        g = [[] for i in range(n + m + 2)]\n        for i in range(m):\n            g[0].append((i + 1, 1))\n        for i in range(n):\n            g[m + i + 1].append((n + m + 1, 1))\n        for i in range(m):\n            for j in range(n):\n                if gcd(b[i], r[j]) > 1:\n                    g[i + 1].append((m + j + 1, 1))\n\n        print(maximum_flow(g, 0, n + m + 1))\n        \nmain()"
  },
  {
    "language": "Python",
    "code": "import collections\nimport fractions\nrange = xrange; input = raw_input\n\n\nclass Dinic:\n    \"\"\"Dinic Algorithm: find max-flow\n       complexity: O(EV^2)\n       used in GRL6A(AOJ)\n    \"\"\"\n    class edge:\n        def __init__(self, to, cap, rev):\n            self.to, self.cap, self.rev = to, cap, rev\n\n    def __init__(self, V, E, source, sink):\n        \"\"\" V: the number of vertexes\n            E: adjacency list\n            source: start point\n            sink: goal point\n        \"\"\"\n        self.V = V\n        self.E = [[] for _ in range(V)]\n        for fr in range(V):\n            for to, cap in E[fr]:\n                self.E[fr].append(self.edge(to, cap, len(self.E[to])))\n                self.E[to].append(self.edge(fr, 0, len(self.E[fr])-1))\n        self.maxflow = self.dinic(source, sink)\n\n    def dinic(self, source, sink):\n        \"\"\"find max-flow\"\"\"\n        INF = float('inf')\n        maxflow = 0\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return maxflow\n            self.itr = [0] * self.V\n            while True:\n                flow = self.dfs(source, sink, INF)\n                if flow > 0:\n                    maxflow += flow\n                else:\n                    break\n\n    def dfs(self, vertex, sink, flow):\n        \"\"\"find augmenting path\"\"\"\n        if vertex == sink:\n            return flow\n        for i in range(self.itr[vertex], len(self.E[vertex])):\n            self.itr[vertex] = i\n            e = self.E[vertex][i]\n            if e.cap > 0 and self.level[vertex] < self.level[e.to]:\n                d = self.dfs(e.to, sink, min(flow, e.cap))\n                if d > 0:\n                    e.cap -= d\n                    self.E[e.to][e.rev].cap += d\n                    return d\n        return 0\n\n    def bfs(self, start):\n        \"\"\"find shortest path from start\"\"\"\n        que = collections.deque()\n        self.level = [-1] * self.V\n        que.append(start)\n        self.level[start] = 0\n\n        while que:\n            fr = que.popleft()\n            for e in self.E[fr]:\n                if e.cap > 0 and self.level[e.to] < 0:\n                    self.level[e.to] = self.level[fr] + 1\n                    que.append(e.to)\n\nwhile True:\n    M, N = map(int, input().split())\n    if M == 0 and N == 0:\n        break\n    blue, red = [], []\n    while True:\n        for x in input().split():\n            blue.append(int(x))\n        if len(blue) == M:\n            break\n    while True:\n        for x in input().split():\n            red.append(int(x))\n        if len(red) == N:\n            break\n    V = M + N + 2\n    edge = [[] for _ in range(V)]\n    for i, b in enumerate(blue):\n        for j, r in enumerate(red):\n            if fractions.gcd(b, r) != 1:\n                edge[i].append((M+j, 1))\n    for i in range(M):\n        edge[M+N].append((i, 1))\n    for j in range(N):\n        edge[M+j].append((M+N+1, 1))\n    print(Dinic(V, edge, M+N, M+N+1).maxflow)"
  },
  {
    "language": "Python",
    "code": "from fractions import gcd\n\nINF = 2 << 30\nV = 1002\nG = [[] for _ in xrange(V)]\nvisited = [False]*V\n\ndef add_edge(fro, to, cap):\n    G[fro].append([to,cap,len(G[to])])\n    G[to].append([fro,0,len(G[fro])-1])\n\ndef dfs(v,t,f):\n    if v == t:\n        return f\n    visited[v] = True\n    for i,(to,cap,rev) in enumerate((G[v])):\n        if visited[to] or cap == 0:\n            continue        \n        d = dfs(to,t,min(f,cap))\n        if d > 0:\n            G[v][i][1] -= d\n            G[to][rev][1] += d\n            return d\n    return 0\n\ndef max_flow(s,t):\n    flow = 0\n    dbg = 0\n    while True:\n        for i in xrange(V):\n            visited[i] = False\n        f = dfs(s,t,INF)\n        if f == 0:\n            return flow\n        flow += f\n        dbg += 1\n        if dbg > 600:\n            return -1\n\nwhile True:\n    m,n = map(int,raw_input().split())\n    if m|n == 0:\n        break\n    V = m+n+2\n    G = [[] for _ in xrange(V)]\n    visited = [True] * V\n    data = []\n    while len(data) < n+m:\n        data += map(int,raw_input().split())\n    blue = data[:m]\n    red = data[m:]\n    for i in xrange(m):\n        add_edge(V-2,i,1)\n    for i in xrange(m,m+n):\n        add_edge(i,V-1,1)\n    for i,b in enumerate(blue):\n        for j,r in enumerate(red,m):\n            if gcd(b,r) != 1:\n                add_edge(i,j,1)\n    print max_flow(V-2,V-1)"
  },
  {
    "language": "Python",
    "code": "\nimport math\nfrom collections import deque\n\nclass MaxFlow:\n    class Edge:\n        def __init__(self,to,cap,rev):\n            self.to = to\n            self.cap = cap\n            self.rev = rev\n\n    def __init__(self,n,inf = 10**9+7):\n        self.n = n\n        self.inf = inf\n        self.level = [-1]*n\n        self.iter = [0]*n\n        self.e = [[] for _ in range(n)]\n\n    def add_edge(self, from_, to, cap):\n        self.e[from_].append(self.Edge(to, cap, len(self.e[to])))\n        self.e[to].append(self.Edge(from_, 0, len(self.e[from_])-1))\n\n    def bfs(self, start):\n        self.level = [-1]*self.n\n        dq = deque()\n        self.level[start] = 0\n        dq.append(start)\n        while dq:\n            cur_vertex = dq.popleft()\n            for edge in self.e[cur_vertex]:\n                if edge.cap > 0 > self.level[edge.to]:\n                    self.level[edge.to] = self.level[cur_vertex] + 1\n                    dq.append(edge.to)\n\n    def dfs(self, cur_vertex, end_vertex, flow):\n        if cur_vertex == end_vertex:return flow\n        while self.iter[cur_vertex] < len(self.e[cur_vertex]):\n            edge = self.e[cur_vertex][self.iter[cur_vertex]]\n            if edge.cap > 0 and self.level[cur_vertex] < self.level[edge.to]:\n                flowed = self.dfs(edge.to, end_vertex, min(flow, edge.cap))\n                if flowed > 0:\n                    edge.cap -= flowed\n                    self.e[edge.to][edge.rev].cap += flowed\n                    return flowed\n            self.iter[cur_vertex] += 1\n        return 0\n\n    def compute(self, source, sink):\n        flow = 0\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:return flow\n            self.iter = [0]*self.n\n            while True:\n                f = self.dfs(source, sink, self.inf)\n                if f == 0:break\n                flow += f\n\ndef main():\n    while True:\n        n,m = map(int,input().split())\n        if n==0:break\n        a = []\n        while True:\n            c = list(map(int,input().split()))\n            a.extend(c)\n            if len(a)>=n:break\n        b = []\n        while True:\n            c = list(map(int,input().split()))\n            b.extend(c)\n            if len(b)>=m:break\n        MF = MaxFlow(n+m+2)\n        s = n+m\n        t = n+m+1\n        for i in range(n):\n            for j in range(m):\n                if math.gcd(a[i],b[j])!=1:\n                    MF.add_edge(i,j+n,1)\n        for i in range(n):\n            MF.add_edge(s,i,1)\n        for i in range(m):\n            MF.add_edge(i+n,t,1)\n        print(MF.compute(s,t))\n\nif __name__ == '__main__':\n    main()\n\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass Flow():\n    def __init__(self, e, N):\n        self.E = e\n        self.N = N\n        self.nl = list(range(N))\n\n    def max_flow(self, s, t):\n        r = 0\n        e = self.E\n        v = None\n\n        def f(c):\n            v[c] = 1\n            if c == t:\n                return 1\n            for i in e[c]:\n                if v[i] is None and f(i):\n                    e[c].remove(i)\n                    e[i].add(c)\n                    return 1\n            return\n\n        while True:\n            v = [None] * self.N\n            if f(s) is None:\n                break\n            r += 1\n\n        return r\n\ndef main():\n    rr = []\n\n    def f(m, n):\n        b = LI()\n        while len(b) < m:\n            b += LI()\n        r = LI()\n        while len(r) < n:\n            r += LI()\n        s = m + n + 2\n        e = collections.defaultdict(set)\n        for i in range(m):\n            e[0].add(i+1)\n        for i in range(n):\n            e[m+i+1].add(s-1)\n\n        for i in range(m):\n            for j in range(n):\n                if fractions.gcd(b[i], r[j]) > 1:\n                    e[i+1].add(m+j+1)\n\n        fl = Flow(e, s)\n\n        return fl.max_flow(0, s-1)\n\n    while True:\n        m, n = LI()\n        if m == 0 and n == 0:\n            break\n        rr.append(f(m,n))\n\n    return '\\n'.join(map(str, rr))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nfrom fractions import gcd\n\nINF = 2 << 30\nMAX_V = 1002\nG = [[] for _ in xrange(MAX_V)]\nvisited = [False]*MAX_V\n\ndef add_edge(fro, to, cap):\n    G[fro].append([to,cap,len(G[to])])\n    G[to].append([fro,0,len(G[fro])-1])\n\ndef dfs(v,t,f):\n    global visited\n    if v == t:\n        return f\n    visited[v] = True\n    for i,(to,cap,rev) in enumerate((G[v])):\n        if visited[to] or cap == 0:            \n            continue        \n        d = dfs(to,t,min(f,cap))\n        if d > 0:\n            G[v][i][1] -= d\n            G[to][rev][1] += d\n            return d\n    return 0\n\ndef max_flow(s,t):\n    global visited\n    flow = 0\n    while True:\n        visited = [False]*MAX_V\n        f = dfs(s,t,INF)\n        if f == 0:\n            return flow\n        flow += f\n\nwhile True:\n    m,n = map(int,raw_input().split())\n    if m|n == 0:\n        break\n    G = [[] for _ in xrange(MAX_V)]\n    data = []\n    while len(data) < n+m:\n        data += map(int,raw_input().split())    \n    blue = data[:m]\n    red = data[m:]\n    for i,b in enumerate(blue):\n        add_edge(MAX_V-2,i,1)\n    for i,r in enumerate(red):\n        add_edge(i+m,MAX_V-1,1)\n    for i in xrange(m):\n        for j in xrange(n):\n            if gcd(blue[i],red[j]) != 1:\n                add_edge(i,j+m,1)\n    print max_flow(MAX_V-2,MAX_V-1)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ninf = 100000000000000000\n\ndef bfs(graph, s, t):\n    V = len(graph)\n    q = deque([(s, -1, -1)])\n    prev = [(-1, -1)] * V\n    visited = [False] * V\n    while len(q) > 0:\n        (v, p, e) = q.popleft()\n        if visited[v]:\n            continue\n        visited[v] = True\n        prev[v] = p, e\n        for i in range(len(graph[v])):\n            e = graph[v][i]\n            if e['cap'] > 0:\n                q.append((e['to'], v, i))\n    if not visited[t]:\n        return None\n    else:\n        return prev\n\ndef decrease_graph(graph, s, t, prev):\n    ((p, e), c) = prev[t], t\n    m = inf\n    while p != -1:\n        m = min(graph[p][e]['cap'], m)\n        ((p, e), c) = prev[p], p\n    ((p, e), c) = prev[t], t\n    while p != -1:\n        graph[p][e]['cap'] -= m\n        graph[c][graph[p][e]['rev']]['cap'] += m\n        ((p, e), c) = prev[p], p\n    return m\n\ndef maximum_flow(graph, s, t):\n    V = len(graph)\nh    g = [[] for _ in range(V)]\n    for v in range(V):\n        nei = graph[v]\n        for (u, cap) in nei:\n            g[v].append({'to' : u, 'from': v, 'cap': cap, 'rev': len(g[u])})\n            g[u].append({'to' : v, 'from': u, 'cap':   0, 'rev': len(g[v]) - 1})\n    \n    sum = 0\n    while True:\n        prev = bfs(g, s, t)\n        if prev == None:\n            break\n        sum += decrease_graph(g, s, t, prev)\n    return sum\n\ndef gcd(x, y):\n    while y > 0:\n        x, y = y, x % y\n    return x\n\ndef main():\n    while True:\n        m, n = map(int, input().split())\n        if m == 0 and n == 0:\n            return\n        b = []\n        while len(b) < m:\n            b += list(map(int, input().split()))\n        r = []\n        while len(r) < n:\n            r += list(map(int, input().split()))\n        \n        g = [[] for i in range(n + m + 2)]\n        for i in range(m):\n            g[0].append((i + 1, 1))\n        for i in range(n):\n            g[m + i + 1].append((n + m + 1, 1))\n        for i in range(m):\n            for j in range(n):\n                if gcd(b[i], r[j]) > 1:\n                    g[i + 1].append((m + j + 1, 1))\n\n        print(maximum_flow(g, 0, n + m + 1))\n        \nmain()"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::stdin;\n\nmod util {\n    use std::io::stdin;\n    use std::str::FromStr;\n    use std::fmt::Debug;\n\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! get {\n    ($t:ty) => {\n        {\n            let mut line: String = String::new();\n            stdin().read_line(&mut line).unwrap();\n            line.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($($t:ty),*) => {\n        {\n            let mut line: String = String::new();\n            stdin().read_line(&mut line).unwrap();\n            let mut iter = line.split_whitespace();\n            (\n                $(iter.next().unwrap().parse::<$t>().unwrap(),)*\n            )\n        }\n    };\n    ($t:ty; $n:expr) => {\n        (0..$n).map(|_|\n                    get!($t)\n                   ).collect::<Vec<_>>()\n    };\n    ($($t:ty),*; $n:expr) => {\n        (0..$n).map(|_|\n                    get!($($t),*)\n                   ).collect::<Vec<_>>()\n    };\n    ($t:ty ;;) => {\n        {\n            let mut line: String = String::new();\n            stdin().read_line(&mut line).unwrap();\n            line.split_whitespace()\n                .map(|t| t.parse::<$t>().unwrap())\n                .collect::<Vec<_>>()\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nstruct Flow {\n    // to, capacity, rev\n    edges: Vec<Vec<(usize, usize, usize)>>,\n}\n\nimpl Flow {\n    fn new(max_size: usize) -> Flow {\n        Flow {\n            edges: vec![Vec::new(); max_size + 1],\n        }\n    }\n\n    fn add_edge(&mut self, from: usize, to: usize, cap: usize) {\n        let from_rev = self.edges[to].len();\n        let to_rev = self.edges[from].len();\n\n        self.edges[from].push((to, cap, from_rev));\n        self.edges[to].push((from, 0, to_rev));\n    }\n\n    fn max_flow_dinic(&mut self, s: usize, t: usize) -> usize {\n        let mut flow = 0;\n        loop {\n            let level = self.bfs_dinic(s);\n            let mut iter = vec![0; self.edges.len()];\n            if level[t].is_none() {\n                return flow;\n            }\n\n            loop {\n                let f = self.dfs_dinic(s, t, usize::max_value(), &level, &mut iter);\n                if f == 0 {\n                    break;\n                }\n                flow += f;\n            }\n        }\n    }\n\n    fn bfs_dinic(&self, s: usize) -> Vec<Option<usize>> {\n        let mut level = vec![None; self.edges.len()];\n        let mut que = VecDeque::new();\n\n        level[s] = Some(0);\n        que.push_back(s);\n\n        while !que.is_empty() {\n            let v = que.pop_front().unwrap();\n            let l = Some(level[v].unwrap() + 1);\n\n            for &(to, cap, _) in &self.edges[v] {\n                if cap > 0 && level[to].is_none() {\n                    level[to] = l;\n                    que.push_back(to);\n                }\n            }\n        }\n        level\n    }\n\n    fn dfs_dinic(\n        &mut self,\n        v: usize,\n        t: usize,\n        f: usize,\n        level: &[Option<usize>],\n        iter: &mut [usize],\n    ) -> usize {\n        if v == t {\n            return f;\n        }\n\n        for i in iter[v]..self.edges[v].len() {\n            iter[v] = i;\n\n            let (to, cap, rev) = self.edges[v][i];\n            if cap > 0 && level[v].unwrap() < level[to].unwrap_or(0) {\n                let d = self.dfs_dinic(to, t, min(f, cap), level, iter);\n                if d > 0 {\n                    self.edges[v][i].1 -= d;\n                    self.edges[to][rev].1 += d;\n                    return d;\n                }\n            }\n        }\n        0\n    }\n\n    #[allow(dead_code)]\n    fn max_flow_ff(&mut self, s: usize, t: usize) -> usize {\n        let mut flow = 0;\n        let l = self.edges.len();\n        loop {\n            let f = self.dfs_ff(s, t, usize::max_value(), &mut vec![false; l]);\n            if f == 0 {\n                break;\n            }\n            flow += f;\n        }\n        flow\n    }\n\n    #[allow(dead_code)]\n    fn dfs_ff(&mut self, v: usize, t: usize, f: usize, used: &mut [bool]) -> usize {\n        if v == t {\n            return f;\n        }\n        used[v] = true;\n\n        for i in 0..self.edges[v].len() {\n            let (to, cap, rev) = self.edges[v][i];\n            if !used[to] && cap > 0 {\n                let d = self.dfs_ff(to, t, min(f, cap), used);\n                if d > 0 {\n                    self.edges[v][i].1 -= d;\n                    self.edges[to][rev].1 += d;\n                    return d;\n                }\n            }\n        }\n        0\n    }\n\n    #[allow(dead_code)]\n    fn cut(&self, s: usize) -> BTreeSet<usize> {\n        let mut stack = Vec::new();\n        let mut ss = BTreeSet::new();\n        ss.insert(s);\n        stack.push(s);\n\n        while !stack.is_empty() {\n            let v = stack.pop().unwrap();\n            for &(to, cap, _) in &self.edges[v] {\n                if cap > 0 && !ss.contains(&to) {\n                    ss.insert(to);\n                    stack.push(to);\n                }\n            }\n        }\n\n        ss\n    }\n}\n\nfn gcd(a: u64, b: u64) -> u64 {\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\n#[allow(dead_code)]\nfn lcm(a: u64, b: u64) -> u64 {\n    a / gcd(a, b) * b\n}\n\n// (gcd, x, y)\n#[allow(dead_code)]\nfn extgcd(a: i64, b: i64) -> (i64, i64, i64) {\n    if b == 0 {\n        (a, 1, 0)\n    } else {\n        let (gcd, x, y) = extgcd(b, a % b);\n        (gcd, y, x - (a / b) * y)\n    }\n}\n\n#[allow(dead_code)]\nfn mod_pow(x: u64, n: u64, m: u64) -> u64 {\n    let mut res = 1;\n    let mut x = x;\n    let mut n = n;\n    while n > 0 {\n        if n & 1 == 1 {\n            res = (res * x) % m;\n        }\n        x = (x * x) % m;\n        n = n >> 1;\n    }\n    res\n}\n\n#[allow(dead_code)]\nfn mod_inverse(a: u64, m: u64) -> u64 {\n    let (_, x, _) = extgcd(a as i64, m as i64);\n    ((m as i64 + x) as u64 % m) % m\n}\n\n#[allow(dead_code)]\nfn fact_table(len: usize, m: u64) -> Vec<u64> {\n    let mut res = vec![1; len];\n    for i in 1..len {\n        res[i] = (i as u64 * res[i - 1]) % m;\n    }\n    res\n}\n\n// (a mod p, e when n! = a p^e)\nfn mod_fact(n: u64, p: u64, fact: &Vec<u64>) -> (u64, u64) {\n    if n == 0 {\n        (1, 0)\n    } else {\n        let (a, b) = mod_fact(n / p, p, fact);\n        let e = b + n / p;\n\n        if n / p % 2 != 0 {\n            (a * (p - fact[(n % p) as usize]) % p, e)\n        } else {\n            (a * fact[(n % p) as usize] % p, e)\n        }\n    }\n}\n\nfn mod_comb(n: u64, k: u64, p: u64, fact: &Vec<u64>) -> u64 {\n    if n < k {\n        0\n    } else {\n        let (a1, e1) = mod_fact(n, p, fact);\n        let (a2, e2) = mod_fact(k, p, fact);\n        let (a3, e3) = mod_fact(n - k, p, fact);\n\n        if e1 > e2 + e3 {\n            0\n        } else {\n            a1 * mod_inverse(a2 * a3 % p, p) % p\n        }\n    }\n}\n\nfn main() {\n    loop {\n        let (m, n) = get!(usize, usize);\n        if m == 0 && n == 0 {\n            break;\n        }\n\n        let b = {\n            // suck\n            let mut v = Vec::new();\n            let mut rest = m;\n            while rest > 0 {\n                let mut input = util::gets::<u64>();\n                rest -= input.len();\n                v.append(&mut input);\n            }\n            v\n        };\n\n        let r = {\n            // suck\n            let mut v = Vec::new();\n            let mut rest = n;\n            while rest > 0 {\n                let mut input = util::gets::<u64>();\n                rest -= input.len();\n                v.append(&mut input);\n            }\n            v\n        };\n\n        let s = m + n + 1;\n        let t = s + 1;\n\n        let mut flow = Flow::new(t);\n\n        for i in 0..m {\n            flow.add_edge(s, i, 1);\n        }\n\n        for i in 0..n {\n            flow.add_edge(m + i, t, 1);\n        }\n\n        for (i, &x) in b.iter().enumerate() {\n            for (k, &y) in r.iter().enumerate() {\n                if gcd(x, y) != 1 {\n                    flow.add_edge(i, m + k, 1);\n                }\n            }\n        }\n\n        println!(\"{}\", flow.max_flow_dinic(s, t));\n    }\n}"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::stdin;\n\nmod util {\n    use std::io::stdin;\n    use std::str::FromStr;\n    use std::fmt::Debug;\n\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! get {\n    ($t:ty) => {\n        {\n            let mut line: String = String::new();\n            stdin().read_line(&mut line).unwrap();\n            line.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($($t:ty),*) => {\n        {\n            let mut line: String = String::new();\n            stdin().read_line(&mut line).unwrap();\n            let mut iter = line.split_whitespace();\n            (\n                $(iter.next().unwrap().parse::<$t>().unwrap(),)*\n            )\n        }\n    };\n    ($t:ty; $n:expr) => {\n        (0..$n).map(|_|\n                    get!($t)\n                   ).collect::<Vec<_>>()\n    };\n    ($($t:ty),*; $n:expr) => {\n        (0..$n).map(|_|\n                    get!($($t),*)\n                   ).collect::<Vec<_>>()\n    };\n    ($t:ty ;;) => {\n        {\n            let mut line: String = String::new();\n            stdin().read_line(&mut line).unwrap();\n            line.split_whitespace()\n                .map(|t| t.parse::<$t>().unwrap())\n                .collect::<Vec<_>>()\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nstruct Flow {\n    // to, capacity, rev\n    edges: Vec<Vec<(usize, usize, usize)>>,\n}\n\nimpl Flow {\n    fn new(max_size: usize) -> Flow {\n        Flow {\n            edges: vec![Vec::new(); max_size + 1],\n        }\n    }\n\n    fn add_edge(&mut self, from: usize, to: usize, cap: usize) {\n        let from_rev = self.edges[to].len();\n        let to_rev = self.edges[from].len();\n\n        self.edges[from].push((to, cap, from_rev));\n        self.edges[to].push((from, 0, to_rev));\n    }\n\n    fn max_flow_dinic(&mut self, s: usize, t: usize) -> usize {\n        let mut flow = 0;\n        loop {\n            let level = self.bfs_dinic(s);\n            let mut iter = vec![0; self.edges.len()];\n            if level[t].is_none() {\n                return flow;\n            }\n\n            loop {\n                let f = self.dfs_dinic(s, t, usize::max_value(), &level, &mut iter);\n                if f == 0 {\n                    break;\n                }\n                flow += f;\n            }\n        }\n    }\n\n    fn bfs_dinic(&self, s: usize) -> Vec<Option<usize>> {\n        let mut level = vec![None; self.edges.len()];\n        let mut que = VecDeque::new();\n\n        level[s] = Some(0);\n        que.push_back(s);\n\n        while !que.is_empty() {\n            let v = que.pop_front().unwrap();\n            let l = Some(level[v].unwrap() + 1);\n\n            for &(to, cap, _) in &self.edges[v] {\n                if cap > 0 && level[to].is_none() {\n                    level[to] = l;\n                    que.push_back(to);\n                }\n            }\n        }\n        level\n    }\n\n    fn dfs_dinic(\n        &mut self,\n        v: usize,\n        t: usize,\n        f: usize,\n        level: &[Option<usize>],\n        iter: &mut [usize],\n    ) -> usize {\n        if v == t {\n            return f;\n        }\n\n        for i in iter[v]..self.edges[v].len() {\n            iter[v] = i;\n\n            let (to, cap, rev) = self.edges[v][i];\n            if cap > 0 && level[v].unwrap() < level[to].unwrap_or(0) {\n                let d = self.dfs_dinic(to, t, min(f, cap), level, iter);\n                if d > 0 {\n                    self.edges[v][i].1 -= d;\n                    self.edges[to][rev].1 += d;\n                    return d;\n                }\n            }\n        }\n        0\n    }\n\n    #[allow(dead_code)]\n    fn max_flow_ff(&mut self, s: usize, t: usize) -> usize {\n        let mut flow = 0;\n        let l = self.edges.len();\n        loop {\n            let f = self.dfs_ff(s, t, usize::max_value(), &mut vec![false; l]);\n            if f == 0 {\n                break;\n            }\n            flow += f;\n        }\n        flow\n    }\n\n    #[allow(dead_code)]\n    fn dfs_ff(&mut self, v: usize, t: usize, f: usize, used: &mut [bool]) -> usize {\n        if v == t {\n            return f;\n        }\n        used[v] = true;\n\n        for i in 0..self.edges[v].len() {\n            let (to, cap, rev) = self.edges[v][i];\n            if !used[to] && cap > 0 {\n                let d = self.dfs_ff(to, t, min(f, cap), used);\n                if d > 0 {\n                    self.edges[v][i].1 -= d;\n                    self.edges[to][rev].1 += d;\n                    return d;\n                }\n            }\n        }\n        0\n    }\n\n    #[allow(dead_code)]\n    fn cut(&self, s: usize) -> BTreeSet<usize> {\n        let mut stack = Vec::new();\n        let mut ss = BTreeSet::new();\n        ss.insert(s);\n        stack.push(s);\n\n        while !stack.is_empty() {\n            let v = stack.pop().unwrap();\n            for &(to, cap, _) in &self.edges[v] {\n                if cap > 0 && !ss.contains(&to) {\n                    ss.insert(to);\n                    stack.push(to);\n                }\n            }\n        }\n\n        ss\n    }\n}\n\nfn gcd(a: u64, b: u64) -> u64 {\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\n#[allow(dead_code)]\nfn lcm(a: u64, b: u64) -> u64 {\n    a / gcd(a, b) * b\n}\n\n// (gcd, x, y)\n#[allow(dead_code)]\nfn extgcd(a: i64, b: i64) -> (i64, i64, i64) {\n    if b == 0 {\n        (a, 1, 0)\n    } else {\n        let (gcd, x, y) = extgcd(b, a % b);\n        (gcd, y, x - (a / b) * y)\n    }\n}\n\n#[allow(dead_code)]\nfn mod_pow(x: u64, n: u64, m: u64) -> u64 {\n    let mut res = 1;\n    let mut x = x;\n    let mut n = n;\n    while n > 0 {\n        if n & 1 == 1 {\n            res = (res * x) % m;\n        }\n        x = (x * x) % m;\n        n = n >> 1;\n    }\n    res\n}\n\n#[allow(dead_code)]\nfn mod_inverse(a: u64, m: u64) -> u64 {\n    let (_, x, _) = extgcd(a as i64, m as i64);\n    ((m as i64 + x) as u64 % m) % m\n}\n\n#[allow(dead_code)]\nfn fact_table(len: usize, m: u64) -> Vec<u64> {\n    let mut res = vec![1; len];\n    for i in 1..len {\n        res[i] = (i as u64 * res[i - 1]) % m;\n    }\n    res\n}\n\n// (a mod p, e when n! = a p^e)\nfn mod_fact(n: u64, p: u64, fact: &Vec<u64>) -> (u64, u64) {\n    if n == 0 {\n        (1, 0)\n    } else {\n        let (a, b) = mod_fact(n / p, p, fact);\n        let e = b + n / p;\n\n        if n / p % 2 != 0 {\n            (a * (p - fact[(n % p) as usize]) % p, e)\n        } else {\n            (a * fact[(n % p) as usize] % p, e)\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn mod_comb(n: u64, k: u64, p: u64, fact: &Vec<u64>) -> u64 {\n    if n < k {\n        0\n    } else {\n        let (a1, e1) = mod_fact(n, p, fact);\n        let (a2, e2) = mod_fact(k, p, fact);\n        let (a3, e3) = mod_fact(n - k, p, fact);\n\n        if e1 > e2 + e3 {\n            0\n        } else {\n            a1 * mod_inverse(a2 * a3 % p, p) % p\n        }\n    }\n}\n\nfn main() {\n    loop {\n        let (m, n) = get!(usize, usize);\n        if m == 0 && n == 0 {\n            break;\n        }\n\n        let b = {\n            // suck\n            let mut v = Vec::new();\n            let mut rest = m;\n            while rest > 0 {\n                let mut input = util::gets::<u64>();\n                rest -= input.len();\n                v.append(&mut input);\n            }\n            v\n        };\n\n        let r = {\n            // suck\n            let mut v = Vec::new();\n            let mut rest = n;\n            while rest > 0 {\n                let mut input = util::gets::<u64>();\n                rest -= input.len();\n                v.append(&mut input);\n            }\n            v\n        };\n\n        let s = m + n + 1;\n        let t = s + 1;\n\n        let mut flow = Flow::new(t);\n\n        for i in 0..m {\n            flow.add_edge(s, i, 1);\n        }\n\n        for i in 0..n {\n            flow.add_edge(m + i, t, 1);\n        }\n\n        for (i, &x) in b.iter().enumerate() {\n            for (k, &y) in r.iter().enumerate() {\n                if gcd(x, y) != 1 {\n                    flow.add_edge(i, m + k, 1);\n                }\n            }\n        }\n\n        println!(\"{}\", flow.max_flow_dinic(s, t));\n    }\n}"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::stdin;\n\nmod util {\n    use std::io::stdin;\n    use std::str::FromStr;\n    use std::fmt::Debug;\n\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! get {\n    ($t:ty) => {\n        {\n            let mut line: String = String::new();\n            stdin().read_line(&mut line).unwrap();\n            line.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($($t:ty),*) => {\n        {\n            let mut line: String = String::new();\n            stdin().read_line(&mut line).unwrap();\n            let mut iter = line.split_whitespace();\n            (\n                $(iter.next().unwrap().parse::<$t>().unwrap(),)*\n            )\n        }\n    };\n    ($t:ty; $n:expr) => {\n        (0..$n).map(|_|\n                    get!($t)\n                   ).collect::<Vec<_>>()\n    };\n    ($($t:ty),*; $n:expr) => {\n        (0..$n).map(|_|\n                    get!($($t),*)\n                   ).collect::<Vec<_>>()\n    };\n    ($t:ty ;;) => {\n        {\n            let mut line: String = String::new();\n            stdin().read_line(&mut line).unwrap();\n            line.split_whitespace()\n                .map(|t| t.parse::<$t>().unwrap())\n                .collect::<Vec<_>>()\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nstruct Flow {\n    // to, capacity, rev\n    edges: Vec<Vec<(usize, usize, usize)>>,\n}\n\nimpl Flow {\n    fn new(max_size: usize) -> Flow {\n        Flow {\n            edges: vec![Vec::new(); max_size + 1],\n        }\n    }\n\n    fn add_edge(&mut self, from: usize, to: usize, cap: usize) {\n        let from_rev = self.edges[to].len();\n        let to_rev = self.edges[from].len();\n\n        self.edges[from].push((to, cap, from_rev));\n        self.edges[to].push((from, 0, to_rev));\n    }\n\n    fn max_flow_dinic(&mut self, s: usize, t: usize) -> usize {\n        let mut flow = 0;\n        loop {\n            let level = self.bfs_dinic(s);\n            let mut iter = vec![0; self.edges.len()];\n            if level[t].is_none() {\n                return flow;\n            }\n\n            loop {\n                let f = self.dfs_dinic(s, t, usize::max_value(), &level, &mut iter);\n                if f == 0 {\n                    break;\n                }\n                flow += f;\n            }\n        }\n    }\n\n    fn bfs_dinic(&self, s: usize) -> Vec<Option<usize>> {\n        let mut level = vec![None; self.edges.len()];\n        let mut que = VecDeque::new();\n\n        level[s] = Some(0);\n        que.push_back(s);\n\n        while !que.is_empty() {\n            let v = que.pop_front().unwrap();\n            let l = Some(level[v].unwrap() + 1);\n\n            for &(to, cap, _) in &self.edges[v] {\n                if cap > 0 && level[to].is_none() {\n                    level[to] = l;\n                    que.push_back(to);\n                }\n            }\n        }\n        level\n    }\n\n    fn dfs_dinic(\n        &mut self,\n        v: usize,\n        t: usize,\n        f: usize,\n        level: &[Option<usize>],\n        iter: &mut [usize],\n    ) -> usize {\n        if v == t {\n            return f;\n        }\n\n        for i in iter[v]..self.edges[v].len() {\n            iter[v] = i;\n\n            let (to, cap, rev) = self.edges[v][i];\n            if cap > 0 && level[v].unwrap() < level[to].unwrap_or(0) {\n                let d = self.dfs_dinic(to, t, min(f, cap), level, iter);\n                if d > 0 {\n                    self.edges[v][i].1 -= d;\n                    self.edges[to][rev].1 += d;\n                    return d;\n                }\n            }\n        }\n        0\n    }\n\n    fn max_flow_ff(&mut self, s: usize, t: usize) -> usize {\n        let mut flow = 0;\n        let l = self.edges.len();\n        loop {\n            let f = self.dfs_ff(s, t, usize::max_value(), &mut vec![false; l]);\n            if f == 0 {\n                break;\n            }\n            flow += f;\n        }\n        flow\n    }\n\n    fn dfs_ff(&mut self, v: usize, t: usize, f: usize, used: &mut [bool]) -> usize {\n        if v == t {\n            return f;\n        }\n        used[v] = true;\n\n        for i in 0..self.edges[v].len() {\n            let (to, cap, rev) = self.edges[v][i];\n            if !used[to] && cap > 0 {\n                let d = self.dfs_ff(to, t, min(f, cap), used);\n                if d > 0 {\n                    self.edges[v][i].1 -= d;\n                    self.edges[to][rev].1 += d;\n                    return d;\n                }\n            }\n        }\n        0\n    }\n\n    fn cut(&self, s: usize) -> BTreeSet<usize> {\n        let mut stack = Vec::new();\n        let mut ss = BTreeSet::new();\n        ss.insert(s);\n        stack.push(s);\n\n        while !stack.is_empty() {\n            let v = stack.pop().unwrap();\n            for &(to, cap, _) in &self.edges[v] {\n                if cap > 0 && !ss.contains(&to) {\n                    ss.insert(to);\n                    stack.push(to);\n                }\n            }\n        }\n\n        ss\n    }\n}\n\nfn gcd(a: u64, b: u64) -> u64 {\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nfn lcm(a: u64, b: u64) -> u64 {\n    a / gcd(a, b) * b\n}\n\n// (gcd, x, y)\nfn extgcd(a: i64, b: i64) -> (i64, i64, i64) {\n    if b == 0 {\n        (a, 1, 0)\n    } else {\n        let (gcd, x, y) = extgcd(b, a % b);\n        (gcd, y, x - (a / b) * y)\n    }\n}\n\nfn mod_pow(x: u64, n: u64, m: u64) -> u64 {\n    let mut res = 1;\n    let mut x = x;\n    let mut n = n;\n    while n > 0 {\n        if n & 1 == 1 {\n            res = (res * x) % m;\n        }\n        x = (x * x) % m;\n        n = n >> 1;\n    }\n    res\n}\n\nfn mod_inverse(a: u64, m: u64) -> u64 {\n    let (_, x, _) = extgcd(a as i64, m as i64);\n    ((m as i64 + x) as u64 % m) % m\n}\n\nfn fact_table(len: usize, m: u64) -> Vec<u64> {\n    let mut res = vec![1; len];\n    for i in 1..len {\n        res[i] = (i as u64 * res[i - 1]) % m;\n    }\n    res\n}\n\n// (a mod p, e when n! = a p^e)\nfn mod_fact(n: u64, p: u64, fact: &Vec<u64>) -> (u64, u64) {\n    if n == 0 {\n        (1, 0)\n    } else {\n        let (a, b) = mod_fact(n / p, p, fact);\n        let e = b + n / p;\n\n        if n / p % 2 != 0 {\n            (a * (p - fact[(n % p) as usize]) % p, e)\n        } else {\n            (a * fact[(n % p) as usize] % p, e)\n        }\n    }\n}\n\nfn mod_comb(n: u64, k: u64, p: u64, fact: &Vec<u64>) -> u64 {\n    if n < k {\n        0\n    } else {\n        let (a1, e1) = mod_fact(n, p, fact);\n        let (a2, e2) = mod_fact(k, p, fact);\n        let (a3, e3) = mod_fact(n - k, p, fact);\n\n        if e1 > e2 + e3 {\n            0\n        } else {\n            a1 * mod_inverse(a2 * a3 % p, p) % p\n        }\n    }\n}\n\nfn main() {\n    loop {\n        let (m, n) = get!(usize, usize);\n        if m == 0 && n == 0 {\n            break;\n        }\n\n        let b = {\n            // suck\n            let mut v = Vec::new();\n            let mut rest = m;\n            while rest > 0 {\n                let mut input = util::gets::<u64>();\n                rest -= input.len();\n                v.append(&mut input);\n            }\n            v\n        };\n\n        let r = {\n            // suck\n            let mut v = Vec::new();\n            let mut rest = n;\n            while rest > 0 {\n                let mut input = util::gets::<u64>();\n                rest -= input.len();\n                v.append(&mut input);\n            }\n            v\n        };\n\n        let s = m + n + 1;\n        let t = s + 1;\n\n        let mut flow = Flow::new(t);\n\n        for i in 0..m {\n            flow.add_edge(s, i, 1);\n        }\n\n        for i in 0..n {\n            flow.add_edge(m + i, t, 1);\n        }\n\n        for (i, &x) in b.iter().enumerate() {\n            for (k, &y) in r.iter().enumerate() {\n                if gcd(x, y) != 1 {\n                    flow.add_edge(i, m + k, 1);\n                }\n            }\n        }\n\n        println!(\"{}\", flow.max_flow_dinic(s, t));\n    }\n}"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::stdin;\n\nmod util {\n    use std::io::stdin;\n    use std::str::FromStr;\n    use std::fmt::Debug;\n\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! get {\n    ($t:ty) => {\n        {\n            let mut line: String = String::new();\n            stdin().read_line(&mut line).unwrap();\n            line.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($($t:ty),*) => {\n        {\n            let mut line: String = String::new();\n            stdin().read_line(&mut line).unwrap();\n            let mut iter = line.split_whitespace();\n            (\n                $(iter.next().unwrap().parse::<$t>().unwrap(),)*\n            )\n        }\n    };\n    ($t:ty; $n:expr) => {\n        (0..$n).map(|_|\n                    get!($t)\n                   ).collect::<Vec<_>>()\n    };\n    ($($t:ty),*; $n:expr) => {\n        (0..$n).map(|_|\n                    get!($($t),*)\n                   ).collect::<Vec<_>>()\n    };\n    ($t:ty ;;) => {\n        {\n            let mut line: String = String::new();\n            stdin().read_line(&mut line).unwrap();\n            line.split_whitespace()\n                .map(|t| t.parse::<$t>().unwrap())\n                .collect::<Vec<_>>()\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nstruct Flow {\n    // to, capacity, rev\n    edges: Vec<Vec<(usize, usize, usize)>>,\n}\n\nimpl Flow {\n    fn new(max_size: usize) -> Flow {\n        Flow {\n            edges: vec![Vec::new(); max_size + 1],\n        }\n    }\n\n    fn add_edge(&mut self, from: usize, to: usize, cap: usize) {\n        let from_rev = self.edges[to].len();\n        let to_rev = self.edges[from].len();\n\n        self.edges[from].push((to, cap, from_rev));\n        self.edges[to].push((from, 0, to_rev));\n    }\n\n    fn max_flow_dinic(&mut self, s: usize, t: usize) -> usize {\n        let mut flow = 0;\n        loop {\n            let level = self.bfs_dinic(s);\n            let mut iter = vec![0; self.edges.len()];\n            if level[t].is_none() {\n                return flow;\n            }\n\n            loop {\n                let f = self.dfs_dinic(s, t, usize::max_value(), &level, &mut iter);\n                if f == 0 {\n                    break;\n                }\n                flow += f;\n            }\n        }\n    }\n\n    fn bfs_dinic(&self, s: usize) -> Vec<Option<usize>> {\n        let mut level = vec![None; self.edges.len()];\n        let mut que = VecDeque::new();\n\n        level[s] = Some(0);\n        que.push_back(s);\n\n        while !que.is_empty() {\n            let v = que.pop_front().unwrap();\n            let l = Some(level[v].unwrap() + 1);\n\n            for &(to, cap, _) in &self.edges[v] {\n                if cap > 0 && level[to].is_none() {\n                    level[to] = l;\n                    que.push_back(to);\n                }\n            }\n        }\n        level\n    }\n\n    fn dfs_dinic(\n        &mut self,\n        v: usize,\n        t: usize,\n        f: usize,\n        level: &[Option<usize>],\n        iter: &mut [usize],\n    ) -> usize {\n        if v == t {\n            return f;\n        }\n\n        for i in iter[v]..self.edges[v].len() {\n            iter[v] = i;\n\n            let (to, cap, rev) = self.edges[v][i];\n            if cap > 0 && level[v].unwrap() < level[to].unwrap_or(0) {\n                let d = self.dfs_dinic(to, t, min(f, cap), level, iter);\n                if d > 0 {\n                    self.edges[v][i].1 -= d;\n                    self.edges[to][rev].1 += d;\n                    return d;\n                }\n            }\n        }\n        0\n    }\n\n    #[allow(dead_code)]\n    fn max_flow_ff(&mut self, s: usize, t: usize) -> usize {\n        let mut flow = 0;\n        let l = self.edges.len();\n        loop {\n            let f = self.dfs_ff(s, t, usize::max_value(), &mut vec![false; l]);\n            if f == 0 {\n                break;\n            }\n            flow += f;\n        }\n        flow\n    }\n\n    #[allow(dead_code)]\n    fn dfs_ff(&mut self, v: usize, t: usize, f: usize, used: &mut [bool]) -> usize {\n        if v == t {\n            return f;\n        }\n        used[v] = true;\n\n        for i in 0..self.edges[v].len() {\n            let (to, cap, rev) = self.edges[v][i];\n            if !used[to] && cap > 0 {\n                let d = self.dfs_ff(to, t, min(f, cap), used);\n                if d > 0 {\n                    self.edges[v][i].1 -= d;\n                    self.edges[to][rev].1 += d;\n                    return d;\n                }\n            }\n        }\n        0\n    }\n\n    #[allow(dead_code)]\n    fn cut(&self, s: usize) -> BTreeSet<usize> {\n        let mut stack = Vec::new();\n        let mut ss = BTreeSet::new();\n        ss.insert(s);\n        stack.push(s);\n\n        while !stack.is_empty() {\n            let v = stack.pop().unwrap();\n            for &(to, cap, _) in &self.edges[v] {\n                if cap > 0 && !ss.contains(&to) {\n                    ss.insert(to);\n                    stack.push(to);\n                }\n            }\n        }\n\n        ss\n    }\n}\n\nfn gcd(a: u64, b: u64) -> u64 {\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\n#[allow(dead_code)]\nfn lcm(a: u64, b: u64) -> u64 {\n    a / gcd(a, b) * b\n}\n\n// (gcd, x, y)\n#[allow(dead_code)]\nfn extgcd(a: i64, b: i64) -> (i64, i64, i64) {\n    if b == 0 {\n        (a, 1, 0)\n    } else {\n        let (gcd, x, y) = extgcd(b, a % b);\n        (gcd, y, x - (a / b) * y)\n    }\n}\n\n#[allow(dead_code)]\nfn mod_pow(x: u64, n: u64, m: u64) -> u64 {\n    let mut res = 1;\n    let mut x = x;\n    let mut n = n;\n    while n > 0 {\n        if n & 1 == 1 {\n            res = (res * x) % m;\n        }\n        x = (x * x) % m;\n        n = n >> 1;\n    }\n    res\n}\n\n#[allow(dead_code)]\nfn mod_inverse(a: u64, m: u64) -> u64 {\n    let (_, x, _) = extgcd(a as i64, m as i64);\n    ((m as i64 + x) as u64 % m) % m\n}\n\n#[allow(dead_code)]\nfn fact_table(len: usize, m: u64) -> Vec<u64> {\n    let mut res = vec![1; len];\n    for i in 1..len {\n        res[i] = (i as u64 * res[i - 1]) % m;\n    }\n    res\n}\n\n// (a mod p, e when n! = a p^e)\nfn mod_fact(n: u64, p: u64, fact: &Vec<u64>) -> (u64, u64) {\n    if n == 0 {\n        (1, 0)\n    } else {\n        let (a, b) = mod_fact(n / p, p, fact);\n        let e = b + n / p;\n\n        if n / p % 2 != 0 {\n            (a * (p - fact[(n % p) as usize]) % p, e)\n        } else {\n            (a * fact[(n % p) as usize] % p, e)\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn mod_comb(n: u64, k: u64, p: u64, fact: &Vec<u64>) -> u64 {\n    if n < k {\n        0\n    } else {\n        let (a1, e1) = mod_fact(n, p, fact);\n        let (a2, e2) = mod_fact(k, p, fact);\n        let (a3, e3) = mod_fact(n - k, p, fact);\n\n        if e1 > e2 + e3 {\n            0\n        } else {\n            a1 * mod_inverse(a2 * a3 % p, p) % p\n        }\n    }\n}\n\nfn main() {\n    loop {\n        let (m, n) = get!(usize, usize);\n        if m == 0 && n == 0 {\n            break;\n        }\n\n        let b = {\n            // suck\n            let mut v = Vec::new();\n            let mut rest = m;\n            while rest > 0 {\n                let mut input = util::gets::<u64>();\n                rest -= input.len();\n                v.append(&mut input);\n            }\n            v\n        };\n\n        let r = {\n            // suck\n            let mut v = Vec::new();\n            let mut rest = n;\n            while rest > 0 {\n                let mut input = util::gets::<u64>();\n                rest -= input.len();\n                v.append(&mut input);\n            }\n            v\n        };\n\n        let s = m + n + 1;\n        let t = s + 1;\n\n        let mut flow = Flow::new(t);\n\n        for i in 0..m {\n            flow.add_edge(s, i, 1);\n        }\n\n        for i in 0..n {\n            flow.add_edge(m + i, t, 1);\n        }\n\n        for (i, &x) in b.iter().enumerate() {\n            for (k, &y) in r.iter().enumerate() {\n                if gcd(x, y) != 1 {\n                    flow.add_edge(i, m + k, 1);\n                }\n            }\n        }\n\n        println!(\"{}\", flow.max_flow_dinic(s, t));\n    }\n}"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::stdin;\n\nmod util {\n    use std::io::stdin;\n    use std::str::FromStr;\n    use std::fmt::Debug;\n\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! get {\n    ($t:ty) => {\n        {\n            let mut line: String = String::new();\n            stdin().read_line(&mut line).unwrap();\n            line.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($($t:ty),*) => {\n        {\n            let mut line: String = String::new();\n            stdin().read_line(&mut line).unwrap();\n            let mut iter = line.split_whitespace();\n            (\n                $(iter.next().unwrap().parse::<$t>().unwrap(),)*\n            )\n        }\n    };\n    ($t:ty; $n:expr) => {\n        (0..$n).map(|_|\n                    get!($t)\n                   ).collect::<Vec<_>>()\n    };\n    ($($t:ty),*; $n:expr) => {\n        (0..$n).map(|_|\n                    get!($($t),*)\n                   ).collect::<Vec<_>>()\n    };\n    ($t:ty ;;) => {\n        {\n            let mut line: String = String::new();\n            stdin().read_line(&mut line).unwrap();\n            line.split_whitespace()\n                .map(|t| t.parse::<$t>().unwrap())\n                .collect::<Vec<_>>()\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nstruct Flow {\n    // to, capacity, rev\n    edges: Vec<Vec<(usize, usize, usize)>>,\n}\n\nimpl Flow {\n    fn new(max_size: usize) -> Flow {\n        Flow {\n            edges: vec![Vec::new(); max_size + 1],\n        }\n    }\n\n    fn add_edge(&mut self, from: usize, to: usize, cap: usize) {\n        let from_rev = self.edges[to].len();\n        let to_rev = self.edges[from].len();\n\n        self.edges[from].push((to, cap, from_rev));\n        self.edges[to].push((from, 0, to_rev));\n    }\n\n    fn max_flow_dinic(&mut self, s: usize, t: usize) -> usize {\n        let mut flow = 0;\n        loop {\n            let level = self.bfs_dinic(s);\n            let mut iter = vec![0; self.edges.len()];\n            if level[t].is_none() {\n                return flow;\n            }\n\n            loop {\n                let f = self.dfs_dinic(s, t, usize::max_value(), &level, &mut iter);\n                if f == 0 {\n                    break;\n                }\n                flow += f;\n            }\n        }\n    }\n\n    fn bfs_dinic(&self, s: usize) -> Vec<Option<usize>> {\n        let mut level = vec![None; self.edges.len()];\n        let mut que = VecDeque::new();\n\n        level[s] = Some(0);\n        que.push_back(s);\n\n        while !que.is_empty() {\n            let v = que.pop_front().unwrap();\n            let l = Some(level[v].unwrap() + 1);\n\n            for &(to, cap, _) in &self.edges[v] {\n                if cap > 0 && level[to].is_none() {\n                    level[to] = l;\n                    que.push_back(to);\n                }\n            }\n        }\n        level\n    }\n\n    fn dfs_dinic(\n        &mut self,\n        v: usize,\n        t: usize,\n        f: usize,\n        level: &[Option<usize>],\n        iter: &mut [usize],\n    ) -> usize {\n        if v == t {\n            return f;\n        }\n\n        for i in iter[v]..self.edges[v].len() {\n            iter[v] = i;\n\n            let (to, cap, rev) = self.edges[v][i];\n            if cap > 0 && level[v].unwrap() < level[to].unwrap_or(0) {\n                let d = self.dfs_dinic(to, t, min(f, cap), level, iter);\n                if d > 0 {\n                    self.edges[v][i].1 -= d;\n                    self.edges[to][rev].1 += d;\n                    return d;\n                }\n            }\n        }\n        0\n    }\n\n    fn max_flow_ff(&mut self, s: usize, t: usize) -> usize {\n        let mut flow = 0;\n        let l = self.edges.len();\n        loop {\n            let f = self.dfs_ff(s, t, usize::max_value(), &mut vec![false; l]);\n            if f == 0 {\n                break;\n            }\n            flow += f;\n        }\n        flow\n    }\n\n    fn dfs_ff(&mut self, v: usize, t: usize, f: usize, used: &mut [bool]) -> usize {\n        if v == t {\n            return f;\n        }\n        used[v] = true;\n\n        for i in 0..self.edges[v].len() {\n            let (to, cap, rev) = self.edges[v][i];\n            if !used[to] && cap > 0 {\n                let d = self.dfs_ff(to, t, min(f, cap), used);\n                if d > 0 {\n                    self.edges[v][i].1 -= d;\n                    self.edges[to][rev].1 += d;\n                    return d;\n                }\n            }\n        }\n        0\n    }\n\n    fn cut(&self, s: usize) -> BTreeSet<usize> {\n        let mut stack = Vec::new();\n        let mut ss = BTreeSet::new();\n        ss.insert(s);\n        stack.push(s);\n\n        while !stack.is_empty() {\n            let v = stack.pop().unwrap();\n            for &(to, cap, _) in &self.edges[v] {\n                if cap > 0 && !ss.contains(&to) {\n                    ss.insert(to);\n                    stack.push(to);\n                }\n            }\n        }\n\n        ss\n    }\n}\n\nfn gcd(a: u64, b: u64) -> u64 {\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nfn lcm(a: u64, b: u64) -> u64 {\n    a / gcd(a, b) * b\n}\n\n// (gcd, x, y)\nfn extgcd(a: i64, b: i64) -> (i64, i64, i64) {\n    if b == 0 {\n        (a, 1, 0)\n    } else {\n        let (gcd, x, y) = extgcd(b, a % b);\n        (gcd, y, x - (a / b) * y)\n    }\n}\n\nfn mod_pow(x: u64, n: u64, m: u64) -> u64 {\n    let mut res = 1;\n    let mut x = x;\n    let mut n = n;\n    while n > 0 {\n        if n & 1 == 1 {\n            res = (res * x) % m;\n        }\n        x = (x * x) % m;\n        n = n >> 1;\n    }\n    res\n}\n\nfn mod_inverse(a: u64, m: u64) -> u64 {\n    let (_, x, _) = extgcd(a as i64, m as i64);\n    ((m as i64 + x) as u64 % m) % m\n}\n\nfn fact_table(len: usize, m: u64) -> Vec<u64> {\n    let mut res = vec![1; len];\n    for i in 1..len {\n        res[i] = (i as u64 * res[i - 1]) % m;\n    }\n    res\n}\n\n// (a mod p, e when n! = a p^e)\nfn mod_fact(n: u64, p: u64, fact: &Vec<u64>) -> (u64, u64) {\n    if n == 0 {\n        (1, 0)\n    } else {\n        let (a, b) = mod_fact(n / p, p, fact);\n        let e = b + n / p;\n\n        if n / p % 2 != 0 {\n            (a * (p - fact[(n % p) as usize]) % p, e)\n        } else {\n            (a * fact[(n % p) as usize] % p, e)\n        }\n    }\n}\n\nfn mod_comb(n: u64, k: u64, p: u64, fact: &Vec<u64>) -> u64 {\n    if n < k {\n        0\n    } else {\n        let (a1, e1) = mod_fact(n, p, fact);\n        let (a2, e2) = mod_fact(k, p, fact);\n        let (a3, e3) = mod_fact(n - k, p, fact);\n\n        if e1 > e2 + e3 {\n            0\n        } else {\n            a1 * mod_inverse(a2 * a3 % p, p) % p\n        }\n    }\n}\n\nfn main() {\n    loop {\n        let (m, n) = get!(usize, usize);\n        if m == 0 && n == 0 {\n            break;\n        }\n\n        let b = {\n            // suck\n            let mut v = Vec::new();\n            let mut rest = m;\n            while rest > 0 {\n                let mut input = get!(u64;;);\n                rest -= input.len();\n                v.append(&mut input);\n            }\n            v\n        };\n\n        let r = {\n            // suck\n            let mut v = Vec::new();\n            let mut rest = n;\n            while rest > 0 {\n                let mut input = get!(u64;;);\n                rest -= input.len();\n                v.append(&mut input);\n            }\n            v\n        };\n\n        let s = m + n + 1;\n        let t = s + 1;\n\n        let mut flow = Flow::new(t);\n\n        for i in 0..m {\n            flow.add_edge(s, i, 1);\n        }\n\n        for i in 0..n {\n            flow.add_edge(m + i, t, 1);\n        }\n\n        for (i, &x) in b.iter().enumerate() {\n            for (k, &y) in r.iter().enumerate() {\n                if gcd(x, y) != 1 {\n                    flow.add_edge(i, m + k, 1);\n                }\n            }\n        }\n\n        println!(\"{}\", flow.max_flow_dinic(s, t));\n    }\n}"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_imports)]\nuse std::io::stdin;\n\nmod util {\n    use std::io::stdin;\n    use std::str::FromStr;\n    use std::fmt::Debug;\n\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! get {\n    ($t:ty) => {\n        {\n            let mut line: String = String::new();\n            stdin().read_line(&mut line).unwrap();\n            line.trim().parse::<$t>().unwrap()\n        }\n    };\n    ($($t:ty),*) => {\n        {\n            let mut line: String = String::new();\n            stdin().read_line(&mut line).unwrap();\n            let mut iter = line.split_whitespace();\n            (\n                $(iter.next().unwrap().parse::<$t>().unwrap(),)*\n            )\n        }\n    };\n    ($t:ty; $n:expr) => {\n        (0..$n).map(|_|\n                    get!($t)\n                   ).collect::<Vec<_>>()\n    };\n    ($($t:ty),*; $n:expr) => {\n        (0..$n).map(|_|\n                    get!($($t),*)\n                   ).collect::<Vec<_>>()\n    };\n    ($t:ty ;;) => {\n        {\n            let mut line: String = String::new();\n            stdin().read_line(&mut line).unwrap();\n            line.split_whitespace()\n                .map(|t| t.parse::<$t>().unwrap())\n                .collect::<Vec<_>>()\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nstruct Flow {\n    // to, capacity, rev\n    edges: Vec<Vec<(usize, usize, usize)>>,\n}\n\nimpl Flow {\n    fn new(max_size: usize) -> Flow {\n        Flow {\n            edges: vec![Vec::new(); max_size + 1],\n        }\n    }\n\n    fn add_edge(&mut self, from: usize, to: usize, cap: usize) {\n        let from_rev = self.edges[to].len();\n        let to_rev = self.edges[from].len();\n\n        self.edges[from].push((to, cap, from_rev));\n        self.edges[to].push((from, 0, to_rev));\n    }\n\n    fn max_flow_dinic(&mut self, s: usize, t: usize) -> usize {\n        let mut flow = 0;\n        loop {\n            let level = self.bfs_dinic(s);\n            let mut iter = vec![0; self.edges.len()];\n            if level[t].is_none() {\n                return flow;\n            }\n\n            loop {\n                let f = self.dfs_dinic(s, t, usize::max_value(), &level, &mut iter);\n                if f == 0 {\n                    break;\n                }\n                flow += f;\n            }\n        }\n    }\n\n    fn bfs_dinic(&self, s: usize) -> Vec<Option<usize>> {\n        let mut level = vec![None; self.edges.len()];\n        let mut que = VecDeque::new();\n\n        level[s] = Some(0);\n        que.push_back(s);\n\n        while !que.is_empty() {\n            let v = que.pop_front().unwrap();\n            let l = Some(level[v].unwrap() + 1);\n\n            for &(to, cap, _) in &self.edges[v] {\n                if cap > 0 && level[to].is_none() {\n                    level[to] = l;\n                    que.push_back(to);\n                }\n            }\n        }\n        level\n    }\n\n    fn dfs_dinic(\n        &mut self,\n        v: usize,\n        t: usize,\n        f: usize,\n        level: &[Option<usize>],\n        iter: &mut [usize],\n    ) -> usize {\n        if v == t {\n            return f;\n        }\n\n        for i in iter[v]..self.edges[v].len() {\n            iter[v] = i;\n\n            let (to, cap, rev) = self.edges[v][i];\n            if cap > 0 && level[v].unwrap() < level[to].unwrap_or(0) {\n                let d = self.dfs_dinic(to, t, min(f, cap), level, iter);\n                if d > 0 {\n                    self.edges[v][i].1 -= d;\n                    self.edges[to][rev].1 += d;\n                    return d;\n                }\n            }\n        }\n        0\n    }\n\n    #[allow(dead_code)]\n    fn max_flow_ff(&mut self, s: usize, t: usize) -> usize {\n        let mut flow = 0;\n        let l = self.edges.len();\n        loop {\n            let f = self.dfs_ff(s, t, usize::max_value(), &mut vec![false; l]);\n            if f == 0 {\n                break;\n            }\n            flow += f;\n        }\n        flow\n    }\n\n    #[allow(dead_code)]\n    fn dfs_ff(&mut self, v: usize, t: usize, f: usize, used: &mut [bool]) -> usize {\n        if v == t {\n            return f;\n        }\n        used[v] = true;\n\n        for i in 0..self.edges[v].len() {\n            let (to, cap, rev) = self.edges[v][i];\n            if !used[to] && cap > 0 {\n                let d = self.dfs_ff(to, t, min(f, cap), used);\n                if d > 0 {\n                    self.edges[v][i].1 -= d;\n                    self.edges[to][rev].1 += d;\n                    return d;\n                }\n            }\n        }\n        0\n    }\n\n    #[allow(dead_code)]\n    fn cut(&self, s: usize) -> BTreeSet<usize> {\n        let mut stack = Vec::new();\n        let mut ss = BTreeSet::new();\n        ss.insert(s);\n        stack.push(s);\n\n        while !stack.is_empty() {\n            let v = stack.pop().unwrap();\n            for &(to, cap, _) in &self.edges[v] {\n                if cap > 0 && !ss.contains(&to) {\n                    ss.insert(to);\n                    stack.push(to);\n                }\n            }\n        }\n\n        ss\n    }\n}\n\nfn gcd(a: u64, b: u64) -> u64 {\n    if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\n#[allow(dead_code)]\nfn lcm(a: u64, b: u64) -> u64 {\n    a / gcd(a, b) * b\n}\n\n// (gcd, x, y)\n#[allow(dead_code)]\nfn extgcd(a: i64, b: i64) -> (i64, i64, i64) {\n    if b == 0 {\n        (a, 1, 0)\n    } else {\n        let (gcd, x, y) = extgcd(b, a % b);\n        (gcd, y, x - (a / b) * y)\n    }\n}\n\n#[allow(dead_code)]\nfn mod_pow(x: u64, n: u64, m: u64) -> u64 {\n    let mut res = 1;\n    let mut x = x;\n    let mut n = n;\n    while n > 0 {\n        if n & 1 == 1 {\n            res = (res * x) % m;\n        }\n        x = (x * x) % m;\n        n = n >> 1;\n    }\n    res\n}\n\n#[allow(dead_code)]\nfn mod_inverse(a: u64, m: u64) -> u64 {\n    let (_, x, _) = extgcd(a as i64, m as i64);\n    ((m as i64 + x) as u64 % m) % m\n}\n\n#[allow(dead_code)]\nfn fact_table(len: usize, m: u64) -> Vec<u64> {\n    let mut res = vec![1; len];\n    for i in 1..len {\n        res[i] = (i as u64 * res[i - 1]) % m;\n    }\n    res\n}\n\n// (a mod p, e when n! = a p^e)\nfn mod_fact(n: u64, p: u64, fact: &Vec<u64>) -> (u64, u64) {\n    if n == 0 {\n        (1, 0)\n    } else {\n        let (a, b) = mod_fact(n / p, p, fact);\n        let e = b + n / p;\n\n        if n / p % 2 != 0 {\n            (a * (p - fact[(n % p) as usize]) % p, e)\n        } else {\n            (a * fact[(n % p) as usize] % p, e)\n        }\n    }\n}\n\n#[allow(dead_code)]\nfn mod_comb(n: u64, k: u64, p: u64, fact: &Vec<u64>) -> u64 {\n    if n < k {\n        0\n    } else {\n        let (a1, e1) = mod_fact(n, p, fact);\n        let (a2, e2) = mod_fact(k, p, fact);\n        let (a3, e3) = mod_fact(n - k, p, fact);\n\n        if e1 > e2 + e3 {\n            0\n        } else {\n            a1 * mod_inverse(a2 * a3 % p, p) % p\n        }\n    }\n}\n\nfn unused() {}\n\nfn main() {\n    loop {\n        let (m, n) = get!(usize, usize);\n        if m == 0 && n == 0 {\n            break;\n        }\n\n        let b = {\n            // suck\n            let mut v = Vec::new();\n            let mut rest = m;\n            while rest > 0 {\n                let mut input = util::gets::<u64>();\n                rest -= input.len();\n                v.append(&mut input);\n            }\n            v\n        };\n\n        let r = {\n            // suck\n            let mut v = Vec::new();\n            let mut rest = n;\n            while rest > 0 {\n                let mut input = util::gets::<u64>();\n                rest -= input.len();\n                v.append(&mut input);\n            }\n            v\n        };\n\n        let s = m + n + 1;\n        let t = s + 1;\n\n        let mut flow = Flow::new(t);\n\n        for i in 0..m {\n            flow.add_edge(s, i, 1);\n        }\n\n        for i in 0..n {\n            flow.add_edge(m + i, t, 1);\n        }\n\n        for (i, &x) in b.iter().enumerate() {\n            for (k, &y) in r.iter().enumerate() {\n                if gcd(x, y) != 1 {\n                    flow.add_edge(i, m + k, 1);\n                }\n            }\n        }\n\n        println!(\"{}\", flow.max_flow_dinic(s, t));\n    }\n}"
  }
]