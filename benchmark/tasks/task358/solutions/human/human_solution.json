[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.{immutable, mutable}\nobject Main extends App {\n  import scala.io.StdIn._\n  val map = mutable.Map[Coordinate, Int]()\n  val queue = mutable.Queue[Int]()\n  loop()\n  @tailrec def loop(): Unit = {\n    val n = readInt()\n    if (n == 0) return\n    val nodes = Array.fill(2 * n){Nil: List[Edge]}\n    map.clear()\n    for (i ← 0 until n) {\n      val Array(ax, ay, d) = readLine.trim.split(' ')\n      val current@Coordinate(x, y) = Coordinate(ax.toInt, ay.toInt)\n      for (neighbor ← current.neighbors; j ← map.get(neighbor)) {\n        nodes(i * 2) ::= Edge(j, 0)\n        nodes(j) ::= Edge(i * 2, 0)\n      }\n      val other: Coordinate = if (d == \"x\") Coordinate(x + 1, y) else Coordinate(x, y + 1)\n      for (neighbor ← other.neighbors; j ← map.get(neighbor)) {\n        nodes(i * 2 + 1) ::= Edge(j, 0)\n        nodes(j) ::= Edge(i * 2 + 1, 0)\n      }\n      nodes(i * 2) ::= Edge(i * 2 + 1, 1)\n      nodes(i * 2 + 1) ::= Edge(i * 2, 1)\n      map += current → (i * 2)\n      map += other → (i * 2 + 1)\n    }\n    val count = Array.fill(2 * n){-1}\n    var canMake = true\n    for (i ← count.indices if count(i) == -1 && canMake) {\n      queue.clear()\n      queue.enqueue(i)\n      count(i) = 0\n      while(queue.nonEmpty && canMake) {\n        val current = queue.dequeue()\n        for (Edge(next, cost) ← nodes(current)) {\n          if (count(next) == -1) {\n            count(next) = (count(current) + cost) % 2\n            queue.enqueue(next)\n          }else if (count(next) != (count(current) + cost) % 2){\n            canMake = false\n          }\n        }\n      }\n    }\n    println(if (canMake) \"Yes\" else \"No\")\n    loop()\n  }\n  case class Edge(from: Int, cost: Int)\n  case class Coordinate(x: Int, y: Int) {\n    def neighbors: List[Coordinate] = List(Coordinate(x + 1, y), Coordinate(x - 1, y), Coordinate(x, y + 1), Coordinate(x, y - 1))\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,int> Pi;\ntypedef long long ll;\n\nint n;\n\n\nbool bfs(int t,map<P,P> &futon,pair<P,P> f) {\n    queue<Pi> que;\n    que.push(Pi(f.fr,t));\n    f.sc.sc=t;\n    futon[f.fr]=f.sc;\n    map<Pi,bool> visited;\n    visited[(Pi(f.fr,t))]=true;;\n\n    while(que.size()) {\n        Pi pi = que.front(); que.pop();\n        P p=pi.fr;\n        //printf(\"[debug] %d : %d %d %d\\n\",t,p.fr,p.sc,pi.sc);\n        rep(k,4) {\n            int ny=p.fr+dy[k];\n            int nx=p.sc+dx[k];\n            int t=pi.sc;\n\n            if(!futon.count(P(ny,nx))) continue;\n            //if(futon[P(ny,nx)].sc!=-1) continue;\n\n            // ???????????£???\n            if(futon[P(ny,nx)].fr==futon[p].fr) {\n                if(futon[P(ny,nx)].sc!=-1&&futon[P(ny,nx)].sc!=(t^1)) return false;\n                if(visited.count(Pi(P(ny,nx),t^1))) continue;\n                visited[(Pi(P(ny,nx),t^1))]=true;\n                futon[P(ny,nx)].sc=t^1;\n                que.push(Pi(P(ny,nx),t^1));\n            }\n            else {\n                if(futon[P(ny,nx)].sc!=-1&&futon[P(ny,nx)].sc!=t) return false;\n                if(visited.count(Pi(P(ny,nx),t))) continue;\n                visited[(Pi(P(ny,nx),t))]=true;\n                futon[P(ny,nx)].sc=t;\n                que.push(Pi(P(ny,nx),t));\n            }\n\n        }\n    }\n\n    return true;\n}\n\nvoid solve() {\n    map<P,P> futon;\n    rep(i,n) {\n        P pos;\n        char d;\n        cin>>pos.sc>>pos.fr>>d;\n        futon[pos]=P(i,-1);\n        if(d=='x') {\n            pos.sc+=1;\n        }\n        else {\n            pos.fr+=1;\n        }\n        futon[pos]=P(i,-1);\n    }\n    bool f=true;\n    for(auto e : futon) {\n        if(e.sc.sc==-1) {\n            if(!bfs(0,futon,*futon.begin())) f=false;\n        }\n    }\n    if(f) {\n        cout<<\"Yes\"<<endl;\n    }\n    else cout<<\"No\"<<endl;\n}\n\nint main() {\n    while(cin>>n) {\n        if(n==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(_vs) for(auto _x : _vs){cout << _x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(_p) cout << _p.first << \" \" << _p.second << endl\n#define printVP(_vp) for(auto _p : _vp) printP(_p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nstruct Point {\n    int x, y, id;\n    Point(){}\n    Point(int _x, int _y, int _id) : x(_x), y(_y), id(_id) {}\n};\n\nbool cmp_Yx(const Point& p, const Point& q) {\n    if (p.y != q.y) return p.y < q.y;\n    if (p.x != q.x) return p.x < q.x;\n    assert(false);\n}\n\nbool cmp_Xy(const Point& p, const Point& q) {\n    if (p.x != q.x) return p.x < q.x;\n    if (p.y != q.y) return p.y < q.y;\n    assert(false);\n}\n\nbool adjecent(const Point& p, const Point& q) {\n    if (p.x == q.x && abs(p.y - q.y) == 1) return true;\n    if (p.y == q.y && abs(p.x - q.x) == 1) return true;\n    return false;\n}\n\n// undirected\nvoid addEdge(Graph& G, int x, int y) {\n    G[x].emplace_back(y);\n    G[y].emplace_back(x);\n}\n\nvoid solve(int n) {\n    vector<Point> p;\n    rep(i, n) {\n        int x, y;\n        char dir;\n        cin >> x >> y >> dir;\n        p.emplace_back(x, y, 2 * i);\n        if (dir == 'x') {\n            p.emplace_back(x + 1, y, 2 * i + 1);\n        } else {\n            p.emplace_back(x, y + 1, 2 * i + 1);\n        }\n    }\n\n    Graph G(2 * n);\n\n    // horizontal edge\n    sort(all(p), cmp_Yx);\n    rep(i, 2 * n - 1) {\n        if (p[i].y == p[i + 1].y && p[i + 1].x - p[i].x == 1) {\n            addEdge(G, p[i].id, p[i + 1].id);\n        }\n    }\n\n    // vertical edge\n    sort(all(p), cmp_Xy);\n    rep(i, 2 * n - 1) {\n        if (p[i].x == p[i + 1].x && p[i + 1].y - p[i].y == 1) {\n            addEdge(G, p[i].id, p[i + 1].id);\n        }\n    }\n\n    vector<int> color(2 * n, -1);\n\n    std::function<bool(int,int)> dfs = [&](int i, int c) {\n        color[i] = c;\n\n        for (auto j : G[i]) {\n            if (color[j] == -1) continue;\n            if (i / 2 == j / 2 && color[i] == color[j]) {\n                // same futon but same color\n                return false;\n            }\n            if (i / 2 != j / 2 && color[i] != color[j]) {\n                // adjecent cells in different futons but different color\n                return false;\n            }\n        }\n\n        for (auto j : G[i]) {\n            if (color[j] != -1) continue;\n            if (i / 2 == j / 2) {\n                // same futon\n                if (!dfs(j, c^1)) {\n                    return false;\n                }\n            } else {\n                // other futon\n                if (!dfs(j, c)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    };\n\n    rep(i, 2 * n) {\n        if (color[i] == -1 && !dfs(i, 0)) {\n            cout << \"No\" << endl;\n            return;\n        }\n    }\n\n    cout << \"Yes\" << endl;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        solve(n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint n, dp[40000], st[40000], k;\nmap<pi, int> id;\nvi x, y, d;\n\nbool rec(int cx, int cy, int cd){\n\tqueue<pair<pi, int> > q;\n\tq.push(mp(mp(cx, cy), cd));\n\twhile(!q.empty()){\n\t\tcx = q.front().first.first; cy = q.front().first.second;\n\t\tcd = q.front().second;\n\t\tq.pop();\n\t\t\n\t\tint i = id[mp(cx, cy)];\n\t\tst[k++] = i;\n\t\tdp[i] = cd;\n\t\trep(d, 4){\n\t\t\tint nx = cx + dx[d], ny = cy + dy[d];\n\t\t\tif(!id.count(mp(nx, ny))) continue;\n\t\t\tint ii = id[mp(nx, ny)], nd = ii == (i ^ 1) ? 1 - cd : cd;\n\t\t\t\n\t\t\tif(dp[ii] >= 0 && dp[ii] != nd) return 0;\n\t\t\tif(dp[ii] < 0) q.push(mp(mp(nx, ny), nd));\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main(){\n\twhile(scanf(\"%d\", &n), n){\n\t\tx.clear(); y.clear(); d.clear();\n\t\tid.clear();\n\t\t\n\t\trep(i, n){\n\t\t\tint a, b; char c;\n\t\t\tscanf(\"%d%d %c\", &a, &b, &c);\n\t\t\tx.pb(a); y.pb(b); d.pb(c == 'x');\n\t\t\tid[mp(a, b)] = i * 2;\n\t\t\tid[mp(a + d[i], b + 1 - d[i])] = i * 2 + 1;\n\t\t}\n\t\tmemset(dp, -1, sizeof(dp));\n\t\trep(i, 2 * n) if(dp[i] < 0){\n\t\t\tk = 0;\n\t\t\tif(rec(x[i], y[i], 0)) continue;\n\t\t\twhile(k) dp[st[--k]] = -1;\n\t\t\tif(!rec(x[i], y[i], 1)){\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t\tcout << \"Yes\" << endl;\n\t\tEND:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return (v[x] < 0) ? x : (v[x] = find(v[x])); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x != y) {\n\t\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\t\tv[x] += v[y]; v[y] = x;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint n;\n\nvoid foo(int k, int x, int y, map<i_i, int>& m, union_find& uf) {\n\tfor (int d = 0; d < 4; d++) {\n\t\tint _x = x + dx[d], _y = y + dy[d];\n\t\tif (!m.count(i_i(_x, _y))) continue;\n\t\tint _k = m[i_i(_x, _y)];\n\t\tuf.unite(k, _k);\n\t\tuf.unite(k + n * 2, _k + n * 2);\n\t}\n}\n\nint main() {\n\tfor (;;) {\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tvector<int> X(n), Y(n);\n\t\tvector<string> dir(n);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcin >> X[i] >> Y[i] >> dir[i];\n\t\tmap<i_i, int> m;\n\t\tunion_find uf(n * 4);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = X[i], y = Y[i];\n\t\t\tint _x, _y;\n\t\t\tif (dir[i] == \"x\") {\n\t\t\t\t_x = x + 1; _y = y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_x = x; _y = y + 1;\n\t\t\t}\n\t\t\tint k = i * 2, _k = k + 1;\n\t\t\tuf.unite(k, _k + n * 2);\n\t\t\tuf.unite(k + n * 2, _k);\n\t\t\tfoo(k, x, y, m, uf);\n\t\t\tfoo(_k, _x, _y, m, uf);\n\t\t\tm[i_i(x, y)] = k;\n\t\t\tm[i_i(_x, _y)] = _k;\n\t\t}\n\t\tbool flag = true;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint k = i * 2, _k = k + 1;\n\t\t\tif (uf.same(k, k + n * 2) || uf.same(_k, _k + n * 2))\n\t\t\t\tflag = false;\n\t\t}\n\t\tcout << (flag ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n13:11 - \n */\n\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<set>\n#include<map>\n#include<climits>\n#include<cassert>\n#include<deque>\n\n#define MAX 20010\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n\nusing namespace std;\n\nstruct Point{\n  int x,y;\n  char c;\n  Point(int x=IINF,int y=IINF,char c='$'):x(x),y(y),c(c){}\n  bool operator < (const Point& a)const{\n    return ( (x!=a.x) ? (x < a.x) : (y < a.y) );\n  }\n};\n\nint n;\nvector<int> G[MAX];\nchar color[MAX];\n\ninline void makeGraph(const vector<Point>& vec,map<Point,int>& Index){\n  rep(i,n)G[i].clear();\n  rep(i,vec.size()){\n    Point p1 = vec[i];\n    Point p2 = p1;\n    assert(Index.find(vec[i]) != Index.end());\n    int cur = Index[vec[i]];\n    if(p1.c == 'x')p2.x++;\n    else if(p1.c == 'y')p2.y++;\n    else assert(false);\n    //cout << \"Futon( (\" << p1.x << \",\" << p1.y << \") , (\" << p2.x << \",\" << p2.y << \") )\" << endl;\n\n    for(int y=p1.y-1;y<=p2.y+1;y++){\n      for(int x=p1.x-1;x<=p2.x+1;x++){\n\tif(x == p1.x-1 && y == p1.y-1)continue;\n\tif(x == p2.x+1 && y == p1.y-1)continue;\n\tif(x == p1.x-1 && y == p2.y+1)continue;\n\tif(x == p2.x+1 && y == p2.y+1)continue;\n\t//cout << \"check => (\" << x << \",\" << y << \")\" << endl;\n\tif(Index.find(Point(x,y)) != Index.end()){\n\n\t  int next = Index[Point(x,y)];\n\t  if(cur == next)continue;\n\n\t  G[cur].push_back(next);\n\t}\n      }\n    }\n  }\n\n  rep(i,n){\n    sort(G[i].begin(),G[i].end());\n    G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n  }\n}\n\nbool dfs(int cur,char c){\n  color[cur] = c;\n  char rec = ((c == 'w')?'b':'w');\n  for(int i=0;i<G[cur].size();i++){\n    if(color[G[cur][i]] == c)return false;\n    if(color[G[cur][i]] == 'x' && !dfs(G[cur][i],rec))return false;\n  }\n  return true;\n}\n\nint main(){\n\n  while(cin >> n,n){\n    // out = false;\n    map<Point,int> Index;\n    vector<Point> input;\n    int dex = 0;\n    for(int i=0;i<n;i++){\n      int x,y;\n      char c;\n      cin >> x >> y >> c;\n      Point p;\n      if(c == 'x'){\n\tp = Point(x+1,y);\n      } else {\n\tp = Point(x,y+1);\n      }\n      input.push_back(Point(x,y,c));\n      Index[Point(x,y)] = Index[p]= dex++;\n      color[i] = 'x';\n    }\n    assert(dex == n);\n    makeGraph(input,Index);\n\n    for(int i=0;i<n;i++){\n      if(color[i] == 'x'){\n\tif(!dfs(i,'w')){\n\t  cout << \"No\" << endl;\n\t  goto Fin;\n\t}\n      }\n    }\n    cout << \"Yes\" << endl;\n  Fin:;\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint n, dp[400000], st[400000], k;\nmap<pi, int> id;\nvi x, y, d;\n\nbool rec(int cx, int cy, int cd){\n\tqueue<pair<pi, int> > q;\n\tq.push(mp(mp(cx, cy), cd));\n\tdp[st[k++] = id[mp(cx, cy)]] = cd;\n\t\n\twhile(!q.empty()){\n\t\tcx = q.front().first.first; cy = q.front().first.second;\n\t\tcd = q.front().second;\n\t\tq.pop();\n\t\t\n\t\trep(d, 4){\n\t\t\tint nx = cx + dx[d], ny = cy + dy[d];\n\t\t\tif(!id.count(mp(nx, ny))) continue;\n\t\t\tint ii = id[mp(nx, ny)];\n\t\t\tint nd = ii == (id[mp(cx, cy)] ^ 1) ? 1 - cd : cd;\n\t\t\t\n\t\t\tif(dp[ii] >= 0 && dp[ii] != nd) return 0;\n\t\t\tif(dp[ii] >= 0) continue;\n\t\t\tdp[st[k++] = ii] = nd;\n\t\t\tq.push(mp(mp(nx, ny), nd));\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main(){\n\twhile(scanf(\"%d\", &n), n){\n\t\tx.clear(); y.clear(); d.clear();\n\t\tid.clear();\n\t\t\n\t\trep(i, n){\n\t\t\tint a, b; char c;\n\t\t\tscanf(\"%d%d %c\", &a, &b, &c);\n\t\t\tx.pb(a); y.pb(b); d.pb(c == 'x');\n\t\t\tid[mp(a, b)] = i * 2;\n\t\t\tid[mp(a + d[i], b + 1 - d[i])] = i * 2 + 1;\n\t\t}\n\t\tmemset(dp, -1, sizeof(dp));\n\t\trep(i, 2 * n) if(dp[i] < 0){\n\t\t\tk = 0;\n\t\t\tif(rec(x[i], y[i], 0)) continue;\n\t\t\twhile(k) dp[st[--k]] = -1;\n\t\t\tif(!rec(x[i], y[i], 1)){\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t\tcout << \"Yes\" << endl;\n\t\tEND:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct union_find {\n  int H, W;\n  vector<int> rank_, size_, rid_;\n  union_find(int h, int w) { H = h, W = w; rank_.resize(H*W); rid_.assign(H*W, -1); size_.resize(H*W, 1); }\n  void operator()(pair<int, int> x, pair<int, int> y) {\n    int u = x.first * W + x.second;\n    int v = y.first * W + y.second;\n    u = operator[](u), v = operator[](v);\n    if(u == v) { return; }\n    size_[u] = size_[v] = size_[u] + size_[v];\n    if(rank_[u] < rank_[v]) { rid_[u] = v; }\n    else { rid_[v] = u; if(rank_[u] == rank_[v]) { rank_[u]++; } }    \n  }\n  int operator[](pair<int, int> a) { int x = a.first * W + a.second; return operator[](operator[](x)); }\n  int size_of(int x) { return size_[x]; }\nprivate:\n  int operator[](int x) { if(rid_[x] < 0) return x; else return rid_[x] = operator[](rid_[x]); }\n};\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint main() {\n  \n  for(int N; cin >> N && N;) {\n    vector<int> fx(N), fy(N); vector<char> fd(N);\n    vector<int> xs, ys;\n    rep(i, N) {\n      cin >> fx[i] >> fy[i] >> fd[i];\n      REP(d,-1,2) xs.push_back(fx[i]+d), ys.push_back(fy[i]+d);\n    }\n\n    sort(all(xs)); xs.erase(unique(all(xs)), xs.end());\n    sort(all(ys)); ys.erase(unique(all(ys)), ys.end());\n\n    const int H = ys.size();\n    const int W = xs.size();\n\n    map<int, int> X, Y;\n    rep(i, xs.size()) X[xs[i]] = i;\n    rep(i, ys.size()) Y[ys[i]] = i;\n\n    union_find uf(H, W);\n\n    set<pair<int, int>> st;\n\n    rep(i, N) {\n      assert(X.find(fx[i])!=X.end());\n      assert(Y.find(fy[i])!=Y.end());\n      fx[i] = X[fx[i]];\n      fy[i] = Y[fy[i]];\n    }\n\n    rep(i, N) {\n      st.emplace(fy[i], fx[i]);\n      if(fd[i] == 'x') {\n        st.emplace(fy[i], fx[i] + 1);\n      } else {\n        st.emplace(fy[i] + 1, fx[i]);\n      }\n    }\n\n    rep(i, N) {\n      if(fd[i] == 'x') {\n        auto po = make_pair(fy[i], fx[i]);\n        rep(k, 4) if(dx[k] != +1) {\n          auto np = make_pair(fy[i] + dy[k], fx[i] + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n        po = make_pair(fy[i], fx[i] + 1);\n        rep(k, 4) if(dx[k] != -1) {\n          auto np = make_pair(fy[i] + dy[k], fx[i] + 1 + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n      }\n      else {\n        auto po = make_pair(fy[i], fx[i]);\n        rep(k, 4) if(dy[k] != +1) {\n          auto np = make_pair(fy[i] + dy[k], fx[i] + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n\n        po = make_pair(fy[i] + 1, fx[i]);\n        rep(k, 4) if(dy[k] != -1) {\n          auto np = make_pair(fy[i] + 1 + dy[k], fx[i] + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n      }\n    }\n\n    bool ok = 1;\n    rep(i, N) {\n      auto a = make_pair(fy[i], fx[i]);\n      if(fd[i] == 'x') {\n        auto b = make_pair(fy[i], fx[i] + 1);\n        ok &= uf[a] != uf[b];\n      }\n      else {\n        auto b = make_pair(fy[i] + 1, fx[i]);\n        ok &= uf[a] != uf[b];\n      }\n    }\n\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\nstruct union_find {\n\tvector<int> data;\n\tunion_find(int n) : data(n, -1) {}\n\tint find(int a) {\n\t\treturn data[a] < 0 ? a : data[a] = find(data[a]);\n\t}\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\tvoid unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b) return;\n\t\tif (data[a] > data[b]) swap(a, b);\n\t\tdata[a] += data[b];\n\t\tdata[b] = a;\n\t}\n};\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<int> x(n), y(n);\n\t\tvector<char> d(n);\n\t\tmap<pii, pii> pos;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> d[i];\n\t\t\tpos[make_pair(x[i], y[i])] = make_pair(i, 0);\n\t\t\t(d[i] == 'x' ? pos[make_pair(x[i] + 1, y[i])] : pos[make_pair(x[i], y[i] + 1)]) = make_pair(i, 1);\n\t\t}\n\t\tbool ok = true;\n\t\tunion_find uf(n * 2);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint nx = x[i], ny = y[i];\n\t\t\tfor (int a = 0; a < 2; a++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tint tx = nx + dx[i], ty = ny + dy[i];\n\t\t\t\t\tpii tp(tx, ty);\n\t\t\t\t\tif (pos.count(tp) && pos[tp].first != i) {\n\t\t\t\t\t\tif (a == pos[tp].second) {\n\t\t\t\t\t\t\tint u = i, v = pos[tp].first;\n\t\t\t\t\t\t\tuf.unite(u, v);\n\t\t\t\t\t\t\tuf.unite(n + u, n + v);\n\t\t\t\t\t\t\tif (uf.same(u, n + u) || uf.same(v, n + v)) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint u = i, v = pos[tp].first;\n\t\t\t\t\t\t\tuf.unite(u, n + v);\n\t\t\t\t\t\t\tuf.unite(n + u, v);\n\t\t\t\t\t\t\tif (uf.same(u, n + u) || uf.same(v, n + v)) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(d[i] == 'x' ? nx : ny) += 1;\n\t\t\t}\n\t\t}\n\t\tputs(ok ? \"Yes\" : \"No\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> parent;\n  UnionFind (int n) { parent.assign(n, -1); }\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n  bool merge(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (parent[y] < parent[x]) swap(x, y);\n    if (parent[x] == parent[y]) --parent[x];\n    parent[y] = x;\n    return true;\n  }\n};\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if(!n) break;\n    UnionFind uf(n*4);\n    REP(i,n){\n      uf.merge(i*4,i*4+3);\n      uf.merge(i*4+1,i*4+2);\n    }\n    map<int,map<int,int>> m;\n    vector<tuple<int,int,string>> f;\n    REP(i,n){\n      int x,y;\n      string d;\n      cin>>x>>y>>d;\n      m[x][y] = i*2+1;\n      if(d==\"x\")\n        m[x+1][y] = i*2+2;\n      else\n        m[x][y+1] = i*2+2;\n      f.emplace_back(x,y,d);\n    }\n    REP(i,n){\n      int x,y;\n      string d;\n      tie(x,y,d) = f[i];\n      int l=m[x-1][y];\n      if (l != 0) {\n        int j = (l-1)/2;\n        int s = (l-1)-2*j;\n        uf.merge(i*4,j*4+s*2);\n        uf.merge(i*4+1,j*4+s*2+1);\n      }\n      l=m[x][y-1];\n      if (l != 0) {\n        int j = (l-1)/2;\n        int s = (l-1)-2*j;\n        uf.merge(i*4,j*4+s*2);\n        uf.merge(i*4+1,j*4+s*2+1);\n      }\n      if(d==\"x\"){\n        l=m[x+1][y-1];\n        if (l != 0) {\n          int j = (l-1)/2;\n          int s = (l-1)-2*j;\n          uf.merge(i*4+2,j*4+s*2);\n          uf.merge(i*4+3,j*4+s*2+1);\n        }\n      }else{\n        l=m[x-1][y+1];\n        if (l != 0) {\n          int j = (l-1)/2;\n          int s = (l-1)-2*j;\n          uf.merge(i*4+2,j*4+s*2);\n          uf.merge(i*4+3,j*4+s*2+1);\n        }\n      }\n    }\n    bool ok = true;\n    REP(i,n) {\n      if (uf.root(i*4)==uf.root(i*4+1)) ok = false;\n    }\n    if(ok)\n      cout<<\"Yes\"<<endl;\n    else\n      cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> parent;\n  UnionFind (int n) { parent.assign(n, -1); }\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n  bool merge(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (parent[y] < parent[x]) swap(x, y);\n    if (parent[x] == parent[y]) --parent[x];\n    parent[y] = x;\n    return true;\n  }\n};\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if(!n) break;\n    UnionFind uf(n*4);\n    REP(i,n){\n      uf.merge(i*4,i*4+3);\n      uf.merge(i*4+1,i*4+2);\n    }\n    map<int,map<int,int>> m;\n    vector<tuple<int,int,string>> f;\n    REP(i,n){\n      int x,y;\n      string d;\n      cin>>x>>y>>d;\n      m[x][y] = i*2+1;\n      if(d==\"x\")\n        m[x][y+1] = i*2+2;\n      else\n        m[x+1][y] = i*2+2;\n      f.emplace_back(x,y,d);\n    }\n    REP(i,n){\n      int x,y;\n      string d;\n      tie(x,y,d) = f[i];\n      int l=m[x-1][y];\n      if (l != 0) {\n        int j = (l-1)/2;\n        int s = (l-1)-2*j;\n        uf.merge(i*4,j*4+s*2);\n        uf.merge(i*4+1,j*4+s*2+1);\n      }\n      l=m[x][y-1];\n      if (l != 0) {\n        int j = (l-1)/2;\n        int s = (l-1)-2*j;\n        uf.merge(i*4,j*4+s*2);\n        uf.merge(i*4+1,j*4+s*2+1);\n      }\n      if(d==\"x\"){\n        l=m[x+1][y-1];\n        if (l != 0) {\n          int j = (l-1)/2;\n          int s = (l-1)-2*j;\n          uf.merge(i*4+2,j*4+s*2);\n          uf.merge(i*4+3,j*4+s*2+1);\n        }\n      }else{\n        l=m[x-1][y+1];\n        if (l != 0) {\n          int j = (l-1)/2;\n          int s = (l-1)-2*j;\n          uf.merge(i*4+2,j*4+s*2);\n          uf.merge(i*4+3,j*4+s*2+1);\n        }\n      }\n    }\n    bool ok = true;\n    REP(i,n) {\n      if (uf.root(i*4)==uf.root(i*4+1)) ok = false;\n    }\n    if(ok)\n      cout<<\"Yes\"<<endl;\n    else\n      cout<<\"No\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef _WIN32\n#define getc_unlocked(stdin) getc(stdin)\n#endif\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n#include <list>\n#include <bitset>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <numeric>\n#include <functional>\n#include <valarray>\n#include <complex>\nusing namespace std;\n\nconst int dx[]={0,-1,0,1,-1,1, 1,-1};\nconst int dy[]={1,0,-1,0, 1,1,-1,-1};\nconst double eps=1e-8;\n\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vgraph;\ntypedef vector<pii> vpii;\ntypedef vector<LL> vLL;\ntypedef vector<string> vs;\n\n#define sz(a) a.size()\n#define fori(i,a,b) for(int i(a),_b(b);i<=_b;++i)\n#define ford(i,a,b) for(int i(a),_b(b);i>=_b;--i)\n#define forn(i,n) fori(i,0,n-1)\n#define fora(i,a) forn(i,sz(a))\n#define fore(it,c) for(typeof((c).begin()) it=(c).begin();it!=(c).end();++it)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back\n#define clear0(a) memset(a,0,sizeof(a))\n#define clearm1(a) memset(a,-1,sizeof(a))\n#define maximum(a) (*max_element(all(a)))\n#define minimum(a) (*min_element(all(a)))\n#define findx(a,x) (find(all(a),x)-a.begin())\n#define two(X) (1LL<<(X))\n#define contain(S,X) ((S)&two(X))\n#define setbit(S,X) ((S)|=two(X))\n#define clearbit(S,X) ((S)&=~two(X))\n#define togglebit(S,X) ((S)^=two(X))\n#define sqr(a) ((a)*(a))\n#define fi \"i.inp\"\n#define fo \"output.out\"\n#define nmax 100\n#define mmax 100\n#define kmax 10\n#define modulo 1000000007\n#define maxc 999999999\nmap<int, map<int, int> > mmap;\nvector<int> adj[nmax];\nint a[nmax], b[nmax], c[nmax], d[nmax], fr[nmax];\nint n;\n\nint go(int u, int color)\n{\n    fr[u] = color;\n    fora(i,adj[u])\n    {\n        int v = adj[u][i];\n        if (fr[v] == -1) go(v, 1-color);\n        else if (fr[v] == fr[u]) return 0;\n    }\n    return 1;\n}\nint main()\n{\n\t#ifndef ONLINE_JUDGE\n\t\t//freopen(fi,\"r\",stdin);\n\t\t//freopen(fo,\"w\", stdout);\n\t#endif\n\tvector<int> uu;\n\n    while (1)\n    {\n        mmap.clear();\n        int m = 0;\n        string s;\n\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        fori(i, 1, n)\n        {\n            while(!adj[i].empty()) adj[i].clear();\n            fr[i] = -1;\n            int u, v;\n            cin >>u >> v >>s;\n            ++m;\n            if (s == \"x\")\n            {\n                mmap[u+1][v-1]=m;\n                mmap[u+2][v-1]=m;\n                a[m] = u+1;\n                b[m] = v-1;\n                c[m] = u+2;\n                d[m] = v-1;\n            }\n            else\n            {\n                mmap[u+1][v+1]=m;\n                mmap[u+1][v+2]=m;\n                a[m] = u+1;\n                b[m] = v+1;\n                c[m] = u+1;\n                d[m] = v+2;\n            }\n        }\n         fori(i, 1, n)\n            {\n                int id1 = mmap[a[i]][b[i]];\n                fori(j, 0, 3)\n                {\n                    int u = a[i] +dx[j];\n                    int v = b[i] +dy[j];\n                    int id2 = mmap[u][v];\n                    if (id2 > 0 && id1 != id2)\n                    {\n                        adj[id1].pb(id2);\n                        adj[id2].pb(id1);\n                    }\n                }\n            }\n            int ans = 1;\n            fori(i, 1, n)\n                if (fr[i] == -1)\n                    if (!go(i,0))\n                    {\n                        ans = 0;\n                        break;\n                    }\n            if (ans) printf(\"Yes\\n\");\n            else printf(\"No\\n\");\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint n, dp[40000], st[40000], k;\nmap<pi, int> id;\nvi x, y, d;\n\nbool rec(int cx, int cy, int cd){\n\tqueue<pair<pi, int> > q;\n\tq.push(mp(mp(cx, cy), cd));\n\tdp[st[k++] = id[mp(cx, cy)]] = cd;\n\t\n\twhile(!q.empty()){\n\t\tcx = q.front().first.first; cy = q.front().first.second;\n\t\tcd = q.front().second;\n\t\tq.pop();\n\t\t\n\t\trep(d, 4){\n\t\t\tint nx = cx + dx[d], ny = cy + dy[d];\n\t\t\tif(!id.count(mp(nx, ny))) continue;\n\t\t\tint ii = id[mp(nx, ny)];\n\t\t\tint nd = ii == (id[mp(cx, cy)] ^ 1) ? 1 - cd : cd;\n\t\t\t\n\t\t\tif(dp[ii] >= 0 && dp[ii] != nd) return 0;\n\t\t\tif(dp[ii] >= 0) continue;\n\t\t\tdp[st[k++] = ii] = nd;\n\t\t\tq.push(mp(mp(nx, ny), nd));\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main(){\n\twhile(scanf(\"%d\", &n), n){\n\t\tx.clear(); y.clear(); d.clear();\n\t\tid.clear();\n\t\t\n\t\trep(i, n){\n\t\t\tint a, b; char c;\n\t\t\tscanf(\"%d%d %c\", &a, &b, &c);\n\t\t\tx.pb(a); y.pb(b); d.pb(c == 'x');\n\t\t\tid[mp(a, b)] = i * 2;\n\t\t\tid[mp(a + d[i], b + 1 - d[i])] = i * 2 + 1;\n\t\t}\n\t\tmemset(dp, -1, sizeof(dp));\n\t\trep(i, 2 * n) if(dp[i] < 0){\n\t\t\tk = 0;\n\t\t\tif(rec(x[i], y[i], 0)) continue;\n\t\t\twhile(k) dp[st[--k]] = -1;\n\t\t\tif(!rec(x[i], y[i], 1)){\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t\tcout << \"Yes\" << endl;\n\t\tEND:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define s second\n#define f first\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct D{\n  int num,used,color;\n  D(){};\n  D(int a,int b,int c){\n    num=a,used=b,color=c;\n  }\n};\nmap<P,D> Futon;\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nchar dir;\nbool ans;\n\nvoid dfs(int y,int x){\n  map<P,D>::iterator F=Futon.find(P(y,x));\n  (*F).s.used=1;\n  for(int i=0;i<4;i++){\n    int ny=y+dy[i],nx=x+dx[i];\n    if(!Futon.count(P(ny,nx)))continue;\n    map<P,D>::iterator F1=Futon.find(P(ny,nx));\n    if((*F1).s.color==-1){\n      if((*F1).s.num==(*F).s.num)\n\t(*F1).s.color=!(*F).s.color;\n      else\n\t(*F1).s.color=(*F).s.color;\n    }else{\n      if((*F1).s.num==(*F).s.num){\n\tif((*F1).s.color==(*F).s.color)\n\t  ans=false;\n      }\n      else if((*F1).s.color!=(*F).s.color)\n\tans=false;\n    }\n    if(!(*F1).s.used)dfs(ny,nx);\n  }\n}\n\nint main(){\n  int n,x,y;\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>x>>y>>dir;\n      Futon[P(y,x)]=D(i,0,-1);\n      if(dir=='x')Futon[P(y,x+1)]=D(i,0,-1);\n      else Futon[P(y+1,x)]=D(i,0,-1);\n    }\n    ans=true;\n    map<P,D>::iterator ite=Futon.begin();\n    while(ite!=Futon.end()){\n      if(!(*ite).s.used){\n\t(*ite).s.color=0;\n\tdfs((*ite).f.f,(*ite).f.s);\n      }\n      ite++;\n    }\n    if(ans)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    Futon.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\n#define X first\n#define Y second\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    P p[n];\n    char d[n];\n    for(int i=0;i<n;i++) cin>>p[i].X>>p[i].Y>>d[i];\n    map<P,int> m;\n    for(int i=0;i<n;i++) m[p[i]]=i;\n    int used[n],visit[n];\n    memset(used,0,sizeof(used));\n    bool f=1;\n\n    int ax1[]={-1, 0, 1, 2,-2,-1, 0, 1};\n    int ay1[]={-1,-1,-1, 0, 0, 1, 1, 1};\n    int ad1[]={ 1, 0, 1, 1, 1, 1, 0, 1};\n    \n    int ax2[]={-1, 0, 1, 2, 2, 1, 0,-1};\n    int ay2[]={ 0, 1, 1, 0,-1,-2,-2,-1};\n    int ad2[]={ 0, 0, 1, 1, 0, 0, 1, 1};\n    \n    int ax3[]={ 0, 1, 1, 1, 0,-1,-1,-1};\n    int ay3[]={ 2, 1, 0,-1,-2,-1, 0, 1};\n    int ad3[]={ 1, 1, 0, 1, 1, 1, 0, 1};\n    \n    int ax4[]={-1, 0, 1, 1, 0,-1,-2,-2};\n    int ay4[]={-1,-1, 0, 1, 2, 2, 1, 0};\n    int ad4[]={ 1, 0, 0, 1, 1, 0, 0, 1};\n    \n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      bool ff=0;\n      for(int k=0;k<2;k++){\n\tbool fff=1;\n\t\n\tmemset(visit,-1,sizeof(visit));\n\tqueue<int> q;\n\tq.push(i);\n\tvisit[i]=k;\n\t\n\twhile(!q.empty()){\n\t  int t=q.front();q.pop();\n\t  //cout<<t<<\" \"<<visit[t]<<endl;\n\t  if(d[t]=='x'){\n\t    for(int j=0;j<8;j++){\n\t      int nx=p[t].X+ax1[j],ny=p[t].Y+ay1[j],nv=visit[t];\n\t      if(!m.count(P(nx,ny))) continue;\n\t      int u=m[P(nx,ny)];\n\t      if(d[u]=='y') continue;\n\t      //cout<<\"a1:\"<<u<<endl;\n\t      if(ad1[j]) nv=!nv;\n\t      if(~visit[u]){\n\t\tif(visit[u]!=nv){\n\t\t  fff=0;\n\t\t  goto END;\n\t\t}\n\t      }else{\n\t\tvisit[u]=nv;\n\t\tq.push(u);\n\t      }\n\t    }\n\t    for(int j=0;j<8;j++){\n\t      int nx=p[t].X+ax2[j],ny=p[t].Y+ay2[j],nv=visit[t];\n\t      if(!m.count(P(nx,ny))) continue;\n\t      int u=m[P(nx,ny)];\n\t      if(d[u]=='x') continue;\n\t      //cout<<\"a2:\"<<u<<endl;\n\t      if(ad2[j]) nv=!nv;\n\t      if(~visit[u]){\n\t\tif(visit[u]!=nv){\n\t\t  fff=0;\n\t\t  goto END;\n\t\t}\n\t      }else{\n\t\tvisit[u]=nv;\n\t\tq.push(u);\n\t      }\n\t    }\n\t  }\n\t  \n\t  if(d[t]=='y'){\n\t    for(int j=0;j<8;j++){\n\t      int nx=p[t].X+ax3[j],ny=p[t].Y+ay3[j],nv=visit[t];\n\t      if(!m.count(P(nx,ny))) continue;\n\t      int u=m[P(nx,ny)];\n\t      if(d[u]=='x') continue;\n\t      //cout<<\"a3:\"<<u<<endl;\n\t      if(ad3[j]) nv=!nv;\n\t      if(~visit[u]){\n\t\tif(visit[u]!=nv){\n\t\t  fff=0;\n\t\t  goto END;\n\t\t}\n\t      }else{\n\t\tvisit[u]=nv;\n\t\tq.push(u);\n\t      }\n\t    }\n\t    for(int j=0;j<8;j++){\n\t      int nx=p[t].X+ax4[j],ny=p[t].Y+ay4[j],nv=visit[t];\n\t      if(!m.count(P(nx,ny))) continue;\n\t      int u=m[P(nx,ny)];\n\t      if(d[u]=='y') continue;\n\t      //cout<<\"a4:\"<<u<<endl;\n\t      if(ad4[j]) nv=!nv;\n\t      if(~visit[u]){\n\t\tif(visit[u]!=nv){\n\t\t  fff=0;\n\t\t  goto END;\n\t\t}\n\t      }else{\n\t\tvisit[u]=nv;\n\t\tq.push(u);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n      END:\n\n\t//cout<<\"fff:\"<<fff<<endl;\n\t\n\tif(fff){\n\t  for(int j=0;j<n;j++) if(~visit[j]) used[i]=1;\n\t  ff=1;\n\t  break;\n\t}\n      }\n      if(!ff){\n\tf=0;\n\tbreak;\n      }\n    }\n    cout<<(f?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n//#define int long long\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define all(x) x.begin(), x.end()\nusing pii = pair<int, int>;\nusing ll = long long;\n\nint t = 0;\n\nstruct Futon {\n    int X[2], Y[2];\n    int id;\n    Futon(int x, int y, char c, int id) : id(id) {\n        X[0] = X[1] = x, Y[0] = Y[1] = y;\n        if (c == 'x')\n            X[1] = x + 1;\n        else\n            Y[1] = y + 1;\n    }\n    bool operator<(const Futon &rhs) {\n        if (X[0] == rhs.X[0]) return Y[0] < rhs.Y[0];\n        return X[0] < rhs.X[0];\n    }\n    void show() { cerr << X[0] << \" \" << Y[0] << \" \" << X[1] << \" \" << Y[1] << endl; }\n    pii p1() { return {X[0], Y[0]}; }\n    pii p2() { return {X[1], Y[1]}; }\n};\n\nconstexpr int dx[4] = {0, 0, -1, 1}, dy[4] = {1, -1, 0, 0};\nbool connect(Futon &a, Futon &b) {\n    REP(i, 2) REP(j, 2) REP(k, 4) {\n        if (a.X[i] + dx[k] == b.X[j] && a.Y[i] + dy[k] == b.Y[j]) return true;\n    }\n    return false;\n}\n\nvector<int> G[100010];\n\nbool solve() {\n    t++;\n    set<pii> stX, stY;\n    int N;\n    cin >> N;\n    if (N == 0) return false;\n    vector<Futon> fs;\n    REP(i, N) {\n        int x, y;\n        char c;\n        cin >> x >> y >> c;\n        Futon f(x, y, c, i);\n        fs.push_back(f);\n        G[i].clear();\n    }\n    sort(all(fs));\n    REP(i, N) {\n        FOR(j, i + 1, N) {\n            if (fs[j].X[0] > fs[i].X[0] + 2) break;\n            if (connect(fs[i], fs[j])) {\n                // fs[i].show();\n                // fs[j].show();\n                // cerr << endl;\n                G[i].push_back(j);\n                G[j].push_back(i);\n            }\n        }\n    }\n    map<pii, int> mp;\n    vector<bool> done(N);\n    bool possible = true;\n    queue<int> que;\n    REP(i, N) {\n        if (!possible) break;\n        if (done[i]) continue;\n\n        que.push(i);\n        while (!que.empty()) {\n            if (!possible) break;\n            int id = que.front();\n            que.pop();\n            if (done[id]) continue;\n            done[id] = true;\n            bool found1 = false, found2 = false;\n            int x0 = fs[id].X[0], y0 = fs[id].Y[0];\n            REP(k, 4) {\n                if (!mp.count({x0 + dx[k], y0 + dy[k]})) continue;\n                if (mp[{x0 + dx[k], y0 + dy[k]}] == 1) found1 = true;\n                if (mp[{x0 + dx[k], y0 + dy[k]}] == 2) found2 = true;\n            }\n            if (found1 && found2) possible = false;\n            int x1 = fs[id].X[1], y1 = fs[id].Y[1];\n            bool found11 = false, found22 = false;\n            REP(k, 4) {\n                if (!mp.count({x1 + dx[k], y1 + dy[k]})) continue;\n                if (mp[{x1 + dx[k], y1 + dy[k]}] == 1) found11 = true;\n                if (mp[{x1 + dx[k], y1 + dy[k]}] == 2) found22 = true;\n                if (mp[{x1 + dx[k], y1 + dy[k]}] == 1 && found1) possible = false;\n                if (mp[{x1 + dx[k], y1 + dy[k]}] == 2 && found2) possible = false;\n            }\n            if (found1 && found11) possible = false;\n            if (found2 && found22) possible = false;\n            if (found11 && found22) possible = false;\n            if (found2 || found11) {\n                mp[{x0, y0}] = 2;\n                mp[{x1, y1}] = 1;\n            } else {\n                mp[{x0, y0}] = 1;\n                mp[{x1, y1}] = 2;\n            }\n\n            for (auto nxt : G[id]) {\n                que.push(nxt);\n            }\n        }\n    }\n    REP(i, N) {\n        int x = fs[i].X[0], y = fs[i].Y[0];\n        int x1 = fs[i].X[1], y1 = fs[i].Y[1];\n        if (!possible) break;\n        if (mp[{x, y}] == 1) {\n            REP(k, 4) {\n                if (x + dx[k] == x1 && y + dy[k] == y1) continue;\n                if (mp[{x + dx[k], y + dy[k]}] == 2) possible = false;\n            }\n        } else if (mp[{x, y}] == 2) {\n            REP(k, 4) {\n                if (x + dx[k] == x1 && y + dy[k] == y1) continue;\n                if (mp[{x + dx[k], y + dy[k]}] == 1) possible = false;\n            }\n        } else {\n            cerr << \"not decided!!!!\" << endl;\n        }\n    }\n    if (possible)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n    return true;\n}\n\nsigned main() {\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int sz = 100010;\nvector<int> G[sz];\nvector<int> rG[sz];\nint cmp[sz];\nbool visit[sz];\n\nvoid dfs(int v, vector<int> &vs){\n  visit[v] = true;\n  REP(i, G[v].size()) if(!visit[G[v][i]]) dfs(G[v][i], vs);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n  visit[v] = true;\n  cmp[v] = k;\n  REP(i, rG[v].size()) if(!visit[rG[v][i]]) rdfs(rG[v][i], k);\n}\n\nint scc(int V){\n  int k = 0;\n  vector<int> vs;\n  \n  memset(visit, false, sizeof(visit));  \n  REP(i, V) if(!visit[i]) dfs(i, vs);\n  memset(visit, false, sizeof(visit));\n  reverse(ALL(vs));\n  REP(i, vs.size())if(!visit[vs[i]]) rdfs(vs[i], k++);\n  return k;\n}\n\nvoid clear(){\n  REP(i, sz){\n    G[i].clear();\n    rG[i].clear();\n  }\n}\n\nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    clear();\n    char dir;\n    vector<int> x(n * 2);\n    vector<int> y(n * 2);\n    vector<int> d(n * 2);\n    \n    REP(i, n){\n      cin >> x[i] >> y[i] >> dir;\n      x[i+n] = x[i];\n      y[i+n] = y[i];\n      \n      if(dir == 'x'){\n        x[i+n]++;\n        d[i] = 0;\n        d[i+n] = 2;\n      }\n      \n      if(dir == 'y'){\n        y[i+n]++;\n        d[i] = 1;\n        d[i+n] = 3;\n      }\n    }\n    \n    n *= 2;\n    map<P, int> futon;    \n    REP(i, n) futon[P(x[i], y[i])] = i;\n    \n    REP(i, n){\n      int dx[4] = {1, 0, -1, 0};\n      int dy[4] = {0, 1, 0, -1};     \n      REP(j, 4){\n        int xa = x[i] + dx[j];\n        int ya = y[i] + dy[j];\n\n        if(futon.find(P(xa, ya)) != futon.end()){\n          int f = futon[P(xa, ya)];\n          if(j == d[i]){\n            add_edge(i, f + n);\n            add_edge(i + n, f);\n          }else{\n            add_edge(i + n, f + n);\n          }\n        }\n      }\n    }\n\n    bool possible = true;\n    scc(2 * n);\n    REP(i, n){\n      possible &= cmp[i] != cmp[n + i];\n    }\n    cout << (possible ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nclass UnionFind {\npublic:\n  vector<int> par, rank; // parent(negative := its root and abs-value is its size), depth\n  UnionFind(int sz) : par(sz, -1), rank(sz, 0){}\n  int find(int x){\n    if(par[x]<0) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;  // already belong to same tree\n    if(rank[x] < rank[y]){  // y becomes parent node\n      par[y] += par[x];\n      par[x] = y;\n    } else {  // x becomes parent node\n      par[x] += par[y];\n      par[y] = x;\n      if(rank[x]==rank[y]) rank[x]++;\n    }\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int size(int x){ return -par[find(x)]; }\n};\n\nbool solve(int n){\n  vector<int> x(n),y(n);\n  vector<char> dir(n);\n  map<pair<int,int>,int> number;\n  int cnt=0;\n  auto add = [&](int xx, int yy){\n    if(number.count(mp(xx,yy))==0) number[mp(xx,yy)] = cnt++;\n  };\n  rep(i,n){\n    char s[5];\n    scanf(\"%d %d %s\", &x[i], &y[i], s);\n    dir[i] = s[0];\n    add(x[i],y[i]);\n    if(dir[i]=='x') add(x[i]+1, y[i]);\n    else add(x[i],y[i]+1);\n  }\n\n  UnionFind uf(2*cnt);\n\n  auto same = [&](int x1, int y1, int x2, int y2){\n    if(number.count(mp(x1,y1))==0 || number.count(mp(x2,y2))==0) return true;\n    int n1 = number[mp(x1,y1)], n2 = number[mp(x2,y2)];\n    uf.unite(n1,n2); uf.unite(n1+cnt, n2+cnt);\n    if(uf.same(n1, n2+cnt) || uf.same(n1+cnt, n2)) return false;\n    return true;\n  };\n  auto diff = [&](int x1, int y1, int x2, int y2){\n    if(number.count(mp(x1,y1))==0 || number.count(mp(x2,y2))==0) return true;\n    int n1 = number[mp(x1,y1)], n2 = number[mp(x2,y2)];\n    uf.unite(n1, n2+cnt); uf.unite(n1+cnt, n2);\n    if(uf.same(n1, n2) || uf.same(n1+cnt, n2+cnt)) return false;\n    return true;\n  };\n\n  rep(i,n){\n    if(dir[i]=='x'){\n      if(!same(x[i],y[i], x[i]-1,y[i]) ||\n         !same(x[i],y[i], x[i],y[i]+1) ||\n         !same(x[i],y[i], x[i],y[i]-1) ||\n         !same(x[i]+1,y[i], x[i]+2,y[i]) ||\n         !same(x[i]+1,y[i], x[i]+1,y[i]+1) ||\n         !same(x[i]+1,y[i], x[i]+1,y[i]-1) ||\n         !diff(x[i],y[i], x[i]+1,y[i]) ) return false;\n    }\n    else {\n      if(!same(x[i],y[i], x[i]-1,y[i]) ||\n         !same(x[i],y[i], x[i]+1,y[i]) ||\n         !same(x[i],y[i], x[i],y[i]-1) ||\n         !same(x[i],y[i]+1, x[i]+1,y[i]+1) ||\n         !same(x[i],y[i]+1, x[i]-1,y[i]+1) ||\n         !same(x[i],y[i]+1, x[i],y[i]+2) ||\n         !diff(x[i],y[i], x[i],y[i]+1) ) return false;\n    }\n  }\n  return true;\n}\n\n\nint main(){\n  int n;\n  while(cin>>n, n){\n    if(solve(n)) cout << \"Yes\" <<endl;\n    else cout << \"No\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct union_find {\n  int n;\n  vector<int> rank_, size_, rid_;\n  union_find(int n) { this->n = n; rank_.resize(n); rid_.assign(n, -1); size_.resize(n, 1); }\n  void operator()(pair<int, int> x, pair<int, int> y) {\n    int u = x.first * sqrt(n) + x.second;\n    int v = y.first * sqrt(n) + y.second;\n    u = operator[](u), v = operator[](v);\n    if(u == v) { return; }\n    size_[u] = size_[v] = size_[u] + size_[v];\n    if(rank_[u] < rank_[v]) { rid_[u] = v; }\n    else { rid_[v] = u; if(rank_[u] == rank_[v]) { rank_[u]++; } }    \n  }\n  int operator[](pair<int, int> a) { int x = a.first * sqrt(n) + a.second; return operator[](operator[](x)); }\n  int size_of(int x) { return size_[x]; }\nprivate:\n  int operator[](int x) { if(rid_[x] < 0) return x; else return rid_[x] = operator[](rid_[x]); }\n};\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint main() {\n  \n  for(int N; cin >> N && N;) {\n    vector<int> fx(N), fy(N); vector<char> fd(N);\n    vector<int> xs, ys;\n    rep(i, N) {\n      cin >> fx[i] >> fy[i] >> fd[i];\n      REP(d,-1,2) xs.push_back(fx[i]+d), ys.push_back(fy[i]+d);\n    }\n\n    sort(all(xs)); xs.erase(unique(all(xs)), xs.end());\n    sort(all(ys)); ys.erase(unique(all(ys)), ys.end());\n\n    const int H = ys.size();\n    const int W = xs.size();\n\n    map<int, int> X, Y;\n    rep(i, xs.size()) X[xs[i]] = i;\n    rep(i, ys.size()) Y[ys[i]] = i;\n\n    union_find uf(max(H,W)*max(H,W));\n\n    set<pair<int, int>> st;\n\n    rep(i, N) {\n      assert(X.find(fx[i])!=X.end());\n      assert(Y.find(fy[i])!=Y.end());\n      fx[i] = X[fx[i]];\n      fy[i] = Y[fy[i]];\n    }\n\n    rep(i, N) {\n      st.emplace(fy[i], fx[i]);\n      if(fd[i] == 'x') {\n        st.emplace(fy[i], fx[i] + 1);\n      } else {\n        st.emplace(fy[i] + 1, fx[i]);\n      }\n    }\n\n    rep(i, N) {\n      if(fd[i] == 'x') {\n        auto po = make_pair(fy[i], fx[i]);\n        rep(k, 4) if(dx[k] != +1) {\n          auto np = make_pair(fy[i] + dy[k], fx[i] + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n        po = make_pair(fy[i], fx[i] + 1);\n        rep(k, 4) if(dx[k] != -1) {\n          auto np = make_pair(fy[i] + dy[k], fx[i] + 1 + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n      }\n      else {\n        auto po = make_pair(fy[i], fx[i]);\n        rep(k, 4) if(dy[k] != +1) {\n          auto np = make_pair(fy[i] + dy[k], fx[i] + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n\n        po = make_pair(fy[i] + 1, fx[i]);\n        rep(k, 4) if(dy[k] != -1) {\n          auto np = make_pair(fy[i] + 1 + dy[k], fx[i] + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n      }\n    }\n\n    bool ok = 1;\n    rep(i, N) {\n      auto a = make_pair(fy[i], fx[i]);\n      if(fd[i] == 'x') {\n        auto b = make_pair(fy[i], fx[i] + 1);\n        ok &= uf[a] != uf[b];\n      }\n      else {\n        auto b = make_pair(fy[i] + 1, fx[i]);\n        ok &= uf[a] != uf[b];\n      }\n    }\n\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nmap<int,map< int,int > > field;\nint n;\nint x[20001],y[20001];\nint head[20001];\nchar dir[20001];\nvector<int> G[20001];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nvector<int> vs;\n\nbool dfs(int v,int c){\n\thead[v]=c;\n\tvs.push_back(v);\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint e=G[v][i];\n\t\tif(dir[v]=='x' && dir[e]=='x'){\n\t\t\tif(x[v]==x[e]){\n\t\t\t\tif(head[e]==-1){\n\t\t\t\t\tif(!dfs(e,c))return false;\n\t\t\t\t}else{\n\t\t\t\t\tif(head[e]!=c)return false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(head[e]==-1){\n\t\t\t\t\tif(!dfs(e,1-c))return false;\n\t\t\t\t}else{\n\t\t\t\t\tif(head[e]!=1-c)return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(dir[v]=='y' && dir[e]=='y'){\n\t\t\tif(y[v]==y[e]){\n\t\t\t\tif(head[e]==-1){\n\t\t\t\t\tif(!dfs(e,c))return false;\n\t\t\t\t}else{\n\t\t\t\t\tif(head[e]!=c)return false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(head[e]==-1){\n\t\t\t\t\tif(!dfs(e,1-c))return false;\n\t\t\t\t}else{\n\t\t\t\t\tif(head[e]!=1-c)return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tbool flag0=true,flag1=true;\n\t\t\tif(c==0){\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tif(x[v]+dx[i]==x[e] && y[v]+dy[i]==y[e])flag1=false;\n\t\t\t\t\tif(x[v]+dx[i]==x[e]+(dir[e]=='x') && y[v]+dy[i]==y[e]+(dir[e]=='y'))flag0=false;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tif(x[e]+dx[i]==x[v]+(dir[v]=='x') && y[e]+dy[i]==y[v]+(dir[v]=='y'))flag0=false;\n\t\t\t\t\tif(x[e]+(dir[e]=='x')+dx[i]==x[v]+(dir[v]=='x') && y[e]+(dir[e]=='y')+dy[i]==y[v]+(dir[v]=='y'))flag1=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c==1){\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tif(x[v]+(dir[v]=='x')+dx[i]==x[e] && y[v]+(dir[v]=='y')+dy[i]==y[e])flag1=false;\n\t\t\t\t\tif(x[v]+(dir[v]=='x')+dx[i]==x[e]+(dir[e]=='x') && y[v]+(dir[v]=='y')+dy[i]==y[e]+(dir[e]=='y'))flag0=false;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tif(x[e]+dx[i]==x[v] && y[e]+dy[i]==y[v])flag0=false;\n\t\t\t\t\tif(x[e]+(dir[e]=='x')+dx[i]==x[v] && y[e]+(dir[e]=='y')+dy[i]==y[v])flag1=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag0 && !flag1)return false;\n\t\t\tint nc;\n\t\t\tif(flag0)nc=0;\n\t\t\tif(flag1)nc=1;\n\t\t\tif(head[e]==-1){\n\t\t\t\tif(!dfs(e,nc))return false;\n\t\t\t}else{\n\t\t\t\tif(head[e]!=nc)return false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nbool check(){\n\tfor(int i=1;i<=n;i++){\n\t\tif(dir[i]=='x'){\n\t\t\tif(field[x[i]][y[i]]!=0)return false;\n\t\t\tfield[x[i]][y[i]]=i;\n\t\t\tif(field[x[i]+1][y[i]]!=0)return false;\n\t\t\tfield[x[i]+1][y[i]]=i;\n\t\t}\n\t\tif(dir[i]=='y'){\n\t\t\tif(field[x[i]][y[i]]!=0)return false;\n\t\t\tfield[x[i]][y[i]]=i;\n\t\t\tif(field[x[i]][y[i]+1]!=0)return false;\n\t\t\tfield[x[i]][y[i]+1]=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(dir[i]=='x'){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(field[x[i]+dx[j]][y[i]+dy[j]]!=0 && field[x[i]+dx[j]][y[i]+dy[j]]!=field[x[i]][y[i]]){\n\t\t\t\t\tG[i].push_back(field[x[i]+dx[j]][y[i]+dy[j]]);\n\t\t\t\t}\n\t\t\t\tif(field[x[i]+dx[j]+1][y[i]+dy[j]]!=0 && field[x[i]+dx[j]+1][y[i]+dy[j]]!=field[x[i]+1][y[i]]){\n\t\t\t\t\tG[i].push_back(field[x[i]+dx[j]+1][y[i]+dy[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dir[i]=='y'){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(field[x[i]+dx[j]][y[i]+dy[j]]!=0 && field[x[i]+dx[j]][y[i]+dy[j]]!=field[x[i]][y[i]]){\n\t\t\t\t\tG[i].push_back(field[x[i]+dx[j]][y[i]+dy[j]]);\n\t\t\t\t}\n\t\t\t\tif(field[x[i]+dx[j]][y[i]+dy[j]+1]!=0 && field[x[i]+dx[j]][y[i]+dy[j]+1]!=field[x[i]][y[i]+1]){\n\t\t\t\t\tG[i].push_back(field[x[i]+dx[j]][y[i]+dy[j]+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemset(head,-1,sizeof(head));\n\tfor(int i=1;i<=n;i++){\n\t\tif(head[i]==-1){\n\t\t\tif(!dfs(i,0)){\n\t\t\t\tfor(int j=0;j<vs.size();j++){\n\t\t\t\t\thead[vs[j]]=-1;\n\t\t\t\t}\n\t\t\t\tif(!dfs(i,1))return false;\n\t\t\t}\n\t\t\tvs.clear();\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(void){\n\twhile(1){\n\t\tfield.clear();\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%d %d %c\",&x[i],&y[i],&dir[i]);\n\t\t}\n\t\tprintf(\"%s\\n\",check()?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<map>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int> p;\nmap<p,p>F;\nint N,X,Y,D,m[5]={0,1,0,-1,0};\nint dfs(p pos,p f,int c)\n{\n\tF[pos].first=c;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tp tmp(pos.first+m[i],pos.second+m[i+1]);\n\t\tif(F.count(tmp))\n\t\t{\n\t\t\tif(F[tmp].second==f.second)//same_futon\n\t\t\t{\n\t\t\t\tif(F[tmp].first==-1&&dfs(tmp,F[tmp],!c)==0)\n\t\t\t\t\treturn 0;\n\t\t\t\telse if(F[tmp].first==c)\n\t\t\t\t\treturn 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse//diff_futon\n\t\t\t{\n\t\t\t\tif(F[tmp].first==-1&&dfs(tmp,F[tmp],c)==0)\n\t\t\t\t\treturn 0;\n\t\t\t\telse if(F[tmp].first!=c)\n\t\t\t\t\treturn 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tF.clear();\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d %c\\n\",&X,&Y,&D);\n\t\t\tif(D-'x')\n\t\t\t{\n\t\t\t\tF[p(X,Y)]=p(-1,i);\n\t\t\t\tF[p(X,Y+1)]=p(-1,i);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tF[p(X,Y)]=p(-1,i);\n\t\t\t\tF[p(X+1,Y)]=p(-1,i);\n\t\t\t}\n\t\t}\n\t\tmap<p,p>::iterator i=F.begin();\n\t\tfor(;i!=F.end();i++)\n\t\t{\n\t\t\tif(i->second.first==-1&&dfs(i->first,i->second,0)==0)\n\t\t\t\tbreak;\n\t\t}\n\t\tputs(i==F.end()?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\nconst int vy[] = {0, 1, 0, -1}, vx[] = {1, 0, -1, 0};\n \n \nmap< Pi, Pi > futon;\nmap< Pi, int > head;\n \nbool check(const Pi& point)\n{\n  head[point] = 1;\n  head[futon[point]] = -1;\n  bool flag = true;\n  for(int i = 0; i < 4 && flag; i++) {\n    const int nx = point.first + vx[i], ny = point.second + vy[i];\n    if(make_pair(nx, ny) == futon[point]) continue;\n    if(head.find({nx, ny}) != head.end()) {\n      if(head[{nx, ny}] == -1) flag = false;\n    } else if(futon.find({nx, ny}) != futon.end()) {\n      if(!check({nx, ny})) flag = false;\n    }\n  }\n   \n  for(int i = 0; i < 4 && flag; i++) {\n    const int nx = futon[point].first + vx[i], ny = futon[point].second + vy[i];\n    if(make_pair(nx, ny) == point) continue;\n    if(head.find({nx, ny}) != head.end()) {\n      if(head[{nx, ny}] == 1) flag = false;\n    } else if(futon.find({nx, ny}) != futon.end()) {\n      if(!check(futon[{nx, ny}])) flag = false;\n    }\n  }\n  return(flag);\n}\n \nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    while(N--) {\n      int x, y;\n      char dir;\n      cin >> x >> y >> dir;\n      if(dir == 'x') {\n        futon[{x, y}] = {x + 1, y};\n        futon[{x + 1, y}] = {x, y};\n      } else {\n        futon[{x, y}] = {x, y + 1};\n        futon[{x, y + 1}] = {x, y};\n      }\n    }\n    while(!futon.empty()) {\n      auto decide = *futon.begin();\n      if(head.find(decide.first) == head.end()) {\n        if(!check(decide.first)) break;\n      }\n      futon.erase(futon.begin());\n    }\n    if(futon.empty()) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n \n    head.clear();\n    futon.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\ntypedef pair<P,int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\n//// UnionFind\nstruct UnionFind{\n\tvector<int> v;\n\tUnionFind(int n) : v(n, -1) {}\n\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tbool unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return false;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t\treturn true;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint n;\nvector<PP> edge;\nvector<P> point;\nint dd[]={-1,0,1,0,-1};\n\nint idlast;\nmap<P,int> mp;\nint id(P p){\n\tif(mp.count(p))return mp[p];\n\tmp[p]=idlast++;\n\treturn mp[p];\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tidlast=0;\n\t\tedge.clear();point.clear(); mp.clear();\n\t\trep(i,n){\n\t\t\tint a,b; char c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tif(c=='x'){\n\t\t\t\tedge.pb(PP(P(a,b),P(a+1,b)));\n\t\t\t\tid(P(a,b)); id(P(a+1,b));\n\t\t\t\tpoint.pb(P(a,b)); point.pb(P(a+1,b));\n\t\t\t}else{\n\t\t\t\tedge.pb(PP(P(a,b),P(a,b+1)));\n\t\t\t\tid(P(a,b)); id(P(a,b+1));\n\t\t\t\tpoint.pb(P(a,b)); point.pb(P(a,b+1));\n\t\t\t}\n\t\t}\n\t\tUnionFind uf(idlast);\n\t\trep(i,point.size()){\n\t\t\tP p=point[i];\n\t\t\trep(j,4){\n\t\t\t\tint nx=p.fi+dd[j], ny=p.se+dd[j+1];\n\t\t\t\tif(mp.count(P(nx,ny))&&P(nx,ny)!=(i%2?point[i-1]:point[i+1])){\n\t\t\t\t\tuf.unite(id(p),id(P(nx,ny)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool ok=true;\n\t\trep(i,n){\n\t\t\tif(uf.same(id(edge[i].fi),id(edge[i].se)))ok=false;\n\t\t}\n\t\tif(ok)cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nclass UnionFind {\n    int n;\n    vector<int> uni;\npublic:\n    explicit UnionFind(int n) : uni(static_cast<u32>(n), -1) , n(n){};\n\n    int root(int a){\n        if (uni[a] < 0) return a;\n        else return (uni[a] = root(uni[a]));\n    }\n\n    bool unite(int a, int b) {\n        a = root(a);\n        b = root(b);\n        if(a == b) return false;\n        if(uni[a] > uni[b]) swap(a, b);\n        uni[a] += uni[b];\n        uni[b] = a;\n        return true;\n    }\n\n    int size(int i){ return -uni[root(i)]; }\n    bool same(int a, int b) { return root(a) == root(b); }\n};\n\nint main() {\n    int n;\n    array<int, 4> di{0, 0, -1, 1}, dj{1, -1, 0, 0};\n    while(cin >> n, n){\n        map<pair<int, int>, int> s;\n        int cnt = 1;\n        for (int i = 0; i < n; ++i) {\n            int x, y; char c;\n            scanf(\"%d %d %c\", &x, &y, &c);\n            if(c == 'x'){\n                s[{x, y}] = cnt;\n                s[{x+1, y}] = cnt++;\n            }else {\n                s[{x, y}] = cnt;\n                s[{x, y+1}] = cnt++;\n            }\n        }\n        UnionFind uf(cnt*2);\n        for (auto &&x : s) {\n            int i, j; tie(i, j) = x.first;\n            int p = x.second;\n            for (int k = 0; k < 4; ++k) {\n                if(s.count({i+di[k], j+dj[k]})) {\n                    int q = s[{i+di[k], j+dj[k]}];\n                    if(p == q) continue;\n                    uf.unite(p, q+cnt);\n                    uf.unite(q, p+cnt);\n                }\n            }\n        }\n        int ok = 1;\n        for (int i = 1; i < cnt; ++i) {\n            if(uf.same(i, i+cnt)){\n                ok = 0;\n                break;\n            }\n        }\n        puts(ok ? \"Yes\" : \"No\");\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nmap<P,P> mp;\nmap<P,int> vis;\nbool dfs(P p,int c){\n\tP q=mp[p];\n\tvis[p]=c;\n\tif(vis[q]==0){\n\t\tbool b=dfs(q,-c);\n\t\tif(!b) return 0;\n\t}\n\trep(i,4){\n\t\tP np=P(p.fs+dx[i],p.sc+dy[i]);\n\t\tif(np==q||!mp.count(np)) continue;\n\t\tif(vis[np]!=0){\n\t\t\tif(vis[np]!=c) return 0;\n\t\t}else{\n\t\t\tbool b=dfs(np,c);\n\t\t\tif(!b) return 0;\n\t\t}\n\t}\n\treturn 1;\n}\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmp.clear();\n\t\tvis.clear();\n\t\trep(i,N){\n\t\t\tint x,y;\n\t\t\tchar c;\n\t\t\tcin>>x>>y>>c;\n\t\t\tP p=P(x,y);\n\t\t\tif(c=='x'){\n\t\t\t\tP q=P(x+1,y);\n\t\t\t\tmp[p]=q,mp[q]=p;\n\t\t\t}else{\n\t\t\t\tP q=P(x,y+1);\n\t\t\t\tmp[p]=q,mp[q]=p;\n\t\t\t}\n\t\t}\n\t\tbool ok=1;\n\t\tfor(auto pp:mp){\n\t\t\tP p=pp.fs;\n\t\t\tif(vis[p]!=0) continue;\n\t\t\tif(!dfs(p,1)) ok=0;\n\t\t}\n\t\tif(ok) puts(\"Yes\");\n\t\telse puts(\"No\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\nvoid solve(){\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0) return;\n\t\tmap<pair<int, int>, pair<int, pair<int, int>>> vertexs;\n\t\tREP(i, n) {\n\t\t\tint a, b;\n\t\t\tstring c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tif (c == \"x\") {\n\t\t\t\tvertexs[mp(a, b)] = mp(-1, mp(a + 1, b));\n\t\t\t\tvertexs[mp(a + 1, b)] = mp(-1, mp(a, b));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvertexs[mp(a, b)] = mp(-1, mp(a, b + 1));\n\t\t\t\tvertexs[mp(a, b + 1)] = mp(-1, mp(a, b));\n\t\t\t}\n\t\t}\n\t\tint ok = 1;\n\t\tfor (auto i = vertexs.begin(); i != vertexs.end(); ++i) {\n\t\t\tif (i->second.first != -1) continue;\n\t\t\tqueue<pair<int, int>> next;\n\t\t\tnext.push(i->first);\n\t\t\tnext.push(i->second.second);\n\t\t\tvertexs[i->first].first = 0;\n\t\t\tvertexs[i->second.second].first = 1;\n\t\t\twhile (next.empty() == false) {\n\t\t\t\tpair<int, int> now = next.front();\n\t\t\t\tnext.pop();\n\t\t\t\tint dx[4] = { 1,-1,0,0 };\n\t\t\t\tREP(q, 4) {\n\t\t\t\t\tint next_x = now.first + dx[q];\n\t\t\t\t\tint next_y = now.second + dx[3 - q];\n\t\t\t\t\tif (vertexs.find(mp(next_x, next_y)) == vertexs.end()) continue;\n\t\t\t\t\tif (mp(next_x, next_y) == vertexs[now].second) continue;\n\t\t\t\t\tif (vertexs[mp(next_x, next_y)].first != -1) {\n\t\t\t\t\t\t//check\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (vertexs[mp(next_x, next_y)].first != vertexs[now].first) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvertexs[mp(next_x, next_y)].first = vertexs[now].first;\n\t\t\t\t\t\tnext.push(mp(next_x, next_y));\n\t\t\t\t\t\tpair<int, int> check = vertexs[mp(next_x, next_y)].second;\n\t\t\t\t\t\tvertexs[check].first = (vertexs[now].first + 1) % 2;\n\t\t\t\t\t\tnext.push(check);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ok == 1) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n}\n\n#undef int\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n;\nP p[2][20100];\nchar d;\nvector<P> g[20100];\nint vis[20100];\n\nvoid add_edge(int u,int v,int col){\n  g[v].push_back(P(u,col));\n  g[u].push_back(P(v,col));\n}\n\nint md(P a, P b){\n  return abs(a.first-b.first) + abs(a.second-b.second);\n}\n\nbool dfs(int v,int col){\n  //cout << v << endl;\n  if(vis[v]>=0)return (vis[v] == col);\n  vis[v] = col;\n\n  for(int i=0;i<g[v].size();i++){\n    if(!dfs(g[v][i].first,col^g[v][i].second))return false;\n  }\n  return true;\n}\n\nint main(){\n  cin.tie(0); std::ios::sync_with_stdio(false);\n\n  while(cin >> n,n){\n    for(int i=0;i<n;i++){\n      cin >> p[0][i].first >> p[0][i].second >> d;\n      p[1][i].first = p[0][i].first + (d=='x');\n      p[1][i].second = p[0][i].second + (d=='y');\n    }\n    \n    for(int i=0;i<n;i++)g[i].clear();\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(i==j)continue;\n\tbool f = true;\n\tfor(int ii=0;f,ii<2;ii++){\n\t  for(int jj=0;f,jj<2;jj++){\n\t    if(md(p[ii][i],p[jj][j])==1){\n\t      add_edge(i,j,ii!=jj);\n\t      f = false;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    bool flag = true;\n    memset(vis,-1,sizeof(vis));\n    /*\n    for(int i=0;i<n;i++){\n      for(int j=0;j<g[i].size();j++)cout << g[i][j].first << \" \" << g[i][j].second << endl;\n      cout << endl;\n    }\n    */\n    for(int i=0;i<n;i++){\n      if(vis[i]<0)flag &= dfs(i,0);\n      if(!flag)break;\n    }\n    //for(int i=0;i<n;i++)cout << vis[i] << \" \";cout << endl;\n    cout << (flag?\"Yes\":\"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\nstruct union_find {\n\tvector<int> data;\n\tunion_find(int n) : data(n, -1) {}\n\tint find(int a) {\n\t\treturn data[a] < 0 ? a : data[a] = find(data[a]);\n\t}\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\tvoid unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b) return;\n\t\tif (data[a] > data[b]) swap(a, b);\n\t\tdata[a] += data[b];\n\t\tdata[b] = a;\n\t}\n};\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<int> x(n), y(n);\n\t\tvector<char> d(n);\n\t\tmap<pii, pii> pos;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> d[i];\n\t\t\tpos[make_pair(x[i], y[i])] = make_pair(i, 0);\n\t\t\t(d[i] == 'x' ? pos[make_pair(x[i] + 1, y[i])] : pos[make_pair(x[i], y[i] + 1)]) = make_pair(i, 1);\n\t\t}\n\t\tbool ok = true;\n\t\tunion_find uf(n * 2);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint nx = x[i], ny = y[i];\n\t\t\tfor (int a = 0; a < 2; a++) {\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tint tx = nx + dx[j], ty = ny + dy[j];\n\t\t\t\t\tpii tp(tx, ty);\n\t\t\t\t\tif (pos.count(tp) && pos[tp].first != i) {\n\t\t\t\t\t\tif (a == pos[tp].second) {\n\t\t\t\t\t\t\tint u = i, v = pos[tp].first;\n\t\t\t\t\t\t\tuf.unite(u, v);\n\t\t\t\t\t\t\tuf.unite(n + u, n + v);\n\t\t\t\t\t\t\tif (uf.same(u, n + u) || uf.same(v, n + v)) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tint u = i, v = pos[tp].first;\n\t\t\t\t\t\t\tuf.unite(u, n + v);\n\t\t\t\t\t\t\tuf.unite(n + u, v);\n\t\t\t\t\t\t\tif (uf.same(u, n + u) || uf.same(v, n + v)) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t(d[i] == 'x' ? nx : ny) += 1;\n\t\t\t}\n\t\t}\n\t\tputs(ok ? \"Yes\" : \"No\");\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\n\ntypedef vector<pii> vp;\n\n\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tmap<pii,vp> g;\n\t\tmap<pii,vi> type;\n\t\tmap<pii,int> hf;\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tchar d;\n\t\t\tcin>>x>>y>>d;\n\t\t\tint dir=(d=='x'?2:3);\n\t\t\tpii c=make_pair(y,x);\n\t\t\tpii n=make_pair(y+dy[dir],x+dx[dir]);\n\n\t\t\tg[c]=vp();\n\t\t\ttype[c]=vi();\n\t\t\tg[c].push_back(n);\n\t\t\ttype[c].push_back(1);\n\t\t\thf[c]=-1;\n\n\t\t\tg[n]=vp();\n\t\t\ttype[n]=vi();\n\t\t\tg[n].push_back(c);\n\t\t\ttype[n].push_back(1);\n\t\t\thf[n]=-1;\n\n\t\t\tREP(j,2){\n\t\t\t\tREP(k,4){\n\t\t\t\t\tpii base=(j==0?c:n);\n\t\t\t\t\tpii neighbor=make_pair(base.first+dy[k],base.second+dx[k]);\n\t\t\t\t\tif(EXIST(g,neighbor)&&find(ALL(g[base]),neighbor)==g[base].end()){\n\t\t\t\t\t\tg[base].push_back(neighbor);\n\t\t\t\t\t\ttype[base].push_back(0);\n\t\t\t\t\t\tg[neighbor].push_back(base);\n\t\t\t\t\t\ttype[neighbor].push_back(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok=true;\n\t\tqueue<pii> q;\n\t\tfor(map<pii,vp>::iterator it=g.begin();it!=g.end();it++){\n\t\t\tif(hf[(*it).first]==-1){\n\t\t\t\tq.push((*it).first);\n\t\t\t\thf[(*it).first]=0;\n\t\t\t\twhile(!q.empty()){\n\t\t\t\t\tpii cur=q.front();q.pop();\n\t\t\t\t\tint cur_hf=hf[cur];\n\t\t\t\t\tREP(i,g[cur].size()){\n\t\t\t\t\t\tpii next=g[cur][i];\n\t\t\t\t\t\tint next_hf=(cur_hf+type[cur][i])%2;\n\t\t\t\t\t\tif(hf[next]==-1){\n\t\t\t\t\t\t\thf[next]=next_hf;\n\t\t\t\t\t\t\tq.push(next);\n\t\t\t\t\t\t}else if(hf[next]==next_hf){\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tok=false;\n\t\t\t\t\t\t\tgoto end;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\nend:\n\t\tcout<<(ok?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nmap<P,P> G;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\n\nset<PP> used;\nset<P> checked;\nint check(P head){\n  P leg = G[head];\n  if(used.count(PP(head,leg)))return 1;\n  if(used.count(PP(leg,head)))return 0;\n  used.insert(PP(head,leg));\n  checked.insert(head);\n  checked.insert(leg);\n\n  int res = 1;\n  for(int i=0;i<4;i++){\n    int nx = head.second+dx[i];\n    int ny = head.first+dy[i];\n    P nhead = P(ny,nx);\n    if(nhead == leg || !G.count(nhead))continue;\n    res &=check(nhead);\n  }\n\n  for(int i=0;i<4;i++){\n    int nx = leg.second+dx[i];\n    int ny = leg.first+dy[i];\n    P nleg = P(ny,nx);\n    if(nleg == head || !G.count(nleg))continue;\n    res &=check(G[nleg]);\n  }\n  return res;\n}\n\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    G.clear();\n    for(int i=0;i<n;i++){\n      int x,y;\n      char dir;\n      cin>>x>>y>>dir;\n      int a = x + (dir == 'x');\n      int b = y + (dir == 'y');\n      G[P(y,x)] = P(b,a);\n      G[P(b,a)] = P(y,x);\n    }\n\n    int ans = 1;\n    checked.clear();\n    for(PP a:G){\n      if(!ans || checked.count(a.first))continue;\n      used.clear();\n      if(check(a.first)) continue;\n      used.clear();\n      if(check(a.second))continue;\n      ans = 0;\n    }\n    cout<<(ans? \"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nusing pll = pair<ll, ll>;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nbool isadj(pii a, pii b) {\n\treturn abs(a.first - b.first) + abs(a.second - b.second) == 1;\n}\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<pair<pii, char>> buf;\n\t\tmap<pii, vector<pair<pii, int>>> fadj;\n\t\tmap<pii, int>futon;\n\t\tset<pii> fl;\n\t\tbuf.reserve(n);\n\t\trep(i, n) {\n\t\t\tint x, y;\n\t\t\tchar d;\n\t\t\tcin >> x >> y >> d;\n\t\t\tbuf.push_back(make_pair(pii(x, y), d));\n\t\t\tfl.insert(pii(x,y));\n\t\t}\n\t\trep(i, n)rep(j, i) {\n\t\t\tpii p1 = buf[i].first, p2 = p1, q1 = buf[j].first, q2 = q1;\n\t\t\tif (buf[i].second == 'x')p2.first += 1;\n\t\t\telse p2.second += 1;\n\t\t\tif (buf[j].second == 'x')q2.first += 1;\n\t\t\telse q2.second += 1;\n\t\t\tint x = -1;\n\t\t\tif (isadj(p1, q1) || isadj(p2, q2))x = 0;\n\t\t\telse if (isadj(p1, q2) || isadj(p2, q1))x = 3;\n\t\t\tif (x != -1)fadj[p1].push_back({ q1,x }), fadj[q1].push_back({ p1,x });\n\t\t}\n\t\tbool ok = 1;\n\t\twhile (!fl.empty()) {\n\t\t\tqueue<pii> que;\n\t\t\tque.push(*fl.begin());\n\t\t\tfuton[*fl.begin()] = 6;\n\t\t\tint ave = 3;\n\t\t\tfl.erase(*fl.begin());\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpii pos = que.front();\n\t\t\t\tint x = futon[que.front()];\n\t\t\t\tque.pop();\n\t\t\t\tfor (auto b : fadj[pos]) {\n\t\t\t\t\tif (!futon[b.first]) {\n\t\t\t\t\t\tfuton[b.first] = x^b.second;\n\t\t\t\t\t\tque.push(b.first);\n\t\t\t\t\t\tfl.erase(b.first);\n\t\t\t\t\t}\n\t\t\t\t\telse ave&=3&~(futon[b.first] ^ x^b.second);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ave) {\n\t\t\t\tok = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\nusing namespace std;\n\n\nconst int mod = 1000000007;\n\nstruct Mod {\n\tint num;\n\tMod() : num(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) { ; }\n\tMod(int n) : num((n % mod + mod) % mod) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(Mod a, Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(long long int a, Mod b) { return Mod(a)+b; }\nMod operator-(Mod a, Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(long long int a, Mod b) { return Mod(a) - b; }\nMod operator*(Mod a, Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(long long int a, Mod b) { return Mod(a)*b; }\nMod operator+=(Mod &a, Mod b) { return a = a + b; }\nMod operator+=(long long int &a, Mod b) { return a = a + b; }\nMod operator-=(Mod &a, Mod b) { return a = a - b; }\nMod operator-=(long long int &a, Mod b) { return a = a - b; }\nMod operator*=(Mod &a, Mod b) { return a = a * b; }\nMod operator*=(long long int &a, Mod b) { return a = a * b; }\nMod operator^(Mod a, int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(Mod a) { return a ^ (mod - 2); }\nMod operator/(Mod a, Mod b) { \nassert(b!=0);\nreturn a * inv(b);\n }\nMod operator/(long long int a, Mod b) {\n\tassert(b != 0);\n\treturn Mod(a) * inv(b);\n}\n\n#define MAX_N 1024000\n\nMod fact[MAX_N], factinv[MAX_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(int a, int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n\nvector<map<vector<int>, Mod>>dp;\n\n\nvector<vector<Mod>> keisann(const vector<vector<Mod>>l, const vector<vector<Mod>>r) {\n\tvector<vector<Mod>>ans(l.size(), vector<Mod>(r[0].size()));\n\tassert(l[0].size() == r.size());\n\tfor (int h = 0; h < l.size(); ++h) {\nfor (int i = 0; i < r.size(); ++i) {\n\t\tfor (int w = 0; w < r[0].size(); ++w) {\n\t\t\t\n\t\t\t\tans[h][w] += l[h][i] * r[i][w];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvector<vector<Mod>>powgyou(vector<vector<Mod>>a, const long long int n) {\n\tif (n == 1)return a;\n\telse {\n\t\tvector<vector<Mod>>ans(a.size(), vector<Mod>(a[0].size(), 0));\n\t\tans = powgyou(a, n / 2);\n\t\tans = keisann(ans, ans);\n\t\tif (n % 2) {\n\t\t\tans = keisann(ans, a);\n\t\t}\n\t\treturn ans;\n\t}\n}\n\n\n\t/*int N; cin >> N;\n\tvector<pair<int, int>>cs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, r; cin >> x >> r;\n\t\tint l = x - r; int r = x + r;\n\t\tcs.emplace_back({ l,r });\n\t}\n\tsort(cs.begin(), cs.end(), [](const pair<int, int>l, const int pair<int, int>r) {\n\t\treturn l.first == r.first ? l.second < r.second : l.first < r.first; }));\n\treturn 0;*/\n\n\t/*int H, W; cin >> W >> H;\n\tdp.resize(H+1);\n\tvector<int>s(W,0);\n\ts[0] = Mod(1);\n\tdp[0][s] = Mod(1);\n\tfor (int i = 1; i <= H; ++i) {\n\t\tfor (auto it = dp[i - 1].begin(); it != dp[i - 1].end(); ++it) {\n\t\t\tvector<int>pre((*it).first);\n\t\t\tfor (int j = 0; j < (1 <<( W)); ++j) {\n\t\t\t\tbitset<6>bs(j);\n\t\t\t\tvector<int>now(W);\n\t\t\t\tint num = 2;\n\t\t\t\tfor (int k = 0; k < W; ++k) {\n\t\t\t\t\tif (bs[k]) {\n\t\t\t\t\t\tnow[k] = num;\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < W; ++k) {\n\t\t\t\t\tif (now[k] && pre[k]) {\n\t\t\t\t\t\tnow[k] = pre[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < W - 1; ++k) {\n\t\t\t\t\tif (now[k] && now[k + 1]) {\n\t\t\t\t\t\tint amin = min(now[k], now[k + 1]);\n\t\t\t\t\t\tnow[k] = amin;\n\t\t\t\t\t\tnow[k + 1] = amin;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = W - 1; k > 0; --k) {\n\t\t\t\t\tif (now[k] && now[k - 1]) {\n\t\t\t\t\t\tint amin = min(now[k], now[k - 1]);\n\t\t\t\t\t\tnow[k] = amin;\n\t\t\t\t\t\tnow[k - 1] = amin;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint nnum = 2;\n\t\t\t\tfor (int k = 0; k < W; ++k) {\n\t\t\t\t\tif (now[k]>=2) {\n\t\t\t\t\t\tint aa = now[k];\n\t\t\t\t\t\tfor (int l = 0; l < W; ++l) {\n\t\t\t\t\t\t\tif (now[l] == aa)now[l] = nnum;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnnum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbool isok = false;\n\t\t\t\tfor (int k = 0; k < W; ++k) {\n\t\t\t\t\tif (now[k] == 1) {\n\t\t\t\t\t\tisok = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isok) {\n\n\t\t\t\t\tdp[i][now] += (*it).second;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\tMod ans(0);\n\tfor (auto it = dp[H].begin(); it != dp[H].end(); ++it) {\n\t\tif ((*it).first[W - 1] == 1) {\n\t\t\tans += (*it).second;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;*/\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\n\nint dx8[8] = { -1,-1,-1,0, 1,1 , 1 ,0};\nint dy8[8] = { -1,0,1 ,1, 1,0 ,-1,-1 };\n\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first1,\n\tBidirectionalIterator last1,\n\tBidirectionalIterator first2,\n\tBidirectionalIterator last2)\n{\n\tif ((first1 == last1) || (first2 == last2)) {\n\t\treturn false;\n\t}\n\tBidirectionalIterator m1 = last1;\n\tBidirectionalIterator m2 = last2; --m2;\n\twhile (--m1 != first1 && !(*m1 < *m2)) {\n\t}\n\tbool result = (m1 == first1) && !(*first1 < *m2);\n\tif (!result) {\n\t\t// ?\n\t\twhile (first2 != m2 && !(*m1 < *first2)) {\n\t\t\t++first2;\n\t\t}\n\t\tfirst1 = m1;\n\t\tstd::iter_swap(first1, first2);\n\t\t++first1;\n\t\t++first2;\n\t}\n\tif ((first1 != last1) && (first2 != last2)) {\n\t\t// ?\n\t\tm1 = last1; m2 = first2;\n\t\twhile ((m1 != first1) && (m2 != last2)) {\n\t\t\tstd::iter_swap(--m1, m2);\n\t\t\t++m2;\n\t\t}\n\t\t// ?\n\t\tstd::reverse(first1, m1);\n\t\tstd::reverse(first1, last1);\n\t\tstd::reverse(m2, last2);\n\t\tstd::reverse(first2, last2);\n\t}\n\treturn !result;\n}\n\ntemplate < class BidirectionalIterator >\nbool next_combination(BidirectionalIterator first,\n\tBidirectionalIterator middle,\n\tBidirectionalIterator last)\n{\n\treturn next_combination(first, middle, middle, last);\n}\n\n\nint main(void) {\n\t/*int N; cin >> N;\n\tvector<pair<int, int>>cs;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, r; cin >> x >> r;\n\t\tint l = x - r; int r = x + r;\n\t\tcs.emplace_back({ l,r });\n\t}\n\tsort(cs.begin(), cs.end(), [](const pair<int, int>l, const int pair<int, int>r) {\n\t\treturn l.first == r.first ? l.second < r.second : l.first < r.first; }));\n\treturn 0;*/\n\n\t/*int H, W; cin >> W >> H;\n\tdp.resize(H+1);\n\tvector<int>s(W,0);\n\ts[0] = Mod(1);\n\tdp[0][s] = Mod(1);\n\tfor (int i = 1; i <= H; ++i) {\n\t\tfor (auto it = dp[i - 1].begin(); it != dp[i - 1].end(); ++it) {\n\t\t\tvector<int>pre((*it).first);\n\t\t\tfor (int j = 0; j < (1 <<( W)); ++j) {\n\t\t\t\tbitset<6>bs(j);\n\t\t\t\tvector<int>now(W);\n\t\t\t\tint num = 2;\n\t\t\t\tfor (int k = 0; k < W; ++k) {\n\t\t\t\t\tif (bs[k]) {\n\t\t\t\t\t\tnow[k] = num;\n\t\t\t\t\t\tnum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < W; ++k) {\n\t\t\t\t\tif (now[k] && pre[k]) {\n\t\t\t\t\t\tnow[k] = pre[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < W - 1; ++k) {\n\t\t\t\t\tif (now[k] && now[k + 1]) {\n\t\t\t\t\t\tint amin = min(now[k], now[k + 1]);\n\t\t\t\t\t\tnow[k] = amin;\n\t\t\t\t\t\tnow[k + 1] = amin;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int k = W - 1; k > 0; --k) {\n\t\t\t\t\tif (now[k] && now[k - 1]) {\n\t\t\t\t\t\tint amin = min(now[k], now[k - 1]);\n\t\t\t\t\t\tnow[k] = amin;\n\t\t\t\t\t\tnow[k - 1] = amin;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint nnum = 2;\n\t\t\t\tfor (int k = 0; k < W; ++k) {\n\t\t\t\t\tif (now[k]>=2) {\n\t\t\t\t\t\tint aa = now[k];\n\t\t\t\t\t\tfor (int l = 0; l < W; ++l) {\n\t\t\t\t\t\t\tif (now[l] == aa)now[l] = nnum;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnnum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbool isok = false;\n\t\t\t\tfor (int k = 0; k < W; ++k) {\n\t\t\t\t\tif (now[k] == 1) {\n\t\t\t\t\t\tisok = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isok) {\n\n\t\t\t\t\tdp[i][now] += (*it).second;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\tMod ans(0);\n\tfor (auto it = dp[H].begin(); it != dp[H].end(); ++it) {\n\t\tif ((*it).first[W - 1] == 1) {\n\t\t\tans += (*it).second;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;*/\n\n\t/*int k = 0;\n\twhile (1) {\n\n\t\tk++;\n\t\tint a; cin >> a;\n\t\tif (a) {\n\t\t\tcout << \"Case \" << k << \": \" << a << endl;\n\t\t}\n\t\telse {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;*/\n\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<string>sts;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tsts.emplace_back(st);\n\t\t}\n\t\tint alphanum=0;\n\t\tvector<bool>ex(26, false);\n\t\tvector<bool>start(26, false);\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif(sts[i].size()!=1)\n\t\t\t\tstart[sts[i][0] - 'A'] = true;\n\t\t\tfor (int j = 0; j < sts[i].size(); ++j) {\n\t\t\t\tif (ex[sts[i][j] - 'A']) {\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\talphanum++;\n\t\t\t\t\tif (alphanum > 10) {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t}\n\t\t\t\t\tex[sts[i][j] - 'A'] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>perm(10);\n\t\tfor (int i = 0; i < 10; ++i) {\n\t\t\tperm[i] = i;\n\t\t}\n\t\t\n\t\tint ansnum = 0;\n\t\tdo {\n\t\t\tmap<char, int>mp;\n\t\t\tint k = 0;\n\t\t\tbool isok = true;\n\t\t\tvector<int>to(26);\n\t\t\tfor (int i = 0; i < 26; ++i) {\n\t\t\t\tif (ex[i]) {\n\t\t\t\t\tif (perm[k] == 0) {\n\t\t\t\t\t\tif (start[i])isok = false;\n\t\t\t\t\t}\n\t\t\t\t\tto[i] = perm[k];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(k == alphanum);\n\t\t\tif (!isok)continue;\n\t\t\tlong long int ans = 0;\n\t\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\t\tint num = 1;\n\t\t\t\tfor (int j = sts[i].size() - 1; j >= 0; --j) {\n\t\t\t\t\tans += num*to[sts[i][j]-'A'];\n\t\t\t\t\tnum *= 10;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint num = 1;\n\t\t\tfor (int j = sts[N - 1].size() - 1; j >= 0; --j) {\n\t\t\t\tans -= num*to[sts[N - 1][j]-'A'];\n\t\t\t\tnum *= 10;\n\t\t\t}\n\t\t\tif (!ans) {\n\t\t\t\tansnum++;\n\t\t\t}\n\t\t} while (next_permutation(perm.begin(), perm.end()));\n\t\tfor (int j = 10 - alphanum; j != 0; --j) {\n\t\t\tansnum /= j;\n\t\t}\n\t\tcout << ansnum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v);\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v);\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream&, const tuple<T...>&){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream& os, const tuple<T...>& t){ os << (n==0?\"\":\" \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream& operator<<(ostream& os, const tuple<T...>& t){ _ot<0>(os, t); return os; }\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _it(istream&, tuple<T...>&){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _it(istream& is, tuple<T...>& t){ is >> get<n>(t); _it<n+1>(is, t); }\ntemplate<class...T> istream& operator>>(istream& is, tuple<T...>& t){ _it<0>(is, t); return is; }\ntemplate<class T> istream& operator>>(istream& is, vector<T>& v){ rep(i,v.size()) is >> v[i]; return is; }\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){ rep(i,v.size()) os << v[i] << (i+1==(int)v.size()?\"\":\" \"); return os; }\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<mt(__VA_ARGS__)<<\" [\"<<__LINE__<<\"]\"<<endl)\n#else\n#define dump(...)\n#endif\n\ntypedef int Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nGraph g;\n\nint vis[40010];\n\nbool dfs(int v, int c){\n    vis[v] = c;\n    for(Edge & e : g[v]){\n        int d = e.dst;\n        if(vis[d]!=-1){\n            if(v/2==d/2 && vis[v]==vis[d]) return false;\n            if(v/2!=d/2 && vis[v]!=vis[d]) return false;\n        } else {\n            if(v/2==d/2 && !dfs(d,1-c)) return false;\n            if(v/2!=d/2 && !dfs(d,c)) return false;\n        }\n    }\n    return true;\n}\n\nint main(){\n    int n;\n    while(cin>>n && n){\n        vector<ll> v(n*2);\n        g.assign(n*2,{});\n        map<ll,int> id;\n        rep(i,n){\n            ll x,y; char c;\n            cin >> x >> y >> c;\n            ll xx=x, yy=y;\n            if(c=='y')yy++;\n            else xx++;\n            v[i*2] = x<<32|y;\n            v[i*2+1] = xx<<32|yy;\n            id[x<<32|y] = i*2;\n            id[xx<<32|yy] = i*2+1;\n        }\n        sort(all(v));\n        rep(i,n*2-1){\n            ll x,y;\n            ll xx,yy;\n            tie(x,y) = mt(v[i]>>32,v[i]&0xFFFFFFFF);\n            tie(xx,yy) = mt(v[i+1]>>32,v[i+1]&0xFFFFFFFF);\n            if(abs(x-xx)+abs(y-yy)==1){\n                int a=id[v[i]], b=id[v[i+1]];\n                g[a].eb(a,b,0);\n                g[b].eb(b,a,0);\n            }\n        }\n        sort(all(v), [](ll a, ll b){\n                ll x,y;\n                ll xx,yy;\n                tie(x,y) = mt(a>>32, a&0xFFFFFFFF);\n                tie(xx,yy) = mt(b>>32, b&0xFFFFFFFF);\n                return y!=yy ? y<yy : x<xx;\n            });\n        rep(i,n*2-1){\n            ll x,y;\n            ll xx,yy;\n            tie(x,y) = mt(v[i]>>32,v[i]&0xFFFFFFFF);\n            tie(xx,yy) = mt(v[i+1]>>32,v[i+1]&0xFFFFFFFF);\n            if(abs(x-xx)+abs(y-yy)==1){\n                int a=id[v[i]], b=id[v[i+1]];\n                g[a].eb(a,b,0);\n                g[b].eb(b,a,0);\n            }\n        }\n        memset(vis,-1,sizeof(vis));\n        bool ok = true;\n        rep(i,n*2) if(vis[i]==-1){\n            ok &= dfs(i,0);\n            if(!ok) break;\n        }\n        puts(ok ? \"Yes\" : \"No\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nchar c;\nint x[20001][2],y[20001][2];\nvector<int>v[40001];\nint b[40001],f,n;\nvoid dfs(int p,int col){\n  b[p]=col;\n  r(i,v[p].size()){\n    if(!(p==v[p][i]+n||p+n==v[p][i])&&b[v[p][i]]&&b[v[p][i]]!=col)f++;\n    else if(!b[v[p][i]]){\n      if(p==v[p][i]+n||p+n==v[p][i]){\n        if(col==1)dfs(v[p][i],2);\n        else dfs(v[p][i],1);\n      }\n      else dfs(v[p][i],col);\n    }\n  }\n}\nint main(){\n  while(cin>>n,n){\n    memset(b,0,sizeof(b));\n    r(i,40001)v[i].clear();\n    r(i,n){\n      cin>>x[i][0]>>y[i][0]>>c;\n      if(c=='x')x[i][1]=x[i][0]+1,y[i][1]=y[i][0];\n      else x[i][1]=x[i][0],y[i][1]=y[i][0]+1;\n    }\n    r(i,n)v[i].push_back(i+n);\n    r(i,n)r(j,n)if(i!=j)r(l,2)r(k,2){\n      if(abs(x[i][l]-x[j][k])+abs(y[i][l]-y[j][k])==1){\n        int p1=i,p2=j;\n        if(l)p1+=n;\n        if(k)p2+=n;\n        v[p1].push_back(p2);\n      }\n    }\n    f=0;\n    r(i,n*2)if(!b[i])dfs(i,1);\n    cout<<(f?\"No\":\"Yes\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int, int> P;\ntypedef pair<P, int> Pp;\n\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n\nint n;\nmap<int, int> G[100000];\nmap<int, int> used[100000];\nmap<int, int> zipx, zipy;\nbool f = false;\n\nvoid dfs(int x, int y, int c) {\n  // cout << x << \" \" << y << \" \" << c << endl;\n  if ( f ) return;\n  int zx = zipx[x], zy = zipy[y];  \n  if ( !G[zx][zy] ) return;  \n  if ( used[zx][zy] && used[zx][zy] != c ) {    \n    f = true;\n    return;    \n  } else if ( used[zx][zy] ) {\n    return;    \n  }\n  used[zx][zy] = c;\n  int d = G[zx][zy]-1;  \n  for ( int i = 0; i < 4; i++ ) {\n    int nx = x+dx[i], ny = y+dy[i];    \n    if ( d == i ) {\n      dfs(nx, ny, 3-c);      \n    } else {\n      dfs(nx, ny, c);      \n    }\n  }\n}\n\nsigned main() {\n  while ( cin >> n, n ) {\n    for ( int i = 0; i < 100000; i++ ) {\n      G[i].clear();\n      used[i].clear();\n    }\n    zipx.clear(); zipy.clear();\n    f = false;    \n    vector<Pp> dat(n);\n    vector<int> X, Y;  \n    for ( int i = 0; i < n; i++ ) {\n      int x, y;\n      char d;\n      cin >> x >> y >> d;\n      dat[i] = (Pp(P(x, y), d == 'y'));    \n      X.emplace_back(x);\n      X.emplace_back(x+1);\n      X.emplace_back(x-1);\n      Y.emplace_back(y);\n      Y.emplace_back(y+1);\n      Y.emplace_back(y-1);\n    }\n\n    {\n      sort(X.begin(), X.end());\n      X.erase(unique(X.begin(), X.end()), X.end());\n      int cnt = 0;\n      for ( int i = 0; i < X.size(); i++ ) {\n\tzipx[X[i]] = cnt++;\n      }\n    }\n\n    {\n      sort(Y.begin(), Y.end());\n      Y.erase(unique(Y.begin(), Y.end()), Y.end());\n      int cnt = 0;\n      for ( int i = 0; i < Y.size(); i++ ) {\n\tzipy[Y[i]] = cnt++;      \n      }\n    }\n\n    for ( int i = 0; i < n; i++ ) {\n      int x = dat[i].first.first, y = dat[i].first.second, d = dat[i].second;\n      int nx = zipx[x], ny = zipy[y];    \n      if ( d == 0 ) { // x\n\tG[nx][ny] = 2;\n\tG[zipx[x+1]][ny] = 4;\n      } else {\n\tG[nx][ny] = 1;\n\tG[nx][zipy[y+1]] = 3;      \n      }\n    }\n\n    for ( int i = 0; i < n; i++ ) {\n      int x = dat[i].first.first, y = dat[i].first.second, d = dat[i].second;\n      int nx = zipx[x], ny = zipy[y];\n      if ( used[nx][ny] ) continue;\n      dfs(x, y, 1);\n      if ( f ) break;    \n    }\n\n    if ( f ) cout << \"No\" << endl;\n    else cout << \"Yes\" << endl;  \n  }  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nclass UnionFind {\npublic:\n  vector<int> par, rank; // parent(negative := its root and abs-value is its size), depth\n  UnionFind(int sz) : par(sz, -1), rank(sz, 0){}\n  int find(int x){\n    if(par[x]<0) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;  // already belong to same tree\n    if(rank[x] < rank[y]){  // y becomes parent node\n      par[y] += par[x];\n      par[x] = y;\n    } else {  // x becomes parent node\n      par[x] += par[y];\n      par[y] = x;\n      if(rank[x]==rank[y]) rank[x]++;\n    }\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int size(int x){ return -par[find(x)]; }\n};\n\nbool solve(int n){\n  vector<int> x(n),y(n),sx,sy;\n  vector<char> dir(n);\n  set<pair<int,int>> occ;\n  rep(i,n){\n    char s[5];\n    scanf(\"%d %d %s\", &x[i], &y[i], s);\n    dir[i] = s[0];\n    sx.pb(x[i]); sx.pb(x[i]+1); sx.pb(x[i]-1);\n    sy.pb(y[i]); sy.pb(y[i]+1); sy.pb(y[i]-1);\n    if(dir[i]=='x') sx.pb(x[i]+2);\n    else sy.pb(y[i]+2);\n  }\n  uniq(sx);\n  uniq(sy);\n  int nx = sx.size();\n  int ny = sy.size();\n  rep(i,n) x[i] = lower_bound(all(sx), x[i]) - sx.begin();\n  rep(i,n) y[i] = lower_bound(all(sy), y[i]) - sy.begin();\n  rep(i,n){\n    occ.insert(mp(x[i],y[i]));\n    if(dir[i]=='x') occ.insert(mp(x[i]+1, y[i]));\n    else occ.insert(mp(x[i], y[i]+1));\n  }\n\n  UnionFind uf(2*nx*ny);\n\n  auto same = [&](int x1, int y1, int x2, int y2){\n    if(occ.count(mp(x1,y1))==0 || occ.count(mp(x2,y2))==0) return true;\n    int n1 = x1*ny + y1, n2 = x2*ny + y2;\n    uf.unite(n1,n2); uf.unite(n1+nx*ny, n2+nx*ny);\n    if(uf.same(n1, n2+nx*ny) || uf.same(n1+nx*ny, n2)) return false;\n    return true;\n  };\n  auto diff = [&](int x1, int y1, int x2, int y2){\n    if(occ.count(mp(x1,y1))==0 || occ.count(mp(x2,y2))==0) return true;\n    int n1 = x1*ny + y1, n2 = x2*ny + y2;\n    uf.unite(n1, n2+nx*ny); uf.unite(n1+nx*ny, n2);\n    if(uf.same(n1, n2) || uf.same(n1+nx*ny, n2+nx*ny)) return false;\n    return true;\n  };\n\n  rep(i,n){\n    if(dir[i]=='x'){\n      if(!same(x[i],y[i], x[i]-1,y[i]) ||\n         !same(x[i],y[i], x[i],y[i]+1) ||\n         !same(x[i],y[i], x[i],y[i]-1) ||\n         !same(x[i]+1,y[i], x[i]+2,y[i]) ||\n         !same(x[i]+1,y[i], x[i]+1,y[i]+1) ||\n         !same(x[i]+1,y[i], x[i]+1,y[i]-1) ||\n         !diff(x[i],y[i], x[i]+1,y[i]) ) return false;\n    }\n    else {\n      if(!same(x[i],y[i], x[i]-1,y[i]) ||\n         !same(x[i],y[i], x[i]+1,y[i]) ||\n         !same(x[i],y[i], x[i],y[i]-1) ||\n         !same(x[i],y[i]+1, x[i]+1,y[i]+1) ||\n         !same(x[i],y[i]+1, x[i]-1,y[i]+1) ||\n         !same(x[i],y[i]+1, x[i],y[i]+2) ||\n         !diff(x[i],y[i], x[i],y[i]+1) ) return false;\n    }\n  }\n  return true;\n}\n\n\nint main(){\n  int n;\n  while(cin>>n, n){\n    if(solve(n)) cout << \"Yes\" <<endl;\n    else cout << \"No\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nstruct futon {\n\tPII cells[2];\n};\n\nvector<futon> futons;\nmap<PII, bool> is_head;\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tfutons.clear();\n\t\tis_head.clear();\n\t\tREP (i, n) {\n\t\t\tint x, y; cin >> x >> y; char d; cin >> d;\n\t\t\tfuton f; f.cells[0] = MP(y, x); f.cells[1] = MP(y+(d=='y'), x+(d=='x'));\n\t\t\tfutons.PB(f);\n\t\t}\n\t\tREP (i, n) {\n\t\t\tPII p = futons[i].cells[0];\n\t\t\t// Look around\n\t\t\tbool free = true, adj_head = false;\n\t\t\tREP (d, 4) {\n\t\t\t\tint y = p.F + dy[d], x = p.S + dx[d];\n\t\t\t\tif (EXIST(is_head, MP(y, x))) {\n\t\t\t\t\tif (free) {\n\t\t\t\t\t\tif (is_head[MP(y, x)] == true) adj_head = true;\n\t\t\t\t\t\telse adj_head = false;\n\t\t\t\t\t\tadj_head = is_head[MP(y, x)];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (is_head[MP(y, x)] == true && !adj_head) goto NO;\n\t\t\t\t\t\telse if (is_head[MP(y, x)] == false && adj_head) goto NO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Opposite cell\n\t\t\tbool head = !adj_head;\n\t\t\tPII op = futons[i].cells[1];\n\t\t\t// Look around\n\t\t\tREP (d, 4) {\n\t\t\t\tint y = op.F + dy[d], x = op.S + dx[d];\n\t\t\t\tif (EXIST(is_head, MP(y, x))) {\n\t\t\t\t\tif (is_head[MP(y, x)] == true && !head) goto NO;\n\t\t\t\t\telse if (is_head[MP(y, x)] == false && head) goto NO;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Here is valid\n\t\t\tis_head[MP(p.F, p.S)] = adj_head;\n\t\t\tis_head[MP(op.F, op.S)] = head;\n\t\t}\nYES:\n\t\tcout << \"Yes\" << endl;\n\t\tcontinue;\nNO:\n\t\tcout << \"No\" << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct SCC{\n    int V;\n    vector<vector<int>> G, rG;\n    vector<int> vs; // ??°?????????????????????\n    vector<int> cmp; //?±????????????£?????????????????????????????????\n    vector<bool> used;\n\n    SCC(){}\n    SCC(int n){\n        V = n;\n        G = vector<vector<int>>(n);\n        rG = vector<vector<int>>(n);\n    }\n\n    void add_edge(int from, int to){\n        G[from].push_back(to);\n        rG[to].push_back(from);\n    }\n\n    void dfs(int v){\n        used[v] = true;\n        rep(i,G[v].size())if(!used[G[v][i]]) dfs(G[v][i]);\n        vs.push_back(v);\n    }\n\n    void rdfs(int v, int k){\n        used[v]=true;\n        cmp[v]=k;\n        rep(i,rG[v].size())if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n    }\n\n    int scc(){\n        used = vector<bool>(V,false);\n        vs.clear();\n        rep(i,V)if(!used[i]) dfs(i);\n\n        used = vector<bool>(V,false);\n        cmp = vector<int>(V);\n        int num_scc = 0;\n        for(int i=vs.size()-1; i>=0; --i)if(!used[vs[i]]) rdfs(vs[i],num_scc++);\n        return num_scc;\n    }\n};\n\nstruct TwoSat{\n    int v;\n    SCC graph;\n\n    // v literals\n    // 0~v-1: true\n    // v~2v-1: false\n\n    TwoSat(int num_literal){\n        v = num_literal;\n        graph = SCC(2*v);\n    }\n\n    inline int num(int id, bool b){return id+(b?0:v);}\n\n    void add_clause(int x, bool X, int y, bool Y){\n        graph.add_edge(num(x,!X), num(y,Y));\n        graph.add_edge(num(y,!Y), num(x,X));\n    }\n\n    // ?????????????????????????????????\n    bool calc(){\n        graph.scc();\n        rep(i,v)if(graph.cmp[i]==graph.cmp[v+i]) return false;\n        return true;\n    }\n\n    // ?????????????????????????????????\n    vector<bool> get_literals(){\n        assert(calc());\n        vector<bool> res(v);\n        rep(i,v) res[i] = (graph.cmp[i]>graph.cmp[v+i]);\n        return res;\n    }\n};\n\nusing pi = pair<int,int>;\nint dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};\n\nint main()\n{\n    int n;\n    while(cin >>n,n)\n    {\n        vector<vector<pi>> v(n);\n        map<pi,pi> m;\n        rep(i,n)\n        {\n            int x,y;\n            char d;\n            cin >>x >>y >>d;\n\n            v[i].pb({x,y});\n            if(d=='x') v[i].pb({x+1,y});\n            else v[i].pb({x,y+1});\n\n            rep(j,2) m[v[i][j]] = {i,j};\n        }\n\n        TwoSat solver(n);\n        rep(i,n)rep(j,2)rep(k,4)\n        {\n            int nx = v[i][j].fi+dx[k];\n            int ny = v[i][j].se+dy[k];\n            if(m.count({nx,ny}))\n            {\n                pi p = m[{nx,ny}];\n                int id = p.fi;\n                int b = p.se;\n                if(id == i) continue;\n\n                solver.add_clause(i,j,id,!b);\n            }\n        }\n\n        cout << (solver.calc()?\"Yes\":\"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int N = 20000;\n\nint n, data[N];\nchar d[N];\nvector<P> points;\nmap<P, P> id;\nbool ans, used[N];\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nvoid dfs(int pos, int c){\n  if(!ans) return;\n  used[pos] = true;\n  data[pos] = c;\n  P p[2];\n  p[0] = p[1] = points[pos];\n  if(d[pos] == 'x') p[1].second++;\n  else p[1].first++;\n  for(int i=0;i<2;i++){\n    for(int j=0;j<4;j++){\n      P np = P(p[i].first + dy[j], p[i].second + dx[j]);\n      if(np == p[1-i]) continue;\n      if(id.count(np)){\n        if(used[id[np].first]){\n          if(i^id[np].second && data[id[np].first] == data[pos]) ans = false;\n          if(!(i^id[np].second) && data[id[np].first] != data[pos]) ans = false;\n        }\n        if(!used[id[np].first]) dfs(id[np].first, i^id[np].second^c);\n      }\n    }\n  }\n}\n\nvoid init(){\n  ans = true;\n  id.clear();\n  points.clear();\n  for(int i=0;i<N;i++){\n    used[i] = false;\n    data[i] = -1;\n  }\n}\n\nmain(){\n  while(cin >> n && n){\n    init();\n    for(int i=0;i<n;i++){\n      P in;\n      cin >> in.second >> in.first >> d[i];\n      points.push_back(in);\n      id[in] = P(i, 0);\n      if(d[i] == 'x') in.second++;\n      else in.first++;\n      id[in] = P(i, 1);      \n    }\n    for(int i=0;i<n;i++) if(!used[i]) dfs(i, 0);\n    cout << (ans ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(_vs) for(auto _x : _vs){cout << _x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(_p) cout << _p.first << \" \" << _p.second << endl\n#define printVP(_vp) for(auto _p : _vp) printP(_p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {;\n        rep(i, n) {\n            int x, y;\n            char dir;\n            cin >> x >> y >> dir;\n        }\n        rep(i, n) {\n            rep(j, n) {\n                ;\n            }\n        }\n        cout << \"Yes\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<set>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst int N =20000;\nenum{UNDEFINED=-1,HEAD=0,TAIL=1};\nclass st{\npublic:\n  int data[2];\n  \n};\nstruct Edge{int t,type;};\nclass tri{\npublic:\n  int ind,x,y,type;\n  bool operator<(const tri & a)const{\n    if (x != a.x)return x < a.x;\n    return y < a.y;\n  }\n};\n\nbool vis[N];\nst in[N];\nvector<Edge> edge[N][2];\n\nbool search(int now,int type,int which){\n  if (vis[now]){\n    return in[now].data[type] == which;\n  }\n  vis[now]=true;\n  in[now].data[type]=which;\n  in[now].data[1-type]=1-which;\n  //cout << \"ch \" << now <<\" \" << type <<\" \" << which << endl;\n  //cout << now <<\" \" << in[now].data[0]<<\" \" << in[now].data[1] << endl;\n  rep(i,2){\n    rep(j,(int)edge[now][i].size()){\n      if (!search(edge[now][i][j].t,edge[now][i][j].type,i == type?which:1-which))return false;\n    }\n  }\n  return true;\n}\n\nbool solve(int n){\n  rep(i,n)vis[i]=false;\n  rep(i,n){\n    if (!vis[i]){\n      if (!search(i,HEAD,HEAD))return false;\n    }\n  }\n  return true;\n}\n\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nvoid makeedge(int ind,int x,int y,int type,set<tri> &S){\n  rep(i,4){\n    int nex=x+dx[i],ney=y+dy[i];\n    set<tri>::iterator itr = S.find((tri){-1,nex,ney,-1});\n    if (itr == S.end())continue;\n    edge[ind][type].push_back((Edge){(*itr).ind,(*itr).type});\n    edge[(*itr).ind][(*itr).type].push_back((Edge){ind,type});\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    rep(i,n){\n      edge[i][0].clear(),edge[i][1].clear();\n      in[i].data[0]=in[i].data[1]=UNDEFINED;\n    }\n    set<tri> S;\n    rep(i,n){\n      int y,x;char c;\n      cin>>x>>y>>c;\n      makeedge(i,x,y,HEAD,S);\n      if (c == 'x')makeedge(i,x+1,y,TAIL,S);\n      else makeedge(i,x,y+1,TAIL,S);\n      S.insert((tri){i,x,y,HEAD});\n      if (c == 'x')S.insert((tri){i,x+1,y,TAIL});\n      else         S.insert((tri){i,x,y+1,TAIL});\n    }\n    /*\n    rep(i,n){\n      cout <<\"info \" << i << endl;\n      cout <<\"0\" << endl;\n      rep(j,edge[i][0].size())\n\tcout << edge[i][0][j].t <<\" \" << edge[i][0][j].type << endl;\n      cout <<\"1\"<<endl;\n      rep(j,edge[i][1].size())\n\tcout << edge[i][1][j].t <<\" \" << edge[i][1][j].type << endl;\n\t}\n    */\n\n    if (solve(n))cout <<\"Yes\" << endl;\n    else cout <<\"No\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint N;\nmap<P,P> fie;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nbool solve(int x,int y){\n  P now = fie[P(x,y)];\n  //cout << x << \" \" << y << \" \" << now.first << \" \"<< now.second << endl;\n  int dr[4]={};\n  for(int i=0;i<4;i++){\n    if( fie.count(P(x+dx[i],y+dy[i])) == 0 ) continue;\n    P &st = fie[P(x+dx[i],y+dy[i])];\n    if( st.first == now.first ){\n      if( st.second == 0 ){\n        st.second = now.second==1?2:1;    \n        dr[i] = 1;\n      }\n      else if( st.second == now.second )\n        return false;\n    } else {\n      if( st.second == 0 ){\n        st.second = now.second == 1?1:2;        \n        dr[i] = 1;\n      } else if( st.second != now.second )\n        return false;             \n    }\n  }\n\n  for(int i=0;i<4;i++)\n    if( dr[i] == 1 )\n      if( !solve( x + dx[i] , y + dy[i] ) ) return false;\n    \n  \n  return true;\n}\n\nint main(){\n  while( cin >> N && N){\n    fie.clear();\n    for(int i=0;i<N;i++){\n      int x,y;char c;\n      cin >> x >> y >> c;\n      if( c == 'y' ){\n        fie[P(x,y)] = P(i,0);\n        fie[P(x+1,y)] = P(i,0);\n      } else {\n        fie[P(x,y)] = P(i,0);\n        fie[P(x,y+1)] = P(i,0);\n      }\n    }\n\n\n    bool f = true;\n    for(map<P,P>::iterator it = fie.begin(); it != fie.end(); it++){\n      int x = it->first.first;\n      int y = it->first.second;\n  \n      if( it->second.second == 0 ){\n        it->second.second = 1;\n        if( !solve(x,y) ) {\n          f = false;\n          //cout << x << \" \"<< y <<\" \"<<it->second.first << \" \"<<it->second.second<< endl;\n          break;\n        }\n      }\n      //      cout << x << \" \"<< y <<\" \"<<it->second.first << \" \"<<it->second.second<< endl;\n    }\n    if( f ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct union_find {\n  int H, W;\n  vector<int> rank_, size_, rid_;\n  union_find(int h, int w) { H = h + 10, W = w + 10; rank_.resize(H*W); rid_.assign(H*W, -1); size_.resize(H*W, 1); }\n  void operator()(pair<int, int> x, pair<int, int> y) {\n    int u = x.first * W + x.second;\n    int v = y.first * W + y.second;\n    u = operator[](u), v = operator[](v);\n    if(u == v) { return; }\n    size_[u] = size_[v] = size_[u] + size_[v];\n    if(rank_[u] < rank_[v]) { rid_[u] = v; }\n    else { rid_[v] = u; if(rank_[u] == rank_[v]) { rank_[u]++; } }    \n  }\n  int operator[](pair<int, int> a) { int x = a.first * W + a.second; return operator[](operator[](x)); }\n  int size_of(int x) { return size_[x]; }\nprivate:\n  int operator[](int x) { if(rid_[x] < 0) return x; else return rid_[x] = operator[](rid_[x]); }\n};\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint main() {\n  \n  for(int N; cin >> N && N;) {\n    vector<int> fx(N), fy(N); vector<char> fd(N);\n    vector<int> xs, ys;\n    rep(i, N) {\n      cin >> fx[i] >> fy[i] >> fd[i];\n      REP(d,-1,2) xs.push_back(fx[i]+d), ys.push_back(fy[i]+d);\n    }\n\n    sort(all(xs)); xs.erase(unique(all(xs)), xs.end());\n    sort(all(ys)); ys.erase(unique(all(ys)), ys.end());\n\n    const int H = ys.size();\n    const int W = xs.size();\n\n    map<int, int> X, Y;\n    rep(i, xs.size()) X[xs[i]] = i;\n    rep(i, ys.size()) Y[ys[i]] = i;\n\n    union_find uf(H, W);\n\n    set<pair<int, int>> st;\n\n    rep(i, N) {\n      assert(X.find(fx[i])!=X.end());\n      assert(Y.find(fy[i])!=Y.end());\n      fx[i] = X[fx[i]];\n      fy[i] = Y[fy[i]];\n    }\n\n    rep(i, N) {\n      st.emplace(fy[i], fx[i]);\n      if(fd[i] == 'x') {\n        st.emplace(fy[i], fx[i] + 1);\n      } else {\n        st.emplace(fy[i] + 1, fx[i]);\n      }\n    }\n\n    rep(i, N) {\n      if(fd[i] == 'x') {\n        auto po = make_pair(fy[i], fx[i]);\n        rep(k, 4) if(dx[k] != +1) {\n          auto np = make_pair(fy[i] + dy[k], fx[i] + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n        po = make_pair(fy[i], fx[i] + 1);\n        rep(k, 4) if(dx[k] != -1) {\n          auto np = make_pair(fy[i] + dy[k], fx[i] + 1 + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n      }\n      else {\n        auto po = make_pair(fy[i], fx[i]);\n        rep(k, 4) if(dy[k] != +1) {\n          auto np = make_pair(fy[i] + dy[k], fx[i] + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n\n        po = make_pair(fy[i] + 1, fx[i]);\n        rep(k, 4) if(dy[k] != -1) {\n          auto np = make_pair(fy[i] + 1 + dy[k], fx[i] + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n      }\n    }\n\n    bool ok = 1;\n    rep(i, N) {\n      auto a = make_pair(fy[i], fx[i]);\n      if(fd[i] == 'x') {\n        auto b = make_pair(fy[i], fx[i] + 1);\n        ok &= uf[a] != uf[b];\n      }\n      else {\n        auto b = make_pair(fy[i] + 1, fx[i]);\n        ok &= uf[a] != uf[b];\n      }\n    }\n\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nstruct Edge{\n\tint src,dst;\n\tEdge(){}\n\tEdge(int s,int d):src(s),dst(d){}\n};\ntypedef vector<vector<Edge>> Graph;\n\nbool ok(const map<pii,int>& ishead,pii head,pii foot)\n{\n\tfor(int i=0;i<4;i++){\n\t\tint nx,ny;\n\t\tnx=head.first+\"\\xff\\x1\\0\\0\"[i],ny=head.second+\"\\0\\0\\xff\\x1\"[i];\n\t\tif(pii(nx,ny)!=foot && ishead.count(pii(nx,ny)) && !ishead.at(pii(nx,ny)))\n\t\t\treturn false;\n\t\tnx=foot.first+\"\\xff\\x1\\0\\0\"[i],ny=foot.second+\"\\0\\0\\xff\\x1\"[i];\n\t\tif(pii(nx,ny)!=head && ishead.count(pii(nx,ny)) && ishead.at(pii(nx,ny)))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool dfs(const vector<pair<pii,pii>>& ps,const Graph& g,int v,vector<int>& vis,map<pii,int>& ishead)\n{\n\tif(vis[v]) return true;\n\tvis[v]=1;\n\t\n\tif(ok(ishead,ps[v].first,ps[v].second))\n\t\tishead[ps[v].first]=1,ishead[ps[v].second]=0;\n\telse if(ok(ishead,ps[v].second,ps[v].first))\n\t\tishead[ps[v].second]=1,ishead[ps[v].first]=0;\n\telse\n\t\treturn false;\n\t\n\tfor(Edge e:g[v])\n\t\tif(!dfs(ps,g,e.dst,vis,ishead))\n\t\t\treturn false;\n\treturn true;\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvector<pair<pii,pii>> ps(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint x,y; char d; cin>>x>>y>>d;\n\t\t\tps[i].first=pii(x,y);\n\t\t\tif(d=='x')\n\t\t\t\tps[i].second=pii(x+1,y);\n\t\t\telse\n\t\t\t\tps[i].second=pii(x,y+1);\n\t\t}\n\t\t\n\t\tmap<pii,int> grid;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tgrid[ps[i].first]=i;\n\t\t\tgrid[ps[i].second]=i;\n\t\t}\n\t\t\n\t\tGraph g(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\tint cx=(!j?ps[i].first:ps[i].second).first;\n\t\t\t\tint cy=(!j?ps[i].first:ps[i].second).second;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint nx=cx+\"\\xff\\x1\\0\\0\"[k];\n\t\t\t\t\tint ny=cy+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\t\tif(!grid.count(pii(nx,ny))) continue;\n\t\t\t\t\tint v=grid.at(pii(nx,ny));\n\t\t\t\t\tif(v!=i){\n\t\t\t\t\t\tg[i].emplace_back(i,v);\n\t\t\t\t\t\tg[v].emplace_back(v,i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tmap<pii,int> ishead;\n\t\tvector<int> vis(n);\n\t\tbool res=true;\n\t\tfor(int i=0;i<n;i++) if(!vis[i])\n\t\t\tres&=dfs(ps,g,i,vis,ishead);\n\t\tcout<<(res?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int sz = 100010;\nvector<int> G[sz];\nvector<int> rG[sz];\nint cmp[sz];\nbool visit[sz];\n\nvoid dfs(int v, vector<int> &vs){\n  visit[v] = true;\n  REP(i, G[v].size()){\n    if(!visit[G[v][i]]) dfs(G[v][i], vs);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n  visit[v] = true;\n  cmp[v] = k;\n  REP(i, rG[v].size()) if(!visit[rG[v][i]]) rdfs(rG[v][i], k);\n}\n\nint scc(int V){\n  REP(i, sz) rG[i].clear();\n  REP(i, V)REP(j, G[i].size()) rG[G[i][j]].push_back(i);\n  \n  int k = 0;\n  vector<int> vs;\n  \n  memset(visit, false, sizeof(visit));  \n  REP(i, V) if(!visit[i]) dfs(i, vs);\n  memset(visit, false, sizeof(visit));\n  reverse(ALL(vs));\n  REP(i, vs.size()){\n    if(!visit[vs[i]]){\n      rdfs(vs[i], k++);\n    }\n  }\n  return k;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    \n    REP(i, sz) G[i].clear();\n        \n    char dir;\n    vector<int> x(n * 2);\n    vector<int> y(n * 2);\n    vector<int> d(n * 2);\n    \n    REP(i, n){\n      cin >> x[i] >> y[i] >> dir;\n      x[i+n] = x[i];\n      y[i+n] = y[i];\n      if(dir == 'x'){\n        x[i+n]++;\n        d[i] = 0;\n        d[i+n] = 2;\n      }\n      \n      if(dir == 'y'){\n        y[i+n]++;\n        d[i] = 1;\n        d[i+n] = 3;\n      }\n    }\n    \n    n *= 2;\n    map<P, int> futon;    \n    REP(i, n) futon[P(x[i], y[i])] = i;\n    \n    REP(i, n){\n      int dx[4] = {1, 0, -1, 0};\n      int dy[4] = {0, 1, 0, -1};     \n      REP(j, 4){\n        int xa = x[i] + dx[j];\n        int ya = y[i] + dy[j];\n\n        if(futon.find(P(xa, ya)) != futon.end()){\n          int f = futon[P(xa, ya)];\n\n          if(j == d[i]){\n            G[i].push_back(f + n);\n            G[f].push_back(i + n);\n            G[i + n].push_back(f);\n            G[f + n].push_back(i);\n          }else{\n            G[i+n].push_back(f+n);\n            G[f+n].push_back(i+n);            \n          }\n        }\n      }\n    }\n\n    bool possible = true;\n    scc(2 * n);\n    REP(i, n){\n      possible &= cmp[i] != cmp[n + i];\n    }\n    cout << (possible ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nmap<PII,PII> mp;\nbool dfs(PII pos, map<PII,int>& vis){\n  int c = vis[pos];\n  PII pos2 = mp[pos];\n  REP(i,4){\n\tPII t = pos;\n\tt.first += dx[i], t.second += dy[i];\n\tif(t == pos2 || !mp.count(t)) continue;\n\tif(vis[t] == -1){\n\t  vis[t] = c;\n\t  vis[mp[t]] = 1-c;\n\t  if(!dfs(t,vis)){\n\t\tvis[t] = vis[mp[t]] = -1;\n\t\treturn false;\n\t  }\n\t}\n\telse if(vis[t] != c)\n\t  return false;\n  }\n\n  c = 1 - c;\n  REP(i,4){\n\tPII t = pos2;\n\tt.first += dx[i], t.second += dy[i];\n\tif(t == pos || !mp.count(t)) continue;\n\tif(vis[t] == -1){\n\t  vis[t] = c;\n\t  vis[mp[t]] = 1-c;\n\t  if(!dfs(t,vis)){\n\t\tvis[t] = vis[mp[t]] = -1;\n\t\treturn false;\n\t  }\n\t}\n\telse if(vis[t] != c)\n\t  return false;\n  }\n\n  return true;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tmp.clear();\n\tREP(i,N){\n\t  int x, y; char c; cin >> x >> y >> c;\n\t  if(c == 'x'){\n\t\tmp[MP(x,y)] = MP(x+1,y);\n\t\tmp[MP(x+1,y)] = MP(x,y);\n\t  }\n\t  else{\n\t\tmp[MP(x,y)] = MP(x,y+1);\n\t\tmp[MP(x,y+1)] = MP(x,y);\n\t  }\n\t}\n\n\tmap<PII,int> vis;\n\tfor(auto it=mp.begin();it!=mp.end();++it){\n\t  vis[it->first] = -1;\n\t}\n\n\tbool ans = true;\n\tfor(auto it=mp.begin();it!=mp.end();++it){\n\t  if(vis[it->first] >= 0) continue;\n\t  vis[it->first] = 0, vis[mp[it->first]] = 1;\n\t  if(dfs(it->first, vis)) continue;\n\t  vis[it->first] = 1, vis[mp[it->first]] = 0;\n\t  if(dfs(it->first, vis)) continue;\n\t  ans = false;\n\t  break;\n\t}\n\n\tcout << (ans? \"Yes\": \"No\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint N;\ntypedef pair<int, int> pii;\n\nint const INF = 1e9+10;\n\nint main() {\n\n  while(cin >> N && N) {\n    map<int, int> cX, cY;\n    set<pii> nolegs;\n    int xs[N], ys[N]; char dirs[N];\n    rep(i, N) {\n      cin >> xs[i] >> ys[i] >> dirs[i];\n      cX[xs[i]] = cY[ys[i]] = 0;\n      for(int x=-1;x<=1;x++) for(int y=-1;y<=1;y++) cX[xs[i]+x] = cY[ys[i]+y] = 0;\n//      if(dirs[i]=='x') { cX[xs[i]+1] = cY[ys[i]-1] = cY[ys[i]+1] = 0; }\n//      if(dirs[i]=='y') { cY[ys[i]-1] = cX[xs[i]-1] = cX[xs[i]+1] = 0; }\n    }\n    cX[-INF] = cY[-INF] = cX[INF] = cY[INF] = 0;\n    { int cnt = 0; for(auto& e: cX) { e.second = cnt++; } }\n    { int cnt = 0; for(auto& e: cY) { e.second = cnt++; } }\n\n    bool ok = true;\n    rep(i, N) {\n      pii legs = {cX[xs[i]], cY[ys[i]]};\n      if(dirs[i]=='x') {\n        for(int d=-1;d<=1;d+=2) {\n          if(nolegs.count(legs)) { ok = false; }\n          pii h_adj = {cX[xs[i]+1], cY[ys[i]+d]};\n          nolegs.insert(h_adj);\n        }\n      }\n      if(dirs[i]=='y') {\n        for(int d=-1;d<=1;d+=2) {\n          if(nolegs.count(legs)) { ok = false; }\n          pii h_adj = {cX[xs[i]+d], cY[ys[i]-1]};\n          nolegs.insert(h_adj);\n        }\n      }\n    }\n    puts(ok ? \"Yes\" : \"No\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n;\nP p[2][20100];\nchar d;\nvector<P> g[20100];\nint vis[20100];\n\nvoid add_edge(int u,int v,int col){\n  g[v].push_back(P(u,col));\n  g[u].push_back(P(v,col));\n}\n\nint md(P a, P b){\n  return abs(a.first-b.first) + abs(a.second-b.second);\n}\n\nbool dfs(int v,int col){\n  vis[v] = col;\n\n  for(int i=0;i<g[v].size();i++){\n    int nxt = g[v][i].first, color = g[v][i].second;\n    if(vis[nxt]>=0 && vis[nxt] != col^color)return false;\n    if(vis[nxt]<0 && !dfs(nxt,col^color))return false;\n  }\n  return true;\n}\n\nint main(){\n  cin.tie(0); std::ios::sync_with_stdio(false);\n\n  while(cin >> n,n){\n    for(int i=0;i<n;i++){\n      cin >> p[0][i].first >> p[0][i].second >> d;\n      p[1][i].first = p[0][i].first + (d=='x');\n      p[1][i].second = p[0][i].second + (d=='y');\n    }\n    \n    for(int i=0;i<n;i++)g[i].clear();\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(i==j)continue;\n\tbool f = true;\n\tfor(int ii=0;f,ii<2;ii++){\n\t  for(int jj=0;f,jj<2;jj++){\n\t    if(md(p[ii][i],p[jj][j])==1){\n\t      add_edge(i,j,ii!=jj);\n\t      f = false;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    bool flag = true;\n    memset(vis,-1,sizeof(vis));\n\n    for(int i=0;i<n;i++){\n      if(vis[i]<0)flag &= dfs(i,0);\n      if(!flag)break;\n    }\n    cout << (flag?\"Yes\":\"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nmap<pair<int, int>, pair<int, int>>mp;\nstruct aa {\n\tint x;\n\tint y;\n\tint way;\n\tint foot;\n};\nint main() {\n\twhile (1) {\n\t\tmp.clear();\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y; char c; cin >> x >> y >> c;\n\t\t\tif (c == 'x')\n\t\t\t{\n\t\t\t\tmp[make_pair(x, y)] = make_pair(2, -1);\n\t\t\t\tmp[make_pair(x+1, y)] = make_pair(0, -1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp[make_pair(x, y)] = make_pair(1, -1);\n\t\t\t\tmp[make_pair(x, y+1)] = make_pair(3, -1);\n\t\t\t}\n\n\t\t}\n\t\tbool ok = true;\n\t\tfor (auto& m : mp) {\n\t\t\tif (m.second.second == -1) {\n\t\t\t\tm.second.second = 0;\n\t\t\t\tqueue<aa>que;\n\t\t\t\tque.push(aa{ m.first.first,m.first.second,m.second.first,0 });\n\t\t\n\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\taa atop(que.front());\n\t\t\t\t\tque.pop();\n\t\t\t\t\tconst int nowx = atop.x;\n\t\t\t\t\tconst int nowy = atop.y;\n\t\t\t\t\tconst int nowf = atop.foot;\n\t\t\t\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\t\t\t\tconst int newx = nowx + dx[way];\n\t\t\t\t\t\tconst int newy =nowy+ dy[way];\n\t\t\t\t\t\tconst int newf = way == atop.way ? !nowf : nowf;\n\t\t\t\t\t\tif (mp.find(make_pair(newx, newy)) != mp.end()) {\n\t\t\t\t\t\t\tif (mp[make_pair(newx, newy)].second == -1) {\n\t\t\t\t\t\t\t\tmp[make_pair(newx, newy)].second = newf;\n\t\t\t\t\t\t\t\tque.push(aa{ newx,newy,mp[make_pair(newx,newy)].first,newf });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (mp[make_pair(newx, newy)].second != newf)ok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\nconst int MAX_N=20001;\nint N;\nbool used[2][MAX_N];\nint headAng[2][MAX_N];\nmap<int,map<int,pii> > m;\npii futons[2][MAX_N];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\nbool ok;\n\nvoid dfs(int s,int idx){\n  used[idx][s]=true;\n  pii p=futons[idx][s];\n  int ncol=headAng[idx][s];\n  for(int i=0;i<4;i++){\n    int ny=p.first+dy[i];\n    int nx=p.second+dx[i];\n    if(m.count(ny)>0&&m[ny].count(nx)>0){\n      int ns=m[ny][nx].first;\n      int nidx=m[ny][nx].second;\n      if(ns!=s){\n\tif(headAng[nidx][ns]==-1){\n\t  headAng[nidx][ns]=ncol;\n\t}\n\telse if(headAng[nidx][ns]!=ncol){\n\t  ok=false;\n\t  return;\n\t}\n\tif(!used[nidx][ns])dfs(ns,nidx);\n      }\n      else{\n\tif(headAng[nidx][ns]==-1){\n\t  headAng[nidx][ns]=1^ncol;\n\t}\n\telse if(headAng[nidx][ns]==ncol){\n\t  ok=false;\n\t  return;\n\t}\n\tif(!used[nidx][ns])dfs(ns,nidx);\n      }\n    }\n  }\n}\n\nint main(){\n\n  while(cin>>N&&N){\n    ok=true;\n    memset(used,0,sizeof(used));\n    memset(headAng,-1,sizeof(headAng));\n    m.clear();\n    for(int i=0;i<N;i++){\n      int x,y;\n      char ang;\n      cin>>x>>y>>ang;\n      futons[0][i]=pii(y,x);\n      if(ang=='x')futons[1][i]=pii(y,x+1);\n      else futons[1][i]=pii(y+1,x);\n      m[futons[0][i].first][futons[0][i].second]\n\t=pii(i,0);\n      m[futons[1][i].first][futons[1][i].second]\n\t=pii(i,1);\n    }\n    for(int i=0;i<N;i++){\n      if(used[0][i])continue;\n      headAng[0][i]=0;\n      dfs(i,0);\n      if(!ok)break;\n    }\n    if(ok)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\nint const OppoSide = 0;\nint const SameSide = 1;\n\nint N;\nvector<pair<int, int>> G[44444];\nmap<pair<int, int>, int> MP;\nmap<int, pair<int, int>> CD;\nint vis[44444];\n\nbool dfs(int curr, int col) {\n  for(auto& e: G[curr]) {\n    int next, dir; tie(next, dir) = e;\n    int nextCol = dir == OppoSide ? col ^ 1 : col;\n    if(vis[next] + 1) {\n      if(vis[next] != nextCol) return false;\n    } else {\n      vis[next] = nextCol;\n      if(!dfs(next, nextCol)) return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n\n  for(int M; cin >> M && M;) {\n    vector<int> xs, ys;\n    vector<int> X, Y; vector<char> D;\n    rep(i, M) {\n      int x, y; char d; cin >> x >> y >> d;\n      X.push_back(x), Y.push_back(y), D.push_back(d);\n\n      xs.push_back(x-1),  ys.push_back(y-1);\n      xs.push_back(x),    ys.push_back(y);\n      xs.push_back(x+1),  ys.push_back(y+1);\n\n      if(d == 'x') {\n        xs.push_back(x+2);\n      } else {\n        ys.push_back(y+2);\n      }\n\n    }\n\n    sort(all(xs)); xs.erase(unique(all(xs)), xs.end());\n    sort(all(ys)); ys.erase(unique(all(ys)), ys.end());\n\n    vector<int> NX, NY;\n    rep(i, X.size()) {\n      NX.push_back(lower_bound(all(xs), X[i]) - X.begin());\n    }\n    rep(i, Y.size()) {\n      NY.push_back(lower_bound(all(ys), Y[i]) - Y.begin());\n    }\n    X = NX, Y = NY;\n\n    MP.clear(), CD.clear();\n    rep(i, 40001) G[i].clear();\n    N = 0;\n\n    rep(i, X.size()) {\n      MP[make_pair(Y[i], X[i])] = N;\n      CD[N++] = make_pair(Y[i], X[i]);\n      if(D[i] == 'x') {\n        MP[make_pair(Y[i], X[i]+1)] = N;\n        CD[N] = make_pair(Y[i], X[i]+1);\n        G[N-1].emplace_back(N, OppoSide), G[N].emplace_back(N-1, OppoSide);\n        N++;\n      } else {\n        MP[make_pair(Y[i]+1, X[i])] = N;\n        CD[N] = make_pair(Y[i]+1, X[i]);\n        G[N-1].emplace_back(N, OppoSide), G[N].emplace_back(N-1, OppoSide);\n        N++;\n      }\n    }\n\n    rep(i, N) {\n      auto curr = CD[i];\n      rep(k, 4) {\n        auto next = make_pair(CD[i].first + dy[k], CD[i].second + dx[k]);\n        if(MP.find(next) == MP.end()) continue; // テ・ツクツε・ツ崢」テ」ツ??」ツ?妥ィツェツソテ」ツ?ケテ」ツつ古」ツ?ーOK\n        if(find(all(G[i]), make_pair(MP[next], OppoSide)) != G[i].end()) continue;  // テ・ツ按・テ」ツ?ョテ・ツクツε・ツ崢」テ」ツ?ッSameSideテ」ツ?療」ツ?凝・ツ?・テ」ツつ古」ツつ暗」ツ??」ツ?ィテ」ツ?療」ツ?ェテ」ツ??」ツ?凝」ツつ碓K\n        G[i].emplace_back(MP[next], SameSide);\n      }\n    }\n\n    minus(vis);\n    vis[0] = 0;\n    cout << (dfs(0, 0) ? \"Yes\" : \"No\") << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\n// #define DEBUG\n\n#ifdef DEBUG\n#define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define dump(...)\n#endif\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n\n\nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n\nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing P = tuple<int, int>;\n\nvi used;\nbool res = true;\n\nvector<set<int>> edges;\n\nvoid dfs(int v, int color){\n\tused[v] = color;\n\n\tfor(auto & nv : edges[v]){\n\t\tint ncolor = color * -1;\n\n\t\tif(used[nv] != 0){\n\t\t\tif(used[nv] != ncolor){\n\t\t\t\tres = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(nv, ncolor);\n\n\t\tif(not res) return;\n\t}\n}\n\nint main(void){\n\tfor(int n; cin >> n, n;){\n\t\tres = true;\n\n\t\tmap<P, int> p2i;\n\t\trep(i, n){\n\t\t\tint x, y; char dir;\n\t\t\tcin >> x >> y >> dir;\n\t\t\tint d = dir == 'x' ? 0:1;\n\t\t\tp2i[P(x, y)] = p2i[P(x + dx[d], y + dy[d])] = i;\n\t\t}\n\n\t\tedges = vector<set<int>>(n);\n\t\tfor(auto & e : p2i){\n\t\t\tP p; int v;\n\t\t\ttie(p, v) = e;\n\t\t\tint x, y;\n\t\t\ttie(x, y) = p;\n\n\t\t\trep(d, 4){\n\t\t\t\tint nx = x + dx[d], ny = y + dy[d];\n\n\t\t\t\tif(p2i.find(P(nx, ny)) == end(p2i)) continue;\n\n\t\t\t\tint u = p2i[P(nx, ny)];\n\t\t\t\tif(v == u) continue;\n\t\t\t\tedges[v].insert(u);\n\t\t\t\tedges[u].insert(v);\n\t\t\t}\n\t\t}\n\n\t\tused = vi(n);\n\t\trep(v, n){\n\t\t\tif(used[v] != 0) continue;\n\t\t\tdfs(v, 1);\n\t\t\tif(not res) break;\n\t\t}\n\n\t\tcout << (res ? \"Yes\":\"No\") << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i = (a);i < (b); i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint n;\n\nstruct futon\n{\n  int x, y; bool dir;\n  futon(int x, int y, bool dir) : x(x), y(y), dir(dir) {}\n};\n\nvector<futon> v;\nmap<pair<int, int>, int> mem;\n\nvoid input()\n{\n  v.clear();\n  mem.clear();\n  rep(i, n) {\n    int x, y; char dir;\n    cin >> x >> y >> dir;\n    v.pb(futon(x, y, dir == 'x'));\n    mem[mp(x, y)] = i;\n  }\n}\n\nstruct edge\n{\n  int to, rev;\n  edge(int to, int rev) : to(to), rev(rev) {}\n};\n\nvector<vector<edge> > G;\n\nconst int dx1[] = {-2, -1, -1, 0, 0, 1, 1, 2};\nconst int dy1[] = {0, -1, 1, -1, 1, -1, 1, 0};\nconst int rev1[] = {-1, -1, -1, 1, 1, -1, -1, -1};\n\nconst int dx2[] = {-1, -1, 0, 0, 1, 1, 2, 2};\nconst int dy2[] = {-1, 0, -2, 1, -2, 1, -1, 0};\nconst int rev2[] = {-1, 1, -1, 1, 1, -1, 1, -1};\n\nvoid gen()\n{\n  G.assign(n, vector<edge>());\n  rep(i, n) {\n    int x = v[i].x, y = v[i].y;\n    if (v[i].dir) {\n      rep(j, 8) {\n\tmap<pair<int,int>,int>::iterator it = mem.find(mp(x + dx1[j], y + dy1[j]));\n\tif (it != mem.end()) {\n\t  int k = it->second;\n\t  if (v[k].dir) {\n\t    G[i].pb(edge(k, rev1[j]));\n\t    G[k].pb(edge(i, rev1[j]));\n\t  }\n\t}\n\tit = mem.find(mp(x + dx2[j], y + dy2[j]));\n\tif (it != mem.end()) {\n\t  int k = it->second;\n\t  if (!v[k].dir) {\n\t    G[i].pb(edge(k, rev2[j]));\n\t    G[k].pb(edge(i, rev2[j]));\n\t  }\n\t}\n      }\n    } else {\n      rep(j, 8) {\n\tmap<pair<int,int>,int>::iterator it = mem.find(mp(x - dy1[j], y + dx1[j]));\n\tif (it != mem.end()) {\n\t  int k = it->second;\n\t  if (!v[k].dir) {\n\t    G[i].pb(edge(k, rev1[j]));\n\t    G[k].pb(edge(i, rev1[j]));\n\t  }\n\t}\n\tit = mem.find(mp(x - dy2[j], y + dx2[j]));\n\tif (it != mem.end()) {\n\t  int k = it->second;\n\t  if (v[k].dir) {\n\t    G[i].pb(edge(k, rev2[j]));\n\t    G[k].pb(edge(i, rev2[j]));\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nvector<int> color;\n\nbool bicolor(int v, int c)\n{\n  if (color[v])\n    return color[v] == c;\n\n  color[v] = c;\n  rep(i, G[v].size())\n    if (!bicolor(G[v][i].to, G[v][i].rev * c))\n      return false;\n  return true;\n}\n\nbool solve()\n{\n  color.assign(n, 0);\n  rep(i, n)\n    if (!color[i] && !bicolor(i, 1))\n      return false;\n  return true;\n}\n\nint main()\n{\n  while (cin >> n && n) {\n    input();\n    gen();\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\nusing namespace std;\n\nint di[8] = {0,0,1,-1,1,1,-1,-1};\nint dj[8] = {1,-1,0,0,1,-1,1,-1};\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        set<pair<int,int>> points;\n        map<pair<int,int>,pair<int,int>> futon;\n        for(int i = 0; i < n; i++){\n            int x, y;\n            char c;\n            cin >> x >> y >> c;\n            points.insert({x, y});\n            int nx = x, ny = y;\n            (c == 'x' ? nx : ny)++;\n            points.insert({nx, ny});\n            futon[{x,y}] = {nx,ny};\n            futon[{nx,ny}] = {x,y};\n        }\n        map<pair<int,int>,int> color;\n        bool valid = true;\n        for(pair<int,int> p : points){\n            if(!valid)  break;\n            if(color.count(p))    continue;\n            queue<pair<int,int>> paint;\n            paint.push(p);\n            color[p] = 1;\n            while(!paint.empty()){\n                pair<int,int> now = paint.front(); paint.pop();\n                for(int k = 0; k < 4; k++){\n                    pair<int,int> next = now;\n                    next.first += di[k], next.second += dj[k];\n                    if(points.count(next) == 0)   continue;\n                    int nowcolor = color[now], nextcolor = color[next];\n                    if(next == futon[now]){\n                        if(nextcolor == 0){\n                            color[next] = -nowcolor;\n                            paint.push(next);\n                        }else if(nextcolor == nowcolor){\n                            valid = false;\n                            break;\n                        }else{\n                            // futon[now] has already colored correctly\n                        }\n                    }else{\n                        if(nextcolor){\n                            if(nextcolor != nowcolor)   valid = false;\n                        }else{\n                            color[next] = nowcolor;\n                            paint.push(next);\n                        }\n                    }\n                }\n            }\n        }\n        cout << (valid ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<vector>\n\nusing namespace std;\n\nint x[20000],y[20000];\nchar dir[20000];\nint p[20000];\nvector<vector<int> >G;\n\nint dst(int x1,int y1,int x2,int y2){\n  return abs(x1-x2)+abs(y1-y2);\n}\n\nbool dfs(int v){\n  for(auto e:G[v]){\n    int sp=(dst(x[v],y[v],x[e],y[e])==2)?-1:1;\n    if(p[e]==0){\n      p[e]=sp*p[v];\n      if(!dfs(e))return false;\n    }else{\n      if(p[e]*p[v]!=sp)return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>dir[i];\n    }\n    G=vector<vector<int> >(n);\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i==j)continue;\n\tif(min({dst(x[i],y[i],x[j],y[j]),\n\t\tdst(x[i],y[i],x[j]+(dir[j]=='x'),y[j]+(dir[j]=='y')),\n\t\tdst(x[i]+(dir[i]=='x'),y[i]+(dir[i]=='y'),x[j],y[j]),\n\t\tdst(x[i]+(dir[i]=='x'),y[i]+(dir[i]=='y'),x[j]+(dir[j]=='x'),y[j]+(dir[j]=='y'))\n\t\t})==1){\n\t  G[i].push_back(j);\n\t}\n      }\n    }\n    fill(begin(p),end(p),0);\n    bool f=false;\n    for(int i=0;i<n;i++){\n      if(p[i]==0){\n\tp[i]=1;\n      }\n      f|=!dfs(i);\n    }\n    cout<<(f?\"No\":\"Yes\")<<endl;\n  }\n}  \n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\ntypedef vector<Pii> Futon;\n\nbool adjecentPoint(const Pii& p, const Pii& q) {\n    return abs(p.first - q.first) + abs(p.second - q.second) <= 1;\n}\n\nbool adjecentFuton(const Futon& f1, const Futon& f2) {\n    rep(k, 2) {\n        rep(l, 2) {\n            if (adjecentPoint(f1[k], f2[l])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool dfs(int v, int pre, int start, int c, const Graph& G) {\n    if (c == 3) return v != start;\n    for (const auto u : G[v]) {\n        if (u != pre && !dfs(u, v, start, c + 1, G)) return false;\n    }\n    return true;\n}\n\nbool solve(const int n, const int t) {\n    vector<Futon> futon(n);\n    rep(i, n) {\n        int x, y;\n        string d;\n        cin >> x >> y >> d;\n        futon[i].emplace_back(Pii(x, y));\n        int k = (d == \"x\");\n        futon[i].emplace_back(Pii(x + 1 * k, y + 1 * (k ^ 1)));\n    }\n\n    Graph G(n);\n    rep(i, n) {\n        rep2(j, i + 1, n) {\n            if (adjecentFuton(futon[i], futon[j])) {\n                G[i].emplace_back(j);\n                G[j].emplace_back(i);\n            }\n        }\n    }\n\n    rep(i, n) {\n        if (!dfs(i, -1, i, 0, G)) return false;\n    }\n\n    return true;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    int t = 0;\n    while (cin >> n, t++, n) {\n        // cout << \"Case #\" << t << \":\" << endl;\n        cout << (solve(n, t) ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing Ti = tuple<int, int, int>;\nusing Tl = tuple<ll, ll, ll>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define Get(t, i) get<(i)>((t))\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\nconst int inf = 1 << 25;\nconst ll INF = 1LL << 55;\n\nmap<Pi, Pi> futon;\nmap<Pi, int> dir;\n\n#define HEAD 0\n#define FOOT 1\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nbool bfs(map<Pi, Pi>::iterator it)\n{\n  queue< map<Pi, Pi>::iterator > que; // Head pos\n  que.push(it);\n  dir[it->F] = HEAD;\n  dir[it->S] = FOOT;\n  while(!que.empty()) {\n    auto itr = que.front(); que.pop();\n    Pi p = itr->F, q = itr->S;\n    //cout << p.F << \" \" << p.S << \" \" << q.F << \" \" << q.S << endl;\n    rep(i, 4) {\n      Pi r = Pi(p.F+dx[i], p.S+dy[i]);\n      if(r == q) continue;\n      if(futon.find(r) == futon.end()) continue;\n      if(dir.find(r) == dir.end()) {\n\tauto itr2 = futon.find(r);\n\tque.push(itr2);\n\tdir[itr2->F] = HEAD;\n\tdir[itr2->S] = FOOT;\n      } else {\n\tauto itr2 = dir.find(r);\n\t//cout << (itr2->F).F << \" \" << (itr2->F).S << endl;\n\tif(itr2->S == FOOT) return false;\n\telse continue;\n      }\n    }\n    rep(i, 4) {\n      Pi r = Pi(q.F+dx[i], q.S+dy[i]);\n      if(r == p) continue;\n      if(futon.find(r) == futon.end()) continue;\n      if(dir.find(r) == dir.end()) {\n\tauto itr2 = futon.find(r);\n\tauto itr3 = futon.find(itr2->S);\n\tque.push(itr3);\n\tdir[itr3->F] = HEAD;\n\tdir[itr3->S] = FOOT;\n      } else {\n\tauto itr2 = dir.find(r);\n\t//cout << (itr2->F).F << \" \" << (itr2->F).S << endl;\n\tif(itr2->S == HEAD) return false;\n\telse continue;\n      }\n    }\n  }\n  return true;\n}\n\nint main()\n{\n  int n;\n  while(cin >> n, n) {\n    futon.clear();\n    dir.clear();\n    rep(i, n) {\n      int x, y; char d;\n      cin >> x >> y >> d;\n      if(d == 'x') {\n\tfuton[Pi(x, y)] = Pi(x+1, y);\n\tfuton[Pi(x+1, y)] = Pi(x, y);\n      } else if(d == 'y') {\n\tfuton[Pi(x, y)] = Pi(x, y+1);\n\tfuton[Pi(x, y+1)] = Pi(x, y);\n      }\n    }\n    bool flag = true;\n    for(auto it = futon.begin(); it != futon.end() && flag; it++) {\n      if(dir.find(it->F) == dir.end()) {\n\tif(!bfs(it)) flag = false;\n      }\n    }\n    cout << (flag ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nstruct StronglyConnectedComponents{\n    vector<int> used,cmp,vs;\n    vector<vector<int>> v,rv;\n    StronglyConnectedComponents(int n):used(n),cmp(n,-1),v(n),rv(n){}\n\n    void add_edge(int x,int y){\n        v[x].push_back(y);\n        rv[y].push_back(x);\n    }\n    void dfs(int x){\n        used[x]=true;\n        for(auto to:v[x])if(!used[to])dfs(to);\n        vs.push_back(x);\n    }\n\n    void rdfs(int x,int k){\n        cmp[x]=k;\n        for(auto to:rv[x])if(cmp[to]==-1)rdfs(to,k);\n    }\n\n    int scc(){\n        rep(i,used.size())if(!used[i])dfs(i);\n        reverse(vs.begin(),vs.end());\n        int k=0;\n        for(auto x:vs)if(cmp[x]==-1)rdfs(x,k++);\n        return k;\n    }\n    void build(vector<vector<int>> &g){\n        int k=scc();\n        g.resize(k);\n        set<pair<int,int>> used;\n        rep(i,v.size()){\n            for(auto& to:v[i]){\n                int x=cmp[i],y=cmp[to];\n                if(x==y||used.count({x,y}))continue;\n                g[x].push_back(y);\n                used.emplace(x,y);\n            }\n        }\n    }\n};\n\nvoid solve(int n){\n    map<pair<int,int>,int> mp;\n    StronglyConnectedComponents scc(2*n);\n    int d[]{1,0,-1,0,1};\n    rep(i,n){\n        int x,y;\n        cin>>x>>y;\n        char dir;\n        cin>>dir;\n        int nx=x,ny=y;\n        if(dir=='x')++nx;\n        else ++ny;\n        rep(j,4){\n            if(mp.count({x+d[j],y+d[j+1]})){\n                scc.add_edge(2*i, mp[{x+d[j],y+d[j+1]}]);\n                scc.add_edge(mp[{x+d[j],y+d[j+1]}],2*i);\n                scc.add_edge(2*i+1, mp[{x+d[j],y+d[j+1]}]^1);\n                scc.add_edge(mp[{x+d[j],y+d[j+1]}]^1,2*i+1);\n            }\n            if(mp.count({nx+d[j],ny+d[j+1]})){\n                scc.add_edge(2*i+1, mp[{nx+d[j],ny+d[j+1]}]);\n                scc.add_edge(mp[{nx+d[j],ny+d[j+1]}],2*i+1);\n                scc.add_edge(2*i, mp[{nx+d[j],ny+d[j+1]}]^1);\n                scc.add_edge(mp[{nx+d[j],ny+d[j+1]}]^1,2*i);\n            }\n        }\n        mp[{x,y}]=2*i;\n        mp[{nx,ny}]=2*i+1;\n    }\n    scc.scc();\n    rep(i,n){\n        if(scc.cmp[2*i]==scc.cmp[2*i+1]){\n            cout<<\"No\"<<endl;\n            return ;\n        }\n    }\n    cout<<\"Yes\"<<endl;\n    return ;\n}\nint main(){\n    int n;\n    while(cin>>n,n)solve(n);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nmap<P,P> G;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\n\nset<PP> used;\nset<P> checked;\nint check(P head){\n  P leg = G[head];\n  if(used.count(PP(head,leg)))return 1;\n  if(used.count(PP(leg,head)))return 0;\n  used.insert(PP(head,leg));\n  checked.insert(head);\n  checked.insert(leg);\n\n  int res = 1;\n  for(int i=0;i<4;i++){\n    int nx = head.second+dx[i];\n    int ny = head.first+dy[i];\n    P nhead = P(ny,nx);\n    if(nhead == leg || !G.count(nhead))continue;\n    res &=check(nhead);\n  }\n\n  for(int i=0;i<4;i++){\n    int nx = leg.second+dx[i];\n    int ny = leg.first+dy[i];\n    P nleg = P(ny,nx);\n    if(nleg == head || !G.count(nleg))continue;\n    res &=check(G[nleg]);\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    G.clear();\n    for(int i=0;i<n;i++){\n      int x,y;\n      char dir;\n      cin>>x>>y>>dir;\n      int a = x + (dir =='x');\n      int b = y + (dir == 'y');\n      G[P(y,x)] = P(b,a);\n      G[P(b,a)] = P(y,x);\n    }\n\n    int ans = 1;\n    for(PP a:G){\n      if(!ans || checked.count(a.first))continue;\n      used.clear();\n      if(check(a.first)) continue;\n      used.clear();\n      if(check(a.second))continue;\n      ans = 0;\n    }\n    cout<<(ans? \"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\n#include \"bits/stdc++.h\"\nstruct UnionFind {\n\tstd::vector<int> par;\n\tstd::vector<int> sizes;\n\n\tUnionFind(int n) {\n\t\tpar.resize(n);\n\t\tsizes.resize(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tpar[i] = i;\n\t\t\tsizes[i] = 1;\n\t\t}\n\t}\n\n\tint root(int a) {\n\t\treturn par[a] == a ? a : par[a] = root(par[a]);\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y)return;\n\t\tif (sizes[x] < sizes[y]) std::swap(x, y);\n\n\t\tpar[y] = x;\n\t\tsizes[x] += sizes[y];\n\t}\n\tint size(int x) {\n\t\treturn sizes[root(x)];\n\t}\n};\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tint m = 2 * n;\n\t\tvector<pair<pii, int>> v;\n\n\t\tvvi g(m);\n\n\t\tREP(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tchar c; cin >> c;\n\t\t\tpii a = { x,y }, b = a;\n\t\t\tif (c == 'x') {\n\t\t\t\tb.first++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb.second++;\n\t\t\t}\n\t\t\tv.push_back({ a,2 * i });\n\t\t\tv.push_back({ b,2 * i + 1 });\n\t\t}\n\t\tvi c(m, -1);\n\t\tsort(ALL(v));\n\t\tREP(i, m - 1) {\n\t\t\tif (v[i].first.first == v[i + 1].first.first && v[i].first.second + 1 == v[i + 1].first.second) {\n\t\t\t\tg[v[i].second].push_back(v[i + 1].second);\n\t\t\t\tg[v[i + 1].second].push_back(v[i].second);\n\t\t\t}\n\t\t}\n\t\tsort(ALL(v), [&](auto a, auto b) {if (a.second == b.second)return a.first < b.first; return a.second < b.second; });\n\t\tREP(i, m - 1) {\n\t\t\tif (v[i].first.first + 1 == v[i + 1].first.first && v[i].first.second == v[i + 1].first.second) {\n\t\t\t\tg[v[i].second].push_back(v[i + 1].second);\n\t\t\t\tg[v[i + 1].second].push_back(v[i].second);\n\t\t\t}\n\t\t}\n\t\tREP(i, m) {\n\t\t\tsort(ALL(g[i]));\n\t\t\tUNIQUE(g[i]);\n\t\t}\n\t\tbool ok = true;\n\t\tqueue<int> q;\n\t\tREP(i, m) {\n\t\t\tif (c[i] != -1)continue;\n\t\t\tq.push(i);\n\t\t\tc[i] = 0;\n\n\t\t\twhile (!q.empty()) {\n\t\t\t\tint p = q.front(); q.pop();\n\t\t\t\tREP(i, g[p].size()) {\n\t\t\t\t\tif (c[g[p][i]] != -1) {\n\t\t\t\t\t\tif (p & 1 && g[p][i] == p - 1) {\n\t\t\t\t\t\t\tif (c[p] == c[g[p][i]])ok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (p % 2 == 0 && g[p][i] == p + 1) {\n\t\t\t\t\t\t\tif (c[p] == c[g[p][i]])ok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (c[p] != c[g[p][i]])ok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (p & 1 && g[p][i] == p - 1) {\n\t\t\t\t\t\t\tc[g[p][i]] = 1 - c[p];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (p % 2 == 0 && g[p][i] == p + 1) {\n\t\t\t\t\t\t\tc[g[p][i]] = 1 - c[p];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tc[g[p][i]] = c[p];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.push(g[p][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <tuple>\n#include <queue>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nstruct futon {\n    int x, y, dir;\n    bool operator<(futon const& f) const {\n        return x < f.x;\n    }\n};\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<futon> v(n);\n        map<P, int> m; // -1: head or foot, 0: none, 1: f, 2: h\n        map<P, int> fidx;\n        for(int i=0; i<n; ++i) {\n            int x, y;\n            char dir;\n            cin >> x >> y >> dir;\n            v[i] = {x, y, dir-'x'};\n            m[make_pair(x, y)] = -1;\n            fidx[make_pair(x, y)] = i;\n            if(v[i].dir == 0) {\n                x += 1;\n                m[make_pair(x, y)] = -1;\n            } else {\n                y++;\n                m[make_pair(x, y)] = -1;\n            }\n            fidx[make_pair(x, y)] = i;\n        }\n        bool ok = true;\n        for(int i=0; i<n; ++i) {\n            if(!ok) {\n                break;\n            }\n            if(m[make_pair(v[i].x, v[i].y)] == -1) {\n                queue<int> que;\n                que.push(i);\n                m[make_pair(v[i].x, v[i].y)] = 1; // foot\n                if(v[i].dir == 0) {\n                    m[make_pair(v[i].x+1, v[i].y)] = 2;\n                } else {\n                    m[make_pair(v[i].x, v[i].y+1)] = 2;\n                }\n                int dx[2][2][3] = {{{-1, 0, 0}, {1, 0, 0}},\n                                   {{0, -1, 1}, {0, -1, 1}}};\n                int dy[2][2][3] = {{{0, 1, -1}, {0, 1, -1}},\n                                   {{-1, 0, 0}, {1, 0, 0}}};\n                while(!que.empty()) {\n                    int idx = que.front(); que.pop();\n                    futon f = v[idx];\n                    //cout << \"futon: \" << f.x << \" \" << f.y << \" \" << f.dir << endl;\n                    int fh[2] = {};\n                    fh[0] = m[make_pair(f.x, f.y)];\n                    if(f.dir == 0) {\n                        fh[1] = m[make_pair(f.x+1, f.y)];\n                    } else {\n                        fh[1] = m[make_pair(f.x, f.y+1)];\n                    }\n                    for(int j=0; j<2; ++j) {\n                        int x = f.x, y = f.y;\n                        if(j == 1) {\n                            if(f.dir == 0) {\n                                x += 1;\n                            } else {\n                                y += 1;\n                            }\n                        }\n                        for(int k=0; k<3; ++k) {\n                            P p = make_pair(x+dx[f.dir][j][k], y+dy[f.dir][j][k]);\n                            //cout << \"p: \" << p.first << \" \" << p.second << endl;\n                            if(m[p] == 1) {\n                                if(fh[j] == 2) {\n                                    //cout << \"error1: \" << p.first << \" \" << p.second << endl;\n                                    ok = false;\n                                }\n                            } else if(m[p] == 2) {\n                                if(fh[j] == 1) {\n                                    //cout << \"error2: \" << p.first << \" \" << p.second << endl;\n                                    ok = false;\n                                }\n                            } else if(m[p] == -1) {\n                                futon next = v[fidx[p]];\n                                m[p] = fh[j];\n                                int next_fh = (fh[j] == 1 ? 2 : 1);\n                                //cout << \"m[p]: \" << m[p] << endl;\n                                if(next.x == p.first && next.y == p.second) {\n                                    if(next.dir == 0) {\n                                        m[make_pair(p.first+1, p.second)] = next_fh;\n                                    } else {\n                                        m[make_pair(p.first, p.second+1)] = next_fh;\n                                    }\n                                } else {\n                                    if(next.dir == 0) {\n                                        m[make_pair(p.first-1, p.second)] = next_fh;\n                                    } else {\n                                        m[make_pair(p.first, p.second-1)] = next_fh;\n                                    }\n                                }\n                                que.push(fidx[p]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if(ok) {\n            cout << \"Yes\" << endl;\n        } else {\n            cout << \"No\" << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<vector>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct Point{\n\tint x,y;\n\tbool operator<(const Point &p)const{ return make_pair(x,y)<make_pair(p.x,p.y); }\n};\n\ntypedef pair<Point,Point> Futon;\n\nint n,mark[40000];\nvector<int> adj[40000];\n\nbool issame(int u,int v){ return abs(u-v)==n; }\n\nbool dfs(int u){\n\trep(i,adj[u].size()){\n\t\tint v=adj[u][i];\n\t\tif(mark[v]==-1){\n\t\t\tif(issame(u,v)) mark[v]=1-mark[u];\n\t\t\telse            mark[v]=mark[u];\n\t\t\tif(!dfs(v)) return false;\n\t\t}\n\t\telse{\n\t\t\tif(!issame(u,v) && mark[u]!=mark[v]) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tPoint futon[40000];\n\t\tmap<Point,int> f;\n\t\trep(j,n){\n\t\t\tint x,y;\n\t\t\tchar dir; scanf(\"%d%d %c\",&x,&y,&dir);\n\n\t\t\tfuton[j]=(Point){x,y};\n\t\t\tif(dir=='x') futon[n+j]=(Point){x+1,y};\n\t\t\tif(dir=='y') futon[n+j]=(Point){x,y+1};\n\n\t\t\tf[futon[ j ]]=j;\n\t\t\tf[futon[n+j]]=n+j;\n\t\t}\n\n\t\trep(u,2*n){\n\t\t\tadj[u].clear();\n\t\t\trep(k,4){\n\t\t\t\tint x=futon[u].x+dx[k];\n\t\t\t\tint y=futon[u].y+dy[k];\n\t\t\t\tPoint p={x,y};\n\t\t\t\tif(f.count(p)) adj[u].push_back(f[p]);\n\t\t\t}\n\t\t}\n\n\t\tbool ok=true;\n\t\trep(u,2*n) mark[u]=-1;\n\t\trep(u,2*n) if(mark[u]==-1) {\n\t\t\tmark[u]=0;\n\t\t\tif(!dfs(u)){ ok=false; break; }\n\t\t}\n\n\t\tputs(ok?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <iterator>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\nstruct P {\n    int x, y;\n    P(int x, int y) : x(x), y(y) {}\n};\nbool operator<(const P& a ,const P& b) {\n    return a.x == b.x ? a.y < b.y : a.x < b.x;\n}\nbool operator==(const P& a, const P& b) {\n    return a.x == b.x && a.y == b.y;\n}\nostream& operator<<(ostream& os, const P& p) {\n    os << \"P(\" << p.x << \",\" << p.y << \")\";\n    return os;\n}\nstruct L {\n    P a, b;\n    L(P a, P b) : a(a), b(b) {}\n};\n\nint N;\nmap<P, int> M;\nmap<P, int> U;\nvector<L> F;\n#define UNDEF 0\n#define HEAD 1\n#define FEET 2\nbool input() {\n    cin >> N; if (N == 0) return false;\n    M.clear(); U.clear(); F.clear();\n    for (int i = 0; i < N; i++) {\n        int x, y; char d;\n        cin >> x >> y >> d;\n        if (d == 'x') {\n            M[P(x, y)] = i;\n            M[P(x + 1, y)] = i;\n            F.push_back(L(P(x, y), P(x + 1, y)));\n        } else {\n            M[P(x, y)] = i;\n            M[P(x, y + 1)] = i;\n            F.push_back(L(P(x, y), P(x, y + 1)));\n        }\n    }\n    return true;\n}\n\nint R(int s) {\n    if (s == HEAD) return FEET;\n    if (s == FEET) return HEAD;\n    assert(0);\n}\n\nconst int dy[] = {0, 1, 0, -1},\n          dx[] = {1, 0, -1, 0};\nbool Set(const P& a, int s) {\n    //cout << a << \" \" << s << endl;\n    int index = M[a];\n    const P& b = (F[index].a == a ? F[index].b : F[index].a);\n    for (int i = 0; i < 4; i++) {\n        P n(a.x + dx[i], a.y + dy[i]);\n        if (n == b) continue;\n        if (M.count(n) == 0) continue;\n        if (U[n] == R(s)) return false;\n    }\n    for (int i = 0; i < 4; i++) {\n        P n(b.x + dx[i], b.y + dy[i]);\n        if (n == a) continue;\n        if (M.count(n) == 0) continue;\n        if (U[n] == s) return false;\n    }\n    U[a] = s;\n    U[b] = R(s);\n    for (int i = 0; i < 4; i++) {\n        P n(a.x + dx[i], a.y + dy[i]);\n        if (n == b) continue;\n        if (M.count(n) == 0) continue;\n        //cout << n << endl;\n        if (U[n] == UNDEF) {\n            if (!Set(n, s)) {\n                U[a] = UNDEF;\n                U[b] = UNDEF;\n                return false;\n            }\n        }\n    }\n    for (int i = 0; i < 4; i++) {\n        P n(b.x + dx[i], b.y + dy[i]);\n        if (n == a) continue;\n        if (M.count(n) == 0) continue;\n        if (U[n] == UNDEF) {\n            if (!Set(n, R(s))) {\n                U[a] = UNDEF;\n                U[b] = UNDEF;\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid solve() {\n    for (int i = 0; i < N; i++) {\n        if (U[F[i].a] != UNDEF) continue;\n        if (Set(F[i].a, HEAD)) continue;\n        if (Set(F[i].a, FEET)) continue;\n        cout << \"No\" << endl;\n        return;\n    }\n    cout << \"Yes\" << endl;\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\ntypedef pair<int,int> pii;\n\nvector<pii> G[40000];\nint V;\nint color[40000];\n\nbool dfs(int v, int c) {\n  color[v] = c;\n  FOR(it, G[v]) {\n    int cc = c;\n    if (it->second == 0) cc=-c;\n    int u = it->first;\n    if (color[u] == cc) {\n      return 0;\n    }\n    if (color[u] == 0 && !dfs(u, -cc)) return 0;\n  }\n  return 1;\n}\nvoid solve() {\n  REP(i,V) color[i] = 0;\n  REP(i, V) {\n    if (color[i] == 0) {\n      if (!dfs(i,1)) {\n        cout << \"No\" << endl;\n        return;\n      }\n    }\n  }\n  cout << \"Yes\" << endl;\n}\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    V = 2*n;\n    REP(i,V) G[i].clear();\n    map<pii, int> mp;\n    REP(i,n) {\n      int x[2], y[2];\n      char d;\n      cin >> x[0] >> y[0] >> d;\n      x[1]=x[0],y[1]=y[0];\n      if (d=='x') x[1]++;\n      else y[1]++;\n      REP(j,2) {\n        int id = i*2+j;\n        const int dy[] = {0,1,0,-1};\n        const int dx[] = {1,0,-1,0};\n        REP(k,4) {\n          int yy=y[j]+dy[k];\n          int xx=x[j]+dx[k];\n          if (mp.count(pii(yy,xx))) {\n            int id2=mp[pii(yy,xx)];\n            G[id].push_back(pii(id2,0));\n            G[id2].push_back(pii(id,0));\n          }\n        }\n      }\n      REP(j,2) mp[pii(y[j],x[j])] = i*2+j;\n      G[i*2].push_back(pii(i*2+1,1));\n      G[i*2+1].push_back(pii(i*2,1));\n    }\n    // REP(i, V) {\n    //   cout << i << \" : \";\n    //   FOR(it, G[i]) {\n    //     printf(\"(%d,%d) \", it->first, it->second);\n    //   }\n    //   cout << endl;\n    // }\n    \n    solve();\n    //REP(i, V) cout << color[i] << \" \";cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct union_find {\n  int H, W;\n  vector<int> rank_, size_, rid_;\n  union_find(){}\n  union_find(int h, int w) { H = h + 10, W = w + 10; rank_.resize(H*W); rid_.assign(H*W, -1); size_.resize(H*W, 1); }\n  void operator()(pair<int, int> x, pair<int, int> y) {\n    int u = x.first * W + x.second;\n    int v = y.first * W + y.second;\n    u = operator[](u), v = operator[](v);\n    if(u == v) { return; }\n    size_[u] = size_[v] = size_[u] + size_[v];\n    if(rank_[u] < rank_[v]) { rid_[u] = v; }\n    else { rid_[v] = u; if(rank_[u] == rank_[v]) { rank_[u]++; } }    \n  }\n  int operator[](pair<int, int> a) { int x = a.first * W + a.second; return operator[](operator[](x)); }\n  int size_of(int x) { return size_[x]; }\nprivate:\n  int operator[](int x) { if(rid_[x] < 0) return x; else return rid_[x] = operator[](rid_[x]); }\n};\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nunion_find uf;\nvector<int> fx, fy; vector<char> fd;\nvector<int> xs, ys;\nmap<int, int> X, Y;\nset<pair<int, int>> st;\n\nint main() {\n  \n  for(int N; cin >> N && N;) {\n    fx.clear(), fx.resize(N);\n    fy.clear(), fy.resize(N);\n    fd.clear(), fd.resize(N);\n    xs.clear(), xs.resize(N);\n    ys.clear(), ys.resize(N);\n    rep(i, N) {\n      cin >> fx[i] >> fy[i] >> fd[i];\n      REP(d,-1,2) xs.push_back(fx[i]+d), ys.push_back(fy[i]+d);\n    }\n\n    sort(all(xs)); xs.erase(unique(all(xs)), xs.end());\n    sort(all(ys)); ys.erase(unique(all(ys)), ys.end());\n\n    const int H = ys.size();\n    const int W = xs.size();\n\n    X.clear(), Y.clear();\n    rep(i, xs.size()) X[xs[i]] = i;\n    rep(i, ys.size()) Y[ys[i]] = i;\n\n    uf = union_find(H, W);\n\n    st.clear();\n\n    rep(i, N) {\n      fx[i] = X[fx[i]];\n      fy[i] = Y[fy[i]];\n    }\n\n    rep(i, N) {\n      st.emplace(fy[i], fx[i]);\n      if(fd[i] == 'x') {\n        st.emplace(fy[i], fx[i] + 1);\n      } else {\n        st.emplace(fy[i] + 1, fx[i]);\n      }\n    }\n\n    rep(i, N) {\n      if(fd[i] == 'x') {\n        auto po = make_pair(fy[i], fx[i]);\n        rep(k, 4) if(dx[k] != +1) {\n          auto np = make_pair(fy[i] + dy[k], fx[i] + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n        po = make_pair(fy[i], fx[i] + 1);\n        rep(k, 4) if(dx[k] != -1) {\n          auto np = make_pair(fy[i] + dy[k], fx[i] + 1 + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n      }\n      else {\n        auto po = make_pair(fy[i], fx[i]);\n        rep(k, 4) if(dy[k] != +1) {\n          auto np = make_pair(fy[i] + dy[k], fx[i] + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n\n        po = make_pair(fy[i] + 1, fx[i]);\n        rep(k, 4) if(dy[k] != -1) {\n          auto np = make_pair(fy[i] + 1 + dy[k], fx[i] + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n      }\n    }\n\n    bool ok = 1;\n    rep(i, N) {\n      auto a = make_pair(fy[i], fx[i]);\n      if(fd[i] == 'x') {\n        auto b = make_pair(fy[i], fx[i] + 1);\n        ok &= uf[a] != uf[b];\n      }\n      else {\n        auto b = make_pair(fy[i] + 1, fx[i]);\n        ok &= uf[a] != uf[b];\n      }\n    }\n\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 20000;\n\nconst int dxs[] = {1, 0, -1, 0};\nconst int dys[] = {0, 1, 0, -1};\n\n/* typedef */\n\ntypedef pair<int,int> pii;\ntypedef map<pii,int> mpii;\n\nstruct Futon {\n  int x0, y0, x1, y1;\n  Futon() {}\n\n  void init(int x, int y, char dir) {\n    x0 = x, y0 = y;\n    if (dir == 'x') x1 = x + 1, y1 = y;\n    else x1 = x, y1 = y + 1;\n  }\n\n  bool _adjcell(int ax, int ay, int bx, int by) const {\n    return\n      (ax == bx && (ay == by - 1 || ay == by + 1)) ||\n      (ay == by && (ax == bx - 1 || ax == bx + 1));\n  }\n  \n  bool adj(const Futon& f0) const {\n    return\n      _adjcell(x0, y0, f0.x0, f0.y0) ||\n      _adjcell(x0, y0, f0.x1, f0.y1) ||\n      _adjcell(x1, y1, f0.x0, f0.y0) ||\n      _adjcell(x1, y1, f0.x1, f0.y1);\n  }\n\n  bool operator<(const Futon& f0) const {\n    return (x0 < f0.x0 || (x0 == f0.x0 && y0 < f0.y0));\n  }\n  \n  void print() { printf(\"(%d,%d)-(%d,%d)\\n\", x0, y0, x1, y1); }\n};\n\ntypedef set<Futon> sftn;\n\nenum { CH = -1, CF = -2 };\n\n/* global variables */\n\nint n;\nFuton ftns[MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n\n    mpii cells;\n    sftn sf;\n    \n    for (int i = 0; i < n; i++) {\n      int x, y;\n      char dir;\n      cin >> x >> y >> dir;\n\n      ftns[i].init(x, y, dir);\n      cells[pii(ftns[i].x0, ftns[i].y0)] = i;\n      cells[pii(ftns[i].x1, ftns[i].y1)] = i;\n      sf.insert(ftns[i]);\n    }\n\n    bool ok = true;\n    \n    while (! sf.empty()) {\n      Futon f = *(sf.begin());\n      sf.erase(f);\n\n      queue<Futon> q;\n      q.push(f);\n      cells[pii(f.x0, f.y0)] = CH;\n      cells[pii(f.x1, f.y1)] = CF;\n\n      while (! q.empty()) {\n\tFuton u = q.front(); q.pop();\n\n\tint c0 = cells[pii(u.x0, u.y0)];\n\tint c1 = cells[pii(u.x1, u.y1)];\n\n\tfor (int di = 0; di < 4; di++) {\n\t  int cx = u.x0 + dxs[di], cy = u.y0 + dys[di];\n\t  if (cx != u.x1 || cy != u.y1) {\n\t    mpii::iterator mit = cells.find(pii(cx, cy));\n\t    if (mit != cells.end()) {\n\t      int ax = mit->first.first;\n\t      int ay = mit->first.second;\n\t      int k = mit->second;\n\t      if (k >= 0) {\n\t\tFuton& v = ftns[k];\n\t\tcells[pii(cx, cy)] = c0;\n\t\tif (cx == v.x0 && cy == v.y0)\n\t\t  cells[pii(v.x1, v.y1)] = c1;\n\t\telse\n\t\t  cells[pii(v.x0, v.y0)] = c1;\n\t\tsf.erase(v);\n\t\tq.push(v);\n\t      }\n\t      else if (k != c0) {\n\t\tok = false;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t}\n\tif (! ok) break;\n\t\n\tfor (int di = 0; di < 4; di++) {\n\t  int cx = u.x1 + dxs[di], cy = u.y1 + dys[di];\n\t  if (cx != u.x0 || cy != u.y0) {\n\t    mpii::iterator mit = cells.find(pii(cx, cy));\n\t    if (mit != cells.end()) {\n\t      int ax = mit->first.first;\n\t      int ay = mit->first.second;\n\t      int k = mit->second;\n\t      if (k >= 0) {\n\t\tFuton& v = ftns[k];\n\t\tcells[pii(cx, cy)] = c1;\n\t\tif (cx == v.x0 && cy == v.y0)\n\t\t  cells[pii(v.x1, v.y1)] = c0;\n\t\telse\n\t\t  cells[pii(v.x0, v.y0)] = c0;\n\t\tsf.erase(v);\n\t\tq.push(v);\n\t      }\n\t      else if (k != c1) {\n\t\tok = false;\n\t\tbreak;\n\t      }\n\t    }\n\t  }\n\t}\n\tif (! ok) break;\n      }\n      if (! ok) break;\n    }\n\n    if (false) {\n      for (mpii::iterator mit = cells.begin(); mit != cells.end(); mit++) {\n\tint x = mit->first.first;\n\tint y = mit->first.second;\n\tint k = mit->second;\n\tprintf(\"(%d,%d)=%d\\n\", x, y, k);\n      }\n    }\n    \n    cout << (ok ? \"Yes\" : \"No\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\nusing namespace std;\n\nint X[4]={-1,0,1,0};\nint Y[4]={0,1,0,-1};\n\nint main()\n{\n  int n,x1[20001],x2[20001],y1[20001],y2[20001];\n  char c;\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    map<pair<int,int>,int> index;\n    map<pair<int,int>,int> m;\n    for(int i=0;i<n;i++){\n      cin>>x1[i]>>y1[i]>>c;\n      index[mp(x1[i],y1[i])]=i;\n      if(c=='x'){\n\tx2[i]=x1[i]+1;\n\ty2[i]=y1[i];\n      }\n      else {\n \tx2[i]=x1[i];\n\ty2[i]=y1[i]+1;\n      }\n      index[mp(x2[i],y2[i])]=i;\n    }\n\n    string ans=\"Yes\";\n    bool checked[20001]={};\n\n    for(int i=0;i<n;i++){\n\n      if(checked[i])continue;\n      checked[i]=true;\n\n      m[mp(x1[i],y1[i])]=1;\n      m[mp(x2[i],y2[i])]=0;\n\n      queue<int> q;\n      q.push(i);\n      while(!q.empty()){\n\tint u=q.front();\n\tq.pop();\n\n\tfor(int k=0;k<4;k++){\n\t  pair<int,int> npii(x1[u]+X[k],y1[u]+Y[k]);\n\t  if(index.find(npii)==index.end())continue;\n\t  int next=index[npii];\n\t  if(next==u)continue;\n\t  if(m.find(npii)==m.end()){\n\t    m[npii]=m[mp(x1[u],y1[u])];\n\t    if(m.find(mp(x1[next],y1[next]))==m.end())\n\t      m[mp(x1[next],y1[next])]=(m[mp(x1[u],y1[u])]+1)%2;\n\t    else  m[mp(x2[next],y2[next])]=(m[mp(x1[u],y1[u])]+1)%2;\n\t    q.push(next);\n\t  }\n\t  else {\n\t    if(m[npii]!=m[mp(x1[u],y1[u])])ans=\"No\";\n\t  }\n\t}\n\tfor(int k=0;k<4;k++){\n\t  pair<int,int> npii(x2[u]+X[k],y2[u]+Y[k]);\n\t  if(index.find(npii)==index.end())continue;\n\t  int next=index[npii];\n\t  if(next==u)continue;\n\t  if(m.find(npii)==m.end()){\n\t    m[npii]=m[mp(x2[u],y2[u])];\n\t    if(m.find(mp(x1[next],y1[next]))==m.end())\n\t      m[mp(x1[next],y1[next])]=(m[mp(x2[u],y2[u])]+1)%2;\n\t    else  m[mp(x2[next],y2[next])]=(m[mp(x2[u],y2[u])]+1)%2;\n\t    q.push(next);\n\t  }\n\t  else {\n\t    if(m[npii]!=m[mp(x2[u],y2[u])])ans=\"No\";\n\t  }\n\t}\n\tchecked[u]=true;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int sz = 40010;\nvector<int> G[sz];\nvector<int> rG[sz];\nint cmp[sz];\nbool visit[sz];\n\nvoid dfs(int v, vector<int> &vs){\n  visit[v] = true;\n  REP(i, G[v].size()){\n    if(!visit[G[v][i]]) dfs(G[v][i], vs);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n  visit[v] = true;\n  cmp[v] = k;\n  REP(i, rG[v].size()) if(!visit[rG[v][i]]) rdfs(rG[v][i], k);\n}\n\nint scc(int V){\n  REP(i, sz) rG[i].clear();\n  REP(i, V)REP(j, G[i].size()) rG[G[i][j]].push_back(i);\n  \n  int k = 0;\n  vector<int> vs;\n  \n  memset(visit, false, sizeof(visit));  \n  REP(i, V) if(!visit[i]) dfs(i, vs);\n  memset(visit, false, sizeof(visit));\n  reverse(ALL(vs));\n  REP(i, vs.size()){\n    if(!visit[vs[i]]){\n      rdfs(vs[i], k++);\n    }\n  }\n  return k;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    \n    REP(i, sz) G[i].clear();\n        \n    char dir;\n    vector<int> x(n * 2);\n    vector<int> y(n * 2);\n    vector<int> d(n * 2);\n    \n    REP(i, n){\n      cin >> x[i] >> y[i] >> dir;\n      x[i+n] = x[i];\n      y[i+n] = y[i];\n      if(dir == 'x'){\n        x[i+n]++;\n        d[i] = 0;\n        d[i+n] = 2;\n      }\n      \n      if(dir == 'y'){\n        y[i+n]++;\n        d[i] = 1;\n        d[i+n] = 3;\n      }\n    }\n    \n    n *= 2;\n    map<P, int> futon;    \n    REP(i, n) futon[P(x[i], y[i])] = i;\n    \n    REP(i, n){\n      int dx[4] = {1, 0, -1, 0};\n      int dy[4] = {0, 1, 0, -1};     \n      REP(j, 4){\n        int xa = x[i] + dx[j];\n        int ya = y[i] + dy[j];\n\n        if(futon.find(P(xa, ya)) != futon.end()){\n          int f = futon[P(xa, ya)];\n\n          if(j == d[i]){\n            G[i].push_back(f + n);\n            G[f].push_back(i + n);\n            G[i + n].push_back(f);\n            G[f + n].push_back(i);\n          }else{\n            G[i+n].push_back(f+n);\n            G[f+n].push_back(i+n);            \n          }\n        }\n      }\n    }\n\n    bool possible = true;\n    scc(2 * n);\n    REP(i, n){\n      possible &= cmp[i] != cmp[n + i];\n    }\n    cout << (possible ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\n#define X first\n#define Y second\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    P p[n];\n    char d[n];\n    for(int i=0;i<n;i++) cin>>p[i].X>>p[i].Y>>d[i];\n    map<P,int> m;\n    for(int i=0;i<n;i++) m[p[i]]=i;\n    int used[n],visit[n];\n    memset(used,0,sizeof(used));\n    bool f=1;\n\n    int ax1[]={-1, 0, 1, 2,-2,-1, 0, 1};\n    int ay1[]={-1,-1,-1, 0, 0, 1, 1, 1};\n    int ad1[]={ 1, 0, 1, 1, 1, 1, 0, 1};\n    \n    int ax2[]={-1, 0, 1, 2, 2, 1, 0,-1};\n    int ay2[]={ 0, 1, 1, 0,-1,-2,-2,-1};\n    int ad2[]={ 0, 0, 1, 1, 0, 0, 1, 1};\n    \n    int ax3[]={ 0, 1, 1, 1, 0,-1,-1,-1};\n    int ay3[]={ 2, 1, 0,-1,-2,-1, 0, 1};\n    int ad3[]={ 1, 1, 0, 1, 1, 1, 0, 1};\n    \n    int ax4[]={-1, 0, 1, 1, 0,-1,-2,-2};\n    int ay4[]={-1,-1, 0, 1, 2, 2, 1, 0};\n    int ad4[]={ 1, 0, 0, 1, 1, 0, 0, 1};\n    \n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      bool ff=0;\n      for(int k=0;k<2;k++){\n\tbool fff=1;\n\t\n\tmemset(visit,-1,sizeof(visit));\n\tqueue<int> q;\n\tq.push(i);\n\tvisit[i]=k;\n\t\n\twhile(!q.empty()){\n\t  int t=q.front();q.pop();\n\t  //cout<<t<<\" \"<<visit[t]<<endl;\n\t  if(d[t]=='x'){\n\t    for(int j=0;j<8;j++){\n\t      int nx=p[t].X+ax1[j],ny=p[t].Y+ay1[j],nv=visit[t];\n\t      if(!m.count(P(nx,ny))) continue;\n\t      int u=m[P(nx,ny)];\n\t      if(d[u]=='y') continue;\n\t      //cout<<\"a1:\"<<u<<endl;\n\t      if(ad1[j]) nv=!nv;\n\t      if(~visit[u]){\n\t\tif(visit[u]!=nv){\n\t\t  fff=0;\n\t\t  goto END;\n\t\t}\n\t      }else{\n\t\tvisit[u]=nv;\n\t\tq.push(u);\n\t      }\n\t    }\n\t    for(int j=0;j<8;j++){\n\t      int nx=p[t].X+ax2[j],ny=p[t].Y+ay2[j],nv=visit[t];\n\t      if(!m.count(P(nx,ny))) continue;\n\t      int u=m[P(nx,ny)];\n\t      if(d[u]=='x') continue;\n\t      //cout<<\"a2:\"<<u<<endl;\n\t      if(ad2[j]) nv=!nv;\n\t      if(~visit[u]){\n\t\tif(visit[u]!=nv){\n\t\t  fff=0;\n\t\t  goto END;\n\t\t}\n\t      }else{\n\t\tvisit[u]=nv;\n\t\tq.push(u);\n\t      }\n\t    }\n\t  }\n\t  \n\t  if(d[t]=='y'){\n\t    for(int j=0;j<8;j++){\n\t      int nx=p[t].X+ax3[j],ny=p[t].Y+ay3[j],nv=visit[t];\n\t      if(!m.count(P(nx,ny))) continue;\n\t      int u=m[P(nx,ny)];\n\t      if(d[u]=='x') continue;\n\t      //cout<<\"a3:\"<<u<<endl;\n\t      if(ad3[j]) nv=!nv;\n\t      if(~visit[u]){\n\t\tif(visit[u]!=nv){\n\t\t  fff=0;\n\t\t  goto END;\n\t\t}\n\t      }else{\n\t\tvisit[u]=nv;\n\t\tq.push(u);\n\t      }\n\t    }\n\t    for(int j=0;j<8;j++){\n\t      int nx=p[t].X+ax4[j],ny=p[t].Y+ay4[j],nv=visit[t];\n\t      if(!m.count(P(nx,ny))) continue;\n\t      int u=m[P(nx,ny)];\n\t      if(d[u]=='y') continue;\n\t      //cout<<\"a4:\"<<u<<endl;\n\t      if(ad4[j]) nv=!nv;\n\t      if(~visit[u]){\n\t\tif(visit[u]!=nv){\n\t\t  fff=0;\n\t\t  goto END;\n\t\t}\n\t      }else{\n\t\tvisit[u]=nv;\n\t\tq.push(u);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n      END:\n\n\t//cout<<\"fff:\"<<fff<<endl;\n\t\n\tif(fff){\n\t  for(int j=0;j<n;j++) if(~visit[j]) used[j]=1;\n\t  ff=1;\n\t  break;\n\t}\n      }\n      if(!ff){\n\tf=0;\n\tbreak;\n      }\n    }\n    cout<<(f?\"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,int> Pi;\ntypedef long long ll;\n\nint n;\n\n\nbool bfs(int t,map<P,P> futon,pair<P,P> f) {\n    queue<Pi> que;\n    que.push(Pi(f.fr,t));\n    f.sc.sc=t;\n    futon[f.fr]=f.sc;\n    map<Pi,bool> visited;\n    visited[(Pi(f.fr,t))]=true;;\n\n    while(que.size()) {\n        Pi pi = que.front(); que.pop();\n        P p=pi.fr;\n        //printf(\"[debug] %d : %d %d %d\\n\",t,p.fr,p.sc,pi.sc);\n        rep(k,4) {\n            int ny=p.fr+dy[k];\n            int nx=p.sc+dx[k];\n            int t=pi.sc;\n\n            if(!futon.count(P(ny,nx))) continue;\n            //if(futon[P(ny,nx)].sc!=-1) continue;\n\n            // ???????????£???\n            if(futon[P(ny,nx)].fr==futon[p].fr) {\n                if(futon[P(ny,nx)].sc!=-1&&futon[P(ny,nx)].sc!=(t^1)) return false;\n                if(visited.count(Pi(P(ny,nx),t^1))) continue;\n                visited[(Pi(P(ny,nx),t^1))]=true;\n                futon[P(ny,nx)].sc=t^1;\n                que.push(Pi(P(ny,nx),t^1));\n            }\n            else {\n                if(futon[P(ny,nx)].sc!=-1&&futon[P(ny,nx)].sc!=t) return false;\n                if(visited.count(Pi(P(ny,nx),t))) continue;\n                visited[(Pi(P(ny,nx),t))]=true;\n                futon[P(ny,nx)].sc=t;\n                que.push(Pi(P(ny,nx),t));\n            }\n\n        }\n    }\n\n    return true;\n}\n\nvoid solve() {\n    map<P,P> futon;\n    rep(i,n) {\n        P pos;\n        char d;\n        cin>>pos.sc>>pos.fr>>d;\n        futon[pos]=P(i,-1);\n        if(d=='x') {\n            pos.sc+=1;\n        }\n        else {\n            pos.fr+=1;\n        }\n        futon[pos]=P(i,-1);\n    }\n    bool f=true;\n    for(auto e : futon) {\n        if(!(bfs(0,futon,e)||bfs(1,futon,e))) f=false;\n    }\n    if(f) {\n        cout<<\"Yes\"<<endl;\n    }\n    else cout<<\"No\"<<endl;\n}\n\nint main() {\n    while(cin>>n) {\n        if(n==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<vector>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct Point{\n\tint x,y;\n\tbool operator<(const Point &p)const{ return make_pair(x,y)<make_pair(p.x,p.y); }\n};\n\ntypedef pair<Point,Point> Futon;\n\nint n,mark[40000];\nvector<int> adj[40000];\n\n// u Æ v ª¯¶ÓÆñÉ®·é©Ç¤©\nbool issame(int u,int v){ return abs(u-v)==n; }\n\nbool dfs(int u){\n\tbool ok=true;\n\trep(i,adj[u].size()){\n\t\tint v=adj[u][i];\n\t\tif(mark[v]==-1){\n\t\t\tif(issame(u,v)) mark[v]=1-mark[u];\n\t\t\telse            mark[v]=mark[u];\n\t\t\tif(!dfs(v)){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(!issame(u,v) && mark[u]!=mark[v]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tmark[u]=-1;\n\treturn ok;\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tPoint futon[40000];\n\t\tmap<Point,int> f;\n\t\trep(j,n){\n\t\t\tint x,y;\n\t\t\tchar dir; scanf(\"%d%d %c\",&x,&y,&dir);\n\n\t\t\tfuton[j]=(Point){x,y};\n\t\t\tif(dir=='x') futon[n+j]=(Point){x+1,y};\n\t\t\tif(dir=='y') futon[n+j]=(Point){x,y+1};\n\n\t\t\tf[futon[ j ]]=j;\n\t\t\tf[futon[n+j]]=n+j;\n\t\t}\n\n\t\trep(u,2*n){\n\t\t\tadj[u].clear();\n\t\t\trep(k,4){\n\t\t\t\tint x=futon[u].x+dx[k];\n\t\t\t\tint y=futon[u].y+dy[k];\n\t\t\t\tPoint p={x,y};\n\t\t\t\tif(f.count(p)) adj[u].push_back(f[p]);\n\t\t\t}\n\t\t}\n\n\t\tbool ok=true;\n\t\trep(u,2*n) mark[u]=-1;\n\t\trep(u,2*n) if(mark[u]==-1) {\n\t\t\tmark[u]=0;\n\t\t\tif(!dfs(u)){ ok=false; break; }\n\t\t}\n\n\t\tputs(ok?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n// >>> union find\nstruct UnionFind {\n    int n, sz; // id : 0...n-1\n    vector<int> par;\n\n    UnionFind(int n = 0) : n(n), sz(n), par(n,-1) { }\n    int root(int x) {\n        assert(0 <= x); assert(x < n);\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n    bool unite(int x, int y) {\n        x = root(x), y = root(y);\n        if (x == y) return false;\n        sz--;\n        if (par[x] < par[y]) swap(x,y);\n        par[y] += par[x];\n        par[x] = y;\n        return true;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -par[root(x)]; }\n    int size() const { return sz; }\n    struct groups_t {\n        vector<vector<int> > grp;\n        vector<pair<int,int> > id;\n    };\n    groups_t groups() {\n        vector<vector<int> > g(n);\n        rep (i,n) if (par[i] < 0) g[i].reserve(-par[i]);\n        rep (i,n) g[root(i)].push_back(i);\n        vector<vector<int> > grp; grp.reserve(size());\n        rep (i,n) if (g[i].size()) grp.emplace_back(move(g[i]));\n        vector<pair<int,int> > id(n);\n        rep (i,grp.size()) rep (j,grp[i].size()) {\n            id[grp[i][j]] = make_pair(i,j);\n        }\n        return { grp, id };\n    }\n};\n// <<<\n\nint32_t main() {\n    while (true) {\n        int n; cin >> n;\n        if (n == 0) break;\n\n        UnionFind uf(4*n);\n        map<pair<int,int>,int> idx;\n\n        vector<int> x0(n),y0(n),x1(n),y1(n);\n        rep (i,n) {\n            cin >> x0[i] >> y0[i];\n            char dir; cin >> dir;\n            if (dir == 'x') {\n                x1[i] = x0[i]+1, y1[i] = y0[i];\n            } else {\n                x1[i] = x0[i], y1[i] = y0[i]+1;\n            }\n        }\n        rep (i,n) {\n            idx[mp(x0[i],y0[i])] = i;\n            idx[mp(x1[i],y1[i])] = n+i;\n        }\n\n        rep (i,n) {\n            uf.unite(i,3*n+i);\n            uf.unite(n+i,2*n+i);\n        }\n        dump(uf.groups().grp);\n\n        rep (i,n) {\n            rep (dir,4) {\n                auto xy = mp(x0[i]+dx[dir], y0[i]+dy[dir]);\n                if (xy == mp(x1[i],y1[i])) continue;\n                if (idx.count(xy)) {\n                    int j = idx[xy];\n                    uf.unite(i,j);\n                    uf.unite(2*n+i,2*n+j);\n                }\n            }\n            rep (dir,4) {\n                auto xy = mp(x1[i]+dx[dir],y1[i]+dy[dir]);\n                if (xy == mp(x0[i],y0[i])) continue;\n                if (idx.count(xy)) {\n                    int j = idx[xy];\n                    uf.unite(n+i,j);\n                    uf.unite(3*n+i,2*n+j);\n                }\n            }\n        }\n        dump(uf.groups().grp);\n\n        bool ok = true;\n        rep (i,2*n) if (uf.same(i,2*n+i)) ok = false;\n        cout << (ok ? \"Yes\" : \"No\") << \"\\n\";\n\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nmap<pair<int, int>, int> pat;\nmap<pair<int, int>, pair<int, int>> opp;\n\nconst int dx[4] = {0, -1, 1, 0}, dy[4] = {-1, 0, 0, 1};\n\nbool paint(pair<int, int> p, int c) {\n    // cerr << p.first << \",\" << p.second << \" \" << c << endl;\n\n    if (!opp.count(p)) return true;\n    if (pat.count(p)) return pat[p] == c;\n\n    pat[p] = c;\n\n    for (int i = 0; i < 4; ++i) {\n        auto q = make_pair(p.first + dx[i], p.second + dy[i]);\n        if (!paint(q, (q == opp[p] ? 1 - c : c))) {\n            pat.erase(p);\n            return false;\n        }\n    }\n    return true;\n}\n\nbool solve() {\n    pat.clear();\n    opp.clear();\n\n    int N;\n    cin >> N;\n    if (N == 0) return false;\n\n    vector<pair<int, int>> T(N);\n    for (auto& t : T) {\n        char dir;\n        cin >> t.first >> t.second >> dir;\n        auto s = t;\n        ++(dir == 'x' ? s.first : s.second);\n        opp[t] = s;\n        opp[s] = t;\n    }\n\n    for (int i = 0; i < N; ++i) {\n        if (pat.count(T[i])) continue;\n        if (!paint(T[i], 0) && !paint(T[i], 1)) {\n            cout << \"No\" << endl;\n            return true;\n        }\n    }\n\n    cout << \"Yes\" << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, lli> P;\n\nconst lli N = 20000;\n\nclass T{\npublic:\n  lli x, y;\n  char c;\n  T(){}\n  T(lli x, lli y, char c) : x(x), y(y), c(c){}\n};\n\nvector<T> data;\nmap<P, lli> mp;\nmap<P, lli> dist; // 0 = atama, 1= ashi;\nbool ans;\nlli dx[2][6] = {\n  {0, 1, 2, 1, 0, -1},\n  {0, 1, 1, 0, -1, -1}\n};\nlli dy[2][6] = {\n  {-1, -1, 0, 1, 1, 0},\n  {-2, -1, 0, 1, 0, -1}\n};\nlli dx2[4] = {0, 1, 0, -1};\nlli dy2[4] = {-1, 0, 1, 0};\n\nvoid dfs(lli pos){\n  lli next[2] = {-1, -1};\n  P p[2];\n  lli d = (data[pos].c == 'x' ? 0 : 1);\n  p[0] = make_pair(data[pos].x, data[pos].y);\n  p[1] = (d ? make_pair(data[pos].x, data[pos].y+1) : make_pair(data[pos].x+1, data[pos].y));\n  for(lli k=0;k<2;k++){\n    for(lli i=0;i<4;i++){\n      lli nx = p[k].first + dx2[i];\n      lli ny = p[k].second + dy2[i];\n      P np = make_pair(nx, ny);\n      if(dist.find(np) != dist.end()){\n\tlli nc = dist[np];\n\tif(next[k] == -1) next[k] = nc;\n\telse if(next[k] != nc){\n\t  ans = false;\n\t  return;\n\t}\n      }\n    }\n  }\n  if(next[0] != -1 && next[0] == next[1]){\n    ans = false;\n    return;\n  }\n  if(next[0] == -1 && next[1] == -1){\n    dist[p[0]] = 0;\n    dist[p[1]] = 1;\n  }else if(next[0] == -1){\n    dist[p[0]] = 1 - next[1];\n    dist[p[1]] = next[1];\n  }else if(next[1] == -1){\n    dist[p[0]] = next[0];\n    dist[p[1]] = 1 - next[0];\n  }else{\n    dist[p[0]] = next[0];\n    dist[p[1]] = next[1];\n  }\n  for(lli i=0;i<6;i++){\n    lli nx = p[0].first + dx[d][i];\n    lli ny = p[0].second + dy[d][i];\n    P np = make_pair(nx, ny);\n    if(mp.find(np) != mp.end() && dist.find(np) == dist.end()){\n      dfs(mp[np]);\n    }\n  }      \n}\n\nvoid init(){\n  mp.clear();\n  dist.clear();\n  ans = true;\n  data.clear();\n}\n\nint main(){\n  lli n;\n  while(cin >> n && n){\n    init();\n    for(lli i=0;i<n;i++){\n      T in;\n      cin >> in.x >> in.y >> in.c;\n      data.push_back(in);\n      if(in.c == 'x'){\n\tmp[make_pair(in.x, in.y)] = i;\n\tmp[make_pair(in.x+1, in.y)] = i;\n      }else{\n\tmp[make_pair(in.x, in.y)] = i;\n\tmp[make_pair(in.x, in.y+1)] = i;\n      }\n    }\n    for(lli i=0;i<n;i++){\n      P p = make_pair(data[i].x, data[i].y);\n      if(dist.find(p) == dist.end()){\n\tdfs(i);\n      }\n    }\n    cout << (ans ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int sz = 100010;\nvector<int> G[sz];\nvector<int> rG[sz];\nint cmp[sz];\nbool visit[sz];\n\nvoid dfs(int v, vector<int> &vs){\n  visit[v] = true;\n  REP(i, G[v].size()) if(!visit[G[v][i]]) dfs(G[v][i], vs);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n  visit[v] = true;\n  cmp[v] = k;\n  REP(i, rG[v].size()) if(!visit[rG[v][i]]) rdfs(rG[v][i], k);\n}\n\nint scc(int V){\n  int k = 0;\n  vector<int> vs;\n  \n  memset(visit, false, sizeof(visit));  \n  REP(i, V) if(!visit[i]) dfs(i, vs);\n  memset(visit, false, sizeof(visit));\n  reverse(ALL(vs));\n  REP(i, vs.size())if(!visit[vs[i]]) rdfs(vs[i], k++);\n  return k;\n}\n\nvoid clear(){\n  REP(i, sz){\n    G[i].clear();\n    rG[i].clear();\n  }\n}\n\nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    clear();\n    char dir;\n    vector<int> x(n * 2);\n    vector<int> y(n * 2);\n    vector<int> d(n * 2);\n    \n    REP(i, n){\n      cin >> x[i] >> y[i] >> dir;\n      x[i+n] = x[i];\n      y[i+n] = y[i];\n      \n      if(dir == 'x'){\n        x[i+n]++;\n        d[i] = 0;\n        d[i+n] = 2;\n      }\n      \n      if(dir == 'y'){\n        y[i+n]++;\n        d[i] = 1;\n        d[i+n] = 3;\n      }\n    }\n    \n    n *= 2;\n    map<P, int> futon;    \n    REP(i, n) futon[P(x[i], y[i])] = i;\n    \n    REP(i, n){\n      int dx[4] = {1, 0, -1, 0};\n      int dy[4] = {0, 1, 0, -1};     \n      REP(j, 4){\n        int xa = x[i] + dx[j];\n        int ya = y[i] + dy[j];\n\n        if(futon.find(P(xa, ya)) != futon.end()){\n          int f = futon[P(xa, ya)];\n          if(j == d[i]){\n            add_edge(i, f + n);\n            add_edge(i + n, f);\n            add_edge(f, i + n);\n            add_edge(f + n, i);\n          }else{\n            add_edge(i + n, f + n);\n            add_edge(f + n, i + n);\n            add_edge(i, f);\n            add_edge(f, i);\n          }\n        }\n      }\n    }\n\n    bool possible = true;\n    scc(2 * n);\n    REP(i, n){\n      possible &= cmp[i] != cmp[n + i];\n    }\n    cout << (possible ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\nint const OppoSide = 0;\nint const SameSide = 1;\n\nint N;\nvector<pair<int, int>> G[44444];\nmap<pair<int, int>, int> MP;\nmap<int, pair<int, int>> CD;\nint vis[44444];\n\nbool dfs(int curr, int col) {\n  for(auto& e: G[curr]) {\n    int next, dir; tie(next, dir) = e;\n    int nextCol = dir == OppoSide ? col ^ 1 : col;\n    if(vis[next] + 1) {\n      if(vis[next] != nextCol) return false;\n    } else {\n      vis[next] = nextCol;\n      if(!dfs(next, nextCol)) return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n\n  for(int M; cin >> M && M;) {\n    vector<int> xs, ys;\n    vector<int> X, Y; vector<char> D;\n    rep(i, M) {\n      int x, y; char d; cin >> x >> y >> d;\n      X.push_back(x), Y.push_back(y), D.push_back(d);\n\n      xs.push_back(x-1),  ys.push_back(y-1);\n      xs.push_back(x),    ys.push_back(y);\n      xs.push_back(x+1),  ys.push_back(y+1);\n\n      if(d == 'x') {\n        xs.push_back(x+2);\n      } else {\n        ys.push_back(y+2);\n      }\n\n    }\n\n    sort(all(xs)); xs.erase(unique(all(xs)), xs.end());\n    sort(all(ys)); ys.erase(unique(all(ys)), ys.end());\n\n    vector<int> NX, NY;\n    rep(i, X.size()) {\n      NX.push_back(lower_bound(all(xs), X[i]) - X.begin());\n    }\n    rep(i, Y.size()) {\n      NY.push_back(lower_bound(all(ys), Y[i]) - Y.begin());\n    }\n    X = NX, Y = NY;\n\n    MP.clear(), CD.clear();\n    rep(i, 44444) G[i].clear();\n    N = 0;\n\n    rep(i, X.size()) {\n      MP[make_pair(Y[i], X[i])] = N;\n      CD[N++] = make_pair(Y[i], X[i]);\n      if(D[i] == 'x') {\n        MP[make_pair(Y[i], X[i]+1)] = N;\n        CD[N] = make_pair(Y[i], X[i]+1);\n        G[N-1].emplace_back(N, OppoSide), G[N].emplace_back(N-1, OppoSide);\n        N++;\n      } else {\n        MP[make_pair(Y[i]+1, X[i])] = N;\n        CD[N] = make_pair(Y[i]+1, X[i]);\n        G[N-1].emplace_back(N, OppoSide), G[N].emplace_back(N-1, OppoSide);\n        N++;\n      }\n    }\n\n    rep(i, N) {\n      auto curr = CD[i];\n      rep(k, 4) {\n        auto next = make_pair(CD[i].first + dy[k], CD[i].second + dx[k]);\n        if(MP.find(next) == MP.end()) continue; // テ・ツクツε・ツ崢」テ」ツ??」ツ?妥ィツェツソテ」ツ?ケテ」ツつ古」ツ?ーOK\n        if(find(all(G[i]), make_pair(MP[next], OppoSide)) != G[i].end()) continue;  // テ・ツ按・テ」ツ?ョテ・ツクツε・ツ崢」テ」ツ?ッSameSideテ」ツ?療」ツ?凝・ツ?・テ」ツつ古」ツつ暗」ツ??」ツ?ィテ」ツ?療」ツ?ェテ」ツ??」ツ?凝」ツつ碓K\n        G[i].emplace_back(MP[next], SameSide);\n      }\n    }\n\n    minus(vis);\n    vis[0] = 0;\n\n    bool ok = 1;\n\n    rep(i, N) {\n      if(vis[i] < 0) {\n        if(!dfs(0, 0)) {\n          ok = 0;\n          break;\n        }\n      }\n    }\n\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\n\n#define TOP 2\n#define RIGHT 1\n\ntypedef pair<int,int> P;\n\nmap<P, P> graph; //テ」ツ?ゥテ」ツ?ョテ」ツつサテ」ツδォテ」ツ?古」ツ?ゥテ」ツ?ョテ」ツつサテ」ツδォテ」ツ?ィテァツケツ凝」ツ?古」ツ?」テ」ツ?ヲテ」ツ??」ツつ凝」ツ??\nset<P> isLeg;    //ティツカツウテ」ツ?ョテ、ツスツ催ァツスツョテ」ツつ津ィツィツ佚ヲツ?カ\nset<P> isHead;   //テゥツ?ュテ」ツ?ョテ、ツスツ催ァツスツョテ」ツつ津ィツィツ佚ヲツ?カ\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\n\nbool dfs(P leg, P head){\n  isLeg.insert(leg);\n  isHead.insert(head);\n\n  for(int i = 0; i < 4; i++){\n    P nleg(leg.first + dx[i], leg.second + dy[i]);\n\n    if(nleg == head) continue;\n    if(isHead.find(nleg) != isHead.end()) return false;\n    if(isLeg.find(nleg) != isLeg.end()) continue;\n    if(graph.find(nleg) == graph.end()) continue;\n\n    P nhead = graph[nleg];\n\n    if(!dfs(nleg, nhead)) return false;\n  }\n\n  for(int i = 0; i < 4; i++){\n    P nhead(head.first + dx[i], head.second + dy[i]);\n\n    if(nhead == leg) continue;\n    if(isHead.find(nhead) != isHead.end()) continue;\n    if(isLeg.find(nhead) != isLeg.end()) return false;\n    if(graph.find(nhead) == graph.end()) continue;\n\n    P nleg = graph[nhead];\n\n    if(!dfs(nleg, nhead)) return false;\n  }\n\n  return true;\n}\n\nbool solve(){\n  isHead.clear();\n  isLeg.clear();\n\n  map<P, P>::iterator iter = graph.begin();\n\n  for( ; iter != graph.end(); iter++){\n    P head = iter->first;\n    P leg = iter->second;\n\n    if(isLeg.find(head)  != isLeg.end())  continue;\n    if(isHead.find(head) != isHead.end()) continue;\n\n    if(!dfs(leg, head)) return false;\n  }\n\n  return true;\n}\n\nint main(){\n  int n;\n\n  while(cin >> n, n){\n    graph.clear();\n\n    for(int i = 0; i < n; i++){\n      int x, y;\n      char dir;\n      cin >> x >> y >> dir;\n\n      if(dir == 'x'){\n        int nx = x + dx[RIGHT];\n        int ny = y + dy[RIGHT];\n        graph[P(x, y)]   = P(nx, ny);\n        graph[P(nx, ny)] = P(x, y);\n      }\n      else{\n        int nx = x + dx[TOP];\n        int ny = y + dy[TOP];\n        graph[P(x, y)]   = P(nx, ny);\n        graph[P(nx, ny)] = P(x, y);\n      }\n    }\n\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nchar c;\nint x[20001][2],y[20001][2];\nvector<int>v[40001];\nint b[40001],f,n;\nvoid dfs(int p,int col){\n  b[p]=col;\n  r(i,v[p].size()){\n    if(!(p==v[p][i]+n||p+n==v[p][i])&&b[v[p][i]]&&b[v[p][i]]!=col)f++;\n    else if(!b[v[p][i]]){\n      if(p==v[p][i]+n||p+n==v[p][i]){\n        if(col==1)dfs(v[p][i],2);\n        else dfs(v[p][i],1);\n      }\n      else dfs(v[p][i],col);\n    }\n  }\n}\nint main(){\n  while(cin>>n,n){\n    memset(b,0,sizeof(b));\n    r(i,40001)v[i].clear();\n    r(i,n){\n      cin>>x[i][0]>>y[i][0]>>c;\n      if(c=='x')x[i][1]=x[i][0]+1,y[i][1]=y[i][0];\n      else x[i][1]=x[i][0],y[i][1]=y[i][0]+1;\n    }\n    r(i,n)v[i].push_back(i+n),v[i+n].push_back(i);\n    r(i,n)r(j,n)if(i!=j&&i<j)r(l,2)r(k,2){\n      if(abs(x[i][l]-x[j][k])+abs(y[i][l]-y[j][k])==1){\n        int p1=i,p2=j;\n        if(l)p1+=n;\n        if(k)p2+=n;\n        v[p1].push_back(p2);\n        v[p2].push_back(p1);\n      }\n    }\n    f=0;\n    r(i,n*2)if(!b[i])dfs(i,1);\n    cout<<(f?\"No\":\"Yes\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n/*\n  3344\n  1122\n\n */\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nusing namespace std;\n\nmap<pair<int, int>, int>  memo;\nvector<vector<pair<int, int> > > futon;\nvector<bool> decide;\nvector<vector<int> > foot;\n\nbool dfs(int i){\n  REP(j,2){\n    int x = futon[i][j].first;\n    int y = futon[i][j].second;\n    \n    REP(k,4){\n      int xx = x + _dx[k];\n      int yy = y + _dy[k];\n      pair<int, int> p = make_pair(xx, yy);\n      \n      if(memo.count(p) && memo[p] != i){\n\tint adj = memo[p];\n\tif(!decide[adj]){\n\t  decide[adj] = true;\n\t  if(xx == futon[adj][0].first && yy == futon[adj][0].second){\n\t    foot[adj][0] = foot[i][j];\n\t    foot[adj][1] = foot[i][j] ^ 1;\n\t  }else{\n\t    foot[adj][0] = foot[i][j] ^ 1;\n\t    foot[adj][1] = foot[i][j];\n\t  }\n\t  if(!dfs(adj)) return false;\n\t}else{\n\t  if(xx == futon[adj][0].first && yy == futon[adj][0].second){\n\t    if(foot[adj][0] != foot[i][j]) return false;\n\t  }else{\n\t    if(foot[adj][1] != foot[i][j]) return false;\n\t  }\n\t}\n      }\n    }\n  }\n  return true;\n}\n\nint main(){\n  int n;\n  while(scanf(\"%d\", &n), n){\n    memo.clear();\n    futon  = vector<vector<pair<int, int> > >(n, vector<pair<int, int> >(2));\n    decide = vector<bool>(n, false);\n    foot   = vector<vector<int> >(n, vector<int>(2));\n\n    REP(i,n){\n      int x, y;\n      char dir[2];\n\n      scanf(\"%d%d%s\", &x, &y, dir);\n\n      futon[i][0] = make_pair(x, y);\n      if(dir[0] == 'x'){\n\tfuton[i][1] = make_pair(x + 1, y);\n      }else{\n\tfuton[i][1] = make_pair(x, y + 1);\n      }\n      memo[futon[i][1]] = memo[futon[i][0]] = i;\n    }\n\n    bool ok = true;\n\n    REP(i,n) if(!decide[i]){\n      decide[i] = true;\n      foot[i][0] = 1; foot[i][1] = 0;\n      if(!dfs(i)){\n\tok = false;\n\tbreak;\n      }\n      // printf(\"%d: ok\\n\", i);\n    }\n    puts(ok ? \"Yes\" : \"No\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\nint const OppoSide = 0;\nint const SameSide = 1;\n\nint N;\nvector<pair<int, int>> G[44444];\nmap<pair<int, int>, int> MP;\nmap<int, pair<int, int>> CD;\nint vis[44444];\n\nbool dfs(int curr, int col) {\n  for(auto& e: G[curr]) {\n    int next, dir; tie(next, dir) = e;\n    int nextCol = dir == OppoSide ? col ^ 1 : col;\n    if(vis[next] + 1) {\n      if(vis[next] != nextCol) return false;\n    } else {\n      vis[next] = nextCol;\n      if(!dfs(next, nextCol)) return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n\n  for(int M; cin >> M && M;) {\n    vector<int> xs, ys;\n    vector<int> X, Y; vector<char> D;\n    rep(i, M) {\n      int x, y; char d; cin >> x >> y >> d;\n      X.push_back(x), Y.push_back(y), D.push_back(d);\n\n      xs.push_back(x-1),  ys.push_back(y-1);\n      xs.push_back(x),    ys.push_back(y);\n      xs.push_back(x+1),  ys.push_back(y+1);\n\n      if(d == 'x') {\n        xs.push_back(x+2);\n      } else {\n        ys.push_back(y+2);\n      }\n\n    }\n\n    sort(all(xs)); xs.erase(unique(all(xs)), xs.end());\n    sort(all(ys)); ys.erase(unique(all(ys)), ys.end());\n\n    vector<int> NX, NY;\n    rep(i, X.size()) {\n      NX.push_back(lower_bound(all(xs), X[i]) - X.begin());\n    }\n    rep(i, Y.size()) {\n      NY.push_back(lower_bound(all(ys), Y[i]) - Y.begin());\n    }\n    X = NX, Y = NY;\n\n    MP.clear(), CD.clear();\n    rep(i, 44444) G[i].clear();\n    N = 0;\n\n    rep(i, X.size()) {\n      MP[make_pair(Y[i], X[i])] = N;\n      CD[N++] = make_pair(Y[i], X[i]);\n      if(D[i] == 'x') {\n        MP[make_pair(Y[i], X[i]+1)] = N;\n        CD[N] = make_pair(Y[i], X[i]+1);\n        G[N-1].emplace_back(N, OppoSide), G[N].emplace_back(N-1, OppoSide);\n        N++;\n      } else {\n        MP[make_pair(Y[i]+1, X[i])] = N;\n        CD[N] = make_pair(Y[i]+1, X[i]);\n        G[N-1].emplace_back(N, OppoSide), G[N].emplace_back(N-1, OppoSide);\n        N++;\n      }\n    }\n\n    rep(i, N) {\n      auto curr = CD[i];\n      rep(k, 4) {\n        auto next = make_pair(CD[i].first + dy[k], CD[i].second + dx[k]);\n        if(MP.find(next) == MP.end()) continue; // テ・ツクツε・ツ崢」テ」ツ??」ツ?妥ィツェツソテ」ツ?ケテ」ツつ古」ツ?ーOK\n        if(find(all(G[i]), make_pair(MP[next], OppoSide)) != G[i].end()) continue;  // テ・ツ按・テ」ツ?ョテ・ツクツε・ツ崢」テ」ツ?ッSameSideテ」ツ?療」ツ?凝・ツ?・テ」ツつ古」ツつ暗」ツ??」ツ?ィテ」ツ?療」ツ?ェテ」ツ??」ツ?凝」ツつ碓K\n        G[i].emplace_back(MP[next], SameSide);\n      }\n    }\n\n    minus(vis);\n    vis[0] = 0;\n\n    bool ok = 1;\n\n    rep(i, N) {\n      if(vis[i] < 0) {\n        if(!dfs(i, 0)) {\n          ok = 0;\n          break;\n        }\n      }\n    }\n\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n\npii in[40010];\n\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\n\nint main(void){\n\tint n;\n\twhile(cin >> n){\n\t\tif(n==0) break;\n\n\t\tmap<pii,int> memo;\n\t\tbool check[40010];\n\t\trep(i,2*n) check[i]=false;\n\t\trep(i,n){\n\t\t\tchar dir;\n\t\t\tcin >> in[2*i].first >> in[2*i].second >> dir;\n\t\t\tin[2*i+1]=in[2*i];\n\t\t\tint d=(dir=='x')?2:3;\n\t\t\tin[2*i+1].first+=dx[d],in[2*i+1].second+=dy[d];\n\t\t\tmemo[in[2*i]]=2*i;\n\t\t\tmemo[in[2*i+1]]=2*i+1;\n\t\t}\n\n\t\tbool ans=true;\n\t\trep(i,n){\n\t\t\tif(check[2*i]) continue;\n\t\t\tbool ok=false;\n\t\t\trep(j,2){\n\t\t\t\tbool ok2=true;\n\t\t\t\tmap<int,int> color;\n\t\t\t\tqueue<int> q;\n\n\t\t\t\tcolor[2*i]=j;\n\t\t\t\tcolor[2*i+1]=j^1;\n\t\t\t\tcheck[2*i]=true;\n\t\t\t\tcheck[2*i+1]=true;\n\t\t\t\tq.push(2*i);\n\t\t\t\tq.push(2*i+1);\n\n\t\t\t\twhile(!q.empty()){\n\t\t\t\t\tint cur=q.front();q.pop();\n\t\t\t\t\tpii xy=in[cur];\n\t\t\t\t\trep(l,4){\n\t\t\t\t\t\tpii next=xy;\n\t\t\t\t\t\tnext.first+=dx[l],next.second+=dy[l];\n\t\t\t\t\t\tif(memo.find(next)==memo.end()) continue;\n\t\t\t\t\t\tint index=memo[next];\n\t\t\t\t\t\tif(color.find(index)==color.end()){\n\t\t\t\t\t\t\tcolor[index]=color[cur];\n\t\t\t\t\t\t\tcolor[index^1]=color[cur]^1;\n\t\t\t\t\t\t\tcheck[index]=true;\n\t\t\t\t\t\t\tcheck[index^1]=true;\n\t\t\t\t\t\t\tq.push(index);\n\t\t\t\t\t\t\tq.push(index^1);\n\t\t\t\t\t\t}else if((cur^1)!=index&&color[index]!=color[cur])\n\t\t\t\t\t\t\tok2=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok2) ok=true;\n\t\t\t}\n\t\t\tif(!ok) ans=false;\n\t\t}\n\t\tif(ans)\n\t\t\tputs(\"Yes\");\n\t\telse\n\t\t\tputs(\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 20000\n#define HEAD MOD\n#define FOOT MOD+1\n\ntypedef pair<int,int> Point;\n\nenum Type{\n\tTATE,\n\tYOKO,\n};\n\nstruct Info{\n\tint row,col;\n\tType dir;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_index,int arg_which){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tindex = arg_index;\n\t\twhich = arg_which;\n\t}\n\n\tint row,col,index,which;\n};\n\n\nmap<Point,int> MAP;\nInfo info[NUM];\nvector<int> Group[NUM];\n\nint near_row[4] = {-1,0,0,1},near_col[4] = {0,-1,1,0};\nint diff_row[2][6] = {{-2,-1,-1,0,0,1},{-1,-1,0,0,1,1}},diff_col[2][6] = {{0,-1,1,-1,1,0},{0,1,-1,2,0,1}};\n\nint N;\nint boss[NUM],height[NUM];\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nbool check(int group_id){\n\n\tmap<Point,int> ROOM;\n\tqueue<Data> Q;\n\tbool used[N];\n\tfor(int i = 0; i < N; i++)used[i] = false;\n\n\tROOM[Point(info[group_id].row,info[group_id].col)] = HEAD;\n\tQ.push(Data(info[group_id].row,info[group_id].col,group_id,HEAD));\n\n\tbool FLG = true;\n\n\tint adj_row,adj_col,adj_index;\n\n\twhile(!Q.empty()){\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tadj_row = Q.front().row+near_row[i];\n\t\t\tadj_col = Q.front().col+near_col[i];\n\n\t\t\tauto at = MAP.find(Point(adj_row,adj_col));\n\t\t\tif(at == MAP.end())continue;\n\n\t\t\tadj_index = MAP[Point(adj_row,adj_col)];\n\t\t\tif(used[adj_index])continue;\n\n\t\t\tif(adj_index != Q.front().index){\n\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,HEAD));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,FOOT));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif((ROOM[Point(adj_row,adj_col)] == FOOT && Q.front().which == HEAD) ||\n\t\t\t\t\t\t\t(ROOM[Point(adj_row,adj_col)] == HEAD && Q.front().which == FOOT)){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,FOOT));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,HEAD));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(ROOM[Point(adj_row,adj_col)] == Q.front().which){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tused[adj_index] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG)break;\n\n\t\tQ.pop();\n\t}\n\n\tif(FLG)return true;\n\n\n\tFLG = true;\n\tROOM.clear();\n\tfor(int i = 0; i < N; i++)used[i] = false;\n\n\tROOM[Point(info[group_id].row,info[group_id].col)] = HEAD;\n\tQ.push(Data(info[group_id].row,info[group_id].col,group_id,HEAD));\n\n\twhile(!Q.empty()){\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tadj_row = Q.front().row+near_row[i];\n\t\t\tadj_col = Q.front().col+near_col[i];\n\n\t\t\tauto at = MAP.find(Point(adj_row,adj_col));\n\t\t\tif(at == MAP.end())continue;\n\n\t\t\tadj_index = MAP[Point(adj_row,adj_col)];\n\t\t\tif(used[adj_index])continue;\n\n\t\t\tif(adj_index != Q.front().index){\n\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,HEAD));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,FOOT));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif((ROOM[Point(adj_row,adj_col)] == FOOT && Q.front().which == HEAD) ||\n\t\t\t\t\t\t\t(ROOM[Point(adj_row,adj_col)] == HEAD && Q.front().which == FOOT)){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,FOOT));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,HEAD));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(ROOM[Point(adj_row,adj_col)] == Q.front().which){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tused[adj_index] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG)break;\n\n\t\tQ.pop();\n\t}\n\n\treturn FLG;\n}\n\nvoid func(){\n\n\tMAP.clear();\n\tfor(int i = 0; i < N; i++)Group[i].clear();\n\n\tinit();\n\n\tchar buf[2];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %s\",&info[i].col,&info[i].row,buf);\n\t\tif(buf[0] == 'x'){\n\t\t\tinfo[i].dir = YOKO;\n\t\t}else{\n\t\t\tinfo[i].dir = TATE;\n\t\t}\n\t\tMAP[Point(info[i].row,info[i].col)] = i;\n\t\tif(info[i].dir == YOKO){\n\t\t\tMAP[Point(info[i].row,info[i].col+1)] = i;\n\t\t}else{\n\t\t\tMAP[Point(info[i].row-1,info[i].col+1)] = i;\n\t\t}\n\t}\n\n\tint adj_row,adj_col;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < 6; k++){\n\t\t\tadj_row = info[i].row+diff_row[info[i].dir][k];\n\t\t\tadj_col = info[i].col+diff_col[info[i].dir][k];\n\n\t\t\tauto at = MAP.find(Point(adj_row,adj_col));\n\t\t\tif(at == MAP.end())continue;\n\n\t\t\tunite(i,MAP[Point(adj_row,adj_col)]);\n\t\t}\n\t}\n\n\tvector<int> BOSS;\n\tfor(int i = 0; i < N; i++){\n\t\tGroup[get_boss(i)].push_back(i);\n\t\tif(boss[i] == i){\n\t\t\tBOSS.push_back(i);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < BOSS.size(); i++){\n\t\tif(check(BOSS[i]) == false){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tprintf(\"Yes\\n\");\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P, P> PP;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main() {\n\tint n;\n\twhile(cin >> n && n) {\n\n\t\tvector<PP> v(n);\n\t\tmap<P, int> id;\n\t\trep(i, n) {\n\t\t\tint x, y;\n\t\t\tchar dir;\n\t\t\tcin >> x >> y >> dir;\n\t\t\n\t\t\tid[mp(x, y)] = i;\n\t\t\tv[i].first = mp(x, y);\n\n\t\t\tif(dir == 'x') {\n\t\t\t\tid[mp(x+1, y)] = i;\n\t\t\t\tv[i].second = mp(x+1, y);\n\t\t\t} else {\n\t\t\t\tid[mp(x, y+1)] = i;\n\t\t\t\tv[i].second = mp(x, y+1);\n\t\t\t}\n\t\t}\n\n\t\tmap<P, bool> head, foot;\n\t\tint inQ[200005];\n\t\tmemset(inQ, 0, sizeof(inQ));\n\n\t\tbool used[200005];\n\t\tmemset(used, 0, sizeof(used));\n\n\t\tbool res = false;\n\n\t\trep(i, n) {\n\t\t\tif(used[i]) continue;\n\n\t\t\tqueue<PP> que;\n\t\t\tque.push(v[i]);\n\t\t\tinQ[i] = true;\n\n\t\t\twhile(que.size()) {\n\t\t\t\tPP p = que.front(); que.pop();\n\t\t\t\tint pid = id[p.first];\n\t\t\t\tinQ[pid] = false;\n\n\t\t\t\tbool flag = false;\n\t\t\t\trep(j, 4) {\n\t\t\t\t\tint ny = p.first.first + dy[j];\n\t\t\t\t\tint nx = p.first.second + dx[j];\n\n\t\t\t\t\tflag |= foot[mp(ny, nx)];\n\t\t\t\t}\n\n\t\t\t\trep(j, 4) {\n\t\t\t\t\tint ny = p.second.first + dy[j];\n\t\t\t\t\tint nx = p.second.second + dx[j];\n\n\t\t\t\t\tflag |= head[mp(ny, nx)];\n\t\t\t\t}\n\n\t\t\t\tif(!flag) {\n\t\t\t\t\tused[pid] = true;\n\t\t\t\t\thead[p.first] = true;\n\t\t\t\t\tfoot[p.second] = true;\n\n\t\t\t\t\trep(j, 4) {\n\t\t\t\t\t\tint ny = p.first.first + dy[j];\n\t\t\t\t\t\tint nx = p.first.second + dx[j];\n\t\t\t\t\t\tP np = mp(ny, nx);\n\t\t\t\t\t\tint nj = id[mp(ny, nx)];\n\n\t\t\t\t\t\trep(k, 4) {\n\t\t\t\t\t\t\tint nny = ny + dy[k];\n\t\t\t\t\t\t\tint nnx = nx + dx[k];\n\t\t\t\t\t\t\tP nnp = mp(nny, nnx);\n\t\t\t\t\t\t\tint nk = id[mp(nny, nnx)];\n\n\t\t\t\t\t\t\tif(nj == nk && !used[nj] && !inQ[nj]) {\n\t\t\t\t\t\t\t\tinQ[nj] = true;\n\t\t\t\t\t\t\t\tque.push(mp(np, nnp));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\trep(j, 4) {\n\t\t\t\t\t\tint ny = p.second.first + dy[j];\n\t\t\t\t\t\tint nx = p.second.second + dx[j];\n\t\t\t\t\t\tP np = mp(ny, nx);\n\t\t\t\t\t\tint nj = id[mp(ny, nx)];\n\n\t\t\t\t\t\trep(k, 4) {\n\t\t\t\t\t\t\tint nny = ny + dy[k];\n\t\t\t\t\t\t\tint nnx = nx + dx[k];\n\t\t\t\t\t\t\tP nnp = mp(nny, nnx);\n\t\t\t\t\t\t\tint nk = id[mp(nny, nnx)];\n\n\t\t\t\t\t\t\tif(nj == nk && !used[nj] && !inQ[nj]) {\n\t\t\t\t\t\t\t\tinQ[nj] = true;\n\t\t\t\t\t\t\t\tque.push(mp(np, nnp));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tflag = false;\n\t\t\t\trep(j, 4) {\n\t\t\t\t\tint ny = p.second.first + dy[j];\n\t\t\t\t\tint nx = p.second.second + dx[j];\n\n\t\t\t\t\tflag |= foot[mp(ny, nx)];\n\t\t\t\t}\n\n\t\t\t\trep(j, 4) {\n\t\t\t\t\tint ny = p.first.first + dy[j];\n\t\t\t\t\tint nx = p.first.second + dx[j];\n\n\t\t\t\t\tflag |= head[mp(ny, nx)];\n\t\t\t\t}\n\n\t\t\t\tif(!flag) {\n\t\t\t\t\tused[pid] = true;\n\t\t\t\t\thead[p.second] = true;\n\t\t\t\t\tfoot[p.first] = true;\n\n\t\t\t\t\trep(j, 4) {\n\t\t\t\t\t\tint ny = p.first.first + dy[j];\n\t\t\t\t\t\tint nx = p.first.second + dx[j];\n\t\t\t\t\t\tP np = mp(ny, nx);\n\t\t\t\t\t\tint nj = id[mp(ny, nx)];\n\n\t\t\t\t\t\trep(k, 4) {\n\t\t\t\t\t\t\tint nny = ny + dy[k];\n\t\t\t\t\t\t\tint nnx = nx + dx[k];\n\t\t\t\t\t\t\tP nnp = mp(nny, nnx);\n\t\t\t\t\t\t\tint nk = id[mp(nny, nnx)];\n\n\t\t\t\t\t\t\tif(nj == nk && !used[nj] && !inQ[nj]) {\n\t\t\t\t\t\t\t\tinQ[nj] = true;\n\t\t\t\t\t\t\t\tque.push(mp(np, nnp));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\trep(j, 4) {\n\t\t\t\t\t\tint ny = p.second.first + dy[j];\n\t\t\t\t\t\tint nx = p.second.second + dx[j];\n\t\t\t\t\t\tP np = mp(ny, nx);\n\t\t\t\t\t\tint nj = id[mp(ny, nx)];\n\n\t\t\t\t\t\trep(k, 4) {\n\t\t\t\t\t\t\tint nny = ny + dy[k];\n\t\t\t\t\t\t\tint nnx = nx + dx[k];\n\t\t\t\t\t\t\tP nnp = mp(nny, nnx);\n\t\t\t\t\t\t\tint nk = id[mp(nny, nnx)];\n\n\t\t\t\t\t\t\tif(nj == nk && !used[nj] && !inQ[nj]) {\n\t\t\t\t\t\t\t\tinQ[nj] = true;\n\t\t\t\t\t\t\t\tque.push(mp(np, nnp));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tres = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(res) cout << \"No\" << endl;\n\t\telse cout << \"Yes\" << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass Cell{\npublic:\n  int id;\n  int x;\n  int y;\n  bool has_head;\n  bool has_leg;\n  Cell(){}\n  Cell(int _id,int _x,int _y) : id(_id), x(_x), y(_y),has_head(false),has_leg(false) {}\n};\n\nclass Bed{\npublic:\n  Cell head;\n  Cell tail;\n  bool has_head;\n\n  Bed() {}\n  Bed (Cell _c1, Cell _c2) : head(_c1),tail(_c2),has_head(false){}\n  Cell* getCell(int x,int y){\n    if(head.x == x && head.y == y){\n      return &head;\n    }\n\n    else if(tail.x == x && tail.y == y){\n      return &tail;\n    }\n  }\n\n  Cell* getCellOtherSide(int x,int y){\n    if(head.x == x && head.y == y){\n      return &tail;\n    }\n\n    else if(tail.x == x && tail.y == y){\n      return &head;\n    }\n  }\n\n  bool is_used(){\n    return (head.has_head || tail.has_head || head.has_leg || tail.has_leg);\n  }\n\n  bool is_same_bed(int x,int y){\n    if((head.x == x && head.y == y) || (tail.x == x && tail.y == y)){\n      return true;\n    }\n    return false;\n  }\n};\n\nvoid dfs(map<P,Bed*>& stage, map<P,Bed*>::iterator it, bool used[20000]){\n  int id = it->second->head.id;\n  used[id] = true;\n\n  int head_x = it->second->head.x;\n  int head_y = it->second->head.y;\n  bool is_head_leg = it->second->head.has_leg;\n  bool is_head_head = it->second->head.has_head;\n\n  int tail_x = it->second->tail.x;\n  int tail_y = it->second->tail.y;\n  bool is_tail_leg = it->second->tail.has_leg;\n  bool is_tail_head = it->second->tail.has_head;\n\n  map<P,Bed*>::iterator dst_bed;\n  for(int i=0;i<4;i++){\n    int dx = head_x + tx[i];\n    int dy = head_y + ty[i];\n\n    if(is_head_head){\n      if((dst_bed = stage.find(P(dx,dy))) != stage.end()){\n\tif(dst_bed->second->is_used()) continue;\n\n\tdst_bed->second->getCell(dx,dy)->has_head = true;\n\tdst_bed->second->getCellOtherSide(dx,dy)->has_leg = true;\n\t// printf(\"x:%d y:%d %s\\n\",dx,dy,\"h\");\n\tdfs(stage,dst_bed,used);\n      }\n    }\n\n    else if(is_head_leg){\n      if((dst_bed = stage.find(P(dx,dy))) != stage.end()){\n\tif(dst_bed->second->is_used()) continue;\n\n\tdst_bed->second->getCell(dx,dy)->has_leg = true;\n\tdst_bed->second->getCellOtherSide(dx,dy)->has_head = true;\n\t// printf(\"x:%d y:%d %s\\n\",dx,dy,\"l\");\n\tdfs(stage,dst_bed,used);\n      }\n    }\n  }\n  for(int i=0;i<4;i++){\n    int dx = tail_x + tx[i];\n    int dy = tail_y + ty[i];\n    \n    if(is_tail_leg){\n      if((dst_bed = stage.find(P(dx,dy))) != stage.end()){\n\tif(dst_bed->second->is_used()) continue;\n\n\tdst_bed->second->getCell(dx,dy)->has_leg = true;\n\tdst_bed->second->getCellOtherSide(dx,dy)->has_head = true;\n\t// printf(\"x:%d y:%d %s\\n\",dx,dy,\"l\");\n\tdfs(stage,dst_bed,used);\n      }\n    }\n\n    else if(is_tail_head){\n      if((dst_bed = stage.find(P(dx,dy))) != stage.end()){\n\tif(dst_bed->second->is_used()) continue;\n\n\tdst_bed->second->getCell(dx,dy)->has_head = true;\n\tdst_bed->second->getCellOtherSide(dx,dy)->has_leg = true;\n\t// printf(\"x:%d y:%d %s\\n\",dx,dy,\"h\");\n\tdfs(stage,dst_bed,used);\n      }\n    }\n  }\n}\n\nbool checkStage(map<P,Bed*>& stage){\n  for(map<P,Bed*>::iterator it = stage.begin();\n    \tit != stage.end();\n    \tit++){\n    int id = it->second->head.id;\n\n    int head_x = it->second->head.x;\n    int head_y = it->second->head.y;\n    bool is_head_leg = it->second->head.has_leg;\n    bool is_head_head = it->second->head.has_head;\n\n    int tail_x = it->second->tail.x;\n    int tail_y = it->second->tail.y;\n    bool is_tail_leg = it->second->tail.has_leg;\n    bool is_tail_head = it->second->tail.has_head;\n\n    map<P,Bed*>::iterator dst_bed;\n    for(int i=0;i<4;i++){\n      int dx = head_x + tx[i];\n      int dy = head_y + ty[i];\n      if(it->second->is_same_bed(dx,dy)) continue;\n      if((dst_bed = stage.find(P(dx,dy))) != stage.end()){\n\tif(is_head_leg){\n\t  if(dst_bed->second->getCell(dx,dy)->has_head) return false;\n\t}\n\telse if(is_head_head){\n\t  if(dst_bed->second->getCell(dx,dy)->has_leg) return false;\n\t}\n      }\n    }\n\n    for(int i=0;i<4;i++){\n      int dx = tail_x + tx[i];\n      int dy = tail_y + ty[i];\n      if(it->second->is_same_bed(dx,dy)) continue;\n      if((dst_bed = stage.find(P(dx,dy))) != stage.end()){\n\tif(is_tail_leg){\n\t  if(dst_bed->second->getCell(dx,dy)->has_head) return false;\n\t}\n\telse if(is_tail_head){\n\t  if(dst_bed->second->getCell(dx,dy)->has_leg) return false;\n\t}\n      }\n    }\n  }\n  return true;\n}\n\nint main(){\n  int total_beds;\n  while(~scanf(\"%d\",&total_beds)){\n    if(total_beds == 0) break;\n\n    map<P,Bed*> stage;\n    bool used[20000];\n    memset(used,false,sizeof(used));\n    \n    for(int bed_idx = 0; bed_idx < total_beds; bed_idx++){\n      int x,y;\n      char dir[2];\n      scanf(\"%d %d %s\",&x,&y,dir);\n\n      int dx = 0;\n      int dy = 0;\n      if(dir[0] == 'x'){\n\tdx = x+1;\n\tdy = y;\n      }\n      else if(dir[0] == 'y'){\n\tdx = x;\n\tdy = y+1;\n      }\n\n      Cell head(bed_idx,x,y);\n      Cell tail(bed_idx,dx,dy);\n\n      Bed* bed = new Bed(head,tail);\n\n      stage[P(x,y)] = bed;\n      stage[P(dx,dy)] = bed;\n    }\n\n    for(map<P,Bed*>::iterator it = stage.begin();\n    \tit != stage.end();\n    \tit++){\n      int id = it->second->head.id;\n      if(used[id]) continue;\n\n      // printf(\"x:%d y:%d %s\\n\",it->second->head.x,it->second->head.y,\"h\");\n      it->second->head.has_head = true;\n      it->second->tail.has_leg = true;\n      dfs(stage,it,used);\n    }\n\n    bool isok = checkStage(stage);\n    printf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <utility>\nusing namespace std;\n\nint dx[4]={1, 0, -1, 0};\nint dy[4]={0, 1, 0, -1};\n\nbool fill(int idx, vector<vector<pair<int,int> > > &adj, vector<int> &alloc){\n    for(int i=0; i<(int)adj[idx].size(); i++){\n        int nidx = adj[idx][i].first;\n        int change = adj[idx][i].second;\n        if(alloc[nidx]!=-1){\n            if((alloc[nidx]+alloc[idx])%2 != change) return false;\n        }else{\n            alloc[nidx] = (alloc[idx]+change)%2;\n            if(!fill(nidx, adj, alloc)) return false;;\n        }\n    }\n    return true;\n}\n\nbool check(vector<vector<pair<int,int> > > &adj){\n    int n = adj.size();\n    vector<int> alloc(n, -1);\n    for(int i=0; i<n; i++){\n        if(alloc[i] == -1){\n            alloc[i]=0;\n            if(!fill(i, adj, alloc)){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        map<pair<int,int>, int> coord;\n        for(int i=0; i<n; i++){\n            int x,y;\n            char c;\n            cin >> x >> y >> c;\n            coord[make_pair(x,y)] = 2*i;\n            if(c=='x') x++;\n            else y++;\n            coord[make_pair(x,y)] = 2*i+1;\n        }\n        \n        vector<vector<pair<int,int> > > adj(2*n);\n        for(int i=0; i<2*n; i+=2){\n            adj[i].push_back(make_pair(i+1, 1));\n            adj[i+1].push_back(make_pair(i, 1));\n        }\n\n        for(map<pair<int,int>, int>::iterator itr=coord.begin(); itr!=coord.end(); itr++){\n            int x = itr->first.first, y = itr->first.second;\n            int idx = itr->second;\n            int p = (idx%2==0)? 1: -1;\n            for(int i=0; i<4; i++){\n                pair<int, int> key(x+dx[i], y+dy[i]);\n                if(coord.count(key)!=0 && coord[key]!=idx+p){\n                    adj[idx].push_back(make_pair(coord[key], 0));\n                }\n            }\n        }\n        \n        if(check(adj)){\n            cout << \"Yes\" << endl;\n        }else{\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P, P> PP;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main() {\n\tint n;\n\twhile(cin >> n && n) {\n\n\t\tvector<PP> v(n);\n\t\tmap<P, int> id;\n\t\trep(i, n) {\n\t\t\tint x, y;\n\t\t\tchar dir;\n\t\t\tcin >> x >> y >> dir;\n\t\t\n\t\t\tid[mp(x, y)] = i;\n\t\t\tv[i].first = mp(x, y);\n\n\t\t\tif(dir == 'x') {\n\t\t\t\tid[mp(x+1, y)] = i;\n\t\t\t\tv[i].second = mp(x+1, y);\n\t\t\t} else {\n\t\t\t\tid[mp(x, y+1)] = i;\n\t\t\t\tv[i].second = mp(x, y+1);\n\t\t\t}\n\t\t}\n\n\t\tmap<P, bool> memo;\n\t\tint inQ[200005];\n\t\tmemset(inQ, 0, sizeof(inQ));\n\n\t\tbool used[200005];\n\t\tmemset(used, 0, sizeof(used));\n\n\t\tbool res = false;\n\n\t\trep(i, n) {\n\t\t\tif(used[i]) continue;\n\n\t\t\tqueue<PP> que;\n\t\t\tque.push(v[i]);\n\t\t\tinQ[i] = true;\n\n\t\t\twhile(que.size()) {\n\t\t\t\tPP p = que.front(); que.pop();\n\t\t\t\tint pid = id[p.first];\n\t\t\t\tinQ[pid] = false;\n\n\t\t\t\tbool flag = false;\n\t\t\t\trep(j, 4) {\n\t\t\t\t\tint ny = p.first.first + dy[j];\n\t\t\t\t\tint nx = p.first.second + dx[j];\n\n\t\t\t\t\tflag |= memo[mp(ny, nx)];\n\t\t\t\t}\n\n\t\t\t\tif(!flag) {\n\t\t\t\t\tused[pid] = true;\n\t\t\t\t\tmemo[p.second] = true;\n\n\t\t\t\t\trep(j, 4) {\n\t\t\t\t\t\tint ny = p.first.first + dy[j];\n\t\t\t\t\t\tint nx = p.first.second + dx[j];\n\t\t\t\t\t\tP np = mp(ny, nx);\n\t\t\t\t\t\tint nj = id[mp(ny, nx)];\n\n\t\t\t\t\t\trep(k, 4) {\n\t\t\t\t\t\t\tint nny = ny + dy[k];\n\t\t\t\t\t\t\tint nnx = nx + dx[k];\n\t\t\t\t\t\t\tP nnp = mp(nny, nnx);\n\t\t\t\t\t\t\tint nk = id[mp(ny, nx)];\n\n\t\t\t\t\t\t\tif(nj == nk && !used[nj] && !inQ[nj]) {\n\t\t\t\t\t\t\t\tinQ[ id[mp(ny, nx)] ] = true;\n\t\t\t\t\t\t\t\tque.push(mp(np, nnp));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tflag = false;\n\t\t\t\trep(j, 4) {\n\t\t\t\t\tint ny = p.second.first + dy[j];\n\t\t\t\t\tint nx = p.second.second + dx[j];\n\n\t\t\t\t\tflag |= memo[mp(ny, nx)];\n\t\t\t\t}\n\n\t\t\t\tif(!flag) {\n\t\t\t\t\tused[pid] = true;\n\t\t\t\t\tmemo[p.first] = true;\n\n\t\t\t\t\trep(j, 4) {\n\t\t\t\t\t\tint ny = p.first.first + dy[j];\n\t\t\t\t\t\tint nx = p.first.second + dx[j];\n\t\t\t\t\t\tP np = mp(ny, nx);\n\t\t\t\t\t\tint nj = id[mp(ny, nx)];\n\n\t\t\t\t\t\trep(k, 4) {\n\t\t\t\t\t\t\tint nny = ny + dy[k];\n\t\t\t\t\t\t\tint nnx = nx + dx[k];\n\t\t\t\t\t\t\tP nnp = mp(nny, nnx);\n\t\t\t\t\t\t\tint nk = id[mp(ny, nx)];\n\n\t\t\t\t\t\t\tif(nj == nk && !used[nj] && !inQ[nj]) {\n\t\t\t\t\t\t\t\tinQ[ id[mp(ny, nx)] ] = true;\n\t\t\t\t\t\t\t\tque.push(mp(np, nnp));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tres = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(res) cout << \"No\" << endl;\n\t\telse cout << \"Yes\" << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nbool solve(void){\n\tint n,i;cin>>n;\n\tif(n==0){return false;}\n\tmap<pair<int,int>,int>futon;\n\t//02\n\t//1\n\t//3\n\tmap<pair<int,int>,int>head;//1が頭 -1が足\n\tvector<pair<int,int>>miru(n);\n\tfor(i=0;i<n;i++){\n\t\tint x,y;char d;\n\t\tcin>>x>>y>>d;\n\t\t\n\t\tmiru[i]=mp(x,y);\n\t\tif(d=='x'){futon[mp(x,y)]=0;futon[mp(x+1,y)]=2;}\n\t\telse{futon[mp(x,y)]=1;futon[mp(x,y+1)]=3;}\n\t}\n\tqueue<pair<int,int>>que;\n\tint dx[8]={1,0,-1,0,1,0,-1,0};\n\tint dy[8]={0,1,0,-1,0,1,0,-1};\n\tfor(i=0;i<n;i++){\n\t\tif(head[miru[i]]==0){\n\t\t\tque.push(miru[i]);\n\t\t\thead[miru[i]]=1;\n\t\t}\n\t\twhile(que.size()){\n\t\t\tint x=que.front().fir;\n\t\t\tint y=que.front().sec;\n\t\t\tint h=head[mp(x,y)];\n\t\t\tint d=futon[mp(x,y)];\n\t\t\tque.pop();\n\t\t\tpair<int,int> ter;\n\t\t\tint sor;\n\t\t\t\n\t\t\tter=mp(x+dx[d],y+dy[d]);\n\t\t\tsor=head[ter];\n\t\t\tif(sor==h){cout<<\"No\"<<endl;return true;}\n\t\t\tif(sor==0){head[ter]=-h;que.push(ter);}\n\t\t\n\t\t\tter=mp(x+dx[d+1],y+dy[d+1]);\n\t\t\tif(futon.count(ter)>0){\n\t\t\t\tsor=head[ter];\n\t\t\t\tif(sor==-h){cout<<\"No\"<<endl;return true;}\n\t\t\t\tif(sor==0){head[ter]=h;que.push(ter);}\n\t\t\t}\n\t\t\n\t\t\tter=mp(x+dx[d+2],y+dy[d+2]);\n\t\t\tif(futon.count(ter)>0){\n\t\t\t\tsor=head[ter];\n\t\t\t\tif(sor==-h){cout<<\"No\"<<endl;return true;}\n\t\t\t\tif(sor==0){head[ter]=h;que.push(ter);}\n\t\t\t}\n\t\t\t\n\t\t\tter=mp(x+dx[d+3],y+dy[d+3]);\n\t\t\tif(futon.count(ter)>0){\n\t\t\t\tsor=head[ter];\n\t\t\t\tif(sor==-h){cout<<\"No\"<<endl;return true;}\n\t\t\t\tif(sor==0){head[ter]=h;que.push(ter);}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"Yes\"<<endl;return true;\n}\nint main(void){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint M;\nmap<pair<int, int>, vector<tuple<int, int, int>>> G;\nmap<pair<int, int>, bool> color;\n\nbool dfs(int y, int x, bool c) {\n  auto p = make_pair(y, x);\n  for(auto& e: G[p]) {\n    int ny, nx, tar; tie(ny, nx, tar) = e;\n    auto np = make_pair(ny, nx);\n    if(tar) {\n      if(color.find(np) != color.end()) {\n        if(color[np] != c) return false;\n      } else {\n        color[np] = c;\n        if(!dfs(ny, nx, tar)) return false;\n      }\n    } else {\n      // atama ashi\n      if(color.find(np) != color.end()) {\n        if(color[np] != !c) return false;\n      } else {\n        color[np] = !c;\n        if(!dfs(ny, nx, tar)) return false;\n      }\n    }\n  }\n  return true;\n}\n\nint main() {\n\n  for(; cin >> M && M;) {\n    G.clear();\n    vector<int> x(M), y(M); vector<char> d(M);\n    set<pair<int, int>> cs;\n    rep(i, M) {\n      cin >> x[i] >> y[i] >> d[i];\n      cs.emplace(y[i], x[i]);\n    }\n\n    rep(i, M) {\n      if(d[i] == 'x') {\n        G[make_pair(y[i], x[i])].emplace_back(y[i], x[i] + 1, 0);\n        rep(k, 4) if(dx[k] != 1) {\n          if(cs.count(make_pair(y[i] + dy[k], x[i] + dx[k])))\n            G[make_pair(y[i], x[i])].emplace_back(y[i] + dy[k], x[i] + dx[k], 1);\n        }\n        rep(k, 4) if(dx[k] != -1) {\n          if(cs.count(make_pair(y[i] + dy[k], x[i] + 1 + dx[k])))\n            G[make_pair(y[i], x[i] + 1)].emplace_back(y[i] + dy[k], x[i] + 1 + dx[k], 1);\n        }\n      }\n      else {\n        G[make_pair(y[i], x[i])].emplace_back(y[i] + 1, x[i], 0);\n        rep(k, 4) if(dy[k] != 1) {\n          if(cs.count(make_pair(y[i] + dy[k], x[i] + dx[k])))\n            G[make_pair(y[i], x[i])].emplace_back(y[i] + dy[k], x[i] + dx[k], 1);\n        }\n        rep(k, 4) if(dy[k] != -1) {\n          if(cs.count(make_pair(y[i] + 1 + dy[k], x[i] + dx[k])))\n            G[make_pair(y[i] + 1, x[i])].emplace_back(y[i] + 1 + dy[k], x[i] + dx[k], 1);\n        }\n      }\n    }\n\n    color.clear();\n    color[make_pair(0, 0)] = 0;\n    cout << (!dfs(y[0], x[0], 0) ? \"Yes\" : \"No\") << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UF{\n    vector<int>par,sz;\n    void init(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint N;\nint dx[]={0,-1,0,1};\nint dy[]={-1,0,1,0};\nint x[55555],y[55555];\n\nvoid solve(){\n    map<pint,int>dic;\n    rep(i,2*N)dic[{y[i],x[i]}]=i;\n    UF uf;uf.init(2*N);\n    rep(i,2*N){\n        rep(d,4){\n            int ny=y[i]+dy[d],nx=x[i]+dx[d];\n            if(dic.find({ny,nx})==dic.end())continue;\n            int tmp=dic[{ny,nx}];\n            if(tmp==(i^1))continue;\n            uf.unite(tmp,i);\n            uf.unite(tmp^1,i^1);\n        }\n    }\n\n    rep(i,N){\n        if(uf.same(i*2,i*2+1)){\n            puts(\"No\");\n            return;\n        }\n    }\n    puts(\"Yes\");\n}\n\nsigned main(){\n    while(scanf(\"%lld\",&N),N){\n        rep(i,N){\n            char c;\n            scanf(\"%lld%lld %c\",&x[i*2],&y[i*2],&c);\n            x[i*2+1]=x[i*2];y[i*2+1]=y[i*2];\n            if(c=='x'){\n                x[i*2+1]++;\n            }\n            else{\n                y[i*2+1]++;\n            }\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\nint n;\n\nbool dfs(pii p, int c, set<pii> &S, map<pii, int> &color, map<pii, pii> &same){\n    if(S.find(p) == S.end()){\n        return color[p] == c;\n    }\n    color[p] = c;\n    S.erase(p);\n    rep(i, 4){\n        pii np = {p.fi + dx[i], p.se + dy[i]};\n        if(color.find(np) == color.end()) continue;\n        int nc = (np == same[p] ? c ^ 1 : c);\n        if(!dfs(np, nc, S, color, same)) return false;\n    }\n    return true;\n}\n\nvoid solve(){\n    map<pii, int> color;\n    map<pii, pii> same;\n    set<pii> S;\n    rep(i, n){\n        int x, y; char dir;\n        scanf(\"%d%d %c\", &x, &y, &dir);\n        int nx = x, ny = y;\n        if(dir == 'x') ++nx;\n        else ++ny;\n        same[{x, y}] = {nx, ny};\n        same[{nx, ny}] = {x, y};\n        color[{x, y}] = color[{nx, ny}] = -1;\n        S.emplace(x, y);\n        S.emplace(nx, ny);\n    }\n\n    while(!S.empty()){\n        if(!dfs(*S.begin(), 0, S, color, same)){\n            puts(\"No\");\n            return;\n        }\n    }\n    puts(\"Yes\");\n}\n\nint main(){\n    while(scanf(\"%d\", &n) && n){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstdlib>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <ctime>\nusing namespace std;\n\nconst int MAX_N = 20001;\ntypedef pair<int, int> P;\n\n// input\nint n, x[MAX_N], y[MAX_N];\nchar dir[MAX_N];\n\nint futon[MAX_N];\nbool used[MAX_N];\nmap<P, int> m;\nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\nbool ans;\n\nvoid dfs(int pos, int k){\n\tif( ans == false ) return ;\n\t\n\tint x1 = x[pos], y1 = y[pos], x2, y2;\n\tused[pos] = true;\n\tfuton[pos] = k;\n\tint next = (k + 1) % 2;\n\tif( dir[pos] == 'x' ){\n\t\tx2 = x1 + 1, y2 = y1;\n\t}else{\n\t\tx2 = x1, y2 = y1 + 1;\n\t}\n\t\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = x1 + dx[i], my = y1 + dy[i];\n\t\tif( mx == x2 && my == y2 ) continue;\n\t\t\n\t\tif( m.count(P(mx,my)) ){\n\t\t\tint id = m[P(mx,my)];\n\t\t\tif( used[id] ){\n\t\t\t\tif( futon[id] == futon[pos] ){\n\t\t\t\t\tans = false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdfs(id, next);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = x2 + dx[i], my = y2 + dy[i];\n\t\tif( mx == x1 && my == y1 ) continue;\n\t\t\n\t\tif( m.count(P(mx,my)) ){\n\t\t\tint id = m[P(mx,my)];\n\t\t\tif( used[id] ){\n\t\t\t\tif( futon[id] == futon[pos] ){\n\t\t\t\t\tans = false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdfs(id, next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> n, n ){\n\t\tfill(used, used + MAX_N, false);\n\t\tfill(futon, futon+MAX_N, -1);\n\t\tm.clear();\n\t\tans = true;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++ ){\n\t\t\tcin >> x[i] >> y[i] >> dir[i];\n\t\t\tif( dir[i] == 'x' ){\n\t\t\t\tm[ P(x[i], y[i]) ] = i;\n\t\t\t\tm[ P(x[i]+1, y[i]) ] = i;\n\t\t\t}else{\n\t\t\t\tm[ P(x[i], y[i]) ] = i;\n\t\t\t\tm[ P(x[i], y[i]+1) ] = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++ ){\n\t\t\tif( used[i] ) continue;\n\t\t\tdfs(i, 0);\t\t\n\t\t}\n\t\tif( ans ){\n\t\t\tcout << \"Yes\" << endl;\n\t\t}else{\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\n\ntypedef vector<pii> vp;\n\nbool dfs(map<pii,vp>& g,map<pii,vi>& type,map<pii,int> hf,pii cur,int cur_hf){\n\thf[cur]=cur_hf;\n\tbool ret=true;\n\tREP(i,g[cur].size()){\n\t\tpii next=g[cur][i];\n\t\tint next_hf=(cur_hf+type[cur][i])%2;\n\t\tif(hf[next]==-1){\n\t\t\tret&=dfs(g,type,hf,next,next_hf);\n\t\t}else if(hf[next]==next_hf){\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tmap<pii,vp> g;\n\t\tmap<pii,vi> type;\n\t\tmap<pii,int> hf;\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tchar d;\n\t\t\tcin>>x>>y>>d;\n\t\t\tint dir=(d=='x'?2:3);\n\t\t\tpii c=make_pair(y,x);\n\t\t\tpii n=make_pair(y+dy[dir],x+dx[dir]);\n\n\t\t\tg[c]=vp();\n\t\t\ttype[c]=vi();\n\t\t\tg[c].push_back(n);\n\t\t\ttype[c].push_back(1);\n\t\t\thf[c]=-1;\n\n\t\t\tg[n]=vp();\n\t\t\ttype[n]=vi();\n\t\t\tg[n].push_back(c);\n\t\t\ttype[n].push_back(1);\n\t\t\thf[n]=-1;\n\n\t\t\tREP(j,2){\n\t\t\t\tREP(k,4){\n\t\t\t\t\tpii base=(j==0?c:n);\n\t\t\t\t\tpii neighbor=make_pair(base.first+dy[k],base.second+dx[k]);\n\t\t\t\t\tif(EXIST(g,neighbor)&&find(ALL(g[base]),neighbor)==g[base].end()){\n\t\t\t\t\t\tg[base].push_back(neighbor);\n\t\t\t\t\t\ttype[base].push_back(0);\n\t\t\t\t\t\tg[neighbor].push_back(base);\n\t\t\t\t\t\ttype[neighbor].push_back(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok=true;\n\t\tfor(map<pii,vp>::iterator it=g.begin();it!=g.end();it++){\n\t\t\tok&=dfs(g,type,hf,(*it).first,0);\n\t\t}\n\t\tcout<<(ok?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n//#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<P, P> PP;\ntypedef pair<P,int> PPI;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\n//// UnionFind\nstruct UnionFind{\n\tvector<int> v;\n\tUnionFind(int n) : v(n, -1) {}\n\n\tint find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n\tbool unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return false;\n\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\tv[x] += v[y]; v[y] = x;\n\t\treturn true;\n\t}\n\tbool root(int x) { return v[x] < 0; }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nint n;\nvector<PP> edge;\nvector<P> point;\nint dd[]={-1,0,1,0,-1};\n\nint idlast;\nmap<P,int> mp;\nint id(P p){\n\tif(mp.count(p))return mp[p];\n\tmp[p]=idlast++;\n\treturn mp[p];\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tUnionFind uf(4*n+100);\n\t\tidlast=0;\n\t\tedge.clear(); point.clear(); mp.clear();\n\t\trep(i,n){\n\t\t\tll a,b; char c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tif(c=='x'){\n\t\t\t\tedge.pb(PP(P(a,b),P(a+1,b)));\n\t\t\t\tuf.unite(id(P(a,b))+2*n,id(P(a+1,b)));\n\t\t\t\tuf.unite(id(P(a,b)),id(P(a+1,b))+2*n);\n\t\t\t\tpoint.pb(P(a,b)); point.pb(P(a+1,b));\n\t\t\t}else{\n\t\t\t\tedge.pb(PP(P(a,b),P(a,b+1)));\n\t\t\t\tuf.unite(id(P(a,b))+2*n,id(P(a,b+1)));\n\t\t\t\tuf.unite(id(P(a,b)),id(P(a,b+1))+2*n);\n\t\t\t\tpoint.pb(P(a,b)); point.pb(P(a,b+1));\n\t\t\t}\n\t\t}\n\t\trep(i,point.size()){\n\t\t\tP p=point[i];\n\t\t\trep(j,4){\n\t\t\t\tll nx=p.fi+dd[j], ny=p.se+dd[j+1];\n\t\t\t\tif(!mp.count(P(nx,ny))||P(nx,ny)==point[i+(i%2?-1:1)])continue;\n\t\t\t\tuf.unite(id(p),id(P(nx,ny)));\n\t\t\t\tuf.unite(id(p)+2*n,id(P(nx,ny))+2*n);\n\t\t\t}\n\t\t}\n\t\tbool ok=true;\n\t\trep(i,edge.size()){\n\t\t\tif(uf.same(id(edge[i].fi),id(edge[i].se))||\n\t\t\t\tuf.same(id(edge[i].fi)+2*n,id(edge[i].se)+2*n))ok=false;\n\t\t}\n\t\tif(ok)cout<<\"Yes\"<<endl;\n\t\telse cout<<\"No\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Graph=vector<vector<int>>;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nbool isBipartite(const Graph &g){\n    int n=g.size();\n    vector<int> color(n,-1);\n    function<bool(int,int)> dfs=[&](int v,int c){\n        if(color[v]!=-1){\n            if(color[v]!=c) return false;\n            return true;\n        }\n        color[v]=c;\n        bool isok=true;\n        for(auto &e:g[v]){\n            isok&=dfs(e,!c);\n        }\n        return isok;\n    };\n    for(int i=0;i<n;i++){\n        if(color[i]==-1){\n            if(!dfs(i,0)){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nbool solve(int n){\n    map<pair<int,int>,int> mp;\n    for(int i=0;i<n;i++){\n        int x,y;\n        cin>>x>>y;\n        char dir;\n        cin>>dir;\n        mp[{x,y}]=i;\n        if(dir=='x') mp[{x+1,y}]=i+n;\n        else mp[{x,y+1}]=i+n;\n    }\n\n    Graph g(2*n);\n    for(int i=0;i<n;i++) g[i].push_back(i+n),g[i+n].push_back(i);\n    for(auto &e:mp){\n        int x=e.first.first,y=e.first.second;\n        int idx=e.second;\n        for(int i=0;i<4;i++){\n            int tox=x+dx[i],toy=y+dy[i];\n            if(mp.count({tox,toy})){\n                if(mp[{tox,toy}]%n!=idx%n){\n                    g[(idx+n)%(2*n)].push_back(mp[{tox,toy}]);\n                }\n            }\n        }\n    }\n    return isBipartite(g);\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        cout<<(solve(n) ? \"Yes\" : \"No\")<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int N = 20000;\n\nclass T{\npublic:\n  int x, y;\n  char c;\n  T(){}\n  T(int x, int y, char c) : x(x), y(y), c(c){}\n};\n\nvector<T> data;\nmap<P, int> mp;\nmap<P, int> dist; // 0 = atama, 1= ashi;\nbool ans;\nint dx[2][6] = {\n  {0, 1, 2, 1, 0, -1},\n  {0, 1, 1, 0, -1, -1}\n};\nint dy[2][6] = {\n  {-1, -1, 0, 1, 1, 0},\n  {-2, -1, 0, 1, 0, -1}\n};\nint dx2[4] = {0, 1, 0, -1};\nint dy2[4] = {-1, 0, 1, 0};\n\nvoid dfs(int pos){\n  int next[2] = {-1, -1};\n  P p[2];\n  int d = (data[pos].c == 'x' ? 0 : 1);\n  p[0] = make_pair(data[pos].x, data[pos].y);\n  p[1] = (d ? make_pair(data[pos].x, data[pos].y+1) : make_pair(data[pos].x+1, data[pos].y));\n  //printf(\"now = (%d,%d)\\n\", data[pos].x, data[pos].y);\n  for(int k=0;k<2;k++){\n    for(int i=0;i<4;i++){\n      int nx = p[k].first + dx2[i];\n      int ny = p[k].second + dy2[i];\n      if(data[pos].x == 2 && data[pos].y == 0){\n\t//printf(\"now = (%d,%d)\\n\", p[k].first, p[k].second);\n      }\n      P np = make_pair(nx, ny);\n      if(data[pos].x == 2 && data[pos].y == 0){\n\t//printf(\"check (%d,%d)\\n\", nx, ny);\n      }\n      if(dist.find(np) != dist.end()){\n\tif(data[pos].x == 2 && data[pos].y == 0){\n\t  //printf(\"(%d,%d)\\n\", nx, ny);\n\t}\n\tint nc = dist[np];\n\tif(next[k] == -1) next[k] = nc;\n\telse if(next[k] != nc){\n\t  //printf(\"(%d,%d) -> (%d,%d) %d\\n\", p[k].first, p[k].second, np.first, np.second, nc);\n\t  ans = false;\n\t  return;\n\t}\n      }\n    }\n  }\n  //printf(\"(%d,%d) %d %d\\n\", data[pos].x, data[pos].y, next[0], next[1]);\n  //printf(\"(%d,%d), (%d,%d)\\n\", p[0].first, p[0].second, p[1].first, p[1].second);\n  if(next[0] == -1 && next[1] == -1){\n    dist[p[0]] = 0;\n    dist[p[1]] = 1;\n  }else if(next[0] == -1){\n    dist[p[0]] = 1 - next[1];\n    dist[p[1]] = next[1];\n  }else if(next[1] == -1){\n    dist[p[0]] = next[0];\n    dist[p[1]] = 1 - next[0];\n  }else{\n    dist[p[0]] = next[0];\n    dist[p[1]] = next[1];\n  }\n  //printf(\"(%d,%d) %d %d\\n\", data[pos].x, data[pos].y, dist[p[0]], dist[p[1]]);\n  for(int k=0;k<2;k++){\n    for(int i=0;i<6;i++){\n      int nx = p[k].first + dx[d][i];\n      int ny = p[k].second + dy[d][i];\n      P np = make_pair(nx, ny);\n      if(mp.find(np) != mp.end() && dist.find(np) == dist.end()){\n\tdfs(mp[np]);\n      }\n    }\n  }      \n}\n\nvoid init(){\n  mp.clear();\n  dist.clear();\n  ans = true;\n  data.clear();\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    init();\n    for(int i=0;i<n;i++){\n      T in;\n      cin >> in.x >> in.y >> in.c;\n      data.push_back(in);\n      if(in.c == 'x'){\n\tmp[make_pair(in.x, in.y)] = i;\n\tmp[make_pair(in.x+1, in.y)] = i;\n      }else{\n\tmp[make_pair(in.x, in.y)] = i;\n\tmp[make_pair(in.x, in.y+1)] = i;\n      }\n    }\n    for(int i=0;i<n;i++){\n      P p = make_pair(data[i].x, data[i].y);\n      if(dist.find(p) == dist.end()){\n\tdfs(i);\n      }\n    }\n    cout << (ans ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 20002\n \nint dy1[6]={1,0,-1,-1,0,1};\nint dx1[6]={1,2,1,0,-1,0};\n \nint dy2[6]={-1,-2,-1,0,1,0};\nint dx2[6]={1,0,-1,-1,0,1};\n \nint dy3[6]={1,0,-1,-1,0,1};\nint dx3[6]={-1,-2,-1,0,1,0};\n \nint dy4[6]={1,2,1,0,-1,0};\nint dx4[6]={1,0,-1,-1,0,1};\n \nint n;\n \nmap<P,int> T,F,vd;\nmap<P,P> G;\n \nint Y[MAX],X[MAX];\nchar c[MAX];\nbool flg[MAX];\n \n \nbool rec(int x,int y){\n  //  cout<<x<<' '<<y<<endl;\n \n  P p=P(x,y);\n  P q=G[p];\n  vd[p]=true;\n  vd[q]=true;\n  F[p]=1;\n  F[q]=2;\n  int id=T[p];\n  flg[id]=true;\n  P to;\n  int ny,nx;\n  for(int i=0;i<6;i++){\n    if(c[id]=='x'){\n      if(y==Y[id]&&x==X[id]){\n    ny=y+dy1[i];\n    nx=x+dx1[i];\n      }else{\n    ny=y+dy3[i];\n    nx=x+dx3[i];\n      }\n    }else{\n      if(y==Y[id]&&x==X[id]){\n    ny=y+dy4[i];\n    nx=x+dx4[i];\n      }else{\n    ny=y+dy2[i];\n    nx=x+dx2[i];\n      }\n    }\n    to=P(nx,ny);\n \n    if(i<3&&F[to]==1)return false;\n    if(i>=3&&F[to]==2)return false;\n    if(vd[to])continue;\n    if(T[to]==0)continue;\n    if(i<3){\n      nx=G[to].first;\n      ny=G[to].second;\n    }\n    if(!rec(nx,ny))return false;\n  }\n \n  return true;\n}\n \nbool solve(){\n  for(int i=1;i<=n;i++){\n    if(flg[i])continue;\n    if(!rec(X[i],Y[i]))return false;\n  }\n  return true;\n}\n \n \nint main() {\n \n  while(cin >> n && n) {\n    T.clear();\n    G.clear();\n    vd.clear();\n    F.clear();\n    for(int i=1; i<=n; i++) {\n      cin >> X[i] >> Y[i] >> c[i];\n      P a,b;\n      a.first=X[i],a.second=Y[i];\n      if(c[i]=='x'){\n    b.first=a.first+1;\n    b.second=a.second;\n    T[a]=i;\n    T[b]=i;\n    G[a]=b;\n    G[b]=a;\n      }else{\n    b.first=a.first;\n    b.second=a.second+1;\n    T[a]=i;\n    T[b]=i;\n    G[a]=b;\n    G[b]=a;\n      }\n    }\n    for(int i=1;i<=n;i++)flg[i]=false;\n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n    /*\n    for(int i=5;i>=0;i--){\n      for(int j=0;j<=5;j++){\n    cout<<vd[P(i,j)];\n      }\n      cout<<endl;\n    }\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n;\nmap<pair<int, int>, int> futon;\nmap<pair<int, int>, int> color;\nint futonX[30000];\nint futonY[30000];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nbool dfs(int x, int y, int c) {\n  if (color[make_pair(x, y)] != -1) {\n   if (color[make_pair(x, y)] == c) { return true; }\n   else { return false; }\n  }\n  color[make_pair(x, y)] = c;\n  REP(i, 4) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if (!futon.count(make_pair(nx, ny))) { continue; }\n    int nc = c;\n    if (futon[make_pair(nx, ny)] == futon[make_pair(x, y)]) { nc ^= 1; }\n    assert(nx != 1 || ny != 0 || nc != 0);\n    if (!dfs(nx, ny, nc)) { return false; }\n  }\n  return true;\n}\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    futon.clear();\n    color.clear();\n    REP(i, n) {\n      int x, y;\n      char c;\n      scanf(\"%d %d %c\", &x, &y, &c);\n      futonX[i] = x;\n      futonY[i] = y;\n      int dir = c == 'x' ? 0 : 1;\n      REP(j, 2) {\n        int nx = x + dx[dir] * j;\n        int ny = y + dy[dir] * j;\n        futon[make_pair(nx, ny)] = i;\n        color[make_pair(nx, ny)] = -1;\n      }\n    }\n    REP(i, n) {\n      int x = futonX[i];\n      int y = futonY[i];\n      if (color[make_pair(x, y)] != -1) { continue; }\n      if (!dfs(x, y, 0)) {\n        puts(\"No\");\n        goto next;\n      }\n    }\n    puts(\"Yes\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct union_find {\n  int H, W;\n  vector<int> rank_, size_, rid_;\n  union_find(){}\n  union_find(int h, int w) { H = h + 10, W = w + 10; rank_.resize(H*W); rid_.assign(H*W, -1); size_.resize(H*W, 1); }\n  void operator()(pair<int, int> x, pair<int, int> y) {\n    int u = x.first * W + x.second;\n    int v = y.first * W + y.second;\n    u = operator[](u), v = operator[](v);\n    if(u == v) { return; }\n    size_[u] = size_[v] = size_[u] + size_[v];\n    if(rank_[u] < rank_[v]) { rid_[u] = v; }\n    else { rid_[v] = u; if(rank_[u] == rank_[v]) { rank_[u]++; } }    \n  }\n  int operator[](pair<int, int> a) { int x = a.first * W + a.second; return operator[](operator[](x)); }\n  int size_of(int x) { return size_[x]; }\nprivate:\n  int operator[](int x) { if(rid_[x] < 0) return x; else return rid_[x] = operator[](rid_[x]); }\n};\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nunion_find uf;\n\nint main() {\n  \n  for(int N; cin >> N && N;) {\n    static vector<int> fx, fy; static vector<char> fd;\n    static vector<int> xs, ys;\n    fx.clear(), fx.resize(N);\n    fy.clear(), fy.resize(N);\n    fd.clear(), fd.resize(N);\n    xs.clear(), xs.resize(N);\n    ys.clear(), ys.resize(N);\n    rep(i, N) {\n      cin >> fx[i] >> fy[i] >> fd[i];\n      REP(d,-1,2) xs.push_back(fx[i]+d), ys.push_back(fy[i]+d);\n    }\n\n    sort(all(xs)); xs.erase(unique(all(xs)), xs.end());\n    sort(all(ys)); ys.erase(unique(all(ys)), ys.end());\n\n    const int H = ys.size();\n    const int W = xs.size();\n\n    static map<int, int> X, Y;\n    X.clear(), Y.clear();\n    rep(i, xs.size()) X[xs[i]] = i;\n    rep(i, ys.size()) Y[ys[i]] = i;\n\n    uf = union_find(H, W);\n\n    static set<pair<int, int>> st;\n    st.clear();\n\n    rep(i, N) {\n      assert(X.find(fx[i])!=X.end());\n      assert(Y.find(fy[i])!=Y.end());\n      fx[i] = X[fx[i]];\n      fy[i] = Y[fy[i]];\n    }\n\n    rep(i, N) {\n      st.emplace(fy[i], fx[i]);\n      if(fd[i] == 'x') {\n        st.emplace(fy[i], fx[i] + 1);\n      } else {\n        st.emplace(fy[i] + 1, fx[i]);\n      }\n    }\n\n    rep(i, N) {\n      if(fd[i] == 'x') {\n        auto po = make_pair(fy[i], fx[i]);\n        rep(k, 4) if(dx[k] != +1) {\n          auto np = make_pair(fy[i] + dy[k], fx[i] + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n        po = make_pair(fy[i], fx[i] + 1);\n        rep(k, 4) if(dx[k] != -1) {\n          auto np = make_pair(fy[i] + dy[k], fx[i] + 1 + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n      }\n      else {\n        auto po = make_pair(fy[i], fx[i]);\n        rep(k, 4) if(dy[k] != +1) {\n          auto np = make_pair(fy[i] + dy[k], fx[i] + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n\n        po = make_pair(fy[i] + 1, fx[i]);\n        rep(k, 4) if(dy[k] != -1) {\n          auto np = make_pair(fy[i] + 1 + dy[k], fx[i] + dx[k]);\n          if(st.count(np)) uf(po, np);\n        }\n      }\n    }\n\n    bool ok = 1;\n    rep(i, N) {\n      auto a = make_pair(fy[i], fx[i]);\n      if(fd[i] == 'x') {\n        auto b = make_pair(fy[i], fx[i] + 1);\n        ok &= uf[a] != uf[b];\n      }\n      else {\n        auto b = make_pair(fy[i] + 1, fx[i]);\n        ok &= uf[a] != uf[b];\n      }\n    }\n\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint n, dp[40000], st[40000], k;\nmap<pi, int> id;\nvi x, y, d;\n\nbool rec(int cx, int cy, int cd){\n\tint i = id[mp(cx, cy)];\n\tst[k++] = i;\n\tdp[i] = cd;\n\trep(d, 4){\n\t\tint nx = cx + dx[d], ny = cy + dy[d];\n\t\tif(!id.count(mp(nx, ny))) continue;\n\t\tint ii = id[mp(nx, ny)], nd = ii == (i ^ 1) ? 1 - cd : cd;\n\t\t\n\t\tif(dp[ii] >= 0 && dp[ii] != nd) return 0;\n\t\tif(dp[ii] < 0 && !rec(nx, ny, nd)) return 0;\n\t}\n\treturn 1;\n}\n\nint main(){\n\twhile(scanf(\"%d\", &n), n){\n\t\tx.clear(); y.clear(); d.clear();\n\t\tid.clear();\n\t\t\n\t\trep(i, n){\n\t\t\tint a, b; char c;\n\t\t\tscanf(\"%d%d %c\", &a, &b, &c);\n\t\t\tx.pb(a); y.pb(b); d.pb(c == 'x');\n\t\t\tid[mp(a, b)] = i * 2;\n\t\t\tid[mp(a + d[i], b + 1 - d[i])] = i * 2 + 1;\n\t\t}\n\t\tmemset(dp, -1, sizeof(dp));\n\t\trep(i, 2 * n) if(dp[i] < 0){\n\t\t\tk = 0;\n\t\t\tif(rec(x[i], y[i], 0)) continue;\n\t\t\twhile(k) dp[st[--k]] = -1;\n\t\t\tif(!rec(x[i], y[i], 1)){\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t\tcout << \"Yes\" << endl;\n\t\tEND:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UF{\n    vector<int>par,sz;\n    void init(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint N;\nint dx[]={0,-1,0,1};\nint dy[]={-1,0,1,0};\nint x[55555],y[55555];\n\nvoid solve(){\n    map<pint,int>dic;\n    rep(i,2*N)dic[{y[i],x[i]}]=i;\n    UF uf;uf.init(2*N);\n    rep(i,2*N){\n        rep(d,4){\n            int ny=y[i]+dy[d],nx=x[i]+dx[d];\n            if(dic.find({ny,nx})==dic.end())continue;\n            int tmp=dic[{ny,nx}];\n            if(tmp==(i^1))continue;\n            uf.unite(tmp,i);\n            uf.unite(tmp^1,i^1);\n        }\n    }\n\n    rep(i,N){\n        if(uf.same(i*2,i*2+1)){\n            cout<<\"No\"<<endl;\n            return;\n        }\n    }\n    cout<<\"Yes\"<<endl;\n}\n\nsigned main(){\n    while(cin>>N,N){\n        rep(i,N){\n            cin>>x[i*2]>>y[i*2];\n            x[i*2+1]=x[i*2];y[i*2+1]=y[i*2];\n            char c;\n            cin>>c;\n            if(c=='x'){\n                x[i*2+1]++;\n            }\n            else{\n                y[i*2+1]++;\n            }\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<vector<int>> dx = {{-1, 0, 1, 2, 1, 0}, {0, -1, -1, 0, 1, 1}};\nvector<vector<int>> dy = {{0, -1, -1, 0, 1, 1}, {-1, 0, 1, 2, 1, 0}};\nint main(){\n  while (1){\n    int n;\n    cin >> n;\n    if (n == 0){\n      break;\n    }\n    vector<int> x(n), y(n);\n    vector<char> d(n);\n    for (int i = 0; i < n; i++){\n      cin >> x[i] >> y[i] >> d[i];\n    }\n    map<int, map<int, int>> mp;\n    for (int i = 0; i < n; i++){\n      mp[x[i]][y[i]] = i;\n      if (d[i] == 'x'){\n        mp[x[i] + 1][y[i]] = i;\n      }\n      if (d[i] == 'y'){\n        mp[x[i]][y[i] + 1] = i;\n      }\n    }\n    vector<vector<int>> E(n * 2);\n    for (int i = 0; i < n; i++){\n      for (int j = 0; j < 6; j++){\n        int x2 = x[i] + dx[d[i] - 'x'][j];\n        int y2 = y[i] + dy[d[i] - 'x'][j];\n        if (mp.count(x2)){\n          if (mp[x2].count(y2)){\n            int id = mp[x2][y2];\n            if ((x[i] + y[i]) % 2 == (x[id] + y[id]) % 2){\n              E[i * 2].push_back(id * 2 + 1);\n              E[i * 2 + 1].push_back(id * 2);\n            } else {\n              E[i * 2].push_back(id * 2);\n              E[i * 2 + 1].push_back(id * 2 + 1);\n            }\n          }\n        }\n      }\n    }\n    vector<int> c(n * 2, -1);\n    int cnt = 0;\n    for (int i = 0; i < n * 2; i++){\n      if (c[i] == -1){\n        c[i] = cnt;\n        queue<int> Q;\n        Q.push(i);\n        while (!Q.empty()){\n          int v = Q.front();\n          Q.pop();\n          for (int w : E[v]){\n            if (c[w] == -1){\n              c[w] = cnt;\n              Q.push(w);\n            }\n          }\n        }\n        cnt++;\n      }\n    }\n    bool ok = true;\n    for (int i = 0; i < n; i++){\n      if (c[i * 2] == c[i * 2 + 1]){\n        ok = false;\n      }\n    }\n    if (ok){\n      cout << \"Yes\" << endl;\n    } else {\n      cout << \"No\" << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\nmap<pair<int, int>, pair<int, int>>mp;\nstruct aa {\n\tint x;\n\tint y;\n\tint way;\n\tint foot;\n};\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y; char c; cin >> x >> y >> c;\n\t\t\tif (c == 'x')\n\t\t\t{\n\t\t\t\tmp[make_pair(x, y)] = make_pair(2, -1);\n\t\t\t\tmp[make_pair(x, y)] = make_pair(0, -1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp[make_pair(x, y)] = make_pair(1, -1);\n\t\t\t\tmp[make_pair(x, y)] = make_pair(3, -1);\n\t\t\t}\n\n\t\t}\n\t\tbool ok = true;\n\t\tfor (auto m : mp) {\n\t\t\tif (m.second.second == -1) {\n\t\t\t\tm.second.second = 0;\n\t\t\t\tqueue<aa>que;\n\t\t\t\tque.push(aa{ m.first.first,m.first.second,m.second.first,0 });\n\t\t\n\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\taa atop(que.front());\n\t\t\t\t\tque.pop();\n\t\t\t\t\tconst int nowx = atop.x;\n\t\t\t\t\tconst int nowy = atop.y;\n\t\t\t\t\tconst int nowf = atop.foot;\n\t\t\t\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\t\t\t\tconst int newx = m.first.first + dx[way];\n\t\t\t\t\t\tconst int newy = m.first.second + dy[way];\n\t\t\t\t\t\tconst int newf = way == atop.way ? !nowf : nowf;\n\t\t\t\t\t\tif (mp.find(make_pair(newx, newy)) != mp.end()) {\n\t\t\t\t\t\t\tif (mp[make_pair(newx, newy)].second == -1) {\n\t\t\t\t\t\t\t\tmp[make_pair(newx, newy)].second = newf;\n\t\t\t\t\t\t\t\tque.push(aa{ newx,newy,mp[make_pair(newx,newy)].first,newf });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tif (mp[make_pair(newx, newy)].second != newf)ok = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint n, dp[40000], st[40000], k;\nmap<pi, int> id;\nvi x, y, d;\n\nbool rec(int cx, int cy, int cd){\n\tint i = id[mp(cx, cy)];\n\tst[k++] = i;\n\tdp[i] = cd;\n\trep(d, 4){\n\t\tint nx = cx + dx[d], ny = cy + dy[d];\n\t\tif(!id.count(mp(nx, ny))) continue;\n\t\tint ii = id[mp(nx, ny)], nd = ii == (i ^ 1) ? 1 - cd : cd;\n\t\t\n\t\tif(dp[ii] >= 0 && dp[ii] != nd) return 0;\n\t\tif(dp[ii] < 0 && !rec(nx, ny, nd)) return 0;\n\t}\n\treturn 1;\n}\n\nint main(){\n\twhile(scanf(\"%d\", &n), n){\n\t\tx.clear(); y.clear(); d.clear();\n\t\tid.clear();\n\t\t\n\t\trep(i, n){\n\t\t\tint a, b; char c;\n\t\t\tscanf(\"%d%d %c\", &a, &b, &c);\n\t\t\tx.pb(a); y.pb(b); d.pb(c == 'x');\n\t\t\tid[mp(a, b)] = i * 2;\n\t\t\tid[mp(a + d[i], b + 1 - d[i])] = i * 2 + 1;\n\t\t}\n\t\tmemset(dp, -1, sizeof(dp));\n\t\trep(i, n) if(dp[i] < 0){\n\t\t\tk = 0;\n\t\t\tif(rec(x[i], y[i], 0)) continue;\n\t\t\twhile(k) dp[st[--k]] = -1;\n\t\t\tif(!rec(x[i], y[i], 1)){\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t\tcout << \"Yes\" << endl;\n\t\tEND:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#include<vector>\nstruct UF{\n\tint n;\n\tvector<int>parent,rank;\n\tUF(int n_=0):n(n_),parent(n_),rank(n_,0)\n\t{\n\t\tfor(int i=0;i<n_;i++)parent[i]=i;\n\t}\n\tint find(int a)\n\t{\n\t\treturn parent[a]!=a?parent[a]=find(parent[a]):a;\n\t}\n\tbool same(int a,int b)\n\t{\n\t\treturn find(a)==find(b);\n\t}\n\tbool unite(int a,int b)\n\t{\n\t\ta=find(a),b=find(b);\n\t\tif(a==b)return false;\n\t\tif(rank[a]<rank[b])\n\t\t{\n\t\t\tparent[a]=b;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[b]=a;\n\t\t\tif(rank[a]==rank[b])rank[a]++;\n\t\t}\n\t\treturn true;\n\t}\n};\nint n;\nvector<int>G[44444];\nint color[44444];\nint d[5]={0,1,0,-1};\nbool dfs(int u,int c)\n{\n\tcolor[u]=c;\n\tbool flag=1;\n\tfor(int v:G[u])\n\t{\n\t\tif(color[v])\n\t\t{\n\t\t\tflag&=color[v]==3-c;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tflag&=dfs(v,3-c);\n\t\t}\n\t}\n\treturn flag;\n}\nmain()\n{\n\twhile(cin>>n,n)\n\t{\n\t\tmap<pair<int,int>,int>M;\n\t\tvector<pair<pair<int,int>,char> >a;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint x,y;char c;cin>>x>>y>>c;\n\t\t\tM[make_pair(x,y)]=i;\n\t\t\tM[make_pair(x+(c=='x'),y+(c=='y'))]=i+n;\n\t\t\ta.push_back(make_pair(make_pair(x,y),c));\n\t\t}\n\t\tUF uf(2*n);\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint x,y;char c;\n\t\t\tx=a[i].first.first,y=a[i].first.second,c=a[i].second;\n\t\t\tfor(int j=0;j<2;j++)\n\t\t\t{\n\t\t\t\tint tx=x+(c=='x')*j,ty=y+(c=='y')*j;\n\t\t\t\tfor(int r=0;r<4;r++)\n\t\t\t\t{\n\t\t\t\t\tint dx=tx+d[r],dy=ty+d[r+1];\n\t\t\t\t\tif(dx+tx==2*x+(c=='x')&&dy+ty==2*y+(c=='y'))continue;\n\t\t\t\t\tif(M.find(make_pair(dx,dy))!=M.end())\n\t\t\t\t\t{\n\t\t\t\t\t\tuf.unite(M[make_pair(tx,ty)],M[make_pair(dx,dy)]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap<int,int>mp;\n\t\tint sz=0;\n\t\tfor(int i=0;i<2*n;i++)\n\t\t{\n\t\t\tint now=uf.find(i);\n\t\t\tif(mp.find(now)==mp.end())\n\t\t\t{\n\t\t\t\tmp[now]=sz++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<sz;i++)G[i].clear(),color[i]=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tint x,y;char c;\n\t\t\tx=a[i].first.first,y=a[i].first.second,c=a[i].second;\n\t\t\tint X,Y;\n\t\t\tX=mp[uf.find(M[make_pair(x,y)])];\n\t\t\tY=mp[uf.find(M[make_pair(x+(c=='x'),y+(c=='y'))])];\n\t\t\tG[X].push_back(Y);\n\t\t\tG[Y].push_back(X);\n\t\t}\n\t\tbool ans=1;\n\t\tfor(int i=0;i<sz;i++)\n\t\t{\n\t\t\tif(!color[i])\n\t\t\t{\n\t\t\t\tans&=dfs(i,1);\n\t\t\t}\n\t\t}\n\t\tcout<<(ans?\"Yes\":\"No\")<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UF{\n    vector<int>par,sz;\n    void init(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint N;\nint dx[]={0,-1,0,1};\nint dy[]={-1,0,1,0};\nint x[55555],y[55555];\n\nvoid solve(){\n    map<pint,int>dic;\n    rep(i,2*N)dic[{y[i],x[i]}]=i;\n    UF uf;uf.init(2*N);\n    rep(i,2*N){\n        rep(d,4){\n            int ny=y[i]+dy[d],nx=x[i]+dx[d];\n            if(dic.find({ny,nx})==dic.end())continue;\n            int tmp=dic[{ny,nx}];\n            if(tmp==(i^1))continue;\n            uf.unite(tmp,i);\n        }\n    }\n\n    rep(i,N){\n        if(uf.same(i*2,i*2+1)){\n            cout<<\"No\"<<endl;\n            return;\n        }\n    }\n    cout<<\"Yes\"<<endl;\n}\n\nsigned main(){\n    while(cin>>N,N){\n        rep(i,N){\n            cin>>x[i*2]>>y[i*2];\n            x[i*2+1]=x[i*2];y[i*2+1]=y[i*2];\n            char c;\n            cin>>c;\n            if(c=='x'){\n                x[i*2+1]++;\n            }\n            else{\n                y[i*2+1]++;\n            }\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <map>\n#include <queue>\n\nconstexpr size_t m1 = -1;\nconstexpr size_t di[] = {m1, 0, 1, 0};\nconstexpr size_t dj[] = {0, m1, 0, 1};\n\ntemplate <class F>\nclass fix_point: F {\npublic:\n  explicit constexpr fix_point(F&& f) noexcept: F(std::forward<F>(f)) {}\n\n  template <class... Args>\n  constexpr decltype(auto) operator ()(Args&&... args) const {\n    return F::operator ()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <class F>\nstatic inline constexpr decltype(auto) make_fix_point(F&& f) noexcept {\n  return fix_point<F>{std::forward<F>(f)};\n}\n\ntemplate <typename Weight>\nstruct edge {\n  using value_type = Weight;\n  size_t src, dst;\n  value_type cost;\n\n  edge(size_t src, size_t dst, value_type cost = 1):\n    src(src), dst(dst), cost(cost)\n  {}\n\n  bool operator <(edge<value_type> const& rhs) const {\n    if (cost != rhs.cost) return cost < rhs.cost;\n    if (src != rhs.src) return src < rhs.src;\n    return dst < rhs.dst;\n  }\n};\n\ntemplate <typename Weight>\nstruct graph: public std::vector<std::vector<edge<Weight>>> {\n  using value_type = Weight;\n  graph(size_t n): std::vector<std::vector<edge<value_type>>>(n) {}\n\n  void connect_to(size_t src, size_t dst, value_type cost = 1) {\n    (*this)[src].emplace_back(src, dst, cost);\n  }\n\n  void connect_with(size_t src, size_t dst, value_type cost = 1) {\n    connect_to(src, dst, cost);\n    connect_to(dst, src, cost);\n  }\n};\n\ntemplate <class Weight>\nstd::vector<size_t> strongly_connected_components(const graph<Weight>& g) {\n  size_t n = g.size();\n  graph<int> rev(n);\n  for (const auto& v: g)\n    for (const auto& e: v)\n      rev.connect_to(e.dst, e.src);\n\n  std::vector<bool> used(n);\n  std::vector<size_t> vs;\n  auto dfs = make_fix_point([&](auto f, size_t v) -> void {\n      used[v] = true;\n      for (size_t i = 0; i < g[v].size(); ++i)\n        if (!used[g[v][i].dst]) f(g[v][i].dst);\n      vs.push_back(v);\n  });\n  for (size_t i = 0; i < n; ++i)\n    if (!used[i]) dfs(i);\n\n  used.assign(n, false);\n  std::vector<size_t> cmp(n);\n  size_t num = 0;\n  auto rdfs = make_fix_point([&](auto f, size_t v) -> void {\n      used[v] = true;\n      cmp[v] = num;\n      for (size_t i = 0; i < rev[v].size(); ++i)\n        if (!used[rev[v][i].dst]) f(rev[v][i].dst);\n  });\n\n  for (size_t i = vs.size(); i--;)\n    if (!used[vs[i]]) {\n      rdfs(vs[i]);\n      ++num;\n    }\n\n  return cmp;\n}\n\ntemplate <typename Weight>\nvoid add_condition(graph<Weight>& g, size_t i, size_t j) {\n  size_t k = g.size() / 2;\n  // (i or j) <=> (!i implies j) and (!j implies i)\n  size_t ni = ((i < k)? i+k : i-k);\n  size_t nj = ((j < k)? j+k : j-k);\n  g.connect_to(ni, j);\n  g.connect_to(nj, i);\n}\n\ntemplate <typename Weight>\nstd::vector<size_t> tsort(graph<Weight>& g) {\n  // based on Kahn algorithm\n  size_t n = g.size();\n  std::vector<size_t> indeg(n);\n  for (size_t i = 0; i < n; ++i)\n    for (auto const& e: g[i]) ++indeg[e.dst];\n\n  std::queue<size_t> q;\n  for (size_t i = 0; i < n; ++i)\n    if (indeg[i] == 0) q.push(i);\n\n  std::vector<size_t> res;\n  while (!q.empty()) {\n    size_t v = q.front();\n    q.pop();\n    res.push_back(v);\n    for (auto const& e: g[v])\n      if (--indeg[e.dst] == 0) q.push(e.dst);\n  }\n  if (res.size() < n) return {};\n  return res;\n}\n\ntemplate <typename Weight>\nbool satisfiable(graph<Weight> const& g) {\n  std::vector<size_t> scc = strongly_connected_components(g);\n  size_t n = g.size();\n  size_t m = *std::max_element(scc.begin(), scc.end()) + 1;\n  graph<int> h(m);\n  for (size_t i = 0; i < n; ++i) {\n    for (auto const& e: g[i]) {\n      size_t u = scc[e.src];\n      size_t v = scc[e.dst];\n      if (u == v) continue;\n      h.connect_to(u, v);\n    }\n  }\n  {\n    auto t = tsort(h);\n    for (size_t i = 0; i < n/2; ++i) {\n      size_t u = scc[i];\n      size_t v = scc[i+n/2];\n      if (t[u] == t[v]) return false;\n    }\n  }\n  return !tsort(h).empty();\n}\n\nint testcase_ends() {\n  size_t n;\n  scanf(\"%zu\", &n);\n  if (n == 0) return 1;\n\n  using zahyo = std::pair<size_t, size_t>;\n  std::map<zahyo, size_t> map;\n  graph<int> g(4*n);\n  size_t neg = n+n;\n\n  for (size_t i = 0; i < n; ++i) {\n    size_t x, y;\n    char d;\n    scanf(\"%zu %zu %c\", &x, &y, &d);\n    size_t i0 = i << 1 | 0;\n    size_t i1 = i << 1 | 1;\n    map[zahyo(x, y)] = i0;\n    size_t dx = (d == 'x');\n    size_t dy = (d == 'y');\n    map[zahyo(x+dx, y+dy)] = i1;\n\n    add_condition(g, i0, i1);\n    add_condition(g, neg+i0, neg+i1);\n  }\n\n  for (auto const& p: map) {\n    size_t i, j;\n    std::tie(i, j) = p.first;\n    size_t id = p.second;\n    for (size_t k = 0; k < 4; ++k) {\n      size_t ni = i + di[k];\n      size_t nj = j + dj[k];\n      auto it = map.find(zahyo(ni, nj));\n      if (it == map.end()) continue;\n      size_t nid = it->second;\n      if ((id >> 1) == (nid >> 1)) continue;\n\n      add_condition(g, neg+id, nid);\n      add_condition(g, id, neg+nid);\n    }\n  }\n\n  puts(satisfiable(g)? \"Yes\":\"No\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nmap<P,P> G;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\n\nset<PP> used;\nset<P> checked;\nint check(P head){\n  P leg = G[head];\n  if(used.count(PP(head,leg)))return 1;\n  if(used.count(PP(leg,head)))return 0;\n  used.insert(PP(head,leg));\n  checked.insert(head);\n  checked.insert(leg);\n\n  int res = 1;\n  for(int i=0;i<4;i++){\n    int nx = head.second+dx[i];\n    int ny = head.first+dy[i];\n    P nhead = P(ny,nx);\n    if(nhead == leg || !G.count(nhead))continue;\n    res &=check(nhead);\n  }\n\n  for(int i=0;i<4;i++){\n    int nx = leg.second+dx[i];\n    int ny = leg.first+dy[i];\n    P nleg = P(ny,nx);\n    if(nleg == head || !G.count(nleg))continue;\n    res &=check(G[nleg]);\n  }\n  return res;\n}\n\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    G.clear();\n    for(int i=0;i<n;i++){\n      int x,y;\n      char dir;\n      cin>>x>>y>>dir;\n      int a = x + (dir == 'x');\n      int b = y + (dir == 'y');\n      G[P(y,x)] = P(b,a);\n      G[P(b,a)] = P(y,x);\n    }\n\n    int ans = 1;\n    checked.clear();\n    for(PP a:G){\n      if(!ans || checked.count(a.first))continue;\n      used.clear();\n      if(check(a.first)) continue;\n      used.clear();\n      if(check(a.second))continue;\n      ans = 0;\n    }\n    cout<<(ans? \"Yes\":\"No\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 20000\ntypedef pair<int,int> pii;\n\nmap<pii,int> id;\nmap<int,pii> mp;\nint color[MAX][2],tmp[MAX][2];\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nstruct State{\n  int v,p,col;\n  State(int v,int p,int col) :\n    v(v),p(p),col(col) {}\n};\n\nbool bfs(int v,int p){\n  queue<State> Q;\n  Q.push(State(v,p,0));\n  Q.push(State(v+1,1-p,1));\n  \n  while(!Q.empty()){\n    State s = Q.front(); Q.pop();\n    pii np = mp[s.v];\n    if(color[s.v/2][s.p] >= 0){\n      if(color[s.v/2][s.p] != s.col){\n        return false;\n      }\n      continue;\n    }\n    color[s.v/2][s.p] = s.col;\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = np.first+dx[i],ny = np.second+dy[i];\n      if(id.find(pii(nx,ny)) != id.end()){\n        int x = id[pii(nx,ny)]%2;\n        if(id[np]/2 == id[pii(nx,ny)]/2){\n          Q.push(State(id[pii(nx,ny)],1-s.p,1-s.col));\n        }else{\n          Q.push(State(id[pii(nx,ny)],(x&1?1:0),s.col));\n        }\n      }\n    }\n  }\n  return true;\n}\n\nvoid init(){\n  mp.clear();\n  id.clear();\n  memset(color,-1,sizeof(color));\n}\n\nint main(){\n  int N,x,y;\n  char ch;\n  while(cin >> N,N){\n    init();\n    for(int i = 0 ; i < N ; i++){\n      cin >> x >> y >> ch;\n      int j = i*2;\n      if(ch == 'x'){\n        mp[j] = pii(x,y); mp[j+1] = pii(x+1,y);\n        id[pii(x,y)] = j; id[pii(x+1,y)] = j+1;\n      }else{\n        mp[j] = pii(x,y); mp[j+1] = pii(x,y+1);\n        id[pii(x,y)] = j; id[pii(x,y+1)] = j+1;\n      }\n    }\n    bool can = true;\n    for(int i = 0 ; i < 2*N ; i+=2){\n      if(color[i/2][0] >= 0){ continue; }\n      for(int j = 0 ; j < N ; j++){\n        for(int k = 0 ; k < 2 ; k++){\n          tmp[j][k] = color[j][k];\n        }\n      }\n      if(!bfs(i,0)){ can = false; }\n      if(!can){\n        can = true;\n        for(int j = 0 ; j < N ; j++){\n          for(int k = 0 ; k < 2 ; k++){\n            color[j][k] = tmp[j][k];\n          }\n        }\n        if(!bfs(i,1)){\n          can = false;\n          break;\n        }\n      }\n    }\n    cout << (can ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n//#define int long long\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define all(x) x.begin(), x.end()\nusing pii = pair<int, int>;\nusing ll = long long;\n\nint t = 0;\n\nstruct Futon {\n    int X[2], Y[2];\n    int id;\n    Futon(int x, int y, char c, int id) : id(id) {\n        X[0] = X[1] = x, Y[0] = Y[1] = y;\n        if (c == 'x')\n            X[1] = x + 1;\n        else\n            Y[1] = y + 1;\n    }\n    bool operator<(const Futon &rhs) {\n        if (X[0] == rhs.X[0]) return Y[0] < rhs.Y[0];\n        return X[0] < rhs.X[0];\n    }\n    void show() { cerr << X[0] << \" \" << Y[0] << \" \" << X[1] << \" \" << Y[1] << endl; }\n    pii p1() { return {X[0], Y[0]}; }\n    pii p2() { return {X[1], Y[1]}; }\n};\n\nconstexpr int dx[4] = {0, 0, -1, 1}, dy[4] = {1, -1, 0, 0};\nbool connect(Futon &a, Futon &b) {\n    REP(i, 2) REP(j, 2) REP(k, 4) {\n        if (a.X[i] + dx[k] == b.X[j] && a.Y[i] + dy[k] == b.Y[j]) return true;\n    }\n    return false;\n}\n\nvector<int> G[100010];\n\nbool solve() {\n    t++;\n    set<pii> stX, stY;\n    int N;\n    cin >> N;\n    if (N == 0) return false;\n    vector<Futon> fs;\n    REP(i, N) {\n        int x, y;\n        char c;\n        cin >> x >> y >> c;\n        Futon f(x, y, c, i);\n        fs.push_back(f);\n        G[i].clear();\n    }\n    sort(all(fs));\n    REP(i, N) {\n        FOR(j, i + 1, N) {\n            if (fs[j].X[0] > fs[i].X[0] + 2) break;\n            if (connect(fs[i], fs[j])) {\n                // fs[i].show();\n                // fs[j].show();\n                // cerr << endl;\n                G[i].push_back(j);\n                G[j].push_back(i);\n            }\n        }\n    }\n    map<pii, int> mp;\n    vector<bool> done(N);\n    bool possible = true;\n    queue<int> que;\n    REP(i, N) {\n        if (!possible) break;\n        if (done[i]) continue;\n\n        que.push(i);\n        while (!que.empty()) {\n            if (!possible) break;\n            int id = que.front();\n            que.pop();\n            if (done[id]) continue;\n            done[id] = true;\n            bool found1 = false, found2 = false;\n            int x0 = fs[id].X[0], y0 = fs[id].Y[0];\n            REP(k, 4) {\n                if (!mp.count({x0 + dx[k], y0 + dy[k]})) continue;\n                if (mp[{x0 + dx[k], y0 + dy[k]}] == 1) found1 = true;\n                if (mp[{x0 + dx[k], y0 + dy[k]}] == 2) found2 = true;\n            }\n            if (found1 && found2) possible = false;\n            int x1 = fs[id].X[1], y1 = fs[id].Y[1];\n            bool found11 = false, found22 = false;\n            REP(k, 4) {\n                if (!mp.count({x1 + dx[k], y1 + dy[k]})) continue;\n                if (mp[{x1 + dx[k], y1 + dy[k]}] == 1) found11 = true;\n                if (mp[{x1 + dx[k], y1 + dy[k]}] == 2) found22 = true;\n                if (mp[{x1 + dx[k], y1 + dy[k]}] == 1 && found1) possible = false;\n                if (mp[{x1 + dx[k], y1 + dy[k]}] == 2 && found2) possible = false;\n            }\n            if (found1 && found11) possible = false;\n            if (found2 && found22) possible = false;\n            if (found11 && found22) possible = false;\n            if (found2 || found11) {\n                mp[{x0, y0}] = 2;\n                mp[{x1, y1}] = 1;\n            } else {\n                mp[{x0, y0}] = 1;\n                mp[{x1, y1}] = 2;\n            }\n\n            for (auto nxt : G[id]) {\n                que.push(nxt);\n            }\n        }\n    }\n    REP(i, N) {\n        int x = fs[i].X[0], y = fs[i].Y[0];\n        int x1 = fs[i].X[1], y1 = fs[i].Y[1];\n        if (!possible) break;\n        if (mp[{x, y}] == 1) {\n            REP(k, 4) {\n                if (x + dx[k] == x1 && y + dy[k] == y1) continue;\n                if (mp[{x + dx[k], y + dy[k]}] == 2) possible = false;\n            }\n        } else if (mp[{x, y}] == 2) {\n            REP(k, 4) {\n                if (x + dx[k] == x1 && y + dy[k] == y1) continue;\n                if (mp[{x + dx[k], y + dy[k]}] == 1) possible = false;\n            }\n        } else {\n            cerr << \"not decided!!!!\" << endl;\n        }\n    }\n    if (possible)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n    return true;\n}\n\nsigned main() {\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\nclass UnionFind {\npublic:\n\tvector<int> Parent;\n\tUnionFind(int N) {\n\t\tParent = vector<int>(N, -1);\n\t}\n\tint root(int A) {\n\t\tif (Parent[A] < 0) {\n\t\t\treturn A;\n\t\t}\n\t\treturn Parent[A] = root(Parent[A]);\n\t}\n\n\tlong long size(int A) {\n\t\treturn -(long long)Parent[root(A)];\n\t}\n\n\tbool connect(int A, int B) {\n\t\tA = root(A);\n\t\tB = root(B);\n\t\tif (A == B) {\n\t\t\treturn false;\n\t\t}\n\t\tif (size(A) < size(B)) {\n\t\t\tswap(A, B);\n\t\t}\n\n\t\tParent[A] += Parent[B];\n\t\tParent[B] = A;\n\n\t\treturn true;\n\t}\n\n};\n\ntemplate<typename T>\nstruct Compress {\n\tvector<T> v;\n\tCompress() {}\n\tCompress(vector<T> _v) :v(_v) {\n\t\tsort(v.begin(), v.end());\n\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\t}\n\n\tvoid build(vector<T> _v) {\n\t\tv = _v;\n\t\tsort(v.begin(), v.end());\n\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\t}\n\tint get(T x) {\n\t\tif (!binary_search(v.begin(), v.end(), x)) assert(false);\n\t\treturn lower_bound(v.begin(), v.end(), x) - v.begin();\n\t}\n\n\tT& operator[](int i) { return v[i]; }\n\n\n\tint size() {\n\t\treturn (int)v.size();\n\t}\n};\n\nint dx[] = { 1,-1,0,0 };\nint dy[] = { 0,0,1,-1 };\n\nint cnt;\nvoid solve() {\n\tcnt++;\n\tusing P = pair<int, int>;\n\tint n; cin >> n; if (n == 0) exit(0);\n\tvector<vector<int>> x(2, vector<int>(n)), y(2, vector<int>(n));\n\tvector<char> c(n);\n\tCompress<P> comp;\n\tvector<P> v;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[0][i] >> y[0][i] >> c[i];\n\t\tv.emplace_back(x[0][i], y[0][i]);\n\t\tif (c[i] == 'x') {\n\t\t\tx[1][i] = x[0][i] + 1;\n\t\t\ty[1][i] = y[0][i];\n\t\t\tv.emplace_back(x[1][i], y[1][i]);\n\t\t}\n\t\telse {\n\t\t\tx[1][i] = x[0][i];\n\t\t\ty[1][i] = y[0][i] + 1;\n\t\t\tv.emplace_back(x[1][i], y[1][i]);\n\t\t}\n\t}\n\tcomp.build(v);\n\tint sz = comp.size();\n\tUnionFind uni(sz * 2);\n\tset<P> st;\n\tfor (int i = 0; i < n; i++) {\n\t\tP s = { x[0][i],y[0][i] };\n\t\tP t = { x[1][i],y[1][i] };\n\t\tint si = comp.get(s);\n\t\tint ti = comp.get(t);\n\t\tuni.connect(si, ti + sz);\n\t\tuni.connect(si + sz, ti);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = s.first + dx[i];\n\t\t\tint ny = s.second + dy[i];\n\t\t\tif (st.count({ nx,ny })) {\n\t\t\t\tint idx = comp.get({ nx,ny });\n\t\t\t\tuni.connect(si, idx);\n\t\t\t\tuni.connect(si + sz, idx + sz);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = t.first + dx[i];\n\t\t\tint ny = t.second + dy[i];\n\t\t\tif (st.count({ nx,ny })) {\n\t\t\t\tint idx = comp.get({ nx,ny });\n\t\t\t\tuni.connect(ti, idx);\n\t\t\t\tuni.connect(ti + sz, idx + sz);\n\t\t\t}\n\t\t}\n\t\tst.emplace(s);\n\t\tst.emplace(t);\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tP s = { x[0][i],y[0][i] };\n\t\tP t = { x[1][i],y[1][i] };\n\t\tint si = comp.get(s);\n\t\tint ti = comp.get(t);\n\t\tif (uni.root(si) == uni.root(si + sz)) {\n\t\t\tcout << \"No\" << \"\\n\";\n\t\t\treturn;\n\t\t}\n\t\tif (uni.root(ti) == uni.root(ti + sz)) {\n\t\t\tcout << \"No\" << \"\\n\";\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << \"Yes\" << \"\\n\";\n}\n\nint main()\n{\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint kkt = 89;\n\twhile (kkt) solve();\n\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nint getValue(map<int,map<int,int>>& m, int a, int b){\n\tif(m.count(a)){\n\t\tif(m[a].count(b)){\n\t\t\treturn m[a][b];\n\t\t}\n\t}\n\treturn -1;\n}\n\nconst int gmax_n = 80000;\n\nint par[gmax_n]; //親\nint depth[gmax_n];//木の深さ\n\nvoid init(int n){\n\trep(i,n){\n\t\tpar[i] = i;\n\t\tdepth[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}else {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(depth[x] < depth[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(depth[x] == depth[y]) depth[x]++;\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nvoid connect(map<int,map<int,int>>& m, int n, int p, int x, int y, int c){\n\trep(i,4){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tint np = getValue(m, nx, ny);\n\t\tif(np == -1) continue;\n\t\tif(np == p + n){\n\t\t\tunite(p, np + n);\n\t\t\tunite(p + n, np);\n\t\t}else{\n\t\t\tunite(p, np);\n\t\t\tunite(p + n, np + n);\n\t\t}\n\t}\n\n\tp += n;\n\trep(i,4){\n\t\tint nx = x + dx[i] + (c == 'x' ? 1 : 0);\n\t\tint ny = y + dy[i] + (c == 'y' ? 1 : 0);\n\t\tint np = getValue(m, nx, ny);\n\t\tif(np == -1) continue;\n\t\tif(np != p - n){\n\t\t\tunite(p, np);\n\t\t\tunite(p + n, np + n);\n\t\t}\n\t}\n}\n\nbool f(int n){\n\trep(i,n){\n\t\tif(same(i, i + n)) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tinit(n * 4);\n\t\tvector<int> x(n), y(n);\n\t\tvector<char> c(n);\n\t\trep(i,n){\n\t\t\tcin >> x[i] >> y[i] >> c[i];\n\t\t}\n\n\t\tmap<int,map<int,int>> ma;\n\t\trep(i,n){\n\t\t\tma[x[i]][y[i]] = i;\n\t\t\tif(c[i] == 'x') ma[x[i] + 1][y[i]] = i + n;\n\t\t\telse ma[x[i]][y[i] + 1] = i + n;\n\t\t}\n\n\t\trep(i,n){\n\t\t\tconnect(ma, n, i, x[i], y[i], c[i]);\n\t\t}\n\t\tcout << (f(n) ? \"Yes\" : \"No\") << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 20000\n#define HEAD MOD\n#define FOOT MOD+1\n\ntypedef pair<int,int> Point;\n\nenum Type{\n\tTATE,\n\tYOKO,\n};\n\nstruct Info{\n\tint row,col;\n\tType dir;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_index,int arg_which){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tindex = arg_index;\n\t\twhich = arg_which;\n\t}\n\n\tint row,col,index,which;\n};\n\n\nmap<Point,int> MAP; //<座標、布団インデックス>\nInfo info[NUM];\nvector<int> Group[NUM]; //隣接している布団のグループ\n\nint near_row[4] = {1,0,0,-1},near_col[4] = {0,-1,1,0};\nint diff_row[2][6] = {{2,1,1,0,0,-1},{-1,-1,0,0,1,1}},diff_col[2][6] = {{0,-1,1,-1,1,0},{0,1,-1,2,0,1}};\n\nint N;\nint boss[NUM],height[NUM];\n\n//自分のボスのindexを取得しつつ、経路圧縮を行う関数\nint get_boss(int id){\n\tif(boss[id] == id)return id; //自分が代表なら、自分の値を返す\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]); //代表でないなら、自分が所属する組織の代表を返しつつ、経路圧縮\n\t}\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\t//既に同じグループなら何もしない\n\tif(boss_x == boss_y)return;\n\n\t//高さが高い方に吸収する\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nbool check(int group_id){\n\n\tmap<Point,int> ROOM;\n\tqueue<Data> Q;\n\n\t//ボスの、左下側を頭にする(ボスのid == group_id)\n\tROOM[Point(info[group_id].row,info[group_id].col)] = HEAD;\n\t//printf(\"(%d,%d)に%dの頭を配置\\n\",info[group_id].row,info[group_id].col,group_id);\n\tQ.push(Data(info[group_id].row,info[group_id].col,group_id,HEAD));\n\n\tbool FLG = true;\n\n\tint adj_row,adj_col,adj_index;\n\n\twhile(!Q.empty()){\n\n\t\t//printf(\"index:%d row:%d col:%d type:%d\\n\",Q.front().index,Q.front().row,Q.front().col,Q.front().which);\n\n\t\t//隣接4近傍を検索\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tadj_row = Q.front().row+near_row[i];\n\t\t\tadj_col = Q.front().col+near_col[i];\n\n\t\t\tauto at = MAP.find(Point(adj_row,adj_col));\n\t\t\tif(at == MAP.end())continue; //隣接する布団がなければSKIP\n\n\t\t\tadj_index = MAP[Point(adj_row,adj_col)];\n\t\t\t//printf(\"adj_row:%d,adj_col:%d adj_index:%d\\n\",adj_row,adj_col,adj_index);\n\n\t\t\tif(adj_index != Q.front().index){ //自分以外の布団が隣接\n\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){ //まだ割り当てがされていない\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD; //頭と足は隣接してはいけない\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,HEAD));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの頭を配置\\n\",adj_row,adj_col,adj_index);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,FOOT));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの足を配置\\n\",adj_row,adj_col,adj_index);\n\t\t\t\t\t}\n\t\t\t\t}else{ //割り当て済\n\t\t\t\t\tif((ROOM[Point(adj_row,adj_col)] == FOOT && Q.front().which == HEAD) ||\n\t\t\t\t\t\t\t(ROOM[Point(adj_row,adj_col)] == HEAD && Q.front().which == FOOT)){ //矛盾発生\n\t\t\t\t\t\t//printf(\"異種隣接\\n\");\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{ //自分の布団が隣接\n\t\t\t\t//自分のもう一方に、不適な割り当てがされていないか調べる\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){ //まだ割り当てがされていない\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,FOOT));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの頭を配置\\n\",adj_row,adj_col,Q.front().index);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,HEAD));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの足を配置\\n\",adj_row,adj_col,Q.front().index);\n\t\t\t\t\t}\n\t\t\t\t}else{ //割り当て済\n\t\t\t\t\tif(ROOM[Point(adj_row,adj_col)] == Q.front().which){ //矛盾発生\n\t\t\t\t\t\t//printf(\"同じパーツが重複\\n\");\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG)break;\n\n\t\tQ.pop();\n\t}\n\n\tif(FLG)return true;\n\n\n\tFLG = true;\n\tROOM.clear();\n\n\t//ボスの、左下側を足にする\n\tROOM[Point(info[group_id].row,info[group_id].col)] = FOOT;\n\tQ.push(Data(info[group_id].row,info[group_id].col,group_id,FOOT));\n\t//printf(\"(%d,%d)に%dの足を配置\\n\",info[group_id].row,info[group_id].col,group_id);\n\n\twhile(!Q.empty()){\n\n\t\t//printf(\"index:%d row:%d col:%d type:%d\\n\",Q.front().index,Q.front().row,Q.front().col,Q.front().which);\n\n\t\t//隣接4近傍を検索\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tadj_row = Q.front().row+near_row[i];\n\t\t\tadj_col = Q.front().col+near_col[i];\n\n\t\t\tauto at = MAP.find(Point(adj_row,adj_col));\n\t\t\tif(at == MAP.end())continue; //隣接する布団がなければSKIP\n\n\t\t\tadj_index = MAP[Point(adj_row,adj_col)];\n\t\t\t//printf(\"adj_row:%d,adj_col:%d adj_index:%d\\n\",adj_row,adj_col,adj_index);\n\n\t\t\tif(adj_index != Q.front().index){ //自分以外の布団が隣接\n\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){ //まだ割り当てがされていない\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD; //頭と足は隣接してはいけない\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,HEAD));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの頭を配置\\n\",adj_row,adj_col,adj_index);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,FOOT));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの足を配置\\n\",adj_row,adj_col,adj_index);\n\t\t\t\t\t}\n\t\t\t\t}else{ //割り当て済\n\t\t\t\t\tif((ROOM[Point(adj_row,adj_col)] == FOOT && Q.front().which == HEAD) ||\n\t\t\t\t\t\t\t(ROOM[Point(adj_row,adj_col)] == HEAD && Q.front().which == FOOT)){ //矛盾発生\n\t\t\t\t\t\t//printf(\"異種隣接\\n\");\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{ //自分の布団が隣接\n\t\t\t\t//自分のもう一方に、不適な割り当てがされていないか調べる\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){ //まだ割り当てがされていない\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,FOOT));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの頭を配置\\n\",adj_row,adj_col,Q.front().index);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,HEAD));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの足を配置\\n\",adj_row,adj_col,Q.front().index);\n\t\t\t\t\t}\n\t\t\t\t}else{ //割り当て済\n\t\t\t\t\tif(ROOM[Point(adj_row,adj_col)] == Q.front().which){ //矛盾発生\n\t\t\t\t\t\t//printf(\"同じパーツが重複\\n\");\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG)break;\n\n\t\tQ.pop();\n\t}\n\n\n\treturn FLG;\n}\n\nvoid func(){\n\n\tMAP.clear();\n\tfor(int i = 0; i < N; i++)Group[i].clear();\n\n\tinit();\n\n\tchar buf[2];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %s\",&info[i].col,&info[i].row,buf);\n\t\tif(buf[0] == 'x'){\n\t\t\tinfo[i].dir = YOKO;\n\t\t}else{\n\t\t\tinfo[i].dir = TATE;\n\t\t}\n\t\tMAP[Point(info[i].row,info[i].col)] = i; //マップに登録(2マス分)\n\t\tif(info[i].dir == YOKO){\n\t\t\tMAP[Point(info[i].row,info[i].col+1)] = i;\n\t\t}else{\n\t\t\tMAP[Point(info[i].row+1,info[i].col+1)] = i;\n\t\t}\n\t}\n\n\t//隣接している布団のグループを作る\n\tint adj_row,adj_col;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < 6; k++){\n\t\t\tadj_row = info[i].row+diff_row[info[i].dir][k];\n\t\t\tadj_col = info[i].col+diff_col[info[i].dir][k];\n\n\t\t\tauto at = MAP.find(Point(adj_row,adj_col));\n\t\t\tif(at == MAP.end())continue;\n\n\t\t\tunite(i,MAP[Point(adj_row,adj_col)]); //隣接している布団を同じグループにする\n\t\t}\n\t}\n\n\tvector<int> BOSS;\n\tfor(int i = 0; i < N; i++){ //布団をグループに振り分ける\n\t\tGroup[get_boss(i)].push_back(i);\n\t\tif(boss[i] == i){\n\t\t\tBOSS.push_back(i); //ボスを収集する\n\t\t}\n\t}\n\n\tfor(int i = 0; i < BOSS.size(); i++){\n\t\tif(check(BOSS[i]) == false){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tprintf(\"Yes\\n\");\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION false\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nstruct futon {\n\tPII cells[2];\n};\n\nvector<futon> futons;\nmap<PII, bool> is_head;\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tfutons.clear();\n\t\tis_head.clear();\n\t\tREP (i, n) {\n\t\t\tint x, y; cin >> x >> y; char d; cin >> d;\n\t\t\tfuton f; f.cells[0] = MP(y, x); f.cells[1] = MP(y+(d=='y'), x+(d=='x'));\n\t\t\tfutons.PB(f);\n\t\t}\n\t\tREP (i, n) {\n\t\t\tPII p = futons[i].cells[0];\n\t\t\t// Look around\n\t\t\tbool free = true, adj_head = false;\n\t\t\tREP (d, 4) {\n\t\t\t\tint y = p.F + dy[d], x = p.S + dx[d];\n\t\t\t\tif (EXIST(is_head, MP(y, x))) {\n\t\t\t\t\tdprt(\"(%d, %d) is %d, free: %d, adj_head: %d\\n\", x, y, is_head[MP(y, x)], free, adj_head);\n\t\t\t\t\tif (free) {\n\t\t\t\t\t\tif (is_head[MP(y, x)] == true) adj_head = true;\n\t\t\t\t\t\telse adj_head = false;\n\t\t\t\t\t\tadj_head = is_head[MP(y, x)];\n\t\t\t\t\t\tfree = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (is_head[MP(y, x)] == true && !adj_head) goto NO;\n\t\t\t\t\t\telse if (is_head[MP(y, x)] == false && adj_head) goto NO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Opposite cell\n\t\t\tbool head = !adj_head;\n\t\t\tPII op = futons[i].cells[1];\n\t\t\t// Look around\n\t\t\tREP (d, 4) {\n\t\t\t\tint y = op.F + dy[d], x = op.S + dx[d];\n\t\t\t\tif (EXIST(is_head, MP(y, x))) {\n\t\t\t\t\tif (is_head[MP(y, x)] == true && !head) goto NO;\n\t\t\t\t\telse if (is_head[MP(y, x)] == false && head) goto NO;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Here is valid\n\t\t\tif (free) {\n\t\t\t\t// Look diagonally and take optimal choice\n\t\t\t\tint ddx[] = {-1, 1, -1, 1}, ddy[] = {1, 1, -1, -1};\n\t\t\t\tREP (d, 4) {\n\t\t\t\t\tint y = p.F + ddy[d], x = p.S + ddx[d];\n\t\t\t\t\tif (EXIST(is_head, MP(y, x))) {\n\t\t\t\t\t\tadj_head = is_head[MP(y,x)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\thead = !adj_head;\n\t\t\t}\n\t\t\tis_head[MP(p.F, p.S)] = adj_head;\n\t\t\tis_head[MP(op.F, op.S)] = head;\n\t\t\tdprt(\"(%d, %d) = %d, (%d, %d) = %d\\n\", p.S, p.F, adj_head, op.S, op.F, head);\n\t\t}\nYES:\n\t\tcout << \"Yes\" << endl;\n\t\tcontinue;\nNO:\n\t\tcout << \"No\" << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<vector>\n\nusing namespace std;\n\nint x[20000],y[20000];\nchar dir[20000];\nint p[20000];\nvector<vector<int> >G;\n\nint dst(int x1,int y1,int x2,int y2){\n  return abs(x1-x2)+abs(y1-y2);\n}\n\nbool dfs(int v){\n  for(auto e:G[v]){\n    int sp=(dst(x[v],y[v],x[e],y[e])==2)?-1:1;\n    if(p[e]==0){\n      p[e]=sp*p[v];\n      if(!dfs(e))return false;\n    }else{\n      if(p[e]*p[v]!=sp)return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    for(int i=0;i<n;i++){\n      cin>>x[i]>>y[i]>>dir[i];\n    }\n    G=vector<vector<int> >(n);\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(min({dst(x[i],y[i],x[j],y[j]),\n\t\tdst(x[i],y[i],x[j]+(dir[j]=='x'),y[j]+(dir[j]=='y')),\n\t\tdst(x[i]+(dir[i]=='x'),y[i]+(dir[i]=='y'),x[j],y[j]),\n\t\tdst(x[i]+(dir[i]=='x'),y[i]+(dir[i]=='y'),x[j]+(dir[j]=='x'),y[j]+(dir[j]=='y'))\n\t\t})==1){\n\t  G[i].push_back(j);\n\t  G[j].push_back(i);\n\t}\n      }\n    }\n    fill(begin(p),end(p),0);\n    bool f=false;\n    for(int i=0;i<n;i++){\n      if(p[i]==0){\n\tp[i]=1;\n      }\n      f|=!dfs(i);\n    }\n    cout<<(f?\"No\":\"Yes\")<<endl;\n  }\n}  \n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\nint di[4] = {0, 1, 0, -1};\nint dj[4] = {1, 0, -1, 0};\n\nbool dfs(int cur, vector<vector<pair<int, int>>> &g, vector<int> &color, int c){\n    \n    color[cur] = c;\n    //cout << cur << \" \" << c << endl;\n    for(int i = 0; i < g[cur].size(); i++){\n        int nxt = g[cur][i].first;\n        int val = g[cur][i].second;\n        \n\n        // 違う色にしなきゃ\n        if(val == 1){\n            int nxtc = 1;\n            if(c == 1) nxtc = 2;\n            if(color[nxt] == 0){\n                if(!dfs(nxt, g, color, nxtc)) return false;\n            }else if(color[nxt] != nxtc) return false;\n        }else{\n            int nxtc = 1;\n            if(c == 2) nxtc = 2;\n            if(color[nxt] == 0){\n                if(!dfs(nxt, g, color, nxtc)) return false;\n            }else if(color[nxt] != nxtc) return false;\n        }\n    }\n    return true;  \n}\n\nsigned main(){\n    \n    while(1){\n        int n; cin >> n;\n        if(!n) break;\n        vector<int> x(n);\n        vector<int> y(n);\n        vector<char> dir(n);\n        map<pair<int, int>, int> toNode;\n        int V = 0;\n        vector<vector<pair<int, int>>> g(2 * n);\n        for(int i = 0; i < n; i++){\n            cin >> x[i] >> y[i] >> dir[i];\n            pair<int, int> u = {x[i], y[i]};\n            pair<int, int> v = u;\n            if(dir[i] == 'x') v.first++;\n            else v.second++;\n            int from = V;\n            toNode[u] = V;\n            V++;\n            int to = V;\n            toNode[v] = V;\n            V++;\n            g[from].push_back({to, 1});\n            g[to].push_back({from, 1});\n        }\n        \n        for(auto itr : toNode){\n            pair<int, int> cur = itr.first;\n            int curNode = itr.second;\n            for(int h = 0; h < 4; h++){\n                pair<int, int> nxt = cur;\n                nxt.first += di[h];\n                nxt.second += dj[h];\n                if(toNode.find(nxt) != toNode.end()){\n                    int nxtNode = toNode[nxt];\n                    // 1 が既にあれば continue\n                    bool flag = true;\n                    for(int j = 0; j < g[curNode].size(); j++){\n                        if(g[curNode][j].first == nxtNode && g[curNode][j].second == 1) flag = false;\n                    }\n                    if(flag) g[curNode].push_back({nxtNode, 2});\n                }\n            }\n        }\n        \n        // グラフの判定\n        assert(V = 2 * n);\n        // 0 := 未決定\n        // 1 := しろ\n        // 2 := くろ\n\n        /*\n        cout << \"gruph\" << endl;\n        for(int i = 0; i < V; i++){\n            for(int j = 0; j < (int)g[i].size(); j++){\n                cout << i << \" \" << g[i][j].first << \" \" << g[i][j].second << endl;\n            }\n        }\n        */\n\n        string ans = \"Yes\";\n        vector<int> color(V, 0);\n        for(int i = 0; i < V; i++){\n            if(color[i] == 0){\n                if(!dfs(i, g, color, 1)){\n                    ans = \"No\";\n                    break;\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nstruct Huton {\n\tint x, y;\n\tchar c;\n\tHuton() {\n\n\t}\n\tHuton(const int a, const int b, const  char cc) {\n\t\ty = a, x = b, c = cc;\n\t}\n\tbool operator<(const Huton&h)const {\n\t\treturn make_pair(make_pair(y, x), c - 'a') < make_pair(make_pair(h.y, h.x), c - 'a');\n\t}\n};\n\nvoid push(vector<vector<int>>&edge, int a, int b) {\n\tedge[a].push_back(b);\n\tedge[b].push_back(a);\n}\n\nvoid in(map<Huton, int>&mp, vector<vector<int>>&edge, pair<Huton, int>h, int y, int x, char c, int aadd, int badd) {\n\tauto it = mp.find(Huton(y, x, c));\n\tif (it != mp.end()&&c==it->first.c) {\n\t\tpush(edge, h.second * 2 + aadd, it->second * 2 + badd);\n\t\tif (h.first.c == c && aadd == badd) {\n\t\t\tpush(edge, h.second * 2 + aadd + 1, it->second * 2 + badd + 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\twhile (cin >> N, N) {\n\t\tvector<vector<int>>same(N * 2);\n\t\tvector<vector<int>>tigau(N * 2);\n\t\tmap<Huton, int>mp;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tHuton h;\n\t\t\tcin >> h.x >> h.y >> h.c;\n\t\t\tmp[h] = i;\n\t\t}\n\t\tfor (int i = 0; i < N * 2; i += 2) {\n\t\t\ttigau[i].push_back(i + 1);\n\t\t\ttigau[i + 1].push_back(i);\n\t\t}\n\t\tfor (auto i : mp) {\n\t\t\tif (i.first.c == 'x') {\n\t\t\t\tin(mp, same, i, i.first.y + 0, i.first.x + 2, 'y', 1, 0);\n\t\t\t\tin(mp, same, i, i.first.y + 1, i.first.x + 0, 'y', 0, 0);\n\t\t\t\tin(mp, same, i, i.first.y + 1, i.first.x + 1, 'y', 1, 0);\n\t\t\t\tin(mp, same, i, i.first.y + 0, i.first.x + 2, 'x', 1, 0);\n\t\t\t\tin(mp, same, i, i.first.y + 1, i.first.x - 1, 'x', 0, 1);\n\t\t\t\tin(mp, same, i, i.first.y + 1, i.first.x - 0, 'x', 0, 0);\n\t\t\t\tin(mp, same, i, i.first.y + 1, i.first.x + 1, 'x', 1, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tin(mp, same, i, i.first.y + 0, i.first.x + 1, 'y', 0, 0);\n\t\t\t\tin(mp, same, i, i.first.y + 1, i.first.x - 1, 'y', 1, 0);\n\t\t\t\tin(mp, same, i, i.first.y + 1, i.first.x + 1, 'y', 1, 0);\n\t\t\t\tin(mp, same, i, i.first.y + 2, i.first.x + 0, 'y', 1, 0);\n\t\t\t\tin(mp, same, i, i.first.y + 0, i.first.x + 1, 'x', 0, 0);\n\t\t\t\tin(mp, same, i, i.first.y + 1, i.first.x + 1, 'x', 1, 0);\n\t\t\t\tin(mp, same, i, i.first.y + 1, i.first.x - 2, 'x', 1, 1);\n\t\t\t\tin(mp, same, i, i.first.y + 2, i.first.x - 1, 'x', 1, 1);\n\t\t\t\tin(mp, same, i, i.first.y + 2, i.first.x - 0, 'x', 1, 0);\n\t\t\t}\n\t\t}\n\t\tbool flag = true;\n\t\tvector<int>node(N * 2, -1);\n\t\tqueue<int>Q;\n\t\tfor (int i = 0; i < N * 2; i++) {\n\t\t\tif (node[i] >= 0)continue;\n\t\t\tnode[i] = 0;\n\t\t\tqueue<int>Q;\n\t\t\tQ.push(i);\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint cn = Q.front();\n\t\t\t\tQ.pop();\n\t\t\t\tfor (auto j : same[cn]) {\n\t\t\t\t\tif (node[j] == -1) {\n\t\t\t\t\t\tnode[j] = node[cn];\n\t\t\t\t\t\tQ.push(j);\n\t\t\t\t\t}\n\t\t\t\t\tif (node[j] != node[cn])flag = false;\n\t\t\t\t}\n\t\t\t\tfor (auto j : tigau[cn]) {\n\t\t\t\t\tif (node[j] == -1) {\n\t\t\t\t\t\tnode[j] = 1 - node[cn];\n\t\t\t\t\t\tQ.push(j);\n\t\t\t\t\t}\n\t\t\t\t\tif (node[j] + node[cn] != 1)flag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (flag)cout << \"Yes\\n\";\n\t\telse cout << \"No\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, lli> P;\n\nconst lli N = 20000;\n\nclass T{\npublic:\n  lli x, y;\n  char c;\n  T(){}\n  T(lli x, lli y, char c) : x(x), y(y), c(c){}\n};\n\nvector<T> data;\nmap<P, lli> mp;\nmap<P, lli> dist; // 0 = atama, 1= ashi;\nbool ans;\nlli dx[2][6] = {\n  {0, 1, 2, 1, 0, -1},\n  {0, 1, 1, 0, -1, -1}\n};\nlli dy[2][6] = {\n  {-1, -1, 0, 1, 1, 0},\n  {-2, -1, 0, 1, 0, -1}\n};\nlli dx2[4] = {0, 1, 0, -1};\nlli dy2[4] = {-1, 0, 1, 0};\n\nvoid dfs(lli pos){\n  lli next[2] = {-1, -1};\n  P p[2];\n  lli d = (data[pos].c == 'x' ? 0 : 1);\n  p[0] = make_pair(data[pos].x, data[pos].y);\n  p[1] = (d ? make_pair(data[pos].x, data[pos].y+1) : make_pair(data[pos].x+1, data[pos].y));\n  for(lli k=0;k<2;k++){\n    for(lli i=0;i<4;i++){\n      lli nx = p[k].first + dx2[i];\n      lli ny = p[k].second + dy2[i];\n      P np = make_pair(nx, ny);\n      if(dist.find(np) != dist.end()){\n\tlli nc = dist[np];\n\tif(next[k] == -1) next[k] = nc;\n\telse if(next[k] != nc){\n\t  ans = false;\n\t  return;\n\t}\n      }\n    }\n  }\n  if(next[0] == -1 && next[1] == -1){\n    dist[p[0]] = 0;\n    dist[p[1]] = 1;\n  }else if(next[0] == -1){\n    dist[p[0]] = 1 - next[1];\n    dist[p[1]] = next[1];\n  }else if(next[1] == -1){\n    dist[p[0]] = next[0];\n    dist[p[1]] = 1 - next[0];\n  }else{\n    dist[p[0]] = next[0];\n    dist[p[1]] = next[1];\n  }\n  for(lli k=0;k<2;k++){\n    for(lli i=0;i<6;i++){\n      lli nx = p[k].first + dx[d][i];\n      lli ny = p[k].second + dy[d][i];\n      P np = make_pair(nx, ny);\n      if(mp.find(np) != mp.end() && dist.find(np) == dist.end()){\n\tdfs(mp[np]);\n      }\n    }\n  }      \n}\n\nvoid init(){\n  mp.clear();\n  dist.clear();\n  ans = true;\n  data.clear();\n}\n\nint main(){\n  lli n;\n  while(cin >> n && n){\n    init();\n    for(lli i=0;i<n;i++){\n      T in;\n      cin >> in.x >> in.y >> in.c;\n      data.push_back(in);\n      if(in.c == 'x'){\n\tmp[make_pair(in.x, in.y)] = i;\n\tmp[make_pair(in.x+1, in.y)] = i;\n      }else{\n\tmp[make_pair(in.x, in.y)] = i;\n\tmp[make_pair(in.x, in.y+1)] = i;\n      }\n    }\n    for(lli i=0;i<n;i++){\n      P p = make_pair(data[i].x, data[i].y);\n      if(dist.find(p) == dist.end()){\n\tdfs(i);\n      }\n    }\n    cout << (ans ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\n#include <string>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\n\n#define pb push_back\n#define fs first\n#define sc second\n#define openfile {freopen(\"input.txt\", \"r\", stdin);freopen(\"output.txt\", \"w\", stdout);}\n#define debug 0\n\nstruct cell\n{\n\tint x, y;\n\tint vt;\n};\n\nstruct futon\n{\n\tcell a, b;\n};\n\nconst int MAXN = 20005;\nconst int mov[4][2] = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};\n\nint col[MAXN];\nvector <int> adj[MAXN];\nfuton a[MAXN];\ncell b[MAXN * 2];\nint n, m;\nbool ok;\n\nvoid rset()\n{\n\tm = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tadj[i].clear();\n\tmemset(col, 0, sizeof col);\n}\n\nbool mycmp(const cell &a, const cell &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint bs2(int trai, int phai, int y)\n{\n\tint L = trai, R = phai, mid;\n\twhile (L + 1 < R)\n\t{\n\t\tmid = (L + R) / 2;\n\t\tif (b[mid].y < y) L = mid;\n\t\telse R = mid;\n\t}\n\tif (b[L].y == y) return b[L].vt;\n\telse if (b[R].y == y) return b[R].vt;\n\treturn -1;\n}\n\nint bs1(int x, int y)\n{\n\tint trai, phai;\n\n\tint L = 1, R = m, mid;\n\twhile (L + 1 < R)\n\t{\n\t\tmid = (L + R) / 2;\n\t\tif (b[mid].x < x) L = mid;\n\t\telse R = mid;\n\t}\n\tif (b[L].x == x) trai = L;\n\telse if (b[R].x == x) trai = R;\n\telse return -1;\n\n\tL = 1, R = m;\n\twhile (L + 1 < R)\n\t{\n\t\tmid = (L + R) / 2;\n\t\tif (b[mid].x > x) R = mid;\n\t\telse L = mid;\n\t}\n\tif (b[R].x == x) phai = R;\n\telse if (b[L].x == x) phai = L;\n\telse return -1;\n\n\treturn bs2(trai, phai, y);\n}\n\nvoid init()\n{\n\tsort(b+1, b+m+1, mycmp);\n\tfor (int i = 1; i <= m; i++)\n\tfor (int j = 0; j < 4; j++)\n\t{\n\t\tint x = b[i].x + mov[j][0], y = b[i].y + mov[j][1];\n\t\tint k = bs1(x, y);\n\t\tif (k == -1) continue;\n\t\tif (k != b[i].vt) adj[b[i].vt].pb(k), adj[k].pb(b[i].vt);\n\t}\n}\n\nbool isKe(cell a, cell b)\n{\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tint x = a.x + mov[i][0], y = a.y + mov[i][1];\n\t\tif (x == b.x && y == b.y) return true;\n\t}\n\treturn false;\n}\n\nvoid dfs(int u)\n{\n\tfor (int i = 0; i < (int)adj[u].size() && ok; i++)\n\t{\n\t\tint v = adj[u][i];\n\t\tif (!col[v])\n\t\t{\n\t\t\tif (isKe(a[v].a, a[u].a))\n\t\t\t{\n\t\t\t\tif (col[u] == 1) col[v] = 1;\n\t\t\t\telse col[v] = 2;\n\t\t\t}\n\t\t\telse if (isKe(a[v].a,a[u].b))\n\t\t\t{\n\t\t\t\tif (col[u] == 1) col[v] = 2;\n\t\t\t\telse col[v] = 1;\n\t\t\t}\n\t\t\telse if (isKe(a[v].b,a[u].a))\n\t\t\t{\n\t\t\t\tif (col[u] == 1) col[v] = 2;\n\t\t\t\telse col[v] = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (col[u] == 1) col[v] = 1;\n\t\t\t\telse col[v] = 2;\n\t\t\t}\n\t\t\tdfs(v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (isKe(a[v].a, a[u].a))\n\t\t\t{\n\t\t\t\tif (col[u] != col[v]) { ok = false; return; }\n\t\t\t}\n\t\t\telse if (isKe(a[v].a,a[u].b))\n\t\t\t{\n\t\t\t\tif (col[u] == col[v]) { ok = false; return; }\n\t\t\t}\n\t\t\telse if (isKe(a[v].b,a[u].a))\n\t\t\t{\n\t\t\t\tif (col[u] == col[v]) { ok = false; return; }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (col[u] != col[v]) { ok = false; return; }\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\tok = true;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tif (col[i]) continue;\n\n\t\tcol[i] = 1;\n\t\tdfs(i);\n\t\tif (ok) continue;\n\n\t\tcol[i] = 2;\n\t\tdfs(i);\n\t\tif (!ok)\n\t\t{\n\t\t\tputs(\"No\");\n\t\t\treturn;\n\t\t}\n\t}\n\tputs(\"Yes\");\n}\n\nint main()\n{\n   if (debug) openfile;\n\n   while (scanf(\"%d\", &n) && n)\n\t{\n\t\trset();\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tscanf(\"%d%d\", &a[i].a.x, &a[i].a.y);\n\t\t\tb[++m] = a[i].a;\n\t\t\tb[m].vt = i;\n\t\t\tchar ch;\n\t\t\tscanf(\"%c%c\", &ch, &ch);\n\t\t\tif (ch == 'x')\n\t\t\t{\n\t\t\t\ta[i].b.x = a[i].a.x + 1;\n\t\t\t\ta[i].b.y = a[i].a.y;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ta[i].b.x = a[i].a.x;\n\t\t\t\ta[i].b.y = a[i].a.y + 1;\n\t\t\t}\n\t\t\tb[++m] = a[i].b;\n\t\t\tb[m].vt = i;\n\t\t\tscanf(\"%c\", &ch);\n\t\t}\n\t\tinit();\n\t\tsolve();\n\t}\n\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\n\nmap< pair<int,int>, map<pair<int,int>,int> > es;\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,1,0,-1};\n\nmap< pair<int,int>,int> color;\n\nint dfs(pair<int,int> p,int c){\n\tif( color.count(p) ){\n\t\tif( color[p] != c ) return 0;\n\t\treturn 1;\n\t}else color[p] = c;\n\tfor( auto e : es[p] ){\n\t\tif( !dfs(e.first,c^e.second) ){\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tcolor.clear();\n\t\tes.clear();\n\t\tset< pair<int,int> > v;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tfor(int d = 0 ; d < 2 ; d++){\n\t\t\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\t\t\tint X = x + (c=='x' and d);\n\t\t\t\t\tint Y = y + (c=='y' and d);\n\t\t\t\t\tint XX = X + dx[i];\n\t\t\t\t\tint YY = Y + dy[i];\n\t\t\t\t\tif( v.count({XX,YY}) ){ \n\t\t\t\t\t\tes[{X,Y}][{XX,YY}] = 0;\n\t\t\t\t\t\tes[{XX,YY}][{X,Y}] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tv.insert({x,y});\t\t\t\n\t\t\tif( c == 'x' ){\n\t\t\t\tv.insert({x+1,y});\n\t\t\t\tes[{x+1,y}][{x,y}] = 1;\n\t\t\t\tes[{x,y}][{x+1,y}] = 1;\n\t\t\t}else{\n\t\t\t\tv.insert({x,y+1});\n\t\t\t\tes[{x,y+1}][{x,y}] = 1;\n\t\t\t\tes[{x,y}][{x,y+1}] = 1;\n\t\t\t}\n\n\t\t}\n\t\tbool flag = true;\n\t\tfor( auto i : v ){\n\t\t\tif( !color.count(i) ){\n\t\t\t\tflag &= dfs(i,0);\n\t\t\t}\n\t\t}\n\t\tcout << (flag?\"Yes\":\"No\") << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint n;\nvector<int> t[100000];\nint dx[] = {1,-1,0,0};\nint dy[] = {0,0,1,-1};\nbool used[100000];\nint color[100000];\n\nbool dfs(int idx,int c){\n  //cout<<idx<<\",\"<<c<<endl;\n\n  color[idx] = c;\n  used[idx] = true;\n\n  rep(i,t[idx].size()){\n    int next = t[idx][i];\n\n    if(color[next] == -1){\n      if(idx + n == next || idx - n == next){\n        bool res = dfs(next,!c);\n        if(!res) return false;\n      }\n      else{\n        bool res = dfs(next,c);\n        if(!res) return false;\n      }\n    }\n    else{\n      if((idx + n == next || idx - n == next) && color[next] == color[idx]) return false;\n      if(!(idx + n == next || idx - n == next) && color[next] != color[idx]) return false;\n    }\n  }\n\n  return true;\n}\n\nbool solve(){\n  memset(used,0,sizeof(used));\n\n  REP(i,1,n+1){\n    if(!used[i]){\n      memset(color,-1,sizeof(color));\n      bool flg = dfs(i,0);\n      if(!flg) return false;\n    }\n  }\n\n  return true;\n}\n\nint main(){\n  while(scanf(\"%d\",&n),n){\n    rep(i,100000) t[i].clear();\n\n    map<P,int> m;\n\n    REP(i,1,n+1){\n      int x[2],y[2];\n      char buff[10];\n\n      scanf(\"%d%d%s\",&x[0],&y[0],buff);\n\n      if(buff[0] == 'x'){\n        x[1] = x[0] + 1;\n        y[1] = y[0];\n      }\n      else{\n        x[1] = x[0];\n        y[1] = y[0] + 1;\n      }\n\n      rep(k,2){\n        rep(j,4){\n          int nx = x[k] + dx[j];\n          int ny = y[k] + dy[j];\n          int tmp = m[P(nx,ny)];\n          if(tmp != 0){\n            t[i+k*n].push_back(tmp);\n            t[tmp].push_back(i+k*n);\n          }\n        }\n      }\n\n      rep(j,2){\n        m[P(x[j],y[j])] = i + j * n;\n      }\n      t[i].push_back(i+n);\n      t[i+n].push_back(i);\n    }\n\n    bool res = solve();\n    printf(\"%s\\n\",res ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconst int dy[4] = {1, 0, -1, 0};\nconst int dx[4] = {0, 1, 0, -1};\nint n;\nint x[20010], y[20010];\nstring dir[20010];\nmap<int, map<int, int>> mp;\nint checked[20010];\nint used[20010];\n\nbool dfs(int curr, int p) {\n  checked[curr] = 1;\n  used[curr] = p;\n  bool res = true;\n  for (int i = 0; i < 4; i++) {\n    int ny = y[curr] + dy[i];\n    int nx = x[curr] + dx[i];\n    int next = mp[ny][nx];\n    if (!next || next == curr) continue;\n    if (y[next] == ny && x[next] == nx) {\n      res *= !used[next] ? dfs(next, p) : used[next] == p;\n    } else {\n      res *= !used[next] ? dfs(next, -p) : used[next] == -p;\n    }\n  }\n  for (int i = 0; i < 4; i++) {\n    int ny = y[curr] + dy[i] + (dir[curr] == \"y\");\n    int nx = x[curr] + dx[i] + (dir[curr] == \"x\");\n    int next = mp[ny][nx];\n    if (!next || next == curr) continue;\n    if (y[next] == ny && x[next] == nx) {\n      res *= !used[next] ? dfs(next, -p) : used[next] == -p;\n    } else {\n      res *= !used[next] ? dfs(next, p) : used[next] == p;\n    }\n  }\n  used[curr] = 0;\n  return res;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  while (cin >> n, n) {\n    mp.clear();\n    fill_n((int*)checked, 20010, 0);\n    for (int i = 1; i <= n; i++) {\n      cin >> x[i] >> y[i] >> dir[i];\n      mp[y[i]][x[i]] = i;\n      mp[y[i] + (dir[i] == \"y\")][x[i] + (dir[i] == \"x\")] = i;\n    }\n    string ans = \"Yes\";\n    for (int i = 1; i <= n; i++) {\n      if (checked[i]) continue;\n      fill_n((int*)used, 20010, 0);\n      if (dfs(i, 1)) continue;\n      fill_n((int*)used, 20010, 0);\n      if (dfs(i, -1)) continue;\n      ans = \"No\";\n    }\n    cout << ans << endl;\n  }  \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int MAX_N = 20001;\nconst int dx[4] = {0,0,-1,1};\nconst int dy[4] = {-1,1,0,0};\n\n// input\nint n, x[MAX_N], y[MAX_N];\nchar dir[MAX_N];\n\nint futon[MAX_N];\nbool used[MAX_N];\nmap<P,int> m;\nbool ans;\n\nvoid dfs(int pos, int k){\n\tif( !ans ) return ;\n\t\n\tint x1 = x[pos], y1 = y[pos], x2, y2;\n\tused[pos] = true;\n\tfuton[pos] = k;\n\tint next = (k + 1) % 2;\n\tif( dir[pos] == 'x' ){\n\t\tx2 = x1 + 1, y2 = y1;\n\t}else{\n\t\tx2 = x1, y2 = y1 + 1;\n\t}\n\t\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = x1 + dx[i], my = y1 + dy[i];\n\t\tif( mx == x2 && my == y2 ) continue;\n\t\t\n\t\tif( m.count(P(mx, my)) ){\n\t\t\tint id = m[P(mx, my)];\n\t\t\tif( used[id] ){\n\t\t\t\tif( futon[id] == futon[pos] ){\n\t\t\t\t\tans = false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdfs(id, next);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = x2 + dx[i], my = y2 + dy[i];\n\t\tif( mx == x1 && my == y1 ) continue;\n\t\t\n\t\tif( m.count(P(mx, my)) ){\n\t\t\tint id = m[P(mx, my)];\n\t\t\tif( used[id] ){\n\t\t\t\tif( futon[id] == futon[pos] ){\n\t\t\t\t\tans = false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdfs(id, next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\t// initialize \n\t\tfill(used, used + MAX_N, false);\n\t\tfill(futon, futon + MAX_N, -1);\n\t\tm.clear();\n\t\tans = true;\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tcin >> x[i] >> y[i] >> dir[i];\n\t\t\tm[P(x[i], y[i])] = i;\n\t\t\tif( dir[i] == 'x' ) m[P(x[i] + 1, y[i])] = i;\n\t\t\tif( dir[i] == 'y' ) m[P(x[i] , y[i] + 1)] = i;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tif( used[i] ) continue;\n\t\t\tdfs(i, 0);\n\t\t}\n\t\tcout << (ans? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n;\nint x,y;\nchar d;\nvector<P> f[2];\nvector<int> g[20100];\nbool vis[20100];\n\nvoid add_edge(int u,int v){\n  g[v].push_back(u);\n  g[u].push_back(v);\n}\n\nint md(P a, P b){\n  return abs(a.first-b.first) + abs(a.second-b.second);\n}\n\nbool dfs(int v,int init,bool even){\n  if(vis[v]){\n    if(v == init)return even;\n    return true;\n  }\n  vis[v] = true;\n\n  for(int i=0;i<g[v].size();i++){\n    if(!dfs(g[v][i],init,!even))return false;\n  }\n  return true;\n}\n\nint main(){\n  cin.tie(0); std::ios::sync_with_stdio(false);\n\n  while(cin >> n,n){\n    f[0].clear(); f[1].clear();\n    for(int i=0;i<n;i++){\n      cin >> x >> y >> d;\n      if(d=='x'){\n\tf[0].push_back(P(x+1,y));\n\tf[1].push_back(P(x,y));\n      }else{\n\tf[0].push_back(P(x,y+1));\n\tf[1].push_back(P(x,y));\n      }\n    }\n\n    for(int i=0;i<n;i++)g[i].clear();\n    \n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(i==j)continue;\n\tfor(int ii=0;ii<2;ii++)\n\t  for(int jj=0;jj<2;jj++)\n\t    if(md(f[ii][i],f[jj][j])==1){\n\t      add_edge(i,j);\n\t      break;\n\t    }\n      }\n    }\n    bool flag = true;\n    for(int i=0;i<n;i++){\n      memset(vis,0,sizeof(vis));\n      flag &= dfs(i,i,true);\n      if(!flag)break;\n    }\n \n    cout << (flag?\"Yes\":\"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nbool adjecent(const Pii& p, const Pii& q) {\n    return abs(p.first - q.first) + abs(p.second - q.second) <= 1;\n}\n\nbool update(const int i, const int j, VV& color, const vector<vector<Pii>>& futon) {\n    rep(k, 2) {\n        rep(l, 2) {\n            if (!adjecent(futon[i][k], futon[j][l])) continue;\n            // cout << \"adjecent: \" << \"(\" << i << \", \" << k << \"), \" << \"(\" << j << \", \" << l << \")\" << endl;\n            if (/* color[i][k] != -1 && */ color[j][l] != -1 && color[i][k] != color[j][l]) {\n                return false;\n            }\n            if (color[j][l] == -1) {\n                color[j][l] = color[i][k];\n                color[j][l ^ 1] = color[i][k ^ 1];\n            }\n        }\n    }\n    return true;\n}\n\nbool solve(const int n) {\n    vector<vector<Pii>> futon(n);\n    rep(i, n) {\n        int x, y;\n        string d;\n        cin >> x >> y >> d;\n        futon[i].emplace_back(Pii(x, y));\n        int k = (d == \"x\");\n        futon[i].emplace_back(Pii(x + 1 * k, y + 1 * (k ^ 1)));\n    }\n\n    // cout << \"--futon--\" << endl;\n    // rep(i, n) {\n    //     rep(k, 2) {\n    //         cout << futon[i][k].first << \" \" << futon[i][k].second << \" \";\n    //     }\n    //     cout << endl;\n    // }\n\n\n    VV color(n, V(2, -1));\n    rep(i, n) {\n        if (color[i][0] == -1) {\n            color[i][0] = 0, color[i][1] = 1;\n        }\n        rep2(j, i + 1, n) {\n            if (!update(i, j, color, futon)) return false;\n            // cout << i << \" \" << j << endl;\n            // rep(k, n) {\n            //     cout << \"(\" << color[k][0] << \", \" << color[k][1] << \") \" << endl;\n            // }\n        }\n    }\n\n    return true;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        cout << (solve(n) ? \"Yes\" : \"No\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct Point{\n\tint x,y;\n\tbool operator<(const Point &p)const{ return make_pair(x,y)<make_pair(p.x,p.y); }\n};\n\ntypedef pair<Point,Point> Futon;\n\nint n,mark[40000];\nvector<int> adj[40000];\n\n// u Æ v ª¯¶ÓÆñÉ®·é©Ç¤©\nbool issame(int u,int v){ return abs(u-v)==n; }\n\nbool dfs(int u){\n\tbool ok=true;\n\trep(i,adj[u].size()){\n\t\tint v=adj[u][i];\n\t\tif(mark[v]==-1){\n\t\t\tif(issame(u,v)) mark[v]=1-mark[u];\n\t\t\telse            mark[v]=mark[u];\n\t\t\tif(!dfs(v)){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(!issame(u,v) && mark[u]!=mark[v]){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tmark[u]=-1;\n\treturn ok;\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tPoint futon[40000];\n\t\tmap<Point,int> f;\n\t\trep(j,n){\n\t\t\tint x,y;\n\t\t\tchar dir; scanf(\"%d%d %c\",&x,&y,&dir);\n\n\t\t\tfuton[j]=(Point){x,y};\n\t\t\tif(dir=='x') futon[n+j]=(Point){x+1,y};\n\t\t\tif(dir=='y') futon[n+j]=(Point){x,y+1};\n\n\t\t\tf[futon[ j ]]=j;\n\t\t\tf[futon[n+j]]=n+j;\n\t\t}\n\n\t\trep(u,2*n){\n\t\t\tadj[u].clear();\n\t\t\trep(k,4){\n\t\t\t\tint x=futon[u].x+dx[k];\n\t\t\t\tint y=futon[u].y+dy[k];\n\t\t\t\tPoint p={x,y};\n\t\t\t\tif(f.count(p)) adj[u].push_back(f[p]);\n\t\t\t}\n\t\t}\n\n\t\tbool ok=true;\n\t\trep(u,2*n) mark[u]=-1;\n\t\trep(u,2*n) if(mark[u]==-1) {\n\t\t\tmark[u]=0;\n\t\t\tif(!dfs(u)){ ok=false; break; }\n\t\t}\n\n\t\tputs(ok?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef string::const_iterator State;\n\nmap<P, int> f, a;\nVI check, x, y, d;\nbool pos;\nint dx[] = {-1,1,0,0}, dy[] = {0,0,1,-1};\n\nvoid dfs(int id, int xc, int yc, int c){\n    if (check[id]) return;\n    check[id] = 1;\n    int x1, x2, y1, y2;\n    x1 = x[id], y1 = y[id];\n    if (d[id] == 0) x2 = x1 + 1, y2 = y1;\n    else x2 = x1, y2 = y1 + 1;\n    if (x1 == xc && y1 == yc){\n        a[P(x1,y1)] = c;\n        a[P(x2,y2)] = c^1;\n        REP(k,4){\n            int xx = x1 + dx[k], yy = y1 + dy[k];\n            if (xx == x2 && yy == y2) continue;\n            if (f[P(xx,yy)] == 0) continue;\n            int id_next = f[P(xx,yy)] - 1;\n            if (check[id_next] && a[P(xx,yy)] != c) pos = false;\n            dfs(id_next, xx, yy, c);\n        }\n        REP(k,4){\n            int xx = x2 + dx[k], yy = y2 + dy[k];\n            if (xx == x1 && yy == y1) continue;\n            if (f[P(xx,yy)] == 0) continue;\n            int id_next = f[P(xx,yy)] - 1;\n            if (check[id_next] && a[P(xx,yy)] == c) pos = false;\n            dfs(id_next, xx, yy, c^1);\n        }\n    }\n    if (x2 == xc && y2 == yc){\n        a[P(x2,y2)] = c;\n        a[P(x1,y1)] = c^1;\n        REP(k,4){\n            int xx = x2 + dx[k], yy = y2 + dy[k];\n            if (xx == x1 && yy == y1) continue;\n            if (f[P(xx,yy)] == 0) continue;\n            int id_next = f[P(xx,yy)] - 1;\n            if (check[id_next] && a[P(xx,yy)] != c) pos = false;\n            dfs(id_next, xx, yy, c);\n        }\n        REP(k,4){\n            int xx = x1 + dx[k], yy = y1 + dy[k];\n            if (xx == x2 && yy == y2) continue;\n            if (f[P(xx,yy)] == 0) continue;\n            int id_next = f[P(xx,yy)] - 1;\n            if (check[id_next] && a[P(xx,yy)] == c) pos = false;\n            dfs(id_next, xx, yy, c^1);\n        }\n    }\n}\n\nint main() {\n    int n;\n    while (cin >> n && n){\n        pos = true;\n        f.clear();\n        a.clear();\n        check.clear();\n        check.resize(n);\n        x.resize(n);\n        y.resize(n);\n        d.resize(n);\n        REP(i,n){\n            char c;\n            cin >> x[i] >> y[i] >> c;\n            f[P(x[i], y[i])] = i+1;\n            if (c == 'x') f[P(x[i]+1, y[i])] = i+1, d[i] = 0;\n            else f[P(x[i], y[i]+1)] = i+1, d[i] = 1;\n        }\n        REP(i,n){\n            if (!check[i]) dfs(i, x[i], y[i], 1);\n            // REP(j,n) cout << check[j];\n            // cout << endl;\n        }\n\n        // REP(i,4){\n        //     REP(j,4){\n        //         cout << f[P(i,j)];\n        //     }\n        //     cout << endl;\n        // }\n        // cout << endl;\n        // REP(i,4){\n        //     REP(j,4){\n        //         cout << a[P(i,j)];\n        //     }\n        //     cout << endl;\n        // }\n\n        cout << (pos ? \"Yes\" : \"No\") << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef pair< int, int > pii;\ntypedef pair< pii, pii > ppii;\n\nconst int dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\nint n, x[20020], y[20020], visit[20020][2];\nchar dir[20020];\npii pos[40040], ids[40040];\n\nint xadd(int i) { return dir[i] == 'x' ? 1 : 0; }\nint yadd(int i) { return dir[i] == 'y' ? 1 : 0; }\n\nbool rec(int i, int j, int v, vector< pii >& upd) {\n\tbool res = 1;\n\t\n\tif (visit[i][j] < 0) {\n\t\tvisit[i][j] = v;\n\t\tvisit[i][j^1] = v^1;\n\t\tupd.push_back(pii(i,j));\n\t\tupd.push_back(pii(i,j^1));\n\t\t\n\t\tfor_(d,0,4) {\n\t\t\tpii nx(x[i] + dx[d], y[i] + dy[d]);\n\t\t\tint k = lower_bound(pos, pos + 2*n, nx) - pos;\n\t\t\tif (k < 2*n && pos[k] == nx && ids[k].second != i) res &= rec(ids[k].second, ids[k].first, j ? v^1 : v, upd);\n\t\t\t\n\t\t\tnx.first += xadd(i); nx.second += yadd(i);\n\t\t\tk = lower_bound(pos, pos + 2*n, nx) - pos;\n\t\t\tif (k < 2*n && pos[k] == nx && ids[k].second != i) res &= rec(ids[k].second, ids[k].first, j ? v : v^1, upd);\n\t\t}\n\t} else {\n\t\tres = (visit[i][j] == v);\n\t}\n\t\n\treturn res;\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n), n) {\n\t\tvector< ppii > vp;\n\t\t\n\t\tfor_(i,0,n) {\n\t\t\tscanf(\"%d %d %c\", &x[i], &y[i], &dir[i]);\n\t\t\tvp.push_back(ppii(pii(x[i], y[i]), pii(0, i)));\n\t\t\tvp.push_back(ppii(pii(x[i] + xadd(i), y[i] + yadd(i)), pii(1, i)));\n\t\t}\n\t\t\n\t\tsort(vp.begin(), vp.end());\n\t\t\n\t\tfor_(i,0,2*n) {\n\t\t\tpos[i] = vp[i].first;\n\t\t\tids[i] = vp[i].second;\n\t\t}\n\t\t\n\t\tmemset(visit, -1, sizeof(visit));\n\t\t\n\t\tbool ok = 1;\n\t\tfor_(i,0,n && ok) {\n\t\t\tif (visit[i][0] < 0) {\n\t\t\t\tvector< pii > upd;\n\t\t\t\tif (!rec(i, 0, 0, upd)) {\n\t\t\t\t\tint u_size = (int)upd.size();\n\t\t\t\t\tfor_(j,0,u_size) visit[upd[j].first][upd[j].second] = -1;\n\t\t\t\t\tok = rec(i, 0, 1, upd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef pair<int, int> P;\ntypedef pair<P, char> S;\nint N;\nmap<P, int> m;\nS s[20000];\nbool h_used[40000];\nbool l_used[40000];\nint dfs(int idx){\n  if(idx == N) return true;\n  int x = s[idx].first.first, y = s[idx].first.second;\n  int x2 = x, y2 = y;\n  if(s[idx].second == 'x') x2++;\n  else y2++;\n  vector<int> useidx1;\n  REP(r, 4){\n    int nx = x + dx[r], ny = y + dy[r];\n    if(m.count(P(nx, ny))){\n      useidx1.push_back(m[P(nx, ny)]);\n    }\n  }\n  vector<int> useidx2;\n  REP(r, 4){\n    int nx = x2 + dx[r], ny = y2 + dy[r];\n    if(m.count(P(nx, ny))){\n      useidx2.push_back(m[P(nx, ny)]);\n    }\n  }\n  REP(iter, 2){\n    if(!h_used[m[P(x, y)]] && !l_used[m[P(x2, y2)]]){\n      //printf(\"put (%d, %d) idx = %d\\n\", x, y, idx);\n      //printf(\"leg is (%d, %d)\\n\", x2, y2);\n      bool mem1[4] = {};\n      bool mem2[4] = {};\n      REP(i, useidx1.size()) {mem1[i] = l_used[useidx1[i]]; l_used[useidx1[i]] = true;}\n      REP(i, useidx2.size()) {mem2[i] = h_used[useidx2[i]]; h_used[useidx2[i]] = true;}\n      if(dfs(idx + 1)) return true;\n      REP(i, useidx1.size()) l_used[useidx1[i]] = mem1[i];\n      REP(i, useidx2.size()) h_used[useidx2[i]] = mem2[i];\n    }\n    if(iter == 0){\n      swap(x, x2); swap(y, y2); swap(useidx1, useidx2);\n    }\n  }\n  return false;\n}\nint main(){\n  while(cin>>N && N){\n    m.clear();\n    int ID = 0;\n    REP(i, N) scanf(\"%d %d %c\", &s[i].first.first, &s[i].first.second, &s[i].second);\n    sort(s, s + N);\n    REP(i, N){\n      int x = s[i].first.first, y = s[i].first.second;\n      m[P(x, y)] = ID++;\n      if(s[i].second == 'x'){\n        m[P(x + 1, y)] = ID++;\n      }else{\n        m[P(x, y + 1)] = ID++;\n      }\n    }\n    memset(h_used, 0, sizeof(h_used));\n    memset(l_used, 0, sizeof(l_used));\n    if(dfs(0)){\n      cout<<\"Yes\"<<endl;\n    }else{\n      cout<<\"No\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\nchar dx[] = {1,0,-1,0};\nchar dy[] = {0,1,0,-1};\n\nint main(){\n\tint n; \n\tint color[40000];\n\twhile(cin >> n, n){\n\t\tint x, y; char c;\n\t\tvector< pair<int,int> > vp;\n\t\tmap< pair<int,int>, int > futon;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> x >> y >> c;\n\t\t\tvp.push_back(make_pair(x         ,y         ));\n\t\t\tvp.push_back(make_pair(x+(c=='x'),y+(c=='y')));\n\t\t\tfuton.insert(make_pair(vp[2*i  ],2*i  ));\n\t\t\tfuton.insert(make_pair(vp[2*i+1],2*i+1));\n\t\t}\n\t\tmemset(color,-1,sizeof(color));\n\t\tbool flag = true;\n\t\tmap< pair<int,int>, int >::iterator it;\n\t\tfor(it=futon.begin();it!=futon.end()&&flag;it++){\n\t\t\tif(color[(*it).second]!=-1) continue;\n\t\t\tcolor[(*it).second] = 0;\n\t\t\tqueue<int> qu; qu.push((*it).second);\n\t\t\twhile(!qu.empty()&&flag){\n\t\t\t\tint pos = qu.front(); qu.pop();\n\t\t\t\tint x = vp[pos].first, y = vp[pos].second;\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint nx = x+dx[i], ny = y+dy[i];\n\t\t\t\t\tif(futon.count(make_pair(nx,ny)) != 0){\n\t\t\t\t\t\tint next = futon[make_pair(nx,ny)];\n\t\t\t\t\t\tif(color[next]!=-1){\n\t\t\t\t\t\t\tif(color[next] != (color[pos]+(next/2==pos/2))%2) flag = false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcolor[next] = (color[pos]+(next/2==pos/2))%2;\n\t\t\t\t\t\t\tqu.push(next);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (flag ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint N;\ntypedef pair<int, int> pii;\n\nint const INF = 1e9+10;\n\nint main() {\n\n  while(cin >> N && N) {\n    map<int, int> cX, cY;\n    map<pii, char> cD;\n    set<pii> nolegs;\n    int xs[N], ys[N]; char dirs[N];\n    rep(i, N) {\n      cin >> xs[i] >> ys[i] >> dirs[i];\n      cX[xs[i]] = cY[ys[i]] = 0;\n      if(dirs[i]=='x') { cX[xs[i]+1] = cY[ys[i]-1] = cY[ys[i]+1] = 0; }\n      if(dirs[i]=='y') { cY[ys[i]-1] = cX[xs[i]-1] = cX[xs[i]+1] = 0; }\n    }\n    cX[-INF] = cY[-INF] = cX[INF] = cY[INF] = 0;\n    { int cnt = 0; for(auto& e: cX) { e.second = cnt++; } }\n    { int cnt = 0; for(auto& e: cY) { e.second = cnt++; } }\n    rep(i, N) cD[{cX[xs[i]], cY[ys[i]]}] = dirs[i];\n\n    bool ok = true;\n    rep(i, N) {\n      pii legs  = {cX[xs[i]], cY[ys[i]]};\n      if(dirs[i]=='x') {\n        for(int d=-1;d<=1;d+=2) {\n          if(nolegs.count(legs)) { ok = false; }\n          pii h_adj = {cX[xs[i]+1], cY[ys[i]+d]};\n          nolegs.insert(h_adj);\n        }\n      }\n      if(dirs[i]=='y') {\n        for(int d=-1;d<=1;d+=2) {\n          if(nolegs.count(legs)) { ok = false; }\n          pii h_adj = {cX[xs[i]+d], cY[ys[i]-1]};\n          nolegs.insert(h_adj);\n        }\n      }\n    }\n    puts(ok ? \"Yes\" : \"No\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint N;\ntypedef pair<int, int> pii;\n\nint const INF = 1e9+10;\n\nint main() {\n\n  while(cin >> N && N) {\n    map<int, int> cX, cY;\n    set<pii> nolegs;\n    int xs[N], ys[N]; char dirs[N];\n    rep(i, N) {\n      cin >> xs[i] >> ys[i] >> dirs[i];\n      cX[xs[i]] = cY[ys[i]] = 0;\n      if(dirs[i]=='x') { cX[xs[i]+1] = cY[ys[i]-1] = cY[ys[i]+1] = 0; }\n      if(dirs[i]=='y') { cY[ys[i]-1] = cX[xs[i]-1] = cX[xs[i]+1] = 0; }\n    }\n    cX[-INF] = cY[-INF] = cX[INF] = cY[INF] = 0;\n    { int cnt = 0; for(auto& e: cX) { e.second = cnt++; } }\n    { int cnt = 0; for(auto& e: cY) { e.second = cnt++; } }\n\n    bool ok = true;\n    rep(i, N) {\n      pii legs  = {cX[xs[i]], cY[ys[i]]};\n      if(dirs[i]=='x') {\n        for(int d=-1;d<=1;d+=2) {\n          if(nolegs.count(legs)) { ok = false; }\n          pii h_adj = {cX[xs[i]+1], cY[ys[i]+d]};\n          nolegs.insert(h_adj);\n        }\n      }\n      if(dirs[i]=='y') {\n        for(int d=-1;d<=1;d+=2) {\n          if(nolegs.count(legs)) { ok = false; }\n          pii h_adj = {cX[xs[i]+d], cY[ys[i]-1]};\n          nolegs.insert(h_adj);\n        }\n      }\n    }\n    puts(ok ? \"Yes\" : \"No\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\n//[int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }; int dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tmap<pii, int> mp;\n\t\tvector<vector<pii>> v;\n\t\tREP(i, n)\n\t\t{\n\t\t\tint x, y; char c;\n\t\t\tcin >> x >> y >> c;\n\t\t\tauto l = pii(x, y);\n\t\t\tif (c == 'x') x++;\n\t\t\telse y++;\n\t\t\tauto r = pii(x, y);\n\t\t\tmp[l] = i;\n\t\t\tmp[r] = i;\n\t\t\tv.emplace_back(vector<pii>{l, r});\n\t\t}\n\t\tvector<bool> vis(n);\n\t\tmap<pii, bool> con;\n\t\tbool ans = true;\n\t\tREP(i, n)\n\t\t{\n\t\t\tif (vis[i]) continue;\n\t\t\tvis[i] = true;\n\t\t\tqueue<pii> que;\n\t\t\tREP(j, 2)\n\t\t\t{\n\t\t\t\tque.push(v[i][j]);\n\t\t\t\tcon[v[i][j]] = j;\n\t\t\t}\n\t\t\twhile (que.size())\n\t\t\t{\n\t\t\t\tint tx = que.front().first, ty = que.front().second;\n\t\t\t\tpii tmp = que.front();\n\t\t\t\tque.pop();\n\t\t\t\tREP(j, 4)\n\t\t\t\t{\n\t\t\t\t\tint nx = tx + dx[j], ny = ty + dy[j];\n\t\t\t\t\tpii t(nx, ny);\n\t\t\t\t\tif (mp.find(t) == mp.end()) continue;\n\t\t\t\t\tint futon = mp[t];\n\t\t\t\t\tpii oth;\n\t\t\t\t\tif (v[futon][0] == t) oth = v[futon][1];\n\t\t\t\t\telse oth = v[futon][0];\n\t\t\t\t\tif (oth == tmp) continue;\n\n\t\t\t\t\tif (con.find(t) == con.end())\n\t\t\t\t\t{\n\t\t\t\t\t\tcon[t] = con[tmp];\n\t\t\t\t\t\tcon[oth] = 1 - con[tmp];\n\t\t\t\t\t\tque.push(t); que.push(oth);\n\t\t\t\t\t\tvis[futon] = true;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (con[t] != con[tmp]) \n\t\t\t\t\t\t\tans = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(ans ? \"Yes\" : \"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <map>\n#include <stack>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nstruct futon {\n\tint x, y;\n\tchar d;\n\tfuton(int x = 0, int y = 0, char d = 0):x(x), y(y), d(d){}\n};\n\nistream& operator>>(istream& is, futon& f) {\n\treturn is >> f.x >> f.y >> f.d;\n}\n\nconst int LEFT_BOTTOM = (1 << 25);\nconst int dx[2][2][3] = {{{-1, 0, 0}, {0, -1, 1}}, {{2, 1, 1}, {0, -1, 1}}};\nconst int dy[2][2][3] = {{{0, 1, -1}, {-1, 0, 0}}, {{0, -1, 1}, {2, 1, 1}}};\n\ntypedef pair<int, int> point;\n\nvector<int> color;\nmap<point, int> field;\nvector<futon> futons;\n\nbool dfs(int start) {\n\tstack<pair<int, int>> sta;\n\tsta.push(make_pair(start, 0));\n\n\twhile(!sta.empty()) {\n\t\tconst int idx = sta.top().first;\n\t\tconst int c = sta.top().second;\n\t\tsta.pop();\n\n\t\tif(color[idx] != -1) {\n\t\t\tif(color[idx] == c) continue;\n\t\t\telse return false;\n\t\t}\n\t\tcolor[idx] = c;\n\n\t\tconst int x = futons[idx].x;\n\t\tconst int y = futons[idx].y;\n\t\tconst int d = futons[idx].d - 'x';\n\n\t\tfor(int i = 0; i < 2; ++i) {\n\t\t\tfor(int j = 0; j < 3; ++j) {\n\t\t\t\tpoint np(x + dx[i][d][j], y + dy[i][d][j]);\n\t\t\t\tif(!field.count(np)) continue;\n\n\t\t\t\tint next_c = (c ^ i);\n\t\t\t\tint next_idx = field[np];\n\t\t\t\tif(!(next_idx & LEFT_BOTTOM)) next_c = !next_c;\n\t\t\t\telse next_idx &= ~LEFT_BOTTOM;\n\n\t\t\t\tsta.push(make_pair(next_idx, next_c));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tfutons.clear();\n\t\tfutons.resize(n);\n\n\t\tfield.clear();\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> futons[i];\n\t\t\tfield[point(futons[i].x, futons[i].y)] = (i | LEFT_BOTTOM);\n\t\t\tif(futons[i].d == 'x') field[point(futons[i].x + 1, futons[i].y)] = i;\n\t\t\telse field[point(futons[i].x, futons[i].y + 1)] = i;\n\t\t}\n\n\t\tcolor.assign(n, -1);\n\t\tstring ans = \"Yes\";\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tif(color[i] == -1 && !dfs(i)) {\n\t\t\t\tans = \"No\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nchar c;\nint x[20001][2],y[20001][2];\nvector<int>v[40001];\nint b[40001],f,n;\nvoid dfs(int p,int col){\n  b[p]=col;\n  r(i,v[p].size()){\n    if(!(p==v[p][i]+n||p+n==v[p][i])&&b[v[p][i]]&&b[v[p][i]]!=col)f++;\n    else if(!b[v[p][i]]){\n      if(p==v[p][i]+n||p+n==v[p][i]){\n        if(col==1)dfs(v[p][i],2);\n        else dfs(v[p][i],1);\n      }\n      else dfs(v[p][i],col);\n    }\n  }\n}\nint main(){\n  while(cin>>n,n){\n    memset(b,0,sizeof(b));\n    r(i,40001)v[i].clear();\n    r(i,n){\n      cin>>x[i][0]>>y[i][0]>>c;\n      if(c=='x')x[i][1]=x[i][0]+1,y[i][1]=y[i][0];\n      else x[i][1]=x[i][0],y[i][1]=y[i][0]+1;\n    }\n    r(i,n)v[i].push_back(i+n),v[i+n].push_back(i);\n    r(i,n)r(j,n)if(i!=j&&i<j)r(l,2)r(k,2){\n      if(abs(x[i][l]-x[j][k])+abs(y[i][l]-y[j][k])==1){\n        int p1=i,p2=j;\n        if(l)p1+=n;\n        if(k)p2+=n;\n        v[p1].push_back(p2);\n        v[p2].push_back(p1);\n      }\n      else if(abs(x[i][l]-x[j][k])==3&&abs(y[i][l]-y[j][k])==0){\n        int p1=i,p2=j;\n        if(l)p1+=n;\n        if(k)p2+=n;\n        v[p1].push_back(p2);\n        v[p2].push_back(p1);\n      }\n      if(abs(x[i][l]-x[j][k])==0&&abs(y[i][l]-y[j][k])==3){\n        int p1=i,p2=j;\n        if(l)p1+=n;\n        if(k)p2+=n;\n        v[p1].push_back(p2);\n        v[p2].push_back(p1);\n      }\n    }\n    f=0;\n    r(i,n*2)if(!b[i])dfs(i,1);\n    cout<<(f?\"No\":\"Yes\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n\npii in[40010];\n\n\nbool check[40010];\n\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\n\nint main(void){\n\tint n;\n\twhile(cin >> n){\n\t\tif(n==0) break;\n\n\t\tmap<pii,int> memo;\n\t\trep(i,n){\n\t\t\tchar dir;\n\t\t\tcin >> in[2*i].first >> in[2*i].second >> dir;\n\t\t\tin[2*i+1]=in[2*i];\n\t\t\tint d=(dir=='x')?2:3;\n\t\t\tin[2*i+1].first+=dx[d],in[2*i+1].second+=dy[d];\n\t\t\tmemo[in[2*i]]=2*i;\n\t\t\tmemo[in[2*i+1]]=2*i+1;\n\t\t}\n\t\tclr(check,false);\n\n\t\tbool ans=true;\n\t\trep(i,n){\n\t\t\tif(check[2*i]) continue;\n\t\t\tbool ok=false;\n\t\t\trep(j,2){\n\t\t\t\tbool ok2=true;\n\t\t\t\tmap<int,int> color;\n\t\t\t\tqueue<int> q;\n\n\t\t\t\tcolor[2*i]=j;\n\t\t\t\tcolor[2*i+1]=j^1;\n\t\t\t\tq.push(2*i);\n\t\t\t\tq.push(2*i+1);\n\n\t\t\t\twhile(!q.empty()){\n\t\t\t\t\tint cur=q.front();q.pop();\n\t\t\t\t\tpii xy=in[cur];\n\t\t\t\t\trep(l,4){\n\t\t\t\t\t\tpii next=xy;\n\t\t\t\t\t\tnext.first+=dx[l],next.second+=dy[l];\n\t\t\t\t\t\tif(memo.find(next)==memo.end()) continue;\n\t\t\t\t\t\tint index=memo[next];\n\t\t\t\t\t\tif(color.find(index)==color.end()){\n\t\t\t\t\t\t\tcolor[index]=color[cur];\n\t\t\t\t\t\t\tcolor[index^1]=color[cur]^1;\n\t\t\t\t\t\t\tq.push(index);\n\t\t\t\t\t\t\tq.push(index^1);\n\t\t\t\t\t\t}else if((cur^1)!=index&&color[index]!=color[cur])\n\t\t\t\t\t\t\tok2=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok2){\n\t\t\t\t\tok=true;\n\t\t\t\t\tfor(auto &k:color) check[k.second]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok) ans=false;\n\t\t}\n\t\tif(ans)\n\t\t\tputs(\"Yes\");\n\t\telse\n\t\t\tputs(\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <sstream>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<30\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<P, P> PP;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint main() {\n\tint n;\n\twhile(cin >> n && n) {\n\n\t\tvector<PP> v(n);\n\t\tmap<P, int> id;\n\t\trep(i, n) {\n\t\t\tint x, y;\n\t\t\tchar dir;\n\t\t\tcin >> x >> y >> dir;\n\t\t\n\t\t\tid[mp(x, y)] = i;\n\t\t\tv[i].first = mp(x, y);\n\n\t\t\tif(dir == 'x') {\n\t\t\t\tid[mp(x+1, y)] = i;\n\t\t\t\tv[i].second = mp(x+1, y);\n\t\t\t} else {\n\t\t\t\tid[mp(x, y+1)] = i;\n\t\t\t\tv[i].second = mp(x, y+1);\n\t\t\t}\n\t\t}\n\n\t\tmap<P, bool> memo;\n\t\tbool used[200005];\n\t\tmemset(used, 0, sizeof(used));\n\n\t\tbool res = false;\n\n\t\trep(i, n) {\n\t\t\tif(used[i]) continue;\n\n\t\t\tbool flag = false;\n\t\t\trep(j, 4) {\n\t\t\t\tint ny = v[i].first.first + dy[j];\n\t\t\t\tint nx = v[i].first.second + dx[j];\n\n\t\t\t\tflag |= memo[mp(ny, nx)];\n\t\t\t}\n\n\t\t\tif(!flag) {\n\t\t\t\tused[i] = true;\n\t\t\t\tmemo[v[i].second] = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tflag = false;\n\t\t\trep(j, 4) {\n\t\t\t\tint ny = v[i].second.first + dy[j];\n\t\t\t\tint nx = v[i].second.second + dx[j];\n\n\t\t\t\tflag |= memo[mp(ny, nx)];\n\t\t\t}\n\n\t\t\tif(!flag) {\n\t\t\t\tused[i] = true;\n\t\t\t\tmemo[v[i].first] = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tres = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(res) cout << \"No\" << endl;\n\t\telse cout << \"Yes\" << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\nconst int MAX_N=20001;\nint N;\nbool used[2][MAX_N];\nint headAng[2][MAX_N];\nmap<int,map<int,pii> > m;\npii futons[2][MAX_N];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\nbool ok;\n\nvoid dfs(int s,int idx){\n  used[idx][s]=true;\n  pii p=futons[idx][s];\n  int ncol=headAng[idx][s];\n  for(int i=0;i<4;i++){\n    int ny=p.first+dy[i];\n    int nx=p.second+dx[i];\n    if(m.count(ny)>0&&m[ny].count(nx)>0){\n      int ns=m[ny][nx].first;\n      int nidx=m[ny][nx].second;\n      if(ns!=s){\n\tif(headAng[nidx][ns]==-1){\n\t  headAng[nidx][ns]=ncol;\n\t}\n\telse if(headAng[nidx][ns]!=ncol){\n\t  ok=false;\n\t  return;\n\t}\n\tif(!used[nidx][ns])dfs(ns,nidx);\n      }\n      else{\n\tif(headAng[nidx][ns]==-1){\n\t  headAng[nidx][ns]=1^ncol;\n\t}\n\tif(!used[nidx][ns])dfs(ns,nidx);\n      }\n    }\n  }\n}\n\nint main(){\n\n  while(cin>>N&&N){\n    ok=true;\n    memset(used,0,sizeof(used));\n    memset(headAng,-1,sizeof(headAng));\n    m.clear();\n    for(int i=0;i<N;i++){\n      int x,y;\n      char ang;\n      cin>>x>>y>>ang;\n      futons[0][i]=pii(y,x);\n      if(ang=='x')futons[1][i]=pii(y,x+1);\n      else futons[1][i]=pii(y+1,x);\n      m[futons[0][i].first][futons[0][i].second]=pii(i,0);\n      m[futons[1][i].first][futons[1][i].second]=pii(i,1);\n    }\n    for(int i=0;i<N;i++){\n      if(used[0][i])continue;\n      headAng[0][i]=0;\n      dfs(i,0);\n      if(!ok)break;\n    }\n    if(ok)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {1, 0, -1, 0};\nint dx[] = {0, -1, 0, 1};\n\nvector<vector<int> > edges;\nvector<int> memo;\n\nbool solve(int curr)\n{\n    for(unsigned i=0; i<edges[curr].size(); ++i){\n        int next = edges[curr][i];\n        int x = memo[curr];\n        if(i == 0)\n            x ^= 1;\n\n        if(memo[next] == -1){\n            memo[next] = x;\n            if(!solve(next))\n                return false;\n        }else if(memo[next] != x){\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        map<pair<int, int>, int> index;\n        edges.assign(2*n, vector<int>(0));\n        for(int i=0; i<n; ++i){\n            int y1, x1, y2, x2;\n            char dir;\n            cin >> x1 >> y1 >> dir;\n            y2 = y1;\n            x2 = x1;\n            if(dir == 'x')\n                ++ x2;\n            else\n                ++ y2;\n\n            edges[2*i].push_back(2*i+1);\n            edges[2*i+1].push_back(2*i);\n\n            for(int j=0; j<4; ++j){\n                map<pair<int, int>, int>::iterator it1 = index.find(make_pair(y1+dy[j], x1+dx[j]));\n                if(it1 != index.end()){\n                    edges[2*i].push_back(it1->second);\n                    edges[it1->second].push_back(2*i);\n                }\n                map<pair<int, int>, int>::iterator it2 = index.find(make_pair(y2+dy[j], x2+dx[j]));\n                if(it2 != index.end()){\n                    edges[2*i+1].push_back(it2->second);\n                    edges[it2->second].push_back(2*i+1);\n                }\n            }\n\n            index[make_pair(y1, x1)] = 2 * i;\n            index[make_pair(y2, x2)] = 2*i+1;\n        }\n\n        memo.assign(2*n, -1);\n        bool ok = true;\n        for(int i=0; i<2*n; ++i){\n            if(memo[i] != -1)\n                continue;\n\n            memo[i] = 0;\n            if(!solve(i)){\n                ok = false;\n                break;\n            }\n        }\n\n        if(ok)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nchar c;\nint x[20001][2],y[20001][2];\nvector<int>v[40001];\nint b[40001],f,n;\nvoid dfs(int p,int col){\n  b[p]=col;\n  r(i,v[p].size()){\n    if(b[v[p][i]]&&b[v[p][i]]!=col)f++;\n    else if(!b[v[p][i]]){\n      if(p==v[p][i]+n||p+n==v[p][i]){\n        if(col==1)dfs(v[p][i],2);\n        else dfs(v[p][i],1);\n      }\n      else dfs(v[p][i],col);\n    }\n  }\n}\nint main(){\n  while(cin>>n,n){\n    memset(b,0,sizeof(b));\n    r(i,40001)v[i].clear();\n    r(i,n){\n      cin>>x[i][0]>>y[i][0]>>c;\n      if(c=='x')x[i][1]=x[i][0]+1,y[i][1]=y[i][0];\n      else x[i][1]=x[i][0],y[i][1]=y[i][0]+1;\n    }\n    r(i,n)v[i].push_back(i+n);\n    r(i,n)r(j,n){\n      if(x[i][0]==x[j][0]&&abs(y[i][0]-y[j][0])==1)v[i].push_back(j);\n      if(x[i][0]==x[j][0]&&abs(y[i][1]-y[j][1])==1)v[i].push_back(j+n);\n      if(x[i][1]==x[j][1]&&abs(y[i][0]-y[j][0])==1)v[i+n].push_back(j);\n      if(x[i][1]==x[j][1]&&abs(y[i][1]-y[j][1])==1)v[i+n].push_back(j+n);\n    }\n    f=0;\n    r(i,n*2)if(!b[i])dfs(i,1);\n    cout<<(!f?\"No\":\"Yes\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n;\nmap<pair<int, int>, int> futon;\nmap<pair<int, int>, int> color;\nint futonX[30000];\nint futonY[30000];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nbool dfs(int x, int y, int c) {\n  if (color[make_pair(x, y)] != -1) {\n   if (color[make_pair(x, y)] == c) { return true; }\n   else { return false; }\n  }\n  color[make_pair(x, y)] = c;\n  REP(i, 4) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if (!futon.count(make_pair(nx, ny))) { continue; }\n    int nc = c;\n    if (futon[make_pair(nx, ny)] == futon[make_pair(x, y)]) { nc ^= 1; }\n    if (!dfs(nx, ny, nc)) { return false; }\n  }\n  return true;\n}\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    futon.clear();\n    color.clear();\n    REP(i, n) {\n      int x, y;\n      char c;\n      scanf(\"%d %d %c\", &x, &y, &c);\n      futonX[i] = x;\n      futonY[i] = y;\n      int dir = c == 'x' ? 0 : 1;\n      REP(j, 2) {\n        int nx = x + dx[dir] * j;\n        int ny = y + dy[dir] * j;\n        futon[make_pair(nx, ny)] = i;\n        color[make_pair(nx, ny)] = -1;\n      }\n    }\n    REP(i, n) {\n      int x = futonX[i];\n      int y = futonY[i];\n      if (color[make_pair(x, y)] != -1) { continue; }\n      if (!dfs(x, y, 0)) {\n        puts(\"No\");\n        goto next;\n      }\n    }\n    puts(\"Yes\");\nnext:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,int> Pi;\ntypedef long long ll;\n\nint n;\n\n\nbool bfs(int t,map<P,P> futon,pair<P,P> f) {\n    queue<Pi> que;\n    que.push(Pi(f.fr,t));\n    f.sc.sc=t;\n    futon[f.fr]=f.sc;\n    map<Pi,bool> visited;\n    visited[(Pi(f.fr,t))]=true;;\n\n    while(que.size()) {\n        Pi pi = que.front(); que.pop();\n        P p=pi.fr;\n        //printf(\"[debug] %d : %d %d %d\\n\",t,p.fr,p.sc,pi.sc);\n        rep(k,4) {\n            int ny=p.fr+dy[k];\n            int nx=p.sc+dx[k];\n            int t=pi.sc;\n\n            if(!futon.count(P(ny,nx))) continue;\n            //if(futon[P(ny,nx)].sc!=-1) continue;\n\n            // ???????????£???\n            if(futon[P(ny,nx)].fr==futon[p].fr) {\n                if(futon[P(ny,nx)].sc!=-1&&futon[P(ny,nx)].sc!=(t^1)) return false;\n                if(visited.count(Pi(P(ny,nx),t^1))) continue;\n                visited[(Pi(P(ny,nx),t^1))]=true;\n                futon[P(ny,nx)].sc=t^1;\n                que.push(Pi(P(ny,nx),t^1));\n            }\n            else {\n                if(futon[P(ny,nx)].sc!=-1&&futon[P(ny,nx)].sc!=t) return false;\n                if(visited.count(Pi(P(ny,nx),t))) continue;\n                visited[(Pi(P(ny,nx),t))]=true;\n                futon[P(ny,nx)].sc=t;\n                que.push(Pi(P(ny,nx),t));\n            }\n\n        }\n    }\n\n    return true;\n}\n\nvoid solve() {\n    map<P,P> futon;\n    rep(i,n) {\n        P pos;\n        char d;\n        cin>>pos.sc>>pos.fr>>d;\n        futon[pos]=P(i,-1);\n        if(d=='x') {\n            pos.sc+=1;\n        }\n        else {\n            pos.fr+=1;\n        }\n        futon[pos]=P(i,-1);\n    }\n    bool f=true;\n    f=bfs(0,futon,*futon.begin())||bfs(1,futon,*futon.begin());\n    if(f) {\n        cout<<\"Yes\"<<endl;\n    }\n    else cout<<\"No\"<<endl;\n}\n\nint main() {\n    while(cin>>n) {\n        if(n==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint n, dp[40000], st[40000], k;\nmap<pi, int> id;\nvi x, y, d;\n\nbool rec(int cx, int cy, int cd){\n\tqueue<pair<pi, int> > q;\n\tq.push(mp(mp(cx, cy), cd));\n\tdp[st[k++] = id[mp(cx, cy)]] = cd;\n\t\n\twhile(!q.empty()){\n\t\tcx = q.front().first.first; cy = q.front().first.second;\n\t\tcd = q.front().second;\n\t\tq.pop();\n\t\t\n\t\trep(d, 4){\n\t\t\tint nx = cx + dx[d], ny = cy + dy[d];\n\t\t\tif(!id.count(mp(nx, ny))) continue;\n\t\t\tint ii = id[mp(nx, ny)];\n\t\t\tint nd = ii == (id[mp(cx, cy)] ^ 1) ? 1 - cd : cd;\n\t\t\t\n\t\t\tif(dp[ii] >= 0 && dp[ii] != nd) return 0;\n\t\t\tif(dp[ii] >= 0) continue;\n\t\t\tdp[st[k++] = ii] = nd;\n\t\t\tq.push(mp(mp(nx, ny), nd));\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main(){\n\twhile(scanf(\"%d\", &n), n){\n\t\tx.clear(); y.clear(); d.clear();\n\t\tid.clear();\n\t\t\n\t\trep(i, n){\n\t\t\tint a, b; char c;\n\t\t\tscanf(\"%d%d %c\", &a, &b, &c);\n\t\t\tx.pb(a); y.pb(b); d.pb(c == 'x');\n\t\t\tid[mp(a, b)] = i * 2;\n\t\t\tid[mp(a + d[i], b + 1 - d[i])] = i * 2 + 1;\n\t\t}\n\t\tmemset(dp, -1, sizeof(dp));\n\t\trep(i, 2 * n) if(dp[i] < 0){\n\t\t\tk = 0;\n\t\t\tif(rec(x[i / 2], y[i / 2], 0)) continue;\n\t\t\twhile(k) dp[st[--k]] = -1;\n\t\t\tif(!rec(x[i / 2], y[i / 2], 1)){\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t\tcout << \"Yes\" << endl;\n\t\tEND:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,int> Pi;\ntypedef long long ll;\n\nint n;\n\n\nbool bfs(int t,map<P,P> &futon,pair<P,P> f) {\n    queue<Pi> que;\n    que.push(Pi(f.fr,t));\n    f.sc.sc=t;\n    futon[f.fr]=f.sc;\n    map<Pi,bool> visited;\n    visited[(Pi(f.fr,t))]=true;;\n\n    while(que.size()) {\n        Pi pi = que.front(); que.pop();\n        P p=pi.fr;\n        //printf(\"[debug] %d : %d %d %d\\n\",t,p.fr,p.sc,pi.sc);\n        rep(k,4) {\n            int ny=p.fr+dy[k];\n            int nx=p.sc+dx[k];\n            int t=pi.sc;\n\n            if(!futon.count(P(ny,nx))) continue;\n            //if(futon[P(ny,nx)].sc!=-1) continue;\n\n            // ???????????£???\n            if(futon[P(ny,nx)].fr==futon[p].fr) {\n                if(futon[P(ny,nx)].sc!=-1&&futon[P(ny,nx)].sc!=(t^1)) return false;\n                if(visited.count(Pi(P(ny,nx),t^1))) continue;\n                visited[(Pi(P(ny,nx),t^1))]=true;\n                futon[P(ny,nx)].sc=t^1;\n                que.push(Pi(P(ny,nx),t^1));\n            }\n            else {\n                if(futon[P(ny,nx)].sc!=-1&&futon[P(ny,nx)].sc!=t) return false;\n                if(visited.count(Pi(P(ny,nx),t))) continue;\n                visited[(Pi(P(ny,nx),t))]=true;\n                futon[P(ny,nx)].sc=t;\n                que.push(Pi(P(ny,nx),t));\n            }\n\n        }\n    }\n\n    return true;\n}\n\nvoid solve() {\n    map<P,P> futon;\n    rep(i,n) {\n        P pos;\n        char d;\n        cin>>pos.sc>>pos.fr>>d;\n        futon[pos]=P(i,-1);\n        if(d=='x') {\n            pos.sc+=1;\n        }\n        else {\n            pos.fr+=1;\n        }\n        futon[pos]=P(i,-1);\n    }\n    bool f=true;\n    for(auto e : futon) {\n        if(e.sc.sc==-1) {\n            if(!bfs(0,futon,e)) f=false;\n        }\n    }\n    if(f) {\n        cout<<\"Yes\"<<endl;\n    }\n    else cout<<\"No\"<<endl;\n}\n\nint main() {\n    while(cin>>n) {\n        if(n==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\ntypedef pair<int, int> P;\nconst int MAX_N = 20001;\n\n// 入力\nint n, x[MAX_N], y[MAX_N];\nchar dir[MAX_N];\n\n// futon[i] := ふとん i に割り振られている数字(0 or 1)\nint futon[MAX_N];\n// used[i] := ふとん i が探索済みかどうか.\nbool used[MAX_N];\n// m[P(x,y)] := (x,y) にあるふとんの番号.\nmap<P, int> m;\n// 4近傍\nint dx[4] = {0,0,-1,1};\nint dy[4] = {-1,1,0,0};\n// 解\nbool ans;\n\n// pos := 布団の番号, k := 割り振る数字(0 or 1)\nvoid dfs(int pos, int k){\n\tif( ans == false ) return;\n\t\n\t// (x1,y1)と(x2,y2)はふとんの位置\n\tint x1 = x[pos], y1 = y[pos], x2, y2;\n\t// メモ\n\tused[pos] = true;\n\tfuton[pos] = k;\n\tint next = (k + 1) % 2;\n\tif( dir[pos] == 'x' ){\n\t\tx2 = x1 + 1, y2 = y1;\n\t}else{\n\t\tx2 = x1, y2 = y1 + 1;\n\t}\n\t\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = x1 + dx[i], my = y1 + dy[i];\n\t\tif( mx == x2 && my == y2 ) continue;\n\t\t\n\t\tif( m.count(P(mx,my)) ){\n\t\t\tint id = m[P(mx,my)];\n\t\t\tif( used[id] ){\n\t\t\t\tif( futon[id] == futon[pos] ){\n\t\t\t\t\tans = false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdfs(id, next);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = x2 + dx[i], my = y2 + dy[i];\n\t\tif( mx == x1 && my == y1 ) continue;\n\t\t\n\t\tif( m.count(P(mx,my)) ){\n\t\t\tint id = m[P(mx,my)];\n\t\t\tif( used[id] ){\n\t\t\t\tif( futon[id] == futon[pos] ){\n\t\t\t\t\tans = false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdfs(id, next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> n, n ){\n\t\t// 初期化.\n\t\tfill(used, used + MAX_N, false);\n\t\tfill(futon, futon+MAX_N, -1);\n\t\tm.clear();\n\t\tans = true;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++ ){\n\t\t\tcin >> x[i] >> y[i] >> dir[i];\n\t\t\tif( dir[i] == 'x' ){\n\t\t\t\tm[ P(x[i], y[i]) ] = i;\n\t\t\t\tm[ P(x[i]+1, y[i]) ] = i;\n\t\t\t}else{\n\t\t\t\tm[ P(x[i], y[i]) ] = i;\n\t\t\t\tm[ P(x[i], y[i]+1) ] = i;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n ; i++ ){\n\t\t\tif( used[i] ) continue;\n\t\t\tdfs(i, 0);\n\t\t}\n\t\tcout << (ans? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef pair< int, int > pii;\ntypedef pair< pii, pii > ppii;\n\nconst int dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\nint n, x[20020], y[20020], visit[20020][2];\nchar dir[20020];\npii pos[40040], ids[40040];\n\nint xadd(int i) { return dir[i] == 'x' ? 1 : 0; }\nint yadd(int i) { return dir[i] == 'y' ? 1 : 0; }\n\nbool rec(int i, int j, int v, vector< pii >& upd) {\n\tbool res = 1;\n\t\n\tif (visit[i][j] < 0) {\n\t\tvisit[i][j] = v;\n\t\tvisit[i][j^1] = v^1;\n\t\tupd.push_back(pii(i,j));\n\t\tupd.push_back(pii(i,j^1));\n\t\t\n\t\tint nx1 = x[i] + (j ? xadd(i) : 0), ny1 = y[i] + (j ? yadd(i) : 0);\n\t\tint nx2 = x[i] + (j ? 0 : xadd(i)), ny2 = y[i] + (j ? 0 : yadd(i));\n\t\tfor_(d,0,4) {\n\t\t\tpii nxp1(nx1 + dx[d], ny1 + dy[d]);\n\t\t\tif (binary_search(pos, pos + 2*n, nxp1)) {\n\t\t\t\tint k = lower_bound(pos, pos + 2*n, nxp1) - pos;\n\t\t\t\tif (ids[k].second != i) res &= rec(ids[k].second, ids[k].first, v, upd);\n\t\t\t}\n\t\t\t\n\t\t\tpii nxp2(nx2 + dx[d], ny2 + dy[d]);\n\t\t\tif (binary_search(pos, pos + 2*n, nxp2)) {\n\t\t\t\tint k = lower_bound(pos, pos + 2*n, nxp2) - pos;\n\t\t\t\tif (ids[k].second != i) res &= rec(ids[k].second, ids[k].first, v^1, upd);\n\t\t\t}\t\t\t\n\t\t}\n\t} else {\n\t\tres = (visit[i][j] == v);\n\t}\n\t\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tvector< ppii > vp;\n\t\t\n\t\tfor_(i,0,n) {\n\t\t\tcin >> x[i] >> y[i] >> dir[i];\n\t\t\tvp.push_back(ppii(pii(x[i], y[i]), pii(0, i)));\n\t\t\tvp.push_back(ppii(pii(x[i] + xadd(i), y[i] + yadd(i)), pii(1, i)));\n\t\t}\n\t\t\n\t\tsort(vp.begin(), vp.end());\n\t\t\n\t\tfor_(i,0,2*n) {\n\t\t\tpos[i] = vp[i].first;\n\t\t\tids[i] = vp[i].second;\n\t\t}\n\t\t\n\t\tmemset(visit, -1, sizeof(visit));\n\t\t\n\t\tbool ok = 1;\n\t\tfor_(i,0,n && ok) {\n\t\t\tif (visit[i][0] < 0) {\n\t\t\t\tvector< pii > upd;\n\t\t\t\tif (!rec(i, 0, 0, upd)) {\n\t\t\t\t\tint u_size = (int)upd.size();\n\t\t\t\t\tfor_(j,0,u_size) visit[upd[j].first][upd[j].second] = -1;\n\t\t\t\t\tok = rec(i, 0, 1, upd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct data{\n  int num,used,color;\n  data(){};\n  data(int a,int b,int c){\n    num=a,used=b,color=c;\n  }\n};\nmap<P,data> Futon;\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nchar dir;\nbool ans;\n\nvoid dfs(int y,int x){\n  Futon[P(y,x)].used=1;\n  for(int i=0;i<4;i++){\n    int ny=y+dy[i],nx=x+dx[i];\n    if(!Futon.count(P(ny,nx)))continue;\n    if(Futon[P(ny,nx)].color==-1){\n      if(Futon[P(ny,nx)].num==Futon[P(y,x)].num)\n\tFuton[P(ny,nx)].color=!Futon[P(y,x)].color;\n      else\n\tFuton[P(ny,nx)].color=Futon[P(y,x)].color;\n    }else{\n      if(Futon[P(ny,nx)].num==Futon[P(y,x)].num){\n\tif(Futon[P(ny,nx)].color==Futon[P(y,x)].color)\n\t  ans=false;\n      }\n      else if(Futon[P(ny,nx)].color!=Futon[P(y,x)].color)\n\tans=false;\n    }\n    if(!Futon[P(ny,nx)].used)dfs(ny,nx);\n  }\n}\n\nint main(){\n  int n,x,y;\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>x>>y>>dir;\n      Futon[P(y,x)]=data(i,0,-1);\n      if(dir=='x')Futon[P(y,x+1)]=data(i,0,-1);\n      else Futon[P(y+1,x)]=data(i,0,-1);\n    }\n    ans=true;\n    map<P,data>::iterator ite=Futon.begin();\n    while(ite!=Futon.end()){\n      if(!(*ite).second.used){\n\t(*ite).second.color=0;\n\tdfs((*ite).first.first,(*ite).first.second);\n      }\n      ite++;\n    }\n    if(ans)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    Futon.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define s second\n#define f first\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct data{\n  int num,used,color;\n  data(){};\n  data(int a,int b,int c){\n    num=a,used=b,color=c;\n  }\n};\nmap<P,data> Futon;\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nchar dir;\nbool ans;\n\nvoid dfs(int y,int x){\n  map<P,data>::iterator F=Futon.find(P(y,x));\n  (*F).s.used=1;\n  for(int i=0;i<4;i++){\n    int ny=y+dy[i],nx=x+dx[i];\n    if(!Futon.count(P(ny,nx)))continue;\n    map<P,data>::iterator F1=Futon.find(P(ny,nx));\n    if((*F1).s.color==-1){\n      if((*F1).s.num==(*F).s.num)\n\t(*F1).s.color=!(*F).s.color;\n      else\n\t(*F1).s.color=(*F).s.color;\n    }else{\n      if((*F1).s.num==(*F).s.num){\n\tif((*F1).s.color==(*F).s.color)\n\t  ans=false;\n      }\n      else if((*F1).s.color!=(*F).s.color)\n\tans=false;\n    }\n    if(!(*F1).s.used)dfs(ny,nx);\n  }\n}\n\nint main(){\n  int n,x,y;\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>x>>y>>dir;\n      Futon[P(y,x)]=data(i,0,-1);\n      if(dir=='x')Futon[P(y,x+1)]=data(i,0,-1);\n      else Futon[P(y+1,x)]=data(i,0,-1);\n    }\n    ans=true;\n    map<P,data>::iterator ite=Futon.begin();\n    while(ite!=Futon.end()){\n      if(!(*ite).s.used){\n\t(*ite).s.color=0;\n\tdfs((*ite).f.f,(*ite).f.s);\n      }\n      ite++;\n    }\n    if(ans)cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    Futon.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nint getValue(map<int,map<int,int>>& m, int a, int b){\n\tif(m.count(a)){\n\t\tif(m[a].count(b)){\n\t\t\treturn m[a][b];\n\t\t}\n\t}\n\treturn -1;\n}\n\nconst int gmax_n = 80000;\n\nint par[gmax_n]; //親\nint depth[gmax_n];//木の深さ\n\nvoid init(int n){\n\trep(i,n){\n\t\tpar[i] = i;\n\t\tdepth[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}else {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(depth[x] < depth[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(depth[x] == depth[y]) depth[x]++;\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nvoid connect(vector<int> t, char c, int p, int n, int p2){\n\trep(i,3){\n\t\tif(t[i] == -1) continue;\n\t\tunite(t[i], p);\n\t\tunite(t[i] + n, p + n);\n\t}\n\trange(i,3,6){\n\t\tif(t[i] == -1) continue;\n\t\tunite(t[i], p2);\n\t\tunite(t[i] + n, p2 + n);\n\t}\n\tunite(p, p2 + n);\n\tunite(p + n, p2);\n}\n\nbool f(int n){\n\trep(i,n){\n\t\tif(same(i, i + n)) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tinit(n * 4);\n\t\tvector<int> a(n), b(n);\n\t\tvector<char> c(n);\n\t\trep(i,n){\n\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t}\n\n\t\tmap<int,map<int,int>> ma;\n\t\trep(i,n){\n\t\t\tma[a[i]][b[i]] = i;\n\t\t\tif(c[i] == 'x') ma[a[i] + 1][b[i]] = i + n;\n\t\t\telse ma[a[i]][b[i] + 1] = i + n;\n\t\t}\n\n\t\trep(i,n){\n\t\t\tvector<int> t;\n\t\t\tif(c[i] == 'x'){\n\t\t\t\tt.emplace_back(getValue(ma, a[i] - 1, b[i]));\n\t\t\t\tt.emplace_back(getValue(ma, a[i]    , b[i] + 1));\n\t\t\t\tt.emplace_back(getValue(ma, a[i]    , b[i] - 1));\n\t\t\t\tt.emplace_back(getValue(ma, a[i] + 1, b[i] + 1));\n\t\t\t\tt.emplace_back(getValue(ma, a[i] + 1, b[i] - 1));\n\t\t\t\tt.emplace_back(getValue(ma, a[i] + 2, b[i]));\n\t\t\t}else{\n\t\t\t\tt.emplace_back(getValue(ma, a[i] - 1, b[i]));\n\t\t\t\tt.emplace_back(getValue(ma, a[i] - 1, b[i] + 1));\n\t\t\t\tt.emplace_back(getValue(ma, a[i]    , b[i] - 1));\n\t\t\t\tt.emplace_back(getValue(ma, a[i]    , b[i] + 2));\n\t\t\t\tt.emplace_back(getValue(ma, a[i] + 1, b[i]));\n\t\t\t\tt.emplace_back(getValue(ma, a[i] + 1, b[i] + 1));\n\t\t\t}\n\t\t\tconnect(t, c[i], i, n, i + n);\n\t\t}\n\t\tcout << (f(n) ? \"Yes\" : \"No\") << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 20000\n#define HEAD MOD\n#define FOOT MOD+1\n\ntypedef pair<int,int> Point;\n\nenum Type{\n\tTATE,\n\tYOKO,\n};\n\nstruct Info{\n\tint row,col;\n\tType dir;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_index,int arg_which){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tindex = arg_index;\n\t\twhich = arg_which;\n\t}\n\n\tint row,col,index,which;\n};\n\n\nmap<Point,int> MAP; //<座標、布団インデックス>\nInfo info[NUM];\nvector<int> Group[NUM]; //隣接している布団のグループ\n\nint near_row[4] = {1,0,0,-1},near_col[4] = {0,-1,1,0};\nint diff_row[2][6] = {{2,1,1,0,0,-1},{-1,-1,0,0,1,1}},diff_col[2][6] = {{0,-1,1,-1,1,0},{0,1,-1,2,0,1}};\n\nint N;\nint boss[NUM],height[NUM];\n\n//自分のボスのindexを取得しつつ、経路圧縮を行う関数\nint get_boss(int id){\n\tif(boss[id] == id)return id; //自分が代表なら、自分の値を返す\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]); //代表でないなら、自分が所属する組織の代表を返しつつ、経路圧縮\n\t}\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\t//既に同じグループなら何もしない\n\tif(boss_x == boss_y)return;\n\n\t//高さが高い方に吸収する\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nbool check(int group_id){\n\n\tmap<Point,int> ROOM;\n\tqueue<Data> Q;\n\n\t//ボスの、左下側を頭にする(ボスのid == group_id)\n\tROOM[Point(info[group_id].row,info[group_id].col)] = HEAD;\n\t//printf(\"(%d,%d)に%dの頭を配置\\n\",info[group_id].row,info[group_id].col,group_id);\n\tQ.push(Data(info[group_id].row,info[group_id].col,group_id,HEAD));\n\n\tbool FLG = true;\n\n\tint adj_row,adj_col,adj_index;\n\n\twhile(!Q.empty()){\n\n\t\t//printf(\"index:%d row:%d col:%d type:%d\\n\",Q.front().index,Q.front().row,Q.front().col,Q.front().which);\n\n\t\t//隣接4近傍を検索\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tadj_row = Q.front().row+near_row[i];\n\t\t\tadj_col = Q.front().col+near_col[i];\n\n\t\t\tauto at = MAP.find(Point(adj_row,adj_col));\n\t\t\tif(at == MAP.end())continue; //隣接する布団がなければSKIP\n\n\t\t\tadj_index = MAP[Point(adj_row,adj_col)];\n\t\t\t//printf(\"adj_row:%d,adj_col:%d adj_index:%d\\n\",adj_row,adj_col,adj_index);\n\n\t\t\tif(adj_index != Q.front().index){ //自分以外の布団が隣接\n\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){ //まだ割り当てがされていない\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD; //頭と足は隣接してはいけない\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,HEAD));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの頭を配置\\n\",adj_row,adj_col,adj_index);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,FOOT));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの足を配置\\n\",adj_row,adj_col,adj_index);\n\t\t\t\t\t}\n\t\t\t\t}else{ //割り当て済\n\t\t\t\t\tif((ROOM[Point(adj_row,adj_col)] == FOOT && Q.front().which == HEAD) ||\n\t\t\t\t\t\t\t(ROOM[Point(adj_row,adj_col)] == HEAD && Q.front().which == FOOT)){ //矛盾発生\n\t\t\t\t\t\t//printf(\"異種隣接\\n\");\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{ //自分の布団が隣接\n\t\t\t\t//自分のもう一方に、不適な割り当てがされていないか調べる\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){ //まだ割り当てがされていない\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,FOOT));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの頭を配置\\n\",adj_row,adj_col,Q.front().index);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,HEAD));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの足を配置\\n\",adj_row,adj_col,Q.front().index);\n\t\t\t\t\t}\n\t\t\t\t}else{ //割り当て済\n\t\t\t\t\tif(ROOM[Point(adj_row,adj_col)] == Q.front().which){ //矛盾発生\n\t\t\t\t\t\t//printf(\"同じパーツが重複\\n\");\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG)break;\n\n\t\tQ.pop();\n\t}\n\n\tif(FLG)return true;\n\n\n\tFLG = true;\n\tROOM.clear();\n\n\t//ボスの、左下側を足にする\n\tROOM[Point(info[group_id].row,info[group_id].col)] = FOOT;\n\tQ.push(Data(info[group_id].row,info[group_id].col,group_id,FOOT));\n\t//printf(\"(%d,%d)に%dの足を配置\\n\",info[group_id].row,info[group_id].col,group_id);\n\n\twhile(!Q.empty()){\n\n\t\t//printf(\"index:%d row:%d col:%d type:%d\\n\",Q.front().index,Q.front().row,Q.front().col,Q.front().which);\n\n\t\t//隣接4近傍を検索\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tadj_row = Q.front().row+near_row[i];\n\t\t\tadj_col = Q.front().col+near_col[i];\n\n\t\t\tauto at = MAP.find(Point(adj_row,adj_col));\n\t\t\tif(at == MAP.end())continue; //隣接する布団がなければSKIP\n\n\t\t\tadj_index = MAP[Point(adj_row,adj_col)];\n\t\t\t//printf(\"adj_row:%d,adj_col:%d adj_index:%d\\n\",adj_row,adj_col,adj_index);\n\n\t\t\tif(adj_index != Q.front().index){ //自分以外の布団が隣接\n\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){ //まだ割り当てがされていない\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD; //頭と足は隣接してはいけない\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,HEAD));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの頭を配置\\n\",adj_row,adj_col,adj_index);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,FOOT));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの足を配置\\n\",adj_row,adj_col,adj_index);\n\t\t\t\t\t}\n\t\t\t\t}else{ //割り当て済\n\t\t\t\t\tif((ROOM[Point(adj_row,adj_col)] == FOOT && Q.front().which == HEAD) ||\n\t\t\t\t\t\t\t(ROOM[Point(adj_row,adj_col)] == HEAD && Q.front().which == FOOT)){ //矛盾発生\n\t\t\t\t\t\t//printf(\"異種隣接\\n\");\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{ //自分の布団が隣接\n\t\t\t\t//自分のもう一方に、不適な割り当てがされていないか調べる\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){ //まだ割り当てがされていない\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,FOOT));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの頭を配置\\n\",adj_row,adj_col,Q.front().index);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,HEAD));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの足を配置\\n\",adj_row,adj_col,Q.front().index);\n\t\t\t\t\t}\n\t\t\t\t}else{ //割り当て済\n\t\t\t\t\tif(ROOM[Point(adj_row,adj_col)] == Q.front().which){ //矛盾発生\n\t\t\t\t\t\t//printf(\"同じパーツが重複\\n\");\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG)break;\n\n\t\tQ.pop();\n\t}\n\n\n\treturn FLG;\n}\n\nvoid func(){\n\n\tMAP.clear();\n\tfor(int i = 0; i < N; i++)Group[i].clear();\n\n\tinit();\n\n\tchar buf[2];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %s\",&info[i].col,&info[i].row,buf);\n\t\tif(buf[0] == 'x'){\n\t\t\tinfo[i].dir = YOKO;\n\t\t}else{\n\t\t\tinfo[i].dir = TATE;\n\t\t}\n\t\tMAP[Point(info[i].row,info[i].col)] = i; //マップに登録(2マス分)\n\t\tif(info[i].dir == YOKO){\n\t\t\tMAP[Point(info[i].row,info[i].col+1)] = i;\n\t\t}else{\n\t\t\tMAP[Point(info[i].row+1,info[i].col+1)] = i;\n\t\t}\n\t}\n\n\t//隣接している布団のグループを作る\n\tint adj_row,adj_col;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < 6; k++){\n\t\t\tadj_row = info[i].row+diff_row[info[i].dir][k];\n\t\t\tadj_col = info[i].col+diff_col[info[i].dir][k];\n\n\t\t\tauto at = MAP.find(Point(adj_row,adj_col));\n\t\t\tif(at == MAP.end())continue;\n\n\t\t\tunite(i,MAP[Point(adj_row,adj_col)]); //隣接している布団を同じグループにする\n\t\t}\n\t}\n\n\tvector<int> BOSS;\n\tfor(int i = 0; i < N; i++){ //布団をグループに振り分ける\n\t\tGroup[get_boss(i)].push_back(i);\n\t\tif(boss[i] == i){\n\t\t\tBOSS.push_back(i); //ボスを収集する\n\t\t}\n\t}\n\n\tfor(int i = 0; i < BOSS.size(); i++){\n\t\tif(check(BOSS[i]) == false){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tprintf(\"Yes\\n\");\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef pair<lli, lli> P;\n\nconst lli N = 20000;\n\nclass T{\npublic:\n  lli x, y;\n  char c;\n  T(){}\n  T(lli x, lli y, char c) : x(x), y(y), c(c){}\n};\n\nvector<T> data;\nmap<P, lli> mp;\nmap<P, lli> dist; // 0 = atama, 1= ashi;\nbool ans;\nlli dx[2][6] = {\n  {0, 1, 2, 1, 0, -1},\n  {0, 1, 1, 0, -1, -1}\n};\nlli dy[2][6] = {\n  {-1, -1, 0, 1, 1, 0},\n  {-2, -1, 0, 1, 0, -1}\n};\nlli dx2[4] = {0, 1, 0, -1};\nlli dy2[4] = {-1, 0, 1, 0};\n\nvoid dfs(lli pos){\n  lli next[2] = {-1, -1};\n  P p[2];\n  lli d = (data[pos].c == 'x' ? 0 : 1);\n  p[0] = make_pair(data[pos].x, data[pos].y);\n  p[1] = (d ? make_pair(data[pos].x, data[pos].y+1) : make_pair(data[pos].x+1, data[pos].y));\n  for(lli k=0;k<2;k++){\n    for(lli i=0;i<4;i++){\n      lli nx = p[k].first + dx2[i];\n      lli ny = p[k].second + dy2[i];\n      P np = make_pair(nx, ny);\n      if(dist.find(np) != dist.end()){\n\tlli nc = dist[np];\n\tif(next[k] == -1) next[k] = nc;\n\telse if(next[k] != nc){\n\t  ans = false;\n\t  return;\n\t}\n      }\n    }\n  }\n  if(next[0] == -1 && next[1] == -1){\n    dist[p[0]] = 0;\n    dist[p[1]] = 1;\n  }else if(next[0] == -1){\n    dist[p[0]] = 1 - next[1];\n    dist[p[1]] = next[1];\n  }else if(next[1] == -1){\n    dist[p[0]] = next[0];\n    dist[p[1]] = 1 - next[0];\n  }else{\n    dist[p[0]] = next[0];\n    dist[p[1]] = next[1];\n  }\n  for(lli i=0;i<6;i++){\n    lli nx = p[0].first + dx[d][i];\n    lli ny = p[0].second + dy[d][i];\n    P np = make_pair(nx, ny);\n    if(mp.find(np) != mp.end() && dist.find(np) == dist.end()){\n      dfs(mp[np]);\n    }\n  }      \n}\n\nvoid init(){\n  mp.clear();\n  dist.clear();\n  ans = true;\n  data.clear();\n}\n\nint main(){\n  lli n;\n  while(cin >> n && n){\n    init();\n    for(lli i=0;i<n;i++){\n      T in;\n      cin >> in.x >> in.y >> in.c;\n      data.push_back(in);\n      if(in.c == 'x'){\n\tmp[make_pair(in.x, in.y)] = i;\n\tmp[make_pair(in.x+1, in.y)] = i;\n      }else{\n\tmp[make_pair(in.x, in.y)] = i;\n\tmp[make_pair(in.x, in.y+1)] = i;\n      }\n    }\n    for(lli i=0;i<n;i++){\n      P p = make_pair(data[i].x, data[i].y);\n      if(dist.find(p) == dist.end()){\n\tdfs(i);\n      }\n    }\n    cout << (ans ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n13:11 - \n */\n\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<set>\n#include<map>\n#include<climits>\n#include<cassert>\n#include<deque>\n\n#define MAX 20010\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n\nusing namespace std;\n\nstruct Point{\n  int x,y;\n  char c;\n  Point(int x=IINF,int y=IINF,char c='$'):x(x),y(y),c(c){}\n  bool operator < (const Point& a)const{\n    return ( (x!=a.x) ? (x < a.x) : (y < a.y) );\n  }\n};\n\nint n;\nvector<int> G[MAX];\nchar color[MAX];\n\ninline void makeGraph(const vector<Point>& vec,map<Point,int>& Index){\n  rep(i,n)G[i].clear();\n  rep(i,vec.size()){\n    Point p1 = vec[i];\n    Point p2 = p1;\n    assert(Index.find(vec[i]) != Index.end());\n    int cur = Index[vec[i]];\n    if(p1.c == 'x')p2.x++;\n    else if(p1.c == 'y')p2.y++;\n    else assert(false);\n    //cout << \"Futon( (\" << p1.x << \",\" << p1.y << \") , (\" << p2.x << \",\" << p2.y << \") )\" << endl;\n\n    for(int y=p1.y-1;y<=p2.y+1;y++){\n      for(int x=p1.x-1;x<=p2.x+1;x++){\n\tif(x == p1.x-1 && y == p1.y-1)continue;\n\tif(x == p2.x+1 && y == p1.y-1)continue;\n\tif(x == p1.x-1 && y == p2.y+1)continue;\n\tif(x == p2.x+1 && y == p2.y+1)continue;\n\t//cout << \"check => (\" << x << \",\" << y << \")\" << endl;\n\tif(Index.find(Point(x,y)) != Index.end()){\n\n\t  int next = Index[Point(x,y)];\n\t  if(cur == next)continue;\n\n\t  G[cur].push_back(next);\n\t}\n      }\n    }\n  }\n\n  rep(i,n){\n    sort(G[i].begin(),G[i].end());\n    G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n  }\n}\n\nbool dfs(int cur,char c){\n  color[cur] = c;\n  char rec = ((c == 'w')?'b':'w');\n  for(int i=0;i<G[cur].size();i++){\n    if(color[G[cur][i]] == c)return false;\n    if(color[G[cur][i]] == 'x' && !dfs(G[cur][i],rec))return false;\n  }\n  return true;\n}\n\nint main(){\n\n  while(cin >> n,n){\n    // out = false;\n    map<Point,int> Index;\n    vector<Point> input;\n    int dex = 0;\n    for(int i=0;i<n;i++){\n      int x,y;\n      char c;\n      cin >> x >> y >> c;\n      Point p;\n      if(c == 'x'){\n\tp = Point(x+1,y);\n      } else {\n\tp = Point(x,y+1);\n      }\n      input.push_back(Point(x,y,c));\n      Index[Point(x,y)] = Index[p]= dex++;\n      color[i] = 'x';\n    }\n    assert(dex == n);\n    makeGraph(input,Index);\n\n    for(int i=0;i<n;i++){\n      if(color[i] == 'x'){\n\tif(!dfs(i,'w')){\n\t  cout << \"No\" << endl;\n\t  goto Fin;\n\t}\n      }\n    }\n    cout << \"Yes\" << endl;\n  Fin:;\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n//#include <tuple>\n//#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) begin(v), end(v)\n#define REV(v) rbegin(v), rend(v)\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nstruct UnionFind{\n\tvector<int> par, sz;\n\tUnionFind(int n){\n\t\tpar = sz = vector<int>(n);\n\t\tfor (int i = 0; i < n; ++i) par[i] = i, sz[i] = 1;\n\t}\n\tint find(int x){\n\t\tif (x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y){\n\t\tx = find(x), y = find(y);\n\t\tif (x == y) return;\n\t\tpar[x] = y;\n\t\tsz[y] += sz[x];\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x){\n\t\treturn sz[find(x)];\n\t}\n};\n\nint dx[] = { 0, 1, 0, -1 };\nint dy[] = { -1, 0, 1, 0 };\n\nint main(){\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile (cin >> n, n){\n\t\tUnionFind uf(n * 4);\n\t\tconst int N = n * 2;\n\t\tmap<P, int> m;\n\t\tint id = 0;\n\t\trep(i, n){\n\t\t\tint x, y;\n\t\t\tchar c;\n\t\t\tcin >> x >> y >> c;\n\t\t\tint nx = x, ny = y;\n\t\t\tif (c == 'x') ++nx;\n\t\t\telse ++ny;\n\t\t\tm[MP(x, y)] = id++;\n\t\t\tm[MP(nx, ny)] = id++;\n\t\t}\n\t\tfor (auto dat : m){\n\t\t\tP pos = dat.first;\n\t\t\tint id = dat.second;\n\t\t\trep(i, 4){\n\t\t\t\tint nx = pos.first + dx[i], ny = pos.second + dy[i];\n\t\t\t\tif (!m.count(MP(nx, ny))) continue;\n\t\t\t\tint adj = m[MP(nx, ny)];\n\t\t\t\tif (id / 2 == adj / 2){\n\t\t\t\t\tuf.unite(id, adj + N);\n\t\t\t\t\tuf.unite(id + N, adj);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tuf.unite(id, adj);\n\t\t\t\t\tuf.unite(id + N, adj + N);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok = true;\n\t\trep(i, N){\n\t\t\tif (uf.same(i, i + N)) ok = false;\n\t\t}\n\t\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\t}\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define iss istringstream\n#define sst stringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint n,dx[]={1,0,-1,0},dy[]={0,1,0,-1},e,s;\nchar d;\nstruct F{int x,y,xx,yy,w;}f[20010];\nmap<pi,int> M,N;\n\nvoid g(int cur){\n\tF c=f[cur];\n\tif(s==1){\n\t\tc.w=1,s=0;\n\t\tN[pi(c.x,c.y)]=1,N[pi(c.xx,c.yy)]=2;\n\t}else{\n\t\tint OK=0;\n\t\trep2(i,1,3){\n\t\t\tint ok=1;\n\t\t\trep(j,4){\n\t\t\t\tint nx=c.x+dx[j],ny=c.y+dy[j];\n\t\t\t\tif(N[pi(nx,ny)]==3-i)ok=0;\n\t\t\t}\n\t\t\trep(j,4){\n\t\t\t\tint nx=c.xx+dx[j],ny=c.yy+dy[j];\n\t\t\t\tif(N[pi(nx,ny)]==i)ok=0;\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tc.w=i;\n\t\t\t\tN[pi(c.x,c.y)]=i,N[pi(c.xx,c.yy)]=3-i;\n\t\t\t\tOK=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!OK){e=1;return;}\n\t}\n\trep(i,4){\n\t\tint nx=c.x+dx[i],ny=c.y+dy[i];\n\t\tif(N[pi(nx,ny)]==-1)g(M[pi(nx,ny)]);\n\t\tnx=c.xx+dx[i],ny=c.yy+dy[i];\n\t\tif(N[pi(nx,ny)]==-1)g(M[pi(nx,ny)]);\n\t}\n}\n\nint main(){\n\twhile(cin>>n&&n){\n\t\trep(i,n)f[i].w=0;\n\t\tM.clear(),N.clear();\n\t\trep(i,n)cin>>f[i].x>>f[i].y>>d,\n\t\tf[i].xx=f[i].x+dx[d=='x'],f[i].yy=f[i].y+dy[d=='x'],\n\t\tM[pi(f[i].x,f[i].y)]=M[pi(f[i].xx,f[i].yy)]=i,\n\t\tN[pi(f[i].x,f[i].y)]=N[pi(f[i].xx,f[i].yy)]=-1;\n\t\te=0;\n\t\trep(i,n)if(!f[i].w)s=1,g(i);\n\t\tcout<<(e?\"No\":\"Yes\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define MAX 10000\n#define F_MAX 20000\n\nint n;\nint field[MAX][MAX];\n\nstruct futon{\n\tint x[2], y[2];\n};\n\nfuton F[F_MAX];\n\nint dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nbool dfs( int pos ){\n\tif( pos == n ) return true;\n\tbool rep = false;\n\tfor( int i = 0; i < 2; i++ ){\n\t\tint legx, legy, headx, heady;\n\t\tlegx = F[pos].x[i];\n\t\tlegy = F[pos].y[i];\n\t\theadx = F[pos].x[1-i];\n\t\theady = F[pos].y[1-i];\n\t\t//cout << \"----\" << pos << \"------\" << endl;\n\t\t//cout << legx << \" \" << legy << \" \" << headx << \" \" << heady << endl;\n\t\tbool ok = true;\n\t\tfor( int j = 0; j < 4; j++ ){\n\t\t\tif( (0 <= legx+dx[j] && legx+dx[j] < MAX) && (0 <= legy+dy[j] && legy+dy[j] < MAX) ){\n\t\t\t\tif( field[legx+dx[j]][legy+dy[j]] == 1 ) ok = false;\n\t\t\t}\n\t\t\tif( (0 <= headx+dx[j] && headx+dx[j] < MAX) && (0 <= heady+dy[j] && heady+dy[j] < MAX) ){\n\t\t\t\tif( field[headx+dx[j]][heady+dy[j]] == 2 ) ok = false;\n\t\t\t}\n\t\t}\n\t\tif( !ok ) continue;\n\t\tfield[headx][heady] = 1;\n\t\tfield[legx][legy] = 2;\n\t\tif( dfs(pos+1) ) rep = true;\n\t\tfield[headx][heady] = 0;\n\t\tfield[legx][legy] = 0;\n\t}\n\treturn rep;\n}\n\nint main(){\n\twhile( cin >> n, n ){\n\t\tfor( int i = 0; i < n; i++ ){\n\t\t\tint x, y;\n\t\t\tchar d;\n\t\t\tcin >> x >> y >> d;\n\t\t\tF[i].x[0] = x;\n\t\t\tF[i].y[0] = y;\n\t\t\tF[i].x[1] = (d == 'x') ? x+1 : x;\n\t\t\tF[i].y[1] = (d == 'x') ? y : y+1;\n\t\t}\n\t\tfor( int j = 0; j < MAX; j++ ){\n\t\t\tfor( int k = 0; k < MAX; k++ ){\n\t\t\t\tfield[j][k] = 0;\n\t\t\t}\n\t\t}\n\t\t/*for( int i = 0; i < n; i++ ){\n\t\t\tfor( int j = 0; j < 2; j++ ){\n\t\t\t\tcout << F[i].x[j] << \" \" << F[i].y[j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tif( dfs(0) ) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,int> Pi;\ntypedef long long ll;\n\nint n;\n\n\nbool bfs(int t,map<P,P> &futon,pair<P,P> f) {\n    queue<Pi> que;\n    que.push(Pi(f.fr,t));\n    f.sc.sc=t;\n    futon[f.fr]=f.sc;\n    map<Pi,bool> visited;\n    visited[(Pi(f.fr,t))]=true;;\n\n    while(que.size()) {\n        Pi pi = que.front(); que.pop();\n        P p=pi.fr;\n        //printf(\"[debug] %d : %d %d %d\\n\",t,p.fr,p.sc,pi.sc);\n        rep(k,4) {\n            int ny=p.fr+dy[k];\n            int nx=p.sc+dx[k];\n            int t=pi.sc;\n\n            if(!futon.count(P(ny,nx))) continue;\n            //if(futon[P(ny,nx)].sc!=-1) continue;\n\n            // ???????????£???\n            if(futon[P(ny,nx)].fr==futon[p].fr) {\n                if(futon[P(ny,nx)].sc!=-1&&futon[P(ny,nx)].sc!=(t^1)) return false;\n                if(visited.count(Pi(P(ny,nx),t^1))) continue;\n                visited[(Pi(P(ny,nx),t^1))]=true;\n                futon[P(ny,nx)].sc=t^1;\n                que.push(Pi(P(ny,nx),t^1));\n            }\n            else {\n                if(futon[P(ny,nx)].sc!=-1&&futon[P(ny,nx)].sc!=t) return false;\n                if(visited.count(Pi(P(ny,nx),t))) continue;\n                visited[(Pi(P(ny,nx),t))]=true;\n                futon[P(ny,nx)].sc=t;\n                que.push(Pi(P(ny,nx),t));\n            }\n\n        }\n    }\n\n    return true;\n}\n\nvoid solve() {\n    map<P,P> futon;\n    rep(i,n) {\n        P pos;\n        char d;\n        cin>>pos.sc>>pos.fr>>d;\n        futon[pos]=P(i,-1);\n        if(d=='x') {\n            pos.sc+=1;\n        }\n        else {\n            pos.fr+=1;\n        }\n        futon[pos]=P(i,-1);\n    }\n    bool f=true;\n    for(auto e : futon) {\n        if(e.sc.sc==-1) {\n            if(!bfs(0,futon,e)) f=false;\n        }\n    }\n    if(f) {\n        cout<<\"Yes\"<<endl;\n    }\n    else cout<<\"No\"<<endl;\n}\n\nint main() {\n    while(cin>>n) {\n        if(n==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 20000\n#define HEAD MOD\n#define FOOT MOD+1\n\ntypedef pair<int,int> Point;\n\nenum Type{\n\tTATE,\n\tYOKO,\n};\n\nstruct Info{\n\tint row,col;\n\tType dir;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_index,int arg_which){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tindex = arg_index;\n\t\twhich = arg_which;\n\t}\n\n\tint row,col,index,which;\n};\n\n\nmap<Point,int> MAP; //<座標、布団インデックス>\nInfo info[NUM];\nvector<int> Group[NUM]; //隣接している布団のグループ\n\nint near_row[4] = {1,0,0,-1},near_col[4] = {0,-1,1,0};\nint diff_row[2][6] = {{2,1,1,0,0,-1},{-1,-1,0,0,1,1}},diff_col[2][6] = {{0,-1,1,-1,1,0},{0,1,-1,2,0,1}};\n\nint N;\nint boss[NUM],height[NUM];\n\n//自分のボスのindexを取得しつつ、経路圧縮を行う関数\nint get_boss(int id){\n\tif(boss[id] == id)return id; //自分が代表なら、自分の値を返す\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]); //代表でないなら、自分が所属する組織の代表を返しつつ、経路圧縮\n\t}\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\t//既に同じグループなら何もしない\n\tif(boss_x == boss_y)return;\n\n\t//高さが高い方に吸収する\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nbool check(int group_id){\n\n\tmap<Point,int> ROOM;\n\tqueue<Data> Q;\n\n\t//ボスの、左下側を頭にする(ボスのid == group_id)\n\tROOM[Point(info[group_id].row,info[group_id].col)] = HEAD;\n\t//printf(\"(%d,%d)に%dの頭を配置\\n\",info[group_id].row,info[group_id].col,group_id);\n\tQ.push(Data(info[group_id].row,info[group_id].col,group_id,HEAD));\n\n\tbool FLG = true;\n\n\tint adj_row,adj_col,adj_index;\n\n\twhile(!Q.empty()){\n\n\t\t//printf(\"index:%d row:%d col:%d type:%d\\n\",Q.front().index,Q.front().row,Q.front().col,Q.front().which);\n\n\t\t//隣接4近傍を検索\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tadj_row = Q.front().row+near_row[i];\n\t\t\tadj_col = Q.front().col+near_col[i];\n\n\t\t\tauto at = MAP.find(Point(adj_row,adj_col));\n\t\t\tif(at == MAP.end())continue; //隣接する布団がなければSKIP\n\n\t\t\tadj_index = MAP[Point(adj_row,adj_col)];\n\t\t\t//printf(\"adj_row:%d,adj_col:%d adj_index:%d\\n\",adj_row,adj_col,adj_index);\n\n\t\t\tif(adj_index != Q.front().index){ //自分以外の布団が隣接\n\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){ //まだ割り当てがされていない\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD; //頭と足は隣接してはいけない\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,HEAD));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの頭を配置\\n\",adj_row,adj_col,adj_index);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,FOOT));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの足を配置\\n\",adj_row,adj_col,adj_index);\n\t\t\t\t\t}\n\t\t\t\t}else{ //割り当て済\n\t\t\t\t\tif((ROOM[Point(adj_row,adj_col)] == FOOT && Q.front().which == HEAD) ||\n\t\t\t\t\t\t\t(ROOM[Point(adj_row,adj_col)] == HEAD && Q.front().which == FOOT)){ //矛盾発生\n\t\t\t\t\t\t//printf(\"異種隣接\\n\");\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{ //自分の布団が隣接\n\t\t\t\t//自分のもう一方に、不適な割り当てがされていないか調べる\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){ //まだ割り当てがされていない\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,FOOT));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの頭を配置\\n\",adj_row,adj_col,Q.front().index);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,HEAD));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの足を配置\\n\",adj_row,adj_col,Q.front().index);\n\t\t\t\t\t}\n\t\t\t\t}else{ //割り当て済\n\t\t\t\t\tif(ROOM[Point(adj_row,adj_col)] == Q.front().which){ //矛盾発生\n\t\t\t\t\t\t//printf(\"同じパーツが重複\\n\");\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG)break;\n\n\t\tQ.pop();\n\t}\n\n\tif(FLG)return true;\n\n\n\tFLG = true;\n\tROOM.clear();\n\n\t//ボスの、左下側を足にする\n\tROOM[Point(info[group_id].row,info[group_id].col)] = FOOT;\n\tQ.push(Data(info[group_id].row,info[group_id].col,group_id,FOOT));\n\t//printf(\"(%d,%d)に%dの足を配置\\n\",info[group_id].row,info[group_id].col,group_id);\n\n\twhile(!Q.empty()){\n\n\t\t//printf(\"index:%d row:%d col:%d type:%d\\n\",Q.front().index,Q.front().row,Q.front().col,Q.front().which);\n\n\t\t//隣接4近傍を検索\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tadj_row = Q.front().row+near_row[i];\n\t\t\tadj_col = Q.front().col+near_col[i];\n\n\t\t\tauto at = MAP.find(Point(adj_row,adj_col));\n\t\t\tif(at == MAP.end())continue; //隣接する布団がなければSKIP\n\n\t\t\tadj_index = MAP[Point(adj_row,adj_col)];\n\t\t\t//printf(\"adj_row:%d,adj_col:%d adj_index:%d\\n\",adj_row,adj_col,adj_index);\n\n\t\t\tif(adj_index != Q.front().index){ //自分以外の布団が隣接\n\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){ //まだ割り当てがされていない\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD; //頭と足は隣接してはいけない\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,HEAD));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの頭を配置\\n\",adj_row,adj_col,adj_index);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,FOOT));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの足を配置\\n\",adj_row,adj_col,adj_index);\n\t\t\t\t\t}\n\t\t\t\t}else{ //割り当て済\n\t\t\t\t\tif((ROOM[Point(adj_row,adj_col)] == FOOT && Q.front().which == HEAD) ||\n\t\t\t\t\t\t\t(ROOM[Point(adj_row,adj_col)] == HEAD && Q.front().which == FOOT)){ //矛盾発生\n\t\t\t\t\t\t//printf(\"異種隣接\\n\");\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{ //自分の布団が隣接\n\t\t\t\t//自分のもう一方に、不適な割り当てがされていないか調べる\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){ //まだ割り当てがされていない\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,FOOT));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの頭を配置\\n\",adj_row,adj_col,Q.front().index);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,HEAD));\n\t\t\t\t\t\t//printf(\"(%d,%d)に%dの足を配置\\n\",adj_row,adj_col,Q.front().index);\n\t\t\t\t\t}\n\t\t\t\t}else{ //割り当て済\n\t\t\t\t\tif(ROOM[Point(adj_row,adj_col)] == Q.front().which){ //矛盾発生\n\t\t\t\t\t\t//printf(\"同じパーツが重複\\n\");\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG)break;\n\n\t\tQ.pop();\n\t}\n\n\n\treturn FLG;\n}\n\nvoid func(){\n\n\tMAP.clear();\n\tfor(int i = 0; i < N; i++)Group[i].clear();\n\n\tinit();\n\n\tchar buf[2];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %s\",&info[i].col,&info[i].row,buf);\n\t\tif(buf[0] == 'x'){\n\t\t\tinfo[i].dir = YOKO;\n\t\t}else{\n\t\t\tinfo[i].dir = TATE;\n\t\t}\n\t\tMAP[Point(info[i].row,info[i].col)] = i; //マップに登録(2マス分)\n\t\tif(info[i].dir == YOKO){\n\t\t\tMAP[Point(info[i].row,info[i].col+1)] = i;\n\t\t}else{\n\t\t\tMAP[Point(info[i].row+1,info[i].col)] = i;\n\t\t}\n\t}\n\n\t//隣接している布団のグループを作る\n\tint adj_row,adj_col;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < 6; k++){\n\t\t\tadj_row = info[i].row+diff_row[info[i].dir][k];\n\t\t\tadj_col = info[i].col+diff_col[info[i].dir][k];\n\n\t\t\tauto at = MAP.find(Point(adj_row,adj_col));\n\t\t\tif(at == MAP.end())continue;\n\n\t\t\tunite(i,MAP[Point(adj_row,adj_col)]); //隣接している布団を同じグループにする\n\t\t}\n\t}\n\n\tvector<int> BOSS;\n\tfor(int i = 0; i < N; i++){ //布団をグループに振り分ける\n\t\tGroup[get_boss(i)].push_back(i);\n\t\tif(boss[i] == i){\n\t\t\tBOSS.push_back(i); //ボスを収集する\n\t\t}\n\t}\n\n\tfor(int i = 0; i < BOSS.size(); i++){\n\t\tif(check(BOSS[i]) == false){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tprintf(\"Yes\\n\");\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint n;\nint x[20000], y[20000];\nstring d[20000];\nmap<P, int> mp;\n\nbool dfs(int x, int y, int c)\n{\n\tmp[P(x, y)] = c;\n\tfor (int dir = 0; dir < 4; dir++){\n\t\tint nx = x + dx[dir];\n\t\tint ny = y + dy[dir];\n\t\tif (!mp.count(P(nx, ny))) continue;\n\t\tif (mp[P(nx, ny)] == c) return true;\n\t\tif (mp[P(nx, ny)] != -1) continue;\n\t\tif (dfs(nx, ny, c ^ 1)) return true;\n\t}\n\treturn false;\n}\n\nint main()\n{\n\twhile (cin >> n, n){\n\t\tmp.clear();\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tcin >> x[i] >> y[i] >> d[i];\n\t\t\tmp[P(x[i], y[i])] = -1;\n\t\t\tif (d[i] == \"x\") mp[P(x[i] + 1, y[i])] = -1;\n\t\t\telse mp[P(x[i], y[i] + 1)] = -1;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (mp[P(x[i], y[i])] != -1) continue;\n\t\t\tif (dfs(x[i], y[i], 0)){\n\t\t\t\tcout << \"No\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tcout << \"Yes\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nchar c;\nint x[20001][2],y[20001][2];\nvector<int>v[40001];\nint b[40001],f,n;\nvoid dfs(int p,int col){\n  b[p]=col;\n  r(i,v[p].size()){\n    if(!(p==v[p][i]+n||p+n==v[p][i])&&b[v[p][i]]&&b[v[p][i]]!=col)f++;\n    else if(!b[v[p][i]]){\n      if(p==v[p][i]+n||p+n==v[p][i]){\n        if(col==1)dfs(v[p][i],2);\n        else dfs(v[p][i],1);\n      }\n      else dfs(v[p][i],col);\n    }\n  }\n}\nint main(){\n  while(cin>>n,n){\n    memset(b,0,sizeof(b));\n    r(i,40001)v[i].clear();\n    r(i,n){\n      cin>>x[i][0]>>y[i][0]>>c;\n      if(c=='x')x[i][1]=x[i][0]+1,y[i][1]=y[i][0];\n      else x[i][1]=x[i][0],y[i][1]=y[i][0]+1;\n    }\n    r(i,n)v[i].push_back(i+n);\n    r(i,n)r(j,n)if(i!=j&&i<j)r(l,2)r(k,2){\n      if(abs(x[i][l]-x[j][k])+abs(y[i][l]-y[j][k])==1){\n        int p1=i,p2=j;\n        if(l)p1+=n;\n        if(k)p2+=n;\n        v[p1].push_back(p2);\n        v[p2].push_back(p1);\n      }\n    }\n    f=0;\n    r(i,n*2)if(!b[i])dfs(i,1);\n    cout<<(f?\"No\":\"Yes\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int sz = 100010;\nvector<int> G[sz];\nvector<int> rG[sz];\nint cmp[sz];\nbool visit[sz];\n\nvoid dfs(int v, vector<int> &vs){\n  visit[v] = true;\n  REP(i, G[v].size()){\n    if(!visit[G[v][i]]) dfs(G[v][i], vs);\n  }\n  vs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n  visit[v] = true;\n  cmp[v] = k;\n  REP(i, rG[v].size()) if(!visit[rG[v][i]]) rdfs(rG[v][i], k);\n}\n\nint scc(int V){\n  int k = 0;\n  vector<int> vs;\n  \n  memset(visit, false, sizeof(visit));  \n  REP(i, V) if(!visit[i]) dfs(i, vs);\n  memset(visit, false, sizeof(visit));\n  reverse(ALL(vs));\n  REP(i, vs.size())if(!visit[vs[i]]) rdfs(vs[i], k++);\n  return k;\n}\n\nvoid clear(){\n  REP(i, sz){\n    G[i].clear();\n    rG[i].clear();\n  }\n}\n\nvoid add_edge(int from, int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    clear();\n    char dir;\n    vector<int> x(n * 2);\n    vector<int> y(n * 2);\n    vector<int> d(n * 2);\n    \n    REP(i, n){\n      cin >> x[i] >> y[i] >> dir;\n      x[i+n] = x[i];\n      y[i+n] = y[i];\n      \n      if(dir == 'x'){\n        x[i+n]++;\n        d[i] = 0;\n        d[i+n] = 2;\n      }\n      \n      if(dir == 'y'){\n        y[i+n]++;\n        d[i] = 1;\n        d[i+n] = 3;\n      }\n    }\n    \n    n *= 2;\n    map<P, int> futon;    \n    REP(i, n) futon[P(x[i], y[i])] = i;\n    \n    REP(i, n){\n      int dx[4] = {1, 0, -1, 0};\n      int dy[4] = {0, 1, 0, -1};     \n      REP(j, 4){\n        int xa = x[i] + dx[j];\n        int ya = y[i] + dy[j];\n\n        if(futon.find(P(xa, ya)) != futon.end()){\n          int f = futon[P(xa, ya)];\n          \n          if(j == d[i]){\n            add_edge(i, f + n);\n            add_edge(f, i + n);\n            add_edge(i + n, f);\n            add_edge(f + n, i);\n          }else{\n            add_edge(i + n, f + n);\n            add_edge(f + n, i + n);\n          }\n        }\n      }\n    }\n\n    bool possible = true;\n    scc(2 * n);\n    REP(i, n){\n      possible &= cmp[i] != cmp[n + i];\n    }\n    cout << (possible ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef pair< int, int > pii;\ntypedef pair< pii, pii > ppii;\n\nconst int dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\nint n, x[20020], y[20020], visit[20020][2];\nchar dir[20020];\npii pos[40040], ids[40040];\n\nint xadd(int i) { return dir[i] == 'x' ? 1 : 0; }\nint yadd(int i) { return dir[i] == 'y' ? 1 : 0; }\n\nbool rec(int i, int j, int v, vector< pii >& upd) {\n\tbool res = 1;\n\t\n\tif (visit[i][j] < 0) {\n\t\tvisit[i][j] = v;\n\t\tvisit[i][j^1] = v^1;\n\t\tupd.push_back(pii(i,j));\n\t\tupd.push_back(pii(i,j^1));\n\t\t\n\t\tint nx1 = x[i] + (j ? xadd(i) : 0), ny1 = y[i] + (j ? yadd(i) : 0);\n\t\tint nx2 = x[i] + (j ? 0 : xadd(i)), ny2 = y[i] + (j ? 0 : yadd(i));\n\t\tfor_(d,0,4) {\n\t\t\tpii nxp1(nx1 + dx[d], ny1 + dy[d]);\n\t\t\tint k = lower_bound(pos, pos + 2*n, nxp1) - pos;\n\t\t\tif (k < 2*n && pos[k] == nxp1 && ids[k].second != i) res &= rec(ids[k].second, ids[k].first, v, upd);\n\t\t\t\n\t\t\tpii nxp2(nx2 + dx[d], ny2 + dy[d]);\n\t\t\tk = lower_bound(pos, pos + 2*n, nxp2) - pos;\n\t\t\tif (k < 2*n && pos[k] == nxp2 && ids[k].second != i) res &= rec(ids[k].second, ids[k].first, v^1, upd);\n\t\t}\n\t} else {\n\t\tres = (visit[i][j] == v);\n\t}\n\t\n\treturn res;\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n), n) {\n\t\tvector< ppii > vp;\n\t\t\n\t\tfor_(i,0,n) {\n\t\t\tscanf(\"%d %d %c\", &x[i], &y[i], &dir[i]);\n\t\t\tvp.push_back(ppii(pii(x[i], y[i]), pii(0, i)));\n\t\t\tvp.push_back(ppii(pii(x[i] + xadd(i), y[i] + yadd(i)), pii(1, i)));\n\t\t}\n\t\t\n\t\tsort(vp.begin(), vp.end());\n\t\t\n\t\tfor_(i,0,2*n) {\n\t\t\tpos[i] = vp[i].first;\n\t\t\tids[i] = vp[i].second;\n\t\t}\n\t\t\n\t\tmemset(visit, -1, sizeof(visit));\n\t\t\n\t\tbool ok = 1;\n\t\tfor_(i,0,n && ok) {\n\t\t\tif (visit[i][0] < 0) {\n\t\t\t\tvector< pii > upd;\n\t\t\t\tif (!rec(i, 0, 0, upd)) {\n\t\t\t\t\tint u_size = (int)upd.size();\n\t\t\t\t\tfor_(j,0,u_size) visit[upd[j].first][upd[j].second] = -1;\n\t\t\t\t\tok = rec(i, 0, 1, upd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n\tint n;\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tmap<pair<int, int>, char> m;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint x, y;\n\t\t\tchar d;\n\t\t\tcin >> x >> y >> d;\n\t\t\tm[make_pair(x, y)] = d;\n\t\t}\n\t\tbool ans = true;\n\t\tfor(auto i = m.begin(); i != m.end(); i++){\n\t\t\tint x = ((*i).first).first;\n\t\t\tint y = ((*i).first).second;\n\t\t\tchar d = (*i).second;\n\t\t\tint checkx = x, checky = y;\n\t\t\tif(d == 'x') checky = y + 2;\n\t\t\telse checkx = x + 2;\n\t\t\tif(m.find(make_pair(checkx, checky)) != m.end()) ans = false;\n\t\t}\n\t\tif(ans) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// template {{{\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define loop(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) loop(i, 0, n)\n#define rloop(i, a, b) for (int i = (int)(b) - 1; i >= (int)(a); i--)\n#define rrep(i, n) rloop(i, 0, n)\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define ef emplace_front\n#define mp std::make_pair\n#define mt std::make_tuple\n#define fi first\n#define se second\n\nusing ll = long long;\nusing ull = unsigned long long;\n\ntemplate<typename T, size_t H, size_t W>\nusing matrix = std::array<std::array<T, W>, H>;\n\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 10;\nconst ll LLINF = 1e18 + 10;\n\nconst int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\nconst int dy[] = {0, -1, 0, 1, -1, 1, -1, 1};\n\ntemplate<typename T>\ninline T sq(T x){ return x * x; }\n\ntemplate<typename T, typename U>\ninline void chmax(T &x, U y){ x = std::max<T>(x, y); }\n\ntemplate<typename T, typename U>\ninline void chmin(T &x, U y){ x = std::min<T>(x, y); }\n\ntemplate<typename T>\ninline void sort(T &c){ std::sort(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void reverse(T &c){ std::reverse(std::begin(c), std::end(c)); }\n\ntemplate<typename T>\ninline void unique(T &c){ std::sort(c); c.erase(std::unique(std::begin(c), std::end(c))); }\n\n// }}}\n\nusing pr = pair<int, int>;\n\nint n;\nint x[20000], y[20000];\nmap<pr, pr> c;\nmap<pr, int> g;\n\nbool dfs(int x, int y, int col)\n{\n\tg[pr(x, y)] = col;\n\trep(dir, 4){\n\t\tint nx = x + dx[dir];\n\t\tint ny = y + dy[dir];\n\t\tif (!g.count(pr(nx, ny))) continue;\n\t\tif (pr(nx, ny) == c[pr(x, y)]){\n\t\t\tif (g[pr(nx, ny)] == col) return false;\n\t\t\tif (g[pr(nx, ny)] == 0){\n\t\t\t\tif (!dfs(nx, ny, -col)) return false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (g[pr(nx, ny)] == -col) return false;\n\t\t\tif (g[pr(nx, ny)] == 0){\n\t\t\t\tif (!dfs(nx, ny, col)) return false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n){\n\t\tc.clear();\n\t\tg.clear();\n\t\trep(i, n){\n\t\t\tstring dir;\n\t\t\tcin >> x[i] >> y[i] >> dir;\n\t\t\tif (dir == \"x\"){\n\t\t\t\tc[pr(x[i], y[i])] = pr(x[i] + 1, y[i]);\n\t\t\t\tc[pr(x[i] + 1, y[i])] = pr(x[i], y[i]);\n\t\t\t\tg[pr(x[i], y[i])] = 0;\n\t\t\t\tg[pr(x[i] + 1, y[i])] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc[pr(x[i], y[i])] = pr(x[i], y[i] + 1);\n\t\t\t\tc[pr(x[i], y[i] + 1)] = pr(x[i], y[i]);\n\t\t\t\tg[pr(x[i], y[i])] = 0;\n\t\t\t\tg[pr(x[i], y[i] + 1)] = 0;\n\t\t\t}\n\t\t}\n\t\tbool res = true;\n\t\trep(i, n){\n\t\t\tif (!g[pr(x[i], y[i])]){\n\t\t\t\tif (!dfs(x[i], y[i], 1)){\n\t\t\t\t\tres = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (res ? \"Yes\" : \"No\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\nint const OppoSide = 0;\nint const SameSide = 1;\n\nint N;\nvector<pair<int, int>> G[40001];\nmap<pair<int, int>, int> MP;\nmap<int, pair<int, int>> CD;\nint vis[40001];\n\nbool dfs(int curr, int col) {\n  for(auto& e: G[curr]) {\n    int next, dir; tie(next, dir) = e;\n    int nextCol = dir == OppoSide ? col ^ 1 : col;\n    if(vis[next] + 1) {\n      if(vis[next] != nextCol) return false;\n    } else {\n      vis[next] = nextCol;\n      if(!dfs(next, nextCol)) return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n\n  for(int M; cin >> M && M;) {\n    vector<int> xs, ys;\n    vector<int> X, Y; vector<char> D;\n    rep(i, M) {\n      int x, y; char d; cin >> x >> y >> d;\n      X.push_back(x), Y.push_back(y), D.push_back(d);\n\n      xs.push_back(x-1),  ys.push_back(y-1);\n      xs.push_back(x),    ys.push_back(y);\n      xs.push_back(x+1),  ys.push_back(y+1);\n\n      if(d == 'x') {\n        xs.push_back(x+2);\n      } else {\n        ys.push_back(y+2);\n      }\n\n    }\n\n    sort(all(xs)); xs.erase(unique(all(xs)), xs.end());\n    sort(all(ys)); ys.erase(unique(all(ys)), ys.end());\n\n    vector<int> NX, NY;\n    rep(i, X.size()) {\n      NX.push_back(lower_bound(all(xs), X[i]) - X.begin());\n    }\n    rep(i, Y.size()) {\n      NY.push_back(lower_bound(all(ys), Y[i]) - Y.begin());\n    }\n    X = NX, Y = NY;\n\n    MP.clear(), CD.clear();\n    rep(i, 40001) G[i].clear();\n    N = 0;\n\n    rep(i, X.size()) {\n      MP[make_pair(Y[i], X[i])] = N;\n      CD[N++] = make_pair(Y[i], X[i]);\n      if(D[i] == 'x') {\n        MP[make_pair(Y[i], X[i]+1)] = N;\n        CD[N] = make_pair(Y[i], X[i]+1);\n        G[N-1].emplace_back(N, OppoSide), G[N].emplace_back(N-1, OppoSide);\n        N++;\n      } else {\n        MP[make_pair(Y[i]+1, X[i])] = N;\n        CD[N] = make_pair(Y[i]+1, X[i]);\n        G[N-1].emplace_back(N, OppoSide), G[N].emplace_back(N-1, OppoSide);\n        N++;\n      }\n    }\n\n    rep(i, N) {\n      auto curr = CD[i];\n      rep(k, 4) {\n        auto next = make_pair(CD[i].first + dy[k], CD[i].second + dx[k]);\n        if(MP.find(next) == MP.end()) continue; // テ・ツクツε・ツ崢」テ」ツ??」ツ?妥ィツェツソテ」ツ?ケテ」ツつ古」ツ?ーOK\n        if(find(all(G[i]), make_pair(MP[next], OppoSide)) != G[i].end()) continue;  // テ・ツ按・テ」ツ?ョテ・ツクツε・ツ崢」テ」ツ?ッSameSideテ」ツ?療」ツ?凝・ツ?・テ」ツつ古」ツつ暗」ツ??」ツ?ィテ」ツ?療」ツ?ェテ」ツ??」ツ?凝」ツつ碓K\n        G[i].emplace_back(MP[next], SameSide);\n      }\n    }\n\n    minus(vis);\n    vis[0] = 0;\n    cout << (dfs(0, 0) ? \"Yes\" : \"No\") << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,int> Pi;\ntypedef long long ll;\n\nint n;\n\n\nbool bfs(int t,map<P,P> futon,pair<P,P> f) {\n    queue<Pi> que;\n    que.push(Pi(f.fr,t));\n    f.sc.sc=t;\n    futon[f.fr]=f.sc;\n    map<Pi,bool> visited;\n    visited[(Pi(f.fr,t))]=true;;\n\n    while(que.size()) {\n        Pi pi = que.front(); que.pop();\n        P p=pi.fr;\n        //printf(\"[debug] %d : %d %d %d\\n\",t,p.fr,p.sc,pi.sc);\n        rep(k,4) {\n            int ny=p.fr+dy[k];\n            int nx=p.sc+dx[k];\n            int t=pi.sc;\n\n            if(!futon.count(P(ny,nx))) continue;\n            //if(futon[P(ny,nx)].sc!=-1) continue;\n\n            // ???????????£???\n            if(futon[P(ny,nx)].fr==futon[p].fr) {\n                if(futon[P(ny,nx)].sc!=-1&&futon[P(ny,nx)].sc!=(t^1)) return false;\n                if(visited.count(Pi(P(ny,nx),t^1))) continue;\n                visited[(Pi(P(ny,nx),t^1))]=true;\n                futon[P(ny,nx)].sc=t^1;\n                que.push(Pi(P(ny,nx),t^1));\n            }\n            else {\n                if(futon[P(ny,nx)].sc!=-1&&futon[P(ny,nx)].sc!=t) return false;\n                if(visited.count(Pi(P(ny,nx),t))) continue;\n                visited[(Pi(P(ny,nx),t))]=true;\n                futon[P(ny,nx)].sc=t;\n                que.push(Pi(P(ny,nx),t));\n            }\n\n        }\n    }\n\n    return true;\n}\n\nvoid solve() {\n    map<P,P> futon;\n    rep(i,n) {\n        P pos;\n        char d;\n        cin>>pos.sc>>pos.fr>>d;\n        futon[pos]=P(i,-1);\n        if(d=='x') {\n            pos.sc+=1;\n        }\n        else {\n            pos.fr+=1;\n        }\n        futon[pos]=P(i,-1);\n    }\n    bool f=true;\n    f=bfs(0,futon,*futon.begin());\n    if(f) {\n        cout<<\"Yes\"<<endl;\n    }\n    else cout<<\"No\"<<endl;\n}\n\nint main() {\n    while(cin>>n) {\n        if(n==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define repi(i,a,b) for(int i = (a);i < (b); i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i = (a); i >= (b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n\n#define pb push_back\n#define mp make_pair\n#define INF 1e9\n#define EPS 1e-9\n#define PI acos(-1.0)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\nint n;\n\nstruct futon\n{\n  int x, y; bool dir;\n  futon(int x, int y, bool dir) : x(x), y(y), dir(dir) {}\n};\n\nvector<futon> v;\nmap<pair<int, int>, int> mem;\n\nvoid input()\n{\n  v.clear();\n  mem.clear();\n  rep(i, n) {\n    int x, y; char dir;\n    cin >> x >> y >> dir;\n    v.pb(futon(x, y, dir == 'x'));\n    mem[mp(x, y)] = i;\n  }\n}\n\nstruct edge\n{\n  int to, rev;\n  edge(int to, int rev) : to(to), rev(rev) {}\n};\n\nvector<vector<edge> > G;\n\nconst int dx1[] = {-2, -1, -1, 0, 0, 1, 1, 2};\nconst int dy1[] = {0, -1, 1, -1, 1, -1, 1, 0};\nconst int rev1[] = {-1, -1, -1, 1, 1, -1, -1, -1};\n\nconst int dx2[] = {-1, -1, 0, 0, 1, 1, 2, 2};\nconst int dy2[] = {-1, 0, -2, 1, -2, 1, -1, 0};\nconst int rev2[] = {-1, 1, -1, 1, 1, -1, 1, -1};\n\nvoid gen()\n{\n  G.assign(n, vector<edge>());\n  rep(i, n) {\n    int x = v[i].x, y = v[i].y;\n    if (v[i].dir) {\n      rep(j, 8) {\n\tmap<pair<int,int>,int>::iterator it = mem.find(mp(x + dx1[j], y + dy1[j]));\n\tif (it != mem.end()) {\n\t  int k = it->second;\n\t  if (v[k].dir) {\n\t    G[i].pb(edge(k, rev1[j]));\n\t    G[k].pb(edge(i, rev1[j]));\n\t  }\n\t}\n\tit = mem.find(mp(x + dx2[j], y + dy2[j]));\n\tif (it != mem.end()) {\n\t  int k = it->second;\n\t  if (!v[k].dir) {\n\t    G[i].pb(edge(k, rev2[j]));\n\t    G[k].pb(edge(i, rev2[j]));\n\t  }\n\t}\n      }\n    } else {\n      rep(j, 8) {\n\tmap<pair<int,int>,int>::iterator it = mem.find(mp(x + dy1[j], y + dx1[j]));\n\tif (it != mem.end()) {\n\t  int k = it->second;\n\t  if (!v[k].dir) {\n\t    G[i].pb(edge(k, rev1[j]));\n\t    G[k].pb(edge(i, rev1[j]));\n\t  }\n\t}\n\tit = mem.find(mp(x + dy2[j], y + dx2[j]));\n\tif (it != mem.end()) {\n\t  int k = it->second;\n\t  if (v[k].dir) {\n\t    G[i].pb(edge(k, rev2[j]));\n\t    G[k].pb(edge(i, rev2[j]));\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nvector<int> color;\n\nbool bicolor(int v, int c)\n{\n  if (color[v])\n    return color[v] == c;\n\n  color[v] = c;\n  rep(i, G[v].size())\n    if (!bicolor(G[v][i].to, G[v][i].rev * c))\n      return false;\n  return true;\n}\n\nbool solve()\n{\n  color.assign(n, 0);\n  rep(i, n)\n    if (!color[i] && !bicolor(i, 1))\n      return false;\n  return true;\n}\n\nint main()\n{\n  while (cin >> n && n) {\n    input();\n    gen();\n    cout << (solve() ? \"Yes\" : \"No\") << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<map>\n#include<algorithm>\n\n#define all(a) (a).begin(),(a).end()\n#define N 100000\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n,V;\nint x[20000],y[20000];\nchar d;\nvector<P> f;\n\nvector<int> g[N];\nint match[N];\nbool used[N];\n\nvoid add_edge(int u,int v){\n  g[u].push_back(v);\n  g[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    int u = g[v][i], w = match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bimatch(){\n  int res = 0;\n  memset(match,-1,sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v] < 0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0); std::ios::sync_with_stdio(false);\n\n  while(cin >> n,n){\n    for(int i=0;i<n;i++){\n      cin >> x[i] >> y[i] >> d;\n      if(d=='x'){\n\tf.push_back(P(x[i]+1,y[i]));\n\tf.push_back(P(x[i]-1,y[i]));\n      }else{\n\tf.push_back(P(x[i],y[i]+1));\n\tf.push_back(P(x[i],y[i]-1));\n      }\n    }\n\n    sort(all(f));\n    f.erase(unique(all(f)),f.end());\n    \n    V = f.size() + n;\n    for(int i=0;i<V;i++)g[i].clear();\n    \n    for(int i=0;i<f.size();i++){\n      int cnt = 0; int tmp;\n      for(int j=0;j<n;j++){\n\tif( abs(f[i].first-x[j]) + abs(f[i].second-y[j]) == 1){\n\t  cnt++; tmp = j;\n\t}\n      }\n      if(cnt==1)add_edge(tmp,n+i);\n    }\n    \n    cout << ((bimatch()==n)?\"Yes\":\"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\nconst int vy[] = {0, 1, 0, -1}, vx[] = {1, 0, -1, 0};\n\n\nmap< Pi, Pi > futon;\nmap< Pi, int > head;\n\nbool check(const Pi& point)\n{\n  head[point] = 1;\n  head[futon[point]] = -1;\n  bool flag = true;\n  for(int i = 0; i < 4 && flag; i++) {\n    const int nx = point.first + vx[i], ny = point.second + vy[i];\n    if(make_pair(nx, ny) == futon[point]) continue;\n    if(head.find({nx, ny}) != head.end()) {\n      if(head[{nx, ny}] == -1) flag = false;\n    } else if(futon.find({nx, ny}) != futon.end()) {\n      if(!check({nx, ny})) flag = false;\n    }\n  }\n  \n  for(int i = 0; i < 4 && flag; i++) {\n    const int nx = futon[point].first + vx[i], ny = futon[point].second + vy[i];\n    if(make_pair(nx, ny) == point) continue;\n    if(head.find({nx, ny}) != head.end()) {\n      if(head[{nx, ny}] == 1) flag = false;\n    } else if(futon.find({nx, ny}) != futon.end()) {\n      if(!check(futon[{nx, ny}])) flag = false;\n    }\n  }\n  \n  if(flag) return(true);\n  head.erase(futon[point]);\n  head.erase(point);\n  return(false);\n}\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    while(N--) {\n      int x, y;\n      char dir;\n      cin >> x >> y >> dir;\n      if(dir == 'x') {\n        futon[{x, y}] = {x + 1, y};\n        futon[{x + 1, y}] = {x, y};\n      } else {\n        futon[{x, y}] = {x, y + 1};\n        futon[{x, y + 1}] = {x, y};\n      }\n    }\n    while(!futon.empty()) {\n      auto decide = *futon.begin();\n      if(head.find(decide.first) == head.end()) {\n        if(!check(decide.first) && !check(decide.second)) break;\n      }\n      futon.erase(futon.begin());\n    }\n    if(futon.empty()) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n    head.clear();\n    futon.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\nint main(void) {\n    while(1) {\n        ll n;\n        cin >> n;\n        if(!n) break;\n        ll idx = 0;\n        map<PII,ll> mp;\n        REP(i, n) {\n            ll x, y;\n            char c;\n            cin >> x >> y >> c;\n\n            if(c == 'x') {\n                if(mp.find({x,y}) == mp.end()) mp[{x, y}] = idx++;\n                if(mp.find({x+1,y}) == mp.end()) mp[{x+1, y}] = idx++;\n            }\n            else {\n                if(mp.find({x,y}) == mp.end()) mp[{x, y}] = idx++;\n                if(mp.find({x,y+1}) == mp.end()) mp[{x, y+1}] = idx++;            \n            }\n        }\n\n        dump(mp);\n\n        vector<vector<ll>> g(idx);\n        auto add_edge = [&](ll a, ll b) {\n            g[a].push_back(b);\n        };\n\n        ll dx[] = {0, -1, 0, 1}, dy[] = {-1, 0, 1, 0};\n        for(auto p: mp) {\n            PII pt = p.first;\n            REP(i, 4) {\n                ll nx = pt.first + dx[i], ny = pt.second + dy[i];\n                if(mp.find({nx,ny}) == mp.end()) continue;\n                add_edge(p.second, mp[{nx, ny}]);\n            }\n        }\n\n        dump(g);\n\n        vector<ll> val(idx);\n        function<void(ll,ll)> dfs = [&](ll v, ll c) {\n            val[v] = c;\n            for(auto to: g[v]) {\n                if(val[to] != -1) continue;\n                ll nc = c;\n                if(v%2 && to==v-1) nc = 1-c;\n                else if(to%2 && v==to-1) nc = 1-c;\n                dfs(to, nc);\n            }\n        };\n\n        auto check = [&] {\n            bool ret = true;\n            REP(i, idx) {\n                for(auto to: g[i]) {\n                    if((i%2 && to==i-1) || (to%2 && i==to-1)) {\n                        if(val[i] == val[to]) ret = false;\n                    } else {\n                        if(val[i] != val[to]) ret = false;\n                    }\n                }\n            }\n            return ret;\n        };\n\n        val.assign(idx, -1);\n        REP(i, idx) if(val[i] == -1) dfs(i, 0);\n        dump(val);\n        if(check()) {\n            cout << \"Yes\" << endl;\n            continue;\n        }\n\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define rep(i, N) for (int i = 0; i < (int)(N); i++)\n#define REP(i, init, N) for (int i = (init); i < (int)(N); i++)\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\nconst double EPS = 1e-12;\n\nstruct Tile {\n    int type;\n    PII another;\n};\n\nint N;\nmap<PII, Tile> ts;\n\nbool solve() {\n    // p, set_type\n    stack<pair<PII, int>> q;\n\n    for (auto t : ts) {\n        q.push(MP(t.fst, 0));\n    }\n\n    while (q.size()) {\n        PII p = q.top().fst;\n        int type = q.top().snd;\n        Tile &t = ts[p];\n        q.pop();\n\n        if (t.type != 0) { // done\n            if (type != 0 && t.type != type) {\n                return false;\n            }\n            continue;\n        }\n\n        if (type == 0) { // init\n            type = 1;\n        }\n\n        t.type = type;\n\n        q.push(MP(t.another, type == 1 ? 2 : 1));\n\n        REP(i, 0, 4) {\n            PII np(p.fst + DY[i], p.snd + DX[i]);\n\n            if (np != t.another && ts.count(np)) {\n                q.push(MP(np, type));\n            }\n        }\n    }\n\n    return true;\n}\n\nint main(void) {\n    while (cin >> N, N) {\n        ts.clear();\n        REP(i, 0, N) {\n            int x, y;\n            char dir;\n            cin >> x >> y >> dir;\n\n            PII p1(y, x);\n            PII p2(y + (dir == 'y'), x + (dir == 'x'));\n\n            Tile t1;\n            Tile t2;\n\n            t1.another = p2;\n            t2.another = p1;\n\n            t1.type = t2.type = 0;\n\n            ts[p1] = t1;\n            ts[p2] = t2;\n        }\n\n        cout << (solve() ? \"Yes\" : \"No\") << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n\ntemplate<class T> inline void chmax(T& a, const T& b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, const T& b) { if(b < a) a = b; }\n\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos << '(' << p.first << \", \" << p.second << ')';\n\treturn os;\n}\n\ntemplate<class Tuple, unsigned Index>\nvoid print_tuple(ostream& os, const Tuple& t) {}\n\ntemplate<class Tuple, unsigned Index, class Type, class... Types>\nvoid print_tuple(ostream& os, const Tuple& t) {\n\tif(Index > 0) os << \", \";\n\tos << get<Index>(t);\n\tprint_tuple<Tuple, Index + 1, Types...>(os, t);\n}\n\ntemplate<class... Types>\nostream& operator<<(ostream& os, const tuple<Types...>& t) {\n\tos << '(';\n\tprint_tuple<tuple<Types...>, 0, Types...>(os, t);\n\treturn os << ')';\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream&, Iterator, const Iterator&);\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> c) {\n\treturn dump_range(os, c.cbegin(), c.cend());\n}\n\ntemplate<class Iterator>\nostream& dump_range(ostream& os, Iterator first, const Iterator& last) {\n\tos << '[';\n\tfor(int i = 0; first != last; ++i, ++first) {\n\t\tif(i) os << \", \";\n\t\tos << *first;\n\t}\n\treturn os << ']';\n}\n\nstruct futon {\n\tint x, y;\n\tchar d;\n\tfuton(int x = 0, int y = 0, char d = 0):x(x), y(y), d(d){}\n};\n\nistream& operator>>(istream& os, futon& f) {\n\treturn os >> f.x >> f.y >> f.d;\n}\n\nconst int LEFT_BOTTOM = (1 << 25);\n\nconst int dx[2][2][3] = {{{-1, 0, 0}, {0, -1, 1}}, {{2, 1, 1}, {0, -1, 1}}};\nconst int dy[2][2][3] = {{{0, 1, -1}, {-1, 0, 0}}, {{0, -1, 1}, {2, 1, 1}}};\n\nvector<int> color;\nvector<vector<int>> field;\nvector<futon> futons;\n\ninline bool out(int x, int y) {\n\treturn x < 0 || y < 0 || x >= (int)field[0].size() || y >= (int)field.size();\n}\n\nbool dfs(int idx, int c = 0) {\n\tif(color[idx] != -1) return color[idx] == c;\n\tcolor[idx] = c;\n\n\tconst int d = futons[idx].d - 'x';\n\tfor(int i = 0; i < 2; ++i) {\n\t\tfor(int j = 0; j < 3; ++j) {\n\t\t\tconst int nx = futons[idx].x + dx[i][d][j];\n\t\t\tconst int ny = futons[idx].y + dy[i][d][j];\n\t\t\tif(out(nx, ny)) continue;\n\n\t\t\tif(field[ny][nx] != -1) {\n\t\t\t\tint next_c = (c ^ i);\n\t\t\t\tint next_idx = field[ny][nx];\n\t\t\t\tif(!(next_idx & LEFT_BOTTOM)) next_c = !next_c;\n\t\t\t\telse next_idx &= ~LEFT_BOTTOM;\n\n\t\t\t\tif(!dfs(next_idx, next_c)) return false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tfutons.assign(n, futon());\n\t\tvector<int> xs, ys;\n\t\txs.reserve(n + n + 2);\n\t\tys.reserve(n + n + 2);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> futons[i];\n\t\t\txs.emplace_back(futons[i].x);\n\t\t\tys.emplace_back(futons[i].y);\n\t\t\tif(futons[i].d == 'x') xs.emplace_back(futons[i].x + 1);\n\t\t\telse ys.emplace_back(futons[i].y + 1);\n\t\t}\n\n\t\tsort(xs.begin(), xs.end());\n\t\tsort(ys.begin(), ys.end());\n\t\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\t\tys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfutons[i].x = lower_bound(xs.begin(), xs.end(), futons[i].x) - xs.begin();\n\t\t\tfutons[i].y = lower_bound(ys.begin(), ys.end(), futons[i].y) - ys.begin();\n\t\t}\n\n\t\tfield.assign(ys.size(), vector<int>(xs.size(), -1));\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfield[futons[i].y][futons[i].x] = (i | LEFT_BOTTOM);\n\t\t\tif(futons[i].d == 'x') field[futons[i].y][futons[i].x + 1] = i;\n\t\t\telse field[futons[i].y + 1][futons[i].x] = i;\n\t\t}\n\n\t\tcolor.assign(n, -1);\n\t\tstring ans = \"Yes\";\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tif(color[i] == -1 && !dfs(i)) {\n\t\t\t\tans = \"No\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define MAX 1000\n#define F_MAX 2000\n\nint n;\nint field[MAX][MAX];\n\nstruct futon{\n\tint x[2], y[2];\n};\n\nfuton F[F_MAX];\n\nint dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nbool dfs( int pos ){\n\tif( pos == n ) return true;\n\tbool rep = false;\n\tfor( int i = 0; i < 2; i++ ){\n\t\tint legx, legy, headx, heady;\n\t\tlegx = F[pos].x[i];\n\t\tlegy = F[pos].y[i];\n\t\theadx = F[pos].x[1-i];\n\t\theady = F[pos].y[1-i];\n\t\t//cout << \"----\" << pos << \"------\" << endl;\n\t\t//cout << legx << \" \" << legy << \" \" << headx << \" \" << heady << endl;\n\t\tbool ok = true;\n\t\tfor( int j = 0; j < 4; j++ ){\n\t\t\tif( (0 <= legx+dx[j] && legx+dx[j] < MAX) && (0 <= legy+dy[j] && legy+dy[j] < MAX) ){\n\t\t\t\tif( field[legx+dx[j]][legy+dy[j]] == 1 ) ok = false;\n\t\t\t}\n\t\t\tif( (0 <= headx+dx[j] && headx+dx[j] < MAX) && (0 <= heady+dy[j] && heady+dy[j] < MAX) ){\n\t\t\t\tif( field[headx+dx[j]][heady+dy[j]] == 2 ) ok = false;\n\t\t\t}\n\t\t}\n\t\tif( !ok ) continue;\n\t\tfield[headx][heady] = 1;\n\t\tfield[legx][legy] = 2;\n\t\tif( dfs(pos+1) ) rep = true;\n\t\tfield[headx][heady] = 0;\n\t\tfield[legx][legy] = 0;\n\t}\n\treturn rep;\n}\n\nint main(){\n\twhile( cin >> n, n ){\n\t\tfor( int i = 0; i < n; i++ ){\n\t\t\tint x, y;\n\t\t\tchar d;\n\t\t\tcin >> x >> y >> d;\n\t\t\tF[i].x[0] = x;\n\t\t\tF[i].y[0] = y;\n\t\t\tF[i].x[1] = (d == 'x') ? x+1 : x;\n\t\t\tF[i].y[1] = (d == 'x') ? y : y+1;\n\t\t}\n\t\tfor( int j = 0; j < MAX; j++ ){\n\t\t\tfor( int k = 0; k < MAX; k++ ){\n\t\t\t\tfield[j][k] = 0;\n\t\t\t}\n\t\t}\n\t\t/*for( int i = 0; i < n; i++ ){\n\t\t\tfor( int j = 0; j < 2; j++ ){\n\t\t\t\tcout << F[i].x[j] << \" \" << F[i].y[j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tif( dfs(0) ) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define MAX 10000\n#define F_MAX 20000\n\nint n;\nint field[MAX][MAX];\n\nstruct futon{\n\tint x[2], y[2];\n};\n\nfuton F[F_MAX];\n\nint dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nbool dfs( int pos ){\n\tif( pos == n ) return true;\n\tbool rep = false;\n\tfor( int i = 0; i < 2; i++ ){\n\t\tint legx, legy, headx, heady;\n\t\tlegx = F[pos].x[i];\n\t\tlegy = F[pos].y[i];\n\t\theadx = F[pos].x[1-i];\n\t\theady = F[pos].y[1-i];\n\t\t//cout << \"----\" << pos << \"------\" << endl;\n\t\t//cout << legx << \" \" << legy << \" \" << headx << \" \" << heady << endl;\n\t\tbool ok = true;\n\t\tfor( int j = 0; j < 4; j++ ){\n\t\t\tif( (0 <= legx+dx[j] && legx+dx[j] < MAX) && (0 <= legy+dy[j] && legy+dy[j] < MAX) ){\n\t\t\t\tif( field[legx+dx[j]][legy+dy[j]] == 1 ) ok = false;\n\t\t\t}\n\t\t\tif( (0 <= headx+dx[j] && headx+dx[j] < MAX) && (0 <= heady+dy[j] && heady+dy[j] < MAX) ){\n\t\t\t\tif( field[headx+dx[j]][heady+dy[j]] == 2 ) ok = false;\n\t\t\t}\n\t\t}\n\t\tif( !ok ) continue;\n\t\tfield[headx][heady] = 1;\n\t\tfield[legx][legy] = 2;\n\t\tif( dfs(pos+1) ) rep = true;\n\t\tfield[headx][heady] = 0;\n\t\tfield[legx][legy] = 0;\n\t}\n\treturn rep;\n}\n\nint main(){\n\twhile( cin >> n, n ){\n\t\tfor( int i = 0; i < n; i++ ){\n\t\t\tint x, y;\n\t\t\tchar d;\n\t\t\tcin >> x >> y >> d;\n\t\t\tF[i].x[0] = x;\n\t\t\tF[i].y[0] = y;\n\t\t\tF[i].x[1] = (d == 'x') ? x+1 : x;\n\t\t\tF[i].y[1] = (d == 'x') ? y : y+1;\n\t\t}\n\t\tfor( int j = 0; j < MAX; j++ ){\n\t\t\tfor( int k = 0; k < MAX; k++ ){\n\t\t\t\tfield[j][k] = 0;\n\t\t\t}\n\t\t}\n\t\t/*for( int i = 0; i < n; i++ ){\n\t\t\tfor( int j = 0; j < 2; j++ ){\n\t\t\t\tcout << F[i].x[j] << \" \" << F[i].y[j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tif( dfs(0) ) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define iss istringstream\n#define sst stringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint n,dx[]={1,0,-1,0},dy[]={0,1,0,-1},e,s;\nchar d;\nstruct F{int x,y,xx,yy,w;}f[20010];\nmap<pi,int> M,N;\nstack<int> S;\n\nint main(){\n\twhile(cin>>n&&n){\n\t\trep(i,n)f[i].w=0;\n\t\tM.clear(),N.clear();\n\t\trep(i,n)cin>>f[i].x>>f[i].y>>d,\n\t\tf[i].xx=f[i].x+dx[d=='y'],f[i].yy=f[i].y+dy[d=='y'],\n\t\tM[pi(f[i].x,f[i].y)]=M[pi(f[i].xx,f[i].yy)]=i,\n\t\tN[pi(f[i].x,f[i].y)]=N[pi(f[i].xx,f[i].yy)]=-1;\n\t\te=0;\n\t\trep(i,n)if(!f[i].w){\n\t\t\ts=1;\n\t\t\tstack<int> S;\n\t\t\tS.push(i);\n\t\t\twhile(S.sz){\n\t\t\t\tint i=S.top();S.pop();\n\t\t\t\tF& c=f[i];\n\t\t\t\tif(c.w)continue;\n\t\t\t\tif(s==1){\n\t\t\t\t\tc.w=1,s=0;\n\t\t\t\t\tN[pi(c.x,c.y)]=1,N[pi(c.xx,c.yy)]=2;\n\t\t\t\t}else{\n\t\t\t\t\tint OK=0;\n\t\t\t\t\trep2(i,1,3){\n\t\t\t\t\t\tint ok=1;\n\t\t\t\t\t\trep(j,4){\n\t\t\t\t\t\t\tint nx=c.x+dx[j],ny=c.y+dy[j];\n\t\t\t\t\t\t\tif(N[pi(nx,ny)]==3-i)ok=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trep(j,4){\n\t\t\t\t\t\t\tint nx=c.xx+dx[j],ny=c.yy+dy[j];\n\t\t\t\t\t\t\tif(N[pi(nx,ny)]==i)ok=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(ok){\n\t\t\t\t\t\t\tc.w=i;\n\t\t\t\t\t\t\tN[pi(c.x,c.y)]=i,N[pi(c.xx,c.yy)]=3-i;\n\t\t\t\t\t\t\tOK=1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!OK){e=1;break;}\n\t\t\t\t}\n\t\t\t\trep(i,4){\n\t\t\t\t\tint nx=c.x+dx[i],ny=c.y+dy[i];\n\t\t\t\t\tif(N[pi(nx,ny)]==-1)S.push(M[pi(nx,ny)]);\n\t\t\t\t\tnx=c.xx+dx[i],ny=c.yy+dy[i];\n\t\t\t\t\tif(N[pi(nx,ny)]==-1)S.push(M[pi(nx,ny)]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<(e?\"No\":\"Yes\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\n\ntypedef vector<pii> vp;\n\nbool dfs(map<pii,vp>& g,map<pii,vi>& type,map<pii,int>& hf,pii cur,int cur_hf){\n\thf[cur]=cur_hf;\n\tbool ret=true;\n\tREP(i,g[cur].size()){\n\t\tpii next=g[cur][i];\n\t\tint next_hf=(cur_hf+type[cur][i])%2;\n\t\tif(hf[next]==-1){\n\t\t\tret&=dfs(g,type,hf,next,next_hf);\n\t\t}else if(hf[next]==next_hf){\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tmap<pii,vp> g;\n\t\tmap<pii,vi> type;\n\t\tmap<pii,int> hf;\n\t\tREP(i,n){\n\t\t\tint x,y;\n\t\t\tchar d;\n\t\t\tcin>>x>>y>>d;\n\t\t\tint dir=(d=='x'?2:3);\n\t\t\tpii c=make_pair(y,x);\n\t\t\tpii n=make_pair(y+dy[dir],x+dx[dir]);\n\n\t\t\tg[c]=vp();\n\t\t\ttype[c]=vi();\n\t\t\tg[c].push_back(n);\n\t\t\ttype[c].push_back(1);\n\t\t\thf[c]=-1;\n\n\t\t\tg[n]=vp();\n\t\t\ttype[n]=vi();\n\t\t\tg[n].push_back(c);\n\t\t\ttype[n].push_back(1);\n\t\t\thf[n]=-1;\n\n\t\t\tREP(j,2){\n\t\t\t\tREP(k,4){\n\t\t\t\t\tpii base=(j==0?c:n);\n\t\t\t\t\tpii neighbor=make_pair(base.first+dy[k],base.second+dx[k]);\n\t\t\t\t\tif(EXIST(g,neighbor)&&find(ALL(g[base]),neighbor)==g[base].end()){\n\t\t\t\t\t\tg[base].push_back(neighbor);\n\t\t\t\t\t\ttype[base].push_back(0);\n\t\t\t\t\t\tg[neighbor].push_back(base);\n\t\t\t\t\t\ttype[neighbor].push_back(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool ok=true;\n\t\tfor(map<pii,vp>::iterator it=g.begin();it!=g.end();it++){\n\t\t\tif(hf[(*it).first]==-1){\n\t\t\t\tok&=dfs(g,type,hf,(*it).first,0);\n\t\t\t}\n\t\t}\n\t\tcout<<(ok?\"Yes\":\"No\")<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n;\n\twhile (cin >> n,n) {\n\t\tmap<pii, pii> futon;\n\t\tREP(i, n) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tchar c;\n\t\t\tcin >> x1 >> y1 >> c;\n\t\t\tx2 = x1;\n\t\t\ty2 = y1;\n\t\t\tif (c == 'x')\n\t\t\t\tx2++;\n\t\t\telse\n\t\t\t\ty2++;\n\t\t\tfuton[{x1, y1}] = { x2,y2 };\n\t\t\tfuton[{x2, y2}] = { x1, y1 };\n\t\t}\n\t\tstring ans = \"Yes\";\n\t\tmap<pii, bool> asi;\n\t\tauto it = futon.begin();\n\t\twhile (it != futon.end()) {\n\t\t\tif (asi.find(it->first) == asi.end()) {\n\t\t\t\tasi[it->first] = true;\n\t\t\t\tasi[it->second] = false;\n\t\t\t\tqueue<pii> Q;\n\t\t\t\tQ.push(it->first);\n\t\t\t\tqueue<pii> Q2;\n\t\t\t\tQ2.push(it->second);\n\t\t\t\twhile (!Q.empty() || !Q2.empty()) {\n\t\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\t\tpii q = Q.front();Q.pop();\n\t\t\t\t\t\tREP(i, 4) {\n\t\t\t\t\t\t\tpii nq;\n\t\t\t\t\t\t\tnq.first = q.first + dx[i];\n\t\t\t\t\t\t\tnq.second = q.second + dy[i];\n\t\t\t\t\t\t\tif (futon.find(nq) != futon.end()) {\n\t\t\t\t\t\t\t\tif (asi.find(nq) == asi.end()) {\n\t\t\t\t\t\t\t\t\tasi[nq] = true;\n\t\t\t\t\t\t\t\t\tasi[futon[nq]] = false;\n\t\t\t\t\t\t\t\t\tQ.push(nq);\n\t\t\t\t\t\t\t\t\tQ2.push(futon[nq]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tif (asi[q] != asi[nq]&&nq!=futon[q]) {\n\t\t\t\t\t\t\t\t\t\tans = \"No\";\n\t\t\t\t\t\t\t\t\t\tgoto res;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile (!Q2.empty()) {\n\t\t\t\t\t\tpii q = Q2.front();Q2.pop();\n\t\t\t\t\t\tREP(i, 4) {\n\t\t\t\t\t\t\tpii nq;\n\t\t\t\t\t\t\tnq.first = q.first + dx[i];\n\t\t\t\t\t\t\tnq.second = q.second + dy[i];\n\t\t\t\t\t\t\tif (futon.find(nq) != futon.end()) {\n\t\t\t\t\t\t\t\tif (asi.find(nq) == asi.end()) {\n\t\t\t\t\t\t\t\t\tasi[nq] = false;\n\t\t\t\t\t\t\t\t\tasi[futon[nq]] = true;\n\t\t\t\t\t\t\t\t\tQ2.push(nq);\n\t\t\t\t\t\t\t\t\tQ.push(futon[nq]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tif (asi[q] != asi[nq] && nq != futon[q]) {\n\t\t\t\t\t\t\t\t\t\tans = \"No\";\n\t\t\t\t\t\t\t\t\t\tgoto res;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tit++;\n\t\t}\n\tres:\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint N;\nmap<P,P> fie;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nbool solve(int x,int y){\n  P now = fie[P(x,y)];\n  //cout << x << \" \" << y << \" \" << now.first << \" \"<< now.second << endl;\n  for(int i=0;i<4;i++){\n    if( fie.count(P(x+dx[i],y+dy[i])) == 0 ) continue;\n    P &st = fie[P(x+dx[i],y+dy[i])];\n    if( st.first == now.first ){\n      if( st.second == 0 ){\n        st.second = now.second==1?2:1;    \n        if( !solve(x+dx[i],y+dy[i]) ) return false;\n      }\n      else if( st.second == now.second )\n        return false;\n    }\n  }\n\n  for(int i=0;i<4;i++){\n    if( fie.count(P(x+dx[i],y+dy[i])) == 0 ) continue;\n    P &st = fie[P(x+dx[i],y+dy[i])];\n    if( st.first != now.first ){\n      if( st.second == 0 ){\n        st.second = now.second == 1?1:2;\n        if( !solve(x+dx[i],y+dy[i]) ) return false;\n      } else if( st.second != now.second ){\n        return false;\n      } \n    }\n  }\n  return true;\n}\n\nint main(){\n  while( cin >> N && N){\n    fie.clear();\n    for(int i=0;i<N;i++){\n      int x,y;char c;\n      cin >> x >> y >> c;\n      if( c == 'y' ){\n        fie[P(x,y)] = P(i,0);\n        fie[P(x+1,y)] = P(i,0);\n      } else {\n        fie[P(x,y)] = P(i,0);\n        fie[P(x,y+1)] = P(i,0);\n      }\n    }\n\n\n    bool f = true;\n    for(map<P,P>::iterator it = fie.begin(); it != fie.end(); it++){\n      int x = it->first.first;\n      int y = it->first.second;\n  \n      if( it->second.second == 0 ){\n        it->second.second = 1;\n        if( !solve(x,y) ) {\n          f = false;\n          //cout << x << \" \"<< y <<\" \"<<it->second.first << \" \"<<it->second.second<< endl;\n          break;\n        }\n      }\n      //      cout << x << \" \"<< y <<\" \"<<it->second.first << \" \"<<it->second.second<< endl;\n    }\n    if( f ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef pair< int, int > pii;\ntypedef pair< pii, pii > ppii;\n\nconst int dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\nint n, x[20020], y[20020], visit[20020][2];\nchar dir[20020];\npii pos[40040], ids[40040];\n\nint xadd(int i) { return dir[i] == 'x' ? 1 : 0; }\nint yadd(int i) { return dir[i] == 'y' ? 1 : 0; }\n\nbool rec(int i, int j, int v) {\n\tbool res = 1;\n\t\n\tif (visit[i][j] < 0) {\n\t\tvisit[i][j] = v;\n\t\tvisit[i][j ^ 1] = v ^ 1;\n\t\t\n\t\tint nx = x[i] + (j ? 0 : xadd(i)), ny = y[i] + (j ? 0 : yadd(i));\n\t\tfor_(d,0,4) {\n\t\t\tpii nxp(nx + dx[d], ny + dy[d]);\n\t\t\tif (binary_search(pos, pos + 2*n, nxp)) {\n\t\t\t\tint k = lower_bound(pos, pos + 2*n, nxp) - pos;\n\t\t\t\tif (k < 2*n && ids[k].second != i) res &= rec(ids[k].second, ids[k].first, v ^ 1);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tres = (visit[i][j] == v);\n\t}\n\t\n\treturn res;\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tvector< ppii > vp;\n\t\t\n\t\tfor_(i,0,n) {\n\t\t\tcin >> x[i] >> y[i] >> dir[i];\n\t\t\tvp.push_back(ppii(pii(x[i], y[i]), pii(0, i)));\n\t\t\tvp.push_back(ppii(pii(x[i] + xadd(i), y[i] + yadd(i)), pii(1, i)));\n\t\t}\n\t\t\n\t\tsort(vp.begin(), vp.end());\n\t\t\n\t\tfor_(i,0,2*n) {\n\t\t\tpos[i] = vp[i].first;\n\t\t\tids[i] = vp[i].second;\n\t\t}\n\t\t\n\t\tmemset(visit, -1, sizeof(visit));\n\t\t\n\t\tbool ok = 1;\n\t\tfor_(i,0,n && ok) if (visit[i][0] < 0) if (!rec(i, 0, 0)) ok = rec(i, 0, 1);\t\t\n\t\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<map>\n#include<algorithm>\n\n#define all(a) (a).begin(),(a).end()\n#define N 100000\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n,V;\nint x[20100],y[20100];\nchar d;\nvector<P> f;\n\nvector<int> g[N];\nint match[N];\nbool used[N];\n\nvoid add_edge(int u,int v){\n  g[u].push_back(v);\n  g[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i=0;i<g[v].size();i++){\n    int u = g[v][i], w = match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bimatch(){\n  int res = 0;\n  memset(match,-1,sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v] < 0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0); std::ios::sync_with_stdio(false);\n\n  while(cin >> n,n){\n    for(int i=0;i<n;i++){\n      cin >> x[i] >> y[i] >> d;\n      if(d=='x'){\n\tf.push_back(P(x[i]+1,y[i]));\n\tf.push_back(P(x[i]-1,y[i]));\n      }else{\n\tf.push_back(P(x[i],y[i]+1));\n\tf.push_back(P(x[i],y[i]-1));\n      }\n    }\n\n    sort(all(f));\n    f.erase(unique(all(f)),f.end());\n    \n    V = 3*n;\n    for(int i=0;i<V;i++)g[i].clear();\n    \n    for(int i=0;i<f.size();i++){\n      int cnt = 0; int tmp;\n      for(int j=0;j<n;j++){\n\tif( abs(f[i].first-x[j]) + abs(f[i].second-y[j]) == 1){\n\t  cnt++; tmp = j;\n\t}\n      }\n      if(cnt==1)add_edge(tmp,n+i);\n    }\n    \n    cout << ((bimatch()==n)?\"Yes\":\"No\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair< int, int > Pi;\nconst int vy[] = {0, 1, 0, -1}, vx[] = {1, 0, -1, 0};\n  \n  \nmap< Pi, Pi > futon;\nmap< Pi, int > head;\n  \nbool check(const Pi& point)\n{\n  head[point] = 1;\n  head[futon[point]] = -1;\n  bool flag = true;\n  for(int i = 0; i < 4 && flag; i++) {\n    const int nx = point.first + vx[i], ny = point.second + vy[i];\n    if(make_pair(nx, ny) == futon[point]) continue;\n    if(head.find({nx, ny}) != head.end()) {\n      if(head[{nx, ny}] == -1) flag = false;\n    } else if(futon.find({nx, ny}) != futon.end()) {\n      if(!check({nx, ny})) flag = false;\n    }\n  }\n  return(flag);\n}\n  \nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    while(N--) {\n      int x, y;\n      char dir;\n      cin >> x >> y >> dir;\n      if(dir == 'x') {\n        futon[{x, y}] = {x + 1, y};\n        futon[{x + 1, y}] = {x, y};\n      } else {\n        futon[{x, y}] = {x, y + 1};\n        futon[{x, y + 1}] = {x, y};\n      }\n    }\n    while(!futon.empty()) {\n      auto decide = *futon.begin();\n      if(head.find(decide.first) == head.end()) {\n        if(!check(decide.first)) break;\n      }\n      futon.erase(futon.begin());\n    }\n    if(futon.empty()) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  \n    head.clear();\n    futon.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n#define NUM 20000\n#define HEAD MOD\n#define FOOT MOD+1\n\ntypedef pair<int,int> Point;\n\nenum Type{\n\tTATE,\n\tYOKO,\n};\n\nstruct Info{\n\tint row,col;\n\tType dir;\n};\n\nstruct Data{\n\tData(int arg_row,int arg_col,int arg_index,int arg_which){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tindex = arg_index;\n\t\twhich = arg_which;\n\t}\n\n\tint row,col,index,which;\n};\n\n\nmap<Point,int> MAP;\nInfo info[NUM];\nvector<int> Group[NUM];\n\nint near_row[4] = {1,0,0,-1},near_col[4] = {0,-1,1,0};\nint diff_row[2][6] = {{2,1,1,0,0,-1},{-1,-1,0,0,1,1}},diff_col[2][6] = {{0,-1,1,-1,1,0},{0,1,-1,2,0,1}};\n\nint N;\nint boss[NUM],height[NUM];\n\nint get_boss(int id){\n\tif(boss[id] == id)return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tint boss_x = get_boss(x);\n\tint boss_y = get_boss(y);\n\n\tif(boss_x == boss_y)return;\n\n\t//高さが高い方に吸収する\n\tif(height[x] > height[y]){\n\n\t\tboss[boss_y] = boss_x;\n\n\t}else if(height[x] < height[y]){\n\n\t\tboss[boss_x] = boss_y;\n\n\t}else{ //height[x] == height[y]\n\n\t\tboss[boss_y] = boss_x;\n\t\theight[x]++;\n\t}\n}\n\nvoid init(){\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nbool check(int group_id){\n\n\tmap<Point,int> ROOM;\n\tqueue<Data> Q;\n\n\tROOM[Point(info[group_id].row,info[group_id].col)] = HEAD;\n\tQ.push(Data(info[group_id].row,info[group_id].col,group_id,HEAD));\n\n\tbool FLG = true;\n\n\tint adj_row,adj_col,adj_index;\n\n\twhile(!Q.empty()){\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tadj_row = Q.front().row+near_row[i];\n\t\t\tadj_col = Q.front().col+near_col[i];\n\n\t\t\tauto at = MAP.find(Point(adj_row,adj_col));\n\t\t\tif(at == MAP.end())continue;\n\n\t\t\tadj_index = MAP[Point(adj_row,adj_col)];\n\n\t\t\tif(adj_index != Q.front().index){\n\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,HEAD));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,FOOT));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif((ROOM[Point(adj_row,adj_col)] == FOOT && Q.front().which == HEAD) ||\n\t\t\t\t\t\t\t(ROOM[Point(adj_row,adj_col)] == HEAD && Q.front().which == FOOT)){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,FOOT));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,HEAD));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(ROOM[Point(adj_row,adj_col)] == Q.front().which){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG)break;\n\n\t\tQ.pop();\n\t}\n\n\tif(FLG)return true;\n\n\n\tFLG = true;\n\tROOM.clear();\n\n\tROOM[Point(info[group_id].row,info[group_id].col)] = FOOT;\n\tQ.push(Data(info[group_id].row,info[group_id].col,group_id,FOOT));\n\n\twhile(!Q.empty()){\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tadj_row = Q.front().row+near_row[i];\n\t\t\tadj_col = Q.front().col+near_col[i];\n\n\t\t\tauto at = MAP.find(Point(adj_row,adj_col));\n\t\t\tif(at == MAP.end())continue;\n\n\t\t\tadj_index = MAP[Point(adj_row,adj_col)];\n\n\t\t\tif(adj_index != Q.front().index){\n\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,HEAD));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,adj_index,FOOT));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif((ROOM[Point(adj_row,adj_col)] == FOOT && Q.front().which == HEAD) ||\n\t\t\t\t\t\t\t(ROOM[Point(adj_row,adj_col)] == HEAD && Q.front().which == FOOT)){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{\n\t\t\t\tat = ROOM.find(Point(adj_row,adj_col));\n\n\t\t\t\tif(at == ROOM.end()){\n\t\t\t\t\tif(Q.front().which == HEAD){\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = FOOT;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,FOOT));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tROOM[Point(adj_row,adj_col)] = HEAD;\n\t\t\t\t\t\tQ.push(Data(adj_row,adj_col,Q.front().index,HEAD));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(ROOM[Point(adj_row,adj_col)] == Q.front().which){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(!FLG)break;\n\n\t\tQ.pop();\n\t}\n\n\n\treturn FLG;\n}\n\nvoid func(){\n\n\tMAP.clear();\n\tfor(int i = 0; i < N; i++)Group[i].clear();\n\n\tinit();\n\n\tchar buf[2];\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %s\",&info[i].col,&info[i].row,buf);\n\t\tif(buf[0] == 'x'){\n\t\t\tinfo[i].dir = YOKO;\n\t\t}else{\n\t\t\tinfo[i].dir = TATE;\n\t\t}\n\t\tMAP[Point(info[i].row,info[i].col)] = i;\n\t\tif(info[i].dir == YOKO){\n\t\t\tMAP[Point(info[i].row,info[i].col+1)] = i;\n\t\t}else{\n\t\t\tMAP[Point(info[i].row+1,info[i].col)] = i;\n\t\t}\n\t}\n\n\tint adj_row,adj_col;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < 6; k++){\n\t\t\tadj_row = info[i].row+diff_row[info[i].dir][k];\n\t\t\tadj_col = info[i].col+diff_col[info[i].dir][k];\n\n\t\t\tauto at = MAP.find(Point(adj_row,adj_col));\n\t\t\tif(at == MAP.end())continue;\n\n\t\t\tunite(i,MAP[Point(adj_row,adj_col)]);\n\t\t}\n\t}\n\n\tvector<int> BOSS;\n\tfor(int i = 0; i < N; i++){\n\t\tGroup[get_boss(i)].push_back(i);\n\t\tif(boss[i] == i){\n\t\t\tBOSS.push_back(i);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < BOSS.size(); i++){\n\t\tif(check(BOSS[i]) == false){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tprintf(\"Yes\\n\");\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int,int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tmap<P, int> mp;\n\t\tpair<P,P> a[20001] = {};\n\t\trep1(i, n) {\n\t\t\tint x, y; char t;\n\t\t\tcin >> x >> y >> t;\n\t\t\tmp[{x, y}] = i;\n\t\t\ta[i].first = { x,y };\n\t\t\tif (t == 'x') {\n\t\t\t\tmp[{x + 1, y}] = i;\n\t\t\t\ta[i].second = { x + 1,y };\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmp[{x, y + 1}] = i;\n\t\t\t\ta[i].second = { x,y + 1 };\n\t\t\t}\n\t\t}\n\t\tint used[20001] = {};\n\t\tbool f = true;\n\t\trep1(i, n) {\n\t\t\tif (used[i])continue;\n\t\t\tqueue<int> q;\n\t\t\tq.push(i);\n\t\t\tused[i] = 1;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tint now = q.front(); q.pop();\n\t\t\t\tint x = a[now].first.first;\n\t\t\t\tint y = a[now].first.second;\n\t\t\t\tint z = used[now];\n    \t\t\trep(k, 4) {\n\t\t\t\t\tint nx = x + dx[k]; int ny = y + dy[k];\n\t\t\t\t\tif (now == mp[{nx, ny}])continue;\n\t\t\t\t\tint num = mp[{nx, ny}];\n\t\t\t\t\tif (num>0) {\n\t\t\t\t\t\tif (a[num].first == P{nx, ny}) {\n\t\t\t\t\t\t\tif (used[num] > 0 && used[num] != z) {\n\t\t\t\t\t\t\t\tf = false; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(used[num]==0){\n\t\t\t\t\t\t\t\tused[num] = z; q.push(num);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (used[num] > 0 && used[num] != 3-z) {\n\t\t\t\t\t\t\t\tf = false; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (used[num] == 0) {\n\t\t\t\t\t\t\t\tused[num] = 3 - z; q.push(num);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!f)break;\n\t\t\t\tx = a[now].second.first;\n\t\t\t\ty = a[now].second.second;\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tint nx = x + dx[k]; int ny = y + dy[k];\n\t\t\t\t\tif (now == mp[{nx, ny}])continue;\n\t\t\t\t\tint num = mp[{nx, ny}];\n\t\t\t\t\tif (num>0) {\n\t\t\t\t\t\tif (a[num].first == P{ nx, ny }) {\n\t\t\t\t\t\t\tif (used[num] > 0 && used[num] != 3-z) {\n\t\t\t\t\t\t\t\tf = false; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (used[num] == 0) {\n\t\t\t\t\t\t\t\tused[num] = 3 - z; q.push(num);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (used[num] > 0 && used[num] != z) {\n\t\t\t\t\t\t\t\tf = false; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (used[num] == 0) {\n\t\t\t\t\t\t\t\tused[num] = z; q.push(num);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f)break;\n\t\t}\n\t\tif (f)cout << \"Yes\" << endl;\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<vector>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct Point{\n\tint x,y;\n\tbool operator<(const Point &p)const{ return make_pair(x,y)<make_pair(p.x,p.y); }\n};\n\ntypedef pair<Point,Point> Futon;\n\nint n,mark[40000];\nvector<int> adj[40000];\n\nbool issame(int u,int v){ return abs(u-v)==n; }\n\nbool dfs(int u){\n\trep(i,adj[u].size()){\n\t\tint v=adj[u][i];\n\t\tif(mark[v]==-1){\n\t\t\tif(issame(u,v)) mark[v]=1-mark[u];\n\t\t\telse            mark[v]=mark[u];\n\t\t\tif(!dfs(v)) return false;\n\t\t}\n\t\telse{\n\t\t\tif(!issame(u,v) && mark[u]!=mark[v]\n\t\t\t||  issame(u,v) && mark[u]==mark[v]) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tPoint futon[40000];\n\t\tmap<Point,int> f;\n\t\trep(j,n){\n\t\t\tint x,y;\n\t\t\tchar dir; scanf(\"%d%d %c\",&x,&y,&dir);\n\n\t\t\tfuton[j]=(Point){x,y};\n\t\t\tif(dir=='x') futon[n+j]=(Point){x+1,y};\n\t\t\tif(dir=='y') futon[n+j]=(Point){x,y+1};\n\n\t\t\tf[futon[ j ]]=j;\n\t\t\tf[futon[n+j]]=n+j;\n\t\t}\n\n\t\trep(u,2*n){\n\t\t\tadj[u].clear();\n\t\t\trep(k,4){\n\t\t\t\tint x=futon[u].x+dx[k];\n\t\t\t\tint y=futon[u].y+dy[k];\n\t\t\t\tPoint p={x,y};\n\t\t\t\tif(f.count(p)) adj[u].push_back(f[p]);\n\t\t\t}\n\t\t}\n\n\t\tbool ok=true;\n\t\trep(u,2*n) mark[u]=-1;\n\t\trep(u,2*n) if(mark[u]==-1) {\n\t\t\tmark[u]=0;\n\t\t\tif(!dfs(u)){ ok=false; break; }\n\t\t}\n\n\t\tputs(ok?\"Yes\":\"No\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\n#include \"bits/stdc++.h\"\nstruct UnionFind {\n\tstd::vector<int> par;\n\tstd::vector<int> sizes;\n\n\tUnionFind(int n) {\n\t\tpar.resize(n);\n\t\tsizes.resize(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tpar[i] = i;\n\t\t\tsizes[i] = 1;\n\t\t}\n\t}\n\n\tint root(int a) {\n\t\treturn par[a] == a ? a : par[a] = root(par[a]);\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y)return;\n\t\tif (sizes[x] < sizes[y]) std::swap(x, y);\n\n\t\tpar[y] = x;\n\t\tsizes[x] += sizes[y];\n\t}\n\tint size(int x) {\n\t\treturn sizes[root(x)];\n\t}\n};\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tint m = 2 * n;\n\t\tvector<pair<pii, int>> v;\n\n\t\tvvi g(m);\n\n\t\tREP(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tchar c; cin >> c;\n\t\t\tpii a = { x,y }, b = a;\n\t\t\tif (c == 'x') {\n\t\t\t\tb.first++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tb.second++;\n\t\t\t}\n\t\t\tv.push_back({ a,2 * i });\n\t\t\tv.push_back({ b,2 * i + 1 });\n\t\t}\n\t\tvi c(m, -1);\n\t\tsort(ALL(v));\n\t\tREP(i, m - 1) {\n\t\t\tif (v[i].first.first == v[i + 1].first.first && v[i].first.second + 1 == v[i + 1].first.second) {\n\t\t\t\tg[v[i].second].push_back(v[i + 1].second);\n\t\t\t\tg[v[i + 1].second].push_back(v[i].second);\n\t\t\t}\n\t\t}\n\t\tsort(ALL(v), [&](auto a, auto b) {if (a.first.second == b.first.second)return a.first.first < b.first.first; return a.first.second < b.first.second; });\n\t\tREP(i, m - 1) {\n\t\t\tif (v[i].first.first + 1 == v[i + 1].first.first && v[i].first.second == v[i + 1].first.second) {\n\t\t\t\tg[v[i].second].push_back(v[i + 1].second);\n\t\t\t\tg[v[i + 1].second].push_back(v[i].second);\n\t\t\t}\n\t\t}\n\t\tREP(i, m) {\n\t\t\tsort(ALL(g[i]));\n\t\t\tUNIQUE(g[i]);\n\t\t}\n\t\tbool ok = true;\n\t\tqueue<int> q;\n\t\tREP(i, m) {\n\t\t\tif (c[i] != -1)continue;\n\t\t\tq.push(i);\n\t\t\tc[i] = 0;\n\n\t\t\twhile (!q.empty()) {\n\t\t\t\tint p = q.front(); q.pop();\n\t\t\t\tREP(i, g[p].size()) {\n\t\t\t\t\tif (c[g[p][i]] != -1) {\n\t\t\t\t\t\tif (p & 1 && g[p][i] == p - 1) {\n\t\t\t\t\t\t\tif (c[p] == c[g[p][i]])ok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (p % 2 == 0 && g[p][i] == p + 1) {\n\t\t\t\t\t\t\tif (c[p] == c[g[p][i]])ok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (c[p] != c[g[p][i]])ok = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (p & 1 && g[p][i] == p - 1) {\n\t\t\t\t\t\t\tc[g[p][i]] = 1 - c[p];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (p % 2 == 0 && g[p][i] == p + 1) {\n\t\t\t\t\t\t\tc[g[p][i]] = 1 - c[p];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tc[g[p][i]] = c[p];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.push(g[p][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint N;\nmap<P,P> fie;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nbool solve(int x,int y){\n  P now = fie[P(x,y)];\n  // cout << x << \" \" << y << \" \" << now.first << \" \"<< now.second << endl;\n  int dr[4]={};\n  for(int i=0;i<4;i++){\n    if( fie.count(P(x+dx[i],y+dy[i])) == 0 ) continue;\n    P &st = fie[P(x+dx[i],y+dy[i])];\n    if( st.first == now.first ){\n      if( st.second == 0 ){\n        st.second = now.second==1?2:1;    \n        dr[i] = 1;\n      }\n      else if( st.second == now.second )\n        return false;\n    } else {\n      if( st.second == 0 ){\n        st.second = now.second == 1?1:2;        \n        dr[i] = 1;\n      } else if( st.second != now.second )\n        return false;             \n    }\n  }\n\n  for(int i=0;i<4;i++)\n    if( dr[i] == 1 )\n     if( !solve( x + dx[i] , y + dy[i] ) ) return false;    \n  \n  return true;\n}\n\nint main(){\n  while( cin >> N && N){\n    fie.clear();\n    bool f = true;\n    for(int i=0;i<N;i++){\n      int x,y;char c;\n      cin >> x >> y >> c;\n      if( fie.count(P(x,y)) ) f = false;\n      fie[P(x,y)] = P(i,0);\n      if( c == 'x' ){\n        if( fie.count(P(x+1,y)) ) f = false;\n        fie[P(x+1,y)] = P(i,0);\n      } else {\n        if( fie.count(P(x,y+1)) ) f = false;\n        fie[P(x,y+1)] = P(i,0);\n      }\n    }\n\n\n\n    for(map<P,P>::iterator it = fie.begin(); it != fie.end() && f; it++){\n      int x = it->first.first;\n      int y = it->first.second;\n  \n      if( it->second.second == 0 ){\n        it->second.second = 1;\n        if( !solve(x,y) ) {\n          f = false;\n          //    cout << x << \" \"<< y <<\" \"<<it->second.first << \" \"<<it->second.second<< endl;\n          break;\n        }\n      }\n      // cout << x << \" \"<< y <<\" \"<<it->second.first << \" \"<<it->second.second<< endl;\n    }\n    if( f ) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=40003;\nconst ll INF=1LL<<63;\n\nint V,cmp[MAX];\nvector<int> G[MAX],rG[MAX],vs;//vsがトポソの逆順になってる\nbool used[MAX];\n\nvoid add_edge(int from,int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid DFS(int v){\n    used[v]=1;\n    for(int i=0;i<G[v].size();i++){\n        if(used[G[v][i]]==0) DFS(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rDFS(int v,int k){\n    used[v]=1;\n    cmp[v]=k;\n    for(int i=0;i<rG[v].size();i++){\n        if(used[rG[v][i]]==0) rDFS(rG[v][i],k);\n    }\n}\n\nint scc(){\n    memset(used,0,sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++){\n        if(used[v]==0) DFS(v);\n    }\n    \n    memset(used,0,sizeof(used));\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n        if(used[vs[i]]==0) rDFS(vs[i],k++);\n    }\n    return k;\n}\n\nvoid init(int si){\n    V=2*si;\n    for(int i=0;i<V;i++){\n        G[i].clear();\n        rG[i].clear();\n    }\n}\n\nvector<int> dx={1,0,-1,0},dy={0,1,0,-1};\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N;cin>>N;\n        if(N==0) break;\n        init(N);\n        \n        map<pair<int,int>,int> MA;\n        \n        vector<int> x(N),y(N),dir(N);\n        for(int i=0;i<N;i++){\n            char c;\n            cin>>x[i]>>y[i]>>c;\n            \n            if(c=='x'){\n                dir[i]=0;\n                MA[{x[i],y[i]}]=i;\n                MA[{x[i]+1,y[i]}]=i;\n            }else{\n                dir[i]=1;\n                MA[{x[i],y[i]}]=i;\n                MA[{x[i],y[i]+1}]=i;\n            }\n        }\n        \n        for(int i=0;i<N;i++){\n            int tox,toy;\n            \n            for(int k=0;k<4;k++){\n                tox=x[i]+dx[k];toy=y[i]+dy[k];\n                \n                if(MA.count({tox,toy})&&MA[{tox,toy}]!=i){\n                    int j=MA[{tox,toy}];\n                    \n                    if(x[j]==tox&&y[j]==toy){\n                        add_edge(i,j);\n                        add_edge(i+N,j+N);\n                        \n                        //cout<<i<<\" \"<<j<<\" \"<<0<<endl;\n                    }else{\n                        add_edge(i,j+N);\n                        add_edge(i+N,j);\n                        \n                        //cout<<i<<\" \"<<j<<\" \"<<1<<endl;\n                    }\n                }\n            }\n            \n            for(int k=0;k<4;k++){\n                if(dir[i]==0){\n                    tox=x[i]+dx[k]+1;toy=y[i]+dy[k];\n                }else{\n                    tox=x[i]+dx[k];toy=y[i]+dy[k]+1;\n                }\n                \n                if(MA.count({tox,toy})&&MA[{tox,toy}]!=i){\n                    int j=MA[{tox,toy}];\n                    \n                    if(x[j]==tox&&y[j]==toy){\n                        add_edge(i,j+N);\n                        add_edge(i+N,j);\n                        \n                        //cout<<i<<\" \"<<j<<\" \"<<1<<endl;\n                    }else{\n                        add_edge(i,j);\n                        add_edge(i+N,j+N);\n                        \n                        //cout<<i<<\" \"<<j<<\" \"<<0<<endl;\n                    }\n                }\n            }\n            \n        }\n        \n        scc();\n        \n        bool ok=true;\n        \n        for(int i=0;i<N;i++){\n            if(cmp[i]==cmp[i+N]) ok=false;\n        }\n        \n        if(ok) cout<<\"Yes\"<<endl;\n        else cout<<\"No\"<<endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nint n, dp[400000], st[400000], k;\nmap<pi, int> id;\nvi x, y, d;\n\nbool rec(int cx, int cy, int cd){\n\tqueue<pair<pi, int> > q;\n\tq.push(mp(mp(cx, cy), cd));\n\tdp[st[k++] = id[mp(cx, cy)]] = cd;\n\t\n\twhile(!q.empty()){\n\t\tcx = q.front().first.first; cy = q.front().first.second;\n\t\tcd = q.front().second;\n\t\tq.pop();\n\t\t\n\t\trep(d, 4){\n\t\t\tint nx = cx + dx[d], ny = cy + dy[d];\n\t\t\tif(!id.count(mp(nx, ny))) continue;\n\t\t\tint ii = id[mp(nx, ny)];\n\t\t\tint nd = ii == (id[mp(cx, cy)] ^ 1) ? 1 - cd : cd;\n\t\t\t\n\t\t\tif(dp[ii] >= 0 && dp[ii] != nd) return 0;\n\t\t\tif(dp[ii] >= 0) continue;\n\t\t\tdp[st[k++] = ii] = nd;\n\t\t\twhile(k >= 400000);\n\t\t\tq.push(mp(mp(nx, ny), nd));\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main(){\n\twhile(scanf(\"%d\", &n), n){\n\t\tx.clear(); y.clear(); d.clear();\n\t\tid.clear();\n\t\t\n\t\trep(i, n){\n\t\t\tint a, b; char c;\n\t\t\tscanf(\"%d%d %c\", &a, &b, &c);\n\t\t\tx.pb(a); y.pb(b); d.pb(c == 'x');\n\t\t\tid[mp(a, b)] = i * 2;\n\t\t\tid[mp(a + d[i], b + 1 - d[i])] = i * 2 + 1;\n\t\t}\n\t\tmemset(dp, -1, sizeof(dp));\n\t\trep(i, 2 * n) if(dp[i] < 0){\n\t\t\tk = 0;\n\t\t\tif(rec(x[i], y[i], 0)) continue;\n\t\t\twhile(k) dp[st[--k]] = -1;\n\t\t\tif(!rec(x[i], y[i], 1)){\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\tgoto END;\n\t\t\t}\n\t\t}\n\t\tcout << \"Yes\" << endl;\n\t\tEND:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef pair<int, int> P;\ntypedef pair<P, int> Pp;\n\nconst int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n\nint n;\nmap<int, int> G[100000];\nmap<int, int> used[100000];\nmap<int, int> zipx, zipy;\nbool f = false;\n\nvoid dfs(int x, int y, int c) {\n  // cout << x << \" \" << y << \" \" << c << endl;\n  if ( f ) return;\n  int zx = zipx[x], zy = zipy[y];  \n  if ( !G[zx][zy] ) return;  \n  if ( used[zx][zy] && used[zx][zy] != c ) {    \n    f = true;\n    return;    \n  } else if ( used[zx][zy] ) {\n    return;    \n  }\n  used[zx][zy] = c;\n  int d = G[zx][zy]-1;  \n  for ( int i = 0; i < 4; i++ ) {\n    int nx = x+dx[i], ny = y+dy[i];    \n    if ( d == i ) {\n      dfs(nx, ny, 3-c);      \n    } else {\n      dfs(nx, ny, c);      \n    }\n  }\n}\n\nsigned main() {\n  while ( cin >> n, n ) {\n    for ( int i = 0; i < 100000; i++ ) {\n      G[i].clear();\n      used[i].clear();\n    }\n    zipx.clear(); zipy.clear();\n    f = false;    \n    vector<Pp> dat(n);\n    vector<int> X, Y;  \n    for ( int i = 0; i < n; i++ ) {\n      int x, y;\n      char d;\n      cin >> x >> y >> d;\n      dat[i] = (Pp(P(x, y), d == 'y'));    \n      X.emplace_back(x);\n      X.emplace_back(x+1);\n      X.emplace_back(x-1);\n      Y.emplace_back(y);\n      Y.emplace_back(y+1);\n      Y.emplace_back(y-1);\n    }\n\n    {\n      sort(X.begin(), X.end());\n      X.erase(unique(X.begin(), X.end()), X.end());\n      int cnt = 0;\n      for ( int i = 0; i < X.size(); i++ ) {\n\tzipx[X[i]] = cnt++;\n      }\n    }\n\n    {\n      sort(Y.begin(), Y.end());\n      Y.erase(unique(Y.begin(), Y.end()), Y.end());\n      int cnt = 0;\n      for ( int i = 0; i < Y.size(); i++ ) {\n\tzipy[Y[i]] = cnt++;      \n      }\n    }\n\n    for ( int i = 0; i < n; i++ ) {\n      int x = dat[i].first.first, y = dat[i].first.second, d = dat[i].second;\n      int nx = zipx[x], ny = zipy[y];    \n      if ( d == 0 ) { // x\n\tG[nx][ny] = 2;\n\tG[zipx[x+1]][ny] = 4;\n      } else {\n\tG[nx][ny] = 1;\n\tG[nx][zipy[y+1]] = 3;      \n      }\n    }\n\n    for ( int i = 0; i < n; i++ ) {\n      int x = dat[i].first.first, y = dat[i].first.second, d = dat[i].second;\n      int nx = zipx[x], ny = zipy[y];\n      if ( used[nx][ny] ) continue;\n      dfs(x, y, 1);\n      if ( f ) break;    \n    }\n\n    if ( f ) cout << \"No\" << endl;\n    else cout << \"Yes\" << endl;  \n  }  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n\npii in[40010];\n\n\nbool check[40010];\n\nint dx[4]={-1,0,1,0};\nint dy[4]={0,-1,0,1};\n\nint main(void){\n\tint n;\n\twhile(cin >> n){\n\t\tif(n==0) break;\n\n\t\tmap<pii,int> memo;\n\t\trep(i,n){\n\t\t\tchar dir;\n\t\t\tcin >> in[2*i].first >> in[2*i].second >> dir;\n\t\t\tin[2*i+1]=in[2*i];\n\t\t\tint d=(dir=='x')?2:3;\n\t\t\tin[2*i+1].first+=dx[d],in[2*i+1].second+=dy[d];\n\t\t\tmemo[in[2*i]]=2*i;\n\t\t\tmemo[in[2*i+1]]=2*i+1;\n\t\t}\n\t\tclr(check,false);\n\n\t\tbool ans=true;\n\t\trep(i,n){\n\t\t\tif(check[2*i]) continue;\n\t\t\tbool ok=false;\n\t\t\trep(j,2){\n\t\t\t\tbool ok2=true;\n\t\t\t\tmap<int,int> color;\n\t\t\t\tqueue<int> q;\n\n\t\t\t\tcolor[2*i]=j;\n\t\t\t\tcolor[2*i+1]=j^1;\n\t\t\t\tq.push(2*i);\n\t\t\t\tq.push(2*i+1);\n\n\t\t\t\twhile(!q.empty()){\n\t\t\t\t\tint cur=q.front();q.pop();\n\t\t\t\t\tpii xy=in[cur];\n\t\t\t\t\trep(l,4){\n\t\t\t\t\t\tpii next=xy;\n\t\t\t\t\t\tnext.first+=dx[l],next.second+=dy[l];\n\t\t\t\t\t\tif(memo.find(next)==memo.end()) continue;\n\t\t\t\t\t\tint index=memo[next];\n\t\t\t\t\t\tif(color.find(index)==color.end()){\n\t\t\t\t\t\t\tcolor[index]=color[cur];\n\t\t\t\t\t\t\tcolor[index^1]=color[cur]^1;\n\t\t\t\t\t\t\tq.push(index);\n\t\t\t\t\t\t\tq.push(index^1);\n\t\t\t\t\t\t}else if((cur^1)!=index&&color[index]!=color[cur])\n\t\t\t\t\t\t\tok2=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok2){\n\t\t\t\t\tok=true;\n\t\t\t\t\tfor(auto &k:color) check[k.second]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok) ans=false;\n\t\t}\n\t\tif(ans)\n\t\t\tputs(\"Yes\");\n\t\telse\n\t\t\tputs(\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,int> Pi;\ntypedef long long ll;\n\nint n;\n\n\nbool bfs(int t,map<P,P> &futon,pair<P,P> f) {\n    queue<Pi> que;\n    que.push(Pi(f.fr,t));\n    f.sc.sc=t;\n    futon[f.fr]=f.sc;\n    map<Pi,bool> visited;\n    visited[(Pi(f.fr,t))]=true;;\n\n    while(que.size()) {\n        Pi pi = que.front(); que.pop();\n        P p=pi.fr;\n        //printf(\"[debug] %d : %d %d %d\\n\",t,p.fr,p.sc,pi.sc);\n        rep(k,4) {\n            int ny=p.fr+dy[k];\n            int nx=p.sc+dx[k];\n            int t=pi.sc;\n\n            if(!futon.count(P(ny,nx))) continue;\n            //if(futon[P(ny,nx)].sc!=-1) continue;\n\n            // ???????????£???\n            if(futon[P(ny,nx)].fr==futon[p].fr) {\n                if(futon[P(ny,nx)].sc!=-1&&futon[P(ny,nx)].sc!=(t^1)) return false;\n                if(visited.count(Pi(P(ny,nx),t^1))) continue;\n                visited[(Pi(P(ny,nx),t^1))]=true;\n                futon[P(ny,nx)].sc=t^1;\n                que.push(Pi(P(ny,nx),t^1));\n            }\n            else {\n                if(futon[P(ny,nx)].sc!=-1&&futon[P(ny,nx)].sc!=t) return false;\n                if(visited.count(Pi(P(ny,nx),t))) continue;\n                visited[(Pi(P(ny,nx),t))]=true;\n                futon[P(ny,nx)].sc=t;\n                que.push(Pi(P(ny,nx),t));\n            }\n\n        }\n    }\n\n    return true;\n}\n\nvoid solve() {\n    map<P,P> futon;\n    rep(i,n) {\n        P pos;\n        char d;\n        cin>>pos.sc>>pos.fr>>d;\n        futon[pos]=P(i,-1);\n        if(d=='x') {\n            pos.sc+=1;\n        }\n        else {\n            pos.fr+=1;\n        }\n        futon[pos]=P(i,-1);\n    }\n    bool f=true;\n    for(auto e : futon) {\n        if(e.sc.sc==-1) {\n            if(!bfs(0,futon,*futon.begin())) f=false;\n        }\n    }\n    if(f) {\n        cout<<\"Yes\"<<endl;\n    }\n    else cout<<\"No\"<<endl;\n}\n\nint main() {\n    while(cin>>n) {\n        if(n==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION false\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nstruct futon {\n\tPII cells[2];\n};\nvector<futon> futons;\nmap<PII, PII> opposite;\nmap<PII, bool> is_head;\n\nbool fix(PII c, bool head)\n{\n\tPII oc = opposite[c];\n\tis_head[c] = head;\n\tis_head[oc] = !head;\n\tbool valid = true;\n\tREP (d, 4) {\n\t\tint y = c.F + dy[d], x = c.S + dx[d];\n\t\tIFC (MP(y, x) == oc);\n\t\tif (EXIST(opposite, MP(y,x))) {\n\t\t\tif (EXIST(is_head, MP(y, x))) {\n\t\t\t\tif (is_head[MP(y, x)] != head) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvalid = valid && fix(MP(y, x), head);\n\t\t\t}\n\t\t}\n\t}\n\tREP (d, 4) {\n\t\tint y = oc.F + dy[d], x = oc.S + dx[d];\n\t\tIFC (MP(y, x) == c);\n\t\tif (EXIST(opposite, MP(y,x))) {\n\t\t\tif (EXIST(is_head, MP(y, x))) {\n\t\t\t\tif (is_head[MP(y, x)] != !head) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvalid = valid && fix(MP(y, x), !head);\n\t\t\t}\n\t\t}\n\t}\n\treturn valid;\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tfutons.clear();\n\t\topposite.clear();\n\t\tis_head.clear();\n\t\tREP (i, n) {\n\t\t\tint x, y; cin >> x >> y; char d; cin >> d;\n\t\t\topposite[MP(y, x)] = MP(y+(d=='y'), x+(d=='x'));\n\t\t\topposite[MP(y+(d=='y'), x+(d=='x'))] = MP(y, x);\n\t\t\tfuton f; f.cells[0] = MP(y, x); f.cells[1] = MP(y+(d=='y'), x+(d=='x'));\n\t\t\tfutons.PB(f);\n\t\t}\n\t\tREP (i, n) {\n\t\t\tPII p = futons[i].cells[0];\n\t\t\tPII op = futons[i].cells[1];\n\t\t\tif (EXIST(is_head, p)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// Fix here\n\t\t\tif (!fix(p, true)) {\n\t\t\t\tgoto NO;\n\t\t\t}\n\t\t}\nYES:\n\t\tcout << \"Yes\" << endl;\n\t\tcontinue;\nNO:\n\t\tcout << \"No\" << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n\nmap<int,map< int,int > > field;\nint n;\nint x[20001],y[20001];\nint head[20001];\nchar dir[20001];\nvector<int> G[20001];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nvector<int> vs;\n\nbool dfs(int v,int c){\n\thead[v]=c;\n\tvs.push_back(v);\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint e=G[v][i];\n\t\tif(dir[v]=='x' && dir[e]=='x'){\n\t\t\tif(x[v]==x[e]){\n\t\t\t\tif(head[e]==-1){\n\t\t\t\t\tif(!dfs(e,c))return false;\n\t\t\t\t}else{\n\t\t\t\t\tif(head[e]!=c)return false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(head[e]==-1){\n\t\t\t\t\tif(!dfs(e,1-c))return false;\n\t\t\t\t}else{\n\t\t\t\t\tif(head[e]!=1-c)return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(dir[v]=='y' && dir[e]=='y'){\n\t\t\tif(y[v]==y[e]){\n\t\t\t\tif(head[e]==-1){\n\t\t\t\t\tif(!dfs(e,c))return false;\n\t\t\t\t}else{\n\t\t\t\t\tif(head[e]!=c)return false;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(head[e]==-1){\n\t\t\t\t\tif(!dfs(e,1-c))return false;\n\t\t\t\t}else{\n\t\t\t\t\tif(head[e]!=1-c)return false;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tbool flag0=true,flag1=true;\n\t\t\tif(c==0){\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tif(x[v]+dx[i]==x[e] && y[v]+dy[i]==y[e])flag1=false;\n\t\t\t\t\tif(x[v]+dx[i]==x[e]+(dir[e]=='x') && y[v]+dy[i]==y[e]+(dir[e]=='y'))flag0=false;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tif(x[e]+dx[i]==x[v]+(dir[v]=='x') && y[e]+dy[i]==y[v]+(dir[v]=='y'))flag0=false;\n\t\t\t\t\tif(x[e]+(dir[e]=='x')+dx[i]==x[v]+(dir[v]=='x') && y[e]+(dir[e]=='y')+dy[i]==y[v]+(dir[v]=='y'))flag1=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(c==1){\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tif(x[v]+(dir[v]=='x')+dx[i]==x[e] && y[v]+(dir[v]=='y')+dy[i]==y[e])flag1=false;\n\t\t\t\t\tif(x[v]+(dir[v]=='x')+dx[i]==x[e]+(dir[e]=='x') && y[v]+(dir[v]=='y')+dy[i]==y[e]+(dir[e]=='y'))flag0=false;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tif(x[e]+dx[i]==x[v] && y[e]+dy[i]==y[v])flag0=false;\n\t\t\t\t\tif(x[e]+(dir[e]=='x')+dx[i]==x[v] && y[e]+(dir[e]=='y')+dy[i]==y[v])flag1=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag0 && !flag1)return false;\n\t\t\tint nc;\n\t\t\tif(flag0)nc=0;\n\t\t\tif(flag1)nc=1;\n\t\t\tif(head[e]==-1){\n\t\t\t\tif(!dfs(e,nc))return false;\n\t\t\t}else{\n\t\t\t\tif(head[e]!=nc)return false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nbool check(){\n\tfor(int i=1;i<=n;i++){\n\t\tif(dir[i]=='x'){\n\t\t\tif(field[x[i]][y[i]]!=0)return false;\n\t\t\tfield[x[i]][y[i]]=i;\n\t\t\tif(field[x[i]+1][y[i]]!=0)return false;\n\t\t\tfield[x[i]+1][y[i]]=i;\n\t\t}\n\t\tif(dir[i]=='y'){\n\t\t\tif(field[x[i]][y[i]]!=0)return false;\n\t\t\tfield[x[i]][y[i]]=i;\n\t\t\tif(field[x[i]][y[i]+1]!=0)return false;\n\t\t\tfield[x[i]][y[i]+1]=i;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(dir[i]=='x'){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(field[x[i]+dx[j]][y[i]+dy[j]]!=0 && field[x[i]+dx[j]][y[i]+dy[j]]!=field[x[i]][y[i]]){\n\t\t\t\t\tG[i].push_back(field[x[i]+dx[j]][y[i]+dy[j]]);\n\t\t\t\t}\n\t\t\t\tif(field[x[i]+dx[j]+1][y[i]+dy[j]]!=0 && field[x[i]+dx[j]+1][y[i]+dy[j]]!=field[x[i]+1][y[i]]){\n\t\t\t\t\tG[i].push_back(field[x[i]+dx[j]+1][y[i]+dy[j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dir[i]=='y'){\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(field[x[i]+dx[j]][y[i]+dy[j]]!=0 && field[x[i]+dx[j]][y[i]+dy[j]]!=field[x[i]][y[i]]){\n\t\t\t\t\tG[i].push_back(field[x[i]+dx[j]][y[i]+dy[j]]);\n\t\t\t\t}\n\t\t\t\tif(field[x[i]+dx[j]][y[i]+dy[j]+1]!=0 && field[x[i]+dx[j]][y[i]+dy[j]+1]!=field[x[i]][y[i]+1]){\n\t\t\t\t\tG[i].push_back(field[x[i]+dx[j]][y[i]+dy[j]+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemset(head,-1,sizeof(head));\n\tfor(int i=1;i<=n;i++){\n\t\tif(head[i]==-1){\n\t\t\tif(!dfs(i,0)){\n\t\t\t\tfor(int j=0;j<vs.size();j++){\n\t\t\t\t\thead[vs[j]]=-1;\n\t\t\t\t}\n\t\t\t\tif(!dfs(i,1))return false;\n\t\t\t}\n\t\t\tvs.clear();\n\t\t}\n\t}\n\treturn true;\n}\n\nint main(void){\n\twhile(1){\n\t\tfield.clear();\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tG[i].clear();\n\t\t\tscanf(\"%d %d %c\",&x[i],&y[i],&dir[i]);\n\t\t}\n\t\tprintf(\"%s\\n\",check()?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, V;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nvector<int> G[100000];\nvector<int> rG[100000];\nvector<int> vs;\nbool used[100000];\nint cmp[100000];\nmap<P,int> m;\nmap<P,int>::iterator it;\n\nvoid add_edge(int from, int to){\n\tG[from].push_back(to);\n\trG[to].push_back(from);\n}\n\nvoid dfs(int v){\n\tused[v] = true;\n\trep(i,G[v].size()){\n\t\tif(!used[G[v][i]]) dfs(G[v][i]);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v, int k){\n\tused[v] = true;\n\tcmp[v] = k;\n\trep(i,rG[v].size()){\n\t\tif(!used[rG[v][i]]) rdfs(rG[v][i], k);\n\t}\n}\n\nint scc(){\n\tmemset(used,0,sizeof(used));\n\tvs.clear();\n\trep(v,V){\n\t\tif(!used[v]) dfs(v);\n\t}\n\tmemset(used,0,sizeof(used));\n\tint k = 0;\n\tfor(int i = vs.size()-1; i >= 0; i--){\n\t\tif(!used[vs[i]]) rdfs(vs[i],k++);\n\t}\n\treturn k;\n}\n\nvoid init(){\n\tm.clear();\n\trep(i,100000){\n\t\tG[i].clear();\n\t\trG[i].clear();\n\t\tused[i] = false;\n\t\tcmp[i] = 0;\n\t}\n\tvs.clear();\n}\n\nvoid solve(){\n\tinit();\n\tV = n*4;\n\trep(i,n){\n\t\tint x, y; char d;\n\t\tcin >> x >> y >> d;\n\t\tm[P(x,y)] = i+1;\n\t\tif(d == 'x') m[P(x+1,y)] = i+n+1;\n\t\telse m[P(x,y+1)] = i+n+1;\n\t}\n\tfor(it = m.begin(); it != m.end(); it++){\n\t\tif(it->second == 0) continue;\n\t\tint id1 = it->second-1;\n\t\tP p = it->first;\n\t\trep(i,4){\n\t\t\tif(m[P(p.first+dx[i],p.second+dy[i])] != 0){\n\t\t\t\tint id2 = m[P(p.first+dx[i],p.second+dy[i])]-1;\n\t\t\t\tif(abs(id2-id1) == n){\n\t\t\t\t\tadd_edge(id1,id2+n*2);\n\t\t\t\t\tadd_edge(id2,id1+n*2);\n\t\t\t\t\tadd_edge(id1+n*2,id2);\n\t\t\t\t\tadd_edge(id2+n*2,id1);\n\t\t\t\t} else{\n\t\t\t\t\tadd_edge(id1,id2);\n\t\t\t\t\tadd_edge(id2,id1);\n\t\t\t\t\tadd_edge(id1+n*2,id2+n*2);\n\t\t\t\t\tadd_edge(id2+n*2,id1+n*2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tscc();\n\t\n\trep(i,2*n){\n\t\tif(cmp[i] == cmp[i+2*n]){\n\t\t\tputs(\"No\");\n\t\t\treturn;\n\t\t}\n\t}\n\tputs(\"Yes\");\n}\n\nint main(){\n\twhile(true){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef pair<P,int> Pi;\ntypedef long long ll;\n\nint n;\n\n\nbool bfs(int t,map<P,P> futon,pair<P,P> f) {\n    queue<Pi> que;\n    que.push(Pi(f.fr,t));\n    f.sc.sc=t;\n    futon[f.fr]=f.sc;\n    map<Pi,bool> visited;\n    visited[(Pi(f.fr,t))]=true;;\n\n    while(que.size()) {\n        Pi pi = que.front(); que.pop();\n        P p=pi.fr;\n        //printf(\"[debug] %d : %d %d %d\\n\",t,p.fr,p.sc,pi.sc);\n        rep(k,4) {\n            int ny=p.fr+dy[k];\n            int nx=p.sc+dx[k];\n            int t=pi.sc;\n\n            if(!futon.count(P(ny,nx))) continue;\n            //if(futon[P(ny,nx)].sc!=-1) continue;\n\n            // ???????????£???\n            if(futon[P(ny,nx)].fr==futon[p].fr) {\n                if(futon[P(ny,nx)].sc!=-1&&futon[P(ny,nx)].sc!=(t^1)) return false;\n                if(visited.count(Pi(P(ny,nx),t^1))) continue;\n                visited[(Pi(P(ny,nx),t^1))]=true;\n                futon[P(ny,nx)].sc=t^1;\n                que.push(Pi(P(ny,nx),t^1));\n            }\n            else {\n                if(futon[P(ny,nx)].sc!=-1&&futon[P(ny,nx)].sc!=t) return false;\n                if(visited.count(Pi(P(ny,nx),t))) continue;\n                visited[(Pi(P(ny,nx),t))]=true;\n                futon[P(ny,nx)].sc=t;\n                que.push(Pi(P(ny,nx),t));\n            }\n\n        }\n    }\n\n    return true;\n}\n\nvoid solve() {\n    map<P,P> futon;\n    rep(i,n) {\n        P pos;\n        char d;\n        cin>>pos.sc>>pos.fr>>d;\n        futon[pos]=P(i,-1);\n        if(d=='x') {\n            pos.sc+=1;\n        }\n        else {\n            pos.fr+=1;\n        }\n        futon[pos]=P(i,-1);\n    }\n    bool f=true;\n    for(auto e : futon) {\n        if(!(bfs(0,futon,e)||bfs(1,futon,e))) f=false;\n    }\n    if(f) {\n        cout<<\"Yes\"<<endl;\n    }\n    else cout<<\"No\"<<endl;\n}\n\nint main() {\n    while(cin>>n) {\n        if(n==0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <ctime>\n#include <deque>\n#include <bitset>\n#include <cctype>\n#include <utility>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\n\n#define Rep(i,n) for(int i = 0; i < (n); ++i)\n#define Repd(i,n) for(int i = (n)-1; i >= 0; --i)\n#define For(i,a,b) for(int i = (a); i <= (b); ++i)\n#define Ford(i,a,b) for(int i = (a); i >= (b); --i)\n#define Fit(i,v) For(__typeof((v).begin()) i = (v).begin(); i != (v).end(); ++i)\n#define Fitd(i,v) For(__typeof((v).rbegin()) i = (v).rbegin(); i != (v).rend(); ++i)\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(a) ((int)(a).size())\n#define all(a) (a).begin(), (a).end()\n#define ms(a,x) memset(a, x, sizeof(a))\n\ntemplate<class F, class T> T convert(F a, int p = -1) { stringstream ss; if (p >= 0) ss << fixed << setprecision(p); ss << a; T r; ss >> r; return r; }\ntemplate<class T> T gcd(T a, T b) { T r; while (b != 0) { r = a % b; a = b; b = r; } return a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\ntemplate<class T> T sqr(T x) { return x * x; }\ntemplate<class T> T cube(T x) { return x * x * x; }\ntemplate<class T> int getbit(T s, int i) { return (s >> i) & 1; }\ntemplate<class T> T onbit(T s, int i) { return s | (T(1) << i); }\ntemplate<class T> T offbit(T s, int i) { return s & (~(T(1) << i)); }\ntemplate<class T> int cntbit(T s) { return __builtin_popcount(s); }\nconst int bfsz = 1 << 16; char bf[bfsz + 5]; int rsz = 0;int ptr = 0;\nchar gc() { if (rsz <= 0) { ptr = 0; rsz = (int) fread(bf, 1, bfsz, stdin); if (rsz <= 0) return EOF; } --rsz; return bf[ptr++]; }\nvoid ga(char &c) { c = EOF; while (!isalpha(c)) c = gc(); }\nint gs(char s[]) { int l = 0; char c = gc(); while (isspace(c)) c = gc(); while (c != EOF && !isspace(c)) { s[l++] = c; c = gc(); } s[l] = '\\0'; return l; }\ntemplate<class T> bool gi(T &v) {\n    v = 0; char c = gc(); while (c != EOF && c != '-' && !isdigit(c)) c = gc(); if (c == EOF) return false; bool neg = c == '-'; if (neg) c = gc();\n    while (isdigit(c)) { v = v * 10 + c - '0'; c = gc(); } if (neg) v = -v; return true;\n}\n\ntypedef pair<int, int> II;\n\nconst ld PI = acos(ld(-1.0));\nconst ld eps = 1e-9;\n\nconst int inf = (int)1e9 + 5;\nconst ll linf = (ll)1e17 + 5;\nint dr[4] = {-1, 0, +1, 0};\nint dc[4] = {0, -1, 0, +1};\nconst ll mod = 1000000007;\n\n#define maxn 100005\n\n#define maxv 100005\n#define pos(v) ((v) << 1)\n#define neg(v) (pos(v) ^ 1)\n\nmap<II, II> M;\nmap<II, int> Mi;\n\nint X[maxn], Y[maxn];\nint n;\n\nstruct triple{\n\tint x, y, z;\n\ttriple(){};\n\ttriple(int _x, int _y, int _z){\n\t\tx = _x; y = _y; z = _z;\n\t}\n};\n\ntriple que[maxn];\nint size;\n\nbool go(int x, int y, int color){\n\n\tsize = 0;\n\tque[size++] = triple(x, y, color);\n\tbool res = true;\n\n\tRep(i, size){\n\t\tx = que[i].x; y = que[i].y, color = que[i].z;\n\t\tII P = M[mp(x, y)];\n\t\tint xx = P.fi, yy = P.se, xt, yt;\n\t\tif(Mi[P] && Mi[P] + color != 3){\n\t\t\tres = false;\n\t\t}\n\n\t\tRep(h, 4){\n\t\t\txt = x + dr[h];\n\t\t\tyt = y + dc[h];\n\t\t\tif(xt == xx && yt == yy) continue;\n\t//\t\tcout << xt << \" \" << yt << endl;\n\t\t\tif(M.count(mp(xt, yt))){\n\t\t\t\tif(Mi[mp(xt, yt)]){\n\t\t\t\t\tif(Mi[mp(xt, yt)] != color) res = false;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tMi[mp(xt, yt)] = color;\n\t\t\t\t\tque[size++] = triple(xt, yt, color);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(Mi[P] && Mi[P] + color != 3){\n\t\t\tres = false;\n\t\t}\n\t\tif(!Mi[P]){\n\t\t\tMi[P] = 3 - color;\n\t\t\tque[size++] = triple(xx, yy, 3 - color);\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid solve(){\n\tint x, y, xx, yy;\n\tchar h;\n\tM.clear(); Mi.clear();\n\tFor(i, 1, n){\n\t\tcin >> x >> y >> h;\n\t\tX[i] = x;\n\t\tY[i] = y;\n\t\tif(h == 'x'){\n\t\t\txx = x + 1;\n\t\t\tyy = y;\n\t\t}\n\t\telse{\n\t\t\txx = x;\n\t\t\tyy = y + 1;\n\t\t}\n\t\tM[mp(x, y)] = mp(xx, yy);\n\t\tM[mp(xx, yy)] = mp(x, y);\n\t}\n\n\tbool res = true;\n\tFor(i, 1, n){\n\t\tif(!Mi[mp(X[i], Y[i])]){\n\t\t\tMi[mp(X[i], Y[i])] = 1;\n\t\t\tif(!go(X[i], Y[i], 1)){\n\t\t\t\tres = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif(res) cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n//    freopen(\"in.txt\", \"r\", stdin);\n\n    while(cin >> n && n > 0){\n    \tsolve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp);\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v);\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << \"(\" << p.first << \":\" << p.second << \")\";\n    return os;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \"; a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int n; cin >> n;\n        if (n == 0) break;\n\n        map<P, vector<P>> diff, same;\n\n        REP(i, n) {\n            int x, y; char dir;\n            cin >> x >> y >> dir;\n            if (dir == 'x') {\n                diff[make_pair(x, y)].emplace_back(x+1, y);\n                diff[make_pair(x+1, y)].emplace_back(x, y);\n\n                if (diff.count(make_pair(x-1, y))) {\n                    same[make_pair(x, y)].emplace_back(x-1, y);\n                    same[make_pair(x-1, y)].emplace_back(x, y);\n                }\n                if (diff.count(make_pair(x, y-1))) {\n                    same[make_pair(x, y)].emplace_back(x, y-1);\n                    same[make_pair(x, y-1)].emplace_back(x, y);\n                }\n                if (diff.count(make_pair(x, y+1))) {\n                    same[make_pair(x, y)].emplace_back(x, y+1);\n                    same[make_pair(x, y+1)].emplace_back(x, y);\n                }\n                if (diff.count(make_pair(x+2, y))) {\n                    same[make_pair(x+1, y)].emplace_back(x+2, y);\n                    same[make_pair(x+2, y)].emplace_back(x+1, y);\n                }\n                if (diff.count(make_pair(x+1, y-1))) {\n                    same[make_pair(x+1, y)].emplace_back(x+1, y-1);\n                    same[make_pair(x+1, y-1)].emplace_back(x+1, y);\n                }\n                if (diff.count(make_pair(x+1, y+1))) {\n                    same[make_pair(x+1, y)].emplace_back(x+1, y+1);\n                    same[make_pair(x+1, y+1)].emplace_back(x+1, y);\n                }\n            }\n            if (dir == 'y') {\n                diff[make_pair(x, y)].emplace_back(x, y+1);\n                diff[make_pair(x, y+1)].emplace_back(x, y);\n\n                if (diff.count(make_pair(x, y-1))) {\n                    same[make_pair(x, y)].emplace_back(x, y-1);\n                    same[make_pair(x, y-1)].emplace_back(x, y);\n                }\n                if (diff.count(make_pair(x-1, y))) {\n                    same[make_pair(x, y)].emplace_back(x-1, y);\n                    same[make_pair(x-1, y)].emplace_back(x, y);\n                }\n                if (diff.count(make_pair(x+1, y))) {\n                    same[make_pair(x, y)].emplace_back(x+1, y);\n                    same[make_pair(x+1, y)].emplace_back(x, y);\n                }\n                if (diff.count(make_pair(x, y+2))) {\n                    same[make_pair(x, y+1)].emplace_back(x, y+2);\n                    same[make_pair(x, y+2)].emplace_back(x, y+1);\n                }\n                if (diff.count(make_pair(x-1, y+1))) {\n                    same[make_pair(x, y+1)].emplace_back(x-1, y+1);\n                    same[make_pair(x-1, y+1)].emplace_back(x, y+1);\n                }\n                if (diff.count(make_pair(x+1, y+1))) {\n                    same[make_pair(x, y+1)].emplace_back(x+1, y+1);\n                    same[make_pair(x+1, y+1)].emplace_back(x, y+1);\n                }\n            }\n        }\n\n        map<P,int> color;\n        function<bool(P,int)> dfs = [&](P p, int c) {\n            if (color[p] == -c) return false;\n            if (color[p] == c) return true;\n            color[p] = c;\n            for (P& q : diff[p]) {\n                if (!dfs(q, -c)) return false;\n            }\n            for (P& q : same[p]) {\n                if (!dfs(q, c)) return false;\n            }\n            return true;\n        };\n\n        bool valid = true;\n        for (auto &tp : diff) {\n            if (color.count(tp.first)) continue;\n            if (!dfs(tp.first, 1)) valid = false;\n        }\n        cout << (valid ? \"Yes\" : \"No\") << endl;\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define MAX 1000\n#define F_MAX 2000\n\nint n;\nint field[MAX][MAX];\n\nstruct futon{\n\tint x[2], y[2];\n};\n\nfuton F[F_MAX];\n\nint dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nbool dfs( int pos ){\n\tif( pos == n ) return true;\n\tbool rep = false;\n\tfor( int i = 0; i < 2; i++ ){\n\t\tint legx, legy, headx, heady;\n\t\tlegx = F[pos].x[i];\n\t\tlegy = F[pos].y[i];\n\t\theadx = F[pos].x[1-i];\n\t\theady = F[pos].y[1-i];\n\t\t//cout << \"----\" << pos << \"------\" << endl;\n\t\t//cout << legx << \" \" << legy << \" \" << headx << \" \" << heady << endl;\n\t\tbool ok = true;\n\t\tfor( int j = 0; j < 4; j++ ){\n\t\t\tif( (0 <= legx+dx[j] && legx+dx[j] < MAX) && (0 <= legy+dy[j] && legy+dy[j] < MAX) ){\n\t\t\t\tif( field[legx+dx[j]][legy+dy[j]] == 1 ) ok = false;\n\t\t\t}\n\t\t\tif( (0 <= headx+dx[j] && headx+dx[j] < MAX) && (0 <= heady+dy[j] && heady+dy[j] < MAX) ){\n\t\t\t\tif( field[headx+dx[j]][heady+dy[j]] == 2 ) ok = false;\n\t\t\t}\n\t\t}\n\t\tif( !ok ) continue;\n\t\tfield[headx][heady] = 1;\n\t\tfield[legx][legy] = 2;\n\t\tif( dfs(pos+1) ) rep = true;\n\t\tfield[headx][heady] = 0;\n\t\tfield[legx][legy] = 0;\n\t}\n\treturn rep;\n}\n\nint main(){\n\twhile( cin >> n, n ){\n\t\tfor( int i = 0; i < n; i++ ){\n\t\t\tint x, y;\n\t\t\tchar d;\n\t\t\tcin >> x >> y >> d;\n\t\t\tF[i].x[0] = x;\n\t\t\tF[i].y[0] = y;\n\t\t\tF[i].x[1] = (d == 'x') ? x+1 : x;\n\t\t\tF[i].y[1] = (d == 'x') ? y : y+1;\n\t\t}\n\t\tfor( int j = 0; j < MAX; j++ ){\n\t\t\tfor( int k = 0; k < MAX; k++ ){\n\t\t\t\tfield[j][k] = 0;\n\t\t\t}\n\t\t}\n\t\t/*for( int i = 0; i < n; i++ ){\n\t\t\tfor( int j = 0; j < 2; j++ ){\n\t\t\t\tcout << F[i].x[j] << \" \" << F[i].y[j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tif( dfs(0) ) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\nusing namespace std;\ntypedef pair<int,int> Pair;\n\nconst int MAXN = 20004;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nnamespace std {\n  bool operator < (const Pair &a, const Pair &b) {\n    if(a.first != b.first) return a.first < b.first;\n    return a.second < b.second;\n  }\n};\n\nint N;\nint X[MAXN], Y[MAXN];\nchar D[MAXN];\n\nmap<Pair, Pair> m;\nint B[MAXN];\n\nbool dfs(int id, int b) {\n  B[id] = b;\n  int fx[2], fy[2];\n  if(D[id] == 'x') {\n    fx[0] = 0; fx[1] = 1;\n    fy[0] = 0; fy[1] = 0;\n  } else {\n    fx[0] = 0; fx[1] = 0;\n    fy[0] = 0; fy[1] = 1;\n  }\n  for(int j = 0; j < 2; ++j) {\n    for(int i = 0; i < 4; ++i) {\n      int nx = X[id] + fx[j] + dx[i];\n      int ny = Y[id] + fy[j] + dy[i];\n      Pair p(nx,ny);\n      if(m.count(p)) {\n        int nid = m[p].first;\n        int nb = m[p].second;\n        if(nid == id) continue;\n        if(B[nid] != -1) {\n          if((B[nid]^nb) != (b^j)) {\n            return false;\n          }\n        } else {\n          if(!dfs(nid, b^j^nb)) return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> X[i] >> Y[i] >> D[i];\n    }\n    m.clear();\n    for(int i = 0; i < N; ++i) {\n      if(D[i] == 'x') {\n        m[Pair(X[i],Y[i])] = Pair(i, 0);\n        m[Pair(X[i]+1,Y[i])] = Pair(i, 1);\n      } else {\n        m[Pair(X[i],Y[i])] = Pair(i, 0);\n        m[Pair(X[i],Y[i]+1)] = Pair(i, 1);\n      }\n    }\n\n    fill(B, B+MAXN, -1);\n    bool ans = true;\n    for(int i = 0; i < N; ++i) {\n      if(B[i] == -1) {\n        if(!dfs(i, 0)) {\n          ans = false;\n          break;\n        }\n      }\n    }\n    if(ans) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 20000\ntypedef pair<int,int> pii;\n \nmap<pii,int> id;\nmap<int,pii> mp;\nint color[MAX][2],tmp[MAX][2];\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n \nstruct State{\n    int v,p,col;\n    State(int v,int p,int col) :\n\tv(v),p(p),col(col) {}\n};\n \nbool bfs(int v,int p){\n    queue<State> Q;\n    Q.push(State(v,p,0));\n    Q.push(State(v+1,1-p,1));\n   \n    while(!Q.empty()){\n\tState s = Q.front(); Q.pop();\n\tpii np = mp[s.v];\n\tif(color[s.v/2][s.p] >= 0){\n\t    if(color[s.v/2][s.p] != s.col){\n\t\treturn false;\n\t    }\n\t    continue;\n\t}\n\tcolor[s.v/2][s.p] = s.col;\n\tfor(int i = 0 ; i < 4 ; i++){\n\t    int nx = np.first+dx[i],ny = np.second+dy[i];\n\t    if(id.find(pii(nx,ny)) != id.end()){\n\t\tint x = id[pii(nx,ny)]%2;\n\t\tif(id[np]/2 == id[pii(nx,ny)]/2){\n\t\t    Q.push(State(id[pii(nx,ny)],1-s.p,1-s.col));\n\t\t}else{\n\t\t    Q.push(State(id[pii(nx,ny)],(x&1?1:0),s.col));\n\t\t}\n\t    }\n\t}\n    }\n    return true;\n}\n \nvoid init(){\n    mp.clear();\n    id.clear();\n    memset(color,-1,sizeof(color));\n}\n \nint main(){\n    int N,x,y;\n    char ch;\n    while(cin >> N,N){\n\tinit();\n\tfor(int i = 0 ; i < N ; i++){\n\t    cin >> x >> y >> ch;\n\t    int j = i*2;\n\t    if(ch == 'x'){\n\t\tmp[j] = pii(x,y); mp[j+1] = pii(x+1,y);\n\t\tid[pii(x,y)] = j; id[pii(x+1,y)] = j+1;\n\t    }else{\n\t\tmp[j] = pii(x,y); mp[j+1] = pii(x,y+1);\n\t\tid[pii(x,y)] = j; id[pii(x,y+1)] = j+1;\n\t    }\n\t}\n\tbool can = true;\n\tfor(int i = 0 ; i < 2*N ; i+=2){\n\t    if(color[i/2][0] >= 0) continue;\n\t    for(int j = 0 ; j < N ; j++){\n\t\tfor(int k = 0 ; k < 2 ; k++){\n\t\t    tmp[j][k] = color[j][k];\n\t\t}\n\t    }\n\t    if(!bfs(i,0)) can = false;\n\t    if(!can){\n\t\tcan = true;\n\t\tfor(int j = 0 ; j < N ; j++){\n\t\t    for(int k = 0 ; k < 2 ; k++){\n\t\t\tcolor[j][k] = tmp[j][k];\n\t\t    }\n\t\t}\n\t\tif(!bfs(i,1)){\n\t\t    can = false;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tcout << (can ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 20002\n\nint dy1[6]={1,0,-1,-1,0,1};\nint dx1[6]={1,2,1,0,-1,0};\n\nint dy2[6]={-1,-2,-1,0,1,0};\nint dx2[6]={1,0,-1,-1,0,1};\n\nint dy3[6]={1,0,-1,-1,0,1};\nint dx3[6]={-1,-2,-1,0,1,0};\n\nint dy4[6]={1,2,1,0,-1,0};\nint dx4[6]={1,0,-1,-1,0,1};\n\nint n;\n\nmap<P,int> T,F,vd;\nmap<P,P> G;\n\nint Y[MAX],X[MAX];\nchar c[MAX];\nbool flg[MAX];\n\n\nbool rec(int x,int y){\n  //  cout<<x<<' '<<y<<endl;\n\n  P p=P(x,y);\n  P q=G[p];\n  vd[p]=true;\n  vd[q]=true;\n  F[p]=1;\n  F[q]=2;\n  int id=T[p];\n  flg[id]=true;\n  P to;\n  int ny,nx;\n  for(int i=0;i<6;i++){\n    if(c[id]=='x'){\n      if(y==Y[id]&&x==X[id]){\n\tny=y+dy1[i];\n\tnx=x+dx1[i];\n      }else{\n\tny=y+dy3[i];\n\tnx=x+dx3[i];\n      }\n    }else{\n      if(y==Y[id]&&x==X[id]){\n\tny=y+dy4[i];\n\tnx=x+dx4[i];\n      }else{\n\tny=y+dy2[i];\n\tnx=x+dx2[i];\n      }\n    }\n    to=P(nx,ny);\n\n    if(i<3&&F[to]==1)return false;\n    if(i>=3&&F[to]==2)return false;\n    if(vd[to])continue;\n    if(T[to]==0)continue;\n    if(i<3){\n      nx=G[to].first;\n      ny=G[to].second;\n    }\n    if(!rec(nx,ny))return false;\n  }\n\n  return true;\n}\n\nbool solve(){\n  for(int i=1;i<=n;i++){\n    if(flg[i])continue;\n    if(!rec(X[i],Y[i]))return false;\n  }\n  return true;\n}\n\n\nint main() {\n\n  while(cin >> n && n) {\n    T.clear();\n    G.clear();\n    vd.clear();\n    F.clear();\n    for(int i=1; i<=n; i++) {\n      cin >> X[i] >> Y[i] >> c[i];\n      P a,b;\n      a.first=X[i],a.second=Y[i];\n      if(c[i]=='x'){\n\tb.first=a.first+1;\n\tb.second=a.second;\n\tT[a]=i;\n\tT[b]=i;\n\tG[a]=b;\n\tG[b]=a;\n      }else{\n\tb.first=a.first;\n\tb.second=a.second+1;\n\tT[a]=i;\n\tT[b]=i;\n\tG[a]=b;\n\tG[b]=a;\n      }\n    }\n    for(int i=1;i<=n;i++)flg[i]=false;\n    cout<<(solve()?\"Yes\":\"No\")<<endl;\n    /*\n    for(int i=5;i>=0;i--){\n      for(int j=0;j<=5;j++){\n\tcout<<vd[P(i,j)];\n      }\n      cout<<endl;\n    }\n    */\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n\ntypedef pair< int, int > pii;\ntypedef pair< pii, pii > ppii;\n\nconst int dx[4] = {0,1,0,-1}, dy[4] = {-1,0,1,0};\nint n, x[20020], y[20020], visit[20020][2];\nchar dir[20020];\npii pos[40040], ids[40040];\n\nint xadd(int i) { return dir[i] == 'x' ? 1 : 0; }\nint yadd(int i) { return dir[i] == 'y' ? 1 : 0; }\n\nbool rec(int i, int j, int v, vector< pii >& upd) {\n\tbool res = 1;\n\t\n\tif (visit[i][j] < 0) {\n\t\tvisit[i][j] = v;\n\t\tvisit[i][j^1] = v^1;\n\t\tupd.push_back(pii(i,j));\n\t\tupd.push_back(pii(i,j^1));\n\t\t\n\t\tint nx1 = x[i] + (j ? xadd(i) : 0), ny1 = y[i] + (j ? yadd(i) : 0);\n\t\tint nx2 = x[i] + (j ? 0 : xadd(i)), ny2 = y[i] + (j ? 0 : yadd(i));\n\t\tfor_(d,0,4) {\n\t\t\tpii nxp1(nx1 + dx[d], ny1 + dy[d]);\n\t\t\tif (binary_search(pos, pos + 2*n, nxp1)) {\n\t\t\t\tint k = lower_bound(pos, pos + 2*n, nxp1) - pos;\n\t\t\t\tif (ids[k].second != i) res &= rec(ids[k].second, ids[k].first, v, upd);\n\t\t\t}\n\t\t\t\n\t\t\tpii nxp2(nx2 + dx[d], ny2 + dy[d]);\n\t\t\tif (binary_search(pos, pos + 2*n, nxp2)) {\n\t\t\t\tint k = lower_bound(pos, pos + 2*n, nxp2) - pos;\n\t\t\t\tif (ids[k].second != i) res &= rec(ids[k].second, ids[k].first, v^1, upd);\n\t\t\t}\t\t\t\n\t\t}\n\t} else {\n\t\tres = (visit[i][j] == v);\n\t}\n\t\n\treturn res;\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n), n) {\n\t\tvector< ppii > vp;\n\t\t\n\t\tfor_(i,0,n) {\n\t\t\tscanf(\"%d %d %c\", &x[i], &y[i], &dir[i]);\n\t\t\tvp.push_back(ppii(pii(x[i], y[i]), pii(0, i)));\n\t\t\tvp.push_back(ppii(pii(x[i] + xadd(i), y[i] + yadd(i)), pii(1, i)));\n\t\t}\n\t\t\n\t\tsort(vp.begin(), vp.end());\n\t\t\n\t\tfor_(i,0,2*n) {\n\t\t\tpos[i] = vp[i].first;\n\t\t\tids[i] = vp[i].second;\n\t\t}\n\t\t\n\t\tmemset(visit, -1, sizeof(visit));\n\t\t\n\t\tbool ok = 1;\n\t\tfor_(i,0,n && ok) {\n\t\t\tif (visit[i][0] < 0) {\n\t\t\t\tvector< pii > upd;\n\t\t\t\tif (!rec(i, 0, 0, upd)) {\n\t\t\t\t\tint u_size = (int)upd.size();\n\t\t\t\t\tfor_(j,0,u_size) visit[upd[j].first][upd[j].second] = -1;\n\t\t\t\t\tok = rec(i, 0, 1, upd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << (ok ? \"Yes\" : \"No\") << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef pair<int, int> P;\ntypedef pair<P, char> S;\nint N;\nmap<P, int> m;\nS s[20000];\nbool h_used[40000];\nbool l_used[40000];\nint dfs(int idx){\n  if(idx == N) return true;\n  int x = s[idx].first.first, y = s[idx].first.second;\n  int x2 = x, y2 = y;\n  if(s[idx].second == 'x') x2++;\n  else y2++;\n  vector<int> useidx1;\n  REP(r, 4){\n    int nx = x + dx[r], ny = y + dy[r];\n    if(m.count(P(nx, ny))){\n      useidx1.push_back(m[P(nx, ny)]);\n    }\n  }\n  vector<int> useidx2;\n  REP(r, 4){\n    int nx = x2 + dx[r], ny = y2 + dy[r];\n    if(m.count(P(nx, ny))){\n      useidx2.push_back(m[P(nx, ny)]);\n    }\n  }\n  REP(iter, 2){\n    if(!h_used[m[P(x, y)]] && !l_used[m[P(x2, y2)]]){\n      //printf(\"put (%d, %d) idx = %d\\n\", x, y, idx);\n      //printf(\"leg is (%d, %d)\\n\", x2, y2);\n      REP(i, useidx1.size()) l_used[useidx1[i]] = true;\n      REP(i, useidx2.size()) h_used[useidx2[i]] = true;\n      if(dfs(idx + 1)) return true;\n      REP(i, useidx1.size()) l_used[useidx1[i]] = false;\n      REP(i, useidx2.size()) h_used[useidx2[i]] = false;\n    }\n    if(iter == 0){\n      swap(x, x2); swap(y, y2); swap(useidx1, useidx2);\n    }\n  }\n  return false;\n}\nint main(){\n  while(cin>>N && N){\n    m.clear();\n    int ID = 0;\n    REP(i, N) scanf(\"%d %d %c\", &s[i].first.first, &s[i].first.second, &s[i].second);\n    sort(s, s + N);\n    REP(i, N){\n      int x = s[i].first.first, y = s[i].first.second;\n      m[P(x, y)] = ID++;\n      if(s[i].second == 'x'){\n        m[P(x + 1, y)] = ID++;\n      }else{\n        m[P(x, y + 1)] = ID++;\n      }\n    }\n    memset(h_used, 0, sizeof(h_used));\n    memset(l_used, 0, sizeof(l_used));\n    if(dfs(0)){\n      cout<<\"Yes\"<<endl;\n    }else{\n      cout<<\"No\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION false\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nstruct futon {\n\tPII cells[2];\n};\n\nvector<futon> futons;\nmap<PII, bool> is_head;\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tfutons.clear();\n\t\tis_head.clear();\n\t\tREP (i, n) {\n\t\t\tint x, y; cin >> x >> y; char d; cin >> d;\n\t\t\tfuton f; f.cells[0] = MP(y, x); f.cells[1] = MP(y+(d=='y'), x+(d=='x'));\n\t\t\tfutons.PB(f);\n\t\t}\n\t\tREP (i, n) {\n\t\t\tPII p = futons[i].cells[0];\n\t\t\t// Look around\n\t\t\tbool free = true, adj_head = false;\n\t\t\tREP (d, 4) {\n\t\t\t\tint y = p.F + dy[d], x = p.S + dx[d];\n\t\t\t\tif (EXIST(is_head, MP(y, x))) {\n\t\t\t\t\tdprt(\"(%d, %d) is %d, free: %d, adj_head: %d\\n\", x, y, is_head[MP(y, x)], free, adj_head);\n\t\t\t\t\tif (free) {\n\t\t\t\t\t\tif (is_head[MP(y, x)] == true) adj_head = true;\n\t\t\t\t\t\telse adj_head = false;\n\t\t\t\t\t\tadj_head = is_head[MP(y, x)];\n\t\t\t\t\t\tfree = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (is_head[MP(y, x)] == true && !adj_head) goto NO;\n\t\t\t\t\t\telse if (is_head[MP(y, x)] == false && adj_head) goto NO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Opposite cell\n\t\t\tbool head = !adj_head;\n\t\t\tPII op = futons[i].cells[1];\n\t\t\t// Look around\n\t\t\tREP (d, 4) {\n\t\t\t\tint y = op.F + dy[d], x = op.S + dx[d];\n\t\t\t\tif (EXIST(is_head, MP(y, x))) {\n\t\t\t\t\tif (is_head[MP(y, x)] == true && !head) goto NO;\n\t\t\t\t\telse if (is_head[MP(y, x)] == false && head) goto NO;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Here is valid\n\t\t\tis_head[MP(p.F, p.S)] = adj_head;\n\t\t\tis_head[MP(op.F, op.S)] = head;\n\t\t\tdprt(\"(%d, %d) = %d, (%d, %d) = %d\\n\", p.S, p.F, adj_head, op.S, op.F, head);\n\t\t}\nYES:\n\t\tcout << \"Yes\" << endl;\n\t\tcontinue;\nNO:\n\t\tcout << \"No\" << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<map>\nusing namespace std;\nint UF[100000];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);\n\tif(a==b)return;\n\tUF[a]+=UF[b];UF[b]=a;\n}\nchar in[2];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint x[30000];\nint y[30000];\nchar d[30000];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tmap<pair<int,int>,int>m;\n\t\tfor(int i=0;i<a*4;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint p,q;\n\t\t\tscanf(\"%d%d%s\",&p,&q,in);\n\t\t\tx[i]=p;y[i]=q;d[i]=in[0];\n\t\t\tm[make_pair(p,q)]=i*2;\n\t\t\tif(in[0]=='y'){\n\t\t\t\tm[make_pair(p,q+1)]=i*2+1;\n\t\t\t}else{\n\t\t\t\tm[make_pair(p+1,q)]=i*2+1;\n\t\t\t}\n\t\t\tUNION(i*2*2,(i*2+1)*2+1);UNION(i*2*2+1,(i*2+1)*2);\n\t\t}\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint xt=x[i];int yt=y[i];\n\t\t\tif(d[i]=='x')xt++;\n\t\t\telse yt++;\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(x[i]+dx[j]==xt&&y[i]+dy[j]==yt)continue;\n\t\t\t\tif(!m.count(make_pair(x[i]+dx[j],y[i]+dy[j])))continue;\n\t\t\t\tUNION(i*2*2,m[make_pair(x[i]+dx[j],y[i]+dy[j])]*2);\n\t\t\t\tUNION(i*2*2+1,m[make_pair(x[i]+dx[j],y[i]+dy[j])]*2+1);\n\t\t\t}\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tif(x[i]-dx[j]==xt&&y[i]-dy[j]==yt)continue;\n\t\t\t\tif(!m.count(make_pair(xt+dx[j],yt+dy[j])))continue;\n\t\t\t\tUNION((i*2+1)*2,m[make_pair(xt+dx[j],yt+dy[j])]*2);\n\t\t\t\tUNION((i*2+1)*2+1,m[make_pair(xt+dx[j],yt+dy[j])]*2+1);\n\t\t\t}\n\t\t}\n\t\tbool ok=true;\n\t\tfor(int i=0;i<a*2;i++)if(FIND(i*2)==FIND(i*2+1))ok=false;\n\t\tif(ok)printf(\"Yes\\n\");\n\t\telse printf(\"No\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\nint const OppoSide = 0;\nint const SameSide = 1;\n\nint N;\nvector<pair<int, int>> G[44444];\nmap<pair<int, int>, int> MP;\nmap<int, pair<int, int>> CD;\nint vis[44444];\n\nbool dfs(int curr, int col) {\n  for(auto& e: G[curr]) {\n    int next, dir; tie(next, dir) = e;\n    int nextCol = dir == OppoSide ? col ^ 1 : col;\n    if(vis[next] + 1) {\n      if(vis[next] != nextCol) return false;\n    } else {\n      vis[next] = nextCol;\n      if(!dfs(next, nextCol)) return false;\n    }\n  }\n  return true;\n}\n\nint main() {\n\n  for(int M; cin >> M && M;) {\n    vector<int> xs, ys;\n    vector<int> X, Y; vector<char> D;\n    rep(i, M) {\n      int x, y; char d; cin >> x >> y >> d;\n      X.push_back(x), Y.push_back(y), D.push_back(d);\n\n      xs.push_back(x-1),  ys.push_back(y-1);\n      xs.push_back(x),    ys.push_back(y);\n      xs.push_back(x+1),  ys.push_back(y+1);\n\n      if(d == 'x') {\n        xs.push_back(x+2);\n      } else {\n        ys.push_back(y+2);\n      }\n\n    }\n\n    sort(all(xs)); xs.erase(unique(all(xs)), xs.end());\n    sort(all(ys)); ys.erase(unique(all(ys)), ys.end());\n\n    vector<int> NX, NY;\n    rep(i, X.size()) {\n      NX.push_back(lower_bound(all(xs), X[i]) - X.begin());\n    }\n    rep(i, Y.size()) {\n      NY.push_back(lower_bound(all(ys), Y[i]) - Y.begin());\n    }\n    X = NX, Y = NY;\n\n    MP.clear(), CD.clear();\n    rep(i, 44444) G[i].clear();\n    N = 0;\n\n    rep(i, X.size()) {\n      MP[make_pair(Y[i], X[i])] = N;\n      CD[N++] = make_pair(Y[i], X[i]);\n      if(D[i] == 'x') {\n        MP[make_pair(Y[i], X[i]+1)] = N;\n        CD[N] = make_pair(Y[i], X[i]+1);\n        G[N-1].emplace_back(N, OppoSide), G[N].emplace_back(N-1, OppoSide);\n        N++;\n      } else {\n        MP[make_pair(Y[i]+1, X[i])] = N;\n        CD[N] = make_pair(Y[i]+1, X[i]);\n        G[N-1].emplace_back(N, OppoSide), G[N].emplace_back(N-1, OppoSide);\n        N++;\n      }\n    }\n\n    rep(i, N) {\n      auto curr = CD[i];\n      rep(k, 4) {\n        auto next = make_pair(CD[i].first + dy[k], CD[i].second + dx[k]);\n        if(MP.find(next) == MP.end()) continue; // テ・ツクツε・ツ崢」テ」ツ??」ツ?妥ィツェツソテ」ツ?ケテ」ツつ古」ツ?ーOK\n        if(find(all(G[i]), make_pair(MP[next], OppoSide)) != G[i].end()) continue;  // テ・ツ按・テ」ツ?ョテ・ツクツε・ツ崢」テ」ツ?ッSameSideテ」ツ?療」ツ?凝・ツ?・テ」ツつ古」ツつ暗」ツ??」ツ?ィテ」ツ?療」ツ?ェテ」ツ??」ツ?凝」ツつ碓K\n        G[i].emplace_back(MP[next], SameSide);\n      }\n    }\n\n    minus(vis);\n\n    bool ok = 1;\n\n    rep(i, N) {\n      if(vis[i] < 0) {\n        vis[i] = 0;\n        if(!dfs(i, 0)) {\n          ok = 0;\n          break;\n        }\n      }\n    }\n\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(_vs) for(auto _x : _vs){cout << _x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(_p) cout << _p.first << \" \" << _p.second << endl\n#define printVP(_vp) for(auto _p : _vp) printP(_p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vector<int>> Graph;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\nstruct Point {\n    int x, y, id;\n    Point(){}\n    Point(int _x, int _y, int _id) : x(_x), y(_y), id(_id) {}\n};\n\nbool cmp_Yx(const Point& p, const Point& q) {\n    if (p.y != q.y) return p.y < q.y;\n    if (p.x != q.x) return p.x < q.x;\n    assert(false);\n}\n\nbool cmp_Xy(const Point& p, const Point& q) {\n    if (p.x != q.x) return p.x < q.x;\n    if (p.y != q.y) return p.y < q.y;\n    assert(false);\n}\n\nbool adjecent(const Point& p, const Point& q) {\n    if (p.x == q.x && abs(p.y - q.y) == 1) return true;\n    if (p.y == q.y && abs(p.x - q.x) == 1) return true;\n    return false;\n}\n\n// undirected\nvoid addEdge(Graph& G, int x, int y) {\n    G[x].emplace_back(y);\n    G[y].emplace_back(x);\n}\n\nvoid solve(int n) {\n    vector<Point> p;\n    rep(i, n) {\n        int x, y;\n        char dir;\n        cin >> x >> y >> dir;\n        p.emplace_back(x, y, 2 * i);\n        if (dir == 'x') {\n            p.emplace_back(x + 1, y, 2 * i + 1);\n        } else {\n            p.emplace_back(x, y + 1, 2 * i + 1);\n        }\n    }\n\n    Graph G(2 * n);\n\n    // horizontal edge\n    sort(all(p), cmp_Yx);\n    rep(i, 2 * n - 1) {\n        if (p[i].y == p[i + 1].y && p[i + 1].x - p[i].x == 1) {\n            addEdge(G, p[i].id, p[i + 1].id);\n        }\n    }\n\n    // vertical edge\n    sort(all(p), cmp_Xy);\n    rep(i, 2 * n - 1) {\n        if (p[i].x == p[i + 1].x && p[i + 1].y - p[i].y == 1) {\n            addEdge(G, p[i].id, p[i + 1].id);\n        }\n    }\n\n    // printVV(G);\n\n    vector<int> color(2 * n, -1);\n\n    std::function<bool(int,int)> dfs = [&](int i, int c) {\n        // cout << i << \" \" << c << endl;\n        color[i] = c;\n\n        for (auto j : G[i]) {\n            if (color[j] == -1) continue;\n            if (i / 2 == j / 2 && color[i] == color[j]) {\n                // same futon but same color\n                return false;\n            }\n            if (i / 2 != j / 2 && color[i] != color[j]) {\n                // adjecent cells in different futons but different color\n                return false;\n            }\n        }\n\n        for (auto j : G[i]) {\n            if (color[j] != -1) continue;\n            if (i / 2 == j / 2) {\n                // same futon\n                if (!dfs(j, c^1)) {\n                    return false;\n                }\n            } else {\n                // other futon\n                if (!dfs(j, c)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    };\n\n    rep(i, 2 * n) {\n        // cout << \"i = \" << i << \":\" << endl;\n        if (color[i] == -1 && !dfs(i, 0)) {\n            cout << \"No\" << endl;\n            return;\n        }\n    }\n\n    // printV(color);\n\n    cout << \"Yes\" << endl;\n    // cout << endl;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    while (cin >> n, n) {\n        solve(n);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define MAX 10000\n#define F_MAX 20000\n\nint n;\nint field[MAX][MAX];\n\nstruct futon{\n\tint x[2], y[2];\n};\n\nfuton F[F_MAX];\n\nint dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nbool dfs( int pos ){\n\tif( pos == n ) return true;\n\tbool rep = false;\n\tfor( int i = 0; i < 2; i++ ){\n\t\tint legx, legy, headx, heady;\n\t\tlegx = F[pos].x[i];\n\t\tlegy = F[pos].y[i];\n\t\theadx = F[pos].x[1-i];\n\t\theady = F[pos].y[1-i];\n\t\t//cout << \"----\" << pos << \"------\" << endl;\n\t\t//cout << legx << \" \" << legy << \" \" << headx << \" \" << heady << endl;\n\t\tbool ok = true;\n\t\tfor( int j = 0; j < 4; j++ ){\n\t\t\tif( (0 <= legx+dx[j] && legx+dx[j] < MAX) && (0 <= legy+dy[j] && legy+dy[j] < MAX) ){\n\t\t\t\tif( field[legx+dx[j]][legy+dy[j]] == 1 ) ok = false;\n\t\t\t}\n\t\t\tif( (0 <= headx+dx[j] && headx+dx[j] < MAX) && (0 <= heady+dy[j] && heady+dy[j] < MAX) ){\n\t\t\t\tif( field[headx+dx[j]][heady+dy[j]] == 2 ) ok = false;\n\t\t\t}\n\t\t}\n\t\tif( !ok ) continue;\n\t\tfield[headx][heady] = 1;\n\t\tfield[legx][legy] = 2;\n\t\tif( dfs(pos+1) ) rep = true;\n\t\tfield[headx][heady] = 0;\n\t\tfield[legx][legy] = 0;\n\t}\n\treturn rep;\n}\n\nint main(){\n\twhile( cin >> n, n ){\n\t\tfor( int i = 0; i < n; i++ ){\n\t\t\tint x, y;\n\t\t\tchar d;\n\t\t\tcin >> x >> y >> d;\n\t\t\tF[i].x[0] = x;\n\t\t\tF[i].y[0] = y;\n\t\t\tF[i].x[1] = (d == 'x') ? x+1 : x;\n\t\t\tF[i].y[1] = (d == 'x') ? y : y+1;\n\t\t}\n\t\tfor( int j = 0; j < MAX; j++ ){\n\t\t\tfor( int k = 0; k < MAX; k++ ){\n\t\t\t\tfield[j][k] = 0;\n\t\t\t}\n\t\t}\n\t\t/*for( int i = 0; i < n; i++ ){\n\t\t\tfor( int j = 0; j < 2; j++ ){\n\t\t\t\tcout << F[i].x[j] << \" \" << F[i].y[j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tif( dfs(0) ) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 40000\ntypedef pair<int,int> pii;\n\nmap<pii,int> mp,color;\nint x[MAX],y[MAX];\nchar ch[MAX];\nbool visited[MAX];\nconst int dx[4] = {-1,0,1,0};\nconst int dy[4] = {0,-1,0,1};\n\nbool dfs(int v,int c){\n  pii p = pii(x[v],y[v]);\n  if(color.find(p) != color.end()){\n    return (color[p] == c);\n  }\n  if(visited[v]){ return true; }\n  visited[v] = true;\n  visited[(v&1?v-1:v+1)] = true;\n  color[p] = c;\n  if(ch[v] == 'x'){\n    int d = (v&1 ? -1 : 1);\n    color[pii(x[v]+d,y[v])] = 1-c;\n    for(int i = 0 ; i < 2 ; i++){\n      int X = x[v]+i*d,Y = y[v];\n      for(int j = 0 ; j < 4 ; j++){\n        int nx = X+dx[j],ny = Y+dy[j];\n        if(mp.find(pii(nx,ny)) != mp.end()){\n          int next = mp[pii(nx,ny)];\n          if(mp[pii(X,Y)]/2 == next/2){ continue; }\n          if(dfs(next,(c+i)%2)){\n            return true;\n          }\n        }\n      }\n    }\n  }else{\n    int d = (v&1 ? -1 : 1);\n    color[pii(x[v],y[v]+d)] = 1-c;\n    for(int i = 0 ; i < 2 ; i++){\n      int X = x[v],Y = y[v]+i*d;\n      for(int j = 0 ; j < 4 ; j++){\n        int nx = X+dx[j],ny = Y+dy[j];\n        if(mp.find(pii(nx,ny)) != mp.end()){\n          int next = mp[pii(nx,ny)];\n          if(mp[pii(X,Y)]/2 == next/2){ continue; }\n          if(dfs(next,(c+i)%2)){\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return true;\n}\n\nint main(){\n  int N;\n  while(cin >> N,N){\n    mp.clear();\n    for(int i = 0 ; i < N ; i++){\n      int j = i*2;\n      cin >> x[j] >> y[j] >> ch[j];\n      pii a = pii(x[j],y[j]),b;\n      ch[j+1] = ch[j];\n      if(ch[j] == 'x'){\n        x[j+1] = x[j]+1; y[j+1] = y[j];\n        b = pii(x[j+1],y[j+1]);\n        mp[a] = j;\n        mp[b] = j+1;\n      }else{\n        x[j+1] = x[j]; y[j+1] = y[j]+1;\n        b = pii(x[j+1],y[j+1]);\n        mp[a] = j;\n        mp[b] = j+1;\n      }\n      visited[i] = false;\n    }\n    bool can = true;\n    for(int i = 0 ; i < 2*N ; i+=2){\n      if(visited[i]){ continue; }\n      if(!dfs(i,0)){\n        can = false;\n        break;\n      }\n    }\n    cout << (can ? \"Yes\" : \"No\") << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\n#include \"bits/stdc++.h\"\nstruct UnionFind {\n\tstd::vector<int> par;\n\tstd::vector<int> sizes;\n\n\tUnionFind(int n) {\n\t\tpar.resize(n);\n\t\tsizes.resize(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tpar[i] = i;\n\t\t\tsizes[i] = 1;\n\t\t}\n\t}\n\n\tint root(int a) {\n\t\treturn par[a] == a ? a : par[a] = root(par[a]);\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x == y)return;\n\t\tif (sizes[x] < sizes[y]) std::swap(x, y);\n\n\t\tpar[y] = x;\n\t\tsizes[x] += sizes[y];\n\t}\n\tint size(int x) {\n\t\treturn sizes[root(x)];\n\t}\n};\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\twhile (cin >> n, n) {\n\t\tint m = 2 * n;\n\t\tvector<pair<pll, ll>> v;\n\t\tREP(i, n) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tchar c; cin >> c;\n\t\t\tv.push_back({ { x,y },2 * i });\n\t\t\tif (c == 'x') {\n\t\t\t\tv.push_back({ {x + 1,y},2 * i + 1 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tv.push_back({ {x,y + 1},2 * i + 1 });\n\t\t\t}\n\t\t}\n\t\tUnionFind uf(m);\n\t\tbool ok = true;\n\t\tsort(ALL(v));\n\t\tREP(i, m - 1) {\n\t\t\tif (v[i].first.first == v[i + 1].first.first && v[i].first.second && v[i + 1].first.second - 1) {\n\t\t\t\tif (uf.same(v[i].second, v[i + 1].second))ok = false;\n\t\t\t\tuf.unite( v[i].second,v[i + 1].second );\n\t\t\t}\n\t\t}\n\t\tREP(i, m) {\n\t\t\tswap(v[i].first.first, v[i].first.second);\n\t\t}\n\t\tsort(ALL(v));\n\t\tREP(i, m - 1) {\n\t\t\tif (v[i].first.first == v[i + 1].first.first && v[i].first.second && v[i + 1].first.second - 1) {\n\t\t\t\tif (uf.same(v[i].second, v[i + 1].second))ok = false;\n\t\t\t\tuf.unite(v[i].second, v[i + 1].second);\n\t\t\t}\n\t\t}\n\t\tif (ok)cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n;\nP p[2][20100];\nchar d;\nvector<P> g[20100];\nint vis[20100];\n\nvoid add_edge(int u,int v,int col){\n  g[v].push_back(P(u,col));\n  g[u].push_back(P(v,col));\n}\n\nint md(P a, P b){\n  return abs(a.first-b.first) + abs(a.second-b.second);\n}\n\nbool dfs(int v,int col){\n  if(vis[v]>=0)return (vis[v]==col);\n  vis[v] = col;\n\n  for(int i=0;i<g[v].size();i++){\n    if(!dfs(g[v][i].first,col^g[v][i].second))return false;\n  }\n  return true;\n}\n\nint main(){\n  cin.tie(0); std::ios::sync_with_stdio(false);\n\n  while(cin >> n,n){\n    for(int i=0;i<n;i++){\n      cin >> p[0][i].first >> p[0][i].second >> d;\n      p[1][i].first = p[0][i].first + (d=='x');\n      p[1][i].second = p[0][i].second + (d=='y');\n    }\n    \n    for(int i=0;i<n;i++)g[i].clear();\n\n    int gs = 0;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(md(p[0][i],p[0][j])<=3){\n\t  bool f = true;\n\t  for(int ii=0;f,ii<2;ii++){\n\t    for(int jj=0;f,jj<2;jj++){\n\t      if(md(p[ii][i],p[jj][j])==1){\n\t\tadd_edge(i,j,ii!=jj); gs += 2;\n\t\tf = false;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    bool flag = true;\n    memset(vis,-1,sizeof(vis));\n\n    for(int i=0;i<n;i++){\n      if(vis[i]<0)flag &= dfs(i,0);\n      if(!flag)break;\n    }\n    cout << (flag?\"Yes\":\"No\") << endl;\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint N,X[20005],Y[20005],D[20005],f[20005][6],i,j,k;\nint A[2][6][2]={{{-1,0},{0,-1},{1,-1},{2,0},{1,1},{0,1}}\n,{{-1,0},{-1,1},{0,2},{1,-1},{1,0},{0,-1}}};\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(f,-1,sizeof(f));\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d %c\\n\",&X[i],&Y[i],&D[i]);\n\t\t\tD[i]-='x';\n\t\t\tfor(j=0;j<i;j++)\n\t\t\t\tfor(k=0;k<6;k++)\n\t\t\t\t{\n\t\t\t\t\tif(X[j]==X[i]+A[D[i]][k][0]&&Y[j]==Y[i]+A[D[i]][k][1])f[i][k]=j;\n\t\t\t\t\telse if((X[j]+D[j]?0:1)==X[i]+A[D[i]][k][0]&&(Y[j]+D[j]?1:0)==Y[i]+A[D[i]][k][1])f[i][k]=j;\n\t\t\t\t}\n\t\t}\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tif(!D[i]&&((f[i][1]==f[i][2]&&f[i][1]!=-1)||(f[i][4]==f[i][5]&&f[i][4]!=-1)))break;\n\t\t\telse if(D[i]&&((f[i][0]==f[i][1]&&f[i][0]!=-1)||(f[i][3]==f[i][4]&&f[i][4]!=-1)))break;\n\t\t}\n\t\tputs(i==N?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \ntypedef struct futon{\n    int x;\n    int y;\n    char dir;\n    int alignment;//??????????????????\n    int isChecked;\n    int number_of_adjacent;\n    struct futon* adjacent[6];\n    int adjacent_type[6];\n} futon;\nfuton futons[20000];\nint isAdjacent(futon* a, futon* b);\nint check(futon* object);\nint comp(const void *a, const void *b);\n \nint main(void){\n    int number_of_futon;\n    while(scanf(\"%d\", &number_of_futon),number_of_futon){\n        int i,j;\n        int isNo=0;\n        for(i=0;i<number_of_futon;i++){\n            scanf(\"%d %d %c\", &(futons[i].x), &(futons[i].y), &(futons[i].dir));\n            futons[i].alignment=-1;\n            futons[i].number_of_adjacent=0;\n            futons[i].isChecked=0;\n        }\n        qsort(futons, number_of_futon, sizeof(futon), comp);\n\n        for(i=0;i<number_of_futon;i++){\n            int x=futons[i].x;\n            for(j=0;j<i;j++){\n                if(futons[j].x>=x-2) break;\n            }\n            for(;j<i;j++){\n                if(futons[j].x>x+2) break;\n                int adjacent_type=isAdjacent(&futons[i], &futons[j]);\n                if(adjacent_type){\n                    futons[i].adjacent[futons[i].number_of_adjacent]=&futons[j];\n                    futons[i].adjacent_type[futons[i].number_of_adjacent]=adjacent_type;\n                    futons[i].number_of_adjacent++;\n                    futons[j].adjacent[futons[j].number_of_adjacent]=&futons[i];\n                    futons[j].adjacent_type[futons[j].number_of_adjacent]=adjacent_type;\n                    futons[j].number_of_adjacent++;\n                }\n            }\n        }\n        //?????°??????????????????\n        for(i=0;i<number_of_futon;i++){\n            if(futons[i].isChecked) continue;\n            if(check(&futons[i])==-1){\n                break;\n            }\n        }\n        if(i==number_of_futon){\n            printf(\"Yes\\n\");\n        }else{\n            printf(\"No\\n\");\n        }\n    }\n    return 0;\n}\n\nint isAdjacent(futon* a, futon* b){//??\\?§?????????????????????°0\n    int Ax1, Ax2, Ay1, Ay2, Bx1, Bx2, By1, By2;\n    Ax1=a->x;\n    Ay1=a->y;\n    if(a->dir=='x'){\n        Ax2=a->x+1;\n        Ay2=a->y;\n    }else{\n        Ax2=a->x;\n        Ay2=a->y+1;\n    }\n    Bx1=b->x;\n    By1=b->y;\n    if(b->dir=='x'){\n        Bx2=b->x+1;\n        By2=b->y;\n    }else{\n        Bx2=b->x;\n        By2=b->y+1;\n    }\n    if(abs(Ax1-Bx1)+abs(Ay1-By1)==1) return 1;\n    if(abs(Ax1-Bx2)+abs(Ay1-By2)==1) return 2;\n    if(abs(Ax2-Bx1)+abs(Ay2-By1)==1) return 2;\n    if(abs(Ax2-Bx2)+abs(Ay2-By2)==1) return 1;\n    return 0;\n}\nint check(futon* object){\n    if(object->isChecked){\n        return 0;\n    }\n    object->isChecked=1;\n    if(object->number_of_adjacent==0){\n        return 0;\n    }\n    if(object->alignment==-1){\n        object->alignment=1;\n    }\n    int i;\n    for(i=0;i<object->number_of_adjacent;i++){\n        switch(object->adjacent_type[i]){\n            case 1:\n                if(object->adjacent[i]->alignment==-1){\n                    object->adjacent[i]->alignment=object->alignment;\n                }else{\n                    if(object->adjacent[i]->alignment!=object->alignment) return -1;\n                }\n                break;\n            case 2:\n                if(object->adjacent[i]->alignment==-1){\n                    object->adjacent[i]->alignment=object->alignment^1;\n                }else{\n                    if(object->adjacent[i]->alignment==object->alignment) return -1;\n                }\n                break;\n        }\n        if(object->adjacent[i]->isChecked==0){\n            if(check(object->adjacent[i])==-1) return -1;            \n        }\n    }\n    return 0;\n}\n\nint comp(const void *c1, const void *c2){\n    futon *a = (futon *)c1;\n    futon *b = (futon *)c2;\n    return a->x - b->x;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \ntypedef struct futon{\n    int x;\n    int y;\n    char dir;\n    int alignment;//??????????????????\n    int isChecked;\n    int number_of_adjacent;\n    struct futon* adjacent[6];\n    int adjacent_type[6];\n} futon;\nfuton futons[20000];\nint isAdjacent(futon* a, futon* b);\nint check(futon* object);\nint comp(const void *a, const void *b);\n \nint main(void){\n    int number_of_futon;\n    while(scanf(\"%d\", &number_of_futon),number_of_futon){\n        int i,j;\n        int isNo=0;\n        for(i=0;i<number_of_futon;i++){\n            scanf(\"%d %d %c\", &(futons[i].x), &(futons[i].y), &(futons[i].dir));\n            futons[i].alignment=-1;\n            futons[i].number_of_adjacent=0;\n            futons[i].isChecked=0;\n        }\n        qsort(futons, number_of_futon, sizeof(futon), comp);\n\n        for(i=0;i<number_of_futon;i++){\n            int x=futons[i].x;\n            for(j=0;j<i;j++){\n                if(futons[j].x>=x-2) break;\n            }\n            for(;j<i;j++){\n                if(futons[j].x>x+2) break;\n                int adjacent_type=isAdjacent(&futons[i], &futons[j]);\n                if(adjacent_type){\n                    futons[i].adjacent[futons[i].number_of_adjacent]=&futons[j];\n                    futons[i].adjacent_type[futons[i].number_of_adjacent]=adjacent_type;\n                    futons[i].number_of_adjacent++;\n                    futons[j].adjacent[futons[j].number_of_adjacent]=&futons[i];\n                    futons[j].adjacent_type[futons[j].number_of_adjacent]=adjacent_type;\n                    futons[j].number_of_adjacent++;\n                }\n            }\n        }\n        //?????°??????????????????\n        for(i=0;i<number_of_futon;i++){\n            if(futons[i].isChecked) continue;\n            if(check(&futons[i])==-1){\n                break;\n            }\n        }\n        if(i==number_of_futon){\n            printf(\"Yes\\n\");\n        }else{\n            printf(\"No\\n\");\n        }\n    }\n}\n\nint isAdjacent(futon* a, futon* b){//??\\?§?????????????????????°0\n    int Ax1, Ax2, Ay1, Ay2, Bx1, Bx2, By1, By2;\n    Ax1=a->x;\n    Ay1=a->y;\n    if(a->dir=='x'){\n        Ax2=a->x+1;\n        Ay2=a->y;\n    }else{\n        Ax2=a->x;\n        Ay2=a->y+1;\n    }\n    Bx1=b->x;\n    By1=b->y;\n    if(b->dir=='x'){\n        Bx2=b->x+1;\n        By2=b->y;\n    }else{\n        Bx2=b->x;\n        By2=b->y+1;\n    }\n    if(abs(Ax1-Bx1)+abs(Ay1-By1)==1) return 1;\n    if(abs(Ax1-Bx2)+abs(Ay1-By2)==1) return 2;\n    if(abs(Ax2-Bx1)+abs(Ay2-By1)==1) return 2;\n    if(abs(Ax2-Bx2)+abs(Ay2-By2)==1) return 1;\n    return 0;\n}\nint check(futon* object){\n    if(object->isChecked){\n        return 0;\n    }\n    object->isChecked=1;\n    if(object->number_of_adjacent==0){\n        return 0;\n    }\n    if(object->alignment==-1){\n        object->alignment=1;\n    }\n    int i;\n    for(i=0;i<object->number_of_adjacent;i++){\n        switch(object->adjacent_type[i]){\n            case 1:\n                if(object->adjacent[i]->alignment==-1){\n                    object->adjacent[i]->alignment=object->alignment;\n                }else{\n                    if(object->adjacent[i]->alignment!=object->alignment) return -1;\n                }\n                break;\n            case 2:\n                if(object->adjacent[i]->alignment==-1){\n                    object->adjacent[i]->alignment=object->alignment^1;\n                }else{\n                    if(object->adjacent[i]->alignment==object->alignment) return -1;\n                }\n                break;\n        }\n        if(object->adjacent[i]->isChecked==0){\n            if(check(object->adjacent[i])==-1) return -1;            \n        }\n    }\n    return 0;\n}\n\nint comp(const void *c1, const void *c2){\n    futon *a = (futon *)c1;\n    futon *b = (futon *)c2;\n    return a->x - b->x;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint N,X[2000],Y[2000],D[2000],f[2000][6],i,j,k;\nint A[2][6][2]={{{-1,0},{0,-1},{1,-1},{2,0},{1,1},{0,1}}\n,{{-1,0},{-1,1},{0,2},{1,-1},{1,0},{0,-1}}};\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(f,-1,sizeof(f));\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d %c\\n\",&X[i],&Y[i],&D[i]);\n\t\t\tD[i]-='x';\n\t\t\tfor(j=0;j<i;j++)\n\t\t\t\tfor(k=0;k<6;k++)\n\t\t\t\t{\n\t\t\t\t\tif(X[j]==X[i]+A[D[i]][k][0]&&Y[j]==Y[i]+A[D[i]][k][1])f[i][k]=j;\n\t\t\t\t\telse if((X[j]+D[j]?0:1)==X[i]+A[D[i]][k][0]&&(Y[j]+D[j]?1:0)==Y[i]+A[D[i]][k][1])f[i][k]=j;\n\t\t\t\t}\n\t\t}\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tif(!D[i]&&((f[i][1]==f[i][2]&&f[i][1]!=-1)||(f[i][4]==f[i][5]&&f[i][4]!=-1)))break;\n\t\t\telse if(D[i]&&((f[i][0]==f[i][1]&&f[i][0]!=-1)||(f[i][3]==f[i][4]&&f[i][4]!=-1)))break;\n\t\t}\n\t\tputs(i==N?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2178 Futon\n// 2018.3.17 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 数値入力\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\nint in()  // 非負整数\n{\n\tint n = 0, c = gc();\n\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n\n// ハッシュテーブル\n#define HASHSIZ 299993\ntypedef struct { long long xy; int id; } HASH;\nHASH hash[HASHSIZ + 5], *hashend = hash + HASHSIZ;\nint hashcnt;\nint lookup(int x, int y)  // (x,y)からidを得る\n{\n\tlong long k;\n\tHASH *p;\n\tif (x < 0 || y < 0) return -1;\n\tk = ((long long)(++x) << 31) | (++y);\n\tp = hash + (int)(k % HASHSIZ);\n\twhile (p->xy) {\n\t\tif (p->xy == k) return p->id;\n\t\tif (++p == hashend) p = hash;\n\t\thashcnt++;\n\t}\n\treturn -1;\n}\n\nvoid insert(int x, int y, int id)  // (x,y)とid を記録する\n{\n\tlong long k = ((long long)(++x) << 31) | (++y);\n\tHASH *p = hash + (int)(k % HASHSIZ);\n//printf(\"insert xy (%d,%d) id=%d\\n\", x - 1, y - 1, id);\n\twhile (p->xy) {\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->xy = k, p->id = id;\n}\n\n\n/* UNION-FIND library */\n#define MAX 40050\nint id[MAX], size[MAX];\nvoid init(int n) { int i; for (i = 0; i < n; i++) id[i] = i, size[i] = 1; }\nint root(int i) { while (i != id[i]) id[i] = id[id[i]], i = id[i]; return i; }\nint connected(int p, int q) { return root(p) == root(q); }\nvoid unite(int p, int q)\n{\n\tint i = root(p), j = root(q); if (i == j) return;\n\tif (size[i] < size[j]) id[i] = j, size[j] += size[i]; else id[j] = i, size[i] += size[j];\n}\n\ntypedef struct { int id, f; } Q;\nQ q[MAX]; int top, end;\nint N, N2;                 // N2 = 2*N\nint hi[MAX], *group[MAX];\nchar flg[MAX];             // すべてのidペアは0か1に矛盾なく帰着できるか\n\nint bfs(int k, int f)\n{\n\tint i, g, x, y;\n\n\tq[0].id = k, q[0].f = f, top = 0, end = 1;\n\twhile (top != end) {\n\t\tk = q[top].id, f = q[top].f, ++top;\n\t\tg = id[k]; for (i = 0; i < hi[g]; i++) {\n\t\t\tx = group[g][i];\n\t\t\tif (flg[x] < 0) flg[x] = f;\n\t\t\telse if (flg[x] != f) return 0;\n\t\t\ty = (x & 1) ? x - 1 : x + 1;\n\t\t\tif (flg[y] < 0) q[end].id = y, q[end].f = !f, ++end;\n\t\t}\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tint i, j, k, x, y, d, t;\n\n\twhile (N = in()) {\n\t\tN2 = N << 1;\n\t\tinit(N2);     // Union Setの初期化\n\t\tmemset(hash, 0, sizeof(hash));     // ハッシュテーブルの初期化\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tx = in(), y = in(), d = gc(), gc();\n\n\t\t\tk = i << 1;\n\t\t\tif (d == 'x') {\n\t\t\t\tfor (j = -1; j <= 1; j+=2) {\n\t\t\t\t\tinsert(x, y, k);\n\t\t\t\t\tif ((t = lookup(x, y - 1)) >= 0) unite(t, k);\n\t\t\t\t\tif ((t = lookup(x + j, y)) >= 0) unite(t, k);\n\t\t\t\t\tif ((t = lookup(x, y + 1)) >= 0) unite(t, k);\n\t\t\t\t\tk++, x++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (j = -1; j <= 1; j+=2) {\n\t\t\t\t\tinsert(x, y, k);\n\t\t\t\t\tif ((t = lookup(x - 1, y)) >= 0) unite(t, k);\n\t\t\t\t\tif ((t = lookup(x, y + j)) >= 0) unite(t, k);\n\t\t\t\t\tif ((t = lookup(x + 1, y)) >= 0) unite(t, k);\n\t\t\t\t\tk++, y++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmemset(hi, 0, N2*sizeof(int));\n\t\tfor (i = 0; i < N2; i += 2) {\n\t\t\tint x = root(i), y = root(i + 1);\n\t\t\tif (x == y) goto No;\n\t\t\thi[x]++, hi[y]++;\n\t\t}\n\t\tfor (i = 0; i < N2; i++) if (hi[i] > 0) group[i] = malloc(hi[i] * sizeof(int));\n\t\tmemset(hi, 0, N2*sizeof(int));\n\t\tfor (i = 0; i < N2; i++) group[id[i]][hi[id[i]]++] = i;\n\t\t\n\t\tmemset(flg, -1, N2*sizeof(char));\n\t\tfor (i = 0; i < N2; i++) if (flg[i] < 0) {\n\t\t\tif (!(t = bfs(i, 0))) break;\n\t\t}\n\t\tfor (i = 0; i < N2; i++) if (hi[i] > 0) free(group[i]);\n\n\t\tif (t) {\n\t\t\tfor (i = 0; i < N2; i += 2) if (flg[i] == flg[i + 1]) goto No;\n\t\t\tputs(\"Yes\");\n\t\t}\n\t\telse {\nNo:\t\t\tputs(\"No\");\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct futon{\n    int x;\n    int y;\n    char dir;\n    int alignment;//??????????????????\n    int isChecked;\n    int number_of_adjacent;\n    struct futon* adjacent[6];\n    int adjacent_type[6];\n} futon;\nfuton futons[20000];\nchar direction;\nint isAdjacent(futon* a, futon* b);\nint check(futon* object);\n\nint main(void){\n    int number_of_futon;\n    while(scanf(\"%d\", &number_of_futon),number_of_futon){\n        int i,j;\n        for(i=0;i<number_of_futon;i++){//??°???????????????\n            scanf(\"%d %d %c\", &(futons[i].x), &(futons[i].y), &direction);\n            futons[i].dir=direction;\n            futons[i].number_of_adjacent=0;\n            futons[i].isChecked=0;\n            futons[i].alignment=-1;\n            for(j=0;j<i;j++){\n                int adjacent_type=isAdjacent(&futons[i], &futons[j]);\n                if(adjacent_type){\n                    futons[i].adjacent[futons[i].number_of_adjacent]=&futons[j];\n                    futons[i].adjacent_type[futons[i].number_of_adjacent]=adjacent_type;\n                    futons[i].number_of_adjacent++;\n                    futons[j].adjacent[futons[j].number_of_adjacent]=&futons[i];\n                    futons[j].adjacent_type[futons[j].number_of_adjacent]=adjacent_type;\n                    futons[j].number_of_adjacent++;\n                }\n            }\n        }\n        //?????°??????????????????\n        for(i=0;i<number_of_futon;i++){\n            if(futons[i].isChecked) continue;\n            if(check(&futons[i])==-1){\n                break;\n            }\n        }\n        if(i==number_of_futon){\n            printf(\"Yes\\n\");\n        }else{\n            printf(\"No\\n\");\n        }\n    }\n}\n\nint check(futon* object){\n    if(object->isChecked){\n        return 0;\n    }\n    object->isChecked=1;\n    if(object->number_of_adjacent==0){\n        return 0;\n    }\n    if(object->alignment==-1){\n        object->alignment=1;\n    }\n    int i;\n    for(i=0;i<object->number_of_adjacent;i++){\n        switch(object->adjacent_type[i]){\n            case 1:\n                if(object->adjacent[i]->alignment==-1){\n                    object->adjacent[i]->alignment=object->alignment;\n                }else{\n                    if(object->adjacent[i]->alignment!=object->alignment) return -1;\n                }\n                break;\n            case 2:\n                if(object->adjacent[i]->alignment==-1){\n                    object->adjacent[i]->alignment=object->alignment^1;\n                }else{\n                    if(object->adjacent[i]->alignment==object->alignment) return -1;\n                }\n                break;\n        }\n        if(object->adjacent[i]->isChecked==0){\n            if(check(object->adjacent[i])==-1) return -1;            \n        }\n    }\n    return 0;\n}\n\nint isAdjacent(futon* a, futon* b){//??\\?§?????????????1???????????????????????°0\n    int Ax1, Ax2, Ay1, Ay2, Bx1, Bx2, By1, By2;\n    Ax1=a->x;\n    Ay1=a->y;\n    if(a->dir=='x'){\n        Ax2=a->x+1;\n        Ay2=a->y;\n    }else{\n        Ax2=a->x;\n        Ay2=a->y+1;\n    }\n    Bx1=b->x;\n    By1=b->y;\n    if(b->dir=='x'){\n        Bx2=b->x+1;\n        By2=b->y;\n    }else{\n        Bx2=b->x;\n        By2=b->y+1;\n    }\n    if(abs(Ax1-Bx1)+abs(Ay1-By1)==1) return 1;\n    if(abs(Ax1-Bx2)+abs(Ay1-By2)==1) return 2;\n    if(abs(Ax2-Bx1)+abs(Ay2-By1)==1) return 2;\n    if(abs(Ax2-Bx2)+abs(Ay2-By2)==1) return 1;\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint N,X[40005],Y[40005],D,G[40005],f[40005][4],m[5]={0,1,0,-1,0},i,j,k,l,c;\nint dfs(int p,int c)\n{\n\tint i;\n\tG[p]=c;\n\tfor(i=0;i<4;i++)\n\t\tif(f[p][i]!=-1)\n\t\t{\n\t\t\tif((p%2==0&&p+1==f[p][i])||(p%2==1&&p-1==f[p][i]))//same_futon\n\t\t\t{\n\t\t\t\tif(G[f[p][i]]==c)\n\t\t\t\t\treturn 0;\n\t\t\t\telse if(G[f[p][i]]==-1&&dfs(f[p][i],!c)==0)\n\t\t\t\t\treturn 0;\n\t\t\t\telse continue;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(G[f[p][i]]!=-1&&G[f[p][i]]!=c)\n\t\t\t\t\treturn 0;\n\t\t\t\telse if(G[f[p][i]]==-1&&dfs(f[p][i],c)==0)\n\t\t\t\t\treturn 0;\n\t\t\t\telse continue;\n\t\t\t}\n\t\t}\n\treturn 1;\n}\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(f,-1,sizeof(f));\n\t\tmemset(G,-1,sizeof(G));\n\t\tfor(i=j=0;i<N;i++,j+=2)\n\t\t{\n\t\t\tscanf(\"%d%d %c\\n\",&X[j],&Y[j],&D);\n\t\t\tX[j+1]=X[j]+(D=='x'?1:0);\n\t\t\tY[j+1]=Y[j]+(D=='x'?0:1);\n\t\t}\n\t\tfor(i=0;i<2*N;i++)\n\t\t\tfor(j=0;j<2*N;j++)\n\t\t\t\tfor(k=0;k<4;k++)\n\t\t\t\t\tif(X[i]+m[k]==X[j]&&Y[i]+m[k+1]==Y[j])\n\t\t\t\t\t\tf[i][k]=j;\n\t\tfor(i=0;i<2*N;i++)\n\t\t\tif(G[i]==-1&&dfs(i,0)==0)break;\n\t\tputs(i==2*N?\"Yes\":\"No\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct futon{\n    int x;\n    int y;\n    char dir;\n    int alignment;//??????????????????\n    int isChecked;\n    int number_of_adjacent;\n    struct futon* adjacent[6];\n    int adjacent_type[6];\n} futon;\nfuton futons[20000];\nchar buf[3];\nint isAdjacent(futon* a, futon* b);\nint check(futon* object);\n\nint main(void){\n    int number_of_futon;\n    while(scanf(\"%d\", &number_of_futon),number_of_futon){\n        int i,j;\n        for(i=0;i<number_of_futon;i++){//??°???????????????\n            scanf(\"%d %d %s\", &(futons[i].x), &(futons[i].y), buf);\n            futons[i].dir=buf[0];\n            futons[i].number_of_adjacent=0;\n            futons[i].isChecked=0;\n            futons[i].alignment=-1;\n            for(j=0;j<i;j++){\n                int adjacent_type=isAdjacent(&futons[i], &futons[j]);\n                if(adjacent_type){\n                    futons[i].adjacent[futons[i].number_of_adjacent]=&futons[j];\n                    futons[i].adjacent_type[futons[i].number_of_adjacent]=adjacent_type;\n                    futons[i].number_of_adjacent++;\n                    futons[j].adjacent[futons[j].number_of_adjacent]=&futons[i];\n                    futons[j].adjacent_type[futons[j].number_of_adjacent]=adjacent_type;\n                    futons[j].number_of_adjacent++;\n                }\n            }\n        }\n        //?????°??????????????????\n        for(i=0;i<number_of_futon;i++){\n            if(check(&futons[i])==-1){\n                break;\n            }\n        }\n        if(i==number_of_futon){\n            printf(\"Yes\\n\");\n        }else{\n            printf(\"No\\n\");\n        }\n    }\n}\n\nint check(futon* object){\n    if(object->isChecked){\n        return 0;\n    }\n    object->isChecked=1;\n    if(object->number_of_adjacent==0){\n        return 0;\n    }\n    if(object->alignment==-1){\n        object->alignment=1;\n    }\n    int i;\n    for(i=0;i<object->number_of_adjacent;i++){\n        switch(object->adjacent_type[i]){\n            case 1:\n                if(object->adjacent[i]->alignment==-1){\n                    object->adjacent[i]->alignment=object->alignment;\n                }else{\n                    if(object->adjacent[i]->alignment!=object->alignment) return -1;\n                }\n                break;\n            case 2:\n                if(object->adjacent[i]->alignment==-1){\n                    object->adjacent[i]->alignment=object->alignment^1;\n                }else{\n                    if(object->adjacent[i]->alignment==object->alignment) return -1;\n                }\n                break;\n        }\n        if(check(object->adjacent[i])==-1) return -1;\n    }\n    return 0;\n}\n\nint isAdjacent(futon* a, futon* b){//??\\?§?????????????1???????????????????????°0\n    int Ax1, Ax2, Ay1, Ay2, Bx1, Bx2, By1, By2;\n    Ax1=a->x;\n    Ay1=a->y;\n    if(a->dir=='x'){\n        Ax2=a->x+1;\n        Ay2=a->y;\n    }else{\n        Ax2=a->x;\n        Ay2=a->y+1;\n    }\n    Bx1=b->x;\n    By1=b->y;\n    if(b->dir=='x'){\n        Bx2=b->x+1;\n        By2=b->y;\n    }else{\n        Bx2=b->x;\n        By2=b->y+1;\n    }\n    if(abs(Ax1-Bx1)+abs(Ay1-By1)==1) return 1;\n    if(abs(Ax1-Bx2)+abs(Ay1-By2)==1) return 2;\n    if(abs(Ax2-Bx1)+abs(Ay2-By1)==1) return 2;\n    if(abs(Ax2-Bx2)+abs(Ay2-By2)==1) return 1;\n    return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint n;\n\tHashMap<P, Integer> map;\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\t\n\tclass P {\n\t\tint x,y;\n\n\t\tpublic P(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + x;\n\t\t\tresult = prime * result + y;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tP other = (P) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (x != other.x)\n\t\t\t\treturn false;\n\t\t\tif (y != other.y)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"P [x=\" + x + \", y=\" + y + \"]\";\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tP [][] ps = new P[n][2];\n\t\t\tmap = new HashMap<P, Integer>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint dir = sc.next().charAt(0) == 'x' ? 0: 1;\n\t\t\t\tps[i][0] = new P(x, y);\n\t\t\t\tmap.put(new P(x, y), 0);\n\t\t\t\tif(dir == 0){\n\t\t\t\t\tps[i][1] = new P(x + 1, y);\n\t\t\t\t\tmap.put(new P(x + 1, y), 0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps[i][1] = new P(x, y + 1);\n\t\t\t\t\tmap.put(new P(x, y + 1), 0);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tboolean ans = true;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint v1 = map.get(ps[i][0]);\n\t\t\t\tint v2 = map.get(ps[i][1]);\n\t\t\t\tif(v1 == 0 && v2 == 0){\n\t\t\t\t\tint adj = 0;\n\t\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\t\tint xx = ps[i][0].x + vx[j];\n\t\t\t\t\t\tint yy = ps[i][1].y + vy[j];\n\t\t\t\t\t\tP pp = new P(xx, yy);\n\t\t\t\t\t\tif(map.containsKey(pp) && map.get(pp) != 0){\n\t\t\t\t\t\t\tadj = map.get(pp);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(adj == 0){\n\t\t\t\t\t\tmap.put(ps[i][0], 1);\n\t\t\t\t\t\tmap.put(ps[i][1], 2);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap.put(ps[i][0], adj);\n\t\t\t\t\t\tmap.put(ps[i][1], adj == 1 ? 2: 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(v1 != 0 && v2 == 0){\n\t\t\t\t\tmap.put(ps[i][1], v1 == 1 ? 2 : 1);\n\t\t\t\t}\n\t\t\t\telse if(v1 == 0 && v2 != 0){\n\t\t\t\t\tmap.put(ps[i][0], v2 == 1 ? 2 : 1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(v1 == v2){\n\t\t\t\t\t\tans = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(! check(ps[i])){\n\t\t\t\t\tans = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tprivate boolean check(P[] p) {\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tint nowvalue = map.get(p[j]);\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint xx = p[j].x + vx[i];\n\t\t\t\tint yy = p[j].y + vy[i];\n\t\t\t\tP pp = new P(xx, yy);\n\t\t\t\tif(pp.equals(p[j^1])) continue;\n\t\t\t\tif(map.containsKey(pp)){\n\t\t\t\t\tint ppvalue = map.get(pp);\n\t\t\t\t\tif(ppvalue == 0){\n\t\t\t\t\t\tmap.put(pp, nowvalue);\n\t\t\t\t\t}\n\t\t\t\t\telse if(ppvalue != nowvalue){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint n;\n\tHashMap<P, Integer> map;\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\t\n\tclass P {\n\t\tint x,y;\n\n\t\tpublic P(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + x;\n\t\t\tresult = prime * result + y;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tP other = (P) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (x != other.x)\n\t\t\t\treturn false;\n\t\t\tif (y != other.y)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"P [x=\" + x + \", y=\" + y + \"]\";\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tP [][] ps = new P[n][2];\n\t\t\tmap = new HashMap<P, Integer>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint dir = sc.next().charAt(0) == 'x' ? 0: 1;\n\t\t\t\tps[i][0] = new P(x, y);\n\t\t\t\tmap.put(new P(x, y), 0);\n\t\t\t\tif(dir == 0){\n\t\t\t\t\tps[i][1] = new P(x + 1, y);\n\t\t\t\t\tmap.put(new P(x + 1, y), 0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps[i][1] = new P(x, y + 1);\n\t\t\t\t\tmap.put(new P(x, y + 1), 0);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tboolean ans = true;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint v1 = map.get(ps[i][0]);\n\t\t\t\tint v2 = map.get(ps[i][1]);\n\t\t\t\tif(v1 == 0 && v2 == 0){\n\t\t\t\t\tmap.put(ps[i][0], 1);\n\t\t\t\t\tmap.put(ps[i][1], 2);\n\t\t\t\t}\n\t\t\t\telse if(v1 != 0 && v2 == 0){\n\t\t\t\t\tmap.put(ps[i][1], v1 == 1 ? 2 : 1);\n\t\t\t\t}\n\t\t\t\telse if(v1 == 0 && v2 != 0){\n\t\t\t\t\tmap.put(ps[i][0], v2 == 1 ? 2 : 1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(v1 == v2){\n\t\t\t\t\t\tans = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(! check(ps[i])){\n\t\t\t\t\tans = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tprivate boolean check(P[] p) {\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tint nowvalue = map.get(p[j]);\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint xx = p[j].x + vx[i];\n\t\t\t\tint yy = p[j].y + vy[i];\n\t\t\t\tP pp = new P(xx, yy);\n\t\t\t\tif(pp.equals(p[j^1])) continue;\n\t\t\t\tif(map.containsKey(pp)){\n\t\t\t\t\tint ppvalue = map.get(pp);\n\t\t\t\t\tif(ppvalue == 0){\n\t\t\t\t\t\tmap.put(pp, nowvalue);\n\t\t\t\t\t}\n\t\t\t\t\telse if(ppvalue != nowvalue){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint n;\n\tHashMap<P, Integer> map;\n\tHashMap<P, P>pair;\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\t\n\tclass P {\n\t\tint x,y;\n\n\t\tpublic P(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + x;\n\t\t\tresult = prime * result + y;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tP other = (P) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (x != other.x)\n\t\t\t\treturn false;\n\t\t\tif (y != other.y)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"P [x=\" + x + \", y=\" + y + \"]\";\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tmap = new HashMap<P, Integer>();\n\t\t\tpair = new HashMap<Main.P, Main.P>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint dir = sc.next().charAt(0) == 'x' ? 0: 1;\n\t\t\t\tP p = new P(x, y);\n\t\t\t\tmap.put(p, 0);\n\t\t\t\tif(dir == 0){\n\t\t\t\t\tP pp = new P(x + 1, y);\n\t\t\t\t\tmap.put(pp, 0);\n\t\t\t\t\tpair.put(p, pp);\n\t\t\t\t\tpair.put(pp, p);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tP pp =  new P(x, y + 1);\n\t\t\t\t\tmap.put(pp, 0);\n\t\t\t\t\tpair.put(p, pp);\n\t\t\t\t\tpair.put(pp, p);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tboolean ans = true;\n\t\t\tfor(P nowp: pair.keySet()){\n\t\t\t\tif(map.get(nowp) == 0){\n\t\t\t\t\tboolean res = bfs(nowp);\n\t\t\t\t\tif(! res){\n\t\t\t\t\t\tans = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tprivate boolean bfs(P argp) {\n\t\tLinkedList<P> open = new LinkedList<Main.P>();\n\t\topen.add(argp);\n\t\tmap.put(argp, 1);\n\t\twhile(! open.isEmpty()){\n\t\t\tP nowp = open.poll();\n\t\t\tint nowvalue = map.get(nowp);\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint xx = nowp.x + vx[i];\n\t\t\t\tint yy = nowp.y + vy[i];\n\t\t\t\tP pp = new P(xx, yy);\n\t\t\t\tif(map.containsKey(pp)){\n\t\t\t\t\tint value = map.get(pp);\n\t\t\t\t\tif(value == 0){\n\t\t\t\t\t\tif(pair.get(nowp).equals(pp)){\n\t\t\t\t\t\t\tmap.put(pp, nowvalue == 1 ? 2 :1);\n\t\t\t\t\t\t\topen.add(pp);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmap.put(pp, nowvalue);\n\t\t\t\t\t\t\topen.add(pp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(pair.get(nowp).equals(pp)){\n\t\t\t\t\t\t\tif(value == nowvalue) return false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tif(value != nowvalue) return false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate void setvalue(P[] p) {\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint xx = p[0].x + vx[i];\n\t\t\tint yy = p[0].y + vy[i];\n\t\t\tP pp = new P(xx, yy);\n\t\t\tif(pp.equals(p[1])) continue;\n\t\t\tif(map.containsKey(pp)){\n\t\t\t\tint value = map.get(pp);\n\t\t\t\tif(value != 0){\n\t\t\t\t\tmap.put(p[0], value);\n\t\t\t\t\tmap.put(p[1], value == 1 ? 2 : 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint xx = p[1].x + vx[i];\n\t\t\tint yy = p[1].y + vy[i];\n\t\t\tP pp = new P(xx, yy);\n\t\t\tif(pp.equals(p[0])) continue;\n\t\t\tif(map.containsKey(pp)){\n\t\t\t\tint value = map.get(pp);\n\t\t\t\tif(value != 0){\n\t\t\t\t\tmap.put(p[1], value);\n\t\t\t\t\tmap.put(p[0], value == 1 ? 2 : 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap.put(p[0], 1);\n\t\tmap.put(p[1], 2);\n\t}\n\n\tprivate boolean check(P[] p) {\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tint nowvalue = map.get(p[j]);\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint xx = p[j].x + vx[i];\n\t\t\t\tint yy = p[j].y + vy[i];\n\t\t\t\tP pp = new P(xx, yy);\n\t\t\t\tif(pp.equals(p[j^1])) continue;\n\t\t\t\tif(map.containsKey(pp)){\n\t\t\t\t\tint ppvalue = map.get(pp);\n\t\t\t\t\tif(ppvalue == 0){\n\t\t\t\t\t\tmap.put(pp, nowvalue);\n\t\t\t\t\t}\n\t\t\t\t\telse if(ppvalue != nowvalue){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint n;\n\tHashMap<P, Integer> map;\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\t\n\tclass P {\n\t\tint x,y;\n\n\t\tpublic P(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + x;\n\t\t\tresult = prime * result + y;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tP other = (P) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (x != other.x)\n\t\t\t\treturn false;\n\t\t\tif (y != other.y)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"P [x=\" + x + \", y=\" + y + \"]\";\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tP [][] ps = new P[n][2];\n\t\t\tmap = new HashMap<P, Integer>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint dir = sc.next().charAt(0) == 'x' ? 0: 1;\n\t\t\t\tps[i][0] = new P(x, y);\n\t\t\t\tmap.put(new P(x, y), 0);\n\t\t\t\tif(dir == 0){\n\t\t\t\t\tps[i][1] = new P(x + 1, y);\n\t\t\t\t\tmap.put(new P(x + 1, y), 0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps[i][1] = new P(x, y + 1);\n\t\t\t\t\tmap.put(new P(x, y + 1), 0);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tboolean ans = true;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint v1 = map.get(ps[i][0]);\n\t\t\t\tint v2 = map.get(ps[i][1]);\n\t\t\t\tif(v1 == 0 && v2 == 0){\n\t\t\t\t\tsetvalue(ps[i]);\n\t\t\t\t}\n\t\t\t\telse if(v1 != 0 && v2 == 0){\n\t\t\t\t\tmap.put(ps[i][1], v1 == 1 ? 2 : 1);\n\t\t\t\t}\n\t\t\t\telse if(v1 == 0 && v2 != 0){\n\t\t\t\t\tmap.put(ps[i][0], v2 == 1 ? 2 : 1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(v1 == v2){\n\t\t\t\t\t\tans = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(! check(ps[i])){\n\t\t\t\t\tans = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tprivate void setvalue(P[] p) {\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint xx = p[0].x + vx[i];\n\t\t\tint yy = p[0].y + vy[i];\n\t\t\tP pp = new P(xx, yy);\n\t\t\tif(pp.equals(p[1])) continue;\n\t\t\tif(map.containsKey(pp)){\n\t\t\t\tint value = map.get(pp);\n\t\t\t\tif(value != 0){\n\t\t\t\t\tmap.put(p[0], value);\n\t\t\t\t\tmap.put(p[1], value == 1 ? 2 : 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint xx = p[1].x + vx[i];\n\t\t\tint yy = p[1].y + vy[i];\n\t\t\tP pp = new P(xx, yy);\n\t\t\tif(pp.equals(p[0])) continue;\n\t\t\tif(map.containsKey(pp)){\n\t\t\t\tint value = map.get(pp);\n\t\t\t\tif(value != 0){\n\t\t\t\t\tmap.put(p[1], value);\n\t\t\t\t\tmap.put(p[0], value == 1 ? 2 : 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmap.put(p[0], 1);\n\t\tmap.put(p[1], 2);\n\t}\n\n\tprivate boolean check(P[] p) {\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tint nowvalue = map.get(p[j]);\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint xx = p[j].x + vx[i];\n\t\t\t\tint yy = p[j].y + vy[i];\n\t\t\t\tP pp = new P(xx, yy);\n\t\t\t\tif(pp.equals(p[j^1])) continue;\n\t\t\t\tif(map.containsKey(pp)){\n\t\t\t\t\tint ppvalue = map.get(pp);\n\t\t\t\t\tif(ppvalue == 0){\n\t\t\t\t\t\tmap.put(pp, nowvalue);\n\t\t\t\t\t}\n\t\t\t\t\telse if(ppvalue != nowvalue){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint n;\n\tint [][] data;\n\tHashSet<P> legs, heads;\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\t\n\tclass P {\n\t\tint x,y;\n\n\t\tpublic P(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + x;\n\t\t\tresult = prime * result + y;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tP other = (P) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (x != other.x)\n\t\t\t\treturn false;\n\t\t\tif (y != other.y)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"P [x=\" + x + \", y=\" + y + \"]\";\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdata = new int[n][3];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint dir = sc.next().charAt(0) == 'x' ? 0: 1;\n\t\t\t\tdata[i][0] = x;\n\t\t\t\tdata[i][1] = y;\n\t\t\t\tdata[i][2] = dir;\n\t\t\t}\n\t\t\tlegs = new HashSet<P>();\n\t\t\theads = new HashSet<P>();\n\t\t\tboolean res = dfs(0);\n\t\t\tSystem.out.println(res ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tprivate boolean dfs(int deep) {\n\t\tif(deep == n){\n\t\t\treturn true;\n\t\t}\n\t\tint x = data[deep][0];\n\t\tint y = data[deep][1];\n\t\tP [] ps = new P[2];\n\t\tps[0] = new P(x, y);\n\t\tif(data[deep][2] == 0){\n\t\t\tps[1] = new P(ps[0].x + 1, ps[0].y);\n\t\t}\n\t\telse {\n\t\t\tps[1] = new P(ps[0].x, ps[0].y + 1);\n\t\t}\n\t\tfor(int i = 0; i < 2; i++){\n\t\t\tboolean flg = true;\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tint xx = ps[i].x + vx[j];\n\t\t\t\tint yy = ps[i].y + vy[j];\n\t\t\t\tP pp = new P(xx, yy);\n\t\t\t\tif(heads.contains(pp)){\n\t\t\t\t\tflg = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\tint xx = ps[i ^ 1].x + vx[j];\n\t\t\t\tint yy = ps[i ^ 1].y + vy[j];\n\t\t\t\tP pp = new P(xx, yy);\n\t\t\t\tif(legs.contains(pp)){\n\t\t\t\t\tflg = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg){\n\t\t\t\tlegs.add(ps[i]);\n\t\t\t\theads.add(ps[i^1]);\n\t\t\t\tboolean res = dfs(deep + 1);\n\t\t\t\tlegs.remove(ps[i]);\n\t\t\t\theads.remove(ps[i ^ 1]);\n\t\t\t\tif(res) return true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint n;\n\tHashMap<P, Integer> map;\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\t\n\tclass P {\n\t\tint x,y;\n\n\t\tpublic P(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + getOuterType().hashCode();\n\t\t\tresult = prime * result + x;\n\t\t\tresult = prime * result + y;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tP other = (P) obj;\n\t\t\tif (!getOuterType().equals(other.getOuterType()))\n\t\t\t\treturn false;\n\t\t\tif (x != other.x)\n\t\t\t\treturn false;\n\t\t\tif (y != other.y)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate Main getOuterType() {\n\t\t\treturn Main.this;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"P [x=\" + x + \", y=\" + y + \"]\";\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tP [][] ps = new P[n][2];\n\t\t\tmap = new HashMap<P, Integer>();\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint dir = sc.next().charAt(0) == 'x' ? 0: 1;\n\t\t\t\tps[i][0] = new P(x, y);\n\t\t\t\tmap.put(new P(x, y), 0);\n\t\t\t\tif(dir == 0){\n\t\t\t\t\tps[i][1] = new P(x + 1, y);\n\t\t\t\t\tmap.put(new P(x + 1, y), 0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tps[i][1] = new P(x, y + 1);\n\t\t\t\t\tmap.put(new P(x, y + 1), 0);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tboolean ans = true;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint v1 = map.get(ps[i][0]);\n\t\t\t\tint v2 = map.get(ps[i][1]);\n\t\t\t\tif(v1 == 0 && v2 == 0){\n\t\t\t\t\tint adj = 0;\n\t\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\t\tint xx = ps[i][0].x + vx[j];\n\t\t\t\t\t\tint yy = ps[i][0].y + vy[j];\n\t\t\t\t\t\tP pp = new P(xx, yy);\n\t\t\t\t\t\tif(map.containsKey(pp) && map.get(pp) != 0){\n\t\t\t\t\t\t\tadj = map.get(pp);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(adj == 0){\n\t\t\t\t\t\tmap.put(ps[i][0], 1);\n\t\t\t\t\t\tmap.put(ps[i][1], 2);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tmap.put(ps[i][0], adj);\n\t\t\t\t\t\tmap.put(ps[i][1], adj == 1 ? 2: 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(v1 != 0 && v2 == 0){\n\t\t\t\t\tmap.put(ps[i][1], v1 == 1 ? 2 : 1);\n\t\t\t\t}\n\t\t\t\telse if(v1 == 0 && v2 != 0){\n\t\t\t\t\tmap.put(ps[i][0], v2 == 1 ? 2 : 1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(v1 == v2){\n\t\t\t\t\t\tans = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(! check(ps[i])){\n\t\t\t\t\tans = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tprivate boolean check(P[] p) {\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tint nowvalue = map.get(p[j]);\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tint xx = p[j].x + vx[i];\n\t\t\t\tint yy = p[j].y + vy[i];\n\t\t\t\tP pp = new P(xx, yy);\n\t\t\t\tif(pp.equals(p[j^1])) continue;\n\t\t\t\tif(map.containsKey(pp)){\n\t\t\t\t\tint ppvalue = map.get(pp);\n\t\t\t\t\tif(ppvalue == 0){\n\t\t\t\t\t\tmap.put(pp, nowvalue);\n\t\t\t\t\t}\n\t\t\t\t\telse if(ppvalue != nowvalue){\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tclass Futon {\n\t\tint type;\n\t\tFuton adj;\n\t\t\n\t\tFuton() {\n\t\t\ttype = -1;\n\t\t}\n\t\t\n\t\tint getType() {\n\t\t\treturn type;\n\t\t}\n\t\t\n\t\tvoid setType(int type) {\n\t\t\tthis.type = type;\n\t\t}\n\t\t\n\t\tvoid setAdj(Futon adj) {\n\t\t\tthis.adj = adj;\n\t\t}\n\t}\n\t\n\tclass State {\n\t\tlong key;\n\t\tint type;\n\n\t\tState(long key, int type) {\n\t\t\tthis.key = key;\n\t\t\tthis.type = type;\n\t\t}\n\t}\n\t\n\tlong getKey(long x, long y) {\n\t\treturn x * MAX + y;\n\t}\n\t\n\tint MAX = 1000000100;\n\tint HEAD = 1, FOOT = 2;\n\tint[] vx = {-1, 0, 1, 0};\n\tint[] vy = {0, -1, 0, 1};\n\t\n\tboolean ok = false;\n\tHashMap<Long, Futon> map = new HashMap<Long, Futon>();\n\t\n\tvoid bfs(int sx, int sy, int stype) {\n\t\tQueue<State> q = new LinkedList<State>();\n\t\tq.add(new State(getKey(sx, sy), stype));\n\t\t\n\t\twhile (!q.isEmpty()) {\n\t\t\tState next = q.poll();\n\t\t\tFuton f = map.get(next.key);\n\t\t\tlong x = next.key / MAX, y = next.key % MAX;\n\t\t\tint type = next.type;\n\t\t\tif (f.type == -1) {\n\t\t\t\tf.type = type;\n\t\t\t} else {\n\t\t\t\tif (f.type != type) {\n\t\t\t\t\tok = false;\t\t\n\t\t\t\t\tq.clear();\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\t\tlong nx = x + vx[d], ny = y + vy[d];\n\t\t\t\tFuton adj = map.get(getKey(nx, ny));\n\t\t\t\tif (adj != null) {\n\t\t\t\t\tint ntype = -1;\n\t\t\t\t\tif (f.adj == adj) {\n\t\t\t\t\t\tntype = (type == HEAD) ? FOOT : HEAD;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tntype = type;\n\t\t\t\t\t}\n\t\t\t\t\tq.add(new State(getKey(nx, ny), ntype));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tvoid reset(int sx, int sy) {\n\t\tQueue<Long> q = new LinkedList<Long>();\n\t\tq.add(getKey(sx, sy));\n\t\t\n\t\twhile (!q.isEmpty()) {\n\t\t\tlong next = q.poll();\n\t\t\tFuton f = map.get(next);\n\t\t\tif (f.type == -1) continue;\n\t\t\t\n\t\t\tlong x = next / MAX, y = next % MAX;\n\t\t\tf.type = -1;\n\n\t\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\t\tlong nx = x + vx[d], ny = y + vy[d];\n\t\t\t\tFuton adj = map.get(getKey(nx, ny));\n\t\t\t\tif (adj != null && f.type != -1) {\n\t\t\t\t\tq.add(getKey(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint[] x = new int[n];\n\t\t\tint[] y = new int[n];\n\t\t\tmap.clear();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tx[i] = in.nextInt();\n\t\t\t\ty[i] = in.nextInt();\n\t\t\t\tchar d = in.next().charAt(0);\n\t\t\t\t\n\t\t\t\tint nx = (d == 'x') ? x[i] + 1 : x[i];\n\t\t\t\tint ny = (d == 'y') ? y[i] + 1 : y[i];\n\t\t\t\tFuton f1 = new Futon(), f2 = new Futon();\n\t\t\t\tf1.setAdj(f2);\n\t\t\t\tf2.setAdj(f1);\n\t\t\t\tmap.put(getKey(x[i], y[i]), f1);\n\t\t\t\tmap.put(getKey(nx, ny), f2);\n\t\t\t}\n\t\t\t\n\t\t\tboolean res = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (map.get(getKey(x[i], y[i])).getType() == -1) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbfs(x[i], y[i], HEAD);\n\t\t\t\t\tif (ok) continue;\n\t\t\t\t\t\n\t\t\t\t\treset(x[i], y[i]);\n\t\t\t\t\t\n\t\t\t\t\tok = true;\n\t\t\t\t\tbfs(x[i], y[i], FOOT);\n\t\t\t\t\tif (!ok) {\n\t\t\t\t\t\tres = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.println(res ? \"Yes\" : \"No\");\n\t\t\tout.flush();\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tclass Futon {\n\t\tint type;\n\t\tFuton adj;\n\t\t\n\t\tFuton() {\n\t\t\ttype = -1;\n\t\t}\n\t\t\n\t\tint getType() {\n\t\t\treturn type;\n\t\t}\n\t\t\n\t\tvoid setType(int type) {\n\t\t\tthis.type = type;\n\t\t}\n\t\t\n\t\tvoid setAdj(Futon adj) {\n\t\t\tthis.adj = adj;\n\t\t}\n\t}\n\t\n\tlong getKey(long x, long y) {\n\t\treturn x * MAX + y;\n\t}\n\t\n\tint MAX = 1000000100;\n\tint HEAD = 1, FOOT = 2;\n\tint[] vx = {-1, 0, 1, 0};\n\tint[] vy = {0, -1, 0, 1};\n\t\n\tboolean ok = false;\n\tHashMap<Long, Futon> map = new HashMap<Long, Futon>();\n\t\n\tvoid dfs(int x, int y, int type) {\n\t\tFuton f = map.get(getKey(x, y));\n\t\tif (f.type == -1) {\n\t\t\tf.type = type;\n\t\t} else {\n\t\t\tif (f.type != type) ok = false;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\tint nx = x + vx[d], ny = y + vy[d];\n\t\t\tFuton adj = map.get(getKey(nx, ny));\n\t\t\tif (adj != null) {\n\t\t\t\tint ntype = -1;\n\t\t\t\tif (f.adj == adj) {\n\t\t\t\t\tntype = (type == HEAD) ? FOOT : HEAD;\n\t\t\t\t} else {\n\t\t\t\t\tntype = type;\n\t\t\t\t}\n\t\t\t\tdfs(nx, ny, ntype);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid reset(int x, int y) {\n\t\tFuton f = map.get(getKey(x, y));\n\t\tif (f.type == -1) return;\n\t\tf.type = -1;\n\n\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\tint nx = x + vx[d], ny = y + vy[d];\n\t\t\tFuton adj = map.get(getKey(nx, ny));\n\t\t\tif (adj != null) {\n\t\t\t\treset(nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint[] x = new int[n];\n\t\t\tint[] y = new int[n];\n\t\t\tmap.clear();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tx[i] = in.nextInt();\n\t\t\t\ty[i] = in.nextInt();\n\t\t\t\tchar d = in.next().charAt(0);\n\t\t\t\t\n\t\t\t\tint nx = (d == 'x') ? x[i] + 1 : x[i];\n\t\t\t\tint ny = (d == 'y') ? y[i] + 1 : y[i];\n\t\t\t\tFuton f1 = new Futon(), f2 = new Futon();\n\t\t\t\tf1.setAdj(f2);\n\t\t\t\tf2.setAdj(f1);\n\t\t\t\tmap.put(getKey(x[i], y[i]), f1);\n\t\t\t\tmap.put(getKey(nx, ny), f2);\n\t\t\t}\n\t\t\t\n\t\t\tboolean res = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (map.get(getKey(x[i], y[i])).getType() == -1) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tdfs(x[i], y[i], HEAD);\n\t\t\t\t\tif (ok) continue;\n\t\t\t\t\t\n\t\t\t\t\treset(x[i], y[i]);\n\t\t\t\t\t\n\t\t\t\t\tok = true;\n\t\t\t\t\tdfs(x[i], y[i], FOOT);\n\t\t\t\t\tif (!ok) {\n\t\t\t\t\t\tres = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.println(res ? \"Yes\" : \"No\");\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic long[] MOVE = { 1L << 32, 1, -(1L << 32), -1 };\n\tstatic int[] X, Y, head;\n\tstatic HashMap<Long, Integer> map;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tX = new int[2 * N];\n\t\t\tY = new int[2 * N];\n\t\t\thead = new int[2 * N];\n\t\t\tmap = new HashMap<Long, Integer>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tX[2 * i] = Integer.parseInt(sc.next()) + 1;\n\t\t\t\tY[2 * i] = Integer.parseInt(sc.next()) + 1;\n\t\t\t\tif (sc.next().equals(\"x\")) {\n\t\t\t\t\tX[2 * i + 1] = X[2 * i] + 1;\n\t\t\t\t\tY[2 * i + 1] = Y[2 * i];\n\t\t\t\t} else {\n\t\t\t\t\tX[2 * i + 1] = X[2 * i];\n\t\t\t\t\tY[2 * i + 1] = Y[2 * i] + 1;\n\t\t\t\t}\n\t\t\t\tmap.put(((long) X[2 * i] << 32) + Y[2 * i], 2 * i);\n\t\t\t\tmap.put(((long) X[2 * i + 1] << 32) + Y[2 * i + 1], 2 * i + 1);\n\t\t\t}\n\t\t\tboolean ok = true;\n\t\t\tfor (int i = 0; i < 2 * N; i += 2) {\n\t\t\t\tif (head[i] != 0) continue;\n\t\t\t\tif (!check(i, true) && !check(i, false)) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ok ? \"Yes\" : \"No\");\n\t\t}\n\t}\n\n\tstatic boolean check(int pos, boolean isHead) {\n\t\tArrayDeque<Long> q = new ArrayDeque<Long>();\n\t\tq.add(pos + ((isHead ? 1L : 0L) << 32));\n\t\twhile (!q.isEmpty()) {\n\t\t\tlong cur = q.poll();\n\t\t\tint cp = (int) (cur & 0xFFFFFFF);\n\t\t\tboolean h = (cur >> 32) != 0;\n\t\t\tif (head[cp] != 0) {\n\t\t\t\tif ((head[cp] == 1) == h) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\trevert(pos);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\thead[cp] = h ? 1 : -1;\n\t\t\tlong coord = ((long) X[cp] << 32) + Y[cp];\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tlong nc = coord + MOVE[i];\n\t\t\t\tif (!map.containsKey(nc)) continue;\n\t\t\t\tint np = map.get(nc);\n\t\t\t\tif (cp / 2 == np / 2) {\n\t\t\t\t\tq.add(np + ((h ? 0L : 1L) << 32));\n\t\t\t\t} else {\n\t\t\t\t\tq.add(np + ((h ? 1L : 0L) << 32));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic void revert(int pos) {\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(pos);\n\t\twhile (!q.isEmpty()) {\n\t\t\tint cur = q.poll();\n\t\t\thead[cur] = 0;\n\t\t\tlong coord = ((long) X[cur] << 32) + Y[cur];\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tlong nc = coord + MOVE[i];\n\t\t\t\tif (!map.containsKey(nc)) continue;\n\t\t\t\tint np = map.get(nc);\n\t\t\t\tif (head[np] != 0) q.add(np);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:pos] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nloop do\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tg = Graph.new\n\tnodes = {}\n\n\t(1..n).each do \n\t\tx1, y1, d = gets.chomp.split\n\t\tx1 = x1.to_i\n\t\ty1 = y1.to_i\n\t\tx2 = x1\n\t\ty2 = y1\n\t\tif d == ?x\n\t\t\tx2 = x1 + 1\n\t\telse\n\t\t\ty2 = y1 + 1\n\t\tend\n\n\t\tu1 = nodes[[x1,y1]] = g.add_node({:pos => [x1, y1]})\n\t\tu2 = nodes[[x2,y2]] = g.add_node({:pos => [x2, y2]})\n\t\tg.add_edge(u1, u2, {:c => -1})\n\n\t\t[[1,0],[-1,0],[0,1],[0,-1]].each do |dx, dy|\n\t\t\tv = nodes[[x1+dx, y1+dy]]\t\n\t\t\tnext if !v || v == u2\n\t\t\tg.add_edge(u1, v, {:c => 1})\n\t\tend\n\n\t\t[[1,0],[-1,0],[0,1],[0,-1]].each do |dx, dy|\n\t\t\tv = nodes[[x2+dx, y2+dy]]\t\n\t\t\tnext if !v || v == u1\n\t\t\tg.add_edge(u2, v, {:c => 1})\n\t\tend\n\tend\n\n\tcolor = {}\n\tok = true\n\tcatch :exit do\n\t\tnodes.each_value do |u0|\n\t\t\tnext if color[u0]\n\t\t\tcolor[u0] = 1\n\t\t\tstack = [u0]\n\n\t\t\tuntil stack.empty?\n\t\t\t\tu = stack.pop\n\t\t\t\tu.each_edge do |e|\n\t\t\t\t\tv = e.opposite[u]\n\t\t\t\t\tc = color[u] * e.property[:c]\n\t\t\t\t\tif color[v]\n\t\t\t\t\t\tif color[v] != c\n\t\t\t\t\t\t\tok = false\n\t\t\t\t\t\t\tthrow :exit\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tnext\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\tcolor[v] = c\n\t\t\t\t\tstack << v\n\t\t\t\tend\t\n\t\t\tend\n\t\tend\n\tend\n\t\n\tputs ok ? 'Yes' : 'No'\nend"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n\n        a = [LS() for _ in range(n)]\n        d = collections.defaultdict(int)\n        for i in range(n):\n            x, y, di = a[i]\n            x = int(x)\n            y = int(y)\n            d[(x,y)] = i + 1\n            if di == 'x':\n                d[(x+1,y)] = i + 1\n            else:\n                d[(x,y+1)] = i + 1\n\n        v = collections.defaultdict(bool)\n        f = True\n        for k in list(d.keys()):\n            if v[k]:\n                continue\n            s1 = set()\n            s2 = set()\n            ns1 = set([k])\n            ns2 = set()\n            while ns1 or ns2:\n                for ak in list(ns1):\n                    for di,dj in dd:\n                        nk = (ak[0]+di, ak[1]+dj)\n                        if d[nk] == 0:\n                            continue\n                        if d[nk] == d[ak]:\n                            ns1.add(nk)\n                        else:\n                            ns2.add(nk)\n                ns2 -= s2\n                for ak in list(ns2):\n                    for di,dj in dd:\n                        nk = (ak[0]+di, ak[1]+dj)\n                        if d[nk] == 0:\n                            continue\n                        if d[nk] == d[ak]:\n                            ns2.add(nk)\n                        else:\n                            ns1.add(nk)\n\n                ns2 -= s2\n                ns1 -= s1\n                s2 |= ns2\n                s1 |= ns1\n                if s1 & s2:\n                    f = False\n                    break\n\n            if not f:\n                break\n\n            for c in s1:\n                v[c] = 1\n            for c in s2:\n                v[c] = 1\n\n        if f:\n            rr.append('Yes')\n        else:\n            rr.append('No')\n\n\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n\n        a = [LS() for _ in range(n)]\n        d = collections.defaultdict(int)\n        ed = collections.defaultdict(lambda: None)\n        for i in range(n):\n            x, y, di = a[i]\n            x = int(x)\n            y = int(y)\n            d[(x,y)] = i + 1\n            if di == 'x':\n                d[(x+1,y)] = i + 1\n                ed[(x,y)] = (x+1,y)\n                ed[(x+1,y)] = (x,y)\n            else:\n                d[(x,y+1)] = i + 1\n                ed[(x,y)] = (x,y+1)\n                ed[(x,y+1)] = (x,y)\n\n        ee = collections.defaultdict(set)\n        dka = list(d.keys())\n        for x,y in list(d.keys()):\n            dt = d[(x,y)]\n            for di,dj in dd:\n                ni = x + di\n                nj = y + dj\n                if d[(ni,nj)] > 0 and d[(ni,nj)] != dt:\n                    ee[(x,y)].add((ni,nj))\n\n        v = collections.defaultdict(bool)\n        f = True\n        for k in dka:\n            if v[k]:\n                continue\n            s1 = set()\n            s2 = set()\n            ns1 = set([k])\n            ns2 = set()\n            while ns1:\n                na = list(ns1)\n                s1 |= ns1\n                ns1 = set()\n                for k in na:\n                    ns1 |= ee[k]\n                    ns2.add(ed[k])\n                ns2 -= s2\n\n                while ns2:\n                    na = list(ns2)\n                    s2 |= ns2\n                    ns2 = set()\n                    for k in na:\n                        ns2 |= ee[k]\n                        ns1.add(ed[k])\n                    ns2 -= s2\n\n                ns1 -= s1\n                if s1 & s2:\n                    f = False\n                    break\n            # print('k', k)\n            # print('s1', s1)\n            # print('s2', s2)\n\n            if f:\n                for k in s1:\n                    v[k] = 1\n                for k in s2:\n                    v[k] = 1\n            else:\n                break\n\n        if f:\n            rr.append('Yes')\n        else:\n            rr.append('No')\n\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n\n        a = [LS() for _ in range(n)]\n        d = collections.defaultdict(int)\n        ed = collections.defaultdict(lambda: None)\n        for i in range(n):\n            x, y, di = a[i]\n            x = int(x)\n            y = int(y)\n            d[(x,y)] = i + 1\n            if di == 'x':\n                d[(x+1,y)] = i + 1\n                ed[(x,y)] = (x+1,y)\n                ed[(x+1,y)] = (x,y)\n            else:\n                d[(x,y+1)] = i + 1\n                ed[(x,y)] = (x,y+1)\n                ed[(x,y+1)] = (x,y)\n\n        ee = collections.defaultdict(set)\n        dka = list(d.keys())\n        for x,y in list(d.keys()):\n            dt = d[(x,y)]\n            for di,dj in dd:\n                ni = x + di\n                nj = y + dj\n                if d[(ni,nj)] > 0 and d[(ni,nj)] != dt:\n                    ee[(x,y)].add((ni,nj))\n\n        v = collections.defaultdict(bool)\n        f = True\n        for k in dka:\n            if v[k]:\n                continue\n            s1 = set()\n            s2 = set()\n            ns1 = set([k])\n            ns2 = set()\n            while ns1:\n                na = list(ns1)\n                s1 |= ns1\n                ns1 = set()\n                for k in na:\n                    ns1 |= ee[k]\n                    ns2.add(ed[k])\n                ns2 -= s2\n\n                while ns2:\n                    na = list(ns2)\n                    s2 |= ns2\n                    ns2 = set()\n                    for k in na:\n                        ns2 |= ee[k]\n                        ns1.add(ed[k])\n                    ns2 -= s2\n\n                ns1 -= s1\n\n            if s1 & s2:\n                f = False\n            # print('k', k)\n            # print('s1', s1)\n            # print('s2', s2)\n\n            if f:\n                for k in s1:\n                    v[k] = 1\n                for k in s2:\n                    v[k] = 1\n            else:\n                break\n\n        if f:\n            rr.append('Yes')\n        else:\n            rr.append('No')\n\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n\n        a = [LS() for _ in range(n)]\n        d = collections.defaultdict(int)\n        for i in range(n):\n            x, y, di = a[i]\n            x = int(x)\n            y = int(y)\n            d[(x,y)] = i + 1\n            if di == 'x':\n                d[(x+1,y)] = i + 1\n            else:\n                d[(x,y+1)] = i + 1\n\n        v = collections.defaultdict(bool)\n        f = True\n        for k in list(d.keys()):\n            if v[k]:\n                continue\n            s1 = set()\n            s2 = set()\n            ns1 = set([k])\n            ns2 = set()\n            while ns1 or ns2:\n                for ak in list(ns1):\n                    for di,dj in dd:\n                        nk = (ak[0]+di, ak[1]+dj)\n                        if d[nk] == 0:\n                            continue\n                        if d[nk] == d[ak]:\n                            ns2.add(nk)\n                        else:\n                            ns1.add(nk)\n                ns2 -= s2\n                for ak in list(ns2):\n                    for di,dj in dd:\n                        nk = (ak[0]+di, ak[1]+dj)\n                        if d[nk] == 0:\n                            continue\n                        if d[nk] == d[ak]:\n                            ns1.add(nk)\n                        else:\n                            ns2.add(nk)\n\n                ns2 -= s2\n                ns1 -= s1\n                s2 |= ns2\n                s1 |= ns1\n                if s1 & s2:\n                    f = False\n                    break\n\n            if not f:\n                break\n\n            for c in s1:\n                v[c] = 1\n            for c in s2:\n                v[c] = 1\n\n        if f:\n            rr.append('Yes')\n        else:\n            rr.append('No')\n\n\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n\n        a = [LS() for _ in range(n)]\n        d = collections.defaultdict(int)\n        ed = collections.defaultdict(lambda: None)\n        for i in range(n):\n            x, y, di = a[i]\n            x = int(x)\n            y = int(y)\n            d[(x,y)] = i + 1\n            if di == 'x':\n                d[(x+1,y)] = i + 1\n                ed[(x,y)] = (x+1,y)\n                ed[(x+1,y)] = (x,y)\n            else:\n                d[(x,y+1)] = i + 1\n                ed[(x,y)] = (x,y+1)\n                ed[(x,y+1)] = (x,y)\n\n        ee = collections.defaultdict(set)\n        dka = list(d.keys())\n        for x,y in list(d.keys()):\n            dt = d[(x,y)]\n            for di,dj in dd:\n                ni = x + di\n                nj = y + dj\n                if d[(ni,nj)] > 0 and d[(ni,nj)] != dt:\n                    ee[(x,y)].add((ni,nj))\n\n        v = collections.defaultdict(bool)\n        f = True\n        for k in dka:\n            if v[k]:\n                continue\n            s1 = set()\n            s2 = set()\n            ns1 = set([k])\n            ns2 = set()\n            while ns1 or ns2:\n                s1 |= ns1\n                na = list(ns1)\n                ns1 = set()\n                for k in na:\n                    ns1 |= ee[k]\n                    ns2.add(ed[k])\n\n                ns2 -= s2\n                na = list(ns2)\n                s2 |= ns2\n                ns2 = set()\n                for k in na:\n                    ns2 |= ee[k]\n                    ns1.add(ed[k])\n\n                ns1 -= s1\n                ns2 -= s2\n                s1 |= ns1\n                s2 |= ns2\n                if s1 & s2:\n                    f = False\n                    break\n            # print('k', k)\n            # print('s1', s1)\n            # print('s2', s2)\n\n            if f:\n                for k in s1:\n                    v[k] = 1\n                for k in s2:\n                    v[k] = 1\n            else:\n                break\n\n        if f:\n            rr.append('Yes')\n        else:\n            rr.append('No')\n\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\nmove = [(0,1),(1,0)]\ndef solve(n):\n    f = defaultdict(lambda : 0)\n    v = defaultdict(list)\n    l = []\n    for i in range(n):\n        a,b,dir = input().split()\n        a = int(a)\n        b = int(b)\n        f[(a,b)] = 1\n        dir = 0 if dir == \"x\" else 1\n        na,nb = a+1-dir,b+dir\n        f[(na,nb)] = 1\n        l.append((a,b,na,nb))\n        l.append((na,nb,a,b))\n        v[(a,b)].append(((na,nb),1))\n        v[(na,nb)].append(((a,b),1))\n    for a,b,c,d in l:\n        for dx,dy in move:\n            na,nb = a+dx,b+dy\n            if f[(na,nb)] and (c,d) != (na,nb):\n                v[(a,b)].append(((na,nb),0))\n                v[(na,nb)].append(((a,b),0))\n    bfs = defaultdict(lambda : -1)\n    q = deque()\n    for a,b,c,d in l:\n        if bfs[(a,b)] < 0:\n            q.append((a,b))\n            bfs[(a,b)] = 0\n            while q:\n                x,y = q.popleft()\n                for node,k in v[(x,y)]:\n                    nx,ny = node\n                    if k:\n                        nb = 1-bfs[(x,y)]\n                    else:\n                        nb = bfs[(x,y)]\n                    if bfs[(nx,ny)] >= 0:\n                        if bfs[(nx,ny)] != nb:\n                            print(\"No\")\n                            return\n                    else:\n                        bfs[(nx,ny)] = nb\n                        q.append((nx,ny))\n    print(\"Yes\")\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    while 1:\n        n = I()\n        if n == 0:\n            break\n        solve(n)\n\n"
  },
  {
    "language": "Python",
    "code": "def check(x,y,d):\n    if d == \"x\":\n        for i in xrange(6):\n            dx,dy = dxy1[i]\n            if not (x+dx,y+dy) in futon: continue\n            if futon[(x+i/3,y)] != futon[(x+dx,y+dy)]:\n                return False\n    else:\n        for i in xrange(6):\n            dx,dy = dxy2[i]\n            if not (x+dx,y+dy) in futon: continue\n            if futon[(x,y+i/3)] != futon[(x+dx,y+dy)]:\n                return False\n    return True\n\ndxy1 = zip([-1,0,0,1,1,2],[0,1,-1,1,-1,0])\ndxy2 = zip([0,1,-1,1,-1,0],[-1,0,0,1,1,2])\nwhile 1:\n    futon = {}\n    n = int(raw_input())\n    if n == 0: break\n    valid = True\n    for loop in xrange(n):\n        x,y,d = raw_input().split()\n        x,y = int(x),int(y)\n        if not valid: continue\n        if d == \"x\":\n            for dx,dy in dxy1:\n                if (x+dx,y+dy) in futon:\n                    v = futon[(x+dx,y+dy)]\n                    futon[(x  ,y)] = (v   if dx < 1 else 1-v)\n                    futon[(x+1,y)] = (1-v if dx < 1 else v  )\n                    valid = check(x,y,d)\n                    break\n            else:\n                futon[(x  ,y)] = 1\n                futon[(x+1,y)] = 0\n        else:\n            for dx,dy in dxy2:\n                if (x+dx,y+dy) in futon:\n                    v = futon[(x+dx,y+dy)]\n                    futon[(x  ,y)] = (v   if dy < 1 else 1-v)\n                    futon[(x,y+1)] = (1-v if dy < 1 else v  )\n                    valid = check(x,y,d)\n                    break\n            else:\n                futon[(x,y  )] = 1\n                futon[(x,y+1)] = 0\n    \n    print \"Yes\" if valid else \"No\""
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    while True:\n        n = I()\n        if n == 0:\n            break\n\n        a = [LS() for _ in range(n)]\n        d = collections.defaultdict(int)\n        for i in range(n):\n            x, y, di = a[i]\n            x = int(x)\n            y = int(y)\n            d[(x,y)] = i + 1\n            if di == 'x':\n                d[(x+1,y)] = i + 1\n            else:\n                d[(x,y+1)] = i + 1\n\n        v = collections.defaultdict(bool)\n        f = True\n        for k in list(d.keys()):\n            if v[k]:\n                continue\n            s1 = set()\n            s2 = set()\n            ns1 = set([k])\n            ns2 = set()\n            while ns1:\n                while ns1:\n                    ns1 -= s1\n                    s1 |= ns1\n                    for ak in list(ns1):\n                        for di,dj in dd:\n                            nk = (ak[0]+di, ak[1]+dj)\n                            if d[nk] == 0:\n                                continue\n                            if d[nk] == d[ak]:\n                                ns2.add(nk)\n                            else:\n                                ns1.add(nk)\n                    if s1 & s2:\n                        f = False\n                        break\n\n                while ns2:\n                    ns2 -= s2\n                    s2 |= ns2\n                    for ak in list(ns2):\n                        for di,dj in dd:\n                            nk = (ak[0]+di, ak[1]+dj)\n                            if d[nk] == 0:\n                                continue\n                            if d[nk] == d[ak]:\n                                ns1.add(nk)\n                            else:\n                                ns2.add(nk)\n\n                    if s1 & s2:\n                        f = False\n                        break\n\n                if s1 & s2:\n                    f = False\n                    break\n\n            if not f:\n                break\n\n            for c in s1:\n                v[c] = 1\n            for c in s2:\n                v[c] = 2\n\n        if f:\n            rr.append('Yes')\n        else:\n            rr.append('No')\n\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  }
]