[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 100\n\nint H, W;\nchar room[MAX_SIZE][MAX_SIZE];\n\nbool check_bad_custom() {\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (room[i][j] == '<') {\n                if (j + 1 < W && room[i][j + 1] == '>') {\n                    return true;\n                }\n            } else if (room[i][j] == '^') {\n                if (i + 1 < H && room[i + 1][j] == 'v') {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        scanf(\"%s\", room[i]);\n    }\n    if (check_bad_custom()) {\n        printf(\"No\\n\");\n    } else {\n        printf(\"Yes\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:12:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> grid(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> grid[i];\n    }\n\n    bool valid = true;\n    for (int i = 0; i < H && valid; ++i) {\n        for (int j = 0; j < W && valid; ++j) {\n            if (grid[i][j] == 'R') {\n                if (j + 1 < W && grid[i][j + 1] == 'R') {\n                    grid[i][j] = grid[i][j + 1] = '.';\n                } else if (i + 1 < H && grid[i + 1][j] == 'R') {\n                    if (j > 0 && grid[i + 1][j - 1] == 'R') {\n                        valid = false;\n                    }\n                    if (j + 1 < W && grid[i + 1][j + 1] == 'R') {\n                        valid = false;\n                    }\n                    grid[i][j] = grid[i + 1][j] = '.';\n                } else {\n                    valid = false;\n                }\n            }\n        }\n    }\n\n    cout << (valid ? \"Yes\" : \"No\") << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:12:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class FutonArrangement {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        scanner.nextLine(); // consume the remaining newline\n        \n        char[][] grid = new char[H][W];\n        for (int i = 0; i < H; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < W; j++) {\n                grid[i][j] = line.charAt(j);\n            }\n        }\n        \n        boolean isValid = true;\n        for (int i = 0; i < H && isValid; i++) {\n            for (int j = 0; j < W && isValid; j++) {\n                if (grid[i][j] == '.') {\n                    if (j + 1 < W && grid[i][j + 1] == '.') {\n                        grid[i][j] = 'H';\n                        grid[i][j + 1] = 'h';\n                    } else if (i + 1 < H && grid[i + 1][j] == '.') {\n                        grid[i][j] = 'H';\n                        grid[i + 1][j] = 'h';\n                    } else {\n                        isValid = false;\n                    }\n                }\n            }\n        }\n        \n        System.out.println(isValid ? \"Yes\" : \"No\");\n    }\n}",
    "timestamp": "2025-08-05 21:12:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class FutonArrangement {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int rows = scanner.nextInt();\n        int cols = scanner.nextInt();\n        \n        char[][] room = new char[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            String row = scanner.next();\n            room[i] = row.toCharArray();\n        }\n        \n        boolean possible = canAvoidBadCustom(room);\n        System.out.println(possible ? \"Yes\" : \"No\");\n    }\n    \n    static boolean canAvoidBadCustom(char[][] room) {\n        int rows = room.length;\n        int cols = room[0].length;\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (room[i][j] == '.') {\n                    // Check horizontal placement\n                    if (j + 1 < cols && room[i][j+1] == '.') {\n                        char[][] tempRoom = copyRoom(room);\n                        tempRoom[i][j] = 'X';\n                        tempRoom[i][j+1] = 'X';\n                        \n                        if (isValidArrangement(tempRoom)) {\n                            return true;\n                        }\n                    }\n                    \n                    // Check vertical placement\n                    if (i + 1 < rows && room[i+1][j] == '.') {\n                        char[][] tempRoom = copyRoom(room);\n                        tempRoom[i][j] = 'X';\n                        tempRoom[i+1][j] = 'X';\n                        \n                        if (isValidArrangement(tempRoom)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    static boolean isValidArrangement(char[][] room) {\n        int rows = room.length;\n        int cols = room[0].length;\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (room[i][j] == 'X') {\n                    // Check adjacent cells\n                    int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n                    \n                    for (int[] dir : directions) {\n                        int newRow = i + dir[0];\n                        int newCol = j + dir[1];\n                        \n                        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && room[newRow][newCol] == 'X') {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n    static char[][] copyRoom(char[][] original) {\n        char[][] copy = new char[original.length][original[0].length];\n        for (int i = 0; i < original.length; i++) {\n            copy[i] = original[i].clone();\n        }\n        return copy;\n    }\n}",
    "timestamp": "2025-08-05 21:12:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_ROWS 100\n#define MAX_COLS 100\n\nint main() {\n    int rows, cols;\n    char room[MAX_ROWS][MAX_COLS];\n    \n    scanf(\"%d %d\", &rows, &cols);\n    \n    for (int i = 0; i < rows; i++) {\n        scanf(\"%s\", room[i]);\n    }\n    \n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n            if (room[r][c] == 'X') {\n                // Check horizontal futon\n                if (c + 1 < cols && room[r][c+1] == 'X') {\n                    // Horizontal futon placement\n                    if ((r > 0 && (room[r-1][c] == 'X' || room[r-1][c+1] == 'X')) ||\n                        (r + 1 < rows && (room[r+1][c] == 'X' || room[r+1][c+1] == 'X'))) {\n                        printf(\"bad\\n\");\n                        return 0;\n                    }\n                }\n                \n                // Check vertical futon\n                if (r + 1 < rows && room[r+1][c] == 'X') {\n                    // Vertical futon placement\n                    if ((c > 0 && (room[r][c-1] == 'X' || room[r+1][c-1] == 'X')) ||\n                        (c + 1 < cols && (room[r][c+1] == 'X' || room[r+1][c+1] == 'X'))) {\n                        printf(\"bad\\n\");\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n    \n    printf(\"good\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 21:12:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool canAvoidFeetHeadContact(vector<vector<char>>& room) {\n    int rows = room.size();\n    int cols = room[0].size();\n\n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols - 1; c++) {\n            if (room[r][c] == 'P' && room[r][c+1] == 'P') {\n                // Check horizontal placement\n                if (r > 0 && ((room[r-1][c] == 'P' || room[r-1][c+1] == 'P'))) return false;\n                if (r < rows-1 && ((room[r+1][c] == 'P' || room[r+1][c+1] == 'P'))) return false;\n            }\n        }\n    }\n\n    for (int r = 0; r < rows - 1; r++) {\n        for (int c = 0; c < cols; c++) {\n            if (room[r][c] == 'P' && room[r+1][c] == 'P') {\n                // Check vertical placement\n                if (c > 0 && ((room[r][c-1] == 'P' || room[r+1][c-1] == 'P'))) return false;\n                if (c < cols-1 && ((room[r][c+1] == 'P' || room[r+1][c+1] == 'P'))) return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    int rows, cols;\n    cin >> rows >> cols;\n\n    vector<vector<char>> room(rows, vector<char>(cols));\n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n            cin >> room[r][c];\n        }\n    }\n\n    cout << (canAvoidFeetHeadContact(room) ? \"Yes\" : \"No\") << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:13:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_avoid_feet_adjacent_to_head(grid):\n    n = len(grid)\n    m = len(grid[0])\n    \n    # Check vertical placement\n    for i in range(n-1):\n        for j in range(m):\n            if grid[i][j] == 'F' and grid[i+1][j] == 'H':\n                return False\n            if grid[i][j] == 'H' and grid[i+1][j] == 'F':\n                return False\n\n    # Check horizontal placement\n    for i in range(n):\n        for j in range(m-1):\n            if grid[i][j] == 'F' and grid[i][j+1] == 'H':\n                return False\n            if grid[i][j] == 'H' and grid[i][j+1] == 'F':\n                return False\n\n    return True\n\n# Example usage\nroom = [\n    ['H', 'F', '.', '.'],\n    ['.', '.', 'F', 'H'],\n    ['F', 'H', '.', 'F'],\n    ['H', 'F', 'H', '.']\n]\n\nprint(can_avoid_feet_adjacent_to_head(room))  # Output: False",
    "timestamp": "2025-08-13 05:29:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class FutonArrangement {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int n = scanner.nextInt(); // Row count\n        int m = scanner.nextInt(); // Column count\n        scanner.nextLine(); // Consume the newline character\n        \n        char[][] room = new char[n][m];\n        \n        for (int i = 0; i < n; i++) {\n            room[i] = scanner.nextLine().toCharArray();\n        }\n        \n        boolean isSafe = true;\n        \n        for (int i = 0; i < n && isSafe; i++) {\n            for (int j = 0; j < m && isSafe; j++) {\n                if (room[i][j] == 'H') {\n                    if (j < m - 1 && room[i][j + 1] == 'F') {\n                        isSafe = false; // Head next to Foot\n                    }\n                    if (j > 0 && room[i][j - 1] == 'F') {\n                        isSafe = false; // Head next to Foot\n                    }\n                    if (i < n - 1 && room[i + 1][j] == 'F') {\n                        isSafe = false; // Head next to Foot\n                    }\n                    if (i > 0 && room[i - 1][j] == 'F') {\n                        isSafe = false; // Head next to Foot\n                    }\n                } else if (room[i][j] == 'F') {\n                    if (j < m - 1 && room[i][j + 1] == 'H') {\n                        isSafe = false; // Foot next to Head\n                    }\n                    if (j > 0 && room[i][j - 1] == 'H') {\n                        isSafe = false; // Foot next to Head\n                    }\n                    if (i < n - 1 && room[i + 1][j] == 'H') {\n                        isSafe = false; // Foot next to Head\n                    }\n                    if (i > 0 && room[i - 1][j] == 'H') {\n                        isSafe = false; // Foot next to Head\n                    }\n                }\n            }\n        }\n        \n        System.out.println(isSafe ? \"SAFE\" : \"UNSAFE\");\n    }\n}",
    "timestamp": "2025-08-13 05:29:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MAX 50\n\nint main() {\n    int n, m;\n    char room[MAX][MAX];\n    int i, j;\n\n    scanf(\"%d %d\", &n, &m);\n    for (i = 0; i < n; i++) {\n        scanf(\"%s\", room[i]);\n    }\n\n    int bad_custom = 0;\n    for (i = 0; i < n && !bad_custom; i++) {\n        for (j = 0; j < m && !bad_custom; j++) {\n            if (room[i][j] == 'H') {\n                if (j + 1 < m && room[i][j + 1] == 'F') { // horizontal check\n                    bad_custom = 1;\n                }\n                if (i + 1 < n && room[i + 1][j] == 'F') { // vertical check\n                    bad_custom = 1;\n                }\n            } else if (room[i][j] == 'F') {\n                if (j + 1 < m && room[i][j + 1] == 'H') { // horizontal check\n                    bad_custom = 1;\n                }\n                if (i + 1 < n && room[i + 1][j] == 'H') { // vertical check\n                    bad_custom = 1;\n                }\n            }\n        }\n    }\n\n    if (bad_custom) {\n        printf(\"Bad\\n\");\n    } else {\n        printf(\"Good\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 05:29:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def can_avoid_bad_custom(grid):\n    rows, cols = len(grid), len(grid[0])\n    futons = []\n    \n    # Find futon positions\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 1:\n                # Horizontal futon\n                if c+1 < cols and grid[r][c+1] == 1:\n                    futons.append(((r,c), (r,c+1)))\n                # Vertical futon\n                elif r+1 < rows and grid[r+1][c] == 1:\n                    futons.append(((r,c), (r+1,c)))\n    \n    # Check adjacency\n    for i in range(len(futons)):\n        for j in range(i+1, len(futons)):\n            r1, c1 = futons[i][0]\n            r2, c2 = futons[i][1]\n            r3, c3 = futons[j][0]\n            r4, c4 = futons[j][1]\n            \n            if abs(r1-r3) <= 1 and abs(c1-c3) <= 1: return False\n            if abs(r1-r4) <= 1 and abs(c1-c4) <= 1: return False\n            if abs(r2-r3) <= 1 and abs(c2-c3) <= 1: return False\n            if abs(r2-r4) <= 1 and abs(c2-c4) <= 1: return False\n    \n    return True",
    "timestamp": "2025-08-13 05:29:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    T = int(data[idx])\n    idx += 1\n    \n    for _ in range(T):\n        H, W = map(int, data[idx:idx+2])\n        idx +=2\n        grid = []\n        for _ in range(H):\n            row = data[idx]\n            idx +=1\n            grid.append(row)\n        \n        possible = True\n        for i in range(H):\n            for j in range(W):\n                if grid[i][j] == 'R':\n                    # Check right neighbor\n                    if j + 1 < W and grid[i][j+1] == 'R':\n                        possible = False\n                        break\n                    # Check bottom neighbor if current is in even row (0-based)\n                    if i + 1 < H and grid[i+1][j] == 'R':\n                        if j > 0 and grid[i+1][j-1] == 'R':\n                            possible = False\n                            break\n            if not possible:\n                break\n        \n        print(\"YES\" if possible else \"NO\")\n\nsolve()",
    "timestamp": "2025-08-13 05:30:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool canSleepWithoutHeadAdjacentToFeet(vector<vector<char>>& room, int rows, int cols) {\n    // Traverse the grid and check for adjacent head and feet\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            if (room[i][j] == 'F') {\n                if ((j + 1 < cols && room[i][j + 1] == 'H') || (j > 0 && room[i][j - 1] == 'H')) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int rows, cols;\n    cin >> rows >> cols;\n    vector<vector<char>> room(rows, vector<char>(cols));\n\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            cin >> room[i][j];\n        }\n    }\n\n    if (canSleepWithoutHeadAdjacentToFeet(room, rows, cols)) {\n        cout << \"Yes\\n\";\n    } else {\n        cout << \"No\\n\";\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:25:35"
  }
]