[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint calc_diff(long long a, long long b, int n) {\n    long long diff = abs(a - b);\n    return (diff < (1LL << (4 * n)) - diff) ? diff : (1LL << (4 * n)) - diff;\n}\n\nint is_valid_password(long long pwd, int n) {\n    int digits[10] = {0};\n    for (int i = 0; i < n; i++) {\n        int digit = pwd % 10;\n        if (digits[digit]) return 0;\n        digits[digit] = 1;\n        pwd /= 10;\n    }\n    return 1;\n}\n\nlong long generate_max_diff_password(long long old_pwd, int n) {\n    long long max_diff = 0;\n    long long best_pwd = 0;\n\n    for (long long pwd = 0; pwd < (1LL << (4 * n)); pwd++) {\n        if (!is_valid_password(pwd, n)) continue;\n\n        long long diff = calc_diff(old_pwd, pwd, n);\n        if (diff > max_diff || (diff == max_diff && pwd < best_pwd)) {\n            max_diff = diff;\n            best_pwd = pwd;\n        }\n    }\n\n    return best_pwd;\n}\n\nint main() {\n    int n;\n    long long old_pwd;\n    scanf(\"%d %lld\", &n, &old_pwd);\n    \n    long long new_pwd = generate_max_diff_password(old_pwd, n);\n    \n    printf(\"%0*lld\\n\", n, new_pwd);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:55:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_DIGITS 10\n\nbool used[MAX_DIGITS];\n\nint findMaxDiffDigit(int old_digit, int N) {\n    int max_diff = 0;\n    int best_digit = -1;\n    for (int d = 0; d < 10; d++) {\n        if (used[d]) continue;\n        int diff1 = abs(old_digit - d);\n        int diff2 = (1 << N) * 5 - diff1; // 10^N is 1 followed by N zeros, but since N is digit count, 10^N is pow(10, N)\n        int current_diff = diff1 < diff2 ? diff1 : diff2;\n        if (current_diff > max_diff) {\n            max_diff = current_diff;\n            best_digit = d;\n        } else if (current_diff == max_diff && d < best_digit) {\n            best_digit = d;\n        }\n    }\n    return best_digit;\n}\n\nvoid generatePassword(char* old_pwd, char* new_pwd, int N) {\n    memset(used, false, sizeof(used));\n    for (int i = 0; i < N; i++) {\n        int old_digit = old_pwd[i] - '0';\n        int new_digit = findMaxDiffDigit(old_digit, N);\n        if (new_digit == -1) {\n            // Fallback: use the smallest available digit if no digit found (shouldn't happen if input is valid)\n            for (int d = 0; d < 10; d++) {\n                if (!used[d]) {\n                    new_digit = d;\n                    break;\n                }\n            }\n        }\n        used[new_digit] = true;\n        new_pwd[i] = new_digit + '0';\n    }\n    new_pwd[N] = '\\0';\n}\n\nint main() {\n    char old_pwd[MAX_DIGITS + 1];\n    char new_pwd[MAX_DIGITS + 1];\n    scanf(\"%s\", old_pwd);\n    int N = strlen(old_pwd);\n    generatePassword(old_pwd, new_pwd, N);\n    printf(\"%s\\n\", new_pwd);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:55:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <climits>\n#include <set>\n\nusing namespace std;\n\nlong long compute_diff(const string& old_pwd, const string& new_pwd) {\n    long long N = old_pwd.size();\n    long long a = stoll(old_pwd);\n    long long b = stoll(new_pwd);\n    long long diff = abs(a - b);\n    long long max_num = 1;\n    for (int i = 0; i < N; ++i) max_num *= 10;\n    return min(diff, max_num - diff);\n}\n\nstring generate_password(const string& old_pwd) {\n    int N = old_pwd.size();\n    set<char> digits;\n    for (char c : old_pwd) {\n        digits.insert(c);\n    }\n    if (digits.size() == N) {\n        return old_pwd;\n    }\n\n    vector<char> available_digits;\n    for (char c = '0'; c <= '9'; ++c) {\n        if (digits.find(c) == digits.end()) {\n            available_digits.push_back(c);\n        }\n    }\n\n    string best_pwd;\n    long long max_diff = -1;\n\n    vector<char> current(N);\n    vector<bool> used(10, false);\n\n    function<void(int)> backtrack = [&](int pos) {\n        if (pos == N) {\n            string candidate(current.begin(), current.end());\n            long long diff = compute_diff(old_pwd, candidate);\n            if (diff > max_diff || (diff == max_diff && (best_pwd.empty() || candidate < best_pwd))) {\n                max_diff = diff;\n                best_pwd = candidate;\n            }\n            return;\n        }\n\n        for (char c = '0'; c <= '9'; ++c) {\n            if (!used[c - '0']) {\n                used[c - '0'] = true;\n                current[pos] = c;\n                backtrack(pos + 1);\n                used[c - '0'] = false;\n            }\n        }\n    };\n\n    backtrack(0);\n    return best_pwd;\n}\n\nint main() {\n    string old_pwd;\n    cin >> old_pwd;\n    string new_pwd = generate_password(old_pwd);\n    cout << new_pwd << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:55:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PasswordGenerator {\n    public static String generateNewPassword(String oldPassword) {\n        int n = oldPassword.length();\n        int[] oldDigits = new int[n];\n        for (int i = 0; i < n; i++) {\n            oldDigits[i] = oldPassword.charAt(i) - '0';\n        }\n\n        Set<Integer> usedDigits = new HashSet<>();\n        int[] newDigits = new int[n];\n        for (int i = 0; i < n; i++) {\n            int currentDigit = oldDigits[i];\n            int maxDiff = -1;\n            int bestDigit = -1;\n            for (int d = 0; d <= 9; d++) {\n                if (usedDigits.contains(d)) continue;\n                int diff = Math.min(Math.abs(currentDigit - d), (int) Math.pow(10, n) - Math.abs(currentDigit - d));\n                if (diff > maxDiff || (diff == maxDiff && d < bestDigit)) {\n                    maxDiff = diff;\n                    bestDigit = d;\n                }\n            }\n            newDigits[i] = bestDigit;\n            usedDigits.add(bestDigit);\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (int digit : newDigits) {\n            sb.append(digit);\n        }\n        return sb.toString();\n    }\n}",
    "timestamp": "2025-08-05 21:56:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PasswordGenerator {\n    public static String generatePassword(String oldPassword) {\n        int n = oldPassword.length();\n        int oldNum = Integer.parseInt(oldPassword);\n        int maxDiff = 0;\n        int bestNewNum = Integer.MAX_VALUE;\n\n        for (int newNum = 0; newNum < Math.pow(10, n); newNum++) {\n            if (hasUniqueDigits(newNum, n) && !hasRepeatedDigits(newNum)) {\n                int diff = calculateDifference(oldNum, newNum, n);\n                if (diff > maxDiff || (diff == maxDiff && newNum < bestNewNum)) {\n                    maxDiff = diff;\n                    bestNewNum = newNum;\n                }\n            }\n        }\n\n        return String.format(\"%0\" + n + \"d\", bestNewNum);\n    }\n\n    private static boolean hasUniqueDigits(int num, int n) {\n        return String.format(\"%0\" + n + \"d\", num).length() == n;\n    }\n\n    private static boolean hasRepeatedDigits(int num) {\n        String strNum = String.format(\"%d\", num);\n        Set<Character> digitSet = new HashSet<>();\n        for (char c : strNum.toCharArray()) {\n            if (!digitSet.add(c)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static int calculateDifference(int oldNum, int newNum, int n) {\n        int directDiff = Math.abs(oldNum - newNum);\n        return Math.min(directDiff, (int)Math.pow(10, n) - directDiff);\n    }\n}",
    "timestamp": "2025-08-05 21:56:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing namespace std;\n\nint calcDifference(const string& a, const string& b) {\n    long long num_a = stoll(a);\n    long long num_b = stoll(b);\n    int N = a.length();\n    int diff1 = abs(num_a - num_b);\n    int diff2 = pow(10, N) - diff1;\n    return min(diff1, diff2);\n}\n\nstring generateNewPassword(const string& oldPassword) {\n    int N = oldPassword.length();\n    vector<int> digits(10);\n    for (char c : oldPassword) {\n        digits[c - '0']++;\n    }\n\n    vector<int> availableDigits;\n    for (int i = 0; i < 10; ++i) {\n        if (digits[i] == 0) availableDigits.push_back(i);\n    }\n\n    string bestPassword = oldPassword;\n    int maxDiff = 0;\n\n    do {\n        string newPassword = oldPassword;\n        for (int i = 0; i < N; ++i) {\n            if (newPassword[i] - '0' == availableDigits[i]) {\n                continue;\n            }\n            newPassword[i] = availableDigits[i] + '0';\n        }\n\n        int diff = calcDifference(oldPassword, newPassword);\n        if (diff > maxDiff || (diff == maxDiff && stoll(newPassword) < stoll(bestPassword))) {\n            maxDiff = diff;\n            bestPassword = newPassword;\n        }\n    } while (next_permutation(availableDigits.begin(), availableDigits.end()));\n\n    return bestPassword;\n}\n\nint main() {\n    string oldPassword;\n    cin >> oldPassword;\n    cout << generateNewPassword(oldPassword) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:56:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_difference_password(old_password):\n    digits = list(map(int, str(old_password)))\n    N = len(digits)\n    \n    available_digits = set(range(0, 10))\n    used_digits = set()\n    \n    new_password = []\n    \n    for digit in digits:\n        remaining_digits = list(available_digits - used_digits)\n        max_diff_digit = None\n        max_diff = -1\n        \n        for d in remaining_digits:\n            diff = min(abs(d - digit), 10 ** N - abs(d - digit))\n            if diff > max_diff or (diff == max_diff and (max_diff_digit is None or d < max_diff_digit)):\n                max_diff_digit = d\n                max_diff = diff\n                \n        new_password.append(max_diff_digit)\n        used_digits.add(max_diff_digit)\n        \n    return int(\"\".join(map(str, new_password)))\n\n# Example usage:\nold_password = 12345\nnew_password = max_difference_password(old_password)\nprint(new_password)",
    "timestamp": "2025-08-13 08:08:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class PasswordGenerator {\n    public static String generateNewPassword(String oldPassword) {\n        int N = oldPassword.length();\n        char[] oldDigits = oldPassword.toCharArray();\n        char[] newDigits = new char[N];\n        Set<Character> usedDigits = new HashSet<>();\n\n        int maxDiff = 0;\n        for (int i = 0; i < N; i++) {\n            char currentDigit = oldDigits[i];\n            char bestReplacement = '0';\n            for (char digit = '0'; digit <= '9'; digit++) {\n                if (usedDigits.contains(digit)) continue;\n                \n                int difference = Math.abs(currentDigit - digit);\n                difference = Math.min(difference, 10 - difference);\n\n                if (difference > maxDiff || (difference == maxDiff && digit < bestReplacement)) {\n                    maxDiff = difference;\n                    bestReplacement = digit;\n                }\n            }\n            newDigits[i] = bestReplacement;\n            usedDigits.add(bestReplacement);\n        }\n\n        return new String(newDigits);\n    }\n\n    public static void main(String[] args) {\n        String oldPassword = \"1234\";\n        System.out.println(generateNewPassword(oldPassword)); // Example usage\n    }\n}",
    "timestamp": "2025-08-13 08:08:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_DIGITS 10\n\nint main() {\n    char oldPassword[MAX_DIGITS + 1];\n    char newPassword[MAX_DIGITS + 1];\n    int digitUsed[MAX_DIGITS] = {0};\n\n    // Read old password\n    scanf(\"%s\", oldPassword);\n    int length = strlen(oldPassword);\n\n    // Generate new password\n    int maxDiff = -1;\n    int bestNewPassword[MAX_DIGITS] = {0};\n\n    for (int i = 0; i < length; ++i) {\n        int oldDigit = oldPassword[i] - '0';\n\n        int maxLocalDiff = -1;\n        int bestLocalDigit = -1;\n        for (int digit = 0; digit < MAX_DIGITS; ++digit) {\n            if (digitUsed[digit]) continue;\n\n            int diff = abs(oldDigit - digit);\n            int minDiff = diff < 10 - diff ? diff : 10 - diff;\n\n            if (minDiff > maxLocalDiff || (minDiff == maxLocalDiff && digit < bestLocalDigit)) {\n                maxLocalDiff = minDiff;\n                bestLocalDigit = digit;\n            }\n        }\n        digitUsed[bestLocalDigit] = 1;\n        bestNewPassword[i] = bestLocalDigit;\n\n        // Update maxDiff\n        if (maxLocalDiff > maxDiff) {\n            maxDiff = maxLocalDiff;\n            memcpy(newPassword, bestNewPassword, sizeof(bestNewPassword));\n        } else if (maxLocalDiff == maxDiff) {\n            // Check lexicographical order for the same maxDiff\n            for (int j = 0; j < length; ++j) {\n                if (bestNewPassword[j] < newPassword[j]) {\n                    memcpy(newPassword, bestNewPassword, sizeof(bestNewPassword));\n                    break;\n                }\n                if (bestNewPassword[j] > newPassword[j]) {\n                    break;\n                }\n            }\n        }\n    }\n\n    // Convert new password array to string\n    for (int i = 0; i < length; ++i) {\n        newPassword[i] = bestNewPassword[i] + '0';\n    }\n    newPassword[length] = '\\0';\n\n    // Output new password\n    printf(\"%s\\n\", newPassword);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 08:09:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def generate_password(old_password):\n    N = len(old_password)\n    old_digits = [int(d) for d in old_password]\n    \n    max_diff = -1\n    best_password = None\n    \n    for perm in permutations(range(10), N):\n        if len(set(perm)) == N:\n            diff = min(\n                sum(abs(a - b) for a, b in zip(old_digits, perm)),\n                10**N - sum(abs(a - b) for a, b in zip(old_digits, perm))\n            )\n            \n            if diff > max_diff or (diff == max_diff and (best_password is None or int(''.join(map(str, perm))) < int(''.join(map(str, best_password))))):\n                max_diff = diff\n                best_password = perm\n    \n    return ''.join(map(str, best_password))\n\nfrom itertools import permutations",
    "timestamp": "2025-08-13 08:09:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def generate_new_password(old_password):\n    N = len(old_password)\n    digits = list(old_password)\n    unique_digits = sorted(list(set(digits)), key=int)\n    candidates = []\n    \n    for d in unique_digits:\n        remaining_digits = [x for x in unique_digits if x != d]\n        new_digits = [d]\n        for i in range(1, N):\n            if i <= len(remaining_digits):\n                new_digits.append(remaining_digits[-i])\n            else:\n                new_digits.append(remaining_digits[0])\n        candidate = ''.join(new_digits)\n        candidates.append(candidate)\n    \n    max_diff = -1\n    best_candidate = None\n    \n    for candidate in candidates:\n        total_diff = 0\n        for a, b in zip(old_password, candidate):\n            a_int = int(a)\n            b_int = int(b)\n            diff = abs(a_int - b_int)\n            total_diff += min(diff, 10**N - diff)\n        \n        if total_diff > max_diff or (total_diff == max_diff and (best_candidate is None or int(candidate) < int(best_candidate))):\n            max_diff = total_diff\n            best_candidate = candidate\n    \n    return best_candidate",
    "timestamp": "2025-08-13 08:09:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <cmath>\n\nint difference(int a, int b, int N) {\n    int diff = std::abs(a - b);\n    return std::min(diff, static_cast<int>(std::pow(10, N)) - diff);\n}\n\nstd::string generate_new_password(const std::string& old_password) {\n    int N = old_password.length();\n    std::vector<int> old_digits(N);\n    for (int i = 0; i < N; ++i) {\n        old_digits[i] = old_password[i] - '0';\n    }\n    \n    std::set<int> available_digits;\n    for (int i = 0; i < 10; ++i) {\n        available_digits.insert(i);\n    }\n    \n    std::string new_password(N, '0');\n    \n    for (int i = 0; i < N; ++i) {\n        int best_digit = -1;\n        int best_difference = -1;\n        \n        for (int digit : available_digits) {\n            int diff = difference(old_digits[i], digit, N);\n            if (diff > best_difference || (diff == best_difference && digit < best_digit)) {\n                best_difference = diff;\n                best_digit = digit;\n            }\n        }\n        \n        new_password[i] = '0' + best_digit;\n        available_digits.erase(best_digit);\n    }\n    \n    return new_password;\n}\n\nint main() {\n    std::string old_password;\n    std::cin >> old_password;\n    std::string new_password = generate_new_password(old_password);\n    std::cout << new_password << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:43:34"
  }
]