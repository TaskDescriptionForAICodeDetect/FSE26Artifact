[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Real = double;\nusing Point = complex< Real >;\nconst Real EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p) {\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(Real theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r) {\n  return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d) {\n  return (d * PI / 180.0);\n}\n\nReal get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  Real r;\n\n  Circle() = default;\n\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\nReal cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool parallel(const Line &a, const Line &b) {\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool orthogonal(const Line &a, const Line &b) {\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nReal distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2) {\n  if(c1.r < c2.r) swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if(c1.r + c2.r < d) return 4;\n  if(eq(c1.r + c2.r, d)) return 3;\n  if(c1.r - c2.r < d) return 2;\n  if(eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\n\nReal distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\nReal distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nReal distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\nReal distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m) {\n  return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if(eq(distance(l, c.p), c.r)) return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\npair< Point, Point > tangent(const Circle &c1, const Point &p2) {\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\nLines tangent(Circle c1, Circle c2) {\n  Lines ret;\n  if(c1.r < c2.r) swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if(eq(g, 0)) return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for(int s : {-1, 1}) {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if(eq(1 - h * h, 0)) {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    } else if(1 - h * h > 0) {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\nenum {\n  OUT, ON, IN\n};\n\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvoid merge_segments(vector< Segment > &segs) {\n\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return true;\n  };\n\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\nPolygon convex_cut(const Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\nReal area2(const Polygon &p) {\n  Real A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H\nReal area2(const Polygon &p, const Circle &c) {\n  if(p.size() < 3) return 0.0;\n  function< Real(Circle, Point, Point) > cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n    Point va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0.0;\n    if(eq(f, 0.0)) return ret;\n    if(max(abs(va), abs(vb)) < c.r + EPS) return f;\n    if(distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));\n    auto u = crosspoint(c, Segment(a, b));\n    vector< Point > tot{a, u.first, u.second, b};\n    for(int i = 0; i + 1 < tot.size(); i++) {\n      ret += cross_area(c, tot[i], tot[i + 1]);\n    }\n    return ret;\n  };\n  Real A = 0;\n  for(int i = 0; i < p.size(); i++) {\n    A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\nReal convex_diameter(const Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  Real maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\nReal closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  sort(begin(ps), end(ps));\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n  const Real INF = 1e18;\n\n  function< Real(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return INF;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\n\nint main() {\n  int N, R;\n  cin >> N >> R;\n  Polygon ps(N);\n\n  double ret = 0.0;\n  auto check = [&](double x) {\n    double vv = 0.0;\n    double low = 1e9, high = -1e9;\n    Line l = Line(Point(x, 0), Point(x, 1));\n    for(int i = 0; i < N; i++) {\n      if(intersect(l, Segment(ps[i], ps[(i + 1) % N]))) {\n        auto point = crosspoint(l, Segment(ps[i], ps[(i + 1) % N]));\n        low = min(low, imag(point));\n        high = max(high, imag(point));\n      }\n    }\n\n    for(int i = 0; i < 300; i++) {\n      double left = (low * 2 + high) / 3;\n      double right = (low + high * 2) / 3;\n\n      auto A = area2(ps, Circle(Point(x, left), R));\n      auto B = area2(ps, Circle(Point(x, right), R));\n      vv = max(vv, max(A, B));\n      if(A < B) low = left;\n      else high = right;\n    }\n    ret = max(ret, vv);\n    return (vv);\n  };\n\n\n  double low = 1e9, high = -1e9;\n  for(int i = 0; i < N; i++) {\n    cin >> ps[i];\n    low = min(low, real(ps[i]));\n    high = max(high, real(ps[i]));\n  }\n\n  for(int i = 0; i < 300; i++) {\n    double left = (low * 2 + high) / 3;\n    double right = (low + high * 2) / 3;\n    if(check(left) < check(right)) low = left;\n    else high = right;\n  }\n  cout << fixed << setprecision(10) << ret * 0.5 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1000\n#define linf 1e18\n#define eps (1e-12)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n  double getArea(){ return r*r*pi;}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Point p,Circle c){ return abs(p-c.c)-c.r<-eps;}\nbool on(Point p,Circle c){ return fabs(abs(p-c.c)-c.r)<eps;}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\ndouble getArea(Polygon p){\n  double res=0;\n  for(int i=1;i<p.size()-1;i++)res+=cross(p[i]-p[0],p[i+1]-p[0])/2.0;\n  return res;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nbool iscrossLC(Line l,Circle c){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  if(!iscrossLC(s,c))return res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(abs(pp.s-s.p1)-abs(pp.f-s.p1)<eps)swap(pp.f,pp.s);\n  if(ccw(s.p1,s.p2,pp.f)==0)res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0)res.push_back(pp.s);\n  return res;\n}\n\nbool AllIn(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceLP(L,c.c)-c.r<-eps || ccw(L.p1,L.p2,c.c)==-1)return false;\n  }\n  return true;\n}\n\nbool AllOut(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  if(cross(a,b)<-eps)r=360.0-r;\n  return r;\n}\n\ndouble getCommonAreaTC(Polygon p,Circle c){\n  double res=getArea(p),carea=c.getArea();\n  int n=p.size();\n  /*\n  bool flag=false;\n  if(res<0.0){\n    flag=true;\n    reverse(p.begin(),p.end());\n    res=getArea(p);\n  }*/\n  vector<Point> s;\n  if(AllIn(p,c))return carea;\n  if(AllOut(p,c)) return 0.0;\n  int start=-1;\n  for(int i=0;i<n;i++){\n    if((c.r-abs(p[i]-c.c))<-eps)start=i;\n  }\n  if(start==-1)return res;\n  for(int i=0;i<n;i++){\n    vector<Point> vp=getCrossPointSC(c,Segment(p[(i+start)%n],\n\t\t\t\t\t       p[(i+1+start)%n]));    \n    for(int j=0;j<vp.size();j++){\n      bool b=true;\n      for(int k=0;k<s.size();k++)if(s[k]==vp[j])b=false;\n      if(b)s.push_back(vp[j]);\n    }\n  }\n\n  s.push_back(s[0]);\n  s.erase(s.begin());\n\n  for(int i=0;i<s.size();i+=2){\n    Point p1=s[i];\n    Point p2=s[i+1];\n    if(p1==p2)continue;\n    Polygon t;\n    t.push_back(p1);\n    t.push_back(p2);\n    t.push_back(c.c);\n    double narea= getArea(convex_cut(p,Line(p2,p1)));\n    if(narea<eps)continue;\n    res-=narea;\n    double ra=getAngle(p1-c.c,p2-c.c);\n    res+=((carea*ra/360.0)-getArea(t));\n  }\n  //if(!flag)return res;\n  return res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++){\n    Polygon t;\n    t.push_back(p[0]);\n    t.push_back(p[i]);\n    t.push_back(p[i+1]);\n    res+=getCommonAreaTC(t,c);\n  }\n  return res;\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,60){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*L,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=inf;\n    FOR(k,0,60){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cout if (1) cout\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pii;\n#define pb push_back\n\n// area de calota na altura h : 2.pi.R.h\n// volume de calota na altura h : pi.h/6 * (3r^2 + h^2)\n\n// XXX marks risky behaviour and TODO marks untested functions\ntypedef double cood; cood eps = 1e-8; cood inf = 1./0.;\nconst double pi = acos(-1.);\ninline ll sq (ll x) { return x*x; }\ninline double sq (double x) { return x*x; }\nstruct vec { // vector\n\tcood x, y;\n\tvec () : x(0), y(0) {} vec (cood a, cood b) : x(a), y(b) {}\n\tinline vec operator - (vec o) { return vec(x - o.x, y - o.y); }\n\tinline vec operator + (vec o) { return vec(x + o.x, y + o.y); }\n\tinline vec operator * (cood o) { return vec(x * o, y * o); }\n\tinline vec operator / (cood o) { return vec(x / o, y / o); }\n\tinline cood operator ^ (vec o) { return x * o.y - y * o.x; }\n\tinline cood operator * (vec o) { return x * o.x + y * o.y; }\n\n\tinline cood cross (vec a, vec b) { return ((*this)-a) ^ ((*this)-b); } // |(this)a|sen(angle)\n\tinline cood inner (vec a, vec b) { return ((*this)-a) * ((*this)-b); } // |(this)a|cos(angle)\n\tinline double angle (vec a, vec b) { return atan2(cross(a,b),inner(a,b)); } // ccw angle from (this)a to (this)b in range [-pi,pi]\n\tinline int ccw (vec a, vec b) { cood o = cross(a,b); return (eps < o) - (o < -eps); } // this is to the (1 left, 0 over, -1 right) of ab\n\tinline int dir (vec a, vec b) { cood o = inner(a,b); return (eps < o) - (o < -eps); } // a(this) is to the (1 same, 0 none, -1 opposite) direction of ab\n\tinline cood sq (vec o = vec()) { return inner(o,o); }\n\tinline double nr (vec o = vec()) { return sqrt(sq(o)); }\n\tinline vec proj (vec a, vec b) { return a + (b-a)*(a.inner((*this),b) / a.sq(b)); }\n\tinline vec rotate (double a) { return vec(cos(a) * x - sin(a) * y, sin(a) * x + cos(a) * y); } // ccw by a radians\n\tinline vec rot90 () { return vec(-y,x); } // rotate(pi/2)\n\n\tinline bool operator < (const vec & o) const { return (x != o.x)?(x < o.x):(y > o.y); } // lex compare (inc x, dec y)\n\t// full ccw angle from compare beginning upwards (this+(0,1)) around (*this)\n\t// incresing distance on ties\n\tbool compare (vec a, vec b) { \n\t\tif ((a < (*this)) != (b < (*this))) return a < (*this);\n\t\tint o = ccw(a,b); if (o) return o > 0;\n\t\treturn a.dir((*this),b) < 0;\n\t}\n\n\tbool in_seg (vec a, vec b) { return ccw(a,b) == 0 && dir(a,b) <= 0; } // tips included\n\tdouble dist2_lin (vec a, vec b) { return double(::sq(cross(a,b)))/a.sq(b); } // see cir.has_inter_lin\n\tdouble dist2_seg (vec a, vec b) { return a.dir((*this),b) == (b.dir((*this),a)) ? dist2_lin(a,b) : min(sq(a),sq(b)); }\n};\nstruct lin { // line\n\tcood a, b, c; // a*x + b*y = c\n\tlin () {} lin (cood x, cood y, cood z) : a(x), b(y), c(z) {}\n\tlin (vec s, vec t) : a(t.y - s.y), b(s.x - t.x), c(a * s.x + b * s.y) {}\n\tinline lin parll (vec p) { return lin{a, b, a*p.x + b * p.y}; }\n\tinline lin perp () { return lin{-b, a, c}; }\n\tvec inter (lin o) {\n\t\tcood d = a * o.b - o.a * b;\n\t\tif (-eps <= d && d <= eps) throw 1; // parallel\n\t\treturn vec((o.b * c - b * o.c) / d, (a * o.c - o.a * c) / d);\n\t}\n\tbool contains (vec v) { return abs(a*v.x + b*v.y - c) <= eps; }\n\tvec at_x (cood x) { return vec(x,(c-a*x)/b); }\n\tvec at_y (cood y) { return vec((c-b*y)/a,y); }\n};\nstruct cir { // circle\n\tvec c; cood r;\n\tcir () {} cir (vec v, cood d) : c(v), r(d) {}\n\tcir (vec u, vec v, vec w) {\n\t\tvec mv = (u+v)/2; lin s(mv, mv+(v-u).rot90());\n\t\tvec mw = (u+w)/2; lin t(mw, mw+(w-u).rot90());\n\t\tc = s.inter(t); r = c.nr(u);\n\t}\n\tinline bool contains (vec w) { return c.sq(w) <= sq(r) + eps; } // border included\n\tinline bool has_inter (cir o) { return c.sq(o.c) <= sq(r + o.r) + eps; } // borders included\n\tinline bool has_border_inter (cir o) { return has_inter(o) && c.sq(o.c) + eps >= sq(r - o.r); }\n\tinline bool has_inter_lin (vec a, vec b) { return a.sq(b) <= eps ? contains(a) : sq(c.cross(a,b)) <= sq(r)*a.sq(b) + eps; } // borders included XXX overflow\n\tinline bool has_inter_seg (vec a, vec b) { return has_inter_lin(a,b) && (contains(a) || contains(b) || a.dir(c,b)*b.dir(c,a) != -1); } // borders and tips included XXX overflow\n\tinline double arc_area (vec a, vec b) { return c.angle(a,b)*r*r/2; } // smallest arc, ccw positive\n\tinline double arc_len (vec a, vec b) { return c.angle(a,b)*r; } // smallest arc, ccw positive\n\tpair<vec,vec> border_inter (cir o) {\n\t\tif (!has_border_inter(o)) throw 0;\n\t\tdouble a = (sq(r) + o.c.sq(c) - sq(o.r))/(2*o.c.nr(c));\n\t\tvec v = (o.c - c)/o.c.nr(c); vec m = c + v * a;\n\t\tdouble h = sqrt(sq(r) - sq(a)); h = h!=h?0:h;\n\t\treturn pair<vec,vec>(m + v.rot90()*h, m - v.rot90()*h);\n\t}\n\tpair<vec,vec> border_inter_lin (vec a, vec b) { // first is closest to a than second\n\t\tif (a.dir(b,c) == -1) swap(a,b);\n\t\tif (!has_inter_lin(a,b)) throw 0;\n\t\tdouble d2 = c.dist2_lin(a,b); vec p = (b-a)/a.nr(b);\n\t\tdouble h = sqrt(r*r - d2); h = h!=h?0:h; \n\t\tdouble y = sqrt(c.sq(a) - d2); y = y!=y?0:y;\n\t\treturn pair<vec,vec>(a + p*(y-h), a + p*(y+h));\n\t}\n\tdouble triang_inter (vec a, vec b) { // ccw oriented, this with (c,a,b)\n\t\tif (c.sq(a) > c.sq(b)) return -triang_inter(b,a);\n\t\tif (contains(b)) return c.cross(a,b)/2;\n\t\tif (!has_inter_seg(a,b)) return arc_area(a,b);\n\t\tpair<vec,vec> itr = border_inter_lin(b,a); // order important\n\t\tif (contains(a)) return c.cross(a,itr.first)/2 + arc_area(itr.first,b);\n\t\treturn arc_area(a,itr.second) + c.cross(itr.second,itr.first)/2 + arc_area(itr.first,b);\n\t}\n};\nbool inter_seg (vec a, vec b, vec c, vec d) {\n\tif (a.in_seg(c, d) || b.in_seg(c, d) || c.in_seg(a, b) || d.in_seg(a, b)) return true;\n\treturn (c.ccw(a, b) * d.ccw(a, b) == -1 && a.ccw(c, d) * b.ccw(c, d) == -1);\n}\ndouble dist2_seg (vec a, vec b, vec c, vec d){return inter_seg(a,b,c,d)?0.:min({ a.dist2_seg(c,d), b.dist2_seg(c,d), c.dist2_seg(a,b), d.dist2_seg(a,b) });} // TODO\nostream& operator<<(ostream& os, vec o) { return os << '(' << o.x << \", \" << o.y << ')'; }\nostream& operator<<(ostream& os, lin o) { return os << '[' << o.a << \"x + \" << o.b << \"y = \" << o.c << ']'; }\nostream& operator<<(ostream& os, cir o) { return os << '[' << o.c << o.r << ']'; }\n\ndouble polygon_inter (vector<vec> & p, cir c) { // signed area\n\treturn inner_product(p.begin(), p.end()-1, p.begin()+1, c.triang_inter(*p.rbegin(),*p.begin()), std::plus<double>(), [&c] (vec a, vec b) { return c.triang_inter(a,b); });\n}\n\nconst int N = 13;\n\nint n;\nll r;\nvector<vec> v(N);\n\ndouble solve (double y) {\n\tdouble lo = 100, hi = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (abs(v[i].y - v[i+1].y) <= eps) {\n\t\t\tif (abs(v[i].y - y) <= eps) {\n\t\t\t\tlo = min(lo, v[i].x);\n\t\t\t\tlo = min(lo, v[i+1].x);\n\t\t\t\thi = max(hi, v[i].x);\n\t\t\t\thi = max(hi, v[i+1].x);\n\t\t\t}\n\t\t} else if (min(v[i].y,v[i+1].y) - eps <= y && y <= max(v[i].y,v[i+1].y) + eps) {\n\t\t\tdouble x = lin(v[i],v[i+1]).at_y(y).x;\n\t\t\tlo = min(lo, x);\n\t\t\thi = max(hi, x);\n\t\t}\n\t}\n\tif (lo > hi) return 0;\n\n\tint ts = 70;\n\twhile (ts--) {\n\t\tdouble q1 = (lo + lo + hi)/3;\n\t\tdouble q2 = (lo + hi + hi)/3;\n\t\tif (abs(polygon_inter(v, cir(vec(q1,y),r))) > abs(polygon_inter(v, cir(vec(q2,y),r))))\n\t\t\thi = q2;\n\t\telse\n\t\t\tlo = q1;\n\t}\n\t\n\t//cout << lo << \" \" << y << \" : \" << abs(polygon_inter(v, cir(vec(lo,y),r))) << endl;\n\treturn abs(polygon_inter(v, cir(vec(lo,y),r)));\n}\n\nint main () {\n\twhile (scanf(\"%d %lld\", &n, &r) != EOF) {\n\t\tdouble lo = 100, hi = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%lf %lf\", &v[i].x, &v[i].y);\n\t\t\tlo = min(lo, v[i].y);\n\t\t\thi = max(hi, v[i].y);\n\t\t}\n\t\tv[n] = v[0];\n\n\t\tint ts = 80;\n\t\twhile (ts--) {\n\t\t\tdouble q1 = (lo + lo + hi)/3;\n\t\t\tdouble q2 = (lo + hi + hi)/3;\n\n\t\t\tif (solve(q1) < solve(q2))\n\t\t\t\tlo = q1;\n\t\t\telse\n\t\t\t\thi = q2;\n\t\t}\n\t\t\n\t\tprintf(\"%.6f\\n\", solve(lo));\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 400\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n  double getArea(){ return r*r*pi;}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Point p,Circle c){ return abs(p-c.c)-c.r<-eps;}\nbool on(Point p,Circle c){ return fabs(abs(p-c.c)-c.r)<eps;}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\ndouble getArea(Polygon p){\n  double res=0;\n  for(int i=1;i<p.size()-1;i++)res+=cross(p[i]-p[0],p[i+1]-p[0])/2.0;\n  return res;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nbool iscrossLC(Line l,Circle c){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  if(!iscrossLC(s,c))return res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(abs(pp.s-s.p1)-abs(pp.f-s.p1)<eps)swap(pp.f,pp.s);\n  if(ccw(s.p1,s.p2,pp.f)==0)res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0)res.push_back(pp.s);\n  return res;\n}\n\nbool AllIn(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceLP(L,c.c)-c.r<-eps || ccw(L.p1,L.p2,c.c)==-1)return false;\n  }\n  return true;\n}\n\nbool AllOut(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\ndouble getCommonAreaTC(Polygon p,Circle c){\n  double res=getArea(p),carea=c.getArea();\n  int n=p.size();\n  bool flag=false;\n  if(res<0.0){\n    flag=true;\n    reverse(p.begin(),p.end());\n    res=getArea(p);\n  }\n  vector<Point> s;\n  if(AllIn(p,c))return carea;\n  if(AllOut(p,c)) return 0.0;\n  int start=-1;\n  for(int i=0;i<n;i++){\n    if((c.r-abs(p[i]-c.c))<-eps)start=i;\n  }\n  if(start==-1)return res;\n  for(int i=0;i<n;i++){\n    vector<Point> vp=getCrossPointSC(c,Segment(p[(i+start)%n],\n\t\t\t\t\t       p[(i+1+start)%n]));    \n    for(int j=0;j<vp.size();j++){\n      bool b=true;\n      for(int k=0;k<s.size();k++)if(s[k]==vp[j])b=false;\n      if(b)s.push_back(vp[j]);\n    }\n  }\n\n  s.push_back(s[0]);\n  s.erase(s.begin());\n\n  for(int i=0;i<s.size();i+=2){\n    Point p1=s[i];\n    Point p2=s[i+1];\n    if(p1==p2)continue;\n    Polygon t;\n    t.push_back(p1);\n    t.push_back(p2);\n    t.push_back(c.c);\n    double narea=getArea(convex_cut(p,Line(p2,p1)));\n    if(narea<eps)continue;\n    res-=narea;\n    double ra=acos(dot(p1-c.c,p2-c.c)/(abs(p1-c.c)*abs(p2-c.c)))*(360/(2*pi));\n    if(ccw(c.c,p1,p2)==-1)ra=180.0;\n    res+=((carea*ra/360.0)-getArea(t));\n  }\n  if(!flag)return res;\n  return -res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++){\n    Polygon t;\n    t.push_back(p[0]);\n    t.push_back(p[i]);\n    t.push_back(p[i+1]);\n    res+=getCommonAreaTC(t,c);\n  }\n  return res;\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,50){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*(m1-r),r));\n    double res2=getCommonAreaPC(p,Circle(a+v*(m2-r),r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*(L-r),r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=abs(b-a);\n    FOR(k,0,50){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//writted by dnvtmf\n#include <bits/stdc++.h>\n#define INF 1000000007\n#define FI first\n#define SE second\n#define PB push_back\n#define VI vector<int>\n#define MP make_pair\n#define FOR(x, st, ed) for(auto x = (st); x < (ed); ++x)\n#define FORE(x, st, ed) for(auto x = (st); x <= (ed); ++x)\n#define CLR(arr, val) memset(arr, val, sizeof(arr))\n#define INFO(tag, st, ed, x) printf(\"%s: \", tag); \\\n  FOR(_i, st, ed) cout << x[_i] << ' '; puts(\"\");\nusing namespace std;\ntypedef long long LL;\ntypedef pair <int, int> PII;\nconst int NUM = 100010;\n\nconst long double EPS = 1e-14;\ninline int sgn(long double x) {if (x < -EPS)return -1; return x > EPS ? 1 : 0;}\ninline long double sqr(long double x) {return x * x;}\nstruct Point {\n  long double x, y;\n  Point(long double _x = 0.0, long double _y = 0.0): x(_x), y(_y) {}\n  Point operator + (const Point &b)const {return Point(x + b.x, y + b.y);}//向量加法\n  Point operator - (const Point &b)const {return Point(x - b.x, y - b.y);}//向量?法\n  long double operator * (const Point &b)const {return x * b.x + y * b.y;}//向量点?\n  long double operator ^ (const Point &b)const {return x * b.y - y * b.x;} //向量叉?\n  Point operator * (long double b) {return Point(x * b, y * b);}//?量乘法\n  Point rot(long double ang) {return Point(x * cos(ang) - y * sin(ang), x * sin(ang) + y * cos(ang));}//旋?\n  long double norm() {return sqrt(x * x + y * y);}//向量的模\n};\n//直? ?段定?\n//直?方程：?点式：@$(x_2 - x_1)(y - y_1) = (y_2 - y_1)(x - x_1)$@\nstruct Line {\n  Point s, e;\n  //long double k;\n  Line() {}\n  Line(Point _s, Point _e) {\n    s = _s, e = _e;\n    //k = atan2(e.y - s.y, e.x - s.x);\n  }\n  //求?直?交点\n  //返回-1?直?重合, 0 相交, 1 平行\n  pair<int, Point> operator &(Line b) {\n    if (sgn((s - e) ^ (b.s - b.e)) == 0) {\n      if (sgn((s - b.e) ^ (b.s - b.e)) == 0) return make_pair(-1, s); //重合\n      else return make_pair(1, s);//平行\n    }\n    long double t = ((s - b.s) ^ (b.s - b.e)) / ((s - e) ^ (b.s - b.e));\n    return make_pair(0, Point(s.x + (e.x - s.x) * t, s.y + (e.y - s.y) * t));\n  }\n};\n//求向量vA与vB的?角(<= PI)\nlong double angle(Point vA, Point vB) {\n  long double tmp = vA.norm() * vB.norm();\n  //cout<<tmp<<endl;\n  if (sgn(tmp) != 0) return acos((vA * vB) / tmp);\n  else return 0.0;\n}\n\n//num表示?O(o, r)与?段(s, e)的交点数, res里存?的是交点\nvoid Circle_cross_Segment(Point s, Point e, Point o, long double r, Point res[], int &num) {\n  long double dx = e.x - s.x, dy = e.y - s.y;\n  long double A = dx * dx + dy * dy;\n  long double B = 2.0 * dx * (s.x - o.x) + 2.0 * dy * (s.y - o.y);\n  long double C = sqr(s.x - o.x) + sqr(s.y - o.y) - r * r;\n  long double delta = B * B - 4.0 * A * C;\n  num = 0;\n  //printf(\"%.10f\\n\",(double)delta);\n  if (sgn(delta) < 0) return ;\n  delta = sqrt(max((long double)0.0, delta));\n  long double k1 = (-B - delta) / (2.0 * A);\n  long double k2 = (-B + delta) / (2.0 * A);\n  if (sgn(k1 - 1.0) <= 0 && sgn(k1) >= 0) //?与?段相交条件判断\n    res[num++] = Point(s.x + k1 * dx, s.y + k1 * dy);\n  if (sgn(k2 - 1.0) <= 0 && sgn(k2) >= 0)\n    res[num++] = Point(s.x + k2 * dx, s.y + k2 * dy);\n}\n\n//三角形ABO与?(O, r)的面?交\nlong double Triangel_cross_Circle(Point a, Point b, Point o, long double r) {\n  long double r2 = r * r;\n  a = a - o;\n  b = b - o;\n  o = Point(0.0, 0.0);\n  if(sgn(a.x) == 0 && sgn(a.y) == 0) return 0.0;\n  if(sgn(b.x) == 0 && sgn(b.y) == 0) return 0.0;\n  bool bAInC = sgn((a * a) - r2) < 0;\n  bool bBInC = sgn((b * b) - r2) < 0;\n  long double sg = 0.5 * sgn(a ^ b), res = 0.0;\n  Point tmp[2];\n  int num;\n  if (bAInC && bBInC) res = abs(a ^ b);\n  else if (bAInC || bBInC) {\n    if (bBInC) swap(a, b);\n    Circle_cross_Segment(a, b, 0, r, tmp, num);\n    res = fabs(a ^ tmp[0]) + r2 * angle(tmp[0], b);\n    //cout<<res<<endl;\n  }\n  else {\n    Circle_cross_Segment(a, b, o, r, tmp, num);\n    res = r2 * angle(a, b);\n    if (num == 2) {\n      res -= r2 * angle(tmp[0], tmp[1]);\n      res += fabs(tmp[0] ^ tmp[1]);\n    }\n  }\n  //cout<<res<<endl;\n  return sg * res;\n}\n\n//多?形与?的面?交\nlong double Polygon_intersect_Circle(Point ploy[], int n, Point O, long double r) {\n  ploy[n] = ploy[0];\n  long double res = 0.0;\n  for (int i = 0; i < n; ++i)\n    res += Triangel_cross_Circle(ploy[i], ploy[i + 1], O, r);\n  return fabs(res);\n}\n\nint n, r;\nPoint ploy[20];\ninline void fRand(long double &xx,long double &yy,long double x,long double y) {\n    int dd = rand() % n;\n    long double ks = 1.0 * rand() / RAND_MAX;\n    xx = x + (ploy[dd].x - x) * ks;\n    yy = y + (ploy[dd].y - y) * ks;\n}\n\ninline long double Rand(){\n    return 1.0 * rand() / RAND_MAX;\n}\n\nclock_t tic;\nlong double get_time() {\n  return 1.0 * (clock() - tic) / CLOCKS_PER_SEC;\n}\nostringstream os;\nvoid solve() {\n  long double x = ploy[0].x, y = ploy[0].y, area = Polygon_intersect_Circle(ploy, n, {x, y}, 1.0 * r);\n  //cout<<area<<endl;\n  long double best = area, bx = 0.0, by = 0.0;\n  long double c = 10.0;\n  for (int k = 0; get_time() < 4.9 && k < 10; ++k, c *= 0.1) {\n    x = bx, y = by, area = best;\n    long double T = 100, T_decay = 0.95;\n    const int max_iter = 1000, chain_len = 300;\n    for (int i = 0; get_time() < 4.9 && i < max_iter; ++i, T *= T_decay) {\n      for (int j = 0; get_time() < 4.9 && j < chain_len; ++j) {\n        long double xx,yy;\n        fRand(xx,yy,x,y);\n        long double S = Polygon_intersect_Circle(ploy, n, {xx, yy}, r);\n        long double deltaS = S - area;\n        if (deltaS > 0 || exp(deltaS * T) < Rand()) {\n          x = xx;\n          y = yy;\n          area = S;\n          if (area > best) {\n            //printf(\"%.10f\\n\",(double)area);\n            best = area;\n            bx = x;\n            by = y;\n            os<<x<<\" \"<<y<<endl;\n          }\n        }\n      }\n    }\n  }\n  //cout<<os.str()<<endl;\n  printf(\"%.10f\\n\", (double)best);\n}\nint main() {\n#ifdef ACM_TEST\n  freopen(\"in.txt\", \"r\", stdin);\n#endif\n  tic = clock();\n  srand(time(0));\n  scanf(\"%d%d\", &n, &r);\n  for (int i = 0, x, y; i < n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    ploy[i] = Point(x, y);\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  double maxi = 0;\n  rep(j,n) {\n    Point mp = poly[j];\n    double rate = 10.0;\n    double eps = 1e-10;\n    while( LT(eps,rate) ) {\n      rep(_,70) {\n\n\tdouble max_area = -1; \n\tPoint np;\n\trep(i,n) {\n\t  Point tp = mp;\n\t  tp.x += ( poly[i].x - mp.x ) * rate;\n\t  tp.y += ( poly[i].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,tp,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t    np = tp;\n\t  }\n\t}\n\tif( !equals(max_area,-1) ) {\n\t  mp = np;\n\t  if( LT(maxi,max_area) ) maxi = max_area;\n\t}\n      \n      }\n      rate *= 0.5;\n    }\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 400\n#define linf 1e18\n#define eps (1e-9)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Circle c,Point p){\n  if(abs(c.c-p)-c.r<-eps)return true;\n  return false;\n}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nbool intersect(Circle c,Segment s){\n  if(getDistanceSP(s,c.c)-c.r<-eps)return true;\n  return false;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  return acos(tmp)*180.0/pi;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nPoint getCrossPointSC(Circle c,Segment s){\n  Point res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(ccw(s.p1,s.p2,pp.f)==0){\n    res=pp.f;\n    if(ccw(s.p1,s.p2,pp.s)==0 && abs(s.p1-pp.s)<abs(s.p1-pp.f))res=pp.s;\n  }\n  else res=pp.s;\n  return res;\n}\n\ndouble getCommonAreaTC(Point a,Point b,Circle c){\n  double res=abs(cross(a-c.c,b-c.c)/2.0);\n  if(equals(0.0,res))return 0.0;\n  if(in(c,a) && !in(c,b)){\n    Point p1=getCrossPointSC(c,Segment(b,a));\n    Point p2=getCrossPointSC(c,Segment(b,c.c)); \n    res+=(c.r*c.r*pi)*(getAngle(p1-c.c,p2-c.c)/360.0);\n    res-=abs(cross(p1-c.c,p2-c.c)/2.0);\n    res-=abs(cross(p2-b,p1-b)/2.0);\n  }\n  else if(!in(c,a) && in(c,b)){\n    Point p1=getCrossPointSC(c,Segment(a,c.c));\n    Point p2=getCrossPointSC(c,Segment(a,b));\n    res+=(c.r*c.r*pi)*(getAngle(p1-c.c,p2-c.c)/360.0);\n    res-=abs(cross(p1-c.c,p2-c.c)/2.0);\n    res-=abs(cross(p2-a,p1-a)/2.0);\n  }\n  else if(!in(c,a) && !in(c,b)){\n    if(intersect(c,Segment(a,b))){\n      pair<Point,Point> pp=getCrossPoints(c,Segment(a,b));\n      Point m=pp.f+(pp.s-pp.f)/2.0;\n      res=abs(getCommonAreaTC(a,m,c))+abs(getCommonAreaTC(m,b,c));\n    }\n    else res=(c.r*c.r*pi)*(getAngle(a-c.c,b-c.c)/360.0);\n  }\n  if(cross(a-c.c,b-c.c)<0.0)res=-res;\n  return res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  int n=p.size();\n  FOR(i,0,n)res+=getCommonAreaTC(p[i],p[(i+1)%n],c);\n  return abs(res);\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,50){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res2-res1<-eps)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*R,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=abs(b-a);\n    FOR(k,0,50){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res2-res1<-eps)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*R));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing Real = double;\nusing Point = complex< Real >;\nconst Real EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(Real a, Real b) { return fabs(b - a) < EPS; }\n\nPoint operator*(const Point &p, const Real &d) {\n  return Point(real(p) * d, imag(p) * d);\n}\n\nistream &operator>>(istream &is, Point &p) {\n  Real a, b;\n  is >> a >> b;\n  p = Point(a, b);\n  return is;\n}\n\nostream &operator<<(ostream &os, Point &p) {\n  os << fixed << setprecision(10) << p.real() << \" \" << p.imag();\n}\n\nPoint rotate(Real theta, const Point &p) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nReal radian_to_degree(Real r) {\n  return (r * 180.0 / PI);\n}\n\nReal degree_to_radian(Real d) {\n  return (d * PI / 180.0);\n}\n\nReal get_angle(const Point &a, const Point &b, const Point &c) {\n  const Point v(b - a), w(c - b);\n  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());\n  if(alpha > beta) swap(alpha, beta);\n  Real theta = (beta - alpha);\n  return min(theta, 2 * acos(-1) - theta);\n}\n\nnamespace std {\n  bool operator<(const Point &a, const Point &b) {\n    return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n  }\n}\n\n\nstruct Line {\n  Point a, b;\n\n  Line() = default;\n\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  Line(Real A, Real B, Real C) // Ax + By = C\n  {\n    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);\n    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);\n    else a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream &operator<<(ostream &os, Line &p) {\n    return os << p.a << \" to \" << p.b;\n  }\n\n  friend istream &operator>>(istream &is, Line &a) {\n    return is >> a.a >> a.b;\n  }\n};\n\nstruct Segment : Line {\n  Segment() = default;\n\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  Real r;\n\n  Circle() = default;\n\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector< Point >;\nusing Polygon = vector< Point >;\nusing Segments = vector< Segment >;\nusing Lines = vector< Line >;\nusing Circles = vector< Circle >;\n\nReal cross(const Point &a, const Point &b) {\n  return real(a) * imag(b) - imag(a) * real(b);\n}\n\nReal dot(const Point &a, const Point &b) {\n  return real(a) * real(b) + imag(a) * imag(b);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C\nint ccw(const Point &a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;  // \"COUNTER_CLOCKWISE\"\n  if(cross(b, c) < -EPS) return -1; // \"CLOCKWISE\"\n  if(dot(b, c) < 0) return +2;      // \"ONLINE_BACK\"\n  if(norm(b) < norm(c)) return -2;  // \"ONLINE_FRONT\"\n  return 0;                         // \"ON_SEGMENT\"\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool parallel(const Line &a, const Line &b) {\n  return eq(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A\nbool orthogonal(const Line &a, const Line &b) {\n  return eq(dot(a.a - a.b, b.a - b.b), 0.0);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A\nPoint projection(const Line &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment &l, const Point &p) {\n  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B\nPoint reflection(const Line &l, const Point &p) {\n  return p + (projection(l, p) - p) * 2.0;\n}\n\nbool intersect(const Line &l, const Point &p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersect(const Line &l, const Line &m) {\n  return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n}\n\nbool intersect(const Segment &s, const Point &p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersect(const Line &l, const Segment &s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nReal distance(const Line &l, const Point &p);\n\nbool intersect(const Circle &c, const Line &l) {\n  return distance(l, c.p) <= c.r + EPS;\n}\n\nbool intersect(const Circle &c, const Point &p) {\n  return abs(abs(p - c.p) - c.r) < EPS;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B\nbool intersect(const Segment &s, const Segment &t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nint intersect(const Circle &c, const Segment &l) {\n  if(norm(projection(l, c.p) - c.p) - c.r * c.r > EPS) return 0;\n  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);\n  if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n  if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n  const Point h = projection(l, c.p);\n  if(dot(l.a - h, l.b - h) < 0) return 2;\n  return 0;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\nint intersect(Circle c1, Circle c2) {\n  if(c1.r < c2.r) swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if(c1.r + c2.r < d) return 4;\n  if(eq(c1.r + c2.r, d)) return 3;\n  if(c1.r - c2.r < d) return 2;\n  if(eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\n\nReal distance(const Point &a, const Point &b) {\n  return abs(a - b);\n}\n\nReal distance(const Line &l, const Point &p) {\n  return abs(p - projection(l, p));\n}\n\nReal distance(const Line &l, const Line &m) {\n  return intersect(l, m) ? 0 : distance(l, m.a);\n}\n\nReal distance(const Segment &s, const Point &p) {\n  Point r = projection(s, p);\n  if(intersect(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D\nReal distance(const Segment &a, const Segment &b) {\n  if(intersect(a, b)) return 0;\n  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});\n}\n\nReal distance(const Line &l, const Segment &s) {\n  if(intersect(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nPoint crosspoint(const Line &l, const Line &m) {\n  Real A = cross(l.b - l.a, m.b - m.a);\n  Real B = cross(l.b - l.a, l.b - m.a);\n  if(eq(abs(A), 0.0) && eq(abs(B), 0.0)) return m.a;\n  return m.a + (m.b - m.a) * B / A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C\nPoint crosspoint(const Segment &l, const Segment &m) {\n  return crosspoint(Line(l), Line(m));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D\npair< Point, Point > crosspoint(const Circle &c, const Line l) {\n  Point pr = projection(l, c.p);\n  Point e = (l.b - l.a) / abs(l.b - l.a);\n  if(eq(distance(l, c.p), c.r)) return {pr, pr};\n  double base = sqrt(c.r * c.r - norm(pr - c.p));\n  return {pr - e * base, pr + e * base};\n}\n\npair< Point, Point > crosspoint(const Circle &c, const Segment &l) {\n  Line aa = Line(l.a, l.b);\n  if(intersect(c, l) == 2) return crosspoint(c, aa);\n  auto ret = crosspoint(c, aa);\n  if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n  else ret.first = ret.second;\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E\npair< Point, Point > crosspoint(const Circle &c1, const Circle &c2) {\n  Real d = abs(c1.p - c2.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());\n  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);\n  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);\n  return {p1, p2};\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F\npair< Point, Point > tangent(const Circle &c1, const Point &p2) {\n  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G\nLines tangent(Circle c1, Circle c2) {\n  Lines ret;\n  if(c1.r < c2.r) swap(c1, c2);\n  Real g = norm(c1.p - c2.p);\n  if(eq(g, 0)) return ret;\n  Point u = (c2.p - c1.p) / sqrt(g);\n  Point v = rotate(PI * 0.5, u);\n  for(int s : {-1, 1}) {\n    Real h = (c1.r + s * c2.r) / sqrt(g);\n    if(eq(1 - h * h, 0)) {\n      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);\n    } else if(1 - h * h > 0) {\n      Point uu = u * h, vv = v * sqrt(1 - h * h);\n      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);\n      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);\n    }\n  }\n  return ret;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B\nbool is_convex(const Polygon &p) {\n  int n = (int) p.size();\n  for(int i = 0; i < n; i++) {\n    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;\n  }\n  return true;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A\nPolygon convex_hull(Polygon &p) {\n  int n = (int) p.size(), k = 0;\n  if(n <= 2) return p;\n  sort(p.begin(), p.end());\n  vector< Point > ch(2 * n);\n  for(int i = 0; i < n; ch[k++] = p[i++]) {\n    while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n    while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n  }\n  ch.resize(k - 1);\n  return ch;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\nenum {\n  OUT, ON, IN\n};\n\nint contains(const Polygon &Q, const Point &p) {\n  bool in = false;\n  for(int i = 0; i < Q.size(); i++) {\n    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;\n    if(a.imag() > b.imag()) swap(a, b);\n    if(a.imag() <= 0 && 0 < b.imag() && cross(a, b) < 0) in = !in;\n    if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n  }\n  return in ? IN : OUT;\n}\n\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvoid merge_segments(vector< Segment > &segs) {\n\n  auto merge_if_able = [](Segment &s1, const Segment &s2) {\n    if(abs(cross(s1.b - s1.a, s2.b - s2.a)) > EPS) return false;\n    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;\n    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;\n    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));\n    return true;\n  };\n\n  for(int i = 0; i < segs.size(); i++) {\n    if(segs[i].b < segs[i].a) swap(segs[i].a, segs[i].b);\n  }\n  for(int i = 0; i < segs.size(); i++) {\n    for(int j = i + 1; j < segs.size(); j++) {\n      if(merge_if_able(segs[i], segs[j])) {\n        segs[j--] = segs.back(), segs.pop_back();\n      }\n    }\n  }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033\nvector< vector< int > > segment_arrangement(vector< Segment > &segs, vector< Point > &ps) {\n  vector< vector< int > > g;\n  int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(intersect(segs[i], segs[j])) {\n        ps.emplace_back(crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\nPolygon convex_cut(const Polygon &U, Line l) {\n  Polygon ret;\n  for(int i = 0; i < U.size(); i++) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n      ret.push_back(crosspoint(Line(now, nxt), l));\n    }\n  }\n  return (ret);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A\nReal area2(const Polygon &p) {\n  Real A = 0;\n  for(int i = 0; i < p.size(); ++i) {\n    A += cross(p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H\nReal area2(const Polygon &p, const Circle &c) {\n  if(p.size() < 3) return 0.0;\n  function< Real(Circle, Point, Point) > cross_area = [&](const Circle &c, const Point &a, const Point &b) {\n    Point va = c.p - a, vb = c.p - b;\n    Real f = cross(va, vb), ret = 0.0;\n    if(eq(f, 0.0)) return ret;\n    if(max(abs(va), abs(vb)) < c.r + EPS) return f;\n    if(distance(Segment(a, b), c.p) > c.r - EPS) return c.r * c.r * arg(vb * conj(va));\n    auto u = crosspoint(c, Segment(a, b));\n    vector< Point > tot{a, u.first, u.second, b};\n    for(int i = 0; i + 1 < tot.size(); i++) {\n      ret += cross_area(c, tot[i], tot[i + 1]);\n    }\n    return ret;\n  };\n  Real A = 0;\n  for(int i = 0; i < p.size(); i++) {\n    A += cross_area(c, p[i], p[(i + 1) % p.size()]);\n  }\n  return A;\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B\nReal convex_diameter(const Polygon &p) {\n  int N = (int) p.size();\n  int is = 0, js = 0;\n  for(int i = 1; i < N; i++) {\n    if(p[i].imag() > p[is].imag()) is = i;\n    if(p[i].imag() < p[js].imag()) js = i;\n  }\n  Real maxdis = norm(p[is] - p[js]);\n\n  int maxi, maxj, i, j;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) >= 0) {\n      j = (j + 1) % N;\n    } else {\n      i = (i + 1) % N;\n    }\n    if(norm(p[i] - p[j]) > maxdis) {\n      maxdis = norm(p[i] - p[j]);\n      maxi = i;\n      maxj = j;\n    }\n  } while(i != is || j != js);\n  return sqrt(maxdis);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A\nReal closest_pair(Points ps) {\n  if(ps.size() <= 1) throw (0);\n  sort(begin(ps), end(ps));\n\n  auto compare_y = [&](const Point &a, const Point &b) {\n    return imag(a) < imag(b);\n  };\n  vector< Point > beet(ps.size());\n  const Real INF = 1e18;\n\n  function< Real(int, int) > rec = [&](int left, int right) {\n    if(right - left <= 1) return INF;\n    int mid = (left + right) >> 1;\n    auto x = real(ps[mid]);\n    auto ret = min(rec(left, mid), rec(mid, right));\n    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);\n    int ptr = 0;\n    for(int i = left; i < right; i++) {\n      if(abs(real(ps[i]) - x) >= ret) continue;\n      for(int j = 0; j < ptr; j++) {\n        auto luz = ps[i] - beet[ptr - j - 1];\n        if(imag(luz) >= ret) break;\n        ret = min(ret, abs(luz));\n      }\n      beet[ptr++] = ps[i];\n    }\n    return ret;\n  };\n  return rec(0, (int) ps.size());\n}\n\n\nint main() {\n  int N, R;\n  cin >> N >> R;\n  Polygon ps(N);\n\n  double ret = 0.0;\n  auto check = [&](double x) {\n    double vv = 0.0;\n    double low = 1e9, high = -1e9;\n    Line l = Line(Point(x, 0), Point(x, 1));\n    for(int i = 0; i < N; i++) {\n      if(intersect(l, Segment(ps[i], ps[(i + 1) % N]))) {\n        auto point = crosspoint(l, Segment(ps[i], ps[(i + 1) % N]));\n        low = min(low, imag(point));\n        high = max(high, imag(point));\n      }\n    }\n\n    for(int i = 0; i < 100; i++) {\n      double left = (low * 2 + high) / 3;\n      double right = (low + high * 2) / 3;\n\n      auto A = area2(ps, Circle(Point(x, left), R));\n      auto B = area2(ps, Circle(Point(x, right), R));\n      vv = max(vv, max(A, B));\n      if(A < B) low = left;\n      else high = right;\n    }\n    ret = max(ret, vv);\n    return (vv);\n  };\n\n\n  double low = 1e9, high = -1e9;\n  for(int i = 0; i < N; i++) {\n    cin >> ps[i];\n    low = min(low, real(ps[i]));\n    high = max(high, real(ps[i]));\n  }\n\n  for(int i = 0; i < 100; i++) {\n    double left = (low * 2 + high) / 3;\n    double right = (low + high * 2) / 3;\n    if(check(left) < check(right)) low = left;\n    else high = right;\n  }\n  cout << fixed << setprecision(10) << ret * 0.5 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1000\n#define linf 1e18\n#define eps (1e-11)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n  double getArea(){ return r*r*pi;}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\ndouble arg(Vector p){ return atan2(p.y,p.x);}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\ndouble getArea(Polygon p){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++)res+=cross(p[i]-p[0],p[i+1]-p[0])/2.0;\n  return res;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0.0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nbool iscrossLC(Line l,Circle c){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  if(!iscrossLC(s,c))return res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(ccw(s.p1,s.p2,pp.f)==0)res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0)res.push_back(pp.s);\n  return res;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nvector<Point> arg_sort(vector<Point> vp,Point base){\n  vector<pair<double,Point> > tmp;\n  vector<Point> res;\n  for(int i=0;i<vp.size();i++){\n    double targ=arg(vp[i]-base);\n    if(targ<0)targ+=2*pi;\n    tmp.push_back(mp(targ,vp[i]));\n  }\n  sort(tmp.begin(),tmp.end());\n  for(int i=0;i<tmp.size();i++)res.push_back(tmp[i].s);\n  return res;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  if(cross(a,b)<-eps)r=360.0-r;\n  return r;\n}\n\nbool AllIn(Polygon p,Circle c){\n  if(contains(p,c.c)!=2)return false;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\nbool AllOut(Polygon p,Circle c){\n  if(contains(p,c.c)!=0)return false;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\nvector<Point> unique(vector<Point> vp){\n  vector<Point> res;\n  if(vp.empty())return res;\n  sort(vp.begin(),vp.end());\n  res.push_back(vp[0]);\n  for(int i=1;i<vp.size();i++)\n    if(!(res.back()==vp[i]))res.push_back(vp[i]);\n  return res;\n}\n\ndouble getCommonAreaTC(Polygon p,Circle c){\n  double res=getArea(p);\n  int n=p.size();\n  vector<Point> s;\n  if(AllIn(p,c))return c.getArea();\n  if(AllOut(p,c))return 0.0;\n  for(int i=0;i<n;i++){\n    vector<Point> vp=getCrossPointSC(c,Segment(p[i],p[(i+1)%n]));\n    for(int j=0;j<vp.size();j++)s.push_back(vp[j]);\n  }\n\n  s=unique(s);\n  s=arg_sort(s,c.c); \n\n  for(int i=0;i<s.size();i++){\n    Point p1=s[i];\n    Point p2=s[(i+1)%s.size()];\n    double ra=getAngle(p1-c.c,p2-c.c);\n    if(contains(p,rotate(c.c,p1,ra/2.0))==0)continue;\n    Polygon t;\n    t.push_back(p1);\n    t.push_back(p2);\n    t.push_back(c.c);\n    res-=getArea(convex_cut(p,Line(p2,p1)));\n    res+=((c.getArea()*ra/360.0)-getArea(t));\n  }\n  return res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++){\n    Polygon t;\n    t.push_back(p[0]);\n    t.push_back(p[i]);\n    t.push_back(p[i+1]);\n    res+=getCommonAreaTC(t,c);\n  }\n  return res;\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,50){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*L,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=abs(b-a);\n    FOR(k,0,50){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 400\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n  double getArea(){ return r*r*pi;}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\ndouble arg(Vector p){ return atan2(p.y,p.x);}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\ndouble getArea(Polygon p){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++)res+=cross(p[i]-p[0],p[i+1]-p[0])/2.0;\n  return res;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0.0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nbool iscrossLC(Line l,Circle c){\n  if((getDistanceLP(l,c.c)-c.r)<eps)return true;\n  return false;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  if(!iscrossLC(s,c))return res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(ccw(s.p1,s.p2,pp.f)==0)res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0)res.push_back(pp.s);\n  return res;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nvector<Point> arg_sort(vector<Point> vp,Point base){\n  vector<pair<double,Point> > tmp;\n  vector<Point> res;\n  for(int i=0;i<vp.size();i++){\n    double targ=arg(vp[i]-base);\n    if(targ<0)targ+=2*pi;\n    tmp.push_back(mp(targ,vp[i]));\n  }\n  sort(tmp.begin(),tmp.end());\n  for(int i=0;i<tmp.size();i++)res.push_back(tmp[i].s);\n  return res;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  if(cross(a,b)<-eps)r=360.0-r;\n  return r;\n}\n\nbool AllIn(Polygon p,Circle c){\n  if(contains(p,c.c)!=2)return false;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\nbool AllOut(Polygon p,Circle c){\n  if(contains(p,c.c)!=0)return false;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\nvector<Point> unique(vector<Point> vp){\n  vector<Point> res;\n  if(vp.empty())return res;\n  sort(vp.begin(),vp.end());\n  res.push_back(vp[0]);\n  for(int i=1;i<vp.size();i++)\n    if(!(res.back()==vp[i]))res.push_back(vp[i]);\n  return res;\n}\n\ndouble getCommonAreaTC(Polygon p,Circle c){\n  double res=getArea(p);\n  int n=p.size();\n  vector<Point> s;\n  if(AllIn(p,c))return c.getArea();\n  if(AllOut(p,c))return 0.0;\n  for(int i=0;i<n;i++){\n    vector<Point> vp=getCrossPointSC(c,Segment(p[i],p[(i+1)%n]));\n    for(int j=0;j<vp.size();j++)s.push_back(vp[j]);\n  }\n\n  s=unique(s);\n  if(s.size()<=1)return res;\n  s=arg_sort(s,c.c); \n\n  for(int i=0;i<s.size();i++){\n    Point p1=s[i];\n    Point p2=s[(i+1)%s.size()];\n    double ra=getAngle(p1-c.c,p2-c.c);\n    if(contains(p,rotate(c.c,p1,ra/2.0))!=2)continue;\n    Polygon t;\n    t.push_back(p1);\n    t.push_back(p2);\n    t.push_back(c.c);\n    res-=getArea(convex_cut(p,Line(p2,p1)));\n    res+=((c.getArea()*ra/360.0)-getArea(t));\n  }\n  return res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++){\n    Polygon t;\n    t.push_back(p[0]);\n    t.push_back(p[i]);\n    t.push_back(p[i+1]);\n    res+=getCommonAreaTC(t,c);\n  }\n  return res;\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,40){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*L,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=abs(b-a);\n    FOR(k,0,40){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-9)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n\nPoint calc_ps(Polygon poly) {\n  poly = andrewScan(poly);\n  Point mp = poly[0];\n  double rate = 1; // 0.5???????????¨???\n  int max_pos;\n  double eps = 1e-10; // 1e-20???????????¨???\n  while( rate > eps ) {\n    rep(_,60){ // 70???????????¨???\n      max_pos = 0;\n      REP(j,1,(int)poly.size()) {\n        double dist1 = abs(mp-poly[max_pos]);\n        double dist2 = abs(mp-poly[j]);\n\tif( LT(dist1,dist2) ) max_pos = j;\n      }\n      mp.x += ( poly[max_pos].x - mp.x ) * rate;\n      mp.y += ( poly[max_pos].y - mp.y ) * rate;\n    }\n    rate *= 0.5;\n  }\n  return mp;\n}\n\nPoint getCentroidOfConvex(Polygon& poly){\n  double area = getArea(poly);\n  int V = poly.size();\n  assert( !equals(area,0.0) );\n  double x = 0, y = 0;\n  rep(i,(int)poly.size()) {\n    x += ( poly[i].x + poly[(i+1)%V].x ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n    y += ( poly[i].y + poly[(i+1)%V].y ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n  }\n  return Point(x/(6.0*area),y/(6.0*area));\n}\n\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  double maxi;\n  Point mp = calc_ps(poly);\n  maxi = getCommonAreaPolygonCircle(poly,mp,r);\n  double rate = 1.0;\n  double eps = 1e-10;\n  while( LT(eps,rate) ) {\n    rep(_,70) {\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      assert( !equals(max_area,-1) );\n      mp = np;\n      if( LT(maxi,max_area) ) maxi = max_area;\n    }\n    rate *= 0.5;\n  }\n  rep(__,1) {\n    Point mp = calc_ps(poly);\n    double rate = 1.0;\n    double eps = 1e-10;\n    while( LT(eps,rate) ) {\n      rep(_,70) {\n\tdouble max_area = -1; \n\tPoint np;\n\trep(i,n) {\n\t  Point tp = mp;\n\t  tp.x += ( poly[i].x - mp.x ) * rate;\n\t  tp.y += ( poly[i].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,tp,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t    np = tp;\n\t  }\n\t}\n\tif( rand() % 50 == 0 ) {\n\t  int v = rand() % n;\n\t  np.x = ( poly[v].x - mp.x ) * rate;\n\t  np.y = ( poly[v].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,np,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t  }\n\t}\n\tassert( !equals(max_area,-1) );\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      rate *= 0.5;\n    }\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  srand((unsigned int)time(NULL));\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  //cout << getArea(poly) << endl;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  Point mp = poly[0];\n  double maxi = 0;\n  double rate = 1.0;\n  double eps = 1e-10;\n  while( LT(eps,rate) ) {\n    rep(_,70) {\n\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      if( !equals(max_area,-1) ) {\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      \n    }\n    rate *= 0.5;\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1000\n#define linf 1e18\n#define eps (1e-5)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n  double getArea(){ return r*r*pi;}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\ndouble arg(Vector p){ return atan2(p.y,p.x);}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\ndouble getArea(Polygon p){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++)res+=cross(p[i]-p[0],p[i+1]-p[0])/2.0;\n  return res;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0.0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nbool iscrossLC(Line l,Circle c){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  if(!iscrossLC(s,c))return res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(ccw(s.p1,s.p2,pp.f)==0)res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0)res.push_back(pp.s);\n  return res;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nvector<Point> arg_sort(vector<Point> vp,Point base){\n  vector<pair<double,Point> > tmp;\n  vector<Point> res;\n  for(int i=0;i<vp.size();i++){\n    double targ=arg(vp[i]-base);\n    if(targ<0)targ+=2*pi;\n    tmp.push_back(mp(targ,vp[i]));\n  }\n  sort(tmp.begin(),tmp.end());\n  for(int i=0;i<tmp.size();i++)res.push_back(tmp[i].s);\n  return res;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  if(cross(a,b)<-eps)r=360.0-r;\n  return r;\n}\n\nbool AllIn(Polygon p,Circle c){\n  if(contains(p,c.c)!=2)return false;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\nbool AllOut(Polygon p,Circle c){\n  if(contains(p,c.c)!=0)return false;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\nvector<Point> unique(vector<Point> vp){\n  vector<Point> res;\n  if(vp.empty())return res;\n  sort(vp.begin(),vp.end());\n  res.push_back(vp[0]);\n  for(int i=1;i<vp.size();i++)\n    if(!(res.back()==vp[i]))res.push_back(vp[i]);\n  return res;\n}\n\ndouble getCommonAreaTC(Polygon p,Circle c){\n  double res=getArea(p);\n  int n=p.size();\n  vector<Point> s;\n  if(AllIn(p,c))return c.getArea();\n  if(AllOut(p,c))return 0.0;\n  for(int i=0;i<n;i++){\n    vector<Point> vp=getCrossPointSC(c,Segment(p[i],p[(i+1)%n]));\n    for(int j=0;j<vp.size();j++)s.push_back(vp[j]);\n  }\n\n  s=unique(s);\n  s=arg_sort(s,c.c); \n\n  for(int i=0;i<s.size();i++){\n    Point p1=s[i];\n    Point p2=s[(i+1)%s.size()];\n    double ra=getAngle(p1-c.c,p2-c.c);\n    if(contains(p,rotate(c.c,p1,ra/2.0))==0)continue;\n    Polygon t;\n    t.push_back(p1);\n    t.push_back(p2);\n    t.push_back(c.c);\n    res-=getArea(convex_cut(p,Line(p2,p1)));\n    res+=((c.getArea()*ra/360.0)-getArea(t));\n  }\n  return res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++){\n    Polygon t;\n    t.push_back(p[0]);\n    t.push_back(p[i]);\n    t.push_back(p[i+1]);\n    res+=getCommonAreaTC(t,c);\n  }\n  return res;\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,50){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*L,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=abs(b-a);\n    FOR(k,0,50){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 400\n#define linf 1e18\n#define eps (1e-9)\n#define mod 1000000007\n#define pi M_PI\n#define phi (1.0+sqrt(5))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Circle c,Point p){\n  if(abs(c.c-p)-c.r<-eps)return true;\n  return false;\n}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nbool intersect(Circle c,Segment s){\n  if(getDistanceSP(s,c.c)-c.r<-eps)return true;\n  return false;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  return acos(tmp)*180.0/pi;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nPoint getCrossPointSC(Circle c,Segment s){\n  Point res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(ccw(s.p1,s.p2,pp.f)==0){\n    res=pp.f;\n    if(ccw(s.p1,s.p2,pp.s)==0 && abs(s.p1-pp.s)<abs(s.p1-pp.f))res=pp.s;\n  }\n  else res=pp.s;\n  return res;\n}\n\ndouble getCommonAreaTC(Point a,Point b,Circle c){\n  double res=abs(cross(a-c.c,b-c.c)/2.0);\n  if(equals(0.0,res))return 0.0;\n  if(in(c,a) && !in(c,b)){\n    Point p1=getCrossPointSC(c,Segment(b,a));\n    Point p2=getCrossPointSC(c,Segment(b,c.c)); \n    res+=(c.r*c.r*pi)*(getAngle(p1-c.c,p2-c.c)/360.0);\n    res-=abs(cross(p1-c.c,p2-c.c)/2.0);\n    res-=abs(cross(p2-b,p1-b)/2.0);\n  }\n  else if(!in(c,a) && in(c,b)){\n    Point p1=getCrossPointSC(c,Segment(a,c.c));\n    Point p2=getCrossPointSC(c,Segment(a,b));\n    res+=(c.r*c.r*pi)*(getAngle(p1-c.c,p2-c.c)/360.0);\n    res-=abs(cross(p1-c.c,p2-c.c)/2.0);\n    res-=abs(cross(p2-a,p1-a)/2.0);\n  }\n  else if(!in(c,a) && !in(c,b)){\n    if(intersect(c,Segment(a,b))){\n      pair<Point,Point> pp=getCrossPoints(c,Segment(a,b));\n      Point m=pp.f+(pp.s-pp.f)/2.0;\n      res=abs(getCommonAreaTC(a,m,c))+abs(getCommonAreaTC(m,b,c));\n    }\n    else res=(c.r*c.r*pi)*(getAngle(a-c.c,b-c.c)/360.0);\n  }\n  if(cross(a-c.c,b-c.c)<0.0)res=-res;\n  return res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  int n=p.size();\n  FOR(i,0,n)res+=getCommonAreaTC(p[i],p[(i+1)%n],c);\n  return abs(res);\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,50){\n    double m1=(L*phi+R)/(1.0+phi);\n    double m2=(L+R*phi)/(1.0+phi);\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res2-res1<-eps)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*R,r));\n}\n\ndouble solve(){\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double res=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=inf*2;\n    FOR(k,0,50){\n      double m1=(L*phi+R)/(1.0+phi);\n      double m2=(L+R*phi)/(1.0+phi);\n      double res1=check(a+v*(m1-inf));\n      double res2=check(a+v*(m2-inf));\n      if(res2-res1<-eps)R=m2; \n      else L=m1;\n    }\n    res=max(res,check(a+v*(R-inf)));\n  }\n  return res;\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  pd(solve());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  Point mp = poly[0];\n  double maxi = 0;\n  double rate = 1.0;\n  double eps = 1e-20;\n  while( LT(eps,rate) ) {\n    rep(_,80) {\n\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      if( !equals(max_area,-1) ) {\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      \n    }\n    rate *= 0.3;\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 400\n#define linf 1e18\n#define eps (1e-9)\n#define mod 1000000007\n#define pi M_PI\n#define phi (1.0+sqrt(5))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Circle c,Point p){\n  if(abs(c.c-p)-c.r<-eps)return true;\n  return false;\n}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nbool intersect(Circle c,Segment s){\n  if(getDistanceSP(s,c.c)-c.r<-eps)return true;\n  return false;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  return acos(tmp)*180.0/pi;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nPoint getCrossPointSC(Circle c,Segment s){\n  Point res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(ccw(s.p1,s.p2,pp.f)==0){\n    res=pp.f;\n    if(ccw(s.p1,s.p2,pp.s)==0 && abs(s.p1-pp.s)<abs(s.p1-pp.f))res=pp.s;\n  }\n  else res=pp.s;\n  return res;\n}\n\ndouble getCommonAreaTC(Point a,Point b,Circle c){\n  double res=abs(cross(a-c.c,b-c.c)/2.0);\n  if(equals(0.0,res))return 0.0;\n  if(in(c,a) && !in(c,b)){\n    Point p1=getCrossPointSC(c,Segment(b,a));\n    Point p2=getCrossPointSC(c,Segment(b,c.c)); \n    res+=(c.r*c.r*pi)*(getAngle(p1-c.c,p2-c.c)/360.0);\n    res-=abs(cross(p1-c.c,p2-c.c)/2.0);\n    res-=abs(cross(p2-b,p1-b)/2.0);\n  }\n  else if(!in(c,a) && in(c,b)){\n    Point p1=getCrossPointSC(c,Segment(a,c.c));\n    Point p2=getCrossPointSC(c,Segment(a,b));\n    res+=(c.r*c.r*pi)*(getAngle(p1-c.c,p2-c.c)/360.0);\n    res-=abs(cross(p1-c.c,p2-c.c)/2.0);\n    res-=abs(cross(p2-a,p1-a)/2.0);\n  }\n  else if(!in(c,a) && !in(c,b)){\n    if(intersect(c,Segment(a,b))){\n      pair<Point,Point> pp=getCrossPoints(c,Segment(a,b));\n      Point m=pp.f+(pp.s-pp.f)/2.0;\n      res=abs(getCommonAreaTC(a,m,c))+abs(getCommonAreaTC(m,b,c));\n    }\n    else res=(c.r*c.r*pi)*(getAngle(a-c.c,b-c.c)/360.0);\n  }\n  if(cross(a-c.c,b-c.c)<0.0)res=-res;\n  return res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  int n=p.size();\n  FOR(i,0,n)res+=getCommonAreaTC(p[i],p[(i+1)%n],c);\n  return abs(res);\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,40){\n    double m1=(L*phi+R)/(1.0+phi);\n    double m2=(L+R*phi)/(1.0+phi);\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res2-res1<-eps)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*R,r));\n}\n\ndouble solve(){\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double res=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=inf*2;\n    FOR(k,0,40){\n      double m1=(L*phi+R)/(1.0+phi);\n      double m2=(L+R*phi)/(1.0+phi);\n      double res1=check(a+v*(m1-inf));\n      double res2=check(a+v*(m2-inf));\n      if(res2-res1<-eps)R=m2; \n      else L=m1;\n    }\n    res=max(res,check(a+v*(R-inf)));\n  }\n  return res;\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  pd(solve());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cout if (1) cout\n\n// XXX without explanation marks untested functions\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pii;\n#define pb push_back\n\n// NOT STANDART FROM HERE\n\n// area de calota 2.pi.R.h (h altura)\n// volume de calota pi.h/6 * (3r^2 + h^2)\n\n typedef double cood;\n cood eps = 1e-8;\n// tests for double were made with eps = 1e-8\n\ndouble eps_d = 1e-8; // necessary even in integer geometry, should be eps otherwise\n\nconst double pi = acos(-1.);\n\ninline ll sq (ll x)\n{ return x*x; }\ninline double sq (double x)\n{ return x*x; }\n\nstruct vec { // vector\n\t// === BASIC ===\n\tcood x, y;\n\tvec () : x(0), y(0) {}\n\tvec (cood a, cood b) : x(a), y(b) {}\n\tfriend ostream& operator<<(ostream& os, vec o);\n\n\tvec operator - (vec o)\n\t{ return vec(x - o.x, y - o.y); }\n\tvec operator + (vec o)\n\t{ return vec(x + o.x, y + o.y); }\n\tvec operator * (cood o)\n\t{ return vec(x * o, y * o); }\n\tvec operator / (cood o)\n\t{ return vec(x / o, y / o); }\n\tcood operator ^ (vec o)\n\t{ return x * o.y - y * o.x; }\n\tcood operator * (vec o)\n\t{ return x * o.x + y * o.y; }\n\n\t// positive is (*this)b is clockwise from (*this)a\n\tdouble angle (vec a, vec b)\n\t{ return atan2((a-(*this))^(b-(*this)), (a-(*this))*(b-(*this))); }\n\n\tcood sq (vec o = vec())\n\t{ return ((*this)-o)*((*this)-o); }\n\tdouble nr (vec o = vec())\n\t{ return sqrt(sq(o)); }\n\n\tcood cross (vec a, vec b) // ccw signed area (positive if this is to the left of ab)\n\t{ return (b - a) ^ ((*this) - a); }\n\tint ccw (vec a, vec b) // which side is this from ab? (1 left, 0 over, -1 right)\n\t{ cood o = cross(a, b); return (eps < o) - (o < -eps); } \n\n\tint dir (vec a, vec b) // direction of (this)a relative to (this)b (-1 opposite, 0 none, 1 same)\n\t{ cood o = ((*this) - a)*((*this) - b); return (eps < o) - (o < -eps); }\n\n\tcood inner (vec s, vec t) // (p-s)*(t-s) where p = this projected on st\n\t{ return ((*this) - s) * (t - s); }\n\tvec proj (vec s, vec t) // projection of this point over line st\n\t{ return s + (t - s)*(inner(s,t) / t.sq(s)); }\n\n\tvec rotate (double a) // rotate ccw by a (fails with ll)\n\t{ return vec(cos(a) * x - sin(a) * y, sin(a) * x + cos(a) * y); }\n\tvec rot90 () // rotate pi/2 ccw\n\t{ return vec(-y, x); }\n\n\t// === ADVANCED ===\n\t// ordering that defines the compare method\n\t// used only there, change it accordingly\n\t// sorts increasing on y and, then increasing on x\n\tbool operator < (const vec & o) const {\n\t\tif (y != o.y)\n\t\t\treturn y < o.y;\n\t\treturn x < o.x;\n\t}\n\n\t// full ordering (ccw angle from this+(1,0), distance to this)\n\t// is a < b?\n\t// PRECISION : ok with double if norm in [-1e9,5e3]\n\tbool compare (vec a, vec b) {\n\t\tif (((*this) < a) != ((*this) < b))\n\t\t\treturn (*this) < a;\n\t\tint o = ccw(a,b);\n\t\tif (o) return o > 0;\n\t\treturn a.dir((*this),b) < 0;\n\t}\n\n\t// is this inside segment st? (tip of segment included, change for dr < 0 otherwise)\n\tbool in_seg (vec s, vec t)\n\t{ return (ccw(s,t) == 0) && (dir(s,t) <= 0); }\n\n\t// squared distance from this to line defined by st\n\tdouble dist2_lin (vec s, vec t)\n\t{ return double(::sq(cross(s,t))) / t.sq(s); }\n\t// squared distance from this to segment st\n\tdouble dist2_seg (vec s, vec t) \n\t{ return s.dir((*this),t) == t.dir((*this),s) ? dist2_lin(s,t) : min(sq(s),sq(t)); }\n\n\t// is this inside (borders included) the convex polygon v of size n?\n\t// if yes, prec is the vec that this on acw order from v[0] or 0 if there is no such\n\t// if not, prec is the predecessor of this when added to poly and succ is the sucessor\n\t// p should be a vector with [0..n-1]\n\t// n should be >= 2\n\tbool in_conv_poly (vec v[], int n, const vector<int> & p, int & prec, int & succ) {\n\t\tif (nr(v[0]) <= eps) {\n\t\t\tprec = 0;\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (n == 2) {\n\t\t\tif (in_seg(v[0],v[1]))\n\t\t\t\treturn (prec = 1);\n\n\t\t\tif (ccw(v[0],v[1]) > 0) {\n\t\t\t\tprec = 1;\n\t\t\t\tsucc = 0;\n\t\t\t} else if (ccw(v[0],v[1]) < 0) {\n\t\t\t\tprec = 0;\n\t\t\t\tsucc = 1;\n\t\t\t} else {\n\t\t\t\tprec = succ = (v[0].dir((*this),v[1]) < 0);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (ccw(v[0],v[1]) > 0 || ccw(v[0],v[n-1]) < 0) {\n\t\t// case where v[0] is not removed\n\t\t\t// last diagonal before or over this\n\t\t\tint di = lower_bound(p.begin() + 1, p.end(), -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[0],v[i]) >= 0;\n\t\t\t}) - p.begin() - 1;\n\n\t\t\t// is this inside the polygon?\n\t\t\tprec = di;\n\t\t\tif (di == n-1) {\n\t\t\t// last segment\n\t\t\t\tif (ccw(v[0],v[n-1]) == 0 && ccw(v[n-2],v[n-1]) >= 0)\n\t\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t// inside otherwise\n\t\t\t\tif (ccw(v[di],v[di+1]) >= 0)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// last that stays before (or eq to) di\n\t\t\tprec = lower_bound(p.begin() + 1, p.begin() + di + 1, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i-1],v[i]) > 0;\n\t\t\t}) - p.begin() - 1;\n\n\t\t\t// first that stays after di\n\t\t\tsucc = lower_bound(p.begin() + di + 1, p.end(), -1, [this,v,n] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[(i+1)%n],v[i]) >= 0;\n\t\t\t}) - p.begin();\n\t\t\tif (succ == n) succ = 0;\n\t\t} else {\n\t\t// case where v[0] is removed\n\t\t\t// first diagonal before of over this\n\t\t\t// di is certainly not removed\n\t\t\tint di = lower_bound(p.begin() + 1, p.end() - 1, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[0],v[i]) < 0;\n\t\t\t}) - p.begin();\n\n\t\t\t// first that stays (<= di)\n\t\t\tsucc = lower_bound(p.begin(), p.begin() + di, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i+1],v[i]) >= 0;\n\t\t\t}) - p.begin();\n\n\t\t\t// last that stays (>= di)\n\t\t\tprec = lower_bound(p.begin() + di + 1, p.end(), -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i-1],v[i]) > 0;\n\t\t\t}) - p.begin() - 1;\n\t\t}\n\t\treturn 0;\n\t}\n};\nostream& operator<<(ostream& os, vec o)\n{ return os << '(' << o.x << \", \" << o.y << ')'; }\n\nstruct lin { // line\n\tcood a, b, c; // a*x + b*y = c\n\n\tlin () {}\n\tlin (cood x, cood y, cood z) : a(x), b(y), c(z) {}\n\tlin (vec s, vec t) : a(t.y - s.y), b(s.x - t.x), c(a * s.x + b * s.y) {}\n\n\tlin parll (vec p) // parallel to this through p\n\t{ return lin(a, b, a * p.x + b * p.y); }\n\tlin perp ()\n\t{ return lin(-b, a, c); }\n\n\tvec inter (lin o) {\n\t\tcood d = a * o.b - o.a * b;\n\t\tif (d < eps && -eps < d) throw 0; // parallel\n\t\treturn vec((o.b * c - b * o.c) / d, (a * o.c - o.a * c) / d);\n\t}\n};\n\nstruct cir { // circle\n\tvec c; cood r;\n\n\t// borders included\n\tbool contains (vec w)\n\t{ return c.sq(w) <= sq(r) + eps; }\n\tbool has_inter (cir o)\n\t{ return c.sq(o.c) <= sq(r + o.r) + eps; }\n\tbool has_inter_lin (vec s, vec t)\n\t{ return c.dist2_lin(s,t) <= sq(r) + eps_d; }\n\tbool has_inter_seg (vec s, vec t)\n\t{ return c.dist2_seg(s,t) <= sq(r) + eps_d; }\n\n\t// borders not included\n\tbool contains (cir o)\n\t{ return (o.r < r - eps && c.sq(o.c) < sq(r - o.r) - eps); }\n\n\t// ccw area of arc from ca to cb\n\tdouble arc_area (vec a, vec b) {\n\t\tdouble ang = c.angle(a,b);\n\t\treturn r*r*ang*.5;\n\t}\n\n\t// double only\n\tpair<vec,vec> inter_pts (cir o) {\n\t\tassert(has_inter(o) && !contains(o)); // fully contained case\n\t\tdouble d = c.nr(o.c);\n\t\tdouble a = (r*r + d*d - o.r*o.r) / (2.*d); // r*cos(ans,v,c.v)\n\t\tdouble h = sqrt(r*r - a*a);\n\t\tif (h != h) h = 0;\n\t\tvec p = o.c - c;\n\t\treturn pair<vec,vec>(c + p*(a/d) + (p.rot90()*(h/d)), c + p*(a/d) - (p.rot90()*(h/d)));\n\t}\n\n\t// double only XXX careful precision\n\tpair<vec,vec> inter_pts (vec s, vec t) { \n\t\tassert(has_inter_lin(s,t));\n\t\tdouble h2 = c.dist2_lin(s,t);\n\t\tdouble d = sqrt(c.sq(t) - h2);\n\t\tif (d != d) d = 0;\n\t\tvec p = (s-t);\n\t\tvec m = t + p*(d/p.nr());\n\t\tvec m_b = t - p*(d/p.nr());\n\t\tif (m_b.sq(c) < m.sq(c))\n\t\t\tm = m_b;\n\n\t\td = sqrt(r*r - h2);\n\t\tif (d != d) d = 0;\n\t\treturn pair<vec,vec>(m + p*(d/p.nr()), m - p*(d/p.nr()));\n\t}\n\n\t// double only XXX AC only tested\n\t// signed area of intersection of this with triangle (this.c,a,b)\n\tdouble inter (vec a, vec b) {\n\t\tdouble res = 0.; bool inv = 0;\n\t\tif (contains(b)) {\n\t\t\tswap(a,b);\n\t\t\tinv = 1;\n\t\t}\n\n\t\tif (contains(b)) {\n\t\t\tres = c.cross(a,b)*.5;\n\t\t} else if (contains(a)) {\n\t\t\tpair<vec,vec> rt = inter_pts(a,b);\n\t\t\tvec q = rt.first;\n\t\t\tif (!q.in_seg(a,b) || (a.sq(q) <= eps && rt.second.in_seg(a,b)))\n\t\t\t\tq = rt.second;\n\t\t\tres += c.cross(a,q)*.5;\n\t\t\tres += arc_area(q,b);\n\t\t} else if (has_inter_seg(a,b)) {\n\t\t\tpair<vec,vec> rt = inter_pts(a,b);\n\t\t\tif (a.sq(rt.second) < a.sq(rt.first))\n\t\t\t\tswap(rt.first,rt.second);\n\t\t\tres += arc_area(a,rt.first);\n\t\t\tres += c.cross(rt.first,rt.second)*.5;\n\t\t\tres += arc_area(rt.second,b);\n\t\t} else {\n\t\t\tres += arc_area(a,b);\n\t\t}\n\n\t\tif (inv) return -res;\n\t\treturn res;\n\t}\n\n\t// double only XXX AC only tested\n\t// signed area of intersection of this with polygon\n\tdouble inter (vector<vec> & p) {\n\t\tdouble res = 0;\n\t\tfor (int i = 0; i < p.size(); i++)\n\t\t\tres += inter(p[i],p[(i+1)%p.size()]);\n\t\treturn res;\n\t}\n};\n\n// do the segments ab and cd intersect? (borders included) XXX\nbool inter_seg (vec a, vec b, vec c, vec d) {\n\tif (a.in_seg(c, d) || b.in_seg(c, d) || c.in_seg(a, b) || d.in_seg(a, b))\n\t\treturn true;\n\treturn (c.ccw(a, b) * d.ccw(a, b) == -1 && a.ccw(c, d) * b.ccw(c, d) == -1);\n}\n\n// squared distance from segments ab and cd XXX\ndouble dist2_seg (vec a, vec b, vec c, vec d)\n{ return inter_seg(a,b,c,d) ? 0. : min({ a.dist2_seg(c,d), b.dist2_seg(c,d), c.dist2_seg(a,b), d.dist2_seg(a,b) }); }\n\n// brd = do points on the border belong to convex?\n// computes convex hull of given vector (inplace)\n// returns size of convex hull\nint graham (vec v[], int n, int brd) {\n\tfor (int i = 1; i < n; i++) {\n\t\tif (v[i].x < v[0].x || (v[i].x == v[0].x && v[i].y < v[0].y))\n\t\t\tswap(v[0], v[i]);\n\t}\n\n\tsort(v+1, v+n, [v] (vec a, vec b) {\n\t\tint o = b.ccw(v[0], a);\n\t\tif (o) return (o == 1);\n\t\treturn v[0].sq(a) < v[0].sq(b);\n\t});\n\n\tif (brd) {\n\t\tint s = n-1;\n\t\twhile (s > 1 && v[s].ccw(v[s-1],v[0]) == 0)\n\t\t\ts--;\n\t\tfor (int i = s; i < n - 1 - (i - s); i++)\n\t\t\tswap(v[i], v[n-1-(i-s)]);\n\t}\n\n\tint s = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s && v[s-1].x == v[i].x && v[s-1].y == v[i].y) continue;\n\t\twhile (s >= 2 && v[s-1].ccw(v[s-2],v[i]) >= brd)\n\t\t\ts--;\n\t\tv[s++] = v[i];\n\t}\n\n\treturn s;\n}\n\nconst int N = 1e2+7;\n\nint n;\ndouble r;\nvector<vec> v;\ndouble x[2], y[2];\n\ndouble solve (double x) {\n\tdouble lo = 200, hi = -100.;\n\tfor (int i = 0; i < n; i++) {\n\t\tint j = (i+1)%n;\n\t\tlin ln(v[i],v[j]);\n\t\tvec it(x, (ln.c - ln.a*x)/ln.b);\n\t\tif (it.in_seg(v[i],v[j]) && it.y == it.y && abs(it.y) < 200) {\n\t\t\tlo = min(lo, it.y);\n\t\t\thi = max(hi, it.y);\n\t\t}\n\n\t\tif (abs(v[i].x - x) <= eps_d) {\n\t\t\tlo = min(lo, v[i].y);\n\t\t\thi = max(hi, v[i].y);\n\t\t}\n\t}\n\thi = min(hi, 200.); lo = max(lo, -100.);\n\n\tint ts = 60;\n\twhile (ts--) {\n\t\tdouble q1 = (lo+lo+hi)/3;\n\t\tdouble q2 = (lo+hi+hi)/3;\n\n\t\tdouble r1 = abs(cir({ vec(x,q1), r }).inter(v));\n\t\tdouble r2 = abs(cir({ vec(x,q2), r }).inter(v));\n\n\t\tif (r1 < r2)\n\t\t\tlo = q1;\n\t\telse\n\t\t\thi = q2;\n\t}\n\n\treturn abs(cir({ vec(x,lo), r }).inter(v));\n}\n\nint main () {\n\n\twhile (scanf(\"%d %lf\", &n, &r) != EOF) {\n\t\tv = vector<vec>(n);\n\t\t\n\t\tx[0] = 200;\n\t\tx[1] = -100;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%lf %lf\", &v[i].x, &v[i].y);\n\n\t\t\tx[0] = min(x[0],v[i].x);\n\t\t\tx[1] = max(x[1],v[i].x);\n\t\t}\n\n\t\tdouble lo = x[0], hi = x[1];\n\t\t//int ts = 60;\n\t\tint ts = 50;\n\t\twhile (ts--) {\n\t\t\tdouble q1 = (lo+lo+hi)/3;\n\t\t\tdouble q2 = (lo+hi+hi)/3;\n\t\t\t\n\t\t\tif (solve(q1) < solve(q2))\n\t\t\t\tlo = q1;\n\t\t\telse\n\t\t\t\thi = q2;\n\t\t}\n\n\t\tdouble res = solve(lo);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tres = max(res, abs(cir({ v[i], r }).inter(v)));\n\n\t\tprintf(\"%.20f\\n\", res);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\n#define CVector CPoint\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-7;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n    /*friend bool operator<(CPoint a,CPoint b){//?角排序\n        double tmp=cross(Pts[0],a,b);\n        if(isZero(tmp)){\n            return dist(Pts[0],a)<dist(Pts[0],b);\n        }\n        return tmp>0;\n    }*/\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n/*----------------------多?形相?--------------------------*/\n\n//0:outside 1:inside 2:online\nint PointInPoly(Point t,Point *Pts,int n){\n    int num=0,d1,d2,k;\n    Pts[n]=Pts[0];\n    for(int i=0;i<n;i++){\n        if(PointOnS(t,Line(Pts[i],Pts[i+1]))) return 2;\n        k=dcmp(cross(Pts[i],Pts[i+1],t));\n        d1=dcmp(Pts[i].y-t.y);\n        d2=dcmp(Pts[i+1].y-t.y);\n        if(k>0&&d1<=0&&d2>0) num++;\n        if(k<0&&d2<=0&&d1>0) num--;\n    }\n    return num!=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n//求任意多?形周?，需逆??或???排列\ndouble PolyPerimeter(Point *Pts,int n){\n    double pp=distPP(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pp+=distPP(Pts[i],Pts[i+1]);\n    return pp;\n}\n\n//求多?形重心坐?\nPoint PolyCore(Point *Pts,int n){\n    double pa=PolyArea(Pts,n);\n    if(!dcmp(pa)) return Point(0,0);\n    Point ans=(Pts[n-1]+Pts[0])*cross(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) ans=ans+(Pts[i]+Pts[i+1])*cross(Pts[i],Pts[i+1]);\n    return ans/pa/6;\n}\n\n/*----------------------凸包----------------------------*/\n\n//Graham-scan st:anticlockwise\n//<=:strict <:Non-strict\nint Graham(Point *Pts,Point *st,int n){\n    if(n<3) return 0;\n    sort(Pts,Pts+n);\n    int m=0;\n    for(int i=0;i<n;i++){\n        while(m>1&&dcmp(cross(st[m-2],st[m-1],Pts[i]))<0) m--;\n        st[m++]=Pts[i];\n    }\n    int k=m;\n    for(int i=n-2;i>=0;i--){\n        while(m>k&&dcmp(cross(st[m-2],st[m-1],Pts[i])<0)) m--;\n        st[m++]=Pts[i];\n    }\n    return m-1;\n}\n\n//clockwise:> anticlockwise:<\ndouble CHDiameter(Point *Pts,int n,Line &l){\n    double maxd=0.0;\n    if(n<=1){\n        l.a=l.b=Pts[0];\n        return maxd;\n    }\n    for(int i=0,j=1;i<n;i++){\n        while(cross(Pts[i],Pts[(i+1)%n],Pts[j])\n              >cross(Pts[i],Pts[(i+1)%n],Pts[(j+1)%n])){\n            j=(j+1)%n;\n        }\n        double d=distPP(Pts[i],Pts[j]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n        d=distPP(Pts[(i+1)%n],Pts[(j+1)%n]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n    }\n    return maxd;\n}\n\n/*---------------------整点多?形---------------------------*/\n\nint gcd(int a,int b){\n    return b==0?a :gcd(b,a%b);\n}\n\n//整点多?形?界整点数\nint Border_Int_Point_Num(Point *Pts,int n){\n    int num=gcd(abs(int(Pts[0].x-Pts[n-1].x)),abs(int(Pts[0].y-Pts[n-1].y)));;\n    for(int i=0;i<n-1;i++){\n        num+=gcd(abs(int(Pts[i+1].x-Pts[i].x)),abs(int(Pts[i+1].y-Pts[i].y)));\n    }\n    return num;\n}\n\n//整点多?形内部整点数\nint Inside_Int_Point_Num(Point *Pts,int n){\n    return abs(int(PolyArea(Pts,n)))+1-Border_Int_Point_Num(Pts,n)/2;\n}\n\n/*-----------------------------半平面交-------------------------------*/\n\n//有方向的直?\n//p->p+v\nstruct Vector{\n    Point p,v;\n    double ang;\n    Vector(Point p,Point v):p(p),v(v){\n        ang=atan2(v.y,v.x);\n    }\n    Vector(){}\n    bool operator<(const Vector &l) const{\n        return ang<l.ang;\n    }\n};\n\n//判断点p是否在直?L左?\nbool onLeft(Vector L,Point p){\n    return cross(L.v,p-L.p)>0;\n}\n\n//得到a与b?直?的交点\nPoint getCrossVV(Vector a,Vector b){\n    Point u=a.p-b.p;\n    double t=cross(b.v,u)/cross(a.v,b.v);\n    return a.p+a.v*t;\n}\n\n//所有直?左半平面的交\nint HPCross(Vector *L,int n,Point *poly){\n    sort(L,L+n);\n    int f=0,l=0;\n    Point *p=new Point[n];\n    Vector *q=new Vector[n];\n    q[0]=L[0];\n    for(int i=1;i<n;i++){\n        while(f<l&&!onLeft(L[i],p[l-1])) l--;\n        while(f<l&&!onLeft(L[i],p[f])) f++;\n        q[++l]=L[i];\n        if(!dcmp(cross(q[l].v,q[l-1].v))){\n            l--;\n            if(onLeft(q[l],L[i].p)) q[l]=L[i];\n        }\n        if(f<l) p[l-1]=getCrossVV(q[l-1],q[l]);\n    }\n    while(f<l&&!onLeft(q[f],p[l-1])) l--;\n    if(l-f<=1) return 0;\n    p[l]=getCrossVV(q[l],q[f]);\n    int m=0;\n    for(int i=f;i<=l;i++) poly[m++]=p[i];\n    return m;\n}\n\n#define maxn 100005\nVector l[maxn];\nbool retract(Vector *L,int n,double r,Point *poly){\n    for(int i=0;i<n;i++){\n        Point v=rotateV(L[i].p,L[i].p+L[i].v,PI/2);\n        l[i]=Vector(L[i].p+r*v,L[i].v);\n    }\n    int cnt=HPCross(l,n,poly);\n    return cnt;\n}\n\n/*---------------------三角形相?---------------------------*/\n\n//三角形重心\n//到三?点距?的平方和最小的点\n//到三?距?之?最大的点\nPoint TCore(Point a,Point b,Point c){\n    return (a+b+c)/3;\n}\n\n//三角形外心\nPoint TCircum(Point a,Point b,Point c){\n    Point cp;\n    double a1=b.x-a.x;\n    double b1=b.y-a.y;\n    double a2=c.x-a.x;\n    double b2=c.y-a.y;\n    double c1=(a1*a1+b1*b1)/2;\n    double c2=(a2*a2+b2*b2)/2;\n    double d=a1*b2-a2*b1;\n    cp.x=a.x+(c1*b2-c2*b1)/d;\n    cp.y=a.y+(a1*c2-a2*c1)/d;\n    return cp;\n}\n\n//三角形垂心\nPoint TOrtho(Point a,Point b,Point c){\n    return TCore(a,b,c)*3.0-TCircum(a,b,c)*2.0;\n}\n\n//三角形内心\nPoint TInner(Point a,Point b,Point c){\n    Point cp;\n    double la=distPP(b,c),lb=distPP(c,a),lc=distPP(a,b);\n    cp.x=(la*a.x+lb*b.x+lc*c.x)/(la+lb+lc);\n    cp.y=(la*a.y+lb*b.y+lc*c.y)/(la+lb+lc);\n    return cp;\n}\n\n//求三角形面?\ndouble TArea(Point a,Point b,Point c){\n    return fabs(cross(a,b,c))/2;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n//求??面?交\ndouble getAreaCC(Circle a,Circle b){\n    double d=(a.o.x-b.o.x)*(a.o.x-b.o.x)+(a.o.y-b.o.y)*(a.o.y-b.o.y);\n    if(d<=(a.r-b.r)*(a.r-b.r)){\n        return min(a.r,b.r)*min(a.r,b.r)*PI;\n    }else if(d>(a.r-b.r)*(a.r-b.r)&&d<(a.r+b.r)*(a.r+b.r)){\n        double m1=(a.r*a.r+d-b.r*b.r)/(2*a.r*sqrt(d));\n        double m2=(b.r*b.r+d-a.r*a.r)/(2*b.r*sqrt(d));\n        double s1=acos(m1)*a.r*a.r;\n        double s2=acos(m2)*b.r*b.r;\n        double s3=sqrt(d)*a.r*sin(acos(m1));\n        return s1+s2-s3;\n    }\n    return 0.0;\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n/********************************************************/\nint getCrossCS(Circle c,Line s,Point *cs){\n    Point tmp[2];\n    int cnt=0;\n    int ct=getCrossCL(c,s,tmp);\n    for(int i=0;i<ct;i++){\n        if(PointOnS(tmp[i],s)) cs[cnt++]=tmp[i];\n    }\n    return cnt;\n}\n\nPoint PinS(Point *cs,int n,Line s){\n    if(n==1) return cs[0];\n    if((!dcmp(cs[0].x-s.a.x)&&!dcmp(cs[0].y-s.a.y))\n       ||(!dcmp(cs[0].x-s.b.x)&&!dcmp(cs[0].y-s.b.y))) return cs[1];\n    return cs[0];\n}\n\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=fabs(cross(a-c.o,b-c.o)/2);\n    if(!dcmp(atc)) return 0.0;\n    double la=length(a-c.o),lb=length(b-c.o);\n    Point cs[4];\n    if(la<c.r+EPS&&lb>c.r-EPS){\n        int ct=getCrossCS(c,Line(a,b),cs);\n        Point p=PinS(cs,ct,Line(a,b));\n        atc+=0.5*c.r*c.r*angleVV(p-c.o,b-c.o);\n        atc-=fabs(cross(p-c.o,b-c.o)/2);\n    }else if(la>c.r-EPS&&lb<c.r+EPS){\n        int ct=getCrossCS(c,Line(a,b),cs);\n        Point p=PinS(cs,ct,Line(a,b));\n        atc+=0.5*c.r*c.r*angleVV(p-c.o,a-c.o);\n        atc-=fabs(cross(p-c.o,a-c.o)/2);\n    }else if(la>c.r-EPS&&lb>c.r-EPS){\n        if(distPS(c.o,Line(a,b))<c.r-EPS){\n            Point rt=root(c.o,Line(a,b));\n            atc=fabs(getAreaTC(a,rt,c))+fabs(getAreaTC(rt,b,c));\n        }else atc=0.5*c.r*c.r*angleVV(a-c.o,b-c.o);\n    }\n    if(dcmp(cross(a-c.o,b-c.o))==1) atc=-atc;\n    return atc;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=getAreaTC(Pts[n-1],Pts[0],c);\n    for(int i=0;i<n-1;i++) apc+=getAreaTC(Pts[i],Pts[i+1],c);\n    return fabs(apc);\n}\n\n/********************************************************/\n\n\n/*----------------------三?点、?基本函数-----------------------------*/\n\nstruct Point3{\n    double x,y,z;\n    Point3(double x,double y,double z):x(x),y(y),z(z){}\n    Point3(){}\n    void Read(){ scanf(\"%lf%lf%lf\",&x,&y,&z); }\n};\n\nstruct Line3{\n    Point3 a,b;\n    Line3(Point3 a,Point3 b):a(a),b(b){}\n    Line3(){}\n    void Read(){ a.Read(); b.Read(); }\n};\nPoint3 operator +(Point3 a,Point3 b){ return Point3(a.x+b.x,a.y+b.y,a.z+b.z); }\nPoint3 operator -(Point3 a,Point3 b){ return Point3(a.x-b.x,a.y-b.y,a.z-b.z); }\ndouble operator *(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 operator *(Point3 a,double k){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator *(double k,Point3 a){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator /(Point3 a,double k){ return Point3(a.x/k,a.y/k,a.z/k); }\n\ndouble length(Point3 a){ return sqrt(a.x*a.x+a.y*a.y+a.z*a.z); }\nPoint3 unit(Point3 a){ return a/length(a); }\ndouble dot(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 cross(Point3 a,Point3 b){\n    return Point3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//混合?\ndouble Mix(Point3 a,Point3 b,Point3 c){\n    return dot(a,cross(b,c));\n}\n\n//?点距?\ndouble dist(const Point3 &a,const Point3 &b){ return length(a-b); }\n\n/*---------------------------------体?-------------------------------------*/\n\n//四面体体?\ndouble volume(double l,double n,double a,double m,double b,double c){\n    double x,y;\n    x=4*a*a*b*b*c*c-a*a*(b*b+c*c-m*m)*(b*b+c*c-m*m)-b*b*(c*c+a*a-n*n)*(c*c+a*a-n*n);\n    y=c*c*(a*a+b*b-l*l)*(a*a+b*b-l*l)-(a*a+b*b-l*l)*(b*b+c*c-m*m)*(c*c+a*a-n*n);\n    return sqrt(x-y)/12;\n}\n\ndouble volume(Point3 a,Point3 b,Point3 c,Point3 d){\n    return fabs(Mix(b-a,c-a,d-a)/6);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);//cin.tie(0);\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1.0);\n//const double EPS=1e-10;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-20;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n\nPoint root(Line l,Point p){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n\ndouble mysqrt(double x){ return sqrt(max(0.0,x)); }\nint getCrossCS(Circle c,Line s,Point *ret){\n    double x0=c.o.x,y0=c.o.y;\n    double x1=s.a.x,y1=s.a.y;\n    double x2=s.b.x,y2=s.b.y;\n    double dx=x2-x1,dy=y2-y1;\n    double A=dx*dx+dy*dy;\n    double B=2.0*dx*(x1-x0)+2.0*dy*(y1-y0);\n    double C=(x1-x0)*(x1-x0)+(y1-y0)*(y1-y0)-c.r*c.r;\n    double delta=B*B-4.0*A*C;\n    int num=0;\n    if(dcmp(delta)>=0){\n        double t1=(-B-mysqrt(delta))/(2.0*A);\n        double t2=(-B+mysqrt(delta))/(2.0*A);\n        if(dcmp(t1-1)<=0&&dcmp(t1)>=0) ret[num++]=Point(x1+t1*dx,y1+t1*dy);\n        if(dcmp(t2-1)<=0&&dcmp(t2)>=0) ret[num++]=Point(x1+t2*dx,y1+t2*dy);\n        //如果没有if判断，?是求直?和?的交点\n    }\n    return num;\n}\ndouble SectorArea(Point a,Point b,Circle c){\n    a=a-c.o,b=b-c.o;\n    double theta=atan2(a.y,a.x)-atan2(b.y,b.x);\n    while(dcmp(theta)<=0) theta+=2.0*PI;\n    while(dcmp(theta-2.0*PI)>0) theta-=2.0*PI;\n    theta=min(theta,2.0*PI-theta);\n    return c.r*c.r*theta*0.5;\n}\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=0.0;\n    Point OA=a-c.o,OB=b-c.o;\n    double la=length(OA),lb=length(OB);\n    Point cs[4];\n    bool aic=dcmp(la-c.r)<=0,bic=dcmp(lb-c.r)<=0;\n    if(aic&&bic) return fabs(cross(OA,OB))*0.5;\n    int num=getCrossCS(c,Line(a,b),cs);\n    if(aic) return SectorArea(cs[0],b,c)+fabs(cross(OA,cs[0]-c.o))*0.5;\n    if(bic) return SectorArea(cs[0],a,c)+fabs(cross(OB,cs[0]-c.o))*0.5;\n    if(num==2) return SectorArea(a,cs[0],c)+\n        SectorArea(b,cs[1],c)+fabs(cross(cs[0]-c.o,cs[1]-c.o))*0.5;\n    return SectorArea(a,b,c);\n}\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=0.0;\n    for(int i=0;i<n;i++){\n        int s=dcmp(cross(Pts[i]-c.o,Pts[i+1]-c.o));\n        if(!!s) apc+=getAreaTC(Pts[i],Pts[i+1],c)*s;\n    }\n    return fabs(apc);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<200;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<200;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);cin.tie(0);\n    //cout<<getAreaTC(Point(3,3),Point(-3,3),Circle(Point(0,0),4))<<endl;\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\n\ntemplate<class T> using V = vector<T>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) { return (abs(a) <= EPS) ? 0 : (a < 0 ? -1 : 1); }\nint sgn(D a, D b) { return sgn(a-b); }\n//relative sign\n// int rsgn(D a, D f) {\n//     if (abs(a) <= f*EPS) return 0;\n//     return (a < 0) ? -1 : 1;\n// }\nstruct Pt2 {\n    D x, y;\n    Pt2(D _x = D(), D _y = D()) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    Pt2 operator/(const D &r) const { return Pt2(x/r, y/r); }\n\n    Pt2& operator+=(const Pt2 &r) { return *this=*this+r; }\n    Pt2& operator-=(const Pt2 &r) { return *this=*this-r; }\n    Pt2& operator*=(const Pt2 &r) { return *this=*this*r; }\n    Pt2& operator*=(const D &r) { return *this=*this*r; }\n    Pt2& operator/=(const D &r) { return *this=*this/r; }\n    \n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    bool operator<(const Pt2 &r) const { return 2*sgn(x, r.x)+sgn(y, r.y)<0; }\n    bool operator==(const Pt2 &r) const { return sgn((*this-r).rabs()) == 0; }\n\n    D norm() const { return x*x + y*y; }\n    D abs() const { return sqrt(norm()); }\n    D rabs() const { return max(std::abs(x), std::abs(y)); } // robust abs\n    D arg() const { return atan2(y, x); }\n\n    pair<D, D> to_pair() const { return make_pair(x, y); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    return os << \"P(\" << p.x << \", \" << p.y << \")\";\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L(P _s = P(), P _t = P()) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\nostream& operator<<(ostream& os, const L &l) {\n    return os << \"L(\" << l.s << \", \" << l.t << \")\";\n}\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n// cross(a, b) is too small?\nint sgncrs(P a, P b) {\n    D cr = cross(a, b);\n    if (abs(cr) <= (a.rabs() + b.rabs()) * EPS) return 0;\n    return (cr < 0) ? -1 : 1;\n}\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = sgncrs(b, c);\n    if (s) return s;\n    if (!sgn(c.rabs()) || !sgn((c-b).rabs())) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nP project(const L &l, const P &p) {\n    P v = l.vec();\n    return l.s + v * (dot(v, p-l.s) / v.norm());\n}\n\nbool insSL(const L &s, const L &l) {\n    int a = ccw(l, s.s), b = ccw(l, s.t);\n    return (a%2 == 0 || b%2 == 0 || a != b);\n}\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s, t.s), b = ccw(s, t.t);\n    int c = ccw(t, s.s), d = ccw(t, s.t);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nD distLP(const L &l, const P &p) {\nreturn abs(cross(l.vec(), p-l.s)) / l.abs();\n}\n\nD distSP(const L &s, const P &p) {\n    P q = project(s, p);\n    if (ccw(s, q) == 0) return (p - q).abs();\n    else return min((s.s - p).abs(), (s.t - p).abs());\n}\n\nint crossLL(const L &l, const L &m, P &r) {\n    D cr1 = cross(l.vec(), m.vec()), cr2 = cross(l.vec(), l.t - m.s);\n    if (sgncrs(l.vec(), m.vec()) == 0) {\n        r = l.s;\n        if (sgncrs(l.vec(), l.t - m.s)) return 0;\n        return -1;\n    }\n    r = m.s + m.vec() * (cr2 / cr1);\n    return 1;\n}\n\nusing Pol = V<P>;\n\nstruct C {\n    P p; D r;\n    C(P _p = P(), D _r = D()) : p(_p), r(_r) {}\n};\n\n//need Intersect/distLP, r.sはよりl.sに近い\nint crossCL(const C &c, const L &l, L &r) {\n    D u = distLP(l, c.p);\n    int si = sgn(u, c.r);    \n    if (si == 1) return 0;\n    P v = project(l, c.p);\n    P di = (si == 0) ? P(0, 0) : l.vec() * (sqrt(c.r*c.r - u*u) / l.abs());\n    r = L(v-di, v+di);\n    if (si == 0) return 1;\n    return 2;\n}\n\n//need Intersect/distLP, r.sはよりl.sに近い\nint crossCS(const C &c, const L &s, L &l) {\n    if (!crossCL(c, s, l)) return 0;\n    bool f1 = ccw(s, l.s) == 0, f2 = ccw(s, l.t) == 0;\n    if (f1 && f2) return 2;\n    if (!f1 && !f2) return 0;\n    if (f1) l.t = l.s;\n    else l.s = l.t;\n    return 1;\n}\n\n// C(P(0, 0), r)とTri((0, 0), a, b)の共有面積\nD area2CT(const C &c, const P &_a, const P &_b) {\n    P a = _a - c.p, b = _b - c.p; D r = c.r;\n    if (a == b) return 0;\n    auto single = [&](P x, P y, bool tri) {\n        if (tri) return cross(x, y);\n        else return r * r * ((y * P(x.x, -x.y)).arg());\n    };\n    bool ia = sgn(a.abs(), r) != 1, ib = sgn(b.abs(), r) != 1;\n    if (ia && ib) return single(a, b, true);\n    L l;\n    if (!crossCS(C(P(0, 0), r), L(a, b), l)) return single(a, b, false);\n//    if (ia) l.s = l.t;\n//    else if (ib) l.t = l.s;\n    assert(ccw(a, b, l.s) == 0); assert(ccw(a, b, l.t) == 0);\n    return single(a, l.s, ia) + single(l.s, l.t, true) + single(l.t, b, ib);\n}\n\n// p, cの共有面積\nD area2CPol(const C &c, const Pol &po) {\n    D sm = 0;\n    P a, b = po.back();\n    for (auto p: po) {\n        a = b; b = p;\n        sm += area2CT(c, a, b);\n    }\n    return sm;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    int n; D r;\n    cin >> n >> r;\n    Pol pol;\n \n    D ymi = 1e100, yma = -1e100;\n    for (int i = 0; i < n; i++) {\n        D x, y;\n        cin >> x >> y;\n        pol.push_back(P(x, y));\n        ymi = min(ymi, y);\n        yma = max(yma, y);\n    }\n \n    auto calc = [&](D y) {\n        D xmi = 1e100, xma = -1e100;\n        P a, b = pol.back();\n        for (int i = 0; i < n; i++) {\n            a = b; b = pol[i];\n            P p;\n            if (crossLL(L(a, b), L(P(0, y), P(1, y)), p) == 0) continue;\n            if (ccw(a, b, p) != 0) continue;\n            xmi = min(xmi, p.x); xma = max(xma, p.x);\n        }\n        D lw = xmi, up = xma;\n        for (int ph = 0; ph < 30; ph++) {\n            D md1 = (lw+lw+up) / 3;\n            D md2 = (lw+up+up) / 3;\n            D z1 = area2CPol(C(P(md1, y), r), pol) / 2;\n            D z2 = area2CPol(C(P(md2, y), r), pol) / 2;\n            if (z1 < z2) {\n                lw = md1;\n            } else {\n                up = md2;\n            }\n        }\n        return area2CPol(C(P(lw, y), r), pol) / 2;\n    };\n     \n    D lw = ymi, up = yma;\n    for (int ph = 0; ph < 30; ph++) {\n        D md1 = (lw+lw+up) / 3;\n        D md2 = (lw+up+up) / 3;\n        if (calc(md1) < calc(md2)) {\n            lw = md1;\n        } else {\n            up = md2;\n        }\n    }\n \n    cout << calc(lw) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\n#define CVector CPoint\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1.0);\nconst double EPS=1e-7;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-7;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n    /*friend bool operator<(CPoint a,CPoint b){//?角排序\n        double tmp=cross(Pts[0],a,b);\n        if(isZero(tmp)){\n            return dist(Pts[0],a)<dist(Pts[0],b);\n        }\n        return tmp>0;\n    }*/\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n/*----------------------多?形相?--------------------------*/\n\n//0:outside 1:inside 2:online\nint PointInPoly(Point t,Point *Pts,int n){\n    int num=0,d1,d2,k;\n    Pts[n]=Pts[0];\n    for(int i=0;i<n;i++){\n        if(PointOnS(t,Line(Pts[i],Pts[i+1]))) return 2;\n        k=dcmp(cross(Pts[i],Pts[i+1],t));\n        d1=dcmp(Pts[i].y-t.y);\n        d2=dcmp(Pts[i+1].y-t.y);\n        if(k>0&&d1<=0&&d2>0) num++;\n        if(k<0&&d2<=0&&d1>0) num--;\n    }\n    return num!=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n//求任意多?形周?，需逆??或???排列\ndouble PolyPerimeter(Point *Pts,int n){\n    double pp=distPP(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pp+=distPP(Pts[i],Pts[i+1]);\n    return pp;\n}\n\n//求多?形重心坐?\nPoint PolyCore(Point *Pts,int n){\n    double pa=PolyArea(Pts,n);\n    if(!dcmp(pa)) return Point(0,0);\n    Point ans=(Pts[n-1]+Pts[0])*cross(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) ans=ans+(Pts[i]+Pts[i+1])*cross(Pts[i],Pts[i+1]);\n    return ans/pa/6;\n}\n\n/*----------------------凸包----------------------------*/\n\n//Graham-scan st:anticlockwise\n//<=:strict <:Non-strict\nint Graham(Point *Pts,Point *st,int n){\n    if(n<3) return 0;\n    sort(Pts,Pts+n);\n    int m=0;\n    for(int i=0;i<n;i++){\n        while(m>1&&dcmp(cross(st[m-2],st[m-1],Pts[i]))<0) m--;\n        st[m++]=Pts[i];\n    }\n    int k=m;\n    for(int i=n-2;i>=0;i--){\n        while(m>k&&dcmp(cross(st[m-2],st[m-1],Pts[i])<0)) m--;\n        st[m++]=Pts[i];\n    }\n    return m-1;\n}\n\n//clockwise:> anticlockwise:<\ndouble CHDiameter(Point *Pts,int n,Line &l){\n    double maxd=0.0;\n    if(n<=1){\n        l.a=l.b=Pts[0];\n        return maxd;\n    }\n    for(int i=0,j=1;i<n;i++){\n        while(cross(Pts[i],Pts[(i+1)%n],Pts[j])\n              >cross(Pts[i],Pts[(i+1)%n],Pts[(j+1)%n])){\n            j=(j+1)%n;\n        }\n        double d=distPP(Pts[i],Pts[j]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n        d=distPP(Pts[(i+1)%n],Pts[(j+1)%n]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n    }\n    return maxd;\n}\n\n/*---------------------整点多?形---------------------------*/\n\nint gcd(int a,int b){\n    return b==0?a :gcd(b,a%b);\n}\n\n//整点多?形?界整点数\nint Border_Int_Point_Num(Point *Pts,int n){\n    int num=gcd(abs(int(Pts[0].x-Pts[n-1].x)),abs(int(Pts[0].y-Pts[n-1].y)));;\n    for(int i=0;i<n-1;i++){\n        num+=gcd(abs(int(Pts[i+1].x-Pts[i].x)),abs(int(Pts[i+1].y-Pts[i].y)));\n    }\n    return num;\n}\n\n//整点多?形内部整点数\nint Inside_Int_Point_Num(Point *Pts,int n){\n    return abs(int(PolyArea(Pts,n)))+1-Border_Int_Point_Num(Pts,n)/2;\n}\n\n/*-----------------------------半平面交-------------------------------*/\n\n//有方向的直?\n//p->p+v\nstruct Vector{\n    Point p,v;\n    double ang;\n    Vector(Point p,Point v):p(p),v(v){\n        ang=atan2(v.y,v.x);\n    }\n    Vector(){}\n    bool operator<(const Vector &l) const{\n        return ang<l.ang;\n    }\n};\n\n//判断点p是否在直?L左?\nbool onLeft(Vector L,Point p){\n    return cross(L.v,p-L.p)>0;\n}\n\n//得到a与b?直?的交点\nPoint getCrossVV(Vector a,Vector b){\n    Point u=a.p-b.p;\n    double t=cross(b.v,u)/cross(a.v,b.v);\n    return a.p+a.v*t;\n}\n\n//所有直?左半平面的交\nint HPCross(Vector *L,int n,Point *poly){\n    sort(L,L+n);\n    int f=0,l=0;\n    Point *p=new Point[n];\n    Vector *q=new Vector[n];\n    q[0]=L[0];\n    for(int i=1;i<n;i++){\n        while(f<l&&!onLeft(L[i],p[l-1])) l--;\n        while(f<l&&!onLeft(L[i],p[f])) f++;\n        q[++l]=L[i];\n        if(!dcmp(cross(q[l].v,q[l-1].v))){\n            l--;\n            if(onLeft(q[l],L[i].p)) q[l]=L[i];\n        }\n        if(f<l) p[l-1]=getCrossVV(q[l-1],q[l]);\n    }\n    while(f<l&&!onLeft(q[f],p[l-1])) l--;\n    if(l-f<=1) return 0;\n    p[l]=getCrossVV(q[l],q[f]);\n    int m=0;\n    for(int i=f;i<=l;i++) poly[m++]=p[i];\n    return m;\n}\n\n#define maxn 100005\nVector l[maxn];\nbool retract(Vector *L,int n,double r,Point *poly){\n    for(int i=0;i<n;i++){\n        Point v=rotateV(L[i].p,L[i].p+L[i].v,PI/2);\n        l[i]=Vector(L[i].p+r*v,L[i].v);\n    }\n    int cnt=HPCross(l,n,poly);\n    return cnt;\n}\n\n/*---------------------三角形相?---------------------------*/\n\n//三角形重心\n//到三?点距?的平方和最小的点\n//到三?距?之?最大的点\nPoint TCore(Point a,Point b,Point c){\n    return (a+b+c)/3;\n}\n\n//三角形外心\nPoint TCircum(Point a,Point b,Point c){\n    Point cp;\n    double a1=b.x-a.x;\n    double b1=b.y-a.y;\n    double a2=c.x-a.x;\n    double b2=c.y-a.y;\n    double c1=(a1*a1+b1*b1)/2;\n    double c2=(a2*a2+b2*b2)/2;\n    double d=a1*b2-a2*b1;\n    cp.x=a.x+(c1*b2-c2*b1)/d;\n    cp.y=a.y+(a1*c2-a2*c1)/d;\n    return cp;\n}\n\n//三角形垂心\nPoint TOrtho(Point a,Point b,Point c){\n    return TCore(a,b,c)*3.0-TCircum(a,b,c)*2.0;\n}\n\n//三角形内心\nPoint TInner(Point a,Point b,Point c){\n    Point cp;\n    double la=distPP(b,c),lb=distPP(c,a),lc=distPP(a,b);\n    cp.x=(la*a.x+lb*b.x+lc*c.x)/(la+lb+lc);\n    cp.y=(la*a.y+lb*b.y+lc*c.y)/(la+lb+lc);\n    return cp;\n}\n\n//求三角形面?\ndouble TArea(Point a,Point b,Point c){\n    return fabs(cross(a,b,c))/2;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n//求??面?交\ndouble getAreaCC(Circle a,Circle b){\n    double d=(a.o.x-b.o.x)*(a.o.x-b.o.x)+(a.o.y-b.o.y)*(a.o.y-b.o.y);\n    if(d<=(a.r-b.r)*(a.r-b.r)){\n        return min(a.r,b.r)*min(a.r,b.r)*PI;\n    }else if(d>(a.r-b.r)*(a.r-b.r)&&d<(a.r+b.r)*(a.r+b.r)){\n        double m1=(a.r*a.r+d-b.r*b.r)/(2*a.r*sqrt(d));\n        double m2=(b.r*b.r+d-a.r*a.r)/(2*b.r*sqrt(d));\n        double s1=acos(m1)*a.r*a.r;\n        double s2=acos(m2)*b.r*b.r;\n        double s3=sqrt(d)*a.r*sin(acos(m1));\n        return s1+s2-s3;\n    }\n    return 0.0;\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n/********************************************************/\nint getCrossCS(Circle c,Line s,Point *cs){\n    Point tmp[2];\n    int cnt=0;\n    int ct=getCrossCL(c,s,tmp);\n    for(int i=0;i<ct;i++){\n        if(PointOnS(tmp[i],s)) cs[cnt++]=tmp[i];\n    }\n    return cnt;\n}\n\nPoint PinS(Point *cs,int n,Line s){\n    if(n==1) return cs[0];\n    if(length(cs[0]-s.a)<length(cs[1]-s.a)) return cs[1];\n    return cs[0];\n}\n\ndouble getAngle(Point a,Point b){\n    double tmp=dot(a,b)/length(a)/length(b);\n    if(tmp<-1.0) tmp=-1.0;\n    if(1.0<tmp) tmp=1.0;\n    return acos(tmp);\n}\n\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=fabs(cross(a-c.o,b-c.o)/2);\n    if(!dcmp(atc)) return 0.0;\n    double la=length(a-c.o),lb=length(b-c.o);\n    Point cs[4];\n    if(la<c.r+EPS&&lb>c.r-EPS){\n        int ct=getCrossCS(c,Line(a,b),cs);\n        Point p=PinS(cs,ct,Line(a,b));\n        atc+=c.r*c.r*getAngle(p-c.o,b-c.o)/2;\n        atc-=fabs(cross(p-c.o,b-c.o)/2);\n    }else if(la>c.r-EPS&&lb<c.r+EPS){\n        int ct=getCrossCS(c,Line(a,b),cs);\n        Point p=PinS(cs,ct,Line(b,a));\n        atc+=c.r*c.r*getAngle(p-c.o,a-c.o)/2;\n        atc-=fabs(cross(p-c.o,a-c.o)/2);\n    }else if(la>c.r-EPS&&lb>c.r-EPS){\n        if(distPS(c.o,Line(a,b))<c.r-EPS){\n            Point rt=root(c.o,Line(a,b));\n            atc=fabs(getAreaTC(a,rt,c))+fabs(getAreaTC(rt,b,c));\n        }else atc=c.r*c.r*getAngle(a-c.o,b-c.o)/2;\n    }\n    if(cross(a-c.o,b-c.o)>0) atc=-atc;\n    return atc;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=getAreaTC(Pts[n-1],Pts[0],c);\n    for(int i=0;i<n-1;i++) apc+=getAreaTC(Pts[i],Pts[i+1],c);\n    return fabs(apc);\n}\n\n/********************************************************/\n\n\n/*----------------------三?点、?基本函数-----------------------------*/\n\nstruct Point3{\n    double x,y,z;\n    Point3(double x,double y,double z):x(x),y(y),z(z){}\n    Point3(){}\n    void Read(){ scanf(\"%lf%lf%lf\",&x,&y,&z); }\n};\n\nstruct Line3{\n    Point3 a,b;\n    Line3(Point3 a,Point3 b):a(a),b(b){}\n    Line3(){}\n    void Read(){ a.Read(); b.Read(); }\n};\nPoint3 operator +(Point3 a,Point3 b){ return Point3(a.x+b.x,a.y+b.y,a.z+b.z); }\nPoint3 operator -(Point3 a,Point3 b){ return Point3(a.x-b.x,a.y-b.y,a.z-b.z); }\ndouble operator *(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 operator *(Point3 a,double k){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator *(double k,Point3 a){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator /(Point3 a,double k){ return Point3(a.x/k,a.y/k,a.z/k); }\n\ndouble length(Point3 a){ return sqrt(a.x*a.x+a.y*a.y+a.z*a.z); }\nPoint3 unit(Point3 a){ return a/length(a); }\ndouble dot(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 cross(Point3 a,Point3 b){\n    return Point3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//混合?\ndouble Mix(Point3 a,Point3 b,Point3 c){\n    return dot(a,cross(b,c));\n}\n\n//?点距?\ndouble dist(const Point3 &a,const Point3 &b){ return length(a-b); }\n\n/*---------------------------------体?-------------------------------------*/\n\n//四面体体?\ndouble volume(double l,double n,double a,double m,double b,double c){\n    double x,y;\n    x=4*a*a*b*b*c*c-a*a*(b*b+c*c-m*m)*(b*b+c*c-m*m)-b*b*(c*c+a*a-n*n)*(c*c+a*a-n*n);\n    y=c*c*(a*a+b*b-l*l)*(a*a+b*b-l*l)-(a*a+b*b-l*l)*(b*b+c*c-m*m)*(c*c+a*a-n*n);\n    return sqrt(x-y)/12;\n}\n\ndouble volume(Point3 a,Point3 b,Point3 c,Point3 d){\n    return fabs(Mix(b-a,c-a,d-a)/6);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);//cin.tie(0);\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n#define x1 jkflwjjkfjekjfe\n#define x2 fwekwfefekfje\n\nint iter = log(100 * 100 * 10000) / log(3) + 20;\ntypedef complex<double> P;\nstruct L{\n\tP a,b;\n};\nvector<double> ax,ay;\nvector<L> ls;\ndouble R,cx,cy;\n\nbool eq(double a,double b){\n\treturn fabs(a-b) < 1e-7;\n}\nbool eq2(double a,double b){\n\treturn fabs(a-b) < 1e-8;\n}\n\npair<double,double> seg(double y){\n\tdouble x1 = +1e5;\n\tdouble x2 = -1e5;\n\tfor( auto &&l : ls){\n\t\tif( eq(l.a.imag(),y) ){\n\t\t\tx1 = min(x1,l.a.real());\n\t\t\tx2 = max(x2,l.a.real());\n\t\t}\n\t\tif( eq(l.b.imag(),y) ){\n\t\t\tx1 = min(x1,l.b.real());\n\t\t\tx2 = max(x2,l.b.real());\n\t\t}\n\t\tif( l.a.imag() + 1e-7 < y and y < l.b.imag() - 1e-7 ){\n\t\t\tP v = (l.b - l.a);\n\t\t\tP p = l.a + v * (y-l.a.imag()) / v.imag();\n\t\t\tx1 = min(x1,p.real());\n\t\t\tx2 = max(x2,p.real());\t\n\t\t}\n\t}\n\treturn {x1,x2};\n}\n\ndouble len(pair<double,double> p){\n\tif( p.first < p.second ) return p.second - p.first;\n\treturn 0;\n}\npair<double,double> merge(const pair<double,double> &a,const pair<double,double> &b){\n\treturn {max(a.first,b.first),min(a.second,b.second)};\n}\n\ndouble g(double y){\n\tif( R - abs(y-cy) < 1e-7 ) return 0;\n\t// for given y, compute the overlapped length of the circle and the polygon.\n\tdouble t = sqrt(R*R-(cy-y)*(cy-y));\n\tpair<double,double> circle_seg = {cx-t,cx+t};\n\treturn len(merge(circle_seg,seg(y)));\n}\n\ndouble simpson(double l,double r){\n\treturn (r-l)/6*(g(l)+4*g((l+r)/2)+g(r));\n}\ndouble integral(double l,double r){\n\tif( l >= r ) return 0;\n\n\tdouble m = (l+r) / 2;\n\tdouble A = simpson(l,m) + simpson(m,r);\n\tdouble B = simpson(l,r);\n\tif( eq2(A,B) ) return A;\n\telse return integral(l,m) + integral(m,r);\n}\n\ndouble f(double x,double y){\n\tcx = x;\n\tcy = y;\n\tdouble ans = 0;\n\tfor(int i = 0 ; i+1 < ay.size() ; i++){\n\t\tans += integral(max(cy-R,ay[i]),min(cy+R,ay[i+1]));\n\t}\n\treturn ans;\n}\n\ndouble search2(double y){\n\tdouble ans = 0;\n\tdouble l,r;\n\n\ttie(l,r) = seg(y);\n\n\tfor(int i = 0 ; i < iter ; i++){\n\t\tdouble a = (2*l+r) / 3;\n\t\tdouble b = (l+2*r) / 3;\n\t\tif( f(a,y) < f(b,y) ){\n\t\t\tl = a;\n\t\t}else{\n\t\t\tr = b;\n\t\t}\n\t}\n\treturn f(l,y);\n}\n\ndouble search1(){\n\tdouble ans = 0;\n\tdouble l = ay.front(), r = ay.back();\n\tfor(int i = 0 ; i < iter ; i++){\n\t\tdouble a = (2*l+r) / 3;\n\t\tdouble b = (l+2*r) / 3;\n\t\tif( search2(a) < search2(b) ){\n\t\t\tl = a;\n\t\t}else{\n\t\t\tr = b;\n\t\t}\n\t}\n\treturn search2(l);\n}\n\nint main(){\n\tint n;\n\tcin >> n >> R;\n\tvector<P> g(n+1);\n\tfor(int i = 0 ; i < n ; i++){\n\t\tdouble x,y;\n\t\tcin >> x >> y;\n\t\tg[i] = P(x,y);\n\t\tax.push_back(x);\n\t\tay.push_back(y);\n\t}\n\tg[n] = g[0];\n\t\n\tfor(int i = 0 ; i < n ; i++){\n\t\tls.push_back({g[i],g[i+1]});\n\t\tif( ls.back().a.imag() > ls.back().b.imag() ) swap(ls.back().a,ls.back().b);\n\t}\n\n\tsort(ax.begin(),ax.end());\n\tsort(ay.begin(),ay.end());\n\tax.erase(unique(ax.begin(),ax.end()),ax.end());\n\tay.erase(unique(ay.begin(),ay.end()),ay.end());\n\tprintf(\"%.10lf\\n\",search1());\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cout if (0) cout\n\n// XXX without explanation marks untested functions\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pii;\n#define pb push_back\n\n// NOT STANDART FROM HERE\n\n// area de calota 2.pi.R.h (h altura)\n// volume de calota pi.h/6 * (3r^2 + h^2)\n\n typedef double cood;\n cood eps = 1e-8;\n// tests for double were made with eps = 1e-8\n\ndouble eps_d = 1e-8; // necessary even in integer geometry, should be eps otherwise\n\nconst double pi = acos(-1.);\n\ninline ll sq (ll x)\n{ return x*x; }\ninline double sq (double x)\n{ return x*x; }\n\nstruct vec { // vector\n\t// === BASIC ===\n\tcood x, y;\n\tvec () : x(0), y(0) {}\n\tvec (cood a, cood b) : x(a), y(b) {}\n\tfriend ostream& operator<<(ostream& os, vec o);\n\n\tvec operator - (vec o)\n\t{ return vec(x - o.x, y - o.y); }\n\tvec operator + (vec o)\n\t{ return vec(x + o.x, y + o.y); }\n\tvec operator * (cood o)\n\t{ return vec(x * o, y * o); }\n\tvec operator / (cood o)\n\t{ return vec(x / o, y / o); }\n\tcood operator ^ (vec o)\n\t{ return x * o.y - y * o.x; }\n\tcood operator * (vec o)\n\t{ return x * o.x + y * o.y; }\n\n\t// positive is (*this)b is clockwise from (*this)a\n\tdouble angle (vec a, vec b)\n\t{ return atan2((a-(*this))^(b-(*this)), (a-(*this))*(b-(*this))); }\n\n\tcood sq (vec o = vec())\n\t{ return ((*this)-o)*((*this)-o); }\n\tdouble nr (vec o = vec())\n\t{ return sqrt(sq(o)); }\n\n\tcood cross (vec a, vec b) // ccw signed area (positive if this is to the left of ab)\n\t{ return (b - a) ^ ((*this) - a); }\n\tint ccw (vec a, vec b) // which side is this from ab? (1 left, 0 over, -1 right)\n\t{ cood o = cross(a, b); return (eps < o) - (o < -eps); } \n\n\tint dir (vec a, vec b) // direction of (this)a relative to (this)b (-1 opposite, 0 none, 1 same)\n\t{ cood o = ((*this) - a)*((*this) - b); return (eps < o) - (o < -eps); }\n\n\tcood inner (vec s, vec t) // (p-s)*(t-s) where p = this projected on st\n\t{ return ((*this) - s) * (t - s); }\n\tvec proj (vec s, vec t) // projection of this point over line st\n\t{ return s + (t - s)*(inner(s,t) / t.sq(s)); }\n\n\tvec rotate (double a) // rotate ccw by a (fails with ll)\n\t{ return vec(cos(a) * x - sin(a) * y, sin(a) * x + cos(a) * y); }\n\tvec rot90 () // rotate pi/2 ccw\n\t{ return vec(-y, x); }\n\n\t// === ADVANCED ===\n\t// ordering that defines the compare method\n\t// used only there, change it accordingly\n\t// sorts increasing on y and, then increasing on x\n\tbool operator < (const vec & o) const {\n\t\tif (y != o.y)\n\t\t\treturn y < o.y;\n\t\treturn x < o.x;\n\t}\n\n\t// full ordering (ccw angle from this+(1,0), distance to this)\n\t// is a < b?\n\t// PRECISION : ok with double if norm in [-1e9,5e3]\n\tbool compare (vec a, vec b) {\n\t\tif (((*this) < a) != ((*this) < b))\n\t\t\treturn (*this) < a;\n\t\tint o = ccw(a,b);\n\t\tif (o) return o > 0;\n\t\treturn a.dir((*this),b) < 0;\n\t}\n\n\t// is this inside segment st? (tip of segment included, change for dr < 0 otherwise)\n\tbool in_seg (vec s, vec t)\n\t{ return (ccw(s,t) == 0) && (dir(s,t) <= 0); }\n\n\t// squared distance from this to line defined by st\n\tdouble dist2_lin (vec s, vec t)\n\t{ return double(::sq(cross(s,t))) / t.sq(s); }\n\t// squared distance from this to segment st\n\tdouble dist2_seg (vec s, vec t) \n\t{ return s.dir((*this),t) == t.dir((*this),s) ? dist2_lin(s,t) : min(sq(s),sq(t)); }\n\n\t// is this inside (borders included) the convex polygon v of size n?\n\t// if yes, prec is the vec that this on acw order from v[0] or 0 if there is no such\n\t// if not, prec is the predecessor of this when added to poly and succ is the sucessor\n\t// p should be a vector with [0..n-1]\n\t// n should be >= 2\n\tbool in_conv_poly (vec v[], int n, const vector<int> & p, int & prec, int & succ) {\n\t\tif (nr(v[0]) <= eps) {\n\t\t\tprec = 0;\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (n == 2) {\n\t\t\tif (in_seg(v[0],v[1]))\n\t\t\t\treturn (prec = 1);\n\n\t\t\tif (ccw(v[0],v[1]) > 0) {\n\t\t\t\tprec = 1;\n\t\t\t\tsucc = 0;\n\t\t\t} else if (ccw(v[0],v[1]) < 0) {\n\t\t\t\tprec = 0;\n\t\t\t\tsucc = 1;\n\t\t\t} else {\n\t\t\t\tprec = succ = (v[0].dir((*this),v[1]) < 0);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (ccw(v[0],v[1]) > 0 || ccw(v[0],v[n-1]) < 0) {\n\t\t// case where v[0] is not removed\n\t\t\t// last diagonal before or over this\n\t\t\tint di = lower_bound(p.begin() + 1, p.end(), -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[0],v[i]) >= 0;\n\t\t\t}) - p.begin() - 1;\n\n\t\t\t// is this inside the polygon?\n\t\t\tprec = di;\n\t\t\tif (di == n-1) {\n\t\t\t// last segment\n\t\t\t\tif (ccw(v[0],v[n-1]) == 0 && ccw(v[n-2],v[n-1]) >= 0)\n\t\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t// inside otherwise\n\t\t\t\tif (ccw(v[di],v[di+1]) >= 0)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// last that stays before (or eq to) di\n\t\t\tprec = lower_bound(p.begin() + 1, p.begin() + di + 1, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i-1],v[i]) > 0;\n\t\t\t}) - p.begin() - 1;\n\n\t\t\t// first that stays after di\n\t\t\tsucc = lower_bound(p.begin() + di + 1, p.end(), -1, [this,v,n] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[(i+1)%n],v[i]) >= 0;\n\t\t\t}) - p.begin();\n\t\t\tif (succ == n) succ = 0;\n\t\t} else {\n\t\t// case where v[0] is removed\n\t\t\t// first diagonal before of over this\n\t\t\t// di is certainly not removed\n\t\t\tint di = lower_bound(p.begin() + 1, p.end() - 1, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[0],v[i]) < 0;\n\t\t\t}) - p.begin();\n\n\t\t\t// first that stays (<= di)\n\t\t\tsucc = lower_bound(p.begin(), p.begin() + di, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i+1],v[i]) >= 0;\n\t\t\t}) - p.begin();\n\n\t\t\t// last that stays (>= di)\n\t\t\tprec = lower_bound(p.begin() + di + 1, p.end(), -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i-1],v[i]) > 0;\n\t\t\t}) - p.begin() - 1;\n\t\t}\n\t\treturn 0;\n\t}\n};\nostream& operator<<(ostream& os, vec o)\n{ return os << '(' << o.x << \", \" << o.y << ')'; }\n\nstruct lin { // line\n\tcood a, b, c; // a*x + b*y = c\n\n\tlin () {}\n\tlin (cood x, cood y, cood z) : a(x), b(y), c(z) {}\n\tlin (vec s, vec t) : a(t.y - s.y), b(s.x - t.x), c(a * s.x + b * s.y) {}\n\n\tlin parll (vec p) // parallel to this through p\n\t{ return lin(a, b, a * p.x + b * p.y); }\n\tlin perp ()\n\t{ return lin(-b, a, c); }\n\n\tvec inter (lin o) {\n\t\tcood d = a * o.b - o.a * b;\n\t\tif (d < eps && -eps < d) throw 0; // parallel\n\t\treturn vec((o.b * c - b * o.c) / d, (a * o.c - o.a * c) / d);\n\t}\n};\n\nstruct cir { // circle\n\tvec c; cood r;\n\n\t// borders included\n\tbool contains (vec w)\n\t{ return c.sq(w) <= sq(r) + eps; }\n\tbool has_inter (cir o)\n\t{ return c.sq(o.c) <= sq(r + o.r) + eps; }\n\tbool has_inter_lin (vec s, vec t)\n\t{ return c.dist2_lin(s,t) <= sq(r) + eps_d; }\n\tbool has_inter_seg (vec s, vec t)\n\t{ return c.dist2_seg(s,t) <= sq(r); }\n\n\t// borders not included\n\tbool contains (cir o)\n\t{ return (o.r < r - eps && c.sq(o.c) < sq(r - o.r) - eps); }\n\n\t// ccw oriented area of arc from a to b\n\tdouble arc_area (vec a, vec b) {\n\t\tdouble ang = c.angle(a,b);\n\t\treturn r*r*ang*.5;\n\t}\n\n\t// double only\n\tpair<vec,vec> inter_pts (cir o) {\n\t\tassert(has_inter(o) && !contains(o)); // fully contained case\n\t\tdouble d = c.nr(o.c);\n\t\tdouble a = (r*r + d*d - o.r*o.r) / (2.*d); // r*cos(ans,v,c.v)\n\t\tdouble h = sqrt(r*r - a*a);\n\t\tif (h != h) h = 0;\n\t\tvec p = o.c - c;\n\t\treturn pair<vec,vec>(c + p*(a/d) + (p.rot90()*(h/d)), c + p*(a/d) - (p.rot90()*(h/d)));\n\t}\n\n\t// double only XXX careful precision\n\tpair<vec,vec> inter_pts (vec s, vec t) { \n\t\tassert(has_inter_lin(s,t));\n\t\tdouble h2 = c.dist2_lin(s,t);\n\t\tdouble d = sqrt(c.sq(t) - h2);\n\t\tif (d != d) d = 0;\n\t\tvec p = (s-t);\n\t\tvec m = t + p*(d/p.nr());\n\t\tvec m_b = t - p*(d/p.nr());\n\t\tif (m_b.sq(c) < m.sq(c))\n\t\t\tm = m_b;\n\n\t\td = sqrt(r*r - h2);\n\t\tif (d != d) d = 0;\n\t\tpair<vec,vec> res(m + p*(d/p.nr()), m - p*(d/p.nr()));\n\t\tif (res.first.sq(t) > res.second.sq(t))\n\t\t\tswap(res.first, res.second);\n\t\treturn res;\n\t}\n\n\t// double only XXX not tested\n\t// signed area of intersection of this with triangle (this.c,a,b)\n\tdouble inter (vec a, vec b) {\n\t\tcout << c << \" with \" << a << \",\" << b << \": \";\n\t\tdouble res = 0.;\n\t\tbool inv = 0;\n\t\tif (contains(b)) {\n\t\t\tswap(a,b);\n\t\t\tinv = 1;\n\t\t\tcout << \"[inv] \";\n\t\t}\n\n\t\tif (contains(b)) {\n\t\t\tcout << \"contains both\";\n\t\t\tres = c.cross(a,b)*.5;\n\t\t} else if (contains(a)) {\n\t\t\tcout << \"contains \" << a;\n\t\t\tpair<vec,vec> rt = inter_pts(a,b);\n\t\t\tcout << endl << \"[[\" << rt.first << \" \" << rt.second << endl;\n\t\t\tvec q = rt.first;\n\t\t\tif (!q.in_seg(a,b) || (a.sq(q) <= eps && rt.second.in_seg(a,b)))\n\t\t\t//if (rt.second.dist2_seg(a,b) < q.dist2_seg(a,b))\n\t\t\t\tq = rt.second;\n\t\t\tcout << \" inter at \" << q;\n\n\t\t\tres += c.cross(a,q)*.5;\n\t\t\tres += arc_area(q,b);\n\t\t} else if (has_inter_seg(a, b)) {\n\t\t\tcout << \"inter seg\";\n\t\t\tpair<vec,vec> rt = inter_pts(b,a);\n\n\t\t\tres += arc_area(a,rt.first);\n\t\t\tres += c.cross(rt.first,rt.second)*.5;\n\t\t\tres += arc_area(rt.second,b);\n\t\t} else {\n\t\t\tcout << \"arc only\";\n\t\t\tres += arc_area(a,b);\n\t\t}\n\n\t\tif (inv) res = -res;\n\t\tcout << \" = \" << res << endl;\n\t\treturn res;\n\t}\n\n\t// double only XXX not tested\n\t// signed area of intersection of this with polygon\n\tdouble inter (vector<vec> & p) {\n\t\tdouble res = 0;\n\t\tfor (int i = 0; i < p.size(); i++)\n\t\t\tres += inter(p[i],p[(i+1)%p.size()]);\n\t\treturn res;\n\t}\n};\n\n// do the segments ab and cd intersect? (borders included) XXX\nbool inter_seg (vec a, vec b, vec c, vec d) {\n\tif (a.in_seg(c, d) || b.in_seg(c, d) || c.in_seg(a, b) || d.in_seg(a, b))\n\t\treturn true;\n\treturn (c.ccw(a, b) * d.ccw(a, b) == -1 && a.ccw(c, d) * b.ccw(c, d) == -1);\n}\n\n// squared distance from segments ab and cd XXX\ndouble dist2_seg (vec a, vec b, vec c, vec d)\n{ return inter_seg(a,b,c,d) ? 0. : min({ a.dist2_seg(c,d), b.dist2_seg(c,d), c.dist2_seg(a,b), d.dist2_seg(a,b) }); }\n\n// brd = do points on the border belong to convex?\n// computes convex hull of given vector (inplace)\n// returns size of convex hull\nint graham (vec v[], int n, int brd) {\n\tfor (int i = 1; i < n; i++) {\n\t\tif (v[i].x < v[0].x || (v[i].x == v[0].x && v[i].y < v[0].y))\n\t\t\tswap(v[0], v[i]);\n\t}\n\n\tsort(v+1, v+n, [v] (vec a, vec b) {\n\t\tint o = b.ccw(v[0], a);\n\t\tif (o) return (o == 1);\n\t\treturn v[0].sq(a) < v[0].sq(b);\n\t});\n\n\tif (brd) {\n\t\tint s = n-1;\n\t\twhile (s > 1 && v[s].ccw(v[s-1],v[0]) == 0)\n\t\t\ts--;\n\t\tfor (int i = s; i < n - 1 - (i - s); i++)\n\t\t\tswap(v[i], v[n-1-(i-s)]);\n\t}\n\n\tint s = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s && v[s-1].x == v[i].x && v[s-1].y == v[i].y) continue;\n\t\twhile (s >= 2 && v[s-1].ccw(v[s-2],v[i]) >= brd)\n\t\t\ts--;\n\t\tv[s++] = v[i];\n\t}\n\n\treturn s;\n}\n\nconst int N = 1e2+7;\n\nint n;\ndouble r;\nvector<vec> v;\ndouble x[2], y[2];\n\ndouble solve (double x) {\n\tdouble lo = 200, hi = -100.;\n\tfor (int i = 0; i < n; i++) {\n\t\tint j = (i+1)%n;\n\t\tlin ln(v[i],v[j]);\n\t\tvec it(x, (ln.c - ln.a*x)/ln.b);\n\t\tcout << it << \" \";\n\t\tif (it.y == it.y && abs(it.y) < 200) {\n\t\t\tif (abs(ln.b) > eps) {\n\t\t\t\tlo = min(lo, it.y);\n\t\t\t\thi = max(hi, it.y);\n\t\t\t}\n\t\t}\n\n\t\tif (abs(v[i].x - x) <= eps_d) {\n\t\t\tcout << v[i] << \"! \";\n\t\t\tlo = min(lo, v[i].y);\n\t\t\thi = max(hi, v[i].y);\n\t\t}\n\t}\n\thi = min(hi, 200.); lo = max(lo, -100.);\n\tcout << x << \" [\" << lo << \" \" << hi << \"]\" << endl;\n\n\tint ts = 60;\n\twhile (ts--) {\n\t\tdouble q1 = (lo+lo+hi)/3;\n\t\tdouble q2 = (lo+hi+hi)/3;\n\n\t\tdouble r1 = abs(cir({ vec(x,q1), r }).inter(v));\n\t\tdouble r2 = abs(cir({ vec(x,q2), r }).inter(v));\n\n\t\tif (r1 < r2)\n\t\t\tlo = q1;\n\t\telse\n\t\t\thi = q2;\n\t}\n\n\treturn abs(cir({ vec(x,lo), r }).inter(v));\n}\n\nint main () {\n\n\twhile (scanf(\"%d %lf\", &n, &r) != EOF) {\n\t\tcout << n << endl;\n\t\tv = vector<vec>(n);\n\t\t\n\t\tx[0] = 200;\n\t\tx[1] = -100;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%lf %lf\", &v[i].x, &v[i].y);\n\t\t\tcout << v[i] << \" \";\n\n\t\t\tx[0] = min(x[0],v[i].x);\n\t\t\tx[1] = max(x[1],v[i].x);\n\t\t}\n\t\tcout << endl;\n\n\t\tdouble lo = x[0], hi = x[1];\n\t\t//int ts = 60;\n\t\tint ts = 50;\n\t\twhile (ts--) {\n\t\t\tdouble q1 = (lo+lo+hi)/3;\n\t\t\tdouble q2 = (lo+hi+hi)/3;\n\t\t\t\n\t\t\tif (solve(q1) < solve(q2))\n\t\t\t\tlo = q1;\n\t\t\telse\n\t\t\t\thi = q2;\n\t\t}\n\n\t\tdouble res = solve(lo);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tres = max(res, abs(cir({ v[i], r }).inter(v)));\n\n\t\tprintf(\"%.20f\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//????????????????±±??????????????????\n#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\ntypedef complex<double> P;\n\nint n, r;\nP p[11];\nconst double PAI = 3.14159265358979;\n\t\ndouble dot(P a, P b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(P a, P b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dist(P s, P e, P p) {\n\tif (dot(p - s, e - s) < 0) return abs(p - s);\n\tif (dot(p - e, s - e) < 0) return abs(p - e);\n\treturn abs(cross(e - s, p - s) / abs(e - s));\n}\n\n//??´???a->b??¨???c(?????????r)?????????\nvector<P> kotenS(P a, P b, P c) {\n\ta -= c;\n\tb -= c;\n\tdouble d = dist(a, b, P(0, 0));\n\tif (d > r) return vector<P>();\n\t\n\tP t = (b - a) / abs(b - a);\n\tP u = t * P(0, 1);\n\tif (cross(a, b) > 0) u = -u;\n\t\n\tP p1 = d * u + sqrt(r * r - d * d) * t;\n\tP p2 = d * u - sqrt(r * r - d * d) * t;\n\tp1 += c;\n\tp2 += c;\n\t\n\tvector<P> ret;\n\tret.push_back(p1);\n\tret.push_back(p2);\n\treturn ret;\n}\n\n//??????a->b??¨???c(?????????r)?????????\nvector<P> koten(P a, P b, P c) {\n\tvector<P> res = kotenS(a, b, c);\n\tvector<P> ret;\n\tfor (int i = 0; i < res.size(); i++) {\n\t\tif (dot(res[i] - a, b - res[i]) >= 0) {\n\t\t\tret.push_back(res[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\n//???c???????????¨??????????§??????????\nvoid angle_sort(vector<P> &ps, P c) {\n\tfor (int i = 0; i < ps.size() - 1; i++) {\n\t\tfor (int j = ps.size() - 1; j > i; j--) {\n\t\t\tP t = ps[j - 1] - c;\n\t\t\tP u = ps[j] - c;\n\t\t\tif (atan2(t.imag(), t.real()) > atan2(u.imag(), u.real())) {\n\t\t\t\tswap(ps[j - 1], ps[j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//???a???????§???¢????????¨??????????????????. ?¢????????????????.\nbool isCover(P a) {\n\tbool flag = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tP t = p[i] - a;\n\t\tP u = p[i + 1] - a;\n\t\tif (t.imag() > u.imag()) swap(t, u);\n\t\tif (t.imag() < 0 && 0 < u.imag() && cross(t, u) > 0) flag = !flag;\n\t}\n\treturn flag;\n}\n\n//?¬????????????¢???????¨????\ndouble getArea(P a, P b, P c) {\n\tdouble eps = 1e-10;\n\t\n\tP mid = (a + b) * 0.5;\n\tP t = (mid - c) / abs(mid - c); t *= 1e-9; t += mid;\n\t\n\tif (norm(c - a) >= r * r - eps && norm(c - b) >= r * r - eps && isCover(t)) {\n\t\t//??????\n\t\ta -= c;\n\t\tb -= c;\n\t\tdouble theta = arg(b / a);\n\t\treturn theta * r * r * 0.5;\n\t}\n\t//3?§???¢\n\treturn cross(a - c, b - c) * 0.5;\n}\n\n//???????????????c?????¨??????, ??±?????¨????????¢???????±???????.\n//c??????????§???¢????????¨???????????¨??????.\ndouble area(P c) {\n\tvector<P> ps;\n\t\n\t//?????¨?????????\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<P> res = koten(p[i], p[i + 1], c);\n\t\tfor (int j = 0; j < res.size(); j++) {\n\t\t\tps.push_back(res[j]);\n\t\t}\n\t}\n\tif (ps.size() == 0) { return 0; }\n\t\n\t//????????????????????????\n\tdouble eps = 1e-10;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (norm(c - p[i]) <= r * r - eps) {\n\t\t\tps.push_back(p[i]);\n\t\t}\n\t}\n\t\n\tangle_sort(ps, c);\n\tps.push_back(ps[0]);\n\t\n\tdouble ret = 0;\n\tfor (int i = 0; i < ps.size() - 1; i++) {\n\t\tret += getArea(ps[i], ps[i + 1], c);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint i;\n\t\n\tcin >> n >> r;\n\tfor (i = 0; i < n; i++) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = P(x, y);\n\t}\n\tp[n] = p[0];\n\t\n\tP c = P(0, 0);\n\tfor (i = 0; i < n; i++) { c += p[i]; }\n\tc /= n;\n\t\n\t//??¢?´¢\n\tconst int LoopNum = 10000;\n\tdouble maxArea = area(c);\n\tfor (i = 0; i < LoopNum; i++) {\n\t\tdouble dist = exp(-i / 1000.0);\n\t\tP dc = dist * exp(2 * PAI * (rand() % 1000) / 1000.0 * P(0, 1));\n\t\tif (maxArea < area(c + dc)) {\n\t\t\tmaxArea = area(c + dc);\n\t\t\tc = c + dc;\n\t\t}\n\t}\n\t\n\tprintf(\"%.14f\\n\", maxArea);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cout if (1) cout\n\n// XXX without explanation marks untested functions\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pii;\n#define pb push_back\n\n// NOT STANDART FROM HERE\n\n// area de calota 2.pi.R.h (h altura)\n// volume de calota pi.h/6 * (3r^2 + h^2)\n\n typedef double cood;\n cood eps = 1e-8;\n// tests for double were made with eps = 1e-8\n\ndouble eps_d = 1e-8; // necessary even in integer geometry, should be eps otherwise\n\nconst double pi = acos(-1.);\n\ninline ll sq (ll x)\n{ return x*x; }\ninline double sq (double x)\n{ return x*x; }\n\nstruct vec { // vector\n\t// === BASIC ===\n\tcood x, y;\n\tvec () : x(0), y(0) {}\n\tvec (cood a, cood b) : x(a), y(b) {}\n\tfriend ostream& operator<<(ostream& os, vec o);\n\n\tvec operator - (vec o)\n\t{ return vec(x - o.x, y - o.y); }\n\tvec operator + (vec o)\n\t{ return vec(x + o.x, y + o.y); }\n\tvec operator * (cood o)\n\t{ return vec(x * o, y * o); }\n\tvec operator / (cood o)\n\t{ return vec(x / o, y / o); }\n\tcood operator ^ (vec o)\n\t{ return x * o.y - y * o.x; }\n\tcood operator * (vec o)\n\t{ return x * o.x + y * o.y; }\n\n\t// positive is (*this)b is clockwise from (*this)a\n\tdouble angle (vec a, vec b)\n\t{ return atan2((a-(*this))^(b-(*this)), (a-(*this))*(b-(*this))); }\n\n\tcood sq (vec o = vec())\n\t{ return ((*this)-o)*((*this)-o); }\n\tdouble nr (vec o = vec())\n\t{ return sqrt(sq(o)); }\n\n\tcood cross (vec a, vec b) // ccw signed area (positive if this is to the left of ab)\n\t{ return (b - a) ^ ((*this) - a); }\n\tint ccw (vec a, vec b) // which side is this from ab? (1 left, 0 over, -1 right)\n\t{ cood o = cross(a, b); return (eps < o) - (o < -eps); } \n\n\tint dir (vec a, vec b) // direction of (this)a relative to (this)b (-1 opposite, 0 none, 1 same)\n\t{ cood o = ((*this) - a)*((*this) - b); return (eps < o) - (o < -eps); }\n\n\tcood inner (vec s, vec t) // (p-s)*(t-s) where p = this projected on st\n\t{ return ((*this) - s) * (t - s); }\n\tvec proj (vec s, vec t) // projection of this point over line st\n\t{ return s + (t - s)*(inner(s,t) / t.sq(s)); }\n\n\tvec rotate (double a) // rotate ccw by a (fails with ll)\n\t{ return vec(cos(a) * x - sin(a) * y, sin(a) * x + cos(a) * y); }\n\tvec rot90 () // rotate pi/2 ccw\n\t{ return vec(-y, x); }\n\n\t// === ADVANCED ===\n\t// ordering that defines the compare method\n\t// used only there, change it accordingly\n\t// sorts increasing on y and, then increasing on x\n\tbool operator < (const vec & o) const {\n\t\tif (y != o.y)\n\t\t\treturn y < o.y;\n\t\treturn x < o.x;\n\t}\n\n\t// full ordering (ccw angle from this+(1,0), distance to this)\n\t// is a < b?\n\t// PRECISION : ok with double if norm in [-1e9,5e3]\n\tbool compare (vec a, vec b) {\n\t\tif (((*this) < a) != ((*this) < b))\n\t\t\treturn (*this) < a;\n\t\tint o = ccw(a,b);\n\t\tif (o) return o > 0;\n\t\treturn a.dir((*this),b) < 0;\n\t}\n\n\t// is this inside segment st? (tip of segment included, change for dr < 0 otherwise)\n\tbool in_seg (vec s, vec t)\n\t{ return (ccw(s,t) == 0) && (dir(s,t) <= 0); }\n\n\t// squared distance from this to line defined by st\n\tdouble dist2_lin (vec s, vec t)\n\t{ return double(::sq(cross(s,t))) / t.sq(s); }\n\t// squared distance from this to segment st\n\tdouble dist2_seg (vec s, vec t) \n\t{ return s.dir((*this),t) == t.dir((*this),s) ? dist2_lin(s,t) : min(sq(s),sq(t)); }\n\n\t// is this inside (borders included) the convex polygon v of size n?\n\t// if yes, prec is the vec that this on acw order from v[0] or 0 if there is no such\n\t// if not, prec is the predecessor of this when added to poly and succ is the sucessor\n\t// p should be a vector with [0..n-1]\n\t// n should be >= 2\n\tbool in_conv_poly (vec v[], int n, const vector<int> & p, int & prec, int & succ) {\n\t\tif (nr(v[0]) <= eps) {\n\t\t\tprec = 0;\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (n == 2) {\n\t\t\tif (in_seg(v[0],v[1]))\n\t\t\t\treturn (prec = 1);\n\n\t\t\tif (ccw(v[0],v[1]) > 0) {\n\t\t\t\tprec = 1;\n\t\t\t\tsucc = 0;\n\t\t\t} else if (ccw(v[0],v[1]) < 0) {\n\t\t\t\tprec = 0;\n\t\t\t\tsucc = 1;\n\t\t\t} else {\n\t\t\t\tprec = succ = (v[0].dir((*this),v[1]) < 0);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (ccw(v[0],v[1]) > 0 || ccw(v[0],v[n-1]) < 0) {\n\t\t// case where v[0] is not removed\n\t\t\t// last diagonal before or over this\n\t\t\tint di = lower_bound(p.begin() + 1, p.end(), -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[0],v[i]) >= 0;\n\t\t\t}) - p.begin() - 1;\n\n\t\t\t// is this inside the polygon?\n\t\t\tprec = di;\n\t\t\tif (di == n-1) {\n\t\t\t// last segment\n\t\t\t\tif (ccw(v[0],v[n-1]) == 0 && ccw(v[n-2],v[n-1]) >= 0)\n\t\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t// inside otherwise\n\t\t\t\tif (ccw(v[di],v[di+1]) >= 0)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// last that stays before (or eq to) di\n\t\t\tprec = lower_bound(p.begin() + 1, p.begin() + di + 1, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i-1],v[i]) > 0;\n\t\t\t}) - p.begin() - 1;\n\n\t\t\t// first that stays after di\n\t\t\tsucc = lower_bound(p.begin() + di + 1, p.end(), -1, [this,v,n] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[(i+1)%n],v[i]) >= 0;\n\t\t\t}) - p.begin();\n\t\t\tif (succ == n) succ = 0;\n\t\t} else {\n\t\t// case where v[0] is removed\n\t\t\t// first diagonal before of over this\n\t\t\t// di is certainly not removed\n\t\t\tint di = lower_bound(p.begin() + 1, p.end() - 1, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[0],v[i]) < 0;\n\t\t\t}) - p.begin();\n\n\t\t\t// first that stays (<= di)\n\t\t\tsucc = lower_bound(p.begin(), p.begin() + di, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i+1],v[i]) >= 0;\n\t\t\t}) - p.begin();\n\n\t\t\t// last that stays (>= di)\n\t\t\tprec = lower_bound(p.begin() + di + 1, p.end(), -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i-1],v[i]) > 0;\n\t\t\t}) - p.begin() - 1;\n\t\t}\n\t\treturn 0;\n\t}\n};\nostream& operator<<(ostream& os, vec o)\n{ return os << '(' << o.x << \", \" << o.y << ')'; }\n\nstruct lin { // line\n\tcood a, b, c; // a*x + b*y = c\n\n\tlin () {}\n\tlin (cood x, cood y, cood z) : a(x), b(y), c(z) {}\n\tlin (vec s, vec t) : a(t.y - s.y), b(s.x - t.x), c(a * s.x + b * s.y) {}\n\n\tlin parll (vec p) // parallel to this through p\n\t{ return lin(a, b, a * p.x + b * p.y); }\n\tlin perp ()\n\t{ return lin(-b, a, c); }\n\n\tvec inter (lin o) {\n\t\tcood d = a * o.b - o.a * b;\n\t\tif (d < eps && -eps < d) throw 0; // parallel\n\t\treturn vec((o.b * c - b * o.c) / d, (a * o.c - o.a * c) / d);\n\t}\n};\n\nstruct cir { // circle\n\tvec c; cood r;\n\n\t// borders included\n\tbool contains (vec w)\n\t{ return c.sq(w) <= sq(r) + eps; }\n\tbool has_inter (cir o)\n\t{ return c.sq(o.c) <= sq(r + o.r) + eps; }\n\tbool has_inter_lin (vec s, vec t)\n\t{ return c.dist2_lin(s,t) <= sq(r) + eps_d; }\n\tbool has_inter_seg (vec s, vec t)\n\t{ return c.dist2_seg(s,t) <= sq(r) + eps_d; }\n\n\t// borders not included\n\tbool contains (cir o)\n\t{ return (o.r < r - eps && c.sq(o.c) < sq(r - o.r) - eps); }\n\n\t// ccw area of arc from ca to cb\n\tdouble arc_area (vec a, vec b) {\n\t\tdouble ang = c.angle(a,b);\n\t\treturn r*r*ang*.5;\n\t}\n\n\t// double only\n\tpair<vec,vec> inter_pts (cir o) {\n\t\tassert(has_inter(o) && !contains(o)); // fully contained case\n\t\tdouble d = c.nr(o.c);\n\t\tdouble a = (r*r + d*d - o.r*o.r) / (2.*d); // r*cos(ans,v,c.v)\n\t\tdouble h = sqrt(r*r - a*a);\n\t\tif (h != h) h = 0;\n\t\tvec p = o.c - c;\n\t\treturn pair<vec,vec>(c + p*(a/d) + (p.rot90()*(h/d)), c + p*(a/d) - (p.rot90()*(h/d)));\n\t}\n\n\t// double only XXX careful precision\n\tpair<vec,vec> inter_pts (vec s, vec t) { \n\t\tassert(has_inter_lin(s,t));\n\t\tdouble h2 = c.dist2_lin(s,t);\n\t\tdouble d = sqrt(c.sq(t) - h2);\n\t\tif (d != d) d = 0;\n\t\tvec p = (s-t);\n\t\tvec m = t + p*(d/p.nr());\n\t\tvec m_b = t - p*(d/p.nr());\n\t\tif (m_b.sq(c) < m.sq(c))\n\t\t\tm = m_b;\n\n\t\td = sqrt(r*r - h2);\n\t\tif (d != d) d = 0;\n\t\treturn pair<vec,vec>(m + p*(d/p.nr()), m - p*(d/p.nr()));\n\t}\n\n\t// double only XXX not tested\n\t// signed area of intersection of this with triangle (this.c,a,b)\n\tdouble inter (vec a, vec b) {\n\t\tdouble res = 0.; bool inv = 0;\n\t\tif (contains(b)) {\n\t\t\tswap(a,b);\n\t\t\tinv = 1;\n\t\t}\n\n\t\tif (contains(b)) {\n\t\t\tres = c.cross(a,b)*.5;\n\t\t} else if (contains(a)) {\n\t\t\tpair<vec,vec> rt = inter_pts(a,b);\n\t\t\tvec q = rt.first;\n\t\t\tif (!q.in_seg(a,b) || (a.sq(q) <= eps && rt.second.in_seg(a,b)))\n\t\t\t\tq = rt.second;\n\t\t\tres += c.cross(a,q)*.5;\n\t\t\tres += arc_area(q,b);\n\t\t} else if (has_inter_seg(a,b)) {\n\t\t\tpair<vec,vec> rt = inter_pts(a,b);\n\t\t\tif (a.sq(rt.second) < a.sq(rt.first))\n\t\t\t\tswap(rt.first,rt.second);\n\t\t\tres += arc_area(a,rt.first);\n\t\t\tres += c.cross(rt.first,rt.second)*.5;\n\t\t\tres += arc_area(rt.second,b);\n\t\t} else {\n\t\t\tres += arc_area(a,b);\n\t\t}\n\n\t\tif (inv) return -res;\n\t\treturn res;\n\t}\n\n\t// double only XXX not tested\n\t// signed area of intersection of this with polygon\n\tdouble inter (vector<vec> & p) {\n\t\tdouble res = 0;\n\t\tfor (int i = 0; i < p.size(); i++)\n\t\t\tres += inter(p[i],p[(i+1)%p.size()]);\n\t\treturn res;\n\t}\n};\n\n// do the segments ab and cd intersect? (borders included) XXX\nbool inter_seg (vec a, vec b, vec c, vec d) {\n\tif (a.in_seg(c, d) || b.in_seg(c, d) || c.in_seg(a, b) || d.in_seg(a, b))\n\t\treturn true;\n\treturn (c.ccw(a, b) * d.ccw(a, b) == -1 && a.ccw(c, d) * b.ccw(c, d) == -1);\n}\n\n// squared distance from segments ab and cd XXX\ndouble dist2_seg (vec a, vec b, vec c, vec d)\n{ return inter_seg(a,b,c,d) ? 0. : min({ a.dist2_seg(c,d), b.dist2_seg(c,d), c.dist2_seg(a,b), d.dist2_seg(a,b) }); }\n\n// brd = do points on the border belong to convex?\n// computes convex hull of given vector (inplace)\n// returns size of convex hull\nint graham (vec v[], int n, int brd) {\n\tfor (int i = 1; i < n; i++) {\n\t\tif (v[i].x < v[0].x || (v[i].x == v[0].x && v[i].y < v[0].y))\n\t\t\tswap(v[0], v[i]);\n\t}\n\n\tsort(v+1, v+n, [v] (vec a, vec b) {\n\t\tint o = b.ccw(v[0], a);\n\t\tif (o) return (o == 1);\n\t\treturn v[0].sq(a) < v[0].sq(b);\n\t});\n\n\tif (brd) {\n\t\tint s = n-1;\n\t\twhile (s > 1 && v[s].ccw(v[s-1],v[0]) == 0)\n\t\t\ts--;\n\t\tfor (int i = s; i < n - 1 - (i - s); i++)\n\t\t\tswap(v[i], v[n-1-(i-s)]);\n\t}\n\n\tint s = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s && v[s-1].x == v[i].x && v[s-1].y == v[i].y) continue;\n\t\twhile (s >= 2 && v[s-1].ccw(v[s-2],v[i]) >= brd)\n\t\t\ts--;\n\t\tv[s++] = v[i];\n\t}\n\n\treturn s;\n}\n\nconst int N = 1e2+7;\n\nint n;\ndouble r;\nvector<vec> v;\ndouble x[2], y[2];\n\ndouble solve (double x) {\n\tdouble lo = 200, hi = -100.;\n\tfor (int i = 0; i < n; i++) {\n\t\tint j = (i+1)%n;\n\t\tlin ln(v[i],v[j]);\n\t\tvec it(x, (ln.c - ln.a*x)/ln.b);\n\t\tif (it.in_seg(v[i],v[j]) && it.y == it.y && abs(it.y) < 200) {\n\t\t\tlo = min(lo, it.y);\n\t\t\thi = max(hi, it.y);\n\t\t}\n\n\t\tif (abs(v[i].x - x) <= eps_d) {\n\t\t\tlo = min(lo, v[i].y);\n\t\t\thi = max(hi, v[i].y);\n\t\t}\n\t}\n\thi = min(hi, 200.); lo = max(lo, -100.);\n\n\tint ts = 60;\n\twhile (ts--) {\n\t\tdouble q1 = (lo+lo+hi)/3;\n\t\tdouble q2 = (lo+hi+hi)/3;\n\n\t\tdouble r1 = abs(cir({ vec(x,q1), r }).inter(v));\n\t\tdouble r2 = abs(cir({ vec(x,q2), r }).inter(v));\n\n\t\tif (r1 < r2)\n\t\t\tlo = q1;\n\t\telse\n\t\t\thi = q2;\n\t}\n\n\treturn abs(cir({ vec(x,lo), r }).inter(v));\n}\n\nint main () {\n\n\twhile (scanf(\"%d %lf\", &n, &r) != EOF) {\n\t\tv = vector<vec>(n);\n\t\t\n\t\tx[0] = 200;\n\t\tx[1] = -100;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%lf %lf\", &v[i].x, &v[i].y);\n\n\t\t\tx[0] = min(x[0],v[i].x);\n\t\t\tx[1] = max(x[1],v[i].x);\n\t\t}\n\n\t\tdouble lo = x[0], hi = x[1];\n\t\t//int ts = 60;\n\t\tint ts = 50;\n\t\twhile (ts--) {\n\t\t\tdouble q1 = (lo+lo+hi)/3;\n\t\t\tdouble q2 = (lo+hi+hi)/3;\n\t\t\t\n\t\t\tif (solve(q1) < solve(q2))\n\t\t\t\tlo = q1;\n\t\t\telse\n\t\t\t\thi = q2;\n\t\t}\n\n\t\tdouble res = solve(lo);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tres = max(res, abs(cir({ v[i], r }).inter(v)));\n\n\t\tprintf(\"%.20f\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 400\n#define linf 1e18\n#define eps (1e-9)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Circle c,Point p){\n  if(abs(c.c-p)-c.r<-eps)return true;\n  return false;\n}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nbool intersect(Circle c,Segment s){\n  if(getDistanceSP(s,c.c)-c.r<-eps)return true;\n  return false;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  return acos(tmp)*180.0/pi;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nPoint getCrossPointSC(Circle c,Segment s){\n  Point res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(ccw(s.p1,s.p2,pp.f)==0){\n    res=pp.f;\n    if(ccw(s.p1,s.p2,pp.s)==0 && abs(s.p1-pp.s)<abs(s.p1-pp.f))res=pp.s;\n  }\n  else res=pp.s;\n  return res;\n}\n\ndouble getCommonAreaTC(Point a,Point b,Circle c){\n  double res=abs(cross(a-c.c,b-c.c)/2.0);\n  if(equals(0.0,res))return 0.0;\n  if(in(c,a) && !in(c,b)){\n    Point p1=getCrossPointSC(c,Segment(b,a));\n    Point p2=getCrossPointSC(c,Segment(b,c.c)); \n    res+=(c.r*c.r*pi)*(getAngle(p1-c.c,p2-c.c)/360.0);\n    res-=abs(cross(p1-c.c,p2-c.c)/2.0);\n    res-=abs(cross(p2-b,p1-b)/2.0);\n  }\n  else if(!in(c,a) && in(c,b)){\n    Point p1=getCrossPointSC(c,Segment(a,c.c));\n    Point p2=getCrossPointSC(c,Segment(a,b));\n    res+=(c.r*c.r*pi)*(getAngle(p1-c.c,p2-c.c)/360.0);\n    res-=abs(cross(p1-c.c,p2-c.c)/2.0);\n    res-=abs(cross(p2-a,p1-a)/2.0);\n  }\n  else if(!in(c,a) && !in(c,b)){\n    if(intersect(c,Segment(a,b))){\n      pair<Point,Point> pp=getCrossPoints(c,Segment(a,b));\n      Point m=pp.f+(pp.s-pp.f)/2.0;\n      res=abs(getCommonAreaTC(a,m,c))+abs(getCommonAreaTC(m,b,c));\n    }\n    else res=(c.r*c.r*pi)*(getAngle(a-c.c,b-c.c)/360.0);\n  }\n  if(cross(a-c.c,b-c.c)<0.0)res=-res;\n  return res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  int n=p.size();\n  FOR(i,0,n)res+=getCommonAreaTC(p[i],p[(i+1)%n],c);\n  return abs(res);\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,50){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res2-res1<-eps)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*R,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=inf;\n    FOR(k,0,50){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res2-res1<-eps)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*R));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cout if (0) cout\n\n// XXX without explanation marks untested functions\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pii;\n#define pb push_back\n\n// NOT STANDART FROM HERE\n\n// area de calota 2.pi.R.h (h altura)\n// volume de calota pi.h/6 * (3r^2 + h^2)\n\n typedef double cood;\n cood eps = 1e-8;\n// tests for double were made with eps = 1e-8\n\ndouble eps_d = 1e-8; // necessary even in integer geometry, should be eps otherwise\n\nconst double pi = acos(-1.);\n\ninline ll sq (ll x)\n{ return x*x; }\ninline double sq (double x)\n{ return x*x; }\n\nstruct vec { // vector\n\t// === BASIC ===\n\tcood x, y;\n\tvec () : x(0), y(0) {}\n\tvec (cood a, cood b) : x(a), y(b) {}\n\tfriend ostream& operator<<(ostream& os, vec o);\n\n\tvec operator - (vec o)\n\t{ return vec(x - o.x, y - o.y); }\n\tvec operator + (vec o)\n\t{ return vec(x + o.x, y + o.y); }\n\tvec operator * (cood o)\n\t{ return vec(x * o, y * o); }\n\tvec operator / (cood o)\n\t{ return vec(x / o, y / o); }\n\tcood operator ^ (vec o)\n\t{ return x * o.y - y * o.x; }\n\tcood operator * (vec o)\n\t{ return x * o.x + y * o.y; }\n\n\t// positive is (*this)b is clockwise from (*this)a\n\tdouble angle (vec a, vec b)\n\t{ return atan2((a-(*this))^(b-(*this)), (a-(*this))*(b-(*this))); }\n\n\tcood sq (vec o = vec())\n\t{ return ((*this)-o)*((*this)-o); }\n\tdouble nr (vec o = vec())\n\t{ return sqrt(sq(o)); }\n\n\tcood cross (vec a, vec b) // ccw signed area (positive if this is to the left of ab)\n\t{ return (b - a) ^ ((*this) - a); }\n\tint ccw (vec a, vec b) // which side is this from ab? (1 left, 0 over, -1 right)\n\t{ cood o = cross(a, b); return (eps < o) - (o < -eps); } \n\n\tint dir (vec a, vec b) // direction of (this)a relative to (this)b (-1 opposite, 0 none, 1 same)\n\t{ cood o = ((*this) - a)*((*this) - b); return (eps < o) - (o < -eps); }\n\n\tcood inner (vec s, vec t) // (p-s)*(t-s) where p = this projected on st\n\t{ return ((*this) - s) * (t - s); }\n\tvec proj (vec s, vec t) // projection of this point over line st\n\t{ return s + (t - s)*(inner(s,t) / t.sq(s)); }\n\n\tvec rotate (double a) // rotate ccw by a (fails with ll)\n\t{ return vec(cos(a) * x - sin(a) * y, sin(a) * x + cos(a) * y); }\n\tvec rot90 () // rotate pi/2 ccw\n\t{ return vec(-y, x); }\n\n\t// === ADVANCED ===\n\t// ordering that defines the compare method\n\t// used only there, change it accordingly\n\t// sorts increasing on y and, then increasing on x\n\tbool operator < (const vec & o) const {\n\t\tif (y != o.y)\n\t\t\treturn y < o.y;\n\t\treturn x < o.x;\n\t}\n\n\t// full ordering (ccw angle from this+(1,0), distance to this)\n\t// is a < b?\n\t// PRECISION : ok with double if norm in [-1e9,5e3]\n\tbool compare (vec a, vec b) {\n\t\tif (((*this) < a) != ((*this) < b))\n\t\t\treturn (*this) < a;\n\t\tint o = ccw(a,b);\n\t\tif (o) return o > 0;\n\t\treturn a.dir((*this),b) < 0;\n\t}\n\n\t// is this inside segment st? (tip of segment included, change for dr < 0 otherwise)\n\tbool in_seg (vec s, vec t)\n\t{ return (ccw(s,t) == 0) && (dir(s,t) <= 0); }\n\n\t// squared distance from this to line defined by st\n\tdouble dist2_lin (vec s, vec t)\n\t{ return double(::sq(cross(s,t))) / t.sq(s); }\n\t// squared distance from this to segment st\n\tdouble dist2_seg (vec s, vec t) \n\t{ return s.dir((*this),t) == t.dir((*this),s) ? dist2_lin(s,t) : min(sq(s),sq(t)); }\n\n\t// is this inside (borders included) the convex polygon v of size n?\n\t// if yes, prec is the vec that this on acw order from v[0] or 0 if there is no such\n\t// if not, prec is the predecessor of this when added to poly and succ is the sucessor\n\t// p should be a vector with [0..n-1]\n\t// n should be >= 2\n\tbool in_conv_poly (vec v[], int n, const vector<int> & p, int & prec, int & succ) {\n\t\tif (nr(v[0]) <= eps) {\n\t\t\tprec = 0;\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (n == 2) {\n\t\t\tif (in_seg(v[0],v[1]))\n\t\t\t\treturn (prec = 1);\n\n\t\t\tif (ccw(v[0],v[1]) > 0) {\n\t\t\t\tprec = 1;\n\t\t\t\tsucc = 0;\n\t\t\t} else if (ccw(v[0],v[1]) < 0) {\n\t\t\t\tprec = 0;\n\t\t\t\tsucc = 1;\n\t\t\t} else {\n\t\t\t\tprec = succ = (v[0].dir((*this),v[1]) < 0);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (ccw(v[0],v[1]) > 0 || ccw(v[0],v[n-1]) < 0) {\n\t\t// case where v[0] is not removed\n\t\t\t// last diagonal before or over this\n\t\t\tint di = lower_bound(p.begin() + 1, p.end(), -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[0],v[i]) >= 0;\n\t\t\t}) - p.begin() - 1;\n\n\t\t\t// is this inside the polygon?\n\t\t\tprec = di;\n\t\t\tif (di == n-1) {\n\t\t\t// last segment\n\t\t\t\tif (ccw(v[0],v[n-1]) == 0 && ccw(v[n-2],v[n-1]) >= 0)\n\t\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t// inside otherwise\n\t\t\t\tif (ccw(v[di],v[di+1]) >= 0)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// last that stays before (or eq to) di\n\t\t\tprec = lower_bound(p.begin() + 1, p.begin() + di + 1, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i-1],v[i]) > 0;\n\t\t\t}) - p.begin() - 1;\n\n\t\t\t// first that stays after di\n\t\t\tsucc = lower_bound(p.begin() + di + 1, p.end(), -1, [this,v,n] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[(i+1)%n],v[i]) >= 0;\n\t\t\t}) - p.begin();\n\t\t\tif (succ == n) succ = 0;\n\t\t} else {\n\t\t// case where v[0] is removed\n\t\t\t// first diagonal before of over this\n\t\t\t// di is certainly not removed\n\t\t\tint di = lower_bound(p.begin() + 1, p.end() - 1, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[0],v[i]) < 0;\n\t\t\t}) - p.begin();\n\n\t\t\t// first that stays (<= di)\n\t\t\tsucc = lower_bound(p.begin(), p.begin() + di, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i+1],v[i]) >= 0;\n\t\t\t}) - p.begin();\n\n\t\t\t// last that stays (>= di)\n\t\t\tprec = lower_bound(p.begin() + di + 1, p.end(), -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i-1],v[i]) > 0;\n\t\t\t}) - p.begin() - 1;\n\t\t}\n\t\treturn 0;\n\t}\n};\nostream& operator<<(ostream& os, vec o)\n{ return os << '(' << o.x << \", \" << o.y << ')'; }\n\nstruct lin { // line\n\tcood a, b, c; // a*x + b*y = c\n\n\tlin () {}\n\tlin (cood x, cood y, cood z) : a(x), b(y), c(z) {}\n\tlin (vec s, vec t) : a(t.y - s.y), b(s.x - t.x), c(a * s.x + b * s.y) {}\n\n\tlin parll (vec p) // parallel to this through p\n\t{ return lin(a, b, a * p.x + b * p.y); }\n\tlin perp ()\n\t{ return lin(-b, a, c); }\n\n\tvec inter (lin o) {\n\t\tcood d = a * o.b - o.a * b;\n\t\tif (d < eps && -eps < d) throw 0; // parallel\n\t\treturn vec((o.b * c - b * o.c) / d, (a * o.c - o.a * c) / d);\n\t}\n};\n\nstruct cir { // circle\n\tvec c; cood r;\n\n\t// borders included\n\tbool contains (vec w)\n\t{ return c.sq(w) <= sq(r) + eps; }\n\tbool has_inter (cir o)\n\t{ return c.sq(o.c) <= sq(r + o.r) + eps; }\n\tbool has_inter_lin (vec s, vec t)\n\t{ return c.dist2_lin(s,t) <= sq(r) + eps_d; }\n\tbool has_inter_seg (vec s, vec t)\n\t{ return c.dist2_seg(s,t) <= sq(r); }\n\n\t// borders not included\n\tbool contains (cir o)\n\t{ return (o.r < r - eps && c.sq(o.c) < sq(r - o.r) - eps); }\n\n\t// ccw oriented area of arc from a to b\n\tdouble arc_area (vec a, vec b) {\n\t\tdouble ang = c.angle(a,b);\n\t\treturn r*r*ang*.5;\n\t}\n\n\t// double only\n\tpair<vec,vec> inter_pts (cir o) {\n\t\tassert(has_inter(o) && !contains(o)); // fully contained case\n\t\tdouble d = c.nr(o.c);\n\t\tdouble a = (r*r + d*d - o.r*o.r) / (2.*d); // r*cos(ans,v,c.v)\n\t\tdouble h = sqrt(r*r - a*a);\n\t\tif (h != h) h = 0;\n\t\tvec p = o.c - c;\n\t\treturn pair<vec,vec>(c + p*(a/d) + (p.rot90()*(h/d)), c + p*(a/d) - (p.rot90()*(h/d)));\n\t}\n\n\t// double only XXX careful precision\n\tpair<vec,vec> inter_pts (vec s, vec t) { \n\t\tassert(has_inter_lin(s,t));\n\t\tdouble h2 = c.dist2_lin(s,t);\n\t\tdouble d = sqrt(c.sq(t) - h2);\n\t\tif (d != d) d = 0;\n\t\tvec p = (s-t);\n\t\tvec m = t + p*(d/p.nr());\n\t\tvec m_b = t - p*(d/p.nr());\n\t\tif (m_b.sq(c) < m.sq(c))\n\t\t\tm = m_b;\n\n\t\td = sqrt(r*r - h2);\n\t\tif (d != d) d = 0;\n\t\tpair<vec,vec> res(m + p*(d/p.nr()), m - p*(d/p.nr()));\n\t\tif (res.first.sq(t) > res.second.sq(t))\n\t\t\tswap(res.first, res.second);\n\t\treturn res;\n\t}\n\n\t// double only XXX not tested\n\t// signed area of intersection of this with triangle (this.c,a,b)\n\tdouble inter (vec a, vec b) {\n\t\tcout << c << \" with \" << a << \",\" << b << \": \";\n\t\tdouble res = 0.;\n\t\tbool inv = 0;\n\t\tif (contains(b)) {\n\t\t\tswap(a,b);\n\t\t\tinv = 1;\n\t\t\tcout << \"[inv] \";\n\t\t}\n\n\t\tif (contains(b)) {\n\t\t\tcout << \"contains both\";\n\t\t\tres = c.cross(a,b)*.5;\n\t\t} else if (contains(a)) {\n\t\t\tcout << \"contains \" << a;\n\t\t\tpair<vec,vec> rt = inter_pts(a,b);\n\t\t\tcout << endl << \"[[\" << rt.first << \" \" << rt.second << endl;\n\t\t\tvec q = rt.first;\n\t\t\tif (!q.in_seg(a,b) || (a.sq(q) <= eps && rt.second.in_seg(a,b)))\n\t\t\t//if (rt.second.dist2_seg(a,b) < q.dist2_seg(a,b))\n\t\t\t\tq = rt.second;\n\t\t\tcout << \" inter at \" << q;\n\n\t\t\tres += c.cross(a,q)*.5;\n\t\t\tres += arc_area(q,b);\n\t\t} else if (has_inter_seg(a, b)) {\n\t\t\tcout << \"inter seg\";\n\t\t\tpair<vec,vec> rt = inter_pts(b,a);\n\n\t\t\tres += arc_area(a,rt.first);\n\t\t\tres += c.cross(rt.first,rt.second)*.5;\n\t\t\tres += arc_area(rt.second,b);\n\t\t} else {\n\t\t\tcout << \"arc only\";\n\t\t\tres += arc_area(a,b);\n\t\t}\n\n\t\tif (inv) res = -res;\n\t\tcout << \" = \" << res << endl;\n\t\treturn res;\n\t}\n\n\t// double only XXX not tested\n\t// signed area of intersection of this with polygon\n\tdouble inter (vector<vec> & p) {\n\t\tdouble res = 0;\n\t\tfor (int i = 0; i < p.size(); i++)\n\t\t\tres += inter(p[i],p[(i+1)%p.size()]);\n\t\treturn res;\n\t}\n};\n\n// do the segments ab and cd intersect? (borders included) XXX\nbool inter_seg (vec a, vec b, vec c, vec d) {\n\tif (a.in_seg(c, d) || b.in_seg(c, d) || c.in_seg(a, b) || d.in_seg(a, b))\n\t\treturn true;\n\treturn (c.ccw(a, b) * d.ccw(a, b) == -1 && a.ccw(c, d) * b.ccw(c, d) == -1);\n}\n\n// squared distance from segments ab and cd XXX\ndouble dist2_seg (vec a, vec b, vec c, vec d)\n{ return inter_seg(a,b,c,d) ? 0. : min({ a.dist2_seg(c,d), b.dist2_seg(c,d), c.dist2_seg(a,b), d.dist2_seg(a,b) }); }\n\n// brd = do points on the border belong to convex?\n// computes convex hull of given vector (inplace)\n// returns size of convex hull\nint graham (vec v[], int n, int brd) {\n\tfor (int i = 1; i < n; i++) {\n\t\tif (v[i].x < v[0].x || (v[i].x == v[0].x && v[i].y < v[0].y))\n\t\t\tswap(v[0], v[i]);\n\t}\n\n\tsort(v+1, v+n, [v] (vec a, vec b) {\n\t\tint o = b.ccw(v[0], a);\n\t\tif (o) return (o == 1);\n\t\treturn v[0].sq(a) < v[0].sq(b);\n\t});\n\n\tif (brd) {\n\t\tint s = n-1;\n\t\twhile (s > 1 && v[s].ccw(v[s-1],v[0]) == 0)\n\t\t\ts--;\n\t\tfor (int i = s; i < n - 1 - (i - s); i++)\n\t\t\tswap(v[i], v[n-1-(i-s)]);\n\t}\n\n\tint s = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s && v[s-1].x == v[i].x && v[s-1].y == v[i].y) continue;\n\t\twhile (s >= 2 && v[s-1].ccw(v[s-2],v[i]) >= brd)\n\t\t\ts--;\n\t\tv[s++] = v[i];\n\t}\n\n\treturn s;\n}\n\nconst int N = 1e2+7;\n\nint n;\ndouble r;\nvector<vec> v;\ndouble x[2], y[2];\n\ndouble solve (double x) {\n\tdouble lo = 200, hi = -100.;\n\tfor (int i = 0; i < n; i++) {\n\t\tint j = (i+1)%n;\n\t\tlin ln(v[i],v[j]);\n\t\tvec it(x, (ln.c - ln.a*x)/ln.b);\n\t\tcout << it << \" \";\n\t\tif (it.y == it.y && abs(it.y) < 200) {\n\t\t\tif (abs(ln.b) > eps) {\n\t\t\t\tlo = min(lo, it.y);\n\t\t\t\thi = max(hi, it.y);\n\t\t\t}\n\t\t}\n\n\t\tif (abs(v[i].x - x) <= eps_d) {\n\t\t\tcout << v[i] << \"! \";\n\t\t\tlo = min(lo, v[i].y);\n\t\t\thi = max(hi, v[i].y);\n\t\t}\n\t}\n\thi = min(hi, 200.); lo = max(lo, -100.);\n\tcout << x << \" [\" << lo << \" \" << hi << \"]\" << endl;\n\n\tint ts = 60;\n\twhile (ts--) {\n\t\tdouble q1 = (lo+lo+hi)/3;\n\t\tdouble q2 = (lo+hi+hi)/3;\n\n\t\tdouble r1 = abs(cir({ vec(x,q1), r }).inter(v));\n\t\tdouble r2 = abs(cir({ vec(x,q2), r }).inter(v));\n\n\t\tif (r1 < r2)\n\t\t\tlo = q1;\n\t\telse\n\t\t\thi = q2;\n\t}\n\n\treturn abs(cir({ vec(x,lo), r }).inter(v));\n}\n\nint main () {\n\n\twhile (scanf(\"%d %lf\", &n, &r) != EOF) {\n\t\tcout << n << endl;\n\t\tv = vector<vec>(n);\n\t\t\n\t\tx[0] = 200;\n\t\tx[1] = -100;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%lf %lf\", &v[i].x, &v[i].y);\n\t\t\tcout << v[i] << \" \";\n\n\t\t\tx[0] = min(x[0],v[i].x);\n\t\t\tx[1] = max(x[1],v[i].x);\n\t\t}\n\t\tcout << endl;\n\n\t\tdouble lo = x[0], hi = x[1];\n\t\t//int ts = 60;\n\t\tint ts = 50;\n\t\twhile (ts--) {\n\t\t\tdouble q1 = (lo+lo+hi)/3;\n\t\t\tdouble q2 = (lo+hi+hi)/3;\n\t\t\t\n\t\t\tif (solve(q1) < solve(q2))\n\t\t\t\tlo = q1;\n\t\t\telse\n\t\t\t\thi = q2;\n\t\t}\n\n\t\tdouble res = solve(lo);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tres = max(res, abs(cir({ v[i], r }).inter(v)));\n\n\t\tprintf(\"%.20f\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\nstruct L{P a, b;};\ntypedef vector<P> Pol;\nstruct C{P c; D r;};\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ninline int sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\n\ninline bool near(const P& a, const P& b) {return !sig(norm(a - b));}\n\nnamespace std {\n  inline bool operator<(const P& a, const P& b) {return sig(a.X, b.X) ? a.X < b.X : a.Y < b.Y;}\n}\n\ninline D sr(D a) {return sqrt(max(a, (D)0));}\n\ninline D dot(const P& a, const P& b) {return a.X * b.X + a.Y * b.Y;}\ninline D det(const P& a, const P& b) {return a.X * b.Y - a.Y * b.X;}\n\ninline P vec(const L& a) {return a.b - a.a;}\n\ninline D arg(const P& base, const P& a, const P& b) {return arg((b - base) / (a - base));}\n\ninline P proj(const P& a, const P& b) {return a * dot(a, b) / norm(a);}\ninline P perp(const L& l, const P& p) {return l.a + proj(vec(l), p - l.a);}\n\ninline pair<P, P> pCL(const C& c, const L& l) {\n  P x = perp(l, c.c);\n  P y = vec(l) / abs(vec(l)) * sr(c.r * c.r - norm(x - c.c));\n  return make_pair(x - y, x + y);\n}\n\ninline D aCTnc(D r, const P& p1, const P& p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? det(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\n\ninline D aCT(D r, const P& p1, const P& p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\n\ninline D aCPol(const C& c, const Pol& pol) {\n  D res = 0;\n  for (int i = 0; i < (int)pol.size(); ++i) res += aCT(c.r, pol[i] - c.c, pol[(i + 1) % pol.size()] - c.c);\n  return res;\n}\n\nint main() {\n  int n, r;\n  cin >> n >> r;\n  D x1 = 1e9, x2 = -1e9, y1 = 1e9, y2 = -1e9, a = 0;\n  Pol pol(n);\n  for (auto& p : pol) {\n    D x, y;\n    cin >> x >> y;\n    p = P(x, y);\n    x1 = min(x1, x);\n    x2 = max(x2, x);\n    y1 = min(y1, y);\n    y2 = max(y2, y);\n  }\n  for (int i = 0; i < 300; ++i) {\n    D xa = (2 * x1 + x2) / 3;\n    D yy1 = y1, yy2 = y2;\n    D aa1 = 0, aa2 = 0;\n    for (int j = 0; j < 300; ++j) {\n      D ya = (2 * yy1 + yy2) / 3;\n      D yb = (yy1 + 2 * yy2) / 3;\n      D a1 = aCPol(C({P(xa, ya), (D)r}), pol);\n      D a2 = aCPol(C({P(xa, yb), (D)r}), pol);\n      if (a1 > a2) yy2 = yb;\n      else yy1 = ya;\n      aa1 = max(a1, a2);\n    }\n    yy1 = y1;\n    yy2 = y2;\n    D xb = (x1 + 2 * x2) / 3;\n    for (int j = 0; j < 300; ++j) {\n      D ya = (2 * yy1 + yy2) / 3;\n      D yb = (yy1 + 2 * yy2) / 3;\n      D a1 = aCPol(C({P(xb, ya), (D)r}), pol);\n      D a2 = aCPol(C({P(xb, yb), (D)r}), pol);\n      if (a1 > a2) yy2 = yb;\n      else yy1 = ya;\n      aa2 = max(a1, a2);\n    }\n    if (aa1 > aa2) x2 = xb;\n    else x1 = xa;\n    a = max(aa1, aa2);\n  }\n  cout << fixed << setprecision(15) << a << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <map>\n#include <set>\n#include <vector>\n#include <bitset>\nusing namespace std;\n//#define f(i, x, y) for (int i = x; i <= y; ++i)\n#define fd(i, x, y) for (int i = x; i >= y; --i)\n#define rep(i, x, y) for (int i = x; i <= y; ++i)\n#define repd(i, x, y) for (int i = x; i >= y; --i)\n#define sqr(x) ((x)*(x))\n\nconst int maxn=20;\nconst double eps=1e-9;\nint n,R,xl=100,xr=0,yl=100,yr=0;\nstruct node{\n\tint x,y;\n\tvoid read(){\n\t\tcin >> x >> y;\n\t}\n}p[maxn];\n\nvoid init()\n{\n\tcin >> n >> R;\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\tp[i].read();\n\t\txl=min(xl,p[i].x);\n\t\txr=max(xr,p[i].x);\n\t\tyl=min(yl,p[i].y);\n\t\tyr=max(yr,p[i].y);\n\t}\n\tp[0]=p[n];\n}\n\ndouble f(double xx,double x,double y)\n{\n\tif(xx<x-R)return 0;\n\tif(xx>x+R)return 0;\n\tdouble mi,mx;\n\tmi=y-sqrt(sqr(R)-sqr(xx-x));\n\tmx=y+sqrt(sqr(R)-sqr(xx-x));\n\tdouble y1=100,y2=0;\n\tfor(int i = 0;i < n;i++)\n\t{\n\t\tif((p[i].x-xx)*(p[i+1].x-xx)<eps)\n\t\t{\n\t\t\tif(p[i].x==p[i+1].x)\n\t\t\t{\n\t\t\t\ty2=max(y2,(double)max(p[i].y,p[i+1].y));\n\t\t\t\ty1=min(y1,(double)min(p[i].y,p[i+1].y));\n\t\t\t}\n\t\t\telse\n\t\t\t{\t\n\t\t\t\tdouble yy=p[i].y+(p[i+1].y-p[i].y)*(xx-p[i].x)/(p[i+1].x-p[i].x);\n\t\t\t\ty2=max(y2,yy);\n\t\t\t\ty1=min(y1,yy);\n\t\t\t}\n\t\t}\n\t}\n\tmi=max(y1,mi);\n\tmx=min(y2,mx);\n\treturn max(mx-mi,0.0);\n}\n\ndouble sum(double l,double r,double x,double y)\n{\n\tdouble mid=(l+r)/2;\n\treturn (f(l,x,y)+f(r,x,y)+4*f(mid,x,y))*(r-l)/6;\n}\n\ndouble simpson(double l,double r,double x,double y)\n{\n\tif (l > r) return 0;\n\tdouble mid=(l+r)/2;\n\t//if(f(mid,x,y)<eps)return simpson(l,mid,x,y)+simpson(mid,r,x,y);\n\tdouble s=sum(l,r,x,y),s1=sum(l,mid,x,y),s2=sum(mid,r,x,y);\n\tif(abs(s-s1-s2)<eps)return s;\n\treturn simpson(l,mid,x,y)+simpson(mid,r,x,y);\n}\n\ndouble gets(double x,double y)\n{\n\t//printf(\"%.6lf\\n\",simpson(xl,xr,x,y));\n\tdouble ll=max(x-R,(double)xl),rr=min((double)xr,x+R);\n\twhile(f(ll,x,y)<eps)ll+=1e-5;\n\twhile(f(rr,x,y)<eps)rr-=1e-5;\n\treturn simpson(ll,rr,x,y);\n}\n\ndouble gets(double x)\n{\n\tdouble l=yl,r=yr;\n\twhile(r-l>1e-8)\n\t{\n\t\tdouble len=(r-l)/3;\n\t\tif(gets(x,l+len)>gets(x,r-len))r=r-len;\n\t\telse l=l+len;\n\t}\n\treturn gets(x,(l+r)/2);\n}\n\nvoid solve()\n{\n\tdouble l=xl,r=xr;\n\twhile(r-l>1e-8)\n\t{\n\t\tdouble len=(r-l)/3;\n\t\tif(gets(l+len)>gets(r-len))r=r-len;\n\t\telse l=l+len;\n\t}\n\tprintf(\"%.12lf\\n\",gets((l+r)/2));\n\t//printf(\"%.12lf %.12lf\\n\",l,r);\n\t//printf(\"%.12lf\\n\",gets(l + 0.1));\n\t//printf(\"%.12lf\\n\",gets(l - 0.1));\n}\nint main()\n{\t\n\tcin.sync_with_stdio(0);\n\tinit();\n\t//if (n == 3 && R == 1 && p[1].x == 0 && p[1].y == 0 && p[2].x == 2 && p[2].y == 1 && p[3].x == 1 && p[3].y == 3)\n//\t\tprintf(\"2.113100\\n\");\n//\telse \n\tsolve();\n\t/*double qmax = 0;\n\tfor (double i = 0; i <= 3; i += 0.001)\n\tfor (double j = 0; j <= 3; j += 0.001)\n\t\tqmax = max(qmax,gets(i, j));\n\tprintf(\"%.12lf\\n\",qmax);*/\n\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MP make_pair\n#define PB push_back\ntypedef long long LL;\ntypedef pair<int,int> PII;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\nconst int K=1e6+7;\nconst int mod=1e9+7;\n\nmap<string,int>hs;\nchar sa[K],sb[K];\nstring tmp;\nint cnt[200];\n\nvoid work(int x,char ch)\n{\n    int st=(ch-'a')*4;\n    int a=x/1000,b=(x/100)%10,c=(x/10)%10,d=x%10;\n    tmp[st]=a+'a',tmp[st+1]=b+'a',tmp[st+2]=c+'a',tmp[st+3]=d+'a';\n}\nint la,lb;\nbool sc(int x)\n{\n    for(int i=0;i<26*4;i++) tmp[i]='a';\n    for(int i='a';i<='z';i++) cnt[i]=0;\n    for(int i=1;i<=x;i++)\n        work(++cnt[sa[i]],sa[i]);\n    hs[tmp]=1;\n    for(int i=x+1;i<=la;i++)\n    {\n        work(--cnt[sa[i-x]],sa[i-x]);\n        work(++cnt[sa[i]],sa[i]);\n        hs[tmp]=1;\n    }\n    for(int i=0;i<26*4;i++) tmp[i]='a';\n    for(int i='a';i<'z';i++) cnt[i]=0;\n    for(int i=1;i<=x;i++)\n        work(++cnt[sb[i]],sb[i]);\n    if(hs[tmp]) return 1;\n    for(int i=x+1;i<=lb;i++)\n    {\n       work(--cnt[sb[i-x]],sb[i-x]);\n       work(++cnt[sb[i]],sb[i]);\n       if(hs[tmp]) return 1;\n    }\n    return 0;\n}\nint main(void)\n{\n    scanf(\"%s%s\",sa+1,sb+1);\n    la=strlen(sa+1),lb=strlen(sb+1);\n    int ans=0;\n    for(int i=0;i<26*4;i++) tmp+='a';\n    for(int i=1,mx=min(la,lb);i<=mx;i++)\n    {\n         if(sc(i)) ans=i;\n         hs.clear();\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\n\ntemplate<class T> using V = vector<T>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) { return (abs(a) <= EPS) ? 0 : (a < 0 ? -1 : 1); }\nint sgn(D a, D b) { return sgn(a-b); }\n//relative sign\n// int rsgn(D a, D f) {\n//     if (abs(a) <= f*EPS) return 0;\n//     return (a < 0) ? -1 : 1;\n// }\nstruct Pt2 {\n    D x, y;\n    Pt2(D _x = D(), D _y = D()) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    Pt2 operator/(const D &r) const { return Pt2(x/r, y/r); }\n\n    Pt2& operator+=(const Pt2 &r) { return *this=*this+r; }\n    Pt2& operator-=(const Pt2 &r) { return *this=*this-r; }\n    Pt2& operator*=(const Pt2 &r) { return *this=*this*r; }\n    Pt2& operator*=(const D &r) { return *this=*this*r; }\n    Pt2& operator/=(const D &r) { return *this=*this/r; }\n    \n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    bool operator<(const Pt2 &r) const { return 2*sgn(x, r.x)+sgn(y, r.y)<0; }\n    bool operator==(const Pt2 &r) const { return sgn((*this-r).rabs()) == 0; }\n\n    D norm() const { return x*x + y*y; }\n    D abs() const { return sqrt(norm()); }\n    D rabs() const { return max(std::abs(x), std::abs(y)); } // robust abs\n    D arg() const { return atan2(y, x); }\n\n    pair<D, D> to_pair() const { return make_pair(x, y); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    return os << \"P(\" << p.x << \", \" << p.y << \")\";\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L(P _s = P(), P _t = P()) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\nostream& operator<<(ostream& os, const L &l) {\n    return os << \"L(\" << l.s << \", \" << l.t << \")\";\n}\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n// cross(a, b) is too small?\nint sgncrs(P a, P b) {\n    D cr = cross(a, b);\n    if (abs(cr) <= (a.rabs() + b.rabs()) * EPS) return 0;\n    return (cr < 0) ? -1 : 1;\n}\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = sgncrs(b, c);\n    if (s) return s;\n    if (!sgn(c.rabs()) || !sgn((c-b).rabs())) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nP project(const L &l, const P &p) {\n    P v = l.vec();\n    return l.s + v * (dot(v, p-l.s) / v.norm());\n}\n\nbool insSL(const L &s, const L &l) {\n    int a = ccw(l, s.s), b = ccw(l, s.t);\n    return (a%2 == 0 || b%2 == 0 || a != b);\n}\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s, t.s), b = ccw(s, t.t);\n    int c = ccw(t, s.s), d = ccw(t, s.t);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nD distLP(const L &l, const P &p) {\n    return abs(cross(l.vec(), p-l.s)) / l.abs();\n}\n\nD distSP(const L &s, const P &p) {\n    P q = project(s, p);\n    if (ccw(s, q) == 0) return (p - q).abs();\n    else return min((s.s - p).abs(), (s.t - p).abs());\n}\n\nint crossLL(const L &l, const L &m, P &r) {\n    D cr1 = cross(l.vec(), m.vec()), cr2 = cross(l.vec(), l.t - m.s);\n    if (sgncrs(l.vec(), m.vec()) == 0) {\n        r = l.s;\n        if (sgncrs(l.vec(), l.t - m.s)) return 0;\n        return -1;\n    }\n    r = m.s + m.vec() * (cr2 / cr1);\n    return 1;\n}\n\nusing Pol = V<P>;\n\nstruct C {\n    P p; D r;\n    C(P _p = P(), D _r = D()) : p(_p), r(_r) {}\n};\n\n//need Intersect/distLP, r.sはよりl.sに近い\nint crossCL(const C &c, const L &l, L &r) {\n    D u = distLP(l, c.p);\n    int si = sgn(u, c.r);    \n    if (si == 1) return 0;\n    P v = project(l, c.p);\n    P di = (si == 0) ? P(0, 0) : l.vec() * (sqrt(c.r*c.r - u*u) / l.abs());\n    r = L(v-di, v+di);\n    if (si == 0) return 1;\n    return 2;\n}\n\n// C(P(0, 0), r)とTri((0, 0), a, b)の共有面積\nD area2CT(const C &c, const P &_a, const P &_b) {\n    P a = _a - c.p, b = _b - c.p; D r = c.r;\n    if (a == b) return 0;\n    auto single = [&](P x, P y, bool tri) {\n        if (tri) return cross(x, y);\n        else return r * r * ((y * P(x.x, -x.y)).arg());\n    };\n    bool ia = sgn(a.abs(), r) != 1, ib = sgn(b.abs(), r) != 1;\n    if (ia && ib) return single(a, b, true);\n    D r2 = distSP(L(a, b), P(0, 0));\n    if (sgn(r, r2) != 1) return single(a, b, false);\n    L l;\n    assert(crossCL(C(P(0, 0), r), L(a, b), l) == 2);\n    if (ia) l.s = l.t;\n    else if (ib) l.t = l.s;\n    assert(ccw(a, b, l.s) == 0); assert(ccw(a, b, l.t) == 0);\n    return single(a, l.s, ia) + single(l.s, l.t, true) + single(l.t, b, ib);\n}\n\n// p, cの共有面積\nD area2CPol(const C &c, const Pol &po) {\n    D sm = 0;\n    P a, b = po.back();\n    for (auto p: po) {\n        a = b; b = p;\n        sm += area2CT(c, a, b);\n    }\n    return sm;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    int n; D r;\n    cin >> n >> r;\n    Pol pol;\n \n    D ymi = 1e100, yma = -1e100;\n    for (int i = 0; i < n; i++) {\n        D x, y;\n        cin >> x >> y;\n        pol.push_back(P(x, y));\n        ymi = min(ymi, y);\n        yma = max(yma, y);\n    }\n \n    auto calc = [&](D y) {\n        D xmi = 1e100, xma = -1e100;\n        for (int i = 0; i < n; i++) {\n            P p;\n            if (crossLL(L(pol[i], pol[(i+1)%n]), L(P(0, y), P(1, y)), p) == 0) continue;\n            if (ccw(pol[i], pol[(i+1)%n], p) != 0) continue;\n            xmi = min(xmi, p.x); xma = max(xma, p.x);\n        }\n        D lw = xmi, up = xma;\n        for (int ph = 0; ph < 50; ph++) {\n            D md1 = (lw+lw+up) / 3;\n            D md2 = (lw+up+up) / 3;\n            D z1 = area2CPol(C(P(md1, y), r), pol) / 2;\n            D z2 = area2CPol(C(P(md2, y), r), pol) / 2;\n            if (z1 < z2) {\n                lw = md1;\n            } else {\n                up = md2;\n            }\n        }\n        return area2CPol(C(P(lw, y), r), pol) / 2;\n    };\n     \n    D lw = ymi, up = yma;\n    for (int ph = 0; ph < 50; ph++) {\n        D md1 = (lw+lw+up) / 3;\n        D md2 = (lw+up+up) / 3;\n        if (calc(md1) < calc(md2)) {\n            lw = md1;\n        } else {\n            up = md2;\n        }\n    }\n \n    cout << calc(lw) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1000\n#define linf 1e18\n#define eps (1e-5)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n  double getArea(){ return r*r*pi;}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Point p,Circle c){ return abs(p-c.c)-c.r<-eps;}\nbool on(Point p,Circle c){ return fabs(abs(p-c.c)-c.r)<eps;}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\ndouble getArea(Polygon p){\n  double res=0;\n  for(int i=1;i<p.size()-1;i++)res+=cross(p[i]-p[0],p[i+1]-p[0])/2.0;\n  return res;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nbool iscrossLC(Line l,Circle c){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  if(!iscrossLC(s,c))return res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(abs(pp.s-s.p1)-abs(pp.f-s.p1)<eps)swap(pp.f,pp.s);\n  if(ccw(s.p1,s.p2,pp.f)==0)res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0)res.push_back(pp.s);\n  return res;\n}\n\nbool AllIn(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceLP(L,c.c)-c.r<-eps || ccw(L.p1,L.p2,c.c)==-1)return false;\n  }\n  return true;\n}\n\nbool AllOut(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\ndouble getCommonAreaTC(Polygon p,Circle c){\n  double res=getArea(p),carea=c.getArea();\n  int n=p.size();\n  bool flag=false;\n  if(res<0.0){\n    flag=true;\n    reverse(p.begin(),p.end());\n    res=getArea(p);\n  }\n  vector<Point> s;\n  if(AllIn(p,c))return carea;\n  if(AllOut(p,c)) return 0.0;\n  int start=-1;\n  for(int i=0;i<n;i++){\n    if((c.r-abs(p[i]-c.c))<-eps)start=i;\n  }\n  if(start==-1)return res;\n  for(int i=0;i<n;i++){\n    vector<Point> vp=getCrossPointSC(c,Segment(p[(i+start)%n],\n\t\t\t\t\t       p[(i+1+start)%n]));    \n    for(int j=0;j<vp.size();j++){\n      bool b=true;\n      for(int k=0;k<s.size();k++)if(s[k]==vp[j])b=false;\n      if(b)s.push_back(vp[j]);\n    }\n  }\n\n  s.push_back(s[0]);\n  s.erase(s.begin());\n\n  for(int i=0;i<s.size();i+=2){\n    Point p1=s[i];\n    Point p2=s[i+1];\n    if(p1==p2)continue;\n    Polygon t;\n    t.push_back(p1);\n    t.push_back(p2);\n    t.push_back(c.c);\n    double narea=getArea(convex_cut(p,Line(p2,p1)));\n    if(narea<eps)continue;\n    res-=narea;\n    double ra=acos(dot(p1-c.c,p2-c.c)/(abs(p1-c.c)*abs(p2-c.c)))*(360/(2*pi));\n    if(ccw(c.c,p1,p2)==-1)ra=180.0;\n    res+=((carea*ra/360.0)-getArea(t));\n  }\n  if(!flag)return res;\n  return -res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++){\n    Polygon t;\n    t.push_back(p[0]);\n    t.push_back(p[i]);\n    t.push_back(p[i+1]);\n    res+=getCommonAreaTC(t,c);\n  }\n  return res;\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,60){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*L,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=inf;\n    FOR(k,0,60){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bismillahir Rahmanir Rahim\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define double long double\nconst double eps = 1e-12;\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst double pi = acos(-1.0);\n\ndouble mysqrt(double x){if(x < 0)\treturn 0;return sqrt(x);}\ndouble myasin(double x){if(x < -1)\treturn -pi/2;if(x > 1)\treturn pi/2;return asin(x);}\ndouble myacos(double x){if(x < -1)\treturn -pi;if(x > 1)\treturn 0;return acos(x);}\n\nint dcmp(double x,double y)\n{\n    if(fabs(x-y)<=EPS) return 0;\n    if(x<y) return 1;\n    else return -1;\n}\n\nstruct PT {\n  double x, y;\n  PT() {}\n  PT(double x, double y) : x(x), y(y) {}\n  PT(const PT &p) : x(p.x), y(p.y)    {}\n  PT operator + (const PT &p)  const { return PT(x+p.x, y+p.y); }\n  PT operator - (const PT &p)  const { return PT(x-p.x, y-p.y); }\n  PT operator * (double c)     const { return PT(x*c,   y*c  ); }\n  PT operator / (double c)     const { return PT(x/c,   y/c  ); }\n};\n\nvector<PT>PP;\n\ndouble dot(PT p, PT q)     { return p.x*q.x+p.y*q.y; }\ndouble dist2(PT p, PT q)   { return dot(p-q,p-q); }\ndouble cross(PT p, PT q)   { return p.x*q.y-p.y*q.x; }\ndouble Length(PT Q)\n{\n    return mysqrt(Q.x*Q.x+Q.y*Q.y);\n}\n\nostream &operator<<(ostream &os, const PT &p) {\n  os << \"(\" << p.x << \",\" << p.y << \")\";\n}\n\n// rotate a point CCW or CW around the origin\nPT RotateCCW90(PT p)   { return PT(-p.y,p.x); }\nPT RotateCW90(PT p)    { return PT(p.y,-p.x); }\nPT RotateCCW(PT p, double t) {\n  return PT(p.x*cos(t)-p.y*sin(t), p.x*sin(t)+p.y*cos(t));\n}\n\n// project point c onto line through a and b\n// assuming a != b\nPT ProjectPTLine(PT a, PT b, PT c) {\n  return a + (b-a)*dot(c-a, b-a)/dot(b-a, b-a);\n}\n\n// project point c onto line segment through a and b\nPT ProjectPTSegment(PT a, PT b, PT c) {\n  double r = dot(b-a,b-a);\n  if (fabs(r) < EPS) return a;\n  r = dot(c-a, b-a)/r;\n  if (r < 0) return a;\n  if (r > 1) return b;\n  return a + (b-a)*r;\n}\n\n// compute distance from c to segment between a and b\ndouble DistancePTSegment(PT a, PT b, PT c) {\n  return sqrt(dist2(c, ProjectPTSegment(a, b, c)));\n}\n\n// compute distance between point (x,y,z) and plane ax+by+cz=d\ndouble DistancePTPlane(double x, double y, double z,\n                          double a, double b, double c, double d)\n{\n  return fabs(a*x+b*y+c*z-d)/sqrt(a*a+b*b+c*c);\n}\n\n// determine if lines from a to b and c to d are parallel or collinear\nbool LinesParallel(PT a, PT b, PT c, PT d) {\n    return fabs(cross(b-a, c-d)) < EPS;\n}\n\nbool LinesCollinear(PT a, PT b, PT c, PT d) {\n  return LinesParallel(a, b, c, d)\n      && fabs(cross(a-b, a-c)) < EPS\n      && fabs(cross(c-d, c-a)) < EPS;\n}\n\n// determine if line segment from a to b intersects with\n// line segment from c to d\nbool SegmentsIntersect(PT a, PT b, PT c, PT d) {\n  if (LinesCollinear(a, b, c, d)) {\n    if (dist2(a, c) < EPS || dist2(a, d) < EPS ||\n      dist2(b, c) < EPS || dist2(b, d) < EPS) return true;\n    if (dot(c-a, c-b) > 0 && dot(d-a, d-b) > 0 && dot(c-b, d-b) > 0)\n      return false;\n    return true;\n  }\n  if (cross(d-a, b-a) * cross(c-a, b-a) > 0) return false;\n  if (cross(a-c, d-c) * cross(b-c, d-c) > 0) return false;\n  return true;\n}\n\n// compute intersection of line passing through a and b\n// with line passing through c and d, assuming that unique\n// intersection exists; for segment intersection, check if\n// segments intersect first\nPT ComputeLineIntersection(PT a, PT b, PT c, PT d) {\n  b=b-a; d=c-d; c=c-a;\n  assert(dot(b, b) > EPS && dot(d, d) > EPS);\n  return a + b*cross(c, d)/cross(b, d);\n}\n\n// compute center of circle given three points\nPT ComputeCircleCenter(PT a, PT b, PT c) {\n  b=(a+b)/2;\n  c=(a+c)/2;\n  return ComputeLineIntersection(b, b+RotateCW90(a-b), c, c+RotateCW90(a-c));\n}\n\n// determine if point is in a possibly non-convex polygon (by William\n// Randolph Franklin); returns 1 for strictly interior points, 0 for\n// strictly exterior points, and 0 or 1 for the remaining points.\n// Note that it is possible to convert this into an *exact* test using\n// integer arithmetic by taking care of the division appropriately\n// (making sure to deal with signs properly) and then by writing exact\n// tests for checking point on polygon boundary\nbool PTInPolygon(const vector<PT> &p, PT q) {\n  bool c = 0;\n  for (int i = 0; i < p.size(); i++){\n    int j = (i+1)%p.size();\n    if ((p[i].y <= q.y && q.y < p[j].y ||\n      p[j].y <= q.y && q.y < p[i].y) &&\n      q.x < p[i].x + (p[j].x - p[i].x) * (q.y - p[i].y) / (p[j].y - p[i].y))\n      c = !c;\n  }\n  return c;\n}\n\n// determine if point is on the boundary of a polygon\nbool PTOnPolygon(const vector<PT> &p, PT q) {\n  for (int i = 0; i < p.size(); i++)\n    if (dist2(ProjectPTSegment(p[i], p[(i+1)%p.size()], q), q) < EPS)\n      return true;\n    return false;\n}\n\n// compute intersection of line through points a and b with\n// circle centered at c with radius r > 0\nvector<PT> CircleLineIntersection(PT a, PT b, PT c, double r) {\n  vector<PT> ret;\n  b = b-a;\n  a = a-c;\n  double A = dot(b, b);\n  double B = dot(a, b);\n  double C = dot(a, a) - r*r;\n  double D = B*B - A*C;\n  if (D < -EPS) return ret;\n  ret.push_back(c+a+b*(-B+sqrt(D+EPS))/A);\n  if (D > EPS)\n    ret.push_back(c+a+b*(-B-sqrt(D))/A);\n  return ret;\n}\n\n// compute intersection of circle centered at a with radius r\n// with circle centered at b with radius R\nvector<PT> CircleCircleIntersection(PT a, PT b, double r, double R) {\n  vector<PT> ret;\n  double d = sqrt(dist2(a, b));\n  if (d > r+R || d+min(r, R) < max(r, R)) return ret;\n  double x = (d*d-R*R+r*r)/(2*d);\n  double y = sqrt(r*r-x*x);\n  PT v = (b-a)/d;\n  ret.push_back(a+v*x + RotateCCW90(v)*y);\n  if (y > 0)\n    ret.push_back(a+v*x - RotateCCW90(v)*y);\n  return ret;\n}\n\n// This code computes the area or centroid of a (possibly nonconvex)\n// polygon, assuming that the coordinates are listed in a clockwise or\n// counterclockwise fashion.  Note that the centroid is often known as\n// the \"center of gravity\" or \"center of mass\".\ndouble ComputeSignedArea(const vector<PT> &p) {\n  double area = 0;\n  for(int i = 0; i < p.size(); i++) {\n    int j = (i+1) % p.size();\n    area += p[i].x*p[j].y - p[j].x*p[i].y;\n  }\n  return area / 2.0;\n}\n\ndouble ComputeArea(const vector<PT> &p) {\n  return fabs(ComputeSignedArea(p));\n}\n\nPT ComputeCentroid(const vector<PT> &p) {\n  PT c(0,0);\n  double scale = 6.0 * ComputeSignedArea(p);\n  for (int i = 0; i < p.size(); i++){\n    int j = (i+1) % p.size();\n    c = c + (p[i]+p[j])*(p[i].x*p[j].y - p[j].x*p[i].y);\n  }\n  return c / scale;\n}\n\n// tests whether or not a given polygon (in CW or CCW order) is simple\nbool IsSimple(const vector<PT> &p) {\n  for (int i = 0; i < p.size(); i++) {\n    for (int k = i+1; k < p.size(); k++) {\n      int j = (i+1) % p.size();\n      int l = (k+1) % p.size();\n      if (i == l || j == k) continue;\n      if (SegmentsIntersect(p[i], p[j], p[k], p[l]))\n        return false;\n    }\n  }\n  return true;\n}\n\ndouble signedareapolygoncircle(const vector<PT> &p,PT C,double mid)\n{\n    int N,i,j,K;\n    double A,temp1,temp2,temp3,val,signflag,disa,ang;\n    vector<PT>temppoint,NOW,TEMP,vec;\n\n    N=p.size();\n    vec=p;\n\n    for(i=0;i<N;i++) vec[i]=vec[i]-C;\n\n    C=PT(0.0,0.0);\n    A=0.0;\n\n    for(i=0;i<N;i++)\n    {\n\n        temppoint.clear();\n        TEMP.clear();\n        NOW.clear();\n\n        temp1=mysqrt(dist2(vec[i],C));\n        temp2=mysqrt(dist2(vec[(i+1)%N],C));\n\n        TEMP.push_back(C);\n        TEMP.push_back(vec[i]);\n        TEMP.push_back(vec[(i+1)%N]);\n\n        if(ComputeSignedArea(TEMP)<-EPS) signflag=-1.0;\n        else if(ComputeSignedArea(TEMP)>EPS) signflag=1.0;\n        else continue;\n\n        if(dcmp(temp1,mid)>0 && dcmp(temp2,mid)>0)\n        {\n            A+=signflag*ComputeArea(TEMP);\n        }\n        else if(dcmp(temp1,mid)>0)\n        {\n            temppoint=CircleLineIntersection(vec[i],vec[(i+1)%N],C,mid);\n            K=temppoint.size();\n            assert(K==2);\n\n            for(j=0;j<K;j++)\n            {\n                disa=DistancePTSegment(vec[i],vec[(i+1)%N],temppoint[j]);\n                if(disa>EPS) continue;\n                NOW.push_back(temppoint[j]);\n            }\n\n            assert(NOW.size()==1);\n\n            NOW.push_back(vec[i]);\n            NOW.push_back(C);\n\n            A+=signflag*ComputeArea(NOW);\n            ang=myacos(dot(vec[(i+1)%N],NOW[0])/(temp2*mid));\n            A+=signflag*mid*mid*ang/2.0;\n        }\n        else if(dcmp(temp2,mid)>0)\n        {\n            temppoint=CircleLineIntersection(vec[i],vec[(i+1)%N],C,mid);\n            K=temppoint.size();\n            assert(K==2);\n\n            for(j=0;j<K;j++)\n            {\n                disa=DistancePTSegment(vec[i],vec[(i+1)%N],temppoint[j]);\n                if(disa>EPS) continue;\n                NOW.push_back(temppoint[j]);\n            }\n\n            assert(NOW.size()==1);\n\n            NOW.push_back(vec[(i+1)%N]);\n            NOW.push_back(C);\n\n            A+=signflag*ComputeArea(NOW);\n            ang=myacos(dot(vec[i],NOW[0])/(temp1*mid));\n            A+=signflag*mid*mid*ang/2.0;\n        }\n        else\n        {\n            temppoint=CircleLineIntersection(vec[i],vec[(i+1)%N],C,mid);\n            K=temppoint.size();\n            for(j=0;j<K;j++)\n            {\n                disa=DistancePTSegment(vec[i],vec[(i+1)%N],temppoint[j]);\n                if(disa>EPS) continue;\n                NOW.push_back(temppoint[j]);\n            }\n            temppoint=NOW;\n            K=temppoint.size();\n            if(K==1) temppoint.push_back(temppoint[0]);\n\n            if(K)\n            {\n                temppoint.push_back(C);\n\n                A+=signflag*ComputeArea(temppoint);\n                ang=myacos(dot(vec[i],vec[(i+1)%N])/(temp1*temp2))-(myacos(dot(temppoint[1],temppoint[0])/(mid*mid)));\n                A+=signflag*mid*mid*ang/2.0;\n            }\n            else\n            {\n                ang=myacos(dot(vec[i],vec[(i+1)%N])/(temp1*temp2));\n                A+=signflag*mid*mid*ang/2.0;\n            }\n        }\n    }\n\n    return A;\n\n}\n\ndouble areapolygoncircle(const vector<PT> &p,PT C,double mid)\n{\n    return fabs(signedareapolygoncircle(p,C,mid));\n}\n\n\nPT BIS(PT A,PT B,PT C)\n{\n    PT Q,W,E,R;\n    Q=A-B;\n    W=C-B;\n\n    Q=Q/Length(Q);\n    W=W/Length(W);\n\n    E=B+Q;\n    R=B+W;\n\n    return (E+R)/2.0;\n}\n\nint main()\n{\n    int i,j,k,n,cnt,nn,flag;\n    double ans,x,y,r,l,temp,h,m,ll,rr,mi;\n    PT T,U,I,TL,TR,L,R,UU,E,II,Q,Y,H,M;\n\n    cin>>n>>r;\n\n    for(i=0;i<n;i++)\n    {\n        cin>>x>>y;\n        PP.push_back(PT(x,y));\n    }\n\n    if(ComputeSignedArea(PP)) reverse(PP.begin(),PP.end());\n    ans=0;\n\n    for(i=0;i<n;i++)\n    {\n        for(j=i+1;j<n;j++)\n        {\n            //cout<<i<<\" \"<<j<<endl;\n            if(LinesParallel(PP[i],PP[(i+1)%n],PP[j],PP[(j+1)%n])) continue;\n            E=ComputeLineIntersection(PP[i],PP[(i+1)%n],PP[j],PP[(j+1)%n]);\n            Q=BIS((PP[i]+PP[(i+1)%n])/2,E,(PP[(j+1)%n]+PP[j])/2);\n            T=Q-E;\n            T=T/Length(T);\n\n            flag=0;\n            for(k=0;k<n;k++)\n            {\n                if(LinesParallel(E,E+T*1000,PP[k],PP[(k+1)%n])) continue;\n                if(SegmentsIntersect(E,E+T*1000,PP[k],PP[(k+1)%n])) flag=1;\n            }\n\n            if(flag)\n            {\n                //cout<<i<<\" nn \"<<j<<endl;\n                mi=1e20;\n                for(k=0;k<n;k++)\n                {\n                    if(LinesParallel(E,E+T*1000,PP[k],PP[(k+1)%n])) continue;\n                    if(SegmentsIntersect(E,E+T*1000,PP[k],PP[(k+1)%n]))\n                    {\n                        U=ComputeLineIntersection(E,E+T*1000,PP[k],PP[(k+1)%n]);\n                        temp=dist2(E,U);\n                        if(temp<mi)\n                        {\n                            temp=mi;\n                            UU=U;\n                        }\n                    }\n                }\n\n                L=E;\n                H=UU;\n\n                //cout<<L.x<<\" \"<<L.y<<\" \"<<H.x<<\" bb \"<<H.y<<endl;\n                cnt=0;\n                while(++cnt<=100)\n                {\n                    M=L+H;\n                    M=M/2;\n\n                    if(areapolygoncircle(PP,M,r)>EPS) H=M;\n                    else L=M;\n                }\n\n                L=M;\n                R=L+T*1000;\n\n                //cout<<L.x<<\" \"<<L.y<<\" \"<<R.x<<\" ee \"<<R.y<<endl;\n                cnt=0;\n                while(++cnt<=100)\n                {\n                    TL=L*2+R;\n                    TL=TL/3;\n                    TR=L+R*2;\n                    TR=TR/3;\n\n                    ll=areapolygoncircle(PP,TL,r);\n                    rr=areapolygoncircle(PP,TR,r);\n                    //cout<<ll<<\" \"<<rr<<endl;\n                    if(rr<ll || fabs(ll-rr)<=EPS) R=TR;\n                    else L=TL;\n                }\n\n                ans=max(ans,(ll+rr)/2);\n\n            }\n\n            T=T*(-1);\n\n            flag=0;\n            for(k=0;k<n;k++)\n            {\n                if(LinesParallel(E,E+T*1000,PP[k],PP[(k+1)%n])) continue;\n                if(SegmentsIntersect(E,E+T*1000,PP[k],PP[(k+1)%n])) flag=1;\n            }\n\n            if(flag)\n            {\n                //cout<<i<<\" nn \"<<j<<endl;\n                mi=1e20;\n                for(k=0;k<n;k++)\n                {\n                    if(LinesParallel(E,E+T*1000,PP[k],PP[(k+1)%n])) continue;\n                    if(SegmentsIntersect(E,E+T*1000,PP[k],PP[(k+1)%n]))\n                    {\n                        U=ComputeLineIntersection(E,E+T*1000,PP[k],PP[(k+1)%n]);\n                        temp=dist2(E,U);\n                        if(temp<mi)\n                        {\n                            temp=mi;\n                            UU=U;\n                        }\n                    }\n                }\n\n                L=E;\n                H=UU;\n\n                //cout<<L.x<<\" \"<<L.y<<\" \"<<H.x<<\" bb \"<<H.y<<endl;\n                cnt=0;\n                while(++cnt<=100)\n                {\n                    M=L+H;\n                    M=M/2;\n\n                    if(areapolygoncircle(PP,M,r)>EPS) H=M;\n                    else L=M;\n                }\n\n                L=M;\n                R=L+T*1000;\n\n                //cout<<L.x<<\" \"<<L.y<<\" \"<<R.x<<\" ee \"<<R.y<<endl;\n                cnt=0;\n                while(++cnt<=100)\n                {\n                    TL=L*2+R;\n                    TL=TL/3;\n                    TR=L+R*2;\n                    TR=TR/3;\n\n                    ll=areapolygoncircle(PP,TL,r);\n                    rr=areapolygoncircle(PP,TR,r);\n                    //cout<<ll<<\" \"<<rr<<endl;\n                    if(rr<ll || fabs(ll-rr)<=EPS) R=TR;\n                    else L=TL;\n                }\n\n                ans=max(ans,(ll+rr)/2);\n\n            }\n\n        }\n    }\n\n    cout<<fixed<<setprecision(10)<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n  \nusing namespace std;\n#define x1 jkflwjjkfjekjfe\n#define x2 fwekwfefekfje\n  \nint iter = log(100 * 100 * 10000) / log(3) + 20;\ntypedef complex<double> P;\nstruct L{\n    P a,b;\n};\nvector<double> ax,ay;\nvector<L> ls;\ndouble R,cx,cy;\n  \nbool eq(double a,double b){\n    return fabs(a-b) < 1e-7;\n}\nbool eq2(double a,double b){\n    return fabs(a-b) < 1e-8;\n}\n  \npair<double,double> seg(double y){\n    double x1 = +1e5;\n    double x2 = -1e5;\n    for( auto &&l : ls){\n        if( eq(l.a.imag(),y) ){\n            x1 = min(x1,l.a.real());\n            x2 = max(x2,l.a.real());\n        }\n        if( eq(l.b.imag(),y) ){\n            x1 = min(x1,l.b.real());\n            x2 = max(x2,l.b.real());\n        }\n        if( l.a.imag() + 1e-7 < y and y < l.b.imag() - 1e-7 ){\n            P v = (l.b - l.a);\n            P p = l.a + v * (y-l.a.imag()) / v.imag();\n            x1 = min(x1,p.real());\n            x2 = max(x2,p.real());  \n        }\n    }\n    return {x1,x2};\n}\n  \ndouble len(pair<double,double> p){\n    if( p.first < p.second ) return p.second - p.first;\n    return 0;\n}\npair<double,double> merge(const pair<double,double> &a,const pair<double,double> &b){\n    return {max(a.first,b.first),min(a.second,b.second)};\n}\nmap<double,double> mp;\ndouble g(double y){\n\tif( mp.count(y) ) return mp[y];\n    if( R - abs(y-cy) < 1e-7 ) return 0;\n    // for given y, compute the overlapped length of the circle and the polygon.\n    double t = sqrt(R*R-(cy-y)*(cy-y));\n    pair<double,double> circle_seg = {cx-t,cx+t};\n    return mp[y] = len(merge(circle_seg,seg(y)));\n}\n  \ndouble simpson(double l,double r){\n    return (r-l)/6*(g(l)+4*g((l+r)/2)+g(r));\n}\ndouble integral(double l,double r,int k=3){\n    if( l >= r ) return 0;\n\tdouble m = (l+r)/2;\n\t\n\t\n    double A = simpson(l,m) + simpson(m,r);\n    double B = simpson(l,r);\n    if( k<=0 and eq2(A,B) ) return A;\n    else return integral(l,m,k-1) + integral(m,r,k-1);\n}\n  \ndouble f(double x,double y){\n    cx = x;\n    cy = y;\n    mp.clear();\n    double ans = 0;\n    for(int i = 0 ; i+1 < ay.size() ; i++){\n        ans += integral(max(cy-R,ay[i]),min(cy+R,ay[i+1]));\n    }\n \n    return ans;\n}\n         \ndouble search2(double y){\n    double ans = 0;\n    double l,r;\n  \n    tie(l,r) = seg(y);\n  \n    for(int i = 0 ; i < iter ; i++){\n        double a = (2*l+r) / 3;\n        double b = (l+2*r) / 3;\n        if( f(a,y) < f(b,y) ){\n            l = a;\n        }else{\n            r = b;\n        }\n    }\n    return f(l,y);\n}\n  \ndouble search1(){\n    double ans = 0;\n    double l = ay.front(), r = ay.back();\n    for(int i = 0 ; i < iter ; i++){\n        double a = (2*l+r) / 3;\n        double b = (l+2*r) / 3;\n        if( search2(a) < search2(b) ){\n            l = a;\n        }else{\n            r = b;\n        }\n    }\n     \n    return search2(l);\n}\n  \nint main(){\n    int n;\n    cin >> n >> R;\n    vector<P> g(n+1);\n    for(int i = 0 ; i < n ; i++){\n        double x,y;\n        cin >> x >> y;\n        g[i] = P(x,y);\n        ax.push_back(x);\n        ay.push_back(y);\n    }\n    g[n] = g[0];\n      \n    for(int i = 0 ; i < n ; i++){\n        ls.push_back({g[i],g[i+1]});\n        if( ls.back().a.imag() > ls.back().b.imag() ) swap(ls.back().a,ls.back().b);\n    }\n \n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    //printf(\"%.10lf\\n\",f(0,0));\n    //return 0;\n     \n    printf(\"%.10lf\\n\",search1());\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1000\n#define linf 1e18\n#define eps (1e-9)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n  double getArea(){ return r*r*pi;}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Point p,Circle c){ return abs(p-c.c)-c.r<-eps;}\nbool on(Point p,Circle c){ return fabs(abs(p-c.c)-c.r)<eps;}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\ndouble getArea(Polygon p){\n  double res=0;\n  for(int i=1;i<p.size()-1;i++)res+=cross(p[i]-p[0],p[i+1]-p[0])/2.0;\n  return res;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nbool iscrossLC(Line l,Circle c){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  if(!iscrossLC(s,c))return res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(abs(pp.s-s.p1)-abs(pp.f-s.p1)<eps)swap(pp.f,pp.s);\n  if(ccw(s.p1,s.p2,pp.f)==0)res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0)res.push_back(pp.s);\n  return res;\n}\n\nbool AllIn(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceLP(L,c.c)-c.r<-eps || ccw(L.p1,L.p2,c.c)==-1)return false;\n  }\n  return true;\n}\n\nbool AllOut(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  if(cross(a,b)<-eps)r=360.0-r;\n  return r;\n}\n\ndouble getCommonAreaTC(Polygon p,Circle c){\n  double res=getArea(p),carea=c.getArea();\n  int n=p.size();\n  /*\n  bool flag=false;\n  if(res<0.0){\n    flag=true;\n    reverse(p.begin(),p.end());\n    res=getArea(p);\n  }*/\n  vector<Point> s;\n  if(AllIn(p,c))return carea;\n  if(AllOut(p,c)) return 0.0;\n  int start=-1;\n  for(int i=0;i<n;i++){\n    if((c.r-abs(p[i]-c.c))<-eps)start=i;\n  }\n  if(start==-1)return res;\n  for(int i=0;i<n;i++){\n    vector<Point> vp=getCrossPointSC(c,Segment(p[(i+start)%n],\n\t\t\t\t\t       p[(i+1+start)%n]));    \n    for(int j=0;j<vp.size();j++){\n      bool b=true;\n      for(int k=0;k<s.size();k++)if(s[k]==vp[j])b=false;\n      if(b)s.push_back(vp[j]);\n    }\n  }\n\n  s.push_back(s[0]);\n  s.erase(s.begin());\n\n  for(int i=0;i<s.size();i+=2){\n    Point p1=s[i];\n    Point p2=s[i+1];\n    if(p1==p2)continue;\n    Polygon t;\n    t.push_back(p1);\n    t.push_back(p2);\n    t.push_back(c.c);\n    double narea= getArea(convex_cut(p,Line(p2,p1)));\n    if(narea<eps)continue;\n    res-=narea;\n    double ra=getAngle(p1-c.c,p2-c.c);\n    res+=((carea*ra/360.0)-getArea(t));\n  }\n  //if(!flag)return res;\n  return res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++){\n    Polygon t;\n    t.push_back(p[0]);\n    t.push_back(p[i]);\n    t.push_back(p[i+1]);\n    res+=getCommonAreaTC(t,c);\n  }\n  return res;\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,60){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*L,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=inf;\n    FOR(k,0,60){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\n\ntemplate<class T> using V = vector<T>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) { return (abs(a) <= EPS) ? 0 : (a < 0 ? -1 : 1); }\nint sgn(D a, D b) { return sgn(a-b); }\n\nstruct Pt2 {\n    D x, y;\n    Pt2(D _x = D(), D _y = D()) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n    \n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    bool operator<(const Pt2 &r) const { return 2*sgn(x, r.x)+sgn(y, r.y)<0; }\n    bool operator==(const Pt2 &r) const { return sgn((*this-r).rabs()) == 0; }\n\n    D norm() const { return x*x + y*y; }\n    D abs() const { return sqrt(norm()); }\n    D rabs() const { return max(std::abs(x), std::abs(y)); } // robust abs\n    D arg() const { return atan2(y, x); }\n};\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L(P _s = P(), P _t = P()) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n// cross(a, b) is too small?\nint sgncrs(P a, P b) {\n    D cr = cross(a, b);\n    if (abs(cr) <= (a.rabs() + b.rabs()) * EPS) return 0;\n    return (cr < 0) ? -1 : 1;\n}\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = sgncrs(b, c);\n    if (s) return s;\n    if (!sgn(c.rabs()) || !sgn((c-b).rabs())) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nP project(const L &l, const P &p) {\n    P v = l.vec();\n    return l.s + v * (dot(v, p-l.s) / v.norm());\n}\n\nD distLP(const L &l, const P &p) {\n    return abs(cross(l.vec(), p-l.s)) / l.abs();\n}\n\nint crossLL(const L &l, const L &m, P &r) {\n    D cr1 = cross(l.vec(), m.vec()), cr2 = cross(l.vec(), l.t - m.s);\n    if (sgncrs(l.vec(), m.vec()) == 0) {\n        r = l.s;\n        if (sgncrs(l.vec(), l.t - m.s)) return 0;\n        return -1;\n    }\n    r = m.s + m.vec() * (cr2 / cr1);\n    return 1;\n}\n\nusing Pol = V<P>;\n\nstruct C {\n    P p; D r;\n    C(P _p = P(), D _r = D()) : p(_p), r(_r) {}\n};\n\n//need Intersect/distLP, r.sはよりl.sに近い\nint crossCL(const C &c, const L &l, L &r) {\n    D u = distLP(l, c.p);\n    int si = sgn(u, c.r);    \n    if (si == 1) return 0;\n    P v = project(l, c.p);\n    P di = (si == 0) ? P(0, 0) : l.vec() * (sqrt(c.r*c.r - u*u) / l.abs());\n    r = L(v-di, v+di);\n    if (si == 0) return 1;\n    return 2;\n}\n\n//need Intersect/distLP, r.sはよりl.sに近い\nint crossCS(const C &c, const L &s, L &l) {\n    if (!crossCL(c, s, l)) return 0;\n    bool f1 = !ccw(s, l.s), f2 = !ccw(s, l.t);\n    if (f1 && f2) return 2;\n    if (!f1 && !f2) return 0;\n    if (f1) l.t = l.s;\n    else l.s = l.t;\n    return 1;\n}\n\n// C(P(0, 0), r)とTri((0, 0), a, b)の共有面積\nD area2CT(const C &c, const P &_a, const P &_b) {\n    P a = _a - c.p, b = _b - c.p; D r = c.r;\n    if (a == b) return 0;\n    auto single = [&](P x, P y, bool tri) {\n        if (tri) return cross(x, y);\n        else return r * r * ((y * P(x.x, -x.y)).arg());\n    };\n    bool ia = sgn(a.abs(), r) != 1, ib = sgn(b.abs(), r) != 1;\n    if (ia && ib) return single(a, b, true);\n    L l;\n    if (!crossCS(C(P(0, 0), r), L(a, b), l)) return single(a, b, false);\n    return single(a, l.s, ia) + single(l.s, l.t, true) + single(l.t, b, ib);\n}\n\n// p, cの共有面積\nD area2CPol(const C &c, const Pol &po) {\n    D sm = 0;\n    P a, b = po.back();\n    for (auto p: po) {\n        a = b; b = p;\n        sm += area2CT(c, a, b);\n    }\n    return sm;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    int n; D r;\n    cin >> n >> r;\n    Pol pol;\n \n    D ymi = 1e100, yma = -1e100;\n    for (int i = 0; i < n; i++) {\n        D x, y;\n        cin >> x >> y;\n        pol.push_back(P(x, y));\n        ymi = min(ymi, y);\n        yma = max(yma, y);\n    }\n \n    auto calc = [&](D y) {\n        D xmi = 1e100, xma = -1e100;\n        P a, b = pol.back();\n        for (int i = 0; i < n; i++) {\n            a = b; b = pol[i];\n            P p;\n            if (crossLL(L(a, b), L(P(0, y), P(1, y)), p) == 0) continue;\n            if (ccw(a, b, p) != 0) continue;\n            xmi = min(xmi, p.x); xma = max(xma, p.x);\n        }\n        D lw = xmi, up = xma;\n        for (int ph = 0; ph < 30; ph++) {\n            D md1 = (lw+lw+up) / 3;\n            D md2 = (lw+up+up) / 3;\n            D z1 = area2CPol(C(P(md1, y), r), pol) / 2;\n            D z2 = area2CPol(C(P(md2, y), r), pol) / 2;\n            if (z1 < z2) {\n                lw = md1;\n            } else {\n                up = md2;\n            }\n        }\n        return area2CPol(C(P(lw, y), r), pol) / 2;\n    };\n     \n    D lw = ymi, up = yma;\n    for (int ph = 0; ph < 30; ph++) {\n        D md1 = (lw+lw+up) / 3;\n        D md2 = (lw+up+up) / 3;\n        if (calc(md1) < calc(md2)) {\n            lw = md1;\n        } else {\n            up = md2;\n        }\n    }\n \n    cout << calc(lw) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1000\n#define linf 1e18\n#define eps (1e-9)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n  double getArea(){ return r*r*pi;}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Point p,Circle c){ return abs(p-c.c)-c.r<-eps;}\nbool on(Point p,Circle c){ return fabs(abs(p-c.c)-c.r)<eps;}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\ndouble getArea(Polygon p){\n  double res=0;\n  for(int i=1;i<p.size()-1;i++)res+=cross(p[i]-p[0],p[i+1]-p[0])/2.0;\n  return res;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nbool iscrossLC(Line l,Circle c){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  if(!iscrossLC(s,c))return res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(abs(pp.s-s.p1)-abs(pp.f-s.p1)<eps)swap(pp.f,pp.s);\n  if(ccw(s.p1,s.p2,pp.f)==0)res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0)res.push_back(pp.s);\n  return res;\n}\n\nbool AllIn(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceLP(L,c.c)-c.r<-eps || ccw(L.p1,L.p2,c.c)==-1)return false;\n  }\n  return true;\n}\n\nbool AllOut(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  if(cross(a,b)<-eps)r=360.0-r;\n  return r;\n}\n\ndouble getCommonAreaTC(Polygon p,Circle c){\n  double res=getArea(p),carea=c.getArea();\n  int n=p.size();\n  vector<Point> s;\n  if(AllIn(p,c))return carea;\n  if(AllOut(p,c)) return 0.0;\n  int start=-1;\n  for(int i=0;i<n;i++){\n    if((c.r-abs(p[i]-c.c))<-eps)start=i;\n  }\n  if(start==-1)return res;\n  for(int i=0;i<n;i++){\n    vector<Point> vp=getCrossPointSC(c,Segment(p[(i+start)%n],\n\t\t\t\t\t       p[(i+1+start)%n]));    \n    for(int j=0;j<vp.size();j++){\n      s.push_back(vp[j]);\n    }\n  }\n\n  s.push_back(s[0]);\n  s.erase(s.begin());\n\n  for(int i=0;i<s.size();i+=2){\n    Point p1=s[i];\n    Point p2=s[i+1];\n    if(p1==p2)continue;\n    Polygon t;\n    t.push_back(p1);\n    t.push_back(p2);\n    t.push_back(c.c);\n    double narea=getArea(convex_cut(p,Line(p2,p1)));\n    if(narea<eps)continue;\n    res-=narea;\n    double ra=getAngle(p1-c.c,p2-c.c);\n    res+=((carea*ra/360.0)-getArea(t));\n  }\n  return res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++){\n    Polygon t;\n    t.push_back(p[0]);\n    t.push_back(p[i]);\n    t.push_back(p[i+1]);\n    res+=getCommonAreaTC(t,c);\n  }\n  return res;\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,60){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*L,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=inf;\n    FOR(k,0,60){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector< P > vecp;\n  \nstruct S{\n  P p,q;\n  S(P p,P q) : p(p),q(q) {}  \n};\n  \nstruct C{\n  P p;  double r;\n  C(P p,double r):p(p),r(r){}\n  C(double x,double y,double rr){\n    p=P(x,y);\n    r=rr;\n  }\n};\n  \ndouble eps=1e-8,  PI=acos(-1),  PI2=PI*2.0;\n  \nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\nbool eq(P a,P b){return (abs(a-b)<eps);}\ndouble Sqrt(double x){  return ( x<0 ? 0.0 : sqrt(x) ); }\ndouble dot(P a,P b){return real(b*conj(a));}\ndouble cross(P a,P b){return imag(b*conj(a));}\n  \ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n  \nP project(P a,P b,P c){  b-=a; c-=a; return a+b*real(c/b); }\n  \ndouble getTime(P a,P b){\n  assert( eq(cross(a,b),0) );\n  return ( dot(a,b) < 0 ? -1.0 : 1.0 ) * abs(b);\n}\n  \nbool onSegment(P a,P b,P p){\n  return eq( abs(a-b) , abs(a-p)+abs(b-p) );\n}\n  \nP getCrossPoint(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n  \ndouble getArg(P a,P b){  return arg(b*conj(a)); }\n  \nvecp getCrossPoint(C c,P a,P b){\n  vecp res;\n  P base=b-a,  target=project(a,b,c.p);\n  double length=abs(base), h=abs(c.p-target);\n  if(c.r+eps<h)return res;\n  double w=Sqrt(c.r*c.r-h*h);\n  double L=getTime(base,target-a)-w, R=L+w*2.0;\n  base/=length;\n  if( -eps<L && L<length+eps )res.push_back(a+base*L);\n  if( eq(L,R) )return res;\n  if( -eps<R && R<length+eps )res.push_back(a+base*R);\n  return res;\n}\n  \nvecp getCrossPoint(C a,S b, bool debug=false){\n  vecp res;\n  P base=b.q-b.p,  target=project(b.p,b.q,a.p);\n  double length=abs(base), h=abs(a.p-target);\n  if(a.r+eps<h)return res;\n  double w=Sqrt(a.r*a.r-h*h);\n  double L=getTime(base,target-b.p)-w,  R=L+w*2.0;\n  base/=length;  \n  if( -eps<L && L< length+eps )res.push_back(b.p+base*L);\n  if( eq(L,R) )return res;\n  if( -eps<R && R< length+eps )res.push_back(b.p+base*R);\n  return res;\n}\n  \ndouble getArea(C c,P a,P b){\n  P va=c.p-a,  vb=c.p-b;\n  double A=abs(va), B=abs(vb);\n  double f=cross(va,vb), d=dist(a,b,c.p), res=0;\n  if( eq(0, f ) )return 0;\n  if(A<c.r+eps&&B<c.r+eps)return f*0.5;\n  if(d>c.r-eps)return c.r*c.r*PI*getArg(va,vb)/PI2;\n    \n  vecp u=getCrossPoint(c, S(a,b) );\n  assert( !u.empty() );\n  u.insert(u.begin(), a),  u.push_back(b);\n  \n  for(int i=0;i+1<(int)u.size();i++) res+=getArea(c,u[i],u[i+1]);\n  return res;\n}\n  \ndouble getArea(vecp t,C c){\n  int n=t.size();\n  if(n<3)return 0;\n  double res=0;\n  for(int i=0;i<n;i++){\n    P a=t[i], b=t[(i+1)%n];\n    res+=getArea(c,a,b);\n  }\n  return res;\n}\n  \nint n;\ndouble cr;\nvecp t;\n  \ndouble calc(double gx){\n  double left=1e9, right=-1e9;\n  for(int i=0;i<(int)t.size();i++){\n    P a=t[i];\n    P b=t[ (i+1)%n ];\n    P k=getCrossPoint( a,b, P(gx,0), P(gx,1) );\n    if( onSegment(a,b,k) == false )continue;\n    left=min(left,k.imag());\n    right=max(right,k.imag());\n  }\n    \n  for(int i=0;i<100;i++){\n    double dist=(right-left)/3.0;\n    double ml=left+dist;\n    double mr=right-dist;\n    if( getArea(t,C(P(gx,ml),cr)) > getArea(t,C(P(gx,mr),cr))){\n      right=mr;\n    }else{\n      left=ml;\n    }\n        \n  }\n  return getArea(t,C(P(gx,left),cr));\n}\n  \nint main(){\n  cin>>n>>cr;\n  double left=1e9, right=-1e9;\n    \n  for(int i=0;i<n;i++){\n    double x,y;\n    cin>>x>>y;\n    t.push_back(P(x,y));\n    left=min(left,x);\n    right=max(right,x);\n  }\n  \n  for(int i=0;i<100;i++){\n    double dist=(right-left)/3.0;\n    double ml=left+dist,mr=right-dist;\n    if( calc(ml) > calc(mr) )right=mr;\n    else left=ml;\n  }\n  printf(\"%.10f\\n\", calc(left) );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-9)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n\nPoint calc_ps(Polygon poly) {\n  poly = andrewScan(poly);\n  Point mp = poly[0];\n  double rate = 1; // 0.5???????????¨???\n  int max_pos;\n  double eps = 1e-10; // 1e-20???????????¨???\n  while( rate > eps ) {\n    rep(_,60){ // 70???????????¨???\n      max_pos = 0;\n      REP(j,1,(int)poly.size()) {\n        double dist1 = abs(mp-poly[max_pos]);\n        double dist2 = abs(mp-poly[j]);\n\tif( LT(dist1,dist2) ) max_pos = j;\n      }\n      mp.x += ( poly[max_pos].x - mp.x ) * rate;\n      mp.y += ( poly[max_pos].y - mp.y ) * rate;\n    }\n    rate *= 0.5;\n  }\n  return mp;\n}\n\nPoint getCentroidOfConvex(Polygon& poly){\n  double area = getArea(poly);\n  int V = poly.size();\n  assert( !equals(area,0.0) );\n  double x = 0, y = 0;\n  rep(i,(int)poly.size()) {\n    x += ( poly[i].x + poly[(i+1)%V].x ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n    y += ( poly[i].y + poly[(i+1)%V].y ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n  }\n  return Point(x/(6.0*area),y/(6.0*area));\n}\n\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  double maxi;\n  Point mp = calc_ps(poly);\n  maxi = getCommonAreaPolygonCircle(poly,mp,r);\n  double rate = 1.0;\n  double eps = 1e-10;\n  while( LT(eps,rate) ) {\n    rep(_,70) {\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      assert( !equals(max_area,-1) );\n      mp = np;\n      if( LT(maxi,max_area) ) maxi = max_area;\n    }\n    rate *= 0.5;\n  }\n  rep(__,10) {\n    Point mp = calc_ps(poly);\n    double rate = 1.0;\n    double eps = 1e-10;\n    while( LT(eps,rate) ) {\n      rep(_,70) {\n\tdouble max_area = -1; \n\tPoint np;\n\trep(i,n) {\n\t  Point tp = mp;\n\t  tp.x += ( poly[i].x - mp.x ) * rate;\n\t  tp.y += ( poly[i].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,tp,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t    np = tp;\n\t  }\n\t}\n\tif( rand() % 50 == 0 ) {\n\t  int v = rand() % n;\n\t  np.x = ( poly[v].x - mp.x ) * rate;\n\t  np.y = ( poly[v].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,np,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t  }\n\t}\n\tassert( !equals(max_area,-1) );\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      rate *= 0.5;\n    }\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  srand((unsigned int)time(NULL));\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  //cout << getArea(poly) << endl;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\nstruct L{P a, b;};\ntypedef vector<P> Pol;\nstruct C{P c; D r;};\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ninline int sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\n\ninline bool near(const P& a, const P& b) {return !sig(norm(a - b));}\n\nnamespace std {\n  inline bool operator<(const P& a, const P& b) {return sig(a.X, b.X) ? a.X < b.X : a.Y < b.Y;}\n}\n\ninline D sr(D a) {return sqrt(max(a, (D)0));}\n\ninline D dot(const P& a, const P& b) {return a.X * b.X + a.Y * b.Y;}\ninline D det(const P& a, const P& b) {return a.X * b.Y - a.Y * b.X;}\n\ninline P vec(const L& a) {return a.b - a.a;}\n\ninline D arg(const P& base, const P& a, const P& b) {return arg((b - base) / (a - base));}\n\ninline P proj(const P& a, const P& b) {return a * dot(a, b) / norm(a);}\ninline P perp(const L& l, const P& p) {return l.a + proj(vec(l), p - l.a);}\n\ninline pair<P, P> pCL(const C& c, const L& l) {\n  P x = perp(l, c.c);\n  P y = vec(l) / abs(vec(l)) * sr(c.r * c.r - norm(x - c.c));\n  return make_pair(x - y, x + y);\n}\n\ninline D aCTnc(D r, const P& p1, const P& p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? det(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\n\ninline D aCT(D r, const P& p1, const P& p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\n\ninline D aCPol(const C& c, const Pol& pol) {\n  D res = 0;\n  for (int i = 0; i < (int)pol.size(); ++i) res += aCT(c.r, pol[i] - c.c, pol[(i + 1) % pol.size()] - c.c);\n  return res;\n}\n\nint main() {\n  int n, r;\n  cin >> n >> r;\n  D x1 = 1e9, x2 = -1e9, y1 = 1e9, y2 = -1e9, a = 0;\n  Pol pol(n);\n  for (auto& p : pol) {\n    D x, y;\n    cin >> x >> y;\n    p = P(x, y);\n    x1 = min(x1, x);\n    x2 = max(x2, x);\n    y1 = min(y1, y);\n    y2 = max(y2, y);\n  }\n  for (int i = 0; i < 200; ++i) {\n    D xa = (2 * x1 + x2) / 3;\n    D yy1 = y1, yy2 = y2;\n    D aa1 = 0, aa2 = 0;\n    for (int j = 0; j < 200; ++j) {\n      D ya = (2 * yy1 + yy2) / 3;\n      D yb = (yy1 + 2 * yy2) / 3;\n      D a1 = aCPol(C({P(xa, ya), (D)r}), pol);\n      D a2 = aCPol(C({P(xa, yb), (D)r}), pol);\n      if (a1 > a2) yy2 = yb;\n      else yy1 = ya;\n      aa1 = max(a1, a2);\n    }\n    yy1 = y1;\n    yy2 = y2;\n    D xb = (x1 + 2 * x2) / 3;\n    for (int j = 0; j < 200; ++j) {\n      D ya = (2 * yy1 + yy2) / 3;\n      D yb = (yy1 + 2 * yy2) / 3;\n      D a1 = aCPol(C({P(xb, ya), (D)r}), pol);\n      D a2 = aCPol(C({P(xb, yb), (D)r}), pol);\n      if (a1 > a2) yy2 = yb;\n      else yy1 = ya;\n      aa2 = max(a1, a2);\n    }\n    if (aa1 > aa2) x2 = xb;\n    else x1 = xa;\n    a = max(aa1, aa2);\n  }\n  cout << fixed << setprecision(15) << a << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n#define double long double\nusing namespace std;\n#define x1 jkflwjjkfjekjfe\n#define x2 fwekwfefekfje\n\nint iter = log(100 * 100 * 10000) / log(3) + 30;\ntypedef complex<double> P;\nstruct L{\n\tP a,b;\n};\nvector<double> ax,ay;\nvector<L> ls;\ndouble R,cx,cy;\n\nbool eq(double a,double b){\n\treturn fabs(a-b) < 1e-8;\n}\nbool eq2(double a,double b){\n\treturn fabs(a-b) < 1e-8;\n}\n\npair<double,double> seg(double y){\n\tdouble x1 = +1e5;\n\tdouble x2 = -1e5;\n\tfor( auto &&l : ls){\n\t\tif( eq(l.a.imag(),y) ){\n\t\t\tx1 = min(x1,l.a.real());\n\t\t\tx2 = max(x2,l.a.real());\n\t\t}\n\t\tif( eq(l.b.imag(),y) ){\n\t\t\tx1 = min(x1,l.b.real());\n\t\t\tx2 = max(x2,l.b.real());\n\t\t}\n\t\tif( l.a.imag() + 1e-7 < y and y < l.b.imag() - 1e-7 ){\n\t\t\tP v = (l.b - l.a);\n\t\t\tP p = l.a + v * (y-l.a.imag()) / v.imag();\n\t\t\tx1 = min(x1,p.real());\n\t\t\tx2 = max(x2,p.real());\t\n\t\t}\n\t}\n\treturn {x1,x2};\n}\n\ndouble len(pair<double,double> p){\n\tif( p.first < p.second ) return p.second - p.first;\n\treturn 0;\n}\npair<double,double> merge(const pair<double,double> &a,const pair<double,double> &b){\n\treturn {max(a.first,b.first),min(a.second,b.second)};\n}\n\ndouble g(double y){\n\tif( R - abs(y-cy) < 1e-7 ) return 0;\n\t// for given y, compute the overlapped length of the circle and the polygon.\n\tdouble t = sqrt(R*R-(cy-y)*(cy-y));\n\tpair<double,double> circle_seg = {cx-t,cx+t};\n\treturn len(merge(circle_seg,seg(y)));\n}\n\ndouble simpson(double l,double r){\n\treturn (r-l)/6*(g(l)+4*g((l+r)/2)+g(r));\n}\ndouble integral(double l,double r){\n\tif( l >= r ) return 0;\n\n\tdouble m = (l+r) / 2;\n\tdouble A = simpson(l,m) + simpson(m,r);\n\tdouble B = simpson(l,r);\n\tif( eq2(A,B) ) return A;\n\telse return integral(l,m) + integral(m,r);\n}\n\ndouble f(double x,double y){\n\tcx = x;\n\tcy = y;\n\tdouble ans = 0;\n\tfor(int i = 0 ; i+1 < ay.size() ; i++){\n\t\tans += integral(max(cy-R,ay[i]),min(cy+R,ay[i+1]));\n\t}\n\treturn ans;\n}\n\ndouble search2(double y){\n\tdouble ans = 0;\n\tdouble l,r;\n\n\ttie(l,r) = seg(y);\n\n\tfor(int i = 0 ; i < iter ; i++){\n\t\tdouble a = (2*l+r) / 3;\n\t\tdouble b = (l+2*r) / 3;\n\t\tif( f(a,y) < f(b,y) ){\n\t\t\tl = a;\n\t\t}else{\n\t\t\tr = b;\n\t\t}\n\t}\n\treturn f(l,y);\n}\n\ndouble search1(){\n\tdouble ans = 0;\n\tdouble l = ay.front(), r = ay.back();\n\tfor(int i = 0 ; i < iter ; i++){\n\t\tdouble a = (2*l+r) / 3;\n\t\tdouble b = (l+2*r) / 3;\n\t\tif( search2(a) < search2(b) ){\n\t\t\tl = a;\n\t\t}else{\n\t\t\tr = b;\n\t\t}\n\t}\n\treturn search2(l);\n}\n\nint main(){\n\tint n;\n\tcin >> n >> R;\n\tvector<P> g(n+1);\n\tfor(int i = 0 ; i < n ; i++){\n\t\tdouble x,y;\n\t\tcin >> x >> y;\n\t\tg[i] = P(x,y);\n\t\tax.push_back(x);\n\t\tay.push_back(y);\n\t}\n\tg[n] = g[0];\n\t\n\tfor(int i = 0 ; i < n ; i++){\n\t\tls.push_back({g[i],g[i+1]});\n\t\tif( ls.back().a.imag() > ls.back().b.imag() ) swap(ls.back().a,ls.back().b);\n\t}\n\n\tsort(ax.begin(),ax.end());\n\tsort(ay.begin(),ay.end());\n\tax.erase(unique(ax.begin(),ax.end()),ax.end());\n\tay.erase(unique(ay.begin(),ay.end()),ay.end());\n\tprintf(\"%.10Lf\\n\",search1());\n\n}"
  },
  {
    "language": "C++",
    "code": "/***************************************\n    codeforces = topcoder = sahedsohel\n    IIT,Jahangirnagar University(42)\n****************************************/\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <iterator>\n#include <utility>\nusing namespace std;\n\n#define ll long long int\n#define ull unsigned long long int\n//#define inf (INT_MAX/10)\n#define linf (LLONG_MAX/10LL)\n#define sc(a) scanf(\"%d\",&a)\n#define sc2(a,b) scanf(\"%d%d\",&a,&b)\n#define sc3(a,b,c) scanf(\"%d%d%d\",&a,&b,&c)\n#define sc4(a,b,c,d) scanf(\"%d%d%d%d\",&a,&b,&c,&d)\n#define fl(c,i,n) for(i=c;i<n;i++)\n#define f(i,n) for(i=0;i<n;i++)\n#define mem(a) memset(a,0,sizeof(a))\n#define memn(a) memset(a,-1,sizeof(a))\n#define pb push_back\n#define pp pop_back()\n#define aov(a) a.begin(),a.end()\n#define mpr make_pair\n#define PI (2.0*acos(0.0)) //#define PI acos(-1.0)\n#define xx first\n#define yy second\n#define mxv(a) *max_element(aov(a))\n#define mnv(a) *min_element(aov(a))\n#define LB(a,x) (lower_bound(aov(a),x)-a.begin())\n#define UB(a,x) (upper_bound(aov(a),x)-a.begin())\n#define to_c_string(a) a.c_str()\n#define strtoint(c) atoi(&c[0])\n#define pii pair< int , int >\n#define pll pair< ll , ll >\n#define pcs(a) printf(\"Case %d: \", a)\n#define nl puts(\"\")\n#define dbg(x) cout<<#x<<\" : \"<<x<<endl\n\ntemplate <class T> inline T bigmod(T p,T e,T M){ll ret = 1;for(; e > 0; e >>= 1){if(e & 1) ret = (ret * p) % M;p = (p * p) % M;}return (T)ret;}\ntemplate <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}   // M is prime}\ntemplate <class T> inline T bpow(T p,T e){ll ret = 1;for(; e > 0; e >>= 1){if(e & 1) ret = (ret * p);p = (p * p);}return (T)ret;}\n\nint toInt(string s){int sm;stringstream ss(s);ss>>sm;return sm;}\nint toLlint(string s){long long int sm;stringstream ss(s);ss>>sm;return sm;}\n\n\n///int mnth[]={-1,31,28,31,30,31,30,31,31,30,31,30,31};  //Not Leap Year\n///int dx[]={1,1,0,-1,-1,-1,0,1};int dy[]={0,1,1,1,0,-1,-1,-1};//8 direction\n///int dx[]={2,1,-1,-2,-2,-1,1,2};int dy[]={1,2,2,1,-1,-2,-2,-1};//Knight Direction\n///int dx[]={-1,-1,+0,+1,+1,+0};int dy[]={-1,+1,+2,+1,-1,-2}; //Hexagonal Direction\n///const double eps=1e-6;\n///int dx[]={0,1,0,-1};int dy[]={1,0,-1,0}; //4 Direction\n\n/*****************************************************************/\n/// ////////////////////   GET SET GO    ////////////////////// ///\n/*****************************************************************/\n\n#define M 50025\n#define MD 100000007LL\n#define MX 5000\n\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\nconst double inf=1e20;\nconst int maxp=25;\nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;}\ninline double sqr(double x){return x*x;}\nstruct point\n{\n    double x,y;\n    point()             {                                    }\n    point(double _x,double _y){    x = _x; y = _y;           }\n    void input()        {   int a,b;scanf(\"%d%d\",&a,&b);x=a*1.0,y=b*1.0;           }// {   scanf(\"%lf%lf\",&x,&y);           }\n    void output()       {   printf(\"%.2f %.2f\\n\",x,y);       }\n    bool operator==(point a)const{\n        return dblcmp(a.x - x) == 0 && dblcmp(a.y - y) == 0;\n    }\n    bool operator<(point a)const{\n        return dblcmp(a.x - x) == 0 ? dblcmp(y - a.y) < 0 : x < a.x;\n    }\n    point operator-(point a)const{\n        return point(x-a.x, y-a.y);\n    }\n    double len()        {   return hypot(x, y);              }\n    double len2()       {   return x * x + y * y;            }\n    double distance(point p){return hypot(x - p.x, y - p.y); }\n    point add(point p)  {   return point(x + p.x, y + p.y);  }\n    point sub(point p)  {   return point(x - p.x, y - p.y);  }\n    point mul(double b) {   return point(x * b, y * b);      }\n    point div(double b) {   return point(x / b, y / b);      }\n    double dot(point p) {   return x*p.x+y*p.y;              }\n    double det(point p) {   return x*p.y-y*p.x;              }\n    double rad(point a,point b){\n        point p=*this;\n        return fabs(atan2(fabs(a.sub(p).det(b.sub(p))),a.sub(p).dot(b.sub(p))));\n    }\n    point trunc(double r){\n        double l=len();\n        if (!dblcmp(l))return *this;\n        r/=l;\n        return point(x*r,y*r);\n    }\n    point rotleft()     {   return point(-y,x);              }\n    point rotright()    {   return point(y,-x);              }\n    point rotate(point p,double angle){\n        point v=this->sub(p);\n        double c=cos(angle),s=sin(angle);\n        return point(p.x+v.x*c-v.y*s,p.y+v.x*s+v.y*c);\n    }\n};\n\nstruct line\n{\n    point a,b;\n    line()              {                                    }\n    line(point _a,point _b){ a=_a; b=_b;                     }\n    bool operator==(line v){ return (a==v.a)&&(b==v.b);      }\n    line(point p,double angle){\n        a=p;\n        if (dblcmp(angle-pi/2)==0){\n            b=a.add(point(0,1));\n        }else{\n            b=a.add(point(1,tan(angle)));\n        }\n    }\n    //ax+by+c=0\n    line(double _a,double _b,double _c){\n        if (dblcmp(_a)==0){\n            a=point(0,-_c/_b);\n            b=point(1,-_c/_b);\n        }else if (dblcmp(_b)==0){\n            a=point(-_c/_a,0);\n            b=point(-_c/_a,1);\n        }else{\n            a=point(0,-_c/_b);\n            b=point(1,(-_c-_a)/_b);\n        }\n    }\n    void input()        {   a.input(); b.input();            }\n    void adjust()       {   if(b<a)swap(a,b);                }\n    double length()     {   return a.distance(b);            }\n    double angle(){\n        double k=atan2(b.y-a.y,b.x-a.x);\n        if (dblcmp(k)<0)k+=pi;\n        if (dblcmp(k-pi)==0)k-=pi;\n        return k;\n    }\n    int relation(point p){\n        int c=dblcmp(p.sub(a).det(b.sub(a)));\n        if (c<0)return 1;\n        if (c>0)return 2;\n        return 3;\n    }\n    bool pointonseg(point p){\n        return dblcmp(p.sub(a).det(b.sub(a)))==0&&dblcmp(p.sub(a).dot(p.sub(b)))<=0;\n    }\n    bool parallel(line v){\n        return dblcmp(b.sub(a).det(v.b.sub(v.a)))==0;\n    }\n    int segcrossseg(line v){\n        int d1=dblcmp(b.sub(a).det(v.a.sub(a)));\n        int d2=dblcmp(b.sub(a).det(v.b.sub(a)));\n        int d3=dblcmp(v.b.sub(v.a).det(a.sub(v.a)));\n        int d4=dblcmp(v.b.sub(v.a).det(b.sub(v.a)));\n        if ((d1^d2)==-2&&(d3^d4)==-2)return 2;\n        return (d1==0&&dblcmp(v.a.sub(a).dot(v.a.sub(b)))<=0||\n            d2==0&&dblcmp(v.b.sub(a).dot(v.b.sub(b)))<=0||\n            d3==0&&dblcmp(a.sub(v.a).dot(a.sub(v.b)))<=0||\n            d4==0&&dblcmp(b.sub(v.a).dot(b.sub(v.b)))<=0);\n    }\n    int segcrossseg_inside(line v){\n        if(v.pointonseg(a) || v.pointonseg(b) || pointonseg(v.a) || pointonseg(v.b)) return 0;\n        int d1=dblcmp(b.sub(a).det(v.a.sub(a)));\n        int d2=dblcmp(b.sub(a).det(v.b.sub(a)));\n        int d3=dblcmp(v.b.sub(v.a).det(a.sub(v.a)));\n        int d4=dblcmp(v.b.sub(v.a).det(b.sub(v.a)));\n        if ((d1^d2)==-2&&(d3^d4)==-2)return 1;\n        return (d1==0&&dblcmp(v.a.sub(a).dot(v.a.sub(b)))<=0||\n            d2==0&&dblcmp(v.b.sub(a).dot(v.b.sub(b)))<=0||\n            d3==0&&dblcmp(a.sub(v.a).dot(a.sub(v.b)))<=0||\n            d4==0&&dblcmp(b.sub(v.a).dot(b.sub(v.b)))<=0);\n    }\n    int linecrossseg(line v){//*this seg v line\n        int d1=dblcmp(b.sub(a).det(v.a.sub(a)));\n        int d2=dblcmp(b.sub(a).det(v.b.sub(a)));\n        if ((d1^d2)==-2)return 2;\n        return (d1==0||d2==0);\n    }\n    int linecrossline(line v){\n        if ((*this).parallel(v)){\n            return v.relation(a)==3;\n        }\n        return 2;\n    }\n    point crosspoint(line v){\n        double a1=v.b.sub(v.a).det(a.sub(v.a));\n        double a2=v.b.sub(v.a).det(b.sub(v.a));\n        return point((a.x*a2-b.x*a1)/(a2-a1),(a.y*a2-b.y*a1)/(a2-a1));\n    }\n    double dispointtoline(point p){\n        return fabs(p.sub(a).det(b.sub(a)))/length();\n    }\n    double dispointtoseg(point p){\n        if (dblcmp(p.sub(b).dot(a.sub(b)))<0||dblcmp(p.sub(a).dot(b.sub(a)))<0){\n            return min(p.distance(a),p.distance(b));\n        }\n        return dispointtoline(p);\n    }\n    point lineprog(point p){\n        return a.add(b.sub(a).mul(b.sub(a).dot(p.sub(a))/b.sub(a).len2()));\n    }\n    point symmetrypoint(point p){\n        point q=lineprog(p);\n        return point(2*q.x-p.x,2*q.y-p.y);\n    }\n};\n\nstruct circle\n{\n    point p;\n    double r;\n    circle()            {                                    }\n    circle(point _p,double _r):     p(_p),r(_r){             };\n    circle(double x,double y,double _r): p(point(x,y)),r(_r){};\n    circle(point a,point b,point c){\n        p=line(a.add(b).div(2),a.add(b).div(2).add(b.sub(a).rotleft())).crosspoint(line(c.add(b).div(2),c.add(b).div(2).add(b.sub(c).rotleft())));\n        r=p.distance(a);\n    }\n    circle(point a,point b,point c,bool t){\n        line u,v;\n        double m=atan2(b.y-a.y,b.x-a.x),n=atan2(c.y-a.y,c.x-a.x);\n        u.a=a;\n        u.b=u.a.add(point(cos((n+m)/2),sin((n+m)/2)));\n        v.a=b;\n        m=atan2(a.y-b.y,a.x-b.x),n=atan2(c.y-b.y,c.x-b.x);\n        v.b=v.a.add(point(cos((n+m)/2),sin((n+m)/2)));\n        p=u.crosspoint(v);\n        r=line(a,b).dispointtoseg(p);\n    }\n    void input()        {   p.input();scanf(\"%lf\",&r);       }\n    void output() { printf(\"%.2lf %.2lf %.2lf\\n\",p.x,p.y,r); }\n    bool operator==(circle v){\n        return ((p==v.p)&&dblcmp(r-v.r)==0);\n    }\n    bool operator<(circle v)const{\n        return ((p<v.p)||(p==v.p)&&dblcmp(r-v.r)<0);\n    }\n    double area()       {   return pi*sqr(r);                }\n    double circumference(){ return 2*pi*r;                   }\n    int relation(point b){\n        double dst=b.distance(p);\n        if (dblcmp(dst-r)<0)return 2;\n        if (dblcmp(dst-r)==0)return 1;\n        return 0;\n    }\n    int relationseg(line v){\n        double dst=v.dispointtoseg(p);\n        if (dblcmp(dst-r)<0)return 2;\n        if (dblcmp(dst-r)==0)return 1;\n        return 0;\n    }\n    int relationline(line v){\n        double dst=v.dispointtoline(p);\n        if (dblcmp(dst-r)<0)return 2;\n        if (dblcmp(dst-r)==0)return 1;\n        return 0;\n    }\n    int getcircle(point a,point b,double r,circle&c1,circle&c2){\n        circle x(a,r),y(b,r);\n        int t=x.pointcrosscircle(y,c1.p,c2.p);\n        if (!t)return 0;\n        c1.r=c2.r=r;\n        return t;\n    }\n    int getcircle(line u,point q,double r1,circle &c1,circle &c2){\n        double dis=u.dispointtoline(q);\n        if (dblcmp(dis-r1*2)>0)return 0;\n        if (dblcmp(dis)==0){\n            c1.p=q.add(u.b.sub(u.a).rotleft().trunc(r1));\n            c2.p=q.add(u.b.sub(u.a).rotright().trunc(r1));\n            c1.r=c2.r=r1;\n            return 2;\n        }\n        line u1=line(u.a.add(u.b.sub(u.a).rotleft().trunc(r1)),u.b.add(u.b.sub(u.a).rotleft().trunc(r1)));\n        line u2=line(u.a.add(u.b.sub(u.a).rotright().trunc(r1)),u.b.add(u.b.sub(u.a).rotright().trunc(r1)));\n        circle cc=circle(q,r1);\n        point p1,p2;\n        if (!cc.pointcrossline(u1,p1,p2))cc.pointcrossline(u2,p1,p2);\n        c1=circle(p1,r1);\n        if (p1==p2)     {   c2=c1;return 1;                  }\n        c2=circle(p2,r1);\n        return 2;\n    }\n    int getcircle(line u,line v,double r1,circle &c1,circle &c2,circle &c3,circle &c4){\n        if (u.parallel(v))return 0;\n        line u1=line(u.a.add(u.b.sub(u.a).rotleft().trunc(r1)),u.b.add(u.b.sub(u.a).rotleft().trunc(r1)));\n        line u2=line(u.a.add(u.b.sub(u.a).rotright().trunc(r1)),u.b.add(u.b.sub(u.a).rotright().trunc(r1)));\n        line v1=line(v.a.add(v.b.sub(v.a).rotleft().trunc(r1)),v.b.add(v.b.sub(v.a).rotleft().trunc(r1)));\n        line v2=line(v.a.add(v.b.sub(v.a).rotright().trunc(r1)),v.b.add(v.b.sub(v.a).rotright().trunc(r1)));\n        c1.r=c2.r=c3.r=c4.r=r1;\n        c1.p=u1.crosspoint(v1);\n        c2.p=u1.crosspoint(v2);\n        c3.p=u2.crosspoint(v1);\n        c4.p=u2.crosspoint(v2);\n        return 4;\n    }\n    int getcircle(circle cx,circle cy,double r1,circle&c1,circle&c2){\n        circle x(cx.p,r1+cx.r),y(cy.p,r1+cy.r);\n        int t=x.pointcrosscircle(y,c1.p,c2.p);\n        if (!t)return 0;\n        c1.r=c2.r=r1;\n        return t;\n    }\n    int pointcrossline(line v,point &p1,point &p2){//求与?段交要先判断relationseg\n        if (!(*this).relationline(v))return 0;\n        point a=v.lineprog(p);\n        double d=v.dispointtoline(p);\n        d=sqrt(r*r-d*d);\n        if (dblcmp(d)==0){  p1=a; p2=a; return 1;            }\n        p1=a.sub(v.b.sub(v.a).trunc(d));\n        p2=a.add(v.b.sub(v.a).trunc(d));\n        return 2;\n    }\n    int relationcircle(circle v){\n        double d=p.distance(v.p);\n        if (dblcmp(d-r-v.r)>0)return 5;\n        if (dblcmp(d-r-v.r)==0)return 4;\n        double l=fabs(r-v.r);\n        if (dblcmp(d-r-v.r)<0&&dblcmp(d-l)>0)return 3;\n        if (dblcmp(d-l)==0)return 2;\n        if (dblcmp(d-l)<0)return 1;\n    }\n    int pointcrosscircle(circle v,point &p1,point &p2){\n        int rel=relationcircle(v);\n        if (rel==1||rel==5)return 0;\n        double d=p.distance(v.p);\n        double l=(d+(sqr(r)-sqr(v.r))/d)/2;\n        double h=sqrt(sqr(r)-sqr(l));\n        p1=p.add(v.p.sub(p).trunc(l).add(v.p.sub(p).rotleft().trunc(h)));\n        p2=p.add(v.p.sub(p).trunc(l).add(v.p.sub(p).rotright().trunc(h)));\n        if (rel==2||rel==4)return 1;\n        return 2;\n    }\n    int tangentline(point q,line &u,line &v){\n        int x=relation(q);\n        if (x==2)return 0;\n        if (x==1){\n            u=line(q,q.add(q.sub(p).rotleft()));\n            v=u; return 1;\n        }\n        double d=p.distance(q);\n        double l=sqr(r)/d;\n        double h=sqrt(sqr(r)-sqr(l));\n        u=line(q,p.add(q.sub(p).trunc(l).add(q.sub(p).rotleft().trunc(h))));\n        v=line(q,p.add(q.sub(p).trunc(l).add(q.sub(p).rotright().trunc(h))));\n        return 2;\n    }\n    double areacircle(circle v){\n        int rel=relationcircle(v);\n        if (rel>=4)return 0.0;\n        if (rel<=2)return min(area(),v.area());\n        double d=p.distance(v.p);\n        double hf=(r+v.r+d)/2.0;\n        double ss=2*sqrt(hf*(hf-r)*(hf-v.r)*(hf-d));\n        double a1=acos((r*r+d*d-v.r*v.r)/(2.0*r*d));\n        a1=a1*r*r;\n        double a2=acos((v.r*v.r+d*d-r*r)/(2.0*v.r*d));\n        a2=a2*v.r*v.r;\n        return a1+a2-ss;\n    }\n    double areatriangle(point a,point b){\n        if (dblcmp(p.sub(a).det(p.sub(b))==0))return 0.0;\n        point q[5];\n        int len=0;\n        q[len++]=a;\n        line l(a,b);\n        point p1,p2;\n        if (pointcrossline(l,q[1],q[2])==2){\n            if (dblcmp(a.sub(q[1]).dot(b.sub(q[1])))<0)q[len++]=q[1];\n            if (dblcmp(a.sub(q[2]).dot(b.sub(q[2])))<0)q[len++]=q[2];\n        }\n        q[len++]=b;\n        if (len==4&&(dblcmp(q[0].sub(q[1]).dot(q[2].sub(q[1])))>0))swap(q[1],q[2]);\n        double res=0;\n        int i;\n        for (i=0;i<len-1;i++){\n            if (relation(q[i])==0||relation(q[i+1])==0){\n                double arg=p.rad(q[i],q[i+1]);\n                res+=r*r*arg/2.0;\n            }\n            else res+=fabs(q[i].sub(p).det(q[i+1].sub(p))/2.0);\n        }\n        return res;\n    }\n};\nstruct polygon\n{\n    int n;\n    point p[maxp];\n    line l[maxp];\n    void input(int _n){\n        n=_n;\n        for (int i=0;i<n;i++)   p[i].input();\n    }\n    void add(point q)   {   p[n++]=q;                        }\n    void getline(){\n        for (int i=0;i<n;i++)\n            l[i]=line(p[i],p[(i+1)%n]);\n    }\n    struct cmp{\n        point p;\n        cmp(const point &p0){p=p0;}\n        bool operator()(const point &aa,const point &bb){\n            point a=aa,b=bb;\n            int d=dblcmp(a.sub(p).det(b.sub(p)));\n            if (d==0)\n                return dblcmp(a.distance(p)-b.distance(p))<0;\n            return d>0;\n        }\n    };\n    double areacircle(circle c){\n        int i,j,k,l,m;\n        double ans=0;\n        for (i=0;i<n;i++){\n            int j=(i+1)%n;\n            if (dblcmp(p[j].sub(c.p).det(p[i].sub(c.p)))>=0)\n                ans+=c.areatriangle(p[i],p[j]);\n            else ans-=c.areatriangle(p[i],p[j]);\n            //cerr<<i<<\" \"<<ans<<endl;\n        }\n        //cerr<<n<<\" \"<<c.r<<\" => \"<<ans<<endl;\n        return fabs(ans);\n    }\n};\n\nint n,r;\npolygon rs,a;\ncircle q;\npoint pl,ph;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);\n//    freopen(\"in.txt\",\"r\",stdin);\n    int t,i,j,k;\n\n    double ans=0.0,lox,loy,hix,hiy;\n\n    lox=loy=LLONG_MAX;\n    hix=hiy=-LLONG_MAX;\n    cin>>n>>r;\n    a.n=0;\n    rs.n=0;\n    f(i,n)\n    {\n        cin>>j>>k;\n        a.p[a.n].x=j;\n        a.p[a.n++].y=k;\n        rs.p[rs.n].x=j;\n        rs.p[rs.n++].y=k;\n        lox=min(lox,j*1.0);\n        hix=max(hix,j*1.0);\n\n        loy=min(loy,k*1.0);\n        hiy=max(hiy,k*1.0);\n    }\n\n    double dx,dy,x,y;\n    dx=(hix-lox)/(MX*1.0);\n    dy=(hiy-loy)/(MX*1.0);\n    for(i=0,x=lox;i<MX;i++,x+=dx)\n    {\n        for(j=0,y=loy;j<MX;j++,y+=dy)\n        {\n            q.p=point(x,y);\n            q.r=r*1.0;\n            ans=max(ans,rs.areacircle(q));\n        }\n        //cerr<<x<<\" \"<<y<<endl;\n        //cerr<<i<<\" \"<<ans<<endl;\n    }\n\n\n    cout<<setprecision(10)<<fixed<<ans<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n==0) ? 1 : 10*TEN(n-1); }\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nstruct Pt2 {\n    D x, y;\n    Pt2() {}\n    Pt2(D _x, D _y) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    Pt2 operator/(const D &r) const { return Pt2(x/r, y/r); }\n\n    Pt2& operator+=(const Pt2 &r) { return *this=*this+r; }\n    Pt2& operator-=(const Pt2 &r) { return *this=*this-r; }\n    Pt2& operator*=(const Pt2 &r) { return *this=*this*r; }\n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    D abs() const { return sqrt(x*x + y*y); }\n    D rabs() const { return max(::abs(x), ::abs(y)); } // robust abs\n    D arg() const { return atan2(y, x); }\n\n    pair<D, D> to_pair() const { return make_pair(x, y); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    os << \"(\" << p.x << \", \" << p.y << \")\";\n    return os;\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L() {}\n    L(P _s, P _t) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\n\nint sgn(D a) {\n    if (abs(a) <= EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\nint sgn(D a, D b) { return sgn(a-b); }\n//relative sign\nint rsgn(D a, D f) {\n    if (abs(a) <= f*EPS) return 0;\n    return (a < 0) ? -1 : 1;\n}\nbool near(P a, P b) { return !sgn((a-b).abs()); }\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = rsgn(cross(b, c), b.rabs());\n    if (s) return s;\n    if (!sgn(c.rabs()) || !sgn((c-b).rabs())) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\n\nD distLP(const L &l, const P &p) {\n    return abs(cross(l.vec(), p-l.s)) / l.abs();\n}\n\nD distSP(const L &s, const P &p) {\n    P s2 = s.vec() * P(0, 1);\n    if (ccw(s.s, s.s+s2, p) == 1) return (s.s-p).abs();\n    if (ccw(s.t, s.t+s2, p) == -1) return (s.t-p).abs();\n    return distLP(s, p);\n}\n\nint crossLL(const L &l, const L &m, P &r) {\n    if (sgn(cross(l.vec(), m.vec())) == 0) {\n        r = l.s;\n        if (ccw(l.s, l.t, m.s) % 2 == 0) return -1;\n        return 0;\n    }\n    D t = cross(l.vec(), l.t - m.s) / cross(l.vec(), m.vec());\n    r = m.s + m.vec() * t;\n    return 1;\n}\n\nusing Pol = V<P>;\n\nstruct C {\n    P p; D r;\n    C() {}\n    C(P p, D r) : p(p), r(r) {}\n};\n\nD insAreaTC(const P &a, const P &b, const D &r) {\n    if (near(a, b)) return 0;\n    D r2 = distSP(L(a, b), P(0, 0));\n//    cout << \"Z \" << a << \" \" << b << \" \" << c.p << \" \" << c.r << endl;\n    if (sgn(max(a.abs(), b.abs()), r) != 1) return cross(a, b) / 2;\n    if (sgn(r, r2) != 1) {\n        D ar = b.arg() - a.arg();\n        ar = fmod(fmod(ar, 2*PI) + 2*PI, 2*PI);\n        if (!sgn(ar - 2*PI)) ar = 0;\n        if (ar >= PI) ar -= 2*PI;\n        return r * r * ar / 2;\n    }\n    return insAreaTC(a, (a+b)/2, r) + insAreaTC((a+b)/2, b, r);\n}\n\nconst P& c_at(const Pol &p, int idx) {\n    int n = int(p.size());\n    return p[idx < n ? idx : idx-n];\n}\nD insAreaPolC(const Pol &p, const C &c) {\n    int n = int(p.size());\n    D sm = 0;\n    for (int i = 0; i < n; i++) {\n        sm += insAreaTC(p[i] - c.p, c_at(p, i+1) - c.p, c.r);\n    }\n    return sm;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    int n; D r;\n    cin >> n >> r;\n    Pol pol;\n\n    D ymi = 1e100, yma = -1e100;\n    for (int i = 0; i < n; i++) {\n        D x, y;\n        cin >> x >> y;\n        pol.push_back(P(x, y));\n        ymi = min(ymi, y);\n        yma = max(yma, y);\n    }\n\n    auto calc = [&](D y) {\n        D xmi = 1e100, xma = -1e100;\n        for (int i = 0; i < n; i++) {\n            P p;\n            if (crossLL(L(pol[i], c_at(pol, i+1)), L(P(0, y), P(1, y)), p) == 0) continue;\n            if (ccw(pol[i], c_at(pol, i+1), p) != 0) continue;\n            xmi = min(xmi, p.x); xma = max(xma, p.x);\n        }\n        D lw = xmi, up = xma;\n        for (int ph = 0; ph < 50; ph++) {\n            D md1 = (lw+lw+up) / 3;\n            D md2 = (lw+up+up) / 3;\n            D z1 = insAreaPolC(pol, C(P(md1, y), r));\n            D z2 = insAreaPolC(pol, C(P(md2, y), r));\n            if (z1 < z2) {\n                lw = md1;\n            } else {\n                up = md2;\n            }\n        }\n        return insAreaPolC(pol, C(P(lw, y), r));\n    };\n    \n    D lw = ymi, up = yma;\n    for (int ph = 0; ph < 50; ph++) {\n        D md1 = (lw+lw+up) / 3;\n        D md2 = (lw+up+up) / 3;\n        if (calc(md1) < calc(md2)) {\n            lw = md1;\n        } else {\n            up = md2;\n        }\n    }\n\n    cout << calc(lw) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n  \nusing namespace std;\n#define x1 jkflwjjkfjekjfe\n#define x2 fwekwfefekfje\n  \nint iter = log(100 * 100 * 10000) / log(3) + 20;\ntypedef complex<double> P;\nstruct L{\n    P a,b;\n};\nvector<double> ax,ay;\nvector<L> ls;\ndouble R,cx,cy;\n  \nbool eq(double a,double b){\n    return fabs(a-b) < 1e-7;\n}\nbool eq2(double a,double b){\n    return fabs(a-b) < 1e-8;\n}\n  \npair<double,double> seg(double y){\n    double x1 = +1e5;\n    double x2 = -1e5;\n    for( auto &&l : ls){\n        if( eq(l.a.imag(),y) ){\n            x1 = min(x1,l.a.real());\n            x2 = max(x2,l.a.real());\n        }\n        if( eq(l.b.imag(),y) ){\n            x1 = min(x1,l.b.real());\n            x2 = max(x2,l.b.real());\n        }\n        if( l.a.imag() + 1e-7 < y and y < l.b.imag() - 1e-7 ){\n            P v = (l.b - l.a);\n            P p = l.a + v * (y-l.a.imag()) / v.imag();\n            x1 = min(x1,p.real());\n            x2 = max(x2,p.real());  \n        }\n    }\n    return {x1,x2};\n}\n  \ndouble len(pair<double,double> p){\n    if( p.first < p.second ) return p.second - p.first;\n    return 0;\n}\npair<double,double> merge(const pair<double,double> &a,const pair<double,double> &b){\n    return {max(a.first,b.first),min(a.second,b.second)};\n}\n  \ndouble g(double y){\n    if( R - abs(y-cy) < 1e-7 ) return 0;\n    // for given y, compute the overlapped length of the circle and the polygon.\n    double t = sqrt(R*R-(cy-y)*(cy-y));\n    pair<double,double> circle_seg = {cx-t,cx+t};\n    return len(merge(circle_seg,seg(y)));\n}\n  \ndouble simpson(double l,double r){\n    return (r-l)/6*(g(l)+4*g((l+r)/2)+g(r));\n}\ndouble integral(double l,double r,int k=5){\n    if( l >= r ) return 0;\n\tint a = 4000 + rand() % 2001;\n\tint b = 10000 - a;\n\tdouble m = (a*l+b*r)/(a+b);\n\t\n\t\n    double A = simpson(l,m) + simpson(m,r);\n    double B = simpson(l,r);\n    if(eq2(A,B) ) return A;\n    else return integral(l,m,k-1) + integral(m,r,k-1);\n}\n  \ndouble f(double x,double y){\n    cx = x;\n    cy = y;\n    double ans = 0;\n    for(int i = 0 ; i+1 < ay.size() ; i++){\n        ans += integral(max(cy-R,ay[i]),min(cy+R,ay[i+1]));\n    }\n \n    return ans;\n}\n         \ndouble search2(double y){\n    double ans = 0;\n    double l,r;\n  \n    tie(l,r) = seg(y);\n  \n    for(int i = 0 ; i < iter ; i++){\n        double a = (2*l+r) / 3;\n        double b = (l+2*r) / 3;\n        if( f(a,y) < f(b,y) ){\n            l = a;\n        }else{\n            r = b;\n        }\n    }\n    return f(l,y);\n}\n  \ndouble search1(){\n    double ans = 0;\n    double l = ay.front(), r = ay.back();\n    for(int i = 0 ; i < iter ; i++){\n        double a = (2*l+r) / 3;\n        double b = (l+2*r) / 3;\n        if( search2(a) < search2(b) ){\n            l = a;\n        }else{\n            r = b;\n        }\n    }\n     \n    return search2(l);\n}\n  \nint main(){\n    int n;\n    cin >> n >> R;\n    vector<P> g(n+1);\n    for(int i = 0 ; i < n ; i++){\n        double x,y;\n        cin >> x >> y;\n        g[i] = P(x,y);\n        ax.push_back(x);\n        ay.push_back(y);\n    }\n    g[n] = g[0];\n      \n    for(int i = 0 ; i < n ; i++){\n        ls.push_back({g[i],g[i+1]});\n        if( ls.back().a.imag() > ls.back().b.imag() ) swap(ls.back().a,ls.back().b);\n    }\n \n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    //printf(\"%.10lf\\n\",f(0,0));\n    //return 0;\n     \n    printf(\"%.10lf\\n\",search1());\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <map>\n#include <set>\n#include <vector>\n#include <bitset>\nusing namespace std;\n//#define f(i, x, y) for (int i = x; i <= y; ++i)\n#define fd(i, x, y) for (int i = x; i >= y; --i)\n#define rep(i, x, y) for (int i = x; i <= y; ++i)\n#define repd(i, x, y) for (int i = x; i >= y; --i)\n#define sqr(x) ((x)*(x))\n\nconst int maxn=20;\ndouble eps;\nint n,R,xl=100,xr=0,yl=100,yr=0;\nstruct node{\n\tint x,y;\n\tvoid read(){\n\t\tcin >> x >> y;\n\t}\n}p[maxn];\n\nvoid init()\n{\n\tcin >> n >> R;\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\tp[i].read();\n\t\txl=min(xl,p[i].x);\n\t\txr=max(xr,p[i].x);\n\t\tyl=min(yl,p[i].y);\n\t\tyr=max(yr,p[i].y);\n\t}\n\tp[0]=p[n];\n\tif (max(xr, yr) > 40) eps = 1e-7; else eps=1e-10;\n}\n\ndouble f(double xx,double x,double y)\n{\n\tif(xx<x-R)return 0;\n\tif(xx>x+R)return 0;\n\tdouble mi,mx;\n\tmi=y-sqrt(sqr(R)-sqr(xx-x));\n\tmx=y+sqrt(sqr(R)-sqr(xx-x));\n\tdouble y1=100,y2=0;\n\tfor(int i = 0;i < n;i++)\n\t{\n\t\tif((p[i].x-xx)*(p[i+1].x-xx)<eps)\n\t\t{\n\t\t\tif(p[i].x==p[i+1].x)\n\t\t\t{\n\t\t\t\ty2=max(y2,(double)max(p[i].y,p[i+1].y));\n\t\t\t\ty1=min(y1,(double)min(p[i].y,p[i+1].y));\n\t\t\t}\n\t\t\telse\n\t\t\t{\t\n\t\t\t\tdouble yy=p[i].y+(p[i+1].y-p[i].y)*(xx-p[i].x)/(p[i+1].x-p[i].x);\n\t\t\t\ty2=max(y2,yy);\n\t\t\t\ty1=min(y1,yy);\n\t\t\t}\n\t\t}\n\t}\n\tmi=max(y1,mi);\n\tmx=min(y2,mx);\n\treturn max(mx-mi,0.0);\n}\n\ndouble sum(double l,double r,double x,double y)\n{\n\tdouble mid=(l+r)/2;\n\treturn (f(l,x,y)+f(r,x,y)+4*f(mid,x,y))*(r-l)/6;\n}\n\ndouble simpson(double l,double r,double x,double y)\n{\n\tif (l > r) return 0;\n\tdouble mid=(l+r)/2;\n\tdouble s=sum(l,r,x,y),s1=sum(l,mid,x,y),s2=sum(mid,r,x,y);\n\tif(abs(s-s1-s2)<eps)return s;\n\treturn simpson(l,mid,x,y)+simpson(mid,r,x,y);\n}\n\ndouble gets(double x,double y)\n{\n\t//printf(\"%.6lf\\n\",simpson(xl,xr,x,y));\n\treturn simpson(max(x-R,(double)xl),min((double)xr,x+R),x,y);\n}\n\ndouble gets(double x)\n{\n\tdouble l=yl,r=yr;\n\twhile(r-l>eps)\n\t{\n\t\tdouble len=(r-l)/3;\n\t\tif(gets(x,l+len)>gets(x,r-len))r=r-len;\n\t\telse l=l+len;\n\t}\n\treturn gets(x,(l+r)/2);\n}\n\nvoid solve()\n{\n\tdouble l=xl,r=xr;\n\twhile(r-l>eps)\n\t{\n\t\tdouble len=(r-l)/3;\n\t\tif(gets(l+len)>gets(r-len))r=r-len;\n\t\telse l=l+len;\n\t}\n\tprintf(\"%.12lf\\n\",gets((l+r)/2));\n\t//printf(\"%.12lf %.12lf\\n\",l,r);\n\t//printf(\"%.12lf\\n\",gets(l + 0.1));\n\t//printf(\"%.12lf\\n\",gets(l - 0.1));\n}\nint main()\n{\t\n\tcin.sync_with_stdio(0);\n\tinit();\n\t//if (n == 3 && R == 1 && p[1].x == 0 && p[1].y == 0 && p[2].x == 2 && p[2].y == 1 && p[3].x == 1 && p[3].y == 3)\n//\t\tprintf(\"2.113100\\n\");\n//\telse \n\tsolve();\n\t/*double qmax = 0;\n\tfor (double i = 0; i <= 3; i += 0.001)\n\tfor (double j = 0; j <= 3; j += 0.001)\n\t\tqmax = max(qmax,gets(i, j));\n\tprintf(\"%.12lf\\n\",qmax);*/\n\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1.0);\nconst double EPS=1e-5;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-5;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n\nPoint root(Line l,Point p){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n\ndouble sqr(double x){ return x*x; }\ndouble mysqrt(double x){ return sqrt(max(0.0,x)); }\n\nint getCrossCS(Circle c,Line s,Point *ret){\n    double x0=c.o.x,y0=c.o.y;\n    double x1=s.a.x,y1=s.a.y;\n    double x2=s.b.x,y2=s.b.y;\n    double dx=x2-x1,dy=y2-y1;\n    double A=dx*dx+dy*dy;\n    double B=2*dx*(x1-x0)+2*dy*(y1-y0);\n    double C=(x1-x0)*(x1-x0)+(y1-y0)*(y1-y0)-c.r*c.r;\n    double delta=B*B-4*A*C;\n    int num=0;\n    if(dcmp(delta)>=0){\n        double t1=(-B-mysqrt(delta))/(2*A);\n        double t2=(-B+mysqrt(delta))/(2*A);\n        if(dcmp(t1-1)<=0&&dcmp(t1)>=0) ret[num++]=Point(x1+t1*dx,y1+t1*dy);\n        if(dcmp(t2-1)<=0&&dcmp(t2)>=0) ret[num++]=Point(x1+t2*dx,y1+t2*dy);\n    }\n    return num;\n}\n\ndouble SectorArea(Point a,Point b,Circle c){\n    a=a-c.o,b=b-c.o;\n    double theta=atan2(a.y,a.x)-atan2(b.y,b.x);\n    while(dcmp(theta)<=0) theta+=2.0*PI;\n    while(dcmp(theta-2.0*PI)>0) theta-=2.0*PI;\n    theta=min(theta,2.0*PI-theta);\n    return c.r*c.r*theta*0.5;\n}\n\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=0.0;\n    Point OA=a-c.o,OB=b-c.o;\n    double la=length(OA),lb=length(OB);\n    Point cs[4];\n    bool aic=dcmp(la-c.r)<=0,bic=dcmp(lb-c.r)<=0;\n    int s=dcmp(cross(OA,OB));\n    if(!s) return 0.0;\n    if(aic){\n        if(bic){\n            atc=fabs(cross(OA,OB))*0.5;\n        }else{\n            int num=getCrossCS(c,Line(a,b),cs);\n            atc=SectorArea(cs[0],b,c)+fabs(cross(OA,cs[0]-c.o))*0.5;\n        }\n    }else{\n        if(bic){\n            int num=getCrossCS(c,Line(a,b),cs);\n            atc=SectorArea(cs[0],a,c)+fabs(cross(OB,cs[0]-c.o))*0.5;\n        }else{\n            int num=getCrossCS(c,Line(a,b),cs);\n            if(num==2){\n                if(distPP(a,cs[0])>distPP(a,cs[1])) swap(cs[0],cs[1]);\n                atc=SectorArea(a,cs[0],c)+SectorArea(b,cs[1],c)+fabs(cross(cs[0]-c.o,cs[1]-c.o))*0.5;\n            }else{\n                atc=SectorArea(a,b,c);\n            }\n        }\n    }\n    return 1.0*s*atc;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=getAreaTC(Pts[n-1],Pts[0],c);\n    for(int i=0;i<n-1;i++) apc+=getAreaTC(Pts[i],Pts[i+1],c);\n    return fabs(apc);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<200;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<200;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);cin.tie(0);\n    //cout<<getAreaTC(Point(3,3),Point(-3,3),Circle(Point(0,0),4))<<endl;\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\n\ntemplate<class T> using V = vector<T>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) { return (abs(a) <= EPS) ? 0 : (a < 0 ? -1 : 1); }\nint sgn(D a, D b) { return sgn(a-b); }\n//relative sign\n// int rsgn(D a, D f) {\n//     if (abs(a) <= f*EPS) return 0;\n//     return (a < 0) ? -1 : 1;\n// }\nstruct Pt2 {\n    D x, y;\n    Pt2(D _x = D(), D _y = D()) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    Pt2 operator/(const D &r) const { return Pt2(x/r, y/r); }\n\n    Pt2& operator+=(const Pt2 &r) { return *this=*this+r; }\n    Pt2& operator-=(const Pt2 &r) { return *this=*this-r; }\n    Pt2& operator*=(const Pt2 &r) { return *this=*this*r; }\n    Pt2& operator*=(const D &r) { return *this=*this*r; }\n    Pt2& operator/=(const D &r) { return *this=*this/r; }\n    \n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    bool operator<(const Pt2 &r) const { return 2*sgn(x, r.x)+sgn(y, r.y)<0; }\n    bool operator==(const Pt2 &r) const { return sgn((*this-r).rabs()) == 0; }\n\n    D norm() const { return x*x + y*y; }\n    D abs() const { return sqrt(norm()); }\n    D rabs() const { return max(std::abs(x), std::abs(y)); } // robust abs\n    D arg() const { return atan2(y, x); }\n\n    pair<D, D> to_pair() const { return make_pair(x, y); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    return os << \"P(\" << p.x << \", \" << p.y << \")\";\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L(P _s = P(), P _t = P()) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\nostream& operator<<(ostream& os, const L &l) {\n    return os << \"L(\" << l.s << \", \" << l.t << \")\";\n}\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n// cross(a, b) is too small?\nint sgncrs(P a, P b) {\n    D cr = cross(a, b);\n    if (abs(cr) <= (a.rabs() + b.rabs()) * EPS) return 0;\n    return (cr < 0) ? -1 : 1;\n}\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = sgncrs(b, c);\n    if (s) return s;\n    if (!sgn(c.rabs()) || !sgn((c-b).rabs())) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nP project(const L &l, const P &p) {\n    P v = l.vec();\n    return l.s + v * (dot(v, p-l.s) / v.norm());\n}\n\nbool insSL(const L &s, const L &l) {\n    int a = ccw(l, s.s), b = ccw(l, s.t);\n    return (a%2 == 0 || b%2 == 0 || a != b);\n}\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s, t.s), b = ccw(s, t.t);\n    int c = ccw(t, s.s), d = ccw(t, s.t);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nD distLP(const L &l, const P &p) {\nreturn abs(cross(l.vec(), p-l.s)) / l.abs();\n}\n\nD distSP(const L &s, const P &p) {\n    P q = project(s, p);\n    if (ccw(s, q) == 0) return (p - q).abs();\n    else return min((s.s - p).abs(), (s.t - p).abs());\n}\n\nint crossLL(const L &l, const L &m, P &r) {\n    D cr1 = cross(l.vec(), m.vec()), cr2 = cross(l.vec(), l.t - m.s);\n    if (sgncrs(l.vec(), m.vec()) == 0) {\n        r = l.s;\n        if (sgncrs(l.vec(), l.t - m.s)) return 0;\n        return -1;\n    }\n    r = m.s + m.vec() * (cr2 / cr1);\n    return 1;\n}\n\nusing Pol = V<P>;\n\nstruct C {\n    P p; D r;\n    C(P _p = P(), D _r = D()) : p(_p), r(_r) {}\n};\n\n//need Intersect/distLP, r.sはよりl.sに近い\nint crossCL(const C &c, const L &l, L &r) {\n    D u = distLP(l, c.p);\n    int si = sgn(u, c.r);    \n    if (si == 1) return 0;\n    P v = project(l, c.p);\n    P di = (si == 0) ? P(0, 0) : l.vec() * (sqrt(c.r*c.r - u*u) / l.abs());\n    r = L(v-di, v+di);\n    if (si == 0) return 1;\n    return 2;\n}\n\n//need Intersect/distLP, r.sはよりl.sに近い\nint crossCS(const C &c, const L &s, L &l) {\n    if (!crossCL(c, s, l)) return 0;\n    bool f1 = ccw(s, l.s) == 0, f2 = ccw(s, l.t) == 0;\n    if (f1 && f2) return 2;\n    if (!f1 && !f2) return 0;\n    if (f1) l.t = l.s;\n    else l.s = l.t;\n    return 1;\n}\n\n// C(P(0, 0), r)とTri((0, 0), a, b)の共有面積\nD area2CT(const C &c, const P &_a, const P &_b) {\n    P a = _a - c.p, b = _b - c.p; D r = c.r;\n    if (a == b) return 0;\n    auto single = [&](P x, P y, bool tri) {\n        if (tri) return cross(x, y);\n        else return r * r * ((y * P(x.x, -x.y)).arg());\n    };\n    bool ia = sgn(a.abs(), r) != 1, ib = sgn(b.abs(), r) != 1;\n    if (ia && ib) return single(a, b, true);\n//    if (sgn(r, distSP(L(a, b), P(0, 0))) != 1) return single(a, b, false);\n    L l;\n    if (!crossCS(C(P(0, 0), r), L(a, b), l)) return single(a, b, false);\n    if (ia) l.s = l.t;\n    else if (ib) l.t = l.s;\n    assert(ccw(a, b, l.s) == 0); assert(ccw(a, b, l.t) == 0);\n    return single(a, l.s, ia) + single(l.s, l.t, true) + single(l.t, b, ib);\n}\n\n// p, cの共有面積\nD area2CPol(const C &c, const Pol &po) {\n    D sm = 0;\n    P a, b = po.back();\n    for (auto p: po) {\n        a = b; b = p;\n        sm += area2CT(c, a, b);\n    }\n    return sm;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    int n; D r;\n    cin >> n >> r;\n    Pol pol;\n \n    D ymi = 1e100, yma = -1e100;\n    for (int i = 0; i < n; i++) {\n        D x, y;\n        cin >> x >> y;\n        pol.push_back(P(x, y));\n        ymi = min(ymi, y);\n        yma = max(yma, y);\n    }\n \n    auto calc = [&](D y) {\n        D xmi = 1e100, xma = -1e100;\n        P a, b = pol.back();\n        for (int i = 0; i < n; i++) {\n            a = b; b = pol[i];\n            P p;\n            if (crossLL(L(a, b), L(P(0, y), P(1, y)), p) == 0) continue;\n            if (ccw(a, b, p) != 0) continue;\n            xmi = min(xmi, p.x); xma = max(xma, p.x);\n        }\n        D lw = xmi, up = xma;\n        for (int ph = 0; ph < 30; ph++) {\n            D md1 = (lw+lw+up) / 3;\n            D md2 = (lw+up+up) / 3;\n            D z1 = area2CPol(C(P(md1, y), r), pol) / 2;\n            D z2 = area2CPol(C(P(md2, y), r), pol) / 2;\n            if (z1 < z2) {\n                lw = md1;\n            } else {\n                up = md2;\n            }\n        }\n        return area2CPol(C(P(lw, y), r), pol) / 2;\n    };\n     \n    D lw = ymi, up = yma;\n    for (int ph = 0; ph < 30; ph++) {\n        D md1 = (lw+lw+up) / 3;\n        D md2 = (lw+up+up) / 3;\n        if (calc(md1) < calc(md2)) {\n            lw = md1;\n        } else {\n            up = md2;\n        }\n    }\n \n    cout << calc(lw) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n \nusing namespace std;\n#define x1 jkflwjjkfjekjfe\n#define x2 fwekwfefekfje\n \nint iter = log(100 * 100 * 10000) / log(3) + 20;\ntypedef complex<double> P;\nstruct L{\n\tP a,b;\n};\nvector<double> ax,ay;\nvector<L> ls;\ndouble R,cx,cy;\n \nbool eq(double a,double b){\n\treturn fabs(a-b) < 1e-7;\n}\nbool eq2(double a,double b){\n\treturn fabs(a-b) < 1e-8;\n}\n \npair<double,double> seg(double y){\n\tdouble x1 = +1e5;\n\tdouble x2 = -1e5;\n\tfor( auto &&l : ls){\n\t\tif( eq(l.a.imag(),y) ){\n\t\t\tx1 = min(x1,l.a.real());\n\t\t\tx2 = max(x2,l.a.real());\n\t\t}\n\t\tif( eq(l.b.imag(),y) ){\n\t\t\tx1 = min(x1,l.b.real());\n\t\t\tx2 = max(x2,l.b.real());\n\t\t}\n\t\tif( l.a.imag() + 1e-7 < y and y < l.b.imag() - 1e-7 ){\n\t\t\tP v = (l.b - l.a);\n\t\t\tP p = l.a + v * (y-l.a.imag()) / v.imag();\n\t\t\tx1 = min(x1,p.real());\n\t\t\tx2 = max(x2,p.real());  \n\t\t}\n\t}\n\treturn {x1,x2};\n}\n \ndouble len(pair<double,double> p){\n\tif( p.first < p.second ) return p.second - p.first;\n\treturn 0;\n}\npair<double,double> merge(const pair<double,double> &a,const pair<double,double> &b){\n\treturn {max(a.first,b.first),min(a.second,b.second)};\n}\n \ndouble g(double y){\n\tif( R - abs(y-cy) < 1e-7 ) return 0;\n\t// for given y, compute the overlapped length of the circle and the polygon.\n\tdouble t = sqrt(R*R-(cy-y)*(cy-y));\n\tpair<double,double> circle_seg = {cx-t,cx+t};\n\treturn len(merge(circle_seg,seg(y)));\n}\n \ndouble simpson(double l,double r){\n\treturn (r-l)/6*(g(l)+4*g((l+r)/2)+g(r));\n}\ndouble integral(double l,double r,int k=5){\n\tif( l >= r ) return 0;\n \n\tdouble m = (l+r) / 2;\n\tdouble A = simpson(l,m) + simpson(m,r);\n\tdouble B = simpson(l,r);\n\tif( k<=0 and eq2(A,B) ) return A;\n\telse return integral(l,m,k-1) + integral(m,r,k-1);\n}\n \ndouble f(double x,double y){\n\tcx = x;\n\tcy = y;\n\tdouble ans = 0;\n\tfor(int i = 0 ; i+1 < ay.size() ; i++){\n\t\tans += integral(max(cy-R,ay[i]),min(cy+R,ay[i+1]));\n\t}\n\n\treturn ans;\n}\n\t\t\ndouble search2(double y){\n\tdouble ans = 0;\n\tdouble l,r;\n \n\ttie(l,r) = seg(y);\n \n\tfor(int i = 0 ; i < iter ; i++){\n\t\tdouble a = (2*l+r) / 3;\n\t\tdouble b = (l+2*r) / 3;\n\t\tif( f(a,y) < f(b,y) ){\n\t\t\tl = a;\n\t\t}else{\n\t\t\tr = b;\n\t\t}\n\t}\n\treturn f(l,y);\n}\n \ndouble search1(){\n\tdouble ans = 0;\n\tdouble l = ay.front(), r = ay.back();\n\tfor(int i = 0 ; i < iter ; i++){\n\t\tdouble a = (2*l+r) / 3;\n\t\tdouble b = (l+2*r) / 3;\n\t\tif( search2(a) < search2(b) ){\n\t\t\tl = a;\n\t\t}else{\n\t\t\tr = b;\n\t\t}\n\t}\n\t\n\treturn search2(l);\n}\n \nint main(){\n\tint n;\n\tcin >> n >> R;\n\tvector<P> g(n+1);\n\tfor(int i = 0 ; i < n ; i++){\n\t\tdouble x,y;\n\t\tcin >> x >> y;\n\t\tg[i] = P(x,y);\n\t\tax.push_back(x);\n\t\tay.push_back(y);\n\t}\n\tg[n] = g[0];\n\t \n\tfor(int i = 0 ; i < n ; i++){\n\t\tls.push_back({g[i],g[i+1]});\n\t\tif( ls.back().a.imag() > ls.back().b.imag() ) swap(ls.back().a,ls.back().b);\n\t}\n\n\tsort(ax.begin(),ax.end());\n\tsort(ay.begin(),ay.end());\n\tax.erase(unique(ax.begin(),ax.end()),ax.end());\n\tay.erase(unique(ay.begin(),ay.end()),ay.end());\n\t//printf(\"%.10lf\\n\",f(0,0));\n \t//return 0;\n \t\n\tprintf(\"%.10lf\\n\",search1());\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1.0);\n//const double EPS=1e-10;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=0;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n\nPoint root(Line l,Point p){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n\ndouble mysqrt(double x){ return sqrt(max(0.0,x)); }\nint getCrossCS(Circle c,Line s,Point *ret){\n    double x0=c.o.x,y0=c.o.y;\n    double x1=s.a.x,y1=s.a.y;\n    double x2=s.b.x,y2=s.b.y;\n    double dx=x2-x1,dy=y2-y1;\n    double A=dx*dx+dy*dy;\n    double B=2.0*dx*(x1-x0)+2.0*dy*(y1-y0);\n    double C=(x1-x0)*(x1-x0)+(y1-y0)*(y1-y0)-c.r*c.r;\n    double delta=B*B-4.0*A*C;\n    int num=0;\n    if(dcmp(delta)>=0){\n        double t1=(-B-mysqrt(delta))/(2.0*A);\n        double t2=(-B+mysqrt(delta))/(2.0*A);\n        if(dcmp(t1-1)<=0&&dcmp(t1)>=0) ret[num++]=Point(x1+t1*dx,y1+t1*dy);\n        if(dcmp(t2-1)<=0&&dcmp(t2)>=0) ret[num++]=Point(x1+t2*dx,y1+t2*dy);\n        //如果没有if判断，?是求直?和?的交点\n    }\n    return num;\n}\ndouble SectorArea(Point a,Point b,Circle c){\n    a=a-c.o,b=b-c.o;\n    double theta=atan2(a.y,a.x)-atan2(b.y,b.x);\n    while(dcmp(theta)<=0) theta+=2.0*PI;\n    while(dcmp(theta-2.0*PI)>0) theta-=2.0*PI;\n    theta=min(theta,2.0*PI-theta);\n    return c.r*c.r*theta*0.5;\n}\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=0.0;\n    Point OA=a-c.o,OB=b-c.o;\n    double la=length(OA),lb=length(OB);\n    Point cs[4];\n    bool aic=dcmp(la-c.r)<=0,bic=dcmp(lb-c.r)<=0;\n    if(aic&&bic) return fabs(cross(OA,OB))*0.5;\n    int num=getCrossCS(c,Line(a,b),cs);\n    if(aic) return SectorArea(cs[0],b,c)+fabs(cross(OA,cs[0]-c.o))*0.5;\n    if(bic) return SectorArea(cs[0],a,c)+fabs(cross(OB,cs[0]-c.o))*0.5;\n    if(num==2) return SectorArea(a,cs[0],c)+\n        SectorArea(b,cs[1],c)+fabs(cross(cs[0]-c.o,cs[1]-c.o))*0.5;\n    return SectorArea(a,b,c);\n}\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=0.0;\n    for(int i=0;i<n;i++){\n        int s=dcmp(cross(Pts[i]-c.o,Pts[i+1]-c.o));\n        if(!!s) apc+=getAreaTC(Pts[i],Pts[i+1],c)*s;\n    }\n    return fabs(apc);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<200;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<200;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);cin.tie(0);\n    //cout<<getAreaTC(Point(3,3),Point(-3,3),Circle(Point(0,0),4))<<endl;\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1.0);\nconst double EPS=1e-8;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-10;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n\nPoint root(Line l,Point p){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n\ndouble mysqrt(double x){ return sqrt(max(0.0,x)); }\nint getCrossCS(Circle c,Line s,Point *ret){\n    double x0=c.o.x,y0=c.o.y;\n    double x1=s.a.x,y1=s.a.y;\n    double x2=s.b.x,y2=s.b.y;\n    double dx=x2-x1,dy=y2-y1;\n    double A=dx*dx+dy*dy;\n    double B=2.0*dx*(x1-x0)+2.0*dy*(y1-y0);\n    double C=(x1-x0)*(x1-x0)+(y1-y0)*(y1-y0)-c.r*c.r;\n    double delta=B*B-4.0*A*C;\n    int num=0;\n    if(dcmp(delta)>=0){\n        double t1=(-B-mysqrt(delta))/(2.0*A);\n        double t2=(-B+mysqrt(delta))/(2.0*A);\n        if(dcmp(t1-1)<=0&&dcmp(t1)>=0) ret[num++]=Point(x1+t1*dx,y1+t1*dy);\n        if(dcmp(t2-1)<=0&&dcmp(t2)>=0) ret[num++]=Point(x1+t2*dx,y1+t2*dy);\n        //如果没有if判断，?是求直?和?的交点\n    }\n    return num;\n}\ndouble SectorArea(Point a,Point b,Circle c){\n    a=a-c.o,b=b-c.o;\n    double theta=atan2(a.y,a.x)-atan2(b.y,b.x);\n    while(dcmp(theta)<=0) theta+=2.0*PI;\n    while(dcmp(theta-2.0*PI)>0) theta-=2.0*PI;\n    theta=min(theta,2.0*PI-theta);\n    return c.r*c.r*theta*0.5;\n}\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=0.0;\n    Point OA=a-c.o,OB=b-c.o;\n    double la=length(OA),lb=length(OB);\n    Point cs[4];\n    bool aic=dcmp(la-c.r)<=0,bic=dcmp(lb-c.r)<=0;\n    int s=dcmp(cross(OA,OB));\n    if(!s) return 0.0;\n    if(aic&&bic) atc=fabs(cross(OA,OB))*0.5;\n    else if(aic){\n        int num=getCrossCS(c,Line(a,b),cs);\n        atc=SectorArea(cs[0],b,c)+fabs(cross(OA,cs[0]-c.o))*0.5;\n    }else if(bic){\n        int num=getCrossCS(c,Line(a,b),cs);\n        atc=SectorArea(cs[0],a,c)+fabs(cross(OB,cs[0]-c.o))*0.5;\n    }else{\n        int num=getCrossCS(c,Line(a,b),cs);\n        if(num==2){\n            if(distPP(a,cs[0])>distPP(a,cs[1])) swap(cs[0],cs[1]);\n            atc=SectorArea(a,cs[0],c)+SectorArea(b,cs[1],c)+fabs(cross(cs[0]-c.o,cs[1]-c.o))*0.5;\n        }else{\n            atc=SectorArea(a,b,c);\n        }\n    }\n    return atc;\n}\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=0.0;\n    for(int i=0;i<n;i++){\n        int s=dcmp(cross(Pts[i]-c.o,Pts[i+1]-c.o));\n        if(!!s) apc+=getAreaTC(Pts[i],Pts[i+1],c)*s;\n    }\n    return fabs(apc);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);cin.tie(0);\n    //cout<<getAreaTC(Point(3,3),Point(-3,3),Circle(Point(0,0),4))<<endl;\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <map>\n#include <set>\n#include <vector>\n#include <bitset>\nusing namespace std;\n//#define f(i, x, y) for (int i = x; i <= y; ++i)\n#define fd(i, x, y) for (int i = x; i >= y; --i)\n#define rep(i, x, y) for (int i = x; i <= y; ++i)\n#define repd(i, x, y) for (int i = x; i >= y; --i)\n#define sqr(x) ((x)*(x))\n\nconst int maxn=20;\ndouble eps;\nint n,R,xl=100,xr=0,yl=100,yr=0;\nstruct node{\n\tint x,y;\n\tvoid read(){\n\t\tcin >> x >> y;\n\t}\n}p[maxn];\n\nvoid init()\n{\n\tcin >> n >> R;\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\tp[i].read();\n\t\txl=min(xl,p[i].x);\n\t\txr=max(xr,p[i].x);\n\t\tyl=min(yl,p[i].y);\n\t\tyr=max(yr,p[i].y);\n\t}\n\tp[0]=p[n];\n\tif (max(xr, yr) > 20) eps = 1e-7; else eps=1e-11;\n}\n\ndouble f(double xx,double x,double y)\n{\n\tif(xx<x-R)return 0;\n\tif(xx>x+R)return 0;\n\tdouble mi,mx;\n\tmi=y-sqrt(sqr(R)-sqr(xx-x));\n\tmx=y+sqrt(sqr(R)-sqr(xx-x));\n\tdouble y1=100,y2=0;\n\tfor(int i = 0;i < n;i++)\n\t{\n\t\tif((p[i].x-xx)*(p[i+1].x-xx)<eps)\n\t\t{\n\t\t\tif(p[i].x==p[i+1].x)\n\t\t\t{\n\t\t\t\ty2=max(y2,(double)max(p[i].y,p[i+1].y));\n\t\t\t\ty1=min(y1,(double)min(p[i].y,p[i+1].y));\n\t\t\t}\n\t\t\telse\n\t\t\t{\t\n\t\t\t\tdouble yy=p[i].y+(p[i+1].y-p[i].y)*(xx-p[i].x)/(p[i+1].x-p[i].x);\n\t\t\t\ty2=max(y2,yy);\n\t\t\t\ty1=min(y1,yy);\n\t\t\t}\n\t\t}\n\t}\n\tmi=max(y1,mi);\n\tmx=min(y2,mx);\n\treturn max(mx-mi,0.0);\n}\n\ndouble sum(double l,double r,double x,double y)\n{\n\tdouble mid=(l+r)/2;\n\treturn (f(l,x,y)+f(r,x,y)+4*f(mid,x,y))*(r-l)/6;\n}\n\ndouble simpson(double l,double r,double x,double y)\n{\n\tif (l > r) return 0;\n\tdouble mid=(l+r)/2;\n\tdouble s=sum(l,r,x,y),s1=sum(l,mid,x,y),s2=sum(mid,r,x,y);\n\tif(abs(s-s1-s2)<eps)return s;\n\treturn simpson(l,mid,x,y)+simpson(mid,r,x,y);\n}\n\ndouble gets(double x,double y)\n{\n\t//printf(\"%.6lf\\n\",simpson(xl,xr,x,y));\n\treturn simpson(max(x-R,(double)xl),min((double)xr,x+R),x,y);\n}\n\ndouble gets(double x)\n{\n\tdouble l=yl,r=yr;\n\twhile(r-l>eps)\n\t{\n\t\tdouble len=(r-l)/3;\n\t\tif(gets(x,l+len)>gets(x,r-len))r=r-len;\n\t\telse l=l+len;\n\t}\n\treturn gets(x,(l+r)/2);\n}\n\nvoid solve()\n{\n\tdouble l=xl,r=xr;\n\twhile(r-l>eps)\n\t{\n\t\tdouble len=(r-l)/3;\n\t\tif(gets(l+len)>gets(r-len))r=r-len;\n\t\telse l=l+len;\n\t}\n\tprintf(\"%.12lf\\n\",gets((l+r)/2));\n\t//printf(\"%.12lf %.12lf\\n\",l,r);\n\t//printf(\"%.12lf\\n\",gets(l + 0.1));\n\t//printf(\"%.12lf\\n\",gets(l - 0.1));\n}\nint main()\n{\t\n\tcin.sync_with_stdio(0);\n\tinit();\n\t//if (n == 3 && R == 1 && p[1].x == 0 && p[1].y == 0 && p[2].x == 2 && p[2].y == 1 && p[3].x == 1 && p[3].y == 3)\n//\t\tprintf(\"2.113100\\n\");\n//\telse \n\tsolve();\n\t/*double qmax = 0;\n\tfor (double i = 0; i <= 3; i += 0.001)\n\tfor (double j = 0; j <= 3; j += 0.001)\n\t\tqmax = max(qmax,gets(i, j));\n\tprintf(\"%.12lf\\n\",qmax);*/\n\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#define N 10005\nusing namespace std;\nconst int maxn = 111111;\nconst int maxisn = 21;\nconst double eps = 1e-8;\nconst double pi = acos(-1.0);\nint dcmp(double x)\n{\n    if(x > eps) return 1;\n    return x < -eps ? -1 : 0;\n}\nstruct Point\n{\n    double x, y;\n    Point(){x = y = 0;}\n    Point(double a, double b)\n    {x = a, y = b;}\n    inline Point operator-(const Point &b)const{return Point(x - b.x, y - b.y);}\n    inline Point operator+(const Point &b)const{return Point(x + b.x, y + b.y);}\n    inline Point operator*(const double &b)const{return Point(x * b, y * b);}\n    inline double dot(const Point &b)const{return x * b.x + y * b.y;}\n    inline double cross(const Point &b, const Point &c)const\n\t{return (b.x - x) * (c.y - y) - (c.x - x) * (b.y - y);}\n    inline double Dis(const Point &b)const\n    {return sqrt((*this - b).dot(*this - b));}\n    inline bool InLine(const Point &b, const Point &c)const//三点共?\n    {return !dcmp(cross(b, c));}\n    inline bool OnSeg(const Point &b, const Point &c)const//点在?段上，包括端点\n    {return InLine(b, c) && (*this - c).dot(*this - b) < eps;}\n}a[N],d[N];\ninline double min(double a, double b){return a < b ? a : b;}\ninline double max(double a, double b){return a > b ? a : b;}\ninline double Sqr(double x){return x * x;}\ninline double Sqr(const Point &p){return p.dot(p);}\nPoint LineCross(const Point &a, const Point &b, const Point &c, const Point &d)\n{\n    double u = a.cross(b, c), v = b.cross(a, d);\n    return Point((c.x * v + d.x * u) / (u + v), (c.y * v + d.y * u) / (u + v));\n}\ndouble LineCrossCircle(const Point &a, const Point &b, const Point &r, \n            double R, Point &p1, Point &p2)\n{\n    Point fp = LineCross(r, Point(r.x + a.y - b.y, r.y + b.x - a.x), a, b);\n    double rtol = r.Dis(fp);\n    double rtos = fp.OnSeg(a, b) ? rtol : min(r.Dis(a), r.Dis(b));\n    double atob = a.Dis(b);\n    double fptoe = sqrt(R * R - rtol * rtol) / atob;\n    if(rtos > R - eps) return rtos;\n    p1 = fp + (a - b) * fptoe;\n    p2 = fp + (b - a) * fptoe;\n    return rtos;\n}\ndouble SectorArea(const Point &r, const Point &a, const Point &b, double R)\n{\n    double A2 = Sqr(r - a), B2 = Sqr(r - b), C2 = Sqr(a - b);\n    return R * R * acos((A2 + B2 - C2) * 0.5 / sqrt(A2) / sqrt(B2)) * 0.5;\n}\ndouble TACIA(const Point &r, const Point &a, const Point &b, double R)\n{\n    double adis = r.Dis(a), bdis = r.Dis(b);\n    if(adis < R + eps && bdis < R + eps) return r.cross(a, b) * 0.5;\n    Point ta, tb;\n    if(r.InLine(a, b)) return 0.0;\n    double rtos = LineCrossCircle(a, b, r, R, ta, tb);\n    if(rtos > R - eps) return SectorArea(r, a, b, R);\n    if(adis < R + eps) return r.cross(a, tb) * 0.5 + SectorArea(r, tb, b, R);\n    if(bdis < R + eps) return r.cross(ta, b) * 0.5 + SectorArea(r, a, ta, R);\n    return r.cross(ta, tb) * 0.5 + \n        SectorArea(r, a, ta, R) + SectorArea(r, tb, b, R);\n}\nbool operator < (Point a,Point b){if (a.x!=b.x) return a.x<b.x;return a.y<b.y;}\nint n;\ndouble SPICA(int n, Point r, double R)//SimplePolygonIntersectCircleArea\n{\n    int i;\n    Point ori, p[2];\n    //scanf(\"%lf%lf\", &ori.x, &ori.y);\n    ori.x=a[1].x;ori.x=a[1].y;\n    p[0] = ori;\n    double res = 0, if_clock_t;\n    int t=1;\n    for(i = 1; i <= n; ++ i)\n    {\n        if(i == n) p[i & 1] = ori;else \n\t\t{\n\t\t\tt++;\n\t\t\tp[i & 1].x=a[t].x;\n\t\t\tp[i & 1].y=a[t].y;\n\t\t}\n\t\t//scanf(\"%lf%lf\", &p[i & 1].x, &p[i & 1].y);\n        if_clock_t = dcmp(r.cross(p[~i & 1], p[i & 1]));\n        if(if_clock_t < 0) res -= TACIA(r, p[i & 1], p[~i & 1], R);\n        else res += TACIA(r, p[~i & 1], p[i & 1], R);\n    }\n    return fabs(res);\n}\ndouble R,t,maxans,ansi,ansj;\ndouble calc1(double x)\n{\n\tdouble l=1000,r=-100,m1,m2,f1=0,f2=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\t//printf(\"dee%lf\\n\",((a[i].x-x) * (a[i+1].x-x)));\n\t\tif (dcmp((a[i].x-x) * (a[i+1].x-x))<=0)\n\t\t{\n\t\t\tPoint tmp;\n\t\t\ttmp.x=a[i].x+(a[i+1].x-a[i].x)/(a[i+1].x-a[i].x)*(x-a[i].x);\n\t\t\ttmp.y=a[i].y+(a[i+1].y-a[i].y)/(a[i+1].x-a[i].x)*(x-a[i].x);\n\t\t//\tprintf(\"yp%lf %lf\\n\",tmp.x,tmp.y);\t\n\t\t\tl=min(l,tmp.y);\n\t\t\tr=max(r,tmp.y);\n\t\t}\n\t}\n\t//printf(\"lllrr%lf %lf\\n\",l,r);\n\twhile (l+eps<r)\n\t{\n\t\tm1=(l+l+r)/3.0; \t\n\t\tPoint bom=Point(x,m1);\n\t\tf1=SPICA(n,bom,R);\n\t\tm2=(l+r+r)/3.0;\t\t\n\t\tbom=Point(x,m2); \n\t\tf2=SPICA(n,bom,R);\t\n\t\tif (f1>f2) r=m2;else l=m1;\n\t}\n\treturn f1;\n}\nint main()\n{\n\tscanf(\"%d%lf\",&n,&R);\n\t\n\tdouble l=1000,r=-100,m1,m2,f1,f2;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lf%lf\",&a[i].x,&a[i].y);\n\t\tl=min(l,a[i].x);\n\t\tr=max(r,a[i].x);\n\t}\n\ta[n+1]=a[1];\t//printf(\"%d\\n\",n);\n//\tfor (int i=1;i<=n;i++)\tprintf(\"%.lf %.lf\\n\",d[i].x,d[i].y);\n\twhile (l+eps<r)\n\t{\n\t\tm1=(l+l+r)/3.0;f1=calc1(m1);\n\t\tm2=(l+r+r)/3.0;f2=calc1(m2);\n\t\tif (f1>f2) r=m2;else l=m1;\n\t}\n\tprintf(\"%.4lf\\n\",f1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cout if (0) cout\n\n// XXX without explanation marks untested functions\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pii;\n#define pb push_back\n\n// NOT STANDART FROM HERE\n\n// area de calota 2.pi.R.h (h altura)\n// volume de calota pi.h/6 * (3r^2 + h^2)\n\n typedef double cood;\n cood eps = 1e-8;\n// tests for double were made with eps = 1e-8\n\ndouble eps_d = 1e-8; // necessary even in integer geometry, should be eps otherwise\n\nconst double pi = acos(-1.);\n\ninline ll sq (ll x)\n{ return x*x; }\ninline double sq (double x)\n{ return x*x; }\n\nstruct vec { // vector\n\t// === BASIC ===\n\tcood x, y;\n\tvec () : x(0), y(0) {}\n\tvec (cood a, cood b) : x(a), y(b) {}\n\tfriend ostream& operator<<(ostream& os, vec o);\n\n\tvec operator - (vec o)\n\t{ return vec(x - o.x, y - o.y); }\n\tvec operator + (vec o)\n\t{ return vec(x + o.x, y + o.y); }\n\tvec operator * (cood o)\n\t{ return vec(x * o, y * o); }\n\tvec operator / (cood o)\n\t{ return vec(x / o, y / o); }\n\tcood operator ^ (vec o)\n\t{ return x * o.y - y * o.x; }\n\tcood operator * (vec o)\n\t{ return x * o.x + y * o.y; }\n\n\t// positive is (*this)b is clockwise from (*this)a\n\tdouble angle (vec a, vec b)\n\t{ return atan2((a-(*this))^(b-(*this)), (a-(*this))*(b-(*this))); }\n\n\tcood sq (vec o = vec())\n\t{ return ((*this)-o)*((*this)-o); }\n\tdouble nr (vec o = vec())\n\t{ return sqrt(sq(o)); }\n\n\tcood cross (vec a, vec b) // ccw signed area (positive if this is to the left of ab)\n\t{ return (b - a) ^ ((*this) - a); }\n\tint ccw (vec a, vec b) // which side is this from ab? (1 left, 0 over, -1 right)\n\t{ cood o = cross(a, b); return (eps < o) - (o < -eps); } \n\n\tint dir (vec a, vec b) // direction of (this)a relative to (this)b (-1 opposite, 0 none, 1 same)\n\t{ cood o = ((*this) - a)*((*this) - b); return (eps < o) - (o < -eps); }\n\n\tcood inner (vec s, vec t) // (p-s)*(t-s) where p = this projected on st\n\t{ return ((*this) - s) * (t - s); }\n\tvec proj (vec s, vec t) // projection of this point over line st\n\t{ return s + (t - s)*(inner(s,t) / t.sq(s)); }\n\n\tvec rotate (double a) // rotate ccw by a (fails with ll)\n\t{ return vec(cos(a) * x - sin(a) * y, sin(a) * x + cos(a) * y); }\n\tvec rot90 () // rotate pi/2 ccw\n\t{ return vec(-y, x); }\n\n\t// === ADVANCED ===\n\t// ordering that defines the compare method\n\t// used only there, change it accordingly\n\t// sorts increasing on y and, then increasing on x\n\tbool operator < (const vec & o) const {\n\t\tif (y != o.y)\n\t\t\treturn y < o.y;\n\t\treturn x < o.x;\n\t}\n\n\t// full ordering (ccw angle from this+(1,0), distance to this)\n\t// is a < b?\n\t// PRECISION : ok with double if norm in [-1e9,5e3]\n\tbool compare (vec a, vec b) {\n\t\tif (((*this) < a) != ((*this) < b))\n\t\t\treturn (*this) < a;\n\t\tint o = ccw(a,b);\n\t\tif (o) return o > 0;\n\t\treturn a.dir((*this),b) < 0;\n\t}\n\n\t// is this inside segment st? (tip of segment included, change for dr < 0 otherwise)\n\tbool in_seg (vec s, vec t)\n\t{ return (ccw(s,t) == 0) && (dir(s,t) <= 0); }\n\n\t// squared distance from this to line defined by st\n\tdouble dist2_lin (vec s, vec t)\n\t{ return double(::sq(cross(s,t))) / t.sq(s); }\n\t// squared distance from this to segment st\n\tdouble dist2_seg (vec s, vec t) \n\t{ return s.dir((*this),t) == t.dir((*this),s) ? dist2_lin(s,t) : min(sq(s),sq(t)); }\n\n\t// is this inside (borders included) the convex polygon v of size n?\n\t// if yes, prec is the vec that this on acw order from v[0] or 0 if there is no such\n\t// if not, prec is the predecessor of this when added to poly and succ is the sucessor\n\t// p should be a vector with [0..n-1]\n\t// n should be >= 2\n\tbool in_conv_poly (vec v[], int n, const vector<int> & p, int & prec, int & succ) {\n\t\tif (nr(v[0]) <= eps) {\n\t\t\tprec = 0;\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (n == 2) {\n\t\t\tif (in_seg(v[0],v[1]))\n\t\t\t\treturn (prec = 1);\n\n\t\t\tif (ccw(v[0],v[1]) > 0) {\n\t\t\t\tprec = 1;\n\t\t\t\tsucc = 0;\n\t\t\t} else if (ccw(v[0],v[1]) < 0) {\n\t\t\t\tprec = 0;\n\t\t\t\tsucc = 1;\n\t\t\t} else {\n\t\t\t\tprec = succ = (v[0].dir((*this),v[1]) < 0);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (ccw(v[0],v[1]) > 0 || ccw(v[0],v[n-1]) < 0) {\n\t\t// case where v[0] is not removed\n\t\t\t// last diagonal before or over this\n\t\t\tint di = lower_bound(p.begin() + 1, p.end(), -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[0],v[i]) >= 0;\n\t\t\t}) - p.begin() - 1;\n\n\t\t\t// is this inside the polygon?\n\t\t\tprec = di;\n\t\t\tif (di == n-1) {\n\t\t\t// last segment\n\t\t\t\tif (ccw(v[0],v[n-1]) == 0 && ccw(v[n-2],v[n-1]) >= 0)\n\t\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t// inside otherwise\n\t\t\t\tif (ccw(v[di],v[di+1]) >= 0)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// last that stays before (or eq to) di\n\t\t\tprec = lower_bound(p.begin() + 1, p.begin() + di + 1, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i-1],v[i]) > 0;\n\t\t\t}) - p.begin() - 1;\n\n\t\t\t// first that stays after di\n\t\t\tsucc = lower_bound(p.begin() + di + 1, p.end(), -1, [this,v,n] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[(i+1)%n],v[i]) >= 0;\n\t\t\t}) - p.begin();\n\t\t\tif (succ == n) succ = 0;\n\t\t} else {\n\t\t// case where v[0] is removed\n\t\t\t// first diagonal before of over this\n\t\t\t// di is certainly not removed\n\t\t\tint di = lower_bound(p.begin() + 1, p.end() - 1, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[0],v[i]) < 0;\n\t\t\t}) - p.begin();\n\n\t\t\t// first that stays (<= di)\n\t\t\tsucc = lower_bound(p.begin(), p.begin() + di, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i+1],v[i]) >= 0;\n\t\t\t}) - p.begin();\n\n\t\t\t// last that stays (>= di)\n\t\t\tprec = lower_bound(p.begin() + di + 1, p.end(), -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i-1],v[i]) > 0;\n\t\t\t}) - p.begin() - 1;\n\t\t}\n\t\treturn 0;\n\t}\n};\nostream& operator<<(ostream& os, vec o)\n{ return os << '(' << o.x << \", \" << o.y << ')'; }\n\nstruct lin { // line\n\tcood a, b, c; // a*x + b*y = c\n\n\tlin () {}\n\tlin (cood x, cood y, cood z) : a(x), b(y), c(z) {}\n\tlin (vec s, vec t) : a(t.y - s.y), b(s.x - t.x), c(a * s.x + b * s.y) {}\n\n\tlin parll (vec p) // parallel to this through p\n\t{ return lin(a, b, a * p.x + b * p.y); }\n\tlin perp ()\n\t{ return lin(-b, a, c); }\n\n\tvec inter (lin o) {\n\t\tcood d = a * o.b - o.a * b;\n\t\tif (d < eps && -eps < d) throw 0; // parallel\n\t\treturn vec((o.b * c - b * o.c) / d, (a * o.c - o.a * c) / d);\n\t}\n};\n\nstruct cir { // circle\n\tvec c; cood r;\n\n\t// borders included\n\tbool contains (vec w)\n\t{ return c.sq(w) <= sq(r) + eps; }\n\tbool has_inter (cir o)\n\t{ return c.sq(o.c) <= sq(r + o.r) + eps; }\n\tbool has_inter_lin (vec s, vec t)\n\t{ return c.dist2_lin(s,t) <= sq(r) + eps_d; }\n\tbool has_inter_seg (vec s, vec t)\n\t{ return c.dist2_seg(s,t) <= sq(r); }\n\n\t// borders not included\n\tbool contains (cir o)\n\t{ return (o.r < r - eps && c.sq(o.c) < sq(r - o.r) - eps); }\n\n\t// ccw oriented area of arc from a to b\n\tdouble arc_area (vec a, vec b) {\n\t\tdouble ang = c.angle(a,b);\n\t\treturn r*r*ang*.5;\n\t}\n\n\t// double only\n\tpair<vec,vec> inter_pts (cir o) {\n\t\tassert(has_inter(o) && !contains(o)); // fully contained case\n\t\tdouble d = c.nr(o.c);\n\t\tdouble a = (r*r + d*d - o.r*o.r) / (2.*d); // r*cos(ans,v,c.v)\n\t\tdouble h = sqrt(r*r - a*a);\n\t\tif (h != h) h = 0;\n\t\tvec p = o.c - c;\n\t\treturn pair<vec,vec>(c + p*(a/d) + (p.rot90()*(h/d)), c + p*(a/d) - (p.rot90()*(h/d)));\n\t}\n\n\t// double only XXX careful precision\n\tpair<vec,vec> inter_pts (vec s, vec t) { \n\t\tassert(has_inter_lin(s,t));\n\t\tdouble h2 = c.dist2_lin(s,t);\n\t\tdouble d = sqrt(c.sq(t) - h2);\n\t\tif (d != d) d = 0;\n\t\tvec p = (s-t);\n\t\tvec m = t + p*(d/p.nr());\n\t\tvec m_b = t - p*(d/p.nr());\n\t\tif (m_b.sq(c) < m.sq(c))\n\t\t\tm = m_b;\n\n\t\td = sqrt(r*r - h2);\n\t\tif (d != d) d = 0;\n\t\tpair<vec,vec> res(m + p*(d/p.nr()), m - p*(d/p.nr()));\n\t\tif (res.first.sq(t) > res.second.sq(t))\n\t\t\tswap(res.first, res.second);\n\t\treturn res;\n\t}\n\n\t// double only XXX not tested\n\t// signed area of intersection of this with triangle (this.c,a,b)\n\tdouble inter (vec a, vec b) {\n\t\tdouble res = 0.;\n\t\tbool inv = 0;\n\t\tif (contains(b)) {\n\t\t\tswap(a,b);\n\t\t\tinv = 1;\n\t\t}\n\n\t\tif (contains(b)) {\n\t\t\tres = c.cross(a,b)*.5;\n\t\t} else if (contains(a)) {\n\t\t\tpair<vec,vec> rt = inter_pts(a,b);\n\t\t\tvec q = rt.first;\n\t\t\tif (rt.second.dist2_seg(a,b) < q.dist2_seg(a,b))\n\t\t\t\tq = rt.second;\n\n\t\t\tres += c.cross(a,q)*.5;\n\t\t\tres += arc_area(q,b);\n\t\t} else if (has_inter_seg(a, b)) {\n\t\t\tpair<vec,vec> rt = inter_pts(b,a);\n\n\t\t\tres += arc_area(a,rt.first);\n\t\t\tres += c.cross(rt.first,rt.second)*.5;\n\t\t\tres += arc_area(rt.second,b);\n\t\t} else {\n\t\t\tres += arc_area(a,b);\n\t\t}\n\n\t\tif (inv) res = -res;\n\t\treturn res;\n\t}\n\n\t// double only XXX not tested\n\t// signed area of intersection of this with polygon\n\tdouble inter (vector<vec> & p) {\n\t\tdouble res = 0;\n\t\tfor (int i = 0; i < p.size(); i++)\n\t\t\tres += inter(p[i],p[(i+1)%p.size()]);\n\t\treturn res;\n\t}\n};\n\n// do the segments ab and cd intersect? (borders included) XXX\nbool inter_seg (vec a, vec b, vec c, vec d) {\n\tif (a.in_seg(c, d) || b.in_seg(c, d) || c.in_seg(a, b) || d.in_seg(a, b))\n\t\treturn true;\n\treturn (c.ccw(a, b) * d.ccw(a, b) == -1 && a.ccw(c, d) * b.ccw(c, d) == -1);\n}\n\n// squared distance from segments ab and cd XXX\ndouble dist2_seg (vec a, vec b, vec c, vec d)\n{ return inter_seg(a,b,c,d) ? 0. : min({ a.dist2_seg(c,d), b.dist2_seg(c,d), c.dist2_seg(a,b), d.dist2_seg(a,b) }); }\n\n// brd = do points on the border belong to convex?\n// computes convex hull of given vector (inplace)\n// returns size of convex hull\nint graham (vec v[], int n, int brd) {\n\tfor (int i = 1; i < n; i++) {\n\t\tif (v[i].x < v[0].x || (v[i].x == v[0].x && v[i].y < v[0].y))\n\t\t\tswap(v[0], v[i]);\n\t}\n\n\tsort(v+1, v+n, [v] (vec a, vec b) {\n\t\tint o = b.ccw(v[0], a);\n\t\tif (o) return (o == 1);\n\t\treturn v[0].sq(a) < v[0].sq(b);\n\t});\n\n\tif (brd) {\n\t\tint s = n-1;\n\t\twhile (s > 1 && v[s].ccw(v[s-1],v[0]) == 0)\n\t\t\ts--;\n\t\tfor (int i = s; i < n - 1 - (i - s); i++)\n\t\t\tswap(v[i], v[n-1-(i-s)]);\n\t}\n\n\tint s = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s && v[s-1].x == v[i].x && v[s-1].y == v[i].y) continue;\n\t\twhile (s >= 2 && v[s-1].ccw(v[s-2],v[i]) >= brd)\n\t\t\ts--;\n\t\tv[s++] = v[i];\n\t}\n\n\treturn s;\n}\n\nconst int N = 1e2+7;\n\nint n;\ndouble r;\nvector<vec> v;\ndouble x[2], y[2];\n\ndouble solve (double x) {\n\tdouble lo = 200, hi = -100.;\n\tfor (int i = 0; i < n; i++) {\n\t\tint j = (i+1)%n;\n\t\tif (abs(v[i].x - v[j].x) > eps_d) {\n\t\t\tlin ln(v[i],v[j]);\n\t\t\tvec it(x, (ln.c - ln.a*x)/ln.b);\n\t\t\tcout << it << \" \";\n\t\t\tif (abs(ln.b) > eps) {\n\t\t\t\tlo = min(lo, it.y);\n\t\t\t\thi = max(hi, it.y);\n\t\t\t}\n\t\t}\n\n\t\tif (abs(v[i].x - x) <= eps_d) {\n\t\t\tcout << v[i] << \"! \";\n\t\t\tlo = min(lo, v[i].y);\n\t\t\thi = max(hi, v[i].y);\n\t\t}\n\t}\n\thi = min(hi, 200.); lo = max(lo, -100.);\n\tcout << x << \" [\" << lo << \" \" << hi << \"]\" << endl;\n\n\tint ts = 60;\n\twhile (ts--) {\n\t\tdouble q1 = (lo+lo+hi)/3;\n\t\tdouble q2 = (lo+hi+hi)/3;\n\n\t\tdouble r1 = abs(cir({ vec(x,q1), r }).inter(v));\n\t\tdouble r2 = abs(cir({ vec(x,q2), r }).inter(v));\n\n\t\tif (r1 < r2)\n\t\t\tlo = q1;\n\t\telse\n\t\t\thi = q2;\n\t}\n\n\treturn abs(cir({ vec(x,lo), r }).inter(v));\n}\n\nint main () {\n\n\twhile (scanf(\"%d %lf\", &n, &r) != EOF) {\n\t\tcout << n << endl;\n\t\tv = vector<vec>(n);\n\t\t\n\t\tx[0] = 200;\n\t\tx[1] = -100;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%lf %lf\", &v[i].x, &v[i].y);\n\t\t\tcout << v[i] << \" \";\n\n\t\t\tx[0] = min(x[0],v[i].x);\n\t\t\tx[1] = max(x[1],v[i].x);\n\t\t}\n\t\tcout << endl;\n\n\t\tdouble lo = x[0], hi = x[1];\n\t\tint ts = 60;\n\t\twhile (ts--) {\n\t\t\tdouble q1 = (lo+lo+hi)/3;\n\t\t\tdouble q2 = (lo+hi+hi)/3;\n\t\t\t\n\t\t\tif (solve(q1) < solve(q2))\n\t\t\t\tlo = q1;\n\t\t\telse\n\t\t\t\thi = q2;\n\t\t}\n\n\t\tprintf(\"%.20f\\n\", solve(lo));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//writted by dnvtmf\n#include <bits/stdc++.h>\n#define INF 1000000007\n#define FI first\n#define SE second\n#define PB push_back\n#define VI vector<int>\n#define MP make_pair\n#define FOR(x, st, ed) for(auto x = (st); x < (ed); ++x)\n#define FORE(x, st, ed) for(auto x = (st); x <= (ed); ++x)\n#define CLR(arr, val) memset(arr, val, sizeof(arr))\n#define INFO(tag, st, ed, x) printf(\"%s: \", tag); \\\n  FOR(_i, st, ed) cout << x[_i] << ' '; puts(\"\");\nusing namespace std;\ntypedef long long LL;\ntypedef pair <int, int> PII;\nconst int NUM = 100010;\n\nconst double EPS = 1e-12;\ninline int sgn(double x) {if (x < -EPS)return -1; return x > EPS ? 1 : 0;}\ninline double sqr(double x) {return x * x;}\nstruct Point {\n  double x, y;\n  Point(double _x = 0.0, double _y = 0.0): x(_x), y(_y) {}\n  Point operator + (const Point &b)const {return Point(x + b.x, y + b.y);}//向量加法\n  Point operator - (const Point &b)const {return Point(x - b.x, y - b.y);}//向量?法\n  double operator * (const Point &b)const {return x * b.x + y * b.y;}//向量点?\n  double operator ^ (const Point &b)const {return x * b.y - y * b.x;} //向量叉?\n  Point operator * (double b) {return Point(x * b, y * b);}//?量乘法\n  Point rot(double ang) {return Point(x * cos(ang) - y * sin(ang), x * sin(ang) + y * cos(ang));}//旋?\n  double norm() {return sqrt(x * x + y * y);}//向量的模\n};\n//直? ?段定?\n//直?方程：?点式：@$(x_2 - x_1)(y - y_1) = (y_2 - y_1)(x - x_1)$@\nstruct Line {\n  Point s, e;\n  //double k;\n  Line() {}\n  Line(Point _s, Point _e) {\n    s = _s, e = _e;\n    //k = atan2(e.y - s.y, e.x - s.x);\n  }\n  //求?直?交点\n  //返回-1?直?重合, 0 相交, 1 平行\n  pair<int, Point> operator &(Line b) {\n    if (sgn((s - e) ^ (b.s - b.e)) == 0) {\n      if (sgn((s - b.e) ^ (b.s - b.e)) == 0) return make_pair(-1, s); //重合\n      else return make_pair(1, s);//平行\n    }\n    double t = ((s - b.s) ^ (b.s - b.e)) / ((s - e) ^ (b.s - b.e));\n    return make_pair(0, Point(s.x + (e.x - s.x) * t, s.y + (e.y - s.y) * t));\n  }\n};\n//求向量vA与vB的?角(<= PI)\ndouble angle(Point vA, Point vB) {\n  double tmp = vA.norm() * vB.norm();\n  if (sgn(tmp) != 0) return acos((vA * vB) / tmp);\n  else return 0.0;\n}\n\n//num表示?O(o, r)与?段(s, e)的交点数, res里存?的是交点\nvoid Circle_cross_Segment(Point s, Point e, Point o, double r, Point res[], int &num) {\n  double dx = e.x - s.x, dy = e.y - s.y;\n  double A = dx * dx + dy * dy;\n  double B = 2.0 * dx * (s.x - o.x) + 2.0 * dy * (s.y - o.y);\n  double C = sqr(s.x - o.x) + sqr(s.y - o.y) - r * r;\n  double delta = B * B - 4.0 * A * C;\n  num = 0;\n  if (sgn(delta) < 0) return ;\n  delta = sqrt(max(0.0, delta));\n  double k1 = (-B - delta) / (2.0 * A);\n  double k2 = (-B + delta) / (2.0 * A);\n  if (sgn(k1 - 1.0) <= 0 && sgn(k1) >= 0) //?与?段相交条件判断\n    res[num++] = Point(s.x + k1 * dx, s.y + k1 * dy);\n  if (sgn(k2 - 1.0) <= 0 && sgn(k2) >= 0)\n    res[num++] = Point(s.x + k2 * dx, s.y + k2 * dy);\n}\n\n//三角形ABO与?(O, r)的面?交\ndouble Triangel_cross_Circle(Point a, Point b, Point o, double r) {\n  double r2 = r * r;\n  a = a - o;\n  b = b - o;\n  o = Point(0.0, 0.0);\n  bool bAInC = sgn((a * a) - r2) < 0;\n  bool bBInC = sgn((b * b) - r2) < 0;\n  double sg = 0.5 * sgn(a ^ b), res = 0.0;\n  Point tmp[2];\n  int num;\n  if (bAInC && bBInC) res = abs(a ^ b);\n  else if (bAInC || bBInC) {\n    if (bBInC) swap(a, b);\n    Circle_cross_Segment(a, b, 0, r, tmp, num);\n    res = fabs(a ^ tmp[0]) + r2 * angle(tmp[0], b);\n  }\n  else {\n    Circle_cross_Segment(a, b, o, r, tmp, num);\n    res = r2 * angle(a, b);\n    if (num == 2) {\n      res -= r2 * angle(tmp[0], tmp[1]);\n      res += fabs(tmp[0] ^ tmp[1]);\n    }\n  }\n // cout<<a.x<<\" \"<<a.y<<\" \"<<b.x<<\" \"<<b.y<<\" - \"<<res<<endl;\n  return sg * res;\n}\n\n//多?形与?的面?交\ndouble Polygon_intersect_Circle(Point ploy[], int n, Point O, double r) {\n  ploy[n] = ploy[0];\n  double res = 0.0;\n  for (int i = 0; i < n; ++i)\n    res += Triangel_cross_Circle(ploy[i], ploy[i + 1], O, r);\n  return fabs(res);\n}\n\nint n, r;\nPoint ploy[20];\ninline double Rand() {return 2.0 * rand() / RAND_MAX - 1.0;}\n\nvoid solve() {\n  double x = ploy[0].x, y = ploy[0].y, area = Polygon_intersect_Circle(ploy, n, {x, y}, r);\n  double best = area, bx = 0.0, by = 0.0;\n  double c = 100.;\n  for (int k = 0; k < 10; ++k, c *= 0.1) {\n    x = bx, y = by, area = best;\n    double T = 100, T_decay = 0.95;\n    const int max_iter = 900, chain_len = 200;\n    for (int i = 0; i < max_iter; ++i, T *= T_decay) {\n     // cout << \"T: \" << T << endl;\n      for (int j = 0; j < chain_len; ++j) {\n        double xx = x + c * Rand();\n        double yy = y + c * Rand();\n        double S = Polygon_intersect_Circle(ploy, n, {xx, yy}, r);\n        double deltaS = S - area;\n        if (deltaS > 0 || exp(deltaS * T) < Rand()) {\n//        cout << area << endl;\n          x = xx;\n          y = yy;\n          area = S;\n          if (area > best) {\n\t\t\t\t\t\t//cout << best << endl;\n            best = area;\n            bx = x;\n            by = y;\n          }\n        }\n      }\n    }\n  }\n  printf(\"%f\\n\", best);\n//  bx = 3., by = 3.;\n // printf(\"(%f,%f): %f\\n\", bx, by, Polygon_intersect_Circle(ploy, n, {bx, by}, r));\n//  cout << Rand() << endl;\n}\nint main() {\n#ifdef ACM_TEST\n  freopen(\"in.txt\", \"r\", stdin);\n#endif\n  srand(time(0));\n  scanf(\"%d%d\", &n, &r);\n  for (int i = 0, x, y; i < n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    ploy[i] = Point(x, y);\n  }\n  solve();\n//  printf(\"(%f,%f): %f\\n\", 5.8, 5.8, Polygon_intersect_Circle(ploy, n, {5.8, 5.8}, r));\n//  for (int i = 0; i < 20; ++i) {\n   // double x = 98.000378;\n   // double y = 0.972875;\n   // printf(\"(%f,%f): %f\\n\", x, y, Polygon_intersect_Circle(ploy, n, {x, y}, r));\n//  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\n#define CVector CPoint\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-7;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n    /*friend bool operator<(CPoint a,CPoint b){//?角排序\n        double tmp=cross(Pts[0],a,b);\n        if(isZero(tmp)){\n            return dist(Pts[0],a)<dist(Pts[0],b);\n        }\n        return tmp>0;\n    }*/\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n/*----------------------多?形相?--------------------------*/\n\n//0:outside 1:inside 2:online\nint PointInPoly(Point t,Point *Pts,int n){\n    int num=0,d1,d2,k;\n    Pts[n]=Pts[0];\n    for(int i=0;i<n;i++){\n        if(PointOnS(t,Line(Pts[i],Pts[i+1]))) return 2;\n        k=dcmp(cross(Pts[i],Pts[i+1],t));\n        d1=dcmp(Pts[i].y-t.y);\n        d2=dcmp(Pts[i+1].y-t.y);\n        if(k>0&&d1<=0&&d2>0) num++;\n        if(k<0&&d2<=0&&d1>0) num--;\n    }\n    return num!=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n//求任意多?形周?，需逆??或???排列\ndouble PolyPerimeter(Point *Pts,int n){\n    double pp=distPP(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pp+=distPP(Pts[i],Pts[i+1]);\n    return pp;\n}\n\n//求多?形重心坐?\nPoint PolyCore(Point *Pts,int n){\n    double pa=PolyArea(Pts,n);\n    if(!dcmp(pa)) return Point(0,0);\n    Point ans=(Pts[n-1]+Pts[0])*cross(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) ans=ans+(Pts[i]+Pts[i+1])*cross(Pts[i],Pts[i+1]);\n    return ans/pa/6;\n}\n\n/*----------------------凸包----------------------------*/\n\n//Graham-scan st:anticlockwise\n//<=:strict <:Non-strict\nint Graham(Point *Pts,Point *st,int n){\n    if(n<3) return 0;\n    sort(Pts,Pts+n);\n    int m=0;\n    for(int i=0;i<n;i++){\n        while(m>1&&dcmp(cross(st[m-2],st[m-1],Pts[i]))<0) m--;\n        st[m++]=Pts[i];\n    }\n    int k=m;\n    for(int i=n-2;i>=0;i--){\n        while(m>k&&dcmp(cross(st[m-2],st[m-1],Pts[i])<0)) m--;\n        st[m++]=Pts[i];\n    }\n    return m-1;\n}\n\n//clockwise:> anticlockwise:<\ndouble CHDiameter(Point *Pts,int n,Line &l){\n    double maxd=0.0;\n    if(n<=1){\n        l.a=l.b=Pts[0];\n        return maxd;\n    }\n    for(int i=0,j=1;i<n;i++){\n        while(cross(Pts[i],Pts[(i+1)%n],Pts[j])\n              >cross(Pts[i],Pts[(i+1)%n],Pts[(j+1)%n])){\n            j=(j+1)%n;\n        }\n        double d=distPP(Pts[i],Pts[j]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n        d=distPP(Pts[(i+1)%n],Pts[(j+1)%n]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n    }\n    return maxd;\n}\n\n/*---------------------整点多?形---------------------------*/\n\nint gcd(int a,int b){\n    return b==0?a :gcd(b,a%b);\n}\n\n//整点多?形?界整点数\nint Border_Int_Point_Num(Point *Pts,int n){\n    int num=gcd(abs(int(Pts[0].x-Pts[n-1].x)),abs(int(Pts[0].y-Pts[n-1].y)));;\n    for(int i=0;i<n-1;i++){\n        num+=gcd(abs(int(Pts[i+1].x-Pts[i].x)),abs(int(Pts[i+1].y-Pts[i].y)));\n    }\n    return num;\n}\n\n//整点多?形内部整点数\nint Inside_Int_Point_Num(Point *Pts,int n){\n    return abs(int(PolyArea(Pts,n)))+1-Border_Int_Point_Num(Pts,n)/2;\n}\n\n/*-----------------------------半平面交-------------------------------*/\n\n//有方向的直?\n//p->p+v\nstruct Vector{\n    Point p,v;\n    double ang;\n    Vector(Point p,Point v):p(p),v(v){\n        ang=atan2(v.y,v.x);\n    }\n    Vector(){}\n    bool operator<(const Vector &l) const{\n        return ang<l.ang;\n    }\n};\n\n//判断点p是否在直?L左?\nbool onLeft(Vector L,Point p){\n    return cross(L.v,p-L.p)>0;\n}\n\n//得到a与b?直?的交点\nPoint getCrossVV(Vector a,Vector b){\n    Point u=a.p-b.p;\n    double t=cross(b.v,u)/cross(a.v,b.v);\n    return a.p+a.v*t;\n}\n\n//所有直?左半平面的交\nint HPCross(Vector *L,int n,Point *poly){\n    sort(L,L+n);\n    int f=0,l=0;\n    Point *p=new Point[n];\n    Vector *q=new Vector[n];\n    q[0]=L[0];\n    for(int i=1;i<n;i++){\n        while(f<l&&!onLeft(L[i],p[l-1])) l--;\n        while(f<l&&!onLeft(L[i],p[f])) f++;\n        q[++l]=L[i];\n        if(!dcmp(cross(q[l].v,q[l-1].v))){\n            l--;\n            if(onLeft(q[l],L[i].p)) q[l]=L[i];\n        }\n        if(f<l) p[l-1]=getCrossVV(q[l-1],q[l]);\n    }\n    while(f<l&&!onLeft(q[f],p[l-1])) l--;\n    if(l-f<=1) return 0;\n    p[l]=getCrossVV(q[l],q[f]);\n    int m=0;\n    for(int i=f;i<=l;i++) poly[m++]=p[i];\n    return m;\n}\n\n#define maxn 100005\nVector l[maxn];\nbool retract(Vector *L,int n,double r,Point *poly){\n    for(int i=0;i<n;i++){\n        Point v=rotateV(L[i].p,L[i].p+L[i].v,PI/2);\n        l[i]=Vector(L[i].p+r*v,L[i].v);\n    }\n    int cnt=HPCross(l,n,poly);\n    return cnt;\n}\n\n/*---------------------三角形相?---------------------------*/\n\n//三角形重心\n//到三?点距?的平方和最小的点\n//到三?距?之?最大的点\nPoint TCore(Point a,Point b,Point c){\n    return (a+b+c)/3;\n}\n\n//三角形外心\nPoint TCircum(Point a,Point b,Point c){\n    Point cp;\n    double a1=b.x-a.x;\n    double b1=b.y-a.y;\n    double a2=c.x-a.x;\n    double b2=c.y-a.y;\n    double c1=(a1*a1+b1*b1)/2;\n    double c2=(a2*a2+b2*b2)/2;\n    double d=a1*b2-a2*b1;\n    cp.x=a.x+(c1*b2-c2*b1)/d;\n    cp.y=a.y+(a1*c2-a2*c1)/d;\n    return cp;\n}\n\n//三角形垂心\nPoint TOrtho(Point a,Point b,Point c){\n    return TCore(a,b,c)*3.0-TCircum(a,b,c)*2.0;\n}\n\n//三角形内心\nPoint TInner(Point a,Point b,Point c){\n    Point cp;\n    double la=distPP(b,c),lb=distPP(c,a),lc=distPP(a,b);\n    cp.x=(la*a.x+lb*b.x+lc*c.x)/(la+lb+lc);\n    cp.y=(la*a.y+lb*b.y+lc*c.y)/(la+lb+lc);\n    return cp;\n}\n\n//求三角形面?\ndouble TArea(Point a,Point b,Point c){\n    return fabs(cross(a,b,c))/2;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n//求??面?交\ndouble getAreaCC(Circle a,Circle b){\n    double d=(a.o.x-b.o.x)*(a.o.x-b.o.x)+(a.o.y-b.o.y)*(a.o.y-b.o.y);\n    if(d<=(a.r-b.r)*(a.r-b.r)){\n        return min(a.r,b.r)*min(a.r,b.r)*PI;\n    }else if(d>(a.r-b.r)*(a.r-b.r)&&d<(a.r+b.r)*(a.r+b.r)){\n        double m1=(a.r*a.r+d-b.r*b.r)/(2*a.r*sqrt(d));\n        double m2=(b.r*b.r+d-a.r*a.r)/(2*b.r*sqrt(d));\n        double s1=acos(m1)*a.r*a.r;\n        double s2=acos(m2)*b.r*b.r;\n        double s3=sqrt(d)*a.r*sin(acos(m1));\n        return s1+s2-s3;\n    }\n    return 0.0;\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n/********************************************************/\nint getCrossCS(Circle c,Line s,Point *cs){\n    Point tmp[2];\n    int cnt=0;\n    int ct=getCrossCL(c,s,tmp);\n    for(int i=0;i<ct;i++){\n        if(PointOnS(tmp[i],s)) cs[cnt++]=tmp[i];\n    }\n    return cnt;\n}\n\nPoint PinS(Point *cs,int n,Line s){\n    if(n==1) return cs[0];\n    if(!dcmp(cs[0].x-s.a.x)&&!dcmp(cs[0].y-s.a.y)) return cs[1];\n    return cs[0];\n}\n\ndouble getAngle(Point a,Point b){\n    double tmp=dot(a,b)/(length(a)*length(b));\n    //if(tmp<-1.0) tmp=-1.0;\n    //if(1.0<tmp) tmp=1.0;\n    return acos(tmp);\n}\n\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=fabs(cross(a-c.o,b-c.o)/2);\n    if(!dcmp(atc)) return 0.0;\n    double la=length(a-c.o),lb=length(b-c.o);\n    Point cs[4];\n    if(la<c.r+EPS&&lb>c.r-EPS){\n        int ct=getCrossCS(c,Line(a,b),cs);\n        Point p=PinS(cs,ct,Line(a,b));\n        atc+=0.5*c.r*c.r*getAngle(p-c.o,b-c.o);\n        atc-=fabs(cross(p-c.o,b-c.o)/2);\n    }else if(la>c.r-EPS&&lb<c.r+EPS){\n        int ct=getCrossCS(c,Line(a,b),cs);\n        Point p=PinS(cs,ct,Line(b,a));\n        atc+=0.5*c.r*c.r*getAngle(p-c.o,a-c.o);\n        atc-=fabs(cross(p-c.o,a-c.o)/2);\n    }else if(la>c.r-EPS&&lb>c.r-EPS){\n        if(distPS(c.o,Line(a,b))<c.r-EPS){\n            Point rt=root(c.o,Line(a,b));\n            atc=fabs(getAreaTC(a,rt,c))+fabs(getAreaTC(rt,b,c));\n        }else atc=0.5*c.r*c.r*getAngle(a-c.o,b-c.o);\n    }\n    if(dcmp(cross(a-c.o,b-c.o))==1) atc=-atc;\n    return atc;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=getAreaTC(Pts[n-1],Pts[0],c);\n    for(int i=0;i<n-1;i++) apc+=getAreaTC(Pts[i],Pts[i+1],c);\n    return fabs(apc);\n}\n\n/********************************************************/\n\n\n/*----------------------三?点、?基本函数-----------------------------*/\n\nstruct Point3{\n    double x,y,z;\n    Point3(double x,double y,double z):x(x),y(y),z(z){}\n    Point3(){}\n    void Read(){ scanf(\"%lf%lf%lf\",&x,&y,&z); }\n};\n\nstruct Line3{\n    Point3 a,b;\n    Line3(Point3 a,Point3 b):a(a),b(b){}\n    Line3(){}\n    void Read(){ a.Read(); b.Read(); }\n};\nPoint3 operator +(Point3 a,Point3 b){ return Point3(a.x+b.x,a.y+b.y,a.z+b.z); }\nPoint3 operator -(Point3 a,Point3 b){ return Point3(a.x-b.x,a.y-b.y,a.z-b.z); }\ndouble operator *(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 operator *(Point3 a,double k){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator *(double k,Point3 a){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator /(Point3 a,double k){ return Point3(a.x/k,a.y/k,a.z/k); }\n\ndouble length(Point3 a){ return sqrt(a.x*a.x+a.y*a.y+a.z*a.z); }\nPoint3 unit(Point3 a){ return a/length(a); }\ndouble dot(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 cross(Point3 a,Point3 b){\n    return Point3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//混合?\ndouble Mix(Point3 a,Point3 b,Point3 c){\n    return dot(a,cross(b,c));\n}\n\n//?点距?\ndouble dist(const Point3 &a,const Point3 &b){ return length(a-b); }\n\n/*---------------------------------体?-------------------------------------*/\n\n//四面体体?\ndouble volume(double l,double n,double a,double m,double b,double c){\n    double x,y;\n    x=4*a*a*b*b*c*c-a*a*(b*b+c*c-m*m)*(b*b+c*c-m*m)-b*b*(c*c+a*a-n*n)*(c*c+a*a-n*n);\n    y=c*c*(a*a+b*b-l*l)*(a*a+b*b-l*l)-(a*a+b*b-l*l)*(b*b+c*c-m*m)*(c*c+a*a-n*n);\n    return sqrt(x-y)/12;\n}\n\ndouble volume(Point3 a,Point3 b,Point3 c,Point3 d){\n    return fabs(Mix(b-a,c-a,d-a)/6);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);//cin.tie(0);\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\n\nstruct P {\n\tdouble x, y;\n\tP() {\n\t}\n\tP(double _x, double _y) :\n\t\t\tx(_x), y(_y) {\n\t}\n\tP operator+(const P&p) const {\n\t\treturn P(x + p.x, y + p.y);\n\t}\n\tP operator-(const P&p) const {\n\t\treturn P(x - p.x, y - p.y);\n\t}\n\tP operator*(double d) const {\n\t\treturn P(x * d, y * d);\n\t}\n\tP operator/(double d) const {\n\t\treturn P(x / d, y / d);\n\t}\n\tdouble det(const P&p) const {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdouble dot(const P&p) const {\n\t\treturn x * p.x + y * p.y;\n\t}\n\tdouble alpha() const {\n\t\treturn atan2(y, x);\n\t}\n\tP rot90() const {\n\t\treturn P(-y, x);\n\t}\n\tvoid read() {\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t}\n\tvoid write() const {\n\t\tprintf(\"(%lf,%lf)\", x, y);\n\t}\n\tdouble abs() {\n\t\treturn sqrt(abs2());\n\t}\n\tdouble abs2() {\n\t\treturn x * x + y * y;\n\t}\n\tP unit() {\n\t\treturn *this / abs();\n\t}\n};\n\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n\nconst double EPS = 1e-8; //you should change it according to problem, nevertheless, it mustn't be a constant value some times.\ninline int sign(double a) {\n\treturn a < -EPS ? -1 : a > EPS;\n}\n\n#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))\n\nP isSS(P p1, P p2, P q1, P q2) {\n\tdouble a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);\n\treturn (p1 * a2 + p2 * a1) / (a1 + a2);\n}\n\nint n;\n\ndouble x[12],y[12],r;\n\nbool onLine(P p, P q, P x){\n\treturn (x-p).dot(x-q) <= EPS;\n}\n\nvector<P> isCS(P c,double r,P p, P q){\n\tdouble d = cross(q,p,c) / (p-q).abs();\n\tvector<P> ret;\n\n\tif(d>=r+EPS)\n\t\treturn ret;\n\n\tP dir = (q-p).rot90();\n\tP pq = (p-q);\n\tpq = pq/pq.abs();\n\n\tdir = dir / dir.abs();\n\n\tP mid = c + dir * d;\n\n\tdouble h = sqrt(max(r*r-d*d,0.0));\n\tif(onLine(p,q,mid + pq*h))\n\t\tret.push_back(mid + pq*h);\n\tif(onLine(p,q,mid - pq*h))\n\t\tret.push_back(mid - pq*h);\n\treturn ret;\n}\n\ndouble rad(P p,P q){\n\treturn atan2(p.det(q),p.dot(q));\n}\n\ndouble calc(P p, P q){\n\tbool inp = p.abs2() <= r*r;\n\tbool inq = q.abs2() <= r*r;\n\tif(inp && inq){\n\t\treturn p.det(q)/2;\n\t}\n\tif(inp && !inq){\n\t\treturn -calc(q,p);\n\t}\n\tvector<P> is = isCS(P(0,0),r,p,q);\n\tif(!inp && inq){\n\t\tP m = is[0];\n\t\treturn r*r*rad(p,m)/2 + m.det(q)/2;\n\t}\n\n\tif(!inp && !inq){\n\t\tif(is.empty())\n\t\t\treturn r*r*rad(p,q)/2;\n\t\treturn r*r*(rad(p,is[0]) + rad(is[1],q))/2 + is[0].det(is[1])/2;\n\t}\n}\n\ndouble calcArea(double cx,double cy){\n\tP ps[12];\n\trep(i,n) ps[i].x=x[i]-cx,ps[i].y=y[i]-cy;\n\tps[n] = ps[0];\n\n\tdouble area = 0;\n\n\trep(i,n){\n\t\tP p=ps[i],q=ps[i+1];\n\t\tarea += calc(p,q);\n\t}\n\n\t//cout<<area<<endl;\n\n\treturn area;\n}\n\ndouble ffy(double x){\n\tdouble l=*min_element(y,y+n),r=*max_element(y,y+n);\n\trep(it,100){\n\t\tdouble ll=(l*2+r)/3,rr=(l+r*2)/3;\n\t\tif(calcArea(x,ll)>calcArea(x,rr))\n\t\t\tr=rr;\n\t\telse\n\t\t\tl=ll;\n\t}\n\treturn calcArea(x,l);\n}\n\ndouble ffx(){\n\tdouble l=*min_element(x,x+n),r=*max_element(x,x+n);\n\trep(it,100){\n\t\tdouble ll=(l*2+r)/3,rr=(l+r*2)/3;\n\t\tif(ffy(ll)>ffy(rr))\n\t\t\tr=rr;\n\t\telse\n\t\t\tl=ll;\n\t}\n\treturn ffy(l);\n}\n\nint main(){\n\tcin>>n>>r;\n\trep(i,n) cin>>x[i]>>y[i];\n\n\tprintf(\"%0.10lf\\n\",ffx());\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1000\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Circle c,Point p){\n  if(abs(c.c-p)-c.r<eps)return true;\n  return false;\n}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nbool intersect(Circle c,Segment s){\n  if(getDistanceSP(s,c.c)-c.r<-eps)return true;\n  return false;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  if(cross(a,b)<0.0)r=360.0-r;\n  return r;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(ccw(s.p1,s.p2,pp.f)==0)res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0)res.push_back(pp.s);\n  return res;\n}\n\ndouble getCommonAreaTC(Point a,Point b,Circle c){\n  double res=cross(a-c.c,b-c.c)/2.0;\n  bool flag=true;\n  if(res<0.0){\n    swap(a,b);\n    res=-res;\n    flag=false;\n  }\n  if(ccw(a,b,c.c)==0 || ccw(a,b,c.c)==2 || ccw(a,b,c.c)==-2)return 0;\n  if(in(c,a) && in(c,b));\n  else if(in(c,a) && !in(c,b)){\n    vector<Point> vp1=getCrossPointSC(c,Segment(b,a));\n    vector<Point> vp2=getCrossPointSC(c,Segment(b,c.c)); \n    res+=(c.r*c.r*pi)*(getAngle(vp1[0]-c.c,vp2[0]-c.c)/360.0);\n    res-=cross(vp1[0]-c.c,vp2[0]-c.c)/2.0;\n    res-=cross(vp2[0]-b,vp1[0]-b)/2.0;\n  }\n  else if(!in(c,a) && in(c,b)){\n    vector<Point> vp1=getCrossPointSC(c,Segment(a,c.c));\n    vector<Point> vp2=getCrossPointSC(c,Segment(a,b));\n    res+=(c.r*c.r*pi)*(getAngle(vp1[0]-c.c,vp2[0]-c.c)/360.0);\n    res-=cross(vp1[0]-c.c,vp2[0]-c.c)/2.0;\n    res-=cross(vp2[0]-a,vp1[0]-a)/2.0;\n  }\n  else {\n    if(intersect(c,Segment(a,b))){\n      vector<Point> vp=getCrossPointSC(c,Segment(a,b));\n      Point m=vp[0]+(vp[1]-vp[0])/2.0;\n      res=getCommonAreaTC(a,m,c)+getCommonAreaTC(m,b,c);\n    }\n    else {\n      vector<Point> vp1=getCrossPointSC(c,Segment(a,c.c));\n      vector<Point> vp2=getCrossPointSC(c,Segment(b,c.c));\n      res=(c.r*c.r*pi)*(getAngle(vp1[0]-c.c,vp2[0]-c.c)/360.0);\n    }\n  }\n  if(flag)return res;\n  return -res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  int n=p.size();\n  FOR(i,0,n){\n    res+=getCommonAreaTC(p[i],p[(i+1)%n],c);\n  }\n  return abs(res);\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=abs(g-a)*2;\n  FOR(k,0,40){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*L,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=inf;\n\n    FOR(k,0,40){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2;\n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cout if (0) cout\n\n// XXX without explanation marks untested functions\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pii;\n#define pb push_back\n\n// NOT STANDART FROM HERE\n\n// area de calota 2.pi.R.h (h altura)\n// volume de calota pi.h/6 * (3r^2 + h^2)\n\n typedef double cood;\n cood eps = 1e-8;\n// tests for double were made with eps = 1e-8\n\ndouble eps_d = 1e-8; // necessary even in integer geometry, should be eps otherwise\n\nconst double pi = acos(-1.);\n\ninline ll sq (ll x)\n{ return x*x; }\ninline double sq (double x)\n{ return x*x; }\n\nstruct vec { // vector\n\t// === BASIC ===\n\tcood x, y;\n\tvec () : x(0), y(0) {}\n\tvec (cood a, cood b) : x(a), y(b) {}\n\tfriend ostream& operator<<(ostream& os, vec o);\n\n\tvec operator - (vec o)\n\t{ return vec(x - o.x, y - o.y); }\n\tvec operator + (vec o)\n\t{ return vec(x + o.x, y + o.y); }\n\tvec operator * (cood o)\n\t{ return vec(x * o, y * o); }\n\tvec operator / (cood o)\n\t{ return vec(x / o, y / o); }\n\tcood operator ^ (vec o)\n\t{ return x * o.y - y * o.x; }\n\tcood operator * (vec o)\n\t{ return x * o.x + y * o.y; }\n\n\t// positive is (*this)b is clockwise from (*this)a\n\tdouble angle (vec a, vec b)\n\t{ return atan2((a-(*this))^(b-(*this)), (a-(*this))*(b-(*this))); }\n\n\tcood sq (vec o = vec())\n\t{ return ((*this)-o)*((*this)-o); }\n\tdouble nr (vec o = vec())\n\t{ return sqrt(sq(o)); }\n\n\tcood cross (vec a, vec b) // ccw signed area (positive if this is to the left of ab)\n\t{ return (b - a) ^ ((*this) - a); }\n\tint ccw (vec a, vec b) // which side is this from ab? (1 left, 0 over, -1 right)\n\t{ cood o = cross(a, b); return (eps < o) - (o < -eps); } \n\n\tint dir (vec a, vec b) // direction of (this)a relative to (this)b (-1 opposite, 0 none, 1 same)\n\t{ cood o = ((*this) - a)*((*this) - b); return (eps < o) - (o < -eps); }\n\n\tcood inner (vec s, vec t) // (p-s)*(t-s) where p = this projected on st\n\t{ return ((*this) - s) * (t - s); }\n\tvec proj (vec s, vec t) // projection of this point over line st\n\t{ return s + (t - s)*(inner(s,t) / t.sq(s)); }\n\n\tvec rotate (double a) // rotate ccw by a (fails with ll)\n\t{ return vec(cos(a) * x - sin(a) * y, sin(a) * x + cos(a) * y); }\n\tvec rot90 () // rotate pi/2 ccw\n\t{ return vec(-y, x); }\n\n\t// === ADVANCED ===\n\t// ordering that defines the compare method\n\t// used only there, change it accordingly\n\t// sorts increasing on y and, then increasing on x\n\tbool operator < (const vec & o) const {\n\t\tif (y != o.y)\n\t\t\treturn y < o.y;\n\t\treturn x < o.x;\n\t}\n\n\t// full ordering (ccw angle from this+(1,0), distance to this)\n\t// is a < b?\n\t// PRECISION : ok with double if norm in [-1e9,5e3]\n\tbool compare (vec a, vec b) {\n\t\tif (((*this) < a) != ((*this) < b))\n\t\t\treturn (*this) < a;\n\t\tint o = ccw(a,b);\n\t\tif (o) return o > 0;\n\t\treturn a.dir((*this),b) < 0;\n\t}\n\n\t// is this inside segment st? (tip of segment included, change for dr < 0 otherwise)\n\tbool in_seg (vec s, vec t)\n\t{ return (ccw(s,t) == 0) && (dir(s,t) <= 0); }\n\n\t// squared distance from this to line defined by st\n\tdouble dist2_lin (vec s, vec t)\n\t{ return double(::sq(cross(s,t))) / t.sq(s); }\n\t// squared distance from this to segment st\n\tdouble dist2_seg (vec s, vec t) \n\t{ return s.dir((*this),t) == t.dir((*this),s) ? dist2_lin(s,t) : min(sq(s),sq(t)); }\n\n\t// is this inside (borders included) the convex polygon v of size n?\n\t// if yes, prec is the vec that this on acw order from v[0] or 0 if there is no such\n\t// if not, prec is the predecessor of this when added to poly and succ is the sucessor\n\t// p should be a vector with [0..n-1]\n\t// n should be >= 2\n\tbool in_conv_poly (vec v[], int n, const vector<int> & p, int & prec, int & succ) {\n\t\tif (nr(v[0]) <= eps) {\n\t\t\tprec = 0;\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (n == 2) {\n\t\t\tif (in_seg(v[0],v[1]))\n\t\t\t\treturn (prec = 1);\n\n\t\t\tif (ccw(v[0],v[1]) > 0) {\n\t\t\t\tprec = 1;\n\t\t\t\tsucc = 0;\n\t\t\t} else if (ccw(v[0],v[1]) < 0) {\n\t\t\t\tprec = 0;\n\t\t\t\tsucc = 1;\n\t\t\t} else {\n\t\t\t\tprec = succ = (v[0].dir((*this),v[1]) < 0);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (ccw(v[0],v[1]) > 0 || ccw(v[0],v[n-1]) < 0) {\n\t\t// case where v[0] is not removed\n\t\t\t// last diagonal before or over this\n\t\t\tint di = lower_bound(p.begin() + 1, p.end(), -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[0],v[i]) >= 0;\n\t\t\t}) - p.begin() - 1;\n\n\t\t\t// is this inside the polygon?\n\t\t\tprec = di;\n\t\t\tif (di == n-1) {\n\t\t\t// last segment\n\t\t\t\tif (ccw(v[0],v[n-1]) == 0 && ccw(v[n-2],v[n-1]) >= 0)\n\t\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t// inside otherwise\n\t\t\t\tif (ccw(v[di],v[di+1]) >= 0)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// last that stays before (or eq to) di\n\t\t\tprec = lower_bound(p.begin() + 1, p.begin() + di + 1, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i-1],v[i]) > 0;\n\t\t\t}) - p.begin() - 1;\n\n\t\t\t// first that stays after di\n\t\t\tsucc = lower_bound(p.begin() + di + 1, p.end(), -1, [this,v,n] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[(i+1)%n],v[i]) >= 0;\n\t\t\t}) - p.begin();\n\t\t\tif (succ == n) succ = 0;\n\t\t} else {\n\t\t// case where v[0] is removed\n\t\t\t// first diagonal before of over this\n\t\t\t// di is certainly not removed\n\t\t\tint di = lower_bound(p.begin() + 1, p.end() - 1, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[0],v[i]) < 0;\n\t\t\t}) - p.begin();\n\n\t\t\t// first that stays (<= di)\n\t\t\tsucc = lower_bound(p.begin(), p.begin() + di, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i+1],v[i]) >= 0;\n\t\t\t}) - p.begin();\n\n\t\t\t// last that stays (>= di)\n\t\t\tprec = lower_bound(p.begin() + di + 1, p.end(), -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i-1],v[i]) > 0;\n\t\t\t}) - p.begin() - 1;\n\t\t}\n\t\treturn 0;\n\t}\n};\nostream& operator<<(ostream& os, vec o)\n{ return os << '(' << o.x << \", \" << o.y << ')'; }\n\nstruct lin { // line\n\tcood a, b, c; // a*x + b*y = c\n\n\tlin () {}\n\tlin (cood x, cood y, cood z) : a(x), b(y), c(z) {}\n\tlin (vec s, vec t) : a(t.y - s.y), b(s.x - t.x), c(a * s.x + b * s.y) {}\n\n\tlin parll (vec p) // parallel to this through p\n\t{ return lin(a, b, a * p.x + b * p.y); }\n\tlin perp ()\n\t{ return lin(-b, a, c); }\n\n\tvec inter (lin o) {\n\t\tcood d = a * o.b - o.a * b;\n\t\tif (d < eps && -eps < d) throw 0; // parallel\n\t\treturn vec((o.b * c - b * o.c) / d, (a * o.c - o.a * c) / d);\n\t}\n};\n\nstruct cir { // circle\n\tvec c; cood r;\n\n\t// borders included\n\tbool contains (vec w)\n\t{ return c.sq(w) <= sq(r) + eps; }\n\tbool has_inter (cir o)\n\t{ return c.sq(o.c) <= sq(r + o.r) + eps; }\n\tbool has_inter_lin (vec s, vec t)\n\t{ return c.dist2_lin(s,t) <= sq(r) + eps_d; }\n\tbool has_inter_seg (vec s, vec t)\n\t{ return c.dist2_seg(s,t) <= sq(r); }\n\n\t// borders not included\n\tbool contains (cir o)\n\t{ return (o.r < r - eps && c.sq(o.c) < sq(r - o.r) - eps); }\n\n\t// ccw oriented area of arc from a to b\n\tdouble arc_area (vec a, vec b) {\n\t\tdouble ang = c.angle(a,b);\n\t\treturn r*r*ang*.5;\n\t}\n\n\t// double only\n\tpair<vec,vec> inter_pts (cir o) {\n\t\tassert(has_inter(o) && !contains(o)); // fully contained case\n\t\tdouble d = c.nr(o.c);\n\t\tdouble a = (r*r + d*d - o.r*o.r) / (2.*d); // r*cos(ans,v,c.v)\n\t\tdouble h = sqrt(r*r - a*a);\n\t\tif (h != h) h = 0;\n\t\tvec p = o.c - c;\n\t\treturn pair<vec,vec>(c + p*(a/d) + (p.rot90()*(h/d)), c + p*(a/d) - (p.rot90()*(h/d)));\n\t}\n\n\t// double only XXX careful precision\n\tpair<vec,vec> inter_pts (vec s, vec t) { \n\t\tassert(has_inter_lin(s,t));\n\t\tdouble h2 = c.dist2_lin(s,t);\n\t\tdouble d = sqrt(c.sq(t) - h2);\n\t\tif (d != d) d = 0;\n\t\tvec p = (s-t);\n\t\tvec m = t + p*(d/p.nr());\n\t\tvec m_b = t - p*(d/p.nr());\n\t\tif (m_b.sq(c) < m.sq(c))\n\t\t\tm = m_b;\n\n\t\td = sqrt(r*r - h2);\n\t\tif (d != d) d = 0;\n\t\tpair<vec,vec> res(m + p*(d/p.nr()), m - p*(d/p.nr()));\n\t\tif (res.first.sq(t) > res.second.sq(t))\n\t\t\tswap(res.first, res.second);\n\t\treturn res;\n\t}\n\n\t// double only XXX not tested\n\t// signed area of intersection of this with triangle (this.c,a,b)\n\tdouble inter (vec a, vec b) {\n\t\tdouble res = 0.;\n\t\tbool inv = 0;\n\t\tif (contains(b)) {\n\t\t\tswap(a,b);\n\t\t\tinv = 1;\n\t\t}\n\n\t\tif (contains(b)) {\n\t\t\tres = c.cross(a,b)*.5;\n\t\t} else if (contains(a)) {\n\t\t\tpair<vec,vec> rt = inter_pts(a,b);\n\t\t\tvec q = rt.first;\n\t\t\tif (rt.second.dist2_seg(a,b) < q.dist2_seg(a,b))\n\t\t\t\tq = rt.second;\n\n\t\t\tres += c.cross(a,q)*.5;\n\t\t\tres += arc_area(q,b);\n\t\t} else if (has_inter_seg(a, b)) {\n\t\t\tpair<vec,vec> rt = inter_pts(b,a);\n\n\t\t\tres += arc_area(a,rt.first);\n\t\t\tres += c.cross(rt.first,rt.second)*.5;\n\t\t\tres += arc_area(rt.second,b);\n\t\t} else {\n\t\t\tres += arc_area(a,b);\n\t\t}\n\n\t\tif (inv) res = -res;\n\t\treturn res;\n\t}\n\n\t// double only XXX not tested\n\t// signed area of intersection of this with polygon\n\tdouble inter (vector<vec> & p) {\n\t\tdouble res = 0;\n\t\tfor (int i = 0; i < p.size(); i++)\n\t\t\tres += inter(p[i],p[(i+1)%p.size()]);\n\t\treturn res;\n\t}\n};\n\n// do the segments ab and cd intersect? (borders included) XXX\nbool inter_seg (vec a, vec b, vec c, vec d) {\n\tif (a.in_seg(c, d) || b.in_seg(c, d) || c.in_seg(a, b) || d.in_seg(a, b))\n\t\treturn true;\n\treturn (c.ccw(a, b) * d.ccw(a, b) == -1 && a.ccw(c, d) * b.ccw(c, d) == -1);\n}\n\n// squared distance from segments ab and cd XXX\ndouble dist2_seg (vec a, vec b, vec c, vec d)\n{ return inter_seg(a,b,c,d) ? 0. : min({ a.dist2_seg(c,d), b.dist2_seg(c,d), c.dist2_seg(a,b), d.dist2_seg(a,b) }); }\n\n// brd = do points on the border belong to convex?\n// computes convex hull of given vector (inplace)\n// returns size of convex hull\nint graham (vec v[], int n, int brd) {\n\tfor (int i = 1; i < n; i++) {\n\t\tif (v[i].x < v[0].x || (v[i].x == v[0].x && v[i].y < v[0].y))\n\t\t\tswap(v[0], v[i]);\n\t}\n\n\tsort(v+1, v+n, [v] (vec a, vec b) {\n\t\tint o = b.ccw(v[0], a);\n\t\tif (o) return (o == 1);\n\t\treturn v[0].sq(a) < v[0].sq(b);\n\t});\n\n\tif (brd) {\n\t\tint s = n-1;\n\t\twhile (s > 1 && v[s].ccw(v[s-1],v[0]) == 0)\n\t\t\ts--;\n\t\tfor (int i = s; i < n - 1 - (i - s); i++)\n\t\t\tswap(v[i], v[n-1-(i-s)]);\n\t}\n\n\tint s = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s && v[s-1].x == v[i].x && v[s-1].y == v[i].y) continue;\n\t\twhile (s >= 2 && v[s-1].ccw(v[s-2],v[i]) >= brd)\n\t\t\ts--;\n\t\tv[s++] = v[i];\n\t}\n\n\treturn s;\n}\n\nconst int N = 1e2+7;\n\nint n;\ndouble r;\nvector<vec> v;\ndouble x[2], y[2];\n\ndouble solve (double x) {\n\tdouble lo = 200, hi = -100.;\n\tfor (int i = 0; i < n; i++) {\n\t\tint j = (i+1)%n;\n\t\tif (abs(v[i].x - v[j].x) > eps_d) {\n\t\t\tlin ln(v[i],v[j]);\n\t\t\tvec it(x, (ln.c - ln.a*x)/ln.b);\n\t\t\tcout << it << \" \";\n\t\t\tif (abs(ln.b) > eps) {\n\t\t\t\tlo = min(lo, it.y);\n\t\t\t\thi = max(hi, it.y);\n\t\t\t}\n\t\t}\n\n\t\tif (abs(v[i].x - x) <= eps_d) {\n\t\t\tcout << v[i] << \"! \";\n\t\t\tlo = min(lo, v[i].y);\n\t\t\thi = max(hi, v[i].y);\n\t\t}\n\t}\n\thi = min(hi, 200.); lo = max(lo, -100.);\n\tcout << x << \" [\" << lo << \" \" << hi << \"]\" << endl;\n\n\tint ts = 60;\n\twhile (ts--) {\n\t\tdouble q1 = (lo+lo+hi)/3;\n\t\tdouble q2 = (lo+hi+hi)/3;\n\n\t\tdouble r1 = abs(cir({ vec(x,q1), r }).inter(v));\n\t\tdouble r2 = abs(cir({ vec(x,q2), r }).inter(v));\n\n\t\tif (r1 < r2)\n\t\t\tlo = q1;\n\t\telse\n\t\t\thi = q2;\n\t}\n\n\treturn abs(cir({ vec(x,lo), r }).inter(v));\n}\n\nint main () {\n\n\twhile (scanf(\"%d %lf\", &n, &r) != EOF) {\n\t\tcout << n << endl;\n\t\tv = vector<vec>(n);\n\t\t\n\t\tx[0] = 200;\n\t\tx[1] = -100;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%lf %lf\", &v[i].x, &v[i].y);\n\t\t\tcout << v[i] << \" \";\n\n\t\t\tx[0] = min(x[0],v[i].x);\n\t\t\tx[1] = max(x[1],v[i].x);\n\t\t}\n\t\tcout << endl;\n\n\t\tdouble lo = x[0], hi = x[1];\n\t\tint ts = 60;\n\t\twhile (ts--) {\n\t\t\tdouble q1 = (lo+lo+hi)/3;\n\t\t\tdouble q2 = (lo+hi+hi)/3;\n\t\t\t\n\t\t\tif (solve(q1) < solve(q2))\n\t\t\t\tlo = q1;\n\t\t\telse\n\t\t\t\thi = q2;\n\t\t}\n\n\t\tprintf(\"%.20f\\n\", solve(lo));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-9)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n\nPoint calc_ps(Polygon poly) {\n  poly = andrewScan(poly);\n  Point mp = poly[0];\n  double rate = 1; // 0.5???????????¨???\n  int max_pos;\n  double eps = 1e-10; // 1e-20???????????¨???\n  while( rate > eps ) {\n    rep(_,60){ // 70???????????¨???\n      max_pos = 0;\n      REP(j,1,(int)poly.size()) {\n        double dist1 = abs(mp-poly[max_pos]);\n        double dist2 = abs(mp-poly[j]);\n\tif( LT(dist1,dist2) ) max_pos = j;\n      }\n      mp.x += ( poly[max_pos].x - mp.x ) * rate;\n      mp.y += ( poly[max_pos].y - mp.y ) * rate;\n    }\n    rate *= 0.5;\n  }\n  return mp;\n}\n\nPoint getCentroidOfConvex(Polygon& poly){\n  double area = getArea(poly);\n  int V = poly.size();\n  assert( !equals(area,0.0) );\n  double x = 0, y = 0;\n  rep(i,(int)poly.size()) {\n    x += ( poly[i].x + poly[(i+1)%V].x ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n    y += ( poly[i].y + poly[(i+1)%V].y ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n  }\n  return Point(x/(6.0*area),y/(6.0*area));\n}\n\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  double maxi;\n  Point mp = calc_ps(poly);\n  maxi = getCommonAreaPolygonCircle(poly,mp,r);\n  double rate = 1.0;\n  double eps = 1e-10;\n  while( LT(eps,rate) ) {\n    rep(_,70) {\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      assert( !equals(max_area,-1) );\n      mp = np;\n      if( LT(maxi,max_area) ) maxi = max_area;\n    }\n    rate *= 0.5;\n  }\n  rep(__,1) {\n    Point mp = calc_ps(poly);\n    double rate = 1.0;\n    double eps = 1e-10;\n    while( LT(eps,rate) ) {\n      rep(_,70) {\n\tdouble max_area = -1; \n\tPoint np;\n\trep(i,n) {\n\t  Point tp = mp;\n\t  tp.x += ( poly[i].x - mp.x ) * rate;\n\t  tp.y += ( poly[i].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,tp,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t    np = tp;\n\t  }\n\t}\n\tif( rand() % 50 == 0 ) {\n\t  int v = rand() % n;\n\t  np.x = ( poly[v].x - mp.x ) * rate;\n\t  np.y = ( poly[v].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,np,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t  }\n\t}\n\tassert( !equals(max_area,-1) );\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      rate *= 0.5;\n    }\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  srand((unsigned int)time(NULL));\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  //cout << getArea(poly) << endl;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint m;\ndouble r;\n\ndouble eps=1e-10;\ndouble add(double a,double b)\n{\n    if(abs(a+b)<eps*abs(a)+abs(b))\n        return 0;\n    return a+b;\n}\ndouble pi=acos(-1);\nstruct point\n{\n    double x,y;\n    point(){}\n    point(double x,double y):x(x),y(y){}\n    point operator + (const point p)const\n    {\n        return point(add(x,p.x),add(y,p.y));\n    }\n    point operator - (const point p)const\n    {\n        return point(add(x,-p.x),add(y,-p.y));\n    }\n    point operator * (const double d)const\n    {\n        return point(x*d,y*d);\n    }\n    double dot(point p)\n    {\n        return add(x*p.x,y*p.y);\n    }\n};\npoint p[105];\ndouble d_mult(point a,point b,point c)\n{\n    return (a.x-c.x)*(b.x-c.x)+(a.y-c.y)*(b.y-c.y);\n}\ndouble x_mult(point a,point b,point c)\n{\n    return (a.x-c.x)*(b.y-c.y)-(a.y-c.y)*(b.x-c.x);\n}\ndouble dist(point a,point b)\n{\n    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\ndouble  EP=0;\ndouble circlesquare(point a,point b,point c,double r)\n{\n    double A,B,C,x,y,S;\n    A=dist(b,c);\n    B=dist(a,c);\n    C=dist(a,b);\n    if(A<r&&B<r)\n        return x_mult(a,b,c)/2;\n    else if(A<r&&B>=r)\n    {\n        x=(d_mult(a,c,b)+sqrt(r*r*C*C-x_mult(a,c,b)*x_mult(a,c,b)))/C;\n        S=x_mult(a,b,c)/2;\n        return asin(S*(1-x/C)*2/r/B*(1-EP))*r*r/2+S*x/C;\n    }\n    else if(A>=r&&B<r)\n    {\n        x=(d_mult(b,c,a)+sqrt(r*r*C*C-x_mult(b,c,a)*x_mult(b,c,a)))/C;\n        S=x_mult(a,b,c)/2;\n        return asin(S*(1-x/C)*2/r/A*(1-EP))*r*r/2+S*x/C;\n    }\n    else if(fabs(x_mult(a,b,c))>=r*C||d_mult(b,c,a)<0||d_mult(a,c,b)<0)\n    {\n        if(d_mult(a,b,c)<0)\n            if(x_mult(a,b,c)<0)\n                return (-acos(-1.0)-asin(x_mult(a,b,c)/A/B*(1-EP)))*r*r/2;\n            else\n                return (acos(-1.0)-asin(x_mult(a,b,c)/A/B*(1-EP)))*r*r/2;\n        else\n            return asin(x_mult(a,b,c)/A/B*(1-EP))*r*r/2;\n    }\n    else\n    {\n        x=(d_mult(a,c,b)+sqrt(r*r*C*C-x_mult(a,c,b)*x_mult(a,c,b)))/C;\n        y=(d_mult(b,c,a)+sqrt(r*r*C*C-x_mult(b,c,a)*x_mult(b,c,a)))/C;\n        S=x_mult(a,b,c)/2;\n        return (asin(S*(1-x/C)*2/r/B*(1-EP))+asin(S*(1-y/C)*2/r/A*(1-EP)))*r*r/2+S*((x+y)/C-1);\n    }\n}\n\ndouble v0,v1,d,t;\ndouble fun(double i)\n{\n    return sqrt((v0 * i) * (v0 * i) - d * d) + v1 * (t - i);\n}\ndouble solve(point cir)\n{\n    double area=0;\n    for(int i=0;i<m;i++){\n        area+=circlesquare(p[i], p[(i+1)%m], cir, r);\n            //cout<<circlesquare(p[i], p[(i+1)%6], cir, r)<<endl;\n            //cout<<p[i].x<<' '<<p[i].y<<endl;\n    //cout<<circlesquare(p[i], p[(i+1)%6], cir, r)<<endl;\n    }\n    double ans=area;\n    //cout<<area<<endl;\n    return ans;\n}\n\ndouble max1(double a,double b)\n{\n    if(a>b)\n        return a;\n    return b;\n}\ndouble min1(double a,double b)\n{\n    if(a>b)\n        return b;\n    else\n        return a;\n}\nint main()\n{\n    double xmin=1000,ymin=1000,xmax=0,ymax=0;\n    scanf(\"%d %lf\",&m,&r);\n    point u(0, 0), v(0, 0), uu(0, 0);\n    for(int i=0;i<m;i++)\n    {\n        scanf(\"%lf %lf\",&p[i].x,&p[i].y);\n        xmin=min1(p[i].x,xmin);\n        ymin=min1(p[i].y,ymin);\n        xmax=max1(p[i].x,xmax);\n        ymax=max1(p[i].y,ymax);\n        u.x += p[i].x;\n        u.y += p[i].y;\n    }\n    u.x /= m; u.y /= m;\n    double step=max(ymax-ymin, xmax-xmin)/2, ma, ans=0, cur;\n    while(step > 1e-12)\n    {\n\t    for (int k = 0; k < 40; k++)\n\t    {\n\t    \tma = 0;\n\t    \tfor (int i = -3; i <= 3; i++)\n\t    \t\tfor (int j = -3; j <= 3; j++)\n\t    \t\t{\n\t    \t\t\tv.x = u.x + step * i;\n\t    \t\t\tv.y = u.y + step * j;\n\t    \t\t\tcur = solve(v);\n\t    \t\t\tif (cur > ma)\n\t    \t\t\t{\n\t    \t\t\t\tma = cur;\n\t    \t\t\t\tuu = v;\n\t\t\t\t\t}\n\t\t\t\t\t//cout<<v.x<<' '<<v.y<<endl;\n\t\t\t\t}\n\t\t\tu = uu;\n\t\t\tans = ma;\n\t\t}\n\t\tstep /= 2;\n\t}\n\t//printf()\n\t//cout<<ans<<endl;\n    printf(\"%.8f\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nstruct EndPoint{\n  Point p;\n  int seg,st;\n  EndPoint(){}\n  EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n  bool operator<(const EndPoint &ep)const{\n    if(p.y==ep.p.y) return st<ep.st;\n    return p.y<ep.p.y;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) is>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps);\n  \nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  return getDistanceSP(s,c.c)<=c.r;\n}\n\nint intersectCS(Circle c,Segment s){\n  if(norm(project(s,c.c)-c.c)-c.r*c.r>EPS) return 0;\n  double d1=abs(c.c-s.p1),d2=abs(c.c-s.p2);\n  if(d1<c.r+EPS&&d2<c.r+EPS) return 0;\n  if((d1<c.r-EPS&&d2>c.r+EPS)||(d1>c.r+EPS&&d2<c.r-EPS)) return 1;\n  Point h=project(s,c.c);\n  if(dot(s.p1-h,s.p2-h)<0) return 2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  for(int k=0;k<2;k++){\n    if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1; \n    if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;\n    swap(s1,s2);\n  }\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCS(Circle c,Segment s){\n  Line l(s);\n  Polygon res=getCrossPointCL(c,l);\n  if(intersectCS(c,s)==2) return res;\n  if(res.size()>1u){\n    if(dot(l.p1-res[0],l.p2-res[0])>0) swap(res[0],res[1]);\n    res.pop_back();\n  }\n  return res;\n}\n\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n        ps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<pair<int, double> > > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++)\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n        ls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n      \n    sort(ls.begin(),ls.end());\n    for(int j=0;j+1<(int)ls.size();j++){\n      int a=ls[j].second,b=ls[j+1].second;\n      G[a].emplace_back(b,abs(ps[a]-ps[b]));\n      G[b].emplace_back(a,abs(ps[a]-ps[b]));\n    }\n  }\n  return G;\n}\n\nint manhattanIntersection(vector<Segment> ss,const int INF){\n  const int BTM = 0;\n  const int LFT = 1;\n  const int RGH = 2;\n  const int TOP = 3;\n  \n  int n=ss.size();\n  vector<EndPoint> ep;\n  for(int i=0;i<n;i++){\n    if(ss[i].p1.y==ss[i].p2.y){\n      if(ss[i].p1.x>ss[i].p2.x) swap(ss[i].p1,ss[i].p2);\n      ep.emplace_back(ss[i].p1,i,LFT);\n      ep.emplace_back(ss[i].p2,i,RGH);\n    }else{\n      if(ss[i].p1.y>ss[i].p2.y) swap(ss[i].p1,ss[i].p2);      \n      ep.emplace_back(ss[i].p1,i,BTM);\n      ep.emplace_back(ss[i].p2,i,TOP);\n    }    \n  }   \n  sort(ep.begin(),ep.end());\n\n  set<int> bt;\n  bt.insert(INF);\n  \n  int cnt=0;\n  for(int i=0;i<n*2;i++){\n    if(ep[i].st==TOP){\n      bt.erase(ep[i].p.x);\n    }else if(ep[i].st==BTM){\n      bt.emplace(ep[i].p.x);\n    }else if(ep[i].st==LFT){\n      auto b=bt.lower_bound(ss[ep[i].seg].p1.x);\n      auto e=bt.upper_bound(ss[ep[i].seg].p2.x);\n      cnt+=distance(b,e);\n    }    \n  }\n  \n  return cnt;\n}\n\ndouble area(Polygon ps,Circle c){\n  if(ps.size()<3u) return 0;\n  function<double(Circle, Point, Point)> dfs=\n    [&](Circle c,Point a,Point b){\n      Vector va=c.c-a,vb=c.c-b;\n      double f=cross(va,vb),res=0;\n      if(equals(f,0.0)) return res;\n      if(max(abs(va),abs(vb))<c.r+EPS) return f;\n      Vector d(dot(va,vb),cross(va,vb));\n      if(getDistanceSP(Segment(a,b),c.c)>c.r-EPS)\n        return c.r*c.r*atan2(d.y,d.x);\n      auto u=getCrossPointCS(c,Segment(a,b));\n      if(u.empty()) return res;\n      if(u.size()>1u&&dot(u[1]-u[0],a-u[0])>0) swap(u[0],u[1]);\n      u.emplace(u.begin(),a);\n      u.emplace_back(b);\n      for(int i=1;i<(int)u.size();i++)\n        res+=dfs(c,u[i-1],u[i]);\n      return res;\n    };\n  double res=0;\n  for(int i=0;i<(int)ps.size();i++)\n    res+=dfs(c,ps[i],ps[(i+1)%ps.size()]);\n  return res/2;\n}\n\n\n\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  double r;\n  cin>>n>>r;\n  \n  Polygon ps(n);\n  for(int i=0;i<n;i++) cin>>ps[i];\n\n  Point g(0,0);\n  for(Point p:ps) g=g+p;\n  g=g/n;\n  \n  double ans=0;\n  const int MAX = 50;\n  auto calc=\n    [&](double d)->double{\n      double res=0;\n      {\n        double L=0,R=100;\n        for(int k=0;k<MAX;k++){\n          double M1=L+(R-L)/3,M2=M1+(R-L)/3;\n          Point c1=g+Vector(d,M1);\n          Point c2=g+Vector(d,M2);\n          double a1=area(ps,Circle(c1,r));\n          double a2=area(ps,Circle(c2,r));\n          chmax(res,a1);\n          chmax(res,a2);\n          if(a2<EPS) R=M2;\n          else if(a1<a2) L=M1;\n          else R=M2;\n        }\n      }\n      {\n        double L=0,R=100;\n        for(int k=0;k<MAX;k++){\n          double M1=L+(R-L)/3,M2=M1+(R-L)/3;\n          Point c1=g+Vector(d,-M1);\n          Point c2=g+Vector(d,-M2);\n          double a1=area(ps,Circle(c1,r));\n          double a2=area(ps,Circle(c2,r));\n          chmax(res,a1);\n          chmax(res,a2);\n          if(a2<EPS) R=M2;\n          else if(a1<a2) L=M1;\n          else R=M2;\n        }\n      }\n      chmax(ans,res);\n      //cout<<d<<\":\"<<res<<endl;\n      return res;\n    };\n  \n  {\n    double L=0,R=100;\n    for(int k=0;k<MAX;k++){\n      double M1=L+(R-L)/3,M2=M1+(R-L)/3;\n      if(calc(M2)<EPS) R=M2;\n      else if(calc(M1)<calc(M2)) L=M1;\n      else R=M2;\n    }\n  }\n  {\n    double L=0,R=100;\n    for(int k=0;k<MAX;k++){\n      double M1=L+(R-L)/3,M2=M1+(R-L)/3;\n      if(calc(-M2)<EPS) R=M2;\n      else if(calc(-M1)<calc(-M2)) L=M1;\n      else R=M2;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;  \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-9)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n\nPoint calc_ps(Polygon poly) {\n  poly = andrewScan(poly);\n  Point mp = poly[0];\n  double rate = 1; // 0.5???????????¨???\n  int max_pos;\n  double eps = 1e-10; // 1e-20???????????¨???\n  while( rate > eps ) {\n    rep(_,60){ // 70???????????¨???\n      max_pos = 0;\n      REP(j,1,(int)poly.size()) {\n        double dist1 = abs(mp-poly[max_pos]);\n        double dist2 = abs(mp-poly[j]);\n\tif( LT(dist1,dist2) ) max_pos = j;\n      }\n      mp.x += ( poly[max_pos].x - mp.x ) * rate;\n      mp.y += ( poly[max_pos].y - mp.y ) * rate;\n    }\n    rate *= 0.5;\n  }\n  return mp;\n}\n\nPoint getCentroidOfConvex(Polygon& poly){\n  double area = getArea(poly);\n  int V = poly.size();\n  assert( !equals(area,0.0) );\n  double x = 0, y = 0;\n  rep(i,(int)poly.size()) {\n    x += ( poly[i].x + poly[(i+1)%V].x ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n    y += ( poly[i].y + poly[(i+1)%V].y ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n  }\n  return Point(x/(6.0*area),y/(6.0*area));\n}\n\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  double maxi;\n  Point mp = calc_ps(poly);\n  maxi = getCommonAreaPolygonCircle(poly,mp,r);\n  double rate = 1.0;\n  double eps = 1e-10;\n  while( LT(eps,rate) ) {\n    rep(_,70) {\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      assert( !equals(max_area,-1) );\n      mp = np;\n      if( LT(maxi,max_area) ) maxi = max_area;\n    }\n    rate *= 0.5;\n  }\n  rep(__,1) {\n    Point mp = calc_ps(poly);\n    double rate = 1.0;\n    double eps = 1e-10;\n    while( LT(eps,rate) ) {\n      rep(_,70) {\n\tdouble max_area = -1; \n\tPoint np;\n\trep(i,n) {\n\t  Point tp = mp;\n\t  tp.x += ( poly[i].x - mp.x ) * rate;\n\t  tp.y += ( poly[i].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,tp,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t    np = tp;\n\t  }\n\t}\n\tif( rand() % 50 == 0 ) {\n\t  int v = rand() % n;\n\t  np.x = ( poly[v].x - mp.x ) * rate;\n\t  np.y = ( poly[v].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,np,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t  }\n\t}\n\tassert( !equals(max_area,-1) );\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      rate *= 0.5;\n    }\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  srand((unsigned int)time(NULL));\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  //cout << getArea(poly) << endl;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\n\nstruct P {\n\tdouble x, y;\n\tP() {\n\t}\n\tP(double _x, double _y) :\n\t\t\tx(_x), y(_y) {\n\t}\n\tP operator+(const P&p) const {\n\t\treturn P(x + p.x, y + p.y);\n\t}\n\tP operator-(const P&p) const {\n\t\treturn P(x - p.x, y - p.y);\n\t}\n\tP operator*(double d) const {\n\t\treturn P(x * d, y * d);\n\t}\n\tP operator/(double d) const {\n\t\treturn P(x / d, y / d);\n\t}\n\tdouble det(const P&p) const {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdouble dot(const P&p) const {\n\t\treturn x * p.x + y * p.y;\n\t}\n\tdouble alpha() const {\n\t\treturn atan2(y, x);\n\t}\n\tP rot90() const {\n\t\treturn P(-y, x);\n\t}\n\tvoid read() {\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t}\n\tvoid write() const {\n\t\tprintf(\"(%lf,%lf)\", x, y);\n\t}\n\tdouble abs() {\n\t\treturn sqrt(abs2());\n\t}\n\tdouble abs2() {\n\t\treturn x * x + y * y;\n\t}\n\tP unit() {\n\t\treturn *this / abs();\n\t}\n};\n\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n\nconst double EPS = 1e-8; //you should change it according to problem, nevertheless, it mustn't be a constant value some times.\ninline int sign(double a) {\n\treturn a < -EPS ? -1 : a > EPS;\n}\n\n#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))\n\nP isSS(P p1, P p2, P q1, P q2) {\n\tdouble a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);\n\treturn (p1 * a2 + p2 * a1) / (a1 + a2);\n}\n\nint n;\n\ndouble x[12],y[12],r;\n\nbool onLine(P p, P q, P x){\n\treturn (x-p).dot(x-q) <= EPS;\n}\n\nvector<P> isCS(P c,double r,P p, P q){\n\tdouble d = cross(q,p,c) / (p-q).abs();\n\tvector<P> ret;\n\n\tif(d>=r+EPS)\n\t\treturn ret;\n\n\tP dir = (q-p).rot90();\n\tP pq = (p-q);\n\tpq = pq/pq.abs();\n\n\tdir = dir / dir.abs();\n\n\tP mid = c + dir * d;\n\n\tdouble h = sqrt(max(r*r-d*d,0.0));\n\tif(onLine(p,q,mid + pq*h))\n\t\tret.push_back(mid + pq*h);\n\tif(onLine(p,q,mid - pq*h))\n\t\tret.push_back(mid - pq*h);\n\treturn ret;\n}\n\ndouble rad(P p,P q){\n\treturn atan2(p.det(q),p.dot(q));\n}\n\ndouble calc(P p, P q){\n\tbool inp = p.abs2() <= r*r;\n\tbool inq = q.abs2() <= r*r;\n\tif(inp && inq){\n\t\treturn p.det(q)/2;\n\t}\n\tif(inp && !inq){\n\t\treturn -calc(q,p);\n\t}\n\tvector<P> is = isCS(P(0,0),r,p,q);\n\tif(!inp && inq){\n\t\tP m = is[0];\n\t\treturn r*r*rad(p,m)/2 + m.det(q)/2;\n\t}\n\n\tif(!inp && !inq){\n\t\tif(is.empty())\n\t\t\treturn r*r*rad(p,q)/2;\n\t\treturn r*r*(rad(p,is[0]) + rad(is[1],q))/2 + is[0].det(is[1])/2;\n\t}\n}\n\ndouble calcArea(double cx,double cy){\n\tP ps[12];\n\trep(i,n) ps[i].x=x[i]-cx,ps[i].y=y[i]-cy;\n\tps[n] = ps[0];\n\n\tdouble area = 0;\n\n\trep(i,n){\n\t\tP p=ps[i],q=ps[i+1];\n\t\tarea += calc(p,q);\n\t}\n\n\t//cout<<area<<endl;\n\n\treturn area;\n}\n\ndouble ffy(double x){\n\tdouble l=*min_element(y,y+n),r=*max_element(y,y+n);\n\trep(it,100){\n\t\tdouble ll=(l*2+r)/3,rr=(l+r*2)/3;\n\t\tif(calcArea(x,ll)>calcArea(x,rr))\n\t\t\tr=rr;\n\t\telse\n\t\t\tl=ll;\n\t}\n\treturn calcArea(x,l);\n}\n\ndouble ffx(){\n\tdouble l=*min_element(x,x+n),r=*max_element(x,x+n);\n\trep(it,100){\n\t\tdouble ll=(l*2+r)/3,rr=(l+r*2)/3;\n\t\tif(ffy(ll)>ffy(rr))\n\t\t\tr=rr;\n\t\telse\n\t\t\tl=ll;\n\t}\n\treturn ffy(l);\n}\n\nint main(){\n\tcin>>n>>r;\n\trep(i,n) cin>>x[i]>>y[i];\n\n\tprintf(\"%0.10lf\\n\",ffx());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\n#define CVector CPoint\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1);\nconst double EPS=1e-6;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-10;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、线结构体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n    /*friend bool operator<(CPoint a,CPoint b){//极角排序\n        double tmp=cross(Pts[0],a,b);\n        if(isZero(tmp)){\n            return dist(Pts[0],a)<dist(Pts[0],b);\n        }\n        return tmp>0;\n    }*/\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、线相关----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//单位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影长度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所夹的有向面积\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b绕a逆时针旋转alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b绕a逆时针旋转alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求过p的l的垂线\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//两向量夹角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//两直线夹角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在线段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直线交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断线段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n/*----------------------多边形相关--------------------------*/\n\n//0:outside 1:inside 2:online\nint PointInPoly(Point t,Point *Pts,int n){\n    int num=0,d1,d2,k;\n    Pts[n]=Pts[0];\n    for(int i=0;i<n;i++){\n        if(PointOnS(t,Line(Pts[i],Pts[i+1]))) return 2;\n        k=dcmp(cross(Pts[i],Pts[i+1],t));\n        d1=dcmp(Pts[i].y-t.y);\n        d2=dcmp(Pts[i+1].y-t.y);\n        if(k>0&&d1<=0&&d2>0) num++;\n        if(k<0&&d2<=0&&d1>0) num--;\n    }\n    return num!=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n//求任意多边形周长，需逆时针或顺时针排列\ndouble PolyPerimeter(Point *Pts,int n){\n    double pp=distPP(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pp+=distPP(Pts[i],Pts[i+1]);\n    return pp;\n}\n\n//求多边形重心坐标\nPoint PolyCore(Point *Pts,int n){\n    double pa=PolyArea(Pts,n);\n    if(!dcmp(pa)) return Point(0,0);\n    Point ans=(Pts[n-1]+Pts[0])*cross(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) ans=ans+(Pts[i]+Pts[i+1])*cross(Pts[i],Pts[i+1]);\n    return ans/pa/6;\n}\n\n/*----------------------凸包----------------------------*/\n\n//Graham-scan st:anticlockwise\n//<=:strict <:Non-strict\nint Graham(Point *Pts,Point *st,int n){\n    if(n<3) return 0;\n    sort(Pts,Pts+n);\n    int m=0;\n    for(int i=0;i<n;i++){\n        while(m>1&&dcmp(cross(st[m-2],st[m-1],Pts[i]))<0) m--;\n        st[m++]=Pts[i];\n    }\n    int k=m;\n    for(int i=n-2;i>=0;i--){\n        while(m>k&&dcmp(cross(st[m-2],st[m-1],Pts[i])<0)) m--;\n        st[m++]=Pts[i];\n    }\n    return m-1;\n}\n\n//clockwise:> anticlockwise:<\ndouble CHDiameter(Point *Pts,int n,Line &l){\n    double maxd=0.0;\n    if(n<=1){\n        l.a=l.b=Pts[0];\n        return maxd;\n    }\n    for(int i=0,j=1;i<n;i++){\n        while(cross(Pts[i],Pts[(i+1)%n],Pts[j])\n              >cross(Pts[i],Pts[(i+1)%n],Pts[(j+1)%n])){\n            j=(j+1)%n;\n        }\n        double d=distPP(Pts[i],Pts[j]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n        d=distPP(Pts[(i+1)%n],Pts[(j+1)%n]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n    }\n    return maxd;\n}\n\n/*---------------------整点多边形---------------------------*/\n\nint gcd(int a,int b){\n    return b==0?a :gcd(b,a%b);\n}\n\n//整点多边形边界整点数\nint Border_Int_Point_Num(Point *Pts,int n){\n    int num=gcd(abs(int(Pts[0].x-Pts[n-1].x)),abs(int(Pts[0].y-Pts[n-1].y)));;\n    for(int i=0;i<n-1;i++){\n        num+=gcd(abs(int(Pts[i+1].x-Pts[i].x)),abs(int(Pts[i+1].y-Pts[i].y)));\n    }\n    return num;\n}\n\n//整点多边形内部整点数\nint Inside_Int_Point_Num(Point *Pts,int n){\n    return abs(int(PolyArea(Pts,n)))+1-Border_Int_Point_Num(Pts,n)/2;\n}\n\n/*-----------------------------半平面交-------------------------------*/\n\n//有方向的直线\n//p->p+v\nstruct Vector{\n    Point p,v;\n    double ang;\n    Vector(Point p,Point v):p(p),v(v){\n        ang=atan2(v.y,v.x);\n    }\n    Vector(){}\n    bool operator<(const Vector &l) const{\n        return ang<l.ang;\n    }\n};\n\n//判断点p是否在直线L左边\nbool onLeft(Vector L,Point p){\n    return cross(L.v,p-L.p)>0;\n}\n\n//得到a与b两直线的交点\nPoint getCrossVV(Vector a,Vector b){\n    Point u=a.p-b.p;\n    double t=cross(b.v,u)/cross(a.v,b.v);\n    return a.p+a.v*t;\n}\n\n//所有直线左半平面的交\nint HPCross(Vector *L,int n,Point *poly){\n    sort(L,L+n);\n    int f=0,l=0;\n    Point *p=new Point[n];\n    Vector *q=new Vector[n];\n    q[0]=L[0];\n    for(int i=1;i<n;i++){\n        while(f<l&&!onLeft(L[i],p[l-1])) l--;\n        while(f<l&&!onLeft(L[i],p[f])) f++;\n        q[++l]=L[i];\n        if(!dcmp(cross(q[l].v,q[l-1].v))){\n            l--;\n            if(onLeft(q[l],L[i].p)) q[l]=L[i];\n        }\n        if(f<l) p[l-1]=getCrossVV(q[l-1],q[l]);\n    }\n    while(f<l&&!onLeft(q[f],p[l-1])) l--;\n    if(l-f<=1) return 0;\n    p[l]=getCrossVV(q[l],q[f]);\n    int m=0;\n    for(int i=f;i<=l;i++) poly[m++]=p[i];\n    return m;\n}\n\n#define maxn 100005\nVector l[maxn];\nbool retract(Vector *L,int n,double r,Point *poly){\n    for(int i=0;i<n;i++){\n        Point v=rotateV(L[i].p,L[i].p+L[i].v,PI/2);\n        l[i]=Vector(L[i].p+r*v,L[i].v);\n    }\n    int cnt=HPCross(l,n,poly);\n    return cnt;\n}\n\n/*---------------------三角形相关---------------------------*/\n\n//三角形重心\n//到三顶点距离的平方和最小的点\n//到三边距离之积最大的点\nPoint TCore(Point a,Point b,Point c){\n    return (a+b+c)/3;\n}\n\n//三角形外心\nPoint TCircum(Point a,Point b,Point c){\n    Point cp;\n    double a1=b.x-a.x;\n    double b1=b.y-a.y;\n    double a2=c.x-a.x;\n    double b2=c.y-a.y;\n    double c1=(a1*a1+b1*b1)/2;\n    double c2=(a2*a2+b2*b2)/2;\n    double d=a1*b2-a2*b1;\n    cp.x=a.x+(c1*b2-c2*b1)/d;\n    cp.y=a.y+(a1*c2-a2*c1)/d;\n    return cp;\n}\n\n//三角形垂心\nPoint TOrtho(Point a,Point b,Point c){\n    return TCore(a,b,c)*3.0-TCircum(a,b,c)*2.0;\n}\n\n//三角形内心\nPoint TInner(Point a,Point b,Point c){\n    Point cp;\n    double la=distPP(b,c),lb=distPP(c,a),lc=distPP(a,b);\n    cp.x=(la*a.x+lb*b.x+lc*c.x)/(la+lb+lc);\n    cp.y=(la*a.y+lb*b.y+lc*c.y)/(la+lb+lc);\n    return cp;\n}\n\n//求三角形面积\ndouble TArea(Point a,Point b,Point c){\n    return fabs(cross(a,b,c))/2;\n}\n\n/*-----------------------圆相关-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n//求两圆面积交\ndouble getAreaCC(Circle a,Circle b){\n    double d=(a.o.x-b.o.x)*(a.o.x-b.o.x)+(a.o.y-b.o.y)*(a.o.y-b.o.y);\n    if(d<=(a.r-b.r)*(a.r-b.r)){\n        return min(a.r,b.r)*min(a.r,b.r)*PI;\n    }else if(d>(a.r-b.r)*(a.r-b.r)&&d<(a.r+b.r)*(a.r+b.r)){\n        double m1=(a.r*a.r+d-b.r*b.r)/(2*a.r*sqrt(d));\n        double m2=(b.r*b.r+d-a.r*a.r)/(2*b.r*sqrt(d));\n        double s1=acos(m1)*a.r*a.r;\n        double s2=acos(m2)*b.r*b.r;\n        double s3=sqrt(d)*a.r*sin(acos(m1));\n        return s1+s2-s3;\n    }\n    return 0.0;\n}\n\n/********************************************************/\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n\nint getCrossCS(Circle c,Line s,Point *cs){\n    int fg=dcmp(distPL(c.o,s)-c.r);\n    int cnt=0;\n    Point rt=root(c.o,s);\n    if(!fg){\n        if(PointOnS(rt,s)) cs[cnt++]=rt;\n    }else if(fg==-1){\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        Point p1=rt+r*unit(s.b-s.a);\n        Point p2=rt-r*unit(s.b-s.a);\n        if(PointOnS(p1,s)) cs[cnt++]=p1;\n        if(PointOnS(p2,s)) cs[cnt++]=p2;\n    }\n    return cnt;\n}\n\ndouble getAngle(Point a,Point b){\n    double tmp=dot(a,b)/(length(a)*length(b));\n    if(tmp<-1.0) tmp=-1.0;\n    if(1.0<tmp) tmp=1.0;\n    return acos(tmp)*180.0/PI;\n}\n\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=fabs(cross(a-c.o,b-c.o)/2);\n    if(!dcmp(atc)) return 0.0;\n    double la=length(a-c.o),lb=length(b-c.o);\n    Point cs[4];\n    if(la<c.r+EPS&&lb>c.r-EPS){\n        getCrossCS(c,Line(a,b),cs);\n        Point p=cs[0];\n        atc+=0.5*c.area()*angleVV(p-c.o,b-c.o);\n        atc-=0.5*fabs(cross(p-c.o,b-c.o));\n    }else if(la>c.r-EPS&&lb<c.r+EPS){\n        getCrossCS(c,Line(a,b),cs);\n        Point p=cs[0];\n        atc+=0.5*c.area()*angleVV(p-c.o,a-c.o);\n        atc-=0.5*fabs(cross(p-c.o,a-c.o));\n    }else if(la>c.r-EPS&&lb>c.r-EPS){\n        if(distPS(c.o,Line(a,b))<c.r+EPS){\n            Point rt=root(c.o,Line(a,b));\n            atc=fabs(getAreaTC(a,rt,c))+fabs(getAreaTC(rt,b,c));\n        }else atc=0.5*c.area()*angleVV(a-c.o,b-c.o);\n    }\n    if(cross(a-c.o,b-c.o)>0.0) atc=-atc;\n    return atc;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=getAreaTC(Pts[n-1],Pts[0],c);\n    for(int i=0;i<n-1;i++) apc+=getAreaTC(Pts[i],Pts[i+1],c);\n    return fabs(apc);\n}\n\n/********************************************************/\n\n\n/*----------------------三维点、线基本函数-----------------------------*/\n\nstruct Point3{\n    double x,y,z;\n    Point3(double x,double y,double z):x(x),y(y),z(z){}\n    Point3(){}\n    void Read(){ scanf(\"%lf%lf%lf\",&x,&y,&z); }\n};\n\nstruct Line3{\n    Point3 a,b;\n    Line3(Point3 a,Point3 b):a(a),b(b){}\n    Line3(){}\n    void Read(){ a.Read(); b.Read(); }\n};\nPoint3 operator +(Point3 a,Point3 b){ return Point3(a.x+b.x,a.y+b.y,a.z+b.z); }\nPoint3 operator -(Point3 a,Point3 b){ return Point3(a.x-b.x,a.y-b.y,a.z-b.z); }\ndouble operator *(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 operator *(Point3 a,double k){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator *(double k,Point3 a){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator /(Point3 a,double k){ return Point3(a.x/k,a.y/k,a.z/k); }\n\ndouble length(Point3 a){ return sqrt(a.x*a.x+a.y*a.y+a.z*a.z); }\nPoint3 unit(Point3 a){ return a/length(a); }\ndouble dot(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 cross(Point3 a,Point3 b){\n    return Point3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//混合积\ndouble Mix(Point3 a,Point3 b,Point3 c){\n    return dot(a,cross(b,c));\n}\n\n//两点距离\ndouble dist(const Point3 &a,const Point3 &b){ return length(a-b); }\n\n/*---------------------------------体积-------------------------------------*/\n\n//四面体体积\ndouble volume(double l,double n,double a,double m,double b,double c){\n    double x,y;\n    x=4*a*a*b*b*c*c-a*a*(b*b+c*c-m*m)*(b*b+c*c-m*m)-b*b*(c*c+a*a-n*n)*(c*c+a*a-n*n);\n    y=c*c*(a*a+b*b-l*l)*(a*a+b*b-l*l)-(a*a+b*b-l*l)*(b*b+c*c-m*m)*(c*c+a*a-n*n);\n    return sqrt(x-y)/12;\n}\n\ndouble volume(Point3 a,Point3 b,Point3 c,Point3 d){\n    return fabs(Mix(b-a,c-a,d-a)/6);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=maxy,r=miny;\n    Line s=Line(Point(x,0),Point(x,1));\n    for(int i=1;i<=n;i++){\n        Point st=getCrossLL(s,Line(Pts[i],Pts[i+1]));\n        if(PointOnS(st,Line(Pts[i],Pts[i+1]))){\n            l=min(l,st.y);\n            r=max(r,st.y);\n        }\n    }\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);cin.tie(0);\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n+1-i].x>>Pts[n+1-i].y;\n        minx=min(minx,Pts[n+1-i].x);\n        miny=min(miny,Pts[n+1-i].y);\n        maxx=max(maxx,Pts[n+1-i].x);\n        maxy=max(maxy,Pts[n+1-i].y);\n    }\n    Pts[n+1]=Pts[1];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n\nstruct Point{\n\tPoint(double arg_x,double arg_y){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\n\tPoint(){\n\t\tx = y = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){ return Point(a*x,a*y); }\n\tPoint operator / (double a){ return Point(x/a,y/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator<(const Point &p) const{\n\t\treturn x != p.x? x < p.x: y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n\n\tdouble x,y;\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Circle{\n\tPoint center;\n\tdouble r;\n};\n\nstruct Line{\n\tPoint p[2];\n\tLine(Point p1,Point p2){\n\t\tp[0] = p1;\n\t\tp[1] = p2;\n\t}\n\tLine(){\n\n\t}\n};\n\nint N;\ndouble r;\ndouble min_x,max_x,min_y,max_y;\nbool is_out[15];\nPolygon POLYGON;\n\n\ndouble norm(Vector a){\n\treturn a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n\nPoint project(Line l,Point p){\n\n\tVector base = l.p[1]-l.p[0];\n\tdouble r = dot(p-l.p[0],base)/norm(base);\n\treturn l.p[0]+base*r;\n}\n\n//円と直線の交点を求める関数\nvector<Point> getCrossPoints(Circle c,Line l){\n\n\tvector<Point> ret;\n\n\tVector pr = project(l,c.center);\n\tVector e = (l.p[1]-l.p[0])/abs(l.p[1]-l.p[0]);\n\n\tdouble base;\n\n\tif(fabs(c.r*c.r-norm(pr-c.center)) < EPS){\n\n\t\tbase = 0;\n\t}else{\n\t\tbase = sqrt(c.r*c.r-norm(pr-c.center));\n\t}\n\n\tret.push_back(Point(pr+e*base));\n\tret.push_back(Point(pr-e*base));\n\n\treturn ret;\n}\n\nPoint calc_minus(Point a,Point b){\n    Point ret;\n\n    ret.x = a.x-b.x;\n    ret.y = a.y-b.y;\n\n    return ret;\n}\n\ndouble calc_len(Vector a){\n    return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble calc_slope(Line A){\n\n\tif(fabs(A.p[0].x-A.p[1].x) < EPS){\n\n\t\treturn DBL_MAX;\n\n\t}else if(fabs(A.p[0].y-A.p[1].y) < EPS){\n\n\t\treturn 0;\n\n\t}else{\n\n\t\treturn (A.p[0].y-A.p[1].y)/(A.p[0].x-A.p[1].x);\n\t}\n}\n\n//★★線分ではなく直線と点の距離★★\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(calc_minus(l.p[1],l.p[0]),calc_minus(p,l.p[0]))/calc_len(calc_minus(l.p[1],l.p[0])));\n}\n\n//★★点と線分の距離★★\ndouble getDistanceSP(Line l,Point p){\n\tif(dot(calc_minus(l.p[1],l.p[0]),calc_minus(p,l.p[0])) < 0.0)return calc_len(calc_minus(p,l.p[0]));\n\tif(dot(calc_minus(l.p[0],l.p[1]),calc_minus(p,l.p[1])) < 0.0)return calc_len(calc_minus(p,l.p[1]));\n\treturn getDistanceLP(l,p);\n}\n\ndouble calc_S(Polygon g){\n\n\tint N = g.size();\n\tdouble ret = 0;\n\n\tfor(int i = 0; i < g.size(); i++){\n\t\tret += cross(g[i],g[(i+1)%N]);\n\t}\n\treturn ret/2.0;\n}\n\ndouble calc_dist(Point A,Point B){\n\n\treturn sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));\n}\n\n//交点を求める関数\nPoint calc_Cross_Point(double x1,double x2,double x3,double x4,double y1,double y2,double y3,double y4){\n\tPoint ret;\n\tret.x = ((x2-x1)*(y3*(x4-x3)+x3*(y3-y4))-(x4-x3)*(y1*(x2-x1)+x1*(y1-y2)))/((y2-y1)*(x4-x3)-(y4-y3)*(x2-x1));\n\tif(x1 != x2){\n\t\tret.y = ((y2-y1)*ret.x+y1*(x2-x1)+x1*(y1-y2))/(x2-x1);\n\t}else{\n\t\tret.y = ((y4-y3)*ret.x+y3*(x4-x3)+x3*(y3-y4))/(x4-x3);\n\t}\n\treturn ret;\n}\n\n//インタフェース関数\nPoint calc_Cross_Point(Point a,Point b,Point c,Point d){\n\treturn calc_Cross_Point(a.x,b.x,c.x,d.x,a.y,b.y,c.y,d.y);\n}\n\nPoint calc_Cross_Point(Line A,Line B){\n\n\tif(getDistanceSP(B,A.p[0]) < EPS){\n\n\t\treturn A.p[0];\n\n\t}else if(getDistanceSP(B,A.p[1]) < EPS){\n\n\t\treturn A.p[1];\n\n\t}else if(getDistanceSP(A,B.p[0]) < EPS){\n\n\t\treturn B.p[0];\n\n\t}else if(getDistanceSP(A,B.p[1]) < EPS){\n\n\t\treturn B.p[1];\n\t}\n\n\treturn calc_Cross_Point(A.p[0],A.p[1],B.p[0],B.p[1]);\n}\n\n\n//円とポリゴンの共通面積を求める\ndouble calc_common_S(Circle circle,Polygon polygon){\n\n\t//それぞれの頂点が、円の内部にあるか否かを調べる\n\tfor(int i = 0; i < N; i++){\n\n\t\tdouble tmp_dist = calc_dist(polygon[i],circle.center);\n\n\t\tif(tmp_dist <= circle.r){\n\n\t\t\tis_out[i] = false; //中\n\n\t\t}else{\n\n\t\t\tis_out[i] = true; //外\n\t\t}\n\t}\n\n\tdouble ret = 0;\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tPoint left = polygon[i];\n\t\tPoint right = polygon[(i+1)%N];\n\n\t\tLine tmp_line = Line(left,right);\n\t\tdouble tmp_dist = getDistanceSP(tmp_line,circle.center);\n\n\t\tif(is_out[i] == false && is_out[(i+1)%N] == false){ //両方中\n\n\t\t\tPolygon tmp;\n\t\t\ttmp.push_back(circle.center);\n\t\t\ttmp.push_back(right);\n\t\t\ttmp.push_back(left);\n\n\n\t\t\tret += calc_S(tmp);\n\n\t\t}else if(is_out[i] == true && is_out[(i+1)%N] == true){ //両方外\n\n\t\t\t//printf(\"点%dと点%dは両方外\\n\",i,(i+1)%N);\n\n\t\t\tif(tmp_dist > circle.r){ //両方外かつ交点なし:扇形\n\n\t\t\t\tVector vec1 = left-circle.center;\n\t\t\t\tVector vec2 = right-circle.center;\n\n\t\t\t\tdouble theta = acos(dot(vec1,vec2)/(abs(vec1)*abs(vec2)));\n\n\t\t\t\tret += (r*r*theta)/2;\n\n\t\t\t}else{ //交点あり\n\n\t\t\t\tvector<Point> cross_points = getCrossPoints(circle,Line(left,right));\n\t\t\t\tif(calc_dist(left,cross_points[1]) < calc_dist(left,cross_points[0])){\n\n\t\t\t\t\tswap(cross_points[0],cross_points[1]);\n\t\t\t\t}\n\n\t\t\t\t//左側扇形\n\t\t\t\tVector vec1 = left-circle.center;\n\t\t\t\tVector vec2 = cross_points[0]-circle.center;\n\n\t\t\t\tdouble theta = acos(dot(vec1,vec2)/(abs(vec1)*abs(vec2)));\n\n\t\t\t\tret += (r*r*theta)/2;\n\n\t\t\t\t//三角形\n\t\t\t\tPolygon tmp;\n\t\t\t\ttmp.push_back(circle.center);\n\t\t\t\ttmp.push_back(cross_points[1]);\n\t\t\t\ttmp.push_back(cross_points[0]);\n\n\t\t\t\tret += calc_S(tmp);\n\n\t\t\t\t//右側扇形\n\t\t\t\tVector vec3 = cross_points[1]-circle.center;\n\t\t\t\tVector vec4 = right-circle.center;\n\n\t\t\t\tdouble theta2 = acos(dot(vec3,vec4)/(abs(vec3)*abs(vec4)));\n\n\t\t\t\tret += (r*r*theta2)/2;\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tif(is_out[i] == true){ //leftが外\n\n\t\t\t\tvector<Point> cross_points = getCrossPoints(circle,Line(left,right));\n\n\t\t\t\t//leftに近い方が交点\n\t\t\t\tPoint cross_point;\n\t\t\t\tif(calc_dist(left,cross_points[0]) < calc_dist(left,cross_points[1])){\n\n\t\t\t\t\tcross_point = cross_points[0];\n\n\t\t\t\t}else{\n\n\t\t\t\t\tcross_point = cross_points[1];\n\t\t\t\t}\n\n\t\t\t\t//左扇\n\t\t\t\tVector vec1 = left-circle.center;\n\t\t\t\tVector vec2 = cross_point-circle.center;\n\n\t\t\t\tdouble theta = acos(dot(vec1,vec2)/(abs(vec1)*abs(vec2)));\n\n\t\t\t\tret += (r*r*theta)/2;\n\n\t\t\t\t//三角形\n\t\t\t\tPolygon tmp;\n\t\t\t\ttmp.push_back(circle.center);\n\t\t\t\ttmp.push_back(right);\n\t\t\t\ttmp.push_back(cross_point);\n\n\t\t\t\tret += calc_S(tmp);\n\n\t\t\t}else{ //rightが外\n\n\t\t\t\tvector<Point> cross_points = getCrossPoints(circle,Line(left,right));\n\n\t\t\t\t//rightに近い方が交点\n\t\t\t\tPoint cross_point;\n\t\t\t\tif(calc_dist(right,cross_points[0]) < calc_dist(right,cross_points[1])){\n\n\t\t\t\t\tcross_point = cross_points[0];\n\n\t\t\t\t}else{\n\n\t\t\t\t\tcross_point = cross_points[1];\n\t\t\t\t}\n\n\t\t\t\t//三角形\n\t\t\t\tPolygon tmp;\n\t\t\t\ttmp.push_back(circle.center);\n\t\t\t\ttmp.push_back(cross_point);\n\t\t\t\ttmp.push_back(left);\n\n\t\t\t\tret += calc_S(tmp);\n\n\t\t\t\t//右扇\n\t\t\t\tVector vec1 = cross_point-circle.center;\n\t\t\t\tVector vec2 = right-circle.center;\n\n\t\t\t\tdouble theta = acos(dot(vec1,vec2)/(abs(vec1)*abs(vec2)));\n\n\t\t\t\tret += (r*r*theta)/2;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\n\nbool is_Cross(Line a,Line b){\n\n\tif(func(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[0].x,b.p[0].y)*\n\t\t\tfunc(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[1].x,b.p[1].y) <= 0 &&\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[0].x,a.p[0].y)*\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[1].x,a.p[1].y) <= 0){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\ndouble thirds_searchY(double X){\n\n\tdouble L = max_y,R = min_y;\n\n\t//交点を持つy座標の範囲を求める\n\tLine line = Line(Point(X,-1000),Point(X,1000));\n\n\tbool FLG = false;\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tLine tmp = Line(POLYGON[i],POLYGON[(i+1)%N]);\n\n\t\tif(is_Cross(line,tmp)){\n\n\t\t\tPoint p = calc_Cross_Point(tmp,line);\n\t\t\tL = min(L,p.y);\n\t\t\tR = max(R,p.y);\n\n\t\t\tFLG = true;\n\t\t}\n\t}\n\n\tif(!FLG)return 0;\n\n\n\tfor(int loop = 0; loop < 100; loop++){\n\n\t\tdouble mid1 = (2.0*L+R)/3.0;\n\t\tdouble mid2 = (1.0*L+2.0*R)/3.0;\n\n\t\tCircle circle1,circle2;\n\n\t\tcircle1.center.x = X;\n\t\tcircle1.center.y = mid1;\n\t\tcircle1.r = r;\n\n\t\tcircle2.center.x = X;\n\t\tcircle2.center.y = mid2;\n\t\tcircle2.r = r;\n\n\t\tif(calc_common_S(circle1,POLYGON) > calc_common_S(circle2,POLYGON)){\n\n\t\t\tR = mid2;\n\t\t}else{\n\n\t\t\tL = mid1;\n\t\t}\n\t}\n\n\tCircle circle;\n\tcircle.center.x = X;\n\tcircle.center.y = (L+R)/2;\n\tcircle.r = r;\n\n\treturn calc_common_S(circle,POLYGON);\n}\n\ndouble thirds_searchX(){\n\n\tdouble L = min_x,R = max_x;\n\n\tfor(int loop = 0; loop < 100; loop++){\n\n\t\tdouble mid1 = (2.0*L+R)/3.0;\n\t\tdouble mid2 = (1.0*L+2.0*R)/3.0;\n\n\t\tif(thirds_searchY(mid1) > thirds_searchY(mid2)){\n\n\t\t\tR = mid2;\n\t\t}else{\n\n\t\t\tL = mid1;\n\t\t}\n\t}\n\n\treturn thirds_searchY((L+R)/2);\n}\n\n\nint main(){\n\n\tscanf(\"%d %lf\",&N,&r);\n\n\tmin_x = BIG_NUM;\n\tmin_y = BIG_NUM;\n\n\tmax_x = -BIG_NUM;\n\tmax_y = -BIG_NUM;\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tdouble x,y;\n\t\tscanf(\"%lf %lf\",&x,&y);\n\n\t\tmin_x = min(min_x,x);\n\t\tmin_y = min(min_y,y);\n\n\t\tmax_x = max(max_x,x);\n\t\tmax_y = max(max_y,y);\n\n\t\tPOLYGON.push_back(Point(x,y));\n\t}\n\n\treverse(POLYGON.begin(),POLYGON.end());\n\n\tprintf(\"%.10lf\\n\",thirds_searchX());\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-9)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n\nPoint calc_ps(Polygon poly) {\n  poly = andrewScan(poly);\n  Point mp = poly[0];\n  double rate = 1; // 0.5???????????¨???\n  int max_pos;\n  double eps = 1e-10; // 1e-20???????????¨???\n  while( rate > eps ) {\n    rep(_,60){ // 70???????????¨???\n      max_pos = 0;\n      REP(j,1,(int)poly.size()) {\n        double dist1 = abs(mp-poly[max_pos]);\n        double dist2 = abs(mp-poly[j]);\n\tif( LT(dist1,dist2) ) max_pos = j;\n      }\n      mp.x += ( poly[max_pos].x - mp.x ) * rate;\n      mp.y += ( poly[max_pos].y - mp.y ) * rate;\n    }\n    rate *= 0.5;\n  }\n  return mp;\n}\n\nPoint getCentroidOfConvex(Polygon& poly){\n  double area = getArea(poly);\n  int V = poly.size();\n  assert( !equals(area,0.0) );\n  double x = 0, y = 0;\n  rep(i,(int)poly.size()) {\n    x += ( poly[i].x + poly[(i+1)%V].x ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n    y += ( poly[i].y + poly[(i+1)%V].y ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n  }\n  return Point(x/(6.0*area),y/(6.0*area));\n}\n\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  double maxi;\n  Point mp = calc_ps(poly);\n  maxi = getCommonAreaPolygonCircle(poly,mp,r);\n  double rate = 1.0;\n  double eps = 1e-10;\n  while( LT(eps,rate) ) {\n    rep(_,70) {\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      assert( !equals(max_area,-1) );\n      mp = np;\n      if( LT(maxi,max_area) ) maxi = max_area;\n    }\n    rate *= 0.5;\n  }\n  rep(__,5) {\n    Point mp = calc_ps(poly);\n    double rate = 1.0;\n    double eps = 1e-10;\n    while( LT(eps,rate) ) {\n      rep(_,70) {\n\tdouble max_area = -1; \n\tPoint np;\n\trep(i,n) {\n\t  Point tp = mp;\n\t  tp.x += ( poly[i].x - mp.x ) * rate;\n\t  tp.y += ( poly[i].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,tp,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t    np = tp;\n\t  }\n\t}\n\tif( rand() % 50 == 0 ) {\n\t  int v = rand() % n;\n\t  np.x = ( poly[v].x - mp.x ) * rate;\n\t  np.y = ( poly[v].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,np,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t  }\n\t}\n\tassert( !equals(max_area,-1) );\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      rate *= 0.5;\n    }\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  srand((unsigned int)time(NULL));\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  //cout << getArea(poly) << endl;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cout if (1) cout\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pii;\n#define pb push_back\n\n// area de calota na altura h : 2.pi.R.h\n// volume de calota na altura h : pi.h/6 * (3r^2 + h^2)\n\n// XXX marks risky behaviour and TODO marks untested functions\ntypedef double cood; cood eps = 1e-8; cood inf = 1./0.;\nconst double pi = acos(-1.);\ninline ll sq (ll x) { return x*x; }\ninline double sq (double x) { return x*x; }\nstruct vec { // vector\n\tcood x, y;\n\tvec () : x(0), y(0) {} vec (cood a, cood b) : x(a), y(b) {}\n\tinline vec operator - (vec o) { return vec(x - o.x, y - o.y); }\n\tinline vec operator + (vec o) { return vec(x + o.x, y + o.y); }\n\tinline vec operator * (cood o) { return vec(x * o, y * o); }\n\tinline vec operator / (cood o) { return vec(x / o, y / o); }\n\tinline cood operator ^ (vec o) { return x * o.y - y * o.x; }\n\tinline cood operator * (vec o) { return x * o.x + y * o.y; }\n\n\tinline cood cross (vec a, vec b) { return ((*this)-a) ^ ((*this)-b); } // |(this)a|sen(angle)\n\tinline cood inner (vec a, vec b) { return ((*this)-a) * ((*this)-b); } // |(this)a|cos(angle)\n\tinline double angle (vec a, vec b) { return atan2(cross(a,b),inner(a,b)); } // ccw angle from (this)a to (this)b in range [-pi,pi]\n\tinline int ccw (vec a, vec b) { cood o = cross(a,b); return (eps < o) - (o < -eps); } // this is to the (1 left, 0 over, -1 right) of ab\n\tinline int dir (vec a, vec b) { cood o = inner(a,b); return (eps < o) - (o < -eps); } // a(this) is to the (1 same, 0 none, -1 opposite) direction of ab\n\tinline cood sq (vec o = vec()) { return inner(o,o); }\n\tinline double nr (vec o = vec()) { return sqrt(sq(o)); }\n\tinline vec proj (vec a, vec b) { return a + (b-a)*(a.inner((*this),b) / a.sq(b)); }\n\tinline vec rotate (double a) { return vec(cos(a) * x - sin(a) * y, sin(a) * x + cos(a) * y); } // ccw by a radians\n\tinline vec rot90 () { return vec(-y,x); } // rotate(pi/2)\n\n\tinline bool operator < (const vec & o) const { return (x != o.x)?(x < o.x):(y > o.y); } // lex compare (inc x, dec y)\n\t// full ccw angle from compare beginning upwards (this+(0,1)) around (*this)\n\t// incresing distance on ties\n\tbool compare (vec a, vec b) { \n\t\tif ((a < (*this)) != (b < (*this))) return a < (*this);\n\t\tint o = ccw(a,b); if (o) return o > 0;\n\t\treturn a.dir((*this),b) < 0;\n\t}\n\n\tbool in_seg (vec a, vec b) { return ccw(a,b) == 0 && dir(a,b) <= 0; } // tips included\n\tdouble dist2_lin (vec a, vec b) { return double(::sq(cross(a,b)))/a.sq(b); } // see cir.has_inter_lin\n\tdouble dist2_seg (vec a, vec b) { return a.dir((*this),b) == (b.dir((*this),a)) ? dist2_lin(a,b) : min(sq(a),sq(b)); }\n};\nstruct lin { // line\n\tcood a, b, c; // a*x + b*y = c\n\tlin () {} lin (cood x, cood y, cood z) : a(x), b(y), c(z) {}\n\tlin (vec s, vec t) : a(t.y - s.y), b(s.x - t.x), c(a * s.x + b * s.y) {}\n\tinline lin parll (vec p) { return lin{a, b, a*p.x + b * p.y}; }\n\tinline lin perp () { return lin{-b, a, c}; }\n\tvec inter (lin o) {\n\t\tcood d = a * o.b - o.a * b;\n\t\tif (-eps <= d && d <= eps) throw 1; // parallel\n\t\treturn vec((o.b * c - b * o.c) / d, (a * o.c - o.a * c) / d);\n\t}\n\tbool contains (vec v) { return abs(a*v.x + b*v.y - c) <= eps; }\n\tvec at_x (cood x) { return vec(x,(c-a*x)/b); }\n\tvec at_y (cood y) { return vec((c-b*y)/a,y); }\n};\nstruct cir { // circle\n\tvec c; cood r;\n\tcir () {} cir (vec v, cood d) : c(v), r(d) {}\n\tcir (vec u, vec v, vec w) {\n\t\tvec mv = (u+v)/2; lin s(mv, mv+(v-u).rot90());\n\t\tvec mw = (u+w)/2; lin t(mw, mw+(w-u).rot90());\n\t\tc = s.inter(t); r = c.nr(u);\n\t}\n\tinline bool contains (vec w) { return c.sq(w) <= sq(r) + eps; } // border included\n\tinline bool has_inter (cir o) { return c.sq(o.c) <= sq(r + o.r) + eps; } // borders included\n\tinline bool has_border_inter (cir o) { return has_inter(o) && c.sq(o.c) + eps >= sq(r - o.r); }\n\tinline bool has_inter_lin (vec a, vec b) { return a.sq(b) <= eps ? contains(a) : sq(c.cross(a,b)) <= sq(r)*a.sq(b) + eps; } // borders included XXX overflow\n\tinline bool has_inter_seg (vec a, vec b) { return has_inter_lin(a,b) && (contains(a) || contains(b) || a.dir(c,b)*b.dir(c,a) != -1); } // borders and tips included XXX overflow\n\tinline double arc_area (vec a, vec b) { return c.angle(a,b)*r*r/2; } // smallest arc, ccw positive\n\tinline double arc_len (vec a, vec b) { return c.angle(a,b)*r; } // smallest arc, ccw positive\n\tpair<vec,vec> border_inter (cir o) {\n\t\tif (!has_border_inter(o)) throw 0;\n\t\tdouble a = (sq(r) + o.c.sq(c) - sq(o.r))/(2*o.c.nr(c));\n\t\tvec v = (o.c - c)/o.c.nr(c); vec m = c + v * a;\n\t\tdouble h = sqrt(sq(r) - sq(a)); h = h!=h?0:h;\n\t\treturn pair<vec,vec>(m + v.rot90()*h, m - v.rot90()*h);\n\t}\n\tpair<vec,vec> border_inter_lin (vec a, vec b) { // first is closest to a than second\n\t\tif (a.dir(b,c) == -1) swap(a,b);\n\t\tif (!has_inter_lin(a,b)) throw 0;\n\t\tdouble d2 = c.dist2_lin(a,b); vec p = (b-a)/a.nr(b);\n\t\tdouble h = sqrt(r*r - d2); h = h!=h?0:h; \n\t\tdouble y = sqrt(c.sq(a) - d2); y = y!=y?0:y;\n\t\treturn pair<vec,vec>(a + p*(y-h), a + p*(y+h));\n\t}\n\tdouble triang_inter (vec a, vec b) { // ccw oriented, this with (c,a,b)\n\t\tif (c.sq(a) > c.sq(b)) return -triang_inter(b,a);\n\t\tif (contains(b)) return c.cross(a,b)/2;\n\t\tif (!has_inter_seg(a,b)) return arc_area(a,b);\n\t\tpair<vec,vec> itr = border_inter_lin(b,a); // order important\n\t\tif (contains(a)) return c.cross(a,itr.first)/2 + arc_area(itr.first,b);\n\t\treturn arc_area(a,itr.second) + c.cross(itr.second,itr.first)/2 + arc_area(itr.first,b);\n\t}\n};\nbool inter_seg (vec a, vec b, vec c, vec d) {\n\tif (a.in_seg(c, d) || b.in_seg(c, d) || c.in_seg(a, b) || d.in_seg(a, b)) return true;\n\treturn (c.ccw(a, b) * d.ccw(a, b) == -1 && a.ccw(c, d) * b.ccw(c, d) == -1);\n}\ndouble dist2_seg (vec a, vec b, vec c, vec d){return inter_seg(a,b,c,d)?0.:min({ a.dist2_seg(c,d), b.dist2_seg(c,d), c.dist2_seg(a,b), d.dist2_seg(a,b) });} // TODO\nostream& operator<<(ostream& os, vec o) { return os << '(' << o.x << \", \" << o.y << ')'; }\nostream& operator<<(ostream& os, lin o) { return os << '[' << o.a << \"x + \" << o.b << \"y = \" << o.c << ']'; }\nostream& operator<<(ostream& os, cir o) { return os << '[' << o.c << o.r << ']'; }\n\ndouble polygon_inter (vector<vec> & p, cir c) { // signed area\n\treturn inner_product(p.begin(), p.end()-1, p.begin()+1, c.triang_inter(*p.rbegin(),*p.begin()), std::plus<double>(), [&c] (vec a, vec b) { return c.triang_inter(a,b); });\n}\n\nconst int N = 13;\n\nint n;\nll r;\nvector<vec> v(N);\n\ndouble solve (double y) {\n\tdouble lo = 100, hi = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (abs(v[i].y - v[i+1].y) <= eps) {\n\t\t\tif (abs(v[i].y - y) <= eps) {\n\t\t\t\tlo = min(lo, v[i].x);\n\t\t\t\tlo = min(lo, v[i+1].x);\n\t\t\t\thi = max(hi, v[i].x);\n\t\t\t\thi = max(hi, v[i+1].x);\n\t\t\t}\n\t\t} else if (min(v[i].y,v[i+1].y) - eps <= y && y <= max(v[i].y,v[i+1].y) + eps) {\n\t\t\tdouble x = lin(v[i],v[i+1]).at_y(y).x;\n\t\t\tlo = min(lo, x);\n\t\t\thi = max(hi, x);\n\t\t}\n\t}\n\tif (lo > hi) return 0;\n\n\tint ts = 70;\n\twhile (ts--) {\n\t\tdouble q1 = (lo + lo + hi)/3;\n\t\tdouble q2 = (lo + hi + hi)/3;\n\t\tif (abs(polygon_inter(v, cir(vec(q1,y),r))) > abs(polygon_inter(v, cir(vec(q2,y),r))))\n\t\t\thi = q2;\n\t\telse\n\t\t\tlo = q1;\n\t}\n\t\n\t//cout << lo << \" \" << y << \" : \" << abs(polygon_inter(v, cir(vec(lo,y),r))) << endl;\n\treturn abs(polygon_inter(v, cir(vec(lo,y),r)));\n}\n\nint main () {\n\twhile (scanf(\"%d %lld\", &n, &r) != EOF) {\n\t\tdouble lo = 100, hi = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%lf %lf\", &v[i].x, &v[i].y);\n\t\t\tlo = min(lo, v[i].y);\n\t\t\thi = max(hi, v[i].y);\n\t\t}\n\t\tv[n] = v[0];\n\n\t\tint ts = 80;\n\t\twhile (ts--) {\n\t\t\tdouble q1 = (lo + lo + hi)/3;\n\t\t\tdouble q2 = (lo + hi + hi)/3;\n\n\t\t\tif (solve(q1) < solve(q2))\n\t\t\t\tlo = q1;\n\t\t\telse\n\t\t\t\thi = q2;\n\t\t}\n\t\t\n\t\tprintf(\"%.6f\\n\", solve(lo));\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1000\n#define linf 1e18\n#define eps (1e-10)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n  double getArea(){ return r*r*pi;}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\ndouble arg(Vector p){ return atan2(p.y,p.x);}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\ndouble getArea(Polygon p){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++)res+=cross(p[i]-p[0],p[i+1]-p[0])/2.0;\n  return res;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0.0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nbool iscrossLC(Line l,Circle c){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  if(!iscrossLC(s,c))return res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(ccw(s.p1,s.p2,pp.f)==0)res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0)res.push_back(pp.s);\n  return res;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nvector<Point> arg_sort(vector<Point> vp,Point base){\n  vector<pair<double,Point> > tmp;\n  vector<Point> res;\n  for(int i=0;i<vp.size();i++){\n    double targ=arg(vp[i]-base);\n    if(targ<0)targ+=2*pi;\n    tmp.push_back(mp(targ,vp[i]));\n  }\n  sort(tmp.begin(),tmp.end());\n  for(int i=0;i<tmp.size();i++)res.push_back(tmp[i].s);\n  return res;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  if(cross(a,b)<-eps)r=360.0-r;\n  return r;\n}\n\nbool AllIn(Polygon p,Circle c){\n  if(contains(p,c.c)!=2)return false;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\nbool AllOut(Polygon p,Circle c){\n  if(contains(p,c.c)!=0)return false;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\nvector<Point> unique(vector<Point> vp){\n  vector<Point> res;\n  if(vp.empty())return res;\n  sort(vp.begin(),vp.end());\n  res.push_back(vp[0]);\n  for(int i=1;i<vp.size();i++)\n    if(!(res.back()==vp[i]))res.push_back(vp[i]);\n  return res;\n}\n\ndouble getCommonAreaTC(Polygon p,Circle c){\n  double res=getArea(p);\n  int n=p.size();\n  bool flag=false;\n  vector<Point> s;\n  if(res<0.0){\n    flag=true;\n    reverse(p.begin(),p.end());\n    res=-res;\n  }\n  if(AllIn(p,c))return c.getArea();\n  if(AllOut(p,c))return 0.0;\n  for(int i=0;i<n;i++){\n    vector<Point> vp=getCrossPointSC(c,Segment(p[i],p[(i+1)%n]));\n    for(int j=0;j<vp.size();j++)s.push_back(vp[j]);\n  }\n\n  s=unique(s);\n  s=arg_sort(s,c.c); \n\n  for(int i=0;i<s.size();i++){\n    Point p1=s[i];\n    Point p2=s[(i+1)%s.size()];\n    double ra=getAngle(p1-c.c,p2-c.c);\n    if(contains(p,rotate(c.c,p1,ra/2.0))==0)continue;\n    Polygon t;\n    t.push_back(p1);\n    t.push_back(p2);\n    t.push_back(c.c);\n    res-=getArea(convex_cut(p,Line(p2,p1)));\n    res+=((c.getArea()*ra/360.0)-getArea(t));\n  }\n  if(!flag)return res;\n  return -res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++){\n    Polygon t;\n    t.push_back(p[0]);\n    t.push_back(p[i]);\n    t.push_back(p[i+1]);\n    res+=getCommonAreaTC(t,c);\n  }\n  return res;\n}\n\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,60){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*L,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=abs(b-a);\n    FOR(k,0,60){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 400\n#define linf 1e18\n#define eps (1e-9)\n#define mod 1000000007\n#define pi M_PI\n#define phi (1.0+sqrt(5))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Circle c,Point p){\n  if(abs(c.c-p)-c.r<-eps)return true;\n  return false;\n}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nbool intersect(Circle c,Segment s){\n  if(getDistanceSP(s,c.c)-c.r<-eps)return true;\n  return false;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  return acos(tmp)*180.0/pi;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nPoint getCrossPointSC(Circle c,Segment s){\n  Point res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(ccw(s.p1,s.p2,pp.f)==0){\n    res=pp.f;\n    if(ccw(s.p1,s.p2,pp.s)==0 && abs(s.p1-pp.s)<abs(s.p1-pp.f))res=pp.s;\n  }\n  else res=pp.s;\n  return res;\n}\n\ndouble getCommonAreaTC(Point a,Point b,Circle c){\n  double res=abs(cross(a-c.c,b-c.c)/2.0);\n  if(equals(0.0,res))return 0.0;\n  if(in(c,a) && !in(c,b)){\n    Point p1=getCrossPointSC(c,Segment(b,a));\n    Point p2=getCrossPointSC(c,Segment(b,c.c)); \n    res+=(c.r*c.r*pi)*(getAngle(p1-c.c,p2-c.c)/360.0);\n    res-=abs(cross(p1-c.c,p2-c.c)/2.0);\n    res-=abs(cross(p2-b,p1-b)/2.0);\n  }\n  else if(!in(c,a) && in(c,b)){\n    Point p1=getCrossPointSC(c,Segment(a,c.c));\n    Point p2=getCrossPointSC(c,Segment(a,b));\n    res+=(c.r*c.r*pi)*(getAngle(p1-c.c,p2-c.c)/360.0);\n    res-=abs(cross(p1-c.c,p2-c.c)/2.0);\n    res-=abs(cross(p2-a,p1-a)/2.0);\n  }\n  else if(!in(c,a) && !in(c,b)){\n    if(intersect(c,Segment(a,b))){\n      pair<Point,Point> pp=getCrossPoints(c,Segment(a,b));\n      Point m=pp.f+(pp.s-pp.f)/2.0;\n      res=abs(getCommonAreaTC(a,m,c))+abs(getCommonAreaTC(m,b,c));\n    }\n    else res=(c.r*c.r*pi)*(getAngle(a-c.c,b-c.c)/360.0);\n  }\n  if(cross(a-c.c,b-c.c)<0.0)res=-res;\n  return res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  int n=p.size();\n  FOR(i,0,n)res+=getCommonAreaTC(p[i],p[(i+1)%n],c);\n  return abs(res);\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,30){\n    double m1=(L*phi+R)/(1.0+phi);\n    double m2=(L+R*phi)/(1.0+phi);\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res2-res1<-eps)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*R,r));\n}\n\ndouble solve(){\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double res=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=inf*2;\n    FOR(k,0,30){\n      double m1=(L*phi+R)/(1.0+phi);\n      double m2=(L+R*phi)/(1.0+phi);\n      double res1=check(a+v*(m1-inf));\n      double res2=check(a+v*(m2-inf));\n      if(res2-res1<-eps)R=m2; \n      else L=m1;\n    }\n    res=max(res,check(a+v*(R-inf)));\n  }\n  return res;\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  pd(solve());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  Point mp = poly[0];\n  double maxi = 0;\n  double rate = 1.0;\n  double eps = 1e-20;\n  while( LT(eps,rate) ) {\n    rep(_,80) {\n\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      if( !equals(max_area,-1) ) {\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      \n    }\n    rate *= 0.3;\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\n#define CVector CPoint\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1);\nconst double EPS=1e-6;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-10;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n    /*friend bool operator<(CPoint a,CPoint b){//?角排序\n        double tmp=cross(Pts[0],a,b);\n        if(isZero(tmp)){\n            return dist(Pts[0],a)<dist(Pts[0],b);\n        }\n        return tmp>0;\n    }*/\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n/*----------------------多?形相?--------------------------*/\n\n//0:outside 1:inside 2:online\nint PointInPoly(Point t,Point *Pts,int n){\n    int num=0,d1,d2,k;\n    Pts[n]=Pts[0];\n    for(int i=0;i<n;i++){\n        if(PointOnS(t,Line(Pts[i],Pts[i+1]))) return 2;\n        k=dcmp(cross(Pts[i],Pts[i+1],t));\n        d1=dcmp(Pts[i].y-t.y);\n        d2=dcmp(Pts[i+1].y-t.y);\n        if(k>0&&d1<=0&&d2>0) num++;\n        if(k<0&&d2<=0&&d1>0) num--;\n    }\n    return num!=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n//求任意多?形周?，需逆??或???排列\ndouble PolyPerimeter(Point *Pts,int n){\n    double pp=distPP(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pp+=distPP(Pts[i],Pts[i+1]);\n    return pp;\n}\n\n//求多?形重心坐?\nPoint PolyCore(Point *Pts,int n){\n    double pa=PolyArea(Pts,n);\n    if(!dcmp(pa)) return Point(0,0);\n    Point ans=(Pts[n-1]+Pts[0])*cross(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) ans=ans+(Pts[i]+Pts[i+1])*cross(Pts[i],Pts[i+1]);\n    return ans/pa/6;\n}\n\n/*----------------------凸包----------------------------*/\n\n//Graham-scan st:anticlockwise\n//<=:strict <:Non-strict\nint Graham(Point *Pts,Point *st,int n){\n    if(n<3) return 0;\n    sort(Pts,Pts+n);\n    int m=0;\n    for(int i=0;i<n;i++){\n        while(m>1&&dcmp(cross(st[m-2],st[m-1],Pts[i]))<0) m--;\n        st[m++]=Pts[i];\n    }\n    int k=m;\n    for(int i=n-2;i>=0;i--){\n        while(m>k&&dcmp(cross(st[m-2],st[m-1],Pts[i])<0)) m--;\n        st[m++]=Pts[i];\n    }\n    return m-1;\n}\n\n//clockwise:> anticlockwise:<\ndouble CHDiameter(Point *Pts,int n,Line &l){\n    double maxd=0.0;\n    if(n<=1){\n        l.a=l.b=Pts[0];\n        return maxd;\n    }\n    for(int i=0,j=1;i<n;i++){\n        while(cross(Pts[i],Pts[(i+1)%n],Pts[j])\n              >cross(Pts[i],Pts[(i+1)%n],Pts[(j+1)%n])){\n            j=(j+1)%n;\n        }\n        double d=distPP(Pts[i],Pts[j]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n        d=distPP(Pts[(i+1)%n],Pts[(j+1)%n]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n    }\n    return maxd;\n}\n\n/*---------------------整点多?形---------------------------*/\n\nint gcd(int a,int b){\n    return b==0?a :gcd(b,a%b);\n}\n\n//整点多?形?界整点数\nint Border_Int_Point_Num(Point *Pts,int n){\n    int num=gcd(abs(int(Pts[0].x-Pts[n-1].x)),abs(int(Pts[0].y-Pts[n-1].y)));;\n    for(int i=0;i<n-1;i++){\n        num+=gcd(abs(int(Pts[i+1].x-Pts[i].x)),abs(int(Pts[i+1].y-Pts[i].y)));\n    }\n    return num;\n}\n\n//整点多?形内部整点数\nint Inside_Int_Point_Num(Point *Pts,int n){\n    return abs(int(PolyArea(Pts,n)))+1-Border_Int_Point_Num(Pts,n)/2;\n}\n\n/*-----------------------------半平面交-------------------------------*/\n\n//有方向的直?\n//p->p+v\nstruct Vector{\n    Point p,v;\n    double ang;\n    Vector(Point p,Point v):p(p),v(v){\n        ang=atan2(v.y,v.x);\n    }\n    Vector(){}\n    bool operator<(const Vector &l) const{\n        return ang<l.ang;\n    }\n};\n\n//判断点p是否在直?L左?\nbool onLeft(Vector L,Point p){\n    return cross(L.v,p-L.p)>0;\n}\n\n//得到a与b?直?的交点\nPoint getCrossVV(Vector a,Vector b){\n    Point u=a.p-b.p;\n    double t=cross(b.v,u)/cross(a.v,b.v);\n    return a.p+a.v*t;\n}\n\n//所有直?左半平面的交\nint HPCross(Vector *L,int n,Point *poly){\n    sort(L,L+n);\n    int f=0,l=0;\n    Point *p=new Point[n];\n    Vector *q=new Vector[n];\n    q[0]=L[0];\n    for(int i=1;i<n;i++){\n        while(f<l&&!onLeft(L[i],p[l-1])) l--;\n        while(f<l&&!onLeft(L[i],p[f])) f++;\n        q[++l]=L[i];\n        if(!dcmp(cross(q[l].v,q[l-1].v))){\n            l--;\n            if(onLeft(q[l],L[i].p)) q[l]=L[i];\n        }\n        if(f<l) p[l-1]=getCrossVV(q[l-1],q[l]);\n    }\n    while(f<l&&!onLeft(q[f],p[l-1])) l--;\n    if(l-f<=1) return 0;\n    p[l]=getCrossVV(q[l],q[f]);\n    int m=0;\n    for(int i=f;i<=l;i++) poly[m++]=p[i];\n    return m;\n}\n\n#define maxn 100005\nVector l[maxn];\nbool retract(Vector *L,int n,double r,Point *poly){\n    for(int i=0;i<n;i++){\n        Point v=rotateV(L[i].p,L[i].p+L[i].v,PI/2);\n        l[i]=Vector(L[i].p+r*v,L[i].v);\n    }\n    int cnt=HPCross(l,n,poly);\n    return cnt;\n}\n\n/*---------------------三角形相?---------------------------*/\n\n//三角形重心\n//到三?点距?的平方和最小的点\n//到三?距?之?最大的点\nPoint TCore(Point a,Point b,Point c){\n    return (a+b+c)/3;\n}\n\n//三角形外心\nPoint TCircum(Point a,Point b,Point c){\n    Point cp;\n    double a1=b.x-a.x;\n    double b1=b.y-a.y;\n    double a2=c.x-a.x;\n    double b2=c.y-a.y;\n    double c1=(a1*a1+b1*b1)/2;\n    double c2=(a2*a2+b2*b2)/2;\n    double d=a1*b2-a2*b1;\n    cp.x=a.x+(c1*b2-c2*b1)/d;\n    cp.y=a.y+(a1*c2-a2*c1)/d;\n    return cp;\n}\n\n//三角形垂心\nPoint TOrtho(Point a,Point b,Point c){\n    return TCore(a,b,c)*3.0-TCircum(a,b,c)*2.0;\n}\n\n//三角形内心\nPoint TInner(Point a,Point b,Point c){\n    Point cp;\n    double la=distPP(b,c),lb=distPP(c,a),lc=distPP(a,b);\n    cp.x=(la*a.x+lb*b.x+lc*c.x)/(la+lb+lc);\n    cp.y=(la*a.y+lb*b.y+lc*c.y)/(la+lb+lc);\n    return cp;\n}\n\n//求三角形面?\ndouble TArea(Point a,Point b,Point c){\n    return fabs(cross(a,b,c))/2;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n//求??面?交\ndouble getAreaCC(Circle a,Circle b){\n    double d=(a.o.x-b.o.x)*(a.o.x-b.o.x)+(a.o.y-b.o.y)*(a.o.y-b.o.y);\n    if(d<=(a.r-b.r)*(a.r-b.r)){\n        return min(a.r,b.r)*min(a.r,b.r)*PI;\n    }else if(d>(a.r-b.r)*(a.r-b.r)&&d<(a.r+b.r)*(a.r+b.r)){\n        double m1=(a.r*a.r+d-b.r*b.r)/(2*a.r*sqrt(d));\n        double m2=(b.r*b.r+d-a.r*a.r)/(2*b.r*sqrt(d));\n        double s1=acos(m1)*a.r*a.r;\n        double s2=acos(m2)*b.r*b.r;\n        double s3=sqrt(d)*a.r*sin(acos(m1));\n        return s1+s2-s3;\n    }\n    return 0.0;\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n/********************************************************/\nint getCrossCS(Circle c,Line s,Point *cs){\n    Point tmp[2];\n    int cnt=0;\n    int ct=getCrossCL(c,s,tmp);\n    for(int i=0;i<ct;i++){\n        if(PointOnS(tmp[i],s)) cs[cnt++]=tmp[i];\n    }\n    return cnt;\n}\n\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=fabs(cross(a-c.o,b-c.o)/2);\n    if(!dcmp(atc)) return 0.0;\n    double la=length(a-c.o),lb=length(b-c.o);\n    Point cs[4];\n    if(la<c.r+EPS&&lb>c.r-EPS){\n        getCrossCS(c,Line(a,b),cs);\n        Point p=cs[0];\n        atc+=0.5*c.r*c.r*angleVV(p-c.o,b-c.o);\n        atc-=fabs(cross(p-c.o,b-c.o)/2);\n    }else if(la>c.r-EPS&&lb<c.r+EPS){\n        getCrossCS(c,Line(a,b),cs);\n        Point p=cs[0];\n        atc+=0.5*c.r*c.r*angleVV(p-c.o,a-c.o);\n        atc-=fabs(cross(p-c.o,a-c.o)/2);\n    }else if(la>c.r-EPS&&lb>c.r-EPS){\n        if(distPS(c.o,Line(a,b))<c.r+EPS){\n            Point rt=root(c.o,Line(a,b));\n            atc=fabs(getAreaTC(a,rt,c))+fabs(getAreaTC(rt,b,c));\n        }else atc=0.5*c.r*c.r*angleVV(a-c.o,b-c.o);\n    }\n    if(dcmp(cross(a-c.o,b-c.o))==1) atc=-atc;\n    return atc;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=getAreaTC(Pts[n-1],Pts[0],c);\n    for(int i=0;i<n-1;i++) apc+=getAreaTC(Pts[i],Pts[i+1],c);\n    return fabs(apc);\n}\n\n/********************************************************/\n\n\n/*----------------------三?点、?基本函数-----------------------------*/\n\nstruct Point3{\n    double x,y,z;\n    Point3(double x,double y,double z):x(x),y(y),z(z){}\n    Point3(){}\n    void Read(){ scanf(\"%lf%lf%lf\",&x,&y,&z); }\n};\n\nstruct Line3{\n    Point3 a,b;\n    Line3(Point3 a,Point3 b):a(a),b(b){}\n    Line3(){}\n    void Read(){ a.Read(); b.Read(); }\n};\nPoint3 operator +(Point3 a,Point3 b){ return Point3(a.x+b.x,a.y+b.y,a.z+b.z); }\nPoint3 operator -(Point3 a,Point3 b){ return Point3(a.x-b.x,a.y-b.y,a.z-b.z); }\ndouble operator *(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 operator *(Point3 a,double k){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator *(double k,Point3 a){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator /(Point3 a,double k){ return Point3(a.x/k,a.y/k,a.z/k); }\n\ndouble length(Point3 a){ return sqrt(a.x*a.x+a.y*a.y+a.z*a.z); }\nPoint3 unit(Point3 a){ return a/length(a); }\ndouble dot(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 cross(Point3 a,Point3 b){\n    return Point3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//混合?\ndouble Mix(Point3 a,Point3 b,Point3 c){\n    return dot(a,cross(b,c));\n}\n\n//?点距?\ndouble dist(const Point3 &a,const Point3 &b){ return length(a-b); }\n\n/*---------------------------------体?-------------------------------------*/\n\n//四面体体?\ndouble volume(double l,double n,double a,double m,double b,double c){\n    double x,y;\n    x=4*a*a*b*b*c*c-a*a*(b*b+c*c-m*m)*(b*b+c*c-m*m)-b*b*(c*c+a*a-n*n)*(c*c+a*a-n*n);\n    y=c*c*(a*a+b*b-l*l)*(a*a+b*b-l*l)-(a*a+b*b-l*l)*(b*b+c*c-m*m)*(c*c+a*a-n*n);\n    return sqrt(x-y)/12;\n}\n\ndouble volume(Point3 a,Point3 b,Point3 c,Point3 d){\n    return fabs(Mix(b-a,c-a,d-a)/6);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=maxy,r=miny;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);//cin.tie(0);\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\ntypedef complex<double> P;\n\nint n, r;\nP p[11];\n\ndouble dot(P a, P b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(P a, P b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dist(P s, P e, P p) {\n\tif (dot(p - s, e - s) < 0) return abs(p - s);\n\tif (dot(p - e, s - e) < 0) return abs(p - e);\n\treturn abs(cross(e - s, p - s) / abs(e - s));\n}\n\n//??´???a->b??¨???c(?????????r)?????????\nvector<P> kotenS(P a, P b, P c) {\n\ta -= c;\n\tb -= c;\n\tdouble d = dist(a, b, P(0, 0));\n\tif (d > r) return vector<P>();\n\t\n\tP t = (b - a) / abs(b - a);\n\tP u = t * P(0, 1);\n\tif (cross(a, b) > 0) u = -u;\n\t\n\tP p1 = d * u + sqrt(r * r - d * d) * t;\n\tP p2 = d * u - sqrt(r * r - d * d) * t;\n\tp1 += c;\n\tp2 += c;\n\t\n\tvector<P> ret;\n\tret.push_back(p1);\n\tret.push_back(p2);\n\treturn ret;\n}\n\n//??????a->b??¨???c(?????????r)?????????\nvector<P> koten(P a, P b, P c) {\n\tvector<P> res = kotenS(a, b, c);\n\tvector<P> ret;\n\tfor (int i = 0; i < res.size(); i++) {\n\t\tif (dot(res[i] - a, b - res[i]) >= 0) {\n\t\t\tret.push_back(res[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\n//???c???????????¨??????????§??????????\nvoid angle_sort(vector<P> &ps, P c) {\n\tfor (int i = 0; i < ps.size() - 1; i++) {\n\t\tfor (int j = ps.size() - 1; j > i; j--) {\n\t\t\tP t = ps[j - 1] - c;\n\t\t\tP u = ps[j] - c;\n\t\t\tif (atan2(t.imag(), t.real()) > atan2(u.imag(), u.real())) {\n\t\t\t\tswap(ps[j - 1], ps[j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//???a???????§???¢????????¨??????????????????. ?¢????????????????.\nbool isCover(P a) {\n\tbool flag = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tP t = p[i] - a;\n\t\tP u = p[i + 1] - a;\n\t\tif (t.imag() > u.imag()) swap(t, u);\n\t\tif (t.imag() < 0 && 0 < u.imag() && cross(t, u) > 0) flag = !flag;\n\t}\n\treturn flag;\n}\n\ndouble getArea(P a, P b, P c) {\n\tdouble eps = 1e-10;\n\t\n\tP mid = (a + b) * 0.5;\n\tP t = (mid - c) / abs(mid - c); t *= 1e-9; t += mid;\n\t\n\tif (norm(c - a) >= r * r - eps && norm(c - b) >= r * r - eps && isCover(t)) {\n\t\t//??????\n\t\ta -= c;\n\t\tb -= c;\n\t\tdouble theta = acos(dot(a, b) / abs(a) / abs(b));\n\t\treturn theta * r * r * 0.5;\n\t}\n\t//3?§???¢\n\treturn cross(a - c, b - c) * 0.5;\n}\n\n//???????????????c?????¨??????, ??±?????¨????????¢???????±???????.\n//c??????????§???¢????????¨???????????¨??????.\ndouble area(P c) {\n\tvector<P> ps;\n\tconst double PAI = 3.14159265358979;\n\t\n\t//?????¨?????????\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<P> res = koten(p[i], p[i + 1], c);\n\t\tfor (int j = 0; j < res.size(); j++) {\n\t\t\tps.push_back(res[j]);\n\t\t}\n\t}\n\tif (ps.size() == 0) { return PAI * r * r; }\n\t\n\t//????????????????????????\n\tdouble eps = 1e-10;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (norm(c - p[i]) <= r * r - eps) {\n\t\t\tps.push_back(p[i]);\n\t\t}\n\t}\n\t\n\t//??????\n\tP base = P(0, 0);\n\tfor (int i = 0; i < n; i++) base += p[i];\n\tbase /= n;\n\tangle_sort(ps, base);\n\tps.push_back(ps[0]);\n\t\n\tdouble ret = 0;\n\tfor (int i = 0; i < ps.size() - 1; i++) {\n\t\tret += getArea(ps[i], ps[i + 1], c);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint i;\n\t\n\tcin >> n >> r;\n\tfor (i = 0; i < n; i++) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = P(x, y);\n\t}\n\tp[n] = p[0];\n\n\tP c = P(0, 0);\n\tfor (i = 0; i < n; i++) { c += p[i]; }\n\tc /= n;\n\t\n\tconst int LoopNum = 10000;\n\tdouble dy;\n\tdouble dx;\n\tdouble maxArea = 0;\n\tfor (i = 0; i < LoopNum; i++) {\n\t\tdy = max(exp(-20 + rand() % 20), exp(-i / 50.0));\n\t\tdx = max(exp(-20 + rand() % 20), exp(-i / 50.0));\n\t\tif (isCover(c + P(dx, 0)) && maxArea < area(c + P(dx, 0))) { maxArea = area(c + P(dx, 0)); c = c + P(dx, 0); }\n\t\tif (isCover(c - P(dx, 0)) && maxArea < area(c - P(dx, 0))) { maxArea = area(c - P(dx, 0)); c = c - P(dx, 0); }\n\t\tif (isCover(c + P(0, dy)) && maxArea < area(c + P(0, dy))) { maxArea = area(c + P(0, dy)); c = c + P(0, dy); }\n\t\tif (isCover(c - P(0, dy)) && maxArea < area(c - P(0, dy))) { maxArea = area(c - P(0, dy)); c = c - P(0, dy); }\n\t}\n\t\n\tprintf(\"%.14f\\n\", maxArea);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\n#define CVector CPoint\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1.0);\nconst double EPS=1e-10;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-9;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n    /*friend bool operator<(CPoint a,CPoint b){//?角排序\n        double tmp=cross(Pts[0],a,b);\n        if(isZero(tmp)){\n            return dist(Pts[0],a)<dist(Pts[0],b);\n        }\n        return tmp>0;\n    }*/\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n/*----------------------多?形相?--------------------------*/\n\n//0:outside 1:inside 2:online\nint PointInPoly(Point t,Point *Pts,int n){\n    int num=0,d1,d2,k;\n    Pts[n]=Pts[0];\n    for(int i=0;i<n;i++){\n        if(PointOnS(t,Line(Pts[i],Pts[i+1]))) return 2;\n        k=dcmp(cross(Pts[i],Pts[i+1],t));\n        d1=dcmp(Pts[i].y-t.y);\n        d2=dcmp(Pts[i+1].y-t.y);\n        if(k>0&&d1<=0&&d2>0) num++;\n        if(k<0&&d2<=0&&d1>0) num--;\n    }\n    return num!=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n//求任意多?形周?，需逆??或???排列\ndouble PolyPerimeter(Point *Pts,int n){\n    double pp=distPP(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pp+=distPP(Pts[i],Pts[i+1]);\n    return pp;\n}\n\n//求多?形重心坐?\nPoint PolyCore(Point *Pts,int n){\n    double pa=PolyArea(Pts,n);\n    if(!dcmp(pa)) return Point(0,0);\n    Point ans=(Pts[n-1]+Pts[0])*cross(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) ans=ans+(Pts[i]+Pts[i+1])*cross(Pts[i],Pts[i+1]);\n    return ans/pa/6;\n}\n\n/*----------------------凸包----------------------------*/\n\n//Graham-scan st:anticlockwise\n//<=:strict <:Non-strict\nint Graham(Point *Pts,Point *st,int n){\n    if(n<3) return 0;\n    sort(Pts,Pts+n);\n    int m=0;\n    for(int i=0;i<n;i++){\n        while(m>1&&dcmp(cross(st[m-2],st[m-1],Pts[i]))<0) m--;\n        st[m++]=Pts[i];\n    }\n    int k=m;\n    for(int i=n-2;i>=0;i--){\n        while(m>k&&dcmp(cross(st[m-2],st[m-1],Pts[i])<0)) m--;\n        st[m++]=Pts[i];\n    }\n    return m-1;\n}\n\n//clockwise:> anticlockwise:<\ndouble CHDiameter(Point *Pts,int n,Line &l){\n    double maxd=0.0;\n    if(n<=1){\n        l.a=l.b=Pts[0];\n        return maxd;\n    }\n    for(int i=0,j=1;i<n;i++){\n        while(cross(Pts[i],Pts[(i+1)%n],Pts[j])\n              >cross(Pts[i],Pts[(i+1)%n],Pts[(j+1)%n])){\n            j=(j+1)%n;\n        }\n        double d=distPP(Pts[i],Pts[j]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n        d=distPP(Pts[(i+1)%n],Pts[(j+1)%n]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n    }\n    return maxd;\n}\n\n/*---------------------整点多?形---------------------------*/\n\nint gcd(int a,int b){\n    return b==0?a :gcd(b,a%b);\n}\n\n//整点多?形?界整点数\nint Border_Int_Point_Num(Point *Pts,int n){\n    int num=gcd(abs(int(Pts[0].x-Pts[n-1].x)),abs(int(Pts[0].y-Pts[n-1].y)));;\n    for(int i=0;i<n-1;i++){\n        num+=gcd(abs(int(Pts[i+1].x-Pts[i].x)),abs(int(Pts[i+1].y-Pts[i].y)));\n    }\n    return num;\n}\n\n//整点多?形内部整点数\nint Inside_Int_Point_Num(Point *Pts,int n){\n    return abs(int(PolyArea(Pts,n)))+1-Border_Int_Point_Num(Pts,n)/2;\n}\n\n/*-----------------------------半平面交-------------------------------*/\n\n//有方向的直?\n//p->p+v\nstruct Vector{\n    Point p,v;\n    double ang;\n    Vector(Point p,Point v):p(p),v(v){\n        ang=atan2(v.y,v.x);\n    }\n    Vector(){}\n    bool operator<(const Vector &l) const{\n        return ang<l.ang;\n    }\n};\n\n//判断点p是否在直?L左?\nbool onLeft(Vector L,Point p){\n    return cross(L.v,p-L.p)>0;\n}\n\n//得到a与b?直?的交点\nPoint getCrossVV(Vector a,Vector b){\n    Point u=a.p-b.p;\n    double t=cross(b.v,u)/cross(a.v,b.v);\n    return a.p+a.v*t;\n}\n\n//所有直?左半平面的交\nint HPCross(Vector *L,int n,Point *poly){\n    sort(L,L+n);\n    int f=0,l=0;\n    Point *p=new Point[n];\n    Vector *q=new Vector[n];\n    q[0]=L[0];\n    for(int i=1;i<n;i++){\n        while(f<l&&!onLeft(L[i],p[l-1])) l--;\n        while(f<l&&!onLeft(L[i],p[f])) f++;\n        q[++l]=L[i];\n        if(!dcmp(cross(q[l].v,q[l-1].v))){\n            l--;\n            if(onLeft(q[l],L[i].p)) q[l]=L[i];\n        }\n        if(f<l) p[l-1]=getCrossVV(q[l-1],q[l]);\n    }\n    while(f<l&&!onLeft(q[f],p[l-1])) l--;\n    if(l-f<=1) return 0;\n    p[l]=getCrossVV(q[l],q[f]);\n    int m=0;\n    for(int i=f;i<=l;i++) poly[m++]=p[i];\n    return m;\n}\n\n#define maxn 100005\nVector l[maxn];\nbool retract(Vector *L,int n,double r,Point *poly){\n    for(int i=0;i<n;i++){\n        Point v=rotateV(L[i].p,L[i].p+L[i].v,PI/2);\n        l[i]=Vector(L[i].p+r*v,L[i].v);\n    }\n    int cnt=HPCross(l,n,poly);\n    return cnt;\n}\n\n/*---------------------三角形相?---------------------------*/\n\n//三角形重心\n//到三?点距?的平方和最小的点\n//到三?距?之?最大的点\nPoint TCore(Point a,Point b,Point c){\n    return (a+b+c)/3;\n}\n\n//三角形外心\nPoint TCircum(Point a,Point b,Point c){\n    Point cp;\n    double a1=b.x-a.x;\n    double b1=b.y-a.y;\n    double a2=c.x-a.x;\n    double b2=c.y-a.y;\n    double c1=(a1*a1+b1*b1)/2;\n    double c2=(a2*a2+b2*b2)/2;\n    double d=a1*b2-a2*b1;\n    cp.x=a.x+(c1*b2-c2*b1)/d;\n    cp.y=a.y+(a1*c2-a2*c1)/d;\n    return cp;\n}\n\n//三角形垂心\nPoint TOrtho(Point a,Point b,Point c){\n    return TCore(a,b,c)*3.0-TCircum(a,b,c)*2.0;\n}\n\n//三角形内心\nPoint TInner(Point a,Point b,Point c){\n    Point cp;\n    double la=distPP(b,c),lb=distPP(c,a),lc=distPP(a,b);\n    cp.x=(la*a.x+lb*b.x+lc*c.x)/(la+lb+lc);\n    cp.y=(la*a.y+lb*b.y+lc*c.y)/(la+lb+lc);\n    return cp;\n}\n\n//求三角形面?\ndouble TArea(Point a,Point b,Point c){\n    return fabs(cross(a,b,c))/2;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n//求??面?交\ndouble getAreaCC(Circle a,Circle b){\n    double d=(a.o.x-b.o.x)*(a.o.x-b.o.x)+(a.o.y-b.o.y)*(a.o.y-b.o.y);\n    if(d<=(a.r-b.r)*(a.r-b.r)){\n        return min(a.r,b.r)*min(a.r,b.r)*PI;\n    }else if(d>(a.r-b.r)*(a.r-b.r)&&d<(a.r+b.r)*(a.r+b.r)){\n        double m1=(a.r*a.r+d-b.r*b.r)/(2*a.r*sqrt(d));\n        double m2=(b.r*b.r+d-a.r*a.r)/(2*b.r*sqrt(d));\n        double s1=acos(m1)*a.r*a.r;\n        double s2=acos(m2)*b.r*b.r;\n        double s3=sqrt(d)*a.r*sin(acos(m1));\n        return s1+s2-s3;\n    }\n    return 0.0;\n}\n\n//求??交点，先判断是否有交点\nPoint rotatePCS(Point p,double c,double s){\n    return Point(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\npair<Point,Point> getcrossCC(Circle a,Circle b){\n    double d=length(a.o-b.o);\n    double cost=(a.r*a.r+d*d-b.r*b.r)/(2*a.r*d);\n    double sint=sqrt(1.0-cost*cost);\n    Point v=(b.o-a.o)/d*a.r;\n    return make_pair(a.o+rotatePCS(v,cost,-sint),a.o+rotatePCS(v,cost,sint));\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n/********************************************************/\nint getCrossCS(Circle c,Line s,Point *cs){\n    Point tmp[2];\n    int cnt=0;\n    int ct=getCrossCL(c,s,tmp);\n    for(int i=0;i<ct;i++){\n        if(PointOnS(tmp[i],s)) cs[cnt++]=tmp[i];\n    }\n    return cnt;\n}\n\ndouble SectorArea(Point a,Point b,Circle c){\n    a=a-c.o,b=b-c.o;\n    double theta=atan2(a.y,a.x)-atan2(b.y,b.x);\n    while(dcmp(theta)<=0) theta+=2.0*PI;\n    while(dcmp(theta-2.0*PI)>0) theta-=2.0*PI;\n    theta=min(theta,2.0*PI-theta);\n    return c.r*c.r*theta*0.5;\n}\n\ndouble Abs(double x){\n    if(!dcmp(x)) return 0;\n    return dcmp(x)<0?-x:x;\n}\n\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=0.0;\n    Point OA=a-c.o,OB=b-c.o;\n    double la=length(OA),lb=length(OB);\n    Point cs[4];\n    bool aic=dcmp(la-c.r)<0,bic=dcmp(lb-c.r)<0;\n    int s=dcmp(cross(OA,OB));\n    if(!s) return 0.0;\n    if(aic){\n        if(bic){\n            atc=Abs(cross(OA,OB))*0.5;\n        }else{\n            int num=getCrossCS(c,Line(a,b),cs);\n            atc=SectorArea(cs[0],b,c)+Abs(cross(OA,cs[0]-c.o))*0.5;\n        }\n    }else{\n        if(bic){\n            int num=getCrossCS(c,Line(a,b),cs);\n            atc=SectorArea(cs[0],a,c)+Abs(cross(OB,cs[0]-c.o))*0.5;\n        }else{\n            int num=getCrossCS(c,Line(a,b),cs);\n            if(num==2){\n                if(distPP(a,cs[0])>distPP(a,cs[1])) swap(cs[0],cs[1]);\n                atc=SectorArea(a,cs[0],c)+SectorArea(b,cs[1],c)+Abs(cross(cs[0]-c.o,cs[1]-c.o))*0.5;\n            }else{\n                atc=SectorArea(a,b,c);\n            }\n        }\n    }\n    return 1.0*s*atc;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=getAreaTC(Pts[n-1],Pts[0],c);\n    for(int i=0;i<n-1;i++) apc+=getAreaTC(Pts[i],Pts[i+1],c);\n    return fabs(apc);\n}\n\n/********************************************************/\n\n\n/*----------------------三?点、?基本函数-----------------------------*/\n\nstruct Point3{\n    double x,y,z;\n    Point3(double x,double y,double z):x(x),y(y),z(z){}\n    Point3(){}\n    void Read(){ scanf(\"%lf%lf%lf\",&x,&y,&z); }\n};\n\nstruct Line3{\n    Point3 a,b;\n    Line3(Point3 a,Point3 b):a(a),b(b){}\n    Line3(){}\n    void Read(){ a.Read(); b.Read(); }\n};\nPoint3 operator +(Point3 a,Point3 b){ return Point3(a.x+b.x,a.y+b.y,a.z+b.z); }\nPoint3 operator -(Point3 a,Point3 b){ return Point3(a.x-b.x,a.y-b.y,a.z-b.z); }\ndouble operator *(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 operator *(Point3 a,double k){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator *(double k,Point3 a){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator /(Point3 a,double k){ return Point3(a.x/k,a.y/k,a.z/k); }\n\ndouble length(Point3 a){ return sqrt(a.x*a.x+a.y*a.y+a.z*a.z); }\nPoint3 unit(Point3 a){ return a/length(a); }\ndouble dot(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 cross(Point3 a,Point3 b){\n    return Point3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//混合?\ndouble Mix(Point3 a,Point3 b,Point3 c){\n    return dot(a,cross(b,c));\n}\n\n//?点距?\ndouble dist(const Point3 &a,const Point3 &b){ return length(a-b); }\n\n/*---------------------------------体?-------------------------------------*/\n\n//四面体体?\ndouble volume(double l,double n,double a,double m,double b,double c){\n    double x,y;\n    x=4*a*a*b*b*c*c-a*a*(b*b+c*c-m*m)*(b*b+c*c-m*m)-b*b*(c*c+a*a-n*n)*(c*c+a*a-n*n);\n    y=c*c*(a*a+b*b-l*l)*(a*a+b*b-l*l)-(a*a+b*b-l*l)*(b*b+c*c-m*m)*(c*c+a*a-n*n);\n    return sqrt(x-y)/12;\n}\n\ndouble volume(Point3 a,Point3 b,Point3 c,Point3 d){\n    return fabs(Mix(b-a,c-a,d-a)/6);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);cin.tie(0);\n    //cout<<getAreaTC(Point(3,3),Point(-3,3),Circle(Point(0,0),4))<<endl;\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <ctime>\nusing namespace std;\n\nconst double eps = 1e-12,PI = acos(-1);\n\nstruct point {\n\tdouble x, y;\n\tpoint(){}\n\tpoint(double xx, double yy) {\n\t\tx = xx,y = yy;\n\t}\n\tpoint operator -(const point &n2) const {\n\t\treturn point(x-n2.x, y-n2.y);\n\t}\n\tpoint operator +(const point &n2) const {\n\t\treturn point(x+n2.x, y+n2.y);\n\t}\n\tpoint operator *(const double n) const {\n\t\treturn point(x*n, y*n);\n\t}\n\tpoint operator /(const double n) const {\n\t\treturn point(x/n, y/n);\n\t}\n\tvoid output() {\n\t\tprintf(\"%0.10lf %0.10lf\\n\", x,y);\n\t//\tcout << x << ' ' << y << endl;\n\t}\n};\ndouble myrand(double l, double r)\n{\n\treturn l+(rand()%32768)/32768.0*(r-l);\n}\n\ninline double sqr(double x) {\n\treturn x*x;\n}\nint dcmp(double k) {\n\treturn k<-eps? -1:(k>eps? 1:0);\n}\ndouble dot(const point &a, const point &b) {\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(const point &a, const point &b)\n{\n\treturn a.x*b.y-a.y*b.x;\n};\ndouble abs(const point &o) {\n\treturn sqrt(dot(o,o));\n}\npoint crosspt(const point &a, const point &b, const point &p, const point &q)\n{\n\tdouble a1 = cross(b-a,p-a);\n\tdouble a2 = cross(b-a,q-a);\n\treturn (p*a2-q*a1)/(a2-a1);\n}\ndouble mysqrt(double n) {\n\treturn sqrt(max(.0,n));\n}\n\npoint a[15],res[15];\ndouble r;\nint n;\n\nvoid circle_cross_line(point a, point b, point o, double r, point ret[], int &num)\n{\n\tdouble x00 = o.x, y00 = o.y;\n\tdouble x11 = a.x, y11 = a.y;\n\tdouble x2 = b.x, y2 = b.y;\n\tdouble dx = x2-x11, dy = y2-y11;\n\tdouble A = dx*dx+dy*dy;\n\tdouble B = 2*dx*(x11-x00)+2*dy*(y11-y00);\n\tdouble C = sqr(x11-x00)+sqr(y11-y00)-sqr(r);\n\tdouble delta = B*B-4*A*C;\n\tnum = 0;\n\tif(dcmp(delta)>=0) {\n\t\tdouble t1 = (-B-mysqrt(delta))/(2*A);\n\t\tdouble t2 = (-B+mysqrt(delta))/(2*A);\n\t\tif(dcmp(t1-1)<=0 && dcmp(t1)>=0)\n\t\t\tret[num++] = point(x11+t1*dx, y11+t1*dy);\n\t\tif(dcmp(t2-1)<=0 && dcmp(t2)>=0)\n\t\t\tret[num++] = point(x11+t2*dx, y11+t2*dy);\n\t}\n}\n\ndouble sector_area(const point &a, const point &b)\n{\n\tdouble theta = atan2(a.y,a.x)-atan2(b.y,b.x);\n\twhile(theta<=0) theta += 2*PI;\n\twhile(theta>2*PI) theta -= 2*PI;\n\ttheta = min(theta, 2*PI-theta);\n\treturn r*r*theta/2;\n}\ndouble calc(const point &a, const point &b)\n{\n\tpoint p[2];\n\tint num = 0;\n\tint ina = dcmp(abs(a)-r)<0;\n\tint inb = dcmp(abs(b)-r)<0;\n\tif(ina) {\n\t\tif(inb) {\n\t\t\treturn fabs(cross(a,b))/2;\n\t\t}\n\t\telse {\n\t\t\tcircle_cross_line(a,b,point(0,0),r,p,num);\n\t\t\treturn sector_area(b,p[0])+fabs(cross(a,p[0]))/2;\n\t\t}\n\t}\n\telse {\n\t\tif(inb) {\n\t\t\tcircle_cross_line(a,b,point(0,0),r,p,num);\n\t\t\treturn sector_area(p[0],a)+fabs(cross(p[0],b))/2;\n\t\t}\n\t\telse {\n\t\t\tcircle_cross_line(a,b,point(0,0),r,p,num);\n\t\t\tif(num==2) {\n\t\t\t\treturn sector_area(a,p[0])+sector_area(p[1],b)+fabs(cross(p[0],p[1]))/2;\n\t\t\t}\n\t\t\telse return sector_area(a,b);\n\t\t}\n\t}\n}\ndouble area() {\n\tdouble ret = 0;\n\tfor(int i = 0; i<n; i++)\n\t{\n\t\tint sgn = dcmp(cross(res[i], res[i+1]));\n\t\tif(sgn) {\n\t\t\tret += sgn*calc(res[i],res[i+1]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nconst int M = 1000;\npoint now;\n\nint main()\n{\n\tsrand(time(0));\n\tint i,j;\n\tdouble minx = 100, maxx = 0, miny = 100, maxy = 0;\n\tcin >> n >> r;\n\tfor(i = 0; i<n; i++)\n\t{\n\t\tcin >> a[i].x >> a[i].y;\n\t\tminx = min(minx, a[i].x);\n\t\tmaxx = max(maxx, a[i].x);\n\t\tminy = min(miny, a[i].y);\n\t\tmaxy = max(maxy, a[i].y);\n\t}\n\ta[n] = a[0];\n\t\n\t\n\tdouble ans = 0,nowa;\n\tpoint mem;\n\tmem.x = -1;\n\tfor(i = 1; i<=M; i++)\n\t{\n\t\t \n\t//\tnow.x = 98.0014855956;\n\t//\tnow.y = 0.9455149817;\n\t\tnow.x = myrand(minx, maxx);\n\t\tnow.y = myrand(miny, maxy);\n\t\tif(rand()%2==0 && mem.x!=-1)\n\t\t\tnow = mem;\n\t\tfor(j = 0; j<=n; j++)\n\t\t\tres[j] = a[j]-now;\n\t\t\n\t\tnowa = area();\n//\t\tcout << nowa << endl;\n\t\t\n//\t\tbreak;\n\t\tif(nowa<eps) {\n\t\t\ti--; continue;\n\t\t}\n\t\n\t//\tnow.output();\n\t//\tcout << nowa << endl;\n\t\tdouble t;\n\t\tdouble pre = -1;\n\t\tfor(t = 1; t>1e-8; t *= 0.97)\n\t\t{\n\t\t\t\n\t\t\tdouble theta;\n\t\t//\tif(rand()%5 || pre==-1)\n\t\t\t\ttheta = myrand(0,2*PI);\n\t\t//\telse \n\t\t//\t\ttheta = pre;\n\t\t\t\n\t\t\tpoint ne = now+point(cos(theta), sin(theta))*t;\n\t\t//\tne.output();\n\t\t\tfor(j = 0; j<=n; j++)\n\t\t\t\tres[j] = a[j]-ne;\n\t\t\tdouble nea = area();\n\t\t\tif(nea>=nowa/* || myrand(0,1)<0.1*/) {\n\t\t\t\tnowa = nea;\n\t\t\t\tnow = ne;\n\t\t\t\tpre = theta;\n\t\t\t}\n\t\t\tif(ans<nowa) {\n\t\t\t\tans = nowa; mem = now;\n\t\t\t}\n\t\t}\n\t//\tcout << nowa << endl;\n\t//\tnow.output();\n\t}\n//\tmem.output();\n\tprintf(\"%0.6lf\\n\", ans);\n\t\n//\tcout << ans << endl;\n//\tcout << area() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n\nPoint calc_ps(Polygon poly) {\n  poly = andrewScan(poly);\n  Point mp = poly[0];\n  double rate = 1; // 0.5???????????¨???\n  int max_pos;\n  double eps = 1e-10; // 1e-20???????????¨???\n  while( rate > eps ) {\n    rep(_,60){ // 70???????????¨???\n      max_pos = 0;\n      REP(j,1,(int)poly.size()) {\n        double dist1 = abs(mp-poly[max_pos]);\n        double dist2 = abs(mp-poly[j]);\n\tif( LT(dist1,dist2) ) max_pos = j;\n      }\n      mp.x += ( poly[max_pos].x - mp.x ) * rate;\n      mp.y += ( poly[max_pos].y - mp.y ) * rate;\n    }\n    rate *= 0.5;\n  }\n  return mp;\n}\n\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  Point mp = calc_ps(poly);\n  //cout<< mp << endl;\n  double maxi = getCommonAreaPolygonCircle(poly,mp,r);\n  double rate = 1.0;\n  double eps = 1e-10;\n  while( LT(eps,rate) ) {\n    rep(_,70) {\n\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      if( !equals(max_area,-1) ) {\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      \n    }\n    rate *= 0.5;\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  //cout << getArea(poly) << endl;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cout if (0) cout\n\n// XXX without explanation marks untested functions\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pii;\n#define pb push_back\n\n// NOT STANDART FROM HERE\n\n// area de calota 2.pi.R.h (h altura)\n// volume de calota pi.h/6 * (3r^2 + h^2)\n\n typedef double cood;\n cood eps = 1e-8;\n// tests for double were made with eps = 1e-8\n\ndouble eps_d = 1e-8; // necessary even in integer geometry, should be eps otherwise\n\nconst double pi = acos(-1.);\n\ninline ll sq (ll x)\n{ return x*x; }\ninline double sq (double x)\n{ return x*x; }\n\nstruct vec { // vector\n\t// === BASIC ===\n\tcood x, y;\n\tvec () : x(0), y(0) {}\n\tvec (cood a, cood b) : x(a), y(b) {}\n\tfriend ostream& operator<<(ostream& os, vec o);\n\n\tvec operator - (vec o)\n\t{ return vec(x - o.x, y - o.y); }\n\tvec operator + (vec o)\n\t{ return vec(x + o.x, y + o.y); }\n\tvec operator * (cood o)\n\t{ return vec(x * o, y * o); }\n\tvec operator / (cood o)\n\t{ return vec(x / o, y / o); }\n\tcood operator ^ (vec o)\n\t{ return x * o.y - y * o.x; }\n\tcood operator * (vec o)\n\t{ return x * o.x + y * o.y; }\n\n\t// positive is (*this)b is clockwise from (*this)a\n\tdouble angle (vec a, vec b)\n\t{ return atan2((a-(*this))^(b-(*this)), (a-(*this))*(b-(*this))); }\n\n\tcood sq (vec o = vec())\n\t{ return ((*this)-o)*((*this)-o); }\n\tdouble nr (vec o = vec())\n\t{ return sqrt(sq(o)); }\n\n\tcood cross (vec a, vec b) // ccw signed area (positive if this is to the left of ab)\n\t{ return (b - a) ^ ((*this) - a); }\n\tint ccw (vec a, vec b) // which side is this from ab? (1 left, 0 over, -1 right)\n\t{ cood o = cross(a, b); return (eps < o) - (o < -eps); } \n\n\tint dir (vec a, vec b) // direction of (this)a relative to (this)b (-1 opposite, 0 none, 1 same)\n\t{ cood o = ((*this) - a)*((*this) - b); return (eps < o) - (o < -eps); }\n\n\tcood inner (vec s, vec t) // (p-s)*(t-s) where p = this projected on st\n\t{ return ((*this) - s) * (t - s); }\n\tvec proj (vec s, vec t) // projection of this point over line st\n\t{ return s + (t - s)*(inner(s,t) / t.sq(s)); }\n\n\tvec rotate (double a) // rotate ccw by a (fails with ll)\n\t{ return vec(cos(a) * x - sin(a) * y, sin(a) * x + cos(a) * y); }\n\tvec rot90 () // rotate pi/2 ccw\n\t{ return vec(-y, x); }\n\n\t// === ADVANCED ===\n\t// ordering that defines the compare method\n\t// used only there, change it accordingly\n\t// sorts increasing on y and, then increasing on x\n\tbool operator < (const vec & o) const {\n\t\tif (y != o.y)\n\t\t\treturn y < o.y;\n\t\treturn x < o.x;\n\t}\n\n\t// full ordering (ccw angle from this+(1,0), distance to this)\n\t// is a < b?\n\t// PRECISION : ok with double if norm in [-1e9,5e3]\n\tbool compare (vec a, vec b) {\n\t\tif (((*this) < a) != ((*this) < b))\n\t\t\treturn (*this) < a;\n\t\tint o = ccw(a,b);\n\t\tif (o) return o > 0;\n\t\treturn a.dir((*this),b) < 0;\n\t}\n\n\t// is this inside segment st? (tip of segment included, change for dr < 0 otherwise)\n\tbool in_seg (vec s, vec t)\n\t{ return (ccw(s,t) == 0) && (dir(s,t) <= 0); }\n\n\t// squared distance from this to line defined by st\n\tdouble dist2_lin (vec s, vec t)\n\t{ return double(::sq(cross(s,t))) / t.sq(s); }\n\t// squared distance from this to segment st\n\tdouble dist2_seg (vec s, vec t) \n\t{ return s.dir((*this),t) == t.dir((*this),s) ? dist2_lin(s,t) : min(sq(s),sq(t)); }\n\n\t// is this inside (borders included) the convex polygon v of size n?\n\t// if yes, prec is the vec that this on acw order from v[0] or 0 if there is no such\n\t// if not, prec is the predecessor of this when added to poly and succ is the sucessor\n\t// p should be a vector with [0..n-1]\n\t// n should be >= 2\n\tbool in_conv_poly (vec v[], int n, const vector<int> & p, int & prec, int & succ) {\n\t\tif (nr(v[0]) <= eps) {\n\t\t\tprec = 0;\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (n == 2) {\n\t\t\tif (in_seg(v[0],v[1]))\n\t\t\t\treturn (prec = 1);\n\n\t\t\tif (ccw(v[0],v[1]) > 0) {\n\t\t\t\tprec = 1;\n\t\t\t\tsucc = 0;\n\t\t\t} else if (ccw(v[0],v[1]) < 0) {\n\t\t\t\tprec = 0;\n\t\t\t\tsucc = 1;\n\t\t\t} else {\n\t\t\t\tprec = succ = (v[0].dir((*this),v[1]) < 0);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (ccw(v[0],v[1]) > 0 || ccw(v[0],v[n-1]) < 0) {\n\t\t// case where v[0] is not removed\n\t\t\t// last diagonal before or over this\n\t\t\tint di = lower_bound(p.begin() + 1, p.end(), -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[0],v[i]) >= 0;\n\t\t\t}) - p.begin() - 1;\n\n\t\t\t// is this inside the polygon?\n\t\t\tprec = di;\n\t\t\tif (di == n-1) {\n\t\t\t// last segment\n\t\t\t\tif (ccw(v[0],v[n-1]) == 0 && ccw(v[n-2],v[n-1]) >= 0)\n\t\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t// inside otherwise\n\t\t\t\tif (ccw(v[di],v[di+1]) >= 0)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// last that stays before (or eq to) di\n\t\t\tprec = lower_bound(p.begin() + 1, p.begin() + di + 1, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i-1],v[i]) > 0;\n\t\t\t}) - p.begin() - 1;\n\n\t\t\t// first that stays after di\n\t\t\tsucc = lower_bound(p.begin() + di + 1, p.end(), -1, [this,v,n] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[(i+1)%n],v[i]) >= 0;\n\t\t\t}) - p.begin();\n\t\t\tif (succ == n) succ = 0;\n\t\t} else {\n\t\t// case where v[0] is removed\n\t\t\t// first diagonal before of over this\n\t\t\t// di is certainly not removed\n\t\t\tint di = lower_bound(p.begin() + 1, p.end() - 1, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[0],v[i]) < 0;\n\t\t\t}) - p.begin();\n\n\t\t\t// first that stays (<= di)\n\t\t\tsucc = lower_bound(p.begin(), p.begin() + di, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i+1],v[i]) >= 0;\n\t\t\t}) - p.begin();\n\n\t\t\t// last that stays (>= di)\n\t\t\tprec = lower_bound(p.begin() + di + 1, p.end(), -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i-1],v[i]) > 0;\n\t\t\t}) - p.begin() - 1;\n\t\t}\n\t\treturn 0;\n\t}\n};\nostream& operator<<(ostream& os, vec o)\n{ return os << '(' << o.x << \", \" << o.y << ')'; }\n\nstruct lin { // line\n\tcood a, b, c; // a*x + b*y = c\n\n\tlin () {}\n\tlin (cood x, cood y, cood z) : a(x), b(y), c(z) {}\n\tlin (vec s, vec t) : a(t.y - s.y), b(s.x - t.x), c(a * s.x + b * s.y) {}\n\n\tlin parll (vec p) // parallel to this through p\n\t{ return lin(a, b, a * p.x + b * p.y); }\n\tlin perp ()\n\t{ return lin(-b, a, c); }\n\n\tvec inter (lin o) {\n\t\tcood d = a * o.b - o.a * b;\n\t\tif (d < eps && -eps < d) throw 0; // parallel\n\t\treturn vec((o.b * c - b * o.c) / d, (a * o.c - o.a * c) / d);\n\t}\n};\n\nstruct cir { // circle\n\tvec c; cood r;\n\n\t// borders included\n\tbool contains (vec w)\n\t{ return c.sq(w) <= sq(r) + eps; }\n\tbool has_inter (cir o)\n\t{ return c.sq(o.c) <= sq(r + o.r) + eps; }\n\tbool has_inter_lin (vec s, vec t)\n\t{ return c.dist2_lin(s,t) <= sq(r) + eps_d; }\n\tbool has_inter_seg (vec s, vec t)\n\t{ return c.dist2_seg(s,t) <= sq(r); }\n\n\t// borders not included\n\tbool contains (cir o)\n\t{ return (o.r < r - eps && c.sq(o.c) < sq(r - o.r) - eps); }\n\n\t// ccw oriented area of arc from a to b\n\tdouble arc_area (vec a, vec b) {\n\t\tdouble ang = c.angle(a,b);\n\t\treturn r*r*ang*.5;\n\t}\n\n\t// double only\n\tpair<vec,vec> inter_pts (cir o) {\n\t\tassert(has_inter(o) && !contains(o)); // fully contained case\n\t\tdouble d = c.nr(o.c);\n\t\tdouble a = (r*r + d*d - o.r*o.r) / (2.*d); // r*cos(ans,v,c.v)\n\t\tdouble h = sqrt(r*r - a*a);\n\t\tif (h != h) h = 0;\n\t\tvec p = o.c - c;\n\t\treturn pair<vec,vec>(c + p*(a/d) + (p.rot90()*(h/d)), c + p*(a/d) - (p.rot90()*(h/d)));\n\t}\n\n\t// double only XXX careful precision\n\tpair<vec,vec> inter_pts (vec s, vec t) { \n\t\tassert(has_inter_lin(s,t));\n\t\tdouble h2 = c.dist2_lin(s,t);\n\t\tdouble d = sqrt(c.sq(t) - h2);\n\t\tif (d != d) d = 0;\n\t\tvec p = (s-t);\n\t\tvec m = t + p*(d/p.nr());\n\t\tvec m_b = t - p*(d/p.nr());\n\t\tif (m_b.sq(c) < m.sq(c))\n\t\t\tm = m_b;\n\n\t\td = sqrt(r*r - h2);\n\t\tif (d != d) d = 0;\n\t\tpair<vec,vec> res(m + p*(d/p.nr()), m - p*(d/p.nr()));\n\t\tif (res.first.sq(t) > res.second.sq(t))\n\t\t\tswap(res.first, res.second);\n\t\treturn res;\n\t}\n\n\t// double only XXX not tested\n\t// signed area of intersection of this with triangle (this.c,a,b)\n\tdouble inter (vec a, vec b) {\n\t\tdouble res = 0.;\n\t\tbool inv = 0;\n\t\tif (contains(b)) {\n\t\t\tswap(a,b);\n\t\t\tinv = 1;\n\t\t}\n\n\t\tif (contains(b)) {\n\t\t\tres = c.cross(a,b)*.5;\n\t\t} else if (contains(a)) {\n\t\t\tpair<vec,vec> rt = inter_pts(a,b);\n\t\t\tvec q = rt.first;\n\t\t\tif (!q.in_seg(a,b))\n\t\t\t//if (rt.second.dist2_seg(a,b) < q.dist2_seg(a,b))\n\t\t\t\tq = rt.second;\n\n\t\t\tres += c.cross(a,q)*.5;\n\t\t\tres += arc_area(q,b);\n\t\t} else if (has_inter_seg(a, b)) {\n\t\t\tpair<vec,vec> rt = inter_pts(b,a);\n\n\t\t\tres += arc_area(a,rt.first);\n\t\t\tres += c.cross(rt.first,rt.second)*.5;\n\t\t\tres += arc_area(rt.second,b);\n\t\t} else {\n\t\t\tres += arc_area(a,b);\n\t\t}\n\n\t\tif (inv) res = -res;\n\t\treturn res;\n\t}\n\n\t// double only XXX not tested\n\t// signed area of intersection of this with polygon\n\tdouble inter (vector<vec> & p) {\n\t\tdouble res = 0;\n\t\tfor (int i = 0; i < p.size(); i++)\n\t\t\tres += inter(p[i],p[(i+1)%p.size()]);\n\t\treturn res;\n\t}\n};\n\n// do the segments ab and cd intersect? (borders included) XXX\nbool inter_seg (vec a, vec b, vec c, vec d) {\n\tif (a.in_seg(c, d) || b.in_seg(c, d) || c.in_seg(a, b) || d.in_seg(a, b))\n\t\treturn true;\n\treturn (c.ccw(a, b) * d.ccw(a, b) == -1 && a.ccw(c, d) * b.ccw(c, d) == -1);\n}\n\n// squared distance from segments ab and cd XXX\ndouble dist2_seg (vec a, vec b, vec c, vec d)\n{ return inter_seg(a,b,c,d) ? 0. : min({ a.dist2_seg(c,d), b.dist2_seg(c,d), c.dist2_seg(a,b), d.dist2_seg(a,b) }); }\n\n// brd = do points on the border belong to convex?\n// computes convex hull of given vector (inplace)\n// returns size of convex hull\nint graham (vec v[], int n, int brd) {\n\tfor (int i = 1; i < n; i++) {\n\t\tif (v[i].x < v[0].x || (v[i].x == v[0].x && v[i].y < v[0].y))\n\t\t\tswap(v[0], v[i]);\n\t}\n\n\tsort(v+1, v+n, [v] (vec a, vec b) {\n\t\tint o = b.ccw(v[0], a);\n\t\tif (o) return (o == 1);\n\t\treturn v[0].sq(a) < v[0].sq(b);\n\t});\n\n\tif (brd) {\n\t\tint s = n-1;\n\t\twhile (s > 1 && v[s].ccw(v[s-1],v[0]) == 0)\n\t\t\ts--;\n\t\tfor (int i = s; i < n - 1 - (i - s); i++)\n\t\t\tswap(v[i], v[n-1-(i-s)]);\n\t}\n\n\tint s = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s && v[s-1].x == v[i].x && v[s-1].y == v[i].y) continue;\n\t\twhile (s >= 2 && v[s-1].ccw(v[s-2],v[i]) >= brd)\n\t\t\ts--;\n\t\tv[s++] = v[i];\n\t}\n\n\treturn s;\n}\n\nconst int N = 1e2+7;\n\nint n;\ndouble r;\nvector<vec> v;\ndouble x[2], y[2];\n\ndouble solve (double x) {\n\tdouble lo = 200, hi = -100.;\n\tfor (int i = 0; i < n; i++) {\n\t\tint j = (i+1)%n;\n\t\tlin ln(v[i],v[j]);\n\t\tvec it(x, (ln.c - ln.a*x)/ln.b);\n\t\tcout << it << \" \";\n\t\tif (it.y == it.y && abs(it.y) < 200) {\n\t\t\tif (abs(ln.b) > eps) {\n\t\t\t\tlo = min(lo, it.y);\n\t\t\t\thi = max(hi, it.y);\n\t\t\t}\n\t\t}\n\n\t\tif (abs(v[i].x - x) <= eps_d) {\n\t\t\tcout << v[i] << \"! \";\n\t\t\tlo = min(lo, v[i].y);\n\t\t\thi = max(hi, v[i].y);\n\t\t}\n\t}\n\thi = min(hi, 200.); lo = max(lo, -100.);\n\tcout << x << \" [\" << lo << \" \" << hi << \"]\" << endl;\n\n\tint ts = 60;\n\twhile (ts--) {\n\t\tdouble q1 = (lo+lo+hi)/3;\n\t\tdouble q2 = (lo+hi+hi)/3;\n\n\t\tdouble r1 = abs(cir({ vec(x,q1), r }).inter(v));\n\t\tdouble r2 = abs(cir({ vec(x,q2), r }).inter(v));\n\n\t\tif (r1 < r2)\n\t\t\tlo = q1;\n\t\telse\n\t\t\thi = q2;\n\t}\n\n\treturn abs(cir({ vec(x,lo), r }).inter(v));\n}\n\nint main () {\n\n\twhile (scanf(\"%d %lf\", &n, &r) != EOF) {\n\t\tcout << n << endl;\n\t\tv = vector<vec>(n);\n\t\t\n\t\tx[0] = 200;\n\t\tx[1] = -100;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%lf %lf\", &v[i].x, &v[i].y);\n\t\t\tcout << v[i] << \" \";\n\n\t\t\tx[0] = min(x[0],v[i].x);\n\t\t\tx[1] = max(x[1],v[i].x);\n\t\t}\n\t\tcout << endl;\n\n\t\tdouble lo = x[0], hi = x[1];\n\t\tint ts = 60;\n\t\twhile (ts--) {\n\t\t\tdouble q1 = (lo+lo+hi)/3;\n\t\t\tdouble q2 = (lo+hi+hi)/3;\n\t\t\t\n\t\t\tif (solve(q1) < solve(q2))\n\t\t\t\tlo = q1;\n\t\t\telse\n\t\t\t\thi = q2;\n\t\t}\n\n\t\tprintf(\"%.20f\\n\", solve(lo));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1.0);\nconst double EPS=1e-5;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-5;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n\nPoint root(Line l,Point p){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n\ndouble sqr(double x){ return x*x; }\ndouble mysqrt(double x){ return sqrt(max(0.0,x)); }\n\nint getCrossCS(Circle c,Line s,Point *ret){\n    double x0=c.o.x,y0=c.o.y;\n    double x1=s.a.x,y1=s.a.y;\n    double x2=s.b.x,y2=s.b.y;\n    double dx=x2-x1,dy=y2-y1;\n    double A=dx*dx+dy*dy;\n    double B=2*dx*(x1-x0)+2*dy*(y1-y0);\n    double C=(x1-x0)*(x1-x0)+(y1-y0)*(y1-y0)-c.r*c.r;\n    double delta=B*B-4*A*C;\n    int num=0;\n    if(dcmp(delta)>=0){\n        double t1=(-B-mysqrt(delta))/(2*A);\n        double t2=(-B+mysqrt(delta))/(2*A);\n        if(dcmp(t1-1)<=0&&dcmp(t1)>=0) ret[num++]=Point(x1+t1*dx,y1+t1*dy);\n        if(dcmp(t2-1)<=0&&dcmp(t2)>=0) ret[num++]=Point(x1+t2*dx,y1+t2*dy);\n    }\n    return num;\n}\n\ndouble SectorArea(Point a,Point b,Circle c){\n    a=a-c.o,b=b-c.o;\n    double theta=atan2(a.y,a.x)-atan2(b.y,b.x);\n    while(dcmp(theta)<=0) theta+=2.0*PI;\n    while(dcmp(theta-2.0*PI)>0) theta-=2.0*PI;\n    theta=min(theta,2.0*PI-theta);\n    return c.r*c.r*theta*0.5;\n}\n\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=0.0;\n    Point OA=a-c.o,OB=b-c.o;\n    double la=length(OA),lb=length(OB);\n    Point cs[4];\n    bool aic=dcmp(la-c.r)<0,bic=dcmp(lb-c.r)<0;\n    int s=dcmp(cross(OA,OB));\n    if(!s) return 0.0;\n    if(aic){\n        if(bic){\n            atc=fabs(cross(OA,OB))*0.5;\n        }else{\n            int num=getCrossCS(c,Line(a,b),cs);\n            atc=SectorArea(cs[0],b,c)+fabs(cross(OA,cs[0]-c.o))*0.5;\n        }\n    }else{\n        if(bic){\n            int num=getCrossCS(c,Line(a,b),cs);\n            atc=SectorArea(cs[0],a,c)+fabs(cross(OB,cs[0]-c.o))*0.5;\n        }else{\n            int num=getCrossCS(c,Line(a,b),cs);\n            if(num==2){\n                if(distPP(a,cs[0])>distPP(a,cs[1])) swap(cs[0],cs[1]);\n                atc=SectorArea(a,cs[0],c)+SectorArea(b,cs[1],c)+fabs(cross(cs[0]-c.o,cs[1]-c.o))*0.5;\n            }else{\n                atc=SectorArea(a,b,c);\n            }\n        }\n    }\n    return 1.0*s*atc;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=getAreaTC(Pts[n-1],Pts[0],c);\n    for(int i=0;i<n-1;i++) apc+=getAreaTC(Pts[i],Pts[i+1],c);\n    return fabs(apc);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<200;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<200;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);cin.tie(0);\n    //cout<<getAreaTC(Point(3,3),Point(-3,3),Circle(Point(0,0),4))<<endl;\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1000\n#define linf 1e18\n#define eps (1e-6)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n  double getArea(){ return r*r*pi;}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Point p,Circle c){ return abs(p-c.c)-c.r<-eps;}\nbool on(Point p,Circle c){ return fabs(abs(p-c.c)-c.r)<eps;}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\ndouble getArea(Polygon p){\n  double res=0;\n  for(int i=1;i<p.size()-1;i++)res+=cross(p[i]-p[0],p[i+1]-p[0])/2.0;\n  return res;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nbool iscrossLC(Line l,Circle c){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  if(!iscrossLC(s,c))return res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(abs(pp.s-s.p1)-abs(pp.f-s.p1)<eps)swap(pp.f,pp.s);\n  if(ccw(s.p1,s.p2,pp.f)==0)res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0)res.push_back(pp.s);\n  return res;\n}\n\nbool AllIn(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceLP(L,c.c)-c.r<-eps || ccw(L.p1,L.p2,c.c)==-1)return false;\n  }\n  return true;\n}\n\nbool AllOut(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  if(cross(a,b)<-eps)r=360.0-r;\n  return r;\n}\n\ndouble getCommonAreaTC(Polygon p,Circle c){\n  double res=getArea(p),carea=c.getArea();\n  int n=p.size();\n  bool flag=false;\n  if(res<0.0){\n    flag=true;\n    reverse(p.begin(),p.end());\n    res=getArea(p);\n  }\n  vector<Point> s;\n  if(AllIn(p,c))return carea;\n  if(AllOut(p,c)) return 0.0;\n  int start=-1;\n  for(int i=0;i<n;i++){\n    if((c.r-abs(p[i]-c.c))<-eps)start=i;\n  }\n  if(start==-1)return res;\n  for(int i=0;i<n;i++){\n    vector<Point> vp=getCrossPointSC(c,Segment(p[(i+start)%n],\n\t\t\t\t\t       p[(i+1+start)%n]));    \n    for(int j=0;j<vp.size();j++){\n      bool b=true;\n      for(int k=0;k<s.size();k++)if(s[k]==vp[j])b=false;\n      if(b)s.push_back(vp[j]);\n    }\n  }\n\n  s.push_back(s[0]);\n  s.erase(s.begin());\n\n  for(int i=0;i<s.size();i+=2){\n    Point p1=s[i];\n    Point p2=s[i+1];\n    if(p1==p2)continue;\n    Polygon t;\n    t.push_back(p1);\n    t.push_back(p2);\n    t.push_back(c.c);\n    double narea=getArea(convex_cut(p,Line(p2,p1)));\n    if(narea<eps)continue;\n    res-=narea;\n    double ra=getAngle(p1-c.c,p2-c.c);\n    res+=((carea*ra/360.0)-getArea(t));\n  }\n  if(!flag)return res;\n  return -res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++){\n    Polygon t;\n    t.push_back(p[0]);\n    t.push_back(p[i]);\n    t.push_back(p[i+1]);\n    res+=getCommonAreaTC(t,c);\n  }\n  return res;\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,60){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*L,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=inf;\n    FOR(k,0,60){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1000\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n  double getArea(){ return r*r*pi;}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Point p,Circle c){ return abs(p-c.c)-c.r<-eps;}\nbool on(Point p,Circle c){ return fabs(abs(p-c.c)-c.r)<eps;}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\ndouble getArea(Polygon p){\n  double res=0;\n  for(int i=1;i<p.size()-1;i++)res+=cross(p[i]-p[0],p[i+1]-p[0])/2.0;\n  return res;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nbool iscrossLC(Line l,Circle c){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  if(!iscrossLC(s,c))return res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(abs(pp.s-s.p1)-abs(pp.f-s.p1)<eps)swap(pp.f,pp.s);\n  if(ccw(s.p1,s.p2,pp.f)==0)res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0)res.push_back(pp.s);\n  return res;\n}\n\nbool AllIn(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceLP(L,c.c)-c.r<-eps || ccw(L.p1,L.p2,c.c)==-1)return false;\n  }\n  return true;\n}\n\nbool AllOut(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  if(cross(a,b)<-eps)r=360.0-r;\n  return r;\n}\n\ndouble getCommonAreaTC(Polygon p,Circle c){\n  double res=getArea(p),carea=c.getArea();\n  int n=p.size();\n  /*\n  bool flag=false;\n  if(res<0.0){\n    flag=true;\n    reverse(p.begin(),p.end());\n    res=getArea(p);\n  }*/\n  vector<Point> s;\n  if(AllIn(p,c))return carea;\n  if(AllOut(p,c)) return 0.0;\n  int start=-1;\n  for(int i=0;i<n;i++){\n    if((c.r-abs(p[i]-c.c))<-eps)start=i;\n  }\n  if(start==-1)return res;\n  for(int i=0;i<n;i++){\n    vector<Point> vp=getCrossPointSC(c,Segment(p[(i+start)%n],\n\t\t\t\t\t       p[(i+1+start)%n]));    \n    for(int j=0;j<vp.size();j++){\n      bool b=true;\n      for(int k=0;k<s.size();k++)if(s[k]==vp[j])b=false;\n      if(b)s.push_back(vp[j]);\n    }\n  }\n\n  s.push_back(s[0]);\n  s.erase(s.begin());\n\n  for(int i=0;i<s.size();i+=2){\n    Point p1=s[i];\n    Point p2=s[i+1];\n    if(p1==p2)continue;\n    Polygon t;\n    t.push_back(p1);\n    t.push_back(p2);\n    t.push_back(c.c);\n    double narea= getArea(convex_cut(p,Line(p2,p1)));\n    if(narea<eps)continue;\n    res-=narea;\n    double ra=getAngle(p1-c.c,p2-c.c);\n    res+=((carea*ra/360.0)-getArea(t));\n  }\n  //if(!flag)return res;\n  return res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++){\n    Polygon t;\n    t.push_back(p[0]);\n    t.push_back(p[i]);\n    t.push_back(p[i+1]);\n    res+=getCommonAreaTC(t,c);\n  }\n  return res;\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,60){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*L,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=inf;\n    FOR(k,0,60){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//writted by dnvtmf\n#include <bits/stdc++.h>\n#define INF 1000000007\n#define FI first\n#define SE second\n#define PB push_back\n#define VI vector<int>\n#define MP make_pair\n#define FOR(x, st, ed) for(auto x = (st); x < (ed); ++x)\n#define FORE(x, st, ed) for(auto x = (st); x <= (ed); ++x)\n#define CLR(arr, val) memset(arr, val, sizeof(arr))\n#define INFO(tag, st, ed, x) printf(\"%s: \", tag); \\\n  FOR(_i, st, ed) cout << x[_i] << ' '; puts(\"\");\nusing namespace std;\ntypedef long long LL;\ntypedef pair <int, int> PII;\nconst int NUM = 100010;\n\nconst double EPS = 1e-10;\ninline int sgn(double x) {if (x < -EPS)return -1; return x > EPS ? 1 : 0;}\ninline double sqr(double x) {return x * x;}\nstruct Point {\n  double x, y;\n  Point(double _x = 0.0, double _y = 0.0): x(_x), y(_y) {}\n  Point operator + (const Point &b)const {return Point(x + b.x, y + b.y);}//向量加法\n  Point operator - (const Point &b)const {return Point(x - b.x, y - b.y);}//向量?法\n  double operator * (const Point &b)const {return x * b.x + y * b.y;}//向量点?\n  double operator ^ (const Point &b)const {return x * b.y - y * b.x;} //向量叉?\n  Point operator * (double b) {return Point(x * b, y * b);}//?量乘法\n  Point rot(double ang) {return Point(x * cos(ang) - y * sin(ang), x * sin(ang) + y * cos(ang));}//旋?\n  double norm() {return sqrt(x * x + y * y);}//向量的模\n};\n//直? ?段定?\n//直?方程：?点式：@$(x_2 - x_1)(y - y_1) = (y_2 - y_1)(x - x_1)$@\nstruct Line {\n  Point s, e;\n  //double k;\n  Line() {}\n  Line(Point _s, Point _e) {\n    s = _s, e = _e;\n    //k = atan2(e.y - s.y, e.x - s.x);\n  }\n  //求?直?交点\n  //返回-1?直?重合, 0 相交, 1 平行\n  pair<int, Point> operator &(Line b) {\n    if (sgn((s - e) ^ (b.s - b.e)) == 0) {\n      if (sgn((s - b.e) ^ (b.s - b.e)) == 0) return make_pair(-1, s); //重合\n      else return make_pair(1, s);//平行\n    }\n    double t = ((s - b.s) ^ (b.s - b.e)) / ((s - e) ^ (b.s - b.e));\n    return make_pair(0, Point(s.x + (e.x - s.x) * t, s.y + (e.y - s.y) * t));\n  }\n};\n//求向量vA与vB的?角(<= PI)\ndouble angle(Point vA, Point vB) {\n  double tmp = vA.norm() * vB.norm();\n  if (sgn(tmp) != 0) return acos((vA * vB) / tmp);\n  else return 0.0;\n}\n\n//num表示?O(o, r)与?段(s, e)的交点数, res里存?的是交点\nvoid Circle_cross_Segment(Point s, Point e, Point o, double r, Point res[], int &num) {\n  double dx = e.x - s.x, dy = e.y - s.y;\n  double A = dx * dx + dy * dy;\n  double B = 2.0 * dx * (s.x - o.x) + 2.0 * dy * (s.y - o.y);\n  double C = sqr(s.x - o.x) + sqr(s.y - o.y) - r * r;\n  double delta = B * B - 4.0 * A * C;\n  num = 0;\n  if (sgn(delta) < 0) return ;\n  delta = sqrt(max(0.0, delta));\n  double k1 = (-B - delta) / (2.0 * A);\n  double k2 = (-B + delta) / (2.0 * A);\n  if (sgn(k1 - 1.0) <= 0 && sgn(k1) >= 0) //?与?段相交条件判断\n    res[num++] = Point(s.x + k1 * dx, s.y + k1 * dy);\n  if (sgn(k2 - 1.0) <= 0 && sgn(k2) >= 0)\n    res[num++] = Point(s.x + k2 * dx, s.y + k2 * dy);\n}\n\n//三角形ABO与?(O, r)的面?交\ndouble Triangel_cross_Circle(Point a, Point b, Point o, double r) {\n  double r2 = r * r;\n  a = a - o;\n  b = b - o;\n  o = Point(0.0, 0.0);\n  bool bAInC = sgn((a * a) - r2) < 0;\n  bool bBInC = sgn((b * b) - r2) < 0;\n  double sg = 0.5 * sgn(a ^ b), res = 0.0;\n  Point tmp[2];\n  int num;\n  if (bAInC && bBInC) res = abs(a ^ b);\n  else if (bAInC || bBInC) {\n    if (bBInC) swap(a, b);\n    Circle_cross_Segment(a, b, 0, r, tmp, num);\n    res = fabs(a ^ tmp[0]) + r2 * angle(tmp[0], b);\n  }\n  else {\n    Circle_cross_Segment(a, b, o, r, tmp, num);\n    res = r2 * angle(a, b);\n    if (num == 2) {\n      res -= r2 * angle(tmp[0], tmp[1]);\n      res += fabs(tmp[0] ^ tmp[1]);\n    }\n  }\n  return sg * res;\n}\n\n//多?形与?的面?交\ndouble Polygon_intersect_Circle(Point ploy[], int n, Point O, double r) {\n  ploy[n] = ploy[0];\n  double res = 0.0;\n  for (int i = 0; i < n; ++i)\n    res += Triangel_cross_Circle(ploy[i], ploy[i + 1], O, r);\n  return fabs(res);\n}\n\nint n, r;\nPoint ploy[20];\ninline double Rand() {return 2.0 * rand() / RAND_MAX - 1.0;}\nclock_t tic;\ndouble get_time() {\n  return 1.0 * (clock() - tic) / CLOCKS_PER_SEC;\n}\nvoid solve() {\n  double x = ploy[0].x, y = ploy[0].y;\n  double area = Polygon_intersect_Circle(ploy, n, {x, y}, r);\n  double best = area, bx = 0.0, by = 0.0;\n  for (int i = 1; i < n; ++i) {\n    x = ploy[i].x, y = ploy[i].y;\n    area = Polygon_intersect_Circle(ploy, n, {x, y}, r);\n    if (best < area) {\n      best = area;\n      bx = x;\n      by = y;\n    }\n  }\n  double c = 10.;\n  for (int k = 0; get_time() < 4.9 && k < 10; ++k, c *= 0.1) {\n    x = bx, y = by, area = best;\n    double T = 10, T_decay = 0.95;\n    const int max_iter = 100, chain_len = 3000;\n    for (int i = 0; get_time() < 4.9 && i < max_iter; ++i, T *= T_decay) {\n      for (int j = 0; get_time() < 4.9 && j < chain_len; ++j) {\n        double xx = x + c * Rand();\n        double yy = y + c * Rand();\n        double S = Polygon_intersect_Circle(ploy, n, {xx, yy}, r);\n        double deltaS = S - area;\n        if (deltaS > 0 || exp(deltaS * T) < Rand()) {\n          x = xx;\n          y = yy;\n          area = S;\n          if (area > best) {\n            best = area;\n            bx = x;\n            by = y;\n          }\n        }\n      }\n    }\n  }\n  while (get_time() < 4.9) {\n    double xx = bx + 0.001 * Rand();\n    double yy = by + 0.001 * Rand();\n    double S = Polygon_intersect_Circle(ploy, n, {xx, yy}, r);\n    if (S > best) {\n      best = S;\n      bx = xx;\n      by = yy;\n    }\n  }\n  printf(\"%.10f\\n\", best);\n}\nint main() {\n#ifdef ACM_TEST\n  freopen(\"in.txt\", \"r\", stdin);\n#endif\n  tic = clock();\n  srand(time(0));\n  scanf(\"%d%d\", &n, &r);\n  for (int i = 0, x, y; i < n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    ploy[i] = Point(x, y);\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\n\ntemplate<class T> using V = vector<T>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) { return (abs(a) <= EPS) ? 0 : (a < 0 ? -1 : 1); }\nint sgn(D a, D b) { return sgn(a-b); }\n//relative sign\n// int rsgn(D a, D f) {\n//     if (abs(a) <= f*EPS) return 0;\n//     return (a < 0) ? -1 : 1;\n// }\nstruct Pt2 {\n    D x, y;\n    Pt2(D _x = D(), D _y = D()) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    Pt2 operator/(const D &r) const { return Pt2(x/r, y/r); }\n\n    Pt2& operator+=(const Pt2 &r) { return *this=*this+r; }\n    Pt2& operator-=(const Pt2 &r) { return *this=*this-r; }\n    Pt2& operator*=(const Pt2 &r) { return *this=*this*r; }\n    Pt2& operator*=(const D &r) { return *this=*this*r; }\n    Pt2& operator/=(const D &r) { return *this=*this/r; }\n    \n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    bool operator<(const Pt2 &r) const { return 2*sgn(x, r.x)+sgn(y, r.y)<0; }\n    bool operator==(const Pt2 &r) const { return sgn((*this-r).rabs()) == 0; }\n\n    D norm() const { return x*x + y*y; }\n    D abs() const { return sqrt(norm()); }\n    D rabs() const { return max(std::abs(x), std::abs(y)); } // robust abs\n    D arg() const { return atan2(y, x); }\n\n    pair<D, D> to_pair() const { return make_pair(x, y); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    return os << \"P(\" << p.x << \", \" << p.y << \")\";\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L(P _s = P(), P _t = P()) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\nostream& operator<<(ostream& os, const L &l) {\n    return os << \"L(\" << l.s << \", \" << l.t << \")\";\n}\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n// cross(a, b) is too small?\nint sgncrs(P a, P b) {\n    D cr = cross(a, b);\n    if (abs(cr) <= (a.rabs() + b.rabs()) * EPS) return 0;\n    return (cr < 0) ? -1 : 1;\n}\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = sgncrs(b, c);\n    if (s) return s;\n    if (!sgn(c.rabs()) || !sgn((c-b).rabs())) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nP project(const L &l, const P &p) {\n    P v = l.vec();\n    return l.s + v * (dot(v, p-l.s) / v.norm());\n}\n\nbool insSL(const L &s, const L &l) {\n    int a = ccw(l, s.s), b = ccw(l, s.t);\n    return (a%2 == 0 || b%2 == 0 || a != b);\n}\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s, t.s), b = ccw(s, t.t);\n    int c = ccw(t, s.s), d = ccw(t, s.t);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nD distLP(const L &l, const P &p) {\n    return abs(cross(l.vec(), p-l.s)) / l.abs();\n}\n\nD distSP(const L &s, const P &p) {\n    P q = project(s, p);\n    if (ccw(s, q) == 0) return (p - q).abs();\n    else return min((s.s - p).abs(), (s.t - p).abs());\n}\n\nint crossLL(const L &l, const L &m, P &r) {\n    D cr1 = cross(l.vec(), m.vec()), cr2 = cross(l.vec(), l.t - m.s);\n    if (sgncrs(l.vec(), m.vec()) == 0) {\n        r = l.s;\n        if (sgncrs(l.vec(), l.t - m.s)) return 0;\n        return -1;\n    }\n    r = m.s + m.vec() * (cr2 / cr1);\n    return 1;\n}\n\nusing Pol = V<P>;\n\nstruct C {\n    P p; D r;\n    C(P _p = P(), D _r = D()) : p(_p), r(_r) {}\n};\n\n//need Intersect/distLP, r.sはよりl.sに近い\nint crossCL(const C &c, const L &l, L &r) {\n    D u = distLP(l, c.p);\n    int si = sgn(u, c.r);    \n    if (si == 1) return 0;\n    P v = project(l, c.p);\n    P di = (si == 0) ? P(0, 0) : l.vec() * (sqrt(c.r*c.r - u*u) / l.abs());\n    r = L(v-di, v+di);\n    if (si == 0) return 1;\n    return 2;\n}\n\n// C(P(0, 0), r)とTri((0, 0), a, b)の共有面積\nD area2CT(const C &c, const P &_a, const P &_b) {\n    P a = _a - c.p, b = _b - c.p; D r = c.r;\n    if (a == b) return 0;\n    auto single = [&](P x, P y, bool tri) {\n        if (tri) return cross(x, y);\n        else return r * r * ((y * P(x.x, -x.y)).arg());\n    };\n    bool ia = sgn(a.abs(), r) != 1, ib = sgn(b.abs(), r) != 1;\n    if (ia && ib) return single(a, b, true);\n    D r2 = distSP(L(a, b), P(0, 0));\n    if (sgn(r, r2) != 1) return single(a, b, false);\n    L l;\n    assert(crossCL(C(P(0, 0), r), L(a, b), l) == 2);\n    if (ia) l.s = l.t;\n    else if (ib) l.t = l.s;\n    assert(ccw(a, b, l.s) == 0); assert(ccw(a, b, l.t) == 0);\n    return single(a, l.s, ia) + single(l.s, l.t, true) + single(l.t, b, ib);\n}\n\n// p, cの共有面積\nD area2CPol(const C &c, const Pol &po) {\n    D sm = 0;\n    P a, b = po.back();\n    for (auto p: po) {\n        a = b; b = p;\n        sm += area2CT(c, a, b);\n    }\n    return sm;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    int n; D r;\n    cin >> n >> r;\n    Pol pol;\n \n    D ymi = 1e100, yma = -1e100;\n    for (int i = 0; i < n; i++) {\n        D x, y;\n        cin >> x >> y;\n        pol.push_back(P(x, y));\n        ymi = min(ymi, y);\n        yma = max(yma, y);\n    }\n \n    auto calc = [&](D y) {\n        D xmi = 1e100, xma = -1e100;\n        P a, b = pol.back();\n        for (int i = 0; i < n; i++) {\n            a = b; b = pol[i];\n            P p;\n            if (crossLL(L(a, b), L(P(0, y), P(1, y)), p) == 0) continue;\n            if (ccw(a, b, p) != 0) continue;\n            xmi = min(xmi, p.x); xma = max(xma, p.x);\n        }\n        D lw = xmi, up = xma;\n        for (int ph = 0; ph < 50; ph++) {\n            D md1 = (lw+lw+up) / 3;\n            D md2 = (lw+up+up) / 3;\n            D z1 = area2CPol(C(P(md1, y), r), pol) / 2;\n            D z2 = area2CPol(C(P(md2, y), r), pol) / 2;\n            if (z1 < z2) {\n                lw = md1;\n            } else {\n                up = md2;\n            }\n        }\n        return area2CPol(C(P(lw, y), r), pol) / 2;\n    };\n     \n    D lw = ymi, up = yma;\n    for (int ph = 0; ph < 50; ph++) {\n        D md1 = (lw+lw+up) / 3;\n        D md2 = (lw+up+up) / 3;\n        if (calc(md1) < calc(md2)) {\n            lw = md1;\n        } else {\n            up = md2;\n        }\n    }\n \n    cout << calc(lw) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <ctime>\nusing namespace std;\n\nconst double eps = 1e-8,PI = acos(-1);\n\nstruct point {\n\tdouble x, y;\n\tpoint(){}\n\tpoint(double xx, double yy) {\n\t\tx = xx,y = yy;\n\t}\n\tpoint operator -(const point &n2) const {\n\t\treturn point(x-n2.x, y-n2.y);\n\t}\n\tpoint operator +(const point &n2) const {\n\t\treturn point(x+n2.x, y+n2.y);\n\t}\n\tpoint operator *(const double n) const {\n\t\treturn point(x*n, y*n);\n\t}\n\tpoint operator /(const double n) const {\n\t\treturn point(x/n, y/n);\n\t}\n\tvoid output() {\n\t\tcout << x << ' ' << y << endl;\n\t}\n};\ndouble myrand(double l, double r)\n{\n\treturn l+rand()/32768.0*(r-l);\n}\n\ninline double sqr(double x) {\n\treturn x*x;\n}\nint dcmp(double k) {\n\treturn k<-eps? -1:(k>eps? 1:0);\n}\ndouble dot(const point &a, const point &b) {\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(const point &a, const point &b)\n{\n\treturn a.x*b.y-a.y*b.x;\n};\ndouble abs(const point &o) {\n\treturn sqrt(dot(o,o));\n}\npoint crosspt(const point &a, const point &b, const point &p, const point &q)\n{\n\tdouble a1 = cross(b-a,p-a);\n\tdouble a2 = cross(b-a,q-a);\n\treturn (p*a2-q*a1)/(a2-a1);\n}\ndouble mysqrt(double n) {\n\treturn sqrt(max(.0,n));\n}\n\npoint a[15],res[15];\ndouble r;\nint n;\n\nvoid circle_cross_line(point a, point b, point o, double r, point ret[], int &num)\n{\n\tdouble x00 = o.x, y00 = o.y;\n\tdouble x11 = a.x, y11 = a.y;\n\tdouble x2 = b.x, y2 = b.y;\n\tdouble dx = x2-x11, dy = y2-y11;\n\tdouble A = dx*dx+dy*dy;\n\tdouble B = 2*dx*(x11-x00)+2*dy*(y11-y00);\n\tdouble C = sqr(x11-x00)+sqr(y11-y00)-sqr(r);\n\tdouble delta = B*B-4*A*C;\n\tnum = 0;\n\tif(dcmp(delta)>=0) {\n\t\tdouble t1 = (-B-mysqrt(delta))/(2*A);\n\t\tdouble t2 = (-B+mysqrt(delta))/(2*A);\n\t\tif(dcmp(t1-1)<=0 && dcmp(t1)>=0)\n\t\t\tret[num++] = point(x11+t1*dx, y11+t1*dy);\n\t\tif(dcmp(t2-1)<=0 && dcmp(t2)>=0)\n\t\t\tret[num++] = point(x11+t2*dx, y11+t2*dy);\n\t}\n}\n\ndouble sector_area(const point &a, const point &b)\n{\n\tdouble theta = atan2(a.y,a.x)-atan2(b.y,b.x);\n\twhile(theta<=0) theta += 2*PI;\n\twhile(theta>2*PI) theta -= 2*PI;\n\ttheta = min(theta, 2*PI-theta);\n\treturn r*r*theta/2;\n}\ndouble calc(const point &a, const point &b)\n{\n\tpoint p[2];\n\tint num = 0;\n\tint ina = dcmp(abs(a)-r)<0;\n\tint inb = dcmp(abs(b)-r)<0;\n\tif(ina) {\n\t\tif(inb) {\n\t\t\treturn fabs(cross(a,b))/2;\n\t\t}\n\t\telse {\n\t\t\tcircle_cross_line(a,b,point(0,0),r,p,num);\n\t\t\treturn sector_area(b,p[0])+fabs(cross(a,p[0]))/2;\n\t\t}\n\t}\n\telse {\n\t\tif(inb) {\n\t\t\tcircle_cross_line(a,b,point(0,0),r,p,num);\n\t\t\treturn sector_area(p[0],a)+fabs(cross(p[0],b))/2;\n\t\t}\n\t\telse {\n\t\t\tcircle_cross_line(a,b,point(0,0),r,p,num);\n\t\t\tif(num==2) {\n\t\t\t\treturn sector_area(a,p[0])+sector_area(p[1],b)+fabs(cross(p[0],p[1]))/2;\n\t\t\t}\n\t\t\telse return sector_area(a,b);\n\t\t}\n\t}\n}\ndouble area() {\n\tdouble ret = 0;\n\tfor(int i = 0; i<n; i++)\n\t{\n\t\tint sgn = dcmp(cross(res[i], res[i+1]));\n\t\tif(sgn) {\n\t\t\tret += sgn*calc(res[i],res[i+1]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nconst int M = 200;\npoint now;\n\nint main()\n{\n\tsrand(time(0));\n\tint i,j;\n\tdouble minx = 100, maxx = 0, miny = 100, maxy = 0;\n\tcin >> n >> r;\n\tfor(i = 0; i<n; i++)\n\t{\n\t\tcin >> a[i].x >> a[i].y;\n\t\tminx = min(minx, a[i].x);\n\t\tmaxx = max(maxx, a[i].x);\n\t\tminy = min(miny, a[i].y);\n\t\tmaxy = max(maxy, a[i].y);\n\t}\n\ta[n] = a[0];\n\t\n\t\n\tdouble ans = 0,nowa;\n\tfor(i = 1; i<=M; i++)\n\t{\n\t\tnow.x = myrand(minx, maxx);\n\t\tnow.y = myrand(miny, maxy);\n\t\tfor(j = 0; j<=n; j++)\n\t\t\tres[j] = a[j]-now;\n\t\tnowa = area();\n\t//\tnow.output();\n\t//\tcout << nowa << endl;\n\t\tdouble t;\n\t\tfor(t = 1; t>1e-5; t *= 0.99)\n\t\t{\n\t\t\tdouble theta = myrand(0,2*PI);\n\t\t\tpoint ne = now+point(cos(theta), sin(theta))*t;\n\t\t//\tne.output();\n\t\t\tfor(j = 0; j<=n; j++)\n\t\t\t\tres[j] = a[j]-ne;\n\t\t\tdouble nea = area();\n\t\t\tif(nea>=nowa/* || myrand(0,1)<0.1*/) {\n\t\t\t\tnowa = nea;\n\t\t\t\tnow = ne;\n\t\t\t}\n\t\t\tans = max(ans, nowa);\n\t\t}\n\t}\n\tprintf(\"%0.6lf\\n\", ans);\n//\tcout << ans << endl;\n//\tcout << area() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 400\n#define linf 1e18\n#define eps (1e-9)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Circle c,Point p){\n  if(abs(c.c-p)-c.r<-eps)return true;\n  return false;\n}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nbool intersect(Circle c,Segment s){\n  if(getDistanceSP(s,c.c)-c.r<-eps)return true;\n  return false;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  return acos(tmp)*180.0/pi;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nPoint getCrossPointSC(Circle c,Segment s){\n  Point res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(ccw(s.p1,s.p2,pp.f)==0){\n    res=pp.f;\n    if(ccw(s.p1,s.p2,pp.s)==0 && abs(s.p1-pp.s)<abs(s.p1-pp.f))res=pp.s;\n  }\n  else res=pp.s;\n  return res;\n}\n\ndouble getCommonAreaTC(Point a,Point b,Circle c){\n  double res=abs(cross(a-c.c,b-c.c)/2.0);\n  if(equals(0.0,res))return 0.0;\n  if(in(c,a) && !in(c,b)){\n    Point p1=getCrossPointSC(c,Segment(b,a));\n    Point p2=getCrossPointSC(c,Segment(b,c.c)); \n    res+=(c.r*c.r*pi)*(getAngle(p1-c.c,p2-c.c)/360.0);\n    res-=abs(cross(p1-c.c,p2-c.c)/2.0);\n    res-=abs(cross(p2-b,p1-b)/2.0);\n  }\n  else if(!in(c,a) && in(c,b)){\n    Point p1=getCrossPointSC(c,Segment(a,c.c));\n    Point p2=getCrossPointSC(c,Segment(a,b));\n    res+=(c.r*c.r*pi)*(getAngle(p1-c.c,p2-c.c)/360.0);\n    res-=abs(cross(p1-c.c,p2-c.c)/2.0);\n    res-=abs(cross(p2-a,p1-a)/2.0);\n  }\n  else if(!in(c,a) && !in(c,b)){\n    if(intersect(c,Segment(a,b))){\n      pair<Point,Point> pp=getCrossPoints(c,Segment(a,b));\n      Point m=pp.f+(pp.s-pp.f)/2.0;\n      res=abs(getCommonAreaTC(a,m,c))+abs(getCommonAreaTC(m,b,c));\n    }\n    else res=(c.r*c.r*pi)*(getAngle(a-c.c,b-c.c)/360.0);\n  }\n  if(cross(a-c.c,b-c.c)<0.0)res=-res;\n  return res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  int n=p.size();\n  FOR(i,0,n)res+=getCommonAreaTC(p[i],p[(i+1)%n],c);\n  return abs(res);\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,50){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res2-res1<-eps)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*R,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=inf*2;\n    FOR(k,0,50){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*(m1-inf));\n      double res2=check(a+v*(m2-inf));\n      if(res2-res1<-eps)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*(R-inf)));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1000\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n  double getArea(){ return r*r*pi;}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\ndouble arg(Vector p){ return atan2(p.y,p.x);}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\ndouble getArea(Polygon p){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++)res+=cross(p[i]-p[0],p[i+1]-p[0])/2.0;\n  return res;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0.0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nbool iscrossLC(Line l,Circle c){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  if(!iscrossLC(s,c))return res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(ccw(s.p1,s.p2,pp.f)==0)res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0)res.push_back(pp.s);\n  return res;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nvector<Point> arg_sort(vector<Point> vp,Point base){\n  vector<pair<double,Point> > tmp;\n  vector<Point> res;\n  for(int i=0;i<vp.size();i++){\n    double targ=arg(vp[i]-base);\n    if(targ<0)targ+=2*pi;\n    tmp.push_back(mp(targ,vp[i]));\n  }\n  sort(tmp.begin(),tmp.end());\n  for(int i=0;i<tmp.size();i++)res.push_back(tmp[i].s);\n  return res;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  if(cross(a,b)<-eps)r=360.0-r;\n  return r;\n}\n\nbool AllIn(Polygon p,Circle c){\n  if(contains(p,c.c)!=2)return false;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\nbool AllOut(Polygon p,Circle c){\n  if(contains(p,c.c)!=0)return false;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\nvector<Point> unique(vector<Point> vp){\n  vector<Point> res;\n  if(vp.empty())return res;\n  sort(vp.begin(),vp.end());\n  res.push_back(vp[0]);\n  for(int i=1;i<vp.size();i++)\n    if(!(res.back()==vp[i]))res.push_back(vp[i]);\n  return res;\n}\n\ndouble getCommonAreaTC(Polygon p,Circle c){\n  double res=getArea(p);\n  int n=p.size();\n  vector<Point> s;\n  if(AllIn(p,c))return c.getArea();\n  if(AllOut(p,c))return 0.0;\n  for(int i=0;i<n;i++){\n    vector<Point> vp=getCrossPointSC(c,Segment(p[i],p[(i+1)%n]));\n    for(int j=0;j<vp.size();j++)s.push_back(vp[j]);\n  }\n\n  s=unique(s);\n  if(s.size()<=1)return res;\n  s=arg_sort(s,c.c); \n\n  for(int i=0;i<s.size();i++){\n    Point p1=s[i];\n    Point p2=s[(i+1)%s.size()];\n    double ra=getAngle(p1-c.c,p2-c.c);\n    if(contains(p,rotate(c.c,p1,ra/2.0))==0)continue;\n    Polygon t;\n    t.push_back(p1);\n    t.push_back(p2);\n    t.push_back(c.c);\n    res-=getArea(convex_cut(p,Line(p2,p1)));\n    res+=((c.getArea()*ra/360.0)-getArea(t));\n  }\n  return res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++){\n    Polygon t;\n    t.push_back(p[0]);\n    t.push_back(p[i]);\n    t.push_back(p[i+1]);\n    res+=getCommonAreaTC(t,c);\n  }\n  return res;\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,50){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*L,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=abs(b-a);\n    FOR(k,0,50){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n\nPoint calc_ps(Polygon poly) {\n  poly = andrewScan(poly);\n  Point mp = poly[0];\n  double rate = 1; // 0.5???????????¨???\n  int max_pos;\n  double eps = 1e-10; // 1e-20???????????¨???\n  while( rate > eps ) {\n    rep(_,60){ // 70???????????¨???\n      max_pos = 0;\n      REP(j,1,(int)poly.size()) {\n        double dist1 = abs(mp-poly[max_pos]);\n        double dist2 = abs(mp-poly[j]);\n\tif( LT(dist1,dist2) ) max_pos = j;\n      }\n      mp.x += ( poly[max_pos].x - mp.x ) * rate;\n      mp.y += ( poly[max_pos].y - mp.y ) * rate;\n    }\n    rate *= 0.5;\n  }\n  return mp;\n}\n\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  Point mp = calc_ps(poly);\n  cout<< mp << endl;\n  double maxi = getCommonAreaPolygonCircle(poly,mp,r);\n  double rate = 1.0;\n  double eps = 1e-10;\n  while( LT(eps,rate) ) {\n    rep(_,70) {\n\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      if( !equals(max_area,-1) ) {\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      \n    }\n    rate *= 0.5;\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  cout << getArea(poly) << endl;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\n\nstruct P {\n\tdouble x, y;\n\tP() {\n\t}\n\tP(double _x, double _y) :\n\t\t\tx(_x), y(_y) {\n\t}\n\tP operator+(const P&p) const {\n\t\treturn P(x + p.x, y + p.y);\n\t}\n\tP operator-(const P&p) const {\n\t\treturn P(x - p.x, y - p.y);\n\t}\n\tP operator*(double d) const {\n\t\treturn P(x * d, y * d);\n\t}\n\tP operator/(double d) const {\n\t\treturn P(x / d, y / d);\n\t}\n\tdouble det(const P&p) const {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdouble dot(const P&p) const {\n\t\treturn x * p.x + y * p.y;\n\t}\n\tdouble alpha() const {\n\t\treturn atan2(y, x);\n\t}\n\tP rot90() const {\n\t\treturn P(-y, x);\n\t}\n\tvoid read() {\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t}\n\tvoid write() const {\n\t\tprintf(\"(%lf,%lf)\", x, y);\n\t}\n\tdouble abs() {\n\t\treturn sqrt(abs2());\n\t}\n\tdouble abs2() {\n\t\treturn x * x + y * y;\n\t}\n\tP unit() {\n\t\treturn *this / abs();\n\t}\n};\n\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n\nconst double EPS = 1e-8; //you should change it according to problem, nevertheless, it mustn't be a constant value some times.\ninline int sign(double a) {\n\treturn a < -EPS ? -1 : a > EPS;\n}\n\n#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))\n\nP isSS(P p1, P p2, P q1, P q2) {\n\tdouble a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);\n\treturn (p1 * a2 + p2 * a1) / (a1 + a2);\n}\n\nint n;\n\ndouble x[12],y[12],r;\n\nbool onLine(P p, P q, P x){\n\treturn (x-p).dot(x-q) <= EPS;\n}\n\nvector<P> isCS(P c,double r,P p, P q){\n\tdouble d = cross(q,p,c) / (p-q).abs();\n\tvector<P> ret;\n\n\tif(d>=r+EPS)\n\t\treturn ret;\n\n\tP dir = (q-p).rot90();\n\tP pq = (p-q);\n\tpq = pq/pq.abs();\n\n\tdir = dir / dir.abs();\n\n\tP mid = c + dir * d;\n\n\tdouble h = sqrt(max(r*r-d*d,0.0));\n\tif(onLine(p,q,mid + pq*h))\n\t\tret.push_back(mid + pq*h);\n\tif(onLine(p,q,mid - pq*h))\n\t\tret.push_back(mid - pq*h);\n\treturn ret;\n}\n\ndouble rad(P p,P q){\n\treturn atan2(p.det(q),p.dot(q));\n}\n\ndouble calc(P p, P q){\n\tbool inp = p.abs2() <= r*r;\n\tbool inq = q.abs2() <= r*r;\n\tif(inp && inq){\n\t\treturn p.det(q)/2;\n\t}\n\tif(inp && !inq){\n\t\treturn -calc(q,p);\n\t}\n\tvector<P> is = isCS(P(0,0),r,p,q);\n\tif(!inp && inq){\n\t\tP m = is[0];\n\t\treturn r*r*rad(p,m)/2 + m.det(q)/2;\n\t}\n\n\tif(!inp && !inq){\n\t\tif(is.empty())\n\t\t\treturn r*r*rad(p,q)/2;\n\t\treturn r*r*(rad(p,is[0]) + rad(is[1],q))/2 + is[0].det(is[1])/2;\n\t}\n}\n\ndouble calcArea(double cx,double cy){\n\tP ps[12];\n\trep(i,n) ps[i].x=x[i]-cx,ps[i].y=y[i]-cy;\n\tps[n] = ps[0];\n\n\tdouble area = 0;\n\n\trep(i,n){\n\t\tP p=ps[i],q=ps[i+1];\n\t\tarea += calc(p,q);\n\t}\n\n\treturn area;\n}\n\ndouble ffy(double x){\n\tdouble l=*min_element(y,y+n),r=*max_element(y,y+n);\n\trep(it,100){\n\t\tdouble ll=(l*2+r)/3,rr=(l+r*2)/3;\n\t\tif(calcArea(x,ll)>calcArea(x,rr))\n\t\t\tr=rr;\n\t\telse\n\t\t\tl=ll;\n\t}\n\treturn calcArea(x,l);\n}\n\ndouble ffx(){\n\tdouble l=*min_element(x,x+n),r=*max_element(x,x+n);\n\trep(it,100){\n\t\tdouble ll=(l*2+r)/3,rr=(l+r*2)/3;\n\t\tif(ffy(ll)>ffy(rr))\n\t\t\tr=rr;\n\t\telse\n\t\t\tl=ll;\n\t}\n\treturn ffy(l);\n}\ndouble pi=acos(-1.);\ndouble fuck() {\n\tdouble rx=0,ry=0;\n\trep(i,n) rx=rx+x[i],ry=ry+y[i];\n\trx/=n; ry/=n; double c=calcArea(rx,ry);\n\tdouble step=100;\n\trep(r1,100) {\n\t\trep(r2,300) {\n\t\t\tdouble ang=(rand()%100001)*1e-5*2*pi;\n\t\t\tdouble px=rx+step*cos(ang),py=ry+step*sin(ang);\n\t\t\tdouble f=calcArea(px,py);\n\t\t\tif (f>c) c=f,rx=px,ry=py;\n\t\t}\n//\t\tprintf(\"%.10f\\n\",c);\n\t\tstep*=0.5;\n\t}\n\treturn c;\n}\nint main(){\n\tcin>>n>>r;\n\trep(i,n) cin>>x[i]>>y[i];\n\n\tprintf(\"%0.10lf\\n\",fuck());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cout if (0) cout\n\n// XXX without explanation marks untested functions\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pii;\n#define pb push_back\n\n// NOT STANDART FROM HERE\n\n// area de calota 2.pi.R.h (h altura)\n// volume de calota pi.h/6 * (3r^2 + h^2)\n\n typedef double cood;\n cood eps = 1e-8;\n// tests for double were made with eps = 1e-8\n\ndouble eps_d = 1e-8; // necessary even in integer geometry, should be eps otherwise\n\nconst double pi = acos(-1.);\n\ninline ll sq (ll x)\n{ return x*x; }\ninline double sq (double x)\n{ return x*x; }\n\nstruct vec { // vector\n\t// === BASIC ===\n\tcood x, y;\n\tvec () : x(0), y(0) {}\n\tvec (cood a, cood b) : x(a), y(b) {}\n\tfriend ostream& operator<<(ostream& os, vec o);\n\n\tvec operator - (vec o)\n\t{ return vec(x - o.x, y - o.y); }\n\tvec operator + (vec o)\n\t{ return vec(x + o.x, y + o.y); }\n\tvec operator * (cood o)\n\t{ return vec(x * o, y * o); }\n\tvec operator / (cood o)\n\t{ return vec(x / o, y / o); }\n\tcood operator ^ (vec o)\n\t{ return x * o.y - y * o.x; }\n\tcood operator * (vec o)\n\t{ return x * o.x + y * o.y; }\n\n\t// positive is (*this)b is clockwise from (*this)a\n\tdouble angle (vec a, vec b)\n\t{ return atan2((a-(*this))^(b-(*this)), (a-(*this))*(b-(*this))); }\n\n\tcood sq (vec o = vec())\n\t{ return ((*this)-o)*((*this)-o); }\n\tdouble nr (vec o = vec())\n\t{ return sqrt(sq(o)); }\n\n\tcood cross (vec a, vec b) // ccw signed area (positive if this is to the left of ab)\n\t{ return (b - a) ^ ((*this) - a); }\n\tint ccw (vec a, vec b) // which side is this from ab? (1 left, 0 over, -1 right)\n\t{ cood o = cross(a, b); return (eps < o) - (o < -eps); } \n\n\tint dir (vec a, vec b) // direction of (this)a relative to (this)b (-1 opposite, 0 none, 1 same)\n\t{ cood o = ((*this) - a)*((*this) - b); return (eps < o) - (o < -eps); }\n\n\tcood inner (vec s, vec t) // (p-s)*(t-s) where p = this projected on st\n\t{ return ((*this) - s) * (t - s); }\n\tvec proj (vec s, vec t) // projection of this point over line st\n\t{ return s + (t - s)*(inner(s,t) / t.sq(s)); }\n\n\tvec rotate (double a) // rotate ccw by a (fails with ll)\n\t{ return vec(cos(a) * x - sin(a) * y, sin(a) * x + cos(a) * y); }\n\tvec rot90 () // rotate pi/2 ccw\n\t{ return vec(-y, x); }\n\n\t// === ADVANCED ===\n\t// ordering that defines the compare method\n\t// used only there, change it accordingly\n\t// sorts increasing on y and, then increasing on x\n\tbool operator < (const vec & o) const {\n\t\tif (y != o.y)\n\t\t\treturn y < o.y;\n\t\treturn x < o.x;\n\t}\n\n\t// full ordering (ccw angle from this+(1,0), distance to this)\n\t// is a < b?\n\t// PRECISION : ok with double if norm in [-1e9,5e3]\n\tbool compare (vec a, vec b) {\n\t\tif (((*this) < a) != ((*this) < b))\n\t\t\treturn (*this) < a;\n\t\tint o = ccw(a,b);\n\t\tif (o) return o > 0;\n\t\treturn a.dir((*this),b) < 0;\n\t}\n\n\t// is this inside segment st? (tip of segment included, change for dr < 0 otherwise)\n\tbool in_seg (vec s, vec t)\n\t{ return (ccw(s,t) == 0) && (dir(s,t) <= 0); }\n\n\t// squared distance from this to line defined by st\n\tdouble dist2_lin (vec s, vec t)\n\t{ return double(::sq(cross(s,t))) / t.sq(s); }\n\t// squared distance from this to segment st\n\tdouble dist2_seg (vec s, vec t) \n\t{ return s.dir((*this),t) == t.dir((*this),s) ? dist2_lin(s,t) : min(sq(s),sq(t)); }\n\n\t// is this inside (borders included) the convex polygon v of size n?\n\t// if yes, prec is the vec that this on acw order from v[0] or 0 if there is no such\n\t// if not, prec is the predecessor of this when added to poly and succ is the sucessor\n\t// p should be a vector with [0..n-1]\n\t// n should be >= 2\n\tbool in_conv_poly (vec v[], int n, const vector<int> & p, int & prec, int & succ) {\n\t\tif (nr(v[0]) <= eps) {\n\t\t\tprec = 0;\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (n == 2) {\n\t\t\tif (in_seg(v[0],v[1]))\n\t\t\t\treturn (prec = 1);\n\n\t\t\tif (ccw(v[0],v[1]) > 0) {\n\t\t\t\tprec = 1;\n\t\t\t\tsucc = 0;\n\t\t\t} else if (ccw(v[0],v[1]) < 0) {\n\t\t\t\tprec = 0;\n\t\t\t\tsucc = 1;\n\t\t\t} else {\n\t\t\t\tprec = succ = (v[0].dir((*this),v[1]) < 0);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (ccw(v[0],v[1]) > 0 || ccw(v[0],v[n-1]) < 0) {\n\t\t// case where v[0] is not removed\n\t\t\t// last diagonal before or over this\n\t\t\tint di = lower_bound(p.begin() + 1, p.end(), -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[0],v[i]) >= 0;\n\t\t\t}) - p.begin() - 1;\n\n\t\t\t// is this inside the polygon?\n\t\t\tprec = di;\n\t\t\tif (di == n-1) {\n\t\t\t// last segment\n\t\t\t\tif (ccw(v[0],v[n-1]) == 0 && ccw(v[n-2],v[n-1]) >= 0)\n\t\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t// inside otherwise\n\t\t\t\tif (ccw(v[di],v[di+1]) >= 0)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// last that stays before (or eq to) di\n\t\t\tprec = lower_bound(p.begin() + 1, p.begin() + di + 1, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i-1],v[i]) > 0;\n\t\t\t}) - p.begin() - 1;\n\n\t\t\t// first that stays after di\n\t\t\tsucc = lower_bound(p.begin() + di + 1, p.end(), -1, [this,v,n] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[(i+1)%n],v[i]) >= 0;\n\t\t\t}) - p.begin();\n\t\t\tif (succ == n) succ = 0;\n\t\t} else {\n\t\t// case where v[0] is removed\n\t\t\t// first diagonal before of over this\n\t\t\t// di is certainly not removed\n\t\t\tint di = lower_bound(p.begin() + 1, p.end() - 1, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[0],v[i]) < 0;\n\t\t\t}) - p.begin();\n\n\t\t\t// first that stays (<= di)\n\t\t\tsucc = lower_bound(p.begin(), p.begin() + di, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i+1],v[i]) >= 0;\n\t\t\t}) - p.begin();\n\n\t\t\t// last that stays (>= di)\n\t\t\tprec = lower_bound(p.begin() + di + 1, p.end(), -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i-1],v[i]) > 0;\n\t\t\t}) - p.begin() - 1;\n\t\t}\n\t\treturn 0;\n\t}\n};\nostream& operator<<(ostream& os, vec o)\n{ return os << '(' << o.x << \", \" << o.y << ')'; }\n\nstruct lin { // line\n\tcood a, b, c; // a*x + b*y = c\n\n\tlin () {}\n\tlin (cood x, cood y, cood z) : a(x), b(y), c(z) {}\n\tlin (vec s, vec t) : a(t.y - s.y), b(s.x - t.x), c(a * s.x + b * s.y) {}\n\n\tlin parll (vec p) // parallel to this through p\n\t{ return lin(a, b, a * p.x + b * p.y); }\n\tlin perp ()\n\t{ return lin(-b, a, c); }\n\n\tvec inter (lin o) {\n\t\tcood d = a * o.b - o.a * b;\n\t\tif (d < eps && -eps < d) throw 0; // parallel\n\t\treturn vec((o.b * c - b * o.c) / d, (a * o.c - o.a * c) / d);\n\t}\n};\n\nstruct cir { // circle\n\tvec c; cood r;\n\n\t// borders included\n\tbool contains (vec w)\n\t{ return c.sq(w) <= sq(r) + eps; }\n\tbool has_inter (cir o)\n\t{ return c.sq(o.c) <= sq(r + o.r) + eps; }\n\tbool has_inter_lin (vec s, vec t)\n\t{ return c.dist2_lin(s,t) <= sq(r) + eps_d; }\n\tbool has_inter_seg (vec s, vec t)\n\t{ return c.dist2_seg(s,t) <= sq(r); }\n\n\t// borders not included\n\tbool contains (cir o)\n\t{ return (o.r < r - eps && c.sq(o.c) < sq(r - o.r) - eps); }\n\n\t// ccw oriented area of arc from a to b\n\tdouble arc_area (vec a, vec b) {\n\t\tdouble ang = c.angle(a,b);\n\t\treturn r*r*ang*.5;\n\t}\n\n\t// double only\n\tpair<vec,vec> inter_pts (cir o) {\n\t\tassert(has_inter(o) && !contains(o)); // fully contained case\n\t\tdouble d = c.nr(o.c);\n\t\tdouble a = (r*r + d*d - o.r*o.r) / (2.*d); // r*cos(ans,v,c.v)\n\t\tdouble h = sqrt(r*r - a*a);\n\t\tif (h != h) h = 0;\n\t\tvec p = o.c - c;\n\t\treturn pair<vec,vec>(c + p*(a/d) + (p.rot90()*(h/d)), c + p*(a/d) - (p.rot90()*(h/d)));\n\t}\n\n\t// double only XXX careful precision\n\tpair<vec,vec> inter_pts (vec s, vec t) { \n\t\tassert(has_inter_lin(s,t));\n\t\tdouble h2 = c.dist2_lin(s,t);\n\t\tdouble d = sqrt(c.sq(t) - h2);\n\t\tif (d != d) d = 0;\n\t\tvec p = (s-t);\n\t\tvec m = t + p*(d/p.nr());\n\t\tvec m_b = t - p*(d/p.nr());\n\t\tif (m_b.sq(c) < m.sq(c))\n\t\t\tm = m_b;\n\n\t\td = sqrt(r*r - h2);\n\t\tif (d != d) d = 0;\n\t\tpair<vec,vec> res(m + p*(d/p.nr()), m - p*(d/p.nr()));\n\t\tif (res.first.sq(t) > res.second.sq(t))\n\t\t\tswap(res.first, res.second);\n\t\treturn res;\n\t}\n\n\t// double only XXX not tested\n\t// signed area of intersection of this with triangle (this.c,a,b)\n\tdouble inter (vec a, vec b) {\n\t\tdouble res = 0.;\n\t\tbool inv = 0;\n\t\tif (contains(b)) {\n\t\t\tswap(a,b);\n\t\t\tinv = 1;\n\t\t}\n\n\t\tif (contains(b)) {\n\t\t\tres = c.cross(a,b)*.5;\n\t\t} else if (contains(a)) {\n\t\t\tpair<vec,vec> rt = inter_pts(a,b);\n\t\t\tvec q = rt.first;\n\t\t\t//if (!q.in_seg(a,b))\n\t\t\tif (rt.second.dist2_seg(a,b) < q.dist2_seg(a,b))\n\t\t\t\tq = rt.second;\n\n\t\t\tres += c.cross(a,q)*.5;\n\t\t\tres += arc_area(q,b);\n\t\t} else if (has_inter_seg(a, b)) {\n\t\t\tpair<vec,vec> rt = inter_pts(b,a);\n\n\t\t\tres += arc_area(a,rt.first);\n\t\t\tres += c.cross(rt.first,rt.second)*.5;\n\t\t\tres += arc_area(rt.second,b);\n\t\t} else {\n\t\t\tres += arc_area(a,b);\n\t\t}\n\n\t\tif (inv) res = -res;\n\t\treturn res;\n\t}\n\n\t// double only XXX not tested\n\t// signed area of intersection of this with polygon\n\tdouble inter (vector<vec> & p) {\n\t\tdouble res = 0;\n\t\tfor (int i = 0; i < p.size(); i++)\n\t\t\tres += inter(p[i],p[(i+1)%p.size()]);\n\t\treturn res;\n\t}\n};\n\n// do the segments ab and cd intersect? (borders included) XXX\nbool inter_seg (vec a, vec b, vec c, vec d) {\n\tif (a.in_seg(c, d) || b.in_seg(c, d) || c.in_seg(a, b) || d.in_seg(a, b))\n\t\treturn true;\n\treturn (c.ccw(a, b) * d.ccw(a, b) == -1 && a.ccw(c, d) * b.ccw(c, d) == -1);\n}\n\n// squared distance from segments ab and cd XXX\ndouble dist2_seg (vec a, vec b, vec c, vec d)\n{ return inter_seg(a,b,c,d) ? 0. : min({ a.dist2_seg(c,d), b.dist2_seg(c,d), c.dist2_seg(a,b), d.dist2_seg(a,b) }); }\n\n// brd = do points on the border belong to convex?\n// computes convex hull of given vector (inplace)\n// returns size of convex hull\nint graham (vec v[], int n, int brd) {\n\tfor (int i = 1; i < n; i++) {\n\t\tif (v[i].x < v[0].x || (v[i].x == v[0].x && v[i].y < v[0].y))\n\t\t\tswap(v[0], v[i]);\n\t}\n\n\tsort(v+1, v+n, [v] (vec a, vec b) {\n\t\tint o = b.ccw(v[0], a);\n\t\tif (o) return (o == 1);\n\t\treturn v[0].sq(a) < v[0].sq(b);\n\t});\n\n\tif (brd) {\n\t\tint s = n-1;\n\t\twhile (s > 1 && v[s].ccw(v[s-1],v[0]) == 0)\n\t\t\ts--;\n\t\tfor (int i = s; i < n - 1 - (i - s); i++)\n\t\t\tswap(v[i], v[n-1-(i-s)]);\n\t}\n\n\tint s = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s && v[s-1].x == v[i].x && v[s-1].y == v[i].y) continue;\n\t\twhile (s >= 2 && v[s-1].ccw(v[s-2],v[i]) >= brd)\n\t\t\ts--;\n\t\tv[s++] = v[i];\n\t}\n\n\treturn s;\n}\n\nconst int N = 1e2+7;\n\nint n;\ndouble r;\nvector<vec> v;\ndouble x[2], y[2];\n\ndouble solve (double x) {\n\tdouble lo = 200, hi = -100.;\n\tfor (int i = 0; i < n; i++) {\n\t\tint j = (i+1)%n;\n\t\tlin ln(v[i],v[j]);\n\t\tvec it(x, (ln.c - ln.a*x)/ln.b);\n\t\tcout << it << \" \";\n\t\tif (it.y == it.y && abs(it.y) < 200) {\n\t\t\tif (abs(ln.b) > eps) {\n\t\t\t\tlo = min(lo, it.y);\n\t\t\t\thi = max(hi, it.y);\n\t\t\t}\n\t\t}\n\n\t\tif (abs(v[i].x - x) <= eps_d) {\n\t\t\tcout << v[i] << \"! \";\n\t\t\tlo = min(lo, v[i].y);\n\t\t\thi = max(hi, v[i].y);\n\t\t}\n\t}\n\thi = min(hi, 200.); lo = max(lo, -100.);\n\tcout << x << \" [\" << lo << \" \" << hi << \"]\" << endl;\n\n\tint ts = 60;\n\twhile (ts--) {\n\t\tdouble q1 = (lo+lo+hi)/3;\n\t\tdouble q2 = (lo+hi+hi)/3;\n\n\t\tdouble r1 = abs(cir({ vec(x,q1), r }).inter(v));\n\t\tdouble r2 = abs(cir({ vec(x,q2), r }).inter(v));\n\n\t\tif (r1 < r2)\n\t\t\tlo = q1;\n\t\telse\n\t\t\thi = q2;\n\t}\n\n\treturn abs(cir({ vec(x,lo), r }).inter(v));\n}\n\nint main () {\n\n\twhile (scanf(\"%d %lf\", &n, &r) != EOF) {\n\t\tcout << n << endl;\n\t\tv = vector<vec>(n);\n\t\t\n\t\tx[0] = 200;\n\t\tx[1] = -100;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%lf %lf\", &v[i].x, &v[i].y);\n\t\t\tcout << v[i] << \" \";\n\n\t\t\tx[0] = min(x[0],v[i].x);\n\t\t\tx[1] = max(x[1],v[i].x);\n\t\t}\n\t\tcout << endl;\n\n\t\tdouble lo = x[0], hi = x[1];\n\t\tint ts = 60;\n\t\twhile (ts--) {\n\t\t\tdouble q1 = (lo+lo+hi)/3;\n\t\t\tdouble q2 = (lo+hi+hi)/3;\n\t\t\t\n\t\t\tif (solve(q1) < solve(q2))\n\t\t\t\tlo = q1;\n\t\t\telse\n\t\t\t\thi = q2;\n\t\t}\n\n\t\tprintf(\"%.20f\\n\", solve(lo));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 200\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n  double getArea(){ return r*r*pi;}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Point p,Circle c){ return abs(p-c.c)-c.r<-eps;}\nbool on(Point p,Circle c){ return fabs(abs(p-c.c)-c.r)<eps;}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\ndouble getArea(Polygon p){\n  double res=0;\n  for(int i=1;i<p.size()-1;i++)res+=cross(p[i]-p[0],p[i+1]-p[0])/2.0;\n  return res;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nbool iscrossLC(Line l,Circle c){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  if(!iscrossLC(s,c))return res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(abs(pp.s-s.p1)-abs(pp.f-s.p1)<eps)swap(pp.f,pp.s);\n  if(ccw(s.p1,s.p2,pp.f)==0)res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0)res.push_back(pp.s);\n  return res;\n}\n\nbool AllIn(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceLP(L,c.c)-c.r<-eps || ccw(L.p1,L.p2,c.c)==-1)return false;\n  }\n  return true;\n}\n\nbool AllOut(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\ndouble getCommonAreaTC(Polygon p,Circle c){\n  double res=getArea(p),carea=c.getArea();\n  int n=p.size();\n  bool flag=false;\n  if(res<0.0){\n    flag=true;\n    reverse(p.begin(),p.end());\n    res=getArea(p);\n  }\n  vector<Point> s;\n  if(AllIn(p,c))return carea;\n  if(AllOut(p,c)) return 0.0;\n  int start=-1;\n  for(int i=0;i<n;i++){\n    if((c.r-abs(p[i]-c.c))<-eps)start=i;\n  }\n  if(start==-1)return res;\n  for(int i=0;i<n;i++){\n    vector<Point> vp=getCrossPointSC(c,Segment(p[(i+start)%n],\n\t\t\t\t\t       p[(i+1+start)%n]));    \n    for(int j=0;j<vp.size();j++){\n      bool b=true;\n      for(int k=0;k<s.size();k++)if(s[k]==vp[j])b=false;\n      if(b)s.push_back(vp[j]);\n    }\n  }\n\n  s.push_back(s[0]);\n  s.erase(s.begin());\n\n  for(int i=0;i<s.size();i+=2){\n    Point p1=s[i];\n    Point p2=s[i+1];\n    if(p1==p2)continue;\n    Polygon t;\n    t.push_back(p1);\n    t.push_back(p2);\n    t.push_back(c.c);\n    double narea=getArea(convex_cut(p,Line(p2,p1)));\n    if(narea<eps)continue;\n    res-=narea;\n    double ra=acos(dot(p1-c.c,p2-c.c)/(abs(p1-c.c)*abs(p2-c.c)))*(360/(2*pi));\n    if(ccw(c.c,p1,p2)==-1)ra=180.0;\n    res+=((carea*ra/360.0)-getArea(t));\n  }\n  if(!flag)return res;\n  return -res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++){\n    Polygon t;\n    t.push_back(p[0]);\n    t.push_back(p[i]);\n    t.push_back(p[i+1]);\n    res+=getCommonAreaTC(t,c);\n  }\n  return res;\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,40){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*(m1-r),r));\n    double res2=getCommonAreaPC(p,Circle(a+v*(m2-r),r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*(L-r),r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=abs(b-a);\n    FOR(k,0,40){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <map>\n#include <set>\n#include <vector>\n#include <bitset>\nusing namespace std;\n//#define f(i, x, y) for (int i = x; i <= y; ++i)\n#define fd(i, x, y) for (int i = x; i >= y; --i)\n#define rep(i, x, y) for (int i = x; i <= y; ++i)\n#define repd(i, x, y) for (int i = x; i >= y; --i)\n#define sqr(x) ((x)*(x))\n\nconst int maxn=20;\ndouble eps;\nint n,R,xl=100,xr=0,yl=100,yr=0;\nstruct node{\n\tint x,y;\n\tvoid read(){\n\t\tcin >> x >> y;\n\t}\n}p[maxn];\n\nvoid init()\n{\n\tcin >> n >> R;\n\tfor(int i = 1;i <= n;i++)\n\t{\n\t\tp[i].read();\n\t\txl=min(xl,p[i].x);\n\t\txr=max(xr,p[i].x);\n\t\tyl=min(yl,p[i].y);\n\t\tyr=max(yr,p[i].y);\n\t}\n\tp[0]=p[n];\n\tif (max(xr, yr) > 30) eps = 1e-8; else eps=1e-12;\n}\n\ndouble f(double xx,double x,double y)\n{\n\tif(xx<x-R)return 0;\n\tif(xx>x+R)return 0;\n\tdouble mi,mx;\n\tmi=y-sqrt(sqr(R)-sqr(xx-x));\n\tmx=y+sqrt(sqr(R)-sqr(xx-x));\n\tdouble y1=100,y2=0;\n\tfor(int i = 0;i < n;i++)\n\t{\n\t\tif((p[i].x-xx)*(p[i+1].x-xx)<eps)\n\t\t{\n\t\t\tif(p[i].x==p[i+1].x)\n\t\t\t{\n\t\t\t\ty2=max(y2,(double)max(p[i].y,p[i+1].y));\n\t\t\t\ty1=min(y1,(double)min(p[i].y,p[i+1].y));\n\t\t\t}\n\t\t\telse\n\t\t\t{\t\n\t\t\t\tdouble yy=p[i].y+(p[i+1].y-p[i].y)*(xx-p[i].x)/(p[i+1].x-p[i].x);\n\t\t\t\ty2=max(y2,yy);\n\t\t\t\ty1=min(y1,yy);\n\t\t\t}\n\t\t}\n\t}\n\tmi=max(y1,mi);\n\tmx=min(y2,mx);\n\treturn max(mx-mi,0.0);\n}\n\ndouble sum(double l,double r,double x,double y)\n{\n\tdouble mid=(l+r)/2;\n\treturn (f(l,x,y)+f(r,x,y)+4*f(mid,x,y))*(r-l)/6;\n}\n\ndouble simpson(double l,double r,double x,double y)\n{\n\tif (l > r) return 0;\n\tdouble mid=(l+r)/2;\n\tdouble s=sum(l,r,x,y),s1=sum(l,mid,x,y),s2=sum(mid,r,x,y);\n\tif(abs(s-s1-s2)<eps)return s;\n\treturn simpson(l,mid,x,y)+simpson(mid,r,x,y);\n}\n\ndouble gets(double x,double y)\n{\n\t//printf(\"%.6lf\\n\",simpson(xl,xr,x,y));\n\treturn simpson(max(x-R,(double)xl),min((double)xr,x+R),x,y);\n}\n\ndouble gets(double x)\n{\n\tdouble l=yl,r=yr;\n\twhile(r-l>eps)\n\t{\n\t\tdouble len=(r-l)/3;\n\t\tif(gets(x,l+len)>gets(x,r-len))r=r-len;\n\t\telse l=l+len;\n\t}\n\treturn gets(x,(l+r)/2);\n}\n\nvoid solve()\n{\n\tdouble l=xl,r=xr;\n\twhile(r-l>eps)\n\t{\n\t\tdouble len=(r-l)/3;\n\t\tif(gets(l+len)>gets(r-len))r=r-len;\n\t\telse l=l+len;\n\t}\n\tprintf(\"%.12lf\\n\",gets((l+r)/2));\n\t//printf(\"%.12lf %.12lf\\n\",l,r);\n\t//printf(\"%.12lf\\n\",gets(l + 0.1));\n\t//printf(\"%.12lf\\n\",gets(l - 0.1));\n}\nint main()\n{\t\n\tcin.sync_with_stdio(0);\n\tinit();\n\t//if (n == 3 && R == 1 && p[1].x == 0 && p[1].y == 0 && p[2].x == 2 && p[2].y == 1 && p[3].x == 1 && p[3].y == 3)\n//\t\tprintf(\"2.113100\\n\");\n//\telse \n\tsolve();\n\t/*double qmax = 0;\n\tfor (double i = 0; i <= 3; i += 0.001)\n\tfor (double j = 0; j <= 3; j += 0.001)\n\t\tqmax = max(qmax,gets(i, j));\n\tprintf(\"%.12lf\\n\",qmax);*/\n\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-9)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n\nPoint calc_ps(Polygon poly) {\n  poly = andrewScan(poly);\n  Point mp = poly[0];\n  double rate = 1; // 0.5???????????¨???\n  int max_pos;\n  double eps = 1e-10; // 1e-20???????????¨???\n  while( rate > eps ) {\n    rep(_,60){ // 70???????????¨???\n      max_pos = 0;\n      REP(j,1,(int)poly.size()) {\n        double dist1 = abs(mp-poly[max_pos]);\n        double dist2 = abs(mp-poly[j]);\n\tif( LT(dist1,dist2) ) max_pos = j;\n      }\n      mp.x += ( poly[max_pos].x - mp.x ) * rate;\n      mp.y += ( poly[max_pos].y - mp.y ) * rate;\n    }\n    rate *= 0.5;\n  }\n  return mp;\n}\n\nPoint getCentroidOfConvex(Polygon& poly){\n  double area = getArea(poly);\n  int V = poly.size();\n  assert( !equals(area,0.0) );\n  double x = 0, y = 0;\n  rep(i,(int)poly.size()) {\n    x += ( poly[i].x + poly[(i+1)%V].x ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n    y += ( poly[i].y + poly[(i+1)%V].y ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n  }\n  return Point(x/(6.0*area),y/(6.0*area));\n}\n\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  double maxi;\n  Point mp = calc_ps(poly);\n  maxi = getCommonAreaPolygonCircle(poly,mp,r);\n  double rate = 1.0;\n  double eps = 1e-10;\n  while( LT(eps,rate) ) {\n    rep(_,70) {\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      assert( !equals(max_area,-1) );\n      mp = np;\n      if( LT(maxi,max_area) ) maxi = max_area;\n    }\n    rate *= 0.5;\n  }\n  rep(__,3) {\n    Point mp = calc_ps(poly);\n    double rate = 1.0;\n    double eps = 1e-10;\n    while( LT(eps,rate) ) {\n      rep(_,70) {\n\tdouble max_area = -1; \n\tPoint np;\n\trep(i,n) {\n\t  Point tp = mp;\n\t  tp.x += ( poly[i].x - mp.x ) * rate;\n\t  tp.y += ( poly[i].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,tp,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t    np = tp;\n\t  }\n\t}\n\tif( rand() % 50 == 0 ) {\n\t  int v = rand() % n;\n\t  np.x = ( poly[v].x - mp.x ) * rate;\n\t  np.y = ( poly[v].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,np,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t  }\n\t}\n\tassert( !equals(max_area,-1) );\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      rate *= 0.5;\n    }\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  srand((unsigned int)time(NULL));\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  //cout << getArea(poly) << endl;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/***************************************\n    codeforces = topcoder = sahedsohel\n    IIT,Jahangirnagar University(42)\n****************************************/\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <iterator>\n#include <utility>\nusing namespace std;\n\n#define ll long long int\n#define ull unsigned long long int\n//#define inf (INT_MAX/10)\n#define linf (LLONG_MAX/10LL)\n#define sc(a) scanf(\"%d\",&a)\n#define sc2(a,b) scanf(\"%d%d\",&a,&b)\n#define sc3(a,b,c) scanf(\"%d%d%d\",&a,&b,&c)\n#define sc4(a,b,c,d) scanf(\"%d%d%d%d\",&a,&b,&c,&d)\n#define fl(c,i,n) for(i=c;i<n;i++)\n#define f(i,n) for(i=0;i<n;i++)\n#define mem(a) memset(a,0,sizeof(a))\n#define memn(a) memset(a,-1,sizeof(a))\n#define pb push_back\n#define pp pop_back()\n#define aov(a) a.begin(),a.end()\n#define mpr make_pair\n#define PI (2.0*acos(0.0)) //#define PI acos(-1.0)\n#define xx first\n#define yy second\n#define mxv(a) *max_element(aov(a))\n#define mnv(a) *min_element(aov(a))\n#define LB(a,x) (lower_bound(aov(a),x)-a.begin())\n#define UB(a,x) (upper_bound(aov(a),x)-a.begin())\n#define to_c_string(a) a.c_str()\n#define strtoint(c) atoi(&c[0])\n#define pii pair< int , int >\n#define pll pair< ll , ll >\n#define pcs(a) printf(\"Case %d: \", a)\n#define nl puts(\"\")\n#define dbg(x) cout<<#x<<\" : \"<<x<<endl\n\ntemplate <class T> inline T bigmod(T p,T e,T M){ll ret = 1;for(; e > 0; e >>= 1){if(e & 1) ret = (ret * p) % M;p = (p * p) % M;}return (T)ret;}\ntemplate <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}   // M is prime}\ntemplate <class T> inline T bpow(T p,T e){ll ret = 1;for(; e > 0; e >>= 1){if(e & 1) ret = (ret * p);p = (p * p);}return (T)ret;}\n\nint toInt(string s){int sm;stringstream ss(s);ss>>sm;return sm;}\nint toLlint(string s){long long int sm;stringstream ss(s);ss>>sm;return sm;}\n\n\n///int mnth[]={-1,31,28,31,30,31,30,31,31,30,31,30,31};  //Not Leap Year\n///int dx[]={1,1,0,-1,-1,-1,0,1};int dy[]={0,1,1,1,0,-1,-1,-1};//8 direction\n///int dx[]={2,1,-1,-2,-2,-1,1,2};int dy[]={1,2,2,1,-1,-2,-2,-1};//Knight Direction\n///int dx[]={-1,-1,+0,+1,+1,+0};int dy[]={-1,+1,+2,+1,-1,-2}; //Hexagonal Direction\n///const double eps=1e-6;\n///int dx[]={0,1,0,-1};int dy[]={1,0,-1,0}; //4 Direction\n\n/*****************************************************************/\n/// ////////////////////   GET SET GO    ////////////////////// ///\n/*****************************************************************/\n\n#define M 50025\n#define MD 100000007LL\n#define MX 2000\n\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\nconst double inf=1e20;\nconst int maxp=25;\nint dblcmp(double d){if (fabs(d)<eps)return 0;return d>eps?1:-1;}\ninline double sqr(double x){return x*x;}\nstruct point\n{\n    double x,y;\n    point()             {                                    }\n    point(double _x,double _y){    x = _x; y = _y;           }\n    void input()        {   int a,b;scanf(\"%d%d\",&a,&b);x=a*1.0,y=b*1.0;           }// {   scanf(\"%lf%lf\",&x,&y);           }\n    void output()       {   printf(\"%.2f %.2f\\n\",x,y);       }\n    bool operator==(point a)const{\n        return dblcmp(a.x - x) == 0 && dblcmp(a.y - y) == 0;\n    }\n    bool operator<(point a)const{\n        return dblcmp(a.x - x) == 0 ? dblcmp(y - a.y) < 0 : x < a.x;\n    }\n    point operator-(point a)const{\n        return point(x-a.x, y-a.y);\n    }\n    double len()        {   return hypot(x, y);              }\n    double len2()       {   return x * x + y * y;            }\n    double distance(point p){return hypot(x - p.x, y - p.y); }\n    point add(point p)  {   return point(x + p.x, y + p.y);  }\n    point sub(point p)  {   return point(x - p.x, y - p.y);  }\n    point mul(double b) {   return point(x * b, y * b);      }\n    point div(double b) {   return point(x / b, y / b);      }\n    double dot(point p) {   return x*p.x+y*p.y;              }\n    double det(point p) {   return x*p.y-y*p.x;              }\n    double rad(point a,point b){\n        point p=*this;\n        return fabs(atan2(fabs(a.sub(p).det(b.sub(p))),a.sub(p).dot(b.sub(p))));\n    }\n    point trunc(double r){\n        double l=len();\n        if (!dblcmp(l))return *this;\n        r/=l;\n        return point(x*r,y*r);\n    }\n    point rotleft()     {   return point(-y,x);              }\n    point rotright()    {   return point(y,-x);              }\n    point rotate(point p,double angle){\n        point v=this->sub(p);\n        double c=cos(angle),s=sin(angle);\n        return point(p.x+v.x*c-v.y*s,p.y+v.x*s+v.y*c);\n    }\n};\n\nstruct line\n{\n    point a,b;\n    line()              {                                    }\n    line(point _a,point _b){ a=_a; b=_b;                     }\n    bool operator==(line v){ return (a==v.a)&&(b==v.b);      }\n    line(point p,double angle){\n        a=p;\n        if (dblcmp(angle-pi/2)==0){\n            b=a.add(point(0,1));\n        }else{\n            b=a.add(point(1,tan(angle)));\n        }\n    }\n    //ax+by+c=0\n    line(double _a,double _b,double _c){\n        if (dblcmp(_a)==0){\n            a=point(0,-_c/_b);\n            b=point(1,-_c/_b);\n        }else if (dblcmp(_b)==0){\n            a=point(-_c/_a,0);\n            b=point(-_c/_a,1);\n        }else{\n            a=point(0,-_c/_b);\n            b=point(1,(-_c-_a)/_b);\n        }\n    }\n    void input()        {   a.input(); b.input();            }\n    void adjust()       {   if(b<a)swap(a,b);                }\n    double length()     {   return a.distance(b);            }\n    double angle(){\n        double k=atan2(b.y-a.y,b.x-a.x);\n        if (dblcmp(k)<0)k+=pi;\n        if (dblcmp(k-pi)==0)k-=pi;\n        return k;\n    }\n    int relation(point p){\n        int c=dblcmp(p.sub(a).det(b.sub(a)));\n        if (c<0)return 1;\n        if (c>0)return 2;\n        return 3;\n    }\n    bool pointonseg(point p){\n        return dblcmp(p.sub(a).det(b.sub(a)))==0&&dblcmp(p.sub(a).dot(p.sub(b)))<=0;\n    }\n    bool parallel(line v){\n        return dblcmp(b.sub(a).det(v.b.sub(v.a)))==0;\n    }\n    int segcrossseg(line v){\n        int d1=dblcmp(b.sub(a).det(v.a.sub(a)));\n        int d2=dblcmp(b.sub(a).det(v.b.sub(a)));\n        int d3=dblcmp(v.b.sub(v.a).det(a.sub(v.a)));\n        int d4=dblcmp(v.b.sub(v.a).det(b.sub(v.a)));\n        if ((d1^d2)==-2&&(d3^d4)==-2)return 2;\n        return (d1==0&&dblcmp(v.a.sub(a).dot(v.a.sub(b)))<=0||\n            d2==0&&dblcmp(v.b.sub(a).dot(v.b.sub(b)))<=0||\n            d3==0&&dblcmp(a.sub(v.a).dot(a.sub(v.b)))<=0||\n            d4==0&&dblcmp(b.sub(v.a).dot(b.sub(v.b)))<=0);\n    }\n    int segcrossseg_inside(line v){\n        if(v.pointonseg(a) || v.pointonseg(b) || pointonseg(v.a) || pointonseg(v.b)) return 0;\n        int d1=dblcmp(b.sub(a).det(v.a.sub(a)));\n        int d2=dblcmp(b.sub(a).det(v.b.sub(a)));\n        int d3=dblcmp(v.b.sub(v.a).det(a.sub(v.a)));\n        int d4=dblcmp(v.b.sub(v.a).det(b.sub(v.a)));\n        if ((d1^d2)==-2&&(d3^d4)==-2)return 1;\n        return (d1==0&&dblcmp(v.a.sub(a).dot(v.a.sub(b)))<=0||\n            d2==0&&dblcmp(v.b.sub(a).dot(v.b.sub(b)))<=0||\n            d3==0&&dblcmp(a.sub(v.a).dot(a.sub(v.b)))<=0||\n            d4==0&&dblcmp(b.sub(v.a).dot(b.sub(v.b)))<=0);\n    }\n    int linecrossseg(line v){//*this seg v line\n        int d1=dblcmp(b.sub(a).det(v.a.sub(a)));\n        int d2=dblcmp(b.sub(a).det(v.b.sub(a)));\n        if ((d1^d2)==-2)return 2;\n        return (d1==0||d2==0);\n    }\n    int linecrossline(line v){\n        if ((*this).parallel(v)){\n            return v.relation(a)==3;\n        }\n        return 2;\n    }\n    point crosspoint(line v){\n        double a1=v.b.sub(v.a).det(a.sub(v.a));\n        double a2=v.b.sub(v.a).det(b.sub(v.a));\n        return point((a.x*a2-b.x*a1)/(a2-a1),(a.y*a2-b.y*a1)/(a2-a1));\n    }\n    double dispointtoline(point p){\n        return fabs(p.sub(a).det(b.sub(a)))/length();\n    }\n    double dispointtoseg(point p){\n        if (dblcmp(p.sub(b).dot(a.sub(b)))<0||dblcmp(p.sub(a).dot(b.sub(a)))<0){\n            return min(p.distance(a),p.distance(b));\n        }\n        return dispointtoline(p);\n    }\n    point lineprog(point p){\n        return a.add(b.sub(a).mul(b.sub(a).dot(p.sub(a))/b.sub(a).len2()));\n    }\n    point symmetrypoint(point p){\n        point q=lineprog(p);\n        return point(2*q.x-p.x,2*q.y-p.y);\n    }\n};\n\nstruct circle\n{\n    point p;\n    double r;\n    circle()            {                                    }\n    circle(point _p,double _r):     p(_p),r(_r){             };\n    circle(double x,double y,double _r): p(point(x,y)),r(_r){};\n    circle(point a,point b,point c){\n        p=line(a.add(b).div(2),a.add(b).div(2).add(b.sub(a).rotleft())).crosspoint(line(c.add(b).div(2),c.add(b).div(2).add(b.sub(c).rotleft())));\n        r=p.distance(a);\n    }\n    circle(point a,point b,point c,bool t){\n        line u,v;\n        double m=atan2(b.y-a.y,b.x-a.x),n=atan2(c.y-a.y,c.x-a.x);\n        u.a=a;\n        u.b=u.a.add(point(cos((n+m)/2),sin((n+m)/2)));\n        v.a=b;\n        m=atan2(a.y-b.y,a.x-b.x),n=atan2(c.y-b.y,c.x-b.x);\n        v.b=v.a.add(point(cos((n+m)/2),sin((n+m)/2)));\n        p=u.crosspoint(v);\n        r=line(a,b).dispointtoseg(p);\n    }\n    void input()        {   p.input();scanf(\"%lf\",&r);       }\n    void output() { printf(\"%.2lf %.2lf %.2lf\\n\",p.x,p.y,r); }\n    bool operator==(circle v){\n        return ((p==v.p)&&dblcmp(r-v.r)==0);\n    }\n    bool operator<(circle v)const{\n        return ((p<v.p)||(p==v.p)&&dblcmp(r-v.r)<0);\n    }\n    double area()       {   return pi*sqr(r);                }\n    double circumference(){ return 2*pi*r;                   }\n    int relation(point b){\n        double dst=b.distance(p);\n        if (dblcmp(dst-r)<0)return 2;\n        if (dblcmp(dst-r)==0)return 1;\n        return 0;\n    }\n    int relationseg(line v){\n        double dst=v.dispointtoseg(p);\n        if (dblcmp(dst-r)<0)return 2;\n        if (dblcmp(dst-r)==0)return 1;\n        return 0;\n    }\n    int relationline(line v){\n        double dst=v.dispointtoline(p);\n        if (dblcmp(dst-r)<0)return 2;\n        if (dblcmp(dst-r)==0)return 1;\n        return 0;\n    }\n    int getcircle(point a,point b,double r,circle&c1,circle&c2){\n        circle x(a,r),y(b,r);\n        int t=x.pointcrosscircle(y,c1.p,c2.p);\n        if (!t)return 0;\n        c1.r=c2.r=r;\n        return t;\n    }\n    int getcircle(line u,point q,double r1,circle &c1,circle &c2){\n        double dis=u.dispointtoline(q);\n        if (dblcmp(dis-r1*2)>0)return 0;\n        if (dblcmp(dis)==0){\n            c1.p=q.add(u.b.sub(u.a).rotleft().trunc(r1));\n            c2.p=q.add(u.b.sub(u.a).rotright().trunc(r1));\n            c1.r=c2.r=r1;\n            return 2;\n        }\n        line u1=line(u.a.add(u.b.sub(u.a).rotleft().trunc(r1)),u.b.add(u.b.sub(u.a).rotleft().trunc(r1)));\n        line u2=line(u.a.add(u.b.sub(u.a).rotright().trunc(r1)),u.b.add(u.b.sub(u.a).rotright().trunc(r1)));\n        circle cc=circle(q,r1);\n        point p1,p2;\n        if (!cc.pointcrossline(u1,p1,p2))cc.pointcrossline(u2,p1,p2);\n        c1=circle(p1,r1);\n        if (p1==p2)     {   c2=c1;return 1;                  }\n        c2=circle(p2,r1);\n        return 2;\n    }\n    int getcircle(line u,line v,double r1,circle &c1,circle &c2,circle &c3,circle &c4){\n        if (u.parallel(v))return 0;\n        line u1=line(u.a.add(u.b.sub(u.a).rotleft().trunc(r1)),u.b.add(u.b.sub(u.a).rotleft().trunc(r1)));\n        line u2=line(u.a.add(u.b.sub(u.a).rotright().trunc(r1)),u.b.add(u.b.sub(u.a).rotright().trunc(r1)));\n        line v1=line(v.a.add(v.b.sub(v.a).rotleft().trunc(r1)),v.b.add(v.b.sub(v.a).rotleft().trunc(r1)));\n        line v2=line(v.a.add(v.b.sub(v.a).rotright().trunc(r1)),v.b.add(v.b.sub(v.a).rotright().trunc(r1)));\n        c1.r=c2.r=c3.r=c4.r=r1;\n        c1.p=u1.crosspoint(v1);\n        c2.p=u1.crosspoint(v2);\n        c3.p=u2.crosspoint(v1);\n        c4.p=u2.crosspoint(v2);\n        return 4;\n    }\n    int getcircle(circle cx,circle cy,double r1,circle&c1,circle&c2){\n        circle x(cx.p,r1+cx.r),y(cy.p,r1+cy.r);\n        int t=x.pointcrosscircle(y,c1.p,c2.p);\n        if (!t)return 0;\n        c1.r=c2.r=r1;\n        return t;\n    }\n    int pointcrossline(line v,point &p1,point &p2){//求与?段交要先判断relationseg\n        if (!(*this).relationline(v))return 0;\n        point a=v.lineprog(p);\n        double d=v.dispointtoline(p);\n        d=sqrt(r*r-d*d);\n        if (dblcmp(d)==0){  p1=a; p2=a; return 1;            }\n        p1=a.sub(v.b.sub(v.a).trunc(d));\n        p2=a.add(v.b.sub(v.a).trunc(d));\n        return 2;\n    }\n    int relationcircle(circle v){\n        double d=p.distance(v.p);\n        if (dblcmp(d-r-v.r)>0)return 5;\n        if (dblcmp(d-r-v.r)==0)return 4;\n        double l=fabs(r-v.r);\n        if (dblcmp(d-r-v.r)<0&&dblcmp(d-l)>0)return 3;\n        if (dblcmp(d-l)==0)return 2;\n        if (dblcmp(d-l)<0)return 1;\n    }\n    int pointcrosscircle(circle v,point &p1,point &p2){\n        int rel=relationcircle(v);\n        if (rel==1||rel==5)return 0;\n        double d=p.distance(v.p);\n        double l=(d+(sqr(r)-sqr(v.r))/d)/2;\n        double h=sqrt(sqr(r)-sqr(l));\n        p1=p.add(v.p.sub(p).trunc(l).add(v.p.sub(p).rotleft().trunc(h)));\n        p2=p.add(v.p.sub(p).trunc(l).add(v.p.sub(p).rotright().trunc(h)));\n        if (rel==2||rel==4)return 1;\n        return 2;\n    }\n    int tangentline(point q,line &u,line &v){\n        int x=relation(q);\n        if (x==2)return 0;\n        if (x==1){\n            u=line(q,q.add(q.sub(p).rotleft()));\n            v=u; return 1;\n        }\n        double d=p.distance(q);\n        double l=sqr(r)/d;\n        double h=sqrt(sqr(r)-sqr(l));\n        u=line(q,p.add(q.sub(p).trunc(l).add(q.sub(p).rotleft().trunc(h))));\n        v=line(q,p.add(q.sub(p).trunc(l).add(q.sub(p).rotright().trunc(h))));\n        return 2;\n    }\n    double areacircle(circle v){\n        int rel=relationcircle(v);\n        if (rel>=4)return 0.0;\n        if (rel<=2)return min(area(),v.area());\n        double d=p.distance(v.p);\n        double hf=(r+v.r+d)/2.0;\n        double ss=2*sqrt(hf*(hf-r)*(hf-v.r)*(hf-d));\n        double a1=acos((r*r+d*d-v.r*v.r)/(2.0*r*d));\n        a1=a1*r*r;\n        double a2=acos((v.r*v.r+d*d-r*r)/(2.0*v.r*d));\n        a2=a2*v.r*v.r;\n        return a1+a2-ss;\n    }\n    double areatriangle(point a,point b){\n        if (dblcmp(p.sub(a).det(p.sub(b))==0))return 0.0;\n        point q[5];\n        int len=0;\n        q[len++]=a;\n        line l(a,b);\n        point p1,p2;\n        if (pointcrossline(l,q[1],q[2])==2){\n            if (dblcmp(a.sub(q[1]).dot(b.sub(q[1])))<0)q[len++]=q[1];\n            if (dblcmp(a.sub(q[2]).dot(b.sub(q[2])))<0)q[len++]=q[2];\n        }\n        q[len++]=b;\n        if (len==4&&(dblcmp(q[0].sub(q[1]).dot(q[2].sub(q[1])))>0))swap(q[1],q[2]);\n        double res=0;\n        int i;\n        for (i=0;i<len-1;i++){\n            if (relation(q[i])==0||relation(q[i+1])==0){\n                double arg=p.rad(q[i],q[i+1]);\n                res+=r*r*arg/2.0;\n            }\n            else res+=fabs(q[i].sub(p).det(q[i+1].sub(p))/2.0);\n        }\n        return res;\n    }\n};\nstruct polygon\n{\n    int n;\n    point p[maxp];\n    line l[maxp];\n    void input(int _n){\n        n=_n;\n        for (int i=0;i<n;i++)   p[i].input();\n    }\n    void add(point q)   {   p[n++]=q;                        }\n    void getline(){\n        for (int i=0;i<n;i++)\n            l[i]=line(p[i],p[(i+1)%n]);\n    }\n    struct cmp{\n        point p;\n        cmp(const point &p0){p=p0;}\n        bool operator()(const point &aa,const point &bb){\n            point a=aa,b=bb;\n            int d=dblcmp(a.sub(p).det(b.sub(p)));\n            if (d==0)\n                return dblcmp(a.distance(p)-b.distance(p))<0;\n            return d>0;\n        }\n    };\n    double areacircle(circle c){\n        int i,j,k,l,m;\n        double ans=0;\n        for (i=0;i<n;i++){\n            int j=(i+1)%n;\n            if (dblcmp(p[j].sub(c.p).det(p[i].sub(c.p)))>=0)\n                ans+=c.areatriangle(p[i],p[j]);\n            else ans-=c.areatriangle(p[i],p[j]);\n            //cerr<<i<<\" \"<<ans<<endl;\n        }\n        //cerr<<n<<\" \"<<c.r<<\" => \"<<ans<<endl;\n        return fabs(ans);\n    }\n};\n\nint n,r;\npolygon rs,a;\ncircle q;\npoint pl,ph;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);cin.tie(0);\n//    freopen(\"in.txt\",\"r\",stdin);\n    int t,i,j,k;\n\n    double ans=0.0,lox,loy,hix,hiy;\n\n    lox=loy=LLONG_MAX;\n    hix=hiy=-LLONG_MAX;\n    cin>>n>>r;\n    a.n=0;\n    rs.n=0;\n    f(i,n)\n    {\n        cin>>j>>k;\n        a.p[a.n].x=j;\n        a.p[a.n++].y=k;\n        rs.p[rs.n].x=j;\n        rs.p[rs.n++].y=k;\n        lox=min(lox,j*1.0);\n        hix=max(hix,j*1.0);\n\n        loy=min(loy,k*1.0);\n        hiy=max(hiy,k*1.0);\n    }\n\n    double dx,dy,x,y;\n    dx=(hix-lox)/(MX*1.0);\n    dy=(hiy-loy)/(MX*1.0);\n    for(i=0,x=lox;i<MX;i++,x+=dx)\n    {\n        for(j=0,y=loy;j<MX;j++,y+=dy)\n        {\n            q.p=point(x,y);\n            q.r=r*1.0;\n            ans=max(ans,rs.areacircle(q));\n        }\n        //cerr<<x<<\" \"<<y<<endl;\n        //cerr<<i<<\" \"<<ans<<endl;\n    }\n\n\n    cout<<setprecision(10)<<fixed<<ans<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1000\n#define linf 1e18\n#define eps (1e-10)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Circle c,Point p){\n  if(abs(c.c-p)-c.r<eps)return true;\n  return false;\n}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nbool intersect(Circle c,Segment s){\n  if(getDistanceSP(s,c.c)-c.r<-eps)return true;\n  return false;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  if(cross(a,b)<0.0)r=360.0-r;\n  return r;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(ccw(s.p1,s.p2,pp.f)==0)res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0)res.push_back(pp.s);\n  return res;\n}\n\ndouble getCommonAreaTC(Point a,Point b,Circle c){\n  double res=cross(a-c.c,b-c.c)/2.0;\n  bool flag=true;\n  if(res<0.0){\n    swap(a,b);\n    res=-res;\n    flag=false;\n  }\n  if(ccw(a,b,c.c)==0 || ccw(a,b,c.c)==2 || ccw(a,b,c.c)==-2)return 0;\n  if(in(c,a) && in(c,b));\n  else if(in(c,a) && !in(c,b)){\n    vector<Point> vp1=getCrossPointSC(c,Segment(b,a));\n    vector<Point> vp2=getCrossPointSC(c,Segment(b,c.c)); \n    res+=(c.r*c.r*pi)*(getAngle(vp1[0]-c.c,vp2[0]-c.c)/360.0);\n    res-=cross(vp1[0]-c.c,vp2[0]-c.c)/2.0;\n    res-=cross(vp2[0]-b,vp1[0]-b)/2.0;\n  }\n  else if(!in(c,a) && in(c,b)){\n    vector<Point> vp1=getCrossPointSC(c,Segment(a,c.c));\n    vector<Point> vp2=getCrossPointSC(c,Segment(a,b));\n    res+=(c.r*c.r*pi)*(getAngle(vp1[0]-c.c,vp2[0]-c.c)/360.0);\n    res-=cross(vp1[0]-c.c,vp2[0]-c.c)/2.0;\n    res-=cross(vp2[0]-a,vp1[0]-a)/2.0;\n  }\n  else {\n    if(intersect(c,Segment(a,b))){\n      vector<Point> vp=getCrossPointSC(c,Segment(a,b));\n      Point m=vp[0]+(vp[1]-vp[0])/2.0;\n      res=getCommonAreaTC(a,m,c)+getCommonAreaTC(m,b,c);\n    }\n    else {\n      vector<Point> vp1=getCrossPointSC(c,Segment(a,c.c));\n      vector<Point> vp2=getCrossPointSC(c,Segment(b,c.c));\n      res=(c.r*c.r*pi)*(getAngle(vp1[0]-c.c,vp2[0]-c.c)/360.0);\n    }\n  }\n  if(flag)return res;\n  return -res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  int n=p.size();\n  FOR(i,0,n){\n    res+=getCommonAreaTC(p[i],p[(i+1)%n],c);\n  }\n  return abs(res);\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=abs(g-a)*2;\n  FOR(k,0,40){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*L,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=abs(b-a);\n\n    FOR(k,0,40){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2;\n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-9)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n\nPoint calc_ps(Polygon poly) {\n  poly = andrewScan(poly);\n  Point mp = poly[0];\n  double rate = 1; // 0.5???????????¨???\n  int max_pos;\n  double eps = 1e-10; // 1e-20???????????¨???\n  while( rate > eps ) {\n    rep(_,60){ // 70???????????¨???\n      max_pos = 0;\n      REP(j,1,(int)poly.size()) {\n        double dist1 = abs(mp-poly[max_pos]);\n        double dist2 = abs(mp-poly[j]);\n\tif( LT(dist1,dist2) ) max_pos = j;\n      }\n      mp.x += ( poly[max_pos].x - mp.x ) * rate;\n      mp.y += ( poly[max_pos].y - mp.y ) * rate;\n    }\n    rate *= 0.5;\n  }\n  return mp;\n}\n\nPoint getCentroidOfConvex(Polygon& poly){\n  double area = getArea(poly);\n  int V = poly.size();\n  assert( !equals(area,0.0) );\n  double x = 0, y = 0;\n  rep(i,(int)poly.size()) {\n    x += ( poly[i].x + poly[(i+1)%V].x ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n    y += ( poly[i].y + poly[(i+1)%V].y ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n  }\n  return Point(x/(6.0*area),y/(6.0*area));\n}\n\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  double maxi;\n  Point mp = calc_ps(poly);\n  maxi = getCommonAreaPolygonCircle(poly,mp,r);\n  double rate = 1.0;\n  double eps = 1e-10;\n  while( LT(eps,rate) ) {\n    rep(_,70) {\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      assert( !equals(max_area,-1) );\n      mp = np;\n      if( LT(maxi,max_area) ) maxi = max_area;\n    }\n    rate *= 0.5;\n  }\n  rep(__,1) {\n    Point mp = calc_ps(poly);\n    double rate = 1.0;\n    double eps = 1e-10;\n    while( LT(eps,rate) ) {\n      rep(_,70) {\n\tdouble max_area = -1; \n\tPoint np;\n\trep(i,n) {\n\t  Point tp = mp;\n\t  tp.x += ( poly[i].x - mp.x ) * rate;\n\t  tp.y += ( poly[i].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,tp,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t    np = tp;\n\t  }\n\t}\n\tif( rand() % 50 == 0 ) {\n\t  int v = rand() % n;\n\t  np.x = ( poly[v].x - mp.x ) * rate;\n\t  np.y = ( poly[v].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,np,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t  }\n\t}\n\tassert( !equals(max_area,-1) );\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      rate *= 0.5;\n    }\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  srand((unsigned int)time(NULL));\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  //cout << getArea(poly) << endl;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector< P > vecp;\n\nstruct S{\n  P p,q;\n  S(P p,P q) : p(p),q(q) {}  \n};\n\nstruct C{\n  P p;  double r;\n  C(P p,double r):p(p),r(r){}\n  C(double x,double y,double rr){\n    p=P(x,y);\n    r=rr;\n  }\n};\n\ndouble eps=1e-8,  PI=acos(-1),  PI2=PI*2.0;\n\nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\nbool eq(P a,P b){return (abs(a-b)<eps);}\ndouble Sqrt(double x){  return ( x<0 ? 0.0 : sqrt(x) ); }\ndouble dot(P a,P b){return real(b*conj(a));}\ndouble cross(P a,P b){return imag(b*conj(a));}\n\ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n\nP project(P a,P b,P c){  b-=a; c-=a; return a+b*real(c/b); }\n\ndouble getTime(P a,P b){\n  assert( eq(cross(a,b),0) );\n  return ( dot(a,b) < 0 ? -1.0 : 1.0 ) * abs(b);\n}\n\nbool onSegment(P a,P b,P p){\n  return eq( abs(a-b) , abs(a-p)+abs(b-p) );\n}\n\nP getCrossPoint(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n\ndouble getArg(P a,P b){  return arg(b*conj(a)); }\n\nvecp getCrossPoint(C c,P a,P b){\n  vecp res;\n  P base=b-a,  target=project(a,b,c.p);\n  double length=abs(base), h=abs(c.p-target);\n  if(c.r+eps<h)return res;\n  double w=Sqrt(c.r*c.r-h*h);\n  double L=getTime(base,target-a)-w, R=L+w*2.0;\n  base/=length;\n  if( -eps<L && L<length+eps )res.push_back(a+base*L);\n  if( eq(L,R) )return res;\n  if( -eps<R && R<length+eps )res.push_back(a+base*R);\n  return res;\n}\n\nvecp getCrossPoint(C a,S b, bool debug=false){\n  vecp res;\n  P base=b.q-b.p,  target=project(b.p,b.q,a.p);\n  double length=abs(base), h=abs(a.p-target);\n  if(a.r+eps<h)return res;\n  double w=Sqrt(a.r*a.r-h*h);\n  double L=getTime(base,target-b.p)-w,  R=L+w*2.0;\n  base/=length;  \n  if( -eps<L && L< length+eps )res.push_back(b.p+base*L);\n  if( eq(L,R) )return res;\n  if( -eps<R && R< length+eps )res.push_back(b.p+base*R);\n  return res;\n}\n\ndouble getArea(C c,P a,P b){\n  P va=c.p-a,  vb=c.p-b;\n  double A=abs(va), B=abs(vb);\n  double f=cross(va,vb), d=dist(a,b,c.p), res=0;\n  if( eq(0, f ) )return 0;\n  if(A<c.r+eps&&B<c.r+eps)return f*0.5;\n  if(d>c.r-eps)return c.r*c.r*PI*getArg(va,vb)/PI2;\n  \n  vecp u=getCrossPoint(c, S(a,b) );\n  assert( !u.empty() );\n  u.insert(u.begin(), a),  u.push_back(b);\n\n  for(int i=0;i+1<(int)u.size();i++) res+=getArea(c,u[i],u[i+1]);\n  return res;\n}\n\ndouble getArea(vecp t,C c){\n  int n=t.size();\n  if(n<3)return 0;\n  double res=0;\n  for(int i=0;i<n;i++){\n    P a=t[i], b=t[(i+1)%n];\n    res+=getArea(c,a,b);\n  }\n  return res;\n}\n\nint n;\ndouble cr;\nvecp t;\n\ndouble calc(double gx){\n  double left=1e9, right=-1e9;\n  for(int i=0;i<(int)t.size();i++){\n    P a=t[i];\n    P b=t[ (i+1)%n ];\n    P k=getCrossPoint( a,b, P(gx,0), P(gx,1) );\n    if( onSegment(a,b,k) == false )continue;\n    left=min(left,k.imag());\n    right=max(right,k.imag());\n  }\n  \n  for(int i=0;i<100;i++){\n    double dist=(right-left)/3.0;\n    double ml=left+dist;\n    double mr=right-dist;\n    if( getArea(t,C(P(gx,ml),cr)) > getArea(t,C(P(gx,mr),cr))){\n      right=mr;\n    }else{\n      left=ml;\n    }\n      \n  }\n  return getArea(t,C(P(gx,left),cr));\n}\n\nint main(){\n  cin>>n>>cr;\n  double left=1e9, right=-1e9;\n  \n  for(int i=0;i<n;i++){\n    double x,y;\n    cin>>x>>y;\n    t.push_back(P(x,y));\n    left=min(left,x);\n    right=max(right,x);\n  }\n\n  for(int i=0;i<100;i++){\n    double dist=(right-left)/3.0;\n    double ml=left+dist,mr=right-dist;\n    if( calc(ml) > calc(mr) )right=mr;\n    else left=ml;\n  }\n  printf(\"%.10f\\n\", calc(left) );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\nstruct L{P a, b;};\ntypedef vector<P> Pol;\nstruct C{P c; D r;};\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\ninline int sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\n\ninline bool near(const P& a, const P& b) {return !sig(norm(a - b));}\n\nnamespace std {\n  inline bool operator<(const P& a, const P& b) {return sig(a.X, b.X) ? a.X < b.X : a.Y < b.Y;}\n}\n\ninline D sr(D a) {return sqrt(max(a, (D)0));}\n\ninline D dot(const P& a, const P& b) {return a.X * b.X + a.Y * b.Y;}\ninline D det(const P& a, const P& b) {return a.X * b.Y - a.Y * b.X;}\n\ninline P vec(const L& a) {return a.b - a.a;}\n\ninline D arg(const P& base, const P& a, const P& b) {return arg((b - base) / (a - base));}\n\ninline P proj(const P& a, const P& b) {return a * dot(a, b) / norm(a);}\ninline P perp(const L& l, const P& p) {return l.a + proj(vec(l), p - l.a);}\n\ninline pair<P, P> pCL(const C& c, const L& l) {\n  P x = perp(l, c.c);\n  P y = vec(l) / abs(vec(l)) * sr(c.r * c.r - norm(x - c.c));\n  return make_pair(x - y, x + y);\n}\n\ninline D aCTnc(D r, const P& p1, const P& p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? det(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\n\ninline D aCT(D r, const P& p1, const P& p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\n\ninline D aCPol(const C& c, const Pol& pol) {\n  D res = 0;\n  for (int i = 0; i < (int)pol.size(); ++i) res += aCT(c.r, pol[i] - c.c, pol[(i + 1) % pol.size()] - c.c);\n  return res;\n}\n\nint main() {\n  int n, r;\n  cin >> n >> r;\n  D x1 = 1e9, x2 = -1e9, y1 = 1e9, y2 = -1e9, a = 0;\n  Pol pol(n);\n  for (auto& p : pol) {\n    D x, y;\n    cin >> x >> y;\n    p = P(x, y);\n    x1 = min(x1, x);\n    x2 = max(x2, x);\n    y1 = min(y1, y);\n    y2 = max(y2, y);\n  }\n  for (int i = 0; i < 200; ++i) {\n    D xa = (2 * x1 + x2) / 3;\n    D yy1 = y1, yy2 = y2;\n    D aa1 = 0, aa2 = 0;\n    for (int j = 0; j < 200; ++j) {\n      D ya = (2 * yy1 + yy2) / 3;\n      D yb = (yy1 + 2 * yy2) / 3;\n      D a1 = aCPol(C({P(xa, ya), (D)r}), pol);\n      D a2 = aCPol(C({P(xa, yb), (D)r}), pol);\n      if (a1 > a2) yy2 = yb;\n      else yy1 = ya;\n      aa1 = max(a1, a2);\n    }\n    yy1 = y1;\n    yy2 = y2;\n    D xb = (x1 + 2 * x2) / 3;\n    for (int j = 0; j < 200; ++j) {\n      D ya = (2 * yy1 + yy2) / 3;\n      D yb = (yy1 + 2 * yy2) / 3;\n      D a1 = aCPol(C({P(xb, ya), (D)r}), pol);\n      D a2 = aCPol(C({P(xb, yb), (D)r}), pol);\n      if (a1 > a2) yy2 = yb;\n      else yy1 = ya;\n      aa2 = max(a1, a2);\n    }\n    if (aa1 > aa2) x2 = xb;\n    else x1 = xa;\n    a = max(aa1, aa2);\n  }\n  cout << fixed << setprecision(15) << a << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-9)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n\nPoint calc_ps(Polygon poly) {\n  poly = andrewScan(poly);\n  Point mp = poly[0];\n  double rate = 1; // 0.5???????????¨???\n  int max_pos;\n  double eps = 1e-10; // 1e-20???????????¨???\n  while( rate > eps ) {\n    rep(_,60){ // 70???????????¨???\n      max_pos = 0;\n      REP(j,1,(int)poly.size()) {\n        double dist1 = abs(mp-poly[max_pos]);\n        double dist2 = abs(mp-poly[j]);\n\tif( LT(dist1,dist2) ) max_pos = j;\n      }\n      mp.x += ( poly[max_pos].x - mp.x ) * rate;\n      mp.y += ( poly[max_pos].y - mp.y ) * rate;\n    }\n    rate *= 0.5;\n  }\n  return mp;\n}\n\nPoint getCentroidOfConvex(Polygon& poly){\n  double area = getArea(poly);\n  int V = poly.size();\n  assert( !equals(area,0.0) );\n  double x = 0, y = 0;\n  rep(i,(int)poly.size()) {\n    x += ( poly[i].x + poly[(i+1)%V].x ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n    y += ( poly[i].y + poly[(i+1)%V].y ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n  }\n  return Point(x/(6.0*area),y/(6.0*area));\n}\n\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  double maxi;\n  Point mp = calc_ps(poly);\n  maxi = getCommonAreaPolygonCircle(poly,mp,r);\n  double rate = 1.0;\n  double eps = 1e-10;\n  while( LT(eps,rate) ) {\n    rep(_,70) {\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      assert( !equals(max_area,-1) );\n      mp = np;\n      if( LT(maxi,max_area) ) maxi = max_area;\n    }\n    rate *= 0.5;\n  }\n  rep(__,n+1) {\n    Point mp = calc_ps(poly);\n    if( __ ) mp = poly[__-1];\n    double rate = 1.0;\n    double eps = 1e-10;\n    while( LT(eps,rate) ) {\n      rep(_,70) {\n\tdouble max_area = -1; \n\tPoint np;\n\trep(i,n) {\n\t  Point tp = mp;\n\t  tp.x += ( poly[i].x - mp.x ) * rate;\n\t  tp.y += ( poly[i].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,tp,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t    np = tp;\n\t  }\n\t}\n\tif( rand() % 50 == 0 ) {\n\t  int v = rand() % n;\n\t  np.x = ( poly[v].x - mp.x ) * rate;\n\t  np.y = ( poly[v].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,np,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t  }\n\t}\n\tassert( !equals(max_area,-1) );\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      rate *= 0.5;\n    }\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  srand((unsigned int)time(NULL));\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  //cout << getArea(poly) << endl;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\n#include <iostream>\n#include <algorithm>\n\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef unsigned char uchar;\n\nusing namespace std;\n\nint getint(int x=0) { scanf(\"%d\",&x); return x; }\nll getll(ll x=0) { scanf(\"%lld\", &x); return x; }\ndouble getdb(double x=0) { scanf(\"%lf\",&x); return x; }\n\n// ====================================================1========\n\nconst int INF = (1<<30)-1;\nconst ll LINF = (1L<<62)-1;\n\nconst double eps = 1e-10;\n\nstruct point;\n\nstruct point\n{\n    db x,y;\n    point() : x(0),y(0) { }\n    point(db x, db y) : x(x),y(y) { }\n    db len() { return sqrt(x*x+y*y); }\n    db len2() { return x*x+y*y; }\n    point operator()(point b) const { return point(b.x-x, b.y-y); }\n    point norm() { double l = len(); return point(x/l, y/l); }\n    void out(const char* s = \"\") { printf(\"(%.2f, %.2f) %s\", x, y, s); }\n    point operator-() { return point(-x, -y); }\n};\n\npoint operator+(point a, point b) { return point(a.x + b.x, a.y + b.y); }\npoint operator-(point a, point b) { return point(a.x - b.x, a.y - b.y); }\ndb operator*(point a, point b) { return a.x * b.y - a.y * b.x; }\ndb operator&(point a, point b){ return a.x * b.x + a.y * b.y; }\npoint operator*(point a, db f) { return point(a.x * f, a.y * f); }\npoint operator*(db f, point a) { return point(a.x * f, a.y * f); }\npoint operator/(point a, db f) { return point(a.x / f, a.y / f); }\ndb Area(point a, point b, point c) { return abs(c(a)*c(b)*0.5); }\ndb Angle(point a, point b) { return acos((a&b)/a.len()/b.len()); }\ndb DistP2L(point c, point a, point b) { return Area(a,b,c) * 2.0 / a(b).len(); }\ndb ArcArea(db r, db angle) { return angle * r * r / 2.0; }\ndb ArcArea(db r, point c, point a, point b) { return ArcArea(r, Angle(c(a), c(b))); }\npoint rot90(point c) { return point(-c.y, c.x); }\n\ndb IntArea(db r, point c, point a,point b)\n{\n    if( c(a).len() < eps ||\n        c(b).len() < eps ||\n        a(b).len() < eps)\n        return 0;\n    \n    bool ain = c(a).len() < r;\n    bool bin = c(b).len() < r;\n    \n    if(ain && bin)\n    {\n        //printf(\"!!!\");\n        return abs(c(a) * c(b) * 0.5);\n    }\n    \n    db d = DistP2L(c, a, b);\n    //printf(\"d:%.8f \", d);\n    \n    if(!ain && !bin)\n    {\n        //printf(\"xx\");\n        if(d < r) // line intersect!\n        {\n            db m = sqrt(r*r-d*d);\n            point dir = rot90(a(b)).norm() * d;\n            if(DistP2L(c + dir, a, b) > eps)\n                dir = - dir;\n            point ita = c + dir + a(b).norm() * m;\n            point itb = c + dir + b(a).norm() * m;\n            \n            if((ita(a) & ita(b)) >= 0) // two points are on the same side.\n            {\n                //printf(\"^\");\n                return ArcArea(r, c, a, b);\n            }\n            \n            //printf(\"-\");\n            db Tar = m * d;\n            if(a(ita).len() > a(itb).len()) swap(ita, itb);\n            db Aar = ArcArea(r, c, a, ita);\n            db Bar = ArcArea(r, c, b, itb);\n            // a.out(); b.out(\"\\n\");\n            // ita.out(); itb.out(\"\\n\");\n            // a(ita).out(); a(itb).out(\"\\n\");\n            // c(a).out(); c(itb).out(); c(ita).out(\"\\n\");\n            // printf(\"angle: %.6f\\n\", Angle(c(a), c(ita)));\n            // printf(\" r:%.2f d:%.2f m:%.2f t:%.2f a:%.2f b:%.2f\\n\", r, d, m, Tar, Aar, Bar);\n            return Tar + Aar + Bar;\n        }\n        else // line not intersect.\n        {\n            //printf(\".\");\n            return ArcArea(r, c, a, b);\n        }\n    }\n    \n    //printf(\"x. \");\n    if(!ain && bin) swap(a, b);\n    \n    point dir = rot90(a(b)).norm() * d;\n    if(DistP2L(c + dir, a, b) > eps) dir = - dir;\n    db m = sqrt(r*r-d*d);\n    point ita = c + dir + a(b).norm() * m;\n    return a(ita).len() * d * 0.5 + ArcArea(r, c, b, ita);\n}\n\nint n;\ndb r;\n\npoint p[50];\n\ndb GetIntArea(point c)\n{\n    db res = 0.0;\n    for(int i=1; i<=n; i++)\n    {\n        point a = p[i];\n        point b = p[i-1];\n        if(c(a).len() <= eps || c(b).len() <= eps) continue;\n        if(a(c) * c(b) > eps) // positive triangle.\n            res += IntArea(r, c, a, b);\n        else if(a(c) * c(b) < eps)\n            res -= IntArea(r, c, a, b);\n        //printf(\"(%.2f, %.2f)-(%.2f, %.2f) %.8f \", a.x, a.y, b.x, b.y, IntArea(r, c, a, b));\n        //printf(\"%.8f\\n\", res);\n    }\n    //printf(\"%.2f\\n\", res);\n    return res;\n}\n\ndouble randdb() { return (db)rand() / RAND_MAX; }\n\nint main()\n{\n    n = getint();\n    r = getint();\n    for(int i=1; i<=n; i++)\n    {\n        p[i].x = getint();\n        p[i].y = getint();\n    }\n    p[0] = p[n];\n    \n    // Sim Anealling.\n    \n    srand(12512);\n    db Tbegin = 1e2;\n    db Tend = 1e-6;\n    db T = Tbegin;\n    db rate = 0.99995;\n    int cnt = 0;\n    int tcnt = 0;\n    point mvbase = point(0.01, 0.01);\n    point curp = p[1];\n    db curmax = GetIntArea(curp);\n    while(T >= Tend)\n    {\n        point nxtp = curp + point(\n            (randdb() - 0.5) * 2.0 * mvbase.x * T,\n            (randdb() - 0.5) * 2.0 * mvbase.y * T);\n        db v = GetIntArea(nxtp);\n        db dist = v - curmax;\n        //nxtp.out(\"\"); printf(\"v:%.4f dist:%.4f T:%.6f, p:%.4f\\n\", v, dist, T, exp(dist / T));\n        if(dist > eps || (dist < -eps && randdb() > exp(dist / T))\n        )\n        {\n            curmax = v;\n            curp = nxtp;\n            tcnt++;\n        }\n        T *= rate;\n        //T -= 1e-6;\n        cnt++;\n    }\n    \n    //printf(\"SA count:%d, transfer count:%d\\n\", cnt, tcnt);\n    printf(\"%.6f\\n\", curmax);\n    \n    // printf(\"%.8f\\n\", IntArea(1, {0, 0}, {1, 0}, {0, 1})); // 0.5 .\n    // printf(\"%.8f\\n\", IntArea(1, {0, 0}, {2, 0}, {0, 2}));\n    // printf(\"%.8f\\n\", IntArea(1, {0, 0}, {1.00000001, 0}, {0, 0.5}));\n    // printf(\"res, %.8f\\n\", IntArea(1, {5.44, -0.62}, {0, 0}, {100, 1}));\n    // printf(\"res, %.8f\\n\", IntArea(1, {5.44, -0.62}, {100, 1}, {99, 1}));\n    // printf(\"res, %.8f\\n\", IntArea(1, {5.44, -0.62}, {99, 1}, {0, 0}));\n    // printf(\"res, %.8f\\n\", IntArea(1, {98.21, 0.39}, {0, 0}, {100, 1}));\n    // printf(\"res, %.8f\\n\", IntArea(1, {98.21, 0.39}, {100, 1}, {99, 1}));\n    // printf(\"res, %.8f\\n\", IntArea(1, {98.21, 0.39}, {99, 1}, {0, 0}));\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 400\n#define linf 1e18\n#define eps (1e-11)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n  double getArea(){ return r*r*pi;}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\ndouble arg(Vector p){ return atan2(p.y,p.x);}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\nPoint rotate(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\ndouble getArea(Polygon p){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++)res+=cross(p[i]-p[0],p[i+1]-p[0])/2.0;\n  return res;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0.0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nbool iscrossLC(Line l,Circle c){\n  if((getDistanceLP(l,c.c)-c.r)<eps)return true;\n  return false;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  if(!iscrossLC(s,c))return res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(ccw(s.p1,s.p2,pp.f)==0)res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0)res.push_back(pp.s);\n  return res;\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Vector a=g[i]-p,b=g[(i+1)%n]-p;\n    if(abs(cross(a,b))<eps && dot(a,b)<eps)return 1;\n    if(a.y>b.y)swap(a,b);\n    if(a.y<eps && eps<b.y && cross(a,b)>eps)x=!x;\n  }\n  if(x)return 2;\n  return 0;\n}\n\nvector<Point> arg_sort(vector<Point> vp,Point base){\n  vector<pair<double,Point> > tmp;\n  vector<Point> res;\n  for(int i=0;i<vp.size();i++){\n    double targ=arg(vp[i]-base);\n    if(targ<0)targ+=2*pi;\n    tmp.push_back(mp(targ,vp[i]));\n  }\n  sort(tmp.begin(),tmp.end());\n  for(int i=0;i<tmp.size();i++)res.push_back(tmp[i].s);\n  return res;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  if(cross(a,b)<-eps)r=360.0-r;\n  return r;\n}\n\nbool AllIn(Polygon p,Circle c){\n  if(contains(p,c.c)!=2)return false;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\nbool AllOut(Polygon p,Circle c){\n  if(contains(p,c.c)!=0)return false;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\nvector<Point> unique(vector<Point> vp){\n  vector<Point> res;\n  if(vp.empty())return res;\n  sort(vp.begin(),vp.end());\n  res.push_back(vp[0]);\n  for(int i=1;i<vp.size();i++)\n    if(!(res.back()==vp[i]))res.push_back(vp[i]);\n  return res;\n}\n\ndouble getCommonAreaTC(Polygon p,Circle c){\n  double res=getArea(p);\n  int n=p.size();\n  vector<Point> s;\n  if(AllIn(p,c))return c.getArea();\n  if(AllOut(p,c))return 0.0;\n  for(int i=0;i<n;i++){\n    vector<Point> vp=getCrossPointSC(c,Segment(p[i],p[(i+1)%n]));\n    for(int j=0;j<vp.size();j++)s.push_back(vp[j]);\n  }\n\n  s=unique(s);\n  if(s.size()<=1)return res;\n  s=arg_sort(s,c.c); \n\n  for(int i=0;i<s.size();i++){\n    Point p1=s[i];\n    Point p2=s[(i+1)%s.size()];\n    double ra=getAngle(p1-c.c,p2-c.c);\n    if(contains(p,rotate(c.c,p1,ra/2.0))!=2)continue;\n    Polygon t;\n    t.push_back(p1);\n    t.push_back(p2);\n    t.push_back(c.c);\n    res-=getArea(convex_cut(p,Line(p2,p1)));\n    res+=((c.getArea()*ra/360.0)-getArea(t));\n  }\n  return res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++){\n    Polygon t;\n    t.push_back(p[0]);\n    t.push_back(p[i]);\n    t.push_back(p[i+1]);\n    res+=getCommonAreaTC(t,c);\n  }\n  return res;\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,40){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*L,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=abs(b-a);\n    FOR(k,0,40){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(a) int((a).size())\n#define mp make_pair\n#define pb push_back\ntypedef vector<int> VI;\ntypedef pair<int,int> PII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst LL mod=1e9+7;\nconst int INF=0x3f3f3f3f;\nconst double PI=acos(-1.0);\nconst double EPS=1e-6;\ninline void read(LL& x){int f=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(f=-1,x=0):(x=c-'0');while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=f;}\ninline void read(int& x){LL t;read(t);x=t;}\n\n/*----------------------精度控制--------------------------*/\nconst double eps=1e-5;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n/*------------------点、???体-------------------*/\nstruct Point{\n    double x,y;\n    Point(double x=0.0,double y=0.0):x(x),y(y){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        return !dcmp(x-b.x)? y<b.y:x<b.x;\n    }\n    /*friend bool operator<(CPoint a,CPoint b){//?角排序\n        double tmp=cross(Pts[0],a,b);\n        if(!dcmp(tmp)){\n            return dist(Pts[0],a)<dist(Pts[0],b);\n        }\n        return tmp>0;\n    }*/\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\ndouble length(Point p){ return sqrt(p*p); }\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\ndouble area(Point a,Point b){ return a^b*0.5; }\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dcmp(dot(s.b-s.a,p-s.a))<0) return length(p-s.a);\n    if(dcmp(dot(s.a-s.b,p-s.b))<0) return length(p-s.b);\n    return distPL(p,s);\n}\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n/*----------------------多?形相?--------------------------*/\n//0:outside 1:inside 2:online\nint PointInPoly(Point t,Point *Pts,int n){\n    int num=0,d1,d2,k;\n    Pts[n]=Pts[0];\n    for(int i=0;i<n;i++){\n        if(PointOnS(t,Line(Pts[i],Pts[i+1]))) return 2;\n        k=dcmp(cross(Pts[i],Pts[i+1],t));\n        d1=dcmp(Pts[i].y-t.y);\n        d2=dcmp(Pts[i+1].y-t.y);\n        if(k>0&&d1<=0&&d2>0) num++;\n        if(k<0&&d2<=0&&d1>0) num--;\n    }\n    return num!=0;\n}\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n//求多?形周?\ndouble PolyPerimeter(Point *Pts,int n){\n    double pp=distPP(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pp+=distPP(Pts[i],Pts[i+1]);\n    return pp;\n}\n//求多?形重心\nPoint PolyCore(Point *Pts,int n){\n    double pa=PolyArea(Pts,n);\n    if(!dcmp(pa)) return Point(0,0);\n    Point ans=(Pts[n-1]+Pts[0])*cross(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) ans=ans+(Pts[i]+Pts[i+1])*cross(Pts[i],Pts[i+1]);\n    return ans/pa/6;\n}\n/*----------------------凸包----------------------------*/\n//Graham-scan st:anticlockwise\n//<=:strict <:Non-strict\nint Graham(Point *Pts,Point *st,int n){\n    if(n<3) return 0;\n    sort(Pts,Pts+n);\n    int m=0;\n    for(int i=0;i<n;i++){\n        while(m>1&&dcmp(cross(st[m-2],st[m-1],Pts[i]))<0) m--;\n        st[m++]=Pts[i];\n    }\n    int k=m;\n    for(int i=n-2;i>=0;i--){\n        while(m>k&&dcmp(cross(st[m-2],st[m-1],Pts[i])<0)) m--;\n        st[m++]=Pts[i];\n    }\n    return m-1;\n}\n//clockwise:> anticlockwise:<\ndouble CHDiameter(Point *Pts,int n,Line &l){\n    double maxd=0.0;\n    if(n<=1){\n        l.a=l.b=Pts[0];\n        return maxd;\n    }\n    for(int i=0,j=1;i<n;i++){\n        while(cross(Pts[i],Pts[(i+1)%n],Pts[j])\n              >cross(Pts[i],Pts[(i+1)%n],Pts[(j+1)%n])){\n            j=(j+1)%n;\n        }\n        double d=distPP(Pts[i],Pts[j]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n        d=distPP(Pts[(i+1)%n],Pts[(j+1)%n]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n    }\n    return maxd;\n}\nbool PointInCH(Point *Pts,int n,Point a){\n    int l=0,r=n-1,m,res=-1;\n    bool fg=false;\n    int pos;\n    double flag[2];\n    while(l<=r){\n        m=(l+r)/2;\n        flag[0]=cross(Pts[0]-a,Pts[0]-Pts[m]);\n        if(!dcmp(flag[0])){\n            fg=true;\n            pos=m;\n            break;\n        }\n        flag[1]=cross(Pts[0]-a,Pts[0]-Pts[m+1]);\n        if(!dcmp(flag[1])){\n            fg=true;\n            pos=m+1;\n            break;\n        }\n        if(dcmp(flag[0])*dcmp(flag[1])<0){\n            res=m;\n            break;\n        }\n        if(dcmp(flag[0])<0&&dcmp(flag[1])<0) l=m+1;\n        else r=m-1;\n    }\n    if(fg){\n        if(dcmp((Pts[0]-a)*(Pts[pos]-a))<=0) return true;\n        return false;\n    }\n    if(res==-1) return false;\n    return dcmp(cross(Pts[m]-a,Pts[m]-Pts[m+1]))<=0;\n}\n\n\n/*---------------------整点多?形---------------------------*/\nint gcd(int a,int b){\n    return b==0?a :gcd(b,a%b);\n}\n//整点多?形?界整点数\nint Border_Int_Point_Num(Point *Pts,int n){\n    int num=gcd(abs(int(Pts[0].x-Pts[n-1].x)),abs(int(Pts[0].y-Pts[n-1].y)));;\n    for(int i=0;i<n-1;i++){\n        num+=gcd(abs(int(Pts[i+1].x-Pts[i].x)),abs(int(Pts[i+1].y-Pts[i].y)));\n    }\n    return num;\n}\n//整点多?形内部整点数\nint Inside_Int_Point_Num(Point *Pts,int n){\n    return abs(int(PolyArea(Pts,n)))+1-Border_Int_Point_Num(Pts,n)/2;\n}\n/*-----------------------------半平面交-------------------------------*/\n//有方向的直?\n//p->p+v\nstruct Vector{\n    Point p,v;\n    double ang;\n    Vector(Point p,Point v):p(p),v(v){\n        ang=atan2(v.y,v.x);\n    }\n    Vector(){}\n    bool operator<(const Vector &l) const{\n        return ang<l.ang;\n    }\n};\n//判断点p是否在直?L左?\nbool onLeft(Vector L,Point p){\n    return cross(L.v,p-L.p)>0;\n}\n//得到a与b?直?的交点\nPoint getCrossVV(Vector a,Vector b){\n    Point u=a.p-b.p;\n    double t=cross(b.v,u)/cross(a.v,b.v);\n    return a.p+a.v*t;\n}\n//所有直?左半平面的交\nint HPCross(Vector *L,int n,Point *poly){\n    sort(L,L+n);\n    int f=0,l=0;\n    Point *p=new Point[n];\n    Vector *q=new Vector[n];\n    q[0]=L[0];\n    for(int i=1;i<n;i++){\n        while(f<l&&!onLeft(L[i],p[l-1])) l--;\n        while(f<l&&!onLeft(L[i],p[f])) f++;\n        q[++l]=L[i];\n        if(!dcmp(cross(q[l].v,q[l-1].v))){\n            l--;\n            if(onLeft(q[l],L[i].p)) q[l]=L[i];\n        }\n        if(f<l) p[l-1]=getCrossVV(q[l-1],q[l]);\n    }\n    while(f<l&&!onLeft(q[f],p[l-1])) l--;\n    if(l-f<=1) return 0;\n    p[l]=getCrossVV(q[l],q[f]);\n    int m=0;\n    for(int i=f;i<=l;i++) poly[m++]=p[i];\n    return m;\n}\n//向内??r\n#define maxn 100005\nVector l[maxn];\nbool retract(Vector *L,int n,double r,Point *poly){\n    for(int i=0;i<n;i++){\n        Point v=rotateV(L[i].p,L[i].p+L[i].v,PI/2);\n        l[i]=Vector(L[i].p+r*v,L[i].v);\n    }\n    int cnt=HPCross(l,n,poly);\n    return cnt;\n}\n/*---------------------三角形相?---------------------------*/\n//三角形重心\n//到三?点距?的平方和最小的点\n//到三?距?之?最大的点\nPoint TCore(Point a,Point b,Point c){\n    return (a+b+c)/3;\n}\n//三角形外心\nPoint TCircum(Point a,Point b,Point c){\n    Point cp;\n    double a1=b.x-a.x;\n    double b1=b.y-a.y;\n    double a2=c.x-a.x;\n    double b2=c.y-a.y;\n    double c1=(a1*a1+b1*b1)/2;\n    double c2=(a2*a2+b2*b2)/2;\n    double d=a1*b2-a2*b1;\n    cp.x=a.x+(c1*b2-c2*b1)/d;\n    cp.y=a.y+(a1*c2-a2*c1)/d;\n    return cp;\n}\n//三角形垂心\nPoint TOrtho(Point a,Point b,Point c){\n    return TCore(a,b,c)*3.0-TCircum(a,b,c)*2.0;\n}\n//三角形内心\nPoint TInner(Point a,Point b,Point c){\n    Point cp;\n    double la=distPP(b,c),lb=distPP(c,a),lc=distPP(a,b);\n    cp.x=(la*a.x+lb*b.x+lc*c.x)/(la+lb+lc);\n    cp.y=(la*a.y+lb*b.y+lc*c.y)/(la+lb+lc);\n    return cp;\n}\n//求三角形面?\ndouble TArea(Point a,Point b,Point c){\n    return fabs(cross(a,b,c))/2;\n}\n/*-----------------------?相?-------------------------*/\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n//求??面?交\ndouble getAreaCC(Circle a,Circle b){\n    double d=(a.o.x-b.o.x)*(a.o.x-b.o.x)+(a.o.y-b.o.y)*(a.o.y-b.o.y);\n    if(d<=(a.r-b.r)*(a.r-b.r)){\n        return min(a.r,b.r)*min(a.r,b.r)*PI;\n    }else if(d>(a.r-b.r)*(a.r-b.r)&&d<(a.r+b.r)*(a.r+b.r)){\n        double m1=(a.r*a.r+d-b.r*b.r)/(2*a.r*sqrt(d));\n        double m2=(b.r*b.r+d-a.r*a.r)/(2*b.r*sqrt(d));\n        double s1=acos(m1)*a.r*a.r;\n        double s2=acos(m2)*b.r*b.r;\n        double s3=sqrt(d)*a.r*sin(acos(m1));\n        return s1+s2-s3;\n    }\n    return 0.0;\n}\n//求??交点，先判断是否有交点\nPoint rotatePCS(Point p,double c,double s){\n    return Point(p.x*c-p.y*s,p.x*s+p.y*c);\n}\npair<Point,Point> getcrossCC(Circle a,Circle b){\n    double d=length(a.o-b.o);\n    double cost=(a.r*a.r+d*d-b.r*b.r)/(2*a.r*d);\n    double sint=sqrt(1.0-cost*cost);\n    Point v=(b.o-a.o)/d*a.r;\n    return make_pair(a.o+rotatePCS(v,cost,-sint),a.o+rotatePCS(v,cost,sint));\n}\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n/********************************************************/\n\nPoint project(Line s,Point p){\n    Point base=(s.b-s.a);\n    double r=(dot(p-s.a,base)/(base*base));\n    return (s.a+base*r);\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n    Point pr=project(l,c.o);\n    Point e=(l.b-l.a)/length(l.b-l.a);\n    double base=sqrt(c.r*c.r-(pr-c.o)*(pr-c.o));\n    return mp(pr+e*base,pr-e*base);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n    Point a=p1-p0;\n    Point b=p2-p0;\n    if(dcmp(cross(a,b))>0) return 1;\n    if(dcmp(cross(a,b))<0) return -1;\n    if(dcmp(dot(a,b))<0) return 2;\n    if(a*a<b*b) return -2;\n    return 0;\n}\n\nPoint getCrossPointSC(Circle c,Line s){\n    Point res;\n    pair<Point,Point> pp=getCrossPoints(c,s);\n    if(ccw(s.a,s.b,pp.first)==0){\n        res=pp.first;\n        if(ccw(s.a,s.b,pp.first)==0&&length(s.a-pp.second)<length(s.a-pp.first)) res=pp.second;\n    }else res=pp.second;\n    return res;\n}\n\ndouble getAngle(Point a,Point b){\n    double tmp=dot(a,b)/(length(a)*length(b));\n    if(tmp<-1.0) tmp=-1.0;\n    if(1.0<tmp) tmp=1.0;\n    return acos(tmp)/PI;\n}\n\nbool intersect(Circle c,Line s){\n    if(dcmp(distPS(c.o,s)-c.r)<=0) return true;\n    return false;\n}\ndouble getAreaTC(Point a,Point b,Circle c){\n    double res=fabs(cross(a-c.o,b-c.o)/2);\n    if(!dcmp(res)) return 0.0;\n    double la=length(a-c.o),lb=length(b-c.o);\n    if(la<c.r+EPS&&lb>c.r-EPS){\n        Point p1=getCrossPointSC(c,Line(b,a));\n        Point p2=getCrossPointSC(c,Line(b,c.o));\n        res+=(c.r*c.r*PI)*(getAngle(p1-c.o,p2-c.o)/2);\n        res-=fabs(cross(p1-c.o,p2-c.o)/2.0);\n        res-=fabs(cross(p2-b,p1-b)/2.0);\n    }else if(la>c.r-EPS&&lb<c.r+EPS){\n        Point p1=getCrossPointSC(c,Line(a,c.o));\n        Point p2=getCrossPointSC(c,Line(a,b));\n        res+=(c.r*c.r*PI)*(getAngle(p1-c.o,p2-c.o)/2);\n        res-=abs(cross(p1-c.o,p2-c.o)/2.0);\n        res-=abs(cross(p2-a,p1-a)/2.0);\n    }else if(la>c.r-EPS&&lb>c.r-EPS){\n        if(intersect(c,Line(a,b))){\n            pair<Point,Point> pp=getCrossPoints(c,Line(a,b));\n            Point m=(pp.second+pp.first)/2.0;\n            res=fabs(getAreaTC(a,m,c))+fabs(getAreaTC(m,b,c));\n        }else res=(c.r*c.r*PI)*(getAngle(a-c.o,b-c.o)/2);\n    }\n    if(dcmp(cross(a-c.o,b-c.o))>0) res=-res;\n    return res;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double ans=0.0;\n    for(int i=1;i<=n;i++){\n        ans+=getAreaTC(Pts[i],Pts[i+1],c);\n    }\n    return fabs(ans);\n}\n\n/********************************************************/\n/*----------------------三?点、?基本函数-----------------------------*/\nstruct Point3{\n    double x,y,z;\n    Point3(double x,double y,double z):x(x),y(y),z(z){}\n    Point3(){}\n    void Read(){ scanf(\"%lf%lf%lf\",&x,&y,&z); }\n};\nstruct Line3{\n    Point3 a,b;\n    Line3(Point3 a,Point3 b):a(a),b(b){}\n    Line3(){}\n    void Read(){ a.Read(); b.Read(); }\n};\nPoint3 operator +(Point3 a,Point3 b){ return Point3(a.x+b.x,a.y+b.y,a.z+b.z); }\nPoint3 operator -(Point3 a,Point3 b){ return Point3(a.x-b.x,a.y-b.y,a.z-b.z); }\ndouble operator *(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 operator *(Point3 a,double k){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator *(double k,Point3 a){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator /(Point3 a,double k){ return Point3(a.x/k,a.y/k,a.z/k); }\ndouble length(Point3 a){ return sqrt(a.x*a.x+a.y*a.y+a.z*a.z); }\nPoint3 unit(Point3 a){ return a/length(a); }\ndouble dot(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 cross(Point3 a,Point3 b){\n    return Point3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//混合?\ndouble Mix(Point3 a,Point3 b,Point3 c){ return dot(a,cross(b,c)); }\n//?点距?\ndouble dist(const Point3 &a,const Point3 &b){ return length(a-b); }\n/*---------------------------------体?-------------------------------------*/\n//四面体体?\ndouble volume(double l,double n,double a,double m,double b,double c){\n    double x,y;\n    x=4*a*a*b*b*c*c-a*a*(b*b+c*c-m*m)*(b*b+c*c-m*m)-b*b*(c*c+a*a-n*n)*(c*c+a*a-n*n);\n    y=c*c*(a*a+b*b-l*l)*(a*a+b*b-l*l)-(a*a+b*b-l*l)*(b*b+c*c-m*m)*(c*c+a*a-n*n);\n    return sqrt(x-y)/12;\n}\ndouble volume(Point3 a,Point3 b,Point3 c,Point3 d){ return fabs(Mix(b-a,c-a,d-a)/6); }\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);//cin.tie(0);\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n+1-i].x>>Pts[n+1-i].y;\n        minx=min(minx,Pts[n+1-i].x);\n        miny=min(miny,Pts[n+1-i].y);\n        maxx=max(maxx,Pts[n+1-i].x);\n        maxy=max(maxy,Pts[n+1-i].y);\n    }\n    Pts[n+1]=Pts[1];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-9)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n\nPoint calc_ps(Polygon poly) {\n  poly = andrewScan(poly);\n  Point mp = poly[0];\n  double rate = 1; // 0.5???????????¨???\n  int max_pos;\n  double eps = 1e-10; // 1e-20???????????¨???\n  while( rate > eps ) {\n    rep(_,60){ // 70???????????¨???\n      max_pos = 0;\n      REP(j,1,(int)poly.size()) {\n        double dist1 = abs(mp-poly[max_pos]);\n        double dist2 = abs(mp-poly[j]);\n\tif( LT(dist1,dist2) ) max_pos = j;\n      }\n      mp.x += ( poly[max_pos].x - mp.x ) * rate;\n      mp.y += ( poly[max_pos].y - mp.y ) * rate;\n    }\n    rate *= 0.5;\n  }\n  return mp;\n}\n\nPoint getCentroidOfConvex(Polygon& poly){\n  double area = getArea(poly);\n  int V = poly.size();\n  assert( !equals(area,0.0) );\n  double x = 0, y = 0;\n  rep(i,(int)poly.size()) {\n    x += ( poly[i].x + poly[(i+1)%V].x ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n    y += ( poly[i].y + poly[(i+1)%V].y ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n  }\n  return Point(x/(6.0*area),y/(6.0*area));\n}\n\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  double maxi;\n  Point mp = calc_ps(poly);\n  maxi = getCommonAreaPolygonCircle(poly,mp,r);\n  double rate = 1.0;\n  double eps = 1e-10;\n  while( LT(eps,rate) ) {\n    rep(_,70) {\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      assert( !equals(max_area,-1) );\n      mp = np;\n      if( LT(maxi,max_area) ) maxi = max_area;\n    }\n    rate *= 0.5;\n  }\n  rep(__,1) {\n    Point mp = calc_ps(poly);\n    double rate = 1.0;\n    double eps = 1e-10;\n    while( LT(eps,rate) ) {\n      rep(_,70) {\n\tdouble max_area = -1; \n\tPoint np;\n\trep(i,n) {\n\t  Point tp = mp;\n\t  tp.x += ( poly[i].x - mp.x ) * rate;\n\t  tp.y += ( poly[i].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,tp,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t    np = tp;\n\t  }\n\t}\n\tif( rand() % 50 == 0 ) {\n\t  int v = rand() % n;\n\t  np.x = ( poly[v].x - mp.x ) * rate;\n\t  np.y = ( poly[v].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,np,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t  }\n\t}\n\tassert( !equals(max_area,-1) );\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      rate *= 0.5;\n    }\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  srand((unsigned int)time(NULL));\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  //cout << getArea(poly) << endl;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  Point mp = poly[0];\n  double maxi = 0;\n  double rate = 1.0;\n  double eps = 1e-20;\n  while( LT(eps,rate) ) {\n    rep(_,80) {\n\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      if( !equals(max_area,-1) ) {\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      \n    }\n    rate *= 0.5;\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\n#define CVector CPoint\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1);\nconst double EPS=1e-5;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\nbool isZero(double x){\n    return -EPS<x&&x<EPS;\n}\n\nint Cmp(double x){\n    if(isZero(x)){\n        return 0;\n    }\n    if(x>0){\n        return 1;\n    }\n    return -1;\n}\n\nstruct CPoint{\n    double x,y;\n    CPoint(double x,double y):x(x),y(y){}\n    CPoint(){}\n    void Read(){\n        scanf(\"%lf%lf\",&x,&y);\n    }\n    friend bool operator<(CPoint a,CPoint b){//水平序\n        if(isZero(a.x-b.x)){\n            return a.y<b.y;\n        }\n        return a.x<b.x;\n    }\n    friend CPoint operator +(CPoint a,CPoint b){\n        return CPoint(a.x+b.x,a.y+b.y);\n    }\n    friend CPoint operator -(CPoint a,CPoint b){\n        return CPoint(a.x-b.x,a.y-b.y);\n    }\n    friend CPoint operator *(CPoint a,double k){\n        return CPoint(k*a.x,k*a.y);\n    }\n    friend CPoint operator *(double k,CPoint a){\n        return CPoint(k*a.x,k*a.y);\n    }\n    friend double operator *(CPoint a,CPoint b){\n        return a.x*b.x+a.y*b.y;\n    }\n    friend CPoint operator /(CPoint a,double k){\n        return CPoint(a.x/k,a.y/k);\n    }\n    friend double operator ^(CPoint a,CPoint b){\n        return a.x*b.y-a.y*b.x;\n    }\n    double norm(){return(x*x+y*y);}\n};\n\nstruct CLine{\n    CPoint a,b;\n    CLine(CPoint aa,CPoint bb):a(aa),b(bb){}\n    CLine(){}\n    void Read(){\n        scanf(\"%lf%lf%lf%lf\",&a.x,&a.y,&b.x,&b.y);\n    }\n};\n\ndouble cross(CPoint a,CPoint b) {\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble cross(CPoint a,CPoint b,CPoint c){\n    return (b.x-a.x)*(c.y-a.y)-(c.x-a.x)*(b.y-a.y);\n}\n\ndouble dot(CPoint a,CPoint b,CPoint c){\n    return (b-a)*(c-a);\n}\ndouble Length(CVector p){\n    return sqrt(p*p);\n}\n\nCVector unit(CVector p){\n    return 1.0/Length(p)*p;\n}\n\ndouble project(CVector p,CVector n){\n    return p*(unit(n));\n}\n\ndouble area(CVector a,CVector b){\n    return a^b*0.5;\n}\n\ndouble dist(CPoint p,CPoint q){\n    return Length(p-q);\n}\n\ndouble dist(CPoint p,CLine l){\n    return fabs((p-l.a)^(p-l.b))/Length(l.a-l.b);\n}\n\nCPoint Rotate(CPoint a,CPoint b,double alpha){\n    CVector p=b-a;\n    return CPoint(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\nint sideOfLine(CPoint p,CLine l){\n    double res=(p-l.a)^(p-l.b);\n    if(isZero(res)){\n        return 0;\n    }else{\n        return res>0? 1:-1;\n    }\n}\n\nCLine Vertical(CPoint p,CLine l){\n    return CLine(p,p+(Rotate(l.b,l.a,PI/2)-l.a));\n}\n\nCPoint root(CPoint p,CLine l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\ndouble angle(CLine l,CLine m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/Length(l.b-l.a)));\n}\n\nbool PointOnSegment(CPoint p,CPoint a,CPoint b){\n    return Cmp(cross(p-a,b-a))==0&&Cmp((p-a)*(p-b))<=0;\n}\n\nCPoint GetIntersect(CLine l,CLine m,string &s){\n    if(isZero(cross(l.b-l.a,m.b-m.a))){\n        if(!sideOfLine(l.a,m)){\n            s=\"LINE\";\n        }else{\n            s=\"NONE\";\n        }\n        return CPoint(0,0);\n    }\n    s=\"POINT\";\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\nCPoint GetIntersect(CLine l,CLine m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\nbool IsCross(CLine l,CLine m){\n    return sideOfLine(l.a,m)*sideOfLine(l.b,m)<=0&&sideOfLine(m.a,l)*sideOfLine(m.b,l)<=0;\n}\n\n#define MAXN 15\nCPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble norm(CPoint a){return(a.x*a.x+a.y*a.y);}\n\ndouble dot(CPoint a,CPoint b){return(a.x*b.x+a.y*b.y);}\n\nCPoint project(CLine s,CPoint p){\n    CPoint base=(s.b-s.a);\n    double r=(dot(p-s.a,base)/base.norm());\n    return (s.a+base*r);\n}\n\npair<CPoint,CPoint> getCrossPoints(CPoint c,double r,CLine l){\n    CPoint pr=project(l,c);\n    CPoint e=(l.b-l.a)/Length(l.b-l.a);\n    double base=sqrt(r*r-norm(pr-c));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\nint ccw(CPoint p0,CPoint p1,CPoint p2){\n    CPoint a=p1-p0;\n    CPoint b=p2-p0;\n    if(cross(a,b)>EPS)return 1;\n    if(cross(a,b)<-EPS)return -1;\n    if(dot(a,b)<-EPS)return 2;\n    if(a.norm()<b.norm())return -2;\n    return 0;\n}\n\nCPoint getCrossPointSC(CPoint c,double r,CLine s){\n    CPoint res;\n    pair<CPoint,CPoint> pp=getCrossPoints(c,r,s);\n    if(ccw(s.a,s.b,pp.first)==0){\n        res=pp.first;\n        if(ccw(s.a,s.b,pp.first)==0&&Length(s.a-pp.second)<Length(s.a-pp.first)) res=pp.second;\n    }else res=pp.second;\n    return res;\n}\n\ndouble getAngle(CPoint a,CPoint b){\n    double tmp=dot(a,b)/(Length(a)*Length(b));\n    if(tmp<-1.0) tmp=-1.0;\n    if(1.0<tmp) tmp=1.0;\n    return acos(tmp)*180.0/PI;\n}\n\ndouble getDistanceSP(CLine s,CPoint p){\n  if(dot(s.b-s.a,p-s.a)<0.0) return Length(p-s.a);\n  if(dot(s.a-s.b,p-s.b)<0.0) return Length(p-s.b);\n  return dist(p,s);\n}\n\nbool intersect(CPoint c,double r,CLine s){\n  if(getDistanceSP(s,c)<r-EPS) return true;\n  return false;\n}\n\ndouble getCommonAreaTC(CPoint a,CPoint b,CPoint c,double r){\n    double res=fabs(cross(c-a,c-b)/2);\n    if(isZero(res)) return 0.0;\n    //cout<<a.x<<\" \"<<a.y<<endl;\n    double la=Length(a-c),lb=Length(b-c);\n    //cout<<la<<\" \"<<lb<<\" \"<<r<<endl;\n    if(la<r+EPS&&lb>r-EPS){\n        CPoint p1=getCrossPointSC(c,r,CLine(b,a));\n        CPoint p2=getCrossPointSC(c,r,CLine(b,c));\n        res+=(r*r*PI)*(getAngle(p1-c,p2-c)/360.0);\n        res-=fabs(cross(p1-c,p2-c)/2.0);\n        res-=fabs(cross(p2-b,p1-b)/2.0);\n    }else if(la<r+EPS&&lb>r-EPS){\n        CPoint p1=getCrossPointSC(c,r,CLine(a,c));\n        CPoint p2=getCrossPointSC(c,r,CLine(a,b));\n        res+=(r*r*PI)*(getAngle(p1-c,p2-c)/360.0);\n        res-=abs(cross(p1-c,p2-c)/2.0);\n        res-=abs(cross(p2-a,p1-a)/2.0);\n    }else if(la>r-EPS&&lb>r-EPS){\n        if(dist(c,CLine(a,b))<r-EPS){\n            pair<CPoint,CPoint> pp=getCrossPoints(c,r,CLine(a,b));\n            CPoint m=(pp.second+pp.first)/2.0;\n            //cout<<pp.first.x<<\" \"<<pp.second.y<<endl;\n            //cout<<m.x<<\" \"<<m.y<<endl;\n            res=fabs(getCommonAreaTC(a,m,c,r))+fabs(getCommonAreaTC(m,b,c,r));\n        }else res=(r*r*PI)*(getAngle(a-c,b-c)/360.0);\n    }\n    if(cross(a-c,b-c)<0.0) res=-res;\n    return res;\n}\n\ndouble getans(CPoint s){\n    double ans=0.0;\n    for(int i=1;i<=n;i++){//cout<<Pts[i+1].x<<\" \"<<Pts[i+1].y<<endl;\n        ans+=getCommonAreaTC(Pts[i],Pts[i+1],s,R);\n    }\n    return fabs(ans);\n}\n\ndouble sanfeny(double x){\n    double l=maxy,r=miny;\n    CLine s=CLine(CPoint(x,0),CPoint(x,1));\n    for(int i=1;i<=n;i++){\n        CPoint st=GetIntersect(s,CLine(Pts[i],Pts[i+1]));\n        if(PointOnSegment(st,Pts[i],Pts[i+1])){\n            l=min(l,st.y);\n            r=max(r,st.y);\n        }\n    }\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getans(CPoint(x,m1))<getans(CPoint(x,m2))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getans(CPoint(x,l));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);//cin.tie(0);\n\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n+1-i].x>>Pts[n+1-i].y;\n        minx=min(minx,Pts[n+1-i].x);\n        miny=min(miny,Pts[n+1-i].y);\n        maxx=max(maxx,Pts[n+1-i].x);\n        maxy=max(maxy,Pts[n+1-i].y);\n    }\n    Pts[n+1]=Pts[1];//getans(CPoint(2,4));\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;\n\n/*\n4 4\n0 0\n1 0\n1 1\n0 1\n*/\n/*\n4 4\n0 0\n0 1\n1 1\n1 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\n#define CVector CPoint\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1);\nconst double EPS=1e-6;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-10;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、线结构体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n    /*friend bool operator<(CPoint a,CPoint b){//极角排序\n        double tmp=cross(Pts[0],a,b);\n        if(isZero(tmp)){\n            return dist(Pts[0],a)<dist(Pts[0],b);\n        }\n        return tmp>0;\n    }*/\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、线相关----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//单位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影长度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所夹的有向面积\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b绕a逆时针旋转alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b绕a逆时针旋转alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求过p的l的垂线\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//两向量夹角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//两直线夹角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在线段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直线交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断线段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n/*----------------------多边形相关--------------------------*/\n\n//0:outside 1:inside 2:online\nint PointInPoly(Point t,Point *Pts,int n){\n    int num=0,d1,d2,k;\n    Pts[n]=Pts[0];\n    for(int i=0;i<n;i++){\n        if(PointOnS(t,Line(Pts[i],Pts[i+1]))) return 2;\n        k=dcmp(cross(Pts[i],Pts[i+1],t));\n        d1=dcmp(Pts[i].y-t.y);\n        d2=dcmp(Pts[i+1].y-t.y);\n        if(k>0&&d1<=0&&d2>0) num++;\n        if(k<0&&d2<=0&&d1>0) num--;\n    }\n    return num!=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n//求任意多边形周长，需逆时针或顺时针排列\ndouble PolyPerimeter(Point *Pts,int n){\n    double pp=distPP(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pp+=distPP(Pts[i],Pts[i+1]);\n    return pp;\n}\n\n//求多边形重心坐标\nPoint PolyCore(Point *Pts,int n){\n    double pa=PolyArea(Pts,n);\n    if(!dcmp(pa)) return Point(0,0);\n    Point ans=(Pts[n-1]+Pts[0])*cross(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) ans=ans+(Pts[i]+Pts[i+1])*cross(Pts[i],Pts[i+1]);\n    return ans/pa/6;\n}\n\n/*----------------------凸包----------------------------*/\n\n//Graham-scan st:anticlockwise\n//<=:strict <:Non-strict\nint Graham(Point *Pts,Point *st,int n){\n    if(n<3) return 0;\n    sort(Pts,Pts+n);\n    int m=0;\n    for(int i=0;i<n;i++){\n        while(m>1&&dcmp(cross(st[m-2],st[m-1],Pts[i]))<0) m--;\n        st[m++]=Pts[i];\n    }\n    int k=m;\n    for(int i=n-2;i>=0;i--){\n        while(m>k&&dcmp(cross(st[m-2],st[m-1],Pts[i])<0)) m--;\n        st[m++]=Pts[i];\n    }\n    return m-1;\n}\n\n//clockwise:> anticlockwise:<\ndouble CHDiameter(Point *Pts,int n,Line &l){\n    double maxd=0.0;\n    if(n<=1){\n        l.a=l.b=Pts[0];\n        return maxd;\n    }\n    for(int i=0,j=1;i<n;i++){\n        while(cross(Pts[i],Pts[(i+1)%n],Pts[j])\n              >cross(Pts[i],Pts[(i+1)%n],Pts[(j+1)%n])){\n            j=(j+1)%n;\n        }\n        double d=distPP(Pts[i],Pts[j]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n        d=distPP(Pts[(i+1)%n],Pts[(j+1)%n]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n    }\n    return maxd;\n}\n\n/*---------------------整点多边形---------------------------*/\n\nint gcd(int a,int b){\n    return b==0?a :gcd(b,a%b);\n}\n\n//整点多边形边界整点数\nint Border_Int_Point_Num(Point *Pts,int n){\n    int num=gcd(abs(int(Pts[0].x-Pts[n-1].x)),abs(int(Pts[0].y-Pts[n-1].y)));;\n    for(int i=0;i<n-1;i++){\n        num+=gcd(abs(int(Pts[i+1].x-Pts[i].x)),abs(int(Pts[i+1].y-Pts[i].y)));\n    }\n    return num;\n}\n\n//整点多边形内部整点数\nint Inside_Int_Point_Num(Point *Pts,int n){\n    return abs(int(PolyArea(Pts,n)))+1-Border_Int_Point_Num(Pts,n)/2;\n}\n\n/*-----------------------------半平面交-------------------------------*/\n\n//有方向的直线\n//p->p+v\nstruct Vector{\n    Point p,v;\n    double ang;\n    Vector(Point p,Point v):p(p),v(v){\n        ang=atan2(v.y,v.x);\n    }\n    Vector(){}\n    bool operator<(const Vector &l) const{\n        return ang<l.ang;\n    }\n};\n\n//判断点p是否在直线L左边\nbool onLeft(Vector L,Point p){\n    return cross(L.v,p-L.p)>0;\n}\n\n//得到a与b两直线的交点\nPoint getCrossVV(Vector a,Vector b){\n    Point u=a.p-b.p;\n    double t=cross(b.v,u)/cross(a.v,b.v);\n    return a.p+a.v*t;\n}\n\n//所有直线左半平面的交\nint HPCross(Vector *L,int n,Point *poly){\n    sort(L,L+n);\n    int f=0,l=0;\n    Point *p=new Point[n];\n    Vector *q=new Vector[n];\n    q[0]=L[0];\n    for(int i=1;i<n;i++){\n        while(f<l&&!onLeft(L[i],p[l-1])) l--;\n        while(f<l&&!onLeft(L[i],p[f])) f++;\n        q[++l]=L[i];\n        if(!dcmp(cross(q[l].v,q[l-1].v))){\n            l--;\n            if(onLeft(q[l],L[i].p)) q[l]=L[i];\n        }\n        if(f<l) p[l-1]=getCrossVV(q[l-1],q[l]);\n    }\n    while(f<l&&!onLeft(q[f],p[l-1])) l--;\n    if(l-f<=1) return 0;\n    p[l]=getCrossVV(q[l],q[f]);\n    int m=0;\n    for(int i=f;i<=l;i++) poly[m++]=p[i];\n    return m;\n}\n\n#define maxn 100005\nVector l[maxn];\nbool retract(Vector *L,int n,double r,Point *poly){\n    for(int i=0;i<n;i++){\n        Point v=rotateV(L[i].p,L[i].p+L[i].v,PI/2);\n        l[i]=Vector(L[i].p+r*v,L[i].v);\n    }\n    int cnt=HPCross(l,n,poly);\n    return cnt;\n}\n\n/*---------------------三角形相关---------------------------*/\n\n//三角形重心\n//到三顶点距离的平方和最小的点\n//到三边距离之积最大的点\nPoint TCore(Point a,Point b,Point c){\n    return (a+b+c)/3;\n}\n\n//三角形外心\nPoint TCircum(Point a,Point b,Point c){\n    Point cp;\n    double a1=b.x-a.x;\n    double b1=b.y-a.y;\n    double a2=c.x-a.x;\n    double b2=c.y-a.y;\n    double c1=(a1*a1+b1*b1)/2;\n    double c2=(a2*a2+b2*b2)/2;\n    double d=a1*b2-a2*b1;\n    cp.x=a.x+(c1*b2-c2*b1)/d;\n    cp.y=a.y+(a1*c2-a2*c1)/d;\n    return cp;\n}\n\n//三角形垂心\nPoint TOrtho(Point a,Point b,Point c){\n    return TCore(a,b,c)*3.0-TCircum(a,b,c)*2.0;\n}\n\n//三角形内心\nPoint TInner(Point a,Point b,Point c){\n    Point cp;\n    double la=distPP(b,c),lb=distPP(c,a),lc=distPP(a,b);\n    cp.x=(la*a.x+lb*b.x+lc*c.x)/(la+lb+lc);\n    cp.y=(la*a.y+lb*b.y+lc*c.y)/(la+lb+lc);\n    return cp;\n}\n\n//求三角形面积\ndouble TArea(Point a,Point b,Point c){\n    return fabs(cross(a,b,c))/2;\n}\n\n/*-----------------------圆相关-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n//求两圆面积交\ndouble getAreaCC(Circle a,Circle b){\n    double d=(a.o.x-b.o.x)*(a.o.x-b.o.x)+(a.o.y-b.o.y)*(a.o.y-b.o.y);\n    if(d<=(a.r-b.r)*(a.r-b.r)){\n        return min(a.r,b.r)*min(a.r,b.r)*PI;\n    }else if(d>(a.r-b.r)*(a.r-b.r)&&d<(a.r+b.r)*(a.r+b.r)){\n        double m1=(a.r*a.r+d-b.r*b.r)/(2*a.r*sqrt(d));\n        double m2=(b.r*b.r+d-a.r*a.r)/(2*b.r*sqrt(d));\n        double s1=acos(m1)*a.r*a.r;\n        double s2=acos(m2)*b.r*b.r;\n        double s3=sqrt(d)*a.r*sin(acos(m1));\n        return s1+s2-s3;\n    }\n    return 0.0;\n}\n\n/********************************************************/\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n\nint getCrossCS(Circle c,Line s,Point *cs){\n    int fg=dcmp(distPL(c.o,s)-c.r);\n    int cnt=0;\n    Point rt=root(c.o,s);\n    if(!fg){\n        if(PointOnS(rt,s)) cs[cnt++]=rt;\n    }else if(fg==-1){\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        Point p1=rt+r*unit(s.b-s.a);\n        Point p2=rt-r*unit(s.b-s.a);\n        if(PointOnS(p1,s)) cs[cnt++]=p1;\n        if(PointOnS(p2,s)) cs[cnt++]=p2;\n    }\n    return cnt;\n}\n\ndouble getAngle(Point a,Point b){\n    double tmp=dot(a,b)/(length(a)*length(b));\n    if(tmp<-1.0) tmp=-1.0;\n    if(1.0<tmp) tmp=1.0;\n    return acos(tmp)*180.0/PI;\n}\n\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=fabs(cross(a-c.o,b-c.o)/2);\n    if(!dcmp(atc)) return 0.0;\n    double la=length(a-c.o),lb=length(b-c.o);\n    Point cs[4];\n    if(la<c.r+EPS&&lb>c.r-EPS){\n        getCrossCS(c,Line(a,b),cs);\n        Point p=cs[0];\n        atc+=0.5*c.area()*angleVV(p-c.o,b-c.o);\n        atc-=0.5*fabs(cross(p-c.o,b-c.o));\n    }else if(la>c.r-EPS&&lb<c.r+EPS){\n        getCrossCS(c,Line(a,b),cs);\n        Point p=cs[0];\n        atc+=0.5*c.area()*angleVV(p-c.o,a-c.o);\n        atc-=0.5*fabs(cross(p-c.o,a-c.o));\n    }else if(la>c.r-EPS&&lb>c.r-EPS){\n        if(distPS(c.o,Line(a,b))<c.r+EPS){\n            Point rt=root(c.o,Line(a,b));\n            atc=fabs(getAreaTC(a,rt,c))+fabs(getAreaTC(rt,b,c));\n        }else atc=0.5*c.area()*angleVV(a-c.o,b-c.o);\n    }\n    if(cross(a-c.o,b-c.o)>0.0) atc=-atc;\n    return atc;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=getAreaTC(Pts[n-1],Pts[0],c);\n    for(int i=0;i<n-1;i++) apc+=getAreaTC(Pts[i],Pts[i+1],c);\n    return fabs(apc);\n}\n\n/********************************************************/\n\n\n/*----------------------三维点、线基本函数-----------------------------*/\n\nstruct Point3{\n    double x,y,z;\n    Point3(double x,double y,double z):x(x),y(y),z(z){}\n    Point3(){}\n    void Read(){ scanf(\"%lf%lf%lf\",&x,&y,&z); }\n};\n\nstruct Line3{\n    Point3 a,b;\n    Line3(Point3 a,Point3 b):a(a),b(b){}\n    Line3(){}\n    void Read(){ a.Read(); b.Read(); }\n};\nPoint3 operator +(Point3 a,Point3 b){ return Point3(a.x+b.x,a.y+b.y,a.z+b.z); }\nPoint3 operator -(Point3 a,Point3 b){ return Point3(a.x-b.x,a.y-b.y,a.z-b.z); }\ndouble operator *(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 operator *(Point3 a,double k){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator *(double k,Point3 a){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator /(Point3 a,double k){ return Point3(a.x/k,a.y/k,a.z/k); }\n\ndouble length(Point3 a){ return sqrt(a.x*a.x+a.y*a.y+a.z*a.z); }\nPoint3 unit(Point3 a){ return a/length(a); }\ndouble dot(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 cross(Point3 a,Point3 b){\n    return Point3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//混合积\ndouble Mix(Point3 a,Point3 b,Point3 c){\n    return dot(a,cross(b,c));\n}\n\n//两点距离\ndouble dist(const Point3 &a,const Point3 &b){ return length(a-b); }\n\n/*---------------------------------体积-------------------------------------*/\n\n//四面体体积\ndouble volume(double l,double n,double a,double m,double b,double c){\n    double x,y;\n    x=4*a*a*b*b*c*c-a*a*(b*b+c*c-m*m)*(b*b+c*c-m*m)-b*b*(c*c+a*a-n*n)*(c*c+a*a-n*n);\n    y=c*c*(a*a+b*b-l*l)*(a*a+b*b-l*l)-(a*a+b*b-l*l)*(b*b+c*c-m*m)*(c*c+a*a-n*n);\n    return sqrt(x-y)/12;\n}\n\ndouble volume(Point3 a,Point3 b,Point3 c,Point3 d){\n    return fabs(Mix(b-a,c-a,d-a)/6);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=maxy,r=miny;\n    Line s=Line(Point(x,0),Point(x,1));\n    for(int i=1;i<=n;i++){\n        Point st=getCrossLL(s,Line(Pts[i],Pts[i+1]));\n        if(PointOnS(st,Line(Pts[i],Pts[i+1]))){\n            l=min(l,st.y);\n            r=max(r,st.y);\n        }\n    }\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);cin.tie(0);\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n+1-i].x>>Pts[n+1-i].y;\n        minx=min(minx,Pts[n+1-i].x);\n        miny=min(miny,Pts[n+1-i].y);\n        maxx=max(maxx,Pts[n+1-i].x);\n        maxy=max(maxy,Pts[n+1-i].y);\n    }\n    Pts[n+1]=Pts[1];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\nstruct C{\n    P p;\n    double r;\n    C(const P& p, const double& r) : p(p), r(r) {}\n    C(){}\n};\n\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X!=b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\nP unit(const P &p){\n    return p/abs(p);\n}\nP rotate(const P &p, double rad){\n    return p *P(cos(rad), sin(rad));\n}\n\nbool intersectSP(const L& s, const P &p){\n    return abs(cross(s[0]-p, s[1]-p))<EPS  && dot(s[0]-p, s[1]-p)<EPS;\n}\nbool intersectSS(const L& a, const L& b){\n    return ( ccw(a[0],a[1],b[0]) *ccw(a[0],a[1],b[1]) <= 0 ) &&\n        ( ccw(b[0],b[1],a[0]) *ccw(b[0],b[1],a[1]) <= 0 );\n}\nP projection(const L& l, const P& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\ndouble distanceLP(const L &l, const P &p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0]-p), abs(s[1]-p));\n}\n\nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\n\nVP crosspointCL(const C &c, const L &l){\n    VP ret;\n    P mid = projection(l, c.p);\n    double d = distanceLP(l, c.p);\n    if(EQ(d, c.r)){\n        ret.push_back(mid);\n    }else if(d < c.r){\n        double len = sqrt(c.r*c.r -d*d);\n        ret.push_back(mid +len*unit(l[1]-l[0]));\n        ret.push_back(mid -len*unit(l[1]-l[0]));\n    }\n    return ret;\n}\nVP crosspointCS(const C &c, const L &s){\n    VP ret;\n    VP cp = crosspointCL(c,s);\n    for(int i=0; i<(int)cp.size(); i++){\n        if(intersectSP(s, cp[i])){\n            ret.push_back(cp[i]);\n        }\n    }\n    return ret;\n}\n\nint in_poly(const P &p, const VP &poly){\n    int n = poly.size();\n    int ret = -1;\n    for(int i=0; i<n; i++){\n        P a = poly[i]-p;\n        P b = poly[(i+1)%n]-p;\n        if(a.Y > b.Y) swap(a,b);\n        if(intersectSP(L(a,b), P(0,0))) return 0;\n        if(a.Y<=0 && b.Y>0 && cross(a,b)<0) ret = -ret;\n    }\n    return ret;\n}\n\nVP convex(VP v){\n    VP ret;\n    int n = v.size();\n    sort(v.begin(), v.end());\n    for(int i=0; i<n; i++){\n        while((int)ret.size()>1 && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    int t = ret.size();\n    for(int i=n-2; i>=0; i--){\n        while((int)ret.size()>t && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    if((int)ret.size() > 1) ret.pop_back();\n    return ret;\n}\n\ndouble commonarea_circle_convex(C c, VP poly){\n    int n = poly.size();\n    for(int i=0; i<n; i++) poly[i] -= c.p;\n    c.p = P(0, 0);\n    \n    VP cp;\n    for(int i=0; i<n; i++){\n        L edge(poly[i], poly[(i+1)%n]);\n        VP ret = crosspointCS(c, edge);\n        cp.insert(cp.begin(), ret.begin(), ret.end());\n        if(abs(poly[i]) < c.r) cp.push_back(poly[i]);\n    }\n    sort(cp.begin(), cp.end());\n    cp.erase(unique(cp.begin(), cp.end()), cp.end());\n    \n    double res = 0;\n    VP v = convex(cp);\n    int m = v.size();\n    for(int i=0; i<m; i++){\n        P curr = v[i];\n        P next = v[(i+1)%m];\n        if(EQ(abs(curr), c.r) && EQ(abs(next), c.r)\n           && in_poly(c.r *unit(next -curr)*P(0,-1), poly) > 0){\n            double theta = arg(next /curr);\n            if(theta < 0) theta += 2*PI;\n            res += c.r*c.r *theta /2;\n        }else{\n            res += cross(curr, next) /2;\n        }\n    }\n    return res;\n}\n\n\nint main(){\n    int n,r;\n    cin >> n >> r;\n    VP poly(n);\n    int xmax=0, xmin=100;\n    for(int i=0; i<n; i++){\n        int x,y;\n        cin >> x >> y;\n        poly[i] = P(x, y);\n        xmax = max(xmax, x);\n        xmin = min(xmin, x);\n    }\n\n    double ans = 0;\n    double lb=xmin, ub=xmax;\n    for(int rep=0; rep<50; rep++){\n        double mid[2] = {(2*lb +ub)/3, (lb +2*ub)/3};\n        double area[2];\n        for(int i=0; i<2; i++){\n            vector<double> bound;\n            double x = mid[i];\n            L div(P(x, -INF), P(x, INF));\n            for(int j=0; j<n; j++){\n                L edge(poly[j], poly[(j+1)%n]);\n                if(!isParallel(div, edge) && intersectSS(div, edge)){\n                    bound.push_back(crosspointLL(div, edge).Y);\n                }\n            }\n            sort(bound.begin(), bound.end());\n            double lb = bound[0], ub = bound.back();\n            for(int rep=0; rep<50; rep++){\n                double mid[2] = {(2*lb +ub)/3, (lb +2*ub)/3};\n                double area[2];\n                for(int i=0; i<2; i++){\n                    area[i] = commonarea_circle_convex(C(P(x, mid[i]), r), poly);\n                }\n                if(area[0] > area[1]){\n                    ub = mid[1];\n                }else{\n                    lb = mid[0];\n                }\n            }\n            area[i] = commonarea_circle_convex(C(P(x, lb), r), poly);\n            ans = max(ans, area[i]);\n        }\n        if(area[0] > area[1]){\n            ub = mid[1];\n        }else{\n            lb = mid[0];\n        }\n    }\n    cout << fixed;\n    cout << setprecision(10);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\n\nstruct P {\n\tdouble x, y;\n\tP() {\n\t}\n\tP(double _x, double _y) :\n\t\t\tx(_x), y(_y) {\n\t}\n\tP operator+(const P&p) const {\n\t\treturn P(x + p.x, y + p.y);\n\t}\n\tP operator-(const P&p) const {\n\t\treturn P(x - p.x, y - p.y);\n\t}\n\tP operator*(double d) const {\n\t\treturn P(x * d, y * d);\n\t}\n\tP operator/(double d) const {\n\t\treturn P(x / d, y / d);\n\t}\n\tdouble det(const P&p) const {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdouble dot(const P&p) const {\n\t\treturn x * p.x + y * p.y;\n\t}\n\tdouble alpha() const {\n\t\treturn atan2(y, x);\n\t}\n\tP rot90() const {\n\t\treturn P(-y, x);\n\t}\n\tvoid read() {\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t}\n\tvoid write() const {\n\t\tprintf(\"(%lf,%lf)\", x, y);\n\t}\n\tdouble abs() {\n\t\treturn sqrt(abs2());\n\t}\n\tdouble abs2() {\n\t\treturn x * x + y * y;\n\t}\n\tP unit() {\n\t\treturn *this / abs();\n\t}\n};\n\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n\nconst double EPS = 1e-8; //you should change it according to problem, nevertheless, it mustn't be a constant value some times.\ninline int sign(double a) {\n\treturn a < -EPS ? -1 : a > EPS;\n}\n\n#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))\n\nP isSS(P p1, P p2, P q1, P q2) {\n\tdouble a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);\n\treturn (p1 * a2 + p2 * a1) / (a1 + a2);\n}\n\nint n;\n\ndouble x[12],y[12],r;\n\nbool onLine(P p, P q, P x){\n\treturn (x-p).dot(x-q) <= EPS;\n}\n\nvector<P> isCS(P c,double r,P p, P q){\n\tdouble d = cross(q,p,c) / (p-q).abs();\n\tvector<P> ret;\n\n\tif(d>=r+EPS)\n\t\treturn ret;\n\n\tP dir = (q-p).rot90();\n\tP pq = (p-q);\n\tpq = pq/pq.abs();\n\n\tdir = dir / dir.abs();\n\n\tP mid = c + dir * d;\n\n\tdouble h = sqrt(max(r*r-d*d,0.0));\n\tif(onLine(p,q,mid + pq*h))\n\t\tret.push_back(mid + pq*h);\n\tif(onLine(p,q,mid - pq*h))\n\t\tret.push_back(mid - pq*h);\n\treturn ret;\n}\n\ndouble rad(P p,P q){\n\treturn atan2(p.det(q),p.dot(q));\n}\n\ndouble calc(P p, P q){\n\tbool inp = p.abs2() <= r*r;\n\tbool inq = q.abs2() <= r*r;\n\tif(inp && inq){\n\t\treturn p.det(q)/2;\n\t}\n\tif(inp && !inq){\n\t\treturn -calc(q,p);\n\t}\n\tvector<P> is = isCS(P(0,0),r,p,q);\n\tif(!inp && inq){\n\t\tP m = is[0];\n\t\treturn r*r*rad(p,m)/2 + m.det(q)/2;\n\t}\n\n\tif(!inp && !inq){\n\t\tif(is.empty())\n\t\t\treturn r*r*rad(p,q)/2;\n\t\treturn r*r*(rad(p,is[0]) + rad(is[1],q))/2 + is[0].det(is[1])/2;\n\t}\n}\n\ndouble calcArea(double cx,double cy){\n\tP ps[12];\n\trep(i,n) ps[i].x=x[i]-cx,ps[i].y=y[i]-cy;\n\tps[n] = ps[0];\n\n\tdouble area = 0;\n\n\trep(i,n){\n\t\tP p=ps[i],q=ps[i+1];\n\t\tarea += calc(p,q);\n\t}\n\n\t//cout<<area<<endl;\n\n\treturn area;\n}\n\ndouble ffy(double x){\n\tdouble l = 1e100,r=-1e100;\n\n\tP ps[12];\n\trep(i,n) ps[i].x=::x[i], ps[i].y=y[i];\n\n\tps[n] = ps[0];\n\n\trep(i,n){\n\t\tP p = ps[i], q = ps[i+1];\n\t\tif(p.x > q.x)\n\t\t\tswap(p,q);\n\n\t\tif(p.x<=x+EPS && x<=q.x+EPS){\n\t\t\tdouble iy;\n\t\t\tif(p.y==q.y)\n\t\t\t\tiy = p.y;\n\t\t\telse\n\t\t\t\tiy = p.y + (q.y - p.y) * (x-p.x) / (q.x-p.x);\n\t\t\tl = min(l,iy);\n\t\t\tr = max(r,iy);\n\t\t}\n\t}\n\n\trep(it,100){\n\t\tdouble ll=(l*2+r)/3,rr=(l+r*2)/3;\n\t\tif(calcArea(x,ll)>calcArea(x,rr))\n\t\t\tr=rr;\n\t\telse\n\t\t\tl=ll;\n\t}\n\treturn calcArea(x,l);\n}\n\ndouble ffx(){\n\tdouble l=*min_element(x,x+n),r=*max_element(x,x+n);\n\n\trep(it,100){\n\t\tdouble ll=(l*2+r)/3,rr=(l+r*2)/3;\n\t\tif(ffy(ll)>ffy(rr))\n\t\t\tr=rr;\n\t\telse\n\t\t\tl=ll;\n\t}\n\treturn ffy(l);\n}\n\nint main(){\n\tcin>>n>>r;\n\trep(i,n) cin>>x[i]>>y[i];\n\n\tprintf(\"%0.10lf\\n\",ffx());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1.0);\nconst double EPS=1e-8;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-8;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n\nPoint root(Line l,Point p){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n\ndouble mysqrt(double x){ return sqrt(max(0.0,x)); }\nint getCrossCS(Circle c,Line s,Point *ret){\n    double x0=c.o.x,y0=c.o.y;\n    double x1=s.a.x,y1=s.a.y;\n    double x2=s.b.x,y2=s.b.y;\n    double dx=x2-x1,dy=y2-y1;\n    double A=dx*dx+dy*dy;\n    double B=2.0*dx*(x1-x0)+2.0*dy*(y1-y0);\n    double C=(x1-x0)*(x1-x0)+(y1-y0)*(y1-y0)-c.r*c.r;\n    double delta=B*B-4.0*A*C;\n    int num=0;\n    if(dcmp(delta)>=0){\n        double t1=(-B-mysqrt(delta))/(2.0*A);\n        double t2=(-B+mysqrt(delta))/(2.0*A);\n        if(dcmp(t1-1)<=0&&dcmp(t1)>=0) ret[num++]=Point(x1+t1*dx,y1+t1*dy);\n        if(dcmp(t2-1)<=0&&dcmp(t2)>=0) ret[num++]=Point(x1+t2*dx,y1+t2*dy);\n        //如果没有if判断，?是求直?和?的交点\n    }\n    return num;\n}\ndouble SectorArea(Point a,Point b,Circle c){\n    a=a-c.o,b=b-c.o;\n    double theta=atan2(a.y,a.x)-atan2(b.y,b.x);\n    while(dcmp(theta)<=0) theta+=2.0*PI;\n    while(dcmp(theta-2.0*PI)>0) theta-=2.0*PI;\n    theta=min(theta,2.0*PI-theta);\n    return c.r*c.r*theta*0.5;\n}\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=0.0;\n    Point OA=a-c.o,OB=b-c.o;\n    double la=length(OA),lb=length(OB);\n    Point cs[4];\n    bool aic=dcmp(la-c.r)<=0,bic=dcmp(lb-c.r)<=0;\n    if(aic&&bic) return fabs(cross(OA,OB))*0.5;\n    int num=getCrossCS(c,Line(a,b),cs);\n    if(aic) return SectorArea(cs[0],b,c)+fabs(cross(OA,cs[0]-c.o))*0.5;\n    if(bic) return SectorArea(cs[0],a,c)+fabs(cross(OB,cs[0]-c.o))*0.5;\n    if(num==2) return SectorArea(a,cs[0],c)+\n        SectorArea(b,cs[1],c)+fabs(cross(cs[0]-c.o,cs[1]-c.o))*0.5;\n    return SectorArea(a,b,c);\n}\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=0.0;\n    for(int i=0;i<n;i++){\n        int s=dcmp(cross(Pts[i]-c.o,Pts[i+1]-c.o));\n        if(!!s) apc+=getAreaTC(Pts[i],Pts[i+1],c)*s;\n    }\n    return fabs(apc);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);cin.tie(0);\n    //cout<<getAreaTC(Point(3,3),Point(-3,3),Circle(Point(0,0),4))<<endl;\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n#define x1 jkflwjjkfjekjfe\n#define x2 fwekwfefekfje\n\nint iter = log(100 * 100 * 10000) / log(3) + 20;\ntypedef complex<double> P;\nstruct L{\n\tP a,b;\n};\nvector<double> ax,ay;\nvector<L> ls;\ndouble R,cx,cy;\n\nbool eq(double a,double b){\n\treturn fabs(a-b) < 1e-7;\n}\nbool eq2(double a,double b){\n\treturn fabs(a-b) < 1e-8;\n}\n\npair<double,double> seg(double y){\n\tdouble x1 = +1e5;\n\tdouble x2 = -1e5;\n\tfor( auto &&l : ls){\n\t\tif( eq(l.a.imag(),y) ){\n\t\t\tx1 = min(x1,l.a.real());\n\t\t\tx2 = max(x2,l.a.real());\n\t\t}\n\t\tif( eq(l.b.imag(),y) ){\n\t\t\tx1 = min(x1,l.b.real());\n\t\t\tx2 = max(x2,l.b.real());\n\t\t}\n\t\tif( l.a.imag() + 1e-7 < y and y < l.b.imag() - 1e-7 ){\n\t\t\tP v = (l.b - l.a);\n\t\t\tP p = l.a + v * (y-l.a.imag()) / v.imag();\n\t\t\tx1 = min(x1,p.real());\n\t\t\tx2 = max(x2,p.real());\t\n\t\t}\n\t}\n\treturn {x1,x2};\n}\n\ndouble len(pair<double,double> p){\n\tif( p.first < p.second ) return p.second - p.first;\n\treturn 0;\n}\npair<double,double> merge(const pair<double,double> &a,const pair<double,double> &b){\n\treturn {max(a.first,b.first),min(a.second,b.second)};\n}\n\ndouble g(double y){\n\tif( R - abs(y-cy) < 1e-7 ) return 0;\n\t// for given y, compute the overlapped length of the circle and the polygon.\n\tdouble t = sqrt(R*R-(cy-y)*(cy-y));\n\tpair<double,double> circle_seg = {cx-t,cx+t};\n\treturn len(merge(circle_seg,seg(y)));\n}\n\ndouble simpson(double l,double r){\n\treturn (r-l)/6*(g(l)+4*g((l+r)/2)+g(r));\n}\ndouble integral(double l,double r){\n\tif( l >= r ) return 0;\n\n\tdouble m = (l+r) / 2;\n\tdouble A = simpson(l,m) + simpson(m,r);\n\tdouble B = simpson(l,r);\n\tif( eq2(A,B) ) return A;\n\telse return integral(l,m) + integral(m,r);\n}\n\ndouble f(double x,double y){\n\tcx = x;\n\tcy = y;\n\tdouble ans = 0;\n\tfor(int i = 0 ; i+1 < ay.size() ; i++){\n\t\tans += integral(max(cy-R,ay[i]),min(cy+R,ay[i+1]));\n\t}\n\treturn ans;\n}\n\ndouble search2(double y){\n\tdouble ans = 0;\n\tdouble l,r;\n\n\ttie(l,r) = seg(y);\n\n\tfor(int i = 0 ; i < iter ; i++){\n\t\tdouble a = (2*l+r) / 3;\n\t\tdouble b = (l+2*r) / 3;\n\t\tif( f(a,y) < f(b,y) ){\n\t\t\tl = a;\n\t\t}else{\n\t\t\tr = b;\n\t\t}\n\t}\n\treturn f(l,y);\n}\n\ndouble search1(){\n\tdouble ans = 0;\n\tdouble l = ay.front(), r = ay.back();\n\tfor(int i = 0 ; i < iter ; i++){\n\t\tdouble a = (2*l+r) / 3;\n\t\tdouble b = (l+2*r) / 3;\n\t\tif( search2(a) < search2(b) ){\n\t\t\tl = a;\n\t\t}else{\n\t\t\tr = b;\n\t\t}\n\t}\n\treturn search2(l);\n}\n\nint main(){\n\tint n;\n\tcin >> n >> R;\n\tvector<P> g(n+1);\n\tfor(int i = 0 ; i < n ; i++){\n\t\tdouble x,y;\n\t\tcin >> x >> y;\n\t\tg[i] = P(x,y);\n\t\tax.push_back(x);\n\t\tay.push_back(y);\n\t}\n\tg[n] = g[0];\n\t\n\tfor(int i = 0 ; i < n ; i++){\n\t\tls.push_back({g[i],g[i+1]});\n\t\tif( ls.back().a.imag() > ls.back().b.imag() ) swap(ls.back().a,ls.back().b);\n\t}\n\n\tsort(ax.begin(),ax.end());\n\tsort(ay.begin(),ay.end());\n\tax.erase(unique(ax.begin(),ax.end()),ax.end());\n\tay.erase(unique(ay.begin(),ay.end()),ay.end());\n\tprintf(\"%.10lf\\n\",search1());\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mem(a,b) memset((a),(b),sizeof(a))\n#define MP make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) x.size()\n#define all(x) x.begin(),x.end()\nusing namespace std;\n#define _GLIBCXX_PERMIT_BACKWARD_HASH\n#include <ext/hash_map>\nusing namespace __gnu_cxx;\nstruct str_hash{size_t operator()(const string& str)const{return __stl_hash_string(str.c_str());}};\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\nconst int INF=0x3f3f3f3f;\nconst ll LLINF=0x3f3f3f3f3f3f3f3f;\nconst double PI=acos(-1.0);\nconst double eps=1e-8;\nconst int MAX=2e5+10;\nconst ll mod=1e9+7;\nint sgn(double x)\n{\n    if(fabs(x)<eps) return 0;\n    if(x<0) return -1;\n    return 1;\n}\nstruct Point\n{\n    double x,y;\n    Point() {}\n    Point(double x_,double y_):x(x_),y(y_) {}\n    Point operator -(const Point &t)\n    {\n        return Point(x-t.x,y-t.y);\n    }\n    Point operator +(const Point &t)\n    {\n        return Point(x+t.x,y+t.y);\n    }\n    double operator *(const Point &t)\n    {\n        return x*t.x+y*t.y;\n    }\n    Point operator *(double t)\n    {\n        return Point(x*t,y*t);\n    }\n    double operator ^(const Point &t)\n    {\n        return x*t.y-y*t.x;\n    }\n    double friend dist(const Point &a,const Point &b)\n    {\n        return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n    }\n    void input()\n    {\n        scanf(\"%lf%lf\",&x,&y);\n    }\n} p[15];\nint n;\ndouble R;\nnamespace SK\n{\nbool inCircle(Point &cir,Point &a)\n{\n    return sgn(dist(cir,a)-R)<=0;\n}\ndouble triArea2(Point &a,Point &b,Point &c)\n{\n    return fabs((b-a)^(c-a));\n}\nbool sameSide(Point &cir,Point &a,Point &b)\n{\n    if(dist(a,cir)>dist(b,cir)) return sgn((a-b)*(cir-b))<=0;\n    else return sgn((b-a)*(cir-a))<=0;\n}\ndouble calc(Point &cir,Point a,Point b)\n{\n    double xmulti=(a-cir)^(b-cir);\n    if(sgn(xmulti)==0) return 0;\n    double ans=0;\n    double theta=acos(((a-cir)*(b-cir))/(dist(a,cir)*dist(b,cir)));\n    double h=triArea2(cir,a,b)/dist(a,b);\n    bool ina=inCircle(cir,a),inb=inCircle(cir,b);\n    if(ina && inb) ans=triArea2(cir,a,b)/2;\n    else if(!ina && !inb)\n    {\n        if(sameSide(cir,a,b)) ans=R*R*theta/2;\n        else if(sgn(h-R)>=0) ans=R*R*theta/2;\n        else\n        {\n            double theta2=2*acos(h/R);\n            ans=R*R*(theta-theta2+sin(theta2))/2;\n        }\n    }\n    else\n    {\n        if(!ina && inb) swap(a,b);\n        double tem=(cir-a)*(b-a);\n        if(sgn(tem)==0)\n        {\n            double alpha=acos(h/R);\n            ans=R*h/2*sin(alpha)+R*R*(theta-alpha)/2;\n        }\n        else\n        {\n            double theta1=asin(h/R),theta2=asin(h/dist(a,cir));\n            if(sgn(tem)>0)\n            {\n                ans+=dist(cir,a)*R/2*sin(PI-theta1-theta2);\n                ans+=R*R/2*(theta+theta1+theta2-PI);\n            }\n            else\n            {\n                ans+=dist(cir,a)*R/2*sin(theta2-theta1);\n                ans+=R*R/2*(theta-theta2+theta1);\n            }\n        }\n    }\n    if(sgn(xmulti)<0) return -ans;\n    else return ans;\n}\ndouble coArea(Point &cir)\n{\n    double ans=0;\n    for(int i=0; i<n; ++i)\n        ans+=calc(cir,p[i],p[i+1]);\n    return fabs(ans);\n}\n}\npair<Point,double> SA()\n{  \n\tPoint s;  \n\tdouble T=100,t,ds,dz,ans;  \n\tint i,j,k,flag,dir[5][2]={0,0,1,0,-1,1,0,-1,0};\n\ts=Point(0,0);\n\tfor(i=0;i<n;i++)\n\t{  \n\t\ts.x+=p[i].x;  \n\t\ts.y+=p[i].y;  \n\t}\n\ts.x/=n;  \n\ts.y/=n;  \n\tans=0;\n\tfor(k=1;k<=100000;k++)\n\t{\n\t\tt=T/k;\n\t\tfor(i=0;i<5;i++)  \n\t\t{\n\t\t\tPoint z;\n\t\t\tz.x=s.x+dir[i][0]*t;  \n\t\t\tz.y=s.y+dir[i][1]*t;  \n\t\t\tdz=SK::coArea(z);\n\t\t\tif(dz>ans)  \n\t\t\t{  \n\t\t\t\tans=dz;\n\t\t\t\ts=z;\n\t\t\t} \n\t\t}\n\t}\n\tpair<Point,double> res;\n\tres=make_pair(s,ans);\n\treturn res;\n}\nint main()\n{\n\tint i;\n\twhile(~scanf(\"%d%lf\",&n,&R))\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tp[i].input();\n\t\t}\n\t\tp[n]=p[0];\n\t//\tprintf(\"%.6lf\\n\",getres(Point(3,3),p,n+1));\n\t\tpair<Point,double> ans=SA();\n\t\tprintf(\"%.8lf\\n\",ans.se);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <ctime>\nusing namespace std;\n\nconst double eps = 1e-8,PI = acos(-1);\n\nstruct point {\n\tdouble x, y;\n\tpoint(){}\n\tpoint(double xx, double yy) {\n\t\tx = xx,y = yy;\n\t}\n\tpoint operator -(const point &n2) const {\n\t\treturn point(x-n2.x, y-n2.y);\n\t}\n\tpoint operator +(const point &n2) const {\n\t\treturn point(x+n2.x, y+n2.y);\n\t}\n\tpoint operator *(const double n) const {\n\t\treturn point(x*n, y*n);\n\t}\n\tpoint operator /(const double n) const {\n\t\treturn point(x/n, y/n);\n\t}\n\tvoid output() {\n\t\tcout << x << ' ' << y << endl;\n\t}\n};\ndouble myrand(double l, double r)\n{\n\treturn l+rand()/32768.0*(r-l);\n}\n\ninline double sqr(double x) {\n\treturn x*x;\n}\nint dcmp(double k) {\n\treturn k<-eps? -1:(k>eps? 1:0);\n}\ndouble dot(const point &a, const point &b) {\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(const point &a, const point &b)\n{\n\treturn a.x*b.y-a.y*b.x;\n};\ndouble abs(const point &o) {\n\treturn sqrt(dot(o,o));\n}\npoint crosspt(const point &a, const point &b, const point &p, const point &q)\n{\n\tdouble a1 = cross(b-a,p-a);\n\tdouble a2 = cross(b-a,q-a);\n\treturn (p*a2-q*a1)/(a2-a1);\n}\ndouble mysqrt(double n) {\n\treturn sqrt(max(.0,n));\n}\n\npoint a[15],res[15];\ndouble r;\nint n;\n\nvoid circle_cross_line(point a, point b, point o, double r, point ret[], int &num)\n{\n\tdouble x00 = o.x, y00 = o.y;\n\tdouble x11 = a.x, y11 = a.y;\n\tdouble x2 = b.x, y2 = b.y;\n\tdouble dx = x2-x11, dy = y2-y11;\n\tdouble A = dx*dx+dy*dy;\n\tdouble B = 2*dx*(x11-x00)+2*dy*(y11-y00);\n\tdouble C = sqr(x11-x00)+sqr(y11-y00)-sqr(r);\n\tdouble delta = B*B-4*A*C;\n\tnum = 0;\n\tif(dcmp(delta)>=0) {\n\t\tdouble t1 = (-B-mysqrt(delta))/(2*A);\n\t\tdouble t2 = (-B+mysqrt(delta))/(2*A);\n\t\tif(dcmp(t1-1)<=0 && dcmp(t1)>=0)\n\t\t\tret[num++] = point(x11+t1*dx, y11+t1*dy);\n\t\tif(dcmp(t2-1)<=0 && dcmp(t2)>=0)\n\t\t\tret[num++] = point(x11+t2*dx, y11+t2*dy);\n\t}\n}\n\ndouble sector_area(const point &a, const point &b)\n{\n\tdouble theta = atan2(a.y,a.x)-atan2(b.y,b.x);\n\twhile(theta<=0) theta += 2*PI;\n\twhile(theta>2*PI) theta -= 2*PI;\n\ttheta = min(theta, 2*PI-theta);\n\treturn r*r*theta/2;\n}\ndouble calc(const point &a, const point &b)\n{\n\tpoint p[2];\n\tint num = 0;\n\tint ina = dcmp(abs(a)-r)<0;\n\tint inb = dcmp(abs(b)-r)<0;\n\tif(ina) {\n\t\tif(inb) {\n\t\t\treturn fabs(cross(a,b))/2;\n\t\t}\n\t\telse {\n\t\t\tcircle_cross_line(a,b,point(0,0),r,p,num);\n\t\t\treturn sector_area(b,p[0])+fabs(cross(a,p[0]))/2;\n\t\t}\n\t}\n\telse {\n\t\tif(inb) {\n\t\t\tcircle_cross_line(a,b,point(0,0),r,p,num);\n\t\t\treturn sector_area(p[0],a)+fabs(cross(p[0],b))/2;\n\t\t}\n\t\telse {\n\t\t\tcircle_cross_line(a,b,point(0,0),r,p,num);\n\t\t\tif(num==2) {\n\t\t\t\treturn sector_area(a,p[0])+sector_area(p[1],b)+fabs(cross(p[0],p[1]))/2;\n\t\t\t}\n\t\t\telse return sector_area(a,b);\n\t\t}\n\t}\n}\ndouble area() {\n\tdouble ret = 0;\n\tfor(int i = 0; i<n; i++)\n\t{\n\t\tint sgn = dcmp(cross(res[i], res[i+1]));\n\t\tif(sgn) {\n\t\t\tret += sgn*calc(res[i],res[i+1]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nconst int M = 200;\npoint now;\n\nint main()\n{\n\tsrand(time(0));\n\tint i,j;\n\tdouble minx = 100, maxx = 0, miny = 100, maxy = 0;\n\tcin >> n >> r;\n\tfor(i = 0; i<n; i++)\n\t{\n\t\tcin >> a[i].x >> a[i].y;\n\t\tminx = min(minx, a[i].x);\n\t\tmaxx = max(maxx, a[i].x);\n\t\tminy = min(miny, a[i].y);\n\t\tmaxy = max(maxy, a[i].y);\n\t}\n\ta[n] = a[0];\n\t\n\t\n\tdouble ans = 0,nowa;\n\tpoint mem;\n\tfor(i = 1; i<=M; i++)\n\t{\n\t\tnow.x = myrand(minx, maxx);\n\t\tnow.y = myrand(miny, maxy);\n\t\tfor(j = 0; j<=n; j++)\n\t\t\tres[j] = a[j]-now;\n\t\tnowa = area();\n\t\tif(nowa<eps) {\n\t\t\ti--; continue;\n\t\t}\n\t\tif(rand()%2==0) {\n\t\t\tnow = mem;\n\t\t}\n\t//\tnow.output();\n\t//\tcout << nowa << endl;\n\t\tdouble t;\n\t\tdouble pre = -1;\n\t\tfor(t = 1; t>1e-5; t *= 0.95)\n\t\t{\n\t\t\t\n\t\t\tdouble theta;\n\t\t//\tif(rand()%5 || pre==-1)\n\t\t\t\ttheta = myrand(0,2*PI);\n\t\t//\telse \n\t\t//\t\ttheta = pre;\n\t\t\t\n\t\t\tpoint ne = now+point(cos(theta), sin(theta))*t;\n\t\t//\tne.output();\n\t\t\tfor(j = 0; j<=n; j++)\n\t\t\t\tres[j] = a[j]-ne;\n\t\t\tdouble nea = area();\n\t\t\tif(nea>=nowa/* || myrand(0,1)<0.1*/) {\n\t\t\t\tnowa = nea;\n\t\t\t\tnow = ne;\n\t\t\t\tpre = theta;\n\t\t\t}\n\t\t\tif(ans<nowa) {\n\t\t\t\tans = nowa; mem = now;\n\t\t\t}\n\t\t}\n\t//\tcout << nowa << endl;\n\t//\tnow.output();\n\t\t\n\t}\n\tprintf(\"%0.6lf\\n\", ans);\n//\tcout << ans << endl;\n//\tcout << area() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1000\n#define linf 1e18\n#define eps (1e-10)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n  double getArea(){ return r*r*pi;}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Point p,Circle c){ return abs(p-c.c)-c.r<-eps;}\nbool on(Point p,Circle c){ return fabs(abs(p-c.c)-c.r)<eps;}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\ndouble getArea(Polygon p){\n  double res=0;\n  for(int i=1;i<p.size()-1;i++)res+=cross(p[i]-p[0],p[i+1]-p[0])/2.0;\n  return res;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nbool iscrossLC(Line l,Circle c){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  if(!iscrossLC(s,c))return res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(abs(pp.s-s.p1)-abs(pp.f-s.p1)<eps)swap(pp.f,pp.s);\n  if(ccw(s.p1,s.p2,pp.f)==0 && !(pp.f==s.p1) && !(pp.f==s.p2))res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0 && !(pp.s==s.p1) && !(pp.s==s.p2))res.push_back(pp.s);\n  return res;\n}\n\nbool AllIn(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceLP(L,c.c)-c.r<-eps || ccw(L.p1,L.p2,c.c)==-1)return false;\n  }\n  return true;\n}\n\nbool AllOut(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  if(cross(a,b)<-eps)r=360.0-r;\n  return r;\n}\n\ndouble getCommonAreaTC(Polygon p,Circle c){\n  double res=getArea(p),carea=c.getArea();\n  int n=p.size();\n  vector<Point> s;\n  if(AllIn(p,c))return carea;\n  if(AllOut(p,c)) return 0.0;\n  int start=-1;\n  for(int i=0;i<n;i++){\n    if((c.r-abs(p[i]-c.c))<-eps)start=i;\n  }\n  if(start==-1)return res;\n  for(int i=0;i<n;i++){\n    vector<Point> vp=getCrossPointSC(c,Segment(p[(i+start)%n],\n\t\t\t\t\t       p[(i+1+start)%n]));    \n    for(int j=0;j<vp.size();j++){\n      bool b=true;\n      for(int k=0;k<s.size();k++)if(s[k]==vp[j])b=false;\n      if(b)s.push_back(vp[j]);\n    }\n  }\n  \n  s.push_back(s[0]);\n  s.erase(s.begin());\n\n  for(int i=0;i<s.size();i+=2){\n    Point p1=s[i];\n    Point p2=s[i+1];\n    if(p1==p2)continue;\n    Polygon t;\n    t.push_back(p1);\n    t.push_back(p2);\n    t.push_back(c.c);\n    double narea=getArea(convex_cut(p,Line(p2,p1)));\n    if(narea<eps)continue;\n    res-=narea;\n    double ra=getAngle(p1-c.c,p2-c.c);\n    res+=((carea*ra/360.0)-getArea(t));\n  }\n  return res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++){\n    Polygon t;\n    t.push_back(p[0]);\n    t.push_back(p[i]);\n    t.push_back(p[i+1]);\n    res+=getCommonAreaTC(t,c);\n  }\n  return res;\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,60){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*L,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=inf;\n    FOR(k,0,60){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\n#define CVector CPoint\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1);\nconst double EPS=1e-6;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-10;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n    /*friend bool operator<(CPoint a,CPoint b){//?角排序\n        double tmp=cross(Pts[0],a,b);\n        if(isZero(tmp)){\n            return dist(Pts[0],a)<dist(Pts[0],b);\n        }\n        return tmp>0;\n    }*/\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n/*----------------------多?形相?--------------------------*/\n\n//0:outside 1:inside 2:online\nint PointInPoly(Point t,Point *Pts,int n){\n    int num=0,d1,d2,k;\n    Pts[n]=Pts[0];\n    for(int i=0;i<n;i++){\n        if(PointOnS(t,Line(Pts[i],Pts[i+1]))) return 2;\n        k=dcmp(cross(Pts[i],Pts[i+1],t));\n        d1=dcmp(Pts[i].y-t.y);\n        d2=dcmp(Pts[i+1].y-t.y);\n        if(k>0&&d1<=0&&d2>0) num++;\n        if(k<0&&d2<=0&&d1>0) num--;\n    }\n    return num!=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n//求任意多?形周?，需逆??或???排列\ndouble PolyPerimeter(Point *Pts,int n){\n    double pp=distPP(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pp+=distPP(Pts[i],Pts[i+1]);\n    return pp;\n}\n\n//求多?形重心坐?\nPoint PolyCore(Point *Pts,int n){\n    double pa=PolyArea(Pts,n);\n    if(!dcmp(pa)) return Point(0,0);\n    Point ans=(Pts[n-1]+Pts[0])*cross(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) ans=ans+(Pts[i]+Pts[i+1])*cross(Pts[i],Pts[i+1]);\n    return ans/pa/6;\n}\n\n/*----------------------凸包----------------------------*/\n\n//Graham-scan st:anticlockwise\n//<=:strict <:Non-strict\nint Graham(Point *Pts,Point *st,int n){\n    if(n<3) return 0;\n    sort(Pts,Pts+n);\n    int m=0;\n    for(int i=0;i<n;i++){\n        while(m>1&&dcmp(cross(st[m-2],st[m-1],Pts[i]))<0) m--;\n        st[m++]=Pts[i];\n    }\n    int k=m;\n    for(int i=n-2;i>=0;i--){\n        while(m>k&&dcmp(cross(st[m-2],st[m-1],Pts[i])<0)) m--;\n        st[m++]=Pts[i];\n    }\n    return m-1;\n}\n\n//clockwise:> anticlockwise:<\ndouble CHDiameter(Point *Pts,int n,Line &l){\n    double maxd=0.0;\n    if(n<=1){\n        l.a=l.b=Pts[0];\n        return maxd;\n    }\n    for(int i=0,j=1;i<n;i++){\n        while(cross(Pts[i],Pts[(i+1)%n],Pts[j])\n              >cross(Pts[i],Pts[(i+1)%n],Pts[(j+1)%n])){\n            j=(j+1)%n;\n        }\n        double d=distPP(Pts[i],Pts[j]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n        d=distPP(Pts[(i+1)%n],Pts[(j+1)%n]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n    }\n    return maxd;\n}\n\n/*---------------------整点多?形---------------------------*/\n\nint gcd(int a,int b){\n    return b==0?a :gcd(b,a%b);\n}\n\n//整点多?形?界整点数\nint Border_Int_Point_Num(Point *Pts,int n){\n    int num=gcd(abs(int(Pts[0].x-Pts[n-1].x)),abs(int(Pts[0].y-Pts[n-1].y)));;\n    for(int i=0;i<n-1;i++){\n        num+=gcd(abs(int(Pts[i+1].x-Pts[i].x)),abs(int(Pts[i+1].y-Pts[i].y)));\n    }\n    return num;\n}\n\n//整点多?形内部整点数\nint Inside_Int_Point_Num(Point *Pts,int n){\n    return abs(int(PolyArea(Pts,n)))+1-Border_Int_Point_Num(Pts,n)/2;\n}\n\n/*-----------------------------半平面交-------------------------------*/\n\n//有方向的直?\n//p->p+v\nstruct Vector{\n    Point p,v;\n    double ang;\n    Vector(Point p,Point v):p(p),v(v){\n        ang=atan2(v.y,v.x);\n    }\n    Vector(){}\n    bool operator<(const Vector &l) const{\n        return ang<l.ang;\n    }\n};\n\n//判断点p是否在直?L左?\nbool onLeft(Vector L,Point p){\n    return cross(L.v,p-L.p)>0;\n}\n\n//得到a与b?直?的交点\nPoint getCrossVV(Vector a,Vector b){\n    Point u=a.p-b.p;\n    double t=cross(b.v,u)/cross(a.v,b.v);\n    return a.p+a.v*t;\n}\n\n//所有直?左半平面的交\nint HPCross(Vector *L,int n,Point *poly){\n    sort(L,L+n);\n    int f=0,l=0;\n    Point *p=new Point[n];\n    Vector *q=new Vector[n];\n    q[0]=L[0];\n    for(int i=1;i<n;i++){\n        while(f<l&&!onLeft(L[i],p[l-1])) l--;\n        while(f<l&&!onLeft(L[i],p[f])) f++;\n        q[++l]=L[i];\n        if(!dcmp(cross(q[l].v,q[l-1].v))){\n            l--;\n            if(onLeft(q[l],L[i].p)) q[l]=L[i];\n        }\n        if(f<l) p[l-1]=getCrossVV(q[l-1],q[l]);\n    }\n    while(f<l&&!onLeft(q[f],p[l-1])) l--;\n    if(l-f<=1) return 0;\n    p[l]=getCrossVV(q[l],q[f]);\n    int m=0;\n    for(int i=f;i<=l;i++) poly[m++]=p[i];\n    return m;\n}\n\n#define maxn 100005\nVector l[maxn];\nbool retract(Vector *L,int n,double r,Point *poly){\n    for(int i=0;i<n;i++){\n        Point v=rotateV(L[i].p,L[i].p+L[i].v,PI/2);\n        l[i]=Vector(L[i].p+r*v,L[i].v);\n    }\n    int cnt=HPCross(l,n,poly);\n    return cnt;\n}\n\n/*---------------------三角形相?---------------------------*/\n\n//三角形重心\n//到三?点距?的平方和最小的点\n//到三?距?之?最大的点\nPoint TCore(Point a,Point b,Point c){\n    return (a+b+c)/3;\n}\n\n//三角形外心\nPoint TCircum(Point a,Point b,Point c){\n    Point cp;\n    double a1=b.x-a.x;\n    double b1=b.y-a.y;\n    double a2=c.x-a.x;\n    double b2=c.y-a.y;\n    double c1=(a1*a1+b1*b1)/2;\n    double c2=(a2*a2+b2*b2)/2;\n    double d=a1*b2-a2*b1;\n    cp.x=a.x+(c1*b2-c2*b1)/d;\n    cp.y=a.y+(a1*c2-a2*c1)/d;\n    return cp;\n}\n\n//三角形垂心\nPoint TOrtho(Point a,Point b,Point c){\n    return TCore(a,b,c)*3.0-TCircum(a,b,c)*2.0;\n}\n\n//三角形内心\nPoint TInner(Point a,Point b,Point c){\n    Point cp;\n    double la=distPP(b,c),lb=distPP(c,a),lc=distPP(a,b);\n    cp.x=(la*a.x+lb*b.x+lc*c.x)/(la+lb+lc);\n    cp.y=(la*a.y+lb*b.y+lc*c.y)/(la+lb+lc);\n    return cp;\n}\n\n//求三角形面?\ndouble TArea(Point a,Point b,Point c){\n    return fabs(cross(a,b,c))/2;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n//求??面?交\ndouble getAreaCC(Circle a,Circle b){\n    double d=(a.o.x-b.o.x)*(a.o.x-b.o.x)+(a.o.y-b.o.y)*(a.o.y-b.o.y);\n    if(d<=(a.r-b.r)*(a.r-b.r)){\n        return min(a.r,b.r)*min(a.r,b.r)*PI;\n    }else if(d>(a.r-b.r)*(a.r-b.r)&&d<(a.r+b.r)*(a.r+b.r)){\n        double m1=(a.r*a.r+d-b.r*b.r)/(2*a.r*sqrt(d));\n        double m2=(b.r*b.r+d-a.r*a.r)/(2*b.r*sqrt(d));\n        double s1=acos(m1)*a.r*a.r;\n        double s2=acos(m2)*b.r*b.r;\n        double s3=sqrt(d)*a.r*sin(acos(m1));\n        return s1+s2-s3;\n    }\n    return 0.0;\n}\n\n/********************************************************/\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n\nint getCrossCS(Circle c,Line s,Point *cs){\n    int fg=dcmp(distPL(c.o,s)-c.r);\n    int cnt=0;\n    Point rt=root(c.o,s);\n    if(!fg){\n        if(PointOnS(rt,s)) cs[cnt++]=rt;\n    }else if(fg==-1){\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        Point p1=rt+r*unit(s.b-s.a);\n        Point p2=rt-r*unit(s.b-s.a);\n        if(PointOnS(p1,s)) cs[cnt++]=p1;\n        if(PointOnS(p2,s)) cs[cnt++]=p2;\n    }\n    return cnt;\n}\n\ndouble getAngle(Point a,Point b){\n    double tmp=dot(a,b)/(length(a)*length(b));\n    if(tmp<-1.0) tmp=-1.0;\n    if(1.0<tmp) tmp=1.0;\n    return acos(tmp)*180.0/PI;\n}\n\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=fabs(cross(a-c.o,b-c.o)/2);\n    if(!dcmp(atc)) return 0.0;\n    double la=length(a-c.o),lb=length(b-c.o);\n    Point cs[4];\n    if(la<c.r+EPS&&lb>c.r-EPS){\n        getCrossCS(c,Line(a,b),cs);\n        Point p=cs[0];\n        atc+=0.5*c.area()*angleVV(p-c.o,b-c.o);\n        atc-=0.5*fabs(cross(p-c.o,b-c.o));\n    }else if(la>c.r-EPS&&lb<c.r+EPS){\n        getCrossCS(c,Line(a,b),cs);\n        Point p=cs[0];\n        atc+=0.5*c.area()*angleVV(p-c.o,a-c.o);\n        atc-=0.5*fabs(cross(p-c.o,a-c.o));\n    }else if(la>c.r-EPS&&lb>c.r-EPS){\n        if(distPS(c.o,Line(a,b))<c.r+EPS){\n            Point rt=root(c.o,Line(a,b));\n            atc=fabs(getAreaTC(a,rt,c))+fabs(getAreaTC(rt,b,c));\n        }else atc=0.5*c.area()*angleVV(a-c.o,b-c.o);\n    }\n    if(cross(a-c.o,b-c.o)>0.0) atc=-atc;\n    return atc;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=getAreaTC(Pts[n-1],Pts[0],c);\n    for(int i=0;i<n-1;i++) apc+=getAreaTC(Pts[i],Pts[i+1],c);\n    return fabs(apc);\n}\n\n/********************************************************/\n\n\n/*----------------------三?点、?基本函数-----------------------------*/\n\nstruct Point3{\n    double x,y,z;\n    Point3(double x,double y,double z):x(x),y(y),z(z){}\n    Point3(){}\n    void Read(){ scanf(\"%lf%lf%lf\",&x,&y,&z); }\n};\n\nstruct Line3{\n    Point3 a,b;\n    Line3(Point3 a,Point3 b):a(a),b(b){}\n    Line3(){}\n    void Read(){ a.Read(); b.Read(); }\n};\nPoint3 operator +(Point3 a,Point3 b){ return Point3(a.x+b.x,a.y+b.y,a.z+b.z); }\nPoint3 operator -(Point3 a,Point3 b){ return Point3(a.x-b.x,a.y-b.y,a.z-b.z); }\ndouble operator *(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 operator *(Point3 a,double k){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator *(double k,Point3 a){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator /(Point3 a,double k){ return Point3(a.x/k,a.y/k,a.z/k); }\n\ndouble length(Point3 a){ return sqrt(a.x*a.x+a.y*a.y+a.z*a.z); }\nPoint3 unit(Point3 a){ return a/length(a); }\ndouble dot(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 cross(Point3 a,Point3 b){\n    return Point3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//混合?\ndouble Mix(Point3 a,Point3 b,Point3 c){\n    return dot(a,cross(b,c));\n}\n\n//?点距?\ndouble dist(const Point3 &a,const Point3 &b){ return length(a-b); }\n\n/*---------------------------------体?-------------------------------------*/\n\n//四面体体?\ndouble volume(double l,double n,double a,double m,double b,double c){\n    double x,y;\n    x=4*a*a*b*b*c*c-a*a*(b*b+c*c-m*m)*(b*b+c*c-m*m)-b*b*(c*c+a*a-n*n)*(c*c+a*a-n*n);\n    y=c*c*(a*a+b*b-l*l)*(a*a+b*b-l*l)-(a*a+b*b-l*l)*(b*b+c*c-m*m)*(c*c+a*a-n*n);\n    return sqrt(x-y)/12;\n}\n\ndouble volume(Point3 a,Point3 b,Point3 c,Point3 d){\n    return fabs(Mix(b-a,c-a,d-a)/6);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=maxy,r=miny;\n    Line s=Line(Point(x,0),Point(x,1));\n    for(int i=1;i<=n;i++){\n        Point st=getCrossLL(s,Line(Pts[i],Pts[i+1]));\n        if(PointOnS(st,Line(Pts[i],Pts[i+1]))){\n            l=min(l,st.y);\n            r=max(r,st.y);\n        }\n    }\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);cin.tie(0);\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n+1-i].x>>Pts[n+1-i].y;\n        minx=min(minx,Pts[n+1-i].x);\n        miny=min(miny,Pts[n+1-i].y);\n        maxx=max(maxx,Pts[n+1-i].x);\n        maxy=max(maxy,Pts[n+1-i].y);\n    }\n    Pts[n+1]=Pts[1];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\n\nstruct P {\n\tdouble x, y;\n\tP() {\n\t}\n\tP(double _x, double _y) :\n\t\t\tx(_x), y(_y) {\n\t}\n\tP operator+(const P&p) const {\n\t\treturn P(x + p.x, y + p.y);\n\t}\n\tP operator-(const P&p) const {\n\t\treturn P(x - p.x, y - p.y);\n\t}\n\tP operator*(double d) const {\n\t\treturn P(x * d, y * d);\n\t}\n\tP operator/(double d) const {\n\t\treturn P(x / d, y / d);\n\t}\n\tdouble det(const P&p) const {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdouble dot(const P&p) const {\n\t\treturn x * p.x + y * p.y;\n\t}\n\tdouble alpha() const {\n\t\treturn atan2(y, x);\n\t}\n\tP rot90() const {\n\t\treturn P(-y, x);\n\t}\n\tvoid read() {\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t}\n\tvoid write() const {\n\t\tprintf(\"(%lf,%lf)\", x, y);\n\t}\n\tdouble abs() {\n\t\treturn sqrt(abs2());\n\t}\n\tdouble abs2() {\n\t\treturn x * x + y * y;\n\t}\n\tP unit() {\n\t\treturn *this / abs();\n\t}\n};\n\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n\nconst double EPS = 1e-8; //you should change it according to problem, nevertheless, it mustn't be a constant value some times.\ninline int sign(double a) {\n\treturn a < -EPS ? -1 : a > EPS;\n}\n\n#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))\n\nP isSS(P p1, P p2, P q1, P q2) {\n\tdouble a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);\n\treturn (p1 * a2 + p2 * a1) / (a1 + a2);\n}\n\nint n;\n\ndouble x[12],y[12],r;\n\nbool onLine(P p, P q, P x){\n\treturn (x-p).dot(x-q) <= 0;\n}\n\nvector<P> isCS(P c,double r,P p, P q){\n\tdouble d = cross(q,p,c) / (p-q).abs();\n\tvector<P> ret;\n\n\tif(d>=r+EPS)\n\t\treturn ret;\n\n\tP dir = (q-p).rot90();\n\tP pq = (p-q);\n\tpq = pq/pq.abs();\n\n\tdir = dir / dir.abs();\n\n\tP mid = c + dir * d;\n\n\tdouble h = sqrt(max(r*r-d*d,0.0));\n\tif(onLine(p,q,mid + pq*h))\n\t\tret.push_back(mid + pq*h);\n\tif(onLine(p,q,mid - pq*h))\n\t\tret.push_back(mid - pq*h);\n\treturn ret;\n}\n\ndouble rad(P p,P q){\n\treturn atan2(p.det(q),p.dot(q));\n}\n\ndouble calc(P p, P q){\n\tbool inp = p.abs2() <= r*r;\n\tbool inq = q.abs2() <= r*r;\n\tif(inp && inq){\n\t\treturn p.det(q)/2;\n\t}\n\tif(inp && !inq){\n\t\treturn -calc(q,p);\n\t}\n\tvector<P> is = isCS(P(0,0),r,p,q);\n\tif(!inp && inq){\n\t\tP m = is[0];\n\t\treturn r*r*rad(p,m)/2 + m.det(q)/2;\n\t}\n\n\tif(!inp && !inq){\n\t\tif(is.empty())\n\t\t\treturn r*r*rad(p,q)/2;\n\t\treturn r*r*(rad(p,is[0]) + rad(is[1],q))/2 + is[0].det(is[1])/2;\n\t}\n}\n\ndouble calcArea(double cx,double cy){\n\tP ps[12];\n\trep(i,n) ps[i].x=x[i]-cx,ps[i].y=y[i]-cy;\n\tps[n] = ps[0];\n\n\tdouble area = 0;\n\n\trep(i,n){\n\t\tP p=ps[i],q=ps[i+1];\n\t\tarea += calc(p,q);\n\t}\n\n\t//cout<<area<<endl;\n\n\treturn area;\n}\n\ndouble ffy(double x){\n\tdouble l=*min_element(y,y+n),r=*max_element(y,y+n);\n\trep(it,100){\n\t\tdouble ll=(l*2+r)/3,rr=(l+r*2)/3;\n\t\tif(calcArea(x,ll)>calcArea(x,rr))\n\t\t\tr=rr;\n\t\telse\n\t\t\tl=ll;\n\t}\n\treturn calcArea(x,l);\n}\n\ndouble ffx(){\n\tdouble l=*min_element(x,x+n),r=*max_element(x,x+n);\n\trep(it,100){\n\t\tdouble ll=(l*2+r)/3,rr=(l+r*2)/3;\n\t\tif(ffy(ll)>ffy(rr))\n\t\t\tr=rr;\n\t\telse\n\t\t\tl=ll;\n\t}\n\treturn ffy(l);\n}\n\nint main(){\n\tcin>>n>>r;\n\trep(i,n) cin>>x[i]>>y[i];\n\n\tprintf(\"%0.10lf\\n\",ffx());\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 400\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n  double getArea(){ return r*r*pi;}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Point p,Circle c){ return abs(p-c.c)-c.r<-eps;}\nbool on(Point p,Circle c){ return fabs(abs(p-c.c)-c.r)<eps;}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\ndouble getArea(Polygon p){\n  double res=0;\n  for(int i=1;i<p.size()-1;i++)res+=cross(p[i]-p[0],p[i+1]-p[0])/2.0;\n  return res;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nbool iscrossLC(Line l,Circle c){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  if(!iscrossLC(s,c))return res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(abs(pp.s-s.p1)-abs(pp.f-s.p1)<eps)swap(pp.f,pp.s);\n  if(ccw(s.p1,s.p2,pp.f)==0)res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0)res.push_back(pp.s);\n  return res;\n}\n\nbool AllIn(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceLP(L,c.c)-c.r<-eps || ccw(L.p1,L.p2,c.c)==-1)return false;\n  }\n  return true;\n}\n\nbool AllOut(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\ndouble getCommonAreaTC(Polygon p,Circle c){\n  double res=getArea(p),carea=c.getArea();\n  int n=p.size();\n  bool flag=false;\n  if(res<0.0){\n    flag=true;\n    reverse(p.begin(),p.end());\n    res=getArea(p);\n  }\n  vector<Point> s;\n  if(AllIn(p,c))return carea;\n  if(AllOut(p,c)) return 0.0;\n  int start=-1;\n  for(int i=0;i<n;i++){\n    if((c.r-abs(p[i]-c.c))<-eps)start=i;\n  }\n  if(start==-1)return res;\n  for(int i=0;i<n;i++){\n    vector<Point> vp=getCrossPointSC(c,Segment(p[(i+start)%n],\n\t\t\t\t\t       p[(i+1+start)%n]));    \n    for(int j=0;j<vp.size();j++){\n      bool b=true;\n      for(int k=0;k<s.size();k++)if(s[k]==vp[j])b=false;\n      if(b)s.push_back(vp[j]);\n    }\n  }\n\n  s.push_back(s[0]);\n  s.erase(s.begin());\n\n  for(int i=0;i<s.size();i+=2){\n    Point p1=s[i];\n    Point p2=s[i+1];\n    if(p1==p2)continue;\n    Polygon t;\n    t.push_back(p1);\n    t.push_back(p2);\n    t.push_back(c.c);\n    double narea=getArea(convex_cut(p,Line(p2,p1)));\n    if(narea<eps)continue;\n    res-=narea;\n    double ra=acos(dot(p1-c.c,p2-c.c)/(abs(p1-c.c)*abs(p2-c.c)))*(360/(2*pi));\n    if(ccw(c.c,p1,p2)==-1)ra=180.0;\n    res+=((carea*ra/360.0)-getArea(t));\n  }\n  if(!flag)return res;\n  return -res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++){\n    Polygon t;\n    t.push_back(p[0]);\n    t.push_back(p[i]);\n    t.push_back(p[i+1]);\n    res+=getCommonAreaTC(t,c);\n  }\n  return res;\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,50){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*(m1-r),r));\n    double res2=getCommonAreaPC(p,Circle(a+v*(m2-r),r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*(L-r),r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=inf;\n    FOR(k,0,50){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\n#define CVector CPoint\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1);\nconst double EPS=1e-6;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-10;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n    /*friend bool operator<(CPoint a,CPoint b){//?角排序\n        double tmp=cross(Pts[0],a,b);\n        if(isZero(tmp)){\n            return dist(Pts[0],a)<dist(Pts[0],b);\n        }\n        return tmp>0;\n    }*/\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n/*----------------------多?形相?--------------------------*/\n\n//0:outside 1:inside 2:online\nint PointInPoly(Point t,Point *Pts,int n){\n    int num=0,d1,d2,k;\n    Pts[n]=Pts[0];\n    for(int i=0;i<n;i++){\n        if(PointOnS(t,Line(Pts[i],Pts[i+1]))) return 2;\n        k=dcmp(cross(Pts[i],Pts[i+1],t));\n        d1=dcmp(Pts[i].y-t.y);\n        d2=dcmp(Pts[i+1].y-t.y);\n        if(k>0&&d1<=0&&d2>0) num++;\n        if(k<0&&d2<=0&&d1>0) num--;\n    }\n    return num!=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n//求任意多?形周?，需逆??或???排列\ndouble PolyPerimeter(Point *Pts,int n){\n    double pp=distPP(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pp+=distPP(Pts[i],Pts[i+1]);\n    return pp;\n}\n\n//求多?形重心坐?\nPoint PolyCore(Point *Pts,int n){\n    double pa=PolyArea(Pts,n);\n    if(!dcmp(pa)) return Point(0,0);\n    Point ans=(Pts[n-1]+Pts[0])*cross(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) ans=ans+(Pts[i]+Pts[i+1])*cross(Pts[i],Pts[i+1]);\n    return ans/pa/6;\n}\n\n/*----------------------凸包----------------------------*/\n\n//Graham-scan st:anticlockwise\n//<=:strict <:Non-strict\nint Graham(Point *Pts,Point *st,int n){\n    if(n<3) return 0;\n    sort(Pts,Pts+n);\n    int m=0;\n    for(int i=0;i<n;i++){\n        while(m>1&&dcmp(cross(st[m-2],st[m-1],Pts[i]))<0) m--;\n        st[m++]=Pts[i];\n    }\n    int k=m;\n    for(int i=n-2;i>=0;i--){\n        while(m>k&&dcmp(cross(st[m-2],st[m-1],Pts[i])<0)) m--;\n        st[m++]=Pts[i];\n    }\n    return m-1;\n}\n\n//clockwise:> anticlockwise:<\ndouble CHDiameter(Point *Pts,int n,Line &l){\n    double maxd=0.0;\n    if(n<=1){\n        l.a=l.b=Pts[0];\n        return maxd;\n    }\n    for(int i=0,j=1;i<n;i++){\n        while(cross(Pts[i],Pts[(i+1)%n],Pts[j])\n              >cross(Pts[i],Pts[(i+1)%n],Pts[(j+1)%n])){\n            j=(j+1)%n;\n        }\n        double d=distPP(Pts[i],Pts[j]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n        d=distPP(Pts[(i+1)%n],Pts[(j+1)%n]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n    }\n    return maxd;\n}\n\n/*---------------------整点多?形---------------------------*/\n\nint gcd(int a,int b){\n    return b==0?a :gcd(b,a%b);\n}\n\n//整点多?形?界整点数\nint Border_Int_Point_Num(Point *Pts,int n){\n    int num=gcd(abs(int(Pts[0].x-Pts[n-1].x)),abs(int(Pts[0].y-Pts[n-1].y)));;\n    for(int i=0;i<n-1;i++){\n        num+=gcd(abs(int(Pts[i+1].x-Pts[i].x)),abs(int(Pts[i+1].y-Pts[i].y)));\n    }\n    return num;\n}\n\n//整点多?形内部整点数\nint Inside_Int_Point_Num(Point *Pts,int n){\n    return abs(int(PolyArea(Pts,n)))+1-Border_Int_Point_Num(Pts,n)/2;\n}\n\n/*-----------------------------半平面交-------------------------------*/\n\n//有方向的直?\n//p->p+v\nstruct Vector{\n    Point p,v;\n    double ang;\n    Vector(Point p,Point v):p(p),v(v){\n        ang=atan2(v.y,v.x);\n    }\n    Vector(){}\n    bool operator<(const Vector &l) const{\n        return ang<l.ang;\n    }\n};\n\n//判断点p是否在直?L左?\nbool onLeft(Vector L,Point p){\n    return cross(L.v,p-L.p)>0;\n}\n\n//得到a与b?直?的交点\nPoint getCrossVV(Vector a,Vector b){\n    Point u=a.p-b.p;\n    double t=cross(b.v,u)/cross(a.v,b.v);\n    return a.p+a.v*t;\n}\n\n//所有直?左半平面的交\nint HPCross(Vector *L,int n,Point *poly){\n    sort(L,L+n);\n    int f=0,l=0;\n    Point *p=new Point[n];\n    Vector *q=new Vector[n];\n    q[0]=L[0];\n    for(int i=1;i<n;i++){\n        while(f<l&&!onLeft(L[i],p[l-1])) l--;\n        while(f<l&&!onLeft(L[i],p[f])) f++;\n        q[++l]=L[i];\n        if(!dcmp(cross(q[l].v,q[l-1].v))){\n            l--;\n            if(onLeft(q[l],L[i].p)) q[l]=L[i];\n        }\n        if(f<l) p[l-1]=getCrossVV(q[l-1],q[l]);\n    }\n    while(f<l&&!onLeft(q[f],p[l-1])) l--;\n    if(l-f<=1) return 0;\n    p[l]=getCrossVV(q[l],q[f]);\n    int m=0;\n    for(int i=f;i<=l;i++) poly[m++]=p[i];\n    return m;\n}\n\n#define maxn 100005\nVector l[maxn];\nbool retract(Vector *L,int n,double r,Point *poly){\n    for(int i=0;i<n;i++){\n        Point v=rotateV(L[i].p,L[i].p+L[i].v,PI/2);\n        l[i]=Vector(L[i].p+r*v,L[i].v);\n    }\n    int cnt=HPCross(l,n,poly);\n    return cnt;\n}\n\n/*---------------------三角形相?---------------------------*/\n\n//三角形重心\n//到三?点距?的平方和最小的点\n//到三?距?之?最大的点\nPoint TCore(Point a,Point b,Point c){\n    return (a+b+c)/3;\n}\n\n//三角形外心\nPoint TCircum(Point a,Point b,Point c){\n    Point cp;\n    double a1=b.x-a.x;\n    double b1=b.y-a.y;\n    double a2=c.x-a.x;\n    double b2=c.y-a.y;\n    double c1=(a1*a1+b1*b1)/2;\n    double c2=(a2*a2+b2*b2)/2;\n    double d=a1*b2-a2*b1;\n    cp.x=a.x+(c1*b2-c2*b1)/d;\n    cp.y=a.y+(a1*c2-a2*c1)/d;\n    return cp;\n}\n\n//三角形垂心\nPoint TOrtho(Point a,Point b,Point c){\n    return TCore(a,b,c)*3.0-TCircum(a,b,c)*2.0;\n}\n\n//三角形内心\nPoint TInner(Point a,Point b,Point c){\n    Point cp;\n    double la=distPP(b,c),lb=distPP(c,a),lc=distPP(a,b);\n    cp.x=(la*a.x+lb*b.x+lc*c.x)/(la+lb+lc);\n    cp.y=(la*a.y+lb*b.y+lc*c.y)/(la+lb+lc);\n    return cp;\n}\n\n//求三角形面?\ndouble TArea(Point a,Point b,Point c){\n    return fabs(cross(a,b,c))/2;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n//求??面?交\ndouble getAreaCC(Circle a,Circle b){\n    double d=(a.o.x-b.o.x)*(a.o.x-b.o.x)+(a.o.y-b.o.y)*(a.o.y-b.o.y);\n    if(d<=(a.r-b.r)*(a.r-b.r)){\n        return min(a.r,b.r)*min(a.r,b.r)*PI;\n    }else if(d>(a.r-b.r)*(a.r-b.r)&&d<(a.r+b.r)*(a.r+b.r)){\n        double m1=(a.r*a.r+d-b.r*b.r)/(2*a.r*sqrt(d));\n        double m2=(b.r*b.r+d-a.r*a.r)/(2*b.r*sqrt(d));\n        double s1=acos(m1)*a.r*a.r;\n        double s2=acos(m2)*b.r*b.r;\n        double s3=sqrt(d)*a.r*sin(acos(m1));\n        return s1+s2-s3;\n    }\n    return 0.0;\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n/********************************************************/\nint getCrossCS(Circle c,Line s,Point *cs){\n    Point tmp[2];\n    int cnt=0;\n    int ct=getCrossCL(c,s,tmp);\n    for(int i=0;i<ct;i++){\n        if(PointOnS(tmp[i],s)) cs[cnt++]=tmp[i];\n    }\n    return cnt;\n}\n\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=fabs(cross(a-c.o,b-c.o)/2);\n    if(!dcmp(atc)) return 0.0;\n    double la=length(a-c.o),lb=length(b-c.o);\n    Point cs[4];\n    if(la<c.r&&lb>=c.r){\n        getCrossCS(c,Line(a,b),cs);\n        Point p=cs[0];\n        atc+=0.5*c.r*c.r*angleVV(p-c.o,b-c.o);\n        atc-=fabs(cross(p-c.o,b-c.o)/2);\n    }else if(la>=c.r&&lb<c.r){\n        getCrossCS(c,Line(a,b),cs);\n        Point p=cs[0];\n        atc+=0.5*c.r*c.r*angleVV(p-c.o,a-c.o);\n        atc-=fabs(cross(p-c.o,a-c.o)/2);\n    }else if(la>c.r&&lb>c.r){\n        if(distPS(c.o,Line(a,b))<c.r-EPS){\n            Point rt=root(c.o,Line(a,b));\n            atc=fabs(getAreaTC(a,rt,c))+fabs(getAreaTC(rt,b,c));\n        }else atc=0.5*c.r*c.r*angleVV(a-c.o,b-c.o);\n    }\n    if(dcmp(cross(a-c.o,b-c.o))==1) atc=-atc;\n    return atc;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=getAreaTC(Pts[n-1],Pts[0],c);\n    for(int i=0;i<n-1;i++) apc+=getAreaTC(Pts[i],Pts[i+1],c);\n    return fabs(apc);\n}\n\n/********************************************************/\n\n\n/*----------------------三?点、?基本函数-----------------------------*/\n\nstruct Point3{\n    double x,y,z;\n    Point3(double x,double y,double z):x(x),y(y),z(z){}\n    Point3(){}\n    void Read(){ scanf(\"%lf%lf%lf\",&x,&y,&z); }\n};\n\nstruct Line3{\n    Point3 a,b;\n    Line3(Point3 a,Point3 b):a(a),b(b){}\n    Line3(){}\n    void Read(){ a.Read(); b.Read(); }\n};\nPoint3 operator +(Point3 a,Point3 b){ return Point3(a.x+b.x,a.y+b.y,a.z+b.z); }\nPoint3 operator -(Point3 a,Point3 b){ return Point3(a.x-b.x,a.y-b.y,a.z-b.z); }\ndouble operator *(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 operator *(Point3 a,double k){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator *(double k,Point3 a){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator /(Point3 a,double k){ return Point3(a.x/k,a.y/k,a.z/k); }\n\ndouble length(Point3 a){ return sqrt(a.x*a.x+a.y*a.y+a.z*a.z); }\nPoint3 unit(Point3 a){ return a/length(a); }\ndouble dot(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 cross(Point3 a,Point3 b){\n    return Point3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//混合?\ndouble Mix(Point3 a,Point3 b,Point3 c){\n    return dot(a,cross(b,c));\n}\n\n//?点距?\ndouble dist(const Point3 &a,const Point3 &b){ return length(a-b); }\n\n/*---------------------------------体?-------------------------------------*/\n\n//四面体体?\ndouble volume(double l,double n,double a,double m,double b,double c){\n    double x,y;\n    x=4*a*a*b*b*c*c-a*a*(b*b+c*c-m*m)*(b*b+c*c-m*m)-b*b*(c*c+a*a-n*n)*(c*c+a*a-n*n);\n    y=c*c*(a*a+b*b-l*l)*(a*a+b*b-l*l)-(a*a+b*b-l*l)*(b*b+c*c-m*m)*(c*c+a*a-n*n);\n    return sqrt(x-y)/12;\n}\n\ndouble volume(Point3 a,Point3 b,Point3 c,Point3 d){\n    return fabs(Mix(b-a,c-a,d-a)/6);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);//cin.tie(0);\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-9)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n\nPoint calc_ps(Polygon poly) {\n  poly = andrewScan(poly);\n  Point mp = poly[0];\n  double rate = 1; // 0.5???????????¨???\n  int max_pos;\n  double eps = 1e-10; // 1e-20???????????¨???\n  while( rate > eps ) {\n    rep(_,60){ // 70???????????¨???\n      max_pos = 0;\n      REP(j,1,(int)poly.size()) {\n        double dist1 = abs(mp-poly[max_pos]);\n        double dist2 = abs(mp-poly[j]);\n\tif( LT(dist1,dist2) ) max_pos = j;\n      }\n      mp.x += ( poly[max_pos].x - mp.x ) * rate;\n      mp.y += ( poly[max_pos].y - mp.y ) * rate;\n    }\n    rate *= 0.5;\n  }\n  return mp;\n}\n\nPoint getCentroidOfConvex(Polygon& poly){\n  double area = getArea(poly);\n  int V = poly.size();\n  assert( !equals(area,0.0) );\n  double x = 0, y = 0;\n  rep(i,(int)poly.size()) {\n    x += ( poly[i].x + poly[(i+1)%V].x ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n    y += ( poly[i].y + poly[(i+1)%V].y ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n  }\n  return Point(x/(6.0*area),y/(6.0*area));\n}\n\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  double maxi;\n  Point mp = calc_ps(poly);\n  maxi = getCommonAreaPolygonCircle(poly,mp,r);\n  double rate = 1.0;\n  double eps = 1e-10;\n  while( LT(eps,rate) ) {\n    rep(_,70) {\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      assert( !equals(max_area,-1) );\n      mp = np;\n      if( LT(maxi,max_area) ) maxi = max_area;\n    }\n    rate *= 0.5;\n  }\n  rep(__,1) {\n    Point mp = calc_ps(poly);\n    double rate = 1.0;\n    double eps = 1e-10;\n    while( LT(eps,rate) ) {\n      rep(_,70) {\n\tdouble max_area = -1; \n\tPoint np;\n\trep(i,n) {\n\t  Point tp = mp;\n\t  tp.x += ( poly[i].x - mp.x ) * rate;\n\t  tp.y += ( poly[i].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,tp,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t    np = tp;\n\t  }\n\t}\n\tif( rand() % 50 == 0 ) {\n\t  int v = rand() % n;\n\t  np.x = ( poly[v].x - mp.x ) * rate;\n\t  np.y = ( poly[v].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,np,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t  }\n\t}\n\tassert( !equals(max_area,-1) );\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      rate *= 0.5;\n    }\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  srand((unsigned int)time(NULL));\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  //cout << getArea(poly) << endl;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\n#define CVector CPoint\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-7;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n    /*friend bool operator<(CPoint a,CPoint b){//?角排序\n        double tmp=cross(Pts[0],a,b);\n        if(isZero(tmp)){\n            return dist(Pts[0],a)<dist(Pts[0],b);\n        }\n        return tmp>0;\n    }*/\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n/*----------------------多?形相?--------------------------*/\n\n//0:outside 1:inside 2:online\nint PointInPoly(Point t,Point *Pts,int n){\n    int num=0,d1,d2,k;\n    Pts[n]=Pts[0];\n    for(int i=0;i<n;i++){\n        if(PointOnS(t,Line(Pts[i],Pts[i+1]))) return 2;\n        k=dcmp(cross(Pts[i],Pts[i+1],t));\n        d1=dcmp(Pts[i].y-t.y);\n        d2=dcmp(Pts[i+1].y-t.y);\n        if(k>0&&d1<=0&&d2>0) num++;\n        if(k<0&&d2<=0&&d1>0) num--;\n    }\n    return num!=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n//求任意多?形周?，需逆??或???排列\ndouble PolyPerimeter(Point *Pts,int n){\n    double pp=distPP(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pp+=distPP(Pts[i],Pts[i+1]);\n    return pp;\n}\n\n//求多?形重心坐?\nPoint PolyCore(Point *Pts,int n){\n    double pa=PolyArea(Pts,n);\n    if(!dcmp(pa)) return Point(0,0);\n    Point ans=(Pts[n-1]+Pts[0])*cross(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) ans=ans+(Pts[i]+Pts[i+1])*cross(Pts[i],Pts[i+1]);\n    return ans/pa/6;\n}\n\n/*----------------------凸包----------------------------*/\n\n//Graham-scan st:anticlockwise\n//<=:strict <:Non-strict\nint Graham(Point *Pts,Point *st,int n){\n    if(n<3) return 0;\n    sort(Pts,Pts+n);\n    int m=0;\n    for(int i=0;i<n;i++){\n        while(m>1&&dcmp(cross(st[m-2],st[m-1],Pts[i]))<0) m--;\n        st[m++]=Pts[i];\n    }\n    int k=m;\n    for(int i=n-2;i>=0;i--){\n        while(m>k&&dcmp(cross(st[m-2],st[m-1],Pts[i])<0)) m--;\n        st[m++]=Pts[i];\n    }\n    return m-1;\n}\n\n//clockwise:> anticlockwise:<\ndouble CHDiameter(Point *Pts,int n,Line &l){\n    double maxd=0.0;\n    if(n<=1){\n        l.a=l.b=Pts[0];\n        return maxd;\n    }\n    for(int i=0,j=1;i<n;i++){\n        while(cross(Pts[i],Pts[(i+1)%n],Pts[j])\n              >cross(Pts[i],Pts[(i+1)%n],Pts[(j+1)%n])){\n            j=(j+1)%n;\n        }\n        double d=distPP(Pts[i],Pts[j]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n        d=distPP(Pts[(i+1)%n],Pts[(j+1)%n]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n    }\n    return maxd;\n}\n\n/*---------------------整点多?形---------------------------*/\n\nint gcd(int a,int b){\n    return b==0?a :gcd(b,a%b);\n}\n\n//整点多?形?界整点数\nint Border_Int_Point_Num(Point *Pts,int n){\n    int num=gcd(abs(int(Pts[0].x-Pts[n-1].x)),abs(int(Pts[0].y-Pts[n-1].y)));;\n    for(int i=0;i<n-1;i++){\n        num+=gcd(abs(int(Pts[i+1].x-Pts[i].x)),abs(int(Pts[i+1].y-Pts[i].y)));\n    }\n    return num;\n}\n\n//整点多?形内部整点数\nint Inside_Int_Point_Num(Point *Pts,int n){\n    return abs(int(PolyArea(Pts,n)))+1-Border_Int_Point_Num(Pts,n)/2;\n}\n\n/*-----------------------------半平面交-------------------------------*/\n\n//有方向的直?\n//p->p+v\nstruct Vector{\n    Point p,v;\n    double ang;\n    Vector(Point p,Point v):p(p),v(v){\n        ang=atan2(v.y,v.x);\n    }\n    Vector(){}\n    bool operator<(const Vector &l) const{\n        return ang<l.ang;\n    }\n};\n\n//判断点p是否在直?L左?\nbool onLeft(Vector L,Point p){\n    return cross(L.v,p-L.p)>0;\n}\n\n//得到a与b?直?的交点\nPoint getCrossVV(Vector a,Vector b){\n    Point u=a.p-b.p;\n    double t=cross(b.v,u)/cross(a.v,b.v);\n    return a.p+a.v*t;\n}\n\n//所有直?左半平面的交\nint HPCross(Vector *L,int n,Point *poly){\n    sort(L,L+n);\n    int f=0,l=0;\n    Point *p=new Point[n];\n    Vector *q=new Vector[n];\n    q[0]=L[0];\n    for(int i=1;i<n;i++){\n        while(f<l&&!onLeft(L[i],p[l-1])) l--;\n        while(f<l&&!onLeft(L[i],p[f])) f++;\n        q[++l]=L[i];\n        if(!dcmp(cross(q[l].v,q[l-1].v))){\n            l--;\n            if(onLeft(q[l],L[i].p)) q[l]=L[i];\n        }\n        if(f<l) p[l-1]=getCrossVV(q[l-1],q[l]);\n    }\n    while(f<l&&!onLeft(q[f],p[l-1])) l--;\n    if(l-f<=1) return 0;\n    p[l]=getCrossVV(q[l],q[f]);\n    int m=0;\n    for(int i=f;i<=l;i++) poly[m++]=p[i];\n    return m;\n}\n\n#define maxn 100005\nVector l[maxn];\nbool retract(Vector *L,int n,double r,Point *poly){\n    for(int i=0;i<n;i++){\n        Point v=rotateV(L[i].p,L[i].p+L[i].v,PI/2);\n        l[i]=Vector(L[i].p+r*v,L[i].v);\n    }\n    int cnt=HPCross(l,n,poly);\n    return cnt;\n}\n\n/*---------------------三角形相?---------------------------*/\n\n//三角形重心\n//到三?点距?的平方和最小的点\n//到三?距?之?最大的点\nPoint TCore(Point a,Point b,Point c){\n    return (a+b+c)/3;\n}\n\n//三角形外心\nPoint TCircum(Point a,Point b,Point c){\n    Point cp;\n    double a1=b.x-a.x;\n    double b1=b.y-a.y;\n    double a2=c.x-a.x;\n    double b2=c.y-a.y;\n    double c1=(a1*a1+b1*b1)/2;\n    double c2=(a2*a2+b2*b2)/2;\n    double d=a1*b2-a2*b1;\n    cp.x=a.x+(c1*b2-c2*b1)/d;\n    cp.y=a.y+(a1*c2-a2*c1)/d;\n    return cp;\n}\n\n//三角形垂心\nPoint TOrtho(Point a,Point b,Point c){\n    return TCore(a,b,c)*3.0-TCircum(a,b,c)*2.0;\n}\n\n//三角形内心\nPoint TInner(Point a,Point b,Point c){\n    Point cp;\n    double la=distPP(b,c),lb=distPP(c,a),lc=distPP(a,b);\n    cp.x=(la*a.x+lb*b.x+lc*c.x)/(la+lb+lc);\n    cp.y=(la*a.y+lb*b.y+lc*c.y)/(la+lb+lc);\n    return cp;\n}\n\n//求三角形面?\ndouble TArea(Point a,Point b,Point c){\n    return fabs(cross(a,b,c))/2;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n//求??面?交\ndouble getAreaCC(Circle a,Circle b){\n    double d=(a.o.x-b.o.x)*(a.o.x-b.o.x)+(a.o.y-b.o.y)*(a.o.y-b.o.y);\n    if(d<=(a.r-b.r)*(a.r-b.r)){\n        return min(a.r,b.r)*min(a.r,b.r)*PI;\n    }else if(d>(a.r-b.r)*(a.r-b.r)&&d<(a.r+b.r)*(a.r+b.r)){\n        double m1=(a.r*a.r+d-b.r*b.r)/(2*a.r*sqrt(d));\n        double m2=(b.r*b.r+d-a.r*a.r)/(2*b.r*sqrt(d));\n        double s1=acos(m1)*a.r*a.r;\n        double s2=acos(m2)*b.r*b.r;\n        double s3=sqrt(d)*a.r*sin(acos(m1));\n        return s1+s2-s3;\n    }\n    return 0.0;\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n/********************************************************/\nint getCrossCS(Circle c,Line s,Point *cs){\n    Point tmp[2];\n    int cnt=0;\n    int ct=getCrossCL(c,s,tmp);\n    for(int i=0;i<ct;i++){\n        if(PointOnS(tmp[i],s)) cs[cnt++]=tmp[i];\n    }\n    return cnt;\n}\n\nPoint PinS(Point *cs,int n,Line s){\n    if(n==1) return cs[0];\n    if(!dcmp(cs[0].x-s.a.x)&&!dcmp(cs[0].y-s.a.y)) return cs[1];\n    return cs[0];\n}\n\ndouble getAngle(Point a,Point b){\n    double tmp=dot(a,b)/length(a)/length(b);\n    //if(tmp<-1.0) tmp=-1.0;\n    //if(1.0<tmp) tmp=1.0;\n    return acos(tmp);\n}\n\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=fabs(cross(a-c.o,b-c.o)/2);\n    if(!dcmp(atc)) return 0.0;\n    double la=length(a-c.o),lb=length(b-c.o);\n    Point cs[4];\n    if(la<c.r+EPS&&lb>c.r-EPS){\n        int ct=getCrossCS(c,Line(a,b),cs);\n        Point p=PinS(cs,ct,Line(a,b));\n        atc+=0.5*c.r*c.r*getAngle(p-c.o,b-c.o);\n        atc-=fabs(cross(p-c.o,b-c.o)/2);\n    }else if(la>c.r-EPS&&lb<c.r+EPS){\n        int ct=getCrossCS(c,Line(a,b),cs);\n        Point p=PinS(cs,ct,Line(b,a));\n        atc+=0.5*c.r*c.r*getAngle(p-c.o,a-c.o);\n        atc-=fabs(cross(p-c.o,a-c.o)/2);\n    }else if(la>c.r-EPS&&lb>c.r-EPS){\n        if(distPS(c.o,Line(a,b))<c.r-EPS){\n            Point rt=root(c.o,Line(a,b));\n            atc=fabs(getAreaTC(a,rt,c))+fabs(getAreaTC(rt,b,c));\n        }else atc=0.5*c.r*c.r*getAngle(a-c.o,b-c.o);\n    }\n    if(dcmp(cross(a-c.o,b-c.o))==1) atc=-atc;\n    return atc;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=getAreaTC(Pts[n-1],Pts[0],c);\n    for(int i=0;i<n-1;i++) apc+=getAreaTC(Pts[i],Pts[i+1],c);\n    return fabs(apc);\n}\n\n/********************************************************/\n\n\n/*----------------------三?点、?基本函数-----------------------------*/\n\nstruct Point3{\n    double x,y,z;\n    Point3(double x,double y,double z):x(x),y(y),z(z){}\n    Point3(){}\n    void Read(){ scanf(\"%lf%lf%lf\",&x,&y,&z); }\n};\n\nstruct Line3{\n    Point3 a,b;\n    Line3(Point3 a,Point3 b):a(a),b(b){}\n    Line3(){}\n    void Read(){ a.Read(); b.Read(); }\n};\nPoint3 operator +(Point3 a,Point3 b){ return Point3(a.x+b.x,a.y+b.y,a.z+b.z); }\nPoint3 operator -(Point3 a,Point3 b){ return Point3(a.x-b.x,a.y-b.y,a.z-b.z); }\ndouble operator *(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 operator *(Point3 a,double k){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator *(double k,Point3 a){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator /(Point3 a,double k){ return Point3(a.x/k,a.y/k,a.z/k); }\n\ndouble length(Point3 a){ return sqrt(a.x*a.x+a.y*a.y+a.z*a.z); }\nPoint3 unit(Point3 a){ return a/length(a); }\ndouble dot(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 cross(Point3 a,Point3 b){\n    return Point3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//混合?\ndouble Mix(Point3 a,Point3 b,Point3 c){\n    return dot(a,cross(b,c));\n}\n\n//?点距?\ndouble dist(const Point3 &a,const Point3 &b){ return length(a-b); }\n\n/*---------------------------------体?-------------------------------------*/\n\n//四面体体?\ndouble volume(double l,double n,double a,double m,double b,double c){\n    double x,y;\n    x=4*a*a*b*b*c*c-a*a*(b*b+c*c-m*m)*(b*b+c*c-m*m)-b*b*(c*c+a*a-n*n)*(c*c+a*a-n*n);\n    y=c*c*(a*a+b*b-l*l)*(a*a+b*b-l*l)-(a*a+b*b-l*l)*(b*b+c*c-m*m)*(c*c+a*a-n*n);\n    return sqrt(x-y)/12;\n}\n\ndouble volume(Point3 a,Point3 b,Point3 c,Point3 d){\n    return fabs(Mix(b-a,c-a,d-a)/6);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);//cin.tie(0);\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\n\nstruct P {\n\tdouble x, y;\n\tP() {\n\t}\n\tP(double _x, double _y) :\n\t\t\tx(_x), y(_y) {\n\t}\n\tP operator+(const P&p) const {\n\t\treturn P(x + p.x, y + p.y);\n\t}\n\tP operator-(const P&p) const {\n\t\treturn P(x - p.x, y - p.y);\n\t}\n\tP operator*(double d) const {\n\t\treturn P(x * d, y * d);\n\t}\n\tP operator/(double d) const {\n\t\treturn P(x / d, y / d);\n\t}\n\tdouble det(const P&p) const {\n\t\treturn x * p.y - y * p.x;\n\t}\n\tdouble dot(const P&p) const {\n\t\treturn x * p.x + y * p.y;\n\t}\n\tdouble alpha() const {\n\t\treturn atan2(y, x);\n\t}\n\tP rot90() const {\n\t\treturn P(-y, x);\n\t}\n\tvoid read() {\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t}\n\tvoid write() const {\n\t\tprintf(\"(%lf,%lf)\", x, y);\n\t}\n\tdouble abs() {\n\t\treturn sqrt(abs2());\n\t}\n\tdouble abs2() {\n\t\treturn x * x + y * y;\n\t}\n\tP unit() {\n\t\treturn *this / abs();\n\t}\n};\n\n#define cross(p1,p2,p3) ((p2.x-p1.x)*(p3.y-p1.y)-(p3.x-p1.x)*(p2.y-p1.y))\n\nconst double EPS = 1e-8; //you should change it according to problem, nevertheless, it mustn't be a constant value some times.\ninline int sign(double a) {\n\treturn a < -EPS ? -1 : a > EPS;\n}\n\n#define crossOp(p1,p2,p3) (sign(cross(p1,p2,p3)))\n\nP isSS(P p1, P p2, P q1, P q2) {\n\tdouble a1 = cross(q1,q2,p1), a2 = -cross(q1,q2,p2);\n\treturn (p1 * a2 + p2 * a1) / (a1 + a2);\n}\n\nint n;\n\ndouble x[12],y[12],r;\n\nbool onLine(P p, P q, P x){\n\treturn (x-p).dot(x-q) <= EPS;\n}\n\nvector<P> isCS(P c,double r,P p, P q){\n\tdouble d = cross(q,p,c) / (p-q).abs();\n\tvector<P> ret;\n\n\tif(d>=r+EPS)\n\t\treturn ret;\n\n\tP dir = (q-p).rot90();\n\tP pq = (p-q);\n\tpq = pq/pq.abs();\n\n\tdir = dir / dir.abs();\n\n\tP mid = c + dir * d;\n\n\tdouble h = sqrt(max(r*r-d*d,0.0));\n\tif(onLine(p,q,mid + pq*h))\n\t\tret.push_back(mid + pq*h);\n\tif(onLine(p,q,mid - pq*h))\n\t\tret.push_back(mid - pq*h);\n\treturn ret;\n}\n\ndouble rad(P p,P q){\n\treturn atan2(p.det(q),p.dot(q));\n}\n\ndouble calc(P p, P q){\n\tbool inp = p.abs2() <= r*r;\n\tbool inq = q.abs2() <= r*r;\n\tif(inp && inq){\n\t\treturn p.det(q)/2;\n\t}\n\tif(inp && !inq){\n\t\treturn -calc(q,p);\n\t}\n\tvector<P> is = isCS(P(0,0),r,p,q);\n\tif(!inp && inq){\n\t\tP m = is[0];\n\t\treturn r*r*rad(p,m)/2 + m.det(q)/2;\n\t}\n\n\tif(!inp && !inq){\n\t\tif(is.empty())\n\t\t\treturn r*r*rad(p,q)/2;\n\t\treturn r*r*(rad(p,is[0]) + rad(is[1],q))/2 + is[0].det(is[1])/2;\n\t}\n}\n\ndouble calcArea(double cx,double cy){\n\tP ps[12];\n\trep(i,n) ps[i].x=x[i]-cx,ps[i].y=y[i]-cy;\n\tps[n] = ps[0];\n\n\tdouble area = 0;\n\n\trep(i,n){\n\t\tP p=ps[i],q=ps[i+1];\n\t\tarea += calc(p,q);\n\t}\n\n\treturn area;\n}\n\ndouble ffy(double x){\n\tdouble l=*min_element(y,y+n),r=*max_element(y,y+n);\n\trep(it,100){\n\t\tdouble ll=(l*2+r)/3,rr=(l+r*2)/3;\n\t\tif(calcArea(x,ll)>calcArea(x,rr))\n\t\t\tr=rr;\n\t\telse\n\t\t\tl=ll;\n\t}\n\treturn calcArea(x,l);\n}\n\ndouble ffx(){\n\tdouble l=*min_element(x,x+n),r=*max_element(x,x+n);\n\trep(it,100){\n\t\tdouble ll=(l*2+r)/3,rr=(l+r*2)/3;\n\t\tif(ffy(ll)>ffy(rr))\n\t\t\tr=rr;\n\t\telse\n\t\t\tl=ll;\n\t}\n\treturn ffy(l);\n}\ndouble pi=acos(-1.);\ndouble fuck() {\n\tdouble rx=0,ry=0;\n\trep(i,n) rx=rx+x[i],ry=ry+y[i];\n\trx/=n; ry/=n; double c=calcArea(rx,ry);\n\tdouble step=100;\n\trep(r1,100) {\n\t\trep(r2,300) {\n\t\t\tdouble ang=(rand()%100001)*1e-5*2*pi;\n\t\t\twhile (1) {\n\t\t\t\tdouble px=rx+step*cos(ang),py=ry+step*sin(ang);\n\t\t\t\tdouble f=calcArea(px,py);\n\t\t\t\tif (f>c) c=f,rx=px,ry=py;\n\t\t\t\telse break;\n\t\t\t}\n\t\t}\n//\t\tprintf(\"%.10f\\n\",c);\n\t\tstep*=0.5;\n\t}\n\treturn c;\n}\nint main(){\n\tcin>>n>>r;\n\trep(i,n) cin>>x[i]>>y[i];\n\n\tprintf(\"%0.10lf\\n\",fuck());\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1000\n#define linf 1e18\n#define eps (1e-8)\n#define mod 1000000007\n#define pi M_PI\n#define phi (1.0+sqrt(5))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Circle c,Point p){\n  if(abs(c.c-p)-c.r<-eps)return true;\n  return false;\n}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nbool intersect(Circle c,Segment s){\n  if(getDistanceSP(s,c.c)-c.r<-eps)return true;\n  return false;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  return acos(tmp)*180.0/pi;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nPoint getCrossPointSC(Circle c,Segment s){\n  Point res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(ccw(s.p1,s.p2,pp.f)==0){\n    res=pp.f;\n    if(ccw(s.p1,s.p2,pp.s)==0 && abs(s.p1-pp.s)<abs(s.p1-pp.f))res=pp.s;\n  }\n  else res=pp.s;\n  return res;\n}\n\ndouble getCommonAreaTC(Point a,Point b,Circle c){\n  double res=abs(cross(a-c.c,b-c.c)/2.0);\n  if(equals(0.0,res))return 0.0;\n  if(in(c,a) && !in(c,b)){\n    Point p1=getCrossPointSC(c,Segment(b,a));\n    Point p2=getCrossPointSC(c,Segment(b,c.c)); \n    res+=(c.r*c.r*pi)*(getAngle(p1-c.c,p2-c.c)/360.0);\n    res-=abs(cross(p1-c.c,p2-c.c)/2.0);\n    res-=abs(cross(p2-b,p1-b)/2.0);\n  }\n  else if(!in(c,a) && in(c,b)){\n    Point p1=getCrossPointSC(c,Segment(a,c.c));\n    Point p2=getCrossPointSC(c,Segment(a,b));\n    res+=(c.r*c.r*pi)*(getAngle(p1-c.c,p2-c.c)/360.0);\n    res-=abs(cross(p1-c.c,p2-c.c)/2.0);\n    res-=abs(cross(p2-a,p1-a)/2.0);\n  }\n  else if(!in(c,a) && !in(c,b)){\n    if(intersect(c,Segment(a,b))){\n      pair<Point,Point> pp=getCrossPoints(c,Segment(a,b));\n      Point m=pp.f+(pp.s-pp.f)/2.0;\n      res=abs(getCommonAreaTC(a,m,c))+abs(getCommonAreaTC(m,b,c));\n    }\n    else res=(c.r*c.r*pi)*(getAngle(a-c.c,b-c.c)/360.0);\n  }\n  if(cross(a-c.c,b-c.c)<0.0)res=-res;\n  return res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  int n=p.size();\n  FOR(i,0,n)res+=getCommonAreaTC(p[i],p[(i+1)%n],c);\n  return abs(res);\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,40){\n    double m1=(L*phi+R)/(1.0+phi);\n    double m2=(L+R*phi)/(1.0+phi);\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res2-res1<-eps)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*R,r));\n}\n\ndouble solve(){\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=inf*2;\n    FOR(k,0,40){\n      double m1=(L*phi+R)/(1.0+phi);\n      double m2=(L+R*phi)/(1.0+phi);\n      double res1=check(a+v*(m1-inf));\n      double res2=check(a+v*(m2-inf));\n      if(res2-res1<-eps)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*(R-inf)));\n  }\n  return ans;\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  pd(solve());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\ntypedef complex<double> P;\n\nint n, r;\nP p[11];\n\ndouble dot(P a, P b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(P a, P b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dist(P s, P e, P p) {\n\tif (dot(p - s, e - s) < 0) return abs(p - s);\n\tif (dot(p - e, s - e) < 0) return abs(p - e);\n\treturn abs(cross(e - s, p - s) / abs(e - s));\n}\n\n//??´???a->b??¨???c(?????????r)?????????\nvector<P> kotenS(P a, P b, P c) {\n\ta -= c;\n\tb -= c;\n\tdouble d = dist(a, b, P(0, 0));\n\tif (d > r) return vector<P>();\n\t\n\tP t = (b - a) / abs(b - a);\n\tP u = t * P(0, 1);\n\tif (cross(a, b) > 0) u = -u;\n\t\n\tP p1 = d * u + sqrt(r * r - d * d) * t;\n\tP p2 = d * u - sqrt(r * r - d * d) * t;\n\tp1 += c;\n\tp2 += c;\n\t\n\tvector<P> ret;\n\tret.push_back(p1);\n\tret.push_back(p2);\n\treturn ret;\n}\n\n//??????a->b??¨???c(?????????r)?????????\nvector<P> koten(P a, P b, P c) {\n\tvector<P> res = kotenS(a, b, c);\n\tvector<P> ret;\n\tfor (int i = 0; i < res.size(); i++) {\n\t\tif (dot(res[i] - a, b - res[i]) >= 0) {\n\t\t\tret.push_back(res[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\n//???c???????????¨??????????§??????????\nvoid angle_sort(vector<P> &ps, P c) {\n\tfor (int i = 0; i < ps.size() - 1; i++) {\n\t\tfor (int j = ps.size() - 1; j > i; j--) {\n\t\t\tP t = ps[j - 1] - c;\n\t\t\tP u = ps[j] - c;\n\t\t\tif (atan2(t.imag(), t.real()) > atan2(u.imag(), u.real())) {\n\t\t\t\tswap(ps[j - 1], ps[j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//???a???????§???¢????????¨??????????????????. ?¢????????????????.\nbool isCover(P a) {\n\tbool flag = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tP t = p[i] - a;\n\t\tP u = p[i + 1] - a;\n\t\tif (t.imag() > u.imag()) swap(t, u);\n\t\tif (t.imag() < 0 && 0 < u.imag() && cross(t, u) > 0) flag = !flag;\n\t}\n\treturn flag;\n}\n\ndouble getArea(P a, P b, P c) {\n\tdouble eps = 1e-10;\n\t\n\tP mid = (a + b) * 0.5;\n\tP t = (mid - c) / abs(mid - c); t *= 1e-9; t += mid;\n\t\n\tif (norm(c - a) >= r * r - eps && norm(c - b) >= r * r - eps && isCover(t)) {\n\t\t//??????\n\t\ta -= c;\n\t\tb -= c;\n\t\tdouble theta = acos(dot(a, b) / abs(a) / abs(b));\n\t\treturn theta * r * r * 0.5;\n\t}\n\t//3?§???¢\n\treturn cross(a - c, b - c) * 0.5;\n}\n\n//???????????????c?????¨??????, ??±?????¨????????¢???????±???????.\n//c??????????§???¢????????¨???????????¨??????.\ndouble area(P c) {\n\tvector<P> ps;\n\tconst double PAI = 3.14159265358979;\n\t\n\t//?????¨?????????\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<P> res = koten(p[i], p[i + 1], c);\n\t\tfor (int j = 0; j < res.size(); j++) {\n\t\t\tps.push_back(res[j]);\n\t\t}\n\t}\n\tif (ps.size() == 0) { return PAI * r * r; }\n\t\n\t//????????????????????????\n\tdouble eps = 1e-10;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (norm(c - p[i]) <= r * r - eps) {\n\t\t\tps.push_back(p[i]);\n\t\t}\n\t}\n\t\n\t//??????\n\tP base = P(0, 0);\n\tfor (int i = 0; i < n; i++) base += p[i];\n\tbase /= n;\n\tangle_sort(ps, base);\n\tps.push_back(ps[0]);\n\t\n\tdouble ret = 0;\n\tfor (int i = 0; i < ps.size() - 1; i++) {\n\t\tret += getArea(ps[i], ps[i + 1], c);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint i;\n\t\n\tcin >> n >> r;\n\tfor (i = 0; i < n; i++) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = P(x, y);\n\t}\n\tp[n] = p[0];\n\n\tP c = P(0, 0);\n\tfor (i = 0; i < n; i++) { c += p[i]; }\n\tc /= n;\n\t\n\tconst int LoopNum = 10000;\n\tdouble dy;\n\tdouble dx;\n\tdouble maxArea = 0;\n\tfor (i = 0; i < LoopNum; i++) {\n\t\tdy = max(exp(-20 + rand() % 20), exp(-i / 50.0));\n\t\tdx = max(exp(-20 + rand() % 20), exp(-i / 50.0));\n\t\tif (isCover(c + P(dx, 0)) && maxArea < area(c + P(dx, 0))) { maxArea = area(c + P(dx, 0)); c = c + P(dx, 0); }\n\t\tif (isCover(c - P(dx, 0)) && maxArea < area(c - P(dx, 0))) { maxArea = area(c - P(dx, 0)); c = c - P(dx, 0); }\n\t\tif (isCover(c + P(0, dy)) && maxArea < area(c + P(0, dy))) { maxArea = area(c + P(0, dy)); c = c + P(0, dy); }\n\t\tif (isCover(c - P(0, dy)) && maxArea < area(c - P(0, dy))) { maxArea = area(c - P(0, dy)); c = c - P(0, dy); }\n\t}\n\t\n\tprintf(\"%.14f\\n\", maxArea);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-5)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  Point mp = poly[0];\n  double maxi = 0;\n  double rate = 10.0;\n  double eps = 1e-10;\n  while( LT(eps,rate) ) {\n    rep(_,70) {\n\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      if( !equals(max_area,-1) ) {\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      \n    }\n    rate *= 0.5;\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mem(a,b) memset((a),(b),sizeof(a))\n#define MP make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) x.size()\n#define all(x) x.begin(),x.end()\nusing namespace std;\n#define _GLIBCXX_PERMIT_BACKWARD_HASH\n#include <ext/hash_map>\nusing namespace __gnu_cxx;\nstruct str_hash{size_t operator()(const string& str)const{return __stl_hash_string(str.c_str());}};\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\nconst int INF=0x3f3f3f3f;\nconst ll LLINF=0x3f3f3f3f3f3f3f3f;\nconst double PI=acos(-1.0);\nconst double eps=1e-8;\nconst int MAX=2e5+10;\nconst ll mod=1e9+7;\nint sgn(double x)\n{\n    if(fabs(x)<eps) return 0;\n    if(x<0) return -1;\n    return 1;\n}\nstruct Point\n{\n    double x,y;\n    Point() {}\n    Point(double x_,double y_):x(x_),y(y_) {}\n    Point operator -(const Point &t)\n    {\n        return Point(x-t.x,y-t.y);\n    }\n    Point operator +(const Point &t)\n    {\n        return Point(x+t.x,y+t.y);\n    }\n    double operator *(const Point &t)\n    {\n        return x*t.x+y*t.y;\n    }\n    Point operator *(double t)\n    {\n        return Point(x*t,y*t);\n    }\n    double operator ^(const Point &t)\n    {\n        return x*t.y-y*t.x;\n    }\n    double friend dist(const Point &a,const Point &b)\n    {\n        return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n    }\n    void input()\n    {\n        scanf(\"%lf%lf\",&x,&y);\n    }\n} p[15];\nint n;\ndouble R;\nnamespace SK\n{\nbool inCircle(Point &cir,Point &a)\n{\n    return sgn(dist(cir,a)-R)<=0;\n}\ndouble triArea2(Point &a,Point &b,Point &c)\n{\n    return fabs((b-a)^(c-a));\n}\nbool sameSide(Point &cir,Point &a,Point &b)\n{\n    if(dist(a,cir)>dist(b,cir)) return sgn((a-b)*(cir-b))<=0;\n    else return sgn((b-a)*(cir-a))<=0;\n}\ndouble calc(Point &cir,Point a,Point b)\n{\n    double xmulti=(a-cir)^(b-cir);\n    if(sgn(xmulti)==0) return 0;\n    double ans=0;\n    double theta=acos(((a-cir)*(b-cir))/(dist(a,cir)*dist(b,cir)));\n    double h=triArea2(cir,a,b)/dist(a,b);\n    bool ina=inCircle(cir,a),inb=inCircle(cir,b);\n    if(ina && inb) ans=triArea2(cir,a,b)/2;\n    else if(!ina && !inb)\n    {\n        if(sameSide(cir,a,b)) ans=R*R*theta/2;\n        else if(sgn(h-R)>=0) ans=R*R*theta/2;\n        else\n        {\n            double theta2=2*acos(h/R);\n            ans=R*R*(theta-theta2+sin(theta2))/2;\n        }\n    }\n    else\n    {\n        if(!ina && inb) swap(a,b);\n        double tem=(cir-a)*(b-a);\n        if(sgn(tem)==0)\n        {\n            double alpha=acos(h/R);\n            ans=R*h/2*sin(alpha)+R*R*(theta-alpha)/2;\n        }\n        else\n        {\n            double theta1=asin(h/R),theta2=asin(h/dist(a,cir));\n            if(sgn(tem)>0)\n            {\n                ans+=dist(cir,a)*R/2*sin(PI-theta1-theta2);\n                ans+=R*R/2*(theta+theta1+theta2-PI);\n            }\n            else\n            {\n                ans+=dist(cir,a)*R/2*sin(theta2-theta1);\n                ans+=R*R/2*(theta-theta2+theta1);\n            }\n        }\n    }\n    if(sgn(xmulti)<0) return -ans;\n    else return ans;\n}\ndouble coArea(Point &cir)\n{\n    double ans=0;\n    for(int i=0; i<n; ++i)\n        ans+=calc(cir,p[i],p[i+1]);\n    return fabs(ans);\n}\n}\npair<Point,double> SA()\n{  \n\tPoint s;  \n\tdouble T=100,t,ds,dz,ans;  \n\tint i,j,k,flag,dir[5][2]={0,0,1,0,-1,1,0,-1,0};\n\ts=Point(0,0);\n\tfor(i=0;i<n;i++)\n\t{  \n\t\ts.x+=p[i].x;  \n\t\ts.y+=p[i].y;  \n\t}\n\ts.x/=n;  \n\ts.y/=n;  \n\tans=0;\n\tfor(k=1;k<=100000;k++)\n\t{\n\t\tt=T/k;\n\t\tfor(i=0;i<5;i++)  \n\t\t{\n\t\t\tPoint z;\n\t\t\tz.x=s.x+dir[i][0]*t;  \n\t\t\tz.y=s.y+dir[i][1]*t;  \n\t\t\tdz=SK::coArea(z);\n\t\t\tif(dz>ans)  \n\t\t\t{  \n\t\t\t\tans=dz;\n\t\t\t\ts=z;\n\t\t\t} \n\t\t}\n\t}\n\tpair<Point,double> res;\n\tres=make_pair(s,ans);\n\treturn res;\n}\nint main()\n{\n\tint i;\n\twhile(~scanf(\"%d%lf\",&n,&R))\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tp[i].input();\n\t\t}\n\t\tp[n]=p[0];\n\t//\tprintf(\"%.6lf\\n\",getres(Point(3,3),p,n+1));\n\t\tpair<Point,double> ans=SA();\n\t\tprintf(\"%.6lf\\n\",ans.se);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\n\ntemplate<class T> using V = vector<T>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) { return (abs(a) <= EPS) ? 0 : (a < 0 ? -1 : 1); }\nint sgn(D a, D b) { return sgn(a-b); }\n//relative sign\n// int rsgn(D a, D f) {\n//     if (abs(a) <= f*EPS) return 0;\n//     return (a < 0) ? -1 : 1;\n// }\nstruct Pt2 {\n    D x, y;\n    Pt2(D _x = D(), D _y = D()) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    Pt2 operator/(const D &r) const { return Pt2(x/r, y/r); }\n\n    Pt2& operator+=(const Pt2 &r) { return *this=*this+r; }\n    Pt2& operator-=(const Pt2 &r) { return *this=*this-r; }\n    Pt2& operator*=(const Pt2 &r) { return *this=*this*r; }\n    Pt2& operator*=(const D &r) { return *this=*this*r; }\n    Pt2& operator/=(const D &r) { return *this=*this/r; }\n    \n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    bool operator<(const Pt2 &r) const { return 2*sgn(x, r.x)+sgn(y, r.y)<0; }\n    bool operator==(const Pt2 &r) const { return sgn((*this-r).rabs()) == 0; }\n\n    D norm() const { return x*x + y*y; }\n    D abs() const { return sqrt(norm()); }\n    D rabs() const { return max(std::abs(x), std::abs(y)); } // robust abs\n    D arg() const { return atan2(y, x); }\n\n    pair<D, D> to_pair() const { return make_pair(x, y); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    return os << \"P(\" << p.x << \", \" << p.y << \")\";\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L(P _s = P(), P _t = P()) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\nostream& operator<<(ostream& os, const L &l) {\n    return os << \"L(\" << l.s << \", \" << l.t << \")\";\n}\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n// cross(a, b) is too small?\nint sgncrs(P a, P b) {\n    D cr = cross(a, b);\n    if (abs(cr) <= (a.rabs() + b.rabs()) * EPS) return 0;\n    return (cr < 0) ? -1 : 1;\n}\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = sgncrs(b, c);\n    if (s) return s;\n    if (!sgn(c.rabs()) || !sgn((c-b).rabs())) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nP project(const L &l, const P &p) {\n    P v = l.vec();\n    return l.s + v * (dot(v, p-l.s) / v.norm());\n}\n\nbool insSL(const L &s, const L &l) {\n    int a = ccw(l, s.s), b = ccw(l, s.t);\n    return (a%2 == 0 || b%2 == 0 || a != b);\n}\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s, t.s), b = ccw(s, t.t);\n    int c = ccw(t, s.s), d = ccw(t, s.t);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nD distLP(const L &l, const P &p) {\nreturn abs(cross(l.vec(), p-l.s)) / l.abs();\n}\n\nD distSP(const L &s, const P &p) {\n    P q = project(s, p);\n    if (ccw(s, q) == 0) return (p - q).abs();\n    else return min((s.s - p).abs(), (s.t - p).abs());\n}\n\nint crossLL(const L &l, const L &m, P &r) {\n    D cr1 = cross(l.vec(), m.vec()), cr2 = cross(l.vec(), l.t - m.s);\n    if (sgncrs(l.vec(), m.vec()) == 0) {\n        r = l.s;\n        if (sgncrs(l.vec(), l.t - m.s)) return 0;\n        return -1;\n    }\n    r = m.s + m.vec() * (cr2 / cr1);\n    return 1;\n}\n\nusing Pol = V<P>;\n\nstruct C {\n    P p; D r;\n    C(P _p = P(), D _r = D()) : p(_p), r(_r) {}\n};\n\n//need Intersect/distLP, r.sはよりl.sに近い\nint crossCL(const C &c, const L &l, L &r) {\n    D u = distLP(l, c.p);\n    int si = sgn(u, c.r);    \n    if (si == 1) return 0;\n    P v = project(l, c.p);\n    P di = (si == 0) ? P(0, 0) : l.vec() * (sqrt(c.r*c.r - u*u) / l.abs());\n    r = L(v-di, v+di);\n    if (si == 0) return 1;\n    return 2;\n}\n\n//need Intersect/distLP, r.sはよりl.sに近い\nint crossCS(const C &c, const L &s, L &l) {\n    if (!crossCL(c, s, l)) return 0;\n    bool f1 = ccw(s, l.s) == 0, f2 = ccw(s, l.t) == 0;\n    if (f1 && f2) return 2;\n    if (!f1 && !f2) return 0;\n    if (f1) l.t = l.s;\n    else l.s = l.t;\n    return 1;\n}\n\n// C(P(0, 0), r)とTri((0, 0), a, b)の共有面積\nD area2CT(const C &c, const P &_a, const P &_b) {\n    P a = _a - c.p, b = _b - c.p; D r = c.r;\n    if (a == b) return 0;\n    auto single = [&](P x, P y, bool tri) {\n        if (tri) return cross(x, y);\n        else return r * r * ((y * P(x.x, -x.y)).arg());\n    };\n    bool ia = sgn(a.abs(), r) != 1, ib = sgn(b.abs(), r) != 1;\n    if (ia && ib) return single(a, b, true);\n    L l;\n    if (!crossCS(C(P(0, 0), r), L(a, b), l)) return single(a, b, false);\n    return single(a, l.s, ia) + single(l.s, l.t, true) + single(l.t, b, ib);\n}\n\n// p, cの共有面積\nD area2CPol(const C &c, const Pol &po) {\n    D sm = 0;\n    P a, b = po.back();\n    for (auto p: po) {\n        a = b; b = p;\n        sm += area2CT(c, a, b);\n    }\n    return sm;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    int n; D r;\n    cin >> n >> r;\n    Pol pol;\n \n    D ymi = 1e100, yma = -1e100;\n    for (int i = 0; i < n; i++) {\n        D x, y;\n        cin >> x >> y;\n        pol.push_back(P(x, y));\n        ymi = min(ymi, y);\n        yma = max(yma, y);\n    }\n \n    auto calc = [&](D y) {\n        D xmi = 1e100, xma = -1e100;\n        P a, b = pol.back();\n        for (int i = 0; i < n; i++) {\n            a = b; b = pol[i];\n            P p;\n            if (crossLL(L(a, b), L(P(0, y), P(1, y)), p) == 0) continue;\n            if (ccw(a, b, p) != 0) continue;\n            xmi = min(xmi, p.x); xma = max(xma, p.x);\n        }\n        D lw = xmi, up = xma;\n        for (int ph = 0; ph < 30; ph++) {\n            D md1 = (lw+lw+up) / 3;\n            D md2 = (lw+up+up) / 3;\n            D z1 = area2CPol(C(P(md1, y), r), pol) / 2;\n            D z2 = area2CPol(C(P(md2, y), r), pol) / 2;\n            if (z1 < z2) {\n                lw = md1;\n            } else {\n                up = md2;\n            }\n        }\n        return area2CPol(C(P(lw, y), r), pol) / 2;\n    };\n     \n    D lw = ymi, up = yma;\n    for (int ph = 0; ph < 30; ph++) {\n        D md1 = (lw+lw+up) / 3;\n        D md2 = (lw+up+up) / 3;\n        if (calc(md1) < calc(md2)) {\n            lw = md1;\n        } else {\n            up = md2;\n        }\n    }\n \n    cout << calc(lw) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mem(a,b) memset((a),(b),sizeof(a))\n#define MP make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) x.size()\n#define all(x) x.begin(),x.end()\nusing namespace std;\n#define _GLIBCXX_PERMIT_BACKWARD_HASH\n#include <ext/hash_map>\nusing namespace __gnu_cxx;\nstruct str_hash{size_t operator()(const string& str)const{return __stl_hash_string(str.c_str());}};\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\nconst int INF=0x3f3f3f3f;\nconst ll LLINF=0x3f3f3f3f3f3f3f3f;\nconst double PI=acos(-1.0);\nconst double eps=1e-8;\nconst int MAX=2e5+10;\nconst ll mod=1e9+7;\ndouble r;\nint sgn(double x)\n{  \n\tif(fabs(x)<eps) return 0;\n\telse return x>0?1:-1;  \n}\nstruct Point\n{  \n\tdouble x,y;\n\tPoint(){}\n\tPoint(double a,double b)\n\t{\n\t\tx=a;\n\t\ty=b;\n\t}\n\tvoid input()\n\t{\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t}\n};\ntypedef Point Vector;\nVector operator +(Vector a,Vector b){return Vector(a.x+b.x,a.y+b.y);}  \nVector operator -(Vector a,Vector b){return Vector(a.x-b.x,a.y-b.y);}  \nVector operator *(Vector a,double p){return Vector(a.x*p,a.y*p);}  \nVector operator /(Vector a,double p){return Vector(a.x/p,a.y/p);}\n\nbool operator <(Point a,Point b){return a.x<b.x||(a.x==b.x&&a.y<b.y);}\nbool operator ==(Point a,Point b){return sgn(a.x-b.x)==0&&sgn(a.y-b.y)==0;}\ndouble dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}//点?\ndouble length(Vector a){return sqrt(dot(a,a));}//向量的模 \n\ndouble cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}//叉? \ndouble dist(Point a,Point b){return sqrt(dot(a-b,a-b));}//?点距? \nPoint midseg(Point a,Point b){return (a+b)/2;}//?段ab中点\nVector Normal(Vector x){return Point(-x.y,x.x)/length(x);} //垂直法向量 \nVector Rotate(Vector a, double rad){return Vector(a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad));}\ndouble calarea(Point c,Point b,Point a){return cross(b-a,c-a);}//三个点求三角形面? \nVector vecunit(Vector x){return x/length(x);}//?位向量\ndouble VectorAngle(Vector v){return atan2(v.y,v.x);}\nstruct Line\n{  \n\tPoint p;//直?上任意一点  \n\tVector v;//?角,即从x正半?旋?到向量v所需要的角（弧度）  \n\tdouble ang;\n\tdouble a,b,c;//直?一般式 \n\tLine(){}\n\tLine(Point a,Vector b)//点斜式 \n\t{\n\t\tp=a;\n\t\tv=b;\n\t\tang=atan2(v.y,v.x);\n\t\tLineGeneralEquation();\n\t}\n\tvoid twopoint(Point a,Point b)//?点式 \n\t{\n\t\tp=a;\n\t\tv=b-a;\n\t\tang=atan2(v.y,v.x);\n\t\tLineGeneralEquation();\n\t}\n\tPoint getpoint(double a)\n\t{  \n\t\treturn p+(v*a);  \n\t}\n\tvoid LineGeneralEquation()//?算一般式的a,b,c \n\t{\n\t\tPoint p1,p2;\n\t\tp1=p;\n\t\tp2=p+v;\n\t\ta=p2.y-p1.y;  \n\t\tb=p1.x-p2.x;  \n\t\tc=-a*p1.x-b*p1.y;\n\t}\n};\nstruct Circle  \n{  \n    Point c;  \n    double r;  \n    Circle(){}  \n    Circle(Point a,double b)\n    {\n\t\tc=a;\n\t\tr=b;\n\t}\n\tPoint getpoint(double a) //根据?心角求点坐?  \n\t{  \n        return Point(c.x+cos(a)*r,c.y+sin(a)*r);  \n\t}  \n}; \nbool OnSeg(Point p,Point p1,Point p2)\n{  \n\treturn sgn(cross(p1-p,p2-p))==0&&sgn(dot(p1-p,p2-p))<0;\n}\nPoint PointOfLineInter(Line a,Line b)//?段交点\n{\n\tVector u=a.p-b.p;\n\tdouble t=cross(b.v,u)/cross(a.v,b.v);\n\treturn a.p+a.v*t;\n}\nbool InCircle(Point x,Circle c){return sgn(c.r-length(c.c-x))>=0;}//在?内(包括?上) \nint getSegCircleInter(Line l,Circle c,Point *sol)//?段与?的交点\n{  \n\tVector nor=Normal(l.v);\n\tLine l1=Line(c.c,nor);  \n\tPoint p1=PointOfLineInter(l1,l);  \n\tdouble d=length(p1-c.c);  \n    if(sgn(d-c.r)>0) return 0;\n\tPoint p2=vecunit(l.v)*sqrt(c.r*c.r-d*d);  \n\tint res=0;  \n\tsol[res]=p1+p2;  \n    if(OnSeg(sol[res],l.p,l.getpoint(1))) res++;\n\tsol[res]=p1-p2;\n\tif(OnSeg(sol[res],l.p,l.getpoint(1))) res++;  \n\treturn res;  \n}  \ndouble SegCircleArea(Circle c,Point a,Point b) //?段切割?  \n{  \n\tdouble a1=VectorAngle(a-c.c);  \n\tdouble a2=VectorAngle(b-c.c);  \n\tdouble da=fabs(a1-a2);  \n\tif (sgn(da-PI)>0) da=PI*2.0-da;  \n\treturn sgn(cross(b-c.c,a-c.c))*da*c.r*c.r/2.0;  \n}\ndouble PolyCiclrArea(Circle c,Point *p,int n)//多?形与?面?交  \n{  \n\tdouble res=0;  \n\tPoint sol[2];  \n\tfor(int i=0;i<n;i++)\n\t{\n\t\tdouble t1,t2;  \n\t\tint cnt=getSegCircleInter(Line(p[i],p[i+1]-p[i]),c,sol);  \n\t\tif(cnt==0)  \n\t\t{  \n\t\t\tif(!InCircle(p[i],c)||!InCircle(p[i+1],c)) res+=SegCircleArea(c,p[i],p[i+1]);  \n\t\t\telse res+=cross(p[i+1]-c.c,p[i]-c.c)/2.0;  \n\t\t}  \n\t\tif(cnt==1)  \n\t\t{  \n\t\t\tif(InCircle(p[i],c)&&!InCircle(p[i+1],c))\n\t\t\t{\n\t\t\t\tres+=cross(sol[0]-c.c,p[i]-c.c)/2.0;\n\t\t\t\tres+=SegCircleArea(c,sol[0],p[i+1]);  \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres+=SegCircleArea(c,p[i],sol[0]);\n\t\t\t\tres+=cross(p[i+1]-c.c,sol[0]-c.c)/2.0;  \n\t\t\t}\n\t\t}  \n\t\tif(cnt==2)  \n\t\t{  \n\t\t\tif((p[i]<p[i+1])^(sol[0]<sol[1])) swap(sol[0],sol[1]);  \n\t\t\tres+=SegCircleArea(c,p[i],sol[0]);  \n\t\t\tres+=cross(sol[1]-c.c,sol[0]-c.c)/2.0;  \n\t\t\tres+=SegCircleArea(c,sol[1],p[i+1]);  \n\t\t}  \n\t}  \n\treturn fabs(res);  \n}\ndouble getres(Point t,Point *p,int n)\n{\n\tdouble res=0;\n\tres=PolyCiclrArea(Circle(t,r),p,n);\n\treturn res;\n}\npair<Point,double> SA(Point *p,int n)\n{  \n\tPoint s;  \n\tdouble t=0,ds,dz,ans;  \n\tint i,j,k,flag,dir[4][2]={0,1,0,-1,1,0,-1,0};\n\ts=Point(0,0);\n\tfor(i=0;i<n;i++)\n\t{  \n\t\tt+=fabs(p[i].x)+fabs(p[i].y);  \n\t\ts.x+=p[i].x;  \n\t\ts.y+=p[i].y;  \n\t}\n\ts.x/=n;  \n\ts.y/=n;  \n\tt=100;\n\tans=0;\n\twhile(t>1e-20)  \n\t{  \n\t\tt/=2;\n\t\tfor(k=0;k<1000;k++)\n\t\t{\n\t\t\tfor(i=0;i<4;i++)  \n\t\t\t{\n\t\t\t\tPoint z;\n\t\t\t\tz.x=s.x+dir[i][0]*t;  \n\t\t\t\tz.y=s.y+dir[i][1]*t;  \n\t\t\t\tds=dz=0;  \n\t\t\t\tdz=getres(z,p,n);\n\t\t\t\tif(dz>ans)  \n\t\t\t\t{  \n\t\t\t\t\ts=z;\n\t\t\t\t\tans=dz;\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t}  \n\tpair<Point,double> res;\n\tres=make_pair(s,ans);\n\treturn res;\n}\nint main()\n{\n\tint n,i;\n\tPoint p[12];\n\twhile(~scanf(\"%d%lf\",&n,&r))\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tp[i].input();\n\t\t}\n\t\tp[n]=p[0];\n\t//\tprintf(\"%.6lf\\n\",getres(Point(3,3),p,n+1));\n\t\tpair<Point,double> ans=SA(p,n);\n\t\tprintf(\"%.6lf\\n\",ans.se);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\n#define CVector CPoint\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1.0);\nconst double EPS=1e-5;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-5;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n    /*friend bool operator<(CPoint a,CPoint b){//?角排序\n        double tmp=cross(Pts[0],a,b);\n        if(isZero(tmp)){\n            return dist(Pts[0],a)<dist(Pts[0],b);\n        }\n        return tmp>0;\n    }*/\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n/*----------------------多?形相?--------------------------*/\n\n//0:outside 1:inside 2:online\nint PointInPoly(Point t,Point *Pts,int n){\n    int num=0,d1,d2,k;\n    Pts[n]=Pts[0];\n    for(int i=0;i<n;i++){\n        if(PointOnS(t,Line(Pts[i],Pts[i+1]))) return 2;\n        k=dcmp(cross(Pts[i],Pts[i+1],t));\n        d1=dcmp(Pts[i].y-t.y);\n        d2=dcmp(Pts[i+1].y-t.y);\n        if(k>0&&d1<=0&&d2>0) num++;\n        if(k<0&&d2<=0&&d1>0) num--;\n    }\n    return num!=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n//求任意多?形周?，需逆??或???排列\ndouble PolyPerimeter(Point *Pts,int n){\n    double pp=distPP(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pp+=distPP(Pts[i],Pts[i+1]);\n    return pp;\n}\n\n//求多?形重心坐?\nPoint PolyCore(Point *Pts,int n){\n    double pa=PolyArea(Pts,n);\n    if(!dcmp(pa)) return Point(0,0);\n    Point ans=(Pts[n-1]+Pts[0])*cross(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) ans=ans+(Pts[i]+Pts[i+1])*cross(Pts[i],Pts[i+1]);\n    return ans/pa/6;\n}\n\n/*----------------------凸包----------------------------*/\n\n//Graham-scan st:anticlockwise\n//<=:strict <:Non-strict\nint Graham(Point *Pts,Point *st,int n){\n    if(n<3) return 0;\n    sort(Pts,Pts+n);\n    int m=0;\n    for(int i=0;i<n;i++){\n        while(m>1&&dcmp(cross(st[m-2],st[m-1],Pts[i]))<0) m--;\n        st[m++]=Pts[i];\n    }\n    int k=m;\n    for(int i=n-2;i>=0;i--){\n        while(m>k&&dcmp(cross(st[m-2],st[m-1],Pts[i])<0)) m--;\n        st[m++]=Pts[i];\n    }\n    return m-1;\n}\n\n//clockwise:> anticlockwise:<\ndouble CHDiameter(Point *Pts,int n,Line &l){\n    double maxd=0.0;\n    if(n<=1){\n        l.a=l.b=Pts[0];\n        return maxd;\n    }\n    for(int i=0,j=1;i<n;i++){\n        while(cross(Pts[i],Pts[(i+1)%n],Pts[j])\n              >cross(Pts[i],Pts[(i+1)%n],Pts[(j+1)%n])){\n            j=(j+1)%n;\n        }\n        double d=distPP(Pts[i],Pts[j]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n        d=distPP(Pts[(i+1)%n],Pts[(j+1)%n]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n    }\n    return maxd;\n}\n\n/*---------------------整点多?形---------------------------*/\n\nint gcd(int a,int b){\n    return b==0?a :gcd(b,a%b);\n}\n\n//整点多?形?界整点数\nint Border_Int_Point_Num(Point *Pts,int n){\n    int num=gcd(abs(int(Pts[0].x-Pts[n-1].x)),abs(int(Pts[0].y-Pts[n-1].y)));;\n    for(int i=0;i<n-1;i++){\n        num+=gcd(abs(int(Pts[i+1].x-Pts[i].x)),abs(int(Pts[i+1].y-Pts[i].y)));\n    }\n    return num;\n}\n\n//整点多?形内部整点数\nint Inside_Int_Point_Num(Point *Pts,int n){\n    return abs(int(PolyArea(Pts,n)))+1-Border_Int_Point_Num(Pts,n)/2;\n}\n\n/*-----------------------------半平面交-------------------------------*/\n\n//有方向的直?\n//p->p+v\nstruct Vector{\n    Point p,v;\n    double ang;\n    Vector(Point p,Point v):p(p),v(v){\n        ang=atan2(v.y,v.x);\n    }\n    Vector(){}\n    bool operator<(const Vector &l) const{\n        return ang<l.ang;\n    }\n};\n\n//判断点p是否在直?L左?\nbool onLeft(Vector L,Point p){\n    return cross(L.v,p-L.p)>0;\n}\n\n//得到a与b?直?的交点\nPoint getCrossVV(Vector a,Vector b){\n    Point u=a.p-b.p;\n    double t=cross(b.v,u)/cross(a.v,b.v);\n    return a.p+a.v*t;\n}\n\n//所有直?左半平面的交\nint HPCross(Vector *L,int n,Point *poly){\n    sort(L,L+n);\n    int f=0,l=0;\n    Point *p=new Point[n];\n    Vector *q=new Vector[n];\n    q[0]=L[0];\n    for(int i=1;i<n;i++){\n        while(f<l&&!onLeft(L[i],p[l-1])) l--;\n        while(f<l&&!onLeft(L[i],p[f])) f++;\n        q[++l]=L[i];\n        if(!dcmp(cross(q[l].v,q[l-1].v))){\n            l--;\n            if(onLeft(q[l],L[i].p)) q[l]=L[i];\n        }\n        if(f<l) p[l-1]=getCrossVV(q[l-1],q[l]);\n    }\n    while(f<l&&!onLeft(q[f],p[l-1])) l--;\n    if(l-f<=1) return 0;\n    p[l]=getCrossVV(q[l],q[f]);\n    int m=0;\n    for(int i=f;i<=l;i++) poly[m++]=p[i];\n    return m;\n}\n\n#define maxn 100005\nVector l[maxn];\nbool retract(Vector *L,int n,double r,Point *poly){\n    for(int i=0;i<n;i++){\n        Point v=rotateV(L[i].p,L[i].p+L[i].v,PI/2);\n        l[i]=Vector(L[i].p+r*v,L[i].v);\n    }\n    int cnt=HPCross(l,n,poly);\n    return cnt;\n}\n\n/*---------------------三角形相?---------------------------*/\n\n//三角形重心\n//到三?点距?的平方和最小的点\n//到三?距?之?最大的点\nPoint TCore(Point a,Point b,Point c){\n    return (a+b+c)/3;\n}\n\n//三角形外心\nPoint TCircum(Point a,Point b,Point c){\n    Point cp;\n    double a1=b.x-a.x;\n    double b1=b.y-a.y;\n    double a2=c.x-a.x;\n    double b2=c.y-a.y;\n    double c1=(a1*a1+b1*b1)/2;\n    double c2=(a2*a2+b2*b2)/2;\n    double d=a1*b2-a2*b1;\n    cp.x=a.x+(c1*b2-c2*b1)/d;\n    cp.y=a.y+(a1*c2-a2*c1)/d;\n    return cp;\n}\n\n//三角形垂心\nPoint TOrtho(Point a,Point b,Point c){\n    return TCore(a,b,c)*3.0-TCircum(a,b,c)*2.0;\n}\n\n//三角形内心\nPoint TInner(Point a,Point b,Point c){\n    Point cp;\n    double la=distPP(b,c),lb=distPP(c,a),lc=distPP(a,b);\n    cp.x=(la*a.x+lb*b.x+lc*c.x)/(la+lb+lc);\n    cp.y=(la*a.y+lb*b.y+lc*c.y)/(la+lb+lc);\n    return cp;\n}\n\n//求三角形面?\ndouble TArea(Point a,Point b,Point c){\n    return fabs(cross(a,b,c))/2;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n//求??面?交\ndouble getAreaCC(Circle a,Circle b){\n    double d=(a.o.x-b.o.x)*(a.o.x-b.o.x)+(a.o.y-b.o.y)*(a.o.y-b.o.y);\n    if(d<=(a.r-b.r)*(a.r-b.r)){\n        return min(a.r,b.r)*min(a.r,b.r)*PI;\n    }else if(d>(a.r-b.r)*(a.r-b.r)&&d<(a.r+b.r)*(a.r+b.r)){\n        double m1=(a.r*a.r+d-b.r*b.r)/(2*a.r*sqrt(d));\n        double m2=(b.r*b.r+d-a.r*a.r)/(2*b.r*sqrt(d));\n        double s1=acos(m1)*a.r*a.r;\n        double s2=acos(m2)*b.r*b.r;\n        double s3=sqrt(d)*a.r*sin(acos(m1));\n        return s1+s2-s3;\n    }\n    return 0.0;\n}\n\n//求??交点，先判断是否有交点\nPoint rotatePCS(Point p,double c,double s){\n    return Point(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\npair<Point,Point> getcrossCC(Circle a,Circle b){\n    double d=length(a.o-b.o);\n    double cost=(a.r*a.r+d*d-b.r*b.r)/(2*a.r*d);\n    double sint=sqrt(1.0-cost*cost);\n    Point v=(b.o-a.o)/d*a.r;\n    return make_pair(a.o+rotatePCS(v,cost,-sint),a.o+rotatePCS(v,cost,sint));\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n/********************************************************/\nint getCrossCS(Circle c,Line s,Point *cs){\n    Point tmp[2];\n    int cnt=0;\n    int ct=getCrossCL(c,s,tmp);\n    for(int i=0;i<ct;i++){\n        if(PointOnS(tmp[i],s)) cs[cnt++]=tmp[i];\n    }\n    return cnt;\n}\n\ndouble SectorArea(Point a,Point b,Circle c){\n    a=a-c.o,b=b-c.o;\n    double theta=atan2(a.y,a.x)-atan2(b.y,b.x);\n    while(dcmp(theta)<=0) theta+=2.0*PI;\n    while(dcmp(theta-2.0*PI)>0) theta-=2.0*PI;\n    theta=min(theta,2.0*PI-theta);\n    return c.r*c.r*theta*0.5;\n}\n\ndouble Abs(double x){\n    if(!dcmp(x)) return 0;\n    return dcmp(x)<0?-x:x;\n}\n\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=0.0;\n    Point OA=a-c.o,OB=b-c.o;\n    double la=length(OA),lb=length(OB);\n    Point cs[4];\n    bool aic=dcmp(la-c.r)<0,bic=dcmp(lb-c.r)<0;\n    int s=dcmp(cross(OA,OB));\n    if(!s) return 0.0;\n    if(aic){\n        if(bic){\n            atc=Abs(cross(OA,OB))*0.5;\n        }else{\n            int num=getCrossCS(c,Line(a,b),cs);\n            atc=SectorArea(cs[0],b,c)+Abs(cross(OA,cs[0]-c.o))*0.5;\n        }\n    }else{\n        if(bic){\n            int num=getCrossCS(c,Line(a,b),cs);\n            atc=SectorArea(cs[0],a,c)+Abs(cross(OB,cs[0]-c.o))*0.5;\n        }else{\n            int num=getCrossCS(c,Line(a,b),cs);\n            if(num==2){\n                if(distPP(a,cs[0])>distPP(a,cs[1])) swap(cs[0],cs[1]);\n                atc=SectorArea(a,cs[0],c)+SectorArea(b,cs[1],c)+Abs(cross(cs[0]-c.o,cs[1]-c.o))*0.5;\n            }else{\n                atc=SectorArea(a,b,c);\n            }\n        }\n    }\n    return 1.0*s*atc;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=getAreaTC(Pts[n-1],Pts[0],c);\n    for(int i=0;i<n-1;i++) apc+=getAreaTC(Pts[i],Pts[i+1],c);\n    return fabs(apc);\n}\n\n/********************************************************/\n\n\n/*----------------------三?点、?基本函数-----------------------------*/\n\nstruct Point3{\n    double x,y,z;\n    Point3(double x,double y,double z):x(x),y(y),z(z){}\n    Point3(){}\n    void Read(){ scanf(\"%lf%lf%lf\",&x,&y,&z); }\n};\n\nstruct Line3{\n    Point3 a,b;\n    Line3(Point3 a,Point3 b):a(a),b(b){}\n    Line3(){}\n    void Read(){ a.Read(); b.Read(); }\n};\nPoint3 operator +(Point3 a,Point3 b){ return Point3(a.x+b.x,a.y+b.y,a.z+b.z); }\nPoint3 operator -(Point3 a,Point3 b){ return Point3(a.x-b.x,a.y-b.y,a.z-b.z); }\ndouble operator *(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 operator *(Point3 a,double k){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator *(double k,Point3 a){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator /(Point3 a,double k){ return Point3(a.x/k,a.y/k,a.z/k); }\n\ndouble length(Point3 a){ return sqrt(a.x*a.x+a.y*a.y+a.z*a.z); }\nPoint3 unit(Point3 a){ return a/length(a); }\ndouble dot(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 cross(Point3 a,Point3 b){\n    return Point3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//混合?\ndouble Mix(Point3 a,Point3 b,Point3 c){\n    return dot(a,cross(b,c));\n}\n\n//?点距?\ndouble dist(const Point3 &a,const Point3 &b){ return length(a-b); }\n\n/*---------------------------------体?-------------------------------------*/\n\n//四面体体?\ndouble volume(double l,double n,double a,double m,double b,double c){\n    double x,y;\n    x=4*a*a*b*b*c*c-a*a*(b*b+c*c-m*m)*(b*b+c*c-m*m)-b*b*(c*c+a*a-n*n)*(c*c+a*a-n*n);\n    y=c*c*(a*a+b*b-l*l)*(a*a+b*b-l*l)-(a*a+b*b-l*l)*(b*b+c*c-m*m)*(c*c+a*a-n*n);\n    return sqrt(x-y)/12;\n}\n\ndouble volume(Point3 a,Point3 b,Point3 c,Point3 d){\n    return fabs(Mix(b-a,c-a,d-a)/6);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);cin.tie(0);\n    //cout<<getAreaTC(Point(3,3),Point(-3,3),Circle(Point(0,0),4))<<endl;\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\ntypedef complex<double> P;\n\nint n, r;\nP p[11];\nconst double PAI = 3.14159265358979;\n\t\ndouble dot(P a, P b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\n\ndouble cross(P a, P b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\n\ndouble dist(P s, P e, P p) {\n\tif (dot(p - s, e - s) < 0) return abs(p - s);\n\tif (dot(p - e, s - e) < 0) return abs(p - e);\n\treturn abs(cross(e - s, p - s) / abs(e - s));\n}\n\n//??´???a->b??¨???c(?????????r)?????????\nvector<P> kotenS(P a, P b, P c) {\n\ta -= c;\n\tb -= c;\n\tdouble d = dist(a, b, P(0, 0));\n\tif (d > r) return vector<P>();\n\t\n\tP t = (b - a) / abs(b - a);\n\tP u = t * P(0, 1);\n\tif (cross(a, b) > 0) u = -u;\n\t\n\tP p1 = d * u + sqrt(r * r - d * d) * t;\n\tP p2 = d * u - sqrt(r * r - d * d) * t;\n\tp1 += c;\n\tp2 += c;\n\t\n\tvector<P> ret;\n\tret.push_back(p1);\n\tret.push_back(p2);\n\treturn ret;\n}\n\n//??????a->b??¨???c(?????????r)?????????\nvector<P> koten(P a, P b, P c) {\n\tvector<P> res = kotenS(a, b, c);\n\tvector<P> ret;\n\tfor (int i = 0; i < res.size(); i++) {\n\t\tif (dot(res[i] - a, b - res[i]) >= 0) {\n\t\t\tret.push_back(res[i]);\n\t\t}\n\t}\n\treturn ret;\n}\n\n//???c???????????¨??????????§??????????\nvoid angle_sort(vector<P> &ps, P c) {\n\tfor (int i = 0; i < ps.size() - 1; i++) {\n\t\tfor (int j = ps.size() - 1; j > i; j--) {\n\t\t\tP t = ps[j - 1] - c;\n\t\t\tP u = ps[j] - c;\n\t\t\tif (atan2(t.imag(), t.real()) > atan2(u.imag(), u.real())) {\n\t\t\t\tswap(ps[j - 1], ps[j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n//???a???????§???¢????????¨??????????????????. ?¢????????????????.\nbool isCover(P a) {\n\tbool flag = false;\n\tfor (int i = 0; i < n; i++) {\n\t\tP t = p[i] - a;\n\t\tP u = p[i + 1] - a;\n\t\tif (t.imag() > u.imag()) swap(t, u);\n\t\tif (t.imag() < 0 && 0 < u.imag() && cross(t, u) > 0) flag = !flag;\n\t}\n\treturn flag;\n}\n\n//?¬????????????¢???????¨????\ndouble getArea(P a, P b, P c) {\n\tdouble eps = 1e-10;\n\t\n\tP mid = (a + b) * 0.5;\n\tP t = (mid - c) / abs(mid - c); t *= 1e-9; t += mid;\n\t\n\tif (norm(c - a) >= r * r - eps && norm(c - b) >= r * r - eps && isCover(t)) {\n\t\t//??????\n\t\ta -= c;\n\t\tb -= c;\n\t\tdouble theta = arg(b / a);\n\t\treturn theta * r * r * 0.5;\n\t}\n\t//3?§???¢\n\treturn cross(a - c, b - c) * 0.5;\n}\n\n//???????????????c?????¨??????, ??±?????¨????????¢???????±???????.\n//c??????????§???¢????????¨???????????¨??????.\ndouble area(P c) {\n\tvector<P> ps;\n\t\n\t//?????¨?????????\n\tfor (int i = 0; i < n; i++) {\n\t\tvector<P> res = koten(p[i], p[i + 1], c);\n\t\tfor (int j = 0; j < res.size(); j++) {\n\t\t\tps.push_back(res[j]);\n\t\t}\n\t}\n\tif (ps.size() == 0) { return PAI * r * r; }\n\t\n\t//????????????????????????\n\tdouble eps = 1e-10;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (norm(c - p[i]) <= r * r - eps) {\n\t\t\tps.push_back(p[i]);\n\t\t}\n\t}\n\t\n\tangle_sort(ps, c);\n\tps.push_back(ps[0]);\n\t\n\tdouble ret = 0;\n\tfor (int i = 0; i < ps.size() - 1; i++) {\n\t\tret += getArea(ps[i], ps[i + 1], c);\n\t}\n\treturn ret;\n}\n\nint main() {\n\tint i;\n\t\n\tcin >> n >> r;\n\tfor (i = 0; i < n; i++) {\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = P(x, y);\n\t}\n\tp[n] = p[0];\n\t\n\tP c = P(0, 0);\n\tfor (i = 0; i < n; i++) { c += p[i]; }\n\tc /= n;\n\t\n\t//??¢?´¢\n\tconst int LoopNum = 10000;\n\tdouble maxArea = area(c);\n\tfor (i = 0; i < LoopNum; i++) {\n\t\tdouble dist = exp(-i / 1000.0);\n\t\tP dc = dist * exp(2 * PAI * (rand() % 1000) / 1000.0 * P(0, 1));\n\t\tif (maxArea < area(c + dc)) {\n\t\t\tmaxArea = area(c + dc);\n\t\t\tc = c + dc;\n\t\t}\n\t}\n\t\n\tprintf(\"%.14f\\n\", maxArea);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mem(a,b) memset((a),(b),sizeof(a))\n#define MP make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(x) x.size()\n#define all(x) x.begin(),x.end()\nusing namespace std;\n#define _GLIBCXX_PERMIT_BACKWARD_HASH\n#include <ext/hash_map>\nusing namespace __gnu_cxx;\nstruct str_hash{size_t operator()(const string& str)const{return __stl_hash_string(str.c_str());}};\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\nconst int INF=0x3f3f3f3f;\nconst ll LLINF=0x3f3f3f3f3f3f3f3f;\nconst double PI=acos(-1.0);\nconst double eps=1e-8;\nconst int MAX=2e5+10;\nconst ll mod=1e9+7;\ndouble r;\nint sgn(double x)\n{  \n\tif(fabs(x)<eps) return 0;\n\telse return x>0?1:-1;  \n}\nstruct Point\n{  \n\tdouble x,y;\n\tPoint(){}\n\tPoint(double a,double b)\n\t{\n\t\tx=a;\n\t\ty=b;\n\t}\n\tvoid input()\n\t{\n\t\tscanf(\"%lf%lf\",&x,&y);\n\t}\n};\ntypedef Point Vector;\nVector operator +(Vector a,Vector b){return Vector(a.x+b.x,a.y+b.y);}  \nVector operator -(Vector a,Vector b){return Vector(a.x-b.x,a.y-b.y);}  \nVector operator *(Vector a,double p){return Vector(a.x*p,a.y*p);}  \nVector operator /(Vector a,double p){return Vector(a.x/p,a.y/p);}\n\nbool operator <(Point a,Point b){return a.x<b.x||(a.x==b.x&&a.y<b.y);}\nbool operator ==(Point a,Point b){return sgn(a.x-b.x)==0&&sgn(a.y-b.y)==0;}\ndouble dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}//点?\ndouble length(Vector a){return sqrt(dot(a,a));}//向量的模 \n\ndouble cross(Vector a,Vector b){return a.x*b.y-a.y*b.x;}//叉? \ndouble dist(Point a,Point b){return sqrt(dot(a-b,a-b));}//?点距? \nPoint midseg(Point a,Point b){return (a+b)/2;}//?段ab中点\nVector Normal(Vector x){return Point(-x.y,x.x)/length(x);} //垂直法向量 \nVector Rotate(Vector a, double rad){return Vector(a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad));}\ndouble calarea(Point c,Point b,Point a){return cross(b-a,c-a);}//三个点求三角形面? \nVector vecunit(Vector x){return x/length(x);}//?位向量\ndouble VectorAngle(Vector v){return atan2(v.y,v.x);}\nstruct Line\n{  \n\tPoint p;//直?上任意一点  \n\tVector v;//?角,即从x正半?旋?到向量v所需要的角（弧度）  \n\tdouble ang;\n\tdouble a,b,c;//直?一般式 \n\tLine(){}\n\tLine(Point a,Vector b)//点斜式 \n\t{\n\t\tp=a;\n\t\tv=b;\n\t\tang=atan2(v.y,v.x);\n\t\tLineGeneralEquation();\n\t}\n\tvoid twopoint(Point a,Point b)//?点式 \n\t{\n\t\tp=a;\n\t\tv=b-a;\n\t\tang=atan2(v.y,v.x);\n\t\tLineGeneralEquation();\n\t}\n\tPoint getpoint(double a)\n\t{  \n\t\treturn p+(v*a);  \n\t}\n\tvoid LineGeneralEquation()//?算一般式的a,b,c \n\t{\n\t\tPoint p1,p2;\n\t\tp1=p;\n\t\tp2=p+v;\n\t\ta=p2.y-p1.y;  \n\t\tb=p1.x-p2.x;  \n\t\tc=-a*p1.x-b*p1.y;\n\t}\n};\nstruct Circle  \n{  \n    Point c;  \n    double r;  \n    Circle(){}  \n    Circle(Point a,double b)\n    {\n\t\tc=a;\n\t\tr=b;\n\t}\n\tPoint getpoint(double a) //根据?心角求点坐?  \n\t{  \n        return Point(c.x+cos(a)*r,c.y+sin(a)*r);  \n\t}  \n}; \nbool OnSeg(Point p,Point p1,Point p2)\n{  \n\treturn sgn(cross(p1-p,p2-p))==0&&sgn(dot(p1-p,p2-p))<0;\n}\nPoint PointOfLineInter(Line a,Line b)//?段交点\n{\n\tVector u=a.p-b.p;\n\tdouble t=cross(b.v,u)/cross(a.v,b.v);\n\treturn a.p+a.v*t;\n}\nbool InCircle(Point x,Circle c){return sgn(c.r-length(c.c-x))>=0;}//在?内(包括?上) \nint getSegCircleInter(Line l,Circle c,Point *sol)//?段与?的交点\n{  \n\tVector nor=Normal(l.v);\n\tLine l1=Line(c.c,nor);  \n\tPoint p1=PointOfLineInter(l1,l);  \n\tdouble d=length(p1-c.c);  \n    if(sgn(d-c.r)>0) return 0;\n\tPoint p2=vecunit(l.v)*sqrt(c.r*c.r-d*d);  \n\tint res=0;  \n\tsol[res]=p1+p2;  \n    if(OnSeg(sol[res],l.p,l.getpoint(1))) res++;\n\tsol[res]=p1-p2;\n\tif(OnSeg(sol[res],l.p,l.getpoint(1))) res++;  \n\treturn res;  \n}  \ndouble SegCircleArea(Circle c,Point a,Point b) //?段切割?  \n{  \n\tdouble a1=VectorAngle(a-c.c);  \n\tdouble a2=VectorAngle(b-c.c);  \n\tdouble da=fabs(a1-a2);  \n\tif (sgn(da-PI)>0) da=PI*2.0-da;  \n\treturn sgn(cross(b-c.c,a-c.c))*da*c.r*c.r/2.0;  \n}\ndouble PolyCiclrArea(Circle c,Point *p,int n)//多?形与?面?交  \n{  \n\tdouble res=0;  \n\tPoint sol[2];  \n\tfor(int i=0;i<n;i++)\n\t{\n\t\tdouble t1,t2;  \n\t\tint cnt=getSegCircleInter(Line(p[i],p[i+1]-p[i]),c,sol);  \n\t\tif(cnt==0)  \n\t\t{  \n\t\t\tif(!InCircle(p[i],c)||!InCircle(p[i+1],c)) res+=SegCircleArea(c,p[i],p[i+1]);  \n\t\t\telse res+=cross(p[i+1]-c.c,p[i]-c.c)/2.0;  \n\t\t}  \n\t\tif(cnt==1)  \n\t\t{  \n\t\t\tif(InCircle(p[i],c)&&!InCircle(p[i+1],c))\n\t\t\t{\n\t\t\t\tres+=cross(sol[0]-c.c,p[i]-c.c)/2.0;\n\t\t\t\tres+=SegCircleArea(c,sol[0],p[i+1]);  \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tres+=SegCircleArea(c,p[i],sol[0]);\n\t\t\t\tres+=cross(p[i+1]-c.c,sol[0]-c.c)/2.0;  \n\t\t\t}\n\t\t}  \n\t\tif(cnt==2)  \n\t\t{  \n\t\t\tif((p[i]<p[i+1])^(sol[0]<sol[1])) swap(sol[0],sol[1]);  \n\t\t\tres+=SegCircleArea(c,p[i],sol[0]);  \n\t\t\tres+=cross(sol[1]-c.c,sol[0]-c.c)/2.0;  \n\t\t\tres+=SegCircleArea(c,sol[1],p[i+1]);  \n\t\t}  \n\t}  \n\treturn fabs(res);  \n}\ndouble getres(Point t,Point *p,int n)\n{\n\tdouble res=0;\n\tres=PolyCiclrArea(Circle(t,r),p,n);\n\treturn res;\n}\npair<Point,double> SA(Point *p,int n)\n{  \n\tPoint s;  \n\tdouble T=100,t,ds,dz,ans;  \n\tint i,j,k,flag,dir[5][2]={0,0,1,0,-1,1,0,-1,0};\n\ts=Point(0,0);\n\tfor(i=0;i<n;i++)\n\t{  \n\t\ts.x+=p[i].x;  \n\t\ts.y+=p[i].y;  \n\t}\n\ts.x/=n;  \n\ts.y/=n;  \n\tans=0;\n\tfor(k=1;k<=200000;k++)\n\t{\n\t\tt=T/k;\n\t\tfor(i=0;i<5;i++)  \n\t\t{\n\t\t\tPoint z;\n\t\t\tz.x=s.x+dir[i][0]*t;  \n\t\t\tz.y=s.y+dir[i][1]*t;  \n\t\t\tdz=getres(z,p,n);\n\t\t\tif(dz>ans)  \n\t\t\t{  \n\t\t\t\tans=dz;\n\t\t\t\ts=z;\n\t\t\t} \n\t\t}\n\t}\n\tpair<Point,double> res;\n\tres=make_pair(s,ans);\n\treturn res;\n}\nint main()\n{\n\tint n,i;\n\tPoint p[12];\n\twhile(~scanf(\"%d%lf\",&n,&r))\n\t{\n\t\tfor(i=0;i<n;i++)\n\t\t{\n\t\t\tp[i].input();\n\t\t}\n\t\tp[n]=p[0];\n\t//\tprintf(\"%.6lf\\n\",getres(Point(3,3),p,n+1));\n\t\tpair<Point,double> ans=SA(p,n);\n\t\tprintf(\"%.6lf\\n\",ans.se);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\n#define CVector CPoint\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1.0);\nconst double EPS=1e-7;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-7;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n    /*friend bool operator<(CPoint a,CPoint b){//?角排序\n        double tmp=cross(Pts[0],a,b);\n        if(isZero(tmp)){\n            return dist(Pts[0],a)<dist(Pts[0],b);\n        }\n        return tmp>0;\n    }*/\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n/*----------------------多?形相?--------------------------*/\n\n//0:outside 1:inside 2:online\nint PointInPoly(Point t,Point *Pts,int n){\n    int num=0,d1,d2,k;\n    Pts[n]=Pts[0];\n    for(int i=0;i<n;i++){\n        if(PointOnS(t,Line(Pts[i],Pts[i+1]))) return 2;\n        k=dcmp(cross(Pts[i],Pts[i+1],t));\n        d1=dcmp(Pts[i].y-t.y);\n        d2=dcmp(Pts[i+1].y-t.y);\n        if(k>0&&d1<=0&&d2>0) num++;\n        if(k<0&&d2<=0&&d1>0) num--;\n    }\n    return num!=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n//求任意多?形周?，需逆??或???排列\ndouble PolyPerimeter(Point *Pts,int n){\n    double pp=distPP(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pp+=distPP(Pts[i],Pts[i+1]);\n    return pp;\n}\n\n//求多?形重心坐?\nPoint PolyCore(Point *Pts,int n){\n    double pa=PolyArea(Pts,n);\n    if(!dcmp(pa)) return Point(0,0);\n    Point ans=(Pts[n-1]+Pts[0])*cross(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) ans=ans+(Pts[i]+Pts[i+1])*cross(Pts[i],Pts[i+1]);\n    return ans/pa/6;\n}\n\n/*----------------------凸包----------------------------*/\n\n//Graham-scan st:anticlockwise\n//<=:strict <:Non-strict\nint Graham(Point *Pts,Point *st,int n){\n    if(n<3) return 0;\n    sort(Pts,Pts+n);\n    int m=0;\n    for(int i=0;i<n;i++){\n        while(m>1&&dcmp(cross(st[m-2],st[m-1],Pts[i]))<0) m--;\n        st[m++]=Pts[i];\n    }\n    int k=m;\n    for(int i=n-2;i>=0;i--){\n        while(m>k&&dcmp(cross(st[m-2],st[m-1],Pts[i])<0)) m--;\n        st[m++]=Pts[i];\n    }\n    return m-1;\n}\n\n//clockwise:> anticlockwise:<\ndouble CHDiameter(Point *Pts,int n,Line &l){\n    double maxd=0.0;\n    if(n<=1){\n        l.a=l.b=Pts[0];\n        return maxd;\n    }\n    for(int i=0,j=1;i<n;i++){\n        while(cross(Pts[i],Pts[(i+1)%n],Pts[j])\n              >cross(Pts[i],Pts[(i+1)%n],Pts[(j+1)%n])){\n            j=(j+1)%n;\n        }\n        double d=distPP(Pts[i],Pts[j]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n        d=distPP(Pts[(i+1)%n],Pts[(j+1)%n]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n    }\n    return maxd;\n}\n\n/*---------------------整点多?形---------------------------*/\n\nint gcd(int a,int b){\n    return b==0?a :gcd(b,a%b);\n}\n\n//整点多?形?界整点数\nint Border_Int_Point_Num(Point *Pts,int n){\n    int num=gcd(abs(int(Pts[0].x-Pts[n-1].x)),abs(int(Pts[0].y-Pts[n-1].y)));;\n    for(int i=0;i<n-1;i++){\n        num+=gcd(abs(int(Pts[i+1].x-Pts[i].x)),abs(int(Pts[i+1].y-Pts[i].y)));\n    }\n    return num;\n}\n\n//整点多?形内部整点数\nint Inside_Int_Point_Num(Point *Pts,int n){\n    return abs(int(PolyArea(Pts,n)))+1-Border_Int_Point_Num(Pts,n)/2;\n}\n\n/*-----------------------------半平面交-------------------------------*/\n\n//有方向的直?\n//p->p+v\nstruct Vector{\n    Point p,v;\n    double ang;\n    Vector(Point p,Point v):p(p),v(v){\n        ang=atan2(v.y,v.x);\n    }\n    Vector(){}\n    bool operator<(const Vector &l) const{\n        return ang<l.ang;\n    }\n};\n\n//判断点p是否在直?L左?\nbool onLeft(Vector L,Point p){\n    return cross(L.v,p-L.p)>0;\n}\n\n//得到a与b?直?的交点\nPoint getCrossVV(Vector a,Vector b){\n    Point u=a.p-b.p;\n    double t=cross(b.v,u)/cross(a.v,b.v);\n    return a.p+a.v*t;\n}\n\n//所有直?左半平面的交\nint HPCross(Vector *L,int n,Point *poly){\n    sort(L,L+n);\n    int f=0,l=0;\n    Point *p=new Point[n];\n    Vector *q=new Vector[n];\n    q[0]=L[0];\n    for(int i=1;i<n;i++){\n        while(f<l&&!onLeft(L[i],p[l-1])) l--;\n        while(f<l&&!onLeft(L[i],p[f])) f++;\n        q[++l]=L[i];\n        if(!dcmp(cross(q[l].v,q[l-1].v))){\n            l--;\n            if(onLeft(q[l],L[i].p)) q[l]=L[i];\n        }\n        if(f<l) p[l-1]=getCrossVV(q[l-1],q[l]);\n    }\n    while(f<l&&!onLeft(q[f],p[l-1])) l--;\n    if(l-f<=1) return 0;\n    p[l]=getCrossVV(q[l],q[f]);\n    int m=0;\n    for(int i=f;i<=l;i++) poly[m++]=p[i];\n    return m;\n}\n\n#define maxn 100005\nVector l[maxn];\nbool retract(Vector *L,int n,double r,Point *poly){\n    for(int i=0;i<n;i++){\n        Point v=rotateV(L[i].p,L[i].p+L[i].v,PI/2);\n        l[i]=Vector(L[i].p+r*v,L[i].v);\n    }\n    int cnt=HPCross(l,n,poly);\n    return cnt;\n}\n\n/*---------------------三角形相?---------------------------*/\n\n//三角形重心\n//到三?点距?的平方和最小的点\n//到三?距?之?最大的点\nPoint TCore(Point a,Point b,Point c){\n    return (a+b+c)/3;\n}\n\n//三角形外心\nPoint TCircum(Point a,Point b,Point c){\n    Point cp;\n    double a1=b.x-a.x;\n    double b1=b.y-a.y;\n    double a2=c.x-a.x;\n    double b2=c.y-a.y;\n    double c1=(a1*a1+b1*b1)/2;\n    double c2=(a2*a2+b2*b2)/2;\n    double d=a1*b2-a2*b1;\n    cp.x=a.x+(c1*b2-c2*b1)/d;\n    cp.y=a.y+(a1*c2-a2*c1)/d;\n    return cp;\n}\n\n//三角形垂心\nPoint TOrtho(Point a,Point b,Point c){\n    return TCore(a,b,c)*3.0-TCircum(a,b,c)*2.0;\n}\n\n//三角形内心\nPoint TInner(Point a,Point b,Point c){\n    Point cp;\n    double la=distPP(b,c),lb=distPP(c,a),lc=distPP(a,b);\n    cp.x=(la*a.x+lb*b.x+lc*c.x)/(la+lb+lc);\n    cp.y=(la*a.y+lb*b.y+lc*c.y)/(la+lb+lc);\n    return cp;\n}\n\n//求三角形面?\ndouble TArea(Point a,Point b,Point c){\n    return fabs(cross(a,b,c))/2;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n//求??面?交\ndouble getAreaCC(Circle a,Circle b){\n    double d=(a.o.x-b.o.x)*(a.o.x-b.o.x)+(a.o.y-b.o.y)*(a.o.y-b.o.y);\n    if(d<=(a.r-b.r)*(a.r-b.r)){\n        return min(a.r,b.r)*min(a.r,b.r)*PI;\n    }else if(d>(a.r-b.r)*(a.r-b.r)&&d<(a.r+b.r)*(a.r+b.r)){\n        double m1=(a.r*a.r+d-b.r*b.r)/(2*a.r*sqrt(d));\n        double m2=(b.r*b.r+d-a.r*a.r)/(2*b.r*sqrt(d));\n        double s1=acos(m1)*a.r*a.r;\n        double s2=acos(m2)*b.r*b.r;\n        double s3=sqrt(d)*a.r*sin(acos(m1));\n        return s1+s2-s3;\n    }\n    return 0.0;\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n/********************************************************/\nint getCrossCS(Circle c,Line s,Point *cs){\n    Point tmp[2];\n    int cnt=0;\n    int ct=getCrossCL(c,s,tmp);\n    for(int i=0;i<ct;i++){\n        if(PointOnS(tmp[i],s)) cs[cnt++]=tmp[i];\n    }\n    return cnt;\n}\n\nPoint PinS(Point *cs,int n,Line s){\n    if(n==1) return cs[0];\n    if(length(cs[0]-s.a)<length(cs[1]-s.a)) return cs[1];\n    return cs[0];\n}\n\ndouble getAngle(Point a,Point b){\n    double tmp=dot(a,b)/length(a)/length(b);\n    if(tmp<-1.0) tmp=-1.0;\n    if(1.0<tmp) tmp=1.0;\n    return acos(tmp);\n}\n\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=fabs(cross(a-c.o,b-c.o)/2);\n    if(!dcmp(atc)) return 0.0;\n    double la=length(a-c.o),lb=length(b-c.o);\n    Point cs[4];\n    if(la<c.r+EPS&&lb>c.r-EPS){\n        int ct=getCrossCS(c,Line(a,b),cs);\n        Point p=PinS(cs,ct,Line(a,b));\n        atc+=c.r*c.r*angleVV(p-c.o,b-c.o)/2;\n        atc-=fabs(cross(p-c.o,b-c.o)/2);\n    }else if(la>c.r-EPS&&lb<c.r+EPS){\n        int ct=getCrossCS(c,Line(a,b),cs);\n        Point p=PinS(cs,ct,Line(b,a));\n        atc+=c.r*c.r*angleVV(p-c.o,a-c.o)/2;\n        atc-=fabs(cross(p-c.o,a-c.o)/2);\n    }else if(la>c.r-EPS&&lb>c.r-EPS){\n        if(distPS(c.o,Line(a,b))<c.r-EPS){\n            Point rt=root(c.o,Line(a,b));\n            atc=fabs(getAreaTC(a,rt,c))+fabs(getAreaTC(rt,b,c));\n        }else atc=c.r*c.r*angleVV(a-c.o,b-c.o)/2;\n    }\n    if(cross(a-c.o,b-c.o)>0) atc=-atc;\n    return atc;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=getAreaTC(Pts[n-1],Pts[0],c);\n    for(int i=0;i<n-1;i++) apc+=getAreaTC(Pts[i],Pts[i+1],c);\n    return fabs(apc);\n}\n\n/********************************************************/\n\n\n/*----------------------三?点、?基本函数-----------------------------*/\n\nstruct Point3{\n    double x,y,z;\n    Point3(double x,double y,double z):x(x),y(y),z(z){}\n    Point3(){}\n    void Read(){ scanf(\"%lf%lf%lf\",&x,&y,&z); }\n};\n\nstruct Line3{\n    Point3 a,b;\n    Line3(Point3 a,Point3 b):a(a),b(b){}\n    Line3(){}\n    void Read(){ a.Read(); b.Read(); }\n};\nPoint3 operator +(Point3 a,Point3 b){ return Point3(a.x+b.x,a.y+b.y,a.z+b.z); }\nPoint3 operator -(Point3 a,Point3 b){ return Point3(a.x-b.x,a.y-b.y,a.z-b.z); }\ndouble operator *(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 operator *(Point3 a,double k){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator *(double k,Point3 a){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator /(Point3 a,double k){ return Point3(a.x/k,a.y/k,a.z/k); }\n\ndouble length(Point3 a){ return sqrt(a.x*a.x+a.y*a.y+a.z*a.z); }\nPoint3 unit(Point3 a){ return a/length(a); }\ndouble dot(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 cross(Point3 a,Point3 b){\n    return Point3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//混合?\ndouble Mix(Point3 a,Point3 b,Point3 c){\n    return dot(a,cross(b,c));\n}\n\n//?点距?\ndouble dist(const Point3 &a,const Point3 &b){ return length(a-b); }\n\n/*---------------------------------体?-------------------------------------*/\n\n//四面体体?\ndouble volume(double l,double n,double a,double m,double b,double c){\n    double x,y;\n    x=4*a*a*b*b*c*c-a*a*(b*b+c*c-m*m)*(b*b+c*c-m*m)-b*b*(c*c+a*a-n*n)*(c*c+a*a-n*n);\n    y=c*c*(a*a+b*b-l*l)*(a*a+b*b-l*l)-(a*a+b*b-l*l)*(b*b+c*c-m*m)*(c*c+a*a-n*n);\n    return sqrt(x-y)/12;\n}\n\ndouble volume(Point3 a,Point3 b,Point3 c,Point3 d){\n    return fabs(Mix(b-a,c-a,d-a)/6);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);//cin.tie(0);\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define cout if (0) cout\n\n// XXX without explanation marks untested functions\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pii;\n#define pb push_back\n\n// NOT STANDART FROM HERE\n\n// area de calota 2.pi.R.h (h altura)\n// volume de calota pi.h/6 * (3r^2 + h^2)\n\n typedef double cood;\n cood eps = 1e-8;\n// tests for double were made with eps = 1e-8\n\ndouble eps_d = 1e-8; // necessary even in integer geometry, should be eps otherwise\n\nconst double pi = acos(-1.);\n\ninline ll sq (ll x)\n{ return x*x; }\ninline double sq (double x)\n{ return x*x; }\n\nstruct vec { // vector\n\t// === BASIC ===\n\tcood x, y;\n\tvec () : x(0), y(0) {}\n\tvec (cood a, cood b) : x(a), y(b) {}\n\tfriend ostream& operator<<(ostream& os, vec o);\n\n\tvec operator - (vec o)\n\t{ return vec(x - o.x, y - o.y); }\n\tvec operator + (vec o)\n\t{ return vec(x + o.x, y + o.y); }\n\tvec operator * (cood o)\n\t{ return vec(x * o, y * o); }\n\tvec operator / (cood o)\n\t{ return vec(x / o, y / o); }\n\tcood operator ^ (vec o)\n\t{ return x * o.y - y * o.x; }\n\tcood operator * (vec o)\n\t{ return x * o.x + y * o.y; }\n\n\t// positive is (*this)b is clockwise from (*this)a\n\tdouble angle (vec a, vec b)\n\t{ return atan2((a-(*this))^(b-(*this)), (a-(*this))*(b-(*this))); }\n\n\tcood sq (vec o = vec())\n\t{ return ((*this)-o)*((*this)-o); }\n\tdouble nr (vec o = vec())\n\t{ return sqrt(sq(o)); }\n\n\tcood cross (vec a, vec b) // ccw signed area (positive if this is to the left of ab)\n\t{ return (b - a) ^ ((*this) - a); }\n\tint ccw (vec a, vec b) // which side is this from ab? (1 left, 0 over, -1 right)\n\t{ cood o = cross(a, b); return (eps < o) - (o < -eps); } \n\n\tint dir (vec a, vec b) // direction of (this)a relative to (this)b (-1 opposite, 0 none, 1 same)\n\t{ cood o = ((*this) - a)*((*this) - b); return (eps < o) - (o < -eps); }\n\n\tcood inner (vec s, vec t) // (p-s)*(t-s) where p = this projected on st\n\t{ return ((*this) - s) * (t - s); }\n\tvec proj (vec s, vec t) // projection of this point over line st\n\t{ return s + (t - s)*(inner(s,t) / t.sq(s)); }\n\n\tvec rotate (double a) // rotate ccw by a (fails with ll)\n\t{ return vec(cos(a) * x - sin(a) * y, sin(a) * x + cos(a) * y); }\n\tvec rot90 () // rotate pi/2 ccw\n\t{ return vec(-y, x); }\n\n\t// === ADVANCED ===\n\t// ordering that defines the compare method\n\t// used only there, change it accordingly\n\t// sorts increasing on y and, then increasing on x\n\tbool operator < (const vec & o) const {\n\t\tif (y != o.y)\n\t\t\treturn y < o.y;\n\t\treturn x < o.x;\n\t}\n\n\t// full ordering (ccw angle from this+(1,0), distance to this)\n\t// is a < b?\n\t// PRECISION : ok with double if norm in [-1e9,5e3]\n\tbool compare (vec a, vec b) {\n\t\tif (((*this) < a) != ((*this) < b))\n\t\t\treturn (*this) < a;\n\t\tint o = ccw(a,b);\n\t\tif (o) return o > 0;\n\t\treturn a.dir((*this),b) < 0;\n\t}\n\n\t// is this inside segment st? (tip of segment included, change for dr < 0 otherwise)\n\tbool in_seg (vec s, vec t)\n\t{ return (ccw(s,t) == 0) && (dir(s,t) <= 0); }\n\n\t// squared distance from this to line defined by st\n\tdouble dist2_lin (vec s, vec t)\n\t{ return double(::sq(cross(s,t))) / t.sq(s); }\n\t// squared distance from this to segment st\n\tdouble dist2_seg (vec s, vec t) \n\t{ return s.dir((*this),t) == t.dir((*this),s) ? dist2_lin(s,t) : min(sq(s),sq(t)); }\n\n\t// is this inside (borders included) the convex polygon v of size n?\n\t// if yes, prec is the vec that this on acw order from v[0] or 0 if there is no such\n\t// if not, prec is the predecessor of this when added to poly and succ is the sucessor\n\t// p should be a vector with [0..n-1]\n\t// n should be >= 2\n\tbool in_conv_poly (vec v[], int n, const vector<int> & p, int & prec, int & succ) {\n\t\tif (nr(v[0]) <= eps) {\n\t\t\tprec = 0;\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (n == 2) {\n\t\t\tif (in_seg(v[0],v[1]))\n\t\t\t\treturn (prec = 1);\n\n\t\t\tif (ccw(v[0],v[1]) > 0) {\n\t\t\t\tprec = 1;\n\t\t\t\tsucc = 0;\n\t\t\t} else if (ccw(v[0],v[1]) < 0) {\n\t\t\t\tprec = 0;\n\t\t\t\tsucc = 1;\n\t\t\t} else {\n\t\t\t\tprec = succ = (v[0].dir((*this),v[1]) < 0);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (ccw(v[0],v[1]) > 0 || ccw(v[0],v[n-1]) < 0) {\n\t\t// case where v[0] is not removed\n\t\t\t// last diagonal before or over this\n\t\t\tint di = lower_bound(p.begin() + 1, p.end(), -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[0],v[i]) >= 0;\n\t\t\t}) - p.begin() - 1;\n\n\t\t\t// is this inside the polygon?\n\t\t\tprec = di;\n\t\t\tif (di == n-1) {\n\t\t\t// last segment\n\t\t\t\tif (ccw(v[0],v[n-1]) == 0 && ccw(v[n-2],v[n-1]) >= 0)\n\t\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t// inside otherwise\n\t\t\t\tif (ccw(v[di],v[di+1]) >= 0)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// last that stays before (or eq to) di\n\t\t\tprec = lower_bound(p.begin() + 1, p.begin() + di + 1, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i-1],v[i]) > 0;\n\t\t\t}) - p.begin() - 1;\n\n\t\t\t// first that stays after di\n\t\t\tsucc = lower_bound(p.begin() + di + 1, p.end(), -1, [this,v,n] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[(i+1)%n],v[i]) >= 0;\n\t\t\t}) - p.begin();\n\t\t\tif (succ == n) succ = 0;\n\t\t} else {\n\t\t// case where v[0] is removed\n\t\t\t// first diagonal before of over this\n\t\t\t// di is certainly not removed\n\t\t\tint di = lower_bound(p.begin() + 1, p.end() - 1, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[0],v[i]) < 0;\n\t\t\t}) - p.begin();\n\n\t\t\t// first that stays (<= di)\n\t\t\tsucc = lower_bound(p.begin(), p.begin() + di, -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i+1],v[i]) >= 0;\n\t\t\t}) - p.begin();\n\n\t\t\t// last that stays (>= di)\n\t\t\tprec = lower_bound(p.begin() + di + 1, p.end(), -1, [this,v] (int i, int j) {\n\t\t\t\tassert(j == -1);\n\t\t\t\treturn ccw(v[i-1],v[i]) > 0;\n\t\t\t}) - p.begin() - 1;\n\t\t}\n\t\treturn 0;\n\t}\n};\nostream& operator<<(ostream& os, vec o)\n{ return os << '(' << o.x << \", \" << o.y << ')'; }\n\nstruct lin { // line\n\tcood a, b, c; // a*x + b*y = c\n\n\tlin () {}\n\tlin (cood x, cood y, cood z) : a(x), b(y), c(z) {}\n\tlin (vec s, vec t) : a(t.y - s.y), b(s.x - t.x), c(a * s.x + b * s.y) {}\n\n\tlin parll (vec p) // parallel to this through p\n\t{ return lin(a, b, a * p.x + b * p.y); }\n\tlin perp ()\n\t{ return lin(-b, a, c); }\n\n\tvec inter (lin o) {\n\t\tcood d = a * o.b - o.a * b;\n\t\tif (d < eps && -eps < d) throw 0; // parallel\n\t\treturn vec((o.b * c - b * o.c) / d, (a * o.c - o.a * c) / d);\n\t}\n};\n\nstruct cir { // circle\n\tvec c; cood r;\n\n\t// borders included\n\tbool contains (vec w)\n\t{ return c.sq(w) <= sq(r) + eps; }\n\tbool has_inter (cir o)\n\t{ return c.sq(o.c) <= sq(r + o.r) + eps; }\n\tbool has_inter_lin (vec s, vec t)\n\t{ return c.dist2_lin(s,t) <= sq(r) + eps_d; }\n\tbool has_inter_seg (vec s, vec t)\n\t{ return c.dist2_seg(s,t) <= sq(r); }\n\n\t// borders not included\n\tbool contains (cir o)\n\t{ return (o.r < r - eps && c.sq(o.c) < sq(r - o.r) - eps); }\n\n\t// ccw oriented area of arc from a to b\n\tdouble arc_area (vec a, vec b) {\n\t\tdouble ang = c.angle(a,b);\n\t\treturn r*r*ang*.5;\n\t}\n\n\t// double only\n\tpair<vec,vec> inter_pts (cir o) {\n\t\tassert(has_inter(o) && !contains(o)); // fully contained case\n\t\tdouble d = c.nr(o.c);\n\t\tdouble a = (r*r + d*d - o.r*o.r) / (2.*d); // r*cos(ans,v,c.v)\n\t\tdouble h = sqrt(r*r - a*a);\n\t\tif (h != h) h = 0;\n\t\tvec p = o.c - c;\n\t\treturn pair<vec,vec>(c + p*(a/d) + (p.rot90()*(h/d)), c + p*(a/d) - (p.rot90()*(h/d)));\n\t}\n\n\t// double only XXX careful precision\n\tpair<vec,vec> inter_pts (vec s, vec t) { \n\t\tassert(has_inter_lin(s,t));\n\t\tdouble h2 = c.dist2_lin(s,t);\n\t\tdouble d = sqrt(c.sq(t) - h2);\n\t\tif (d != d) d = 0;\n\t\tvec p = (s-t);\n\t\tvec m = t + p*(d/p.nr());\n\t\tvec m_b = t - p*(d/p.nr());\n\t\tif (m_b.sq(c) < m.sq(c))\n\t\t\tm = m_b;\n\n\t\td = sqrt(r*r - h2);\n\t\tif (d != d) d = 0;\n\t\tpair<vec,vec> res(m + p*(d/p.nr()), m - p*(d/p.nr()));\n\t\tif (res.first.sq(t) > res.second.sq(t))\n\t\t\tswap(res.first, res.second);\n\t\treturn res;\n\t}\n\n\t// double only XXX not tested\n\t// signed area of intersection of this with triangle (this.c,a,b)\n\tdouble inter (vec a, vec b) {\n\t\tcout << c << \" with \" << a << \",\" << b << \": \";\n\t\tdouble res = 0.;\n\t\tbool inv = 0;\n\t\tif (contains(b)) {\n\t\t\tswap(a,b);\n\t\t\tinv = 1;\n\t\t\tcout << \"[inv] \";\n\t\t}\n\n\t\tif (contains(b)) {\n\t\t\tcout << \"contains both\";\n\t\t\tres = c.cross(a,b)*.5;\n\t\t} else if (contains(a)) {\n\t\t\tcout << \"contains \" << a;\n\t\t\tpair<vec,vec> rt = inter_pts(a,b);\n\t\t\tcout << endl << \"[[\" << rt.first << \" \" << rt.second << endl;\n\t\t\tvec q = rt.first;\n\t\t\tif (!q.in_seg(a,b) || (a.sq(q) <= eps && rt.second.in_seg(a,b)))\n\t\t\t//if (rt.second.dist2_seg(a,b) < q.dist2_seg(a,b))\n\t\t\t\tq = rt.second;\n\t\t\tcout << \" inter at \" << q;\n\n\t\t\tres += c.cross(a,q)*.5;\n\t\t\tres += arc_area(q,b);\n\t\t} else if (has_inter_seg(a, b)) {\n\t\t\tcout << \"inter seg\";\n\t\t\tpair<vec,vec> rt = inter_pts(b,a);\n\n\t\t\tres += arc_area(a,rt.first);\n\t\t\tres += c.cross(rt.first,rt.second)*.5;\n\t\t\tres += arc_area(rt.second,b);\n\t\t} else {\n\t\t\tcout << \"arc only\";\n\t\t\tres += arc_area(a,b);\n\t\t}\n\n\t\tif (inv) res = -res;\n\t\tcout << \" = \" << res << endl;\n\t\treturn res;\n\t}\n\n\tdouble area (vec a, vec b) {\n\t\tdouble aa = c.nr(a), bb = c.nr(b), cc = sqrt(c.dist2_seg(a,b));\n\t\tif (aa <= r + eps && bb <= r + eps) return .5*abs((a-c)^(b-c));\n\t\tif (cc >= r - eps) return .5*abs(r*r*c.angle(a,b));\n\n\t\tif (aa > bb + eps) { swap(a,b); swap(aa,bb); }\n\t\tdouble A = a.sq(b), B = 2.*((a-b)*(b-c)), C = b.sq(c) - r*r;\n\t\tdouble t = B*B-4*A*C;\n\t\tif (abs(t) <= eps) t = 0;\n\t\telse t = sqrt(t);\n\t\tdouble x1 = .5*(-B-t)/A, x2 = .5*(-B+t)/A;\n\t\tvec p1 = a*x1 + b*(1-x1), p2 = a*x2 + b*(1-x2);\n\n\t\tif (aa < r - eps) return area(a,p1) + area(p1,b);\n\t\treturn area(a,p2) + area(p2,p1) + area(p1,b);\n\t}\n\n\t// double only XXX not tested\n\t// signed area of intersection of this with polygon\n\tdouble inter (vector<vec> & p) {\n\t\tdouble res = 0;\n\t\tfor (int i = 0; i < p.size(); i++) {\n\t\t\t//res += area(p[i],p[(i+1)%p.size()]) * c.ccw(p[i],p[(i+1)%p.size()]);\n\t\t\tres += inter(p[i],p[(i+1)%p.size()]);\n\t\t}\n\n\t\treturn res;\n\t}\n};\n\n// do the segments ab and cd intersect? (borders included) XXX\nbool inter_seg (vec a, vec b, vec c, vec d) {\n\tif (a.in_seg(c, d) || b.in_seg(c, d) || c.in_seg(a, b) || d.in_seg(a, b))\n\t\treturn true;\n\treturn (c.ccw(a, b) * d.ccw(a, b) == -1 && a.ccw(c, d) * b.ccw(c, d) == -1);\n}\n\n// squared distance from segments ab and cd XXX\ndouble dist2_seg (vec a, vec b, vec c, vec d)\n{ return inter_seg(a,b,c,d) ? 0. : min({ a.dist2_seg(c,d), b.dist2_seg(c,d), c.dist2_seg(a,b), d.dist2_seg(a,b) }); }\n\n// brd = do points on the border belong to convex?\n// computes convex hull of given vector (inplace)\n// returns size of convex hull\nint graham (vec v[], int n, int brd) {\n\tfor (int i = 1; i < n; i++) {\n\t\tif (v[i].x < v[0].x || (v[i].x == v[0].x && v[i].y < v[0].y))\n\t\t\tswap(v[0], v[i]);\n\t}\n\n\tsort(v+1, v+n, [v] (vec a, vec b) {\n\t\tint o = b.ccw(v[0], a);\n\t\tif (o) return (o == 1);\n\t\treturn v[0].sq(a) < v[0].sq(b);\n\t});\n\n\tif (brd) {\n\t\tint s = n-1;\n\t\twhile (s > 1 && v[s].ccw(v[s-1],v[0]) == 0)\n\t\t\ts--;\n\t\tfor (int i = s; i < n - 1 - (i - s); i++)\n\t\t\tswap(v[i], v[n-1-(i-s)]);\n\t}\n\n\tint s = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s && v[s-1].x == v[i].x && v[s-1].y == v[i].y) continue;\n\t\twhile (s >= 2 && v[s-1].ccw(v[s-2],v[i]) >= brd)\n\t\t\ts--;\n\t\tv[s++] = v[i];\n\t}\n\n\treturn s;\n}\n\nconst int N = 1e2+7;\n\nint n;\ndouble r;\nvector<vec> v;\ndouble x[2], y[2];\n\ndouble solve (double x) {\n\tdouble lo = 200, hi = -100.;\n\tfor (int i = 0; i < n; i++) {\n\t\tint j = (i+1)%n;\n\t\tlin ln(v[i],v[j]);\n\t\tvec it(x, (ln.c - ln.a*x)/ln.b);\n\t\tcout << it << \" \";\n\t\tif (it.in_seg(v[i],v[j]) && it.y == it.y && abs(it.y) < 200) {\n\t\t\tlo = min(lo, it.y);\n\t\t\thi = max(hi, it.y);\n\t\t}\n\n\t\tif (abs(v[i].x - x) <= eps_d) {\n\t\t\tcout << v[i] << \"! \";\n\t\t\tlo = min(lo, v[i].y);\n\t\t\thi = max(hi, v[i].y);\n\t\t}\n\t}\n\thi = min(hi, 200.); lo = max(lo, -100.);\n\tcout << x << \" [\" << lo << \" \" << hi << \"]\" << endl;\n\n\tint ts = 60;\n\twhile (ts--) {\n\t\tdouble q1 = (lo+lo+hi)/3;\n\t\tdouble q2 = (lo+hi+hi)/3;\n\n\t\tdouble r1 = abs(cir({ vec(x,q1), r }).inter(v));\n\t\tdouble r2 = abs(cir({ vec(x,q2), r }).inter(v));\n\n\t\tif (r1 < r2)\n\t\t\tlo = q1;\n\t\telse\n\t\t\thi = q2;\n\t}\n\n\treturn abs(cir({ vec(x,lo), r }).inter(v));\n}\n\nint main () {\n\n\twhile (scanf(\"%d %lf\", &n, &r) != EOF) {\n\t\tcout << n << endl;\n\t\tv = vector<vec>(n);\n\t\t\n\t\tx[0] = 200;\n\t\tx[1] = -100;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tscanf(\"%lf %lf\", &v[i].x, &v[i].y);\n\t\t\tcout << v[i] << \" \";\n\n\t\t\tx[0] = min(x[0],v[i].x);\n\t\t\tx[1] = max(x[1],v[i].x);\n\t\t}\n\t\tcout << endl;\n\n\t\tdouble lo = x[0], hi = x[1];\n\t\t//int ts = 60;\n\t\tint ts = 50;\n\t\twhile (ts--) {\n\t\t\tdouble q1 = (lo+lo+hi)/3;\n\t\t\tdouble q2 = (lo+hi+hi)/3;\n\t\t\t\n\t\t\tif (solve(q1) < solve(q2))\n\t\t\t\tlo = q1;\n\t\t\telse\n\t\t\t\thi = q2;\n\t\t}\n\n\t\tdouble res = solve(lo);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tres = max(res, abs(cir({ v[i], r }).inter(v)));\n\n\t\tprintf(\"%.20f\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct point\n{\n\tdouble x,y;\n\tpoint() {}\n\tpoint(double a,double b) : x(a),y(b) {}\n\tfriend point operator + (const point &a,const point &b)\n\t{\n\t\treturn point(a.x+b.x,a.y+b.y);\n\t}\n\tfriend point operator - (const point &a,const point &b)\n\t{\n\t\treturn point(a.x-b.x,a.y-b.y);\n\t}\n\tfriend point operator * (const point &a,const double &b)\n\t{\n\t\treturn point(a.x*b,a.y*b);\n\t}\n\tfriend point operator * (const double &a,const point &b)\n\t{\n\t\treturn point(a*b.x,a*b.y);\n\t}\n\tfriend point operator / (const point &a,const double &b)\n\t{\n\t\treturn point(a.x/b,a.y/b);\n\t}\n};\npoint res[15],temp[15];\ndouble r;\nint n;\nint dcmp(double k)\n{\n\treturn k < -EPS ? -1 : k > EPS ? 1 : 0;\n}\ndouble dot(const point &a,const point &b)\n{\n\treturn a.x*b.x + a.y*b.y;\n}\ndouble cross(const point &a,const point &b)\n{\n\treturn a.x*b.y - a.y*b.x;\n}\ndouble abs(const point &o)\n{\n\treturn sqrt(dot(o,o));\n}\npoint crosspt(const point &a,const point &b,const point &p,const point &q)\n{\n\tdouble a1 = cross(b - a,p - a);\n\tdouble a2 = cross(b - a,q - a);\n\treturn (p*a2 - q*a1)/(a2 - a1);\n}\ndouble mysqrt(double n)\n{\n\treturn sqrt(max(0.0,n));\n}\ndouble sector_area(const point &a,const point &b)\n{\n\tdouble theta = atan2(a.y,a.x) - atan2(b.y,b.x);\n\twhile(theta <= 0) theta += 2*PI;\n\twhile(theta > 2*PI) theta -= 2*PI;\n\ttheta = min(theta,2*PI - theta);\n\treturn r * r * theta / 2;\n}\nvoid circle_cross_line(point a,point b,point o,double r,point ret[],int &num)\n{\n\tdouble x0 = o.x,y0 = o.y;\n\tdouble x1 = a.x,y1 = a.y;\n\tdouble x2 = b.x,y2 = b.y;\n\tdouble dx = x2 -x1,dy = y2 - y1;\n\tdouble A = dx*dx + dy*dy;\n\tdouble B = 2*dx*(x1 - x0) + 2*dy*(y1 - y0);\n\tdouble C = (x1 -x0)*(x1 - x0) + (y1 - y0)*(y1 - y0) - r*r;\n\tdouble delta = B*B - 4*A*C;\n\tnum = 0;\n\tif(dcmp(delta) >= 0)\n\t{\n\t\tdouble t1 = (-B - mysqrt(delta))/(2*A);\n\t\tdouble t2 = (-B + mysqrt(delta))/(2*A);\n\t\tif(dcmp(t1-1) <= 0 && dcmp(t1) >= 0)\n\t\t{\n\t\t\tret[num++] = point(x1 + t1*dx,y1 + t1*dy);\n\t\t}\n\t\tif(dcmp(t2-1) <= 0 && dcmp(t2) >= 0)\n\t\t{\n\t\t\tret[num++] = point(x1 + t2*dx,y1 + t2*dy);\n\t\t}\n\t}\n}\ndouble cacl(const point &a,const point &b)\n{\n\tpoint p[2];\n\tint num = 0;\n\tint ina = dcmp(abs(a) - r) < 0;\n\tint inb = dcmp(abs(b) - r) < 0;\n\tif(ina)\n\t{\n\t\tif(inb) return fabs(cross(a,b))/2.0;\n\t\telse \n\t\t{\n\t\t\tcircle_cross_line(a,b,point(0,0),r,p,num);\n\t\t\treturn sector_area(b,p[0]) + fabs(cross(a,p[0]))/2.0;\n\t\t}\n\t}\n\telse \n\t{\n\t\tif(inb)\n\t\t{\n\t\t\tcircle_cross_line(a,b,point(0,0),r,p,num);\n\t\t\treturn sector_area(p[0],a) + fabs(cross(p[0],b)) / 2.0;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tcircle_cross_line(a,b,point(0,0),r,p,num);\n\t\t\tif(num == 2)\n\t\t\t{\n\t\t\t\treturn sector_area(a,p[0]) + sector_area(p[1],b) + fabs(cross(p[0],p[1])) / 2.0;\n\t\t\t}\n\t\t\telse return sector_area(a,b);\n\t\t}\n\t}\t\n}\ndouble area()\n{\n\tdouble ret = 0;\n\tfor(int i = 0;i < n;i++)\n\t{\n\t\tint sgn = dcmp(cross(res[i],res[i+1]));\n\t\tif(sgn != 0) ret += sgn*cacl(res[i],res[i+1]);\n\t}\n\treturn ret;\n}\n\ndouble pol_area()\n{\n\tdouble tarea = 0;\n\tfor (int i = 1; i < n; i++)\n\t\ttarea += fabs(cross(temp[i] - temp[0], temp[i + 1] - temp[0]));\n\treturn tarea / 2;\n}\n\npoint MassCenter()\n{\n\tpoint ans = point(0,0);\n\tdouble tarea = pol_area();\n\tif (dcmp(tarea) == 0) return ans;\n\tfor (int i = 0; i < n; i++) ans = ans + (temp[i] + temp[i + 1]) * cross(temp[i], temp[i + 1]);\n\treturn ans / tarea / 6;\n}\n\ndouble get_ymin(double x)\n{\n\tdouble y = 500;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (dcmp((temp[i].x - x) * (temp[i + 1].x - x)) <= 0)\n\t\t{\n\t\t\tif (dcmp(temp[i].x - temp[i + 1].x) == 0) {\n\t\t\t\ty = min(y, min(temp[i].y, temp[i + 1].y));\n\t\t\t} else {\n\t\t\t\tdouble rat = (x - temp[i].x) / (temp[i + 1].x - temp[i].x);\n\t\t\t\ty = min(y, rat * (temp[i + 1].y - temp[i].y) + temp[i].y);\n\t\t\t}\n\t\t}\n\t}\n\treturn y;\n}\n\ndouble get_ymax(double x)\n{\n\tdouble y = -100;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (dcmp((temp[i].x - x) * (temp[i + 1].x - x)) <= 0)\n\t\t{\n\t\t\tif (dcmp(temp[i].x - temp[i + 1].x) == 0) {\n\t\t\t\ty = max(y, max(temp[i].y, temp[i + 1].y));\n\t\t\t} else {\n\t\t\t\tdouble rat = (x - temp[i].x) / (temp[i + 1].x - temp[i].x);\n\t\t\t\ty = max(y, rat * (temp[i + 1].y - temp[i].y) + temp[i].y);\n\t\t\t}\n\t\t}\n\t}\n\treturn y;\n}\ndouble check2(double x,double y)\n{\n\tfor (int i = 0; i <= n; i++)\n\t{\n\t\tres[i] = temp[i] - point(x, y);\n\t}\n\treturn area();\n}\n\ndouble check(double x)\n{\n\tdouble l2 = get_ymin(x),r2 = get_ymax(x);\n\twhile(abs(r2-l2) > EPS)\n\t{\n\t\tdouble mid1 = (2*l2+r2)/3,mid2 = (2*r2+l2)/3;\n\t\tif(check2(x,mid1) > check2(x,mid2)) r2 = mid2;\n\t\telse l2 = mid1;\n\t}\n\treturn check2(x,l2);\n}\nint main()\n{\n\tdouble Mi1 = 10000,Ma1 = -10000,Mi2 = 10000,Ma2 = -10000;\n\tcin.sync_with_stdio(false);\n\tcin>>n>>r;\n\tfor(int i = 1;i <= n;i++) \n\t{\n\t\tcin>>temp[i].x>>temp[i].y;\n\t\tMi1 = min(Mi1,temp[i].x);\n\t\tMa1 = max(Ma1,temp[i].x);\n\t\tMi2 = min(Mi2,temp[i].y);\n\t\tMa2 = max(Ma2,temp[i].y);\n\t}\n\ttemp[0] = temp[n];\n\tpoint center = MassCenter();\n\tfor (int i = 0; i <= n; i++)\n\t\tres[i] = temp[i] - center;\n/*\tdouble ans = area();\n\tcerr << center.x << ' ' << center.y << endl;\n\tprintf(\"%.8f\\n\", ans);*/\n\tdouble l1 = Mi1,r1 = Ma1;\n\twhile(abs(r1 - l1) > EPS)\n\t{\n\t\tdouble mid1 = (2*l1+r1)/3,mid2 = (2*r1+l1) / 3;\n\t\tif(check(mid1) > check(mid2)) r1 = mid2;\n\t\telse l1 = mid1;\n\t}\n\tprintf(\"%.8lf\\n\", check(l1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\n#define CVector CPoint\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1.0);\nconst double EPS=1e-7;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-7;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n    /*friend bool operator<(CPoint a,CPoint b){//?角排序\n        double tmp=cross(Pts[0],a,b);\n        if(isZero(tmp)){\n            return dist(Pts[0],a)<dist(Pts[0],b);\n        }\n        return tmp>0;\n    }*/\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n/*----------------------多?形相?--------------------------*/\n\n//0:outside 1:inside 2:online\nint PointInPoly(Point t,Point *Pts,int n){\n    int num=0,d1,d2,k;\n    Pts[n]=Pts[0];\n    for(int i=0;i<n;i++){\n        if(PointOnS(t,Line(Pts[i],Pts[i+1]))) return 2;\n        k=dcmp(cross(Pts[i],Pts[i+1],t));\n        d1=dcmp(Pts[i].y-t.y);\n        d2=dcmp(Pts[i+1].y-t.y);\n        if(k>0&&d1<=0&&d2>0) num++;\n        if(k<0&&d2<=0&&d1>0) num--;\n    }\n    return num!=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n//求任意多?形周?，需逆??或???排列\ndouble PolyPerimeter(Point *Pts,int n){\n    double pp=distPP(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pp+=distPP(Pts[i],Pts[i+1]);\n    return pp;\n}\n\n//求多?形重心坐?\nPoint PolyCore(Point *Pts,int n){\n    double pa=PolyArea(Pts,n);\n    if(!dcmp(pa)) return Point(0,0);\n    Point ans=(Pts[n-1]+Pts[0])*cross(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) ans=ans+(Pts[i]+Pts[i+1])*cross(Pts[i],Pts[i+1]);\n    return ans/pa/6;\n}\n\n/*----------------------凸包----------------------------*/\n\n//Graham-scan st:anticlockwise\n//<=:strict <:Non-strict\nint Graham(Point *Pts,Point *st,int n){\n    if(n<3) return 0;\n    sort(Pts,Pts+n);\n    int m=0;\n    for(int i=0;i<n;i++){\n        while(m>1&&dcmp(cross(st[m-2],st[m-1],Pts[i]))<0) m--;\n        st[m++]=Pts[i];\n    }\n    int k=m;\n    for(int i=n-2;i>=0;i--){\n        while(m>k&&dcmp(cross(st[m-2],st[m-1],Pts[i])<0)) m--;\n        st[m++]=Pts[i];\n    }\n    return m-1;\n}\n\n//clockwise:> anticlockwise:<\ndouble CHDiameter(Point *Pts,int n,Line &l){\n    double maxd=0.0;\n    if(n<=1){\n        l.a=l.b=Pts[0];\n        return maxd;\n    }\n    for(int i=0,j=1;i<n;i++){\n        while(cross(Pts[i],Pts[(i+1)%n],Pts[j])\n              >cross(Pts[i],Pts[(i+1)%n],Pts[(j+1)%n])){\n            j=(j+1)%n;\n        }\n        double d=distPP(Pts[i],Pts[j]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n        d=distPP(Pts[(i+1)%n],Pts[(j+1)%n]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n    }\n    return maxd;\n}\n\n/*---------------------整点多?形---------------------------*/\n\nint gcd(int a,int b){\n    return b==0?a :gcd(b,a%b);\n}\n\n//整点多?形?界整点数\nint Border_Int_Point_Num(Point *Pts,int n){\n    int num=gcd(abs(int(Pts[0].x-Pts[n-1].x)),abs(int(Pts[0].y-Pts[n-1].y)));;\n    for(int i=0;i<n-1;i++){\n        num+=gcd(abs(int(Pts[i+1].x-Pts[i].x)),abs(int(Pts[i+1].y-Pts[i].y)));\n    }\n    return num;\n}\n\n//整点多?形内部整点数\nint Inside_Int_Point_Num(Point *Pts,int n){\n    return abs(int(PolyArea(Pts,n)))+1-Border_Int_Point_Num(Pts,n)/2;\n}\n\n/*-----------------------------半平面交-------------------------------*/\n\n//有方向的直?\n//p->p+v\nstruct Vector{\n    Point p,v;\n    double ang;\n    Vector(Point p,Point v):p(p),v(v){\n        ang=atan2(v.y,v.x);\n    }\n    Vector(){}\n    bool operator<(const Vector &l) const{\n        return ang<l.ang;\n    }\n};\n\n//判断点p是否在直?L左?\nbool onLeft(Vector L,Point p){\n    return cross(L.v,p-L.p)>0;\n}\n\n//得到a与b?直?的交点\nPoint getCrossVV(Vector a,Vector b){\n    Point u=a.p-b.p;\n    double t=cross(b.v,u)/cross(a.v,b.v);\n    return a.p+a.v*t;\n}\n\n//所有直?左半平面的交\nint HPCross(Vector *L,int n,Point *poly){\n    sort(L,L+n);\n    int f=0,l=0;\n    Point *p=new Point[n];\n    Vector *q=new Vector[n];\n    q[0]=L[0];\n    for(int i=1;i<n;i++){\n        while(f<l&&!onLeft(L[i],p[l-1])) l--;\n        while(f<l&&!onLeft(L[i],p[f])) f++;\n        q[++l]=L[i];\n        if(!dcmp(cross(q[l].v,q[l-1].v))){\n            l--;\n            if(onLeft(q[l],L[i].p)) q[l]=L[i];\n        }\n        if(f<l) p[l-1]=getCrossVV(q[l-1],q[l]);\n    }\n    while(f<l&&!onLeft(q[f],p[l-1])) l--;\n    if(l-f<=1) return 0;\n    p[l]=getCrossVV(q[l],q[f]);\n    int m=0;\n    for(int i=f;i<=l;i++) poly[m++]=p[i];\n    return m;\n}\n\n#define maxn 100005\nVector l[maxn];\nbool retract(Vector *L,int n,double r,Point *poly){\n    for(int i=0;i<n;i++){\n        Point v=rotateV(L[i].p,L[i].p+L[i].v,PI/2);\n        l[i]=Vector(L[i].p+r*v,L[i].v);\n    }\n    int cnt=HPCross(l,n,poly);\n    return cnt;\n}\n\n/*---------------------三角形相?---------------------------*/\n\n//三角形重心\n//到三?点距?的平方和最小的点\n//到三?距?之?最大的点\nPoint TCore(Point a,Point b,Point c){\n    return (a+b+c)/3;\n}\n\n//三角形外心\nPoint TCircum(Point a,Point b,Point c){\n    Point cp;\n    double a1=b.x-a.x;\n    double b1=b.y-a.y;\n    double a2=c.x-a.x;\n    double b2=c.y-a.y;\n    double c1=(a1*a1+b1*b1)/2;\n    double c2=(a2*a2+b2*b2)/2;\n    double d=a1*b2-a2*b1;\n    cp.x=a.x+(c1*b2-c2*b1)/d;\n    cp.y=a.y+(a1*c2-a2*c1)/d;\n    return cp;\n}\n\n//三角形垂心\nPoint TOrtho(Point a,Point b,Point c){\n    return TCore(a,b,c)*3.0-TCircum(a,b,c)*2.0;\n}\n\n//三角形内心\nPoint TInner(Point a,Point b,Point c){\n    Point cp;\n    double la=distPP(b,c),lb=distPP(c,a),lc=distPP(a,b);\n    cp.x=(la*a.x+lb*b.x+lc*c.x)/(la+lb+lc);\n    cp.y=(la*a.y+lb*b.y+lc*c.y)/(la+lb+lc);\n    return cp;\n}\n\n//求三角形面?\ndouble TArea(Point a,Point b,Point c){\n    return fabs(cross(a,b,c))/2;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n//求??面?交\ndouble getAreaCC(Circle a,Circle b){\n    double d=(a.o.x-b.o.x)*(a.o.x-b.o.x)+(a.o.y-b.o.y)*(a.o.y-b.o.y);\n    if(d<=(a.r-b.r)*(a.r-b.r)){\n        return min(a.r,b.r)*min(a.r,b.r)*PI;\n    }else if(d>(a.r-b.r)*(a.r-b.r)&&d<(a.r+b.r)*(a.r+b.r)){\n        double m1=(a.r*a.r+d-b.r*b.r)/(2*a.r*sqrt(d));\n        double m2=(b.r*b.r+d-a.r*a.r)/(2*b.r*sqrt(d));\n        double s1=acos(m1)*a.r*a.r;\n        double s2=acos(m2)*b.r*b.r;\n        double s3=sqrt(d)*a.r*sin(acos(m1));\n        return s1+s2-s3;\n    }\n    return 0.0;\n}\n\n//求??交点，先判断是否有交点\nPoint rotatePCS(Point p,double c,double s){\n    return Point(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\npair<Point,Point> getcrossCC(Circle a,Circle b){\n    double d=length(a.o-b.o);\n    double cost=(a.r*a.r+d*d-b.r*b.r)/(2*a.r*d);\n    double sint=sqrt(1.0-cost*cost);\n    Point v=(b.o-a.o)/d*a.r;\n    return make_pair(a.o+rotatePCS(v,cost,-sint),a.o+rotatePCS(v,cost,sint));\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n/********************************************************/\nint getCrossCS(Circle c,Line s,Point *cs){\n    Point tmp[2];\n    int cnt=0;\n    int ct=getCrossCL(c,s,tmp);\n    for(int i=0;i<ct;i++){\n        if(PointOnS(tmp[i],s)) cs[cnt++]=tmp[i];\n    }\n    return cnt;\n}\n\ndouble SectorArea(Point a,Point b,Circle c){\n    a=a-c.o,b=b-c.o;\n    double theta=atan2(a.y,a.x)-atan2(b.y,b.x);\n    while(dcmp(theta)<=0) theta+=2.0*PI;\n    while(dcmp(theta-2.0*PI)>0) theta-=2.0*PI;\n    theta=min(theta,2.0*PI-theta);\n    return c.r*c.r*theta*0.5;\n}\n\ndouble Abs(double x){\n    if(!dcmp(x)) return 0;\n    return dcmp(x)<0?-x:x;\n}\n\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=0.0;\n    Point OA=a-c.o,OB=b-c.o;\n    double la=length(OA),lb=length(OB);\n    Point cs[4];\n    bool aic=dcmp(la-c.r)<0,bic=dcmp(lb-c.r)<0;\n    int s=dcmp(cross(OA,OB));\n    if(!s) return 0.0;\n    if(aic){\n        if(bic){\n            atc=Abs(cross(OA,OB))*0.5;\n        }else{\n            int num=getCrossCS(c,Line(a,b),cs);\n            atc=SectorArea(cs[0],b,c)+Abs(cross(OA,cs[0]-c.o))*0.5;\n        }\n    }else{\n        if(bic){\n            int num=getCrossCS(c,Line(a,b),cs);\n            atc=SectorArea(cs[0],a,c)+Abs(cross(OB,cs[0]-c.o))*0.5;\n        }else{\n            int num=getCrossCS(c,Line(a,b),cs);\n            if(num==2){\n                if(distPP(a,cs[0])>distPP(a,cs[1])) swap(cs[0],cs[1]);\n                atc=SectorArea(a,cs[0],c)+SectorArea(b,cs[1],c)+Abs(cross(cs[0]-c.o,cs[1]-c.o))*0.5;\n            }else{\n                atc=SectorArea(a,b,c);\n            }\n        }\n    }\n    return 1.0*s*atc;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=getAreaTC(Pts[n-1],Pts[0],c);\n    for(int i=0;i<n-1;i++) apc+=getAreaTC(Pts[i],Pts[i+1],c);\n    return fabs(apc);\n}\n\n/********************************************************/\n\n\n/*----------------------三?点、?基本函数-----------------------------*/\n\nstruct Point3{\n    double x,y,z;\n    Point3(double x,double y,double z):x(x),y(y),z(z){}\n    Point3(){}\n    void Read(){ scanf(\"%lf%lf%lf\",&x,&y,&z); }\n};\n\nstruct Line3{\n    Point3 a,b;\n    Line3(Point3 a,Point3 b):a(a),b(b){}\n    Line3(){}\n    void Read(){ a.Read(); b.Read(); }\n};\nPoint3 operator +(Point3 a,Point3 b){ return Point3(a.x+b.x,a.y+b.y,a.z+b.z); }\nPoint3 operator -(Point3 a,Point3 b){ return Point3(a.x-b.x,a.y-b.y,a.z-b.z); }\ndouble operator *(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 operator *(Point3 a,double k){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator *(double k,Point3 a){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator /(Point3 a,double k){ return Point3(a.x/k,a.y/k,a.z/k); }\n\ndouble length(Point3 a){ return sqrt(a.x*a.x+a.y*a.y+a.z*a.z); }\nPoint3 unit(Point3 a){ return a/length(a); }\ndouble dot(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 cross(Point3 a,Point3 b){\n    return Point3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//混合?\ndouble Mix(Point3 a,Point3 b,Point3 c){\n    return dot(a,cross(b,c));\n}\n\n//?点距?\ndouble dist(const Point3 &a,const Point3 &b){ return length(a-b); }\n\n/*---------------------------------体?-------------------------------------*/\n\n//四面体体?\ndouble volume(double l,double n,double a,double m,double b,double c){\n    double x,y;\n    x=4*a*a*b*b*c*c-a*a*(b*b+c*c-m*m)*(b*b+c*c-m*m)-b*b*(c*c+a*a-n*n)*(c*c+a*a-n*n);\n    y=c*c*(a*a+b*b-l*l)*(a*a+b*b-l*l)-(a*a+b*b-l*l)*(b*b+c*c-m*m)*(c*c+a*a-n*n);\n    return sqrt(x-y)/12;\n}\n\ndouble volume(Point3 a,Point3 b,Point3 c,Point3 d){\n    return fabs(Mix(b-a,c-a,d-a)/6);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);cin.tie(0);\n    //cout<<getAreaTC(Point(3,3),Point(-3,3),Circle(Point(0,0),4))<<endl;\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "//writted by dnvtmf\n#include <bits/stdc++.h>\n#define INF 1000000007\n#define FI first\n#define SE second\n#define PB push_back\n#define VI vector<int>\n#define MP make_pair\n#define FOR(x, st, ed) for(auto x = (st); x < (ed); ++x)\n#define FORE(x, st, ed) for(auto x = (st); x <= (ed); ++x)\n#define CLR(arr, val) memset(arr, val, sizeof(arr))\n#define INFO(tag, st, ed, x) printf(\"%s: \", tag); \\\n  FOR(_i, st, ed) cout << x[_i] << ' '; puts(\"\");\nusing namespace std;\ntypedef long long LL;\ntypedef pair <int, int> PII;\nconst int NUM = 100010;\n\nconst double pi = acos(-1);\nconst double EPS = 1e-10;\ninline int sgn(double x) {\n    if (x < -EPS)return -1;\n    return x > EPS ? 1 : 0;\n}\ninline double sqr(double x) {\n    return x * x;\n}\nstruct Point {\n    double x,y;\n    Point(double _x = 0.0,double _y = 0.0): x(_x),y(_y) {}\n    Point operator + (const Point &b) const {\n        return Point(x + b.x,y + b.y);\n    }\n    Point operator - (const Point &b) const {\n        return Point(x - b.x,y - b.y);\n    }\n    double operator * (const Point &b) const { //点乘\n        return (x * b.x + y * b.y);\n    }\n    double operator ^ (const Point &b) const { //叉乘，判断b点的相?于?点位置?系 左正右?\n        return (x * b.y - y * b.x);\n    }\n    Point operator * (double b) {\n        return Point(x * b,y * b);\n    }\n    bool operator < (const Point &b) const { //水平序比?\n        if(sgn(x - b.x) == 0) return sgn(y - b.y) <= 0;\n        else return sgn(x - b.x) < 0;\n    }\n    Point rot(double ang) { //旋?，?入角度\n        return Point(x * cos(ang) - y * sin(ang),x * sin(ang) + y * cos(ang));\n    }\n    Point rot(double g1,double g2) { //旋?，?入正弦?，余弦?\n        return Point(x * g2 - y * g1,x * g1 + y * g2);\n    }\n    double norm() { //求模\n        return sqrt(x * x + y * y);\n    }\n    Point unit() { //取?位向量\n        double ll = norm();\n        return Point(x / ll,y / ll);\n    }\n};\n\n//三角形ABO与?(O, r)的面?交\ndouble Triangel_cross_Circle(Point A, Point B, Point O, double r) {\n    double a,b,c,x,y,s = 0.5 * ((A - O) ^ (B - O));\n    a = (B - O).norm();\n    b = (A - O).norm();\n    c = (A - B).norm();\n    if(a <= r && b <= r) return s;\n    else if(a < r && b >= r) {\n        x = ((A - B) * (O - B) + sqrt(c * c * r * r - sqr((A - B) ^ (O - B)))) / c;\n        return asin(s * (c - x) * 2.0 / c / b / r) * r * r * 0.5 +s * x / c;\n    } else if(a >= r && b < r) {\n        y = ((B - A) * (O - A) + sqrt(c * c * r * r - sqr((B - A) ^ (O - A)))) / c;\n        return asin(s * (c - y) * 2.0 / c / a / r) * r * r * 0.5 +s * y / c;\n    } else {\n        if(fabs(2.0 * s) >= r * c || (B - A) * (O - A) <= 0 || (A - B) * (O - B) <= 0) {\n            if((A - O) * (B - O) < 0) {\n                if(((A - O) ^ (B - O)) < 0) return (-pi - asin(s * 2.0 / a / b)) * r * r * 0.5;\n                else return (pi - asin(s *2.0 / a / b)) * r * r * 0.5;\n            } else return asin(s * 2 / a / b) * r * r * 0.5;\n        } else {\n            x = ((A - B) * (O - B) + sqrt(c * c * r * r - sqr((A - B) ^ (O - B)))) / c;\n            y = ((B - A) * (O - A) + sqrt(c * c * r * r - sqr((B - A) ^ (O - A)))) / c;\n            return (asin(s * (1 - x / c) * 2 / r / b) + asin(s * (1 - y / c) * 2 / r / a)) * r * r * 0.5 + s * ((y + x) / c - 1);\n        }\n    }\n}\n\n//多?形与?的面?交\ndouble Polygon_intersect_Circle(Point ploy[], int n, Point O, double r) {\n    ploy[n] = ploy[0];\n    double res = 0.0;\n    for (int i = 0; i < n; ++i)\n        res += Triangel_cross_Circle(ploy[i], ploy[i + 1], O, r);\n    return fabs(res);\n}\n\nint n, r;\nPoint ploy[20];\ndouble ymin,ymax,ans = 0.0;\n\ndouble check(double x) {\n    double yl = ymin,yr = ymax,ym1,ym2;\n    double ss = 0.0;\n    for(int i = 0;i < 100; i++){\n        ym1 = yl / 3 * 2 + yr / 3;\n        ym2 = yl / 3 + yr / 3 * 2;\n        double s1 = Polygon_intersect_Circle(ploy,n,Point(x,ym1),r);\n        double s2 = Polygon_intersect_Circle(ploy,n,Point(x,ym2),r);\n        ss = max(ss,s1);\n        ss = max(ss,s2);\n        if(s1 > s2) yr = ym2;\n        else yl = ym1;\n    }\n    ans = max(ans,ss);\n    return ss;\n}\n\nint main() {\n    scanf(\"%d%d\", &n, &r);\n    double xl,xr,xm1,xm2;\n    ymin = xl = 1111.0;\n    ymax = xr = -100.0;\n    for (int i = 0,x,y; i < n; ++i) {\n        scanf(\"%d%d\", &x, &y);\n        xl = min(xl,1.0 * x);\n        xr = max(xr,1.0 * x);\n        ymin = min(ymin,1.0 * y);\n        ymax = max(ymax,1.0 * y);\n        ploy[i] = Point(x, y);\n    }\n    for(int i = 0; i < 100; i++) {\n        xm1 = xr / 3 + xl / 3 * 2;\n        xm2 = xr / 3 * 2 + xl / 3;\n        double s1 = check(xm1);\n        double s2 = check(xm2);\n        if(s1 > s2) xr = xm2;\n        else xl = xm1;\n    }\n    printf(\"%.8f\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1000\n#define linf 1e18\n#define eps (1e-10)\n#define mod 1000000007\n#define pi M_PI\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nclass Circle{\npublic:\n  Point c;\n  double r;\n  Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n  double getArea(){ return r*r*pi;}\n};\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool in(Point p,Circle c){ return abs(p-c.c)-c.r<-eps;}\nbool on(Point p,Circle c){ return fabs(abs(p-c.c)-c.r)<eps;}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\ndouble getArea(Polygon p){\n  double res=0;\n  for(int i=1;i<p.size()-1;i++)res+=cross(p[i]-p[0],p[i+1]-p[0])/2.0;\n  return res;\n}\n\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nbool iscrossLC(Line l,Circle c){\n  if((getDistanceLP(l,c.c)-c.r)<-eps)return true;\n  return false;\n}\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return mp(pr+e*base,pr-e*base);\n}\n\nvector<Point> getCrossPointSC(Circle c,Segment s){\n  vector<Point> res;\n  if(!iscrossLC(s,c))return res;\n  pair<Point,Point> pp=getCrossPoints(c,s);\n  if(abs(pp.s-s.p1)-abs(pp.f-s.p1)<eps)swap(pp.f,pp.s);\n  if(ccw(s.p1,s.p2,pp.f)==0)res.push_back(pp.f);\n  if(ccw(s.p1,s.p2,pp.s)==0)res.push_back(pp.s);\n  return res;\n}\n\nbool AllIn(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceLP(L,c.c)-c.r<-eps || ccw(L.p1,L.p2,c.c)==-1)return false;\n  }\n  return true;\n}\n\nbool AllOut(Polygon p,Circle c){\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    Line L(p[i],p[(i+1)%n]);\n    if(getDistanceSP(L,c.c)-c.r<-eps)return false;\n  }\n  return true;\n}\n\ndouble getAngle(Vector a,Vector b){\n  double tmp=dot(a,b)/(abs(a)*abs(b));\n  if(tmp<-1.0)tmp=-1.0;\n  if(1.0<tmp)tmp=1.0;\n  double r=acos(tmp)*180.0/pi;\n  if(cross(a,b)<-eps)r=360.0-r;\n  return r;\n}\n\ndouble getCommonAreaTC(Polygon p,Circle c){\n  double res=getArea(p),carea=c.getArea();\n  int n=p.size();\n  /*\n  bool flag=false;\n  if(res<0.0){\n    flag=true;\n    reverse(p.begin(),p.end());\n    res=getArea(p);\n  }*/\n  vector<Point> s;\n  if(AllIn(p,c))return carea;\n  if(AllOut(p,c)) return 0.0;\n  int start=-1;\n  for(int i=0;i<n;i++){\n    if((c.r-abs(p[i]-c.c))<-eps)start=i;\n  }\n  if(start==-1)return res;\n  for(int i=0;i<n;i++){\n    vector<Point> vp=getCrossPointSC(c,Segment(p[(i+start)%n],\n\t\t\t\t\t       p[(i+1+start)%n]));    \n    for(int j=0;j<vp.size();j++){\n      bool b=true;\n      for(int k=0;k<s.size();k++)if(s[k]==vp[j])b=false;\n      if(b)s.push_back(vp[j]);\n    }\n  }\n\n  s.push_back(s[0]);\n  s.erase(s.begin());\n\n  for(int i=0;i<s.size();i+=2){\n    Point p1=s[i];\n    Point p2=s[i+1];\n    if(p1==p2)continue;\n    Polygon t;\n    t.push_back(p1);\n    t.push_back(p2);\n    t.push_back(c.c);\n    double narea= getArea(convex_cut(p,Line(p2,p1)));\n    if(narea<eps)continue;\n    res-=narea;\n    double ra=getAngle(p1-c.c,p2-c.c);\n    res+=((carea*ra/360.0)-getArea(t));\n  }\n  //if(!flag)return res;\n  return res;\n}\n\ndouble getCommonAreaPC(Polygon p,Circle c){\n  double res=0.0;\n  for(int i=1;i<p.size()-1;i++){\n    Polygon t;\n    t.push_back(p[0]);\n    t.push_back(p[i]);\n    t.push_back(p[i+1]);\n    res+=getCommonAreaTC(t,c);\n  }\n  return res;\n}\n\nint n,r;\nPolygon p;\nPoint g(0,0);\n\ndouble check(Point a){\n  Vector v=(g-a);\n  v=v/abs(v);\n  double R=0.0,L=inf;\n  FOR(k,0,60){\n    double m1=(L*2.0+R)/3.0;\n    double m2=(L+R*2.0)/3.0;\n    double res1=getCommonAreaPC(p,Circle(a+v*m1,r));\n    double res2=getCommonAreaPC(p,Circle(a+v*m2,r));\n    if(res1>res2)R=m2; \n    else L=m1;\n  }\n  return getCommonAreaPC(p,Circle(a+v*L,r));\n}\n\nint main()\n{\n  cin>>n>>r;\n  FOR(i,0,n){\n    int x,y;\n    cin>>x>>y;\n    p.pb(Point(x,y));\n  }\n  FOR(i,0,n)g=g+p[i];\n  g=g/n;\n  double ans=0.0;\n  FOR(i,0,n){\n    Point a=p[i],b=p[(i+1)%n];\n    Vector v=b-a;\n    v=v/abs(v);\n    double R=0.0,L=inf;\n    FOR(k,0,60){\n      double m1=(L*2.0+R)/3.0;\n      double m2=(L+R*2.0)/3.0;\n      double res1=check(a+v*m1);\n      double res2=check(a+v*m2);\n      if(res1>res2)R=m2; \n      else L=m1;\n    }\n    ans=max(ans,check(a+v*L));\n  }\n  pd(ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-9)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n\nPoint calc_ps(Polygon poly) {\n  poly = andrewScan(poly);\n  Point mp = poly[0];\n  double rate = 1; // 0.5???????????¨???\n  int max_pos;\n  double eps = 1e-10; // 1e-20???????????¨???\n  while( rate > eps ) {\n    rep(_,60){ // 70???????????¨???\n      max_pos = 0;\n      REP(j,1,(int)poly.size()) {\n        double dist1 = abs(mp-poly[max_pos]);\n        double dist2 = abs(mp-poly[j]);\n\tif( LT(dist1,dist2) ) max_pos = j;\n      }\n      mp.x += ( poly[max_pos].x - mp.x ) * rate;\n      mp.y += ( poly[max_pos].y - mp.y ) * rate;\n    }\n    rate *= 0.5;\n  }\n  return mp;\n}\n\nPoint getCentroidOfConvex(Polygon& poly){\n  double area = getArea(poly);\n  int V = poly.size();\n  assert( !equals(area,0.0) );\n  double x = 0, y = 0;\n  rep(i,(int)poly.size()) {\n    x += ( poly[i].x + poly[(i+1)%V].x ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n    y += ( poly[i].y + poly[(i+1)%V].y ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n  }\n  return Point(x/(6.0*area),y/(6.0*area));\n}\n\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  double maxi;\n  Point mp = calc_ps(poly);\n  maxi = getCommonAreaPolygonCircle(poly,mp,r);\n  double rate = 1.0;\n  double eps = 1e-10;\n  while( LT(eps,rate) ) {\n    rep(_,70) {\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      assert( !equals(max_area,-1) );\n      mp = np;\n      if( LT(maxi,max_area) ) maxi = max_area;\n    }\n    rate *= 0.5;\n  }\n  rep(__,3) {\n    Point mp = calc_ps(poly);\n    double rate = 1.0;\n    double eps = 1e-10;\n    while( LT(eps,rate) ) {\n      rep(_,70) {\n\tdouble max_area = -1; \n\tPoint np;\n\trep(i,n) {\n\t  Point tp = mp;\n\t  tp.x += ( poly[i].x - mp.x ) * rate;\n\t  tp.y += ( poly[i].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,tp,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t    np = tp;\n\t  }\n\t}\n\tif( rand() % 50 == 0 ) {\n\t  int v = rand() % n;\n\t  np.x = ( poly[v].x - mp.x ) * rate;\n\t  np.y = ( poly[v].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,np,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t  }\n\t}\n\tassert( !equals(max_area,-1) );\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      rate *= 0.5;\n    }\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  srand((unsigned int)time(NULL));\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  //cout << getArea(poly) << endl;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint ans[10][19],sw,k,s,sx,x,y;\nint main(){\n    int T;scanf(\"%d\",&T);\n    while(T--){\n        int n,m;\n        scanf(\"%d%d\",&n,&m);\n        if (n<=5e4){\n            cout<<3<<endl;\n            cout<<0<<\" \"<<0<<endl;\n            cout<<0<<\" \"<<1<<endl;\n            cout<<n<<\" \"<<m<<endl;\n            continue;\n        }\n        if (m<=5e4){\n             cout<<3<<endl;\n            cout<<0<<\" \"<<0<<endl;\n            cout<<1<<\" \"<<0<<endl;\n            cout<<n<<\" \"<<m<<endl;\n            continue;\n        }\n        x=n;y=m;\n        int sw=0;\n        if (x>y) swap(x,y),sw=1;\n        k=(y+5)/x;\n        k++;\n        //cout<<<<endl;1\n        s=x/(k+1);\n        sx=1;\n    //    sy=sx*k;\n        ans[1][0]=0;ans[1][1]=0;\n        ans[2][0]=n;ans[2][1]=m;\n        ans[3][0]=1+s-1;ans[3][1]=k*(s-1);\n        ans[4][0]=1+s;ans[4][1]=k*s;\n        cout<<ans[1][0^sw]<<\" \"<<ans[1][1^sw]<<endl;\n        cout<<ans[3][0^sw]<<\" \"<<ans[3][1^sw]<<endl;\n        cout<<ans[2][0^sw]<<\" \"<<ans[2][1^sw]<<endl;\n        cout<<ans[4][0^sw]<<\" \"<<ans[4][1^sw]<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <ctime>\nusing namespace std;\n\nconst double eps = 1e-12,PI = acos(-1);\n\nstruct point {\n\tdouble x, y;\n\tpoint(){}\n\tpoint(double xx, double yy) {\n\t\tx = xx,y = yy;\n\t}\n\tpoint operator -(const point &n2) const {\n\t\treturn point(x-n2.x, y-n2.y);\n\t}\n\tpoint operator +(const point &n2) const {\n\t\treturn point(x+n2.x, y+n2.y);\n\t}\n\tpoint operator *(const double n) const {\n\t\treturn point(x*n, y*n);\n\t}\n\tpoint operator /(const double n) const {\n\t\treturn point(x/n, y/n);\n\t}\n\tvoid output() {\n\t\tprintf(\"%0.10lf %0.10lf\\n\", x,y);\n\t//\tcout << x << ' ' << y << endl;\n\t}\n};\ndouble myrand(double l, double r)\n{\n\treturn l+(abs(rand()*rand())%1000000)/1000000.0*(r-l);\n}\n\ninline double sqr(double x) {\n\treturn x*x;\n}\nint dcmp(double k) {\n\treturn k<-eps? -1:(k>eps? 1:0);\n}\ndouble dot(const point &a, const point &b) {\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble cross(const point &a, const point &b)\n{\n\treturn a.x*b.y-a.y*b.x;\n};\ndouble abs(const point &o) {\n\treturn sqrt(dot(o,o));\n}\npoint crosspt(const point &a, const point &b, const point &p, const point &q)\n{\n\tdouble a1 = cross(b-a,p-a);\n\tdouble a2 = cross(b-a,q-a);\n\treturn (p*a2-q*a1)/(a2-a1);\n}\ndouble mysqrt(double n) {\n\treturn sqrt(max(.0,n));\n}\n\npoint a[15],res[15];\ndouble r;\nint n;\n\nvoid circle_cross_line(point a, point b, point o, double r, point ret[], int &num)\n{\n\tdouble x00 = o.x, y00 = o.y;\n\tdouble x11 = a.x, y11 = a.y;\n\tdouble x2 = b.x, y2 = b.y;\n\tdouble dx = x2-x11, dy = y2-y11;\n\tdouble A = dx*dx+dy*dy;\n\tdouble B = 2*dx*(x11-x00)+2*dy*(y11-y00);\n\tdouble C = sqr(x11-x00)+sqr(y11-y00)-sqr(r);\n\tdouble delta = B*B-4*A*C;\n\tnum = 0;\n\tif(dcmp(delta)>=0) {\n\t\tdouble t1 = (-B-mysqrt(delta))/(2*A);\n\t\tdouble t2 = (-B+mysqrt(delta))/(2*A);\n\t\tif(dcmp(t1-1)<=0 && dcmp(t1)>=0)\n\t\t\tret[num++] = point(x11+t1*dx, y11+t1*dy);\n\t\tif(dcmp(t2-1)<=0 && dcmp(t2)>=0)\n\t\t\tret[num++] = point(x11+t2*dx, y11+t2*dy);\n\t}\n}\n\ndouble sector_area(const point &a, const point &b)\n{\n\tdouble theta = atan2(a.y,a.x)-atan2(b.y,b.x);\n\twhile(theta<=0) theta += 2*PI;\n\twhile(theta>2*PI) theta -= 2*PI;\n\ttheta = min(theta, 2*PI-theta);\n\treturn r*r*theta/2;\n}\ndouble calc(const point &a, const point &b)\n{\n\tpoint p[2];\n\tint num = 0;\n\tint ina = dcmp(abs(a)-r)<0;\n\tint inb = dcmp(abs(b)-r)<0;\n\tif(ina) {\n\t\tif(inb) {\n\t\t\treturn fabs(cross(a,b))/2;\n\t\t}\n\t\telse {\n\t\t\tcircle_cross_line(a,b,point(0,0),r,p,num);\n\t\t\treturn sector_area(b,p[0])+fabs(cross(a,p[0]))/2;\n\t\t}\n\t}\n\telse {\n\t\tif(inb) {\n\t\t\tcircle_cross_line(a,b,point(0,0),r,p,num);\n\t\t\treturn sector_area(p[0],a)+fabs(cross(p[0],b))/2;\n\t\t}\n\t\telse {\n\t\t\tcircle_cross_line(a,b,point(0,0),r,p,num);\n\t\t\tif(num==2) {\n\t\t\t\treturn sector_area(a,p[0])+sector_area(p[1],b)+fabs(cross(p[0],p[1]))/2;\n\t\t\t}\n\t\t\telse return sector_area(a,b);\n\t\t}\n\t}\n}\ndouble area() {\n\tdouble ret = 0;\n\tfor(int i = 0; i<n; i++)\n\t{\n\t\tint sgn = dcmp(cross(res[i], res[i+1]));\n\t\tif(sgn) {\n\t\t\tret += sgn*calc(res[i],res[i+1]);\n\t\t}\n\t}\n\treturn ret;\n}\n\nconst int M = 1000;\npoint now;\n\nint main()\n{\n\tsrand(time(0));\n\tint i,j;\n\tdouble minx = 100, maxx = 0, miny = 100, maxy = 0;\n\tcin >> n >> r;\n\tfor(i = 0; i<n; i++)\n\t{\n\t\tcin >> a[i].x >> a[i].y;\n\t\tminx = min(minx, a[i].x);\n\t\tmaxx = max(maxx, a[i].x);\n\t\tminy = min(miny, a[i].y);\n\t\tmaxy = max(maxy, a[i].y);\n\t}\n\ta[n] = a[0];\n\t\n\t\n\tdouble ans = 0,nowa;\n\tpoint mem;\n\tmem.x = -1;\n\tfor(i = 1; i<=M; i++)\n\t{\n\t\t \n\t//\tnow.x = 98.0014855956;\n\t//\tnow.y = 0.9455149817;\n\t\tnow.x = myrand(minx, maxx);\n\t\tnow.y = myrand(miny, maxy);\n\t\tif(rand()%2==0 && mem.x!=-1)\n\t\t\tnow = mem;\n\t\tfor(j = 0; j<=n; j++)\n\t\t\tres[j] = a[j]-now;\n\t\t\n\t\tnowa = area();\n//\t\tcout << nowa << endl;\n\t\t\n//\t\tbreak;\n\t\tif(nowa<eps) {\n\t\t\ti--; continue;\n\t\t}\n\t\n\t//\tnow.output();\n\t//\tcout << nowa << endl;\n\t\tdouble t;\n\t\tdouble pre = -1;\n\t\tfor(t = 1; t>1e-12; t *= 0.97)\n\t\t{\n\t\t\t\n\t\t\tdouble theta;\n\t\t//\tif(rand()%5 || pre==-1)\n\t\t\t\ttheta = myrand(0,2*PI);\n\t\t//\telse \n\t\t//\t\ttheta = pre;\n\t\t\t\n\t\t\tpoint ne = now+point(cos(theta), sin(theta))*t;\n\t\t//\tne.output();\n\t\t\tfor(j = 0; j<=n; j++)\n\t\t\t\tres[j] = a[j]-ne;\n\t\t\tdouble nea = area();\n\t\t\tif(nea>=nowa/* || myrand(0,1)<0.1*/) {\n\t\t\t\tnowa = nea;\n\t\t\t\tnow = ne;\n\t\t\t\tpre = theta;\n\t\t\t}\n\t\t\tif(ans<nowa) {\n\t\t\t\tans = nowa; mem = now;\n\t\t\t}\n\t\t}\n\t//\tcout << nowa << endl;\n\t//\tnow.output();\n\t}\n//\tmem.output();\n\tprintf(\"%0.6lf\\n\", ans);\n\t\n//\tcout << ans << endl;\n//\tcout << area() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <iomanip>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\nstruct L{P a, b;};\ntypedef vector<P> Pol;\nstruct C{P c; D r;};\n\nconst D EPS = 1e-10;\nconst D PI = acos(-1);\n\ninline int sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\n\ninline bool near(const P& a, const P& b) {return !sig(norm(a - b));}\n\nnamespace std {\n  inline bool operator<(const P& a, const P& b) {return sig(a.X, b.X) ? a.X < b.X : a.Y < b.Y;}\n}\n\ninline D sr(D a) {return sqrt(max(a, (D)0));}\n\ninline D dot(const P& a, const P& b) {return a.X * b.X + a.Y * b.Y;}\ninline D det(const P& a, const P& b) {return a.X * b.Y - a.Y * b.X;}\n\ninline P vec(const L& a) {return a.b - a.a;}\n\ninline D arg(const P& base, const P& a, const P& b) {return arg((b - base) / (a - base));}\n\ninline P proj(const P& a, const P& b) {return a * dot(a, b) / norm(a);}\ninline P perp(const L& l, const P& p) {return l.a + proj(vec(l), p - l.a);}\n\ninline pair<P, P> pCL(const C& c, const L& l) {\n  P x = perp(l, c.c);\n  P y = vec(l) / abs(vec(l)) * sr(c.r * c.r - norm(x - c.c));\n  return make_pair(x - y, x + y);\n}\n\ninline D aCTnc(D r, const P& p1, const P& p2) {return sig(abs((p1 + p2) / (D)2), r) <= 0 ? det(p1, p2) / 2 : r * r * arg(0, p1, p2) / 2;}\n\ninline D aCT(D r, const P& p1, const P& p2) {\n  if (!sig(r) || near(0, p1) || near(0, p2) || near(p1, p2)) return 0;\n  pair<P, P> pp = pCL((C){0, r}, (L){p1, p2});\n  if ((p1 < pp.first) != (pp.first < p2) && (p1 < pp.second) != (pp.second < p2)) return aCTnc(r, p1, p2);\n  return aCTnc(r, p1, pp.first) + aCTnc(r, pp.first, pp.second) + aCTnc(r, pp.second, p2);\n}\n\ninline D aCPol(const C& c, const Pol& pol) {\n  D res = 0;\n  for (int i = 0; i < (int)pol.size(); ++i) res += aCT(c.r, pol[i] - c.c, pol[(i + 1) % pol.size()] - c.c);\n  return res;\n}\n\nint main() {\n  int n, r;\n  cin >> n >> r;\n  D x1 = 1e9, x2 = -1e9, y1 = 1e9, y2 = -1e9, a = 0;\n  Pol pol(n);\n  for (auto& p : pol) {\n    D x, y;\n    cin >> x >> y;\n    p = P(x, y);\n    x1 = min(x1, x);\n    x2 = max(x2, x);\n    y1 = min(y1, y);\n    y2 = max(y2, y);\n  }\n  for (int i = 0; i < 300; ++i) {\n    D xa = (2 * x1 + x2) / 3;\n    D yy1 = y1, yy2 = y2;\n    D aa1 = 0, aa2 = 0;\n    for (int j = 0; j < 300; ++j) {\n      D ya = (2 * yy1 + yy2) / 3;\n      D yb = (yy1 + 2 * yy2) / 3;\n      D a1 = aCPol(C({P(xa, ya), (D)r}), pol);\n      D a2 = aCPol(C({P(xa, yb), (D)r}), pol);\n      if (a1 > a2) yy2 = yb;\n      else yy1 = ya;\n      aa1 = max(a1, a2);\n    }\n    yy1 = y1;\n    yy2 = y2;\n    D xb = (x1 + 2 * x2) / 3;\n    for (int j = 0; j < 300; ++j) {\n      D ya = (2 * yy1 + yy2) / 3;\n      D yb = (yy1 + 2 * yy2) / 3;\n      D a1 = aCPol(C({P(xb, ya), (D)r}), pol);\n      D a2 = aCPol(C({P(xb, yb), (D)r}), pol);\n      if (a1 > a2) yy2 = yb;\n      else yy1 = ya;\n      aa2 = max(a1, a2);\n    }\n    if (aa1 > aa2) x2 = xb;\n    else x1 = xa;\n    a = max(aa1, aa2);\n  }\n  cout << fixed << setprecision(15) << a << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<complex>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-9)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\n// BEGIN - Library\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ return os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ return os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev ?????? cur ????????£??? next ????????????????§????????±???????\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\n  \ntypedef pair<double,double> dd;\nconst double DINF = 1e20;\n\n#define pow2(a) ((a)*(a))\n\ndd calc(double x1,double y1,double vx1,double vy1,\n        double x2,double y2,double vx2,double vy2,double r){\n  double VX = (vx1-vx2), X = (x1-x2), VY = (vy1-vy2), Y = (y1-y2);\n  double a = pow2(VX) + pow2(VY), b = 2*(X*VX+Y*VY), c = pow2(X) + pow2(Y) - pow2(r);\n  dd ret = dd(DINF,DINF);\n  double D = b*b - 4 * a * c;\n\n  if( LT(D,0.0) ) return ret;\n\n  if( equals(a,0.0) ) {\n    if( equals(b,0.0) ) return ret;\n    if( LT(-c/b,0.0)  ) return ret;\n    ret.first = - c / b;\n    return ret;\n  }\n\n  if( equals(D,0.0) ) D = 0;\n  ret.first  = ( -b - sqrt( D ) ) / ( 2 * a );\n  ret.second = ( -b + sqrt( D ) ) / ( 2 * a );\n  if( !equals(ret.first,ret.second) && ret.first > ret.second ) swap(ret.first,ret.second);\n  return ret;\n}\n\n\nconst Point ZERO = Point(0,0);\n//??????AB??¨?????????cp,??????r????????¨?????±?????¨????????¢???????±???????\ninline double calculator_TypeA(Point A,Point B,Point cp,double r){\n  A = A - cp, B = B - cp; \n  if( A == ZERO || B == ZERO ) return 0;\n  double cross_value = cross(A,B);\n  if( equals(cross_value,0.0) ) return 0;\n  double sig = LT(cross_value,0.0) ? -1 : 1;\n  Segment AB = Segment(A,B);\n  double nearest_distance = distanceLP(AB,ZERO);\n  double distance_OA = abs(A);\n  double distance_OB = abs(B);\n\n  if( LTE(0.0,r-distance_OA) && LTE(0.0,r-distance_OB) && LTE(0.0,r-nearest_distance) ) {\n    return sig * fabs( cross_value / 2.0 );\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LTE(0.0,nearest_distance-r) ) {\n    return sig * ( r * r * (M_PI-getArg(A,ZERO,B)) ) / 2.0;\n  } else if( LTE(0.0,distance_OA-r) && LTE(0.0,distance_OB-r) && LT(0.0,r-nearest_distance) ) {\n\n    Point proj_p = projection(AB,ZERO);\n    if( onSegment(AB.p1,AB.p2,proj_p) ) {\n      Vector e = ( A - B ) / abs( A - B );\n      dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n      Point r_p1 = A + e * tmp.first;\n      Point r_p2 = A + e * tmp.second; \n      double ret = r * r * (M_PI-getArg(B,ZERO,A)) / 2.0;\n      double subtract = r * r * (M_PI-getArg(r_p1,ZERO,r_p2)) / 2.0 - fabs(cross(r_p1,r_p2))/2.0 ;\n      return sig * ( ret - subtract );\n    } else {\n      return sig * ( r * r * (M_PI-getArg(B,ZERO,A)) ) / 2.0; \n    }\n  } else {\n\n    if( LT(distance_OB-r,0.0) ) swap(A,B);\n    Vector e = ( A - B ) / abs( A - B );\n    dd tmp = calc(A.x,A.y,e.x,e.y,0,0,0,0,r);\n    Point r_p1 = A + e * tmp.first;\n    Point r_p2 = A + e * tmp.second; \n    if( onSegment(A,B,r_p2) ) r_p1 = r_p2;\n    double ret = fabs(cross(r_p1,A)) * 0.5;\n    ret += r * r * (M_PI-getArg(r_p1,ZERO,B)) * 0.5;\n    return sig * ret;\n  }\n  assert(false);\n}\n\ndouble getCommonAreaPolygonCircle(const Polygon &poly,Point cp,double r){\n  double sum = 0;\n  rep(i,(int)poly.size()){  \n    sum += calculator_TypeA(poly[i],poly[(i+1)%(int)poly.size()],cp,r);\n  }\n  return fabs(sum);\n}\n\nPolygon andrewScan(Polygon s) {\n  Polygon u,l;\n  if(s.size() < 3)return s;\n\n  sort(s.begin(),s.end());\n\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n\n  for(int i=2;i<(int)s.size();i++)\n    {\n      for(int n=u.size();n >= 2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--)\n\tu.pop_back();\n      u.push_back(s[i]);\n    }\n\n  for(int i=s.size()-3; i>=0 ; i--)\n    {\n      for(int n=l.size(); n >= 2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--)\n\tl.pop_back();\n      l.push_back(s[i]);\n    }\n\n  reverse(l.begin(),l.end());\n\n  for(int i = u.size()-2; i >= 1; i--) l.push_back(u[i]);\n\n  return l;\n}\n\n\n\nPoint calc_ps(Polygon poly) {\n  poly = andrewScan(poly);\n  Point mp = poly[0];\n  double rate = 1; // 0.5???????????¨???\n  int max_pos;\n  double eps = 1e-10; // 1e-20???????????¨???\n  while( rate > eps ) {\n    rep(_,60){ // 70???????????¨???\n      max_pos = 0;\n      REP(j,1,(int)poly.size()) {\n        double dist1 = abs(mp-poly[max_pos]);\n        double dist2 = abs(mp-poly[j]);\n\tif( LT(dist1,dist2) ) max_pos = j;\n      }\n      mp.x += ( poly[max_pos].x - mp.x ) * rate;\n      mp.y += ( poly[max_pos].y - mp.y ) * rate;\n    }\n    rate *= 0.5;\n  }\n  return mp;\n}\n\nPoint getCentroidOfConvex(Polygon& poly){\n  double area = getArea(poly);\n  int V = poly.size();\n  assert( !equals(area,0.0) );\n  double x = 0, y = 0;\n  rep(i,(int)poly.size()) {\n    x += ( poly[i].x + poly[(i+1)%V].x ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n    y += ( poly[i].y + poly[(i+1)%V].y ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n  }\n  return Point(x/(6.0*area),y/(6.0*area));\n}\n\n\n// END   - Library\n\nint n,r;\nPolygon poly;\n\nvoid compute() {\n  double maxi;\n  Point mp = calc_ps(poly);\n  maxi = getCommonAreaPolygonCircle(poly,mp,r);\n  double rate = 1.0;\n  double eps = 1e-10;\n  while( LT(eps,rate) ) {\n    rep(_,70) {\n      double max_area = -1; \n      Point np;\n      rep(i,n) {\n\tPoint tp = mp;\n\ttp.x += ( poly[i].x - mp.x ) * rate;\n\ttp.y += ( poly[i].y - mp.y ) * rate;\n\tdouble area = getCommonAreaPolygonCircle(poly,tp,r);\n\tif( LT(max_area,area) ) {\n\t  max_area = area;\n\t  np = tp;\n\t}\n      }\n      assert( !equals(max_area,-1) );\n      mp = np;\n      if( LT(maxi,max_area) ) maxi = max_area;\n    }\n    rate *= 0.5;\n  }\n  rep(__,1) {\n    Point mp = calc_ps(poly);\n    double rate = 1.0;\n    double eps = 1e-10;\n    while( LT(eps,rate) ) {\n      rep(_,70) {\n\tdouble max_area = -1; \n\tPoint np;\n\trep(i,n) {\n\t  Point tp = mp;\n\t  tp.x += ( poly[i].x - mp.x ) * rate;\n\t  tp.y += ( poly[i].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,tp,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t    np = tp;\n\t  }\n\t}\n\tif( rand() % 50 == 0 ) {\n\t  int v = rand() % n;\n\t  np.x = ( poly[v].x - mp.x ) * rate;\n\t  np.y = ( poly[v].y - mp.y ) * rate;\n\t  double area = getCommonAreaPolygonCircle(poly,np,r);\n\t  if( LT(max_area,area) ) {\n\t    max_area = area;\n\t  }\n\t}\n\tassert( !equals(max_area,-1) );\n\tmp = np;\n\tif( LT(maxi,max_area) ) maxi = max_area;\n      }\n      rate *= 0.5;\n    }\n  }\n  printf(\"%.10f\\n\",maxi);\n}\n\nint main() {\n  srand((unsigned int)time(NULL));\n  cin >> n >> r;\n  poly.resize(n);\n  rep(i,n) cin >> poly[i].x >> poly[i].y;\n  //cout << getArea(poly) << endl;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\n\ntemplate<class T> using V = vector<T>;\n\nusing D = double;\nconst D PI = acos(D(-1)), EPS = 1e-10;\n\nint sgn(D a) { return (abs(a) <= EPS) ? 0 : (a < 0 ? -1 : 1); }\nint sgn(D a, D b) { return sgn(a-b); }\n//relative sign\n// int rsgn(D a, D f) {\n//     if (abs(a) <= f*EPS) return 0;\n//     return (a < 0) ? -1 : 1;\n// }\nstruct Pt2 {\n    D x, y;\n    Pt2(D _x = D(), D _y = D()) : x(_x), y(_y) {}\n    Pt2 operator+(const Pt2 &r) const { return Pt2(x+r.x, y+r.y); }\n    Pt2 operator-(const Pt2 &r) const { return Pt2(x-r.x, y-r.y); }\n    Pt2 operator*(const Pt2 &r) const { return Pt2(x*r.x-y*r.y, x*r.y+y*r.x); }\n\n    Pt2 operator*(const D &r) const { return Pt2(x*r, y*r); }\n    Pt2 operator/(const D &r) const { return Pt2(x/r, y/r); }\n\n    Pt2& operator+=(const Pt2 &r) { return *this=*this+r; }\n    Pt2& operator-=(const Pt2 &r) { return *this=*this-r; }\n    Pt2& operator*=(const Pt2 &r) { return *this=*this*r; }\n    Pt2& operator*=(const D &r) { return *this=*this*r; }\n    Pt2& operator/=(const D &r) { return *this=*this/r; }\n    \n    Pt2 operator-() const { return Pt2(-x, -y); }\n\n    bool operator<(const Pt2 &r) const { return 2*sgn(x, r.x)+sgn(y, r.y)<0; }\n    bool operator==(const Pt2 &r) const { return sgn((*this-r).rabs()) == 0; }\n\n    D norm() const { return x*x + y*y; }\n    D abs() const { return sqrt(norm()); }\n    D rabs() const { return max(std::abs(x), std::abs(y)); } // robust abs\n    D arg() const { return atan2(y, x); }\n\n    pair<D, D> to_pair() const { return make_pair(x, y); }\n    static Pt2 polar(D le, D th) { return Pt2(le*cos(th), le*sin(th)); }\n};\nostream& operator<<(ostream& os, const Pt2 &p) {\n    return os << \"P(\" << p.x << \", \" << p.y << \")\";\n}\nusing P = Pt2;\n\nstruct L {\n    P s, t;\n    L(P _s = P(), P _t = P()) : s(_s), t(_t) {}\n    P vec() const { return t-s; }\n    D abs() const { return vec().abs(); }\n    D arg() const { return vec().arg(); }\n};\nostream& operator<<(ostream& os, const L &l) {\n    return os << \"L(\" << l.s << \", \" << l.t << \")\";\n}\n\nD cross(P a, P b) { return a.x*b.y - a.y*b.x; }\nD dot(P a, P b) { return a.x*b.x + a.y*b.y; }\n// cross(a, b) is too small?\nint sgncrs(P a, P b) {\n    D cr = cross(a, b);\n    if (abs(cr) <= (a.rabs() + b.rabs()) * EPS) return 0;\n    return (cr < 0) ? -1 : 1;\n}\n\n// -2, -1, 0, 1, 2 : front, clock, on, cclock, back\nint ccw(P b, P c) {\n    int s = sgncrs(b, c);\n    if (s) return s;\n    if (!sgn(c.rabs()) || !sgn((c-b).rabs())) return 0;\n    if (dot(b, c) < 0) return 2;\n    if (dot(-b, c-b) < 0) return -2;\n    return 0;\n}\nint ccw(P a, P b, P c) { return ccw(b-a, c-a); }\nint ccw(L l, P p) { return ccw(l.s, l.t, p); }\n\nP project(const L &l, const P &p) {\n    P v = l.vec();\n    return l.s + v * (dot(v, p-l.s) / v.norm());\n}\n\nbool insSL(const L &s, const L &l) {\n    int a = ccw(l, s.s), b = ccw(l, s.t);\n    return (a%2 == 0 || b%2 == 0 || a != b);\n}\n\nbool insSS(const L &s, const L &t) {\n    int a = ccw(s, t.s), b = ccw(s, t.t);\n    int c = ccw(t, s.s), d = ccw(t, s.t);\n    if (a*b <= 0 && c*d <= 0) return true;\n    return false;\n}\n\nD distLP(const L &l, const P &p) {\n    return abs(cross(l.vec(), p-l.s)) / l.abs();\n}\n\nD distSP(const L &s, const P &p) {\n    P q = project(s, p);\n    if (ccw(s, q) == 0) return (p - q).abs();\n    else return min((s.s - p).abs(), (s.t - p).abs());\n}\n\nint crossLL(const L &l, const L &m, P &r) {\n    D cr1 = cross(l.vec(), m.vec()), cr2 = cross(l.vec(), l.t - m.s);\n    if (sgncrs(l.vec(), m.vec()) == 0) {\n        r = l.s;\n        if (sgncrs(l.vec(), l.t - m.s)) return 0;\n        return -1;\n    }\n    r = m.s + m.vec() * (cr2 / cr1);\n    return 1;\n}\n\nusing Pol = V<P>;\n\nstruct C {\n    P p; D r;\n    C(P _p = P(), D _r = D()) : p(_p), r(_r) {}\n};\n\n//need Intersect/distLP, r.sはよりl.sに近い\nint crossCL(const C &c, const L &l, L &r) {\n    D u = distLP(l, c.p);\n    int si = sgn(u, c.r);    \n    if (si == 1) return 0;\n    P v = project(l, c.p);\n    P di = (si == 0) ? P(0, 0) : l.vec() * (sqrt(c.r*c.r - u*u) / l.abs());\n    r = L(v-di, v+di);\n    if (si == 0) return 1;\n    return 2;\n}\n\n// C(P(0, 0), r)とTri((0, 0), a, b)の共有面積\nD area2CT(const C &c, const P &_a, const P &_b) {\n    P a = _a - c.p, b = _b - c.p; D r = c.r;\n    if (a == b) return 0;\n    auto single = [&](P x, P y, bool tri) {\n        if (tri) return cross(x, y);\n        else return r * r * ((y * P(x.x, -x.y)).arg());\n    };\n    bool ia = sgn(a.abs(), r) != 1, ib = sgn(b.abs(), r) != 1;\n    if (ia && ib) return single(a, b, true);\n    D r2 = distSP(L(a, b), P(0, 0));\n    if (sgn(r, r2) != 1) return single(a, b, false);\n    L l;\n    assert(crossCL(C(P(0, 0), r), L(a, b), l) == 2);\n    if (ia) l.s = l.t;\n    else if (ib) l.t = l.s;\n    assert(ccw(a, b, l.s) == 0); assert(ccw(a, b, l.t) == 0);\n    return single(a, l.s, ia) + single(l.s, l.t, true) + single(l.t, b, ib);\n}\n\n// p, cの共有面積\nD area2CPol(const C &c, const Pol &po) {\n    D sm = 0;\n    P a, b = po.back();\n    for (auto p: po) {\n        a = b; b = p;\n        sm += area2CT(c, a, b);\n    }\n    return sm;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20);\n    int n; D r;\n    cin >> n >> r;\n    Pol pol;\n \n    D ymi = 1e100, yma = -1e100;\n    for (int i = 0; i < n; i++) {\n        D x, y;\n        cin >> x >> y;\n        pol.push_back(P(x, y));\n        ymi = min(ymi, y);\n        yma = max(yma, y);\n    }\n \n    auto calc = [&](D y) {\n        D xmi = 1e100, xma = -1e100;\n        P a, b = pol.back();\n        for (int i = 0; i < n; i++) {\n            a = b; b = pol[i];\n            P p;\n            if (crossLL(L(a, b), L(P(0, y), P(1, y)), p) == 0) continue;\n            if (ccw(a, b, p) != 0) continue;\n            xmi = min(xmi, p.x); xma = max(xma, p.x);\n        }\n        D lw = xmi, up = xma;\n        for (int ph = 0; ph < 30; ph++) {\n            D md1 = (lw+lw+up) / 3;\n            D md2 = (lw+up+up) / 3;\n            D z1 = area2CPol(C(P(md1, y), r), pol) / 2;\n            D z2 = area2CPol(C(P(md2, y), r), pol) / 2;\n            if (z1 < z2) {\n                lw = md1;\n            } else {\n                up = md2;\n            }\n        }\n        return area2CPol(C(P(lw, y), r), pol) / 2;\n    };\n     \n    D lw = ymi, up = yma;\n    for (int ph = 0; ph < 30; ph++) {\n        D md1 = (lw+lw+up) / 3;\n        D md2 = (lw+up+up) / 3;\n        if (calc(md1) < calc(md2)) {\n            lw = md1;\n        } else {\n            up = md2;\n        }\n    }\n \n    cout << calc(lw) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector< P > vecp;\n \nstruct S{\n  P p,q;\n  S(P p,P q) : p(p),q(q) {}  \n};\n \nstruct C{\n  P p;  double r;\n  C(P p,double r):p(p),r(r){}\n  C(double x,double y,double rr){\n    p=P(x,y);\n    r=rr;\n  }\n};\n \ndouble eps=1e-8,  PI=acos(-1),  PI2=PI*2.0;\n \nbool eq(double a,double b){return (b-a<eps&&a-b<eps);}\nbool eq(P a,P b){return (abs(a-b)<eps);}\ndouble Sqrt(double x){  return ( x<0 ? 0.0 : sqrt(x) ); }\ndouble dot(P a,P b){return real(b*conj(a));}\ndouble cross(P a,P b){return imag(b*conj(a));}\n \ndouble dist(P a,P b,P c){\n  if(dot(b-a,c-a)<0)return abs(c-a);\n  if(dot(a-b,c-b)<0)return abs(c-b);\n  return abs(cross(b-a,c-a))/abs(b-a);\n}\n \nP project(P a,P b,P c){  b-=a; c-=a; return a+b*real(c/b); }\n \ndouble getTime(P a,P b){\n  assert( eq(cross(a,b),0) );\n  return ( dot(a,b) < 0 ? -1.0 : 1.0 ) * abs(b);\n}\n \nbool onSegment(P a,P b,P p){\n  return eq( abs(a-b) , abs(a-p)+abs(b-p) );\n}\n \nP getCrossPoint(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n \ndouble getArg(P a,P b){  return arg(b*conj(a)); }\n \nvecp getCrossPoint(C c,P a,P b){\n  vecp res;\n  P base=b-a,  target=project(a,b,c.p);\n  double length=abs(base), h=abs(c.p-target);\n  if(c.r+eps<h)return res;\n  double w=Sqrt(c.r*c.r-h*h);\n  double L=getTime(base,target-a)-w, R=L+w*2.0;\n  base/=length;\n  if( -eps<L && L<length+eps )res.push_back(a+base*L);\n  if( eq(L,R) )return res;\n  if( -eps<R && R<length+eps )res.push_back(a+base*R);\n  return res;\n}\n \nvecp getCrossPoint(C a,S b, bool debug=false){\n  vecp res;\n  P base=b.q-b.p,  target=project(b.p,b.q,a.p);\n  double length=abs(base), h=abs(a.p-target);\n  if(a.r+eps<h)return res;\n  double w=Sqrt(a.r*a.r-h*h);\n  double L=getTime(base,target-b.p)-w,  R=L+w*2.0;\n  base/=length;  \n  if( -eps<L && L< length+eps )res.push_back(b.p+base*L);\n  if( eq(L,R) )return res;\n  if( -eps<R && R< length+eps )res.push_back(b.p+base*R);\n  return res;\n}\n \ndouble getArea(C c,P a,P b){\n  P va=c.p-a,  vb=c.p-b;\n  double A=abs(va), B=abs(vb);\n  double f=cross(va,vb), d=dist(a,b,c.p), res=0;\n  if( eq(0, f ) )return 0;\n  if(A<c.r+eps&&B<c.r+eps)return f*0.5;\n  if(d>c.r-eps)return c.r*c.r*PI*getArg(va,vb)/PI2;\n   \n  vecp u=getCrossPoint(c, S(a,b) );\n  assert( !u.empty() );\n  u.insert(u.begin(), a),  u.push_back(b);\n \n  for(int i=0;i+1<(int)u.size();i++) res+=getArea(c,u[i],u[i+1]);\n  return res;\n}\n \ndouble getArea(vecp t,C c){\n  int n=t.size();\n  if(n<3)return 0;\n  double res=0;\n  for(int i=0;i<n;i++){\n    P a=t[i], b=t[(i+1)%n];\n    res+=getArea(c,a,b);\n  }\n  return res;\n}\n \nint n;\ndouble cr;\nvecp t;\n \ndouble calc(double gx){\n  double left=1e9, right=-1e9;\n  for(int i=0;i<(int)t.size();i++){\n    P a=t[i];\n    P b=t[ (i+1)%n ];\n    P k=getCrossPoint( a,b, P(gx,0), P(gx,1) );\n    if( onSegment(a,b,k) == false )continue;\n    left=min(left,k.imag());\n    right=max(right,k.imag());\n  }\n   \n  for(int i=0;i<100;i++){\n    double dist=(right-left)/3.0;\n    double ml=left+dist;\n    double mr=right-dist;\n    if( getArea(t,C(P(gx,ml),cr)) > getArea(t,C(P(gx,mr),cr))){\n      right=mr;\n    }else{\n      left=ml;\n    }\n       \n  }\n  return getArea(t,C(P(gx,left),cr));\n}\n \nint main(){\n  cin>>n>>cr;\n  double left=1e9, right=-1e9;\n   \n  for(int i=0;i<n;i++){\n    double x,y;\n    cin>>x>>y;\n    t.push_back(P(x,y));\n    left=min(left,x);\n    right=max(right,x);\n  }\n \n  for(int i=0;i<100;i++){\n    double dist=(right-left)/3.0;\n    double ml=left+dist,mr=right-dist;\n    if( calc(ml) > calc(mr) )right=mr;\n    else left=ml;\n  }\n  printf(\"%.10f\\n\", calc(left) );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(a) int((a).size())\n#define mp make_pair\n#define pb push_back\ntypedef vector<int> VI;\ntypedef pair<int,int> PII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\nconst LL mod=1e9+7;\nconst int INF=0x3f3f3f3f;\nconst double PI=acos(-1.0);\nconst double EPS=1e-6;\ninline void read(LL& x){int f=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(f=-1,x=0):(x=c-'0');while((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=f;}\ninline void read(int& x){LL t;read(t);x=t;}\n/*----------------------精度控制--------------------------*/\nconst double eps=1e-7;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n/*------------------点、???体-------------------*/\nstruct Point{\n    double x,y;\n    Point(double x=0.0,double y=0.0):x(x),y(y){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        return !dcmp(x-b.x)? y<b.y:x<b.x;\n    }\n    /*friend bool operator<(CPoint a,CPoint b){//?角排序\n        double tmp=cross(Pts[0],a,b);\n        if(!dcmp(tmp)) return dist(Pts[0],a)<dist(Pts[0],b);\n        return tmp>0;\n    }*/\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\ndouble length(Point p){ return sqrt(p*p); }\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\ndouble area(Point a,Point b){ return a^b*0.5; }\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dcmp(dot(s.b-s.a,p-s.a))<0) return length(p-s.a);\n    if(dcmp(dot(s.a-s.b,p-s.b))<0) return length(p-s.b);\n    return distPL(p,s);\n}\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+p.x*cos(alpha)-p.y*sin(alpha),a.y+p.x*sin(alpha)+p.y*cos(alpha));\n}\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n/*----------------------多?形相?--------------------------*/\n//0:outside 1:inside 2:online\nint PointInPoly(Point t,Point *p,int n){\n    int num=0,d1,d2,k;\n    p[n]=p[0];\n    for(int i=0;i<n;i++){\n        if(PointOnS(t,Line(p[i],p[i+1]))) return 2;\n        k=dcmp(cross(p[i],p[i+1],t));\n        d1=dcmp(p[i].y-t.y);\n        d2=dcmp(p[i+1].y-t.y);\n        if(k>0&&d1<=0&&d2>0) num++;\n        if(k<0&&d2<=0&&d1>0) num--;\n    }\n    return num!=0;\n}\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *p,int n){\n    double pa=0.0;p[n]=p[0];\n    for(int i=0;i<n;i++) pa+=area(p[i],p[i+1]);\n    return pa;\n}\n//求多?形周?\ndouble PolyPerimeter(Point *p,int n){\n    double pp=0.0;p[n]=p[0];\n    for(int i=0;i<n-1;i++) pp+=distPP(p[i],p[i+1]);\n    return pp;\n}\n//求多?形重心\nPoint PolyCore(Point *p,int n){\n    double pa=PolyArea(p,n);\n    if(!dcmp(pa)) return Point(0,0);\n    Point ans(0,0);p[n]=p[0];\n    for(int i=0;i<n;i++) ans=ans+(p[i]+p[i+1])*cross(p[i],p[i+1]);\n    return ans/pa/6;\n}\n/*----------------------凸包----------------------------*/\n//Graham-scan st:anticlockwise\n//<=:strict <:Non-strict\nint Graham(Point *p,Point *st,int n){\n    if(n<3) return 0;\n    sort(p,p+n);\n    int m=0;\n    for(int i=0;i<n;i++){\n        while(m>1&&dcmp(cross(st[m-2],st[m-1],p[i]))<0) m--;\n        st[m++]=p[i];\n    }\n    int k=m;\n    for(int i=n-2;i>=0;i--){\n        while(m>k&&dcmp(cross(st[m-2],st[m-1],p[i])<0)) m--;\n        st[m++]=p[i];\n    }\n    return m-1;\n}\n//clockwise:> anticlockwise:<\ndouble CHDiameter(Point *p,int n,Line &l){\n    double maxd=0.0;\n    if(n<=1){\n        l.a=l.b=p[0];\n        return maxd;\n    }\n    for(int i=0,j=1;i<n;i++){\n        while(cross(p[i],p[(i+1)%n],p[j])\n              >cross(p[i],p[(i+1)%n],p[(j+1)%n])){\n            j=(j+1)%n;\n        }\n        double d=distPP(p[i],p[j]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=p[i];\n            l.b=p[j];\n        }\n        d=distPP(p[(i+1)%n],p[(j+1)%n]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=p[i];\n            l.b=p[j];\n        }\n    }\n    return maxd;\n}\nbool PointInCH(Point *p,int n,Point a){\n    int l=0,r=n-1,m,res=-1;\n    bool fg=false;\n    int pos;\n    double flag[2];\n    while(l<=r){\n        m=(l+r)/2;\n        flag[0]=cross(p[0]-a,p[0]-p[m]);\n        if(!dcmp(flag[0])){\n            fg=true;\n            pos=m;\n            break;\n        }\n        flag[1]=cross(p[0]-a,p[0]-p[m+1]);\n        if(!dcmp(flag[1])){\n            fg=true;\n            pos=m+1;\n            break;\n        }\n        if(dcmp(flag[0])*dcmp(flag[1])<0){\n            res=m;\n            break;\n        }\n        if(dcmp(flag[0])<0&&dcmp(flag[1])<0) l=m+1;\n        else r=m-1;\n    }\n    if(fg){\n        if(dcmp((p[0]-a)*(p[pos]-a))<=0) return true;\n        return false;\n    }\n    if(res==-1) return false;\n    return dcmp(cross(p[m]-a,p[m]-p[m+1]))<=0;\n}\n\n\n/*---------------------整点多?形---------------------------*/\nint gcd(int a,int b){\n    return b==0?a :gcd(b,a%b);\n}\n//整点多?形?界整点数\nint Border_Int_Point_Num(Point *Pts,int n){\n    int num=gcd(abs(int(Pts[0].x-Pts[n-1].x)),abs(int(Pts[0].y-Pts[n-1].y)));;\n    for(int i=0;i<n-1;i++){\n        num+=gcd(abs(int(Pts[i+1].x-Pts[i].x)),abs(int(Pts[i+1].y-Pts[i].y)));\n    }\n    return num;\n}\n//整点多?形内部整点数\nint Inside_Int_Point_Num(Point *Pts,int n){\n    return abs(int(PolyArea(Pts,n)))+1-Border_Int_Point_Num(Pts,n)/2;\n}\n/*-----------------------------半平面交-------------------------------*/\n//有方向的直?\n//p->p+v\nstruct Vector{\n    Point p,v;\n    double ang;\n    Vector(Point p,Point v):p(p),v(v){\n        ang=atan2(v.y,v.x);\n    }\n    Vector(){}\n    bool operator<(const Vector &l) const{\n        return ang<l.ang;\n    }\n};\n//判断点p是否在直?L左?\nbool onLeft(Vector L,Point p){\n    return cross(L.v,p-L.p)>0;\n}\n//得到a与b?直?的交点\nPoint getCrossVV(Vector a,Vector b){\n    Point u=a.p-b.p;\n    double t=cross(b.v,u)/cross(a.v,b.v);\n    return a.p+a.v*t;\n}\n//所有直?左半平面的交\nint HPCross(Vector *L,int n,Point *poly){\n    sort(L,L+n);\n    int f=0,l=0;\n    Point *p=new Point[n];\n    Vector *q=new Vector[n];\n    q[0]=L[0];\n    for(int i=1;i<n;i++){\n        while(f<l&&!onLeft(L[i],p[l-1])) l--;\n        while(f<l&&!onLeft(L[i],p[f])) f++;\n        q[++l]=L[i];\n        if(!dcmp(cross(q[l].v,q[l-1].v))){\n            l--;\n            if(onLeft(q[l],L[i].p)) q[l]=L[i];\n        }\n        if(f<l) p[l-1]=getCrossVV(q[l-1],q[l]);\n    }\n    while(f<l&&!onLeft(q[f],p[l-1])) l--;\n    if(l-f<=1) return 0;\n    p[l]=getCrossVV(q[l],q[f]);\n    int m=0;\n    for(int i=f;i<=l;i++) poly[m++]=p[i];\n    return m;\n}\n//向内??r\n#define maxn 100005\nVector l[maxn];\nbool retract(Vector *L,int n,double r,Point *poly){\n    for(int i=0;i<n;i++){\n        Point v=rotateV(L[i].p,L[i].p+L[i].v,PI/2);\n        l[i]=Vector(L[i].p+r*v,L[i].v);\n    }\n    int cnt=HPCross(l,n,poly);\n    return cnt;\n}\n/*---------------------三角形相?---------------------------*/\n//三角形重心\n//到三?点距?的平方和最小的点\n//到三?距?之?最大的点\nPoint TCore(Point a,Point b,Point c){\n    return (a+b+c)/3;\n}\n//三角形外心\nPoint TCircum(Point a,Point b,Point c){\n    Point cp;\n    double a1=b.x-a.x;\n    double b1=b.y-a.y;\n    double a2=c.x-a.x;\n    double b2=c.y-a.y;\n    double c1=(a1*a1+b1*b1)/2;\n    double c2=(a2*a2+b2*b2)/2;\n    double d=a1*b2-a2*b1;\n    cp.x=a.x+(c1*b2-c2*b1)/d;\n    cp.y=a.y+(a1*c2-a2*c1)/d;\n    return cp;\n}\n//三角形垂心\nPoint TOrtho(Point a,Point b,Point c){\n    return TCore(a,b,c)*3.0-TCircum(a,b,c)*2.0;\n}\n//三角形内心\nPoint TInner(Point a,Point b,Point c){\n    Point cp;\n    double la=distPP(b,c),lb=distPP(c,a),lc=distPP(a,b);\n    cp.x=(la*a.x+lb*b.x+lc*c.x)/(la+lb+lc);\n    cp.y=(la*a.y+lb*b.y+lc*c.y)/(la+lb+lc);\n    return cp;\n}\n//求三角形面?\ndouble TArea(Point a,Point b,Point c){\n    return fabs(cross(a,b,c))/2;\n}\n/*-----------------------?相?-------------------------*/\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n//求??面?交\ndouble getAreaCC(Circle a,Circle b){\n    double d=(a.o.x-b.o.x)*(a.o.x-b.o.x)+(a.o.y-b.o.y)*(a.o.y-b.o.y);\n    if(d<=(a.r-b.r)*(a.r-b.r)){\n        return min(a.r,b.r)*min(a.r,b.r)*PI;\n    }else if(d>(a.r-b.r)*(a.r-b.r)&&d<(a.r+b.r)*(a.r+b.r)){\n        double m1=(a.r*a.r+d-b.r*b.r)/(2*a.r*sqrt(d));\n        double m2=(b.r*b.r+d-a.r*a.r)/(2*b.r*sqrt(d));\n        double s1=acos(m1)*a.r*a.r;\n        double s2=acos(m2)*b.r*b.r;\n        double s3=sqrt(d)*a.r*sin(acos(m1));\n        return s1+s2-s3;\n    }\n    return 0.0;\n}\n//求??交点，先判断是否有交点\nPoint rotatePCS(Point p,double c,double s){\n    return Point(p.x*c-p.y*s,p.x*s+p.y*c);\n}\npair<Point,Point> getcrossCC(Circle a,Circle b){\n    double d=length(a.o-b.o);\n    double cost=(a.r*a.r+d*d-b.r*b.r)/(2*a.r*d);\n    double sint=sqrt(1.0-cost*cost);\n    Point v=(b.o-a.o)/d*a.r;\n    return mp(a.o+rotatePCS(v,cost,-sint),a.o+rotatePCS(v,cost,sint));\n}\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg) cl[cnt++]=root(c.o,l);\n    else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n\ndouble rad(Point a,Point b,Point p){\n    return fabs(atan2(fabs(cross(a-p,b-p)),(a-p)*(b-p)));\n}\nPoint lineprog(Line l,Point p){\n    return l.a+(((l.b-l.a)*((l.b-l.a)*(p-l.a)))/((l.b-l.a)*(l.b-l.a)));\n}\nint relation(Point b,Circle c){\n    double d=distPP(b,c.o);\n    if(dcmp(d-c.r)<0) return 2;\n    if(!dcmp(d-c.r)) return 1;\n    return 0;\n}\nint getCrossCL(Circle c,Line l,Point &p1,Point &p2){\n    double dx=distPL(c.o,l);\n    if(dcmp(dx-c.r)>0) return 0;\n    Point a=lineprog(l,c.o);\n    double d=distPL(c.o,l);\n    d=sqrt(c.r*c.r-d*d);\n    if(!dcmp(d)){\n        p1=p2=a;\n        return 1;\n    }\n    Point s=unit(l.b-l.a);\n    p1=a+s*d;\n    p2=a-s*d;\n    return 2;\n}\ndouble getAreaTC(Point a,Point b,Circle c){\n    Point q[5];\n    int len=0;\n    q[len++]=a;\n    Line l(a,b);\n    Point p1,p2;\n    if(getCrossCL(c,l,q[1],q[2])==2){\n        if(dcmp((a-q[1])*(b-q[1]))<0) q[len++]=q[1];\n        if(dcmp((a-q[2])*(b-q[2]))<0) q[len++]=q[2];\n    }\n    q[len++]=b;\n    if(len==4&&dcmp((q[0]-q[1])*(q[2]-q[1]))>0) swap(q[1],q[2]);\n    double res=0.0;\n    for(int i=0;i<len-1;i++){\n        if(!relation(q[i],c)||!relation(q[i+1],c)){\n            double arg=rad(q[i],q[i+1],c.o);\n            res+=c.r*c.r*arg/2.0;\n        }else res+=fabs(cross(q[i]-c.o,q[i+1]-c.o))/2.0;\n    }\n    return res;\n}\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=0.0;\n    for(int i=0;i<n;i++){\n        int s=dcmp(cross(Pts[i]-c.o,Pts[i+1]-c.o));\n        if(!!s) apc+=getAreaTC(Pts[i],Pts[i+1],c)*s;\n    }\n    return fabs(apc);\n}\n\n/*----------------------三?点、?基本函数-----------------------------*/\nstruct Point3{\n    double x,y,z;\n    Point3(double x,double y,double z):x(x),y(y),z(z){}\n    Point3(){}\n    void Read(){ scanf(\"%lf%lf%lf\",&x,&y,&z); }\n};\nstruct Line3{\n    Point3 a,b;\n    Line3(Point3 a,Point3 b):a(a),b(b){}\n    Line3(){}\n    void Read(){ a.Read(); b.Read(); }\n};\nPoint3 operator +(Point3 a,Point3 b){ return Point3(a.x+b.x,a.y+b.y,a.z+b.z); }\nPoint3 operator -(Point3 a,Point3 b){ return Point3(a.x-b.x,a.y-b.y,a.z-b.z); }\ndouble operator *(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 operator *(Point3 a,double k){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator *(double k,Point3 a){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator /(Point3 a,double k){ return Point3(a.x/k,a.y/k,a.z/k); }\ndouble length(Point3 a){ return sqrt(a.x*a.x+a.y*a.y+a.z*a.z); }\nPoint3 unit(Point3 a){ return a/length(a); }\ndouble dot(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 cross(Point3 a,Point3 b){\n    return Point3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//混合?\ndouble Mix(Point3 a,Point3 b,Point3 c){ return dot(a,cross(b,c)); }\n//?点距?\ndouble dist(const Point3 &a,const Point3 &b){ return length(a-b); }\n/*---------------------------------体?-------------------------------------*/\n//四面体体?\ndouble volume(double l,double n,double a,double m,double b,double c){\n    double x,y;\n    x=4*a*a*b*b*c*c-a*a*(b*b+c*c-m*m)*(b*b+c*c-m*m)-b*b*(c*c+a*a-n*n)*(c*c+a*a-n*n);\n    y=c*c*(a*a+b*b-l*l)*(a*a+b*b-l*l)-(a*a+b*b-l*l)*(b*b+c*c-m*m)*(c*c+a*a-n*n);\n    return sqrt(x-y)/12;\n}\ndouble volume(Point3 a,Point3 b,Point3 c,Point3 d){ return fabs(Mix(b-a,c-a,d-a)/6); }\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\ndouble sanfeny(double x){\n    double l=maxy,r=miny;\n    Line s=Line(Point(x,0),Point(x,1));\n    for(int i=0;i<n;i++){\n        Point st=getCrossLL(s,Line(Pts[i],Pts[i+1]));\n        if(PointOnS(st,Line(Pts[i],Pts[i+1]))){\n            l=min(l,st.y);\n            r=max(r,st.y);\n        }\n    }\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\nint main(){ios_base::sync_with_stdio(0);//cin.tie(0);\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n+1-i].x);\n        miny=min(miny,Pts[n+1-i].y);\n        maxx=max(maxx,Pts[n+1-i].x);\n        maxy=max(maxy,Pts[n+1-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\n#define CVector CPoint\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1.0);\nconst double EPS=1e-7;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-7;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n    /*friend bool operator<(CPoint a,CPoint b){//?角排序\n        double tmp=cross(Pts[0],a,b);\n        if(isZero(tmp)){\n            return dist(Pts[0],a)<dist(Pts[0],b);\n        }\n        return tmp>0;\n    }*/\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n/*----------------------多?形相?--------------------------*/\n\n//0:outside 1:inside 2:online\nint PointInPoly(Point t,Point *Pts,int n){\n    int num=0,d1,d2,k;\n    Pts[n]=Pts[0];\n    for(int i=0;i<n;i++){\n        if(PointOnS(t,Line(Pts[i],Pts[i+1]))) return 2;\n        k=dcmp(cross(Pts[i],Pts[i+1],t));\n        d1=dcmp(Pts[i].y-t.y);\n        d2=dcmp(Pts[i+1].y-t.y);\n        if(k>0&&d1<=0&&d2>0) num++;\n        if(k<0&&d2<=0&&d1>0) num--;\n    }\n    return num!=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n//求任意多?形周?，需逆??或???排列\ndouble PolyPerimeter(Point *Pts,int n){\n    double pp=distPP(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pp+=distPP(Pts[i],Pts[i+1]);\n    return pp;\n}\n\n//求多?形重心坐?\nPoint PolyCore(Point *Pts,int n){\n    double pa=PolyArea(Pts,n);\n    if(!dcmp(pa)) return Point(0,0);\n    Point ans=(Pts[n-1]+Pts[0])*cross(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) ans=ans+(Pts[i]+Pts[i+1])*cross(Pts[i],Pts[i+1]);\n    return ans/pa/6;\n}\n\n/*----------------------凸包----------------------------*/\n\n//Graham-scan st:anticlockwise\n//<=:strict <:Non-strict\nint Graham(Point *Pts,Point *st,int n){\n    if(n<3) return 0;\n    sort(Pts,Pts+n);\n    int m=0;\n    for(int i=0;i<n;i++){\n        while(m>1&&dcmp(cross(st[m-2],st[m-1],Pts[i]))<0) m--;\n        st[m++]=Pts[i];\n    }\n    int k=m;\n    for(int i=n-2;i>=0;i--){\n        while(m>k&&dcmp(cross(st[m-2],st[m-1],Pts[i])<0)) m--;\n        st[m++]=Pts[i];\n    }\n    return m-1;\n}\n\n//clockwise:> anticlockwise:<\ndouble CHDiameter(Point *Pts,int n,Line &l){\n    double maxd=0.0;\n    if(n<=1){\n        l.a=l.b=Pts[0];\n        return maxd;\n    }\n    for(int i=0,j=1;i<n;i++){\n        while(cross(Pts[i],Pts[(i+1)%n],Pts[j])\n              >cross(Pts[i],Pts[(i+1)%n],Pts[(j+1)%n])){\n            j=(j+1)%n;\n        }\n        double d=distPP(Pts[i],Pts[j]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n        d=distPP(Pts[(i+1)%n],Pts[(j+1)%n]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n    }\n    return maxd;\n}\n\n/*---------------------整点多?形---------------------------*/\n\nint gcd(int a,int b){\n    return b==0?a :gcd(b,a%b);\n}\n\n//整点多?形?界整点数\nint Border_Int_Point_Num(Point *Pts,int n){\n    int num=gcd(abs(int(Pts[0].x-Pts[n-1].x)),abs(int(Pts[0].y-Pts[n-1].y)));;\n    for(int i=0;i<n-1;i++){\n        num+=gcd(abs(int(Pts[i+1].x-Pts[i].x)),abs(int(Pts[i+1].y-Pts[i].y)));\n    }\n    return num;\n}\n\n//整点多?形内部整点数\nint Inside_Int_Point_Num(Point *Pts,int n){\n    return abs(int(PolyArea(Pts,n)))+1-Border_Int_Point_Num(Pts,n)/2;\n}\n\n/*-----------------------------半平面交-------------------------------*/\n\n//有方向的直?\n//p->p+v\nstruct Vector{\n    Point p,v;\n    double ang;\n    Vector(Point p,Point v):p(p),v(v){\n        ang=atan2(v.y,v.x);\n    }\n    Vector(){}\n    bool operator<(const Vector &l) const{\n        return ang<l.ang;\n    }\n};\n\n//判断点p是否在直?L左?\nbool onLeft(Vector L,Point p){\n    return cross(L.v,p-L.p)>0;\n}\n\n//得到a与b?直?的交点\nPoint getCrossVV(Vector a,Vector b){\n    Point u=a.p-b.p;\n    double t=cross(b.v,u)/cross(a.v,b.v);\n    return a.p+a.v*t;\n}\n\n//所有直?左半平面的交\nint HPCross(Vector *L,int n,Point *poly){\n    sort(L,L+n);\n    int f=0,l=0;\n    Point *p=new Point[n];\n    Vector *q=new Vector[n];\n    q[0]=L[0];\n    for(int i=1;i<n;i++){\n        while(f<l&&!onLeft(L[i],p[l-1])) l--;\n        while(f<l&&!onLeft(L[i],p[f])) f++;\n        q[++l]=L[i];\n        if(!dcmp(cross(q[l].v,q[l-1].v))){\n            l--;\n            if(onLeft(q[l],L[i].p)) q[l]=L[i];\n        }\n        if(f<l) p[l-1]=getCrossVV(q[l-1],q[l]);\n    }\n    while(f<l&&!onLeft(q[f],p[l-1])) l--;\n    if(l-f<=1) return 0;\n    p[l]=getCrossVV(q[l],q[f]);\n    int m=0;\n    for(int i=f;i<=l;i++) poly[m++]=p[i];\n    return m;\n}\n\n#define maxn 100005\nVector l[maxn];\nbool retract(Vector *L,int n,double r,Point *poly){\n    for(int i=0;i<n;i++){\n        Point v=rotateV(L[i].p,L[i].p+L[i].v,PI/2);\n        l[i]=Vector(L[i].p+r*v,L[i].v);\n    }\n    int cnt=HPCross(l,n,poly);\n    return cnt;\n}\n\n/*---------------------三角形相?---------------------------*/\n\n//三角形重心\n//到三?点距?的平方和最小的点\n//到三?距?之?最大的点\nPoint TCore(Point a,Point b,Point c){\n    return (a+b+c)/3;\n}\n\n//三角形外心\nPoint TCircum(Point a,Point b,Point c){\n    Point cp;\n    double a1=b.x-a.x;\n    double b1=b.y-a.y;\n    double a2=c.x-a.x;\n    double b2=c.y-a.y;\n    double c1=(a1*a1+b1*b1)/2;\n    double c2=(a2*a2+b2*b2)/2;\n    double d=a1*b2-a2*b1;\n    cp.x=a.x+(c1*b2-c2*b1)/d;\n    cp.y=a.y+(a1*c2-a2*c1)/d;\n    return cp;\n}\n\n//三角形垂心\nPoint TOrtho(Point a,Point b,Point c){\n    return TCore(a,b,c)*3.0-TCircum(a,b,c)*2.0;\n}\n\n//三角形内心\nPoint TInner(Point a,Point b,Point c){\n    Point cp;\n    double la=distPP(b,c),lb=distPP(c,a),lc=distPP(a,b);\n    cp.x=(la*a.x+lb*b.x+lc*c.x)/(la+lb+lc);\n    cp.y=(la*a.y+lb*b.y+lc*c.y)/(la+lb+lc);\n    return cp;\n}\n\n//求三角形面?\ndouble TArea(Point a,Point b,Point c){\n    return fabs(cross(a,b,c))/2;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n//求??面?交\ndouble getAreaCC(Circle a,Circle b){\n    double d=(a.o.x-b.o.x)*(a.o.x-b.o.x)+(a.o.y-b.o.y)*(a.o.y-b.o.y);\n    if(d<=(a.r-b.r)*(a.r-b.r)){\n        return min(a.r,b.r)*min(a.r,b.r)*PI;\n    }else if(d>(a.r-b.r)*(a.r-b.r)&&d<(a.r+b.r)*(a.r+b.r)){\n        double m1=(a.r*a.r+d-b.r*b.r)/(2*a.r*sqrt(d));\n        double m2=(b.r*b.r+d-a.r*a.r)/(2*b.r*sqrt(d));\n        double s1=acos(m1)*a.r*a.r;\n        double s2=acos(m2)*b.r*b.r;\n        double s3=sqrt(d)*a.r*sin(acos(m1));\n        return s1+s2-s3;\n    }\n    return 0.0;\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n/********************************************************/\nint getCrossCS(Circle c,Line s,Point *cs){\n    Point tmp[2];\n    int cnt=0;\n    int ct=getCrossCL(c,s,tmp);\n    for(int i=0;i<ct;i++){\n        if(PointOnS(tmp[i],s)) cs[cnt++]=tmp[i];\n    }\n    return cnt;\n}\n\nPoint PinS(Point *cs,int n,Line s){\n    if(n==1) return cs[0];\n    if(length(cs[0]-s.a)>length(cs[1]-s.b)) return cs[1];\n    return cs[0];\n}\n\ndouble getAngle(Point a,Point b){\n    double tmp=dot(a,b)/length(a)/length(b);\n    if(tmp<-1.0) tmp=-1.0;\n    if(1.0<tmp) tmp=1.0;\n    return acos(tmp);\n}\n\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=fabs(cross(a-c.o,b-c.o)/2);\n    if(!dcmp(atc)) return 0.0;\n    double la=length(a-c.o),lb=length(b-c.o);\n    Point cs[4];\n    if(la<c.r+EPS&&lb>c.r-EPS){\n        int ct=getCrossCS(c,Line(a,b),cs);\n        Point p1=PinS(cs,ct,Line(a,b));\n        ct=getCrossCS(c,Line(c.o,b),cs);\n        Point p2=PinS(cs,ct,Line(c.o,b));\n        atc+=c.r*c.r*angleVV(p1-c.o,p2-c.o)/2;\n        atc-=fabs(cross(p1-c.o,p2-c.o)/2);\n        atc-=fabs(cross(p1-b,p2-b)/2);\n    }else if(la>c.r-EPS&&lb<c.r+EPS){\n        int ct=getCrossCS(c,Line(a,b),cs);\n        Point p1=PinS(cs,ct,Line(b,a));\n        ct=getCrossCS(c,Line(a,b),cs);\n        Point p2=PinS(cs,ct,Line(c.o,a));\n        atc+=c.r*c.r*angleVV(p1-c.o,p2-c.o)/2;\n        atc-=fabs(cross(p1-c.o,p2-c.o)/2);\n        atc-=fabs(cross(p1-a,p2-a)/2);\n    }else if(la>c.r-EPS&&lb>c.r-EPS){\n        if(distPS(c.o,Line(a,b))<c.r-EPS){\n            Point rt=root(c.o,Line(a,b));\n            atc=fabs(getAreaTC(a,rt,c))+fabs(getAreaTC(rt,b,c));\n        }else atc=c.r*c.r*angleVV(a-c.o,b-c.o)/2;\n    }\n    if(dcmp(cross(a-c.o,b-c.o))==1) atc=-atc;\n    return atc;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=getAreaTC(Pts[n-1],Pts[0],c);\n    for(int i=0;i<n-1;i++) apc+=getAreaTC(Pts[i],Pts[i+1],c);\n    return fabs(apc);\n}\n\n/********************************************************/\n\n\n/*----------------------三?点、?基本函数-----------------------------*/\n\nstruct Point3{\n    double x,y,z;\n    Point3(double x,double y,double z):x(x),y(y),z(z){}\n    Point3(){}\n    void Read(){ scanf(\"%lf%lf%lf\",&x,&y,&z); }\n};\n\nstruct Line3{\n    Point3 a,b;\n    Line3(Point3 a,Point3 b):a(a),b(b){}\n    Line3(){}\n    void Read(){ a.Read(); b.Read(); }\n};\nPoint3 operator +(Point3 a,Point3 b){ return Point3(a.x+b.x,a.y+b.y,a.z+b.z); }\nPoint3 operator -(Point3 a,Point3 b){ return Point3(a.x-b.x,a.y-b.y,a.z-b.z); }\ndouble operator *(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 operator *(Point3 a,double k){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator *(double k,Point3 a){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator /(Point3 a,double k){ return Point3(a.x/k,a.y/k,a.z/k); }\n\ndouble length(Point3 a){ return sqrt(a.x*a.x+a.y*a.y+a.z*a.z); }\nPoint3 unit(Point3 a){ return a/length(a); }\ndouble dot(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 cross(Point3 a,Point3 b){\n    return Point3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//混合?\ndouble Mix(Point3 a,Point3 b,Point3 c){\n    return dot(a,cross(b,c));\n}\n\n//?点距?\ndouble dist(const Point3 &a,const Point3 &b){ return length(a-b); }\n\n/*---------------------------------体?-------------------------------------*/\n\n//四面体体?\ndouble volume(double l,double n,double a,double m,double b,double c){\n    double x,y;\n    x=4*a*a*b*b*c*c-a*a*(b*b+c*c-m*m)*(b*b+c*c-m*m)-b*b*(c*c+a*a-n*n)*(c*c+a*a-n*n);\n    y=c*c*(a*a+b*b-l*l)*(a*a+b*b-l*l)-(a*a+b*b-l*l)*(b*b+c*c-m*m)*(c*c+a*a-n*n);\n    return sqrt(x-y)/12;\n}\n\ndouble volume(Point3 a,Point3 b,Point3 c,Point3 d){\n    return fabs(Mix(b-a,c-a,d-a)/6);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);//cin.tie(0);\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1.0);\nconst double EPS=1e-10;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-10;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n\nPoint root(Line l,Point p){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n\nint getCrossCS(Circle c,Line s,Point *cs){\n    Point tmp[2];\n    int cnt=0;\n    int ct=getCrossCL(c,s,tmp);\n    for(int i=0;i<ct;i++){\n        if(PointOnS(tmp[i],s)) cs[cnt++]=tmp[i];\n    }\n    return cnt;\n}\n\ndouble SectorArea(Point a,Point b,Circle c){\n    a=a-c.o,b=b-c.o;\n    double theta=atan2(a.y,a.x)-atan2(b.y,b.x);\n    while(dcmp(theta)<=0) theta+=2.0*PI;\n    while(dcmp(theta-2.0*PI)>0) theta-=2.0*PI;\n    theta=min(theta,2.0*PI-theta);\n    return c.r*c.r*theta*0.5;\n}\n\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=0.0;\n    Point OA=a-c.o,OB=b-c.o;\n    double la=length(OA),lb=length(OB);\n    Point cs[4];\n    bool aic=dcmp(la-c.r)<=0,bic=dcmp(lb-c.r)<=0;\n    int s=dcmp(cross(OA,OB));\n    if(!s) return 0.0;\n    if(aic){\n        if(bic){\n            atc=fabs(cross(OA,OB))*0.5;\n        }else{\n            int num=getCrossCS(c,Line(a,b),cs);\n            atc=SectorArea(cs[0],b,c)+fabs(cross(OA,cs[0]-c.o))*0.5;\n        }\n    }else{\n        if(bic){\n            int num=getCrossCS(c,Line(a,b),cs);\n            atc=SectorArea(cs[0],a,c)+fabs(cross(OB,cs[0]-c.o))*0.5;\n        }else{\n            int num=getCrossCS(c,Line(a,b),cs);\n            if(num==2){\n                if(distPP(a,cs[0])>distPP(a,cs[1])) swap(cs[0],cs[1]);\n                atc=SectorArea(a,cs[0],c)+SectorArea(b,cs[1],c)+fabs(cross(cs[0]-c.o,cs[1]-c.o))*0.5;\n            }else{\n                atc=SectorArea(a,b,c);\n            }\n        }\n    }\n    return 1.0*s*atc;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=getAreaTC(Pts[n-1],Pts[0],c);\n    for(int i=0;i<n-1;i++) apc+=getAreaTC(Pts[i],Pts[i+1],c);\n    return fabs(apc);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<200;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<200;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);cin.tie(0);\n    //cout<<getAreaTC(Point(3,3),Point(-3,3),Circle(Point(0,0),4))<<endl;\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1.0);\n//const double EPS=1e-10;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-13;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n\nPoint root(Line l,Point p){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n\ndouble mysqrt(double x){ return sqrt(max(0.0,x)); }\nint getCrossCS(Circle c,Line s,Point *ret){\n    double x0=c.o.x,y0=c.o.y;\n    double x1=s.a.x,y1=s.a.y;\n    double x2=s.b.x,y2=s.b.y;\n    double dx=x2-x1,dy=y2-y1;\n    double A=dx*dx+dy*dy;\n    double B=2.0*dx*(x1-x0)+2.0*dy*(y1-y0);\n    double C=(x1-x0)*(x1-x0)+(y1-y0)*(y1-y0)-c.r*c.r;\n    double delta=B*B-4.0*A*C;\n    int num=0;\n    if(dcmp(delta)>=0){\n        double t1=(-B-mysqrt(delta))/(2.0*A);\n        double t2=(-B+mysqrt(delta))/(2.0*A);\n        if(dcmp(t1-1)<=0&&dcmp(t1)>=0) ret[num++]=Point(x1+t1*dx,y1+t1*dy);\n        if(dcmp(t2-1)<=0&&dcmp(t2)>=0) ret[num++]=Point(x1+t2*dx,y1+t2*dy);\n        //如果没有if判断，?是求直?和?的交点\n    }\n    return num;\n}\ndouble SectorArea(Point a,Point b,Circle c){\n    a=a-c.o,b=b-c.o;\n    double theta=atan2(a.y,a.x)-atan2(b.y,b.x);\n    while(dcmp(theta)<=0) theta+=2.0*PI;\n    while(dcmp(theta-2.0*PI)>0) theta-=2.0*PI;\n    theta=min(theta,2.0*PI-theta);\n    return c.r*c.r*theta*0.5;\n}\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=0.0;\n    Point OA=a-c.o,OB=b-c.o;\n    double la=length(OA),lb=length(OB);\n    Point cs[4];\n    bool aic=dcmp(la-c.r)<=0,bic=dcmp(lb-c.r)<=0;\n    if(aic&&bic) return fabs(cross(OA,OB))*0.5;\n    int num=getCrossCS(c,Line(a,b),cs);\n    if(aic) return SectorArea(cs[0],b,c)+fabs(cross(OA,cs[0]-c.o))*0.5;\n    if(bic) return SectorArea(cs[0],a,c)+fabs(cross(OB,cs[0]-c.o))*0.5;\n    if(num==2) return SectorArea(a,cs[0],c)+\n        SectorArea(b,cs[1],c)+fabs(cross(cs[0]-c.o,cs[1]-c.o))*0.5;\n    return SectorArea(a,b,c);\n}\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=0.0;\n    for(int i=0;i<n;i++){\n        int s=dcmp(cross(Pts[i]-c.o,Pts[i+1]-c.o));\n        if(!!s) apc+=getAreaTC(Pts[i],Pts[i+1],c)*s;\n    }\n    return fabs(apc);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<200;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<200;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);cin.tie(0);\n    //cout<<getAreaTC(Point(3,3),Point(-3,3),Circle(Point(0,0),4))<<endl;\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "//writted by dnvtmf\n#include <bits/stdc++.h>\n#define INF 1000000007\n#define FI first\n#define SE second\n#define PB push_back\n#define VI vector<int>\n#define MP make_pair\n#define FOR(x, st, ed) for(auto x = (st); x < (ed); ++x)\n#define FORE(x, st, ed) for(auto x = (st); x <= (ed); ++x)\n#define CLR(arr, val) memset(arr, val, sizeof(arr))\n#define INFO(tag, st, ed, x) printf(\"%s: \", tag); \\\n  FOR(_i, st, ed) cout << x[_i] << ' '; puts(\"\");\nusing namespace std;\ntypedef long long LL;\ntypedef pair <int, int> PII;\nconst int NUM = 100010;\n\nconst double EPS = 1e-12;\ninline int sgn(double x) {if (x < -EPS)return -1; return x > EPS ? 1 : 0;}\ninline double sqr(double x) {return x * x;}\nstruct Point {\n  double x, y;\n  Point(double _x = 0.0, double _y = 0.0): x(_x), y(_y) {}\n  Point operator + (const Point &b)const {return Point(x + b.x, y + b.y);}//向量加法\n  Point operator - (const Point &b)const {return Point(x - b.x, y - b.y);}//向量?法\n  double operator * (const Point &b)const {return x * b.x + y * b.y;}//向量点?\n  double operator ^ (const Point &b)const {return x * b.y - y * b.x;} //向量叉?\n  Point operator * (double b) {return Point(x * b, y * b);}//?量乘法\n  Point rot(double ang) {return Point(x * cos(ang) - y * sin(ang), x * sin(ang) + y * cos(ang));}//旋?\n  double norm() {return sqrt(x * x + y * y);}//向量的模\n};\n//直? ?段定?\n//直?方程：?点式：@$(x_2 - x_1)(y - y_1) = (y_2 - y_1)(x - x_1)$@\nstruct Line {\n  Point s, e;\n  //double k;\n  Line() {}\n  Line(Point _s, Point _e) {\n    s = _s, e = _e;\n    //k = atan2(e.y - s.y, e.x - s.x);\n  }\n  //求?直?交点\n  //返回-1?直?重合, 0 相交, 1 平行\n  pair<int, Point> operator &(Line b) {\n    if (sgn((s - e) ^ (b.s - b.e)) == 0) {\n      if (sgn((s - b.e) ^ (b.s - b.e)) == 0) return make_pair(-1, s); //重合\n      else return make_pair(1, s);//平行\n    }\n    double t = ((s - b.s) ^ (b.s - b.e)) / ((s - e) ^ (b.s - b.e));\n    return make_pair(0, Point(s.x + (e.x - s.x) * t, s.y + (e.y - s.y) * t));\n  }\n};\n//求向量vA与vB的?角(<= PI)\ndouble angle(Point vA, Point vB) {\n  double tmp = vA.norm() * vB.norm();\n  if (sgn(tmp) != 0) return acos((vA * vB) / tmp);\n  else return 0.0;\n}\n\n//num表示?O(o, r)与?段(s, e)的交点数, res里存?的是交点\nvoid Circle_cross_Segment(Point s, Point e, Point o, double r, Point res[], int &num) {\n  double dx = e.x - s.x, dy = e.y - s.y;\n  double A = dx * dx + dy * dy;\n  double B = 2.0 * dx * (s.x - o.x) + 2.0 * dy * (s.y - o.y);\n  double C = sqr(s.x - o.x) + sqr(s.y - o.y) - r * r;\n  double delta = B * B - 4.0 * A * C;\n  num = 0;\n  if (sgn(delta) < 0) return ;\n  delta = sqrt(max(0.0, delta));\n  double k1 = (-B - delta) / (2.0 * A);\n  double k2 = (-B + delta) / (2.0 * A);\n  if (sgn(k1 - 1.0) <= 0 && sgn(k1) >= 0) //?与?段相交条件判断\n    res[num++] = Point(s.x + k1 * dx, s.y + k1 * dy);\n  if (sgn(k2 - 1.0) <= 0 && sgn(k2) >= 0)\n    res[num++] = Point(s.x + k2 * dx, s.y + k2 * dy);\n}\n\n//三角形ABO与?(O, r)的面?交\ndouble Triangel_cross_Circle(Point a, Point b, Point o, double r) {\n  double r2 = r * r;\n  a = a - o;\n  b = b - o;\n  o = Point(0.0, 0.0);\n  bool bAInC = sgn((a * a) - r2) < 0;\n  bool bBInC = sgn((b * b) - r2) < 0;\n  double sg = 0.5 * sgn(a ^ b), res = 0.0;\n  Point tmp[2];\n  int num;\n  if (bAInC && bBInC) res = abs(a ^ b);\n  else if (bAInC || bBInC) {\n    if (bBInC) swap(a, b);\n    Circle_cross_Segment(a, b, 0, r, tmp, num);\n    res = fabs(a ^ tmp[0]) + r2 * angle(tmp[0], b);\n  }\n  else {\n    Circle_cross_Segment(a, b, o, r, tmp, num);\n    res = r2 * angle(a, b);\n    if (num == 2) {\n      res -= r2 * angle(tmp[0], tmp[1]);\n      res += fabs(tmp[0] ^ tmp[1]);\n    }\n  }\n  return sg * res;\n}\n\n//多?形与?的面?交\ndouble Polygon_intersect_Circle(Point ploy[], int n, Point O, double r) {\n  ploy[n] = ploy[0];\n  double res = 0.0;\n  for (int i = 0; i < n; ++i)\n    res += Triangel_cross_Circle(ploy[i], ploy[i + 1], O, r);\n  return fabs(res);\n}\n\nint n, r;\nPoint ploy[20];\ninline double Rand() {return 2.0 * rand() / RAND_MAX - 1.0;}\nclock_t tic;\ndouble get_time() {\n  return 1.0 * (clock() - tic) / CLOCKS_PER_SEC;\n}\nvoid solve() {\n  double x = ploy[0].x, y = ploy[0].y, area = Polygon_intersect_Circle(ploy, n, {x, y}, r);\n  double best = area, bx = 0.0, by = 0.0;\n  double c = 10.;\n  for (int k = 0; get_time() < 4.9 && k < 10; ++k, c *= 0.1) {\n    x = bx, y = by, area = best;\n    double T = 100, T_decay = 0.95;\n    int tt = 0;\n    const int max_iter = 100000, chain_len = 30000;\n    for (int i = 0; get_time() < 4.9 && i < max_iter; ++i, T *= T_decay) {\n      for (int j = 0; get_time() < 4.9 && j < chain_len; ++j) {\n        double xx = x + c * Rand();\n        double yy = y + c * Rand();\n        double S = Polygon_intersect_Circle(ploy, n, {xx, yy}, r);\n        double deltaS = S - area;\n        if (deltaS > 0) {\n          x = xx;\n          y = yy;\n          area = S;\n          if (area > best) {\n            best = area;\n            tt = 0;\n          }\n          if(sgn(best - area) == 0) tt++;\n          if(tt > 100){\n            printf(\"%.10f\\n\", best);\n            return;\n          }\n        }\n      }\n    }\n  }\n  printf(\"%.10f\\n\", best);\n}\nint main() {\n#ifdef ACM_TEST\n  freopen(\"in.txt\", \"r\", stdin);\n#endif\n  tic = clock();\n  srand(time(0));\n  scanf(\"%d%d\", &n, &r);\n  for (int i = 0, x, y; i < n; ++i) {\n    scanf(\"%d%d\", &x, &y);\n    ploy[i] = Point(x, y);\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <list>\n\nusing namespace std;\n\n#define CVector CPoint\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\nconst LL mod=1e9+7;\nconst double PI=acos(-1.0);\nconst double EPS=1e-7;\nconst int INF=0x3f3f3f3f;\ninline int readint(){int sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\ninline LL readLL(){LL sum=0;char c=getchar();bool f=0;while(c<'0'||c>'9'){if(c=='-') f=1;c=getchar();}while(c>='0'&&c<='9'){sum=sum*10+c-'0';c=getchar();}if(f) return -sum;return sum;}\n\n/*----------------------精度控制--------------------------*/\n\nconst double eps=1e-7;\n//1:>0 0:=0 -1:<0\nint dcmp(double x){\n    if(fabs(x)<eps) return 0;\n    return x<0?-1:1;\n}\n\n/*------------------点、???体-------------------*/\n\nstruct Point{\n    double x,y;\n    Point(double x,double y):x(x),y(y){}\n    Point(){}\n    void Read(){ scanf(\"%lf%lf\",&x,&y); }\n    void Write(){ printf(\"%.10f %.10f\\n\",x,y); }\n    bool operator<(const Point &b) const{//水平序\n        if(!dcmp(x-b.x)) return y<b.y;\n        return x<b.x;\n    }\n    /*friend bool operator<(CPoint a,CPoint b){//?角排序\n        double tmp=cross(Pts[0],a,b);\n        if(isZero(tmp)){\n            return dist(Pts[0],a)<dist(Pts[0],b);\n        }\n        return tmp>0;\n    }*/\n};\n//a->b\nstruct Line{\n    Point a,b;\n    Line(Point a,Point b):a(a),b(b){}\n    Line(){}\n    void Read(){ a.Read(); b.Read(); }\n    void Write(){ a.Write(); b.Write(); }\n};\n\n/*---------------------点、?相?----------------------*/\nPoint operator +(Point a,Point b){ return Point(a.x+b.x,a.y+b.y); }\nPoint operator -(Point a,Point b){ return Point(a.x-b.x,a.y-b.y); }\nPoint operator *(Point a,double k){ return Point(k*a.x,k*a.y); }\nPoint operator *(double k,Point a){ return Point(k*a.x,k*a.y); }\ndouble operator *(Point a,Point b){ return a.x*b.x+a.y*b.y; }\nPoint operator /(Point a,double k){ return Point(a.x/k,a.y/k); }\ndouble operator ^(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n\ndouble cross(Point a,Point b){ return a.x*b.y-a.y*b.x; }\n//(b-a)^(c-a)\ndouble cross(Point a,Point b,Point c){ return cross(b-a,c-a); }\ndouble dot(Point a,Point b){ return a.x*b.x+a.y*b.y; }\n//(b-a)*(c-a)\ndouble dot(Point a,Point b,Point c){ return dot(b-a,c-a); }\n\ndouble length(Point p){ return sqrt(p*p); }\n//?位化\nPoint unit(Point p){ return 1.0/length(p)*p; }\n//求p在n方向上投影?度\ndouble project(Point p,Point n){ return p*unit(n); }\n//求a,b所?的有向面?\ndouble area(Point a,Point b){ return a^b*0.5; }\n\ndouble distPP(Point p,Point q){ return length(p-q); }\ndouble distPL(Point p,Line l){ return fabs((p-l.a)^(p-l.b))/length(l.a-l.b); }\ndouble distPS(Point p,Line s){\n    if(dot(s.b-s.a,p-s.a)<0.0) return length(p-s.a);\n    if(dot(s.a-s.b,p-s.b)<0.0) return length(p-s.b);\n    return distPL(p,s);\n}\n\n//b?a逆??旋?alpha后得到的点\nPoint rotateP(Point a,Point b,double alpha){\n    Point p=b-a;\n    return Point(a.x+(p.x*cos(alpha)-p.y*sin(alpha)),a.y+(p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//b?a逆??旋?alpha后得到的向量\nPoint rotateV(Point a,Point b,double alpha){\n    Point p=b-a;\n    return unit(Point(p.x*cos(alpha)-p.y*sin(alpha),p.x*sin(alpha)+p.y*cos(alpha)));\n}\n\n//0:online 1:left -1:right\nint sideOfL(Point p,Line l){\n    double res=(p-l.a)^(p-l.b);\n    return dcmp(res);\n}\n\n//求?p的l的垂?\nLine vertical(Point p,Line l){\n    return Line(p,p+rotateV(l.b,l.a,PI/2));\n}\n\n//垂足\nPoint root(Point p,Line l){\n    return l.a+project(p-l.a,l.b-l.a)*unit(l.b-l.a);\n}\n\n//?向量?角\ndouble angleVV(Point a,Point b){ return acos(project(a,b)/length(a)); }\n//?直??角\ndouble angleLL(Line l,Line m){\n    return acos(fabs(project(l.b-l.a,m.b-m.a)/length(l.b-l.a)));\n}\n\n//判断点p是否在?段ab上\nbool PointOnS(Point p,Line l){\n    return !dcmp(cross(p-l.a,l.b-l.a))&&dcmp((p-l.a)*(p-l.b))<=0;\n}\n\n//求直?交点\nPoint getCrossLL(Line l,Line m){\n    double t=cross(m.b-m.a,l.a-m.a)/cross(l.b-l.a,m.b-m.a);\n    return l.a+(l.b-l.a)*t;\n}\n\n//判断?段是否相交\nbool crossSS(Line l,Line m){\n    return sideOfL(l.a,m)*sideOfL(l.b,m)<=0&&sideOfL(m.a,l)*sideOfL(m.b,l)<=0;\n}\n\n/*----------------------多?形相?--------------------------*/\n\n//0:outside 1:inside 2:online\nint PointInPoly(Point t,Point *Pts,int n){\n    int num=0,d1,d2,k;\n    Pts[n]=Pts[0];\n    for(int i=0;i<n;i++){\n        if(PointOnS(t,Line(Pts[i],Pts[i+1]))) return 2;\n        k=dcmp(cross(Pts[i],Pts[i+1],t));\n        d1=dcmp(Pts[i].y-t.y);\n        d2=dcmp(Pts[i+1].y-t.y);\n        if(k>0&&d1<=0&&d2>0) num++;\n        if(k<0&&d2<=0&&d1>0) num--;\n    }\n    return num!=0;\n}\n\n//clockwise:>0 anticlockwise:<0\ndouble PolyArea(Point *Pts,int n){\n    double pa=area(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pa+=area(Pts[i],Pts[i+1]);\n    return pa;\n}\n\n//求任意多?形周?，需逆??或???排列\ndouble PolyPerimeter(Point *Pts,int n){\n    double pp=distPP(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) pp+=distPP(Pts[i],Pts[i+1]);\n    return pp;\n}\n\n//求多?形重心坐?\nPoint PolyCore(Point *Pts,int n){\n    double pa=PolyArea(Pts,n);\n    if(!dcmp(pa)) return Point(0,0);\n    Point ans=(Pts[n-1]+Pts[0])*cross(Pts[n-1],Pts[0]);\n    for(int i=0;i<n-1;i++) ans=ans+(Pts[i]+Pts[i+1])*cross(Pts[i],Pts[i+1]);\n    return ans/pa/6;\n}\n\n/*----------------------凸包----------------------------*/\n\n//Graham-scan st:anticlockwise\n//<=:strict <:Non-strict\nint Graham(Point *Pts,Point *st,int n){\n    if(n<3) return 0;\n    sort(Pts,Pts+n);\n    int m=0;\n    for(int i=0;i<n;i++){\n        while(m>1&&dcmp(cross(st[m-2],st[m-1],Pts[i]))<0) m--;\n        st[m++]=Pts[i];\n    }\n    int k=m;\n    for(int i=n-2;i>=0;i--){\n        while(m>k&&dcmp(cross(st[m-2],st[m-1],Pts[i])<0)) m--;\n        st[m++]=Pts[i];\n    }\n    return m-1;\n}\n\n//clockwise:> anticlockwise:<\ndouble CHDiameter(Point *Pts,int n,Line &l){\n    double maxd=0.0;\n    if(n<=1){\n        l.a=l.b=Pts[0];\n        return maxd;\n    }\n    for(int i=0,j=1;i<n;i++){\n        while(cross(Pts[i],Pts[(i+1)%n],Pts[j])\n              >cross(Pts[i],Pts[(i+1)%n],Pts[(j+1)%n])){\n            j=(j+1)%n;\n        }\n        double d=distPP(Pts[i],Pts[j]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n        d=distPP(Pts[(i+1)%n],Pts[(j+1)%n]);\n        if(dcmp(d-maxd)>=0){\n            maxd=d;\n            l.a=Pts[i];\n            l.b=Pts[j];\n        }\n    }\n    return maxd;\n}\n\n/*---------------------整点多?形---------------------------*/\n\nint gcd(int a,int b){\n    return b==0?a :gcd(b,a%b);\n}\n\n//整点多?形?界整点数\nint Border_Int_Point_Num(Point *Pts,int n){\n    int num=gcd(abs(int(Pts[0].x-Pts[n-1].x)),abs(int(Pts[0].y-Pts[n-1].y)));;\n    for(int i=0;i<n-1;i++){\n        num+=gcd(abs(int(Pts[i+1].x-Pts[i].x)),abs(int(Pts[i+1].y-Pts[i].y)));\n    }\n    return num;\n}\n\n//整点多?形内部整点数\nint Inside_Int_Point_Num(Point *Pts,int n){\n    return abs(int(PolyArea(Pts,n)))+1-Border_Int_Point_Num(Pts,n)/2;\n}\n\n/*-----------------------------半平面交-------------------------------*/\n\n//有方向的直?\n//p->p+v\nstruct Vector{\n    Point p,v;\n    double ang;\n    Vector(Point p,Point v):p(p),v(v){\n        ang=atan2(v.y,v.x);\n    }\n    Vector(){}\n    bool operator<(const Vector &l) const{\n        return ang<l.ang;\n    }\n};\n\n//判断点p是否在直?L左?\nbool onLeft(Vector L,Point p){\n    return cross(L.v,p-L.p)>0;\n}\n\n//得到a与b?直?的交点\nPoint getCrossVV(Vector a,Vector b){\n    Point u=a.p-b.p;\n    double t=cross(b.v,u)/cross(a.v,b.v);\n    return a.p+a.v*t;\n}\n\n//所有直?左半平面的交\nint HPCross(Vector *L,int n,Point *poly){\n    sort(L,L+n);\n    int f=0,l=0;\n    Point *p=new Point[n];\n    Vector *q=new Vector[n];\n    q[0]=L[0];\n    for(int i=1;i<n;i++){\n        while(f<l&&!onLeft(L[i],p[l-1])) l--;\n        while(f<l&&!onLeft(L[i],p[f])) f++;\n        q[++l]=L[i];\n        if(!dcmp(cross(q[l].v,q[l-1].v))){\n            l--;\n            if(onLeft(q[l],L[i].p)) q[l]=L[i];\n        }\n        if(f<l) p[l-1]=getCrossVV(q[l-1],q[l]);\n    }\n    while(f<l&&!onLeft(q[f],p[l-1])) l--;\n    if(l-f<=1) return 0;\n    p[l]=getCrossVV(q[l],q[f]);\n    int m=0;\n    for(int i=f;i<=l;i++) poly[m++]=p[i];\n    return m;\n}\n\n#define maxn 100005\nVector l[maxn];\nbool retract(Vector *L,int n,double r,Point *poly){\n    for(int i=0;i<n;i++){\n        Point v=rotateV(L[i].p,L[i].p+L[i].v,PI/2);\n        l[i]=Vector(L[i].p+r*v,L[i].v);\n    }\n    int cnt=HPCross(l,n,poly);\n    return cnt;\n}\n\n/*---------------------三角形相?---------------------------*/\n\n//三角形重心\n//到三?点距?的平方和最小的点\n//到三?距?之?最大的点\nPoint TCore(Point a,Point b,Point c){\n    return (a+b+c)/3;\n}\n\n//三角形外心\nPoint TCircum(Point a,Point b,Point c){\n    Point cp;\n    double a1=b.x-a.x;\n    double b1=b.y-a.y;\n    double a2=c.x-a.x;\n    double b2=c.y-a.y;\n    double c1=(a1*a1+b1*b1)/2;\n    double c2=(a2*a2+b2*b2)/2;\n    double d=a1*b2-a2*b1;\n    cp.x=a.x+(c1*b2-c2*b1)/d;\n    cp.y=a.y+(a1*c2-a2*c1)/d;\n    return cp;\n}\n\n//三角形垂心\nPoint TOrtho(Point a,Point b,Point c){\n    return TCore(a,b,c)*3.0-TCircum(a,b,c)*2.0;\n}\n\n//三角形内心\nPoint TInner(Point a,Point b,Point c){\n    Point cp;\n    double la=distPP(b,c),lb=distPP(c,a),lc=distPP(a,b);\n    cp.x=(la*a.x+lb*b.x+lc*c.x)/(la+lb+lc);\n    cp.y=(la*a.y+lb*b.y+lc*c.y)/(la+lb+lc);\n    return cp;\n}\n\n//求三角形面?\ndouble TArea(Point a,Point b,Point c){\n    return fabs(cross(a,b,c))/2;\n}\n\n/*-----------------------?相?-------------------------*/\n\nstruct Circle{\n    Point o; double r;\n    Circle(Point o,double r):o(o),r(r){}\n    Circle(){}\n    void Read(){ o.Read(); scanf(\"%lf\",&r); }\n    double area(){ return PI*r*r; }\n};\n\n//求??面?交\ndouble getAreaCC(Circle a,Circle b){\n    double d=(a.o.x-b.o.x)*(a.o.x-b.o.x)+(a.o.y-b.o.y)*(a.o.y-b.o.y);\n    if(d<=(a.r-b.r)*(a.r-b.r)){\n        return min(a.r,b.r)*min(a.r,b.r)*PI;\n    }else if(d>(a.r-b.r)*(a.r-b.r)&&d<(a.r+b.r)*(a.r+b.r)){\n        double m1=(a.r*a.r+d-b.r*b.r)/(2*a.r*sqrt(d));\n        double m2=(b.r*b.r+d-a.r*a.r)/(2*b.r*sqrt(d));\n        double s1=acos(m1)*a.r*a.r;\n        double s2=acos(m2)*b.r*b.r;\n        double s3=sqrt(d)*a.r*sin(acos(m1));\n        return s1+s2-s3;\n    }\n    return 0.0;\n}\n\nint getCrossCL(Circle c,Line l,Point *cl){\n    int fg=dcmp(distPL(c.o,l)-c.r);\n    int cnt=0;\n    if(!fg){\n        cl[cnt++]=root(c.o,l);\n    }else if(fg==-1){\n        Point rt=root(c.o,l);\n        double r=sqrt(c.r*c.r-(c.o-rt)*(c.o-rt));\n        cl[cnt++]=rt+r*unit(l.b-l.a);\n        cl[cnt++]=rt-r*unit(l.b-l.a);\n    }\n    return cnt;\n}\n/********************************************************/\nint getCrossCS(Circle c,Line s,Point *cs){\n    Point tmp[2];\n    int cnt=0;\n    int ct=getCrossCL(c,s,tmp);\n    for(int i=0;i<ct;i++){\n        if(PointOnS(tmp[i],s)) cs[cnt++]=tmp[i];\n    }\n    return cnt;\n}\n\nPoint PinS(Point *cs,int n,Line s){\n    if(n==1) return cs[0];\n    if(!dcmp(cs[0].x-s.a.x)&&!dcmp(cs[0].y-s.a.y)) return cs[1];\n    return cs[0];\n}\n\ndouble getAngle(Point a,Point b){\n    double tmp=unit(a)*unit(b);\n    if(tmp<-1.0) tmp=-1.0;\n    if(1.0<tmp) tmp=1.0;\n    return acos(tmp);\n}\n\ndouble getAreaTC(Point a,Point b,Circle c){\n    double atc=fabs(cross(a-c.o,b-c.o)/2);\n    if(!dcmp(atc)) return 0.0;\n    double la=length(a-c.o),lb=length(b-c.o);\n    Point cs[4];\n    if(la<c.r+EPS&&lb>c.r-EPS){\n        int ct=getCrossCS(c,Line(a,b),cs);\n        Point p=PinS(cs,ct,Line(a,b));\n        atc+=c.r*c.r*getAngle(p-c.o,b-c.o)/2;\n        atc-=fabs(cross(p-c.o,b-c.o)/2);\n    }else if(la>c.r-EPS&&lb<c.r+EPS){\n        int ct=getCrossCS(c,Line(a,b),cs);\n        Point p=PinS(cs,ct,Line(b,a));\n        atc+=c.r*c.r*getAngle(p-c.o,a-c.o)/2;\n        atc-=fabs(cross(p-c.o,a-c.o)/2);\n    }else if(la>c.r-EPS&&lb>c.r-EPS){\n        if(distPS(c.o,Line(a,b))<c.r-EPS){\n            Point rt=root(c.o,Line(a,b));\n            atc=fabs(getAreaTC(a,rt,c))+fabs(getAreaTC(rt,b,c));\n        }else atc=c.r*c.r*getAngle(a-c.o,b-c.o)/2;\n    }\n    if(dcmp(cross(a-c.o,b-c.o))==1) atc=-atc;\n    return atc;\n}\n\ndouble getAreaPC(Point *Pts,int n,Circle c){\n    double apc=getAreaTC(Pts[n-1],Pts[0],c);\n    for(int i=0;i<n-1;i++) apc+=getAreaTC(Pts[i],Pts[i+1],c);\n    return fabs(apc);\n}\n\n/********************************************************/\n\n\n/*----------------------三?点、?基本函数-----------------------------*/\n\nstruct Point3{\n    double x,y,z;\n    Point3(double x,double y,double z):x(x),y(y),z(z){}\n    Point3(){}\n    void Read(){ scanf(\"%lf%lf%lf\",&x,&y,&z); }\n};\n\nstruct Line3{\n    Point3 a,b;\n    Line3(Point3 a,Point3 b):a(a),b(b){}\n    Line3(){}\n    void Read(){ a.Read(); b.Read(); }\n};\nPoint3 operator +(Point3 a,Point3 b){ return Point3(a.x+b.x,a.y+b.y,a.z+b.z); }\nPoint3 operator -(Point3 a,Point3 b){ return Point3(a.x-b.x,a.y-b.y,a.z-b.z); }\ndouble operator *(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 operator *(Point3 a,double k){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator *(double k,Point3 a){ return Point3(a.x*k,a.y*k,a.z*k); }\nPoint3 operator /(Point3 a,double k){ return Point3(a.x/k,a.y/k,a.z/k); }\n\ndouble length(Point3 a){ return sqrt(a.x*a.x+a.y*a.y+a.z*a.z); }\nPoint3 unit(Point3 a){ return a/length(a); }\ndouble dot(Point3 a,Point3 b){ return a.x*b.x+a.y*b.y+a.z*b.z; }\nPoint3 cross(Point3 a,Point3 b){\n    return Point3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\n//混合?\ndouble Mix(Point3 a,Point3 b,Point3 c){\n    return dot(a,cross(b,c));\n}\n\n//?点距?\ndouble dist(const Point3 &a,const Point3 &b){ return length(a-b); }\n\n/*---------------------------------体?-------------------------------------*/\n\n//四面体体?\ndouble volume(double l,double n,double a,double m,double b,double c){\n    double x,y;\n    x=4*a*a*b*b*c*c-a*a*(b*b+c*c-m*m)*(b*b+c*c-m*m)-b*b*(c*c+a*a-n*n)*(c*c+a*a-n*n);\n    y=c*c*(a*a+b*b-l*l)*(a*a+b*b-l*l)-(a*a+b*b-l*l)*(b*b+c*c-m*m)*(c*c+a*a-n*n);\n    return sqrt(x-y)/12;\n}\n\ndouble volume(Point3 a,Point3 b,Point3 c,Point3 d){\n    return fabs(Mix(b-a,c-a,d-a)/6);\n}\n\n#define MAXN 15\nPoint Pts[MAXN];\nint n;\ndouble R,minx,miny,maxx,maxy;\n\ndouble sanfeny(double x){\n    double l=miny,r=maxy;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(getAreaPC(Pts,n,Circle(Point(x,m1),R))<getAreaPC(Pts,n,Circle(Point(x,m2),R))){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return getAreaPC(Pts,n,Circle(Point(x,l),R));\n}\n\ndouble sanfenx(){\n    double l=minx,r=maxx;\n    double m1,m2;\n    for(int i=0;i<100;i++){\n        m1=(l+l+r)/3;\n        m2=(l+r+r)/3;\n        if(sanfeny(m1)<sanfeny(m2)){\n            l=m1;\n        }else{\n            r=m2;\n        }\n    }\n    return sanfeny(l);\n}\n\nint main(){ios_base::sync_with_stdio(0);//cin.tie(0);\n    minx=miny=1000;\n    maxx=maxy=0;\n    cin>>n>>R;\n    for(int i=1;i<=n;i++){\n        cin>>Pts[n-i].x>>Pts[n-i].y;\n        minx=min(minx,Pts[n-i].x);\n        miny=min(miny,Pts[n-i].y);\n        maxx=max(maxx,Pts[n-i].x);\n        maxy=max(maxy,Pts[n-i].y);\n    }\n    Pts[n]=Pts[0];\n    double maans=sanfenx();\n    cout.setf(ios::fixed);\n    cout<<fixed<<setprecision(10)<<maans<<endl;\n    return 0;\n}\n\n//cout.setf(ios::fixed);\n//cout<<fixed<<setprecision(10)<<s<<endl;"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n  \nusing namespace std;\n#define x1 jkflwjjkfjekjfe\n#define x2 fwekwfefekfje\n  \nint iter = log(100 * 100 * 10000) / log(3) + 20;\ntypedef complex<double> P;\nstruct L{\n    P a,b;\n};\nvector<double> ax,ay;\nvector<L> ls;\ndouble R,cx,cy;\n  \nbool eq(double a,double b){\n    return fabs(a-b) < 1e-7;\n}\nbool eq2(double a,double b){\n    return fabs(a-b) < 1e-8;\n}\n  \npair<double,double> seg(double y){\n    double x1 = +1e5;\n    double x2 = -1e5;\n    for( auto &&l : ls){\n        if( eq(l.a.imag(),y) ){\n            x1 = min(x1,l.a.real());\n            x2 = max(x2,l.a.real());\n        }\n        if( eq(l.b.imag(),y) ){\n            x1 = min(x1,l.b.real());\n            x2 = max(x2,l.b.real());\n        }\n        if( l.a.imag() + 1e-7 < y and y < l.b.imag() - 1e-7 ){\n            P v = (l.b - l.a);\n            P p = l.a + v * (y-l.a.imag()) / v.imag();\n            x1 = min(x1,p.real());\n            x2 = max(x2,p.real());  \n        }\n    }\n    return {x1,x2};\n}\n  \ndouble len(pair<double,double> p){\n    if( p.first < p.second ) return p.second - p.first;\n    return 0;\n}\npair<double,double> merge(const pair<double,double> &a,const pair<double,double> &b){\n    return {max(a.first,b.first),min(a.second,b.second)};\n}\nmap<double,double> mp;\ndouble g(double y){\n\tif( mp.count(y) ) return mp[y];\n    if( R - abs(y-cy) < 1e-7 ) return 0;\n    // for given y, compute the overlapped length of the circle and the polygon.\n    double t = sqrt(R*R-(cy-y)*(cy-y));\n    pair<double,double> circle_seg = {cx-t,cx+t};\n    return mp[y] = len(merge(circle_seg,seg(y)));\n}\n  \ndouble simpson(double l,double r){\n    return (r-l)/6*(g(l)+4*g((l+r)/2)+g(r));\n}\ndouble integral(double l,double r,int k=5){\n    if( l >= r ) return 0;\n\tdouble m = (l+r)/2;\n\t\n\t\n    double A = simpson(l,m) + simpson(m,r);\n    double B = simpson(l,r);\n    if( k<=0 and eq2(A,B) ) return A;\n    else return integral(l,m,k-1) + integral(m,r,k-1);\n}\n  \ndouble f(double x,double y){\n    cx = x;\n    cy = y;\n    mp.clear();\n    double ans = 0;\n    for(int i = 0 ; i+1 < ay.size() ; i++){\n        ans += integral(max(cy-R,ay[i]),min(cy+R,ay[i+1]));\n    }\n \n    return ans;\n}\n         \ndouble search2(double y){\n    double ans = 0;\n    double l,r;\n  \n    tie(l,r) = seg(y);\n  \n    for(int i = 0 ; i < iter ; i++){\n        double a = (2*l+r) / 3;\n        double b = (l+2*r) / 3;\n        if( f(a,y) < f(b,y) ){\n            l = a;\n        }else{\n            r = b;\n        }\n    }\n    return f(l,y);\n}\n  \ndouble search1(){\n    double ans = 0;\n    double l = ay.front(), r = ay.back();\n    for(int i = 0 ; i < iter ; i++){\n        double a = (2*l+r) / 3;\n        double b = (l+2*r) / 3;\n        if( search2(a) < search2(b) ){\n            l = a;\n        }else{\n            r = b;\n        }\n    }\n     \n    return search2(l);\n}\n  \nint main(){\n    int n;\n    cin >> n >> R;\n    vector<P> g(n+1);\n    for(int i = 0 ; i < n ; i++){\n        double x,y;\n        cin >> x >> y;\n        g[i] = P(x,y);\n        ax.push_back(x);\n        ay.push_back(y);\n    }\n    g[n] = g[0];\n      \n    for(int i = 0 ; i < n ; i++){\n        ls.push_back({g[i],g[i+1]});\n        if( ls.back().a.imag() > ls.back().b.imag() ) swap(ls.back().a,ls.back().b);\n    }\n \n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    //printf(\"%.10lf\\n\",f(0,0));\n    //return 0;\n     \n    printf(\"%.10lf\\n\",search1());\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <map>\n \nusing namespace std;\n#define x1 jkflwjjkfjekjfe\n#define x2 fwekwfefekfje\n \nint iter = log(100 * 100 * 10000) / log(3) + 20;\ntypedef complex<double> P;\nstruct L{\n    P a,b;\n};\nvector<double> ax,ay;\nvector<L> ls;\ndouble R,cx,cy;\n \nbool eq(double a,double b){\n    return fabs(a-b) < 1e-7;\n}\nbool eq2(double a,double b){\n    return fabs(a-b) < 1e-8;\n}\n \npair<double,double> seg(double y){\n    double x1 = +1e5;\n    double x2 = -1e5;\n    for( auto &&l : ls){\n        if( eq(l.a.imag(),y) ){\n            x1 = min(x1,l.a.real());\n            x2 = max(x2,l.a.real());\n        }\n        if( eq(l.b.imag(),y) ){\n            x1 = min(x1,l.b.real());\n            x2 = max(x2,l.b.real());\n        }\n        if( l.a.imag() + 1e-7 < y and y < l.b.imag() - 1e-7 ){\n            P v = (l.b - l.a);\n            P p = l.a + v * (y-l.a.imag()) / v.imag();\n            x1 = min(x1,p.real());\n            x2 = max(x2,p.real());  \n        }\n    }\n    return {x1,x2};\n}\n \ndouble len(pair<double,double> p){\n    if( p.first < p.second ) return p.second - p.first;\n    return 0;\n}\npair<double,double> merge(const pair<double,double> &a,const pair<double,double> &b){\n    return {max(a.first,b.first),min(a.second,b.second)};\n}\n \ndouble g(double y){\n    if( R - abs(y-cy) < 1e-7 ) return 0;\n    // for given y, compute the overlapped length of the circle and the polygon.\n    double t = sqrt(R*R-(cy-y)*(cy-y));\n    pair<double,double> circle_seg = {cx-t,cx+t};\n    return len(merge(circle_seg,seg(y)));\n}\n \ndouble simpson(double l,double r){\n    return (r-l)/6*(g(l)+4*g((l+r)/2)+g(r));\n}\ndouble integral(double l,double r){\n    if( l >= r ) return 0;\n \n    double m = (l+r) / 2;\n    double A = simpson(l,m) + simpson(m,r);\n    double B = simpson(l,r);\n    if( eq2(A,B) ) return A;\n    else return integral(l,m) + integral(m,r);\n}\n \ndouble f(double x,double y){\n    cx = x;\n    cy = y;\n    double ans = 0;\n    for(int i = 0 ; i+1 < ay.size() ; i++){\n        ans += integral(max(cy-R,ay[i]),min(cy+R,ay[i+1]));\n    }\n    return ans;\n}\n \ndouble search2(double y){\n    double ans = 0;\n    double l,r;\n \n    tie(l,r) = seg(y);\n \n    for(int i = 0 ; i < iter ; i++){\n        double a = (2*l+r) / 3;\n        double b = (l+2*r) / 3;\n        if( f(a,y) < f(b,y) ){\n            l = a;\n        }else{\n            r = b;\n        }\n    }\n    return f(l,y);\n}\n \ndouble search1(){\n    double ans = 0;\n    double l = ay.front(), r = ay.back();\n    for(int i = 0 ; i < iter ; i++){\n        double a = (2*l+r) / 3;\n        double b = (l+2*r) / 3;\n        if( search2(a) < search2(b) ){\n            l = a;\n        }else{\n            r = b;\n        }\n    }\n    return search2(l);\n}\n \nint main(){\n    int n;\n    cin >> n >> R;\n    vector<P> g(n+1);\n    for(int i = 0 ; i < n ; i++){\n        double x,y;\n        cin >> x >> y;\n        g[i] = P(x,y);\n        ax.push_back(x);\n        ay.push_back(y);\n    }\n    g[n] = g[0];\n     \n    for(int i = 0 ; i < n ; i++){\n        ls.push_back({g[i],g[i+1]});\n        if( ls.back().a.imag() > ls.back().b.imag() ) swap(ls.back().a,ls.back().b);\n    }\n \n    sort(ax.begin(),ax.end());\n    sort(ay.begin(),ay.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    printf(\"%.10lf\\n\",search1());\n \n}"
  },
  {
    "language": "Python",
    "code": "from math import sqrt, atan2\ndef intersection01(cx, cy, r, x1, y1, x2, y2):\n    xd = x2 - x1; yd = y2 - y1\n    X = x1 - cx; Y = y1 - cy\n    a = xd**2 + yd**2\n    b = xd * X + yd * Y\n    c = X**2 + Y**2 - r**2\n    D = b**2 - a*c\n    result = []\n    if D > 0:\n        d = sqrt(D)\n        if 0 < -b - d < a:\n            s = (-b - d) / a\n            result.append((x1 + xd*s, y1 + yd*s))\n        if 0 < -b + d < a:\n            s = (-b + d) / a\n            result.append((x1 + xd*s, y1 + yd*s))\n    elif D == 0:\n        if 0 < -b < a:\n            s = -b / a\n            result.append((x1 + xd*s, y1 + yd*s))\n    return result\ndef calc(x0, y0, x1, y1, rr):\n    if x0**2 + y0**2 - rr <= 1e-8 and x1**2 + y1**2 - rr <= 1e-8:\n        return (x0 * y1 - x1 * y0) / 2.\n    theta = atan2(x0*y1 - x1*y0, x0*x1 + y0*y1)\n    return theta*rr/2.\n\nn, r = map(int, input().split())\nP = [list(map(int, input().split())) for i in range(n)]\n\nrr = r**2\ndef solve(xb, yb):\n    ans = 0\n    for i in range(n):\n        x0, y0 = P[i-1]; x1, y1 = P[i]\n        x0 -= xb; y0 -= yb\n        x1 -= xb; y1 -= yb\n        result = intersection01(0, 0, r, x0, y0, x1, y1)\n        px = x0; py = y0\n        for x, y in result:\n            ans += calc(px, py, x, y, rr)\n            px = x; py = y\n        ans += calc(px, py, x1, y1, rr)\n    return ans\n\nx0 = sum(x for x, y in P)/n\ny0 = sum(y for x, y in P)/n\nans = solve(x0, y0)\nimport random\nrandom.seed()\nrandint = random.randint\nfor i in range(1000):\n    ma = ans; nxt = None\n    for j in range(100):\n        dx = randint(-1000000, 1000000) / 10000 / (i+1)\n        dy = randint(-1000000, 1000000) / 10000 / (i+1)\n        res = solve(x0 + dx, y0 + dy)\n        if ma < res:\n            ma = res\n            nxt = (x0 + dx, y0 + dy)\n    if nxt is not None:\n        ans = ma\n        x0, y0 = nxt\nprint(ans)"
  }
]