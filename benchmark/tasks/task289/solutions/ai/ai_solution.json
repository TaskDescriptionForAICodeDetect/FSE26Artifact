[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point p;\n    double r;\n} Disk;\n\ndouble distance(Point a, Point b) {\n    double dx = a.x - b.x;\n    double dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n}\n\ndouble cross(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ndouble dot(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.x - a.x) + (b.y - a.y) * (c.y - a.y);\n}\n\ndouble point_to_segment_distance(Point p, Point a, Point b) {\n    if (distance(a, b) < 1e-8) return distance(p, a);\n    if (dot(a, b, p) < 0) return distance(p, a);\n    if (dot(b, a, p) < 0) return distance(p, b);\n    return fabs(cross(a, b, p)) / distance(a, b);\n}\n\ndouble area_of_intersection(Disk disk, Point* polygon, int n) {\n    double area = 0.0;\n    for (int i = 0; i < n; i++) {\n        Point a = polygon[i];\n        Point b = polygon[(i + 1) % n];\n        double d = point_to_segment_distance(disk.p, a, b);\n        if (d >= disk.r) continue;\n        double theta = 2 * acos(d / disk.r);\n        area += 0.5 * disk.r * disk.r * (theta - sin(theta));\n    }\n    return area;\n}\n\nvoid find_max_intersection(Point* polygon, int n, double r, Point* best_center, double* max_area) {\n    double step = r / 10.0;\n    *max_area = -1.0;\n    \n    double min_x = polygon[0].x, max_x = polygon[0].x;\n    double min_y = polygon[0].y, max_y = polygon[0].y;\n    for (int i = 1; i < n; i++) {\n        if (polygon[i].x < min_x) min_x = polygon[i].x;\n        if (polygon[i].x > max_x) max_x = polygon[i].x;\n        if (polygon[i].y < min_y) min_y = polygon[i].y;\n        if (polygon[i].y > max_y) max_y = polygon[i].y;\n    }\n    \n    for (double x = min_x - r; x <= max_x + r; x += step) {\n        for (double y = min_y - r; y <= max_y + r; y += step) {\n            Disk disk = {{x, y}, r};\n            double area = area_of_intersection(disk, polygon, n);\n            if (area > *max_area) {\n                *max_area = area;\n                best_center->x = x;\n                best_center->y = y;\n            }\n        }\n    }\n}\n\nint main() {\n    int n;\n    double r;\n    scanf(\"%d %lf\", &n, &r);\n    \n    Point polygon[100];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &polygon[i].x, &polygon[i].y);\n    }\n    \n    Point best_center;\n    double max_area;\n    find_max_intersection(polygon, n, r, &best_center, &max_area);\n    \n    printf(\"Best center: (%.6lf, %.6lf)\\n\", best_center.x, best_center.y);\n    printf(\"Max intersection area: %.6lf\\n\", max_area);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:56:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    Point operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n    Point operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n    Point operator*(double c) const { return Point(x * c, y * c); }\n    Point operator/(double c) const { return Point(x / c, y / c); }\n    double cross(const Point &p) const { return x * p.y - y * p.x; }\n    double dot(const Point &p) const { return x * p.x + y * p.y; }\n    double norm() const { return sqrt(x * x + y * y); }\n};\n\ndouble polygonArea(const vector<Point> &poly) {\n    double area = 0;\n    int n = poly.size();\n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        area += poly[i].cross(poly[j]);\n    }\n    return fabs(area) / 2;\n}\n\ndouble segmentPointDistance(const Point &a, const Point &b, const Point &p) {\n    Point ab = b - a, ap = p - a;\n    double t = ap.dot(ab) / ab.dot(ab);\n    if (t < 0) t = 0;\n    if (t > 1) t = 1;\n    Point proj = a + ab * t;\n    return (p - proj).norm();\n}\n\nPoint centroid(const vector<Point> &poly) {\n    Point c(0, 0);\n    double area = 0;\n    int n = poly.size();\n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        double cross = poly[i].cross(poly[j]);\n        c.x += (poly[i].x + poly[j].x) * cross;\n        c.y += (poly[i].y + poly[j].y) * cross;\n        area += cross;\n    }\n    return c / (3 * area);\n}\n\ndouble maxIntersectionArea(const vector<Point> &poly, double r) {\n    double area = 0;\n    int n = poly.size();\n    Point center = centroid(poly);\n    \n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        Point a = poly[i], b = poly[j];\n        double d = segmentPointDistance(a, b, center);\n        if (d >= r) continue;\n        \n        double theta = 2 * acos(d / r);\n        area += 0.5 * r * r * (theta - sin(theta));\n    }\n    \n    double polyArea = polygonArea(poly);\n    if (area > polyArea) area = polyArea;\n    \n    return area;\n}\n\ndouble findOptimalRadius(const vector<Point> &poly, double maxR) {\n    double low = 0, high = maxR;\n    for (int iter = 0; iter < 100; ++iter) {\n        double mid1 = low + (high - low) / 3;\n        double mid2 = high - (high - low) / 3;\n        double area1 = maxIntersectionArea(poly, mid1);\n        double area2 = maxIntersectionArea(poly, mid2);\n        if (area1 < area2) {\n            low = mid1;\n        } else {\n            high = mid2;\n        }\n    }\n    return (low + high) / 2;\n}\n\nint main() {\n    int n;\n    double r;\n    cin >> n >> r;\n    vector<Point> poly(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> poly[i].x >> poly[i].y;\n    }\n    \n    double maxR = 0;\n    Point center = centroid(poly);\n    for (const Point &p : poly) {\n        double dist = (p - center).norm();\n        if (dist > maxR) maxR = dist;\n    }\n    maxR += r;\n    \n    double optimalR = findOptimalRadius(poly, maxR);\n    double maxArea = maxIntersectionArea(poly, optimalR);\n    \n    cout << fixed << setprecision(10) << maxArea << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 20:57:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main {\n    static final double EPS = 1e-9;\n\n    static class Point {\n        double x, y;\n        Point(double x, double y) { this.x = x; this.y = y; }\n    }\n\n    static double dist(Point a, Point b) {\n        return Math.hypot(a.x - b.x, a.y - b.y);\n    }\n\n    static Point[] convexHull(Point[] points) {\n        if (points.length <= 1) return points;\n        Arrays.sort(points, (a, b) -> Double.compare(a.x, b.x) != 0 ? Double.compare(a.x, b.x) : Double.compare(a.y, b.y));\n        Point[] hull = new Point[points.length * 2];\n        int k = 0;\n        for (Point p : points) {\n            while (k >= 2 && cross(hull[k-2], hull[k-1], p) <= 0) k--;\n            hull[k++] = p;\n        }\n        for (int i = points.length - 2, t = k + 1; i >= 0; i--) {\n            Point p = points[i];\n            while (k >= t && cross(hull[k-2], hull[k-1], p) <= 0) k--;\n            hull[k++] = p;\n        }\n        return Arrays.copyOf(hull, k - 1);\n    }\n\n    static double cross(Point a, Point b, Point c) {\n        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    }\n\n    static double polygonArea(Point[] points) {\n        double area = 0;\n        for (int i = 0; i < points.length; i++) {\n            int j = (i + 1) % points.length;\n            area += points[i].x * points[j].y - points[j].x * points[i].y;\n        }\n        return Math.abs(area) / 2;\n    }\n\n    static Point[] polygon;\n    static double R;\n\n    static double f(Point c) {\n        Path2D poly = new Path2D.Double();\n        poly.moveTo(polygon[0].x, polygon[0].y);\n        for (int i = 1; i < polygon.length; i++) {\n            poly.lineTo(polygon[i].x, polygon[i].y);\n        }\n        poly.closePath();\n\n        Area circle = new Area(new Ellipse2D.Double(c.x - R, c.y - R, 2 * R, 2 * R));\n        Area intersection = new Area(poly);\n        intersection.intersect(circle);\n\n        PathIterator it = intersection.getPathIterator(null);\n        double[] coords = new double[6];\n        List<Point> points = new ArrayList<>();\n        while (!it.isDone()) {\n            int type = it.currentSegment(coords);\n            if (type != PathIterator.SEG_CLOSE) {\n                points.add(new Point(coords[0], coords[1]));\n            }\n            it.next();\n        }\n\n        if (points.isEmpty()) return 0;\n        Point[] intersectionPoints = points.toArray(new Point[0]);\n        return polygonArea(convexHull(intersectionPoints));\n    }\n\n    static Point ternarySearch(Point a, Point b) {\n        Point left = a, right = b;\n        for (int i = 0; i < 100; i++) {\n            Point m1 = new Point((2 * left.x + right.x) / 3, (2 * left.y + right.y) / 3);\n            Point m2 = new Point((left.x + 2 * right.x) / 3, (left.y + 2 * right.y) / 3);\n            if (f(m1) < f(m2)) {\n                left = m1;\n            } else {\n                right = m2;\n            }\n        }\n        return new Point((left.x + right.x) / 2, (left.y + right.y) / 2);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        R = sc.nextDouble();\n        Point[] points = new Point[N];\n        for (int i = 0; i < N; i++) {\n            points[i] = new Point(sc.nextDouble(), sc.nextDouble());\n        }\n        polygon = convexHull(points);\n\n        Point best = null;\n        double maxArea = -1;\n        for (int i = 0; i < polygon.length; i++) {\n            for (int j = i + 1; j < polygon.length; j++) {\n                Point candidate = ternarySearch(polygon[i], polygon[j]);\n                double area = f(candidate);\n                if (area > maxArea) {\n                    maxArea = area;\n                    best = candidate;\n                }\n            }\n        }\n\n        System.out.printf(\"%.10f\\n\", maxArea);\n    }\n}",
    "timestamp": "2025-08-05 20:58:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\nclass PolygonDiskCoverage {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static double polygonDiskMaxCoverage(Point[] polygon) {\n        int n = polygon.length;\n        double maxArea = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                for (int k = j + 1; k < n; k++) {\n                    Point center = findCircumcenter(polygon[i], polygon[j], polygon[k]);\n                    double radius = distance(center, polygon[i]);\n                    \n                    double area = calculateIntersectionArea(polygon, center, radius);\n                    maxArea = Math.max(maxArea, area);\n                }\n            }\n        }\n        return maxArea;\n    }\n\n    static Point findCircumcenter(Point a, Point b, Point c) {\n        double d = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));\n        double ux = ((a.x * a.x + a.y * a.y) * (b.y - c.y) + \n                     (b.x * b.x + b.y * b.y) * (c.y - a.y) + \n                     (c.x * c.x + c.y * c.y) * (a.y - b.y)) / d;\n        double uy = ((a.x * a.x + a.y * a.y) * (c.x - b.x) + \n                     (b.x * b.x + b.y * b.y) * (a.x - c.x) + \n                     (c.x * c.x + c.y * c.y) * (b.x - a.x)) / d;\n        return new Point(ux, uy);\n    }\n\n    static double calculateIntersectionArea(Point[] polygon, Point center, double radius) {\n        List<Point> intersectionPoints = new ArrayList<>();\n        for (int i = 0; i < polygon.length; i++) {\n            Point p1 = polygon[i];\n            Point p2 = polygon[(i + 1) % polygon.length];\n            \n            Point[] lineCircleIntersections = lineCircleIntersection(p1, p2, center, radius);\n            for (Point p : lineCircleIntersections) {\n                if (isPointInPolygon(p, polygon) && isPointInDisk(p, center, radius)) {\n                    intersectionPoints.add(p);\n                }\n            }\n        }\n        \n        // Compute the intersection area using polygon or triangulation method\n        return computeArea(intersectionPoints);\n    }\n\n    static Point[] lineCircleIntersection(Point p1, Point p2, Point center, double radius) {\n        // Implement line-circle intersection calculation\n        return new Point[0];\n    }\n\n    static boolean isPointInPolygon(Point p, Point[] polygon) {\n        // Implement point-in-polygon check using ray casting\n        return false;\n    }\n\n    static boolean isPointInDisk(Point p, Point center, double radius) {\n        return distance(p, center) <= radius;\n    }\n\n    static double distance(Point a, Point b) {\n        return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n    }\n\n    static double computeArea(List<Point> points) {\n        // Implement area computation for intersection points\n        return 0.0;\n    }\n\n    public static void main(String[] args) {\n        Point[] polygon = {\n            new Point(0, 0),\n            new Point(0, 1),\n            new Point(1, 1),\n            new Point(1, 0)\n        };\n        \n        double maxCoverage = polygonDiskMaxCoverage(polygon);\n        System.out.println(\"Maximum Coverage: \" + maxCoverage);\n    }\n}",
    "timestamp": "2025-08-05 20:58:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAX_POINTS 1000\n#define EPS 1e-9\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble cross_product(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ndouble distance(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble polygon_area(Point polygon[], int n) {\n    double area = 0;\n    for (int i = 1; i < n - 1; i++) {\n        area += cross_product(polygon[0], polygon[i], polygon[i+1]) / 2.0;\n    }\n    return fabs(area);\n}\n\ndouble disk_polygon_intersection(Point center, double radius, Point polygon[], int n) {\n    double area = 0;\n    for (int i = 0; i < n; i++) {\n        Point a = polygon[i], b = polygon[(i + 1) % n];\n        double dist_a = distance(center, a);\n        double dist_b = distance(center, b);\n\n        if (dist_a <= radius && dist_b <= radius) {\n            area += fabs(cross_product(center, a, b) / 2.0);\n        } else if (dist_a <= radius || dist_b <= radius) {\n            // Partial coverage segment calculation\n            // Implement complex geometric calculations here\n        }\n    }\n    return area;\n}\n\ndouble solve_max_disk_coverage(Point polygon[], int n) {\n    double max_intersection = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            Point center = {\n                (polygon[i].x + polygon[j].x) / 2.0,\n                (polygon[i].y + polygon[j].y) / 2.0\n            };\n            double radius = distance(polygon[i], polygon[j]) / 2.0;\n\n            double intersection = disk_polygon_intersection(center, radius, polygon, n);\n            max_intersection = fmax(max_intersection, intersection);\n        }\n    }\n    return max_intersection;\n}\n\nint main() {\n    int n;\n    Point polygon[MAX_POINTS];\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &polygon[i].x, &polygon[i].y);\n    }\n\n    double result = solve_max_disk_coverage(polygon, n);\n    printf(\"%.6f\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:58:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    \n    Point operator-(const Point& p) const {\n        return Point(x - p.x, y - p.y);\n    }\n    \n    double length() const {\n        return sqrt(x * x + y * y);\n    }\n};\n\ndouble cross(const Point& a, const Point& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nstruct Circle {\n    Point center;\n    double radius;\n    Circle(Point c = Point(), double r = 0) : center(c), radius(r) {}\n};\n\ndouble polygonArea(const vector<Point>& polygon) {\n    double area = 0;\n    int n = polygon.size();\n    for (int i = 0; i < n; i++) {\n        area += cross(polygon[i], polygon[(i + 1) % n]);\n    }\n    return abs(area) / 2.0;\n}\n\ndouble segmentCircleIntersection(const Point& a, const Point& b, const Circle& circle) {\n    Point ab = b - a;\n    Point ac = circle.center - a;\n    \n    double t = (ac.x * ab.x + ac.y * ab.y) / (ab.x * ab.x + ab.y * ab.y);\n    t = max(0.0, min(1.0, t));\n    \n    Point closest(a.x + t * ab.x, a.y + t * ab.y);\n    double dist = (closest - circle.center).length();\n    \n    if (dist > circle.radius) return 0;\n    \n    double h = sqrt(circle.radius * circle.radius - dist * dist);\n    double intersectionArea = 2 * h * circle.radius;\n    \n    return intersectionArea;\n}\n\ndouble polygonCircleIntersection(const vector<Point>& polygon, const Circle& circle) {\n    double totalIntersection = 0;\n    int n = polygon.size();\n    \n    for (int i = 0; i < n; i++) {\n        totalIntersection += segmentCircleIntersection(polygon[i], polygon[(i + 1) % n], circle);\n    }\n    \n    return totalIntersection;\n}\n\ndouble maximizePolygonDiskCoverage(const vector<Point>& polygon) {\n    double maxCoverage = 0;\n    double totalArea = polygonArea(polygon);\n    int n = polygon.size();\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            Point mid((polygon[i].x + polygon[j].x) / 2, \n                      (polygon[i].y + polygon[j].y) / 2);\n            \n            double radius = (polygon[i] - mid).length();\n            Circle testCircle(mid, radius);\n            \n            double coverage = min(polygonCircleIntersection(polygon, testCircle), totalArea);\n            maxCoverage = max(maxCoverage, coverage);\n        }\n    }\n    \n    return maxCoverage;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<Point> polygon(n);\n    for (int i = 0; i < n; i++) {\n        cin >> polygon[i].x >> polygon[i].y;\n    }\n    \n    cout << fixed << setprecision(6) << maximizePolygonDiskCoverage(polygon) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:58:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from shapely.geometry import Polygon, Point\nfrom shapely.ops import unary_union\nimport numpy as np\n\ndef maximize_intersection(polygon_vertices, disk_radius, step=0.1):\n    def polygon_area_intersection(center):\n        disk = Point(center).buffer(disk_radius)\n        return polygon.intersection(disk).area\n\n    polygon = Polygon(polygon_vertices)\n    minx, miny, maxx, maxy = polygon.bounds\n\n    best_center = None\n    max_intersection_area = -1\n\n    x = np.arange(minx, maxx, step)\n    y = np.arange(miny, maxy, step)\n    xv, yv = np.meshgrid(x, y)\n\n    for cx, cy in zip(xv.ravel(), yv.ravel()):\n        current_area = polygon_area_intersection((cx, cy))\n        if current_area > max_intersection_area:\n            max_intersection_area = current_area\n            best_center = (cx, cy)\n\n    return best_center, max_intersection_area\n\n# Example usage\npolygon_vertices = [(0, 0), (2, 0), (2, 2), (0, 2)]\ndisk_radius = 1\nbest_center, max_area = maximize_intersection(polygon_vertices, disk_radius)\nprint(\"Best center:\", best_center)\nprint(\"Max intersection area:\", max_area)",
    "timestamp": "2025-08-13 04:12:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.List;\n\npublic class CoverPolygonWithDisk {\n\n    public static double findMaxDiskRadius(Point2D[] polygon) {\n        double maxRadius = 0.0;\n        \n        for (int i = 0; i < polygon.length; i++) {\n            Point2D p1 = polygon[i];\n            for (int j = i + 1; j < polygon.length; j++) {\n                Point2D p2 = polygon[j];\n                double distance = p1.distance(p2) / 2.0;\n                if (distance > maxRadius) {\n                    if (checkAllPointsWithinDisk(polygon, p1, p2)) {\n                        maxRadius = distance;\n                    }\n                }\n            }\n        }\n        return maxRadius;\n    }\n\n    private static boolean checkAllPointsWithinDisk(Point2D[] polygon, Point2D p1, Point2D p2) {\n        Point2D center = new Point2D.Double((p1.getX() + p2.getX()) / 2, (p1.getY() + p2.getY()) / 2);\n        double radius = p1.distance(center);\n\n        for (Point2D point : polygon) {\n            if (point.distance(center) > radius) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public static void main(String[] args) {\n        Point2D[] polygon = {\n            new Point2D.Double(0, 0),\n            new Point2D.Double(4, 0),\n            new Point2D.Double(4, 3),\n            new Point2D.Double(0, 3)\n        };\n        \n        double radius = findMaxDiskRadius(polygon);\n        System.out.println(\"Maximum Disk Radius to cover the polygon: \" + radius);\n    }\n}",
    "timestamp": "2025-08-13 04:13:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\nint n; // number of points in polygon\nPoint points[1000]; // polygon vertices\n\ndouble dist(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble max(double a, double b) {\n    return a > b ? a : b;\n}\n\nPoint findCenter(Point p[]) {\n    double totalX = 0, totalY = 0;\n    for (int i = 0; i < n; i++) {\n        totalX += p[i].x;\n        totalY += p[i].y;\n    }\n    Point center = {totalX / n, totalY / n};\n    return center;\n}\n\ndouble maximizeIntersection(Point center, double radius, Point p[]) {\n    double bestRadius = 0;\n    for (int i = 0; i < n; i++) {\n        double dToVertex = dist(center, p[i]);\n        if (dToVertex > bestRadius) {\n            bestRadius = dToVertex;\n        }\n    }\n    return max(bestRadius, radius);\n}\n\nint main() {\n    n = 4; // example: square polygon of size 2x2\n    points[0] = (Point){0, 0};\n    points[1] = (Point){2, 0};\n    points[2] = (Point){2, 2};\n    points[3] = (Point){0, 2};\n\n    Point center = findCenter(points);\n    double startingRadius = 0.0;\n    double maxRadius = maximizeIntersection(center, startingRadius, points);\n\n    printf(\"Center of disk: (%.2lf, %.2lf)\\n\", center.x, center.y);\n    printf(\"Maximum radius to maximize coverage: %.2lf\\n\", maxRadius);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:13:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\nfrom typing import List, Tuple\n\ndef polygon_disk_intersection(polygon: List[Tuple[float, float]], radius: float) -> float:\n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n    \n    def point_inside_polygon(point, polygon):\n        x, y = point\n        inside = False\n        j = len(polygon) - 1\n        for i in range(len(polygon)):\n            xi, yi = polygon[i]\n            xj, yj = polygon[j]\n            intersect = ((yi > y) != (yj > y)) and (x < (xj - xi) * (y - yi) / (yj - yi) + xi)\n            if intersect:\n                inside = not inside\n            j = i\n        return inside\n    \n    def line_circle_intersection(p1, p2, center, radius):\n        x1, y1 = p1\n        x2, y2 = p2\n        cx, cy = center\n        \n        dx = x2 - x1\n        dy = y2 - y1\n        \n        a = dx**2 + dy**2\n        b = 2 * ((x1 - cx) * dx + (y1 - cy) * dy)\n        c = (x1 - cx)**2 + (y1 - cy)**2 - radius**2\n        \n        discriminant = b**2 - 4 * a * c\n        \n        if discriminant < 0:\n            return False\n        \n        t1 = (-b + math.sqrt(discriminant)) / (2 * a)\n        t2 = (-b - math.sqrt(discriminant)) / (2 * a)\n        \n        return (0 <= t1 <= 1) or (0 <= t2 <= 1)\n    \n    max_intersection = 0\n    \n    for i in range(len(polygon)):\n        center = polygon[i]\n        \n        # Check if the center is inside the polygon\n        if point_inside_polygon(center, polygon):\n            intersection_area = 0\n            for j in range(len(polygon)):\n                p1 = polygon[j]\n                p2 = polygon[(j + 1) % len(polygon)]\n                \n                # Check if the line segment intersects with the circle\n                if line_circle_intersection(p1, p2, center, radius):\n                    intersection_area += 1\n            \n            max_intersection = max(max_intersection, intersection_area)\n    \n    return max_intersection\n\n# Example usage\npolygon = [(0, 0), (4, 0), (4, 4), (0, 4)]\nradius = 2\nresult = polygon_disk_intersection(polygon, radius)\nprint(result)",
    "timestamp": "2025-08-13 04:13:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom shapely.geometry import Polygon, Point\nfrom shapely.ops import unary_union\n\ndef polygon_area(polygon):\n    return polygon.area\n\ndef disk_area(x, y, radius, polygon):\n    disk = Point(x, y).buffer(radius)\n    intersection = polygon.intersection(disk)\n    return -intersection.area  # Negative because we minimize\n\ndef find_optimal_disk(polygon_points, initial_radius):\n    polygon = Polygon(polygon_points)\n    bounds = polygon.bounds\n    x0 = (bounds[0] + bounds[2]) / 2\n    y0 = (bounds[1] + bounds[3]) / 2\n    initial_guess = [x0, y0, initial_radius]\n    \n    # Bounds: x and y within polygon bounds, radius >=0\n    bounds_opt = [(bounds[0], bounds[2]), (bounds[1], bounds[3]), (0, None)]\n    \n    result = minimize(disk_area, initial_guess, args=(polygon,), \n                      bounds=bounds_opt, method='L-BFGS-B')\n    \n    optimal_x, optimal_y, optimal_radius = result.x\n    max_intersection_area = -result.fun\n    \n    return optimal_x, optimal_y, optimal_radius, max_intersection_area\n\n# Example usage:\n# polygon_points = [(0, 0), (4, 0), (4, 3), (2, 5), (0, 3)]\n# initial_radius = 2.0\n# x, y, r, area = find_optimal_disk(polygon_points, initial_radius)\n# print(f\"Optimal disk center: ({x}, {y}), radius: {r}, intersection area: {area}\")",
    "timestamp": "2025-08-13 04:13:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\nstruct Circle {\n    Point center;\n    double radius;\n};\n\ndouble distance(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nPoint getCentroid(const vector<Point>& points) {\n    double xSum = 0, ySum = 0;\n    for (const auto& point : points) {\n        xSum += point.x;\n        ySum += point.y;\n    }\n    return {xSum / points.size(), ySum / points.size()};\n}\n\nCircle maxInscribedCircle(const vector<Point>& polygon) {\n    Point centroid = getCentroid(polygon);\n    double minDistance = numeric_limits<double>::max();\n\n    for (const auto& point : polygon) {\n        double dist = distance(centroid, point);\n        if (dist < minDistance) {\n            minDistance = dist;\n        }\n    }\n    \n    return {centroid, minDistance};\n}\n\nint main() {\n    int n;\n    cout << \"Enter the number of vertices of the polygon: \";\n    cin >> n;\n    vector<Point> polygon;\n\n    cout << \"Enter the coordinates of the vertices:\" << endl;\n    for (int i = 0; i < n; ++i) {\n        Point p;\n        cin >> p.x >> p.y;\n        polygon.push_back(p);\n    }\n\n    Circle circle = maxInscribedCircle(polygon);\n    cout << \"Circle Center: (\" << circle.center.x << \", \" << circle.center.y << \")\\n\";\n    cout << \"Circle Radius: \" << circle.radius << \"\\n\";\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:17:52"
  }
]