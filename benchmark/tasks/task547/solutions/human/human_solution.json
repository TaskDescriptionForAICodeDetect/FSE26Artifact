[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for(int i=(int)(a);i<(int)(b);++i)\n#define ll long long\n\nconstexpr int SIZE = 1000000;\nvoid solve(){\n    int N;\n    ll L;\n    cin >> N >> L;\n    pair<ll, ll> interval[N];\n    vector<ll> compressTemp(N);\n    map<ll, int> compress; // 座圧\n    rep(i, N) {\n        ll l, r;\n        cin >> l >> r;\n        compressTemp.push_back(l);\n        compressTemp.push_back(r);\n        interval[i] = make_pair(l, r);\n    }\n    sort(compressTemp.begin(), compressTemp.end());\n    compressTemp.erase(unique(compressTemp.begin(), compressTemp.end()),compressTemp.end());\n    rep(i, compressTemp.size()) {\n        compress[compressTemp[i]] = i;\n    } // ここまで座圧パート\n\n    // xは区間スケジューリングなので貪欲\n    sort(interval, interval+N);\n    ll x = 0, xl = -1, xr = 0;\n    rep(i, N) {\n        if (interval[i].first > xl) {\n            ++ x;\n            xl = xr;\n        }\n        xr = max(xr, interval[i].second);\n        if (xr >= L) break;\n    }\n    cout << x << \" \"; // ここまででxが解ける\n    // 次にyは、座圧+imosで解けるね\n\n    vector<int>imos(SIZE);\n    rep(i, imos.size())\n    {\n        imos[i] = 0;\n    }\n\n    rep(i, N) {\n        ++ imos[compress[interval[i].first]];\n        -- imos[compress[interval[i].second]];\n    }\n    int y = N - imos[0] + 1;\n    repi(i, 1, SIZE) {\n        imos[i] += imos[i - 1];\n        if (imos[i] > 0) y = max(y, N - imos[i] + 1);\n    }\n    cout << y << endl;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    solve();\n\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <set>\n#include <vector>\n\nusing namespace std;\nusing ll = long long;\n#define REP(i, n) for (ll i = 0; i < n; ++i)\n\nusing P = pair<ll, ll>;\nint main() {\n\tll n, l;\n\tcin >> n >> l;\n\tvector<P> v(n);\n\tREP(i, n) cin >> v[i].first >> v[i].second;\n\tsort(v.begin(), v.end());\n\tmap<ll, ll> mp;\n\t{\n\t\tset<ll> st;\n\n\t\tREP(i, n) {\n\t\t\tst.insert(v[i].first);\n\t\t\tst.insert(v[i].second);\n\t\t}\n\t\tint i = 0;\n\t\tfor (auto &&a : st) {\n\t\t\tmp[a] = i++;\n\t\t}\n\t}\n\tint k = mp.size();\n\tll left = 0, right = 0, x = 0;\n\tint i = 0;\n\twhile (left < k - 1) {\n\t\twhile (i < n && mp[v[i].first] <= left) {\n\t\t\tright = max(right, mp[v[i].second]);\n\t\t\t++i;\n\t\t}\n\t\tleft = right;\n\t\tx++;\n\t}\n\tvector<int> cnt(k, 0);\n\tREP(i, n) {\n\t\tcnt[mp[v[i].first]]++;\n\t\tcnt[mp[v[i].second]]--;\n\t}\n\tREP(i, k - 1) cnt[i + 1] += cnt[i];\n\tll y = 1e9;\n\tREP(i, k - 1) y = min(y, (ll)cnt[i]);\n\n\tcout << x << \" \" << n - y + 1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <math.h>\n#include <set>\n#include <random>\n#include <map>\n#include <unordered_map>\n#include <bits/stdc++.h>\n#define FOR(i, n, m) for(ll i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = std::int_fast64_t;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 1000000007;\nconstexpr long double eps = 1e-15;\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n    os << to_string(p.first) << \" \" << to_string(p.second);\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n    REP(i, v.size()) {\n        if(i) os << \" \";\n        os << to_string(v[i]);\n    }\n    return os;\n}\n\nstruct modint {\n    ll n;\npublic:\n    modint(const ll n = 0) : n((n % mod + mod) % mod) {}\n    static modint pow(modint a, int m) {\n        modint r = 1;\n        while(m > 0) {\n            if(m & 1) { r *= a; }\n            a = (a * a); m /= 2;\n        }\n        return r;\n    }\n    modint &operator++() { *this += 1; return *this; }\n    modint &operator--() { *this -= 1; return *this; }\n    modint operator++(int) { modint ret = *this; *this += 1; return ret; }\n    modint operator--(int) { modint ret = *this; *this -= 1; return ret; }\n    modint operator~() const { return (this -> pow(n, mod - 2)); } // inverse\n    friend bool operator==(const modint& lhs, const modint& rhs) {\n        return lhs.n == rhs.n;\n    }\n    friend bool operator<(const modint& lhs, const modint& rhs) {\n        return lhs.n < rhs.n;\n    }\n    friend bool operator>(const modint& lhs, const modint& rhs) {\n        return lhs.n > rhs.n;\n    }\n    friend modint &operator+=(modint& lhs, const modint& rhs) {\n        lhs.n += rhs.n;\n        if (lhs.n >= mod) lhs.n -= mod;\n        return lhs;\n    }\n    friend modint &operator-=(modint& lhs, const modint& rhs) {\n        lhs.n -= rhs.n;\n        if (lhs.n < 0) lhs.n += mod;\n        return lhs;\n    }\n    friend modint &operator*=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * rhs.n) % mod;\n        return lhs;\n    }\n    friend modint &operator/=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * (~rhs).n) % mod;\n        return lhs;\n    }\n    friend modint operator+(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n + rhs.n);\n    }\n    friend modint operator-(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n - rhs.n);\n    }\n    friend modint operator*(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * rhs.n);\n    }\n    friend modint operator/(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * (~rhs).n);\n    }\n};\nistream& operator>>(istream& is, modint m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, modint m) { os << m.n; return os; }\n\n#define MAX_N 3030303\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n    long long d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1; y = 0;\n    }\n    return d;\n}\nlong long mod_inverse(long long a, long long m) {\n    long long x, y;\n    if(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n    else return -1;\n}\nvector<long long> fact(MAX_N+1, inf);\nlong long mod_fact(long long n, long long& e) {\n    if(fact[0] == inf) {\n        fact[0]=1;\n        if(MAX_N != 0) fact[1]=1;\n        for(ll i = 2; i <= MAX_N; ++i) {\n            fact[i] = (fact[i-1] * i) % mod;\n        }\n    }\n    e = 0;\n    if(n == 0) return 1;\n    long long res = mod_fact(n / mod, e);\n    e += n / mod;\n    if((n / mod) % 2 != 0) return (res * (mod - fact[n % mod])) % mod;\n    return (res * fact[n % mod]) % mod;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n    if(n < 0 || k < 0 || n < k) return 0;\n    long long e1, e2, e3;\n    long long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n    if(e1 > e2 + e3) return 0;\n    return (a1 * mod_inverse((a2 * a3) % mod, mod)) % mod;\n}\n\nusing mi = modint;\n\nmi mod_pow(ll a, ll n) {\n    mi ret = 1;\n    mi tmp = a;\n    while(n > 0) {\n        if(n % 2) ret *= tmp;\n        tmp = tmp * tmp;\n        n /= 2;\n    }\n    return ret;\n}\n\ntemplate <typename T> struct segment_tree {\nprivate:\n    int n;\n    const function<T(T, T)> op;\n    const T ie;\n    vector<T> seq;\n    \npublic:\n    segment_tree(int _n, function<T(T, T)> op, const T ie) : op(op), ie(ie) {\n        n = 1;\n        while(n < _n) n *= 2;\n        seq.resize(2 * n - 1);\n        for(int i = 0; i < 2 * n - 1; i++) seq[i] = ie;\n    }\n    \n    void update(int k, const T e) {\n        k += n - 1;\n        seq[k] = e;\n        while(k > 0) {\n            k = (k - 1) / 2;\n            seq[k] = op(seq[k * 2 + 1], seq[k * 2 + 2]);\n        }\n    }\n    \n    T get(int k) {\n        k += n - 1;\n        return seq[k];\n    }\n    \n    T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n        if(r == -1) r = n;\n        if(r <= a || b <= l) return ie;\n        if(a <= l && r <= b) return seq[k];\n        T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n        T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n        return op(vl, vr);\n    }\n};\n// segment_tree<ll> rsq(n, [] (ll a, ll b) { return a + b; }, 0)\n// segment_tree<ll> rMq(n, [] (ll a, ll b) { return max(a, b); }, -1e18)\n// segment_tree<ll> rmq(n, [] (ll a, ll b) { return min(a, b); }, 1e18)\n\n\nll N, L;\nvector<ll> l(202020), r(202020);\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin >> N >> L;\n    REP(i, N) cin >> l[i] >> r[i];\n    set<ll> s;\n    unordered_map<ll, int> m;\n    REP(i, N) {\n        s.insert(l[i]);\n        s.insert(r[i]);\n    }\n    int cnt = 0;\n    for(auto elm: s) {\n        m[elm] = cnt;\n        cnt++;\n    }\n    segment_tree<ll> rMq(cnt + 1, [] (ll a, ll b) { return max(a, b); }, -1e18);\n    REP(i, N) {\n        rMq.update(m[l[i]], max(r[i], rMq.get(m[l[i]])));\n    }\n    vector<int> imos(cnt, 0);\n    REP(i, N) {\n        imos[m[l[i]]]++;\n        imos[m[r[i]]]--;\n    }\n    FOR(i, 1, cnt) imos[i] += imos[i - 1];\n    int ans1 = 0, ans2 = inf;\n    ll tmp = 0;\n    while(tmp != L) {\n        tmp = rMq.query(0, m[tmp] + 1);\n        ans1++;\n    }\n    REP(i, cnt - 1) ans2 = min(ans2, imos[i]);\n    cout << ans1 << \" \" << N - ans2 + 1 << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll,ll>;\n#define pb push_back\n#define fi first\n#define sec second\n#define INF 1000000000\nconst int SIZE = 1<<20;\nstruct segtree{\n\tint seg[SIZE*2];\n\tsegtree(){\n\t\tfor(int i=0;i<SIZE*2;i++){\n\t\t\tseg[i] = INF;\n\t\t}\n\t}\n\tvoid update(int k,int x){\n\t\tk += SIZE-1;\n\t\tseg[k] = min(seg[k],x);\n\t\twhile(k>0){\n\t\t\tk = (k-1)/2;\n\t\t\tseg[k] = min(seg[k*2+1],seg[k*2+2]);\n\t\t}\n\t}\n\tint query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l)return INF;\n\t\tif(a<=l&&r<=b)return seg[k];\n\t\tint mid = (l+r)/2;\n\t\treturn min(query(a,b,k*2+1,l,mid),query(a,b,k*2+2,mid,r));\n\t}\n}seg;\nbool comp(P a,P b){\n\tif(a.sec!=b.sec)return a.sec < b.sec;\n\telse return a.fi < b.fi;\n}\nint N;\nll L;\nvector<ll> zip;\nvector<P> vec;\nint dp[400100];\nint rui[400100];\nint main(){\n\tcin >> N >> L;\n\tzip.pb(L);\n\tvec.resize(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin >> vec[i].fi >> vec[i].sec;\n\t\tzip.pb(vec[i].fi);\n\t\tzip.pb(vec[i].sec);\n\t}\n\tzip.pb(0ll);\n\tsort(zip.begin(),zip.end());\n\tzip.erase(unique(zip.begin(),zip.end()),zip.end());\n\tfor(int i=0;i<N;i++){\n\t\tvec[i].fi = lower_bound(zip.begin(),zip.end(),vec[i].fi)-zip.begin();\n\t\tvec[i].sec = lower_bound(zip.begin(),zip.end(),vec[i].sec)-zip.begin();\n\t\trui[vec[i].fi]++;\n\t\trui[vec[i].sec]--;\n\t}\n\tsort(vec.begin(),vec.end(),comp);\n\t// for(int i=0;i<vec.size();i++){\n\t// \tcout << vec[i].fi << ' ' << vec[i].sec << endl;\n\t// }\n\tfor(int i=1;i<=zip.size();i++){\n\t\tdp[i] = INF;\n\t}\n\tdp[0] = 0ll;\n\tseg.update(0,dp[0]);\n\tfor(int i=0;i<vec.size();i++){\n\t\tint l = vec[i].fi;\n\t\tint r = vec[i].sec;\n\t\tdp[r] = min(dp[r],seg.query(l,r,0,0,SIZE)+1);\n\t\tseg.update(r,dp[r]);\n\t}\n\tfor(int i=1;i<zip.size();i++){\n\t\trui[i] += rui[i-1];\n\t}\n\tint mi = INF;\n\tfor(int i=0;i+1<zip.size();i++){\n\t\tmi = min(mi,rui[i]);\n\t}\n\tcout << dp[zip.size()-1] << ' ' << N-mi+1 << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MOD=1e9+7;\n//const int MOD=998244353;\nconst int INF=1e9;\nconst long long LINF=1e18;\n#define int long long\n//template\ntemplate <typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\n//main\nsigned main(){\n  int N,L,x=0,y=LINF;cin>>N>>L;\n  std::vector<int> v(2*N+5,0),used(2*N+5,0);\n  typedef pair<int,int> P;\n  std::vector<P> lr(N+1);\n  map<int,int> m;\n  for(int i=0;i<N;i++){\n    int l,r;cin>>l>>r;m[l]=m[r]=0;\n    lr[i]=P(l,r);\n  }\n  int cnt=0;\n  for(auto &p:m)p.second=cnt++;\n  for(int i=0;i<N;i++)lr[i]=P(m[lr[i].first],m[lr[i].second]);\n  L=m[L];\n  lr[N]=P(LINF,LINF);\n  sort(lr.begin(),lr.end());\n  int nownum=0,nowpo=0;\n  priority_queue<int> que;\n  while(nowpo<L){\n    while(lr[nownum].first<=nowpo)que.push(lr[nownum++].second);\n    nowpo=que.top();que.pop();\n    x++;\n  }\n  for(int i=0;i<N;i++)v[lr[i].first]++,v[lr[i].second]--;\n  for(int i=0;i<L+4;i++)v[i+1]+=v[i];\n  for(int i=0;i<L;i++)y=min(y,v[i]);\n  cout<<x<<\" \"<<N-y+1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nint N;\nlong long L;\nint main(){\n    cin>>N>>L;\n    vector<long long>A;\n    vector<pair<LL,LL> >B;\n    for(int i=0;i<N;i++)\n    {\n        long long l,r;\n        cin>>l>>r;\n        A.push_back(l);\n        A.push_back(r);\n        B.push_back(make_pair(l,r));\n    }\n    sort(A.begin(),A.end());\n    A.erase(unique(A.begin(),A.end()),A.end());\n    sort(B.begin(),B.end());\n    long long p=0,q=0;\n    int ans=0;\n    for(int i=0;i<N;i++)\n    {\n        q=max(q,B[i].second);\n        if(i==N-1||B[i+1].first>p)\n        {\n            ans++;\n            p=q;\n            if(p>=L)break;\n        }\n    }\n    cout<<ans<<\" \";\n    vector<int>S(A.size(),0);\n    for(pair<LL,LL>a:B)\n    {\n        int l,r;\n        l=lower_bound(A.begin(),A.end(),a.first)-A.begin();\n        r=lower_bound(A.begin(),A.end(),a.second)-A.begin();\n        S[l]++;\n        S[r]--;\n    }\n    int T=0,K=2e9;\n    for(int i=0;i<A.size();i++)\n    {\n        T+=S[i];\n        if(i+1<A.size())K=min(K,T);\n    }\n    cout<<N-K+1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\nusing p = pair<long long,long long>;\n\nlong long N,L;\nvector<long long> memo,sum;\nvector<p> lr;\nmap<long long,long long> mp;\n\nlong long solve();\nbool asc(const p &l,const p & r){\n    if(l.fi != r.fi)return l.fi < r.fi;\n    return l.se > r.se;\n}\n\nint main(){\n    cin >> N >> L;\n    lr.resize(N);\n    for(int i = 0;i < N;++i){\n        cin >> lr[i].fi >> lr[i].se;\n        memo.push_back(lr[i].fi);\n        memo.push_back(lr[i].se);\n    }\n    sort(memo.begin(),memo.end());\n    memo.erase(unique(memo.begin(),memo.end()),memo.end());\n    cout << solve() << endl;\n    return 0;\n}\n\nlong long solve(){\n    sort(lr.begin(),lr.end(),asc);\n    sum.resize(memo.size(),0);\n    long long ans = 0,now = 0,msize = memo.size();\n    for(int i = 0;i < N;){\n        long long nextp = now;\n        while(i < N && lr[i].fi <= now){\n            nextp = max(nextp,lr[i].se);\n            ++i;\n        }\n        ++ans;\n        now = nextp;\n        if(nextp >= L){\n            cout << ans << \" \";\n            break;\n        }\n    }\n    for(int i = 0;i < msize;++i)\n        mp[memo[i]] = i;\n    for(int i = 0;i < N;++i){\n        ++sum[mp[lr[i].fi]];\n        if(mp[lr[i].se] + 1 < msize)--sum[mp[lr[i].se] + 1];\n    }\n    ans = sum[0];\n    for(int i = 1;i < msize;++i)\n        if(memo[i] <= L){\n        sum[i] += sum[i-1];\n        ans = min(ans,sum[i]);\n    }\n    return N - ans + 1;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nmap<ll, int> zip;\nVL unzip;\nvoid compress_coordinate(VL x){\n    int n = x.size();\n    REP(i,n) unzip.push_back(x[i]);\n    sort(ALL(unzip));\n    unzip.erase(unique(ALL(unzip)), unzip.end());\n    REP(i,unzip.size()) zip[unzip[i]] = i;\n}\n\nint main() {\n    ll n, l;\n    cin >> n >> l;\n    vector<PL> p(n);\n    VL x;\n    REP(i,n){\n        p[i].first = lin();\n        p[i].second = lin();\n        x.push_back(p[i].first);\n        x.push_back(p[i].second);\n    }\n    sort(ALL(p));\n    compress_coordinate(x);\n    l = zip[l];\n    REP(i,n){\n        p[i].first = zip[p[i].first];\n        p[i].second = zip[p[i].second];\n    }\n    ll ans1 = 1, d = 0, e = 0;\n    REP(i,n){\n        if (p[i].first > d){\n            d = e;\n            if (d < l) ans1++;\n        }\n        chmax(e, p[i].second);\n    }\n\n    VL s(l + 1);\n    REP(i,n){\n        s[p[i].first]++;\n        s[p[i].second]--;\n    }\n    REP(i,l) s[i + 1] += s[i];\n    ll ans2 = 0;\n    REP(i,l) chmax(ans2, n - s[i] + 1);\n\n    cout << ans1 << \" \" << ans2 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\n\nint N;\nll P;\nvector<ll> L,R;\n\nint main(){\n  cin>>N>>P;\n  L.resize(N);\n  R.resize(N);\n  for(int i=0;i<N;i++) cin>>L[i]>>R[i];\n\n  for(int i=0;i<N;i++) R[i]--;\n  P--;\n\n  vector<pair<ll,int>> l;\n  for(int i=0;i<N;i++) l.push_back(mkp(L[i],i));\n  sort(l.begin(),l.end());\n\n  ll now=0;\n  int pos=0;\n  vector<ll> lef;\n  while(now<=P){\n    ll ma=now;\n    while(pos<N&&l[pos].first<=now){\n      int tar=l[pos].second;\n      ma=max(ma,R[tar]);\n      pos++;\n    }\n    lef.push_back(ma);\n    now=ma+1;\n  }\n\n  vector<ll> v;\n  for(int i=0;i<N;i++){\n      v.push_back(L[i]);\n      v.push_back(R[i]+1);\n  }\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n\n  map<ll,int> mp;\n  for(int i=0;i<v.size();i++) mp[v[i]]=i+1;\n\n  vector<int> imos((int)v.size()+1,0);\n  for(int i=0;i<N;i++){\n      imos[mp[L[i]]]++;\n      imos[mp[R[i]+1]]--;\n  }\n  for(int i=1;i<=v.size();i++) imos[i]+=imos[i-1];\n\n  int x=lef.size();\n  int y=N;\n  for(int i=1;i<v.size();i++) y=min(y,imos[i]);\n\n  cout<<x<<\" \"<<N-y+1<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define SIZE 200005\n\nstruct Info{\n\n\tbool operator<(const struct Info &arg) const{\n\n\t\tif(left != arg.left){\n\n\t\t\treturn left < arg.left;\n\t\t}else{\n\n\t\t\treturn right < arg.right;\n\t\t}\n\t}\n\n\tll left,right;\n};\n\nint N;\nll L;\nInfo info[SIZE];\nvector<ll> V;\nmap<ll,int> MAP;\nint table[2*SIZE];\n\nint main(){\n\n\tscanf(\"%d %lld\",&N,&L);\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%lld %lld\",&info[i].left,&info[i].right);\n\n\t\tV.push_back(info[i].left);\n\t\tV.push_back(info[i].right);\n\t}\n\n\tsort(info,info+N);\n\n\tint x = 0;\n\tll pre_right = 0,next_maximum = -HUGE_NUM;\n\n\tfor(int i = 0; pre_right <= L-1 && i < N; ){\n\n\t\tif(info[i].left <= pre_right){\n\n\t\t\tnext_maximum = max(next_maximum,info[i].right);\n\t\t\tif(next_maximum == L){\n\n\t\t\t\tx++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\n\t\t}else{ //次の区間に移る\n\n\t\t\tpre_right = next_maximum;\n\t\t\tnext_maximum = -HUGE_NUM;\n\t\t\tx++;\n\t\t}\n\t}\n\n\tsort(V.begin(),V.end());\n\tV.erase(unique(V.begin(),V.end()),V.end());\n\n\t//数字の変換表\n\tfor(int i = 0; i < V.size(); i++){\n\n\t\tMAP[V[i]] = i;\n\t}\n\n\tfor(int i = 0; i < V.size(); i++){\n\n\t\ttable[i] = 0;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\n\t\ttable[MAP[info[i].left]]++;\n\t\ttable[MAP[info[i].right]]--;\n\t}\n\n\tint minimum = table[0];\n\n\tfor(int i = 1; i < V.size()-1; i++){\n\n\t\ttable[i] += table[i-1];\n\t\tminimum = min(minimum,table[i]);\n\t}\n\n\tprintf(\"%d %d\\n\",x,N-minimum+1);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int n;\n    int64_t L;\n    cin >> n >> L;\n\n    vector<array<int64_t, 2>> R(n);\n    for (int i = 0; i < n; i++){\n        int64_t l, r;\n        cin >> l >> r;\n        R[i] = {l, r};\n    }\n\n    sort(R.begin(), R.end());\n\n    map<int64_t, int64_t> maxes;\n    int64_t ma = 0;\n\n    for (int i = 0; i < n; i++){\n        int64_t l = R[i][0], r = R[i][1];\n        ma = max(ma, r);\n        //printf(\"%d %d %d\\n\", l, r, ma);\n        maxes[l] = ma;\n        if (maxes.count(r) == 0)\n            maxes[r] = 0;\n    }\n\n    ma = 0;\n    for (auto &m: maxes){\n        int64_t key = m.first;\n        int64_t value = m.second;\n        ma = max(ma, value);\n        maxes[key] = max(maxes[key], ma);\n    }\n\n    int64_t cur = 0;\n    int x = 0;\n    while (cur < L) {\n        //printf(\"%d %d\\n\", cur, maxes[cur]);\n        cur = maxes[cur];\n        x++;\n    }\n\n    map<int64_t, int> S;\n    for (int i = 0; i < n; i++){\n        int64_t l = R[i][0], r = R[i][1];\n        S[l]++;\n        S[r]--;\n    }\n\n    int mi = n;\n    int cur_s = 0;\n    for (auto &s: S){\n        int64_t key = s.first;\n        int value = s.second;\n        if (key == L)\n            break;\n        S[key] += cur_s;\n        mi = min(mi, S[key]);\n        cur_s = S[key];\n    }\n\n    int y = n - mi + 1;\n\n    cout << x << \" \" << y << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#define int long long\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\ntypedef pair<int, int> P;\n\nint N, L;\nP pl[200000];\t//l昇順, (l, r)\nP pr[200000];\t//r昇順, (r, l)\n\nint calcX() {\n\tint i = 0;\n\tint left = 0;\n\tint ret = 0;\n\t\n\twhile (i < N) {\n\t\tint maxR = left;\n\t\tfor (; i < N && pl[i].first <= left; i++) {\n\t\t\tmaxR = max(maxR, pl[i].second);\n\t\t}\n\t\tleft = maxR;\n\t\tret++;\n\t\tif (maxR == L) break;\n\t}\n\treturn ret;\n}\n\nint calcY() {\n\tint i;\n\tvector<int> xs;\n\t\n\trep(i, N) {\n\t\txs.push_back(pl[i].first);\n\t\txs.push_back(pl[i].second);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\t\n\t/*cout << \"pl[]\" << endl;\n\trep(i, N) {\n\t\tcout << pl[i].first << \", \" << pl[i].second << endl;\n\t}\n\tcout << endl;\n\tcout << \"pr[]\" << endl;\n\trep(i, N) {\n\t\tcout << pr[i].first << \", \" << pr[i].second << endl;\n\t}*/\n\t\n\tint ret = 0;\n\trep(i, xs.size()) {\n\t\t//r < x\n\t\tint idL = lower_bound(pr, pr + N, P(xs[i], -1)) - pr;\n\t\tint cntL = idL;\n\t\t//l > x\n\t\tint idR = lower_bound(pl, pl + N, P(xs[i] + 1, -1)) - pl;\n\t\tint cntR = N - idR;\n\t\tret = max(ret, cntL + cntR);\n\t\t//cout << \"x = \" << xs[i] << \", cntL = \" << cntL << \", cntR = \" << cntR << endl;\n\t}\n\treturn ret + 1;\n}\n\nsigned main() {\n\tint i;\n\t\n\tcin >> N >> L;\n\trep(i, N) {\n\t\tint l, r;\n\t\tcin >> l >> r;\n\t\tpl[i] = P(l, r);\n\t\tpr[i] = P(r, l);\n\t}\n\tsort(pl, pl + N);\n\tsort(pr, pr + N);\n\t\n\tint x = calcX();\n\tint y = calcY();\n\tcout << x << \" \" << y << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ll long long\n\nusing namespace std;\n\nint main()\n{\n\tll n, l; cin>>n>>l;\n\tvector<pair<ll, ll> > p(n);\n\tset<ll> s;\n\tfor(int i=0; i<n; i++){\n\t\tll l, r; cin>>l>>r;\n\t\ts.insert(l); s.insert(r);\n\t\tp[i] = make_pair(l, r);\n\t}\n\tsort(p.begin(), p.end());\n\tll cur=0, x=0;\n\tfor(int i=0; i<n; i++){\n\t\tll maxi=0;\n\t\twhile(p[i].first<=cur){\n\t\t\tmaxi = max(maxi, p[i].second);\n\t\t\ti++;\n\t\t}\n\t\tcur = maxi;\n\t\tx++; i--;\n\t\tif (cur==l) break;\n\t}\n\tll mini, y;\n\tmap<ll, ll> m;\n\tll idx=0;\n\tfor(auto it=s.begin(); it!=s.end(); it++){\n\t\tm[*it] = idx;\n\t\tidx++;\n\t}\n\tvector<ll> imos(s.size()+1);\n\tfor(int i=0; i<n; i++){\n\t\tll left = m[p[i].first];\n\t\tll right = m[p[i].second];\n\t\timos[left]++;\n\t\timos[right+1]--;\n\t}\n\tmini = imos[0];\n\tfor(int i=1; i<imos.size()-1; i++){\n\t\timos[i]+=imos[i-1];\n\t\tmini = min(mini, imos[i]);\n\t}\n\ty = n-(mini-1);\n\tcout << x << \" \" << y << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\nusing p = pair<long long,long long>;\n\nlong long N,L;\nvector<long long> memo,sum;\nvector<p> lr;\nmap<long long,long long> mp;\n\nlong long solve();\nbool asc(const p &l,const p & r){\n    if(l.fi != r.fi)return l.fi < r.fi;\n    return l.se > r.se;\n}\n\nint main(){\n    cin >> N >> L;\n    lr.resize(N);\n    for(int i = 0;i < N;++i){\n        cin >> lr[i].fi >> lr[i].se;\n        memo.push_back(lr[i].fi);\n        memo.push_back(lr[i].se);\n    }\n    sort(memo.begin(),memo.end());\n    memo.erase(unique(memo.begin(),memo.end()),memo.end());\n    cout << solve() << endl;\n    return 0;\n}\n\nlong long solve(){\n    sort(lr.begin(),lr.end(),asc);\n    sum.resize(memo.size(),0);\n    long long ans = 0,now = 0,msize = memo.size();\n    for(int i = 0;i < N;){\n        long long nextp = now;\n        while(i < N && lr[i].fi <= now){\n            nextp = max(nextp,lr[i].se);\n            ++i;\n        }\n        ++ans;\n        now = nextp;\n        if(nextp >= L){\n            cout << ans << \" \";\n            break;\n        }\n    }\n    for(int i = 0;i < msize;++i)\n        mp[memo[i]] = i;\n    for(int i = 0;i < N;++i){\n        ++sum[mp[lr[i].fi]];\n        if(mp[lr[i].se] + 1 < msize)--sum[mp[lr[i].se] + 1];\n    }\n    ans = sum[0];\n    for(int i = 1;i < msize;++i)\n        if(memo[i] <= L){\n        sum[i] += sum[i-1];\n        ans = min(ans,sum[i]);\n    }\n    return N - ans + 1;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long int;\n\nstruct Range{\n  long long int l,r;\n  Range(const long long int ll,const long long int rr){\n    l=ll,r=rr;\n    return;\n  }\n  bool operator <(const Range&ra)const{\n    return r<ra.r;\n  }\n};\n\nsigned main() {\n\n  long long int N,M;\n  cin>>N>>M;\n  vector<Range>range;\n  map<long long int,int>m;\n  for(int i=0;i<N;i++){\n    long long int a,b;\n    cin>>a>>b;\n    m[a]=0;\n    m[b]=0;\n    range.push_back(Range(a,b));\n  }\n  int cnt=0;\n  for(auto &i:m){\n    i.second=cnt++;\n  }\n  for(auto &i:range){\n    i.l=m[i.l];\n    i.r=m[i.r];\n   // cout<<\"range \"<<i.l<<\" \"<<i.r<<endl;\n  }\n  vector<vector<Range>>vr(m.size());\n  for(auto i:range){\n    vr[i.l].push_back(i);\n  }\n  sort(range.begin(),range.end());\n  priority_queue<Range>PQ;\n  cnt=0;\n  int ans=0;\n  for(auto i:vr[0]){\n    PQ.push(i);\n  }\n  M=m[M];\n  while(!PQ.empty()){\n    auto box=PQ.top();\n    PQ.pop();\n    for(int i=cnt+1;i<=box.r;i++){\n      for(auto j:vr[i]){\n        PQ.push(j);\n      }\n    }\n    ans++;\n    cnt=box.r;\n    if(cnt==M)break;\n  }\n  cout<<ans<<\" \";\n  vector<int>sum(m.size());\n  for(auto i:range){\n    sum[i.l]++;\n    sum[i.r]--;\n  }\n  for(int i=1;i<m.size();i++){\n    sum[i]+=sum[i-1];\n  }\n  sum.pop_back();\n // for(auto i:sum)cout<<i<<endl;\n  cout<<N+1-(*min_element(sum.begin(),sum.end()))<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint main(){\n    ll N, L;\n    cin >> N >> L;\n    vector<P> ls, imos;\n    for(int i=0;i<N;i++){\n        ll l, r;\n        cin >> l >> r;\n        ls.push_back(P(l,r));\n        imos.push_back(P(l,+1));\n        imos.push_back(P(r,-1));\n    }\n    sort(ls.begin(), ls.end());\n    sort(imos.begin(), imos.end());\n    ll x = 0;\n    for(ll rmax = 0, i=0; rmax < L;){\n        ll tmp = rmax;\n        while(i<N && ls[i].first <= rmax){\n            tmp = max(tmp, ls[i].second);\n            i++;\n        }\n        x++;\n        rmax = tmp;\n    }\n    ll sum = 0, smin = INT_MAX;\n    for(int i=0;i<N*2-1;i++){\n        sum += imos[i].second;\n        if(imos[i].first != imos[i+1].first){\n            smin = min(sum, smin);\n        }\n    }\n    ll y = N - smin + 1;\n    cout << x << \" \" << y << endl;\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <cassert>\n#include <random>\n\nstruct Range {\n\tlong long int left, right;\n};\nint main() {\n\tint n; long long int l; std::cin >> n >> l;\n\tstd::vector<Range> ranges(n); for (auto& r : ranges) std::cin >> r.left >> r.right;\n\tstd::vector<long long int> values;\n\tfor (const auto r : ranges) {\n\t\tvalues.push_back(r.left);\n\t\tvalues.push_back(r.right);\n\t}\n\tstd::sort(values.begin(), values.end());\n\tvalues.erase(std::unique(values.begin(), values.end()), values.end());\n\tstd::unordered_map<long long int, int> rank;\n\tfor (auto i = 0; i < values.size(); ++i) {\n\t\trank[values[i]] = i;\n\t}\n\tfor (auto& r : ranges) {\n\t\tr.left = rank[r.left];\n\t\tr.right = rank[r.right];\n\t}\n\tstd::sort(ranges.begin(), ranges.end(), [](const Range& a, const Range& b) {return a.left == b.left ? a.right < b.right : a.left < b.left; });\n\tstd::vector<int> max_right(values.size(), 0);\n\tfor (const auto& r : ranges) {\n\t\tmax_right[r.left] = r.right;\n\t}\n\tfor (auto i = 1; i < max_right.size(); ++i) {\n\t\tmax_right[i] = std::max(max_right[i], max_right[i - 1]);\n\t}\n\tint x = 0;\n\tfor (auto i = 0; i + 1 < max_right.size(); i = max_right[i]) {\n\t\t++x;\n\t}\n\tstd::vector<int> count(values.size(), 0);\n\tfor (const auto& r : ranges) {\n\t\tcount[r.left]++;\n\t\tcount[r.right]--;\n\t}\n\tfor (auto i = 1; i < count.size(); ++i) {\n\t\tcount[i] += count[i - 1];\n\t}\n\tcount.pop_back();\n\tint y = 0;\n\tfor (const auto c : count) {\n\t\ty = std::max(y, n - c + 1);\n\t}\n\tstd::cout << x << ' ' << y << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<n;i++)\n#define int long long\n\ntypedef pair<int, int> P;\n\nvector<P>v;\nbool comp1(const P& p1, const P& p2) {\n\tif (p1.second == p2.second) {\n\t\treturn p1.first > p2.first;\n\t}\n\telse return p1.second < p2.second;\n}\nbool comp2(const P& p1, const P& p2) {\n\tif (p1.first == p2.first) {\n\t\treturn p1.second < p2.second;\n\t}\n}\n\nsigned main() {\n\tint N, L; cin >> N >> L;\n\tREP(i, N) {\n\t\tint l, r; cin >> l >> r;\n\t\tv.push_back({ l,r });\n\t}\n\tsort(v.begin(), v.end());\n\tint pos = 0;\n\tint cnt = 0;\n\tint idx;\n\tpriority_queue<int>que;\n\tREP(i, N) {\n\t\tidx = i;\n\t\tif (v[i].first > 0)break;\n\t\tque.push(v[i].second);\n\t}\n\twhile (pos < L) {\n\t\tint nex = que.top();\n\t\tcnt++;\n\t\tpos = nex;\n\t\tif (nex == L) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = idx; i < N; i++) {\n\t\t\tif (v[i].first > nex) {\n\t\t\t\tidx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tque.push(v[i].second);\n\t\t}\n\t}\n\tint x = cnt;\n\tcout << x << \" \";\n\n\tsort(v.begin(), v.end(), comp1);\n\t//cout << \"sorted\" << endl;\n\tint l = 0;\n\tint y = 1e9;\n\tREP(i, N) {\n\t\tif (v[i].first <= l)l = v[i].second;\n\t\tif (l == L)y = min(y, i + 1);\n\t}\n\tcout << y << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nint main() {\n    // cin.tie(nullptr); ios::sync_with_stdio(false);\n    int n; cin >> n;\n    lint m; cin >> m;\n    V<lint> l(n), r(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> l[i] >> r[i];\n    }\n    auto vl = l, vr = r;\n    auto v = l;\n    v.insert(end(v), begin(r), end(r));\n    sort(begin(v), end(v));\n    v.erase(unique(begin(v), end(v)), end(v));\n    for (auto&& e : l) {\n        e = lower_bound(begin(v), end(v), e) - begin(v);\n    }\n    for (auto&& e : r) {\n        e = lower_bound(begin(v), end(v), e) - begin(v);\n    }\n    for (auto&& e : vl) {\n        e = lower_bound(begin(v), end(v), e) - begin(v);\n    }\n    for (auto&& e : vr) {\n        e = lower_bound(begin(v), end(v), e) - begin(v);\n    }\n    sort(begin(vl), end(vl));\n    sort(begin(vr), end(vr));\n\n    map<int, int> mp;\n    for (int i = 0; i < n; ++i) {\n        mp[l[i]] = max<lint>(mp[l[i]], r[i]);\n    }\n\n    m = v.size() - 1;\n    // cerr << m << endl;\n    int x = 0, p = 0;\n    auto itr = begin(mp);\n    while (p < m) {\n        int np = p;\n        while (itr != end(mp) and itr->first <= p) {\n            np = max(np, itr->second);\n            ++itr;\n        }\n        p = np;\n        // cerr << np << endl;\n        ++x;\n    }\n    int y = 0;\n    for (int i = 0; i < m; ++i) {\n        int z = upper_bound(begin(vr), end(vr), i) - begin(vr);\n        z += end(vl) - lower_bound(begin(vl), end(vl), i + 1);\n        y = max(y, z);\n        // cerr << i << ' ' << z << endl;\n    }\n    cout << x << ' ' << y + 1 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MOD 1000000007\n#define INF 1000000010\n#define EPS 1e-9\n#define fst first\n#define scd second\n\n#define debug(x) cout<<x<<endl;\n#define repi(i,x,n) for(int i=x;i<n;i++)\n#define rep(i,n) repi(i,0,n)\n#define lp(i,n) repi(i,0,n)\n#define repn(i,n) for(int i=n;i>=0;i--)\n#define int long long\n#define endl \"\\n\"\n\n\nsigned main(){\n  int N,L;cin>>N>>L;\n  vector<int> l(N),r(N);\n  for(int i=0;i<N;i++)cin>>l[i]>>r[i];\n  map<int,int> m;\n  for(int i=0;i<N;i++){\n    m[l[i]]=0;\n    m[r[i]]=0;\n  }\n  int cnt=0;\n  for(auto &p:m)p.second=cnt++;\n  for(int i=0;i<N;i++){\n    l[i]=m[l[i]];\n    r[i]=m[r[i]];\n  }\n  int ans=0;\n  vector<int> d(500000,-1);\n  for(int i=0;i<N;i++)d[l[i]]=max(d[l[i]],r[i]);\n  int now=0;int mx=0;cnt--;\n  for(int i=0;i<cnt;i++){\n    if(now>i){\n      mx=max(mx,d[i]);\n      continue;\n    }\n   \n    ans++;\n    now=max(d[i],mx);\n    //cout<<i<<\" \"<<ans<<\" \"<<now<<endl;\n  }\n  cout<<ans<<\" \";\n  vector<int> imos(cnt+10,0);\n  for(int i=0;i<N;i++){\n    imos[l[i]]++;\n    imos[r[i]]--;\n  }\n  for(int i=1;i<cnt;i++)imos[i]+=imos[i-1];\n  ans=100000000000000;\n  for(int i=0;i<cnt;i++)ans=min(ans,imos[i]);\n  cout<<N-ans+1<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\n#define SIZE 400000\n#define SIZE0 200000\n#define INF 1000000000\n\ntypedef long long ll;\n\nstruct Segtree {\n  int segn2;\n  vector<int> data;\n\n  Segtree(int n) {\n    for(segn2=1; segn2<n; segn2*=2);\n    data.assign(segn2*2, 1000000000);\n  }\n\n  int query(int a, int b, int l = 0, int r = -1, int k = 0) {\n    if (r == -1) r = segn2;\n    if (a <= l && r <= b) return data[k];\n    if (r <= a || b <= l) return INF;\n    return min(query(a, b, l, (l+r)/2, k*2+1), query(a, b, (l+r)/2, r, k*2+2));\n  }\n\n  void set(int k, int x) {\n    k += segn2-1;\n    data[k] = x;\n    while(k > 0) {\n      k = (k-1)/2;\n      data[k] = min(data[k*2+1], data[k*2+2]);\n    }\n  }\n};\n\n\nint N;\nll L;\nint M;\npair<ll,ll> p[SIZE0];\n\nint memo[SIZE];\nint solve1() {\n  Segtree seg(M+1);\n\n  seg.set(0, 0);\n\n  for(int i=0; i<M; i++) {\n    memo[i] = INF;\n  }\n  memo[0] = 0;\n\n  for(int i=0; i<N; i++) {\n    int l = p[i].first;\n    int r = p[i].second;\n\n    int v = seg.query(l, r);\n    memo[r] = min(memo[r], v+1);\n    seg.set(r, memo[r]);\n\n  }\n\n  return seg.query(M-1, M);\n}\n\nint sum[SIZE];\nint solve2() {\n\n  for(int i=0; i<N; i++) {\n    sum[p[i].first]++;\n    sum[p[i].second]--;\n  }\n\n  int ans = 1e9;\n\n  for(int i=0; i<M-1; i++) {\n    sum[i+1] += sum[i];\n    ans = min(ans, sum[i]);\n  }\n\n  return N - ans + 1;\n}\n\nint main(){\n  vector<ll> vec;\n  map<ll, int> dic;\n\n  scanf(\"%d%lld\", &N, &L);\n\n  for(int i=0; i<N; i++) {\n    ll l, r;\n    scanf(\"%lld%lld\", &l, &r);\n\n    p[i] = {l, r};\n    vec.push_back(l);\n    vec.push_back(r);\n  }\n\n  sort(vec.begin(), vec.end());\n  vec.erase(unique(vec.begin(), vec.end()), vec.end());\n\n  M = vec.size();\n\n  for(int i=0; i<vec.size(); i++) {\n    dic[vec[i]] = i;\n  }\n\n  sort(p, p+N);\n\n  for(int i=0; i<N; i++) {\n    p[i].first = dic[p[i].first];\n    p[i].second = dic[p[i].second];\n  }\n\n\n  int ans1 = solve1();\n  int ans2 = solve2();\n\n  printf(\"%d %d\\n\", ans1, ans2);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int N;\n    int64_t _;\n    cin >> N >> _;\n    map<int64_t, int> mp;\n    int64_t L[200000], R[200000];\n    for(int i=0; i<N; i++){\n        cin >> L[i] >> R[i];\n        mp[L[i]] = mp[R[i]] = 0;\n    }\n    int sz = 0;\n    for(auto p : mp) mp[p.first] = sz++;\n    vector<int> L2R(sz);\n    for(int i=0; i<N; i++){\n        L[i] = mp[L[i]];\n        R[i] = mp[R[i]];\n        L2R[L[i]] = max(L2R[L[i]], (int)R[i]);\n    }\n\n    int rnow = 0, rnxt = 0, ans1 = 0;\n    for(int i=0; i<sz-1; i++){\n        rnxt = max(rnxt, L2R[i]);\n        if(rnow == i){\n            ans1++;\n            rnow = rnxt;\n        }\n    }\n\n    vector<int> imos(sz);\n    for(int i=0; i<N; i++){\n        imos[L[i]]++;\n        imos[R[i]]--;\n    }\n    imos.pop_back();\n    for(int i=1; i<sz-1; i++) imos[i] += imos[i-1];\n    int ans2 = N - *min_element(imos.begin(), imos.end()) + 1;\n    cout << ans1 << \" \" << ans2 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <map>\n\nusing Int = long long int;\nusing std::pair;\nusing std::vector;\n\ntemplate <class T>\nstd::map<T, Int> compress(vector<T>& v) {\n    std::sort(v.begin(), v.end());\n    v.erase(std::unique(v.begin(), v.end()), v.end());\n\n    std::map<T, Int> rev;\n    for (Int i = 0; i < v.size(); ++i) rev[v[i]] = i;\n    return rev;\n}\n\nint main() {\n    int n;\n    Int l;\n    std::cin >> n >> l;\n\n    vector<pair<Int, Int>> segs(n);\n    vector<Int> xs;\n    xs.reserve(n * 2);\n    for (auto& p : segs) {\n        std::cin >> p.first >> p.second;\n        xs.push_back(p.first);\n        xs.push_back(p.second);\n    }\n\n    auto revx = compress(xs);\n    for (auto& p : segs) {\n        p.first = revx[p.first];\n        p.second = revx[p.second];\n    }\n    l = xs.size();\n\n    std::sort(segs.begin(), segs.end());\n\n    int min = 0;\n    Int covered = 0, next = 0;\n    for (auto p : segs) {\n        if (p.first > covered) {\n            ++min;\n            covered = next;\n        }\n        next = std::max(next, p.second);\n    }\n    if (covered < l - 1) ++min;\n\n    vector<int> imos(l, 0);\n    for (auto p : segs) {\n        ++imos[p.first];\n        --imos[p.second];\n    }\n    imos.pop_back();\n    std::partial_sum(imos.begin(), imos.end(), imos.begin());\n    int max = n - *std::min_element(imos.begin(), imos.end()) + 1;\n\n    std::cout << min << \" \" << max << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define ri register int\n#define N 400005\nusing namespace std;\nint n,m,cnt,ans1,ans2=1e18,b[N],f[N];\nmap <int,int> mp;\nstruct node {\n\tint l,r;\n} a[N];\ntemplate <typename T> inline void read(T &x) {\n\tT f=1,c=getchar();\n\tfor (; c<48||57<c; c=getchar()) if (c=='-') f=-1;\n\tfor (x=0; 48<=c&&c<=57; c=getchar()) x=(x<<3)+(x<<1)+(c^48);\n\tx*=f;\n}\ntemplate <typename T> inline void print(T x) {\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>9) print(x/10);\n\tputchar(x%10+48);\n}\ninline int cmp(node a,node b) {\n\treturn a.l^b.l?a.l<b.l:a.r>b.r;\n}\nsigned main() {\n\tread(n),read(m),b[(n<<1)+1]=m;\n\tfor (ri i=1; i<=n; ++i) read(a[i].l),read(a[i].r),b[i]=a[i].l,b[i+n]=a[i].r;\n\tsort(b+1,b+2+(n<<1));\n\tfor (ri i=1; i<=(n<<1)+1; ++i)\n\t\tif (!mp[b[i]]) mp[b[i]]=++cnt;\n\tfor (ri i=1; i<=n; ++i) a[i].l=mp[a[i].l],a[i].r=mp[a[i].r];\n\tm=mp[m],sort(a+1,a+1+n,cmp),memset(b,0,sizeof(b));\n\tfor (ri i=1; i<=n; ++i) f[a[i].l]=max(f[a[i].l],a[i].r);\n\tfor (ri i=1,now=0,maxr=f[1]; i<m; ++i) {\n\t\tif (now<=i) now=maxr,ans1++;\n\t\tmaxr=max(maxr,f[i]);\n\t}\n\tfor (ri i=1; i<=n; ++i) b[a[i].l]++,b[a[i].r]--;\n\tfor (ri i=1; i<=m; ++i) b[i]+=b[i-1];\n\tfor (ri i=1; i<m; ++i) ans2=min(ans2,b[i]);\n\tprint(ans1),putchar(' '),print(n-ans2+1),putchar('\\n');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(a>b)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream&os, const pair<t,u>&p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream&operator <<(ostream&os,const vc<t>&v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nconst int inf=LLONG_MAX/3;\n\n//edit below\n\nint waf(int n,int s,vc<pi> lr){\n\tsort(all(lr));\n\tint cur=0,ans=0,head=0;\n\twhile(cur<s-1){\n\t\tint nx=cur;\n\t\twhile(head<n&&lr[head].a<=cur)\n\t\t\tchmax(nx,lr[head++].b);\n\t\tcur=nx;\n\t\tans++;\n\t}\n\treturn ans;\n}\nint relka(int n,int s,vc<pi> lr){\n\tvi p(s),q(s);\n\tfor(auto w:lr){\n\t\tp[w.b]++;\n\t\tq[w.a]++;\n\t}\n\trep(i,s-1)p[i+1]+=p[i];\n\tper(i,s-1)q[i]+=q[i+1];\n\tdmp(p);\n\tdmp(q);\n\tint ans=0;\n\trep(i,s-1)chmax(ans,p[i]+q[i+1]);\n\treturn ans;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,l;cin>>n>>l;\n\tvc<pi> lr(n);\n\trep(i,n)cin>>lr[i].a>>lr[i].b;\n\tvi pos;\n\tfor(auto w:lr){\n\t\tpos.pb(w.a);\n\t\tpos.pb(w.b);\n\t}\n\tmkuni(pos);\n\tfor(auto&w:lr){\n\t\tw.a=lower_bound(all(pos),w.a)-pos.bg;\n\t\tw.b=lower_bound(all(pos),w.b)-pos.bg;\n\t}\n\tdmp(lr);\n\tint x=waf(n,pos.size(),lr);\n\tint y=relka(n,pos.size(),lr);\n\tcout<<x<<\" \"<<y+1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) v.begin(),v.end()\nusing vint=vector<int>;\n\nint N,L;\n\nvector<int>lis[444444];\nint acc[444444];\nsigned  main(){\n  cin>>N>>L;\n  vector<int> l(N),r(N);\n  for(int i=0;i<N;i++)cin>>l[i]>>r[i];\n  \n   \n  vector<int>vs;\n  vs.push_back(0);vs.push_back(L);for(int i=0;i<N;i++)vs.push_back(l[i]),vs.push_back(r[i]);\n  sort(vs.begin(),vs.end());vs.erase(unique(vs.begin(),vs.end()),vs.end());\n  L=lower_bound(vs.begin(),vs.end(),L)-vs.begin();\n  for(int i=0;i<N;i++){\n    l[i]=lower_bound(vs.begin(),vs.end(),l[i])-vs.begin();\n    r[i]=lower_bound(vs.begin(),vs.end(),r[i])-vs.begin();\n  }\n\n  rep(i,N)lis[l[i]].pb(r[i]);\n\n  int cur=0;\n  int v=0;\n  int ans=0;\n  while(v!=L){\n    int vv=0;\n    while(cur<=v){\n      for(auto a:lis[cur])vv=max(vv,a);\n      cur++;\n    }\n    v=vv;\n    ans++;\n  }\n  cout<<ans<<\" \";\n  rep(i,N)acc[l[i]]++,acc[r[i]]--;\n  \n  ans=0;\n  rep(i,vs.size()-1){\n    acc[i+1]+=acc[i];\n    ans=max(ans,N-acc[i]+1);\n  }\n  cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#define llint long long\n#define inf 1000000000000000000\n\nusing namespace std;\n\nstruct SegTree{\n\tint size;\n\tvector<llint> seg;\n\t\n\tSegTree(){}\n\tSegTree(int size){\n\t\tthis->size = size;\n\t\tseg.resize(1<<(size+1));\n\t}\n\tvoid init()\n\t{\n\t\tfor(int i = 0; i < (1<<(size+1)); i++) seg[i] = inf;\n\t}\n\tvoid update(int i, llint val)\n\t{\n\t\ti += (1<<size);\n\t\tseg[i] = val;\n\t\twhile(i > 1){\n\t\t\ti /= 2;\n\t\t\tseg[i] = min(seg[i*2], seg[i*2+1]);\n\t\t}\n\t}\n\tllint query(int a, int b, int k, int l, int r)\n\t{\n\t\tif(b < l || r < a) return inf;\n\t\tif(a <= l && r <= b) return seg[k];\n\t\tllint lval = query(a, b, k*2, l, (l+r)/2);\n\t\tllint rval = query(a, b, k*2+1, (l+r)/2+1, r);\n\t\treturn min(lval, rval);\n\t}\n\tllint query(int a, int b)\n\t{\n\t\treturn query(a, b, 1, 0, (1<<size)-1);\n\t}\n};\n\nllint n, L;\nllint l[200005], r[200005];\nvector<llint> comp;\nllint dp[400005];\nllint dif[400005], sum[400005];\nvector<llint> vec[400005];\nSegTree seg(19);\n\nint main(void)\n{\n\tcin >> n >> L;\n\tfor(int i = 1; i <= n; i++) cin >> l[i] >> r[i];\n\t\n\tfor(int i = 1; i <= n; i++) comp.push_back(l[i]), comp.push_back(r[i]);\n\tsort(comp.begin(), comp.end());\n\tcomp.erase(unique(comp.begin(), comp.end()), comp.end());\n\tfor(int i = 1; i <= n; i++) l[i] = lower_bound(comp.begin(), comp.end(), l[i]) - comp.begin() + 1;\n\tfor(int i = 1; i <= n; i++) r[i] = lower_bound(comp.begin(), comp.end(), r[i]) - comp.begin() + 1;\n\tfor(int i = 1; i <= n; i++) vec[r[i]].push_back(l[i]);\n\t\n\tllint m = comp.size();\n\t//cout << m << endl;\n\t\n\t//for(int i = 1; i <= n; i++) cout << l[i] << \" \" << r[i] << endl;\n\t\n\tseg.init();\n\tseg.update(1, 0);\n\tfor(int i = 2; i <= m; i++){\n\t\tllint mn = inf;\n\t\tfor(int j = 0; j < vec[i].size(); j++){\n\t\t\tmn = min(mn, seg.query(vec[i][j], i-1));\n\t\t}\n\t\tseg.update(i, mn+1);\n\t}\n\tllint ansx = seg.query(m, m);\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tdif[l[i]]++, dif[r[i]]--;\n\t}\n\tllint ansy = inf;\n\tfor(int i = 1; i < m; i++){\n\t\tsum[i] = sum[i-1] + dif[i];\n\t\tansy = min(ansy, sum[i]);\n\t}\n\t//cout << ansy << endl;\n\tansy = n - ansy + 1;\n\t\n\tcout << ansx << \" \" << ansy << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace::std;\nstruct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// #include <boost/numeric/interval.hpp>\n// #include <boost/numeric/interval/io.hpp>\n// #include <boost/intrusive/rbtree.hpp>\n// #include <boost/geometry.hpp>\n// #include <boost/geometry/geometries/linestring.hpp>\n// #include <boost/geometry/geometries/polygon.hpp>\n// #include <boost/geometry/geometries/point_xy.hpp>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds;\nusing namespace::std;\n// namespace mp = boost::multiprecision;\n// typedef mp::number<mp::cpp_dec_float<0>> cfloat;\n// typedef mp::cpp_int cint;\ntypedef long long lint;\ntypedef long long ll;\ntypedef long double ldouble;\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\ntypedef vector<double> dvec;\ntypedef vector<vector<double>> dmat;\ntypedef vector<vector<vector<double>>> dmat3;\ntypedef vector<string> svec;\ntypedef vector<vector<string>> smat;\ntypedef vector<vector<vector<string>>> smat3;\ntypedef vector<pair<lint,lint>> pvec;\ntypedef vector<vector<pair<lint,lint>>> pmat;\ntypedef vector<vector<vector<pair<lint,lint>>>> pmat3;\n#define rep(i, n) for(lint i = 0; i < (lint)(n); i++)\n#define irep(i) for(lint i = 0;; i++)\n#define irep1(i) for(lint i = 1;; i++)\n#define irep2(i) for(lint i = 2;; i++)\n#define rrep(i, n) for(lint i = (lint)(n-1); i >-1; i--)\n#define rrepi(i,a,b) for(lint i = (lint)(b-1); i >a-1; i--)\n#define repi(i,a,b) for(lint i=lint(a);i<lint(b);i++)\n#define rep2(i,a,b,c) for(lint i=lint(a);i>lint(b);i+=c)\n#define all(x) (x).begin(),(x).end()\n#define PI 3.141592653589793\n#define dist(x1,y1,x2,y2) (pow(pow(x2-x1,2)+pow(y2-y1,2),0.5))\n#define output(v) do{bool f=0;for(auto i:v){cout<<(f?\" \":\"\");if(i>INF/2)cout<<\"INF\";else cout<<i;f=1;}cout<<\"\\n\";}while(0)\n#define output2(v) for(auto j:v)output(j);\n#define input(a,n) lint n;cin>>n;vector<lint>a(n);rep(i,n)cin>>a[i];\n#define SUM(v) accumulate(all(v),0LL)\n#define INF (1LL<<60)\n#define IINF (1<<30)\n#define EPS (1e-10)\n#define LINF 9223372036854775807\n#define MOD 1000000007\n#define endl \"\\n\"\ntemplate<typename T=lint>T in(){return *istream_iterator<T>(cin);}\ninline lint gcd(lint a,lint b){return b?gcd(b,a%b):a;}\ninline lint lcm(lint a,lint b){return a*b/gcd(a,b);}\ninline bool chmin(auto& s,const auto& t){bool res=s>t;s=min(s,t);return res;}\ninline bool chmax(auto& s,const auto& t){bool res=s<t;s=max(s,t);return res;}\nvector<lint> dx={-1,1,0,0,1,1,-1,-1};\nvector<lint> dy={0,0,-1,1,1,-1,1,-1};\n\n\nint main(){\n    lint n,k;\n    cin>>n>>k;\n    vec l(n),r(n),v,b;\n    vector<pair<lint,lint>> a;\n    rep(i,n){\n        cin>>l[i]>>r[i];\n        a.push_back(make_pair(l[i],r[i]));\n    }\n    sort(all(a));\n    lint now=0,cnt=0;\n    lint mx=0;\n    rep(i,n){\n        if(a[i].first<=now){\n            chmax(mx,a[i].second);\n        }else{\n            cnt++;\n            now=mx;\n            mx=a[i].second;\n        }\n    }\n    if(now!=k)cnt++;\n    rep(i,n)b.push_back(l[i]);\n    //rep(i,n)b.push_back(r[i]-1);\n    rep(i,n)b.push_back(r[i]);\n    sort(all(b));\n    b.erase(unique(all(b)),b.end());\n    rep(i,n)l[i]=lower_bound(all(b),l[i])-b.begin();\n    rep(i,n)r[i]=lower_bound(all(b),r[i])-b.begin();\n    lint sz=lower_bound(all(b),k)-b.begin();\n    v.resize(sz,0);\n    rep(i,n){\n        v[l[i]]++;\n        if(r[i]<sz)v[r[i]]--;\n    }\n    repi(i,1,sz){\n        v[i]+=v[i-1];\n    }\n    cout<<cnt<<\" \"<<n-*min_element(all(v))+1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by yamunaku on 2019/10/15.\n//\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repl(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perl(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD9 998244353\n#define MOD1 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n#define CST(x) cout<<fixed<<setprecision(x)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> mti;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> mtl;\n\nstruct ku{\n    ll l;\n    ll r;\n};\n\nint main(){\n    ll n;\n    ll m;\n    cin >> n >> m;\n    vector<ku> a(n);\n    map<ll,int> mp;\n    rep(i,n){\n        cin >> a[i].l >> a[i].r;\n        mp[a[i].l]=0;\n        mp[a[i].r]=0;\n    }\n    int sz = 0;\n    for(auto &p: mp) p.second=sz++;\n    sort(all(a),[](ku &l, ku &r){\n        return l.l < r.l;\n    });\n    priority_queue<ll> q;\n    ll now = 0;\n    int idx = 0;\n    ll ans = 0;\n    while(now<m){\n        while(idx<n){\n            if(a[idx].l>now) break;\n            q.push(a[idx].r);\n            idx++;\n        }\n        ans++;\n        now = q.top();\n    }\n    cout << ans << \" \";\n    vi v(sz);\n    rep(i,n){\n        v[mp[a[i].l]]++;\n        v[mp[a[i].r]]--;\n    }\n    ll ans2 = n-v[0]+1;\n    repl(i,1,sz-1){\n        v[i]+=v[i-1];\n        ans2=max(ans2,n-v[i]+1);\n    }\n    cout << ans2 << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define N 2000006\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nint n,l,maxn=0,b[N],c[N],ans1,ans2=inf;\nmap <int,int> mp;\nstruct node\n{\n\tint l,r;\n}a[N];\nbool cmp(node a,node b)\n{\n\tif (a.l==b.l) return a.r>b.r;\n\telse return a.l<b.l;\n}\nsigned main()\n{\n\tscanf(\"%lld%lld\",&n,&l);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&a[i].l,&a[i].r);\n\t\tb[2*i-1]=a[i].l;\n\t\tb[2*i]=a[i].r;\n\t}\n\tsort(b+1,b+2*n+1);\n\tint cnt=unique(b+1,b+2*n+1)-b-1;\n\tl=lower_bound(b+1,b+cnt+1,l)-b;\n\tfor (int i=1;i<=n*2;i++)\n\t{\n\t\ta[i].l=lower_bound(b+1,b+cnt+1,a[i].l)-b;\n\t\ta[i].r=lower_bound(b+1,b+cnt+1,a[i].r)-b;\n\t\tc[a[i].l]++;\n\t\tc[a[i].r]--;\n\t}\n\tfor (int i=1;i<cnt;i++)\n\t{\n\t\tif (i) c[i]+=c[i-1];\n\t\tans2=min(ans2,c[i]);\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tans1=0;\n\tint r=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint j=i,tmp=a[i].r;\n\t\twhile (a[j+1].l<=r && j<n) tmp=max(tmp,a[j+1].r),j++;\n\t\ti=j;\n\t\tr=max(tmp,r);\n\t\tans1++;\n\t\tif (r==l) break;\n\t}\n\tprintf(\"%lld %lld\\n\",ans1,n-ans2+1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n\n#define int long long\n\n\nsigned main(){\n\n    int N, MAX;\n    cin >> N >> MAX;\n    vector<pair<int,int> > A(N);\n    set<int> st;\n    for(int i=0;i<N;i++){\n        cin >> A[i].first >> A[i].second;\n        st.insert(A[i].second);\n        st.insert(A[i].first);\n    }\n    \n    sort(A.begin(), A.end());\n\n\n    int cur = 0;\n    int ncur = 0;\n    int X = 1;\n    for(int i=0;i<N;i++){\n        if(cur < A[i].first){\n            cur = ncur;\n            if(cur == MAX)break;\n            X++;\n        }\n        ncur = max(A[i].second, ncur);\n    }\n\n   \n\n    vector<pair<int,int> > R = A;\n    vector<pair<int,int> > L = A;\n    for(int i=0;i<N;i++){\n        swap(R[i].first, R[i].second);\n    }\n    sort(R.begin(), R.end());\n    sort(L.begin(), L.end());\n    int Y = 0;\n    for(int i = 0;i <= N; i++){\n        int l;\n        if(i < N)l = L[i].first;\n        else l = MAX;\n        if(l > 0){\n            int t = upper_bound(R.begin(), R.end(), make_pair(l, (int)-1)) - R.begin();\n            Y = max(Y, N - i + t);\n        }\n\n    }\n    cout << X << \" \" << Y + 1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate <class T = int>\nusing V = vector<T>;\ntemplate <class T = int>\nusing VV = V<V<T>>;\n\nint main()\n{\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  lint m;\n  cin >> m;\n  V<lint> l(n), r(n);\n  for (int i = 0; i < n; ++i)\n  {\n    cin >> l[i] >> r[i];\n  }\n  auto vl = l, vr = r;\n  auto v = l;\n  v.insert(end(v), begin(r), end(r));\n  sort(begin(v), end(v));\n  v.erase(unique(begin(v), end(v)), end(v));\n  for (auto &&e : l)\n  {\n    e = lower_bound(begin(v), end(v), e) - begin(v);\n  }\n  for (auto &&e : r)\n  {\n    e = lower_bound(begin(v), end(v), e) - begin(v);\n  }\n  for (auto &&e : vl)\n  {\n    e = lower_bound(begin(v), end(v), e) - begin(v);\n  }\n  for (auto &&e : vr)\n  {\n    e = lower_bound(begin(v), end(v), e) - begin(v);\n  }\n  sort(begin(vl), end(vl));\n  sort(begin(vr), end(vr));\n\n  map<int, int> mp;\n  for (int i = 0; i < n; ++i)\n  {\n    mp[l[i]] = max<lint>(mp[l[i]], r[i]);\n  }\n\n  m = v.size() - 1;\n  // cerr << m << endl;\n  int x = 0, p = 0;\n  auto itr = begin(mp);\n  while (p < m)\n  {\n    int np = p;\n    while (itr != end(mp) and itr->first <= p)\n    {\n      np = max(np, itr->second);\n      ++itr;\n    }\n    p = np;\n    // cerr << np << endl;\n    ++x;\n  }\n  int y = 0;\n  for (int i = 0; i < m; ++i)\n  {\n    int z = upper_bound(begin(vr), end(vr), i) - begin(vr);\n    z += end(vl) - lower_bound(begin(vl), end(vl), i + 1);\n    y = max(y, z);\n    // cerr << i << ' ' << z << endl;\n  }\n  cout << x << ' ' << y + 1 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\n  long long N, L;\n  cin >> N >> L;\n  vector<pair<long long, long long>> LR(N);\n\n  long long a, b;\n  for(int i = 0; i < N; i++){\n    cin >> a >> b;\n    LR[i] = make_pair(a, b);\n  }\n\n  sort(LR.begin(), LR.end());\n\n  int index = 0;\n  long long endPoint = 0;\n  int ansX = 0;\n  priority_queue<long long> pq;\n\n  // X\n  while(endPoint != L){\n    bool isAppend = false;\n    if(index != N){\n      auto temp = LR[index];\n      if(temp.first <= endPoint){\n\tindex++;\n\tisAppend = true;\n\tpq.push(temp.second);\n      }\n    }\n\n    if(!isAppend){\n      long long temp = pq.top();\n      pq.pop();\n\n      ansX++;\n      endPoint = temp;\n    }\n  }\n\n  // Y\n  vector<pair<long long, int>> eventList(2 * N);\n  for(int i = 0; i < N; i++){\n    auto temp = LR[i];\n    eventList[2 * i] = make_pair(temp.first, 1);\n    eventList[2 * i + 1] = make_pair(temp.second, -1);\n  }\n\n  sort(eventList.begin(), eventList.end());\n\n  int cnt = 0;\n  int minCnt = N;\n  long long before = 0;\n  index = 0;\n\n  while(index != 2 * N){\n    auto temp = eventList[index];\n    while(temp.first == before){\n      cnt += temp.second;\n      index++;\n      if(index == 2 * N){\n\tbreak;\n      }\n      temp = eventList[index];\n    }\n    before = temp.first;\n\n    if(index == 2 * N){\n      break;\n    }\n    minCnt = min(minCnt, cnt);\n  }\n\n  int ansY = N - minCnt + 1;\n\n  cout << ansX << \" \" << ansY << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n//#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nll n;\nll L;\nvector<pair<ll,ll>>vec;\nvector<ll>za;\npriority_queue<ll>que;\nvector<ll>edge[1300005];\nll cnt[1300005];\n\nint main(){\n    cin >> n >> L;\n    rep(i,n){\n        ll a,b; cin >> a >> b;\n        vec.pb(mp(a,b-1));\n        if(a-1 >= 0) za.pb(a-1); za.pb(a); if(a+1 < L) za.pb(a+1);\n        if(b-2 >= 0) za.pb(b-2); za.pb(b-1); if(b < L) za.pb(b);\n    }\n    za.pb(0); za.pb(L-1);\n    SORT(za); ERASE(za);\n    rep(i,n){\n        vec[i].fi = POSL(za,vec[i].fi); vec[i].sc = POSL(za,vec[i].sc);\n        edge[vec[i].fi].pb(vec[i].sc);\n        cnt[vec[i].fi]++; cnt[vec[i].sc+1]--;\n    }\n    rep(i,edge[0].size()) que.push(edge[0][i]);\n    ll ans_min = 0; ll pre = 0;\n    while(!que.empty()){\n        ll q = que.top(); que.pop(); ans_min++;\n        if(q == za.size()-1) break;\n        for(int i=pre+1;i<=q+1;i++) rep(j,edge[i].size()) que.push(edge[i][j]);\n        pre = q+1;\n    }\n    for(int i=1;i<za.size();i++) cnt[i] += cnt[i-1];\n    ll ans_max = 0;\n    for(int i=0;i<za.size();i++) ans_max = max(ans_max,n-cnt[i]+1);\n    cout << ans_min << \" \" << ans_max << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nvoid compress(vector<ll>& xs) {\n    sort(xs.begin(), xs.end());\n    xs.erase(unique(xs.begin(), xs.end()), xs.end());\n}\n\nint main() {\n    ll n, L; cin >> n >> L;\n    vector<ll> l(n), r(n);\n    vector<ll> not_cover_cand, ps;\n    for(int i = 0; i < n; ++i) {\n        cin >> l[i] >> r[i];\n        ps.push_back(l[i]);\n        ps.push_back(r[i]);\n        if(l[i] != 0) {\n            not_cover_cand.push_back(l[i] - 1);\n            ps.push_back(l[i] - 1);\n        }\n        if(r[i] != L) {\n            not_cover_cand.push_back(r[i]);\n        }\n    }\n    compress(ps);\n    compress(not_cover_cand);\n\n    const int m = ps.size();\n    vector<ll> max_to(ps.size(), -1);\n    for(int i = 0; i < n; ++i) {\n        l[i] = lower_bound(ps.begin(), ps.end(), l[i]) - ps.begin();\n        r[i] = lower_bound(ps.begin(), ps.end(), r[i]) - ps.begin();\n        max_to[l[i]] = max(max_to[l[i]], r[i]);\n    }\n    for(int i = 0; i + 1 < m; ++i) {\n        max_to[i + 1] = max(max_to[i + 1], max_to[i]);\n    }\n\n    int x = 0;\n    for(ll i = 0, cur = 0; i < m && cur != m - 1; ++i) {\n        x += 1;\n        cur = max_to[cur];\n    }\n\n    vector<int> sum_l(m + 1), sum_r(m + 1);\n    for(int i = 0; i < n; ++i) {\n        sum_l[r[i]] += 1;\n        if(l[i] != 0) {\n            sum_r[l[i] - 1] += 1;\n        }\n    }\n    for(int i = 0; i < m; ++i) {\n        sum_l[i + 1] += sum_l[i];\n    }\n    for(int i = m - 1; i >= 0; --i) {\n        sum_r[i] += sum_r[i + 1];\n    }\n    int y = 0;\n    for(auto p : not_cover_cand) {\n        p = lower_bound(ps.begin(), ps.end(), p) - ps.begin();\n        //cout << ps[p] << \" \" << \" -> \" << sum_l[p] << \" \" << sum_r[p] << endl;\n        y = max(y, sum_l[p] + sum_r[p]);\n    }\n    cout << x << \" \" << y + 1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll,ll>;\n#define pb push_back\n#define fi first\n#define sec second\n#define INF 1000000000\nconst int SIZE = 1<<20;\nstruct segtree{\n\tint seg[SIZE*2];\n\tsegtree(){\n\t\tfor(int i=0;i<SIZE*2;i++){\n\t\t\tseg[i] = INF;\n\t\t}\n\t}\n\tvoid update(int k,int x){\n\t\tk += SIZE-1;\n\t\tseg[k] = min(seg[k],x);\n\t\twhile(k>0){\n\t\t\tk = (k-1)/2;\n\t\t\tseg[k] = min(seg[k*2+1],seg[k*2+2]);\n\t\t}\n\t}\n\tint query(int a,int b,int k,int l,int r){\n\t\tif(r<=a||b<=l)return INF;\n\t\tif(a<=l&&r<=b)return seg[k];\n\t\tint mid = (l+r)/2;\n\t\treturn min(query(a,b,k*2+1,l,mid),query(a,b,k*2+2,mid,r));\n\t}\n}seg;\nbool comp(P a,P b){\n\tif(a.sec!=b.sec)return a.sec < b.sec;\n\telse return a.fi < b.fi;\n}\nint N;\nll L;\nvector<ll> zip;\nvector<P> vec;\nint dp[400100];\nint rui[400100];\nint main(){\n\tcin >> N >> L;\n\tzip.pb(L);\n\tvec.resize(N);\n\tfor(int i=0;i<N;i++){\n\t\tcin >> vec[i].fi >> vec[i].sec;\n\t\tzip.pb(vec[i].fi);\n\t\tzip.pb(vec[i].sec);\n\t}\n\tzip.pb(0ll);\n\tsort(zip.begin(),zip.end());\n\tzip.erase(unique(zip.begin(),zip.end()),zip.end());\n\tfor(int i=0;i<N;i++){\n\t\tvec[i].fi = lower_bound(zip.begin(),zip.end(),vec[i].fi)-zip.begin();\n\t\tvec[i].sec = lower_bound(zip.begin(),zip.end(),vec[i].sec)-zip.begin();\n\t\trui[vec[i].fi]++;\n\t\trui[vec[i].sec]--;\n\t}\n\tsort(vec.begin(),vec.end(),comp);\n\t// for(int i=0;i<vec.size();i++){\n\t// \tcout << vec[i].fi << ' ' << vec[i].sec << endl;\n\t// }\n\tfor(int i=1;i<=zip.size();i++){\n\t\tdp[i] = INF;\n\t}\n\tdp[0] = 0ll;\n\tseg.update(0,dp[0]);\n\tfor(int i=0;i<vec.size();i++){\n\t\tint l = vec[i].fi;\n\t\tint r = vec[i].sec;\n\t\tdp[r] = min(dp[r],seg.query(l,r,0,0,SIZE)+1);\n\t\tseg.update(r,dp[r]);\n\t}\n\tfor(int i=1;i<zip.size();i++){\n\t\trui[i] += rui[i-1];\n\t}\n\tint mi = INF;\n\tfor(int i=0;i+1<zip.size();i++){\n\t\tmi = min(mi,rui[i]);\n\t}\n\tcout << dp[zip.size()-1] << ' ' << N-mi+1 << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<utility>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<ll, ll> P;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) (x).begin(),(x).end()\n#define stop char nyaa; cin>>nyaa;\n\n\nvoid solve() {\n\tint n; ll l;\n\tcin >> n >> l;\n\tvector<P> v(n);\n\trep(i, n) {\n\t\tcin >> v[i].first >> v[i].second;\n\t}\n\tsort(v.begin(), v.end());\n\tint ans = 0;\n\tint cur = 0;\n\tll ri = 0;\n\twhile (cur < n&&v[cur].first == 0) {\n\t\tri = max(ri, v[cur].second);\n\t\tcur++;\n\t}\n\tans = 1;\n\t//cout << ri << endl;\n\twhile (ri<l) {\n\t\tans++;\n\t\tll nexri = ri;\n\t\twhile (cur < n&&v[cur].first <= ri) {\n\t\t\tnexri = max(nexri, v[cur].second);\n\t\t\tcur++;\n\t\t}\n\t\tri = nexri;\n\t}\n\tll ans1 = ans;\n\tans = 0;\n\tint c = 0;\n\tcur = 0;\n\tvector<P> x;\n\trep(i, n) {\n\t\tx.push_back({ v[i].first,1 });\n\t\tx.push_back({ v[i].second,-1 });\n\t}\n\tsort(x.begin(), x.end());\n\tint ans2 = 0;\n\trep(i, x.size()) {\n\t\tc += x[i].second;\n\t\twhile (i + 1 < x.size() && x[i].first == x[i + 1].first) {\n\t\t\ti++; c += x[i].second;\n\t\t}\n\t\t//cout << i << \" \" << c << endl;\n\t\tif (i+1 != x.size()) {\n\t\t\tans2 = max(ans2, n - c);\n\t\t}\n\t}\n\tans2 = min(ans2+1, n);\n\tcout << ans1 << \" \" << ans2 << endl;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstdio>\n#include <complex>\n#include <numeric>\n#include <string.h>\n#include <random>\n#define rep(i,n) for (int i = 0; i < (int)n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pp;\ntypedef pair<ll, ll> pl;\ndouble PI = 3.141592653589793238462643383279;\nconst double EPS = 1e-9;\nconst ll MOD = 998244353;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\n\nll N, L;\npl p[200000];\nll dp[400001];\nll sum[400001];\nmap<ll, int> rev;\n\nint main() {\n    cin >> N >> L;\n    rep(i,N) cin >> p[i].first >> p[i].second;\n    sort(p, p+N);\n    set<ll> s;\n    rep(i,N) { s.insert(p[i].first); s.insert(p[i].second); }\n    {\n        int i = 0;\n        for (auto it = s.begin(); it != s.end(); it++) {\n            rev[*it] = i++;\n        }\n    }\n    rep(i,N) {\n        p[i].first = rev[p[i].first];\n        p[i].second = rev[p[i].second];\n    }\n    dp[0] = 0;\n    int st = 0;\n    int ans = 0;\n    ll last = 0;\n    while (true) {\n        ll M = 0;\n        for (; st < N; st++) {\n            if (p[st].first > last) break;\n            M = max(M, p[st].second);\n        }\n        ans++;\n        last = M;\n        if (st == N) break;\n        if (last+1 == s.size()) break;\n    }\n    rep(i,N) {\n        sum[p[i].first]++;\n        sum[p[i].second+1]--;\n    }\n    ll ans2 = sum[0];\n    for (int i = 1; i < s.size(); i++) {\n        sum[i] += sum[i-1];\n        ans2 = min(ans2, sum[i]);\n    }\n    cout << ans << \" \" << N-ans2+1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for (int i = (a); i < (b); i++)\n#define rep(i, b) for (int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x) cerr << #x << \" = \" << (x) << endl;\n#define int long long\nusing namespace std;\n\ntemplate <typename X, typename T>\nauto vectors(X x, T a) {\n\treturn vector<T>(x, a);\n}\n\ntemplate <typename X, typename Y, typename Z, typename... Zs>\nauto vectors(X x, Y y, Z z, Zs... zs) {\n\tauto cont = vectors(y, z, zs...);\n\treturn vector<decltype(cont)>(x, cont);\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n\trep(i, v.size()) { os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); }\n\treturn os;\n}\ntemplate <typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n\tfor (T& x : v) { is >> x; }\n\treturn is;\n}\n\nsigned main() {\n\tint n, l;\n\tcin >> n >> l;\n\n\tvector<pair<int, int>> s(n);\n\trep(i, n) {\n\t\tcin >> s[i].first >> s[i].second;\n\t\ts[i].second *= -1;\n\t}\n\tsort(all(s));\n\tfor (auto& p : s) p.second *= -1;\n\n\tint cur = 0;\n\tint ans = 0;\n\tint idx = 0;\n\twhile (idx < n and cur < l) {\n\t\tans++;\n\t\tint nxt = 0;\n\t\twhile (idx < n and s[idx].first <= cur) {\n\t\t\t// show(s[idx].first)\n\t\t\t// show(cur)\n\t\t\tnxt = max(nxt, s[idx].second);\n\t\t\tidx++;\n\t\t}\n\t\t// show(idx)\n\t\tcur = nxt;\n\t}\n\tcout << ans << ' ';\n\n\tmap<int,int> m;\n\tfor(auto p : s){\n\t\tm[p.first]++;\n\t\tm[p.second]--;\n\t}\n\tint sum = 0;\n\tans = 1e9;\n\tint i = 0;\n\tfor(auto p : m){\n\t\tsum += p.second;\n\t\ti++;\n\t\tif(i == m.size()) break;\n\t\tans = min(ans, sum);\n\t\t//cout << p.first << ' ' << p.second << endl;\n\t}\n\tcout << n - ans + 1 << endl;\n\treturn 0;\n\n\n\tans = 1e9;\n\tcur = 0;\n\tidx = 0;\n\tpriority_queue<int, vector<int>, greater<int>> q;\n\twhile (idx < n and cur < l) {\n\t\twhile (idx < n and s[idx].first <= cur) { q.emplace(s[idx++].second); }\n\t\tint d = 0;\n\t\tint id = idx - 1;\n\t\twhile(id >= 0 and s[id].second == cur){\n\t\t\tid--;\n\t\t\td++;\n\t\t}\n\t\tshow(d)\n\t\tans = min<int>(ans, q.size() - d);\n\t\tcur = q.top();\n\t\tq.pop();\n\t}\n\tcout << n - ans + 1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define inf (int)(1e18)\n\ntemplate<typename M>\nstruct segment_tree{\n\ttypedef function<M(M, M)> F;\n\tint size;\n\tvector<M> val;\n\tF f;\n\tM e;\n\n\tsegment_tree(int N, vector<M> &data, F f, M e) : f(f), e(e){\n\t\tsize = 1;\n\t\twhile(size < N) size *= 2;\n\t\tval.assign(2 * size, e);\n\t\tfor(int i = 0; i < N; i++) val[size + i] = data[i];\n\t\tfor(int i = 0; i < size; i++) val[size + i] = e;\n\t\tfor(int i = size - 1; i > 0; i--) val[i] = f(val[2 * i], val[2 * i + 1]);\n\t}\n\n\tvoid update(int k, M x){\n\t\tk += size;\n\t\tval[k] = x;\n\t\twhile(k /= 2) val[k] = f(val[2 * k], val[2 * k + 1]);\n\t}\n\n\tM query(int l, int r){\n\t\tM L = e, R = e;\n\t\tfor(l += size, r += size; l < r; l /= 2, r /= 2){\n\t\t\tif(l & 1) L = f(L, val[l++]);\n\t\t\tif(r & 1) R = f(val[--r], R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n};\n\nint mini(int a, int b){\n\treturn a <= b ? a : b;\n}\n\nsigned main(){\n\tint N, L, i, j;\n\tscanf(\"%lld%lld\", &N, &L);\n\tvector<int> l(N), r(N);\n\tvector<int> event(0);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lld%lld\", &l[i], &r[i]);\n\t\tevent.push_back(l[i]);\n\t\tevent.push_back(r[i]);\n\t}\n\tsort(event.begin(), event.end());\n/*\tfor(i = 1, j = 1; j < 2 * N; j++){\n\t\tif(event[j] != event[j - 1]){\n\t\t\tevent[i] = event[j];\n\t\t\ti++;\n\t\t}\n\t}\n\tevent.erase(event.begin() + i, event.end());\n*/\tL = 0;\n\tfor(i = 0; i < N; i++){\n\t\tl[i] = lower_bound(event.begin(), event.end(), l[i]) - event.begin();\n\t\tr[i] = lower_bound(event.begin(), event.end(), r[i]) - event.begin();\n\t\tL = max(L, r[i]);\n\t}\n/*\tprintf(\"L = %lld\\n\", L);\n\tfor(i = 0; i < N; i++){\n\t\tprintf(\"(%lld, %lld)\\n\", l[i], r[i]);\n\t}\n*/\tvector<vector<int>> corl(L + 1, vector<int>(0));\n\tfor(i = 0; i < N; i++){\n\t\tcorl[r[i]].push_back(l[i]);\n\t}\n\tvector<int> data(L + 1, inf);\n//\tdata[0] = 0;\n\tsegment_tree<int> dp(L + 1, data, mini, inf);\n\tdp.update(0, 0);\n//\tprintf(\"dp[0] = %lld\\n\", dp.query(0, 1));\n\tfor(i = 1; i <= L; i++){\n//\t\tprintf(\"i = %lld\\n\", i);\n\t\tint now = inf;\n\t\tfor(j = 0; j < corl[i].size(); j++){\n//\t\t\tprintf(\"corl[i][%lld]\\n\", corl[i][j]);\n\t\t\tnow = min(now, dp.query(corl[i][j], i) + 1);\n\t\t}\n//\t\tprintf(\"test3\\n\");\n\t\tdp.update(i, now);\n//\t\tprintf(\"%lld\\n\", dp.query(i, i + 1));\n\t}\n//\tprintf(\"test5\\n\");\n\tprintf(\"%lld \", dp.query(L, L + 1));\n\n\tvector<int> A(L + 1, 0);\n\tfor(i = 0; i < N; i++){\n\t\tA[l[i]]++;\n\t\tA[r[i]]--;\n\t}\n\tint minA = A[0];\n\tfor(i = 1; i < L; i++){\n\t\tA[i] += A[i - 1];\n\t\tminA = min(minA, A[i]);\n\t}\n/*\tfor(i = 0; i <= L; i++){\n\t\tprintf(\"A[%lld] = %lld\\n\", i, A[i]);\n\t}\n*/\tprintf(\"%lld\\n\", N - minA + 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ll long long\n\nusing namespace std;\n\nint main()\n{\n\tll n, l; cin>>n>>l;\n\tvector<pair<ll, ll> > itv(n);\n\tfor(int i=0; i<n; i++){\n\t\tll l, r; cin>>l>>r;\n\t\titv[i] = make_pair(l, r);\n\t}\n\tsort(itv.begin(), itv.end());\n\tll cur=0, x=0;\n\tfor(int i=0; i<n; i++){\n\t\tll maximum=0;\n\t\twhile(itv[i].first<=cur){\n\t\t\tmaximum = max(maximum, itv[i].second);\n\t\t\ti++;\n\t\t\tif (i==n) break;\n\t\t}\n\t\tcur = maximum;\n\t\tx++; i--;\n\t\tif (cur==l) break;\n\t}\n\tll y;\n\tset<ll> S;\n\tmap<ll, ll> M;\n\tfor(int i=0; i<n; i++){\n\t\tS.insert(itv[i].first); S.insert(itv[i].second);\n\t}\n\tll idx=0;\n\tfor(auto it=S.begin(); it!=S.end(); it++){\n\t\tM[*it] = idx;\n\t\tidx++;\n\t}\n\tvector<ll> imos(S.size()+1);\n\tfor(int i=0; i<n; i++){\n\t\tll left = M[itv[i].first];\n\t\tll right = M[itv[i].second];\n\t\timos[left]++;\n\t\timos[right+1]--;\n\t}\n\tll minimum = imos[0];\n\tfor(int i=1; i<imos.size()-1; i++){\n\t\timos[i]+=imos[i-1];\n\t\tminimum = min(minimum, imos[i]);\n\t}\n\ty = n-(minimum-1);\n\tcout << x << \" \" << y << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <functional>\nusing namespace std;\nusing ll = long long;\n\nstruct SegTree {\n    using F = function<int(int, int)>;\n    const F f;\n    const int M1;\n    int sz;\n    vector<int> dat;\n    SegTree(int n, const F f, const int &M1) : f(f), M1(M1), sz(1) {\n        while (sz < n) sz <<= 1;\n        dat.assign(sz * 2, M1);\n    }\n    void set(int k, const int &x) { dat[k + sz] = x; }\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            dat[k] = f(dat[2 * k], dat[2 * k + 1]);\n        }\n    }\n    int get(int a, int b) {\n        int L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, dat[a++]);\n            if (b & 1) R = f(dat[--b], R);\n        }\n        return f(L, R);\n    }\n    int operator[](const int &k) const { return dat[k + sz]; }\n};\n\nint main() {\n    int N; ll L; cin >> N >> L;\n    vector<ll> left(N), right(N);\n    map<long long, int> id;\n    int sz = 0;\n    for (int i = 0; i < N; i++) cin >> left[i] >> right[i], id[left[i]], id[right[i]];\n    for (auto &p: id) p.second = sz++;\n    for (int i = 0; i < N; i++) left[i] = id[left[i]], right[i] = id[right[i]];\n    vector<int> cnt(sz + 1);\n    SegTree seg(sz, [](int a, int b) { return max(a, b); }, 0);\n    for (int i = 0; i < N; i++) {\n        int l = left[i], r = right[i];\n        cnt[left[i]]++, cnt[right[i]]--;\n        seg.set(l, max(seg[l], r));\n    }\n    //---\n    seg.build();\n    int c = 0;\n    int cur = 0;\n    while (cur < sz - 1) {\n        cur = seg.get(0, cur + 1);\n        c++;\n    }\n    cout << c << \" \";\n    //---\n    for (int i = 0; i < sz; i++) cnt[i + 1] += cnt[i];\n    int mi = *min_element(cnt.begin(), cnt.begin() + sz - 1);\n    cout << N - mi + 1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n\n #define int long long\n #define pa pair<int,int>\n #define ll long long\n  #define  mp make_pair\n  #define  pb push_back\n\n\nusing namespace std;\nconst int inf=1000000007;\n\n\nint solve_min(vector<pa> &ve,int n,int l){\n\tint ans=0;\n\tint pos=0;\n\tint it=0;\n\tint ma=0;\n\twhile(1){\n\t\twhile(it!=n && ve[it].first<=pos){\n\t\t\tma=max(ma,ve[it].second);\n\t\t\tit++;\n\t\t}\n\t\tans++;\n\t\tpos=ma;\n\t\tif(pos==l) return ans;\n\t}\n}\n\nint solve_max(vector<pa> &ve,int n,int l){\n\tvector<pa> V(2*n);\n\tfor(int i=0;i<n;i++)V[i]=mp(ve[i].first,1);\n\tfor(int i=0;i<n;i++)V[i+n]=mp(ve[i].second,-1);\n\tV.pb(mp(inf*2000000000ll,100));\n\tsort(V.begin(),V.end());\n\tint cnt=0;\n\tint ans=inf;\n\tfor(int i=0;i<2*n;i++){\n\t\tcnt+=V[i].second;\n\t\tif(V[i].first==l) break;\n\t\tif(V[i].first!=V[i+1].first)ans=min(ans,cnt);\n\t}\n\treturn n+1-ans;\n}\n\n signed main(){\n \t\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nint n,l;\n \tcin>>n>>l;\n\n \tvector<pa> ve(n);\n \tfor(int i=0;i<n;i++)cin>>ve[i].first>>ve[i].second;\n \tsort(ve.begin(),ve.end());\n \tcout<<solve_min(ve,n,l)<<\" \"<<solve_max(ve,n,l)<<endl;\n \t\n \treturn 0;\n\n  }\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\n#define int long long\n#define endl \"\\n\"\n\nconst long long INF = (long long)1e18;\nconst long long MOD = 1'000'000'007; \n\nstring yn(bool f){return f?\"Yes\":\"No\";}\nstring YN(bool f){return f?\"YES\":\"NO\";}\n\n#define l first\n#define r second\n\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tint N, L;\n\tint x, y;\n\tint conl = 0, conr = 0, conm = 0, conb = 0;\n\tvector<pair<int,int>> interval;\n\tpriority_queue<pair<int,int>, vector<pair<int,int>>,greater<pair<int,int>>  > Q;\n\t\n\tcin>>N>>L;\n\t\n\tinterval.assign(N,{});\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tcin>>interval[i].l>>interval[i].r;\n\t\tif(interval[i].l == 0 && interval[i].r == L) conb++;\n\t\telse if(interval[i].l == 0) conl++;\n\t\telse if(interval[i].r == L) conr++;\n\t\telse conm++;\n\t}\n\t\n\tQ.push(make_pair(0,0));\n\t\n\tsort(interval.begin(), interval.end());\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tint minimum = INF;\n\t\tint x = Q.top().first;\n\t\t\n\t\t// cout<<interval[i].l<<\" <> \"<<interval[i].r<<endl;\n\t\t// cout<<Q.top().first<<\" \"<<Q.top().second<<\" em \"<<Q.empty()<<endl;\n\t\twhile(!Q.empty() && Q.top().second < interval[i].l){\n\t\t\tQ.pop();\n\t\t\tx = Q.top().first;\n\t\t}\n\t\t\n\t\tif(Q.empty()){\n\t\t}\n\t\t// cout<<\"i = \"<<i<<\" \"<<x<<\" \"<<endl;\n\t\tQ.push(make_pair(x+1,interval[i].r));\n\t\t\n\t}\n\t\n\tx = Q.top().first;\n\t\t\n\twhile(!Q.empty() && Q.top().second < L){\n\t\tQ.pop();\n\t\tx = Q.top().first;\n\t}\n\t\n\t\n\ty = conm + max(conl, conr) + 1;\n\t\n\tcout<<x<<\" \"<<y<<endl;\n\t// cout<<x<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(x) x.begin(),x.end()\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> ii;\n\ninline bool LT(double a,double b) { return !equals(a,b) && a < b; }\ninline bool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nstruct Data { ll l, r; };\nint n;\nll L;\nvector<Data> segs;\n\nbool cmp1(Data d1, Data d2) {\n  if( d1.l != d2.l ) return d1.l < d2.l;\n  return d1.r > d2.r;\n}\n\nint solve1() {\n  sort(ALL(segs),cmp1);\n  assert( segs[0].l == 0 );\n  ll cur = segs[0].r-1LL;\n  int mini = 1;\n  ll maxi = segs[0].r-1LL;\n  REP(i,1,n) {\n    if( cur < segs[i].l ) {\n      int j = i;\n      while( j < n && cur + 1LL == segs[j].l ) {\n\tmaxi = max(maxi,segs[j].r-1LL);\n\t++j;\n      }\n      i = j;\n      cur = maxi-1LL;\n      ++mini;\n    }\n    maxi = max(maxi,segs[i].r);\n  }\n  if( cur != L-1LL ) ++mini;\n  return mini;\n}\n\n#define IN 1\n#define OUT 0\nstruct Event {\n  ll p;\n  int type;\n  bool operator < ( const Event &e ) const {\n    if( p != e.p ) return p < e.p;\n    return type > e.type;\n  }\n};\n\n\n \n\nint solve2() {\n  deque<Event> deq;\n  rep(i,n) {\n    deq.push_back((Event){segs[i].l, IN});\n    deq.push_back((Event){segs[i].r, OUT});\n  }\n  sort(ALL(deq));\n  int maxi = 0;\n  int sum = 0;\n  \n  while( !deq.empty() ) {\n    Event e = deq.front(); deq.pop_front();\n    if( e.type == OUT ) {\n      //cout << \"[OUT] sum = \" << sum << \", e.p = \" << e.p << \", \" << e.type << \" : \" << n-sum+1 << endl;\n      maxi = max(maxi,n-sum+1);\n    }\n    \n    if( e.type == IN ) ++sum;\n    else               --sum;\n    while( !deq.empty() && e.p == deq.front().p && e.type == deq.front().type ) {\n      deq.pop_front();\n      if( e.type == IN ) ++sum;\n      else               --sum;\n    }\n    if( e.type == IN ) {\n      //cout << \"[IN] sum = \" << sum << \", e.p = \" << e.p << \", \" << e.type << \" : \" << n-sum+1 << endl;\n      maxi = max(maxi,n-sum+1);\n    }\n  }\n  return maxi;\n}\n\nvoid compute() {\n  int ans1 = solve1();\n  int ans2 = solve2();\n  cout << ans1 << \" \" << ans2 << endl;\n}\n\nint main() {\n  cin >> n >> L;\n  segs.resize(n);\n  rep(i,n) {\n    cin >> segs[i].l >> segs[i].r;\n  }\n  compute();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\nlong long dp[300000] = {};\nint main() {\n\tiostream::sync_with_stdio(false);\n\tcin.tie(0);\n#define int long long\n\tlong long n, l;\n\tcin >> n >> l;\n\tvector<pair<int, int>> gogo;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tgogo.push_back(make_pair(a, b));\n\t}\n\tgogo.push_back(make_pair(l, l + 1));\n\tsort(gogo.begin(), gogo.end());\n\tint next_max = 0;\n\tint now = 0;\n\tint ans = 0;\n\tfor (int i = 0; i < gogo.size(); ++i) {\n\t\tif (gogo[i].first > now) {\n\t\t\t//bad,just gogo\n\t\t\tans++;\n\t\t\tnow = next_max;\n\t\t\tnext_max = gogo[i].second;\n\t\t}\n\t\telse {\n\t\t\tnext_max = max(next_max, gogo[i].second);\n\t\t}\n\t}\n\tcout << ans << \" \";\n\tans = 0;\n\tnow = 0;\n\tnext_max = 1e15;\n\tpriority_queue<int,vector<int>,greater<int>> going;\n\tfor (int i = 0; i < gogo.size(); ++i) {\n\t\tif (gogo[i].first > now) {\n\t\t\t//bad,just gogo\n\t\t\twhile (gogo[i].first > now) {\n\t\t\t\tnow = going.top();\n\t\t\t\tans++;\n\t\t\t\tgoing.pop();\n\t\t\t}\n\t\t}\n\t\tif (now == l)ans++;\n\t\tgoing.push(gogo[i].second);\n\t}\n\tcout << ans-1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n#define ull unsigned long long\n#define vi vector<ll>\n#define vvi vector<vi>\n#define DBG_N(hoge) cerr<<\" \"<<(hoge)<<endl;\n#define DBG cerr<<\"!\"<<endl;\n#define BITLE(n) (1LL<<((ll)n))\n#define BITCNT(n) (__builtin_popcountll(n))\n#define SUBS(s,f,t) ((s).substr((f)-1,(t)-(f)+1))\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\nmap<ll,ll>zip;\nll unzip[555555];\nll imos[555555];\nvi to[555555];\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,L;\n  cin>>n>>L;\n  vector<pair<ll,ll>>pll(n);\n  set<ll>se;\n  for(int i=0;i<n;i++){\n    cin>>pll[i].F>>pll[i].S;\n    se.insert(pll[i].F);\n    se.insert(pll[i].S);\n  }\n  ll cnt=0;\n  for(auto a:se){\n    zip[a] = cnt;\n    unzip[cnt] = a;\n    cnt++;\n  }\n  for(int i=0;i<n;i++){\n    to[zip[pll[i].F]].pb(zip[pll[i].S]);\n    imos[zip[pll[i].F]]++;\n    imos[zip[pll[i].S]]--;\n    //cout<<zip[pll[i].F]<<\" \"<<zip[pll[i].S]<<endl;\n  }\n  for(int i=0;i<555000;i++)\n    imos[i+1]+=imos[i];\n  ll mi=llINF;\n  for(int i=0;i<cnt-1;i++){\n    mi=min(imos[i],mi);\n  }\n  ll ans=0;\n  priority_queue<ll>que;\n  /*  for(int i=0;i<to[0].size();i++)\n      que.push(to[0][i]);*/\n  que.push(0);\n  ll now=-1;\n  while(now<cnt-1){\n    ll num=que.top();\n    que.pop();\n    // cout<<now<<\" \"<<num<<endl;\n    for(int i=now+1;i<=num;i++){\n      for(auto a:to[i])\n\tque.push(a);\n    }\n    now=num;\n    ans++;\n  }\n\n  cout<<ans-1<<\" \"<<n-mi+1<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nusing ll = long long;\n#define REP(i,n) for(int i=0; i<(n); ++i)\n\nll N, L;\nvector<pair<ll, ll>> rl, lr;\n\nsigned main() {\n\n    cin >> N >> L;\n\n    set<ll> st;\n\n    REP(i, N) {\n        ll l, r;\n        cin >> l >> r;\n        rl.emplace_back(make_pair(-r, l));\n        st.insert(l);\n        st.insert(r);\n        lr.emplace_back(make_pair(l, r));\n    }\n\n    sort(rl.begin(), rl.end());\n\n    int res = 0;\n    int p = -1, q = -1, tmp = -1;\n    REP(i, N) {\n        // cerr << i << \" : \" << rl[i].second << ' ' << -rl[i].first << endl;\n        int l = rl[i].second;\n        int r = -rl[i].first;\n        if (i == 0) {\n            ++res;\n            p = l;\n            q = r;\n        } else {\n            if (r < p) {\n                ++res;\n                p = tmp;\n                tmp = l;\n            } else {\n                if (tmp == -1) tmp = l;\n                else {\n                    tmp = min(tmp, l);\n                }\n            }\n        }\n        // cerr << i << ' ' << p << ' ' << q << endl;\n    }\n    if (tmp != -1 and p != 0) {\n    // if (tmp < p) {\n        ++res;\n    }\n\n    map<ll, ll> mp;\n    int idx = 0;\n    for (auto& e: st) {\n        mp[e] = idx++;\n    }\n\n    vector<int> imos(3 * N, 0);\n    for (int i = 0; i < N; ++i) {\n        pair<ll, ll> p = lr[i];\n        ll l = mp[p.first], r = mp[p.second];\n        imos[l]++; imos[r]--;\n    }\n    REP(i, 3 * N - 1) {\n        imos[i + 1] += imos[i];\n    }\n    idx = 0;\n    ll mn = -1;\n    while (true) {\n        if (imos[idx] == 0) break;\n        if (mn == -1) mn = imos[idx];\n        else {\n            mn = min<ll>(mn, imos[idx]);\n        }\n        // cerr << zidx << ' ' << imos[idx] << endl;\n        idx++;\n    }\n// cerr << endl;\n    cout << res << ' ' << N - mn + 1 << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint main(){\n    ll N, L;\n    cin >> N >> L;\n    vector<P> ls, imos;\n    for(int i=0;i<N;i++){\n        ll l, r;\n        cin >> l >> r;\n        ls.push_back(P(l,r));\n        imos.push_back(P(l,+1));\n        imos.push_back(P(r,-1));\n    }\n    sort(ls.begin(), ls.end());\n    sort(imos.begin(), imos.end());\n    ll x = 0;\n    for(ll rmax = 0, i=0; rmax < L;){\n        ll tmp = rmax;\n        while(i<N && ls[i].first <= rmax){\n            tmp = max(tmp, ls[i].second);\n            i++;\n        }\n        x++;\n        rmax = tmp;\n    }\n    ll sum = 0, smin = INT_MAX;\n    for(int i=0;i<N*2-1;i++){\n        sum += imos[i].second;\n        if(imos[i].first != imos[i+1].first){\n            smin = min(sum, smin);\n        }\n    }\n    ll y = N - smin + 1;\n    cout << x << \" \" << y << endl;\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\nusing namespace std;\ntypedef long long ll;\nconst int N=4e5+10;\nint n,ans2,cnt,now_r,b[N];ll L,t[N];\nstruct seg{ll l,r;}a[N];\nint main(){\n    scanf(\"%d%lld\",&n,&L);\n    rep(i,1,n) scanf(\"%lld%lld\",&a[i].l,&a[i].r),t[++cnt]=a[i].l,t[++cnt]=a[i].r;\n    sort(t+1,t+cnt+1);\n    int w=unique(t+1,t+cnt+1)-t-1;\n    rep(i,1,n) a[i].l=lower_bound(t+1,t+w+1,a[i].l)-t,a[i].r=lower_bound(t+1,t+w+1,a[i].r)-t,++b[a[i].l],--b[a[i].r];\n    rep(i,1,w-1) b[i]+=b[i-1],ans2=max(ans2,n-b[i]);\n    sort(a+1,a+n+1,[&](seg x,seg y){return x.l==y.l?x.r>y.r:x.l<y.l;});\n    now_r=1;cnt=0;\n    for(int i=1,j=1;i<=n;i=j){\n        int tr=0;\n        while(j<=n&&a[j].l<=now_r) tr=max(tr,(int)a[j].r),++j;\n        now_r=tr;\n        ++cnt;if(now_r==lower_bound(t+1,t+w+1,L)-t) break;\n    }\n    printf(\"%d %d\\n\",cnt,ans2+1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 2969.cc: Universal and Existential Quantifiers\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 200000;\nconst int MAX_M = MAX_N * 2;\nconst int MAX_E2 = 1 << 20; // = 1048576\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\ntemplate <typename T, const int MAX_E2>\nstruct SegTreeMin {\n  int n, e2;\n  T nodes[MAX_E2], def;\n  SegTreeMin() {}\n\n  void init(int _n, T _def) {\n    n = _n; def = _def;\n    for (e2 = 1; e2 < n; e2 <<= 1);\n    fill(nodes, nodes + MAX_E2, def);\n  }\n\n  T &get(int i) { return nodes[e2 - 1 + i]; }\n\n  void set(int i, T v) {\n    int j = e2 - 1 + i;\n    nodes[j] = v;\n    while (j > 0) {\n      j = (j - 1) / 2;\n      nodes[j] = min<T>(nodes[j * 2 + 1], nodes[j * 2 + 2]);\n    }\n  }\n\n  T min_range(int r0, int r1, int k, int i0, int i1) {\n    if (r1 <= i0 || i1 <= r0) return def;\n    if (r0 <= i0 && i1 <= r1) return nodes[k];\n\n    int im = (i0 + i1) / 2;\n    T v0 = min_range(r0, r1, k * 2 + 1, i0, im);\n    T v1 = min_range(r0, r1, k * 2 + 2, im, i1);\n    return min<T>(v0, v1);\n  }\n  T min_range(int r0, int r1) { return min_range(r0, r1, 0, 0, e2); }\n};\n\n/* global variables */\n\nll ls[MAX_N], rs[MAX_N], xs[MAX_M];\nvi nbrs[MAX_M];\nSegTreeMin<int,MAX_E2> st;\nint cs[MAX_M];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n;\n  ll l;\n  scanf(\"%d%lld\", &n, &l);\n\n  for (int i = 0, j = 0; i < n; i++) {\n    scanf(\"%lld%lld\", ls + i, rs + i);\n    xs[j++] = ls[i];\n    xs[j++] = rs[i];\n  }\n\n  sort(xs, xs + n * 2);\n  int m = unique(xs, xs + n * 2) - xs;\n  //printf(\"m=%d\\n\", m);\n\n  for (int i = 0; i < n; i++) {\n    int li = lower_bound(xs, xs + m, ls[i]) - xs;\n    int ri = lower_bound(xs, xs + m, rs[i]) - xs;\n    nbrs[li].push_back(ri);\n    cs[li]++, cs[ri]--;\n  }\n\n  st.init(m, INF);\n  st.set(0, 0);\n\n  for (int i = 0; i < m; i++)\n    if (! nbrs[i].empty()) {\n      int d = st.min_range(i, m) + 1;\n      vi &nbri = nbrs[i];\n      for (vi::iterator vit = nbri.begin(); vit != nbri.end(); vit++) {\n\tint &j = *vit;\n\tif (st.get(j) > d) st.set(j, d);\n      }\n    }\n\n  int minc = cs[0];\n  for (int i = 1; i < m - 1; i++) {\n    cs[i] += cs[i - 1];\n    if (minc > cs[i]) minc = cs[i];\n  }\n\n  printf(\"%d %d\\n\", st.get(m - 1), n - (minc - 1));\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint N;\nlong L;\nvector<pair<long,long> >A,B;\nint a,b;\nmain()\n{\n\tcin>>N>>L;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tlong l,r;cin>>l>>r;\n\t\tA.push_back(make_pair(l,1));\n\t\tA.push_back(make_pair(r,-1));\n\t\tB.push_back(make_pair(l,r));\n\t}\n\tsort(A.begin(),A.end());\n\tsort(B.begin(),B.end());\n\tlong r=0;\n\tlong q=0;\n\tfor(pair<long,long>p:B)\n\t{\n\t\tif(r<p.first)\n\t\t{\n\t\t\tr=q;\n\t\t\ta++;\n\t\t}\n\t\tq=max(q,p.second);\n\t}\n\ta+=r<L;\n\tr=0;\n\tb=N;\n\tlong pre=0;\n\tfor(pair<long,long>p:A)\n\t{\n\t\tif(pre!=p.first)b=min(b,(int)r);\n\t\tpre=p.first;\n\t\tif(p.second==-1)r--;\n\t\telse r++;\n\t}\n\tcout<<a<<\" \"<<N-b+1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b)a=b;};\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b)a=b;};\n\ntemplate<typename T> void drop(T x){cout<<x<<endl;exit(0);};\n\ntemplate<typename T, typename E>\nstruct SegmentTree{\n  using F = function<T(T ,T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n\n  int n, height;\n  F f;\n  G g;\n  H h;\n  T ti;\n  E ei;\n  vector<T> dat;\n  vector<E> laz;\n\n  SegmentTree(F f, G g, H h, T ti, E ei):\n    f(f), g(g), h(h), ti(ti), ei(ei){}\n\n  void init(int n_){\n    n = 1; height = 0;\n    while(n < n_) n<<=1, height++;\n    dat.assign(2*n, ti);\n    laz.assign(2*n, ei);\n  }\n\n  void build(const vector<T> &v){\n    int n_ = v.size();\n    init(n_);\n    for(int i=0;i<n_;i++) dat[n+i] = v[i];\n    for(int i=n-1;i;i--)\n      dat[i] = f(dat[(i<<1)|0], dat[(i<<1)|1]);\n  }\n\n  inline T reflect(int k){\n    return laz[k] == ei? dat[k]:g(dat[k], laz[k]);\n  }\n\n  inline void eval(int k){\n    if(laz[k] == ei) return;\n    laz[(k<<1)|0] = h(laz[(k<<1)|0], laz[k]);\n    laz[(k<<1)|1] = h(laz[(k<<1)|1], laz[k]);\n    dat[k] = reflect(k);\n    laz[k] = ei;\n  }\n\n  inline void thrust(int k){\n    for(int i=height;i;i--) eval(k>>i);\n  }\n\n  inline void recalc(int k){\n    while(k>>=1)\n      dat[k] = f(reflect((k<<1)|0), reflect((k<<1)|1));\n  }\n\n  void update(int a, int b, E x){\n    thrust(a += n);\n    thrust(b += n-1);\n    for(int l=a, r=b+1;l<r;l>>=1, r>>=1){\n      if(l&1) laz[l] = h(laz[l], x), l++;\n      if(r&1) --r, laz[r] = h(laz[r], x);\n    }\n    recalc(a);\n    recalc(b);\n  }\n\n  void set_val(int a, T x){\n    thrust(a += n);\n    dat[a] = x; laz[a] = ei;\n    recalc(a);\n  }\n\n  T query(int a, int b){\n    thrust(a += n);\n    thrust(b += n-1);\n    T vl = ti, vr = ti;\n    for(int l=a, r=b+1;l<r;l>>=1, r>>=1){\n      if(l&1) vl = f(vl, reflect(l++));\n      if(r&1) vr = f(reflect(--r), vr);\n    }\n    return f(vl, vr);\n  }\n\n};\n\n#define F first\n#define S second\n\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  using pll = pair<ll,ll>;\n  auto f1=[](ll a,ll b){return min(a,b);};\n  auto f2=[](ll a,ll b){return a+b;};\n\n  ll N,L;\n  cin>>N>>L;\n  vector<pll> A(N);\n  map<ll,ll> M;\n  ll cnt=0;\n  const ll INF=N+100;\n  for(auto &I:A){\n    cin>>I.F>>I.S;\n    M[I.F]=M[I.S]=0;\n  }\n  for(auto &I:M){I.S=cnt; cnt++;}\n  for(auto &I:A){I.F=M[I.F]; I.S=M[I.S];}\n  L=M[L];\n  SegmentTree<ll,ll> dp(f1,f1,f1,INF,INF);\n  SegmentTree<ll,ll> sumL(f2,f2,f2,0,0);\n  SegmentTree<ll,ll> sumR(f2,f2,f2,0,0);\n  dp.build(vector<ll>(cnt+100,INF));\n  sumL.build(vector<ll>(cnt+100,0));\n  sumR.build(vector<ll>(cnt+100,0));\n  dp.update(0,1,0);\n  sort(A.begin(),A.end());\n  for(auto &I:A){\n    ll x=dp.query(I.F,L+1);\n    dp.update(I.S,I.S+1,x+1);\n  }\n  cout<<dp.query(L,L+1)<<\" \";\n  for(auto &I:A){\n    sumL.update(I.F,I.F+1,1);\n    sumR.update(I.S,I.S+1,1);\n  }\n  ll mx=0;\n  for(ll i=0;i<=L;i++){\n    ll c=sumL.query(i+1,L+10);\n    if(i!=0){c+=sumR.query(0,i);}\n    mx=max(mx,c);\n  }\n  cout<<mx+1<<endl;\n\n\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint N;\nint64_t L;\nstd::vector<std::pair<int64_t, int64_t>> intervals;\n\nint64_t calcX();\nint64_t calcY();\n\nint main()\n{\n\tscanf(\"%d%lld\", &N, &L);\n\tintervals.resize(N);\n\tfor (auto& e: intervals) scanf(\"%lld%lld\", &e.first, &e.second);\n\tprintf(\"%d %d\\n\", calcX(), calcY());\n\n\treturn 0;\n}\n\nint64_t calcX()\n{\n\tstd::sort(intervals.begin(), intervals.end());\n\tstd::priority_queue<int64_t> available;\n\tint64_t right{};\n\tint ans{}, index{};\n\twhile (right < L)\n\t{\n\t\twhile (index < N && intervals[index].first <= right)\n\t\t{\n\t\t\tavailable.push(intervals[index].second);\n\t\t\tindex++;\n\t\t}\n\t\tans++;\n\t\tright = available.top();\n\t\tavailable.pop();\n\t}\n\treturn ans;\n}\n\nint64_t calcY()\n{\n\tstd::vector<std::pair<int64_t, int>> points(2 * N);\n\tfor (int i{}; i < N; i++)\n\t{\n\t\tpoints[i].first = intervals[i].first;\n\t\tpoints[N + i].first = intervals[i].second;\n\t}\n\tstd::sort(points.begin(), points.end());\n\tpoints.erase(std::unique(points.begin(), points.end()), points.end());\n\tfor (auto& e: intervals)\n\t{\n\t\tstd::pair<int64_t, int> tmp(e.first, -N);\n\t\tstd::lower_bound(points.begin(), points.end(), tmp)->second++;\n\t\ttmp.first = e.second;\n\t\tstd::lower_bound(points.begin(), points.end(), tmp)->second--;\n\t}\n\tfor (int i{1}; i < (int)points.size(); i++)\n\t\tpoints[i].second += points[i - 1].second;\n\tint min{1 << 30};\n\tfor (int i{}; i < (int)points.size() - 1; i++)\n\t\tmin = std::min(min, points[i].second);\n\treturn N - min + 1;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\n#define SIZE 400000\n#define SIZE0 200000\n#define INF 1000000000\n\ntypedef long long ll;\n\nstruct Segtree {\n  int segn2;\n  vector<int> data;\n\n  Segtree(int n) {\n    for(segn2=1; segn2<n; segn2*=2);\n    data.assign(segn2*2, 1000000000);\n  }\n\n  int query(int a, int b, int l = 0, int r = -1, int k = 0) {\n    if (r == -1) r = segn2;\n    if (a <= l && r <= b) return data[k];\n    if (r <= a || b <= l) return INF;\n    return min(query(a, b, l, (l+r)/2, k*2+1), query(a, b, (l+r)/2, r, k*2+2));\n  }\n\n  void set(int k, int x) {\n    k += segn2-1;\n    data[k] = x;\n    while(k > 0) {\n      k = (k-1)/2;\n      data[k] = min(data[k*2+1], data[k*2+2]);\n    }\n  }\n};\n\n\nint N;\nll L;\nint M;\npair<ll,ll> p[SIZE0];\n\nint memo[SIZE];\nint solve1() {\n  Segtree seg(M+1);\n\n  seg.set(0, 0);\n\n  for(int i=0; i<M; i++) {\n    memo[i] = INF;\n  }\n  memo[0] = 0;\n\n  for(int i=0; i<N; i++) {\n    int l = p[i].first;\n    int r = p[i].second;\n\n    int v = seg.query(l, r);\n    memo[r] = min(memo[r], v+1);\n    seg.set(r, memo[r]);\n\n  }\n\n  return seg.query(M-1, M);\n}\n\nint sum[SIZE];\nint solve2() {\n\n  for(int i=0; i<N; i++) {\n    sum[p[i].first]++;\n    sum[p[i].second]--;\n  }\n\n  int ans = 1e9;\n\n  for(int i=0; i<M-1; i++) {\n    sum[i+1] += sum[i];\n    ans = min(ans, sum[i]);\n  }\n\n  return N - ans + 1;\n}\n\nint main(){\n  vector<ll> vec;\n  map<ll, int> dic;\n\n  scanf(\"%d%lld\", &N, &L);\n\n  for(int i=0; i<N; i++) {\n    ll l, r;\n    scanf(\"%lld%lld\", &l, &r);\n\n    p[i] = {l, r};\n    vec.push_back(l);\n    vec.push_back(r);\n  }\n\n  sort(vec.begin(), vec.end());\n  vec.erase(unique(vec.begin(), vec.end()), vec.end());\n\n  M = vec.size();\n\n  for(int i=0; i<vec.size(); i++) {\n    dic[vec[i]] = i;\n  }\n\n  sort(p, p+N);\n\n  for(int i=0; i<N; i++) {\n    p[i].first = dic[p[i].first];\n    p[i].second = dic[p[i].second];\n  }\n\n\n  int ans1 = solve1();\n  int ans2 = solve2();\n\n  printf(\"%d %d\\n\", ans1, ans2);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint n; cin >> n;\n\tint64_t L; cin >> L;\n\tint64_t l[n], r[n];\n\tfor(int i = 0; i < n; ++i) {\n\t\tcin >> l[i] >> r[i];\n\t}\n\t{ // x\n\t\t// {l, r}\n\t\tpair<int64_t, int64_t> p[n];\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tp[i] = {l[i], r[i]};\n\t\t}\n\t\tsort(p, p + n);\n\t\tint64_t rr = 0;\n\t\tint64_t maxi = 0;\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint64_t l, r;\n\t\t\ttie(l, r) = p[i];\n\t\t\tif(l <= rr) {\n\t\t\t\tmaxi = max(maxi, r);\n\t\t\t} else {\n\t\t\t\trr = maxi;\n\t\t\t\tmaxi = r;\n\t\t\t\t++ans;\n\t\t\t}\n\t\t}\n\t\tif(rr < L) {\n\t\t\t++ans;\n\t\t}\n\t\tcout << ans << \" \";\n\t}\n\t{ // y\n\t\tmap<int64_t, int> mp;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tmp[l[i]]++;\n\t\t\tmp[r[i]]++;\t\n\t\t}\n\t\tint idx = 0;\n\t\tfor(auto &e : mp) {\n\t\t\te.second = idx;\n\t\t\tidx++;\n\t\t}\n\t\tint imos[3 * n] = {};\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\timos[mp[l[i]]]++;\n\t\t\timos[mp[r[i]] + 1]--;\n\t\t}\n\t\tfor(int i = 1; i < 3 * n; ++i) {\n\t\t\timos[i] += imos[i - 1];\n\t\t}\n\t\tint ans = n;\n\t\tfor(int i = 0; i < 3 * n; ++i) {\n\t\t\tif(imos[i] > 0) {\n\t\t\t\tans = min(ans, imos[i]);\n\t\t\t}\n\t\t}\n\t\tcout << n - ans + 1 << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint main(){\n  long long N, L;\n  cin >> N >> L;\n  map<long long, long long> M;\n  M[L] = 1;\n  vector<pair<long long,long long>> V;\n  for(long long i = 0; i < N; ++i){\n    long long l, r;\n    cin >> l >> r;\n    M[l] = 1;\n    M[r] = 1;\n    V.emplace_back(l,r);\n  }\n  long long n = 0;\n  for(auto &p : M){\n    p.second = n++;\n  }\n  L = M[L];\n  vector<long long> I(L+1,0);\n  vector<pair<long long,long long>> T;\n  for(long long i = 0; i < N; ++i){\n    V[i].first = M[V[i].first];\n    V[i].second = M[V[i].second];\n    ++I[V[i].first];\n    --I[V[i].second];\n    T.emplace_back(V[i].first,-V[i].second);\n  }\n  sort(T.begin(),T.end());\n  long long r = 0, x = 0, j = 0;\n  while(r < L){\n    long long nex_r = r;\n    for(;j < N and T[j].first <= r; ++j){\n      nex_r = max(nex_r,-T[j].second);\n    }\n    r = nex_r;\n    ++x;\n  }\n  long long t = N;\n  for(long long i = 1; i <= L; ++i){\n    I[i] += I[i-1];\n    t = min(t,I[i-1]);\n  }\n  long long y = N - t + 1;\n  cout << x << \" \" << y << endl;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner ir = new Scanner(System.in);\n        int n = ir.nextInt();\n        long l = ir.nextLong();\n        long[][] x = new long[n][];\n        for (int i = 0; i < n; i++) {\n            x[i] = new long[] { ir.nextLong(), ir.nextLong() };\n        }\n        int[][] a = compress(x);\n        // System.out.println(Arrays.deepToString(a));\n        Arrays.sort(a, new Comparator<int[]>() {\n            public int compare(int[] A, int[] B) {\n                return A[0] - B[0];\n            }\n        });\n        int ma = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 2; j++) {\n                ma = Math.max(ma, a[i][j]);\n            }\n        }\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\n        int end = 0;\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (end == ma) {\n                break;\n            }\n            while (i < n && a[i][0] <= end) {\n                pq.add(a[i][1]);\n                i++;\n            }\n            i--;\n            end = pq.poll();\n            // System.out.println(end);\n            res++;\n        }\n        System.out.print(res + \" \");\n        int[] imos = new int[ma + 1];\n        for (int i = 0; i < n; i++) {\n            imos[a[i][0]]++;\n            imos[a[i][1]]--;\n        }\n        res = imos[0];\n        for (int i = 0; i < ma; i++) {\n            imos[i + 1] += imos[i];\n            res = Math.min(res, imos[i]);\n        }\n        System.out.println(n + 1 - res);\n    }\n\n    static int[][] compress(long[][] a) {\n        int[][] ret = new int[a.length][2];\n        TreeSet<Long> st = new TreeSet<>();\n        for (int i = 0; i < a.length; i++) {\n            for (int j = 0; j < 2; j++) {\n                st.add(a[i][j]);\n            }\n        }\n        ArrayList<Long> l = new ArrayList<>(st);\n        for (int i = 0; i < a.length; i++) {\n            for (int j = 0; j < 2; j++) {\n                ret[i][j] = Collections.binarySearch(l, a[i][j]);\n            }\n        }\n        return ret;\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, core.stdc.stdio;\n\nvoid main() {\n    auto s = readln.split.map!(to!long);\n    auto N = s[0].to!int;\n    auto L = s[1];\n    auto A = N.iota.map!(_ => readln.split.map!(to!long).array).array;\n    A.sort!\"a[0] < b[0]\";\n\n    {\n        auto pq = new BinaryHeap!(Array!long, \"a < b\");\n        long right = 0;\n        int p = 0;\n        int ans = 0;\n        while (right < L) {\n            while (p < N && A[p][0] <= right) {\n                pq.insert(A[p][1]);\n                p += 1;\n            }\n            right = pq.front;\n            pq.removeFront;\n            ans += 1;\n        }\n        write(ans, \" \");\n    }\n\n    {\n        long[] B;\n        foreach (a; A) B ~= a;\n        B = B.sort().uniq.array;\n        long[long] comp;\n        foreach (i; 0..B.length.to!int) comp[B[i]] = i;\n        foreach (i; 0..N) A[i][0] = comp[A[i][0]], A[i][1] = comp[A[i][1]];\n        L = B.length.to!long - 1;\n\n        auto imos = new int[](L+1);\n        foreach (i; 0..N) {\n            imos[A[i][0]] += 1;\n            imos[A[i][1]] -= 1;\n        }\n        foreach (i; 0..L) {\n            imos[i+1] += imos[i];\n        }\n        int ans = 1;\n        foreach (i; 0..L) {\n            ans = max(ans, N - imos[i] + 1);\n        }\n        ans.writeln;\n    }\n}\n\n"
  },
  {
    "language": "Python",
    "code": "import heapq\nimport sys\nfrom operator import itemgetter\n\ninput = sys.stdin.readline\nN, L = map(int, input().split())\nLR = []\nLR_set = []\nfor _ in range(N):\n  l, r = map(int, input().split())\n  LR.append((l, r))\n  LR_set.append(l)\n  LR_set.append(r)\nLR_set = sorted(set(LR_set))\nmapping = {}\n# zahyou asshuku\nfor i, lr in enumerate(LR_set):\n  mapping[lr] = i\n\n\nimos = [0] * (len(mapping)+1)\n\nLR.sort(key=itemgetter(0))\nq = []\nans_x = 0\nright = 0\nfor i, (l, r) in enumerate(LR, 1):\n  # x\n  heapq.heappush(q, -r)\n  #print(q, right, ans_x)\n  if i<N and LR[i][0] > right:\n    rr = heapq.heappop(q)\n    rr = -rr\n    right = rr\n    ans_x += 1\n\n  # y\n  imos[mapping[l]] += 1\n  imos[mapping[r]] -= 1\n\nif L > right:\n  ans_x += 1\n\nfor i in range(1, len(imos)):\n  imos[i] += imos[i-1]\n\nans_y = N + 1 - min(imos[:mapping[L]])\n\nprint(ans_x, ans_y)\n\n\n\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::{BTreeMap, BTreeSet, BinaryHeap};\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let _: u64 = sc.read();\n    let mut segments = vec![];\n    for _ in 0..n {\n        let left: u64 = sc.read();\n        let right: u64 = sc.read();\n        segments.push((left, right));\n    }\n\n    let seg_map = segments\n        .iter()\n        .flat_map(|&(l, r)| vec![l, r])\n        .collect::<BTreeSet<_>>()\n        .into_iter()\n        .enumerate()\n        .map(|(i, v)| (v, i))\n        .collect::<BTreeMap<_, _>>();\n    let segments = segments\n        .into_iter()\n        .map(|(l, r)| {\n            let l = *seg_map.get(&l).unwrap();\n            let r = *seg_map.get(&r).unwrap();\n            (l, r)\n        })\n        .collect::<Vec<_>>();\n    let length: usize = segments.iter().map(|&(_, r)| r).max().unwrap();\n    let mut graph = vec![vec![]; length];\n    for i in 0..n {\n        let (l, r) = segments[i];\n        graph[l].push(r);\n    }\n\n    let mut cost = vec![n as i64; length + 1];\n    cost[0] = 0;\n    let mut q = BinaryHeap::new();\n    q.push((0, 0));\n    while let Some((_, v)) = q.pop() {\n        if v == length {\n            break;\n        }\n        for &next in graph[v].iter() {\n            if cost[next] > cost[v] + 1 {\n                cost[next] = cost[v] + 1;\n                q.push((-cost[next], next));\n            }\n        }\n        if v > 0 && cost[v - 1] > cost[v] {\n            cost[v - 1] = cost[v];\n            q.push((-cost[v - 1], v - 1));\n        }\n    }\n\n    let mut acc: Vec<i64> = vec![0; length + 1];\n    for from in 0..length {\n        for &to in graph[from].iter() {\n            acc[from] += 1;\n            acc[to] -= 1;\n        }\n    }\n    for i in 0..length {\n        acc[i + 1] += acc[i];\n    }\n\n    let min_acc = (0..length).map(|i| acc[i]).min().unwrap();\n    println!(\"{} {}\", cost[length], n as i64 + 1 - min_acc);\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n\n"
  }
]