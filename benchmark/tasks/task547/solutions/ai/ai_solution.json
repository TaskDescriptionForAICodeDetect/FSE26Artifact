[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n#define MAX_L 1000000005\n\ntypedef struct {\n    int left;\n    int right;\n} Interval;\n\nint cmp(const void* a, const void* b) {\n    Interval* x = (Interval*)a;\n    Interval* y = (Interval*)b;\n    return x->left - y->left;\n}\n\nint solve_min_x(Interval* intervals, int n, int L) {\n    qsort(intervals, n, sizeof(Interval), cmp);\n    int count = 0;\n    int cur_end = 0;\n    int best_end = 0;\n    int i = 0;\n\n    while (cur_end < L) {\n        while (i < n && intervals[i].left <= cur_end) {\n            best_end = fmax(best_end, intervals[i].right);\n            i++;\n        }\n\n        if (best_end <= cur_end) return -1;\n\n        cur_end = best_end;\n        count++;\n    }\n\n    return count;\n}\n\nint solve_min_y(Interval* intervals, int n, int L) {\n    qsort(intervals, n, sizeof(Interval), cmp);\n    int* dp = malloc((L + 1) * sizeof(int));\n    memset(dp, 0x3f, (L + 1) * sizeof(int));\n    dp[0] = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = L; j >= 0; j--) {\n            if (j + intervals[i].right - intervals[i].left <= L) {\n                int next = fmin(L, j + intervals[i].right - intervals[i].left);\n                dp[next] = fmin(dp[next], dp[j] + 1);\n            }\n        }\n    }\n\n    int result = dp[L];\n    free(dp);\n    return result == 0x3f3f3f3f ? -1 : result;\n}\n\nint main() {\n    int n, L;\n    scanf(\"%d %d\", &n, &L);\n\n    Interval* intervals = malloc(n * sizeof(Interval));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &intervals[i].left, &intervals[i].right);\n    }\n\n    int x = solve_min_x(intervals, n, L);\n    int y = solve_min_y(intervals, n, L);\n\n    printf(\"%d %d\\n\", x, y);\n\n    free(intervals);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:05:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int l;\n    int r;\n} Interval;\n\nint compare(const void *a, const void *b) {\n    Interval *ia = (Interval *)a;\n    Interval *ib = (Interval *)b;\n    if (ia->l != ib->l) {\n        return ia->l - ib->l;\n    } else {\n        return ib->r - ia->r;\n    }\n}\n\nint min_intervals_to_cover(Interval *intervals, int N, int L) {\n    qsort(intervals, N, sizeof(Interval), compare);\n    int res = 0;\n    int current_end = 0;\n    int i = 0;\n    while (current_end < L) {\n        int max_end = current_end;\n        while (i < N && intervals[i].l <= current_end) {\n            if (intervals[i].r > max_end) {\n                max_end = intervals[i].r;\n            }\n            i++;\n        }\n        if (max_end == current_end) {\n            return -1;\n        }\n        current_end = max_end;\n        res++;\n    }\n    return res;\n}\n\nint is_covered(Interval *intervals, int N, int L, int y) {\n    int *dp = (int *)malloc((L + 1) * sizeof(int));\n    for (int i = 0; i <= L; i++) {\n        dp[i] = 0;\n    }\n    dp[0] = 1;\n    for (int i = 0; i < N; i++) {\n        for (int j = L; j >= intervals[i].l; j--) {\n            if (dp[j - intervals[i].l] && j <= intervals[i].r) {\n                dp[j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < L; i++) {\n        if (!dp[i]) {\n            free(dp);\n            return 0;\n        }\n    }\n    free(dp);\n    return 1;\n}\n\nint min_y(Interval *intervals, int N, int L) {\n    int low = 1;\n    int high = N;\n    int res = N;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (is_covered(intervals, N, L, mid)) {\n            res = mid;\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return res;\n}\n\nint main() {\n    int N, L;\n    scanf(\"%d %d\", &N, &L);\n    Interval *intervals = (Interval *)malloc(N * sizeof(Interval));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &intervals[i].l, &intervals[i].r);\n    }\n    int x = min_intervals_to_cover(intervals, N, L);\n    int y = min_y(intervals, N, L);\n    printf(\"%d %d\\n\", x, y);\n    free(intervals);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:05:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int N, L;\n    cin >> N >> L;\n    vector<pair<int, int>> intervals(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> intervals[i].first >> intervals[i].second;\n    }\n\n    // Sort intervals by left endpoint\n    sort(intervals.begin(), intervals.end());\n\n    // Compute x: minimum number of intervals to cover [0, L)\n    int x = 0;\n    int current_end = 0;\n    int i = 0;\n    while (current_end < L) {\n        int max_end = current_end;\n        while (i < N && intervals[i].first <= current_end) {\n            max_end = max(max_end, intervals[i].second);\n            ++i;\n        }\n        if (max_end == current_end) {\n            // No progress, can't cover\n            x = -1;\n            break;\n        }\n        current_end = max_end;\n        ++x;\n    }\n\n    // Compute y: minimum number such that all combinations of y intervals cover [0, L)\n    int y = -1;\n    for (int k = 1; k <= N; ++k) {\n        bool all_cover = true;\n        vector<bool> selected(N, false);\n        fill(selected.end() - k, selected.end(), true);\n        do {\n            int covered = 0;\n            for (int j = 0; j < N; ++j) {\n                if (selected[j]) {\n                    if (intervals[j].first <= covered) {\n                        covered = max(covered, intervals[j].second);\n                    }\n                }\n            }\n            if (covered < L) {\n                all_cover = false;\n                break;\n            }\n        } while (next_permutation(selected.begin(), selected.end()));\n        if (all_cover) {\n            y = k;\n            break;\n        }\n    }\n\n    cout << x << \" \" << y << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:06:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class IntervalCoverage {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int L = scanner.nextInt();\n        int[][] intervals = new int[N][2];\n        for (int i = 0; i < N; i++) {\n            intervals[i][0] = scanner.nextInt();\n            intervals[i][1] = scanner.nextInt();\n        }\n\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n\n        int x = computeMinIntervals(intervals, L);\n        int y = computeMinCoverage(intervals, L, N);\n\n        System.out.println(x + \" \" + y);\n    }\n\n    private static int computeMinIntervals(int[][] intervals, int L) {\n        int count = 0;\n        int currentEnd = 0;\n        int i = 0;\n        while (currentEnd < L) {\n            int maxEnd = currentEnd;\n            while (i < intervals.length && intervals[i][0] <= currentEnd) {\n                maxEnd = Math.max(maxEnd, intervals[i][1]);\n                i++;\n            }\n            if (maxEnd == currentEnd) {\n                return -1;\n            }\n            currentEnd = maxEnd;\n            count++;\n        }\n        return count;\n    }\n\n    private static int computeMinCoverage(int[][] intervals, int L, int N) {\n        boolean[] covered = new boolean[L];\n        for (int[] interval : intervals) {\n            for (int j = interval[0]; j < interval[1]; j++) {\n                if (j < L) {\n                    covered[j] = true;\n                }\n            }\n        }\n        for (boolean b : covered) {\n            if (!b) {\n                return -1;\n            }\n        }\n\n        int left = 1;\n        int right = N;\n        int result = N;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (canCover(intervals, L, mid)) {\n                result = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return result;\n    }\n\n    private static boolean canCover(int[][] intervals, int L, int y) {\n        int n = intervals.length;\n        int[] selected = new int[y];\n        return backtrack(intervals, selected, 0, 0, L, n);\n    }\n\n    private static boolean backtrack(int[][] intervals, int[] selected, int pos, int start, int L, int n) {\n        if (pos == selected.length) {\n            boolean[] covered = new boolean[L];\n            for (int idx : selected) {\n                int l = intervals[idx][0];\n                int r = intervals[idx][1];\n                for (int i = l; i < r && i < L; i++) {\n                    covered[i] = true;\n                }\n            }\n            for (int i = 0; i < L; i++) {\n                if (!covered[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        for (int i = start; i < n; i++) {\n            selected[pos] = i;\n            if (backtrack(intervals, selected, pos + 1, i + 1, L, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
    "timestamp": "2025-08-05 22:07:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class IntervalCoverage {\n    public static int[] computeIntervalCoverage(int[][] intervals, int L) {\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        \n        int minX = 0;\n        int currentRight = 0;\n        int maxRight = 0;\n        int index = 0;\n        \n        while (currentRight < L) {\n            while (index < intervals.length && intervals[index][0] <= currentRight) {\n                maxRight = Math.max(maxRight, intervals[index][1]);\n                index++;\n            }\n            \n            if (maxRight <= currentRight) {\n                return new int[]{-1, -1};\n            }\n            \n            currentRight = maxRight;\n            minX++;\n        }\n        \n        int minY = 0;\n        currentRight = 0;\n        int selectedCount = 0;\n        index = 0;\n        \n        while (currentRight < L) {\n            maxRight = currentRight;\n            selectedCount = 0;\n            \n            while (index < intervals.length && intervals[index][0] <= currentRight) {\n                if (intervals[index][1] > maxRight) {\n                    maxRight = intervals[index][1];\n                    selectedCount++;\n                }\n                index++;\n            }\n            \n            if (maxRight <= currentRight) {\n                return new int[]{-1, -1};\n            }\n            \n            currentRight = maxRight;\n            minY = Math.max(minY, selectedCount);\n        }\n        \n        return new int[]{minX, minY};\n    }\n    \n    public static void main(String[] args) {\n        int[][] intervals = {{0, 3}, {2, 6}, {3, 5}, {4, 8}};\n        int L = 9;\n        int[] result = computeIntervalCoverage(intervals, L);\n        System.out.println(result[0] + \" \" + result[1]);\n    }\n}",
    "timestamp": "2025-08-05 22:07:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N, L;\n    cin >> N >> L;\n    \n    vector<pair<int, int>> intervals(N);\n    for (int i = 0; i < N; i++) {\n        cin >> intervals[i].first >> intervals[i].second;\n    }\n    \n    // Sort intervals based on left endpoint\n    sort(intervals.begin(), intervals.end());\n    \n    // Minimum number of intervals to cover [0, L)\n    int min_x = 0;\n    int current_end = 0;\n    int max_end = 0;\n    \n    while (current_end < L) {\n        bool found = false;\n        for (const auto& interval : intervals) {\n            if (interval.first <= current_end) {\n                max_end = max(max_end, interval.second);\n                found = true;\n            } else {\n                break;\n            }\n        }\n        \n        if (!found) break;\n        \n        current_end = max_end;\n        min_x++;\n    }\n    \n    if (current_end < L) {\n        min_x = -1;\n    }\n    \n    // Minimum number of intervals to cover all possible combinations\n    int min_y = INT_MAX;\n    \n    for (int mask = 1; mask < (1 << N); mask++) {\n        int current_end = 0;\n        int max_end = 0;\n        bool cover_complete = false;\n        \n        for (int i = 0; i < N; i++) {\n            if (mask & (1 << i)) {\n                if (intervals[i].first <= current_end) {\n                    max_end = max(max_end, intervals[i].second);\n                }\n            }\n        }\n        \n        if (max_end >= L) {\n            int count_intervals = __builtin_popcount(mask);\n            min_y = min(min_y, count_intervals);\n        }\n    }\n    \n    if (min_y == INT_MAX) {\n        min_y = -1;\n    }\n    \n    cout << min_x << \" \" << min_y << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:07:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_intervals_cover(n, L, intervals):\n    intervals.sort()\n    \n    # Function to find the minimum x intervals to cover [0, L)\n    def min_x_intervals():\n        covered = 0\n        count = 0\n        idx = 0\n        \n        while covered < L:\n            max_right = covered\n            while idx < n and intervals[idx][0] <= covered:\n                max_right = max(max_right, intervals[idx][1])\n                idx += 1\n            \n            if max_right == covered:\n                return -1\n            \n            covered = max_right\n            count += 1\n            \n            if covered >= L:\n                return count\n        \n        return -1\n\n    # Function to find the minimum y such that all combinations of y cover [0, L)\n    def min_y_intervals():\n        def can_cover_with_y(k):\n            from itertools import combinations\n            \n            all_indices = list(range(n))\n            for indices in combinations(all_indices, k):\n                covered = 0\n                sub_intervals = sorted([intervals[i] for i in indices])\n                \n                for l, r in sub_intervals:\n                    if covered < l:\n                        return False\n                    covered = max(covered, r)\n                    if covered >= L:\n                        return True\n            \n            return covered >= L\n        \n        left, right = 0, n\n        \n        while left < right:\n            mid = (left + right) // 2\n            if can_cover_with_y(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left\n\n    x = min_x_intervals()\n    y = min_y_intervals()\n\n    return x, y\n\n# Example usage\nN = 3\nL = 10\nintervals = [(0, 3), (2, 6), (5, 10)]\nprint(min_intervals_cover(N, L, intervals))  # Output will depend on the intervals given.",
    "timestamp": "2025-08-13 08:58:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class IntervalCoverage {\n    public static void main(String[] args) {\n        int N = 3;  // number of intervals\n        int L = 5;  // target range [0, L)\n        int[][] intervals = { {0, 2}, {1, 4}, {3, 5} };  // intervals\n\n        System.out.println(Arrays.toString(findMinXAndY(intervals, L)));\n    }\n\n    public static int[] findMinXAndY(int[][] intervals, int L) {\n        int minX = calculateMinX(intervals, L);\n        int minY = calculateMinY(intervals, L);\n        return new int[]{minX, minY};\n    }\n\n    private static int calculateMinX(int[][] intervals, int L) {\n        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\n        int covered = 0, numIntervals = 0;\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\n\n        for (int[] interval : intervals) {\n            if (covered >= L) break;\n            while (!pq.isEmpty() && pq.peek() <= interval[0]) {\n                pq.poll();\n            }\n            if (covered < interval[0]) return -1;  // can't cover the next segment\n\n            pq.offer(interval[1]);\n            covered = interval[0];\n            while (!pq.isEmpty() && pq.peek() > covered) {\n                covered = pq.poll();\n                numIntervals++;\n                if (covered >= L) return numIntervals;\n            }\n        }\n\n        return covered >= L ? numIntervals : -1;\n    }\n\n    private static int calculateMinY(int[][] intervals, int L) {\n        int n = intervals.length;\n        int minY = n + 1;  // Initialize to larger than any possible answer\n\n        for (int mask = 1; mask < (1 << n); mask++) {\n            int covered = 0;\n            List<int[]> selected = new ArrayList<>();\n\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    selected.add(intervals[i]);\n                }\n            }\n\n            Collections.sort(selected, Comparator.comparingInt(a -> a[0]));\n            PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\n\n            for (int[] interval : selected) {\n                while (!pq.isEmpty() && pq.peek() <= interval[0]) {\n                    pq.poll();\n                }\n\n                if (covered < interval[0]) break;\n                pq.offer(interval[1]);\n                covered = interval[0];\n\n                while (!pq.isEmpty() && pq.peek() > covered) {\n                    covered = pq.poll();\n                    if (covered >= L) {\n                        minY = Math.min(minY, selected.size());\n                        break;\n                    }\n                }\n            }\n\n            if (covered >= L) {\n                minY = Math.min(minY, selected.size());\n            }\n        }\n\n        return minY == n + 1 ? -1 : minY;\n    }\n}",
    "timestamp": "2025-08-13 08:58:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int start, end;\n} Interval;\n\nint compare(const void *a, const void *b) {\n    Interval *intervalA = (Interval *)a;\n    Interval *intervalB = (Interval *)b;\n    if (intervalA->start != intervalB->start) {\n        return intervalA->start - intervalB->start;\n    } else {\n        return intervalB->end - intervalA->end;\n    }\n}\n\nint findMinimumX(Interval intervals[], int N, int L) {\n    qsort(intervals, N, sizeof(Interval), compare);\n    int covered = 0, count = 0, i = 0, maxEnd = 0;\n    while (covered < L && i < N) {\n        int bestEnd = maxEnd;\n        while (i < N && intervals[i].start <= covered) {\n            if (intervals[i].end > bestEnd) {\n                bestEnd = intervals[i].end;\n            }\n            i++;\n        }\n        if (bestEnd > maxEnd) {\n            maxEnd = bestEnd;\n            covered = maxEnd;\n            count++;\n        } else {\n            break;\n        }\n    }\n    return covered >= L ? count : -1;\n}\n\nvoid findMinimumY(Interval intervals[], int N, int L, int *y, int depth, int *comb, int covered) {\n    if (covered >= L) {\n        if (*y == -1 || depth < *y) {\n            *y = depth;\n        }\n        return;\n    }\n    if (depth >= *y && *y != -1) {\n        return;\n    }\n    for (int i = 0; i < N; i++) {\n        if (!comb[i] && intervals[i].start <= covered) {\n            comb[i] = 1;\n            findMinimumY(intervals, N, L, y, depth + 1, comb, \n                            intervals[i].end > covered ? intervals[i].end : covered);\n            comb[i] = 0;\n        }\n    }\n}\n\nint main() {\n    int N, L;\n    scanf(\"%d %d\", &N, &L);\n    Interval intervals[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &intervals[i].start, &intervals[i].end);\n    }\n    \n    int x = findMinimumX(intervals, N, L);\n    int y = -1;\n    int comb[N];\n    for (int i = 0; i < N; i++) comb[i] = 0;\n    findMinimumY(intervals, N, L, &y, 0, comb, 0);\n    \n    printf(\"%d %d\\n\", x, y);\n    return 0;\n}",
    "timestamp": "2025-08-13 08:58:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_interval_coverage(intervals, L):\n    # Sort intervals by left endpoint\n    intervals.sort(key=lambda x: x[0])\n    \n    # Find minimum x (greedy approach)\n    def find_min_x():\n        x = 0\n        covered = 0\n        while covered < L:\n            max_right = covered\n            found = False\n            for interval in intervals:\n                if interval[0] <= covered:\n                    max_right = max(max_right, interval[1])\n                else:\n                    break\n            \n            if max_right == covered:\n                return -1  # Impossible to cover\n            \n            covered = max_right\n            x += 1\n        return x\n    \n    # Find minimum y (dynamic programming)\n    def find_min_y():\n        dp = [float('inf')] * (L + 1)\n        dp[0] = 0\n        \n        for i in range(1, L + 1):\n            for interval in intervals:\n                if interval[1] >= i and interval[0] <= i:\n                    dp[i] = min(dp[i], dp[max(0, interval[0])] + 1)\n        \n        return dp[L] if dp[L] != float('inf') else -1\n    \n    return find_min_x(), find_min_y()\n\n# Example usage\ndef main():\n    N, L = map(int, input().split())\n    intervals = []\n    for _ in range(N):\n        l, r = map(int, input().split())\n        intervals.append([l, r])\n    \n    x, y = solve_interval_coverage(intervals, L)\n    print(x, y)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 08:58:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N, L = int(data[idx]), int(data[idx+1])\n    idx += 2\n    \n    intervals = []\n    for _ in range(N):\n        l, r = int(data[idx]), int(data[idx+1])\n        intervals.append((l, r))\n        idx += 2\n    \n    # Sort intervals by starting time\n    intervals.sort()\n    \n    # Compute x: minimum number of intervals to cover [0, L)\n    x = 0\n    current_end = 0\n    i = 0\n    max_r = 0\n    while current_end < L and i < N:\n        # Find the interval with the maximum r that starts <= current_end\n        max_r = current_end\n        found = False\n        while i < N and intervals[i][0] <= current_end:\n            if intervals[i][1] > max_r:\n                max_r = intervals[i][1]\n                found = True\n            i += 1\n        if not found:\n            break\n        current_end = max_r\n        x += 1\n    \n    if current_end < L:\n        x = -1\n    \n    # Compute y: minimum y such that all combinations of y intervals cover [0, L)\n    # This is equivalent to finding the size of the smallest subset S where the union is [0, L)\n    # and no proper subset of S has union [0, L). This is equivalent to the hitting set problem,\n    # which is NP-hard, so for large N, it's impractical. However, for small N, we can brute-force.\n    # Here, we assume N is small (e.g., <= 20), otherwise it's not feasible.\n    \n    y = -1\n    if N <= 20:\n        # Try all possible subset sizes from 1 to N\n        for k in range(1, N+1):\n            from itertools import combinations\n            found = False\n            for subset in combinations(intervals, k):\n                covered = [False] * L\n                for l, r in subset:\n                    for j in range(l, r):\n                        if j < L:\n                            covered[j] = True\n                if all(covered):\n                    y = k\n                    found = True\n                    break\n            if found:\n                break\n    else:\n        y = -1  # Not computable for large N\n    \n    print(x, y)\n\nsolve()",
    "timestamp": "2025-08-13 08:58:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nstruct Interval {\n    int l, r;\n};\n\nbool compareByStart(const Interval &a, const Interval &b) {\n    return a.l < b.l;\n}\n\nbool compareByEnd(const Interval &a, const Interval &b) {\n    return a.r < b.r;\n}\n\nint minXIntervals(std::vector<Interval> &intervals, int L) {\n    std::sort(intervals.begin(), intervals.end(), compareByStart);\n    int x = 0, i = 0, n = intervals.size(), current_coverage = 0;\n    while (current_coverage < L) {\n        int max_cover = current_coverage;\n        while (i < n && intervals[i].l <= current_coverage) {\n            max_cover = std::max(max_cover, intervals[i].r);\n            i++;\n        }\n        if (max_cover == current_coverage) return -1;\n        current_coverage = max_cover;\n        x++;\n    }\n    return x;\n}\n\nint minYIntervals(std::vector<Interval> &intervals, int L) {\n    int n = intervals.size();\n    int y = INT_MAX;\n\n    for (int mask = 1; mask < (1 << n); ++mask) {\n        std::vector<Interval> selected_intervals;\n        for (int i = 0; i < n; ++i) {\n            if (mask & (1 << i)) {\n                selected_intervals.push_back(intervals[i]);\n            }\n        }\n\n        int current_coverage = 0;\n        while (!selected_intervals.empty() && current_coverage < L) {\n            auto it = std::max_element(selected_intervals.begin(), selected_intervals.end(), compareByEnd);\n            if (it == selected_intervals.end() || it->l > current_coverage) break;\n            current_coverage = std::max(current_coverage, it->r);\n            selected_intervals.erase(it);\n        }\n\n        if (current_coverage >= L) {\n            y = std::min(y, static_cast<int>(selected_intervals.size()));\n        }\n    }\n    return y == INT_MAX ? -1 : y;\n}\n\nint main() {\n    int N, L;\n    std::cin >> N >> L;\n    std::vector<Interval> intervals(N);\n    for (int i = 0; i < N; ++i) {\n        std::cin >> intervals[i].l >> intervals[i].r;\n    }\n\n    int minX = minXIntervals(intervals, L);\n    int minY = minYIntervals(intervals, L);\n\n    std::cout << minX << \" \" << minY << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:48:49"
  }
]