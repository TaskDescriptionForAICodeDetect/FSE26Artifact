[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\ntypedef long long ll;\ntypedef vector<int> vi;\nconst int MOD = 1000003;\nint n, m;\nvector<vi> g;\n\nvi solve(int l, int r, int gi){\n\tvi res({1, 1});\n\tfor(int i=l;i<r;i++){\n\t\tif(gi < g[i].size()){\n\t\t\tvi ret = solve(i, g[i][gi], gi+1);\n\t\t\tREP(j, 2) res[j] = (ll)res[j]*ret[j]%MOD;\n\t\t\ti = g[i][gi]-1;\n\t\t}\n\t\tswap(res[0], res[1]);\n\t\tgi = 0;\n\t}\n\tswap(res[0], res[1]);\n\tif(r-l > 1) res[1] -= ((res[1] = res[1] + res[0]) >= MOD) ? MOD : 0;\n\treturn res;\n}\n\nint main(){\n\twhile(~scanf(\"%d%d\", &n, &m), n){\n\t\tg = vector<vi>(n);\n\t\tREP(i, m){\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v);u--; v--;\n\t\t\tif(v < u) swap(u, v);\n\t\t\tif(((u^v)&1)) g[u].push_back(v);\n\t\t}\n\t\tREP(i, n) sort(g[i].rbegin(), g[i].rend());\n\t\tprintf(\"%d\\n\", n%2 ? 0 : (int)solve(0, n-1, 0)[1]);\n\t}\n\treturn 0;\n}\n\nlong long esp_org, esp_new;\n\nint main_(){\n    //  新しいスタック領域を確保する\n    const int size = 50*1024*1024;\n    void *p = malloc(size);\n    esp_new = (long long)p + size - 1;\n\n    //  スタックを置き換える\n    __asm__(\"mov %rsp, esp_org\");\n    __asm__(\"mov esp_new, %rsp\");\n    \n    //  メインの処理\n    main_();\n    //  スタックを元に戻す\n   __asm__(\"mov esp_org, %rsp\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for (ll i=0;i<(n);++i)\nconst ll MOD=1e6+3;\n\nconst int MAX_NM=5e4+10;\n\nint n,m,s;\nvector<pair<int,int>> es;\nvector<pair<int,ll>> dp(MAX_NM);\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> n >> m,n){\n        es.clear();\n        rep(i,m){\n            int a,b; cin >> a >> b; --a,--b;\n            if (a>b) swap(a,b);\n            if ((b-a)%2==0) continue;\n            es.push_back({b-a,a});\n        }\n        if (n%2==1){\n            cout << 0 << endl;\n            continue;\n        }\n        es.push_back({n-1,0});\n        sort(es.begin(),es.end());\n        s=es.size();\n        rep(i,n-1) dp[i]={i+1,1};\n        rep(i,s){\n            int b=es[i].first,a=es[i].second; b+=a;\n            ll res1=1,res2=1,l1=a,r1=b,l2=a+1,r2=b-1;\n            while(l1<r1){\n                res1=res1*dp[l1].second%MOD;\n                l1=dp[l1].first+1;\n            }\n            while(l2<r2){\n                res2=res2*dp[l2].second%MOD;\n                l2=dp[l2].first+1;\n            }\n            dp[a]={b,(res1+res2)%MOD};\n        }\n        cout << dp[0].second << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<algorithm>\nusing namespace std;\n\nconst int MOD=1000003;\nint N,M;\nvector<vector<int> > L;\nint ans=0;\n\nint calc(int start,int end){\n//\tcout<<start<<\" \"<<end<<endl;\n\tif((end-start)%2==0){\n\t\t//cout<<\"end \"<<start<<\" \"<<end<<\" :\"<<0<<endl; \n\t\treturn 0;}\n\tif(end-start==1){\n\t\t//cout<<\"end \"<<start<<\" \"<<end<<\" :\"<<1<<endl;\n\t\treturn 1;\n\t}\n\tint res=0;\n\n\tfor(int i=0;i<L[start].size();i++){\n\t\tif(start<=L[start][i] && L[start][i]<=end){\n\t\t\tint ans1=1,ans2=1;\n\t\t\tans1=calc(start+1,L[start][i]-1)%MOD;\n\t\t\tif(L[start][i]+1<end)\n\t\t\t\tans2=calc(L[start][i]+1,end)%MOD;\n\t\t\tres+=(ans1*ans2)%MOD;\n\t\t\tres%=MOD;\n\t\t}\n\t}\n\tres+=1*calc(start+2,end)%MOD;\n\tres%=MOD;\n\tif(start==0 && end==N-1){\n\t\tres+=1*calc(start+1,end-1);\n\t\tres%=MOD;\n\t}\n//\tcout<<\"end \"<<start<<\" \"<<end<<\" :\"<<res<<endl;\n\treturn res%MOD;\n}\n\nint main()\n{\n\twhile(cin>>N>>M && N!=0){\n\t\tL.clear();\n\t\tL.resize(N,vector<int>());\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint in,out;cin>>in>>out;\n\t\t\tin--;out--;\n\t\t\tL[in].push_back(out);\n\t\t\tL[out].push_back(in);\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tsort(L[i].begin(),L[i].end());\n\t\t\tL[i].erase(unique(L[i].begin(),L[i].end()),L[i].end());\n\t\t}\n\t\tans=0;\n\t\tcout<<calc(0,N-1)<<endl;\n//\t\tcout<<\"////////////////\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\ntypedef long long ll;\ntypedef vector<ll> vi;\nconst int MOD = 1000003;\nint n, m;\nvector<vi> g;\n\nvi solve(int l, int r, int gi){\n\tint last = l;\n\tvi res({1, 1});\n\tfor(int i=l;i<=r;i++){\n\t\tif(gi < g[i].size()){\n\t\t\tvi ret = solve(i, g[i][gi], gi+1);\n\t\t\tif((i-last)&1) swap(res[0], res[1]);\n\t\t\tres = vi({res[0]*ret[0] % MOD, res[1]*ret[1] % MOD});\n\t\t\tlast = g[i][gi];\n\t\t\ti = last-1;\n\t\t}\n\t\tgi = 0;\n\t}\n\tres[1] =(res[1] + res[0]) % MOD;\n\tif((r-last)&1) swap(res[0], res[1]);\n\treturn res;\n}\n\nint main(){\n\twhile(~scanf(\"%d%d\", &n, &m), n){\n\t\tg = vector<vi>(n);\n\t\tREP(i, m){\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v);u--; v--;\n\t\t\tif(v < u) swap(u, v);\n\t\t\tif(((u^v)&1)) g[u].push_back(v);\n\t\t}\n\t\tREP(i, n) sort(g[i].rbegin(), g[i].rend());\n\t\tprintf(\"%d\\n\", n%2 ? 0 : (int)solve(0, n-1, 0)[1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\ntypedef long long ll;\ntypedef vector<int> vi;\nconst int MOD = 1000003;\nint n, m;\nvector<vi> g;\n\nvi solve(int l, int r, int gi){\n\tvi res(2, 1);\n\tfor(int i=l;i<r;i++){\n\t\tif(gi < g[i].size()){\n\t\t\tvi ret = solve(i, g[i][gi], gi+1);\n\t\t\tREP(j, 2) res[j] = (ll)res[j]*ret[j]%MOD;\n\t\t\ti = g[i][gi]-1;\n\t\t}\n\t\tswap(res[0], res[1]);\n\t\tgi = 0;\n\t}\n\tswap(res[0], res[1]);\n\tif(r-l > 1) res[1] -= ((res[1] = res[1] + res[0]) >= MOD) ? MOD : 0;\n\treturn res;\n}\n\nint main(){\n\twhile(~scanf(\"%d%d\", &n, &m), n){\n\t\tg = vector<vi>(n);\n\t\tREP(i, m){\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v);u--; v--;\n\t\t\tif(v < u) swap(u, v);\n\t\t\tif(((u^v)&1)) g[u].push_back(v);\n\t\t}\n\t\tREP(i, n) sort(g[i].rbegin(), g[i].rend());\n\t\tprintf(\"%d\\n\", n%2 ? 0 : (int)solve(0, n-1, 0)[1]);\n\t}\n\treturn 0;\n}\n\nlong long esp_org, esp_new;\n\nint main_(){\n    //  ??°????????????????????????????¢??????????\n    const int size = 128*1024*1024;\n    void *p = malloc(size);\n    esp_new = (long long)p + size - 1;\n\n    //  ??????????????????????????????\n    __asm__(\"mov %rsp, esp_org\");\n    __asm__(\"mov esp_new, %rsp\");\n    \n    //  ??????????????????\n    main_();\n    //  ???????????????????????????\n   __asm__(\"mov esp_org, %rsp\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define MOD (1000003LL)\ntypedef long long Int;\n\nint n, mi, cs[60000][2], dp[60000][2][2];\nvector<int> g[60000];\nbool has[60000];\n\ninline int f(int k, int x, int y) { return k == -1 ? x==y : dp[k][x][y]; }\n\nvoid add(int p, int q) {\n    if (p > q) swap(p, q);\n    g[p].push_back(q);\n}\n\nint pre(int p, int q) {\n    if (p+1 == q) return -1;\n    const int k = mi++;\n    has[k] = 0;\n    if (g[p].back() == q) has[k] = 1, g[p].pop_back();\n    const int r = g[p].back();\n    cs[k][0] = pre(p, r);\n    cs[k][1] = pre(r, q);\n    return k;\n}\n\nint main() {\n    for (;;) {\n        int m, a, b;\n        scanf(\"%d%d\", &n, &m);\n        if (n == 0) return 0;\n        rep (_, m) {\n            scanf(\"%d%d\", &a, &b);\n            add(a-1, b-1);\n        }\n        rep (i, n) add(i, (i+1)%n);\n        rep (i, n) sort(g[i].begin(), g[i].end());\n        mi = 0;\n        pre(0, n-1);\n        for (int k = mi-1; k >= 0; k--) {\n            const int p = cs[k][0], q = cs[k][1];\n#define F(x, y) ((Int)f(p, x, 0)*f(q, 1, y) + (Int)f(p, x, 1)*f(q, 0, y))\n            dp[k][0][0] = F(0, 0) % MOD;\n            dp[k][0][1] = F(0, 1) % MOD;\n            dp[k][1][0] = F(1, 0) % MOD;\n            Int a = F(1, 1);\n            if (has[k]) a += dp[k][0][0];\n            dp[k][1][1] = a % MOD;\n        }\n        printf(\"%d\\n\", dp[0][1][1]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntypedef vector< pair<vi,vi> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\nset<unsigned int> is_edge;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(vector<vi> &g){\n  unsigned int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  set<unsigned int> tmp_edge = is_edge;\n  rep(i,n){\n    deg[i] = g[i].sz; deg[i]*=-1;\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vi unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tunsigned int aa = a, bb = b;\n\tif(aa>bb)swap(aa,bb);\n\tif(aa!=bb && !tmp_edge.count(aa*n + bb)){\n\t  g[aa].pb(bb);\n\t  g[bb].pb(aa);\n\t  tmp_edge.insert(aa*n + bb);\n\t  deg[aa]--; deg[bb]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, int id){\n  stack<int> s;\n  s.push(id);\n\n  while(s.sz){\n    id = s.top(); s.pop();\n    \n    //for join\n    while(t[id].first.size()>2){\n      vi child(2);\n      child[0] = t[id].first.back(); t[id].first.pop_back();\n      child[1] = t[id].first.back(); t[id].first.pop_back();\n      t.push_back(make_pair(child, t[id].second));\n      t[id].first.push_back(t.size()-1);\n    }\n\n    if(t[id].first.size()==2){\n      rep(i,2){\n\tconst int &j = t[id].first[i];\n\tif(t[id].second != t[j].second){\n\t  vi child(1);\n\t  child[0] = j;\n\t  t.push_back(make_pair(child, t[id].second));\n\t  t[id].first[i] = t.size()-1;\n\t}\n      }\n    }\n\n    //for introduce & forget\n    if(t[id].first.size()==1){\n      const int &j = t[id].first[0];\n      vi child(1);\n      child[0] = j;\n      \n      vi disA, disB;\n      rep(a,t[id].second.size()){\n\tbool f = true;\n\trep(b,t[j].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disA.push_back(a);\n      }\n      rep(b,t[j].second.size()){\n\tbool f = true;\n\trep(a,t[id].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disB.push_back(b);\n      }\n      \n      if(disA.size() + disB.size() > 1){\n\tif(disA.size()>0){\n\t  vi tmp = t[id].second;\n\t  tmp.erase(tmp.begin() + disA[0]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}else{\n\t  vi tmp = t[id].second;\n\t  tmp.push_back(t[j].second[disB[0]]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}      \n      }\n    }\n    \n    //for leaf\n    if(t[id].first.size() == 0){\n      if(t[id].second.size() > 1){\n\tvi tmp;\n\trep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n\tt.push_back(make_pair(vi(), tmp));\n\tt[id].first.push_back(t.size()-1);\n      }\n    }\n\n    rep(i,t[id].first.size()){\n      s.push(t[id].first[i]);\n    }\n  }\n}\n\nunordered_map<int,int> memo;\n\ninline int dp(int id, int use, unsigned int n, const TD &t){\n  int key = 100*id + use;\n\n  stack<int> s;\n  s.push(key);\n\n  while(s.sz){\n    ll res = 0;\n    key = s.top(); s.pop();\n    id = key/100; use = key%100;\n    const vi& child = t[id].fs, bag = t[id].sc;\n    \n    //for leaf\n    if(child.sz==0){\n      memo[key] = use;\n      goto END;\n    }\n    \n    if(child.sz==1){\n      const vi &nbag = t[child[0]].second;\n      vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n      rep(i,bag.size())rep(j,nbag.size()){\n\tif(bag[i] == nbag[j]){\n\t  to_bag[j] = i; to_nbag[i] = j;\n\t}\n      }\n      \n      //for introduce\n      if(nbag.sz < bag.sz){\n\tint nuse = 0;\n\trep(i,bag.sz){\n\t  if(to_nbag[i]<0){\n\t    if( ((use>>i)&1) == 0 ){\n\t      memo[key] = 0;\n\t      goto END;\n\t    }\n\t  }else{\n\t    if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t  }\n\t}\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  memo[key] = memo[nxt];\n\t  goto END;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n      }\n      \n      //for forget\n      if(nbag.sz > bag.sz){\n\tint add = -1,  nuse = 0;\n\trep(i,nbag.sz){\n\t  if(to_bag[i]<0)add = i;\n\t  else if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n\t}\n\t\n\tll res = 0;\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  (res += memo[nxt]) %= mod;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n\n\trep(i,bag.sz){\n\t  if((use>>i)&1)continue;\n\t  \n\t  unsigned int a = bag[i], b = nbag[add];\n\t  if(a>b)swap(a,b);\n\t  if(is_edge.count(a*n + b)){\n\t    nxt = child[0]*100 + (nuse | (1<<add) | (1<<to_nbag[i]));\n\t    if(memo.count(nxt)){\n\t      (res += memo[nxt]) %= mod;\n\t    }else{\n\t      s.push(key); s.push(nxt);\n\t      goto END;\n\t    }\n\t  }\n\t}\n\tmemo[key] = res;\n      }\n    }\n    \n    //for join\n    if(child.sz==2){\n      int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n      do{\n\tint nxt1 = child[0]*100 + (use|sub), nxt2 = child[1]*100 + (use|(unuse-sub));\n\tif(memo.count(nxt1) == 0){\n\t  s.push(key); s.push(nxt1);\n\t  goto END;\n\t}\n\tif(memo.count(nxt2) == 0){\n\t  s.push(key); s.push(nxt2);\n\t  goto END;\n\t}\n\tif(memo.count(nxt1) && memo.count(nxt2)){\n\t  res += (ll)memo[nxt1] * memo[nxt2];\n\t  res %= mod;\n\t}\n\tsub = (sub-1)&unuse;\n      }while(sub != unuse);\n    \n      memo[key] = res;\n    }\n  END:;\n  }\n  return memo[key];\n}\n\nvoid visg(vector<vi> g){\n  int n = g.size();\n  cout << \"graph {\" << endl;\n  rep(i,n){\n    rep(k,g[i].sz){\n      if(i<g[i][k]){\n\tcout << \"  \\\"\" << i << \" \";\n\tcout << \"\\\" -- \\\"\" << g[i][k] << \" \";\n\tcout << \"\\\"\" << endl;\n      }\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nvoid vis(TD t){\n  int n = t.size();\n  cout << \"digraph {\" << endl;\n  rep(i,n){\n    rep(k,t[i].first.size()){\n      int nxt = t[i].first[k];\n      cout << \"  \\\"\" << i << \": \";\n      rep(j,t[i].second.size())cout << t[i].second[j] << \" \";\n      cout << \"\\\" -> \\\"\" << nxt << \": \";\n      rep(j,t[nxt].second.size())cout << t[nxt].second[j] << \" \";\n      cout << \"\\\"\" << endl;\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nint main(){\n  unsigned int n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    vector<vi> g(n);\n    is_edge.clear();\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*n + b);\n      else is_edge.insert(b*n + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*n + b);\n      else is_edge.insert(b*n + a);\n    }\n\n    //visg(g);\n    TD t = heuristic_tree_decomposition(g);\n    g.clear();\n    //cout << t.size() << endl;\n    //vis(t);\n    toNice(t,0);\n    //cerr << t.size() << endl;\n    //vis(t);\n\n    ll res = 0;\n    memo.clear();\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      res += dp(0,use,n,t);\n      res %= mod;\n    }\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<stack>\n#include<set>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nconst long long mod=1000003;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nint N,M;\nvector<int> G[50500];\n\nmap<PP,long long> dp;\nset<PP> se;\n\nstack<PP> st;\nlong long solve(){\n\twhile(!st.empty()) st.pop();\n\tst.push(PP(P(0,N-1),P(0,0)));\n\twhile(!st.empty()){\n\t\tPP pp=st.top();\n\t\tst.pop();\n\t\tif(dp.count(pp)==1) continue;\n\t\tif(se.find(pp)!=se.end()){\n\t\t\tint u=pp.first.first,v=pp.first.second;\n\t\t\tint fu=pp.second.first,fv=pp.second.second;\n\t//\t\tprintf(\"a%d %d %d %d \",u,v,fu,fv);\n\t//\t\tprintf(\"%d %d %d %d\\n\",u,v,fu,fv);\n\t\t/*\tif(v==u+1){\n\t\t\t\tint res=(fu+fv)%2;\n\t\t\t\tres^=1;\n\t\t\t\tdp[pp]=res;\n\t\t\t\treturn res;\n\t\t\t}*/\n\t\t\tlong long res=0;\n\t\t\tint id=distance(G[u].begin(),lower_bound(G[u].begin(),G[u].end(),v));\n\t\t\tif(id>0&&G[u][id-1]>u){\n\t\t\t\tint w=G[u][id-1];\n\t\t//\t\tres+=(solve(u,w,fu,1)*solve(w,v,0,fv));\n\t\t\t\tres+=dp[PP(P(u,w),P(fu,1))]*dp[PP(P(w,v),P(0,fv))];\n\t\t\t\tres%=mod;\n\t\t\t//\tres+=(solve(u,w,fu,0)*solve(w,v,1,fv));\n\t\t\t\tres+=dp[PP(P(u,w),P(fu,0))]*dp[PP(P(w,v),P(1,fv))];\n\t\t\t\tres%=mod;\n\t\t\t/*\tif(fu==0){\n\t\t\t\t\tres+=(solve(u,w,1,1)*solve(w,v,1,fv));\n\t\t\t\t\tres%=mod;\n\t\t\t\t}*/\n\t\t\t\tif(fu==0&&fv==0&&binary_search(G[u].begin(),G[u].end(),v)){\n\t\t\t\t//\tres+=(solve(u,w,1,0)*solve(w,v,1,1));\n\t\t\t\t//\tres+=(solve(u,w,1,1)*solve(w,v,0,1));\n\t\t\t\t\tres+=dp[PP(P(u,w),P(1,0))]*dp[PP(P(w,v),P(1,1))];\n\t\t\t\t\tres+=dp[PP(P(u,w),P(1,1))]*dp[PP(P(w,v),P(0,1))];\n\t\t\t\t\tres%=mod;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tint u=pp.first.first,v=pp.first.second;\n\t\t\t\tint fu=pp.second.first,fv=pp.second.second;\n\t\t\t\t//res+=solve(u+1,v,fu^1,fv);\n\t\t\t\tres+=dp[PP(P(u+1,v),P(fu^1,fv))];\n\t\t\t\tif(fu==0&&fv==0&&binary_search(G[u].begin(),G[u].end(),v)){\n\t\t\t\t\t//res+=solve(u+1,v,0,1);\n\t\t\t\t\tres+=dp[PP(P(u+1,v),P(0,1))];\n\t\t\t\t}\n\t\t\t\tres%=mod;\n\t\t\t}\n\t\t//\tprintf(\"%lld\\n\",res);\n\t\t\tdp[pp]=res;\n\t\t}\n\t\telse{\n\t\t\tint u=pp.first.first,v=pp.first.second;\n\t\t\tint fu=pp.second.first,fv=pp.second.second;\n\t\t//\tprintf(\"b%d %d %d %d\\n\",u,v,fu,fv);\n\t\t\tif(v==u+1){\n\t\t\t\tint res=(fu+fv)%2;\n\t\t\t\tres^=1;\n\t\t\t\tdp[pp]=res;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tse.insert(pp);\n\t\t\tst.push(pp);\n\t\t\tint id=distance(G[u].begin(),lower_bound(G[u].begin(),G[u].end(),v));\n\t\t\tif(id>0&&G[u][id-1]>u){\n\t\t\t\tint w=G[u][id-1];\n\t\t\t\tfor(int a=0;a<2;a++) for(int b=0;b<2;b++){\n\t\t\t\t\tst.push(PP(P(u,w),P(a,b)));\n\t\t\t\t\tst.push(PP(P(w,v),P(a,b)));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int a=0;a<2;a++) for(int b=0;b<2;b++){\n\t\t\t\t\tst.push(PP(P(u+1,v),P(a,b)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[PP(P(0,N-1),P(0,0))];\n}\n\nvoid init(){\n\tmap<PP,long long> mp;\n\tswap(mp,dp);\n\tset<PP> se_;\n\tswap(se,se_);\n\tfor(int i=0;i<N;i++) G[i].clear();\n}\n\nvoid output(){\n\tmap<PP,long long>::iterator it=dp.begin();\n\tfor(;it!=dp.end();it++){\n\t\tPP pp=it->first;\n\t\tlong long val=it->second;\n\t\tprintf(\"%d %d %d %d =%lld\\n\",pp.first.first,pp.first.second,pp.second.first,pp.second.second,\n\t\tval);\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tinit();\n\t\tscanf(\"%d%d\",&N,&M);\n\t\tif(N==0) break;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t\tG[0].push_back(N-1);\n\t\tG[N-1].push_back(0);\n\t\tfor(int i=0;i<N;i++) sort(G[i].begin(),G[i].end());\n\t\tlong long ans=solve();\n\t\tans+=mod;\n\t\tans%=mod;\n\t//\toutput();\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<unsigned short> vs;\n\ntypedef vector< pair<vi,vs> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\nset<ui> is_edge;\nvector<vs> g;\nTD t;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(void){\n  unsigned int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  set<ui> tmp_edge = is_edge;\n  rep(i,n){\n    deg[i] = g[i].sz; deg[i]*=-1;\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vs unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tui aa = a, bb = b;\n\tif(aa>bb)swap(aa,bb);\n\tif(aa!=bb && !tmp_edge.count(aa*n + bb)){\n\t  g[aa].pb(bb);\n\t  g[bb].pb(aa);\n\t  tmp_edge.insert(aa*n + bb);\n\t  deg[aa]--; deg[bb]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, int id){\n  stack<int> s;\n  s.push(id);\n\n  while(s.sz){\n    id = s.top(); s.pop();\n    \n    //for join\n    while(t[id].first.size()>2){\n      vi child(2);\n      child[0] = t[id].first.back(); t[id].first.pop_back();\n      child[1] = t[id].first.back(); t[id].first.pop_back();\n      t.push_back(make_pair(child, t[id].second));\n      t[id].first.push_back(t.size()-1);\n    }\n\n    if(t[id].first.size()==2){\n      rep(i,2){\n\tconst int &j = t[id].first[i];\n\tif(t[id].second != t[j].second){\n\t  vi child(1);\n\t  child[0] = j;\n\t  t.push_back(make_pair(child, t[id].second));\n\t  t[id].first[i] = t.size()-1;\n\t}\n      }\n    }\n\n    //for introduce & forget\n    if(t[id].first.size()==1){\n      const int &j = t[id].first[0];\n      vi child(1);\n      child[0] = j;\n      \n      vi disA, disB;\n      rep(a,t[id].second.size()){\n\tbool f = true;\n\trep(b,t[j].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disA.push_back(a);\n      }\n      rep(b,t[j].second.size()){\n\tbool f = true;\n\trep(a,t[id].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disB.push_back(b);\n      }\n      \n      if(disA.size() + disB.size() > 1){\n\tif(disA.size()>0){\n\t  vs tmp = t[id].second;\n\t  tmp.erase(tmp.begin() + disA[0]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}else{\n\t  vs tmp = t[id].second;\n\t  tmp.push_back(t[j].second[disB[0]]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}      \n      }\n    }\n    \n    //for leaf\n    if(t[id].first.size() == 0){\n      if(t[id].second.size() > 1){\n\tvs tmp;\n\trep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n\tt.push_back(make_pair(vi(), tmp));\n\tt[id].first.push_back(t.size()-1);\n      }\n    }\n\n    rep(i,t[id].first.size()){\n      s.push(t[id].first[i]);\n    }\n  }\n}\n\nunordered_map<int,int> memo;\n\ninline int dp(int id, int use, unsigned int n, const TD &t){\n  int key = 100*id + use;\n\n  int maxs = 0;\n  vector<int> s(t.sz);\n  int pos = 0;\n  s[pos++] = key;\n\n  while(pos){\n    ll res = 0;\n    key = s[--pos];\n    id = key/100; use = key%100;\n    const vi &child = t[id].fs;\n    const vs &bag = t[id].sc;\n    \n    //for leaf\n    if(child.sz==0){\n      memo[key] = use;\n      goto END;\n    }\n    \n    if(child.sz==1){\n      const vs &nbag = t[child[0]].second;\n      vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n      rep(i,bag.size())rep(j,nbag.size()){\n\tif(bag[i] == nbag[j]){\n\t  to_bag[j] = i; to_nbag[i] = j;\n\t}\n      }\n      \n      //for introduce\n      if(nbag.sz < bag.sz){\n\tint nuse = 0;\n\trep(i,bag.sz){\n\t  if(to_nbag[i]<0){\n\t    if( ((use>>i)&1) == 0 ){\n\t      memo[key] = 0;\n\t      goto END;\n\t    }\n\t  }else{\n\t    if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t  }\n\t}\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  memo[key] = memo[nxt];\n\t  goto END;\n\t}else{\n\t  s[pos++] = key; s[pos++] = nxt;\n\t  goto END;\n\t}\n      }\n      \n      //for forget\n      if(nbag.sz > bag.sz){\n\tint add = -1,  nuse = 0;\n\trep(i,nbag.sz){\n\t  if(to_bag[i]<0)add = i;\n\t  else if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n\t}\n\t\n\tll res = 0;\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  (res += memo[nxt]) %= mod;\n\t}else{\n\t  s[pos++] = key; s[pos++] = nxt;\n\t  goto END;\n\t}\n\n\trep(i,bag.sz){\n\t  if((use>>i)&1)continue;\n\t  \n\t  ui a = bag[i], b = nbag[add];\n\t  if(a>b)swap(a,b);\n\t  if(is_edge.count(a*n + b)){\n\t    nxt = child[0]*100 + (nuse | (1<<add) | (1<<to_nbag[i]));\n\t    if(memo.count(nxt)){\n\t      (res += memo[nxt]) %= mod;\n\t    }else{\n\t      s[pos++] = key; s[pos++] = nxt;\n\t      goto END;\n\t    }\n\t  }\n\t}\n\tmemo[key] = res;\n      }\n    }\n    \n    //for join\n    if(child.sz==2){\n      int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n      do{\n\tint nxt1 = child[0]*100 + (use|sub), nxt2 = child[1]*100 + (use|(unuse-sub));\n\tif(memo.count(nxt1) == 0){\n\t  s[pos++] = key; s[pos++] = nxt1;\n\t  goto END;\n\t}\n\tif(memo[nxt1]){\n\t  if(memo.count(nxt2) == 0){\n\t    s[pos++] = key; s[pos++] = nxt2;\n\t    goto END;\n\t  }\n\t  if(memo[nxt2]){\n\t    res += (ll)memo[nxt1] * memo[nxt2];\n\t    res %= mod;\n\t  }\n\t}\n\tsub = (sub-1)&unuse;\n      }while(sub != unuse);\n    \n      memo[key] = res;\n    }\n  END: maxs = max(maxs, (int)s.sz);\n  }\n  //cerr << maxs << endl;\n  return memo[key];\n}\n\nvoid visg(vector<vi> g){\n  int n = g.size();\n  cout << \"graph {\" << endl;\n  rep(i,n){\n    rep(k,g[i].sz){\n      if(i<g[i][k]){\n\tcout << \"  \\\"\" << i << \" \";\n\tcout << \"\\\" -- \\\"\" << g[i][k] << \" \";\n\tcout << \"\\\"\" << endl;\n      }\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nvoid vis(TD t){\n  int n = t.size();\n  cout << \"digraph {\" << endl;\n  rep(i,n){\n    rep(k,t[i].first.size()){\n      int nxt = t[i].first[k];\n      cout << \"  \\\"\" << i << \": \";\n      rep(j,t[i].second.size())cout << t[i].second[j] << \" \";\n      cout << \"\\\" -> \\\"\" << nxt << \": \";\n      rep(j,t[nxt].second.size())cout << t[nxt].second[j] << \" \";\n      cout << \"\\\"\" << endl;\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nint main(){\n  ui n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    g.resize(n,vs());\n    is_edge.clear();\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*n + b);\n      else is_edge.insert(b*n + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*n + b);\n      else is_edge.insert(b*n + a);\n    }\n\n    t = heuristic_tree_decomposition();\n    g.clear();\n    toNice(t,0);\n    //cerr << t.sz << endl;\n\n    ll res = 0;\n    memo.clear();\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      res += dp(0,use,n,t);\n      res %= mod;\n    }\n    printf(\"%lld\\n\",res);\n    t.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include <complex>\n#include<list>\n#include<float.h>\n#include <functional>\n#include <hash_map.h>\n//lib\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REP0(i,n)   REP(i,0,n)\n\n#define foreach(it,o) for(__typeof((o).begin()) it=(o).begin(); it!=(o).end(); ++it)\n\nint n,m;\n\nint a,b;\n\nhash_map<int,list<int> >nodes;\n\n\nvector<bool> passed;\nint search(int i){//パターン数の出力\n\tif(passed[i] ||nodes[i].size()==0){\n\t\treturn 0;\n\t}\n\tpassed[i]=true;\n\n\tint val=nodes[i].size();\n\tforeach(node,nodes[i]){\n\t\tint v=search(*node);\n\t\tval*=v>0?v:1;\n\t}\n\tcout<<\"(\"<< i << \",\"<<nodes[i].size()<< \",\"<<val<<\")\"<<endl;\n\treturn val;\n}\nvoid solve(){\n\t//与えられたノードのONOFF判定のみすればよい。\n\tint val=1;\n\tint graphs=0;\n\tREP(i,1,n+1){\n\t\tint s=search(i)+1;\n\t\tval*=s;\n\t\tif(s>1){\n\t\t\tgraphs++;\n\t\t}\n\t}\n\tcout <<val+1<<endl;\n}\n//データ整形\nint main() {\n\twhile (true) {\n\t\tcin >> n>>m;\n\t\tif (n == 0&& m==0) {\n\t\t\tbreak;\n\t\t}\n\t\tif(n%2==1){\n\t\t\tcout <<0<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tpassed.clear();\n\t\tnodes.clear();\n\n\t\tREP0(p,m){\n\t\t\tcin >>a>>b;\n\t\t\tif((b-a+2*n)%2==1){\n\t\t\tnodes[a].push_back(b);\n\t\t\tnodes[b].push_back(a);\n\t\t\t}\n\t\t}\n\t\tREP(i,0,n+1){\n\t\t\tpassed.push_back(false);\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int M=1000003;\n\nvector<int> G[50000];\n\nmap<pair<int,int>,ll> dp[2][2];\nll dfs(int l,int r,bool bl,bool br){\n\tif(l+1==r) return bl&&br?1:0;\n\n\tif(dp[bl][br].count(make_pair(l,r))>0) return dp[bl][br][make_pair(l,r)];\n\n\tint u=*upper_bound(G[r].begin(),G[r].end(),l);\n\n\tll res=0;\n\tres+=dfs(l,u,bl, true)*dfs(u,r,false,br); // 頂点 u を [u,r] 側のマッチングに使う\n\tres+=dfs(l,u,bl,false)*dfs(u,r, true,br); // 頂点 u を [l,u] 側のマッチングに使う\n\tif(!bl && binary_search(G[l].begin(),G[l].end(),u)){\n\t\tres+=dfs(l,u,true,true)*dfs(u,r,true,br); // 辺 l-u をマッチングに使う\n\t}\n\tif(!br && binary_search(G[r].begin(),G[r].end(),u)){\n\t\tres+=dfs(l,u,bl,true)*dfs(u,r,true,true); // 辺 u-r をマッチングに使う\n\t}\n\treturn dp[bl][br][make_pair(l,r)]=res%M;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\trep(u,n) G[u].clear();\n\t\trep(u,n){\n\t\t\tG[u].push_back((u+1)%n);\n\t\t\tG[u].push_back((u-1+n)%n);\n\t\t}\n\t\trep(i,m){\n\t\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t\trep(u,n) sort(G[u].begin(),G[u].end());\n\n\t\trep(i,2) rep(j,2) dp[i][j].clear();\n\t\tprintf(\"%lld\\n\",(dfs(0,n-1,false,false)+dfs(0,n-1,true,true))%M);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntypedef vector< pair<vi,vi> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\nset<ll> is_edge;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(vector<vi> g){\n  int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  set<ll> tmp_edge = is_edge;\n  rep(i,n){\n    deg[i] = g[i].sz; deg[i]*=-1;\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vi unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tif(a!=b && !tmp_edge.count(a*mod + b)){\n\t  g[a].pb(b);\n\t  g[b].pb(a);\n\t  tmp_edge.insert(a*mod + b);\n\t  tmp_edge.insert(b*mod + a);\n\t  deg[a]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, const int &id){\n  //for join\n  while(t[id].first.size()>2){\n    vi child(2);\n    child[0] = t[id].first.back(); t[id].first.pop_back();\n    child[1] = t[id].first.back(); t[id].first.pop_back();\n    t.push_back(make_pair(child, t[id].second));\n    t[id].first.push_back(t.size()-1);\n  }\n\n  if(t[id].first.size()==2){\n    rep(i,2){\n      const int &j = t[id].first[i];\n      if(t[id].second != t[j].second){\n\tvi child(1);\n\tchild[0] = j;\n\tt.push_back(make_pair(child, t[id].second));\n\tt[id].first[i] = t.size()-1;\n      }\n    }\n  }\n\n  //for introduce & forget\n  if(t[id].first.size()==1){\n    const int &j = t[id].first[0];\n    vi child(1);\n    child[0] = j;\n\n    vi disA, disB;\n    rep(a,t[id].second.size()){\n      bool f = true;\n      rep(b,t[j].second.size()){\n\tif(t[id].second[a] == t[j].second[b])f = false;\n      }\n      if(f)disA.push_back(a);\n    }\n    rep(b,t[j].second.size()){\n      bool f = true;\n      rep(a,t[id].second.size()){\n\tif(t[id].second[a] == t[j].second[b])f = false;\n      }\n      if(f)disB.push_back(b);\n    }\n\n    if(disA.size() + disB.size() > 1){\n      if(disA.size()>0){\n\tvi tmp = t[id].second;\n\ttmp.erase(tmp.begin() + disA[0]);\n\tt.push_back(make_pair(child, tmp));\n\tt[id].first[0] = t.size()-1;\n      }else{\n\tvi tmp = t[id].second;\n\ttmp.push_back(t[j].second[disB[0]]);\n\tt.push_back(make_pair(child, tmp));\n\tt[id].first[0] = t.size()-1;\n      }      \n    }\n  }\n\n  //for leaf\n  if(t[id].first.size() == 0){\n    if(t[id].second.size() > 1){\n      vi tmp;\n      rep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n      t.push_back(make_pair(vi(), tmp));\n      t[id].first.push_back(t.size()-1);\n    }\n  }\n\n  rep(i,t[id].first.size())toNice(t, t[id].first[i]);\n}\n\nunordered_map<ll,ll> memo;\n\nll rec(int id, int use, const TD &t){\n  ll key = mod*id + use;\n  if(memo.count(key))return memo[key];\n\n  const vi& child = t[id].fs, bag = t[id].sc;\n  \n  //for leaf\n  if(child.sz==0)return use;\n\n  ll res = 0;\n  if(child.sz==1){\n    const vi &nbag = t[child[0]].second;\n    vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n    rep(i,bag.size())rep(j,nbag.size()){\n      if(bag[i] == nbag[j]){\n\tto_bag[j] = i; to_nbag[i] = j;\n      }\n    }\n\n    //for introduce\n    if(nbag.sz < bag.sz){\n      int nuse = 0;\n      rep(i,bag.sz){\n\tif(to_nbag[i]<0){\n\t  if( ((use>>i)&1) == 0 )return memo[key] = 0;\n\t}else{\n\t  if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t}\n      }\n      return memo[key] = rec(child[0],nuse,t);\n    }\n\n    //for forget\n    if(nbag.sz > bag.sz){\n      int add = -1,  nuse = 0;\n      rep(i,nbag.sz){\n\tif(to_bag[i]<0)add = i;\n\telse if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n      }\n\n      ll res = 0;\n      (res += rec(child[0],nuse,t)) %= mod;\n\n      rep(i,bag.sz){\n\tif((use>>i)&1)continue;\n\n\tif(is_edge.count(bag[i]*mod + nbag[add])){\n\t  res += rec(child[0], nuse | (1<<add) | (1<<to_nbag[i]), t);\n\t  res %= mod;\n\t}\n      }\n      return memo[key] = res;\n    }\n  }\n\n  //for join\n  if(child.sz==2){\n    int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n    do{\n      res += rec(child[0],use|sub,t) * rec(child[1],use|(unuse-sub),t);\n      res %= mod;\n      sub = (sub-1)&unuse;\n    }while(sub != unuse);\n  }\n  return memo[key] = res % mod;\n}\n\nvoid vis(TD t){\n  int n = t.size();\n  cout << \"digraph {\" << endl;\n  rep(i,n){\n    rep(k,t[i].first.size()){\n      int nxt = t[i].first[k];\n      cout << \"  \\\"\" << i << \": \";\n      rep(j,t[i].second.size())cout << t[i].second[j] << \" \";\n      cout << \"\\\" -> \\\"\" << nxt << \": \";\n      rep(j,t[nxt].second.size())cout << t[nxt].second[j] << \" \";\n      cout << \"\\\"\" << endl;\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nint main(){\n  int n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    vector<vi> g(n);\n    is_edge.clear();\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      is_edge.insert(a*mod + b);\n      is_edge.insert(b*mod + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      is_edge.insert(a*mod + b);\n      is_edge.insert(b*mod + a);\n    }\n\n    TD t = heuristic_tree_decomposition(g);\n    toNice(t,0);\n    //vis(t);\n\n    ll res = 0;\n    memo.clear();\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      res += rec(0,use,t);\n      res %= mod;\n    }\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include <complex>\n#include<list>\n#include<float.h>\n#include <functional>\n#include <vector>\n#include <map>\n//lib\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REP0(i,n)   REP(i,0,n)\n\n#define foreach(it,o) for(__typeof((o).begin()) it=(o).begin(); it!=(o).end(); ++it)\n\nint n, m;\n\nint a, b;\n\n\nvector<bool> passed;\nmap<int, list<int> > nodes;\n\nint search(int i) { //パターン数の出力\n\tif (passed[i] || nodes[i].size() == 0) {\n\t\treturn 0;\n\t}\n\tpassed[i] = true;\n\n\tint val = nodes[i].size();\n\tforeach(node,nodes[i]) {\n\t\tint v = search(*node);\n\t\tval *= v > 0 ? v : 1;\n\t}\n\t//cout<<\"(\"<< i << \",\"<<nodes[i].size()<< \",\"<<val<<\")\"<<endl;\n\treturn val % 1000003;\n}\nvoid solve() {\n\t//与えられたノードのONOFF判定のみすればよい。\n\tint val = 1;\n\tint graphs = 0;\n\tREP(i,1,n+1) {\n\t\tval *=(search(i) + 1);\n\t\tval%=1000003;\n\t}\n\tcout << (val + 1)%1000003 << endl;\n}\n//データ整形\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (n % 2 == 1) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tpassed.clear();\n\t\tnodes.clear();\n\n\t\tREP0(p,m) {\n\t\t\tcin >> a >> b;\n\t\t\tif ((b - a + 2 * n) % 2 == 1 && b!=a) {\n\t\t\t\tnodes[a].push_back(b);\n\t\t\t\tnodes[b].push_back(a);\n\t\t\t}\n\t\t}\n\t\tREP(i,0,n+1) {\n\t\t\tpassed.push_back(false);\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntypedef vector< pair<vi,vi> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\nset<unsigned int> is_edge;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(vector<vi> &g){\n  unsigned int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  set<unsigned int> tmp_edge = is_edge;\n  rep(i,n){\n    deg[i] = g[i].sz; deg[i]*=-1;\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vi unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tunsigned int aa = a, bb = b;\n\tif(aa>bb)swap(aa,bb);\n\tif(aa!=bb && !tmp_edge.count(aa*n + bb)){\n\t  g[aa].pb(bb);\n\t  g[bb].pb(aa);\n\t  tmp_edge.insert(aa*n + bb);\n\t  deg[aa]--; deg[bb]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, int id){\n  stack<int> s;\n  s.push(id);\n\n  while(s.sz){\n    id = s.top(); s.pop();\n    \n    //for join\n    while(t[id].first.size()>2){\n      vi child(2);\n      child[0] = t[id].first.back(); t[id].first.pop_back();\n      child[1] = t[id].first.back(); t[id].first.pop_back();\n      t.push_back(make_pair(child, t[id].second));\n      t[id].first.push_back(t.size()-1);\n    }\n\n    if(t[id].first.size()==2){\n      rep(i,2){\n\tconst int &j = t[id].first[i];\n\tif(t[id].second != t[j].second){\n\t  vi child(1);\n\t  child[0] = j;\n\t  t.push_back(make_pair(child, t[id].second));\n\t  t[id].first[i] = t.size()-1;\n\t}\n      }\n    }\n\n    //for introduce & forget\n    if(t[id].first.size()==1){\n      const int &j = t[id].first[0];\n      vi child(1);\n      child[0] = j;\n      \n      vi disA, disB;\n      rep(a,t[id].second.size()){\n\tbool f = true;\n\trep(b,t[j].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disA.push_back(a);\n      }\n      rep(b,t[j].second.size()){\n\tbool f = true;\n\trep(a,t[id].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disB.push_back(b);\n      }\n      \n      if(disA.size() + disB.size() > 1){\n\tif(disA.size()>0){\n\t  vi tmp = t[id].second;\n\t  tmp.erase(tmp.begin() + disA[0]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}else{\n\t  vi tmp = t[id].second;\n\t  tmp.push_back(t[j].second[disB[0]]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}      \n      }\n    }\n    \n    //for leaf\n    if(t[id].first.size() == 0){\n      if(t[id].second.size() > 1){\n\tvi tmp;\n\trep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n\tt.push_back(make_pair(vi(), tmp));\n\tt[id].first.push_back(t.size()-1);\n      }\n    }\n\n    rep(i,t[id].first.size()){\n      s.push(t[id].first[i]);\n    }\n  }\n}\n\nunordered_map<int,int> memo;\n\ninline int dp(int id, int use, unsigned int n, const TD &t){\n  int key = 100*id + use;\n\n  int maxs = 0;\n  stack<int> s;\n  s.push(key);\n\n  while(s.sz){\n    ll res = 0;\n    key = s.top(); s.pop();\n    id = key/100; use = key%100;\n    const vi& child = t[id].fs, bag = t[id].sc;\n    \n    //for leaf\n    if(child.sz==0){\n      memo[key] = use;\n      goto END;\n    }\n    \n    if(child.sz==1){\n      const vi &nbag = t[child[0]].second;\n      vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n      rep(i,bag.size())rep(j,nbag.size()){\n\tif(bag[i] == nbag[j]){\n\t  to_bag[j] = i; to_nbag[i] = j;\n\t}\n      }\n      \n      //for introduce\n      if(nbag.sz < bag.sz){\n\tint nuse = 0;\n\trep(i,bag.sz){\n\t  if(to_nbag[i]<0){\n\t    if( ((use>>i)&1) == 0 ){\n\t      memo[key] = 0;\n\t      goto END;\n\t    }\n\t  }else{\n\t    if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t  }\n\t}\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  memo[key] = memo[nxt];\n\t  goto END;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n      }\n      \n      //for forget\n      if(nbag.sz > bag.sz){\n\tint add = -1,  nuse = 0;\n\trep(i,nbag.sz){\n\t  if(to_bag[i]<0)add = i;\n\t  else if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n\t}\n\t\n\tll res = 0;\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  (res += memo[nxt]) %= mod;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n\n\trep(i,bag.sz){\n\t  if((use>>i)&1)continue;\n\t  \n\t  unsigned int a = bag[i], b = nbag[add];\n\t  if(a>b)swap(a,b);\n\t  if(is_edge.count(a*n + b)){\n\t    nxt = child[0]*100 + (nuse | (1<<add) | (1<<to_nbag[i]));\n\t    if(memo.count(nxt)){\n\t      (res += memo[nxt]) %= mod;\n\t    }else{\n\t      s.push(key); s.push(nxt);\n\t      goto END;\n\t    }\n\t  }\n\t}\n\tmemo[key] = res;\n      }\n    }\n    \n    //for join\n    if(child.sz==2){\n      int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n      do{\n\tint nxt1 = child[0]*100 + (use|sub), nxt2 = child[1]*100 + (use|(unuse-sub));\n\tif(memo.count(nxt1) == 0){\n\t  s.push(key); s.push(nxt1);\n\t  goto END;\n\t}\n\tif(memo[nxt1]){\n\t  if(memo.count(nxt2) == 0){\n\t    s.push(key); s.push(nxt2);\n\t    goto END;\n\t  }\n\t  if(memo[nxt2]){\n\t    res += (ll)memo[nxt1] * memo[nxt2];\n\t    res %= mod;\n\t  }\n\t}\n\tsub = (sub-1)&unuse;\n      }while(sub != unuse);\n    \n      memo[key] = res;\n    }\n  END: maxs = max(maxs, (int)s.sz);\n  }\n  //cerr << maxs << endl;\n  return memo[key];\n}\n\nvoid visg(vector<vi> g){\n  int n = g.size();\n  cout << \"graph {\" << endl;\n  rep(i,n){\n    rep(k,g[i].sz){\n      if(i<g[i][k]){\n\tcout << \"  \\\"\" << i << \" \";\n\tcout << \"\\\" -- \\\"\" << g[i][k] << \" \";\n\tcout << \"\\\"\" << endl;\n      }\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nvoid vis(TD t){\n  int n = t.size();\n  cout << \"digraph {\" << endl;\n  rep(i,n){\n    rep(k,t[i].first.size()){\n      int nxt = t[i].first[k];\n      cout << \"  \\\"\" << i << \": \";\n      rep(j,t[i].second.size())cout << t[i].second[j] << \" \";\n      cout << \"\\\" -> \\\"\" << nxt << \": \";\n      rep(j,t[nxt].second.size())cout << t[nxt].second[j] << \" \";\n      cout << \"\\\"\" << endl;\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nint main(){\n  unsigned int n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    vector<vi> g(n);\n    is_edge.clear();\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*n + b);\n      else is_edge.insert(b*n + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*n + b);\n      else is_edge.insert(b*n + a);\n    }\n\n    TD t = heuristic_tree_decomposition(g);\n    g.clear();\n    toNice(t,0);\n    //cerr << t.sz << endl;\n\n    ll res = 0;\n    memo.clear();\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      res += dp(0,use,n,t);\n      res %= mod;\n    }\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntypedef vector< pair<vi,vi> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\nset<ll> is_edge;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(vector<vi> &g){\n  int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  set<ll> tmp_edge = is_edge;\n  rep(i,n){\n    deg[i] = g[i].sz; deg[i]*=-1;\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vi unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tint aa = a, bb = b;\n\tif(aa>bb)swap(aa,bb);\n\tif(aa!=bb && !tmp_edge.count(aa*mod + bb)){\n\t  g[aa].pb(bb);\n\t  g[bb].pb(aa);\n\t  tmp_edge.insert(aa*mod + bb);\n\t  deg[aa]--; deg[bb]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, int id){\n  stack<int> s;\n  s.push(id);\n\n  while(s.sz){\n    id = s.top(); s.pop();\n    \n    //for join\n    while(t[id].first.size()>2){\n      vi child(2);\n      child[0] = t[id].first.back(); t[id].first.pop_back();\n      child[1] = t[id].first.back(); t[id].first.pop_back();\n      t.push_back(make_pair(child, t[id].second));\n      t[id].first.push_back(t.size()-1);\n    }\n\n    if(t[id].first.size()==2){\n      rep(i,2){\n\tconst int &j = t[id].first[i];\n\tif(t[id].second != t[j].second){\n\t  vi child(1);\n\t  child[0] = j;\n\t  t.push_back(make_pair(child, t[id].second));\n\t  t[id].first[i] = t.size()-1;\n\t}\n      }\n    }\n\n    //for introduce & forget\n    if(t[id].first.size()==1){\n      const int &j = t[id].first[0];\n      vi child(1);\n      child[0] = j;\n      \n      vi disA, disB;\n      rep(a,t[id].second.size()){\n\tbool f = true;\n\trep(b,t[j].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disA.push_back(a);\n      }\n      rep(b,t[j].second.size()){\n\tbool f = true;\n\trep(a,t[id].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disB.push_back(b);\n      }\n      \n      if(disA.size() + disB.size() > 1){\n\tif(disA.size()>0){\n\t  vi tmp = t[id].second;\n\t  tmp.erase(tmp.begin() + disA[0]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}else{\n\t  vi tmp = t[id].second;\n\t  tmp.push_back(t[j].second[disB[0]]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}      \n      }\n    }\n    \n    //for leaf\n    if(t[id].first.size() == 0){\n      if(t[id].second.size() > 1){\n\tvi tmp;\n\trep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n\tt.push_back(make_pair(vi(), tmp));\n\tt[id].first.push_back(t.size()-1);\n      }\n    }\n\n    rep(i,t[id].first.size()){\n      s.push(t[id].first[i]);\n    }\n  }\n}\n\nunordered_map<int,int> memo;\n\ninline int dp(int id, int use, const TD &t){\n  int key = 100*id + use;\n\n  stack<int> s;\n  s.push(key);\n\n  while(s.sz){\n    ll res = 0;\n    key = s.top(); s.pop();\n    id = key/100; use = key%100;\n    const vi& child = t[id].fs, bag = t[id].sc;\n    \n    //for leaf\n    if(child.sz==0){\n      memo[key] = use;\n      goto END;\n    }\n    \n    if(child.sz==1){\n      const vi &nbag = t[child[0]].second;\n      vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n      rep(i,bag.size())rep(j,nbag.size()){\n\tif(bag[i] == nbag[j]){\n\t  to_bag[j] = i; to_nbag[i] = j;\n\t}\n      }\n      \n      //for introduce\n      if(nbag.sz < bag.sz){\n\tint nuse = 0;\n\trep(i,bag.sz){\n\t  if(to_nbag[i]<0){\n\t    if( ((use>>i)&1) == 0 ){\n\t      memo[key] = 0;\n\t      goto END;\n\t    }\n\t  }else{\n\t    if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t  }\n\t}\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  memo[key] = memo[nxt];\n\t  goto END;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n      }\n      \n      //for forget\n      if(nbag.sz > bag.sz){\n\tint add = -1,  nuse = 0;\n\trep(i,nbag.sz){\n\t  if(to_bag[i]<0)add = i;\n\t  else if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n\t}\n\t\n\tll res = 0;\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  (res += memo[nxt]) %= mod;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n\n\trep(i,bag.sz){\n\t  if((use>>i)&1)continue;\n\t  \n\t  int a = bag[i], b = nbag[add];\n\t  if(a>b)swap(a,b);\n\t  if(is_edge.count(a*mod + b)){\n\t    nxt = child[0]*100 + (nuse | (1<<add) | (1<<to_nbag[i]));\n\t    if(memo.count(nxt)){\n\t      (res += memo[nxt]) %= mod;\n\t    }else{\n\t      s.push(key); s.push(nxt);\n\t      goto END;\n\t    }\n\t  }\n\t}\n\tmemo[key] = res;\n      }\n    }\n    \n    //for join\n    if(child.sz==2){\n      int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n      do{\n\tint nxt1 = child[0]*100 + (use|sub), nxt2 = child[1]*100 + (use|(unuse-sub));\n\tif(memo.count(nxt1) == 0){\n\t  s.push(key); s.push(nxt1);\n\t  goto END;\n\t}\n\tif(memo.count(nxt2) == 0){\n\t  s.push(key); s.push(nxt2);\n\t  goto END;\n\t}\n\tif(memo.count(nxt1) && memo.count(nxt2)){\n\t  res += (ll)memo[nxt1] * memo[nxt2];\n\t  res %= mod;\n\t}\n\tsub = (sub-1)&unuse;\n      }while(sub != unuse);\n    \n      memo[key] = res;\n    }\n  END:;\n  }\n  return memo[key];\n}\n\nvoid visg(vector<vi> g){\n  int n = g.size();\n  cout << \"graph {\" << endl;\n  rep(i,n){\n    rep(k,g[i].sz){\n      if(i<g[i][k]){\n\tcout << \"  \\\"\" << i << \" \";\n\tcout << \"\\\" -- \\\"\" << g[i][k] << \" \";\n\tcout << \"\\\"\" << endl;\n      }\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nvoid vis(TD t){\n  int n = t.size();\n  cout << \"digraph {\" << endl;\n  rep(i,n){\n    rep(k,t[i].first.size()){\n      int nxt = t[i].first[k];\n      cout << \"  \\\"\" << i << \": \";\n      rep(j,t[i].second.size())cout << t[i].second[j] << \" \";\n      cout << \"\\\" -> \\\"\" << nxt << \": \";\n      rep(j,t[nxt].second.size())cout << t[nxt].second[j] << \" \";\n      cout << \"\\\"\" << endl;\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nint main(){\n  int n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    vector<vi> g(n);\n    is_edge.clear();\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*mod + b);\n      else is_edge.insert(b*mod + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*mod + b);\n      else is_edge.insert(b*mod + a);\n    }\n\n    //visg(g);\n    TD t = heuristic_tree_decomposition(g);\n    g.clear();\n    //cout << t.size() << endl;\n    //vis(t);\n    toNice(t,0);\n    //cerr << t.size() << endl;\n    //vis(t);\n\n    ll res = 0;\n    memo.clear();\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      res += dp(0,use,t);\n      res %= mod;\n    }\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\n\nconst int MOD=1000003;\nint N,M;\nvector<vector<int> > L;\nint ans=0;\nmap<pair<int,int> ,int> memo;\n\nint calc(int start,int end){\n\tif(memo.count(make_pair(start,end))) return memo[make_pair(start,end)];\n//\tcout<<start<<\" \"<<end<<endl;\n\tif((end-start)%2==0){\n\t\t//cout<<\"end \"<<start<<\" \"<<end<<\" :\"<<0<<endl; \n\t\treturn 0;\n\t}\n\tif(end-start==1){\n\t\t//cout<<\"end \"<<start<<\" \"<<end<<\" :\"<<1<<endl;\n\t\treturn 1;\n\t}\n\tint res=0;\n\n\tfor(int i=0;i<L[start].size();i++){\n\t\tif(start<=L[start][i] && L[start][i]<=end){\n\t\t\tint ans1=1,ans2=1;\n\t\t\tans1=calc(start+1,L[start][i]-1)%MOD;\n\t\t\tif(L[start][i]+1<end)\n\t\t\t\tans2=calc(L[start][i]+1,end)%MOD;\n\t\t\tres+=(ans1*ans2)%MOD;\n\t\t\tres%=MOD;\n\t\t}\n\t}\n\tres+=1*calc(start+2,end)%MOD;\n\tres%=MOD;\n\tif(start==0 && end==N-1){\n\t\tres+=1*calc(start+1,end-1);\n\t\tres%=MOD;\n\t}\n//\tcout<<\"end \"<<start<<\" \"<<end<<\" :\"<<res<<endl;\n\tmemo[make_pair(start,end)]=res%MOD;\n\treturn res%MOD;\n}\n\nint main()\n{\n\twhile(cin>>N>>M && N!=0){\n\t\tmemo.clear();\n\t\tL.clear();\n\t\tL.resize(N,vector<int>());\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint in,out;cin>>in>>out;\n\t\t\tin--;out--;\n\t\t\tL[in].push_back(out);\n\t\t\tL[out].push_back(in);\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tsort(L[i].begin(),L[i].end());\n\t\t\tL[i].erase(unique(L[i].begin(),L[i].end()),L[i].end());\n\t\t}\n\t\tans=0;\n\t\tcout<<calc(0,N-1)<<endl;\n//\t\tcout<<\"////////////////\\n\";\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntypedef vector< pair<vi,vi> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\nset<ll> is_edge;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(vector<vi> g){\n  int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  set<ll> tmp_edge = is_edge;\n  rep(i,n){\n    deg[i] = -accumulate(all(g[i]),0);\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vi unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tif(a!=b && !tmp_edge.count(a*mod + b)){\n\t  g[a].pb(b);\n\t  g[b].pb(a);\n\t  tmp_edge.insert(a*mod + b);\n\t  tmp_edge.insert(b*mod + a);\n\t  deg[a]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, const int &id){\n  //for join\n  while(t[id].first.size()>2){\n    vi child(2);\n    child[0] = t[id].first.back(); t[id].first.pop_back();\n    child[1] = t[id].first.back(); t[id].first.pop_back();\n    t.push_back(make_pair(child, t[id].second));\n    t[id].first.push_back(t.size()-1);\n  }\n\n  if(t[id].first.size()==2){\n    rep(i,2){\n      const int &j = t[id].first[i];\n      if(t[id].second != t[j].second){\n\tvi child(1);\n\tchild[0] = j;\n\tt.push_back(make_pair(child, t[id].second));\n\tt[id].first[i] = t.size()-1;\n      }\n    }\n  }\n\n  //for introduce & forget\n  if(t[id].first.size()==1){\n    const int &j = t[id].first[0];\n    vi child(1);\n    child[0] = j;\n\n    vi disA, disB;\n    rep(a,t[id].second.size()){\n      bool f = true;\n      rep(b,t[j].second.size()){\n\tif(t[id].second[a] == t[j].second[b])f = false;\n      }\n      if(f)disA.push_back(a);\n    }\n    rep(b,t[j].second.size()){\n      bool f = true;\n      rep(a,t[id].second.size()){\n\tif(t[id].second[a] == t[j].second[b])f = false;\n      }\n      if(f)disB.push_back(b);\n    }\n\n    if(disA.size() + disB.size() > 1){\n      if(disA.size()>0){\n\tvi tmp = t[id].second;\n\ttmp.erase(tmp.begin() + disA[0]);\n\tt.push_back(make_pair(child, tmp));\n\tt[id].first[0] = t.size()-1;\n      }else{\n\tvi tmp = t[id].second;\n\ttmp.push_back(t[j].second[disB[0]]);\n\tt.push_back(make_pair(child, tmp));\n\tt[id].first[0] = t.size()-1;\n      }      \n    }\n  }\n\n  //for leaf\n  if(t[id].first.size() == 0){\n    if(t[id].second.size() > 1){\n      vi tmp;\n      rep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n      t.push_back(make_pair(vi(), tmp));\n      t[id].first.push_back(t.size()-1);\n    }\n  }\n\n  rep(i,t[id].first.size())toNice(t, t[id].first[i]);\n}\n\nunordered_map<ll,ll> memo;\n\nll rec(int id, int use, const TD &t){\n  ll key = mod*id + use;\n  if(memo.count(key))return memo[key];\n\n  const vi& child = t[id].fs, bag = t[id].sc;\n  \n  //for leaf\n  if(child.sz==0)return use;\n\n  ll res = 0;\n  if(child.sz==1){\n    const vi &nbag = t[child[0]].second;\n    vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n    rep(i,bag.size())rep(j,nbag.size()){\n      if(bag[i] == nbag[j]){\n\tto_bag[j] = i; to_nbag[i] = j;\n      }\n    }\n\n    //for introduce\n    if(nbag.sz < bag.sz){\n      int nuse = 0;\n      rep(i,bag.sz){\n\tif(to_nbag[i]<0){\n\t  if( ((use>>i)&1) == 0 )return memo[key] = 0;\n\t}else{\n\t  if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t}\n      }\n      return memo[key] = rec(child[0],nuse,t);\n    }\n\n    //for forget\n    if(nbag.sz > bag.sz){\n      int add = -1,  nuse = 0;\n      rep(i,nbag.sz){\n\tif(to_bag[i]<0)add = i;\n\telse if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n      }\n\n      ll res = 0;\n      (res += rec(child[0],nuse,t)) %= mod;\n\n      rep(i,bag.sz){\n\tif((use>>i)&1)continue;\n\n\tif(is_edge.count(bag[i]*mod + nbag[add])){\n\t  res += rec(child[0], nuse | (1<<add) | (1<<to_nbag[i]), t);\n\t  res %= mod;\n\t}\n      }\n      return memo[key] = res;\n    }\n  }\n\n  //for join\n  if(child.sz==2){\n    int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n    do{\n      res += rec(child[0],use|sub,t) * rec(child[1],use|(unuse-sub),t);\n      res %= mod;\n      sub = (sub-1)&unuse;\n    }while(sub != unuse);\n  }\n  return memo[key] = res % mod;\n}\n\nvoid vis(TD t){\n  int n = t.size();\n  cout << \"digraph {\" << endl;\n  rep(i,n){\n    rep(k,t[i].first.size()){\n      int nxt = t[i].first[k];\n      cout << \"  \\\"\" << i << \": \";\n      rep(j,t[i].second.size())cout << t[i].second[j] << \" \";\n      cout << \"\\\" -> \\\"\" << nxt << \": \";\n      rep(j,t[nxt].second.size())cout << t[nxt].second[j] << \" \";\n      cout << \"\\\"\" << endl;\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nint main(){\n  int n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    vector<vi> g(n);\n    is_edge.clear();\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      is_edge.insert(a*mod + b);\n      is_edge.insert(b*mod + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      is_edge.insert(a*mod + b);\n      is_edge.insert(b*mod + a);\n    }\n\n    TD t = heuristic_tree_decomposition(g);\n    toNice(t,0);\n    //vis(t);\n\n    ll res = 0;\n    memo.clear();\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      res += rec(0,use,t);\n      res %= mod;\n    }\n    cout << res << endl;    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#define _CRT_SECURE_NO_WARNINGS\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n#endif\n\n\nusing namespace std;\n#define REP(i,n) for(int i=0; i<(n); i++)\n#define FOR(i,a,b) for(int i=(a); i<(b); i++)\n#define FORR(i,a,b) for(int i=(b)-1; i>=(a); i--)\n\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\n\ntemplate<typename T>\nvoid fillall(T& arr, const T& value) {\n\tarr = value;\n}\ntemplate<typename T, typename ARR>\nvoid fillall(ARR& arr, const T& value) {\n\tfor (auto& i : arr) fillall(i, value);\n}\n\n#define MOD 1000003\n\nint n, m;\npii es[52525];\nint deg[52525];\n\nvi g[52525];\n\nconst int M = 65536;\nunordered_map<int, int> memo;\nll f(int l, int r) {\n\t//if(l+1==r)return 0;\n\twhile (!(l + 2 >= r) && g[l].empty()) {\n\t\tl += 2;\n\t}\n\twhile (!(l + 2 >= r) && g[r-1].empty()) {\n\t\tr -= 2;\n\t}\n\tif (l + 2 >= r)return 1;\n\tif (memo.count(l * M + r))return memo[l * M + r];\n\tll ans = 0;\n\tauto gbeg = std::upper_bound(g[l].begin(), g[l].end(), l);\n\tauto gend = std::lower_bound(g[l].begin(), g[l].end(), r);\n\n\t//if (gend - gbeg >= 1) {\n\t//\tint lst = gend[-1];\n\t//\tif (gend[-1] == r - 1) {\n\t//\t\tans += f(l+1, r - 1);\n\t//\t\tans %= MOD;\n\t//\t\tif (gend - gbeg >= 2) {\n\t//\t\t\tans += (f(l, gend[-2] + 1) * f(gend[-2] + 1, r)) % MOD;\n\t//\t\t\tans %= MOD;\n\t//\t\t}\n\t//\t\telse {\n\t//\t\t\tans += f(l + 2, r);\n\t//\t\t\tans %= MOD;\n\t//\t\t}\n\t//\t}\n\t//\telse {\n\t//\t\tans += (f(l, lst + 1) * f(lst + 1, r)) % MOD;\n\t//\t\tans %= MOD;\n\t//\t}\n\t//}\n\t//else {\n\t//\tans += f(l + 2, r);\n\t//\tans %= MOD;\n\t//}\n\tans += f(l + 2, r);\n\tif (gend - gbeg >= 2) {\n\t\tint fst = gbeg[0];\n\t\tint lst = gend[-1];\n\t\tll bef = f(l + 1, fst);\n\t\tll aft = f(lst + 1, r);    // O(f(r-lst))\n\t\t// printf(\"bef=%lld, aft=%lld\\n\",bef,aft);\n\t\t// f(l+1, *)\n\t\t// f(*, lst)\n\t\tFOR(i, 0, (gend - gbeg)) {\n\t\t\tint to = gbeg[i];\n\t\t\tans += bef * f(fst, to) * f(to + 1, lst + 1) % MOD * aft % MOD;\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\telse if ((gend - gbeg) == 1) {\n\t\t// int to = gg.back();\n\t\t//for (int to : gg) {\n\t\t//}\n\t\tint to = gbeg[0];\n\t\tans += f(l + 1, to) * f(to + 1, r);\n\t\tans %= MOD;\n\t}\n\telse {\n\t\t// do nothing\n\t}\n\t// printf(\"[%d, %d) -> %lld\\n\",l,r,ans);\n\t//return ans;\n\treturn memo[l * M + r] = ans;\n}\nll solve(int n) {\n\tmemo.clear();\n\treturn f(0, n);\n}\n\nint main() {\n\tint ccc = 1;\n\twhile (true) {\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif (n + m == 0)break;\n\t\tfill(deg, deg + n, 0);\n\t\tREP(i, m) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\t--a; --b;\n\t\t\tes[i] = pii(a, b);\n\t\t\tdeg[a]++; deg[b]++;\n\t\t}\n\t\tif (n % 2 == 1) {\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tint id = -1;\n\t\tREP(i, n)if (deg[i] == 0) {\n\t\t\tid = i;\n\t\t\t// cerr << id << endl;\n\t\t\tbreak;\n\t\t}\n\t\t// id - (id+1)\n\t\t// (id+2) -> 0\n\t\tREP(i, n)g[i].clear();\n\t\tREP(i, m) {\n\t\t\tint a = es[i].first, b = es[i].second;\n\t\t\tif (a == id || b == id)continue;\n\t\t\tif (a == id + 1 || b == id + 1)continue;\n\t\t\ta = (a - (id + 2) + n + n) % n;\n\t\t\tb = (b - (id + 2) + n + n) % n;\n\t\t\tif (a % 2 == b % 2)continue;\n\t\t\t//if (a > b)swap(a, b);\n\t\t\tg[b].push_back(a);\n\t\t\tg[a].push_back(b);\n\t\t}\n\t\tREP(i, n)sort(g[i].begin(), g[i].end());\n\t\tll ans = solve(n - 2);\n\t\t// cerr << \"first : \" << ans << endl;\n\t\t// (id-1) - id\n\t\t// (id+1) -> 0\n\t\tREP(i, n)g[i].clear();\n\t\tREP(i, m) {\n\t\t\tint a = es[i].first, b = es[i].second;\n\t\t\tif (a == id || b == id)continue;\n\t\t\tif (a == id - 1 || b == id - 1)continue;\n\t\t\ta = (a - (id + 1) + n + n) % n;\n\t\t\tb = (b - (id + 1) + n + n) % n;\n\t\t\tif (a % 2 == b % 2)continue;\n\t\t\t//if (a > b)swap(a, b);\n\t\t\tg[b].push_back(a);\n\t\t\tg[a].push_back(b);\n\t\t}\n\t\tREP(i, n)sort(g[i].begin(), g[i].end());\n\t\tint x = solve(n - 2);\n\t\tans += x;\n\t\t// cerr << \"second : \" << x << endl;\n\t\tans %= MOD;\n\t\tprintf(\"%lld\\n\", ans);\n\t\t// fprintf(stderr, \"%d/141: %lld\\n\",ccc++,ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n \n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <cassert>\n#include <unistd.h>\n#include <cstdio>\n#include <cstdlib>\n#include <stack>\n#include <random>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, ll> P;\ntypedef tuple<int, int, int> T;\nconst int MN = 50500; \nconst int MD = 1000003;\n\nint n, m;\nvector<P> g[MN];\nvector<P> edge;\n\nll calc(int l, int r) {\n    ll res = 1;\n    while (l <= r) {\n        P p = g[l][g[l].size()-1];\n        l = p.first+1;\n        res *= p.second; res %= MD;\n    }\n    return res;\n}\nint solve() {\n    if (n % 2) return 0;\n    for (int i = 0; i < n; i++) {\n        g[i].clear();\n    }\n    edge.clear();\n    for (int i = 0; i < n-1; i++) {\n        g[i].push_back(P(i+1, 1));\n    }\n    vector<T> buf;\n    buf.push_back(T(n-1, 0, n-1));\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        if (a > b) swap(a, b);\n        if ((b-a) % 2 == 0) continue;\n        buf.push_back(T(b-a, a, b));\n    }\n    sort(buf.begin(), buf.end());\n    for (T t: buf) {\n        int a, b, c;\n        tie(c, a, b) = t;\n        edge.push_back(P(a, b));\n    }\n    for (P p: edge) {\n        int a, b;\n        tie(a, b) = p;\n        ll res = calc(a, b) + calc(a+1, b-1);\n        res %= MD;\n        g[a].push_back(P(b, res));\n    }\n    return g[0][g[0].size()-1].second;\n}\n\nint main() {\n    while (true) {\n        cin >> n >> m;\n        if (!n) break;\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> T;\n\nconst int MN = 50500; \nconst int MD = 1000003;\n\nint n, m;\nP g[MN];\nint calc(int l, int r) {\n    ll res = 1;\n    while (l < r) {\n        res *= g[l].second; res %= MD;\n        l = g[l].first;\n    }\n    return res;\n}\nT e[MN];\nint solve() {\n    if (n % 2) return 0;\n    for (int i = 0; i < n-1; i++) {\n        g[i] = P(i+2, 1);\n    }\n    e[0] = T(n-1, P(0, n));\n    int ec = 1;\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        if (a > b) swap(a, b); a--;\n        if ((b-a) % 2) continue;\n        e[ec] = T(b-a, P(a, b));\n        ec++;\n    }\n    sort(e, e+ec);\n    for (int i = 0; i < ec; i++) {\n        int a, b;\n        tie(a, b) = e[i].second;\n        g[a+1] = P(b-1, calc(a+1, b-1));\n        g[a] = P(b, (calc(a, b) + g[a+1].second) % MD);\n    }\n    return g[0].second;\n}\n\nint main() {\n    while (true) {\n        scanf(\"%d %d\", &n, &m);\n        if (!n) break;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint mod=1000003;\nstruct wolf{\n    int l,r;\n    wolf(){}\n    wolf(int a,int b){\n        l=a;r=b;\n    }\n};\ninline bool operator<(const wolf&a,const wolf&b){\n    if(a.l!=b.l)return a.l<b.l;\n    return a.r>b.r;\n}\nwolf p[51000];\nint in[51000];\nint next[51000];\nint dp[51000][2][2];\nint solve(int a,int b,int c){\n    if(~dp[a][b][c])return dp[a][b][c];\n    if(in[a]==-1){\n        int ret=0;\n        if((p[a].r-p[a].l+b+c)%2==0)return dp[a][b][c]=0;\n        if(b==0&&c==0)return dp[a][b][c]=2;\n        return dp[a][b][c]=1;\n    }\n    long long ret=0;\n    long long te=0;\n    long long to=0;\n    int at;\n    if(b==0&&c==0&&(p[a].r-p[a].l)%2){\n        to=1;\n        at=p[a].l;\n        for(int i=in[a];~i;i=next[i]){\n            if(p[i].l>=p[a].r)break;\n            long long tte;\n            long long tto;\n            if((p[i].l-at)%2){\n                tte=te*solve(i,1,1)+to*solve(i,0,1);\n                tto=te*solve(i,1,0)+to*solve(i,0,0);\n            }else{\n                tte=te*solve(i,0,1)+to*solve(i,1,1);\n                tto=te*solve(i,0,0)+to*solve(i,1,0);\n            }\n            te=tte%mod;\n            to=tto%mod;\n            at=p[i].r;\n        }\n        if((p[a].r-at)%2==0)ret=te;\n        else ret=to;\n    }\n    te=to=0;\n    if(b)to=1;\n    else te=1;\n    at=p[a].l;\n    for(int i=in[a];~i;i=next[i]){\n        if(p[i].l>=p[a].r)break;\n        long long tte;\n        long long tto;\n        if((p[i].l-at)%2){\n            tte=te*solve(i,1,1)+to*solve(i,0,1);\n            tto=te*solve(i,1,0)+to*solve(i,0,0);\n        }else{\n            tte=te*solve(i,0,1)+to*solve(i,1,1);\n            tto=te*solve(i,0,0)+to*solve(i,1,0);\n        }\n        te=tte%mod;\n        to=tto%mod;\n        at=p[i].r;\n    }\n    if((p[a].r-at)%2==!c)ret=(ret+te)%mod;\n    else ret=(ret+to)%mod;\n    //printf(\"%d %d %d: %d\\n\",a,b,c,ret);\n    return dp[a][b][c]=ret;\n}\nint main(){\n    int a,b;\n    while(scanf(\"%d%d\",&a,&b),a){\n        for(int i=0;i<b;i++){\n            int s,t;scanf(\"%d%d\",&s,&t);\n            s--;t--;\n            p[i]=wolf(min(s,t),max(s,t));\n        }\n        p[b++]=wolf(0,a-1);\n        if(a%2){\n            printf(\"0\\n\");continue;\n        }\n        std::sort(p,p+b);\n        for(int i=0;i<b;i++){\n            int nx=lower_bound(p,p+b,wolf(p[i].r,99999999))-p;\n            if(nx>=b)next[i]=-1;\n            else next[i]=nx;\n            int ni=upper_bound(p,p+b,wolf(p[i].l,p[i].r))-p;\n            if(ni>=b||p[ni].l>=p[i].r)in[i]=-1;\n            else in[i]=ni;\n        }\n    //  for(int i=0;i<b;i++)printf(\"%d %d\\n\",in[i],next[i]);\n        for(int i=0;i<b;i++)for(int j=0;j<2;j++)for(int k=0;k<2;k++)dp[i][j][k]=-1;\n        printf(\"%d\\n\",solve(0,0,0));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n \n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <cassert>\n#include <unistd.h>\n#include <cstdio>\n#include <cstdlib>\n#include <stack>\n#include <random>\nusing namespace std;\ntypedef long long ll;\n\nconst int MN = 50500; \nconst int MD = 1000003;\n\nint n, m;\nvector<int> g[MN];\n\n\nll calc(int l, int r) {\n    if (l-1 == r) return 1;\n    int res = 0;\n    for (int d: g[l]) {\n        if (d <= l || r < d) continue;\n        res += calc(l+1, d-1)*calc(d+1, r);\n        res %= MD;\n    }\n    return res;\n}\n\nint solve() {\n    for (int i = 0; i < n; i++) {\n        g[i].clear();\n    }\n    for (int i = 0; i < n-1; i++) {\n        g[i].push_back(i+1);\n        g[i+1].push_back(i);\n    }\n    g[n-1].push_back(0);\n    g[0].push_back(n-1);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        assert(a != b);\n        if (a > b) swap(a, b);\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    return calc(0, n-1);\n}\n\nint main() {\n    while (true) {\n        cin >> n >> m;\n        if (!n) break;\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nmultimap<int, int> road;\nint n,m;\n\nint solve(int start, int end, int now){\n\tint i,j,sum=0,f=0;\n\t\n\tfor(i=start;i<end;i++) if(road.count(i)!=1) f=1;\n\tif(!f) return 1;\n\t\n\tmultimap<int, int>::iterator it = road.find(start);\n\tfor(;it!=road.end()&&it->first==start;it++){\n\t\tint ret=1;\n//\t\tfor(j=now;j--;)printf(\" \");\n//\t\tprintf(\"set %d %d\\n\", start, it->second);\n\t\tif(start+1!=it->second) ret*=solve(start+1, it->second-1, now+1)%1000003;\n\t\tif(it->second!=end) ret*=solve(it->second+1, end, now+1)%1000003;\n\t\tsum+=ret%1000003;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tint i,j,a,b;\n\twhile(cin>>n>>m,n){\n\t\troad.clear();\n\t\tfor(i=1;i<n;i++){\n\t\t\troad.insert( pair<int, int>( i, i+1 ) );\n\t\t}\troad.insert( pair<int, int>( 1, n ) );\n\t\tfor(i=1;i<=m;i++){\n\t\t\tcin>>a>>b;\n\t\t\tif(!((a+b)%2)) continue;\n\t\t\troad.insert( pair<int, int>( a, b ) );\n\t\t}\n\t\tif(n%2) cout<<\"0\"<<endl;\n\t\telse cout<<solve(1,n,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\n\nmap<unsigned int, int> match;\nset<unsigned int> road;\n\n//flag : whether road between left and right is available\nint countMatching(unsigned int left, unsigned int right, bool flag = true){\n  //cout << \"call \"<< (flag ? \"t \" : \"f \") << left << \" \" << right << endl;\n  if(right - left == 1 || right - left == -1){\n    return 1;\n  }\n  //memo check\n  if(match.find((left << 16) + right) != match.end()){\n    return match[(left << 16) + right];\n  }\n  \n  long long result = -1;\n  //Get leftest road\n  set<unsigned int>::iterator froad = road.lower_bound((left + 1 << 16) - right + !flag);\n  //There is no inner road in the segment.\n  if(froad == road.end() || *froad >> 16 >= right ){\n    result = 1;\n  }else{\n    unsigned int nleft = *froad >> 16, nright = 0x10000 - *froad & 0xFFFF;\n    if((left & 1) == (nleft & 1)){\n      if(match.find((nleft << 16) + nright) != match.end()){\n        result = match[(nleft << 16) + nright];\n      }else{\n        result = countMatching(nleft + 1, nright - 1) + countMatching(nleft, nright, false);\n      }\n      result *= countMatching(nright + 1, right);\n    } else {\n      result = countMatching(nleft + 1, nright - 1);\n      result *= countMatching(nright, right);\n    }\n    result %= 1000003;\n  }\n  if(flag){\n    match[(left << 16) + right] = result;\n  }\n  //cout << (flag ? \"t \" : \"f \") << left << \" \" << right << \" : \" << result << endl; \n  return result;\n}\n\nint main(){\n  int N, M;\n  while(true){\n    cin >> N >> M;\n    //end of cases\n    if(N == 0 && M == 0){\n      break;\n    }\n    match.clear();\n    road.clear();\n    for(int i = 0; i < M; i++){\n      int start, end;\n      cin >> start >> end;\n      //Start and End should be between 0 and N-1\n      start--; end--;\n      //Skip roads which has odd number of nodes between its Start and End.\n      if((start - end) % 2 == 0){\n        continue;\n      }\n      if(start < end){\n        road.insert(((start + 1) << 16) - end);\n      }else{\n        road.insert(((end + 1) << 16) - start);\n      }\n    }\n    if(N & 1){\n      cout << 0 << endl;\n      continue;\n    }\n    if(road.size() == 0){\n      cout << 2 << endl;\n      continue;\n    }\n    int result = countMatching(0, N-1) + countMatching(1, N-2);\n    cout << result % 1000003 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\n\nconst int MOD=1000003;\nint N,M;\nvector<vector<int> > L;\nint ans=0;\nmap<pair<int,int> ,int> memo;\n\n\nlong long calc(int start,int end){\n//\tcout<<\"do \"<<start<<\" \"<<end<<endl;\n\tif((end-start)%2==0) return 0;\n\tif(start>end) return 1;\n\tif(memo.count(make_pair(start,end))) return memo[make_pair(start,end)];\n\tlong long res=1;\n\n\tint now=start;\n\tif(L[now].size()==0){\n\t\twhile(now<=end && L[now].size()==0) now+=2;\n\t\treturn calc(now,end);\n\t}\n\telse{\n\t\tres=0;\n\t\tfor(int k=0;k<L[now].size();k++){\n\t\t\tlong long ans1=calc(now+1,L[now][k]-1),ans2=1;\n\t\t\tif(L[now][k]+1<end) ans2=calc(L[now][k]+1,end);\n\t\t\tres+=(ans1*ans2)%MOD;\n\t\t\tres%=MOD;\n\t\t}\n\t}\n\tres+=calc(now+2,end);\n\tres%=MOD;\n\tmemo[make_pair(start,end)]=res;\n//\tcout<<\"res \"<<start<<\" \"<<end<<\" :\"<<res<<endl;\n\treturn res%MOD;\n}\n\nint main()\n{\n\twhile(cin>>N>>M && N!=0){\n\t\tmemo.clear();\n\t\tL.clear();\n\t\tL.resize(N,vector<int>());\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint in,out;cin>>in>>out;\n\t\t\tin--;out--;\n\t\t\tif(in<out)\n\t\t\t\tL[in].push_back(out);\n\t\t\telse\n\t\t\t\tL[out].push_back(in);\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tsort(L[i].begin(),L[i].end());\n\t\t\tL[i].erase(unique(L[i].begin(),L[i].end()),L[i].end());\n\t\t}\n\t\tcout<<(calc(0,N-1)+calc(1,N-2))%MOD<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define MOD (1000003LL)\ntypedef long long Int;\n\nint n, mi, memo[60000*4], cs[60000][2];\nvector<int> g[60000];\nbool has[60000];\n\nvoid add(int p, int q) {\n    if (p > q) swap(p, q);\n    g[p].push_back(q);\n}\n\nint pre(int p, int q) {\n    if (p+1 == q) return -1;\n    const int k = mi++;\n    has[k] = false;\n    if (g[p].back() == q) {\n        has[k] = true;\n        g[p].pop_back();\n    }\n    const int r = g[p].back();\n    rep (b, 4) memo[k*4|b] = -1;\n    cs[k][0] = pre(p, r);\n    cs[k][1] = pre(r, q);\n    return k;\n}\n\nint rec(int k, int x, int y) {\n    if (k == -1) return x == y;\n    const int sig = k*4|x*2|y;\n    if (memo[sig] != -1) return memo[sig];\n    const int p = cs[k][0], q = cs[k][1];\n    Int ans = 0;\n    rep (i, 2) ans = (ans + (Int)rec(p, x, i)*rec(q, 1-i, y)) % MOD;\n    if (x && y && has[k]) {\n        rep (i, 2) ans = (ans + (Int)rec(p, 0, i)*rec(q, 1-i, 0)) % MOD;\n    }\n    return memo[sig] = ans;\n}\n\nint main() {\n    for (;;) {\n        int m, a, b;\n        scanf(\"%d%d\", &n, &m);\n        if (n == 0) return 0;\n        rep (_, m) {\n            scanf(\"%d%d\", &a, &b);\n            add(a-1, b-1);\n        }\n        rep (i, n) add(i, (i+1)%n);\n        rep (i, n) sort(g[i].begin(), g[i].end());\n        mi = 0;\n        pre(0, n-1);\n        printf(\"%d\\n\", rec(0, 1, 1));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000003\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstruct edge{\n    int dis;\n    int from;\n    int to;\n    bool operator<(const edge& right) const{\n        return dis < right.dis;\n    }\n};\n\nint n, m;\nll x[50000];\nint to[50000];\nvector<edge> e;\n\nvoid func(int st, int en){\n    ll y = 1;\n    int now = st;\n    while(now != (en+1)%n){\n        y = y*x[now]%MOD;\n        now = (to[now]+1)%n;\n    }\n    now = (st+1)%n;\n    ll yy = 1;\n    while(now != en%n){\n        yy = y*x[now]%MOD;\n        now = (to[now]+1)%n;\n    }\n    y = (y+yy)%MOD;\n    \n    x[st] = y;\n    to[st] = en;\n}\n\nll calc(int st, int en){\n    ll ret = 1;\n    int now = st;\n    while(now != (en+1)%n){\n        ret = ret*x[now]%MOD;\n        now = (to[now]+1)%n;\n    }\n    return ret;\n}\n\nint main(){\n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        e.clear();\n        rep(i,n) to[i] = (i+1)%n;\n        rep(i,n) x[i] = 1;\n        \n        rep(i,m){\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            if(a > b) swap(a,b);\n            if((b-a)%2==0) continue;\n            edge tmp;\n            if(b-a <= a+n-b){\n                tmp.dis = b-a;\n                tmp.from = a;\n                tmp.to = b;\n            } else{\n                tmp.dis = a+n-b;\n                tmp.from = b;\n                tmp.to = a;\n            }\n            e.push_back(tmp);\n        }\n       if(n&1){\n            cout << 0 << endl;\n            continue;\n        }\n        if(e.size() == 0){\n            cout << 2 << endl;\n            continue;\n        }\n       \n        sort(e.begin(),e.end());\n        \n        for(int i = 0; i < e.size()-1; i++){\n            edge ee = e[i];\n            func(ee.from,ee.to);\n        }\n        ll ans = 0;\n        edge ee = e[e.size()-1];\n        ll p1 = calc(ee.from,ee.to);\n        ll p2 = calc((ee.to+1)%n,(ee.from-1+n)%n);\n        ll p3 = calc(ee.to,ee.from);\n        ll p4 = calc((ee.from+1)%n,(ee.to-1+n)%n);\n        ans = (ans+p1*p2)%MOD;\n        ans = (ans+p3*p4)%MOD;\n        ans = (ans+p2*p4)%MOD;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\n\nconst int MOD=1000003;\nint N,M;\nvector<vector<int> > L;\nint ans=0;\nmap<pair<int,int> ,int> memo;\n\n\nlong long calc(int start,int end){\n//\tcout<<\"do \"<<start<<\" \"<<end<<endl;\n\tif((end-start)%2==0) return 0;\n\tif(start>end) return 1;\n\tif(memo.count(make_pair(start,end))) return memo[make_pair(start,end)];\n\tlong long res=1;\n\n\tint now=start;\n\tif(L[now].size()==0){\n\t\twhile(now<=end && L[now].size()==0) now+=2;\n\t\treturn calc(now,end);\n\t}\n\n\tfor(int k=0;k<L[now].size();k++){\n\t\tlong long a=1;\n\t\tif(L[now][k]+1<end) a=calc(L[now][k]+1,end);\n\t\tres+=(calc(now+1,L[now][k]-1)*a)%MOD;\n\t\tres%=MOD;\n\t}\n//\tif(now+2<end)\n\t\tres+=calc(now+2,end);\n\tres%=MOD;\n\tmemo[make_pair(start,end)]=res;\n//\tcout<<\"res \"<<start<<\" \"<<end<<\" :\"<<res<<endl;\n\treturn res%MOD;\n}\n\nint main()\n{\n\twhile(cin>>N>>M && N!=0){\n\t\tmemo.clear();\n\t\tL.clear();\n\t\tL.resize(N,vector<int>());\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint in,out;cin>>in>>out;\n\t\t\tin--;out--;\n\t\t\tif(in<out)\n\t\t\t\tL[in].push_back(out);\n\t\t\telse\n\t\t\t\tL[out].push_back(in);\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tsort(L[i].begin(),L[i].end());\n\t\t\tL[i].erase(unique(L[i].begin(),L[i].end()),L[i].end());\n\t\t}\n\t\tcout<<(calc(0,N-1)+calc(1,N-2))%MOD<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nusing int64 = long long;\nconst int mod = 1000003;\n\nconst int64 infll = (1LL << 58) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\n/**\n * @bref Tree-Decomposition(木分解)\n */\nstruct DecompNode {\n  vector< int > bag, child;\n\n  DecompNode() = default;\n};\n\nstruct TreeDecomposition {\n\n  vector< vector< int > > g;\n\n  explicit TreeDecomposition(int V) : g(V) {}\n\n  void add_edge(int a, int b) {\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n\n  vector< DecompNode > build() {\n    const int N = (int) g.size();\n\n    vector< int > used(N, -1), deg(N);\n    queue< int > que;\n    for(int i = 0; i < N; i++) {\n      deg[i] = (int) g[i].size();\n      if(deg[i] <= 2) que.emplace(i);\n    }\n\n    vector< set< int > > exists(N);\n    for(int i = 0; i < N; i++) {\n      for(auto &j : g[i]) {\n        if(i < j) exists[i].emplace(j);\n      }\n    }\n\n    vector< DecompNode > ret;\n    ret.emplace_back();\n    while(!que.empty()) {\n      int idx = que.front();\n      que.pop();\n      if(deg[idx] > 2 || used[idx] != -1) continue;\n\n      DecompNode r;\n      r.bag.emplace_back(idx);\n      int u = -1, v = -1;\n      for(auto &to : g[idx]) {\n        if(used[to] == -1) {\n          (u == -1 ? u : v) = to;\n          r.bag.emplace_back(to);\n        } else if(used[to] >= 0) {\n          r.child.emplace_back(used[to]);\n          used[to] = -2;\n        }\n      }\n\n      if(u == -1) {\n\n      } else if(v == -1) {\n        --deg[u];\n      } else {\n        if(u > v) swap(u, v);\n        if(!exists[u].count(v)) {\n          g[u].emplace_back(v);\n          g[v].emplace_back(u);\n          exists[u].emplace(v);\n        } else {\n          --deg[u];\n          --deg[v];\n        }\n      }\n\n      for(auto &to : g[idx]) {\n        if(deg[to] <= 2) que.emplace(to);\n      }\n\n      used[idx] = (int) ret.size();\n      deg[idx] = 0;\n      ret.emplace_back(r);\n    }\n    for(int i = 0; i < N; i++) {\n      if(deg[i] > 0) return {};\n    }\n    ret.front() = ret.back();\n    ret.pop_back();\n    return ret;\n  }\n};\n\n\nvoid to_nice(vector< DecompNode > &g, int root = 0) {\n\n  for(auto &p : g) {\n    sort(p.bag.begin(), p.bag.end());\n  }\n\n  stack< int > st;\n  st.emplace(root);\n\n  while(!st.empty()) {\n    int idx = st.top();\n    st.pop();\n\n    // join\n    while(g[idx].child.size() > 2) {\n      DecompNode r;\n      r.child.resize(2);\n      r.child[0] = g[idx].child.back();\n      g[idx].child.pop_back();\n      r.child[1] = g[idx].child.back();\n      g[idx].child.pop_back();\n      r.bag = g[idx].bag;\n      g[idx].child.emplace_back((int) g.size());\n      g.emplace_back(r);\n    }\n\n    if(g[idx].child.size() == 2) {\n      for(auto &ch : g[idx].child) {\n        if(g[ch].bag != g[idx].bag) {\n          DecompNode r;\n          r.child = {ch};\n          r.bag = g[idx].bag;\n          ch = (int) g.size();\n          g.emplace_back(r);\n        }\n      }\n    }\n\n    // introduce / forget\n    if(g[idx].child.size() == 1) {\n      int &ch = g[idx].child[0];\n\n      vector< int > latte, malta;\n      set_difference(g[idx].bag.begin(), g[idx].bag.end(),\n                     g[ch].bag.begin(), g[ch].bag.end(),\n                     back_inserter(latte));\n      set_difference(g[ch].bag.begin(), g[ch].bag.end(),\n                     g[idx].bag.begin(), g[idx].bag.end(),\n                     back_inserter(malta));\n      if(latte.size() + malta.size() > 1) {\n        DecompNode r;\n        r.child = {ch};\n        r.bag = g[idx].bag;\n        if(!latte.empty()) {\n          r.bag.erase(find(r.bag.begin(), r.bag.end(), latte.back()));\n        } else {\n          r.bag.emplace_back(malta.back());\n        }\n        ch = (int) g.size();\n        g.emplace_back(r);\n      }\n    }\n\n    // leaf\n    if(g[idx].child.empty()) {\n      if(g[idx].bag.size() > 1) {\n        DecompNode r;\n        r.bag = g[idx].bag;\n        r.bag.pop_back();\n        g[idx].child.emplace_back((int) g.size());\n        g.emplace_back(r);\n      }\n    }\n\n    for(auto &ch : g[idx].child) {\n      st.emplace(ch);\n    }\n  }\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< mod >;\n\nint main() {\n  int N, M;\n  while(cin >> N >> M, N) {\n    TreeDecomposition td(N);\n    set< pair< int, int > > edges;\n    for(int i = 0; i < N; i++) {\n      td.add_edge(i, (i + 1) % N);\n      edges.emplace(minmax(i, (i + 1) % N));\n    }\n    for(int i = 0; i < M; i++) {\n      int a, b;\n      cin >> a >> b;\n      --a, --b;\n      td.add_edge(a, b);\n      edges.emplace(minmax(a, b));\n    }\n\n    if(N % 2) {\n      cout << 0 << endl;\n      continue;\n    }\n\n    auto t = td.build();\n    to_nice(t);\n    vector< vector< modint > > dps(t.size());\n    vector< int > buff(N), buff2(N, -1);\n    MFP([&](auto rec, int idx) -> void {\n\n      auto &ch = t[idx].child;\n      auto &bag = t[idx].bag;\n\n      for(auto &to : ch) rec(to);\n      vector< modint > dp(1 << bag.size());\n\n      if(ch.empty()) { // leaf\n        dp[0] = 1;\n      } else if(ch.size() == 2) { // join\n        for(int i = 0; i < dp.size(); i++) {\n          for(int j = 0; j < dp.size(); j++) {\n            if((i & j) == 0) dp[i | j] += dps[ch[0]][i] * dps[ch[1]][j];\n          }\n        }\n      } else {\n        auto &ch_bag = t[ch[0]].bag;\n        auto &ch_dp = dps[ch[0]];\n\n        for(int i = 0; i < bag.size(); i++) {\n          buff[bag[i]] = 1 << i;\n          buff2[bag[i]] = idx;\n        }\n\n        if(ch_bag.size() + 1 == bag.size()) { // introduce\n          for(int i = 0; i < ch_dp.size(); i++) {\n            int bit = 0;\n            for(int j = 0; j < ch_bag.size(); j++) {\n              if((i >> j) & 1) bit |= buff[ch_bag[j]];\n            }\n            dp[bit] = ch_dp[i];\n          }\n        } else { // forget\n          int v = -1;\n          for(int i = 0; i < ch_bag.size(); i++) {\n            if(buff2[ch_bag[i]] != idx) v = ch_bag[i];\n          }\n          vector< int > ok_match(bag.size());\n          for(int i = 0; i < bag.size(); i++) {\n            ok_match[i] = edges.count(minmax(bag[i], v));\n          }\n\n          for(int i = 0; i < ch_dp.size(); i++) {\n            int bit = 0;\n            bool v_use = false;\n            for(int j = 0; j < ch_bag.size(); j++) {\n              if((i >> j) & 1) {\n                if(v != ch_bag[j]) bit |= buff[ch_bag[j]];\n              } else {\n                if(v == ch_bag[j]) v_use = true;\n              }\n            }\n            if(v_use) {\n              for(int j = 0; j < bag.size(); j++) {\n                if((bit >> j) & 1) continue;\n                if(ok_match[j]) dp[bit | (1 << j)] += ch_dp[i];\n              }\n            } else {\n              dp[bit] += ch_dp[i];\n            }\n          }\n        }\n      }\n      dps[idx].swap(dp);\n    })(0);\n    auto &dp = dps[0];\n    cout << dp.back() << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst int MOD=1000003;\nint x0;\nint n, m;\nint a[50000], b[50000];\nvector<int> g[50001];\nll dp[50001], s[2][50001];\nbool used[50001];\nvoid dfs(int x){\n\tdp[x]=1;\n\ts[0][x]=s[1][x]=1;\n\tfor(auto y:g[x]){\n\t\tdfs(y);\n\t\tdp[x]*=s[(b[x]+1)&1][y];\n\t\tdp[x]%=MOD;\n\t\ts[1][x]*=s[1][y];\n\t\ts[1][x]%=MOD;\n\t\ts[0][x]*=s[0][y];\n\t\ts[0][x]%=MOD;\n\t}\n\ts[b[x]&1][x]+=dp[x];\n\ts[b[x]&1][x]%=MOD;\n}\nll solve(){\n\tif(n&1) return 0;\n\tif(m==0) return 2;\n\tvector<int> ind;\n\tint dmn=n, i0;\n\tfor(int i=0; i<m; i++){\n\t\tint d1=abs(b[i]-a[i]);\n\t\tif(d1%2==0) continue;\n\t\tind.push_back(i);\n\t\tif(dmn>min(d1, n-d1)){\n\t\t\ti0=i;\n\t\t\tdmn=min(d1, n-d1);\n\t\t}\n\t}\n\tif(ind.empty()) return 2;\n\tif(abs(b[i0]-a[i0])<=n/2){\n\t\tx0=(a[i0]+b[i0])/2;\n\t}else{\n\t\tx0=n-(a[i0]+b[i0])/2;\n\t}\n\tvector<int> v[50001];\n\tfor(auto i:ind){\n\t\ta[i]=(a[i]-x0+n)%n, b[i]=(b[i]-x0+n)%n;\n\t\tif(a[i]>b[i]) swap(a[i], b[i]);\n\t\tv[b[i]].push_back(i);\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tsort(v[i].begin(), v[i].end(), [&](int x, int y){ return a[x]>a[y];});\n\t}\n\tvector<int> w;\n\tfor(int i=0; i<n; i++){\n\t\tfor(auto j:v[i]){\n\t\t\twhile(!w.empty()){\n\t\t\t\tint y=w.back();\n\t\t\t\tif(b[y]<=a[j]) break;\n\t\t\t\tg[j].push_back(y);\n\t\t\t\tw.pop_back();\n\t\t\t}\n\t\t\tw.push_back(j);\n\t\t}\n\t}\n\tdfs(i0);\n\tfor(int i=0; i<n; i++) g[i].clear();\n\treturn (s[0][i0]+s[1][i0])%MOD;\n}\n\nint main()\n{\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0) return 0;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcin>>a[i]>>b[i];\n\t\t\ta[i]--; b[i]--;\n\t\t}\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000003\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nmap<ll,int>mem;\nint n,m;\nvector<int>edge[50005],redge[50005];\n\nint rec(int l,int r){\n\twhile(edge[l].empty() && l <= r) l += 2;\n\twhile(redge[r].empty() && l <= r) r -= 2;\n\tif(l > r) return 1;\n\tll ky = 50005 * l + r;\n\tif(mem.find(ky) != mem.end()) return mem[ky];\n\t//use first edge\n\tint ans = 0;\n\t//decreasing order\n\tfor(int i=edge[l].size()-1;i>=0;i--){\n\t\tif(edge[l][i] > r) continue;\n\t\tans += 1LL * rec(l+1,edge[l][i]-1) * rec(edge[l][i]+1,r) % mod;\n\t\tif(ans >= mod) ans -= mod;\n\t}\n\tans += rec(l+2,r);\n\tif(ans >= mod) ans -= mod;\n\treturn mem[ky] = ans;\n}\nint main(){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m); if(n==0 && m==0) return 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tedge[i].clear();\n\t\t\tredge[i].clear();\n\t\t}\n\t\tmem.clear();\n\t\tedge[1].pb(n);\n\t\tredge[n].pb(1);\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\t\tif(a > b) swap(a,b);\n\t\t\tif(a%2 == b%2) continue;\n\t\t\tif(b-a == 1) continue;\n\t\t\tedge[a].pb(b);\n\t\t\tredge[b].pb(a);\n\t\t}\n\t\tif(n%2 == 1) {\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tSORT(edge[i]);\n\t\t\tERASE(edge[i]);\n\t\t\tSORT(redge[i]);\n\t\t\tERASE(redge[i]);\n\t\t\treverse(redge[i].begin(),redge[i].end());\n\t\t}\n\t\tcout << rec(1,n) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\ntypedef long long ll;\ntypedef vector<int> vi;\nconst int MOD = 1000003;\nint n, m;\nvector<vi> g;\n\nvi solve(int l, int r, int gi){\n\tvi res(2, 1);\n\tfor(int i=l;i<r;i++){\n\t\tif(gi < g[i].size()){\n\t\t\tvi ret = solve(i, g[i][gi], gi+1);\n\t\t\tREP(j, 2) res[j] = (ll)res[j]*ret[j]%MOD;\n\t\t\ti = g[i][gi]-1;\n\t\t}\n\t\tswap(res[0], res[1]);\n\t\tgi = 0;\n\t}\n\tswap(res[0], res[1]);\n\tif(r-l > 1) res[1] -= ((res[1] = res[1] + res[0]) >= MOD) ? MOD : 0;\n\treturn res;\n}\n\nint main(){\n\twhile(~scanf(\"%d%d\", &n, &m), n){\n\t\tg = vector<vi>(n);\n\t\tREP(i, m){\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v);u--; v--;\n\t\t\tif(v < u) swap(u, v);\n\t\t\tif(((u^v)&1)) g[u].push_back(v);\n\t\t}\n\t\tREP(i, n) sort(g[i].rbegin(), g[i].rend());\n\t\tprintf(\"%d\\n\", n%2 ? 0 : (int)solve(0, n-1, 0)[1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntypedef vector< pair<vi,vi> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\nset<ll> is_edge;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(vector<vi> g){\n  int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  set<ll> tmp_edge = is_edge;\n  rep(i,n){\n    deg[i] = g[i].sz; deg[i]*=-1;\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vi unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tif(a!=b && !tmp_edge.count(a*mod + b)){\n\t  g[a].pb(b);\n\t  g[b].pb(a);\n\t  tmp_edge.insert(a*mod + b);\n\t  tmp_edge.insert(b*mod + a);\n\t  deg[a]--; deg[b]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, int id){\n  stack<int> s;\n  s.push(id);\n\n  while(s.sz){\n    id = s.top(); s.pop();\n    \n    //for join\n    while(t[id].first.size()>2){\n      vi child(2);\n      child[0] = t[id].first.back(); t[id].first.pop_back();\n      child[1] = t[id].first.back(); t[id].first.pop_back();\n      t.push_back(make_pair(child, t[id].second));\n      t[id].first.push_back(t.size()-1);\n    }\n\n    if(t[id].first.size()==2){\n      rep(i,2){\n\tconst int &j = t[id].first[i];\n\tif(t[id].second != t[j].second){\n\t  vi child(1);\n\t  child[0] = j;\n\t  t.push_back(make_pair(child, t[id].second));\n\t  t[id].first[i] = t.size()-1;\n\t}\n      }\n    }\n\n    //for introduce & forget\n    if(t[id].first.size()==1){\n      const int &j = t[id].first[0];\n      vi child(1);\n      child[0] = j;\n      \n      vi disA, disB;\n      rep(a,t[id].second.size()){\n\tbool f = true;\n\trep(b,t[j].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disA.push_back(a);\n      }\n      rep(b,t[j].second.size()){\n\tbool f = true;\n\trep(a,t[id].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disB.push_back(b);\n      }\n      \n      if(disA.size() + disB.size() > 1){\n\tif(disA.size()>0){\n\t  vi tmp = t[id].second;\n\t  tmp.erase(tmp.begin() + disA[0]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}else{\n\t  vi tmp = t[id].second;\n\t  tmp.push_back(t[j].second[disB[0]]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}      \n      }\n    }\n    \n    //for leaf\n    if(t[id].first.size() == 0){\n      if(t[id].second.size() > 1){\n\tvi tmp;\n\trep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n\tt.push_back(make_pair(vi(), tmp));\n\tt[id].first.push_back(t.size()-1);\n      }\n    }\n\n    rep(i,t[id].first.size()){\n      s.push(t[id].first[i]);\n    }\n  }\n}\n\nunordered_map<ll,ll> memo;\n\nll rec(int id, int use, const TD &t){\n  ll key = mod*id + use;\n\n  stack<ll> s;\n  s.push(key);\n\n  while(s.sz){\n    ll res = 0;\n    key = s.top(); s.pop();\n    id = key/mod; use = key%mod;\n    const vi& child = t[id].fs, bag = t[id].sc;\n    \n    //for leaf\n    if(child.sz==0){\n      memo[key] = use;\n      goto END;\n    }\n    \n    if(child.sz==1){\n      const vi &nbag = t[child[0]].second;\n      vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n      rep(i,bag.size())rep(j,nbag.size()){\n\tif(bag[i] == nbag[j]){\n\t  to_bag[j] = i; to_nbag[i] = j;\n\t}\n      }\n      \n      //for introduce\n      if(nbag.sz < bag.sz){\n\tint nuse = 0;\n\trep(i,bag.sz){\n\t  if(to_nbag[i]<0){\n\t    if( ((use>>i)&1) == 0 ){\n\t      memo[key] = 0;\n\t      goto END;\n\t    }\n\t  }else{\n\t    if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t  }\n\t}\n\tll nxt = child[0]*mod + nuse;\n\tif(memo.count(nxt)){\n\t  memo[key] = memo[nxt];\n\t  goto END;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n      }\n      \n      //for forget\n      if(nbag.sz > bag.sz){\n\tint add = -1,  nuse = 0;\n\trep(i,nbag.sz){\n\t  if(to_bag[i]<0)add = i;\n\t  else if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n\t}\n\t\n\tqueue<ll> uncal;\n\tll res = 0, nxt = child[0]*mod + nuse;\n\tif(memo.count(nxt)){\n\t  (res += memo[nxt]) %= mod;\n\t}else{\n\t  uncal.push(nxt);\n\t}\n\n\trep(i,bag.sz){\n\t  if((use>>i)&1)continue;\n\t  \n\t  if(is_edge.count(bag[i]*mod + nbag[add])){\n\t    nxt = child[0]*mod + (nuse | (1<<add) | (1<<to_nbag[i]));\n\t    if(memo.count(nxt)){\n\t      (res += memo[nxt]) %= mod;\n\t    }else{\n\t      uncal.push(nxt);\n\t    }\n\t  }\n\t}\n\n\tif(uncal.sz){\n\t  s.push(key); while(uncal.sz){ s.push(uncal.front()); uncal.pop(); }\n\t  goto END;\n\t}else{\n\t  memo[key] = res;\n\t  goto END;\n\t}\n      }\n    }\n    \n    //for join\n    if(child.sz==2){\n      int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n      queue<ll> uncal;\n      do{\n\tll nxt1 = child[0]*mod + (use|sub), nxt2 = child[1]*mod + (use|(unuse-sub));\n\tif(memo.count(nxt1) == 0){\n\t  uncal.push(nxt1);\n\t}\n\tif(memo.count(nxt2) == 0){\n\t  uncal.push(nxt2);\n\t}\n\tif(memo.count(nxt1) && memo.count(nxt2)){\n\t  res += memo[nxt1] * memo[nxt2];\n\t  res %= mod;\n\t}\n\tsub = (sub-1)&unuse;\n      }while(sub != unuse);\n    \n      if(uncal.sz){\n\ts.push(key); while(uncal.sz){ s.push(uncal.front()); uncal.pop(); }\n\tgoto END;\n      }else{\n\tmemo[key] = res;\n\tgoto END;\n      }\n    }\n  END:;\n  }\n  return memo[key];\n}\n\nvoid visg(vector<vi> g){\n  int n = g.size();\n  cout << \"graph {\" << endl;\n  rep(i,n){\n    rep(k,g[i].sz){\n      if(i<g[i][k]){\n\tcout << \"  \\\"\" << i << \" \";\n\tcout << \"\\\" -- \\\"\" << g[i][k] << \" \";\n\tcout << \"\\\"\" << endl;\n      }\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nvoid vis(TD t){\n  int n = t.size();\n  cout << \"digraph {\" << endl;\n  rep(i,n){\n    rep(k,t[i].first.size()){\n      int nxt = t[i].first[k];\n      cout << \"  \\\"\" << i << \": \";\n      rep(j,t[i].second.size())cout << t[i].second[j] << \" \";\n      cout << \"\\\" -> \\\"\" << nxt << \": \";\n      rep(j,t[nxt].second.size())cout << t[nxt].second[j] << \" \";\n      cout << \"\\\"\" << endl;\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nint main(){\n  int n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    vector<vi> g(n);\n    is_edge.clear();\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      is_edge.insert(a*mod + b);\n      is_edge.insert(b*mod + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      is_edge.insert(a*mod + b);\n      is_edge.insert(b*mod + a);\n    }\n\n    //visg(g);\n    TD t = heuristic_tree_decomposition(g);\n    //cout << t.size() << endl;\n    //vis(t);\n    toNice(t,0);\n    //cout << t.size() << endl;\n    //vis(t);\n\n    ll res = 0;\n    memo.clear();\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      res += rec(0,use,t);\n      res %= mod;\n    }\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\n\nconst int MOD=1000003;\nint N,M;\nvector<vector<int> > L;\nint ans=0;\nmap<pair<int,int> ,int> memo;\n\n\nlong long calc(int start,int end){\n//\tcout<<\"do \"<<start<<\" \"<<end<<endl;\n\tif((end-start)%2==0) return 0;\n\tif(start>end) return 1;\n\tif(memo.count(make_pair(start,end))) return memo[make_pair(start,end)];\n\tlong long res=1;\n\n\tint now=start;\n\tif(L[now].size()==0){\n\t\twhile(now<=end && L[now].size()==0) now+=2;\n\t\treturn calc(now,end);\n\t}\n\telse{\n\t\tres=0;\n\t\tfor(int k=0;k<L[now].size();k++){\n\t\t\tres+=(calc(now+1,L[now][k]-1)*calc(L[now][k]+1,end))%MOD;\n\t\t\tres%=MOD;\n\t\t}\n\t}\n\tif(now+2<end)\n\t\tres+=calc(now+2,end);\n\tres%=MOD;\n\tmemo[make_pair(start,end)]=res;\n//\tcout<<\"res \"<<start<<\" \"<<end<<\" :\"<<res<<endl;\n\treturn res%MOD;\n}\n\nint main()\n{\n\twhile(cin>>N>>M && N!=0){\n\t\tmemo.clear();\n\t\tL.clear();\n\t\tL.resize(N,vector<int>());\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint in,out;cin>>in>>out;\n\t\t\tin--;out--;\n\t\t\tif(in<out)\n\t\t\t\tL[in].push_back(out);\n\t\t\telse\n\t\t\t\tL[out].push_back(in);\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tsort(L[i].begin(),L[i].end());\n\t\t\tL[i].erase(unique(L[i].begin(),L[i].end()),L[i].end());\n\t\t}\n\t\tcout<<(calc(0,N-1)+calc(1,N-2))%MOD<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n\nusing namespace std;\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\ntypedef long long ll;\nconst int mod=1000000003;\nvector<int> to[50000];\n\nvoid Merge(int a[2][2],int b[2][2],int (&c)[2][2]){\n\tREP(i,2)\n\t\tREP(j,2)\n\t\t\tc[i][j]=(ll(a[i][0])*b[1][j]+ll(a[i][1])*b[0][j])%mod;\n}\n\nvoid Calc(int l,int r,int (&dst)[2][2]){\n\tdst[0][0]=1;\n\tdst[0][1]=0;\n\tdst[1][0]=0;\n\tdst[1][1]=1;\n\tif(l+1==r)\n\t\treturn;\n\tint buf[2][2],tmp[2][2];\n\tFOR(i,1,(int)to[l].size()){\n\t\tCalc(to[l][i-1],to[l][i],buf);\n\t\tMerge(dst,buf,tmp);\n\t\tmemcpy(dst,tmp,sizeof(dst));\n\t\tdst[1][1]=(dst[1][1]+dst[0][0])%mod;\n\t}\n\tif(to[l].back()<r){\n\t\tCalc(to[l].back(),r,buf);\n\t\tMerge(dst,buf,tmp);\n\t\tmemcpy(dst,tmp,sizeof(dst));\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint n=read(),m=read();\n\t\tif(!n)\n\t\t\treturn 0;\n\t\tREP(i,n)\n\t\t\tto[i].clear();\n\t\tREP(i,n-1)\n\t\t\tto[i].PB(i+1);\n\t\tto[0].PB(n-1);\n\t\tREP(i,m){\n\t\t\tint a=read()-1,b=read()-1;\n\t\t\tto[min(a,b)].PB(max(a,b));\n\t\t}\n\t\tREP(i,n)\n\t\t\tsort(to[i].begin(),to[i].end());\n\t\tint ans[2][2];\n\t\tCalc(0,n-1,ans);\n\t\tprintf(\"%d\\n\",ans[1][1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n//#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define MOD 1000003\n#define NUM 50005\n\nenum Type{\n\tNOT_NOT,\n\tNOT_USED,\n\tUSED_NOT,\n\tUSED_USED,\n};\n\nstruct Info{\n\tInfo(){\n\n\t\tleft = right = 0;\n\t}\n\tInfo(int arg_left,int arg_right){\n\t\tleft = arg_left;\n\t\tright = arg_right;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\n\t\tif(left != arg.left){\n\n\t\t\treturn left < arg.left;\n\t\t}else{\n\n\t\t\treturn right < arg.right;\n\t\t}\n\t}\n\n\tint left,right;\n};\n\nint V,E;\nmap<Info,ll> dp[4];\nvector<int> G[NUM];\n\n\nll recursive(int left,int right,bool used_0,bool used_1){\n\n\tif(left+1 == right){\n\n\t\tif(used_0 == true && used_1 == true){\n\n\t\t\treturn true;\n\t\t}else{\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tbool used[2];\n\n\tused[0] = used_0;\n\tused[1] = used_1;\n\n\tType type;\n\n\tif(used[0] == true && used[1] == true){\n\n\t\ttype = USED_USED;\n\n\t}else if(used[0] == true && used[1] == false){\n\n\t\ttype = USED_NOT;\n\n\t}else if(used[0] == false && used[1] == true){\n\n\t\ttype = NOT_USED;\n\n\t}else if(used[0] == false && used[1] == false){\n\n\t\ttype = NOT_NOT;\n\t}\n\n\tInfo info;\n\tinfo.left = left;\n\tinfo.right = right;\n\n\tif(dp[type].count(info) > 0){\n\n\t\treturn dp[type][info];\n\t}\n\n\tll ret = 0;\n\n\tint L,R,mid,next_node;\n\n\tL = 0,R = G[right].size()-1,mid = (L+R)/2;\n\n\twhile(L <= R){\n\n\t\tif(G[right][mid] > left){\n\n\t\t\tnext_node = G[right][mid];\n\t\t\tR = mid-1;\n\n\t\t}else{\n\n\t\t\tL = mid+1;\n\t\t}\n\t\tmid = (L+R)/2;\n\t}\n\n\tret += recursive(next_node,right,true,used[1])*recursive(left,next_node,used[0],false);\n\tret %= MOD;\n\n\tret += recursive(next_node,right,false,used[1])*recursive(left,next_node,used[0],true);\n\tret %= MOD;\n\n\tbool is_adj[2];\n\n\tL = 0,R = G[left].size()-1,mid = (L+R)/2;\n\tis_adj[0] = false;\n\n\twhile(L <= R){\n\n\t\tif(G[left][mid] == next_node){\n\n\t\t\tis_adj[0] = true;\n\t\t\tbreak;\n\t\t}else if(G[left][mid] > next_node){\n\n\t\t\tR = mid-1;\n\t\t}else{\n\n\t\t\tL = mid+1;\n\t\t}\n\n\t\tmid = (L+R)/2;\n\t}\n\n\tL = 0,R = G[right].size()-1,mid = (L+R)/2;\n\tis_adj[1] = false;\n\n\twhile(L <= R){\n\n\t\tif(G[right][mid] == next_node){\n\n\t\t\tis_adj[1] = true;\n\t\t\tbreak;\n\t\t}else if(G[right][mid] > next_node){\n\n\t\t\tR = mid-1;\n\t\t}else{\n\n\t\t\tL = mid+1;\n\t\t}\n\n\t\tmid = (L+R)/2;\n\t}\n\n\tif(used[0] == false && is_adj[0] == true){\n\n\t\tret += recursive(next_node,right,true,used[1])*recursive(left,next_node,true,true);\n\t\tret %= MOD;\n\t}\n\n\tif(used[1] == false && is_adj[1] == true){\n\n\t\tret += recursive(next_node,right,true,true)*recursive(left,next_node,used[0],true);\n\t\tret %= MOD;\n\t}\n\n\treturn dp[type][info] = ret%MOD;\n}\n\n\nvoid func(){\n\n\tfor(int i = 0; i < V; i++){\n\n\t\tG[i].clear();\n\t}\n\n\tfor(int i = 0; i < 4; i++){\n\n\t\tdp[i].clear();\n\t}\n\n\tint from,to;\n\n\tfor(int i = 0; i <= V-1; i++){\n\n\t\tfrom = i;\n\t\tto = (i+1)%V;\n\n\t\tG[from].push_back(to);\n\t\tG[to].push_back(from);\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\n\t\tG[from].push_back(to);\n\t\tG[to].push_back(from);\n\t}\n\n\tfor(int i = 0; i < V; i++){\n\n\t\tsort(G[i].begin(),G[i].end());\n\t}\n\n\tll ans = recursive(0,V-1,true,true)+recursive(0,V-1,false,false);\n\n\tprintf(\"%lld\\n\",ans%MOD);\n}\n\n\nint main(){\n\n\twhile(true){\n\n\t\tscanf(\"%d %d\",&V,&E);\n\t\tif(V == 0 && E == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\n\nconst int MOD=1000003;\nint N,M;\nvector<vector<int> > L;\nint ans=0;\nmap<pair<int,int> ,int> memo;\n\n\nlong long calc(int start,int end){\n//\tcout<<\"do \"<<start<<\" \"<<end<<endl;\n\tif((end-start)%2==0) return 0;\n\tif(start>end) return 0;\n\tif(memo.count(make_pair(start,end))) return memo[make_pair(start,end)];\n\tlong long res=1;\n\n\tint now=start;\n\tif(L[now].size()==0){\n\t\twhile(now<=end && L[now].size()==0) now+=2;\n\t\treturn calc(now,end);\n\t}\n\telse{\n\t\tres=0;\n\t\tfor(int k=0;k<L[now].size();k++){\n\t\t\tlong long ans1=calc(now+1,L[now][k]-1),ans2=1;\n\t\t\tif(L[now][k]+1<end) ans2=calc(L[now][k]+1,end);\n\t\t\tres+=(ans1*ans2)%MOD;\n\t\t\tres%=MOD;\n\t\t}\n\t}\n\tres+=calc(now+2,end);\n\tres%=MOD;\n\tmemo[make_pair(start,end)]=res;\n//\tcout<<\"res \"<<start<<\" \"<<end<<\" :\"<<res<<endl;\n\treturn res%MOD;\n}\n\nint main()\n{\n\twhile(cin>>N>>M && N!=0){\n\t\tmemo.clear();\n\t\tL.clear();\n\t\tL.resize(N,vector<int>());\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint in,out;cin>>in>>out;\n\t\t\tin--;out--;\n\t\t\tif(in<out)\n\t\t\t\tL[in].push_back(out);\n\t\t\telse\n\t\t\t\tL[out].push_back(in);\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tsort(L[i].begin(),L[i].end());\n\t\t\tL[i].erase(unique(L[i].begin(),L[i].end()),L[i].end());\n\t\t}\n\t\tcout<<(calc(0,N-1)+calc(1,N-2))%MOD<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\n\n\n\nconst int MOD=1000003;\nint N,M;\nvector<vector<int> > L;\nmap<pair<int,int> ,int> memo;\nvoid print(int n){\n\tfor(int i=0;i<n;i++)\n\t\tcout<<\"\t  \";\n}\n\nint calc(int start,int end,int depth){//startからendまでの組み合わせを計算　この時点でサイクルになっていない\n//\tprint(depth);\n//\tcout<<\"do \"<<start<<\" \"<<end<<endl;\n\tif((end-start)%2==0){\n//\t\t\tprint(depth);cout<<\"res \"<<0<<\" :\"<<start<<\" \"<<end<<endl;\n\t\t\treturn 0;\n\t}//奇数とか無理です\n\tif(memo.count(make_pair(start,end))) return memo[make_pair(start,end)];\n\tint res=1;\n\n\tfor(int from=start;from<=end;from++){\n\t\tfor(int idx=0;idx<L[from].size();idx++){\n\t\t\tint to=L[from][idx];\n\t\t\tif(start<=to && to<=end && from<to){\n\t\t\t\tint num1=1,num2=1,num3=1;\n\t\t\t\tif(start<=from-1) num1=calc(start,from-1,depth+1);\n\t\t\t\tif(from+1<=to-1) num2=calc(from+1,to-1,depth+1);\n\t\t\t\tif(to+1<=end) num3=calc(to+1,end,depth+1);\n\t\t\t\tres+=(((num1*num2)%MOD)*num3)%MOD;\n\t\t\t\tres%=MOD;\n\t\t\t}\n\t\t}\n\t}\n//\tprint(depth);\n//\tcout<<\"res \"<<res<<\" :\"<<start<<\" \"<<end<<endl;\n\tmemo[make_pair(start,end)]=res;\n\treturn res;\n\n}\n\nint main()\n{\n\twhile(cin>>N>>M && N!=0){\n\t\tmemo.clear();\n\t\tL.clear();\n\t\tL.resize(N,vector<int>());\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint in,out;cin>>in>>out;\n\t\t\tin--;out--;\n\t\t\tL[in].push_back(out);\n\t\t\tL[out].push_back(in);\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tsort(L[i].begin(),L[i].end());\n\t\t\tL[i].erase(unique(L[i].begin(),L[i].end()),L[i].end());\n\t\t}\n\t\tif(N%2!=0)\n\t\t\tcout<<100<<endl;\n\t\telse{\n\t\t\tint ans=0;\n\t\t\tans+=calc(2,N-1,0);//0と1を姉妹港にしたよ\n\t\t\tans%=MOD;\n\t\t\tans+=calc(1,N-2,0);//0とN-1を姉妹港にしたよ\n\t\t\tans%=MOD;\n\t\t\tfor(int i=0;i<L[0].size();i++){\n\t\t\t\tans+=(calc(1,L[0][i]-1,0)*calc(L[0][i]+1,N-1,0))%MOD;//道がつながっているところを別途計算するよ\n\t\t\t\tans%=MOD;\n\t\t\t}\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntypedef vector< pair<vi,vi> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\nset<ll> is_edge;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(vector<vi> &g){\n  int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  set<ll> tmp_edge = is_edge;\n  rep(i,n){\n    deg[i] = g[i].sz; deg[i]*=-1;\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vi unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tint aa = a, bb = b;\n\tif(aa>bb)swap(aa,bb);\n\tif(aa!=bb && !tmp_edge.count(aa*mod + bb)){\n\t  g[aa].pb(bb);\n\t  g[bb].pb(aa);\n\t  tmp_edge.insert(aa*mod + bb);\n\t  deg[aa]--; deg[bb]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, int id){\n  stack<int> s;\n  s.push(id);\n\n  while(s.sz){\n    id = s.top(); s.pop();\n    \n    //for join\n    while(t[id].first.size()>2){\n      vi child(2);\n      child[0] = t[id].first.back(); t[id].first.pop_back();\n      child[1] = t[id].first.back(); t[id].first.pop_back();\n      t.push_back(make_pair(child, t[id].second));\n      t[id].first.push_back(t.size()-1);\n    }\n\n    if(t[id].first.size()==2){\n      rep(i,2){\n\tconst int &j = t[id].first[i];\n\tif(t[id].second != t[j].second){\n\t  vi child(1);\n\t  child[0] = j;\n\t  t.push_back(make_pair(child, t[id].second));\n\t  t[id].first[i] = t.size()-1;\n\t}\n      }\n    }\n\n    //for introduce & forget\n    if(t[id].first.size()==1){\n      const int &j = t[id].first[0];\n      vi child(1);\n      child[0] = j;\n      \n      vi disA, disB;\n      rep(a,t[id].second.size()){\n\tbool f = true;\n\trep(b,t[j].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disA.push_back(a);\n      }\n      rep(b,t[j].second.size()){\n\tbool f = true;\n\trep(a,t[id].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disB.push_back(b);\n      }\n      \n      if(disA.size() + disB.size() > 1){\n\tif(disA.size()>0){\n\t  vi tmp = t[id].second;\n\t  tmp.erase(tmp.begin() + disA[0]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}else{\n\t  vi tmp = t[id].second;\n\t  tmp.push_back(t[j].second[disB[0]]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}      \n      }\n    }\n    \n    //for leaf\n    if(t[id].first.size() == 0){\n      if(t[id].second.size() > 1){\n\tvi tmp;\n\trep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n\tt.push_back(make_pair(vi(), tmp));\n\tt[id].first.push_back(t.size()-1);\n      }\n    }\n\n    rep(i,t[id].first.size()){\n      s.push(t[id].first[i]);\n    }\n  }\n}\n\nmap<int,ll> memo;\n\nll rec(int id, int use, const TD &t){\n  int key = 100*id + use;\n\n  stack<int> s;\n  s.push(key);\n\n  while(s.sz){\n    ll res = 0;\n    key = s.top(); s.pop();\n    id = key/100; use = key%100;\n    const vi& child = t[id].fs, bag = t[id].sc;\n    \n    //for leaf\n    if(child.sz==0){\n      memo[key] = use;\n      goto END;\n    }\n    \n    if(child.sz==1){\n      const vi &nbag = t[child[0]].second;\n      vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n      rep(i,bag.size())rep(j,nbag.size()){\n\tif(bag[i] == nbag[j]){\n\t  to_bag[j] = i; to_nbag[i] = j;\n\t}\n      }\n      \n      //for introduce\n      if(nbag.sz < bag.sz){\n\tint nuse = 0;\n\trep(i,bag.sz){\n\t  if(to_nbag[i]<0){\n\t    if( ((use>>i)&1) == 0 ){\n\t      memo[key] = 0;\n\t      goto END;\n\t    }\n\t  }else{\n\t    if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t  }\n\t}\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  memo[key] = memo[nxt];\n\t  goto END;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n      }\n      \n      //for forget\n      if(nbag.sz > bag.sz){\n\tint add = -1,  nuse = 0;\n\trep(i,nbag.sz){\n\t  if(to_bag[i]<0)add = i;\n\t  else if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n\t}\n\t\n\tll res = 0;\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  (res += memo[nxt]) %= mod;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n\n\trep(i,bag.sz){\n\t  if((use>>i)&1)continue;\n\t  \n\t  int a = bag[i], b = nbag[add];\n\t  if(a>b)swap(a,b);\n\t  if(is_edge.count(a*mod + b)){\n\t    nxt = child[0]*100 + (nuse | (1<<add) | (1<<to_nbag[i]));\n\t    if(memo.count(nxt)){\n\t      (res += memo[nxt]) %= mod;\n\t    }else{\n\t      s.push(key); s.push(nxt);\n\t      goto END;\n\t    }\n\t  }\n\t}\n\tmemo[key] = res;\n      }\n    }\n    \n    //for join\n    if(child.sz==2){\n      int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n      do{\n\tint nxt1 = child[0]*100 + (use|sub), nxt2 = child[1]*100 + (use|(unuse-sub));\n\tif(memo.count(nxt1) == 0){\n\t  s.push(key); s.push(nxt1);\n\t  goto END;\n\t}\n\tif(memo.count(nxt2) == 0){\n\t  s.push(key); s.push(nxt2);\n\t  goto END;\n\t}\n\tif(memo.count(nxt1) && memo.count(nxt2)){\n\t  res += memo[nxt1] * memo[nxt2];\n\t  res %= mod;\n\t}\n\tsub = (sub-1)&unuse;\n      }while(sub != unuse);\n    \n      memo[key] = res;\n    }\n  END:;\n  }\n  return memo[key];\n}\n\nvoid visg(vector<vi> g){\n  int n = g.size();\n  cout << \"graph {\" << endl;\n  rep(i,n){\n    rep(k,g[i].sz){\n      if(i<g[i][k]){\n\tcout << \"  \\\"\" << i << \" \";\n\tcout << \"\\\" -- \\\"\" << g[i][k] << \" \";\n\tcout << \"\\\"\" << endl;\n      }\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nvoid vis(TD t){\n  int n = t.size();\n  cout << \"digraph {\" << endl;\n  rep(i,n){\n    rep(k,t[i].first.size()){\n      int nxt = t[i].first[k];\n      cout << \"  \\\"\" << i << \": \";\n      rep(j,t[i].second.size())cout << t[i].second[j] << \" \";\n      cout << \"\\\" -> \\\"\" << nxt << \": \";\n      rep(j,t[nxt].second.size())cout << t[nxt].second[j] << \" \";\n      cout << \"\\\"\" << endl;\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nint main(){\n  int n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    vector<vi> g(n);\n    is_edge.clear();\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*mod + b);\n      else is_edge.insert(b*mod + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*mod + b);\n      else is_edge.insert(b*mod + a);\n    }\n\n    //visg(g);\n    TD t = heuristic_tree_decomposition(g);\n    g.clear();\n    //cout << t.size() << endl;\n    //vis(t);\n    toNice(t,0);\n    //cerr << t.size() << endl;\n    //vis(t);\n\n    ll res = 0;\n    memo.clear();\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      res += rec(0,use,t);\n      res %= mod;\n    }\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\ntypedef long long ll;\ntypedef vector<int> vi;\nconst int MOD = 1000003;\nint n, m;\nvector<vi> g;\n\nvi solve(int l, int r, int gi){\n\tvi res(2, 1);\n\tfor(int i=l;i<r;i++){\n\t\tif(gi < (int)g[i].size()){\n\t\t\tvi ret = solve(i, g[i][gi], gi+1);\n\t\t\tREP(j, 2) res[j] = (ll)res[j]*ret[j]%MOD;\n\t\t\ti = g[i][gi]-1;\n\t\t}\n\t\tswap(res[0], res[1]);\n\t\tgi = 0;\n\t}\n\tswap(res[0], res[1]);\n\tif(r-l > 1) res[1] -= ((res[1] = res[1] + res[0]) >= MOD) ? MOD : 0;\n\treturn res;\n}\n\nint main(){\n\twhile(scanf(\"%d%d\", &n, &m), n){\n\t\tg = vector<vi>(n);\n\t\tREP(i, m){\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v);u--; v--;\n\t\t\tif(v < u) swap(u, v);\n\t\t\tif(((u^v)&1)) g[u].push_back(v);\n\t\t}\n\t\tREP(i, n) sort(g[i].rbegin(), g[i].rend());\n\t\tprintf(\"%d\\n\", n%2 ? 0 : (int)(solve(0, n-1, 0)[1]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint MOD = 1000003;\n\nll f(int u, int i, vector<vector<int> >& G, vector<vector<ll> >& memo) {\n\tif (memo[u][i] != -1) return memo[u][i];\n\tif (i == 0) return memo[u][i] = 1 * MOD + 1;\n\tll X = 1, Y = 1;\n\tint v = u, j = i - 1;\n\tfor (int t = 0; ; t++) {\n\t\tll z = f(v, j, G, memo);\n\t\tint x = z / MOD, y = z % MOD;\n\t\tif (t % 2 == 1) swap(x, y);\n\t\tX = X * x % MOD;\n\t\tY = Y * y % MOD;\n\t\tv = G[v][j];\n\t\tif (v == G[u][i]) break;\n\t\tj = G[v].size() - 1;\n\t}\n\treturn memo[u][i] = X * MOD + (X + Y) % MOD;\n}\n\nint solve(int n, int m, vector<int> a, vector<int> b) {\n\tif (n % 2 == 1) return 0;\n\tvector<vector<int> > G(n);\n\tG[0].push_back(n - 1);\n\tfor (int u = 0; u + 1 < n; u++)\n\t\tG[u].push_back(u + 1);\n\tfor (int i = 0; i < m; i++) {\n\t\ta[i]--; b[i]--;\n\t\tif (a[i] > b[i]) swap(a[i], b[i]);\n\t\tif ((b[i] - a[i]) % 2 == 1)\n\t\t\tG[a[i]].push_back(b[i]);\n\t}\n\tvector<vector<ll> > memo(n);\n\tfor (int u = 0; u < n; u++) {\n\t\tsort(G[u].begin(), G[u].end());\n\t\tmemo[u] = vector<ll>(G[u].size(), -1);\n\t}\n\treturn f(0, G[0].size() - 1, G, memo) % MOD;\n}\n\nint main() {\n\tfor (;;) {\n\t\tint n, m; cin >> n >> m;\n\t\tif (n == 0 && m == 0) break;\n\t\tvector<int> a(m), b(m);\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tcin >> a[i] >> b[i];\n\t\tcout << solve(n, m, a, b) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct P {\n  int a, b;\n  P(int a, int b) : a(a),b(b) {}\n};\nbool operator<(const P &a, const P &b) {\n  return a.a != b.a ? a.a < b.a : a.b > b.b;\n}\nbool parity[50002][2];\nll dp[50002][2][2];\n\nll MOD = 1000003;\nint main() {\n  int n,m;\n  while(cin>>n>>m,n||m) {\n    vector<P> v;\n    v.push_back(P(0,n-1));\n    REP(i,m) {\n      int a, b;cin >> a >> b;\n      a--; b--;\n      v.push_back(P(min(a,b),max(a,b)));\n    }\n    sort(ALL(v));\n    REP(i,m) {\n      parity[i][0] = (v[i+1].a-v[i].a) % 2;\n      parity[i][1] = (v[i].b-v[i+1].b) % 2;\n    }\n    memset(dp,0,sizeof(dp));\n    dp[0][0][0] = 1;\n    REP(i,m) {\n      // use edge i\n      (dp[i+1][!parity[i][0]][!parity[i][1]] += dp[i][0][0]) %= MOD;\n      // not use\n      REP(j,2) {\n        REP(k,2) {\n          //cout << dp[i][j][k] << \" \";\n          (dp[i+1][j^parity[i][0]][k^parity[i][1]] += dp[i][j][k]) %= MOD;\n        }\n      }\n      //cout << endl;\n    }\n    ll sum = 0;\n    if ((v[m].b-v[m].a) % 2 == 0) {\n      sum += dp[m][0][1];\n      sum += dp[m][1][0];\n    } else {\n      sum += dp[m][0][0] * 2;\n      sum += dp[m][1][1];\n    }\n    cout << sum % MOD << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst int MOD=1000003;\nint x0;\nint n, m;\nint a[50000], b[50000];\nint solve(){\n\tif(n&1) return 0;\n\tif(m==0) return 2;\n\tvector<int> ind;\n\tint dmn=n, i0;\n\tfor(int i=0; i<m; i++){\n\t\tint d1=abs(b[i]-a[i]);\n\t\tif(d1%2==0) continue;\n\t\tind.push_back(i);\n\t\tif(dmn>min(d1, n-d1)){\n\t\t\ti0=i;\n\t\t\tdmn=min(d1, n-d1);\n\t\t}\n\t}\n\tif(ind.empty()) return 2;\n\tif(abs(b[i0]-a[i0])<=n/2){\n\t\tx0=(a[i0]+b[i0])/2;\n\t}else{\n\t\tx0=n-(a[i0]+b[i0])/2;\n\t}\n\tvector<int> v[50001];\n\tfor(auto i:ind){\n\t\ta[i]=(a[i]-x0+n)%n, b[i]=(b[i]-x0+n)%n;\n\t\tif(a[i]>b[i]) swap(a[i], b[i]);\n\t\tv[b[i]].push_back(a[i]);\n\t}\n\tint s[2][50001]; s[0][0]=s[1][0]=0;\n\tfor(int i=1; i<n; i++){\n\t\ts[0][i]=s[0][i-1], s[1][i]=s[1][i-1];\n\t\tfor(auto l:v[i]){\n\t\t\tint dp=1;\n\t\t\tif(i&1){\n\t\t\t\tdp+=(s[0][i]-s[0][l]+MOD);\n\t\t\t\tdp%=MOD;\n\t\t\t\ts[1][i]+=dp;\n\t\t\t\ts[1][i]%=MOD;\n\t\t\t}else{\n\t\t\t\tdp+=(s[1][i]-s[1][l]+MOD);\n\t\t\t\tdp%=MOD;\n\t\t\t\ts[0][i]+=dp;\n\t\t\t\ts[0][i]%=MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn (s[0][n-1]+s[1][n-1]+2)%MOD;\n}\n\nint main()\n{\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0) return 0;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcin>>a[i]>>b[i];\n\t\t\ta[i]--; b[i]--;\n\t\t}\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n \n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <cassert>\n#include <unistd.h>\n#include <cstdio>\n#include <cstdlib>\n#include <stack>\n#include <random>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nconst int MN = 50500; \nconst int MD = 1000003;\n\nint n, m;\nP g[MN];\nvector<P> edge;\nint calc(int l, int r) {\n    ll res = 1;\n    while (l <= r) {\n        P p = g[l];\n        l = p.first+1;\n        res *= p.second; res %= MD;\n    }\n    return res;\n}\nint solve() {\n    if (n % 2) return 0;\n    edge.clear();\n    for (int i = 0; i < n-1; i++) {\n        g[i] = P(i+1, 1);\n    }\n    vector<T> buf;\n    buf.push_back(T(n-1, 0, n-1));\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b); a--; b--;\n        if (a > b) swap(a, b);\n        if ((b-a) % 2 == 0) continue;\n        buf.push_back(T(b-a, a, b));\n    }\n    sort(buf.begin(), buf.end());\n    for (T &t: buf) {\n        int a, b, c;\n        tie(c, a, b) = t;\n        int res = calc(a, b) + calc(a+1, b-1);\n        res %= MD;\n        g[a] = P(b, res);\n    }\n    return g[0].second;\n}\n\nint main() {\n    while (true) {\n        scanf(\"%d %d\", &n, &m);\n        if (!n) break;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<string>\n#include <complex>\n#include<list>\n#include<float.h>\n#include <functional>\n#include <vector>\n#include <map>\n//lib\nusing namespace std;\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REP0(i,n)   REP(i,0,n)\n\n#define foreach(it,o) for(__typeof((o).begin()) it=(o).begin(); it!=(o).end(); ++it)\n\nint n, m;\n\nint a, b;\n\n\nvector<bool> passed;\nmap<int, list<int> > nodes;\n\nint search(int i) { //パターン数の出力\n\tif (passed[i] || nodes[i].size() == 0) {\n\t\treturn 0;\n\t}\n\tpassed[i] = true;\n\n\tint val = nodes[i].size();\n\tforeach(node,nodes[i]) {\n\t\tint v = search(*node);\n\t\tval *= v > 0 ? v : 1;\n\t}\n\t//cout<<\"(\"<< i << \",\"<<nodes[i].size()<< \",\"<<val<<\")\"<<endl;\n\treturn val;\n}\nvoid solve() {\n\t//与えられたノードのONOFF判定のみすればよい。\n\tint val = 1;\n\tint graphs = 0;\n\tREP(i,1,n+1) {\n\t\tint s = search(i) + 1;\n\t\tval *= s;\n\t\tif (s > 1) {\n\t\t\tgraphs++;\n\t\t}\n\t}\n\tcout << val + 1 << endl;\n}\n//データ整形\nint main() {\n\twhile (true) {\n\t\tcin >> n >> m;\n\t\tif (n == 0 && m == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tif (n % 2 == 1) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tpassed.clear();\n\t\tnodes.clear();\n\n\t\tREP0(p,m) {\n\t\t\tcin >> a >> b;\n\t\t\tif ((b - a + 2 * n) % 2 == 1) {\n\t\t\t\tnodes[a].push_back(b);\n\t\t\t\tnodes[b].push_back(a);\n\t\t\t}\n\t\t}\n\t\tREP(i,0,n+1) {\n\t\t\tpassed.push_back(false);\n\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n\nconst int mod = 1000003;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct line {\n\tint a;\n\tint b;\n};\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<pair<int, int>>ps;\n\t\tint offset=-1;\n\t\tint mindis = N;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tif (a == b)continue;\n\t\t\tps.push_back(make_pair(a, b));\n\t\t\tif (a > b)swap(a, b);\n\t\t\tassert(a < b);\n\t\t\tif (b - a == 1 || (N - (b - a) == 1))continue;\n\t\t\tif (mindis > min(b-a, N - (b-a))) {\n\t\t\t\tmindis = min(b-a, N - (b-a));\n\t\t\t\tif (b-a < N - (b-a)) {\n\t\t\t\t\toffset = (a + b) / 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toffset = (N + a + b) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (auto&p : ps) {\n\t\t\tp.first = (p.first+N-offset)% N;\n\t\t\tp.second = (p.second+N - offset) % N;\n\t\t\tif (p.second < p.first)swap(p.first, p.second);\n\t\t}\n\t\tsort(ps.begin(), ps.end(), [](const pair<int, int>&l, const pair<int, int>&r) {\n\t\t\treturn l.first == r.first ? l.second > r.second : l.first < r.first;\n\t\t});\n\t\tfor (auto&p : ps) {\n\t\t\tp.second = N - p.second;\n\t\t}\n\t\tvector<vector<vector<line>>>ls(2,vector<vector<line>>(2));\n\t\tfor (const auto&p : ps) {\n\t\t\tls[p.first % 2][p.second % 2].push_back(line{ p.first,p.second });\n\t\t}\n\t\tvector<vector<int>>sums(2, vector<int>(2));\n\t\t//vector<vector<int>>dp(N + 1,vector<int>(2));\n\t\t//dp[0][0] = 0;\n\t\tsums[1][0] = 1;\n\t\tsums[0][1] = 1;\n\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\n\t\t\tsums[ps[i].first % 2][ps[i].second % 2] += sums[!(ps[i].first % 2)][!(ps[i].second % 2)];\n\n\t\t\t\n\t\t\t//if ((ps[i].first + ps[i].second) % 2)sums[ps[i].first % 2][ps[i].second % 2]++;\n\t\t}\n\t\tint ans = sums[0][!(N % 2)] + sums[1][(N % 2)];\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nchar road[50050][50050];\nint n,m;\n\nint solve(int start, int end){\n\tint i,sum=0;\n//\tfor(j=now;j--;)printf(\" \");\n\tif(start+1==end){\n//\t\tfor(j=now;j--;)printf(\" \");\n//\t\tprintf(\"set %d %d\\n\", start, end);\n\t\treturn 1;\n\t}\n\tfor(i=start;i<=end;i++){\n\t\tint ret=1;\n\t\tif(!road[start][i] || !((start+i)%2)) continue;\n//\t\tfor(j=now;j--;)printf(\" \");\n//\t\tprintf(\"set %d %d\\n\", start, i);\n\t\tif(start+1!=i) ret=solve(start+1, i-1)%1000003;\n\t\tif(i!=end) ret*=solve(i+1, end)%1000003;\n\t\tsum+=ret%1000003;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tint i,j,a,b;\n\twhile(cin>>n>>m,n){\n\t\tmemset(road,0,sizeof(road));\n\t\tfor(i=1;i<=m;i++){\n\t\t\tcin>>a>>b;\n\t\t\troad[a][b]=road[b][a]=1;\n\t\t}\n\t\tfor(i=1;i<n;i++){\n\t\t\troad[i][i+1]=road[i+1][i]=1;\n\t\t}\troad[1][n]=road[n][1]=1;\n\t\tif(n%2) cout<<\"0\"<<endl;\n\t\telse cout<<solve(1,n)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n\nconst int mod = 1000003;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct line {\n\tint a;\n\tint b;\n};\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<pair<int, int>>ps;\n\t\tvector<int>nums(N);\n\t\tint offset;\n\t\tint mindis = N;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tps.push_back(make_pair(a, b));\n\t\t\tif (mindis > min(abs(a - b), N - abs(a - b))) {\n\t\t\t\tmindis = min(abs(a - b), N - abs(a - b));\n\t\t\t\tif (abs(a - b) < N - abs(a - b)) {\n\t\t\t\t\toffset = (a + b) / 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toffset = (N + a + b) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (auto&p : ps) {\n\t\t\tp.first = (p.first+N-offset)% N;\n\t\t\tp.second = (p.second+N - offset) % N;\n\t\t\tif (p.second < p.first)swap(p.first, p.second);\n\t\t}\n\t\tsort(ps.begin(), ps.end(), [](const pair<int, int>&l, const pair<int, int>&r) {\n\t\t\treturn l.first == r.first ? l.second > r.second : l.first < r.first;\n\t\t});\n\t\tfor (auto&p : ps) {\n\t\t\tp.second = N - p.second;\n\t\t}\n\t\tvector<vector<vector<line>>>ls(2,vector<vector<line>>(2));\n\t\tfor (const auto&p : ps) {\n\t\t\tls[p.first % 2][p.second % 2].push_back(line{ p.first,p.second });\n\t\t}\n\t\tvector<vector<int>>sums(2, vector<int>(2));\n\t\t//vector<vector<int>>dp(N + 1,vector<int>(2));\n\t\t//dp[0][0] = 0;\n\t\tsums[1][0] = 1;\n\t\tsums[0][1] = 1;\n\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\n\t\t\tsums[ps[i].first % 2][ps[i].second % 2] += sums[!(ps[i].first % 2)][!(ps[i].second % 2)];\n\n\t\t\t\n\t\t\t//if ((ps[i].first + ps[i].second) % 2)sums[ps[i].first % 2][ps[i].second % 2]++;\n\t\t}\n\t\tint ans = sums[0][!(N % 2)] + sums[1][(N % 2)];\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep2(i,a,b) for(int i=a;i<=b;i++)\n#define pb push_back\n#define eb emplace_back\n\nint in(){int x;cin>>x;return x;}\n\n\n    \n#define ll long long\nvector<vector<int>> g;\nvector<int> nxt;\nconstexpr ll MOD = 1000003;\n\nmain(){\n    while(1){\n        int n=in(),m=in();\n        if(!n)return 0;\n        g=vector<vector<int>>(n);\n        vector<vector<int>> v(2);\n        using P = pair<int,int> ;\n        vector<P> ed;\n        rep(i,m){\n            int a=in()-1,b=in()-1;\n            if(a>b)swap(a,b);\n            if((a+b)&1){\n                g[a].pb(b);\n                v[a&1].pb(a);\n                ed.eb(P(a,b));\n            }\n        }\n        if(n&1){\n            cout<<0<<endl;continue;\n        }\n        #define all(c) (c).begin(),(c).end()\n        vector<pair<int,ll>> dp(n);\n        ed.emplace_back(0,n-1);\n        sort(all(ed),[](P x,P y){return x.second-x.first<y.second-y.first;});\n        rep(i,n-1) dp[i] = P(i+1,1);\n        for(auto p:ed){\n            int a = p.first,b=p.second;\n            ll ans = 1;\n            int now = a+1;\n            while(now!=b){\n                ans=(ans*dp[now].second)%MOD;\n                now = dp[now].first+1;\n            }\n            dp[a+1]={b-1,ans};\n            now = a,ans = 1;\n            while(now!=b+1){\n                ans = (ans*dp[now].second)%MOD;\n                now = dp[now].first+1;\n            }\n            ans+=dp[a+1].second;\n            if(ans>=MOD)ans-=MOD;\n            dp[a] = {b,ans};\n        }\n        cout<<dp[0].second<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<unsigned short> vs;\n\ntypedef vector< pair<vi,vs> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(vector<vs> &g, set<ui> is_edge){\n  unsigned int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  rep(i,n){\n    deg[i] = g[i].sz; deg[i]*=-1;\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vs unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tui aa = a, bb = b;\n\tif(aa>bb)swap(aa,bb);\n\tif(aa!=bb && !is_edge.count(aa*n + bb)){\n\t  g[aa].pb(bb);\n\t  g[bb].pb(aa);\n\t  is_edge.insert(aa*n + bb);\n\t  deg[aa]--; deg[bb]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, int id){\n  stack<int> s;\n  s.push(id);\n\n  while(s.sz){\n    id = s.top(); s.pop();\n    \n    //for join\n    while(t[id].first.size()>2){\n      vi child(2);\n      child[0] = t[id].first.back(); t[id].first.pop_back();\n      child[1] = t[id].first.back(); t[id].first.pop_back();\n      t.push_back(make_pair(child, t[id].second));\n      t[id].first.push_back(t.size()-1);\n    }\n\n    if(t[id].first.size()==2){\n      rep(i,2){\n\tconst int &j = t[id].first[i];\n\tif(t[id].second != t[j].second){\n\t  vi child(1);\n\t  child[0] = j;\n\t  t.push_back(make_pair(child, t[id].second));\n\t  t[id].first[i] = t.size()-1;\n\t}\n      }\n    }\n\n    //for introduce & forget\n    if(t[id].first.size()==1){\n      const int &j = t[id].first[0];\n      vi child(1);\n      child[0] = j;\n      \n      vi disA, disB;\n      rep(a,t[id].second.size()){\n\tbool f = true;\n\trep(b,t[j].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disA.push_back(a);\n      }\n      rep(b,t[j].second.size()){\n\tbool f = true;\n\trep(a,t[id].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disB.push_back(b);\n      }\n      \n      if(disA.size() + disB.size() > 1){\n\tif(disA.size()>0){\n\t  vs tmp = t[id].second;\n\t  tmp.erase(tmp.begin() + disA[0]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}else{\n\t  vs tmp = t[id].second;\n\t  tmp.push_back(t[j].second[disB[0]]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}      \n      }\n    }\n    \n    //for leaf\n    if(t[id].first.size() == 0){\n      if(t[id].second.size() > 1){\n\tvs tmp;\n\trep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n\tt.push_back(make_pair(vi(), tmp));\n\tt[id].first.push_back(t.size()-1);\n      }\n    }\n\n    rep(i,t[id].first.size()){\n      s.push(t[id].first[i]);\n    }\n  }\n}\n\ninline int dp(int id, int use, unsigned int n,\n\t      const TD &t, const set<ui> &is_edge, unordered_map<int,int> &memo){\n  int key = 100*id + use;\n\n  int maxs = 0;\n  vector<int> s(t.sz);\n  int pos = 0;\n  s[pos++] = key;\n\n  while(pos){\n    ll res = 0;\n    key = s[--pos];\n    id = key/100; use = key%100;\n    const vi &child = t[id].fs;\n    const vs &bag = t[id].sc;\n    \n    //for leaf\n    if(child.sz==0){\n      memo[key] = use;\n      goto END;\n    }\n    \n    if(child.sz==1){\n      const vs &nbag = t[child[0]].second;\n      vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n      rep(i,bag.size())rep(j,nbag.size()){\n\tif(bag[i] == nbag[j]){\n\t  to_bag[j] = i; to_nbag[i] = j;\n\t}\n      }\n      \n      //for introduce\n      if(nbag.sz < bag.sz){\n\tint nuse = 0;\n\trep(i,bag.sz){\n\t  if(to_nbag[i]<0){\n\t    if( ((use>>i)&1) == 0 ){\n\t      memo[key] = 0;\n\t      goto END;\n\t    }\n\t  }else{\n\t    if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t  }\n\t}\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  memo[key] = memo[nxt];\n\t  goto END;\n\t}else{\n\t  s[pos++] = key; s[pos++] = nxt;\n\t  goto END;\n\t}\n      }\n      \n      //for forget\n      if(nbag.sz > bag.sz){\n\tint add = -1,  nuse = 0;\n\trep(i,nbag.sz){\n\t  if(to_bag[i]<0)add = i;\n\t  else if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n\t}\n\t\n\tll res = 0;\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  (res += memo[nxt]) %= mod;\n\t}else{\n\t  s[pos++] = key; s[pos++] = nxt;\n\t  goto END;\n\t}\n\n\trep(i,bag.sz){\n\t  if((use>>i)&1)continue;\n\t  \n\t  ui a = bag[i], b = nbag[add];\n\t  if(a>b)swap(a,b);\n\t  if(is_edge.count(a*n + b)){\n\t    nxt = child[0]*100 + (nuse | (1<<add) | (1<<to_nbag[i]));\n\t    if(memo.count(nxt)){\n\t      (res += memo[nxt]) %= mod;\n\t    }else{\n\t      s[pos++] = key; s[pos++] = nxt;\n\t      goto END;\n\t    }\n\t  }\n\t}\n\tmemo[key] = res;\n      }\n    }\n    \n    //for join\n    if(child.sz==2){\n      int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n      do{\n\tint nxt1 = child[0]*100 + (use|sub), nxt2 = child[1]*100 + (use|(unuse-sub));\n\tif(memo.count(nxt1) == 0){\n\t  s[pos++] = key; s[pos++] = nxt1;\n\t  goto END;\n\t}\n\tif(memo[nxt1]){\n\t  if(memo.count(nxt2) == 0){\n\t    s[pos++] = key; s[pos++] = nxt2;\n\t    goto END;\n\t  }\n\t  if(memo[nxt2]){\n\t    res += (ll)memo[nxt1] * memo[nxt2];\n\t    res %= mod;\n\t  }\n\t}\n\tsub = (sub-1)&unuse;\n      }while(sub != unuse);\n    \n      memo[key] = res;\n    }\n  END: maxs = max(maxs, (int)s.sz);\n  }\n  return memo[key];\n}\n\nint main(){\n  ui n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    vector<vs> g(n);\n    set<ui> is_edge;\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*n + b);\n      else is_edge.insert(b*n + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*n + b);\n      else is_edge.insert(b*n + a);\n    }\n\n    TD t = heuristic_tree_decomposition(g,is_edge);\n    g.clear();\n    toNice(t,0);\n\n    ll res = 0;\n    unordered_map<int,int> memo;\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      res += dp(0,use,n,t,is_edge,memo);\n      res %= mod;\n    }\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<unsigned short> vs;\n\ntypedef vector< pair<vi,vs> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(vector<vs> &g, set<ui> is_edge){\n  unsigned int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  rep(i,n){\n    deg[i] = g[i].sz; deg[i]*=-1;\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vs unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tui aa = a, bb = b;\n\tif(aa>bb)swap(aa,bb);\n\tif(aa!=bb && !is_edge.count(aa*n + bb)){\n\t  g[aa].pb(bb);\n\t  g[bb].pb(aa);\n\t  is_edge.insert(aa*n + bb);\n\t  deg[aa]--; deg[bb]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, int id){\n  stack<int> s;\n  s.push(id);\n\n  while(s.sz){\n    id = s.top(); s.pop();\n    \n    //for join\n    while(t[id].first.size()>2){\n      vi child(2);\n      child[0] = t[id].first.back(); t[id].first.pop_back();\n      child[1] = t[id].first.back(); t[id].first.pop_back();\n      t.push_back(make_pair(child, t[id].second));\n      t[id].first.push_back(t.size()-1);\n    }\n\n    if(t[id].first.size()==2){\n      rep(i,2){\n\tconst int &j = t[id].first[i];\n\tif(t[id].second != t[j].second){\n\t  vi child(1);\n\t  child[0] = j;\n\t  t.push_back(make_pair(child, t[id].second));\n\t  t[id].first[i] = t.size()-1;\n\t}\n      }\n    }\n\n    //for introduce & forget\n    if(t[id].first.size()==1){\n      const int &j = t[id].first[0];\n      vi child(1);\n      child[0] = j;\n      \n      vi disA, disB;\n      rep(a,t[id].second.size()){\n\tbool f = true;\n\trep(b,t[j].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disA.push_back(a);\n      }\n      rep(b,t[j].second.size()){\n\tbool f = true;\n\trep(a,t[id].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disB.push_back(b);\n      }\n      \n      if(disA.size() + disB.size() > 1){\n\tif(disA.size()>0){\n\t  vs tmp = t[id].second;\n\t  tmp.erase(tmp.begin() + disA[0]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}else{\n\t  vs tmp = t[id].second;\n\t  tmp.push_back(t[j].second[disB[0]]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}      \n      }\n    }\n    \n    //for leaf\n    if(t[id].first.size() == 0){\n      if(t[id].second.size() > 1){\n\tvs tmp;\n\trep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n\tt.push_back(make_pair(vi(), tmp));\n\tt[id].first.push_back(t.size()-1);\n      }\n    }\n\n    rep(i,t[id].first.size()){\n      s.push(t[id].first[i]);\n    }\n  }\n}\n\n\ninline int dp(int id, int use, unsigned int n,\n\t      const TD &t, const set<ui> &is_edge, unordered_map<int,int> &memo){\n  int key = 100*id + use;\n\n  int maxs = 0;\n  vector<int> s(t.sz);\n  int pos = 0;\n  s[pos++] = key;\n\n  while(pos){\n    ll res = 0;\n    key = s[--pos];\n    id = key/100; use = key%100;\n    const vi &child = t[id].fs;\n    const vs &bag = t[id].sc;\n    \n    //for leaf\n    if(child.sz==0){\n      memo[key] = use;\n      goto END;\n    }\n    \n    if(child.sz==1){\n      const vs &nbag = t[child[0]].second;\n      vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n      rep(i,bag.size())rep(j,nbag.size()){\n\tif(bag[i] == nbag[j]){\n\t  to_bag[j] = i; to_nbag[i] = j;\n\t}\n      }\n      \n      //for introduce\n      if(nbag.sz < bag.sz){\n\tint nuse = 0;\n\trep(i,bag.sz){\n\t  if(to_nbag[i]<0){\n\t    if( ((use>>i)&1) == 0 ){\n\t      memo[key] = 0;\n\t      goto END;\n\t    }\n\t  }else{\n\t    if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t  }\n\t}\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  memo[key] = memo[nxt];\n\t  goto END;\n\t}else{\n\t  s[pos++] = key; s[pos++] = nxt;\n\t  goto END;\n\t}\n      }\n      \n      //for forget\n      if(nbag.sz > bag.sz){\n\tint add = -1,  nuse = 0;\n\trep(i,nbag.sz){\n\t  if(to_bag[i]<0)add = i;\n\t  else if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n\t}\n\t\n\tll res = 0;\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  (res += memo[nxt]) %= mod;\n\t}else{\n\t  s[pos++] = key; s[pos++] = nxt;\n\t  goto END;\n\t}\n\n\trep(i,bag.sz){\n\t  if((use>>i)&1)continue;\n\t  \n\t  ui a = bag[i], b = nbag[add];\n\t  if(a>b)swap(a,b);\n\t  if(is_edge.count(a*n + b)){\n\t    nxt = child[0]*100 + (nuse | (1<<add) | (1<<to_nbag[i]));\n\t    if(memo.count(nxt)){\n\t      (res += memo[nxt]) %= mod;\n\t    }else{\n\t      s[pos++] = key; s[pos++] = nxt;\n\t      goto END;\n\t    }\n\t  }\n\t}\n\tmemo[key] = res;\n      }\n    }\n    \n    //for join\n    if(child.sz==2){\n      int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n      do{\n\tint nxt1 = child[0]*100 + (use|sub), nxt2 = child[1]*100 + (use|(unuse-sub));\n\tif(memo.count(nxt1) == 0){\n\t  s[pos++] = key; s[pos++] = nxt1;\n\t  goto END;\n\t}\n\tif(memo[nxt1]){\n\t  if(memo.count(nxt2) == 0){\n\t    s[pos++] = key; s[pos++] = nxt2;\n\t    goto END;\n\t  }\n\t  if(memo[nxt2]){\n\t    res += (ll)memo[nxt1] * memo[nxt2];\n\t    res %= mod;\n\t  }\n\t}\n\tsub = (sub-1)&unuse;\n      }while(sub != unuse);\n    \n      memo[key] = res;\n    }\n  END: maxs = max(maxs, (int)s.sz);\n  }\n  //cerr << maxs << endl;\n  return memo[key];\n}\n\nvoid visg(vector<vi> g){\n  int n = g.size();\n  cout << \"graph {\" << endl;\n  rep(i,n){\n    rep(k,g[i].sz){\n      if(i<g[i][k]){\n\tcout << \"  \\\"\" << i << \" \";\n\tcout << \"\\\" -- \\\"\" << g[i][k] << \" \";\n\tcout << \"\\\"\" << endl;\n      }\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nvoid vis(TD t){\n  int n = t.size();\n  cout << \"digraph {\" << endl;\n  rep(i,n){\n    rep(k,t[i].first.size()){\n      int nxt = t[i].first[k];\n      cout << \"  \\\"\" << i << \": \";\n      rep(j,t[i].second.size())cout << t[i].second[j] << \" \";\n      cout << \"\\\" -> \\\"\" << nxt << \": \";\n      rep(j,t[nxt].second.size())cout << t[nxt].second[j] << \" \";\n      cout << \"\\\"\" << endl;\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nint main(){\n  ui n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    vector<vs> g(n);\n    set<ui> is_edge;\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*n + b);\n      else is_edge.insert(b*n + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*n + b);\n      else is_edge.insert(b*n + a);\n    }\n\n    TD t = heuristic_tree_decomposition(g,is_edge);\n    g.clear();\n    toNice(t,0);\n    //cerr << t.sz << endl;\n\n    ll res = 0;\n    unordered_map<int,int> memo;\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      res += dp(0,use,n,t,is_edge,memo);\n      res %= mod;\n    }\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n \n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <cassert>\n#include <unistd.h>\n#include <cstdio>\n#include <cstdlib>\n#include <stack>\n#include <random>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nconst int MN = 50500; \nconst int MD = 1000003;\n\nint n, m;\nP g[MN];\nvector<P> edge;\nint calc(int l, int r) {\n    ll res = 1;\n    while (l <= r) {\n        P p = g[l];\n        l = p.first+1;\n        res *= p.second; res %= MD;\n    }\n    return res;\n}\nint solve() {\n    if (n % 2) return 0;\n    edge.clear();\n    for (int i = 0; i < n-1; i++) {\n        g[i] = P(i+1, 1);\n    }\n    vector<T> buf;\n    buf.push_back(T(n-1, 0, n-1));\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        if (a > b) swap(a, b);\n        if ((b-a) % 2 == 0) continue;\n        buf.push_back(T(b-a, a, b));\n    }\n    sort(buf.begin(), buf.end());\n    for (T &t: buf) {\n        int a, b, c;\n        tie(c, a, b) = t;\n        int res = calc(a, b) + calc(a+1, b-1);\n        res %= MD;\n        g[a] = P(b, res);\n    }\n    return g[0].second;\n}\n\nint main() {\n    while (true) {\n        cin >> n >> m;\n        if (!n) break;\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int,int>;\nconst ll MOD = 1000003;\n\nvector<int> G[50010];\nint nxt[50010];\nmap<pii,ll> memo;\n\nll dfs(int l,int r){\n\tif(memo.count(pii(l,r))) return memo[pii(l,r)];\n\tif(r - l <= 2) return 1;\n\tif(nxt[l] >= r) return 1;\n\tif(nxt[l] != l) return dfs(nxt[l],r);\n\tll ret = dfs(l + 2,r);\n\tfor(int to : G[l]){\n\t\tret = (ret + dfs(l + 1,to) * dfs(to + 1,r)) % MOD;\n\t}\n\treturn memo[pii(l,r)] = ret;\n}\n\nsigned main(){\n\tint n,m;\n\twhile(cin >> n >> m,n){\n\t\tmemo.clear();\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tG[i].clear();\n\t\t\tnxt[i] = n;\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b; a--;b--;\n\t\t\tif(a > b) swap(a,b);\n\t\t\tif((b - a) % 2) G[a].push_back(b);\n\t\t}\n\t\tG[0].push_back(n - 1);\n\t\tif(n % 2){\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i = n - 3;i >= 0;i--){\n\t\t\tif(G[i].size()) nxt[i] = i;\n\t\t\telse nxt[i] = nxt[i + 2];\n\t\t}\n\t\tcout << dfs(0,n) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntypedef vector< pair<vi,vi> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\nset<ll> is_edge;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(vector<vi> &g){\n  int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  set<ll> tmp_edge = is_edge;\n  rep(i,n){\n    deg[i] = g[i].sz; deg[i]*=-1;\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vi unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tint aa = a, bb = b;\n\tif(aa>bb)swap(aa,bb);\n\tif(aa!=bb && !tmp_edge.count(aa*mod + bb)){\n\t  g[aa].pb(bb);\n\t  g[bb].pb(aa);\n\t  tmp_edge.insert(aa*mod + bb);\n\t  deg[aa]--; deg[bb]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, int id){\n  stack<int> s;\n  s.push(id);\n\n  while(s.sz){\n    id = s.top(); s.pop();\n    \n    //for join\n    while(t[id].first.size()>2){\n      vi child(2);\n      child[0] = t[id].first.back(); t[id].first.pop_back();\n      child[1] = t[id].first.back(); t[id].first.pop_back();\n      t.push_back(make_pair(child, t[id].second));\n      t[id].first.push_back(t.size()-1);\n    }\n\n    if(t[id].first.size()==2){\n      rep(i,2){\n\tconst int &j = t[id].first[i];\n\tif(t[id].second != t[j].second){\n\t  vi child(1);\n\t  child[0] = j;\n\t  t.push_back(make_pair(child, t[id].second));\n\t  t[id].first[i] = t.size()-1;\n\t}\n      }\n    }\n\n    //for introduce & forget\n    if(t[id].first.size()==1){\n      const int &j = t[id].first[0];\n      vi child(1);\n      child[0] = j;\n      \n      vi disA, disB;\n      rep(a,t[id].second.size()){\n\tbool f = true;\n\trep(b,t[j].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disA.push_back(a);\n      }\n      rep(b,t[j].second.size()){\n\tbool f = true;\n\trep(a,t[id].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disB.push_back(b);\n      }\n      \n      if(disA.size() + disB.size() > 1){\n\tif(disA.size()>0){\n\t  vi tmp = t[id].second;\n\t  tmp.erase(tmp.begin() + disA[0]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}else{\n\t  vi tmp = t[id].second;\n\t  tmp.push_back(t[j].second[disB[0]]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}      \n      }\n    }\n    \n    //for leaf\n    if(t[id].first.size() == 0){\n      if(t[id].second.size() > 1){\n\tvi tmp;\n\trep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n\tt.push_back(make_pair(vi(), tmp));\n\tt[id].first.push_back(t.size()-1);\n      }\n    }\n\n    rep(i,t[id].first.size()){\n      s.push(t[id].first[i]);\n    }\n  }\n}\n\nunordered_map<ll,ll> memo;\n\nll rec(int id, int use, const TD &t){\n  ll key = mod*id + use;\n\n  stack<ll> s;\n  s.push(key);\n\n  while(s.sz){\n    ll res = 0;\n    key = s.top(); s.pop();\n    id = key/mod; use = key%mod;\n    const vi& child = t[id].fs, bag = t[id].sc;\n    \n    //for leaf\n    if(child.sz==0){\n      memo[key] = use;\n      goto END;\n    }\n    \n    if(child.sz==1){\n      const vi &nbag = t[child[0]].second;\n      vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n      rep(i,bag.size())rep(j,nbag.size()){\n\tif(bag[i] == nbag[j]){\n\t  to_bag[j] = i; to_nbag[i] = j;\n\t}\n      }\n      \n      //for introduce\n      if(nbag.sz < bag.sz){\n\tint nuse = 0;\n\trep(i,bag.sz){\n\t  if(to_nbag[i]<0){\n\t    if( ((use>>i)&1) == 0 ){\n\t      memo[key] = 0;\n\t      goto END;\n\t    }\n\t  }else{\n\t    if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t  }\n\t}\n\tll nxt = child[0]*mod + nuse;\n\tif(memo.count(nxt)){\n\t  memo[key] = memo[nxt];\n\t  goto END;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n      }\n      \n      //for forget\n      if(nbag.sz > bag.sz){\n\tint add = -1,  nuse = 0;\n\trep(i,nbag.sz){\n\t  if(to_bag[i]<0)add = i;\n\t  else if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n\t}\n\t\n\tqueue<ll> uncal;\n\tll res = 0, nxt = child[0]*mod + nuse;\n\tif(memo.count(nxt)){\n\t  (res += memo[nxt]) %= mod;\n\t}else{\n\t  uncal.push(nxt);\n\t}\n\n\trep(i,bag.sz){\n\t  if((use>>i)&1)continue;\n\t  \n\t  int a = bag[i], b = nbag[add];\n\t  if(a>b)swap(a,b);\n\t  if(is_edge.count(a*mod + b)){\n\t    nxt = child[0]*mod + (nuse | (1<<add) | (1<<to_nbag[i]));\n\t    if(memo.count(nxt)){\n\t      (res += memo[nxt]) %= mod;\n\t    }else{\n\t      uncal.push(nxt);\n\t    }\n\t  }\n\t}\n\n\tif(uncal.sz){\n\t  s.push(key); while(uncal.sz){ s.push(uncal.front()); uncal.pop(); }\n\t  goto END;\n\t}else{\n\t  memo[key] = res;\n\t  goto END;\n\t}\n      }\n    }\n    \n    //for join\n    if(child.sz==2){\n      int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n      queue<ll> uncal;\n      do{\n\tll nxt1 = child[0]*mod + (use|sub), nxt2 = child[1]*mod + (use|(unuse-sub));\n\tif(memo.count(nxt1) == 0){\n\t  uncal.push(nxt1);\n\t}\n\tif(memo.count(nxt2) == 0){\n\t  uncal.push(nxt2);\n\t}\n\tif(memo.count(nxt1) && memo.count(nxt2)){\n\t  res += memo[nxt1] * memo[nxt2];\n\t  res %= mod;\n\t}\n\tsub = (sub-1)&unuse;\n      }while(sub != unuse);\n    \n      if(uncal.sz){\n\ts.push(key); while(uncal.sz){ s.push(uncal.front()); uncal.pop(); }\n\tgoto END;\n      }else{\n\tmemo[key] = res;\n\tgoto END;\n      }\n    }\n  END:;\n  }\n  return memo[key];\n}\n\nvoid visg(vector<vi> g){\n  int n = g.size();\n  cout << \"graph {\" << endl;\n  rep(i,n){\n    rep(k,g[i].sz){\n      if(i<g[i][k]){\n\tcout << \"  \\\"\" << i << \" \";\n\tcout << \"\\\" -- \\\"\" << g[i][k] << \" \";\n\tcout << \"\\\"\" << endl;\n      }\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nvoid vis(TD t){\n  int n = t.size();\n  cout << \"digraph {\" << endl;\n  rep(i,n){\n    rep(k,t[i].first.size()){\n      int nxt = t[i].first[k];\n      cout << \"  \\\"\" << i << \": \";\n      rep(j,t[i].second.size())cout << t[i].second[j] << \" \";\n      cout << \"\\\" -> \\\"\" << nxt << \": \";\n      rep(j,t[nxt].second.size())cout << t[nxt].second[j] << \" \";\n      cout << \"\\\"\" << endl;\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nint main(){\n  int n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    vector<vi> g(n);\n    is_edge.clear();\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*mod + b);\n      else is_edge.insert(b*mod + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*mod + b);\n      else is_edge.insert(b*mod + a);\n    }\n\n    //visg(g);\n    TD t = heuristic_tree_decomposition(g);\n    g.clear();\n    //cout << t.size() << endl;\n    //vis(t);\n    toNice(t,0);\n    //cout << t.size() << endl;\n    //vis(t);\n\n    ll res = 0;\n    memo.clear();\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      res += rec(0,use,t);\n      res %= mod;\n    }\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define MOD (1000003LL)\ntypedef long long Int;\n\nint n, mi, cs[60000][2];\nvector<int> g[60000];\nbool has[60000];\nint dp[60000][2][2];\n\ninline int f(int k, int x, int y) { return k == -1 ? x==y : dp[k][x][y]; }\n\nvoid add(int p, int q) {\n    if (p > q) swap(p, q);\n    g[p].push_back(q);\n}\n\nint pre(int p, int q) {\n    if (p+1 == q) return -1;\n    const int k = mi++;\n    has[k] = false;\n    if (g[p].back() == q) {\n        has[k] = true;\n        g[p].pop_back();\n    }\n    const int r = g[p].back();\n    cs[k][0] = pre(p, r);\n    cs[k][1] = pre(r, q);\n    return k;\n}\n\nint main() {\n    for (;;) {\n        int m, a, b;\n        scanf(\"%d%d\", &n, &m);\n        if (n == 0) return 0;\n        rep (_, m) {\n            scanf(\"%d%d\", &a, &b);\n            add(a-1, b-1);\n        }\n        rep (i, n) add(i, (i+1)%n);\n        rep (i, n) sort(g[i].begin(), g[i].end());\n        mi = 0;\n        pre(0, n-1);\n        for (int k = mi-1; k >= 0; k--) rep (x, 2) rep (y, 2) {\n            const int p = cs[k][0], q = cs[k][1];\n            Int ans = 0;\n            ans += (Int)f(p, x, 0) * f(q, 1, y);\n            ans += (Int)f(p, x, 1) * f(q, 0, y);\n            if (x && y && has[k]) {\n                ans += (Int)f(p, 0, 0) * f(q, 1, 0);\n                ans += (Int)f(p, 0, 1) * f(q, 0, 0);\n            }\n            dp[k][x][y] = ans % MOD;\n        }\n        printf(\"%d\\n\", dp[0][1][1]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define MOD (1000003LL)\ntypedef long long Int;\n\nint n, mi, memo[60000*4], cs[60000][2];\nvector<int> g[60000];\nbool has[60000];\n\nvoid add(int p, int q) {\n    if (p > q) swap(p, q);\n    g[p].push_back(q);\n}\n\nint pre(int p, int q) {\n    if (p+1 == q) return -1;\n    const int k = mi++;\n    has[k] = false;\n    if (g[p].back() == q) {\n        has[k] = true;\n        g[p].pop_back();\n    }\n    const int r = g[p].back();\n    rep (b, 4) memo[k*4|b] = -1;\n    cs[k][0] = pre(p, r);\n    cs[k][1] = pre(r, q);\n    return k;\n}\n\nint rec(int k, int x, int y) {\n    if (k == -1) return x == y;\n    const int sig = k*4|x*2|y;\n    if (memo[sig] != -1) return memo[sig];\n    const int p = cs[k][0], q = cs[k][1];\n    Int ans = 0;\n    rep (i, 2) ans = (ans + (Int)rec(p, x, i)*rec(q, 1-i, y)) % MOD;\n    if (x && y && has[k]) {\n        rep (i, 2) ans = (ans + (Int)rec(p, 0, i)*rec(q, 1-i, 0)) % MOD;\n    }\n    return memo[sig] = ans;\n}\n\nint main() {\n    for (;;) {\n        int m, a, b;\n        scanf(\"%d%d\", &n, &m);\n        if (n == 0) return 0;\n        rep (i, 60000) g[i].clear();\n        rep (_, m) {\n            scanf(\"%d%d\", &a, &b);\n            add(a-1, b-1);\n        }\n        rep (i, n) add(i, (i+1)%n);\n        rep (i, n) sort(g[i].begin(), g[i].end());\n        mi = 0;\n        pre(0, n-1);\n        printf(\"%d\\n\", (int)rec(0, 1, 1));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\ntypedef long long ll;\ntypedef vector<int> vi;\nconst int MOD = 1000003;\nint n, m;\nvector<vi> g;\n\nvi solve(int l, int r, int gi){\n\tvi res(2, 1);\n\tfor(int i=l;i<r;i++){\n\t\tif(gi < g[i].size()){\n\t\t\tvi ret = solve(i, g[i][gi], gi+1);\n\t\t\tREP(j, 2) res[j] = (ll)res[j]*ret[j]%MOD;\n\t\t\ti = g[i][gi]-1;\n\t\t}\n\t\tswap(res[0], res[1]);\n\t\tgi = 0;\n\t}\n\tswap(res[0], res[1]);\n\tif(r-l > 1) res[1] -= ((res[1] = res[1] + res[0]) >= MOD) ? MOD : 0;\n\treturn res;\n}\n\nint main(){\n\twhile(~scanf(\"%d%d\", &n, &m), n){\n\t\tg = vector<vi>(n);\n\t\tREP(i, m){\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v);u--; v--;\n\t\t\tif(v < u) swap(u, v);\n\t\t\tif(((u^v)&1)) g[u].push_back(v);\n\t\t}\n\t\tREP(i, n) sort(g[i].rbegin(), g[i].rend());\n\t\tprintf(\"%d\\n\", n%2 ? 0 : (int)solve(0, n-1, 0)[1]);\n\t}\n\treturn 0;\n}\n\nlong long esp_org, esp_new;\n\nint main_(){\n    //  ??°????????????????????????????¢??????????\n    const int size = 50*1024*1024;\n    void *p = malloc(size);\n    esp_new = (long long)p + size - 1;\n\n    //  ??????????????????????????????\n    __asm__(\"mov %rsp, esp_org\");\n    __asm__(\"mov esp_new, %rsp\");\n    \n    //  ??????????????????\n    main_();\n    //  ???????????????????????????\n   __asm__(\"mov esp_org, %rsp\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\n\nconst int MOD=1000003;\nint N,M;\nvector<vector<int> > L;\nint ans=0;\nmap<pair<int,int> ,int> memo;\n\n\nlong long calc(int start,int end){\n//\tcout<<\"do \"<<start<<\" \"<<end<<endl;\n\tif((end-start)%2==0) return 0;\n\tif(start>end) return 1;\n\tif(memo.count(make_pair(start,end))) return memo[make_pair(start,end)];\n\tlong long res=1;\n\n\tint now=start;\n\tif(L[now].size()==0){\n\t\twhile(now<=end && L[now].size()==0) now+=2;\n\t\treturn calc(now,end);\n\t}\n\telse{\n\t\tres=0;\n\t\tfor(int k=0;k<L[now].size();k++){\n\t\t\tres+=(calc(now+1,L[now][k]-1)*calc(L[now][k]+1,end))%MOD;\n\t\t\tres%=MOD;\n\t\t}\n\t}\n\tres+=calc(now+2,end);\n\tres%=MOD;\n\tmemo[make_pair(start,end)]=res;\n//\tcout<<\"res \"<<start<<\" \"<<end<<\" :\"<<res<<endl;\n\treturn res%MOD;\n}\n\nint main()\n{\n\twhile(cin>>N>>M && N!=0){\n\t\tmemo.clear();\n\t\tL.clear();\n\t\tL.resize(N,vector<int>());\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint in,out;cin>>in>>out;\n\t\t\tin--;out--;\n\t\t\tif(in<out)\n\t\t\t\tL[in].push_back(out);\n\t\t\telse\n\t\t\t\tL[out].push_back(in);\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tsort(L[i].begin(),L[i].end());\n\t\t\tL[i].erase(unique(L[i].begin(),L[i].end()),L[i].end());\n\t\t}\n\t\tcout<<(calc(0,N-1)+calc(1,N-2))%MOD<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\n\nconst int MOD=1000003;\nint N,M;\nvector<vector<int> > L;\nint ans=0;\nmap<pair<int,int> ,int> memo;\n\n\nlong long calc(int start,int end){\n//\tcout<<\"do \"<<start<<\" \"<<end<<endl;\n\tif((end-start)%2==0) return 0;\n\tif(start>end) return 1;\n\tif(memo.count(make_pair(start,end))) return memo[make_pair(start,end)];\n\tlong long res=1;\n\n\tint now=start;\n\tif(L[now].size()==0){\n\t\twhile(now<=end && L[now].size()==0) now+=2;\n\t\treturn calc(now,end);\n\t}\n\n\tfor(int k=0;k<L[now].size();k++){\n\t\tlong long a=1;\n\t\tif(L[now][k]+1<end) a=calc(L[now][k]+1,end);\n\t\tres+=(calc(now+1,L[now][k]-1)*a)%MOD;\n\t\tres%=MOD;\n\t}\n\tif(now+2<end)\n\t\tres+=calc(now+2,end);\n\tres%=MOD;\n\tmemo[make_pair(start,end)]=res;\n//\tcout<<\"res \"<<start<<\" \"<<end<<\" :\"<<res<<endl;\n\treturn res%MOD;\n}\n\nint main()\n{\n\twhile(cin>>N>>M && N!=0){\n\t\tmemo.clear();\n\t\tL.clear();\n\t\tL.resize(N,vector<int>());\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint in,out;cin>>in>>out;\n\t\t\tin--;out--;\n\t\t\tif(in<out)\n\t\t\t\tL[in].push_back(out);\n\t\t\telse\n\t\t\t\tL[out].push_back(in);\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tsort(L[i].begin(),L[i].end());\n\t\t\tL[i].erase(unique(L[i].begin(),L[i].end()),L[i].end());\n\t\t}\n\t\tcout<<(calc(0,N-1)+calc(1,N-2))%MOD<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n\nconst int mod = 1000003;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct line {\n\tint a;\n\tint b;\n};\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<pair<int, int>>ps;\n\t\tint offset=-1;\n\t\tint mindis = N;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tif (a == b)continue;\n\t\t\tif (a > b)swap(a, b);\n\t\t\tassert(a < b);\n\t\t\tif (b - a == 1 || (N - (b - a) == 1))continue;\n\t\t\tps.push_back(make_pair(a, b));\n\t\t\tif (mindis > min(b-a, N - (b-a))) {\n\t\t\t\tmindis = min(b-a, N - (b-a));\n\t\t\t\tif (b-a < N - (b-a)) {\n\t\t\t\t\toffset = (a + b) / 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toffset = (N + a + b) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (auto&p : ps) {\n\t\t\tp.first = (p.first+N-offset)% N;\n\t\t\tp.second = (p.second+N - offset) % N;\n\t\t\tif (p.second < p.first)swap(p.first, p.second);\n\t\t}\n\t\tsort(ps.begin(), ps.end(), [](const pair<int, int>&l, const pair<int, int>&r) {\n\t\t\treturn l.first == r.first ? l.second > r.second : l.first < r.first;\n\t\t});\n\t\tfor (auto&p : ps) {\n\t\t\tp.second = N - p.second;\n\t\t}\n\t\tvector<vector<vector<line>>>ls(2,vector<vector<line>>(2));\n\t\tfor (const auto&p : ps) {\n\t\t\tls[p.first % 2][p.second % 2].push_back(line{ p.first,p.second });\n\t\t}\n\t\tvector<vector<Mod>>sums(2, vector<Mod>(2));\n\t\t//vector<vector<int>>dp(N + 1,vector<int>(2));\n\t\t//dp[0][0] = 0;\n\t\tsums[1][0] = 1;\n\t\tsums[0][1] = 1;\n\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\n\t\t\tsums[ps[i].first % 2][ps[i].second % 2] += sums[!(ps[i].first % 2)][!(ps[i].second % 2)];\n\n\t\t\t\n\t\t\t//if ((ps[i].first + ps[i].second) % 2)sums[ps[i].first % 2][ps[i].second % 2]++;\n\t\t}\n\t\tint ans = sums[0][!(N % 2)] + sums[1][(N % 2)];\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n \n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <cassert>\n#include <unistd.h>\n#include <cstdio>\n#include <cstdlib>\n#include <stack>\n#include <random>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int MN = 50500; \nconst int MD = 1000003;\n\nint n, m;\nvector<int> g[MN];\n\n\nmap<P, int> dp;\nll calc(int l, int r) {\n    if (l-1 == r) return 1;\n    if (dp.count(P(l, r))) {\n        return dp[P(l, r)];\n    }\n    int res = 0;\n    for (int d: g[l]) {\n        if (d <= l || r < d) continue;\n        res += calc(l+1, d-1)*calc(d+1, r);\n        res %= MD;\n    }\n    dp[P(l, r)] = res;\n    return res;\n}\n\nint solve() {\n    for (int i = 0; i < n; i++) {\n        g[i].clear();\n    }\n    dp.clear();\n    for (int i = 0; i < n-1; i++) {\n        g[i].push_back(i+1);\n        g[i+1].push_back(i);\n    }\n    g[n-1].push_back(0);\n    g[0].push_back(n-1);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        assert(a != b);\n        if (a > b) swap(a, b);\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    return calc(0, n-1);\n}\n\nint main() {\n    while (true) {\n        cin >> n >> m;\n        if (!n) break;\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n\nconst int mod = 1000003;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct line {\n\tint id;\n\tint a;\n\tint b;\n};\n\nvoid dfs(const int now,int&a,const vector<line>&ps,vector<vector<int>>&edges) {\n\tint nowl = ps[now].a;\n\tint nowr = ps[now].b;\n\ta++;\n\twhile (a != ps.size()) {\n\t\tconst int nextl = ps[a].a;\n\t\tconst int nextr = ps[a].b;\n\t\tif (nowl <= nextl&&nextr <= nowr) {\n\t\t\tedges[now].push_back(a);\n\t\t\tdfs(a, a, ps, edges);\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\t}\n}\npair<Mod, Mod>getans(const int now, const vector<line>&ps, const vector<vector<int>>&edges) {\n\t\n\t\tpair<Mod, Mod>ans(1, 1);\n\t\tfor (auto e : edges[now]) {\n\t\t\tconst auto p(getans(e, ps, edges));\n\t\t\tans.first *=p.first;\n\t\t\tans.second *= p.second;\n\t\t}\n\t\tif (!now)return ans;\n\t\tif (ps[now].a % 2)ans.first +=ans.second;\n\t\telse ans.second += ans.first;\n\t\treturn ans;\n\t\n}\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<line>ps;\n\t\tint offset=-1;\n\t\tint mindis = N;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tif (a == b)continue;\n\t\t\tif (a > b)swap(a, b);\n\t\t\tassert(a <= b);\n\t\t\tif (b - a == 1 || (N - (b - a) == 1)||(a-b)%2==0)continue;\n\t\t\tps.push_back(line{ i,a,b });\n\t\t}\n\t\tif (N % 2) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tps.push_back(line{ -1,0,N });\n\t\t\n\t\tsort(ps.begin(), ps.end(), [](const line&l, const line&r) {\n\t\t\treturn l.a == r.a ? l.b > r.b : l.a < r.a;\n\t\t});\n\t\t\n\t\tvector<vector<int>>edges(ps.size());\n\t\tint a (0);\n\t\tdfs(0, a, ps, edges);\n\t\tauto ans = getans(0, ps,edges);\n\t\tcout << ans.first + ans.second << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n \n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <cassert>\n#include <unistd.h>\n#include <cstdio>\n#include <cstdlib>\n#include <stack>\n#include <random>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, bool> T;\nconst int MN = 50500; \nconst int MD = 1000003;\n\nint n, m;\nvector<int> g[MN];\n\n\nmap<T, ll> dp;\nll calc(int l, int r, bool f) {\n    if (l-1 == r) return 1;\n    if (l == r-1) return f;\n    assert((r-l)%2);\n    if (dp.count(T(l, r, f))) {\n        return dp[T(l, r, f)];\n    }\n    ll res = 0;\n    if (f) {\n        auto it = upper_bound(g[l].begin(), g[l].end(), r);\n        assert(it != g[l].begin()); it--;\n        int u = *it;\n        res = calc(l+1, u-1, true)*calc(u+1, r, true)%MD + calc(l, u, false)*calc(u+1, r, true)%MD;\n        res %= MD;\n        dp[T(l, r, f)] = res;\n        return res;\n    }\n    for (int d: g[l]) {\n        if (f) {\n            if (r < d) break;\n        } else {\n            if (r <= d) break;\n        }\n        res += calc(l+1, d-1, true)*calc(d+1, r, true);\n        res %= MD;\n    }\n    dp[T(l, r, f)] = res;\n    return res;\n}\nint solve() {\n    if (n % 2) return 0;\n    for (int i = 0; i < n; i++) {\n        g[i].clear();\n    }\n    dp.clear();\n    for (int i = 0; i < n-1; i++) {\n        g[i].push_back(i+1);\n    }\n    g[0].push_back(n-1);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b; a--; b--;\n        assert(a != b);\n        if (a > b) swap(a, b);\n        if ((b-a) % 2 == 0) continue;\n        g[a].push_back(b);\n    }\n    for (int i = 0; i < n; i++) {\n        sort(g[i].begin(), g[i].end());\n    }\n    return calc(0, n-1, true);\n}\n\nint main() {\n    while (true) {\n        cin >> n >> m;\n        if (!n) break;\n        cout << solve() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n\nconst int mod = 1000003;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\tassert(b.num != 0);\n\treturn Mod(a) * inv(b);\n}\nMod operator/=(Mod &a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a = a * inv(b);\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init() {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < MAX_MOD_N - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct line {\n\tint a;\n\tint b;\n};\nint main() {\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tvector<pair<int, int>>ps;\n\t\tint offset=-1;\n\t\tint mindis = N;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tif (a == b)continue;\n\t\t\tif (a > b)swap(a, b);\n\t\t\tassert(a < b);\n\t\t\tif (b - a == 1 || (N - (b - a) == 1))continue;\n\t\t\tps.push_back(make_pair(a, b));\n\t\t\tif (mindis > min(b-a, N - (b-a))) {\n\t\t\t\tmindis = min(b-a, N - (b-a));\n\t\t\t\tif (b-a < N - (b-a)) {\n\t\t\t\t\toffset = (a + b) / 2;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toffset = (N + a + b) / 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (auto&p : ps) {\n\t\t\tp.first = (p.first+N-offset)% N;\n\t\t\tp.second = (p.second+N - offset) % N;\n\t\t\tif (p.second < p.first)swap(p.first, p.second);\n\t\t}\n\t\tsort(ps.begin(), ps.end(), [](const pair<int, int>&l, const pair<int, int>&r) {\n\t\t\treturn l.first == r.first ? l.second > r.second : l.first < r.first;\n\t\t});\n\t\tfor (auto&p : ps) {\n\t\t\tp.second = N - p.second;\n\t\t}\n\t\tvector<vector<vector<line>>>ls(2,vector<vector<line>>(2));\n\t\tfor (const auto&p : ps) {\n\t\t\tls[p.first % 2][p.second % 2].push_back(line{ p.first,p.second });\n\t\t}\n\t\tvector<vector<int>>sums(2, vector<int>(2));\n\t\t//vector<vector<int>>dp(N + 1,vector<int>(2));\n\t\t//dp[0][0] = 0;\n\t\tsums[1][0] = 1;\n\t\tsums[0][1] = 1;\n\t\tfor (int i = 0; i < ps.size(); ++i) {\n\t\t\t\n\t\t\tsums[ps[i].first % 2][ps[i].second % 2] += sums[!(ps[i].first % 2)][!(ps[i].second % 2)];\n\n\t\t\t\n\t\t\t//if ((ps[i].first + ps[i].second) % 2)sums[ps[i].first % 2][ps[i].second % 2]++;\n\t\t}\n\t\tint ans = sums[0][!(N % 2)] + sums[1][(N % 2)];\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define MOD (1000003LL)\ntypedef long long Int;\n\nint n, mi, memo[60000*4], cs[60000][2];\nvector<int> g[60000];\nbool has[60000];\n\nvoid add(int p, int q) {\n    if (p > q) swap(p, q);\n    g[p].push_back(q);\n}\n\nint pre(int p, int q) {\n    if (p+1 == q) return -1;\n    const int k = mi++;\n    has[k] = false;\n    if (g[p].back() == q) {\n        has[k] = true;\n        g[p].pop_back();\n    }\n    const int r = g[p].back();\n    rep (b, 4) memo[k*4|b] = -1;\n    cs[k][0] = pre(p, r);\n    cs[k][1] = pre(r, q);\n    return k;\n}\n\nint rec(int k, int b) {\n    if (k == -1) return b == 0 || b == 3;\n    const int sig = k*4|b;\n    if (memo[sig] != -1) return memo[sig];\n    const int x = b&2, y = b&1;\n    const int p = cs[k][0], q = cs[k][1];\n    Int ans = 0;\n    ans += (Int)rec(p, x) * rec(q, 2|y);\n    ans += (Int)rec(p, x|1) * rec(q, y);\n    if (b==3 && has[k]) {\n        ans += (Int)rec(p, 0) * rec(q, 2);\n        ans += (Int)rec(p, 1) * rec(q, 0);\n    }\n    return memo[sig] = ans % MOD;\n}\n\nint main() {\n    for (;;) {\n        int m, a, b;\n        scanf(\"%d%d\", &n, &m);\n        if (n == 0) return 0;\n        rep (_, m) {\n            scanf(\"%d%d\", &a, &b);\n            add(a-1, b-1);\n        }\n        rep (i, n) add(i, (i+1)%n);\n        rep (i, n) sort(g[i].begin(), g[i].end());\n        mi = 0;\n        pre(0, n-1);\n        printf(\"%d\\n\", rec(0, 3));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define MOD (1000003LL)\ntypedef long long Int;\n\nint n, mi, cs[60000][2];\nvector<int> g[60000];\nbool has[60000];\nint dp[60000][2][2];\n\ninline int f(int k, int x, int y) { return k == -1 ? x==y : dp[k][x][y]; }\n\nvoid add(int p, int q) {\n    if (p > q) swap(p, q);\n    g[p].push_back(q);\n}\n\nint pre(int p, int q) {\n    if (p+1 == q) return -1;\n    const int k = mi++;\n    has[k] = false;\n    if (g[p].back() == q) {\n        has[k] = true;\n        g[p].pop_back();\n    }\n    const int r = g[p].back();\n    cs[k][0] = pre(p, r);\n    cs[k][1] = pre(r, q);\n    return k;\n}\n\nint main() {\n    for (;;) {\n        int m, a, b;\n        scanf(\"%d%d\", &n, &m);\n        if (n == 0) return 0;\n        rep (_, m) {\n            scanf(\"%d%d\", &a, &b);\n            add(a-1, b-1);\n        }\n        rep (i, n) add(i, (i+1)%n);\n        rep (i, n) sort(g[i].begin(), g[i].end());\n        mi = 0;\n        pre(0, n-1);\n        for (int k = mi-1; k >= 0; k--) rep (x, 2) rep (y, 2) {\n            const int p = cs[k][0], q = cs[k][1];\n            Int ans = 0;\n            ans += (Int)f(p, x, 0) * f(q, 1, y);\n            ans += (Int)f(p, x, 1) * f(q, 0, y);\n            if (x && y && has[k]) {\n                ans += (Int)f(p, 0, 0) * f(q, 1, 0);\n                ans += (Int)f(p, 0, 1) * f(q, 0, 0);\n            }\n            dp[k][x][y] = ans;\n        }\n        printf(\"%d\\n\", dp[0][1][1]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntypedef vector< pair<vi,vi> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\nset<ll> is_edge;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(vector<vi> g){\n  int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  set<ll> tmp_edge = is_edge;\n  rep(i,n){\n    deg[i] = g[i].sz; deg[i]*=-1;\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vi unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tif(a!=b && !tmp_edge.count(a*mod + b)){\n\t  g[a].pb(b);\n\t  g[b].pb(a);\n\t  tmp_edge.insert(a*mod + b);\n\t  tmp_edge.insert(b*mod + a);\n\t  deg[a]--; deg[b]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, int id){\n  stack<int> s;\n  s.push(id);\n\n  while(s.sz){\n    id = s.top(); s.pop();\n    \n    //for join\n    while(t[id].first.size()>2){\n      vi child(2);\n      child[0] = t[id].first.back(); t[id].first.pop_back();\n      child[1] = t[id].first.back(); t[id].first.pop_back();\n      t.push_back(make_pair(child, t[id].second));\n      t[id].first.push_back(t.size()-1);\n    }\n\n    if(t[id].first.size()==2){\n      rep(i,2){\n\tconst int &j = t[id].first[i];\n\tif(t[id].second != t[j].second){\n\t  vi child(1);\n\t  child[0] = j;\n\t  t.push_back(make_pair(child, t[id].second));\n\t  t[id].first[i] = t.size()-1;\n\t}\n      }\n    }\n\n    //for introduce & forget\n    if(t[id].first.size()==1){\n      const int &j = t[id].first[0];\n      vi child(1);\n      child[0] = j;\n      \n      vi disA, disB;\n      rep(a,t[id].second.size()){\n\tbool f = true;\n\trep(b,t[j].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disA.push_back(a);\n      }\n      rep(b,t[j].second.size()){\n\tbool f = true;\n\trep(a,t[id].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disB.push_back(b);\n      }\n      \n      if(disA.size() + disB.size() > 1){\n\tif(disA.size()>0){\n\t  vi tmp = t[id].second;\n\t  tmp.erase(tmp.begin() + disA[0]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}else{\n\t  vi tmp = t[id].second;\n\t  tmp.push_back(t[j].second[disB[0]]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}      \n      }\n    }\n    \n    //for leaf\n    if(t[id].first.size() == 0){\n      if(t[id].second.size() > 1){\n\tvi tmp;\n\trep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n\tt.push_back(make_pair(vi(), tmp));\n\tt[id].first.push_back(t.size()-1);\n      }\n    }\n\n    rep(i,t[id].first.size()){\n      s.push(t[id].first[i]);\n    }\n  }\n}\n\nunordered_map<ll,ll> memo;\n\nll rec(int id, int use, const TD &t){\n  ll key = mod*id + use;  \n  if(memo.count(key))return memo[key];\n\n  const vi& child = t[id].fs, bag = t[id].sc;\n  \n  //for leaf\n  if(child.sz==0)return use;\n\n  ll res = 0;\n  if(child.sz==1){\n    const vi &nbag = t[child[0]].second;\n    vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n    rep(i,bag.size())rep(j,nbag.size()){\n      if(bag[i] == nbag[j]){\n\tto_bag[j] = i; to_nbag[i] = j;\n      }\n    }\n\n    //for introduce\n    if(nbag.sz < bag.sz){\n      int nuse = 0;\n      rep(i,bag.sz){\n\tif(to_nbag[i]<0){\n\t  if( ((use>>i)&1) == 0 )return memo[key] = 0;\n\t}else{\n\t  if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t}\n      }\n      return memo[key] = rec(child[0],nuse,t);\n    }\n\n    //for forget\n    if(nbag.sz > bag.sz){\n      int add = -1,  nuse = 0;\n      rep(i,nbag.sz){\n\tif(to_bag[i]<0)add = i;\n\telse if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n      }\n\n      ll res = 0;\n      (res += rec(child[0],nuse,t)) %= mod;\n\n      rep(i,bag.sz){\n\tif((use>>i)&1)continue;\n\n\tif(is_edge.count(bag[i]*mod + nbag[add])){\n\t  res += rec(child[0], nuse | (1<<add) | (1<<to_nbag[i]), t);\n\t  res %= mod;\n\t}\n      }\n      return memo[key] = res;\n    }\n  }\n\n  //for join\n  if(child.sz==2){\n    int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n    do{\n      res += rec(child[0],use|sub,t) * rec(child[1],use|(unuse-sub),t);\n      res %= mod;\n      sub = (sub-1)&unuse;\n    }while(sub != unuse);\n  }\n  return memo[key] = res % mod;\n}\n\nvoid visg(vector<vi> g){\n  int n = g.size();\n  cout << \"graph {\" << endl;\n  rep(i,n){\n    rep(k,g[i].sz){\n      if(i<g[i][k]){\n\tcout << \"  \\\"\" << i << \" \";\n\tcout << \"\\\" -- \\\"\" << g[i][k] << \" \";\n\tcout << \"\\\"\" << endl;\n      }\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nvoid vis(TD t){\n  int n = t.size();\n  cout << \"digraph {\" << endl;\n  rep(i,n){\n    rep(k,t[i].first.size()){\n      int nxt = t[i].first[k];\n      cout << \"  \\\"\" << i << \": \";\n      rep(j,t[i].second.size())cout << t[i].second[j] << \" \";\n      cout << \"\\\" -> \\\"\" << nxt << \": \";\n      rep(j,t[nxt].second.size())cout << t[nxt].second[j] << \" \";\n      cout << \"\\\"\" << endl;\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nint main(){\n  int n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    vector<vi> g(n);\n    is_edge.clear();\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      is_edge.insert(a*mod + b);\n      is_edge.insert(b*mod + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      is_edge.insert(a*mod + b);\n      is_edge.insert(b*mod + a);\n    }\n\n    //visg(g);\n    TD t = heuristic_tree_decomposition(g);\n    //cout << t.size() << endl;\n    //vis(t);\n    toNice(t,0);\n    //cout << t.size() << endl;\n    //vis(t);\n\n    ll res = 0;\n    memo.clear();\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      res += rec(0,use,t);\n      res %= mod;\n    }\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst int MOD=1000003;\nint x0;\nint n, m;\nint a[50000], b[50000];\nint solve(){\n\tif(n&1) return 0;\n\tif(m==0) return 2;\n\tvector<int> ind;\n\tint dmn=n, i0;\n\tfor(int i=0; i<m; i++){\n\t\tint d1=b[i]-a[i];\n\t\tif(d1%2==0) continue;\n\t\tind.push_back(i);\n\t\tif(dmn>min(d1, n-d1)){\n\t\t\ti0=i;\n\t\t\tdmn=min(d1, n-d1);\n\t\t}\n\t}\n\tif(ind.empty()) return 2;\n\tif(b[i0]-a[i0]<=n/2){\n\t\tx0=a[i0]+b[i0];\n\t}else{\n\t\tx0=2*n-(a[i0]+b[i0]);\n\t}\n\tint d[50000];\n\tfor(auto i:ind){\n\t\tif(2*a[i]<x0 && x0<2*b[i]) d[i]=b[i]-a[i];\n\t\telse{\n\t\t\td[i]=n-(b[i]-a[i]);\n\t\t\tif(2*a[i]>x0) swap(a[i], b[i]);\n\t\t}\n\t}\n\tsort(ind.begin(), ind.end(), [&](int i, int j){ return d[i]<d[j];});\n\tint dp, s[2]={};\n\tfor(int i=0; i<ind.size(); i++){\n\t\tdp=1;\n\t\tif(a[ind[i]]&1){\n\t\t\tdp+=s[0];\n\t\t\tdp%=MOD;\n\t\t\ts[1]+=dp;\n\t\t\ts[1]%=MOD;\n\t\t}else{\n\t\t\tdp+=s[1];\n\t\t\tdp%=MOD;\n\t\t\ts[0]+=dp;\n\t\t\ts[0]%=MOD;\n\t\t}\n\t}\n\treturn (s[0]+s[1]+2)%MOD;\n}\nint main()\n{\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0) return 0;\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcin>>a[i]>>b[i];\n\t\t\ta[i]--; b[i]--;\n\t\t\tif(a[i]>b[i]) swap(a[i], b[i]);\n\t\t}\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct P {\n  int a, b;\n  P(int a, int b) : a(a),b(b) {}\n};\nbool operator<(const P &a, const P &b) {\n  return a.a != b.a ? a.a < b.a : a.b > b.b;\n}\nbool parity[50002][2];\nll dp[50002][2][2];\n\nll MOD = 1000003;\nint main() {\n  int n,m;\n  while(cin>>n>>m,n||m) {\n    vector<P> v;\n    v.push_back(P(0,n-1));\n    REP(i,m) {\n      int a, b;cin >> a >> b;\n      a--; b--;\n      v.push_back(P(a,b));\n    }\n    sort(ALL(v));\n    REP(i,m) {\n      parity[i][0] = (v[i+1].a-v[i].a) % 2;\n      parity[i][1] = (v[i].b-v[i+1].b) % 2;\n    }\n    memset(dp,0,sizeof(dp));\n    dp[0][0][0] = 1;\n    REP(i,m) {\n      // use edge i\n      (dp[i+1][!parity[i][0]][!parity[i][1]] += dp[i][0][0]) %= MOD;\n      // not use\n      REP(j,2) {\n        REP(k,2) {\n          //cout << dp[i][j][k] << \" \";\n          (dp[i+1][j^parity[i][0]][k^parity[i][1]] += dp[i][j][k]) %= MOD;\n        }\n      }\n      //cout << endl;\n    }\n    ll sum = 0;\n    if ((v[m].b-v[m].a) % 2 == 0) {\n      sum += dp[m][0][1];\n      sum += dp[m][1][0];\n    } else {\n      sum += dp[m][0][0] * 2;\n      sum += dp[m][1][1];\n    }\n    cout << sum % MOD << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define MOD (1000003LL)\ntypedef long long Int;\n\nint n, mi, cs[60000][2], dp[60000][2][2];\nvector<int> g[60000];\nbool has[60000];\n\ninline int f(int k, int x, int y) { return k == -1 ? x==y : dp[k][x][y]; }\n\nvoid add(int p, int q) {\n    if (p > q) swap(p, q);\n    g[p].push_back(q);\n}\n\nint pre(int p, int q) {\n    if (p+1 == q) return -1;\n    const int k = mi++;\n    has[k] = 0;\n    if (g[p].back() == q) has[k] = 1, g[p].pop_back();\n    const int r = g[p].back();\n    cs[k][0] = pre(p, r);\n    cs[k][1] = pre(r, q);\n    return k;\n}\n\nint main() {\n    for (;;) {\n        int m, a, b;\n        scanf(\"%d%d\", &n, &m);\n        if (n == 0) return 0;\n        rep (_, m) {\n            scanf(\"%d%d\", &a, &b);\n            add(a-1, b-1);\n        }\n        rep (i, n) add(i, (i+1)%n);\n        rep (i, n) sort(g[i].begin(), g[i].end());\n        mi = 0;\n        pre(0, n-1);\n        for (int k = mi-1; k >= 0; k--) {\n            const int p = cs[k][0], q = cs[k][1];\n#define F(x, y) ((Int)f(p, x, 0)*f(q, 1, y) + (Int)f(p, x, 1)*f(q, 0, y))\n            dp[k][0][0] = F(0, 0) % MOD;\n            dp[k][0][1] = F(0, 1) % MOD;\n            dp[k][1][0] = F(1, 0) % MOD;\n            dp[k][1][1] = F(1, 1);\n            if (has[k]) dp[k][1][1] += dp[k][0][0];\n            dp[k][1][1] %= MOD;\n        }\n        printf(\"%d\\n\", dp[0][1][1]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define rept(i,k,n) for(int i = (k); i < (int)(n); i++)\n#define MOD 1000003\ntypedef pair<int,int> Pii;\n\n\nint main(){\n    while(true){\n        int n,m;\n        cin>>n>>m;\n        if(n==0) return 0;\n        if(n%2){\n            cout<<0<<endl;\n            continue;\n        }\n        vector<Pii> edge(0);\n        rep(i,m){\n            int a,b;\n            cin>>a>>b;\n            a--;b--;\n            if(abs(a-b)%2==0) continue;\n            edge.push_back(Pii(min(a,b),max(a,b)));\n        }\n        sort(edge.begin(), edge.end(), [](Pii a,Pii b){return a.second-a.first < b.second-b.first;});\n        edge.push_back(Pii(0,n-1));\n        vector<Pii> dp(n); //Pii（最長道路、行き方)\n        rep(i,n-1) dp[i]=Pii(i+1,1);\n        for(Pii P : edge){\n            int a=P.first,b=P.second;\n            long long cnt=1,left=a+1;\n            while(left != b){\n                cnt *= dp[left].second;\n                cnt %= MOD;\n                left = dp[left].first+1;\n            }\n            dp[a+1]=Pii(b-1,cnt);\n            left=a;cnt=1;\n            while(left != b+1){\n                cnt *= dp[left].second;\n                cnt %= MOD;\n                left = dp[left].first+1;\n            }\n            dp[a]=Pii(b,(cnt+dp[a+1].second)%MOD);\n        }\n        cout<<dp[0].second<<endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define MOD (1000003LL)\ntypedef long long Int;\n\ntypedef pair<pair<int, int>, int> ST;\nint n;\nvector<int> g[60000];\nmap<ST, int> memo;\nset<pair<int, int> > es;\n\nvoid add(int p, int q) {\n    if (p > q) swap(p, q);\n    g[p].push_back(q);\n    es.insert(mp(p, q));\n}\n\nInt rec(int p, int q, int x, int y) {\n    if (p+1 == q) return x == y;\n    const ST sig(mp(p, q), x*2+y);\n    if (memo.count(sig)) return memo[sig];\n    const int r = *(lower_bound(g[p].begin(), g[p].end(), q)-1);\n    Int ans = 0;\n    rep (k, 2) ans = (ans + rec(p, r, x, k) * rec(r, q, 1-k, y)) % MOD;\n    if (x && y && es.count(mp(p, q))) {\n        rep (k, 2) ans = (ans + rec(p, r, 0, k) * rec(r, q, 1-k, 0)) % MOD;\n    }\n    return memo[sig] = ans;\n}\n\nint main() {\n    for (;;) {\n        int m, a, b;\n        scanf(\"%d%d\", &n, &m);\n        if (n == 0) return 0;\n        rep (i, 60000) g[i].clear();\n        es.clear();\n        rep (_, m) {\n            scanf(\"%d%d\", &a, &b);\n            add(a-1, b-1);\n        }\n        rep (i, n) add(i, (i+1)%n);\n        rep (i, n) sort(g[i].begin(), g[i].end());\n        memo.clear();\n        printf(\"%d\\n\", (int)rec(0, n-1, 1, 1));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nconst long long mod=1000003;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nint N,M;\nvector<int> G[50500];\n\nmap<PP,long long> dp;\n\nlong long solve(PP);\nlong long solve(int u,int v,int fu,int fv){\n\treturn solve(PP(P(u,v),P(fu,fv)));\n}\n\nlong long solve(PP pp){\n\tif(dp.count(pp)==1) return dp[pp];\n\tint u=pp.first.first,v=pp.first.second;\n\tint fu=pp.second.first,fv=pp.second.second;\n\tif(v==u+1){\n\t\tint res=(fu+fv)%2;\n\t\tres^=1;\n\t\tdp[pp]=res;\n\t\treturn res;\n\t}\n\tlong long res=0;\n\tint id=distance(G[u].begin(),lower_bound(G[u].begin(),G[u].end(),v));\n\tif(id>0&&G[u][id-1]>u){\n\t\tint w=G[u][id-1];\n\t\tres+=(solve(u,w,fu,1)*solve(w,v,0,fv));\n\t\tres%=mod;\n\t\tres+=(solve(u,w,fu,0)*solve(w,v,1,fv));\n\t\tres%=mod;\n\t/*\tif(fu==0){\n\t\t\tres+=(solve(u,w,1,1)*solve(w,v,1,fv));\n\t\t\tres%=mod;\n\t\t}*/\n\t\tif(fu==0&&fv==0&&binary_search(G[u].begin(),G[u].end(),v)){\n\t\t\tres+=(solve(u,w,1,0)*solve(w,v,1,1));\n\t\t\tres+=(solve(u,w,1,1)*solve(w,v,0,1));\n\t\t\tres%=mod;\n\t\t}\n\t}else{\n\t\tres+=solve(u+1,v,fu^1,fv);\n\t\tif(fu==0&&fv==0&&binary_search(G[u].begin(),G[u].end(),v)){\n\t\t\tres+=solve(u+1,v,0,1);\n\t\t}\n\t\tres%=mod;\n\t}\n\tdp[pp]=res;\n\treturn res;\n}\n\nvoid init(){\n\tmap<PP,long long> mp;\n\tswap(mp,dp);\n\tfor(int i=0;i<N;i++) G[i].clear();\n}\n\nvoid output(){\n\tmap<PP,long long>::iterator it=dp.begin();\n\tfor(;it!=dp.end();it++){\n\t\tPP pp=it->first;\n\t\tlong long val=it->second;\n\t\tprintf(\"%d %d %d %d =%lld\\n\",pp.first.first,pp.first.second,pp.second.first,pp.second.second,\n\t\tval);\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tinit();\n\t\tscanf(\"%d%d\",&N,&M);\n\t\tif(N==0) break;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t\tG[0].push_back(N-1);\n\t\tG[N-1].push_back(0);\n\t\tfor(int i=0;i<N;i++) sort(G[i].begin(),G[i].end());\n\t\tlong long ans=solve(0,N-1,0,0);\n\t\tans+=mod;\n\t\tans%=mod;\n\t//\toutput();\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint road[5000][5000];\nint n,m;\n\nint solve(int start, int end, int now){\n\tint i,j,sum=0;\n\tif(start+1==end){\n\t\treturn 1;\n\t}\n\tfor(i=start;i<=end;i++){\n\t\tint ret=1;\n\t\tif(!road[start][i] || !((start+i)%2)) continue;\n\t\tif(start+1!=i) ret=solve(start+1, i-1, now+1);\n\t\tif(i!=end) ret*=solve(i+1, end, now+1);\n\t\tsum+=ret;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tint i,j,a,b;\n\twhile(cin>>n>>m,n){\n\t\tmemset(road,0,sizeof(road));\n\t\tfor(i=1;i<=m;i++){\n\t\t\tcin>>a>>b;\n\t\t\troad[a][b]=road[b][a]=1;\n\t\t}\n\t\tfor(i=1;i<n;i++){\n\t\t\troad[i][i+1]=road[i+1][i]=1;\n\t\t}\troad[1][n]=road[n][1]=1;\n\t\tif(n%2) cout<<\"0\"<<endl;\n\t\telse cout<<solve(1,n,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef unsigned int ui;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<unsigned short> vs;\n\ntypedef vector< pair<vi,vs> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\nset<ui> is_edge;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(vector<vs> &g){\n  unsigned int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  set<ui> tmp_edge = is_edge;\n  rep(i,n){\n    deg[i] = g[i].sz; deg[i]*=-1;\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vs unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tui aa = a, bb = b;\n\tif(aa>bb)swap(aa,bb);\n\tif(aa!=bb && !tmp_edge.count(aa*n + bb)){\n\t  g[aa].pb(bb);\n\t  g[bb].pb(aa);\n\t  tmp_edge.insert(aa*n + bb);\n\t  deg[aa]--; deg[bb]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, int id){\n  stack<int> s;\n  s.push(id);\n\n  while(s.sz){\n    id = s.top(); s.pop();\n    \n    //for join\n    while(t[id].first.size()>2){\n      vi child(2);\n      child[0] = t[id].first.back(); t[id].first.pop_back();\n      child[1] = t[id].first.back(); t[id].first.pop_back();\n      t.push_back(make_pair(child, t[id].second));\n      t[id].first.push_back(t.size()-1);\n    }\n\n    if(t[id].first.size()==2){\n      rep(i,2){\n\tconst int &j = t[id].first[i];\n\tif(t[id].second != t[j].second){\n\t  vi child(1);\n\t  child[0] = j;\n\t  t.push_back(make_pair(child, t[id].second));\n\t  t[id].first[i] = t.size()-1;\n\t}\n      }\n    }\n\n    //for introduce & forget\n    if(t[id].first.size()==1){\n      const int &j = t[id].first[0];\n      vi child(1);\n      child[0] = j;\n      \n      vi disA, disB;\n      rep(a,t[id].second.size()){\n\tbool f = true;\n\trep(b,t[j].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disA.push_back(a);\n      }\n      rep(b,t[j].second.size()){\n\tbool f = true;\n\trep(a,t[id].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disB.push_back(b);\n      }\n      \n      if(disA.size() + disB.size() > 1){\n\tif(disA.size()>0){\n\t  vs tmp = t[id].second;\n\t  tmp.erase(tmp.begin() + disA[0]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}else{\n\t  vs tmp = t[id].second;\n\t  tmp.push_back(t[j].second[disB[0]]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}      \n      }\n    }\n    \n    //for leaf\n    if(t[id].first.size() == 0){\n      if(t[id].second.size() > 1){\n\tvs tmp;\n\trep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n\tt.push_back(make_pair(vi(), tmp));\n\tt[id].first.push_back(t.size()-1);\n      }\n    }\n\n    rep(i,t[id].first.size()){\n      s.push(t[id].first[i]);\n    }\n  }\n}\n\nunordered_map<int,int> memo;\n\ninline int dp(int id, int use, unsigned int n, const TD &t){\n  int key = 100*id + use;\n\n  int maxs = 0;\n  vector<int> s(t.sz);\n  int pos = 0;\n  s[pos++] = key;\n\n  while(pos){\n    ll res = 0;\n    key = s[--pos];\n    id = key/100; use = key%100;\n    const vi &child = t[id].fs;\n    const vs &bag = t[id].sc;\n    \n    //for leaf\n    if(child.sz==0){\n      memo[key] = use;\n      goto END;\n    }\n    \n    if(child.sz==1){\n      const vs &nbag = t[child[0]].second;\n      vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n      rep(i,bag.size())rep(j,nbag.size()){\n\tif(bag[i] == nbag[j]){\n\t  to_bag[j] = i; to_nbag[i] = j;\n\t}\n      }\n      \n      //for introduce\n      if(nbag.sz < bag.sz){\n\tint nuse = 0;\n\trep(i,bag.sz){\n\t  if(to_nbag[i]<0){\n\t    if( ((use>>i)&1) == 0 ){\n\t      memo[key] = 0;\n\t      goto END;\n\t    }\n\t  }else{\n\t    if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t  }\n\t}\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  memo[key] = memo[nxt];\n\t  goto END;\n\t}else{\n\t  s[pos++] = key; s[pos++] = nxt;\n\t  goto END;\n\t}\n      }\n      \n      //for forget\n      if(nbag.sz > bag.sz){\n\tint add = -1,  nuse = 0;\n\trep(i,nbag.sz){\n\t  if(to_bag[i]<0)add = i;\n\t  else if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n\t}\n\t\n\tll res = 0;\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  (res += memo[nxt]) %= mod;\n\t}else{\n\t  s[pos++] = key; s[pos++] = nxt;\n\t  goto END;\n\t}\n\n\trep(i,bag.sz){\n\t  if((use>>i)&1)continue;\n\t  \n\t  ui a = bag[i], b = nbag[add];\n\t  if(a>b)swap(a,b);\n\t  if(is_edge.count(a*n + b)){\n\t    nxt = child[0]*100 + (nuse | (1<<add) | (1<<to_nbag[i]));\n\t    if(memo.count(nxt)){\n\t      (res += memo[nxt]) %= mod;\n\t    }else{\n\t      s[pos++] = key; s[pos++] = nxt;\n\t      goto END;\n\t    }\n\t  }\n\t}\n\tmemo[key] = res;\n      }\n    }\n    \n    //for join\n    if(child.sz==2){\n      int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n      do{\n\tint nxt1 = child[0]*100 + (use|sub), nxt2 = child[1]*100 + (use|(unuse-sub));\n\tif(memo.count(nxt1) == 0){\n\t  s[pos++] = key; s[pos++] = nxt1;\n\t  goto END;\n\t}\n\tif(memo[nxt1]){\n\t  if(memo.count(nxt2) == 0){\n\t    s[pos++] = key; s[pos++] = nxt2;\n\t    goto END;\n\t  }\n\t  if(memo[nxt2]){\n\t    res += (ll)memo[nxt1] * memo[nxt2];\n\t    res %= mod;\n\t  }\n\t}\n\tsub = (sub-1)&unuse;\n      }while(sub != unuse);\n    \n      memo[key] = res;\n    }\n  END: maxs = max(maxs, (int)s.sz);\n  }\n  //cerr << maxs << endl;\n  return memo[key];\n}\n\nvoid visg(vector<vi> g){\n  int n = g.size();\n  cout << \"graph {\" << endl;\n  rep(i,n){\n    rep(k,g[i].sz){\n      if(i<g[i][k]){\n\tcout << \"  \\\"\" << i << \" \";\n\tcout << \"\\\" -- \\\"\" << g[i][k] << \" \";\n\tcout << \"\\\"\" << endl;\n      }\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nvoid vis(TD t){\n  int n = t.size();\n  cout << \"digraph {\" << endl;\n  rep(i,n){\n    rep(k,t[i].first.size()){\n      int nxt = t[i].first[k];\n      cout << \"  \\\"\" << i << \": \";\n      rep(j,t[i].second.size())cout << t[i].second[j] << \" \";\n      cout << \"\\\" -> \\\"\" << nxt << \": \";\n      rep(j,t[nxt].second.size())cout << t[nxt].second[j] << \" \";\n      cout << \"\\\"\" << endl;\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nint main(){\n  ui n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    vector<vs> g(n);\n    is_edge.clear();\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*n + b);\n      else is_edge.insert(b*n + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*n + b);\n      else is_edge.insert(b*n + a);\n    }\n\n    TD t = heuristic_tree_decomposition(g);\n    g.clear();\n    toNice(t,0);\n    //cerr << t.sz << endl;\n\n    ll res = 0;\n    memo.clear();\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      res += dp(0,use,n,t);\n      res %= mod;\n    }\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<utility>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nconst long long mod=1000003;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n\nint N,M;\nvector<int> G[50500];\n\nmap<PP,long long> dp;\n\nlong long solve(PP);\nlong long solve(int u,int v,int fu,int fv){\n\treturn solve(PP(P(u,v),P(fu,fv)));\n}\n\nlong long solve(PP pp){\n\tif(dp.count(pp)==1) return dp[pp];\n\tint u=pp.first.first,v=pp.first.second;\n\tint fu=pp.second.first,fv=pp.second.second;\n\tif(v==u+1){\n\t\tint res=(fu+fv)%2;\n\t\tres^=1;\n\t\tdp[pp]=res;\n\t\treturn res;\n\t}\n\tlong long res=0;\n\tint id=distance(G[u].begin(),lower_bound(G[u].begin(),G[u].end(),v));\n\tif(id>0&&G[u][id-1]>u){\n\t\tint w=G[u][id-1];\n\t\tres+=(solve(u,w,fu,1)*solve(w,v,0,fv));\n\t\tres%=mod;\n\t\tres+=(solve(u,w,fu,0)*solve(w,v,1,fv));\n\t\tres%=mod;\n\t\tif(fu==0){\n\t\t\tres+=(solve(u,w,1,1)*solve(w,v,0,fv));\n\t\t\tres%=mod;\n\t\t}\n\t\tif(fu==0&&fv==0&&binary_search(G[u].begin(),G[u].end(),v)){\n\t\t\tres+=(solve(u,w,1,0)*solve(w,v,1,1));\n\t\t\tres+=(solve(u,w,1,1)*solve(w,v,0,1));\n\t\t\tres%=mod;\n\t\t}\n\t}else{\n\t\tres+=solve(u+1,v,fu^1,fv);\n\t\tif(fu==0&&fv==0&&binary_search(G[u].begin(),G[u].end(),v)){\n\t\t\tres+=solve(u+1,v,0,1);\n\t\t}\n\t\tres%=mod;\n\t}\n\tdp[pp]=res;\n\treturn res;\n}\n\nvoid init(){\n\tmap<PP,long long> mp;\n\tswap(mp,dp);\n\tfor(int i=0;i<N;i++) G[i].clear();\n}\n\nvoid output(){\n\tmap<PP,long long>::iterator it=dp.begin();\n\tfor(;it!=dp.end();it++){\n\t\tPP pp=it->first;\n\t\tlong long val=it->second;\n\t\tprintf(\"%d %d %d %d =%lld\\n\",pp.first.first,pp.first.second,pp.second.first,pp.second.second,\n\t\tval);\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tinit();\n\t\tscanf(\"%d%d\",&N,&M);\n\t\tif(N==0) break;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t\tG[0].push_back(N-1);\n\t\tG[N-1].push_back(0);\n\t\tfor(int i=0;i<N;i++) sort(G[i].begin(),G[i].end());\n\t\tlong long ans=solve(0,N-1,0,0);\n\t\tans+=mod;\n\t\tans%=mod;\n\t//\toutput();\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000003\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nmap<ll,int>mem;\nint n,m;\nvector<int>edge[50005],redge[50005];\n\nint rec(int l,int r){\n\twhile(edge[l].empty() && l <= r) l += 2;\n\twhile(redge[r].empty() && l <= r) r -= 2;\n\tif(l > r) return 1;\n\tll ky = 50005 * l + r;\n\tif(mem.find(ky) != mem.end()) return mem[ky];\n\t//use first edge\n\tint ans = 0;\n\t//decreasing order\n\t//for(int i=edge[l].size()-1;i>=0;i--){\n\tfor(int i=0;i<edge[l].size();i++){\n\t\tif(edge[l][i] > r) continue;\n\t\tans += 1LL * rec(l+1,edge[l][i]-1) * rec(edge[l][i]+1,r) % mod;\n\t\tif(ans >= mod) ans -= mod;\n\t}\n\tans += rec(l+2,r);\n\tif(ans >= mod) ans -= mod;\n\treturn mem[ky] = ans;\n}\nint main(){\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m); if(n==0 && m==0) return 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tedge[i].clear();\n\t\t\tredge[i].clear();\n\t\t}\n\t\tmem.clear();\n\t\tedge[1].pb(n);\n\t\tredge[n].pb(1);\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\t\tif(a > b) swap(a,b);\n\t\t\tif(a%2 == b%2) continue;\n\t\t\tif(b-a == 1) continue;\n\t\t\tedge[a].pb(b);\n\t\t\tredge[b].pb(a);\n\t\t}\n\t\tif(n%2 == 1) {\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tSORT(edge[i]);\n\t\t\tERASE(edge[i]);\n\t\t\tSORT(redge[i]);\n\t\t\tERASE(redge[i]);\n\t\t\treverse(redge[i].begin(),redge[i].end());\n\t\t}\n\t\tcout << rec(1,n) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\n\nconst int MOD=1000003;\nint N,M;\nvector<vector<int> > L;\nint ans=0;\nmap<pair<int,int> ,int> memo;\n\nint calc(int start,int end){\n\tif((end-start)%2==0) return 0;\n\tif(start>end) return 1;\n\tif(memo.count(make_pair(start,end))) return memo[make_pair(start,end)];\n\tint res=1;\n\n\tfor(int now=start;now<end;now+=2){\n\t\tfor(int k=0;k<L[now].size();k++){\n\t\t\tres+=calc(now+1,L[now][k]-1)*calc(L[now][k]+1,end);\n\t\t\tres%=MOD;\n\t\t}\n\t}\n\tmemo[make_pair(start,end)]=res;\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin>>N>>M && N!=0){\n\t\tmemo.clear();\n\t\tL.clear();\n\t\tL.resize(N,vector<int>());\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint in,out;cin>>in>>out;\n\t\t\tin--;out--;\n\t\t\tif(in<out)\n\t\t\t\tL[in].push_back(out);\n\t\t\telse\n\t\t\t\tL[out].push_back(in);\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tsort(L[i].begin(),L[i].end());\n\t\t\tL[i].erase(unique(L[i].begin(),L[i].end()),L[i].end());\n\t\t}\n\t\tcout<<(calc(0,N-1)+calc(1,N-2))%MOD<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\ntypedef long long ll;\ntypedef vector<int> vi;\nconst int MOD = 1000003;\nint n, m;\nvector<vi> g;\n\nvi solve(int l, int r, int gi){\n\tvi res(2, 1);\n\tfor(int i=l;i<r;i++){\n\t\tif(gi < (int)g[i].size()){\n\t\t\tvi ret = solve(i, g[i][gi], gi+1);\n\t\t\tres[0] = (ll)res[0]*ret[0]%MOD;\n\t\t\tres[1] = (ll)res[1]*ret[1]%MOD;\n\t\t\ti = g[i][gi]-1;\n\t\t}\n\t\tswap(res[0], res[1]);\n\t\tgi = 0;\n\t}\n\tswap(res[0], res[1]);\n\tif(r-l > 1) res[1] = (res[1] + res[0]) % MOD;\n\treturn res;\n}\n\nint main(){\n\twhile(scanf(\"%d%d\", &n, &m), n){\n\t\tg = vector<vi>(n);\n\t\tREP(i, m){\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v);u--; v--;\n\t\t\tif(v < u) swap(u, v);\n\t\t\tif(((u^v)&1)) g[u].push_back(v);\n\t\t}\n\t\tREP(i, n) sort(g[i].rbegin(), g[i].rend());\n\t\tprintf(\"%d\\n\", n%2 ? 0 : (int)(solve(0, n-1, 0)[1]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\n\n\n\nconst int MOD=1000003;\nint N,M;\nvector<vector<int> > L;\nmap<pair<int,int> ,int> memo;\nvoid print(int n){\n\tfor(int i=0;i<n;i++)\n\t\tcout<<\"\t  \";\n}\n\nint calc(int start,int end,int depth){//startからendまでの組み合わせを計算　この時点でサイクルになっていない\n//\tprint(depth);\n//\tcout<<\"do \"<<start<<\" \"<<end<<endl;\n\tif((end-start)%2==0){\n//\t\t\tprint(depth);cout<<\"res \"<<0<<\" :\"<<start<<\" \"<<end<<endl;\n\t\t\treturn 0;\n\t}//奇数とか無理です\n\tif(memo.count(make_pair(start,end))) return memo[make_pair(start,end)];\n\tint res=1;\n\n\tfor(int from=start;from<=end;from++){\n\t\tfor(int idx=0;idx<L[from].size();idx++){\n\t\t\tint to=L[from][idx];\n\t\t\tif(start<=to && to<=end && from<to){\n\t\t\t\tint num1=1,num2=1,num3=1;\n\t\t\t\tif(start<=from-1) num1=calc(start,from-1,depth+1);\n\t\t\t\tif(from+1<=to-1) num2=calc(from+1,to-1,depth+1);\n\t\t\t\tif(to+1<=end) num3=calc(to+1,end,depth+1);\n\t\t\t\tres+=(((num1*num2)%MOD)*num3)%MOD;\n\t\t\t\tres%=MOD;\n\t\t\t}\n\t\t}\n\t}\n//\tprint(depth);\n//\tcout<<\"res \"<<res<<\" :\"<<start<<\" \"<<end<<endl;\n\tmemo[make_pair(start,end)]=res;\n\treturn res;\n\n}\n\nint main()\n{\n\twhile(cin>>N>>M && N!=0){\n\t\tmemo.clear();\n\t\tL.clear();\n\t\tL.resize(N,vector<int>());\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint in,out;cin>>in>>out;\n\t\t\tin--;out--;\n\t\t\tL[in].push_back(out);\n\t\t\tL[out].push_back(in);\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tsort(L[i].begin(),L[i].end());\n\t\t\tL[i].erase(unique(L[i].begin(),L[i].end()),L[i].end());\n\t\t}\n\t\tif(N%2!=0)\n\t\t\tcout<<0<<endl;\n\t\telse{\n\t\t\tint ans=0;\n\t\t\tans+=calc(2,N-1,0);//0と1を姉妹港にしたよ\n\t\t\tans%=MOD;\n\t\t\tans+=calc(1,N-2,0);//0とN-1を姉妹港にしたよ\n\t\t\tans%=MOD;\n\t\t\tfor(int i=0;i<L[0].size();i++){\n\t\t\t\tans+=(calc(1,L[0][i]-1,0)*calc(L[0][i]+1,N-1,0))%MOD;//道がつながっているところを別途計算するよ\n\t\t\t\tans%=MOD;\n\t\t\t}\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstruct P {\n  int a, b;\n  P(int a, int b) : a(a),b(b) {}\n};\nbool operator<(const P &a, const P &b) {\n  return a.a != b.a ? a.a < b.a : a.b > b.b;\n}\nbool parity[50002][2];\nll dp[50002][2][2];\n\nll MOD = 1000003;\nint main() {\n  int n,m;\n  while(cin>>n>>m,n||m) {\n    vector<P> v;\n    v.push_back(P(0,n-1));\n    REP(i,m) {\n      int a, b;cin >> a >> b;\n      v.push_back(P(a,b));\n    }\n    sort(ALL(v));\n    REP(i,m) {\n      parity[i][0] = (v[i+1].a-v[i].a) % 2;\n      parity[i][1] = (v[i].b-v[i+1].b) % 2;\n    }\n    memset(dp,0,sizeof(dp));\n    dp[0][0][0] = 1;\n    REP(i,m) {\n      // use edge i\n      (dp[i+1][!parity[i][0]][!parity[i][1]] += dp[i][0][0]) %= MOD;\n      // not use\n      REP(j,2) {\n        REP(k,2) {\n          //cout << dp[i][j][k] << \" \";\n          (dp[i+1][j^parity[i][0]][k^parity[i][1]] += dp[i][j][k]) %= MOD;\n        }\n      }\n      //cout << endl;\n    }\n    ll sum = 0;\n    if ((v[m].b-v[m].a) % 2 == 0) {\n      sum += dp[m][0][1];\n      sum += dp[m][1][0];\n    } else {\n      sum += dp[m][0][0] * 2;\n      sum += dp[m][1][1];\n    }\n    cout << sum % MOD << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntypedef vector< pair<vi,vi> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\nset<unsigned int> is_edge;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(vector<vi> &g){\n  unsigned int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  set<unsigned int> tmp_edge = is_edge;\n  rep(i,n){\n    deg[i] = g[i].sz; deg[i]*=-1;\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vi unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tunsigned int aa = a, bb = b;\n\tif(aa>bb)swap(aa,bb);\n\tif(aa!=bb && !tmp_edge.count(aa*n + bb)){\n\t  g[aa].pb(bb);\n\t  g[bb].pb(aa);\n\t  tmp_edge.insert(aa*n + bb);\n\t  deg[aa]--; deg[bb]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, int id){\n  stack<int> s;\n  s.push(id);\n\n  while(s.sz){\n    id = s.top(); s.pop();\n    \n    //for join\n    while(t[id].first.size()>2){\n      vi child(2);\n      child[0] = t[id].first.back(); t[id].first.pop_back();\n      child[1] = t[id].first.back(); t[id].first.pop_back();\n      t.push_back(make_pair(child, t[id].second));\n      t[id].first.push_back(t.size()-1);\n    }\n\n    if(t[id].first.size()==2){\n      rep(i,2){\n\tconst int &j = t[id].first[i];\n\tif(t[id].second != t[j].second){\n\t  vi child(1);\n\t  child[0] = j;\n\t  t.push_back(make_pair(child, t[id].second));\n\t  t[id].first[i] = t.size()-1;\n\t}\n      }\n    }\n\n    //for introduce & forget\n    if(t[id].first.size()==1){\n      const int &j = t[id].first[0];\n      vi child(1);\n      child[0] = j;\n      \n      vi disA, disB;\n      rep(a,t[id].second.size()){\n\tbool f = true;\n\trep(b,t[j].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disA.push_back(a);\n      }\n      rep(b,t[j].second.size()){\n\tbool f = true;\n\trep(a,t[id].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disB.push_back(b);\n      }\n      \n      if(disA.size() + disB.size() > 1){\n\tif(disA.size()>0){\n\t  vi tmp = t[id].second;\n\t  tmp.erase(tmp.begin() + disA[0]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}else{\n\t  vi tmp = t[id].second;\n\t  tmp.push_back(t[j].second[disB[0]]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}      \n      }\n    }\n    \n    //for leaf\n    if(t[id].first.size() == 0){\n      if(t[id].second.size() > 1){\n\tvi tmp;\n\trep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n\tt.push_back(make_pair(vi(), tmp));\n\tt[id].first.push_back(t.size()-1);\n      }\n    }\n\n    rep(i,t[id].first.size()){\n      s.push(t[id].first[i]);\n    }\n  }\n}\n\nunordered_map<int,int> memo;\nTD t;\n\ninline int dp(int id, int use, unsigned int n){\n  int key = 100*id + use;\n\n  stack<int> s;\n  s.push(key);\n\n  while(s.sz){\n    ll res = 0;\n    key = s.top(); s.pop();\n    id = key/100; use = key%100;\n    const vi& child = t[id].fs, bag = t[id].sc;\n    \n    //for leaf\n    if(child.sz==0){\n      memo[key] = use;\n      goto END;\n    }\n    \n    if(child.sz==1){\n      const vi &nbag = t[child[0]].second;\n      vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n      rep(i,bag.size())rep(j,nbag.size()){\n\tif(bag[i] == nbag[j]){\n\t  to_bag[j] = i; to_nbag[i] = j;\n\t}\n      }\n      \n      //for introduce\n      if(nbag.sz < bag.sz){\n\tint nuse = 0;\n\trep(i,bag.sz){\n\t  if(to_nbag[i]<0){\n\t    if( ((use>>i)&1) == 0 ){\n\t      memo[key] = 0;\n\t      goto END;\n\t    }\n\t  }else{\n\t    if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t  }\n\t}\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  memo[key] = memo[nxt];\n\t  goto END;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n      }\n      \n      //for forget\n      if(nbag.sz > bag.sz){\n\tint add = -1,  nuse = 0;\n\trep(i,nbag.sz){\n\t  if(to_bag[i]<0)add = i;\n\t  else if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n\t}\n\t\n\tll res = 0;\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  (res += memo[nxt]) %= mod;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n\n\trep(i,bag.sz){\n\t  if((use>>i)&1)continue;\n\t  \n\t  unsigned int a = bag[i], b = nbag[add];\n\t  if(a>b)swap(a,b);\n\t  if(is_edge.count(a*n + b)){\n\t    nxt = child[0]*100 + (nuse | (1<<add) | (1<<to_nbag[i]));\n\t    if(memo.count(nxt)){\n\t      (res += memo[nxt]) %= mod;\n\t    }else{\n\t      s.push(key); s.push(nxt);\n\t      goto END;\n\t    }\n\t  }\n\t}\n\tmemo[key] = res;\n      }\n    }\n    \n    //for join\n    if(child.sz==2){\n      int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n      do{\n\tint nxt1 = child[0]*100 + (use|sub), nxt2 = child[1]*100 + (use|(unuse-sub));\n\tif(memo.count(nxt1) == 0){\n\t  s.push(key); s.push(nxt1);\n\t  goto END;\n\t}\n\tif(memo.count(nxt2) == 0){\n\t  s.push(key); s.push(nxt2);\n\t  goto END;\n\t}\n\tif(memo.count(nxt1) && memo.count(nxt2)){\n\t  res += (ll)memo[nxt1] * memo[nxt2];\n\t  res %= mod;\n\t}\n\tsub = (sub-1)&unuse;\n      }while(sub != unuse);\n    \n      memo[key] = res;\n    }\n  END:;\n  }\n  return memo[key];\n}\n\nvoid visg(vector<vi> g){\n  int n = g.size();\n  cout << \"graph {\" << endl;\n  rep(i,n){\n    rep(k,g[i].sz){\n      if(i<g[i][k]){\n\tcout << \"  \\\"\" << i << \" \";\n\tcout << \"\\\" -- \\\"\" << g[i][k] << \" \";\n\tcout << \"\\\"\" << endl;\n      }\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nvoid vis(TD t){\n  int n = t.size();\n  cout << \"digraph {\" << endl;\n  rep(i,n){\n    rep(k,t[i].first.size()){\n      int nxt = t[i].first[k];\n      cout << \"  \\\"\" << i << \": \";\n      rep(j,t[i].second.size())cout << t[i].second[j] << \" \";\n      cout << \"\\\" -> \\\"\" << nxt << \": \";\n      rep(j,t[nxt].second.size())cout << t[nxt].second[j] << \" \";\n      cout << \"\\\"\" << endl;\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nint main(){\n  unsigned int n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    vector<vi> g(n);\n    is_edge.clear();\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*n + b);\n      else is_edge.insert(b*n + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*n + b);\n      else is_edge.insert(b*n + a);\n    }\n\n    //visg(g);\n    t = heuristic_tree_decomposition(g);\n    g.clear();\n    //cout << t.size() << endl;\n    //vis(t);\n    toNice(t,0);\n    //cerr << t.size() << endl;\n    //vis(t);\n\n    ll res = 0;\n    memo.clear();\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      res += dp(0,use,n);\n      res %= mod;\n    }\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef long long ll;\ntypedef pair<int,int> P;\nll mod=1e6+3;\nvoid add(ll &x,ll y){\n\tx+=y;\n\tx%=mod;\n}\nint N,M;\nvector<P> es;\nset<int> st;\nset<int>::iterator it;\nint nxt[110000];\nll dp[110000][4];\nbool comp(const P& l,const P& r){\n\treturn l.sc-l.fs<r.sc-r.fs;\n}\nvoid init(){\n\tes.clear();\n\tst.clear();\n\trep(i,110000){\n\t\tnxt[i]=0;\n\t\trep(j,4) dp[i][j]=0;\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M;\n\t\tif(N==0) break;\n\t\tinit();\n\t\tif(N%2){\n\t\t\tputs(\"0\");\n\t\t\tcontinue;\n\t\t}\n\t\tif(M==0){\n\t\t\tif(N==2) puts(\"1\");\n\t\t\telse puts(\"2\");\n\t\t\tcontinue;\n\t\t}\n\t\tint p,q,r,s;\n\t\trep(i,M){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--,b--;\n\t\t\tif(a>b) swap(a,b);\n\t\t\tif(b-a>N/2) swap(a,b),b+=N;\n\t\t\tes.pb(P(a,b));\n\t\t}\n\t\tsort(all(es),comp);\n\t\t{\n\t\t\tp=es[M-1].fs,q=es[M-1].sc,r=q,s=p+N;\n\t\t\tif(r>=N) r-=N,s-=N;\n\t\t\tes.pb(P(r,s));\n\t\t}\n\t\trep(i,M+1){\n\t\t\tP e=es[i];\n\t\t\tint a=e.fs,b=e.sc;\n\t\t\tint y=a,x=-1,nx=b;\n\t\t\tll val[4]={},nval[4]={};\n\t\t\tval[1]=val[2]=1;\n\t\t\twhile(true){\n\t\t\t\tit=st.lower_bound(y);\n\t\t\t\tif(it==st.end()||*it>=b) break;\n\t\t\t\tx=*it;\n\t\t\t\tnx=nxt[x];\n\t\t\t\tif((x-y)%2){\n\t\t\t\t\tswap(val[0],val[1]);\n\t\t\t\t\tswap(val[2],val[3]);\n\t\t\t\t}\n\t\t\t\tfor(int o=0;o<=2;o+=2){\n\t\t\t\t\tadd(nval[0+o],val[0+o]*dp[x][2]);\n\t\t\t\t\tadd(nval[1+o],val[0+o]*dp[x][3]);\n\t\t\t\t\tadd(nval[0+o],val[1+o]*dp[x][0]);\n\t\t\t\t\tadd(nval[1+o],val[1+o]*dp[x][1]);\n\t\t\t\t}\n\t\t\t\trep(j,4) val[j]=nval[j],nval[j]=0;\n\t\t\t\tst.erase(x);\n\t\t\t\tst.erase(x+N);\n\t\t\t\ty=nx;\n\t\t\t}\n\t\t\tif((b-y)%2){\n\t\t\t\tswap(val[0],val[1]);\n\t\t\t\tswap(val[2],val[3]);\n\t\t\t}\n\t\t\tst.insert(a);\n\t\t\tst.insert(a+N);\n\t\t\tnxt[a]=b,nxt[a+N]=b+N;\n\t\t\trep(j,4) dp[a][j]=val[j];\n\t\t\tif(i!=M) add(dp[a][3],dp[a][0]);\n\t\t\trep(j,4) dp[a+N][j]=dp[a][j];\n\t\t}\n\t\tll ans=dp[p][0]*dp[r][3]+dp[p][1]*dp[r][1]+dp[p][2]*dp[r][2]+dp[p][3]*dp[r][0];\n/*\t\tshow(p);\n\t\tshow(q);\n\t\tshow(r);\n\t\tshow(s);\n\t\trep(i,4) show(dp[p][i]);\n\t\trep(i,4) show(dp[r][i]);*/\n\t\tcout<<ans%mod<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n\nusing namespace std;\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\ntypedef long long ll;\nconst int mod=1000003;\nvector<int> to[50000];\n\nvoid Merge(int a[2][2],int b[2][2],int (&c)[2][2]){\n\tREP(i,2)\n\t\tREP(j,2)\n\t\t\tc[i][j]=(ll(a[i][0])*b[1][j]+ll(a[i][1])*b[0][j])%mod;\n}\n\nvoid Calc(int l,int r,int (&dst)[2][2]){\n\tdst[0][0]=1;\n\tdst[0][1]=0;\n\tdst[1][0]=0;\n\tdst[1][1]=1;\n\tif(l+1==r)\n\t\treturn;\n\tint buf[2][2],tmp[2][2];\n\tFOR(i,1,(int)to[l].size()){\n\t\tCalc(to[l][i-1],to[l][i],buf);\n\t\tMerge(dst,buf,tmp);\n\t\tmemcpy(dst,tmp,sizeof(dst));\n\t\tdst[1][1]=(dst[1][1]+dst[0][0])%mod;\n\t}\n\tif(to[l].back()<r){\n\t\tCalc(to[l].back(),r,buf);\n\t\tMerge(dst,buf,tmp);\n\t\tmemcpy(dst,tmp,sizeof(dst));\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tint n=read(),m=read();\n\t\tif(!n)\n\t\t\treturn 0;\n\t\tREP(i,n)\n\t\t\tto[i].clear();\n\t\tREP(i,n-1)\n\t\t\tto[i].PB(i+1);\n\t\tto[0].PB(n-1);\n\t\tREP(i,m){\n\t\t\tint a=read()-1,b=read()-1;\n\t\t\tto[min(a,b)].PB(max(a,b));\n\t\t}\n\t\tREP(i,n)\n\t\t\tsort(to[i].begin(),to[i].end());\n\t\tint ans[2][2];\n\t\tCalc(0,n-1,ans);\n\t\tprintf(\"%d\\n\",ans[1][1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//{{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\ntemplate<typename T>\nostream& operator <<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    for(int i = 0; i < v.size(); i++)\n        os << v[i] << (i+1<v.size()?\", \":\"\");\n    os << \"]\"; return os;\n}\n\ntemplate<typename T>\nostream& operator <<(ostream& os, const set<T>& s) {\n    os << \"{\";\n    for(auto it = s.begin(); it != s.end(); ++it)\n        os << *it << \",\";\n    os << \"}\"; return os;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator <<(ostream& os, const pair<T1, T2>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n//}}}\nconst int MOD = 1000003;\n\npair<vector<int>, vector<int>> split(const vector<int>& v, int x, int y) {\n    int a = find(v.begin(), v.end(), x) - v.begin();\n    int b = find(v.begin(), v.end(), y) - v.begin();\n    if(a > b) swap(a, b);\n    vector<int> lv, rv;\n    for(int i = a; i <= b; i++) {\n        lv.push_back(v[i]);\n    }\n    for(int i = b; i < v.size(); i++) {\n        rv.push_back(v[i]);\n    }\n    for(int i = 0; i <= a; i++) {\n        rv.push_back(v[i]);\n    }\n    return make_pair(lv, rv);\n}\n\nvector<pair<int, int>> border(int n, const vector<int>& v) {\n    int l = v.size();\n    vector<pair<int, int>> res;\n    for(int i = 0; i < l; i++) {\n        int a = v[i];\n        int b = v[(i+1)%l];\n        if((a + 1) % n != b) {\n            if(a > b) swap(a, b);\n            res.push_back(make_pair(a, b));\n        }\n    }\n    return res;\n}\n\nvoid to_back(vector<int>& v, int x, int y) {\n    int n = v.size();\n    int j;\n    for(j=0; j<v.size(); j++) {\n        if(v[j] == x || v[j] == y) break;\n    }\n    if(j == 0 && (v[n-1] == x || v[n-1] == y)) j = n-1;\n    assert(v[(j+1)%n] == x || v[(j+1)%n] == y);\n    rotate(v.begin(), v.begin() + (j+1)%n, v.end());\n}\n\nint memo[50005][2];\nint dfs(int idx, int head, int n, const set<int>& off, bool back=true) {\n    if(memo[idx][head] != -1) return memo[idx][head];\n    if(idx == 0) {\n        int& res = memo[idx][head];\n        res = 0;\n        int next = (idx + 1) % n;\n        if(!off.count(0) && !off.count(next)) res += dfs(idx+2, 1, n, off, back); // use 0-1\n        res += dfs(idx+1, off.count(0), n, off, back); // not use 0-1\n        // cout << \"idx : \" << idx << endl;\n        // cout << \"head: \" << head << endl;\n        // cout << \"res : \" << res << endl;\n        return res;\n    }else if(idx >= n){\n        // cout << \"idx : \" << idx << endl;\n        // cout << \"head: \" << head << endl;\n        // cout << \"res : \" << (head ? 1 : 0) << endl;\n        return memo[idx][head] = (head ? 1 : 0);\n    }else if(off.count(idx)){\n        int& res = memo[idx][head];\n        res = dfs(idx+1, head, n, off, back);\n        // cout << \"idx : \" << idx << endl;\n        // cout << \"head: \" << head << endl;\n        // cout << \"res : \" << res << endl;\n        return res;\n    }\n\n    int& res = memo[idx][head];\n    res = 0;\n    int next = (idx + 1) % n;\n    if(!off.count(next) && !(next == 0 && head) && !(next == 0 && !back))\n        res += dfs(idx+2, (next == 0 ? 1 : head), n, off, back);\n    // cout << \"idx : \" << idx << endl;\n    // cout << \"head: \" << head << endl;\n    // cout << \"back: \" << back << endl;\n    // cout << \"res : \" << res << endl;\n    return res;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    while(cin >> n >> m && n > 0) {\n        if(n % 2 == 1) {\n            cout << 0 << endl;\n            continue;\n        }\n\n        if(m == 0) {\n            cout << 2 << endl;\n            continue;\n        }\n\n        vector< vector<int> > vs;\n        vector<int> init(n);\n        REP(i, n) init[i] = i;\n        vs.push_back(init);\n\n        REP(_, m) {\n            int x, y;\n            cin >> x >> y;\n            x--; y--;\n            auto target = vs.end();\n            for(auto it = vs.begin(); it != vs.end(); ++it) {\n                auto i = find(it->begin(), it->end(), x);\n                auto j = find(it->begin(), it->end(), y);\n                if(i == it->end() || j == it->end()) continue;\n                assert(target == vs.end());\n                target = it;\n            }\n            assert(target != vs.end());\n            auto p = split(*target, x, y);\n\n            vs.erase(target);\n            vs.push_back(p.first);\n            vs.push_back(p.second);\n        }\n\n        vector<vector<pair<int, int>>> bs;\n        for(auto& v : vs) {\n            bs.push_back(border(n, v));\n        }\n\n        // cout << \"vs: \" << vs << endl;\n        // cout << \"bs: \" << bs << endl;\n\n        int l = vs.size();\n        int dp[1 << 2] = {};\n\n        pair<int, int> last_b;\n        int last_idx;\n        REP(i, l) if(bs[i].size() == 1) {\n            auto b = bs[i][0];\n            to_back(vs[i], b.first, b.second);\n            int x = find(vs[i].begin(), vs[i].end(), b.first) - vs[i].begin();\n            int y = find(vs[i].begin(), vs[i].end(), b.second) - vs[i].begin();\n            REP(s, 1<<2) {\n                set<int> off;\n                if((s>>0)&1) off.insert(x);\n                if((s>>1)&1) off.insert(y);\n                // cout << \"off: \" << off << endl;\n                memset(memo, -1, sizeof(memo));\n                dp[s] = dfs(0, 0, vs[i].size(), off);\n                // cout << dp[s] << endl;\n            }\n            last_b = b;\n            last_idx = i;\n            break;\n        }\n        // cout << vector<int>(dp, dp + (1<<2)) << endl;\n\n        REP(_, l-2) {\n            REP(i, l) if(i != last_idx && find(bs[i].begin(), bs[i].end(), last_b) != bs[i].end()) {\n                to_back(vs[i], last_b.first, last_b.second);\n                int k = find(bs[i].begin(), bs[i].end(), last_b) - bs[i].begin();\n                k ^= 1;\n                auto b = bs[i][k];\n                int ndp[1 << 2] = {};\n                int u = find(vs[i].begin(), vs[i].end(), last_b.first) - vs[i].begin();\n                int v = find(vs[i].begin(), vs[i].end(), last_b.second) - vs[i].begin();\n                int x = find(vs[i].begin(), vs[i].end(), b.first) - vs[i].begin();\n                int y = find(vs[i].begin(), vs[i].end(), b.second) - vs[i].begin();\n                REP(s, 1<<2) REP(ns, 1<<2) {\n                    set<int> off;\n                    if(!((s>>0)&1)) off.insert(u);\n                    if(!((s>>1)&1)) off.insert(v);\n                    if((ns>>0)&1) off.insert(x);\n                    if((ns>>1)&1) off.insert(y);\n                    memset(memo, -1, sizeof(memo));\n                    ndp[ns] += (long long)dfs(0, 0, vs[i].size(), off, (s!=3)) * dp[s] % MOD;\n                    ndp[ns] %= MOD;\n                }\n                REP(s, 1<<2) dp[s] = ndp[s];\n                last_idx = i;\n                last_b = b;\n                break;\n            }\n            // cout << vector<int>(dp, dp + (1<<2)) << endl;\n        }\n\n        int ans = 0;\n        REP(i, l) if(i != last_idx && find(bs[i].begin(), bs[i].end(), last_b) != bs[i].end()) {\n            to_back(vs[i], last_b.first, last_b.second);\n            // cout << \"vs[i]: \" << vs[i] << endl;\n            int u = find(vs[i].begin(), vs[i].end(), last_b.first) - vs[i].begin();\n            int v = find(vs[i].begin(), vs[i].end(), last_b.second) - vs[i].begin();\n            REP(s, 1<<2) {\n                set<int> off;\n                if(!(s>>0&1)) off.insert(u);\n                if(!(s>>1&1)) off.insert(v);\n                // cout << \"off: \" << off << endl;\n                // cout << \"ans: \" << ans << \"->\";\n                memset(memo, -1, sizeof(memo));\n                ans += (long long)dfs(0, 0, vs[i].size(), off, (s!=3)) * dp[s] % MOD;\n                // cout << ans << endl;\n                // cout << dp[s] << \" * \" << dfs(0, 0, vs[i].size(), off, (s!=3)) << endl;\n                ans %= MOD;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\n\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n\n//repetition//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define MOD 1000003\n#define EPS 1e-8\n\nvoid UpperTriangle(vector<vector<double> > &mat){//GaussJordan法により上三角行列を得る\n\tint n = mat.size();\n\tREP(i, n){\n\t\tif(abs(mat[i][i])<EPS){//ピボット操作\n\t\t\tFOR(j, i+1, n){\n\t\t\t\tif(abs(mat[j][i]) >= EPS){\n\t\t\t\t\tswap(mat[i], mat[j]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(j,n){\n\t\t\tif(j==i)continue;\n\t\t\tdouble c = mat[j][i]/mat[i][i];\n\t\t\tREP(k, n)mat[j][k] -= mat[i][k]*c;\n\t\t}\n\t}\n}\n\ndouble Determinant(vector<vector<double> > &mat){//正方行列の行列式を求める\n\tint n=mat.size();\n\tdouble ret = 1.0;\n\tUpperTriangle(mat);\n\tREP(i,n)ret*=mat[i][i];\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tvector<PII> vpii;\n\t\tcin >> n >> m;\n\t\tif(n==0)return 0;\n\t\tREP(i,m){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\tif((a+b)%2==1){\n\t\t\t\tif(a < b)vpii.PB(MP(a, b));\n\t\t\t\telse vpii.PB(MP(b,a));\n\t\t\t}\n\t\t}\n\t\tif(n%2)cout << 0 << endl;\n\t\t//2部グラフの完全マッチングの数えあげに帰着\n\t\telse{\n\t\t\tvector<vector<double> > mat(n, vector<double>(n,0.0));\n\t\t\tREP(i, n-1){\n\t\t\t\tmat[i][i+1] = 1.0;\n\t\t\t\tmat[i+1][i] = -1.0;\n\t\t\t}\n\t\t\tmat[n-1][0]=-1.0;\n\t\t\tmat[0][n-1]=1.0;\n\t\t\tREP(i, vpii.size()){\n\t\t\t\tmat[vpii[i].first-1][vpii[i].second-1]=1.0;\n\t\t\t\tmat[vpii[i].second-1][vpii[i].first-1]=-1.0;\n\t\t\t}\n\t\t\tint k= sqrt(abs(Determinant(mat)));\n\t\t\tcout << k << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define MOD (1000003LL)\ntypedef long long Int;\n\nint n, mi, cs[60000][2];\nvector<int> g[60000];\nbool has[60000];\nint dp[60000][2][2];\n\ninline int f(int k, int x, int y) { return k == -1 ? x==y : dp[k][x][y]; }\n\nvoid add(int p, int q) {\n    if (p > q) swap(p, q);\n    g[p].push_back(q);\n}\n\nint pre(int p, int q) {\n    if (p+1 == q) return -1;\n    const int k = mi++;\n    has[k] = false;\n    if (g[p].back() == q) {\n        has[k] = true;\n        g[p].pop_back();\n    }\n    const int r = g[p].back();\n    cs[k][0] = pre(p, r);\n    cs[k][1] = pre(r, q);\n    return k;\n}\n\nint main() {\n    for (;;) {\n        int m, a, b;\n        scanf(\"%d%d\", &n, &m);\n        if (n == 0) return 0;\n        rep (_, m) {\n            scanf(\"%d%d\", &a, &b);\n            if (n%2 == 0) add(a-1, b-1);\n        }\n        if (n%2) {\n            printf(\"%d\\n\", 0);\n            continue;\n        }\n        rep (i, n) add(i, (i+1)%n);\n        rep (i, n) sort(g[i].begin(), g[i].end());\n        mi = 0;\n        pre(0, n-1);\n        for (int k = mi-1; k >= 0; k--) rep (x, 2) rep (y, 2) {\n            const int p = cs[k][0], q = cs[k][1];\n            Int ans = 0;\n            ans += (Int)f(p, x, 0) * f(q, 1, y);\n            ans += (Int)f(p, x, 1) * f(q, 0, y);\n            if (x && y && has[k]) {\n                ans += (Int)f(p, 0, 0) * f(q, 1, 0);\n                ans += (Int)f(p, 0, 1) * f(q, 0, 0);\n            }\n            dp[k][x][y] = ans % MOD;\n        }\n        printf(\"%d\\n\", dp[0][1][1]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int M=1000003;\n\nvector<int> G[50000];\n\nll dfs(int l,int r,bool bl,bool br){\n\tif(l+1==r) return bl==br?1:0;\n\n\t// 多角形の縁以外に l から出る辺があるとき, その辺を使ってグラフを二分割する\n\trep(i,G[l].size()){\n\t\tint u=G[l][i];\n\t\tif(l<u && u<r){\n\t\t\tll res=0;\n\t\t\t// 辺 l-u をマッチングに使わない\n\t\t\tres+=dfs(l,u,bl, true)*dfs(u,r,false,br); // 頂点 u を [u,r] 側のマッチングに使う\n\t\t\tres+=dfs(l,u,bl,false)*dfs(u,r, true,br); // 頂点 u を [l,u] 側のマッチングに使う\n\t\t\t// 辺 l-u をマッチングに使う\n\t\t\tif(!bl){\n\t\t\t\tres+=dfs(l,u,true,true)*dfs(u,r,true,br);\n\t\t\t}\n\t\t\treturn res%M;\n\t\t}\n\t}\n\n\t// 多角形の縁以外に r から出る辺があるとき, その辺を使ってグラフを二分割する\n\trep(i,G[r].size()){\n\t\tint u=G[r][i];\n\t\tif(l<u && u<r){\n\t\t\tll res=0;\n\t\t\t// 辺 u-r をマッチングに使わない\n\t\t\tres+=dfs(l,u,bl, true)*dfs(u,r,false,br); // 頂点 u を [u,r] 側のマッチングに使う\n\t\t\tres+=dfs(l,u,bl,false)*dfs(u,r, true,br); // 頂点 u を [l,u] 側のマッチングに使う\n\t\t\t// 辺 u-r をマッチングに使う\n\t\t\tif(!br){\n\t\t\t\tres+=dfs(l,u,bl,true)*dfs(u,r,true,true);\n\t\t\t}\n\t\t\treturn res%M;\n\t\t}\n\t}\n\n\t// 多角形の縁しか進める辺がないとき, 多角形に沿って l を一つ進める\n\treturn dfs(l+1,r,!bl,br);\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\trep(u,n) G[u].clear();\n\t\trep(i,m){\n\t\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t\tprintf(\"%lld\\n\",(dfs(0,n-1,false,false)+dfs(0,n-1,true,true))%M);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> T;\n\nconst int MN = 50500; \nconst int MD = 1000003;\n\nint n, m;\nP g[MN];\nint calc(int l, int r) {\n    ll res = 1;\n    while (l < r) {\n        res *= g[l].second; res %= MD;\n        l = g[l].first;\n    }\n    return res;\n}\n\nint solve() {\n    if (n % 2) return 0;\n    for (int i = 0; i < n-1; i++) {\n        g[i] = P(i+2, 1);\n    }\n    vector<T> buf;\n    buf.push_back(T(n-1, P(0, n)));\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b); a--;\n        if (a > b) swap(a, b);\n        if ((b-a) % 2) continue;\n        buf.push_back(T(b-a, P(a, b)));\n    }\n    sort(buf.begin(), buf.end());\n    for (T &t: buf) {\n        int a, b;\n        tie(a, b) = t.second;\n        g[a] = P(b, (calc(a, b) + calc(a+1, b-1)) % MD);\n    }\n    return g[0].second;\n}\n\nint main() {\n    while (true) {\n        scanf(\"%d %d\", &n, &m);\n        if (!n) break;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint mod=1000003;\nstruct wolf{\n\tint l,r;\n\twolf(){}\n\twolf(int a,int b){\n\t\tl=a;r=b;\n\t}\n};\ninline bool operator<(const wolf&a,const wolf&b){\n\tif(a.l!=b.l)return a.l<b.l;\n\treturn a.r>b.r;\n}\nwolf p[51000];\nint in[51000];\nint next[51000];\nint dp[51000][2][2];\nint solve(int a,int b,int c){\n\tif(~dp[a][b][c])return dp[a][b][c];\n\tif(in[a]==-1){\n\t\tint ret=0;\n\t\tif((p[a].r-p[a].l+b+c)%2==0)return dp[a][b][c]=0;\n\t\tif(b==0&&c==0)return dp[a][b][c]=2;\n\t\treturn dp[a][b][c]=1;\n\t}\n\tlong long ret=0;\n\tlong long te=0;\n\tlong long to=0;\n\tint at;\n\tif(b==0&&c==0&&(p[a].r-p[a].l)%2){\n\t\tto=1;\n\t\tat=p[a].l;\n\t\tfor(int i=in[a];~i;i=next[i]){\n\t\t\tif(p[i].l>=p[a].r)break;\n\t\t\tlong long tte;\n\t\t\tlong long tto;\n\t\t\tif((p[i].l-at)%2){\n\t\t\t\ttte=te*solve(i,1,1)+to*solve(i,0,1);\n\t\t\t\ttto=te*solve(i,1,0)+to*solve(i,0,0);\n\t\t\t}else{\n\t\t\t\ttte=te*solve(i,0,1)+to*solve(i,1,1);\n\t\t\t\ttto=te*solve(i,0,0)+to*solve(i,1,0);\n\t\t\t}\n\t\t\tte=tte%mod;\n\t\t\tto=tto%mod;\n\t\t\tat=p[i].r;\n\t\t}\n\t\tif((p[a].r-at)%2==0)ret=te;\n\t\telse ret=to;\n\t}\n\tte=to=0;\n\tif(b)to=1;\n\telse te=1;\n\tat=p[a].l;\n\tfor(int i=in[a];~i;i=next[i]){\n\t\tif(p[i].l>=p[a].r)break;\n\t\tlong long tte;\n\t\tlong long tto;\n\t\tif((p[i].l-at)%2){\n\t\t\ttte=te*solve(i,1,1)+to*solve(i,0,1);\n\t\t\ttto=te*solve(i,1,0)+to*solve(i,0,0);\n\t\t}else{\n\t\t\ttte=te*solve(i,0,1)+to*solve(i,1,1);\n\t\t\ttto=te*solve(i,0,0)+to*solve(i,1,0);\n\t\t}\n\t\tte=tte%mod;\n\t\tto=tto%mod;\n\t\tat=p[i].r;\n\t}\n\tif((p[a].r-at)%2==!c)ret=(ret+te)%mod;\n\telse ret=(ret+to)%mod;\n\t//printf(\"%d %d %d: %d\\n\",a,b,c,ret);\n\treturn dp[a][b][c]=ret;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint s,t;scanf(\"%d%d\",&s,&t);\n\t\t\ts--;t--;\n\t\t\tp[i]=wolf(s,t);\n\t\t}\n\t\tp[b++]=wolf(0,a-1);\n\t\tif(a%2){\n\t\t\tprintf(\"0\\n\");continue;\n\t\t}\n\t\tstd::sort(p,p+b);\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint nx=lower_bound(p,p+b,wolf(p[i].r,99999999))-p;\n\t\t\tif(nx>=b)next[i]=-1;\n\t\t\telse next[i]=nx;\n\t\t\tint ni=upper_bound(p,p+b,wolf(p[i].l,p[i].r))-p;\n\t\t\tif(ni>=b||p[ni].l>=p[i].r)in[i]=-1;\n\t\t\telse in[i]=ni;\n\t\t}\n\t//\tfor(int i=0;i<b;i++)printf(\"%d %d\\n\",in[i],next[i]);\n\t\tfor(int i=0;i<b;i++)for(int j=0;j<2;j++)for(int k=0;k<2;k++)dp[i][j][k]=-1;\n\t\tprintf(\"%d\\n\",solve(0,0,0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define PI       3.1415926535897932384626433832795028841971\n#define INF 1000000000\n#define EPS      1e-10\n#define MOD      1000003\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,double> P;\ntypedef pair<double,P> PQ;\n\nstruct edge{\n    int dis;\n    int from;\n    int to;\n    bool operator<(const edge& right) const{\n        return dis < right.dis;\n    }\n};\n\nint n, m;\nll x[50000];\nint to[50000];\nvector<edge> e;\n\nvoid func(int st, int en){\n    ll y = 1;\n    int now = st;\n    while(now != (en+1)%n){\n        y = y*x[now]%MOD;\n        now = (to[now]+1)%n;\n    }\n    now = (st+1)%n;\n    ll yy = 1;\n    while(now != en){\n        yy = yy*x[now]%MOD;\n        now = (to[now]+1)%n;\n    }\n    y = (y+yy)%MOD;\n    \n    x[st] = y;\n    to[st] = en;\n}\n\nll calc(int st, int en){\n    ll ret = 1;\n    int now = st;\n    while(now != (en+1)%n){\n        ret = ret*x[now]%MOD;\n        now = (to[now]+1)%n;\n    }\n    return ret;\n}\n\nint main(){\n    while(cin >> n >> m){\n        if(n == 0 && m == 0) break;\n        e.clear();\n        rep(i,n) to[i] = (i+1)%n;\n        rep(i,n) x[i] = 1;\n        \n        rep(i,m){\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            if(a > b) swap(a,b);\n            if((b-a)%2==0) continue;\n            edge tmp;\n            if(b-a <= a+n-b){\n                tmp.dis = b-a;\n                tmp.from = a;\n                tmp.to = b;\n            } else{\n                tmp.dis = a+n-b;\n                tmp.from = b;\n                tmp.to = a;\n            }\n            e.push_back(tmp);\n        }\n       if(n&1){\n            cout << 0 << endl;\n            continue;\n        }\n        if(e.size() == 0){\n            cout << 2 << endl;\n            continue;\n        }\n       \n        sort(e.begin(),e.end());\n        \n        for(int i = 0; i < e.size()-1; i++){\n            edge ee = e[i];\n            func(ee.from,ee.to);\n        }\n        ll ans = 0;\n        edge ee = e[e.size()-1];\n        ll p1 = calc(ee.from,ee.to);\n        ll p2 = calc((ee.to+1)%n,(ee.from-1+n)%n);\n        ll p3 = calc(ee.to,ee.from);\n        ll p4 = calc((ee.from+1)%n,(ee.to-1+n)%n);\n        ans = (ans+p1*p2)%MOD;\n        ans = (ans+p3*p4)%MOD;\n        ans = (ans+p2*p4)%MOD;\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define MOD (1000003LL)\ntypedef long long Int;\n\nint n, mi, memo[60000*4], cs[60000][2], w[60000];\nvector<int> g[60000];\nbool has[60000];\n\nvoid add(int p, int q) {\n    if (p > q) swap(p, q);\n    g[p].push_back(q);\n}\n\nint pre(int p, int q) {\n    if (p+1 == q) return -1;\n    const int k = mi++;\n    has[k] = false;\n    if (g[p].back() == q) {\n        has[k] = true;\n        g[p].pop_back();\n    }\n    const int r = g[p].back();\n    rep (b, 4) memo[k*4|b] = -1;\n    cs[k][0] = pre(p, r);\n    cs[k][1] = pre(r, q);\n    w[k] = q-p+1;\n    return k;\n}\n\nint rec(int k, int x, int y) {\n    if ((w[k]+x+y)%2) return 0;\n    if (k == -1) return x == y;\n    const int sig = k*4|x*2|y;\n    if (memo[sig] != -1) return memo[sig];\n    const int p = cs[k][0], q = cs[k][1];\n    Int ans = 0;\n    ans += (Int)rec(p, x, 0) * rec(q, 1, y);\n    ans += (Int)rec(p, x, 1) * rec(q, 0, y);\n    if (x && y && has[k]) {\n        ans += (Int)rec(p, 0, 0) * rec(q, 1, 0);\n        ans += (Int)rec(p, 0, 1) * rec(q, 0, 0);\n    }\n    return memo[sig] = ans % MOD;\n}\n\nint main() {\n    for (;;) {\n        int m, a, b;\n        scanf(\"%d%d\", &n, &m);\n        if (n == 0) return 0;\n        rep (_, m) {\n            scanf(\"%d%d\", &a, &b);\n            add(a-1, b-1);\n        }\n        rep (i, n) add(i, (i+1)%n);\n        rep (i, n) sort(g[i].begin(), g[i].end());\n        mi = 0;\n        pre(0, n-1);\n        printf(\"%d\\n\", rec(0, 1, 1));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef long double LD;\ntypedef pair<LD, LD> PLDLD;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\nLL MOD = 1e9+3;\nLL INF = 1e9;\n\n\nint main()\n{\n    int n,m;\n    while(cin>>n>>m,n)\n    {\n        vector<vector<int> > e(n, vector<int>());\n        REP(i,m)\n        {\n            int a,b;\n            cin>>a>>b;\n            if(abs(a-b)%2==0) continue;\n            if(abs(a-b)==1||abs(a-b)==n-1) continue;\n            e[a-1].push_back(b-1);\n            e[b-1].push_back(a-1);\n        }\n        if(n%2!=0) \n        {\n            cout<<0<<endl;\n            continue;\n        }\n        \n        vector<int> s(n+2),t(n+2),u(n+2);\n        fill(t.begin(),t.end(),0);\n        \n        s[0]=1;\n        s[1]=1;\n        REP(i,n)\n        {\n            s[i+2]=s[i]+u[i+2];\n            if(t[i+1]>0)\n                u[i+2]=t[i+1]*s[i];\n            REP(j,e[i].size())\n            {\n                if(e[i][j]>i)\n                t[e[i][j]]++;\n            }\n            //cout<<i<<\" \"<<s[i]<<endl;\n        }\n        cout<<s[n]+s[n+1]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define MOD (1000003LL)\ntypedef long long Int;\n\nint cnt[256], pos[256];\nint buf[60000];\nvoid _bsort(vector<int>::iterator begin, vector<int>::iterator end, int d) {\n    memset(cnt, 0, sizeof(cnt));\n    for(vector<int>::iterator it=begin; it!=end; it++) cnt[(*it>>d)&255]++;\n    pos[0] = 0;\n    rep(i, 255) pos[i+1] = pos[i]+cnt[i];\n    for(vector<int>::iterator it=begin; it!=end; it++) {\n        buf[pos[(*it>>d)&255]++] = *it;\n    }\n    int ix = 0;\n    for(vector<int>::iterator it=begin; it!=end; it++) *it = buf[ix++];\n}\nvoid radix_sort(vector<int>::iterator begin, vector<int>::iterator end) {\n    rep(i, 2) _bsort(begin, end, i*8);\n}\n\nint n, mi, memo[60000*4], cs[60000][2];\nvector<int> g[60000];\nbool has[60000];\n\nvoid add(int p, int q) {\n    if (p > q) swap(p, q);\n    g[p].push_back(q);\n}\n\nint pre(int p, int q) {\n    if (p+1 == q) return -1;\n    const int k = mi++;\n    has[k] = false;\n    if (g[p].back() == q) {\n        has[k] = true;\n        g[p].pop_back();\n    }\n    const int r = g[p].back();\n    rep (b, 4) memo[k*4|b] = -1;\n    cs[k][0] = pre(p, r);\n    cs[k][1] = pre(r, q);\n    return k;\n}\n\nint rec(int k, int x, int y) {\n    if (k == -1) return x == y;\n    const int sig = k*4|x*2|y;\n    if (memo[sig] != -1) return memo[sig];\n    const int p = cs[k][0], q = cs[k][1];\n    Int ans = 0;\n    rep (i, 2) ans = (ans + (Int)rec(p, x, i)*rec(q, 1-i, y)) % MOD;\n    if (x && y && has[k]) {\n        rep (i, 2) ans = (ans + (Int)rec(p, 0, i)*rec(q, 1-i, 0)) % MOD;\n    }\n    return memo[sig] = ans;\n}\n\nint main() {\n    for (;;) {\n        int m, a, b;\n        scanf(\"%d%d\", &n, &m);\n        if (n == 0) return 0;\n        rep (i, n) g[i].clear();\n        rep (_, m) {\n            scanf(\"%d%d\", &a, &b);\n            add(a-1, b-1);\n        }\n        rep (i, n) add(i, (i+1)%n);\n        rep (i, n) radix_sort(g[i].begin(), g[i].end());\n        mi = 0;\n        pre(0, n-1);\n        printf(\"%d\\n\", (int)rec(0, 1, 1));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint mod=1000003;\nstruct wolf{\n\tint l,r;\n\twolf(){}\n\twolf(int a,int b){\n\t\tl=a;r=b;\n\t}\n};\ninline bool operator<(const wolf&a,const wolf&b){\n\tif(a.l!=b.l)return a.l<b.l;\n\treturn a.r>b.r;\n}\nwolf p[51000];\nint in[51000];\nint next[51000];\nint dp[51000][2][2];\nint solve(int a,int b,int c){\n\tif(~dp[a][b][c])return dp[a][b][c];\n\tif(in[a]==-1){\n\t\tint ret=0;\n\t\tif((p[a].r-p[a].l+b+c)%2==0)return dp[a][b][c]=0;\n\t\tif(b==0&&c==0)return dp[a][b][c]=2;\n\t\treturn dp[a][b][c]=1;\n\t}\n\tlong long ret=0;\n\tlong long te=0;\n\tlong long to=0;\n\tint at;\n\tif(b==0&&c==0&&(p[a].r-p[a].l)%2){\n\t\tto=1;\n\t\tat=p[a].l;\n\t\tfor(int i=in[a];~i;i=next[i]){\n\t\t\tlong long tte;\n\t\t\tlong long tto;\n\t\t\tif((p[i].l-at)%2){\n\t\t\t\ttte=te*solve(i,1,0)+to*solve(i,0,0);\n\t\t\t\ttto=te*solve(i,1,1)+to*solve(i,0,1);\n\t\t\t}else{\n\t\t\t\ttte=te*solve(i,0,0)+to*solve(i,1,0);\n\t\t\t\ttto=te*solve(i,0,1)+to*solve(i,1,1);\n\t\t\t}\n\t\t\tte=tte;\n\t\t\tto=tto;\n\t\t\tat=p[i].r;\n\t\t}\n\t\tif((p[a].r-at)%2==0)ret=to;\n\t\telse ret=te;\n\t}\n\tte=to=0;\n\tif(b)to=1;\n\telse te=1;\n\tat=p[a].l;\n\tfor(int i=in[a];~i;i=next[i]){\n\t\tlong long tte;\n\t\tlong long tto;\n\t\tif((p[i].l-at)%2){\n\t\t\ttte=te*solve(i,1,0)+to*solve(i,0,0);\n\t\t\ttto=te*solve(i,1,1)+to*solve(i,0,1);\n\t\t}else{\n\t\t\ttte=te*solve(i,0,0)+to*solve(i,1,0);\n\t\t\ttto=te*solve(i,0,1)+to*solve(i,1,1);\n\t\t}\n\t\tte=tte;\n\t\tto=tto;\n\t\tat=p[i].r;\n\t}\n\tif((p[a].r-at)%2==!c)ret=(ret+to)%mod;\n\telse ret=(ret+te)%mod;\n\t//printf(\"%d %d %d: %d\\n\",a,b,c,ret);\n\treturn dp[a][b][c]=ret;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint s,t;scanf(\"%d%d\",&s,&t);\n\t\t\ts--;t--;\n\t\t\tp[i]=wolf(s,t);\n\t\t}\n\t\tp[b++]=wolf(0,a-1);\n\t\tif(a%2){\n\t\t\tprintf(\"0\\n\");continue;\n\t\t}\n\t\tstd::sort(p,p+b);\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint nx=lower_bound(p,p+b,wolf(p[i].r,99999999))-p;\n\t\t\tif(nx>=b)next[i]=-1;\n\t\t\telse next[i]=nx;\n\t\t\tint ni=upper_bound(p,p+b,wolf(p[i].l,p[i].r))-p;\n\t\t\tif(ni>=b||p[ni].l>=p[i].r)in[i]=-1;\n\t\t\telse in[i]=ni;\n\t\t}\n\t//\tfor(int i=0;i<b;i++)printf(\"%d %d\\n\",in[i],next[i]);\n\t\tfor(int i=0;i<b;i++)for(int j=0;j<2;j++)for(int k=0;k<2;k++)dp[i][j][k]=-1;\n\t\tprintf(\"%d\\n\",solve(0,0,0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nlong long mod=1000003;\nstruct wolf{\n\tint l,r;\n\twolf(){}\n\twolf(int a,int b){\n\t\tl=a;r=b;\n\t}\n};\ninline bool operator<(const wolf&a,const wolf&b){\n\tif(a.l!=b.l)return a.l<b.l;\n\treturn a.r>b.r;\n}\nwolf p[51000];\nint in[51000];\nint next[51000];\nint dp[51000][2][2];\n\nvoid calc(int m){\n\tfor(int A=m-1;A>=0;A--){\n\t\tfor(int B=0;B<2;B++)for(int C=0;C<2;C++){\n\t\t\tint a=A;\n\t\t\tint b=B;\n\t\t\tint c=C;\n\t\t\tif(in[a]==-1){\n\t\t\t\tint ret=0;\n\t\t\t\tif((p[a].r-p[a].l+b+c)%2==0)dp[a][b][c]=0;\n\t\t\t\telse if(b==0&&c==0)dp[a][b][c]=2;\n\t\t\t\telse dp[a][b][c]=1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint ret=0;\n\t\t\tlong long te=0;\n\t\t\tlong long to=0;\n\t\t\tint at;\n\t\t\tif(b==0&&c==0&&(p[a].r-p[a].l)%2){\n\t\t\t\tto=1;\n\t\t\t\tat=p[a].l;\n\t\t\t\tfor(int i=in[a];~i;i=next[i]){\n\t\t\t\t\tif(p[i].l>=p[a].r)break;\n\t\t\t\t\tlong long tte;\n\t\t\t\t\tlong long tto;\n\t\t\t\t\tif((p[i].l-at)%2){\n\t\t\t\t\t\ttte=te*dp[i][1][1]+to*dp[i][0][1];\n\t\t\t\t\t\ttto=te*dp[i][1][0]+to*dp[i][0][0];\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttte=te*dp[i][0][1]+to*dp[i][1][1];\n\t\t\t\t\t\ttto=te*dp[i][0][0]+to*dp[i][1][0];\n\t\t\t\t\t}\n\t\t\t\t\tte=tte%mod;\n\t\t\t\t\tto=tto%mod;\n\t\t\t\t\tat=p[i].r;\n\t\t\t\t}\n\t\t\t\tif((p[a].r-at)%2==0)ret=te;\n\t\t\t\telse ret=to;\n\t\t\t}\n\t\t\tte=to=0;\n\t\t\tif(b)to=1;\n\t\t\telse te=1;\n\t\t\tat=p[a].l;\n\t\t\tfor(int i=in[a];~i;i=next[i]){\n\t\t\t\tif(p[i].l>=p[a].r)break;\n\t\t\t\tlong long tte;\n\t\t\t\tlong long tto;\n\t\t\t\tif((p[i].l-at)%2){\n\t\t\t\t\ttte=te*dp[i][1][1]+to*dp[i][0][1];\n\t\t\t\t\ttto=te*dp[i][1][0]+to*dp[i][0][0];\n\t\t\t\t}else{\n\t\t\t\t\ttte=te*dp[i][0][1]+to*dp[i][1][1];\n\t\t\t\t\ttto=te*dp[i][0][0]+to*dp[i][1][0];\n\t\t\t\t}\n\t\t\t\tte=tte%mod;\n\t\t\t\tto=tto%mod;\n\t\t\t\tat=p[i].r;\n\t\t\t}\n\t\t\tif((p[a].r-at)%2==!c)ret=(ret+te)%mod;\n\t\t\telse ret=(ret+to)%mod;\n\t\t\tdp[a][b][c]=ret;\n\t\t}\n\t}\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint s,t;scanf(\"%d%d\",&s,&t);\n\t\t\ts--;t--;\n\t\t\tp[i]=wolf(min(s,t),max(s,t));\n\t\t}\n\t\tp[b++]=wolf(0,a-1);\n\t\tif(a%2){\n\t\t\tprintf(\"0\\n\");continue;\n\t\t}\n\t\tstd::sort(p,p+b);\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint nx=lower_bound(p,p+b,wolf(p[i].r,99999999))-p;\n\t\t\tif(nx>=b)next[i]=-1;\n\t\t\telse next[i]=nx;\n\t\t\tint ni=upper_bound(p,p+b,wolf(p[i].l,p[i].r))-p;\n\t\t\tif(ni>=b||p[ni].l>=p[i].r)in[i]=-1;\n\t\t\telse in[i]=ni;\n\t\t}\n\t\t\n\t\t//for(int i=0;i<b;i++)if((~in[i]&&in[i]<=i)||(~next[i]&&next[i]<=i))printf(\"%d %d\\n\",in[i],next[i]);\n\t\tfor(int i=0;i<b;i++)for(int j=0;j<2;j++)for(int k=0;k<2;k++)dp[i][j][k]=-1;\n\t\tcalc(b);\n\t\tprintf(\"%d\\n\",dp[0][0][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntypedef vector< pair<vi,vi> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\nset<ll> is_edge;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(vector<vi> g){\n  int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  set<ll> tmp_edge = is_edge;\n  rep(i,n){\n    deg[i] = g[i].sz; deg[i]*=-1;\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vi unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tint aa = a, bb = b;\n\tif(aa>bb)swap(aa,bb);\n\tif(aa!=bb && !tmp_edge.count(aa*mod + bb)){\n\t  g[aa].pb(bb);\n\t  g[bb].pb(aa);\n\t  tmp_edge.insert(aa*mod + bb);\n\t  deg[aa]--; deg[bb]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, int id){\n  stack<int> s;\n  s.push(id);\n\n  while(s.sz){\n    id = s.top(); s.pop();\n    \n    //for join\n    while(t[id].first.size()>2){\n      vi child(2);\n      child[0] = t[id].first.back(); t[id].first.pop_back();\n      child[1] = t[id].first.back(); t[id].first.pop_back();\n      t.push_back(make_pair(child, t[id].second));\n      t[id].first.push_back(t.size()-1);\n    }\n\n    if(t[id].first.size()==2){\n      rep(i,2){\n\tconst int &j = t[id].first[i];\n\tif(t[id].second != t[j].second){\n\t  vi child(1);\n\t  child[0] = j;\n\t  t.push_back(make_pair(child, t[id].second));\n\t  t[id].first[i] = t.size()-1;\n\t}\n      }\n    }\n\n    //for introduce & forget\n    if(t[id].first.size()==1){\n      const int &j = t[id].first[0];\n      vi child(1);\n      child[0] = j;\n      \n      vi disA, disB;\n      rep(a,t[id].second.size()){\n\tbool f = true;\n\trep(b,t[j].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disA.push_back(a);\n      }\n      rep(b,t[j].second.size()){\n\tbool f = true;\n\trep(a,t[id].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disB.push_back(b);\n      }\n      \n      if(disA.size() + disB.size() > 1){\n\tif(disA.size()>0){\n\t  vi tmp = t[id].second;\n\t  tmp.erase(tmp.begin() + disA[0]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}else{\n\t  vi tmp = t[id].second;\n\t  tmp.push_back(t[j].second[disB[0]]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}      \n      }\n    }\n    \n    //for leaf\n    if(t[id].first.size() == 0){\n      if(t[id].second.size() > 1){\n\tvi tmp;\n\trep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n\tt.push_back(make_pair(vi(), tmp));\n\tt[id].first.push_back(t.size()-1);\n      }\n    }\n\n    rep(i,t[id].first.size()){\n      s.push(t[id].first[i]);\n    }\n  }\n}\n\nunordered_map<ll,ll> memo;\n\nll rec(int id, int use, const TD &t){\n  ll key = mod*id + use;\n\n  stack<ll> s;\n  s.push(key);\n\n  while(s.sz){\n    ll res = 0;\n    key = s.top(); s.pop();\n    id = key/mod; use = key%mod;\n    const vi& child = t[id].fs, bag = t[id].sc;\n    \n    //for leaf\n    if(child.sz==0){\n      memo[key] = use;\n      goto END;\n    }\n    \n    if(child.sz==1){\n      const vi &nbag = t[child[0]].second;\n      vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n      rep(i,bag.size())rep(j,nbag.size()){\n\tif(bag[i] == nbag[j]){\n\t  to_bag[j] = i; to_nbag[i] = j;\n\t}\n      }\n      \n      //for introduce\n      if(nbag.sz < bag.sz){\n\tint nuse = 0;\n\trep(i,bag.sz){\n\t  if(to_nbag[i]<0){\n\t    if( ((use>>i)&1) == 0 ){\n\t      memo[key] = 0;\n\t      goto END;\n\t    }\n\t  }else{\n\t    if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t  }\n\t}\n\tll nxt = child[0]*mod + nuse;\n\tif(memo.count(nxt)){\n\t  memo[key] = memo[nxt];\n\t  goto END;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n      }\n      \n      //for forget\n      if(nbag.sz > bag.sz){\n\tint add = -1,  nuse = 0;\n\trep(i,nbag.sz){\n\t  if(to_bag[i]<0)add = i;\n\t  else if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n\t}\n\t\n\tqueue<ll> uncal;\n\tll res = 0, nxt = child[0]*mod + nuse;\n\tif(memo.count(nxt)){\n\t  (res += memo[nxt]) %= mod;\n\t}else{\n\t  uncal.push(nxt);\n\t}\n\n\trep(i,bag.sz){\n\t  if((use>>i)&1)continue;\n\t  \n\t  int a = bag[i], b = nbag[add];\n\t  if(a>b)swap(a,b);\n\t  if(is_edge.count(a*mod + b)){\n\t    nxt = child[0]*mod + (nuse | (1<<add) | (1<<to_nbag[i]));\n\t    if(memo.count(nxt)){\n\t      (res += memo[nxt]) %= mod;\n\t    }else{\n\t      uncal.push(nxt);\n\t    }\n\t  }\n\t}\n\n\tif(uncal.sz){\n\t  s.push(key); while(uncal.sz){ s.push(uncal.front()); uncal.pop(); }\n\t  goto END;\n\t}else{\n\t  memo[key] = res;\n\t  goto END;\n\t}\n      }\n    }\n    \n    //for join\n    if(child.sz==2){\n      int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n      queue<ll> uncal;\n      do{\n\tll nxt1 = child[0]*mod + (use|sub), nxt2 = child[1]*mod + (use|(unuse-sub));\n\tif(memo.count(nxt1) == 0){\n\t  uncal.push(nxt1);\n\t}\n\tif(memo.count(nxt2) == 0){\n\t  uncal.push(nxt2);\n\t}\n\tif(memo.count(nxt1) && memo.count(nxt2)){\n\t  res += memo[nxt1] * memo[nxt2];\n\t  res %= mod;\n\t}\n\tsub = (sub-1)&unuse;\n      }while(sub != unuse);\n    \n      if(uncal.sz){\n\ts.push(key); while(uncal.sz){ s.push(uncal.front()); uncal.pop(); }\n\tgoto END;\n      }else{\n\tmemo[key] = res;\n\tgoto END;\n      }\n    }\n  END:;\n  }\n  return memo[key];\n}\n\nvoid visg(vector<vi> g){\n  int n = g.size();\n  cout << \"graph {\" << endl;\n  rep(i,n){\n    rep(k,g[i].sz){\n      if(i<g[i][k]){\n\tcout << \"  \\\"\" << i << \" \";\n\tcout << \"\\\" -- \\\"\" << g[i][k] << \" \";\n\tcout << \"\\\"\" << endl;\n      }\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nvoid vis(TD t){\n  int n = t.size();\n  cout << \"digraph {\" << endl;\n  rep(i,n){\n    rep(k,t[i].first.size()){\n      int nxt = t[i].first[k];\n      cout << \"  \\\"\" << i << \": \";\n      rep(j,t[i].second.size())cout << t[i].second[j] << \" \";\n      cout << \"\\\" -> \\\"\" << nxt << \": \";\n      rep(j,t[nxt].second.size())cout << t[nxt].second[j] << \" \";\n      cout << \"\\\"\" << endl;\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nint main(){\n  int n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    vector<vi> g(n);\n    is_edge.clear();\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*mod + b);\n      else is_edge.insert(b*mod + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*mod + b);\n      else is_edge.insert(b*mod + a);\n    }\n\n    //visg(g);\n    TD t = heuristic_tree_decomposition(g);\n    //cout << t.size() << endl;\n    //vis(t);\n    toNice(t,0);\n    //cout << t.size() << endl;\n    //vis(t);\n\n    ll res = 0;\n    memo.clear();\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      res += rec(0,use,t);\n      res %= mod;\n    }\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntypedef vector< pair<vi,vi> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\nset<ll> is_edge;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(vector<vi> &g){\n  int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  set<ll> tmp_edge = is_edge;\n  rep(i,n){\n    deg[i] = g[i].sz; deg[i]*=-1;\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vi unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tint aa = a, bb = b;\n\tif(aa>bb)swap(aa,bb);\n\tif(aa!=bb && !tmp_edge.count(aa*mod + bb)){\n\t  g[aa].pb(bb);\n\t  g[bb].pb(aa);\n\t  tmp_edge.insert(aa*mod + bb);\n\t  deg[aa]--; deg[bb]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, int id){\n  stack<int> s;\n  s.push(id);\n\n  while(s.sz){\n    id = s.top(); s.pop();\n    \n    //for join\n    while(t[id].first.size()>2){\n      vi child(2);\n      child[0] = t[id].first.back(); t[id].first.pop_back();\n      child[1] = t[id].first.back(); t[id].first.pop_back();\n      t.push_back(make_pair(child, t[id].second));\n      t[id].first.push_back(t.size()-1);\n    }\n\n    if(t[id].first.size()==2){\n      rep(i,2){\n\tconst int &j = t[id].first[i];\n\tif(t[id].second != t[j].second){\n\t  vi child(1);\n\t  child[0] = j;\n\t  t.push_back(make_pair(child, t[id].second));\n\t  t[id].first[i] = t.size()-1;\n\t}\n      }\n    }\n\n    //for introduce & forget\n    if(t[id].first.size()==1){\n      const int &j = t[id].first[0];\n      vi child(1);\n      child[0] = j;\n      \n      vi disA, disB;\n      rep(a,t[id].second.size()){\n\tbool f = true;\n\trep(b,t[j].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disA.push_back(a);\n      }\n      rep(b,t[j].second.size()){\n\tbool f = true;\n\trep(a,t[id].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disB.push_back(b);\n      }\n      \n      if(disA.size() + disB.size() > 1){\n\tif(disA.size()>0){\n\t  vi tmp = t[id].second;\n\t  tmp.erase(tmp.begin() + disA[0]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}else{\n\t  vi tmp = t[id].second;\n\t  tmp.push_back(t[j].second[disB[0]]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}      \n      }\n    }\n    \n    //for leaf\n    if(t[id].first.size() == 0){\n      if(t[id].second.size() > 1){\n\tvi tmp;\n\trep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n\tt.push_back(make_pair(vi(), tmp));\n\tt[id].first.push_back(t.size()-1);\n      }\n    }\n\n    rep(i,t[id].first.size()){\n      s.push(t[id].first[i]);\n    }\n  }\n}\n\nunordered_map<ll,ll> memo;\n\nll rec(int id, int use, const TD &t){\n  ll key = mod*id + use;\n\n  stack<ll> s;\n  s.push(key);\n\n  while(s.sz){\n    ll res = 0;\n    key = s.top(); s.pop();\n    id = key/mod; use = key%mod;\n    const vi& child = t[id].fs, bag = t[id].sc;\n    \n    //for leaf\n    if(child.sz==0){\n      memo[key] = use;\n      goto END;\n    }\n    \n    if(child.sz==1){\n      const vi &nbag = t[child[0]].second;\n      vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n      rep(i,bag.size())rep(j,nbag.size()){\n\tif(bag[i] == nbag[j]){\n\t  to_bag[j] = i; to_nbag[i] = j;\n\t}\n      }\n      \n      //for introduce\n      if(nbag.sz < bag.sz){\n\tint nuse = 0;\n\trep(i,bag.sz){\n\t  if(to_nbag[i]<0){\n\t    if( ((use>>i)&1) == 0 ){\n\t      memo[key] = 0;\n\t      goto END;\n\t    }\n\t  }else{\n\t    if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t  }\n\t}\n\tll nxt = child[0]*mod + nuse;\n\tif(memo.count(nxt)){\n\t  memo[key] = memo[nxt];\n\t  goto END;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n      }\n      \n      //for forget\n      if(nbag.sz > bag.sz){\n\tint add = -1,  nuse = 0;\n\trep(i,nbag.sz){\n\t  if(to_bag[i]<0)add = i;\n\t  else if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n\t}\n\t\n\tll res = 0, nxt = child[0]*mod + nuse;\n\tif(memo.count(nxt)){\n\t  (res += memo[nxt]) %= mod;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n\n\trep(i,bag.sz){\n\t  if((use>>i)&1)continue;\n\t  \n\t  int a = bag[i], b = nbag[add];\n\t  if(a>b)swap(a,b);\n\t  if(is_edge.count(a*mod + b)){\n\t    nxt = child[0]*mod + (nuse | (1<<add) | (1<<to_nbag[i]));\n\t    if(memo.count(nxt)){\n\t      (res += memo[nxt]) %= mod;\n\t    }else{\n\t      s.push(key); s.push(nxt);\n\t      goto END;\n\t    }\n\t  }\n\t}\n\tmemo[key] = res;\n      }\n    }\n    \n    //for join\n    if(child.sz==2){\n      int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n      queue<ll> uncal;\n      do{\n\tll nxt1 = child[0]*mod + (use|sub), nxt2 = child[1]*mod + (use|(unuse-sub));\n\tif(memo.count(nxt1) == 0){\n\t  s.push(key); s.push(nxt1);\n\t  goto END;\n\t}\n\tif(memo.count(nxt2) == 0){\n\t  s.push(key); s.push(nxt2);\n\t  goto END;\n\t}\n\tif(memo.count(nxt1) && memo.count(nxt2)){\n\t  res += memo[nxt1] * memo[nxt2];\n\t  res %= mod;\n\t}\n\tsub = (sub-1)&unuse;\n      }while(sub != unuse);\n    \n      memo[key] = res;\n    }\n  END:;\n  }\n  return memo[key];\n}\n\nvoid visg(vector<vi> g){\n  int n = g.size();\n  cout << \"graph {\" << endl;\n  rep(i,n){\n    rep(k,g[i].sz){\n      if(i<g[i][k]){\n\tcout << \"  \\\"\" << i << \" \";\n\tcout << \"\\\" -- \\\"\" << g[i][k] << \" \";\n\tcout << \"\\\"\" << endl;\n      }\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nvoid vis(TD t){\n  int n = t.size();\n  cout << \"digraph {\" << endl;\n  rep(i,n){\n    rep(k,t[i].first.size()){\n      int nxt = t[i].first[k];\n      cout << \"  \\\"\" << i << \": \";\n      rep(j,t[i].second.size())cout << t[i].second[j] << \" \";\n      cout << \"\\\" -> \\\"\" << nxt << \": \";\n      rep(j,t[nxt].second.size())cout << t[nxt].second[j] << \" \";\n      cout << \"\\\"\" << endl;\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nint main(){\n  int n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    vector<vi> g(n);\n    is_edge.clear();\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*mod + b);\n      else is_edge.insert(b*mod + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*mod + b);\n      else is_edge.insert(b*mod + a);\n    }\n\n    //visg(g);\n    TD t = heuristic_tree_decomposition(g);\n    g.clear();\n    //cout << t.size() << endl;\n    //vis(t);\n    toNice(t,0);\n    //cout << t.size() << endl;\n    //vis(t);\n\n    ll res = 0;\n    memo.clear();\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      res += rec(0,use,t);\n      res %= mod;\n    }\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define MOD (1000003LL)\ntypedef long long Int;\n\nint n, mi, memo[60000*4], cs[60000][2], w[60000];\nvector<int> g[60000];\nbool has[60000];\n\nvoid add(int p, int q) {\n    if (p > q) swap(p, q);\n    g[p].push_back(q);\n}\n\nint pre(int p, int q) {\n    if (p+1 == q) return -1;\n    const int k = mi++;\n    w[k] = q-p+1;\n    has[k] = false;\n    if (g[p].back() == q) {\n        has[k] = true;\n        g[p].pop_back();\n    }\n    const int r = g[p].back();\n    rep (b, 4) memo[k*4|b] = -1;\n    cs[k][0] = pre(p, r);\n    cs[k][1] = pre(r, q);\n    return k;\n}\n\nint rec(int k, int b) {\n    if (w[k]%2 == 1 && (b == 0 || b == 3)) return 0;\n    if (w[k]%2 == 0 && (b == 1 || b == 2)) return 0;\n    if (k == -1) return b == 0 || b == 3;\n    const int sig = k*4|b;\n    if (memo[sig] != -1) return memo[sig];\n    const int x = b&2, y = b&1;\n    const int p = cs[k][0], q = cs[k][1];\n    Int ans = 0;\n    ans += (Int)rec(p, x) * rec(q, 2|y);\n    ans += (Int)rec(p, x|1) * rec(q, y);\n    if (b==3 && has[k]) {\n        ans += (Int)rec(p, 0) * rec(q, 2);\n        ans += (Int)rec(p, 1) * rec(q, 0);\n    }\n    return memo[sig] = ans % MOD;\n}\n\nint main() {\n    for (;;) {\n        int m, a, b;\n        scanf(\"%d%d\", &n, &m);\n        if (n == 0) return 0;\n        rep (_, m) {\n            scanf(\"%d%d\", &a, &b);\n            add(a-1, b-1);\n        }\n        rep (i, n) add(i, (i+1)%n);\n        rep (i, n) sort(g[i].begin(), g[i].end());\n        mi = 0;\n        pre(0, n-1);\n        printf(\"%d\\n\", rec(0, 3));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2405\"\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define call_from_test\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n//END CUT HERE\n#ifndef call_from_test\nsigned main(){\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\n// Assume Connected\nstruct NiceTree{\n  vector< vector<int> > G;\n  vector< set<int> > ex;\n  vector<int> buff;\n  NiceTree(int n):G(n),ex(n),buff(n){}\n\n  void add_edge(int u,int v){\n    if(u>v) swap(u,v);\n    if(ex[u].count(v)) return;\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n    ex[u].emplace(v);\n  }\n\n  enum Type{LEAF, JOIN, INTRODUCE, FORGET};\n  struct Node{\n    int type;\n\n    // index for G\n    vector<int> bag;\n    void add_vertex(int v){bag.emplace_back(v);}\n\n    // index for T\n    vector<int> child;\n    void add_child(int v){child.emplace_back(v);}\n  };\n\n  vector<Node> T;\n  void to_nice(){\n    for(auto &v:T)\n      sort(v.bag.begin(),v.bag.end());\n\n    stack<int> st;\n    st.emplace(0);\n\n    while(!st.empty()){\n      int v=st.top();st.pop();\n\n      while(T[v].child.size()>2){\n        Node r;\n        r.add_child(T[v].child.back());\n        T[v].child.pop_back();\n        r.add_child(T[v].child.back());\n        T[v].child.pop_back();\n        r.bag=T[v].bag;\n        T[v].add_child(T.size());\n        T.emplace_back(r);\n      }\n\n      if(T[v].child.size()==2){\n        for(auto &u:T[v].child){\n          if(T[u].bag!=T[v].bag){\n            Node r;\n            r.add_child(u);\n            r.bag=T[v].bag;\n            u=T.size();\n            T.emplace_back(r);\n          }\n        }\n        T[v].type=JOIN;\n      }\n\n      if(T[v].child.size()==1){\n        int &u=T[v].child[0];\n        vector<int> latte,malta;\n        auto &ps=T[v].bag;\n        auto &qs=T[u].bag;\n        set_difference(ps.begin(),ps.end(),qs.begin(),qs.end(),\n                       back_inserter(latte));\n        set_difference(qs.begin(),qs.end(),ps.begin(),ps.end(),\n                       back_inserter(malta));\n        if(latte.size()+malta.size()>1){\n          Node r;\n          r.add_child(u);\n          r.bag=T[v].bag;\n          if(!latte.empty()){\n            r.bag.erase(find(r.bag.begin(),r.bag.end(),latte.back()));\n          }else{\n            r.bag.emplace_back(malta.back());\n          }\n          u=T.size();\n          T.emplace_back(r);\n        }\n        if(T[v].bag.size()<T[u].bag.size()) T[v].type=FORGET;\n        if(T[v].bag.size()>T[u].bag.size()) T[v].type=INTRODUCE;\n      }\n\n      if(T[v].child.empty()){\n        if(T[v].bag.size()>1){\n          Node r;\n          r.bag=T[v].bag;\n          r.bag.pop_back();\n          T[v].type=INTRODUCE;\n          T[v].add_child(T.size());\n          T.emplace_back(r);\n        }else{\n          T[v].type=LEAF;\n        }\n      }\n\n      for(auto &u:T[v].child)\n        st.emplace(u);\n    }\n  }\n\n  // root = 0\n  void build(){\n    int n=G.size();\n    if(n<=3){\n      Node r;\n      for(int i=0;i<n;i++) r.add_vertex(i);\n      T=vector<Node>({r});\n      return to_nice();\n    }\n\n    vector<int> deg(n);\n    queue<int> que;\n    for(int i=0;i<n;i++){\n      deg[i]=G[i].size();\n      if(deg[i]<=2) que.emplace(i);\n    }\n\n    vector<int> used(n,-1);\n    T.emplace_back();\n    while(!que.empty()){\n      int v=que.front();que.pop();\n      if(deg[v]>2||used[v]!=-1) continue;\n      Node r;\n      r.add_vertex(v);\n\n      int p=-1,q=-1;\n      for(int u:G[v]){\n        if(used[u]==-1){\n          (p==-1?p:q)=u;\n          r.add_vertex(u);\n        }else if(used[u]>=0){\n          r.add_child(used[u]);\n          used[u]=-2;\n        }\n      }\n\n      if(deg[v]==0){\n        used[v]=T.size();\n        T.emplace_back(r);\n        continue;\n      }\n\n      if(q==-1){\n        deg[p]--;\n      }else{\n        if(p>q) swap(p,q);\n        if(!ex[p].count(q)){\n          add_edge(p,q);\n        }else{\n          deg[p]--;\n          deg[q]--;\n        }\n      }\n      for(int u:G[v])\n        if(deg[u]<=2) que.emplace(u);\n      deg[v]=0;\n      used[v]=T.size();\n      T.emplace_back(r);\n    }\n\n    for(int i=0;i<n;i++){\n      if(deg[i]>0){\n        T={};\n        return;\n      }\n    }\n\n    T.front()=T.back();T.pop_back();\n    to_nice();\n  }\n\n  template<typename F1,typename F2,typename F3,typename F4>\n  void dfs(int v,F1 &leaf,F2 &join,F3 &introduce,F4 &forget){\n    const auto &chd=T[v].child;\n    for(int u:chd) dfs(u,leaf,join,introduce,forget);\n\n    if(T[v].type==LEAF){\n      leaf(v);\n      return;\n    }\n    if(T[v].type==JOIN){\n      join(v);\n      return;\n    }\n\n    const auto &bag=T[v].bag;\n    for(int i=0;i<(int)bag.size();i++)\n      buff[bag[i]]=1<<i;\n\n    const auto &chd_bag=T[chd[0]].bag;\n    int dif=0;\n    for(int b:bag) dif^=b;\n    for(int b:chd_bag) dif^=b;\n\n    if(T[v].type==INTRODUCE){\n      introduce(v,dif);\n      return;\n    }\n    if(T[v].type==FORGET){\n      forget(v,dif);\n      return;\n    }\n  }\n};\n//END CUT HERE\n#ifndef call_from_test\n\n#define call_from_test\n#include \"../tools/fastio.cpp\"\n#include \"../tools/chminmax.cpp\"\n#undef call_from_test\n\nsigned CSA_SPECIAL_MVC(){\n  int n,m;\n  cin>>n>>m;\n  NiceTree G(n);\n  using P = pair<int, int>;\n  set<P> es;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    G.add_edge(a,b);\n    es.emplace(a,b);\n    es.emplace(b,a);\n  }\n\n  G.build();\n  auto &T=G.T;\n  auto &buff=G.buff;\n\n  vector< vector<int> > dps(T.size());\n\n  const int INF = 1e9;\n  auto base=\n    [&](int v){\n      const auto &bag=T[v].bag;\n      auto &dp=dps[v];\n      dp.assign(1<<bag.size(),-INF);\n    };\n\n  auto leaf=\n    [&](int v){\n      base(v);\n      auto &dp=dps[v];\n      dp[0]=0;\n      dp[1]=1;\n    };\n\n  auto join=\n    [&](int v){\n      base(v);\n      const auto &chd=T[v].child;\n      auto &dp=dps[v];\n      for(int i=0;i<(int)dp.size();i++)\n        chmax(dp[i],dps[chd[0]][i]+dps[chd[1]][i]-__builtin_popcount(i));\n    };\n\n  auto introduce=\n    [&](int v,int add){\n      base(v);\n\n      const auto &chd=T[v].child;\n      const auto &chd_bag=T[chd[0]].bag;\n      const auto &pr=dps[chd[0]];\n\n      auto &dp=dps[v];\n      for(int i=0;i<(int)pr.size();i++){\n        int bit=0,valid=1;\n        for(int j=0;j<(int)chd_bag.size();j++){\n          if((~i>>j)&1) continue;\n          bit|=buff[chd_bag[j]];\n          valid&=!es.count(P(chd_bag[j],add));\n        }\n        assert(!(bit&buff[add]));\n        if(valid) chmax(dp[bit|buff[add]],pr[i]+1);\n        chmax(dp[bit],pr[i]);\n      }\n    };\n\n  auto forget=\n    [&](int v,int rmv){\n      base(v);\n\n      const auto &chd=T[v].child;\n      const auto &chd_bag=T[chd[0]].bag;\n      const auto &pr=dps[chd[0]];\n\n      auto &dp=dps[v];\n      for(int i=0;i<(int)pr.size();i++){\n        int bit=0;\n        for(int j=0;j<(int)chd_bag.size();j++){\n          if((~i>>j)&1) continue;\n          if(rmv!=chd_bag[j]) bit|=buff[chd_bag[j]];\n        }\n        chmax(dp[bit],pr[i]);\n      }\n    };\n\n  G.dfs(0,leaf,join,introduce,forget);\n  auto &dp=dps[0];\n  cout<<n-*max_element(dp.begin(),dp.end())<<endl;\n  return 0;\n}\n/*\n  verified 2020/02/21\n  https://csacademy.com/contest/archive/task/special-mvc/statement/\n*/\n\nsigned main(){\n  CSA_SPECIAL_MVC();\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;}\n  Mint operator-(Mint a) const{return Mint(v)-=a;}\n  Mint operator*(Mint a) const{return Mint(v)*=a;}\n  Mint operator/(Mint a) const{return Mint(v)/=a;}\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n//END CUT HERE\n#ifndef call_from_test\n\n//INSERT ABOVE HERE\nsigned ABC127_E(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int h,w,k;\n  cin>>h>>w>>k;\n  using M = Mint<int>;\n\n  M ans{0};\n  for(int d=1;d<h;d++)\n    ans+=M(d)*M(h-d)*M(w)*M(w);\n\n  for(int d=1;d<w;d++)\n    ans+=M(d)*M(w-d)*M(h)*M(h);\n\n  ans*=M::comb(h*w-2,k-2);\n  cout<<ans<<endl;\n  return 0;\n}\n/*\n  verified on 2019/06/12\n  https://atcoder.jp/contests/abc127/tasks/abc127_e\n*/\n\nsigned main(){\n  //ABC127_E();\n  return 0;\n}\n#endif\n\n#undef call_from_test\n\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    NiceTree G(n);\n    using P = pair<int, int>;\n    set<P> es;\n    for(int i=0;i<n;i++){\n      int j=(i+1)%n;\n      G.add_edge(i,j);\n      es.emplace(i,j);\n      es.emplace(j,i);\n    }\n    for(int i=0;i<m;i++){\n      int a,b;\n      cin>>a>>b;\n      a--;b--;\n      G.add_edge(a,b);\n      es.emplace(a,b);\n      es.emplace(b,a);\n    }\n    if(n&1){\n      cout<<0<<endl;\n      continue;\n    }\n    G.build();\n    auto &T=G.T;\n    auto &buff=G.buff;\n\n    using M = Mint<int, 1000003>;\n    vector<vector<M>> dps(T.size());\n\n    auto base=\n      [&](int v){\n        const auto &bag=T[v].bag;\n        auto &dp=dps[v];\n        dp.assign(1<<bag.size(),0);\n      };\n\n    auto leaf=\n      [&](int v){\n        base(v);\n        auto &dp=dps[v];\n        dp[0]=M(1);\n      };\n\n    auto join=\n      [&](int v){\n        base(v);\n        const auto &chd=T[v].child;\n        auto &dp=dps[v];\n\n        for(int i=0;i<(int)dp.size();i++)\n          for(int j=0;j<(int)dp.size();j++)\n            if((i&j)==0) dp[i|j]+=dps[chd[0]][i]*dps[chd[1]][j];\n      };\n\n    auto introduce=\n      [&](int v,int){\n        base(v);\n        const auto &chd=T[v].child;\n\n        const auto &chd_bag=T[chd[0]].bag;\n        const auto &pr=dps[chd[0]];\n\n        auto &dp=dps[v];\n        for(int i=0;i<(int)pr.size();i++){\n          int bit=0;\n          for(int j=0;j<(int)chd_bag.size();j++)\n            if((i>>j)&1) bit|=buff[chd_bag[j]];\n          dp[bit]=pr[i];\n        }\n      };\n\n    auto forget=\n      [&](int v,int rmv){\n        base(v);\n        const auto &bag=T[v].bag;\n        const auto &chd=T[v].child;\n\n        const auto &chd_bag=T[chd[0]].bag;\n        const auto &pr=dps[chd[0]];\n\n        auto &dp=dps[v];\n\n        for(int i=0;i<(int)pr.size();i++){\n          int bit=0,used=0;\n          for(int j=0;j<(int)chd_bag.size();j++){\n            if((~i>>j)&1) continue;\n            if(rmv==chd_bag[j]) used=1;\n            if(rmv!=chd_bag[j]) bit|=buff[chd_bag[j]];\n          }\n          if(!used){\n            for(int j=0;j<(int)bag.size();j++){\n              if((bit>>j)&1) continue;\n              if(es.count(P(bag[j],rmv))) dp[bit|(1<<j)]+=pr[i];\n            }\n          }else{\n            dp[bit]+=pr[i];\n          }\n        }\n      };\n\n    G.dfs(0,leaf,join,introduce,forget);\n\n    auto &dp=dps[0];\n    if(es.count(P(T[0].bag[0],T[0].bag[1])))\n      dp.back()+=dp[0];\n    cout<<dp.back()<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define MOD (1000003LL)\ntypedef long long Int;\n\nint n, mi, memo[60000*4], cs[60000][2];\nvector<int> g[60000];\nbool has[60000];\n\nvoid add(int p, int q) {\n    if (p > q) swap(p, q);\n    g[p].push_back(q);\n}\n\nint pre(int p, int q) {\n    if (p+1 == q) return -1;\n    const int k = mi++;\n    has[k] = false;\n    if (g[p].back() == q) {\n        has[k] = true;\n        g[p].pop_back();\n    }\n    const int r = g[p].back();\n    rep (b, 4) memo[k*4|b] = -1;\n    cs[k][0] = pre(p, r);\n    cs[k][1] = pre(r, q);\n    return k;\n}\n\nint rec(int k, int x, int y) {\n    if (k == -1) return x == y;\n    const int sig = k*4|x*2|y;\n    if (memo[sig] != -1) return memo[sig];\n    const int p = cs[k][0], q = cs[k][1];\n    Int ans = 0;\n    ans += (Int)rec(p, x, 0) * rec(q, 1, y);\n    ans += (Int)rec(p, x, 1) * rec(q, 0, y);\n    if (x && y && has[k]) {\n        ans += (Int)rec(p, 0, 0) * rec(q, 1, 0);\n        ans += (Int)rec(p, 0, 1) * rec(q, 0, 0);\n    }\n    return memo[sig] = ans % MOD;\n}\n\nint main() {\n    for (;;) {\n        int m, a, b;\n        scanf(\"%d%d\", &n, &m);\n        if (n == 0) return 0;\n        rep (_, m) {\n            scanf(\"%d%d\", &a, &b);\n            add(a-1, b-1);\n        }\n        rep (i, n) add(i, (i+1)%n);\n        rep (i, n) sort(g[i].begin(), g[i].end());\n        mi = 0;\n        pre(0, n-1);\n        printf(\"%d\\n\", rec(0, 1, 1));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define MOD (1000003LL)\ntypedef long long Int;\n\nint n, mi, cs[60000][2], dp[60000][2][2];\nvector<int> g[60000];\nbool has[60000];\n\ninline int f(int k, int x, int y) { return k == -1 ? x==y : dp[k][x][y]; }\n\nvoid add(int p, int q) {\n    if (p > q) swap(p, q);\n    g[p].push_back(q);\n}\n\nint pre(int p, int q) {\n    if (p+1 == q) return -1;\n    const int k = mi++;\n    has[k] = 0;\n    if (g[p].back() == q) has[k] = 1, g[p].pop_back();\n    const int r = g[p].back();\n    cs[k][0] = pre(p, r);\n    cs[k][1] = pre(r, q);\n    return k;\n}\n\nint main() {\n    for (;;) {\n        int m, a, b;\n        scanf(\"%d%d\", &n, &m);\n        if (n == 0) return 0;\n        rep (_, m) {\n            scanf(\"%d%d\", &a, &b);\n            add(a-1, b-1);\n        }\n        rep (i, n) add(i, (i+1)%n);\n        rep (i, n) sort(g[i].begin(), g[i].end());\n        mi = 0;\n        pre(0, n-1);\n        for (int k = mi-1; k >= 0; k--) {\n            const int p = cs[k][0], q = cs[k][1];\n#define F(x, y) ((Int)f(p, x, 0)*f(q, 1, y) + (Int)f(p, x, 1)*f(q, 0, y))\n            dp[k][0][0] = F(0, 0) % MOD;\n            dp[k][0][1] = F(0, 1) % MOD;\n            dp[k][1][0] = F(1, 0) % MOD;\n            dp[k][1][1] = F(1, 1);\n            if (has[k]) dp[k][1][1] += F(0, 0);\n            dp[k][1][1] %= MOD;\n        }\n        printf(\"%d\\n\", dp[0][1][1]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntypedef vector< pair<vi,vi> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\nset<ll> is_edge;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(vector<vi> &g){\n  int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  set<ll> tmp_edge = is_edge;\n  rep(i,n){\n    deg[i] = g[i].sz; deg[i]*=-1;\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vi unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tint aa = a, bb = b;\n\tif(aa>bb)swap(aa,bb);\n\tif(aa!=bb && !tmp_edge.count(aa*mod + bb)){\n\t  g[aa].pb(bb);\n\t  g[bb].pb(aa);\n\t  tmp_edge.insert(aa*mod + bb);\n\t  deg[aa]--; deg[bb]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, int id){\n  stack<int> s;\n  s.push(id);\n\n  while(s.sz){\n    id = s.top(); s.pop();\n    \n    //for join\n    while(t[id].first.size()>2){\n      vi child(2);\n      child[0] = t[id].first.back(); t[id].first.pop_back();\n      child[1] = t[id].first.back(); t[id].first.pop_back();\n      t.push_back(make_pair(child, t[id].second));\n      t[id].first.push_back(t.size()-1);\n    }\n\n    if(t[id].first.size()==2){\n      rep(i,2){\n\tconst int &j = t[id].first[i];\n\tif(t[id].second != t[j].second){\n\t  vi child(1);\n\t  child[0] = j;\n\t  t.push_back(make_pair(child, t[id].second));\n\t  t[id].first[i] = t.size()-1;\n\t}\n      }\n    }\n\n    //for introduce & forget\n    if(t[id].first.size()==1){\n      const int &j = t[id].first[0];\n      vi child(1);\n      child[0] = j;\n      \n      vi disA, disB;\n      rep(a,t[id].second.size()){\n\tbool f = true;\n\trep(b,t[j].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disA.push_back(a);\n      }\n      rep(b,t[j].second.size()){\n\tbool f = true;\n\trep(a,t[id].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disB.push_back(b);\n      }\n      \n      if(disA.size() + disB.size() > 1){\n\tif(disA.size()>0){\n\t  vi tmp = t[id].second;\n\t  tmp.erase(tmp.begin() + disA[0]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}else{\n\t  vi tmp = t[id].second;\n\t  tmp.push_back(t[j].second[disB[0]]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}      \n      }\n    }\n    \n    //for leaf\n    if(t[id].first.size() == 0){\n      if(t[id].second.size() > 1){\n\tvi tmp;\n\trep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n\tt.push_back(make_pair(vi(), tmp));\n\tt[id].first.push_back(t.size()-1);\n      }\n    }\n\n    rep(i,t[id].first.size()){\n      s.push(t[id].first[i]);\n    }\n  }\n}\n\nunordered_map<int,ll> memo;\n\nll rec(int id, int use, const TD &t){\n  int key = 100*id + use;\n\n  stack<int> s;\n  s.push(key);\n\n  while(s.sz){\n    ll res = 0;\n    key = s.top(); s.pop();\n    id = key/100; use = key%100;\n    const vi& child = t[id].fs, bag = t[id].sc;\n    \n    //for leaf\n    if(child.sz==0){\n      memo[key] = use;\n      goto END;\n    }\n    \n    if(child.sz==1){\n      const vi &nbag = t[child[0]].second;\n      vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n      rep(i,bag.size())rep(j,nbag.size()){\n\tif(bag[i] == nbag[j]){\n\t  to_bag[j] = i; to_nbag[i] = j;\n\t}\n      }\n      \n      //for introduce\n      if(nbag.sz < bag.sz){\n\tint nuse = 0;\n\trep(i,bag.sz){\n\t  if(to_nbag[i]<0){\n\t    if( ((use>>i)&1) == 0 ){\n\t      memo[key] = 0;\n\t      goto END;\n\t    }\n\t  }else{\n\t    if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t  }\n\t}\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  memo[key] = memo[nxt];\n\t  goto END;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n      }\n      \n      //for forget\n      if(nbag.sz > bag.sz){\n\tint add = -1,  nuse = 0;\n\trep(i,nbag.sz){\n\t  if(to_bag[i]<0)add = i;\n\t  else if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n\t}\n\t\n\tll res = 0;\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  (res += memo[nxt]) %= mod;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n\n\trep(i,bag.sz){\n\t  if((use>>i)&1)continue;\n\t  \n\t  int a = bag[i], b = nbag[add];\n\t  if(a>b)swap(a,b);\n\t  if(is_edge.count(a*mod + b)){\n\t    nxt = child[0]*100 + (nuse | (1<<add) | (1<<to_nbag[i]));\n\t    if(memo.count(nxt)){\n\t      (res += memo[nxt]) %= mod;\n\t    }else{\n\t      s.push(key); s.push(nxt);\n\t      goto END;\n\t    }\n\t  }\n\t}\n\tmemo[key] = res;\n      }\n    }\n    \n    //for join\n    if(child.sz==2){\n      int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n      do{\n\tint nxt1 = child[0]*100 + (use|sub), nxt2 = child[1]*100 + (use|(unuse-sub));\n\tif(memo.count(nxt1) == 0){\n\t  s.push(key); s.push(nxt1);\n\t  goto END;\n\t}\n\tif(memo.count(nxt2) == 0){\n\t  s.push(key); s.push(nxt2);\n\t  goto END;\n\t}\n\tif(memo.count(nxt1) && memo.count(nxt2)){\n\t  res += memo[nxt1] * memo[nxt2];\n\t  res %= mod;\n\t}\n\tsub = (sub-1)&unuse;\n      }while(sub != unuse);\n    \n      memo[key] = res;\n    }\n  END:;\n  }\n  return memo[key];\n}\n\nvoid visg(vector<vi> g){\n  int n = g.size();\n  cout << \"graph {\" << endl;\n  rep(i,n){\n    rep(k,g[i].sz){\n      if(i<g[i][k]){\n\tcout << \"  \\\"\" << i << \" \";\n\tcout << \"\\\" -- \\\"\" << g[i][k] << \" \";\n\tcout << \"\\\"\" << endl;\n      }\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nvoid vis(TD t){\n  int n = t.size();\n  cout << \"digraph {\" << endl;\n  rep(i,n){\n    rep(k,t[i].first.size()){\n      int nxt = t[i].first[k];\n      cout << \"  \\\"\" << i << \": \";\n      rep(j,t[i].second.size())cout << t[i].second[j] << \" \";\n      cout << \"\\\" -> \\\"\" << nxt << \": \";\n      rep(j,t[nxt].second.size())cout << t[nxt].second[j] << \" \";\n      cout << \"\\\"\" << endl;\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nint main(){\n  int n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    vector<vi> g(n);\n    is_edge.clear();\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*mod + b);\n      else is_edge.insert(b*mod + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*mod + b);\n      else is_edge.insert(b*mod + a);\n    }\n\n    //visg(g);\n    TD t = heuristic_tree_decomposition(g);\n    g.clear();\n    //cout << t.size() << endl;\n    //vis(t);\n    toNice(t,0);\n    //cerr << t.size() << endl;\n    //vis(t);\n\n    ll res = 0;\n    memo.clear();\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      res += rec(0,use,t);\n      res %= mod;\n    }\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define MOD (1000003LL)\ntypedef long long Int;\n\nint n, mi, memo[60000*4], cs[60000][2];\nvector<int> g[60000];\nbool has[60000];\n\nvoid add(int p, int q) {\n    if (p > q) swap(p, q);\n    g[p].push_back(q);\n}\n\nint pre(int p, int q) {\n    if (p+1 == q) return -1;\n    const int k = mi++;\n    has[k] = false;\n    if (g[p].back() == q) {\n        has[k] = true;\n        g[p].pop_back();\n    }\n    const int r = g[p].back();\n    rep (b, 4) memo[k*4|b] = -1;\n    cs[k][0] = pre(p, r);\n    cs[k][1] = pre(r, q);\n    return k;\n}\n\nint rec(int k, int x, int y) {\n    if (k == -1) return x == y;\n    const int sig = k*4|x*2|y;\n    if (memo[sig] != -1) return memo[sig];\n    const int p = cs[k][0], q = cs[k][1];\n    Int ans = 0;\n    rep (i, 2) ans = (ans + (Int)rec(p, x, i)*rec(q, 1-i, y)) % MOD;\n    if (x && y && has[k]) {\n        rep (i, 2) ans = (ans + (Int)rec(p, 0, i)*rec(q, 1-i, 0)) % MOD;\n    }\n    return memo[sig] = ans;\n}\n\nint main() {\n    for (;;) {\n        int m, a, b;\n        scanf(\"%d%d\", &n, &m);\n        if (n == 0) return 0;\n        rep (i, n-1) g[i].push_back(i+1);\n        rep (_, m) {\n            scanf(\"%d%d\", &a, &b);\n            add(a-1, b-1);\n        }\n        rep (i, n-1) sort(g[i].begin()+1, g[i].end());\n        sort(g[n-1].begin(), g[n-1].end());\n        g[0].push_back(n-1);\n        mi = 0;\n        pre(0, n-1);\n        printf(\"%d\\n\", rec(0, 1, 1));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nint road[5000][5000];\nint n,m;\n\nint solve(int start, int end, int now){\n\tint i,j,sum=0;\n//\tfor(j=now;j--;)printf(\" \");\n\tif(start+1==end){\n//\t\tfor(j=now;j--;)printf(\" \");\n//\t\tprintf(\"set %d %d\\n\", start, end);\n\t\treturn 1;\n\t}\n\tfor(i=start;i<=end;i++){\n\t\tint ret=1;\n\t\tif(!road[start][i] || !((start+i)%2)) continue;\n//\t\tfor(j=now;j--;)printf(\" \");\n//\t\tprintf(\"set %d %d\\n\", start, i);\n\t\tif(start+1!=i) ret=solve(start+1, i-1, now+1);\n\t\tif(i!=end) ret*=solve(i+1, end, now+1);\n\t\tsum+=ret;\n\t}\n\treturn sum;\n}\n\nint main(){\n\tint i,j,a,b;\n\twhile(cin>>n>>m,n){\n\t\tmemset(road,0,sizeof(road));\n\t\tfor(i=1;i<=m;i++){\n\t\t\tcin>>a>>b;\n\t\t\troad[a][b]=road[b][a]=1;\n\t\t}\n\t\tfor(i=1;i<n;i++){\n\t\t\troad[i][i+1]=road[i+1][i]=1;\n\t\t}\troad[1][n]=road[n][1]=1;\n\t\tif(n%2) cout<<\"0\"<<endl;\n\t\telse cout<<solve(1,n,0)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define MOD (1000003LL)\ntypedef long long Int;\n\nint n, mi, memo[60000*4], cs[60000][2];\nvector<int> g[60000];\nbool has[60000];\n\nvoid add(int p, int q) {\n    if (p > q) swap(p, q);\n    g[p].push_back(q);\n}\n\nint pre(int p, int q) {\n    if (p+1 == q) return -1;\n    const int k = mi++;\n    has[k] = false;\n    if (g[p].back() == q) {\n        has[k] = true;\n        g[p].pop_back();\n    }\n    const int r = g[p].back();\n    rep (b, 4) memo[k*4|b] = -1;\n    cs[k][0] = pre(p, r);\n    cs[k][1] = pre(r, q);\n    return k;\n}\n\nint rec(int k, int x, int y) {\n    if (k == -1) return x == y;\n    const int sig = k*4|x*2|y;\n    if (memo[sig] != -1) return memo[sig];\n    const int p = cs[k][0], q = cs[k][1];\n    Int ans = 0;\n    rep (i, 2) ans = (ans + (Int)rec(p, x, i)*rec(q, 1-i, y)) % MOD;\n    if (x && y && has[k]) {\n        rep (i, 2) ans = (ans + (Int)rec(p, 0, i)*rec(q, 1-i, 0)) % MOD;\n    }\n    return memo[sig] = ans;\n}\n\nint main() {\n    for (;;) {\n        int m, a, b;\n        scanf(\"%d%d\", &n, &m);\n        if (n == 0) return 0;\n        rep (i, n) g[i].clear();\n        rep (_, m) {\n            scanf(\"%d%d\", &a, &b);\n            add(a-1, b-1);\n        }\n        rep (i, n) add(i, (i+1)%n);\n        rep (i, n) sort(g[i].begin(), g[i].end());\n        mi = 0;\n        pre(0, n-1);\n        printf(\"%d\\n\", (int)rec(0, 1, 1));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep2(i,a,b) for(int i=a;i<=b;i++)\n#define pb push_back\n#define eb emplace_back\n\nint in(){int x;cin>>x;return x;}\n\n\n    \n#define ll long long\nvector<vector<int>> g;\nvector<int> nxt;\nconstexpr ll MOD = 1000003;\n\nmain(){\n    while(1){\n        int n=in(),m=in();\n        if(!n)return 0;\n        g=vector<vector<int>>(n);\n        vector<vector<int>> v(2);\n        using P = pair<int,int> ;\n        vector<P> ed;\n        rep(i,m){\n            int a=in()-1,b=in()-1;\n            if(a>b)swap(a,b);\n            if((a+b)&1){\n                g[a].pb(b);\n                v[a&1].pb(a);\n                ed.eb(P(a,b));\n            }\n        }\n        if(n&1){\n            cout<<0<<endl;continue;\n        }\n        #define all(c) (c).begin(),(c).end()\n        vector<pair<int,ll>> dp(n);\n        ed.emplace_back(0,n-1);\n        sort(all(ed),[](P x,P y){return x.second-x.first<y.second-y.first;});\n        rep(i,n-1) dp[i] = P(i+1,1);\n        for(auto p:ed){\n            int a = p.first,b=p.second;\n            ll ans = 1;\n            int now = a+1;\n            while(now!=b){\n                ans=(ans*dp[now].second)%MOD;\n                now = dp[now].first+1;\n            }\n            dp[a+1]={b-1,ans};\n            now = a,ans = 1;\n            while(now!=b+1){\n                ans = (ans*dp[now].second)%MOD;\n                now = dp[now].first+1;\n            }\n            ans+=dp[a+1].second;\n            if(ans>=MOD)ans-=MOD;\n            dp[a] = {b,ans};\n        }\n        cout<<dp[0].second<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\ntypedef long long ll;\ntypedef vector<ll> vi;\nconst int MOD = 1000003;\nint n, m;\nvector<vi> g;\n\nvi solve(int l, int r, int gi){\n\tvi res({1, 1});\n\tfor(int i=l;i<r;i++){\n\t\tif(gi < g[i].size()){\n\t\t\tvi ret = solve(i, g[i][gi], gi+1);\n\t\t\tres = vi({res[0]*ret[0] % MOD, res[1]*ret[1] % MOD});\n\t\t\ti = g[i][gi]-1;\n\t\t}\n\t\tswap(res[0], res[1]);\n\t\tgi = 0;\n\t}\n\tswap(res[0], res[1]);\n\tif(r-l > 1) res[1] -= ((res[1] = res[1] + res[0]) >= MOD) ? MOD : 0;\n\treturn res;\n}\n\nint main_(){\n\twhile(~scanf(\"%d%d\", &n, &m), n){\n\t\tg = vector<vi>(n);\n\t\tREP(i, m){\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v);u--; v--;\n\t\t\tif(v < u) swap(u, v);\n\t\t\tif(((u^v)&1)) g[u].push_back(v);\n\t\t}\n\t\tREP(i, n) sort(g[i].rbegin(), g[i].rend());\n\t\tprintf(\"%d\\n\", n%2 ? 0 : (int)solve(0, n-1, 0)[1]);\n\t}\n\treturn 0;\n}\n\nlong long esp_org, esp_new;\n\nmain(){\n    //  新しいスタック領域を確保する\n    const int size = 50*1024*1024;\n    void *p = malloc(size);\n    esp_new = (long long)p + size - 1;\n\n    //  スタックを置き換える\n    __asm__(\"mov %rsp, esp_org\");\n    __asm__(\"mov esp_new, %rsp\");\n    \n    //  メインの処理\n    main_();\n    //  スタックを元に戻す\n   __asm__(\"mov esp_org, %rsp\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntypedef vector< pair<vi,vi> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\nset<unsigned int> is_edge;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(vector<vi> &g){\n  unsigned int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  set<unsigned int> tmp_edge = is_edge;\n  rep(i,n){\n    deg[i] = g[i].sz; deg[i]*=-1;\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vi unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tunsigned int aa = a, bb = b;\n\tif(aa>bb)swap(aa,bb);\n\tif(aa!=bb && !tmp_edge.count(aa*n + bb)){\n\t  g[aa].pb(bb);\n\t  g[bb].pb(aa);\n\t  tmp_edge.insert(aa*n + bb);\n\t  deg[aa]--; deg[bb]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, int id){\n  stack<int> s;\n  s.push(id);\n\n  while(s.sz){\n    id = s.top(); s.pop();\n    \n    //for join\n    while(t[id].first.size()>2){\n      vi child(2);\n      child[0] = t[id].first.back(); t[id].first.pop_back();\n      child[1] = t[id].first.back(); t[id].first.pop_back();\n      t.push_back(make_pair(child, t[id].second));\n      t[id].first.push_back(t.size()-1);\n    }\n\n    if(t[id].first.size()==2){\n      rep(i,2){\n\tconst int &j = t[id].first[i];\n\tif(t[id].second != t[j].second){\n\t  vi child(1);\n\t  child[0] = j;\n\t  t.push_back(make_pair(child, t[id].second));\n\t  t[id].first[i] = t.size()-1;\n\t}\n      }\n    }\n\n    //for introduce & forget\n    if(t[id].first.size()==1){\n      const int &j = t[id].first[0];\n      vi child(1);\n      child[0] = j;\n      \n      vi disA, disB;\n      rep(a,t[id].second.size()){\n\tbool f = true;\n\trep(b,t[j].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disA.push_back(a);\n      }\n      rep(b,t[j].second.size()){\n\tbool f = true;\n\trep(a,t[id].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disB.push_back(b);\n      }\n      \n      if(disA.size() + disB.size() > 1){\n\tif(disA.size()>0){\n\t  vi tmp = t[id].second;\n\t  tmp.erase(tmp.begin() + disA[0]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}else{\n\t  vi tmp = t[id].second;\n\t  tmp.push_back(t[j].second[disB[0]]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}      \n      }\n    }\n    \n    //for leaf\n    if(t[id].first.size() == 0){\n      if(t[id].second.size() > 1){\n\tvi tmp;\n\trep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n\tt.push_back(make_pair(vi(), tmp));\n\tt[id].first.push_back(t.size()-1);\n      }\n    }\n\n    rep(i,t[id].first.size()){\n      s.push(t[id].first[i]);\n    }\n  }\n}\n\nunordered_map<int,int> memo;\n\ninline int dp(int id, int use, unsigned int n, const TD &t){\n  int key = 100*id + use;\n\n  stack<int> s;\n  s.push(key);\n\n  while(s.sz){\n    ll res = 0;\n    key = s.top(); s.pop();\n    id = key/100; use = key%100;\n    const vi& child = t[id].fs, bag = t[id].sc;\n    \n    //for leaf\n    if(child.sz==0){\n      memo[key] = use;\n      goto END;\n    }\n    \n    if(child.sz==1){\n      const vi &nbag = t[child[0]].second;\n      vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n      rep(i,bag.size())rep(j,nbag.size()){\n\tif(bag[i] == nbag[j]){\n\t  to_bag[j] = i; to_nbag[i] = j;\n\t}\n      }\n      \n      //for introduce\n      if(nbag.sz < bag.sz){\n\tint nuse = 0;\n\trep(i,bag.sz){\n\t  if(to_nbag[i]<0){\n\t    if( ((use>>i)&1) == 0 ){\n\t      memo[key] = 0;\n\t      goto END;\n\t    }\n\t  }else{\n\t    if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t  }\n\t}\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  memo[key] = memo[nxt];\n\t  goto END;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n      }\n      \n      //for forget\n      if(nbag.sz > bag.sz){\n\tint add = -1,  nuse = 0;\n\trep(i,nbag.sz){\n\t  if(to_bag[i]<0)add = i;\n\t  else if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n\t}\n\t\n\tll res = 0;\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  (res += memo[nxt]) %= mod;\n\t}else{\n\t  s.push(key); s.push(nxt);\n\t  goto END;\n\t}\n\n\trep(i,bag.sz){\n\t  if((use>>i)&1)continue;\n\t  \n\t  unsigned int a = bag[i], b = nbag[add];\n\t  if(a>b)swap(a,b);\n\t  if(is_edge.count(a*n + b)){\n\t    nxt = child[0]*100 + (nuse | (1<<add) | (1<<to_nbag[i]));\n\t    if(memo.count(nxt)){\n\t      (res += memo[nxt]) %= mod;\n\t    }else{\n\t      s.push(key); s.push(nxt);\n\t      goto END;\n\t    }\n\t  }\n\t}\n\tmemo[key] = res;\n      }\n    }\n    \n    //for join\n    if(child.sz==2){\n      int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n      do{\n\tint nxt1 = child[0]*100 + (use|sub), nxt2 = child[1]*100 + (use|(unuse-sub));\n\tif(memo.count(nxt1) == 0){\n\t  s.push(key); s.push(nxt1);\n\t  goto END;\n\t}\n\tif(memo.count(nxt2) == 0){\n\t  s.push(key); s.push(nxt2);\n\t  goto END;\n\t}\n\tif(memo.count(nxt1) && memo.count(nxt2)){\n\t  res += (ll)memo[nxt1] * memo[nxt2];\n\t  res %= mod;\n\t}\n\tsub = (sub-1)&unuse;\n      }while(sub != unuse);\n    \n      memo[key] = res;\n    }\n  END:;\n  }\n  return memo[key];\n}\n\nvoid visg(vector<vi> g){\n  int n = g.size();\n  cout << \"graph {\" << endl;\n  rep(i,n){\n    rep(k,g[i].sz){\n      if(i<g[i][k]){\n\tcout << \"  \\\"\" << i << \" \";\n\tcout << \"\\\" -- \\\"\" << g[i][k] << \" \";\n\tcout << \"\\\"\" << endl;\n      }\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nvoid vis(TD t){\n  int n = t.size();\n  cout << \"digraph {\" << endl;\n  rep(i,n){\n    rep(k,t[i].first.size()){\n      int nxt = t[i].first[k];\n      cout << \"  \\\"\" << i << \": \";\n      rep(j,t[i].second.size())cout << t[i].second[j] << \" \";\n      cout << \"\\\" -> \\\"\" << nxt << \": \";\n      rep(j,t[nxt].second.size())cout << t[nxt].second[j] << \" \";\n      cout << \"\\\"\" << endl;\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nint main(){\n  unsigned int n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    vector<vi> g(n);\n    is_edge.clear();\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*n + b);\n      else is_edge.insert(b*n + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*n + b);\n      else is_edge.insert(b*n + a);\n    }\n\n    //visg(g);\n    TD t = heuristic_tree_decomposition(g);\n    g.clear();\n    //cout << t.size() << endl;\n    //vis(t);\n    toNice(t,0);\n    //cerr << t.size() << endl;\n    //vis(t);\n\n    ll res = 0;\n    memo.clear();\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      //res += dp(0,use,n,t);\n      res %= mod;\n    }\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int M=1000003;\n\nvector<int> G[50000];\n\nmap<pair<int,int>,ll> dp[2][2];\nll dfs(int l,int r,bool bl,bool br){\n\tif(l+1==r) return bl==br?1:0;\n\n\tif(dp[bl][br].count(make_pair(l,r))>0) return dp[bl][br][make_pair(l,r)];\n\n\t// 多角形の縁以外に l から出る辺があるとき, その辺を使ってグラフを二分割する\n\trep(i,G[l].size()){\n\t\tint u=G[l][i];\n\t\tif(l<u && u<r){\n\t\t\tll res=0;\n\t\t\t// 辺 l-u をマッチングに使わない\n\t\t\tres+=dfs(l,u,bl, true)*dfs(u,r,false,br); // 頂点 u を [u,r] 側のマッチングに使う\n\t\t\tres+=dfs(l,u,bl,false)*dfs(u,r, true,br); // 頂点 u を [l,u] 側のマッチングに使う\n\t\t\t// 辺 l-u をマッチングに使う\n\t\t\tif(!bl){\n\t\t\t\tres+=dfs(l,u,true,true)*dfs(u,r,true,br);\n\t\t\t}\n\t\t\treturn dp[bl][br][make_pair(l,r)]=res%M;\n\t\t}\n\t}\n\n\t// 多角形の縁以外に r から出る辺があるとき, その辺を使ってグラフを二分割する\n\trep(i,G[r].size()){\n\t\tint u=G[r][i];\n\t\tif(l<u && u<r){\n\t\t\tll res=0;\n\t\t\t// 辺 u-r をマッチングに使わない\n\t\t\tres+=dfs(l,u,bl, true)*dfs(u,r,false,br); // 頂点 u を [u,r] 側のマッチングに使う\n\t\t\tres+=dfs(l,u,bl,false)*dfs(u,r, true,br); // 頂点 u を [l,u] 側のマッチングに使う\n\t\t\t// 辺 u-r をマッチングに使う\n\t\t\tif(!br){\n\t\t\t\tres+=dfs(l,u,bl,true)*dfs(u,r,true,true);\n\t\t\t}\n\t\t\treturn dp[bl][br][make_pair(l,r)]=res%M;\n\t\t}\n\t}\n\n\t// 多角形の縁しか進める辺がないとき, 多角形に沿って l を一つ進める\n\treturn dp[bl][br][make_pair(l,r)]=dfs(l+1,r,!bl,br);\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\trep(u,n) G[u].clear();\n\t\trep(i,m){\n\t\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t\trep(i,2) rep(j,2) dp[i][j].clear();\n\t\tprintf(\"%lld\\n\",(dfs(0,n-1,false,false)+dfs(0,n-1,true,true))%M);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\nusing namespace std;\nconst int mod = 1000003;\nint N, M; vector<vector<int> > G;\nunordered_map<unsigned, int> dp;\nint solve(int l, int r) {\n\tif (l == r) return 1;\n\tif ((r - l) % 2 == 1) return 0;\n\tif (dp.find(unsigned(l) * N + r) != dp.end()) return dp[unsigned(l) * N + r];\n\tvector<int> child(G[l].begin(), lower_bound(G[l].begin(), G[l].end(), r));\n\tint S = child.size();\n\tvector<int> lmul(S + 1), rmul(S + 1);\n\tlmul[0] = 1;\n\tint pl = l + 1;\n\tfor (int i = 0; i < S; ++i) {\n\t\tint nxt = (child[i] % 2 == pl % 2 ? child[i] : child[i] + 1);\n\t\tlmul[i + 1] = 1LL * lmul[i] * solve(pl, nxt) % mod;\n\t\tpl = nxt;\n\t}\n\trmul[S] = 1;\n\tint pr = r;\n\tfor (int i = S - 1; i >= 0; --i) {\n\t\tint nxt = (child[i] % 2 == pr % 2 ? child[i] : child[i] + 1);\n\t\trmul[i] = 1LL * rmul[i + 1] * solve(nxt, pr) % mod;\n\t\tpr = nxt;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < S; ++i) {\n\t\tif ((child[i] - (l + 1)) % 2 == 0 && (r - (child[i] + 1)) % 2 == 0) {\n\t\t\tans = (ans + 1LL * lmul[i + 1] * rmul[i]) % mod;\n\t\t}\n\t}\n\tdp[unsigned(l) * N + r] = ans;\n\treturn ans;\n}\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\twhile (cin >> N >> M, N) {\n\t\tG = vector<vector<int> >(N);\n\t\tdp.clear();\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b; --a, --b;\n\t\t\tif (a > b) swap(a, b);\n\t\t\tif ((b - a) % 2 != 0) G[a].push_back(b);\n\t\t}\n\t\tif (N % 2 == 1) cout << 0 << '\\n';\n\t\telse {\n\t\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\t\tG[i].push_back(i + 1);\n\t\t\t}\n\t\t\tG[0].push_back(N - 1);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tsort(G[i].begin(), G[i].end());\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor (int i : G[0]) {\n\t\t\t\tint sl = solve(1, i);\n\t\t\t\tint sr = solve(i + 1, N);\n\t\t\t\tans = (ans + 1LL * sl * sr) % mod;\n\t\t\t}\n\t\t\tcout << ans << '\\n';\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\ntypedef long long ll;\ntypedef vector<ll> vi;\nconst int MOD = 1000003;\nint n, m;\nvector<vi> g;\n\nvi solve(int l, int r, int gi){\n\tvi res({1, 1});\n\tfor(int i=l;i<r;i++){\n\t\tif(gi < g[i].size()){\n\t\t\tvi ret = solve(i, g[i][gi], gi+1);\n\t\t\tres = vi({res[0]*ret[0] % MOD, res[1]*ret[1] % MOD});\n\t\t\ti = g[i][gi]-1;\n\t\t}\n\t\tswap(res[0], res[1]);\n\t\tgi = 0;\n\t}\n\tswap(res[0], res[1]);\n\tif(r-l > 1) res[1] -= ((res[1] = res[1] + res[0]) >= MOD) ? MOD : 0;\n\treturn res;\n}\n\nint main_(){\n\twhile(~scanf(\"%d%d\", &n, &m), n){\n\t\tg = vector<vi>(n);\n\t\tREP(i, m){\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v);u--; v--;\n\t\t\tif(v < u) swap(u, v);\n\t\t\tif(((u^v)&1)) g[u].push_back(v);\n\t\t}\n\t\tREP(i, n) sort(g[i].rbegin(), g[i].rend());\n\t\tprintf(\"%d\\n\", n%2 ? 0 : (int)solve(0, n-1, 0)[1]);\n\t}\n\treturn 0;\n}\n\nlong long esp_org, esp_new;\n\nmain(){\n    //  新しいスタック領域を確保する\n    const int size = 64*1024*1024;\n    void *p = malloc(size);\n    esp_new = (long long)p + size - 1;\n\n    //  スタックを置き換える\n    __asm__(\"mov %rsp, esp_org\");\n    __asm__(\"mov esp_new, %rsp\");\n    \n    //  メインの処理\n    main_();\n    //  スタックを元に戻す\n   __asm__(\"mov esp_org, %rsp\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define pb push_back\n#define sz size()\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\ntypedef vector< pair<vi,vi> > TD;\n//first: child of tree, second: bag\n\nconst ll mod = 1e6+3;\nset<unsigned int> is_edge;\n\n/*Tree Decomposition for a graph with small treewidth.*/\ninline TD heuristic_tree_decomposition(vector<vi> &g){\n  unsigned int n = g.size();\n  TD res = TD(n);\n  vi use(n,-1), deg(n);\n\n  priority_queue<pii> q;\n  set<unsigned int> tmp_edge = is_edge;\n  rep(i,n){\n    deg[i] = g[i].sz; deg[i]*=-1;\n    q.push(pii(deg[i],i));\n  }\n\n  int id = n-1;\n  while(q.sz){\n    int v = q.top().sc, d = q.top().fs; q.pop();\n    if(use[v]!=-1 || deg[v] != d)continue;\n\n    vi unuse;\n    for(int u : g[v]){\n      if(use[u]==-1)unuse.push_back(u);\n      else if(use[u]>=0){\n\tres[id].first.push_back(use[u]);\n\tuse[u] = -2;\n      }\n    }\n\n    res[id].second.push_back(v);\n    for(int a : unuse){\n      res[id].second.push_back(a);\n      deg[a]++;\n      for(int b :unuse){\n\tunsigned int aa = a, bb = b;\n\tif(aa>bb)swap(aa,bb);\n\tif(aa!=bb && !tmp_edge.count(aa*n + bb)){\n\t  g[aa].pb(bb);\n\t  g[bb].pb(aa);\n\t  tmp_edge.insert(aa*n + bb);\n\t  deg[aa]--; deg[bb]--;\n\t}\n      }\n    }\n    for(int u: unuse)q.push(pii(deg[u],u));\n\n    use[v] = id;\n    id--;\n  }\n\n  return res;\n}\n\ninline void toNice(TD &t, int id){\n  stack<int> s;\n  s.push(id);\n\n  while(s.sz){\n    id = s.top(); s.pop();\n    \n    //for join\n    while(t[id].first.size()>2){\n      vi child(2);\n      child[0] = t[id].first.back(); t[id].first.pop_back();\n      child[1] = t[id].first.back(); t[id].first.pop_back();\n      t.push_back(make_pair(child, t[id].second));\n      t[id].first.push_back(t.size()-1);\n    }\n\n    if(t[id].first.size()==2){\n      rep(i,2){\n\tconst int &j = t[id].first[i];\n\tif(t[id].second != t[j].second){\n\t  vi child(1);\n\t  child[0] = j;\n\t  t.push_back(make_pair(child, t[id].second));\n\t  t[id].first[i] = t.size()-1;\n\t}\n      }\n    }\n\n    //for introduce & forget\n    if(t[id].first.size()==1){\n      const int &j = t[id].first[0];\n      vi child(1);\n      child[0] = j;\n      \n      vi disA, disB;\n      rep(a,t[id].second.size()){\n\tbool f = true;\n\trep(b,t[j].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disA.push_back(a);\n      }\n      rep(b,t[j].second.size()){\n\tbool f = true;\n\trep(a,t[id].second.size()){\n\t  if(t[id].second[a] == t[j].second[b])f = false;\n\t}\n\tif(f)disB.push_back(b);\n      }\n      \n      if(disA.size() + disB.size() > 1){\n\tif(disA.size()>0){\n\t  vi tmp = t[id].second;\n\t  tmp.erase(tmp.begin() + disA[0]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}else{\n\t  vi tmp = t[id].second;\n\t  tmp.push_back(t[j].second[disB[0]]);\n\t  t.push_back(make_pair(child, tmp));\n\t  t[id].first[0] = t.size()-1;\n\t}      \n      }\n    }\n    \n    //for leaf\n    if(t[id].first.size() == 0){\n      if(t[id].second.size() > 1){\n\tvi tmp;\n\trep(i,t[id].second.size()-1)tmp.push_back(t[id].second[i]);\n\tt.push_back(make_pair(vi(), tmp));\n\tt[id].first.push_back(t.size()-1);\n      }\n    }\n\n    rep(i,t[id].first.size()){\n      s.push(t[id].first[i]);\n    }\n  }\n}\n\nunordered_map<int,int> memo;\n\ninline int dp(int id, int use, unsigned int n, const TD &t){\n  int key = 100*id + use;\n\n  int maxs = 0;\n  vector<int> s(t.sz);\n  int pos = 0;\n  s[pos++] = key;\n\n  while(pos){\n    ll res = 0;\n    key = s[--pos];\n    id = key/100; use = key%100;\n    const vi& child = t[id].fs, bag = t[id].sc;\n    \n    //for leaf\n    if(child.sz==0){\n      memo[key] = use;\n      goto END;\n    }\n    \n    if(child.sz==1){\n      const vi &nbag = t[child[0]].second;\n      vi to_bag(nbag.size(),-1), to_nbag(bag.size(),-1);\n      rep(i,bag.size())rep(j,nbag.size()){\n\tif(bag[i] == nbag[j]){\n\t  to_bag[j] = i; to_nbag[i] = j;\n\t}\n      }\n      \n      //for introduce\n      if(nbag.sz < bag.sz){\n\tint nuse = 0;\n\trep(i,bag.sz){\n\t  if(to_nbag[i]<0){\n\t    if( ((use>>i)&1) == 0 ){\n\t      memo[key] = 0;\n\t      goto END;\n\t    }\n\t  }else{\n\t    if( ((use>>i)&1) )nuse |= 1<<to_nbag[i];\n\t  }\n\t}\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  memo[key] = memo[nxt];\n\t  goto END;\n\t}else{\n\t  s[pos++] = key; s[pos++] = nxt;\n\t  goto END;\n\t}\n      }\n      \n      //for forget\n      if(nbag.sz > bag.sz){\n\tint add = -1,  nuse = 0;\n\trep(i,nbag.sz){\n\t  if(to_bag[i]<0)add = i;\n\t  else if( (use>>to_bag[i])&1 )nuse |= 1<<i;\n\t}\n\t\n\tll res = 0;\n\tint nxt = child[0]*100 + nuse;\n\tif(memo.count(nxt)){\n\t  (res += memo[nxt]) %= mod;\n\t}else{\n\t  s[pos++] = key; s[pos++] = nxt;\n\t  goto END;\n\t}\n\n\trep(i,bag.sz){\n\t  if((use>>i)&1)continue;\n\t  \n\t  unsigned int a = bag[i], b = nbag[add];\n\t  if(a>b)swap(a,b);\n\t  if(is_edge.count(a*n + b)){\n\t    nxt = child[0]*100 + (nuse | (1<<add) | (1<<to_nbag[i]));\n\t    if(memo.count(nxt)){\n\t      (res += memo[nxt]) %= mod;\n\t    }else{\n\t      s[pos++] = key; s[pos++] = nxt;\n\t      goto END;\n\t    }\n\t  }\n\t}\n\tmemo[key] = res;\n      }\n    }\n    \n    //for join\n    if(child.sz==2){\n      int n = bag.sz, unuse = (1<<n)-1 - use, sub = unuse;\n      do{\n\tint nxt1 = child[0]*100 + (use|sub), nxt2 = child[1]*100 + (use|(unuse-sub));\n\tif(memo.count(nxt1) == 0){\n\t  s[pos++] = key; s[pos++] = nxt1;\n\t  goto END;\n\t}\n\tif(memo[nxt1]){\n\t  if(memo.count(nxt2) == 0){\n\t    s[pos++] = key; s[pos++] = nxt2;\n\t    goto END;\n\t  }\n\t  if(memo[nxt2]){\n\t    res += (ll)memo[nxt1] * memo[nxt2];\n\t    res %= mod;\n\t  }\n\t}\n\tsub = (sub-1)&unuse;\n      }while(sub != unuse);\n    \n      memo[key] = res;\n    }\n  END: maxs = max(maxs, (int)s.sz);\n  }\n  //cerr << maxs << endl;\n  return memo[key];\n}\n\nvoid visg(vector<vi> g){\n  int n = g.size();\n  cout << \"graph {\" << endl;\n  rep(i,n){\n    rep(k,g[i].sz){\n      if(i<g[i][k]){\n\tcout << \"  \\\"\" << i << \" \";\n\tcout << \"\\\" -- \\\"\" << g[i][k] << \" \";\n\tcout << \"\\\"\" << endl;\n      }\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nvoid vis(TD t){\n  int n = t.size();\n  cout << \"digraph {\" << endl;\n  rep(i,n){\n    rep(k,t[i].first.size()){\n      int nxt = t[i].first[k];\n      cout << \"  \\\"\" << i << \": \";\n      rep(j,t[i].second.size())cout << t[i].second[j] << \" \";\n      cout << \"\\\" -> \\\"\" << nxt << \": \";\n      rep(j,t[nxt].second.size())cout << t[nxt].second[j] << \" \";\n      cout << \"\\\"\" << endl;\n    }\n  }\n  cout << \"}\" << endl;\n}\n\nint main(){\n  unsigned int n,m,a,b;\n  while(scanf(\"%d%d\",&n,&m),n){\n    vector<vi> g(n);\n    is_edge.clear();\n\n    rep(i,n){\n      a = i, b = (i+1)%n;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*n + b);\n      else is_edge.insert(b*n + a);\n    }\n    rep(i,m){\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      g[a].pb(b);\n      g[b].pb(a);\n      if(a<b)is_edge.insert(a*n + b);\n      else is_edge.insert(b*n + a);\n    }\n\n    TD t = heuristic_tree_decomposition(g);\n    g.clear();\n    toNice(t,0);\n    //cerr << t.sz << endl;\n\n    ll res = 0;\n    memo.clear();\n\n    int x = t[0].sc.sz;\n    int match = x*(x-1)/2;\n    rep(bit,1<<match){\n      int use = 0;\n      rep(i,match){\n\tif( (bit>>i)&1 ){\n\t  a = i, b = (i+1)%x;\n\t  if(is_edge.count(t[0].fs[a]*mod + t[0].fs[b])){\n\t    if( (use>>a)&1 || (use>>b)&1 ){\n\t      use = -1; break;\n\t    }else{\n\t      use |= 1<<a | 1<<b;\n\t    }\n\t  }else{\n\t    use = -1; break;\n\t  }\n\t}\n      }\n      if(use<0)continue;\n      res += dp(0,use,n,t);\n      res %= mod;\n    }\n    printf(\"%lld\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\ntypedef long long ll;\ntypedef vector<ll> vi;\nconst int MOD = 1000003;\nint n, m;\nvector<vi> g;\n\nvi solve(int l, int r, int gi){\n\tvi res({1, 1});\n\tfor(int i=l;i<r;i++){\n\t\tif(gi < g[i].size()){\n\t\t\tvi ret = solve(i, g[i][gi], gi+1);\n\t\t\tres = vi({res[0]*ret[0] % MOD, res[1]*ret[1] % MOD});\n\t\t\ti = g[i][gi]-1;\n\t\t}\n\t\tswap(res[0], res[1]);\n\t\tgi = 0;\n\t}\n\tswap(res[0], res[1]);\n\tif(r-l > 1) res[1] =(res[1] + res[0]) % MOD;\n\treturn res;\n}\n\nint main(){\n\twhile(~scanf(\"%d%d\", &n, &m), n){\n\t\tcerr << n << \", \" << m << endl;\n\t\tg = vector<vi>(n);\n\t\tREP(i, m){\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v);u--; v--;\n\t\t\tif(v < u) swap(u, v);\n\t\t\tif(((u^v)&1)) g[u].push_back(v);\n\t\t}\n\t\tREP(i, n) sort(g[i].rbegin(), g[i].rend());\n\t\tprintf(\"%d\\n\", n%2 ? 0 : (int)solve(0, n-1, 0)[1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> T;\n\nconst int MN = 50500; \nconst int MD = 1000003;\n\nint n, m;\nP g[MN];\nint calc(int l, int r) {\n    ll res = 1;\n    while (l < r) {\n        res *= g[l].second; res %= MD;\n        l = g[l].first;\n    }\n    return res;\n}\n\nint solve() {\n    if (n % 2) return 0;\n    for (int i = 0; i < n-1; i++) {\n        g[i] = P(i+2, 1);\n    }\n    vector<T> buf;\n    buf.push_back(T(n-1, P(0, n)));\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        if (a > b) swap(a, b); a--;\n        if ((b-a) % 2) continue;\n        buf.push_back(T(b-a, P(a, b)));\n    }\n    sort(buf.begin(), buf.end());\n    for (T &t: buf) {\n        int a, b;\n        tie(a, b) = t.second;\n        g[a] = P(b, (calc(a, b) + calc(a+1, b-1)) % MD);\n    }\n    return g[0].second;\n}\n\nint main() {\n    while (true) {\n        scanf(\"%d %d\", &n, &m);\n        if (!n) break;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n#define REP(i, n) for(int i=0;i<(int)(n);i++)\ntypedef long long ll;\ntypedef vector<int> vi;\nconst int MOD = 1000003;\nint n, m;\nvector<vi> g;\n\nvi solve(int l, int r, int gi){\n\tvi res({1, 1});\n\tfor(int i=l;i<r;i++){\n\t\tif(gi < g[i].size()){\n\t\t\tvi ret = solve(i, g[i][gi], gi+1);\n\t\t\tREP(j, 2) res[j] = (ll)res[j]*ret[j]%MOD;\n\t\t\ti = g[i][gi]-1;\n\t\t}\n\t\tswap(res[0], res[1]);\n\t\tgi = 0;\n\t}\n\tswap(res[0], res[1]);\n\tif(r-l > 1) res[1] -= ((res[1] = res[1] + res[0]) >= MOD) ? MOD : 0;\n\treturn res;\n}\n\nint main(){\n\twhile(~scanf(\"%d%d\", &n, &m), n){\n\t\tg = vector<vi>(n);\n\t\tREP(i, m){\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v);u--; v--;\n\t\t\tif(v < u) swap(u, v);\n\t\t\tif(((u^v)&1)) g[u].push_back(v);\n\t\t}\n\t\tREP(i, n) sort(g[i].rbegin(), g[i].rend());\n\t\tprintf(\"%d\\n\", n%2 ? 0 : (int)solve(0, n-1, 0)[1]);\n\t}\n\treturn 0;\n}\n\nlong long esp_org, esp_new;\n\nint main_(){\n    //  新しいスタック領域を確保する\n    const int size = 50*1024*1024;\n    void *p = malloc(size);\n    esp_new = (long long)p + size - 1;\n\n    //  スタックを置き換える\n    __asm__(\"mov %rsp, esp_org\");\n    __asm__(\"mov esp_new, %rsp\");\n    \n    //  メインの処理\n    main_();\n    //  スタックを元に戻す\n   __asm__(\"mov esp_org, %rsp\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\n\nconst int MOD=1000003;\nint N,M;\nvector<vector<int> > L;\nint ans=0;\nmap<pair<int,int> ,int> memo;\n\nint calc(int start,int end){\n\tif((end-start)%2==0) return 0;\n\tif(start>end) return 1;\n\tif(memo.count(make_pair(start,end))) return memo[make_pair(start,end)];\n\tint res=1;\n\n\tfor(int now=start;now<end;now++){\n\t\tfor(int k=0;k<L[now].size();k++){\n\t\t\tres+=calc(now+1,L[now][k]-1)*calc(L[now][k]+1,end);\n\t\t\tres%=MOD;\n\t\t}\n\t}\n\tmemo[make_pair(start,end)]=res;\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin>>N>>M && N!=0){\n\t\tmemo.clear();\n\t\tL.clear();\n\t\tL.resize(N,vector<int>());\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint in,out;cin>>in>>out;\n\t\t\tin--;out--;\n\t\t\tif(in<out)\n\t\t\t\tL[in].push_back(out);\n\t\t\telse\n\t\t\t\tL[out].push_back(in);\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tsort(L[i].begin(),L[i].end());\n\t\t\tL[i].erase(unique(L[i].begin(),L[i].end()),L[i].end());\n\t\t}\n\t\tcout<<(calc(0,N-1)+calc(1,N-2))%MOD<<endl;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\t\n\tpublic final static int MOD = 1000003;\n\tpublic static int N;\n\tpublic static int[] A = new int[50000+2];\n\tpublic static int[] B = new int[50000];\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\t\tString[] param;\n\t\t\tint i, M, a, b, c, n;\n\t\t\tlong[] AB = new long[50000];\n\t\t\twhile (true) {\n\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\tN = Integer.parseInt(param[0]);\n\t\t\t\tM = Integer.parseInt(param[1]);\n\t\t\t\tif (N==0 && M==0) break;\n\t\t\t\tif ((N&1) == 1) {\n\t\t\t\t\tfor (i = 0; i < M; i++) br.readLine();\n\t\t\t\t\tpw.println(0);\n\t\t\t\t} else {\n\t\t\t\t\tfor (n = 0, i = 0; i < M; i++) {\n\t\t\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\t\t\ta = Integer.parseInt(param[0]);\n\t\t\t\t\t\tb = Integer.parseInt(param[1]);\n\t\t\t\t\t\tif ((a+b&1)==1) AB[n++] = (Math.min(a, b)<<16)|(Math.max(a, b));\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(AB, 0, n);\n\t\t\t\t\tfor (c = 0, i = 0; i < n; i++) {\n\t\t\t\t\t\tB[i] = (int)(AB[i]&65535);\n\t\t\t\t\t\ta = (int)(AB[i]>>>16);\n\t\t\t\t\t\tif (c < a) {\n\t\t\t\t\t\t\tfor (c = c+1; c < a; c++) A[c] = i;\n\t\t\t\t\t\t\tA[c] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (c = c+1; c < N+2; c++) A[c] = n;\n\t\t\t\t\tpw.println(analyze());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.close();\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tpublic static int analyze() {\n\t\tint answer = 2;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tanswer = (answer + check(i, B[j])) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\t\n\tpublic static int check(int X, int Y) {\n\t\tint answer = 1;\n\t\tfor (int i = X+1; i < Y; i+=2) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tif (B[j]>=Y) break;\n\t\t\t\tanswer = (answer + check(i, B[j])) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tint n, m;\n\tint[] a, b;\n\tArrayList<Integer>[] g;\n\tfinal long MODULO = 1000003;\n\n\tvoid solver() throws FileNotFoundException {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\t\t\ta = new int[m];\n\t\t\tb = new int[m];\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t\t--a[i];\n\t\t\t\t--b[i];\n\t\t\t\tg[Math.min(a[i], b[i])].add(Math.max(a[i], b[i]));\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tg[Math.min(i, (i + 1) % n)].add(Math.max(i, (i + 1) % n));\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tCollections.sort(g[i]);\n\t\t\t}\n\t\t\tSystem.out.println(f(0, n - 1)[0][0]);\n\t\t}\n\t}\n\n\tlong[][] f(int src, int dst) {\n\t\tlong[][] ret = new long[2][2];\n\t\tret[0][0] = 1;\n\t\tret[1][1] = 1;\n\t\tfor (int i = 0; i + 1 < g[src].size(); ++i) {\n\t\t\tret = merge(ret, f(g[src].get(i), g[src].get(i + 1)));\n\t\t\tret[0][0] = (ret[0][0] + ret[1][1]) % MODULO;\n\t\t}\n\t\tif (g[src].get(g[src].size() - 1) != dst) {\n\t\t\tret = merge(ret, f(g[src].get(g[src].size() - 1), dst));\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolver();\n\t\t} catch (FileNotFoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t// 0???true???1???false??¨?????????\n\tlong[][] merge(long[][] a, long[][] b) {\n\t\tlong[][] ret = new long[2][2];\n\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tret[i][j] = (a[i][0] * b[1][j] + a[i][1] * b[0][j]) % MODULO;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate static void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tint n, m;\n\tint[] a, b;\n\tArrayList<Integer>[] g;\n\tfinal long MODULO = 1000003;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\t\t\ta = new int[m];\n\t\t\tb = new int[m];\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t\t--a[i];\n\t\t\t\t--b[i];\n\t\t\t\tg[Math.min(a[i], b[i])].add(Math.max(a[i], b[i]));\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tg[Math.min(i, (i + 1) % n)].add(Math.max(i, (i + 1) % n));\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tCollections.sort(g[i]);\n\t\t\t}\n\t\t\tSystem.out.println(f(0, n - 1)[0][0]);\n\t\t}\n\t}\n\n\tlong[][] f(int src, int dst) {\n\t\tlong[][] ret = new long[2][2];\n\t\tret[0][0] = 1;\n\t\tret[1][1] = 1;\n\t\tfor (int i = 0; i + 1 < g[src].size(); ++i) {\n\t\t\tret = merge(ret, f(g[src].get(i), g[src].get(i + 1)));\n\t\t\tret[0][0] = (ret[0][0] + ret[1][1]) % MODULO;\n\t\t}\n\t\tif (g[src].get(g[src].size() - 1) != dst) {\n\t\t\tret = merge(ret, f(g[src].get(g[src].size() - 1), dst));\n\t\t}\n\t\treturn ret;\n\t}\n\n\t// 0???true???1???false??¨?????????\n\tlong[][] merge(long[][] a, long[][] b) {\n\t\tlong[][] ret = new long[2][2];\n\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tret[i][j] = (a[i][0] * b[1][j] + a[i][1] * b[0][j]) % MODULO;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate static void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\t\n\tpublic final static int MOD = 1000003;\n\tpublic static int N;\n\tpublic static int[] A = new int[50000+2];\n\tpublic static int[] B = new int[50000];\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\t\tString[] param;\n\t\t\tint i, M, a, b, c, n;\n\t\t\tlong[] AB = new long[50000];\n\t\t\twhile (true) {\n\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\tN = Integer.parseInt(param[0]);\n\t\t\t\tM = Integer.parseInt(param[1]);\n\t\t\t\tif (N==0 && M==0) break;\n\t\t\t\tif ((N&1) == 1) {\n\t\t\t\t\tfor (i = 0; i < M; i++) br.readLine();\n\t\t\t\t\tpw.println(0);\n\t\t\t\t} else {\n\t\t\t\t\tfor (n = 0, i = 0; i < M; i++) {\n\t\t\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\t\t\ta = Integer.parseInt(param[0]);\n\t\t\t\t\t\tb = Integer.parseInt(param[1]);\n\t\t\t\t\t\tif ((a+b&1)==1) AB[n++] = ((long)Math.min(a, b)<<16)|(Math.max(a, b));\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(AB, 0, n);\n\t\t\t\t\tfor (c = 0, i = 0; i < n; i++) {\n\t\t\t\t\t\tB[i] = (int)(AB[i]&65535);\n\t\t\t\t\t\ta = (int)(AB[i]>>>16);\n\t\t\t\t\t\tif (c < a) {\n\t\t\t\t\t\t\tfor (c = c+1; c < a; c++) A[c] = i;\n\t\t\t\t\t\t\tA[c] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (c = c+1; c < N+2; c++) A[c] = n;\n\t\t\t\t\tpw.println(analyze());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.close();\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tpublic static int analyze() {\n\t\tint answer = 2;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tanswer = (answer + check(i, B[j])) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\t\n\tpublic static int check(int X, int Y) {\n\t\tint answer = 1;\n\t\tfor (int i = X+1; i < Y; i+=2) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tif (B[j]>=Y) break;\n\t\t\t\tanswer = (answer + check(i, B[j])) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tint n, m;\n\tint[] a, b;\n\tArrayList<Integer>[] g;\n\tfinal long MODULO = 1000003;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\t\t\ta = new int[m];\n\t\t\tb = new int[m];\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t\t--a[i];\n\t\t\t\t--b[i];\n\t\t\t\tg[Math.min(a[i], b[i])].add(Math.max(a[i], b[i]));\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tg[Math.min(i, (i + 1) % n)].add(Math.max(i, (i + 1) % n));\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tCollections.sort(g[i]);\n\t\t\t}\n\t\t\tSystem.out.println(f(0, n - 1)[0][0]);\n\t\t}\n\t}\n\n\tlong[][] f(int src, int dst) {\n\t\tlong[][] ret = new long[2][2];\n\t\tret[0][0] = 1;\n\t\tret[1][1] = 1;\n\t\tfor (int i = 0; i + 1 < g[src].size(); ++i) {\n\t\t\tret = merge(ret, f(g[src].get(i), g[src].get(i + 1)));\n\t\t\tret[0][0] = (ret[0][0] + ret[1][1]) % MODULO;\n\t\t}\n\t\tif (g[src].get(g[src].size() - 1) != dst) {\n\t\t\tret = merge(ret, f(g[src].get(g[src].size() - 1), dst));\n\t\t}\n\t\treturn ret;\n\t}\n\n\t// 0???true???1???false??¨?????????\n\tlong[][] merge(long[][] a, long[][] b) {\n\t\tlong[][] ret = new long[2][2];\n\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tret[i][j] = (a[i][0] * b[1][j] + a[i][1] * b[0][j]) % MODULO;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate static void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\t\n\tpublic final static int MOD = 1000003;\n\tpublic static int N;\n\tpublic static int[] A = new int[50000+2];\n\tpublic static int[] B = new int[50000];\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\t\tString[] param;\n\t\t\tint i, M, a, b, c, n;\n\t\t\tlong[] AB = new long[50000];\n\t\t\twhile (true) {\n\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\tN = Integer.parseInt(param[0]);\n\t\t\t\tM = Integer.parseInt(param[1]);\n\t\t\t\tif (N==0 && M==0) break;\n\t\t\t\tif ((N&1) == 1) {\n\t\t\t\t\tfor (i = 0; i < M; i++) br.readLine();\n\t\t\t\t\tpw.println(0);\n\t\t\t\t} else {\n\t\t\t\t\tfor (n = 0, i = 0; i < M; i++) {\n\t\t\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\t\t\ta = Integer.parseInt(param[0]);\n\t\t\t\t\t\tb = Integer.parseInt(param[1]);\n\t\t\t\t\t\tif ((a+b&1)==1) AB[n++] = (Math.min(a, b)<<16)|(Math.max(a, b));\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(AB, 0, n);\n\t\t\t\t\tfor (c = 0, i = 0; i < n; i++) {\n\t\t\t\t\t\tB[i] = (int)(AB[i]&65535);\n\t\t\t\t\t\ta = (int)(AB[i]>>>16);\n\t\t\t\t\t\tif (c < a) {\n\t\t\t\t\t\t\tfor (c = c+1; c < a; c++) A[c] = A[c-1];\n\t\t\t\t\t\t\tA[c] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (c = c+1; c < N+2; c++) A[c] = n;\n\t\t\t\t\tpw.println(analyze());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.close();\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tpublic static int analyze() {\n\t\tint answer = 2;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tanswer = (answer + check(i, B[j])) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\t\n\tpublic static int check(int X, int Y) {\n\t\tint answer = 1;\n\t\tfor (int i = X+1; i < Y; i+=2) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tif (j>=Y) break;\n\t\t\t\tanswer = (answer + check(i, B[j])) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic class Main {\n\t\n\tpublic final static int MOD = 1000003;\n\tpublic static int N;\n\tpublic static int[] A = new int[50000+2];\n\tpublic static int[] B = new int[50000];\n\tpublic static HashMap<Integer,Long> hm = new HashMap<Integer,Long>();\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\t\tString[] param;\n\t\t\tint i, M, a, b, c, n;\n\t\t\tlong[] AB = new long[50000];\n\t\t\twhile (true) {\n\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\tN = Integer.parseInt(param[0]);\n\t\t\t\tM = Integer.parseInt(param[1]);\n\t\t\t\tif (N==0 && M==0) break;\n\t\t\t\tif ((N&1) == 1) {\n\t\t\t\t\tfor (i = 0; i < M; i++) br.readLine();\n\t\t\t\t\tpw.println(0);\n\t\t\t\t} else {\n\t\t\t\t\tfor (n = 0, i = 0; i < M; i++) {\n\t\t\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\t\t\ta = Integer.parseInt(param[0]);\n\t\t\t\t\t\tb = Integer.parseInt(param[1]);\n\t\t\t\t\t\tif ((a+b&1)==1) AB[n++] = ((long)Math.min(a, b)<<16)|(Math.max(a, b));\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(AB, 0, n);\n\t\t\t\t\tfor (c = 0, i = 0; i < n; i++) {\n\t\t\t\t\t\tB[i] = (int)(AB[i]&65535);\n\t\t\t\t\t\ta = (int)(AB[i]>>>16);\n\t\t\t\t\t\tif (c < a) {\n\t\t\t\t\t\t\tfor (c = c+1; c < a; c++) A[c] = i;\n\t\t\t\t\t\t\tA[c] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (c = c+1; c < N+2; c++) A[c] = n;\n\t\t\t\t\tpw.println(analyze());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.close();\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tpublic static long analyze() {\n\t\thm.clear();\n\t\tlong answer = 2;\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tanswer = (answer + (1 + check(i+1, B[j]-1)) * (1 + check(B[j]+1, N))) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\t\n\tpublic static long check(int X, int Y) {\n\t\tif (X >= Y) return 0;\n//\t\tLong memo = hm.get((X<<16)|Y);\n//\t\tif (memo != null) return memo.longValue(); \n\t\tlong answer = 0;\n\t\tfor (int i = X; i < Y; i+=2) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tif (B[j]>Y) break;\n\t\t\t\tanswer = (answer + (1 + check(i+1, B[j]-1)) * (1 + check(B[j]+1, Y))) % MOD;\n\t\t\t}\n\t\t}\n//\t\thm.put((X<<16)|Y, answer);\n\t\treturn answer;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic class Main {\n\t\n\tpublic final static int MOD = 1000003;\n\tpublic static int N;\n\tpublic static int[] A = new int[50010+2];\n\tpublic static int[] B = new int[50010];\n\tpublic static HashMap<Integer,Long> hm = new HashMap<Integer,Long>();\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\t\tString[] param;\n\t\t\tint i, M, a, b, c, n;\n\t\t\tlong[] AB = new long[50010];\n\t\t\twhile (true) {\n\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\tN = Integer.parseInt(param[0]);\n\t\t\t\tM = Integer.parseInt(param[1]);\n\t\t\t\tif (N==0 && M==0) break;\n\t\t\t\tif ((N&1) == 1) {\n\t\t\t\t\tfor (i = 0; i < M; i++) br.readLine();\n\t\t\t\t\tpw.println(0);\n\t\t\t\t} else {\n\t\t\t\t\tfor (n = 0, i = 0; i < M; i++) {\n\t\t\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\t\t\ta = Integer.parseInt(param[0]);\n\t\t\t\t\t\tb = Integer.parseInt(param[1]);\n\t\t\t\t\t\tif ((a+b&1)==1) AB[n++] = ((long)Math.min(a, b)<<16)|(Math.max(a, b));\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(AB, 0, n);\n\t\t\t\t\tfor (c = 0, i = 0; i < n; i++) {\n\t\t\t\t\t\tB[i] = (int)(AB[i]&65535);\n\t\t\t\t\t\ta = (int)(AB[i]>>>16);\n\t\t\t\t\t\tif (c < a) {\n\t\t\t\t\t\t\tfor (c = c+1; c < a; c++) A[c] = i;\n\t\t\t\t\t\t\tA[c] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (c = c+1; c < N+2; c++) A[c] = n;\n\t\t\t\t\tpw.println(analyze());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.close();\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tpublic static long analyze() {\n\t\thm.clear();\n\t\tlong answer = 2;\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tanswer = (answer + (1 + check(i+1, B[j]-1)) * (1 + check(B[j]+1, N))) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\t\n\tpublic static long check(int X, int Y) {\n\t\tif (X >= Y) return 0;\n\t\tLong memo = hm.get((X<<16)|Y);\n\t\tif (memo != null) return memo.longValue(); \n\t\tlong answer = 0;\n\t\tfor (int i = X; i < Y; i+=2) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tif (B[j]>Y) break;\n\t\t\t\tanswer = (answer + (1 + check(i+1, B[j]-1)) * (1 + check(B[j]+1, Y))) % MOD;\n\t\t\t}\n\t\t}\n\t\thm.put((X<<16)|Y, answer);\n\t\treturn answer;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\t\n\tpublic final static int MOD = 1000003;\n\tpublic static int N;\n\tpublic static int[] A = new int[50000+2];\n\tpublic static int[] B = new int[50000];\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\t\tString[] param;\n\t\t\tint i, M, a, b, c, n;\n\t\t\tint[] AB = new int[50000];\n\t\t\twhile (true) {\n\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\tN = Integer.parseInt(param[0]);\n\t\t\t\tM = Integer.parseInt(param[1]);\n\t\t\t\tif (N==0 && M==0) break;\n\t\t\t\tif ((N&1) == 1) {\n\t\t\t\t\tfor (i = 0; i < M; i++) br.readLine();\n\t\t\t\t\tpw.println(0);\n\t\t\t\t} else {\n\t\t\t\t\tAB = new int[M];\n\t\t\t\t\tfor (n = 0, i = 0; i < M; i++) {\n\t\t\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\t\t\ta = Integer.parseInt(param[0]);\n\t\t\t\t\t\tb = Integer.parseInt(param[1]);\n\t\t\t\t\t\tif ((a+b&1)==1) AB[n++] = (Math.min(a, b)<<16)|(Math.max(a, b));\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(AB, 0, n);\n\t\t\t\t\tfor (c = 0, i = 0; i < n; i++) {\n\t\t\t\t\t\tB[i] = AB[i]&65535;\n\t\t\t\t\t\ta = AB[i]>>16;\n\t\t\t\t\t\tif (c < a) {\n\t\t\t\t\t\t\tfor (c = c+1; c < a; c++) A[c] = A[c-1];\n\t\t\t\t\t\t\tA[c] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (c = c+1; c < N+2; c++) A[c] = n;\n\t\t\t\t\tpw.println(analyze());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.close();\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tpublic static long analyze() {\n\t\tlong answer = 2;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tanswer = (answer + (check(i, B[j]))) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\t\n\tpublic static long check(int X, int Y) {\n\t\tlong answer = 1;\n\t\tfor (int i = X+1; i < Y; i+=2) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tif (j>=Y) break;\n\t\t\t\tanswer = (answer + (check(i, B[j])));\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic class Main {\n\t\n\tpublic final static int MOD = 1000003;\n\tpublic static int N;\n\tpublic static int[] A = new int[50000+2];\n\tpublic static int[] B = new int[50000];\n\tpublic static HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\t\tString[] param;\n\t\t\tint i, M, a, b, c, n;\n\t\t\tlong[] AB = new long[50000];\n\t\t\twhile (true) {\n\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\tN = Integer.parseInt(param[0]);\n\t\t\t\tM = Integer.parseInt(param[1]);\n\t\t\t\tif (N==0 && M==0) break;\n\t\t\t\tif ((N&1) == 1) {\n\t\t\t\t\tfor (i = 0; i < M; i++) br.readLine();\n\t\t\t\t\tpw.println(0);\n\t\t\t\t} else {\n\t\t\t\t\tfor (n = 0, i = 0; i < M; i++) {\n\t\t\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\t\t\ta = Integer.parseInt(param[0]);\n\t\t\t\t\t\tb = Integer.parseInt(param[1]);\n\t\t\t\t\t\tif ((a+b&1)==1) AB[n++] = ((long)Math.min(a, b)<<16)|(Math.max(a, b));\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(AB, 0, n);\n\t\t\t\t\tfor (c = 0, i = 0; i < n; i++) {\n\t\t\t\t\t\tB[i] = (int)(AB[i]&65535);\n\t\t\t\t\t\ta = (int)(AB[i]>>>16);\n\t\t\t\t\t\tif (c < a) {\n\t\t\t\t\t\t\tfor (c = c+1; c < a; c++) A[c] = i;\n\t\t\t\t\t\t\tA[c] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (c = c+1; c < N+2; c++) A[c] = n;\n\t\t\t\t\tpw.println(analyze());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.close();\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tpublic static int analyze() {\n\t\thm.clear();\n\t\tint answer = 2;\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tanswer = (answer + 1 + check(i+1, B[j]-1) + check(B[j]+1, N)) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\t\n\tpublic static int check(int X, int Y) {\n\t\tif (X >= Y) return 0;\n//\t\tInteger memo = hm.get((X<<16)|Y);\n//\t\tif (memo != null) return memo.intValue(); \n\t\tint answer = 0;\n\t\tfor (int i = X; i < Y; i+=2) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tif (B[j]>Y) break;\n\t\t\t\tanswer = (answer + 1 + check(i+1, B[j]-1) + check(B[j]+1, Y)) % MOD;\n\t\t\t}\n\t\t}\n//\t\thm.put((X<<16)|Y, answer);\n\t\treturn answer;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\t\n\tpublic final static int MOD = 1000003;\n\tpublic static int N;\n\tpublic static int[] A = new int[50000+2];\n\tpublic static int[] B = new int[50000];\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\t\tString[] param;\n\t\t\tint i, M, a, b, c, n;\n\t\t\tlong[] AB = new long[50000];\n\t\t\twhile (true) {\n\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\tN = Integer.parseInt(param[0]);\n\t\t\t\tM = Integer.parseInt(param[1]);\n\t\t\t\tif (N==0 && M==0) break;\n\t\t\t\tif ((N&1) == 1) {\n\t\t\t\t\tfor (i = 0; i < M; i++) br.readLine();\n\t\t\t\t\tpw.println(0);\n\t\t\t\t} else {\n\t\t\t\t\tfor (n = 0, i = 0; i < M; i++) {\n\t\t\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\t\t\ta = Integer.parseInt(param[0]);\n\t\t\t\t\t\tb = Integer.parseInt(param[1]);\n\t\t\t\t\t\tif ((a+b&1)==1) AB[n++] = ((long)Math.min(a, b)<<16)|(Math.max(a, b));\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(AB, 0, n);\n\t\t\t\t\tfor (c = 0, i = 0; i < n; i++) {\n\t\t\t\t\t\tB[i] = (int)(AB[i]&65535);\n\t\t\t\t\t\ta = (int)(AB[i]>>>16);\n\t\t\t\t\t\tif (c < a) {\n\t\t\t\t\t\t\tfor (c = c+1; c < a; c++) A[c] = i;\n\t\t\t\t\t\t\tA[c] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (c = c+1; c < N+2; c++) A[c] = n;\n\t\t\t\t\tpw.println(analyze());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.close();\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tpublic static int analyze() {\n\t\tint answer = 2;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tanswer = (answer + check(i, B[j])) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\t\n\tpublic static int check(int X, int Y) {\n\t\tint answer = 1;\n\t\tfor (int i = X+1; i < Y; i+=2) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tif (B[j]>=Y) break;\n\t\t\t\tanswer = (answer + check(i, B[j])) % MOD;\n\t\t\t}\n\t\t}\n\t\tfor (int i = Y+1; i <= N; i+=2) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tanswer = (answer + check(i, B[j])) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main implements Runnable {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Thread(null, new Main(), \"\", Runtime.getRuntime().maxMemory()).start();\n\t}\n\n\tint n, m;\n\tint[] a, b;\n\tArrayList<Integer>[] g;\n\tfinal long MODULO = 1000003;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() throws FileNotFoundException {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\t\t\ta = new int[m];\n\t\t\tb = new int[m];\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t\t--a[i];\n\t\t\t\t--b[i];\n\t\t\t\tg[Math.min(a[i], b[i])].add(Math.max(a[i], b[i]));\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tg[Math.min(i, (i + 1) % n)].add(Math.max(i, (i + 1) % n));\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tCollections.sort(g[i]);\n\t\t\t}\n\t\t\tSystem.out.println(f(0, n - 1)[0][0]);\n\t\t}\n\t}\n\n\tlong[][] f(int src, int dst) {\n\t\tlong[][] ret = new long[2][2];\n\t\tret[0][0] = 1;\n\t\tret[1][1] = 1;\n\t\tfor (int i = 0; i + 1 < g[src].size(); ++i) {\n\t\t\tret = merge(ret, f(g[src].get(i), g[src].get(i + 1)));\n\t\t\tret[0][0] = (ret[0][0] + ret[1][1]) % MODULO;\n\t\t}\n\t\tif (g[src].get(g[src].size() - 1) != dst) {\n\t\t\tret = merge(ret, f(g[src].get(g[src].size() - 1), dst));\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolver();\n\t\t} catch (FileNotFoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t// 0???true???1???false??¨?????????\n\tlong[][] merge(long[][] a, long[][] b) {\n\t\tlong[][] ret = new long[2][2];\n\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tret[i][j] = (a[i][0] * b[1][j] + a[i][1] * b[0][j]) % MODULO;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate static void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic class Main {\n\t\n\tpublic final static int MOD = 1000003;\n\tpublic static int N;\n\tpublic static int[] A = new int[50000+2];\n\tpublic static int[] B = new int[50000];\n\tpublic static HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\t\tString[] param;\n\t\t\tint i, M, a, b, c, n;\n\t\t\tlong[] AB = new long[50000];\n\t\t\twhile (true) {\n\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\tN = Integer.parseInt(param[0]);\n\t\t\t\tM = Integer.parseInt(param[1]);\n\t\t\t\tif (N==0 && M==0) break;\n\t\t\t\tif ((N&1) == 1) {\n\t\t\t\t\tfor (i = 0; i < M; i++) br.readLine();\n\t\t\t\t\tpw.println(0);\n\t\t\t\t} else {\n\t\t\t\t\tfor (n = 0, i = 0; i < M; i++) {\n\t\t\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\t\t\ta = Integer.parseInt(param[0]);\n\t\t\t\t\t\tb = Integer.parseInt(param[1]);\n\t\t\t\t\t\tif ((a+b&1)==1) AB[n++] = ((long)Math.min(a, b)<<16)|(Math.max(a, b));\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(AB, 0, n);\n\t\t\t\t\tfor (c = 0, i = 0; i < n; i++) {\n\t\t\t\t\t\tB[i] = (int)(AB[i]&65535);\n\t\t\t\t\t\ta = (int)(AB[i]>>>16);\n\t\t\t\t\t\tif (c < a) {\n\t\t\t\t\t\t\tfor (c = c+1; c < a; c++) A[c] = i;\n\t\t\t\t\t\t\tA[c] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (c = c+1; c < N+2; c++) A[c] = n;\n\t\t\t\t\tpw.println(analyze());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.close();\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tpublic static int analyze() {\n\t\thm.clear();\n\t\tint answer = 2;\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tanswer = (answer + 1 + check(i+1, B[j]-1) + check(B[j]+1, N)) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\t\n\tpublic static int check(int X, int Y) {\n\t\tif (X >= Y) return 0;\n\t\tInteger memo = hm.get((X<<16)|Y);\n\t\tif (memo != null) return memo.intValue(); \n\t\tint answer = 0;\n\t\tfor (int i = X; i < Y; i+=2) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tif (B[j]>Y) break;\n\t\t\t\tanswer = (answer + 1 + check(i+1, B[j]-1) + check(B[j]+1, Y)) % MOD;\n\t\t\t}\n\t\t}\n\t\thm.put((X<<16)|Y, answer);\n\t\treturn answer;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\t\n\tpublic final static int MOD = 1000003;\n\tpublic static int N;\n\tpublic static int[] A = new int[50000+2];\n\tpublic static int[] B = new int[50000];\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\t\tString[] param;\n\t\t\tint i, M, a, b, c, n;\n\t\t\tlong[] AB = new long[50000];\n\t\t\twhile (true) {\n\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\tN = Integer.parseInt(param[0]);\n\t\t\t\tM = Integer.parseInt(param[1]);\n\t\t\t\tif (N==0 && M==0) break;\n\t\t\t\tif ((N&1) == 1) {\n\t\t\t\t\tfor (i = 0; i < M; i++) br.readLine();\n\t\t\t\t\tpw.println(0);\n\t\t\t\t} else {\n\t\t\t\t\tfor (n = 0, i = 0; i < M; i++) {\n\t\t\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\t\t\ta = Integer.parseInt(param[0]);\n\t\t\t\t\t\tb = Integer.parseInt(param[1]);\n\t\t\t\t\t\tif ((a+b&1)==1) AB[n++] = (Math.min(a, b)<<16)|(Math.max(a, b));\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(AB, 0, n);\n\t\t\t\t\tfor (c = 0, i = 0; i < n; i++) {\n\t\t\t\t\t\tB[i] = (int)(AB[i]&65535);\n\t\t\t\t\t\ta = (int)(AB[i]>>>16);\n\t\t\t\t\t\tif (c < a) {\n\t\t\t\t\t\t\tfor (c = c+1; c < a; c++) A[c] = i;\n\t\t\t\t\t\t\tA[c] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (c = c+1; c < N+2; c++) A[c] = n;\n\t\t\t\t\tpw.println(analyze());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.close();\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tpublic static int analyze() {\n\t\tint answer = 2;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tanswer = (answer + check(i, B[j])) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\t\n\tpublic static int check(int X, int Y) {\n\t\tint answer = 1;\n\t\tfor (int i = X+1; i < Y; i+=2) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tif (B[j]>=Y) break;\n\t\t\t\tanswer = (answer + check(i, B[j])) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic class Main {\n\t\n\tpublic final static int MOD = 1000003;\n\tpublic static int N;\n\tpublic static int[] A = new int[50000+2];\n\tpublic static int[] B = new int[50000];\n\tpublic static HashMap<Integer,Long> hm = new HashMap<Integer,Long>();\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\t\tString[] param;\n\t\t\tint i, M, a, b, c, n;\n\t\t\tlong[] AB = new long[50000];\n\t\t\twhile (true) {\n\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\tN = Integer.parseInt(param[0]);\n\t\t\t\tM = Integer.parseInt(param[1]);\n\t\t\t\tif (N==0 && M==0) break;\n\t\t\t\tif ((N&1) == 1) {\n\t\t\t\t\tfor (i = 0; i < M; i++) br.readLine();\n\t\t\t\t\tpw.println(0);\n\t\t\t\t} else {\n\t\t\t\t\tfor (n = 0, i = 0; i < M; i++) {\n\t\t\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\t\t\ta = Integer.parseInt(param[0]);\n\t\t\t\t\t\tb = Integer.parseInt(param[1]);\n\t\t\t\t\t\tif ((a+b&1)==1) AB[n++] = ((long)Math.min(a, b)<<16)|(Math.max(a, b));\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(AB, 0, n);\n\t\t\t\t\tfor (c = 0, i = 0; i < n; i++) {\n\t\t\t\t\t\tB[i] = (int)(AB[i]&65535);\n\t\t\t\t\t\ta = (int)(AB[i]>>>16);\n\t\t\t\t\t\tif (c < a) {\n\t\t\t\t\t\t\tfor (c = c+1; c < a; c++) A[c] = i;\n\t\t\t\t\t\t\tA[c] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (c = c+1; c < N+2; c++) A[c] = n;\n\t\t\t\t\tpw.println(analyze());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.close();\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tpublic static long analyze() {\n\t\thm.clear();\n\t\tlong answer = 2;\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tanswer = (answer + (1 + check(i+1, B[j]-1)) * (1 + check(B[j]+1, N))) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\t\n\tpublic static long check(int X, int Y) {\n\t\tif (X >= Y) return 0;\n\t\tLong memo = hm.get((X<<16)|Y);\n\t\tif (memo != null) return memo.longValue(); \n\t\tlong answer = 0;\n\t\tfor (int i = X; i < Y; i+=2) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tif (B[j]>Y) break;\n\t\t\t\tanswer = (answer + (1 + check(i+1, B[j]-1)) * (1 + check(B[j]+1, Y))) % MOD;\n\t\t\t}\n\t\t}\n\t\thm.put((X<<16)|Y, answer);\n\t\treturn answer;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\t\n\tpublic final static int MOD = 1000003;\n\tpublic static int N;\n\tpublic static int[] A = new int[50000+2];\n\tpublic static int[] B = new int[50000];\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\t\tString[] param;\n\t\t\tint i, M, a, b, c, n;\n\t\t\tint[] AB = new int[50000];\n\t\t\twhile (true) {\n\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\tN = Integer.parseInt(param[0]);\n\t\t\t\tM = Integer.parseInt(param[1]);\n\t\t\t\tif (N==0 && M==0) break;\n\t\t\t\tif ((N&1) == 1) {\n\t\t\t\t\tfor (i = 0; i < M; i++) br.readLine();\n\t\t\t\t\tpw.println(0);\n\t\t\t\t} else {\n\t\t\t\t\tfor (n = 0, i = 0; i < M; i++) {\n\t\t\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\t\t\ta = Integer.parseInt(param[0]);\n\t\t\t\t\t\tb = Integer.parseInt(param[1]);\n\t\t\t\t\t\tif ((a+b&1)==1) AB[n++] = (Math.min(a, b)<<16)|(Math.max(a, b));\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(AB, 0, n);\n\t\t\t\t\tfor (c = 0, i = 0; i < n; i++) {\n\t\t\t\t\t\tB[i] = AB[i]&65535;\n\t\t\t\t\t\ta = AB[i]>>>16;\n\t\t\t\t\t\tif (c < a) {\n\t\t\t\t\t\t\tfor (c = c+1; c < a; c++) A[c] = A[c-1];\n\t\t\t\t\t\t\tA[c] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (c = c+1; c < N+2; c++) A[c] = n;\n\t\t\t\t\tpw.println(analyze());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.close();\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tpublic static int analyze() {\n\t\tint answer = 2;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tanswer = (answer + check(i, B[j])) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\t\n\tpublic static int check(int X, int Y) {\n\t\tint answer = 1;\n\t\tfor (int i = X+1; i < Y; i+=2) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tif (j>=Y) break;\n\t\t\t\tanswer = (answer + check(i, B[j])) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\n\npublic class Main {\n\t\n\tpublic final static int MOD = 1000003;\n\tpublic static int N;\n\tpublic static int[] A = new int[50000+2];\n\tpublic static int[] B = new int[50000];\n\tpublic static HashMap<Integer,Integer> hm = new HashMap<Integer,Integer>();\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\t\tString[] param;\n\t\t\tint i, M, a, b, c, n;\n\t\t\tlong[] AB = new long[50000];\n\t\t\twhile (true) {\n\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\tN = Integer.parseInt(param[0]);\n\t\t\t\tM = Integer.parseInt(param[1]);\n\t\t\t\tif (N==0 && M==0) break;\n\t\t\t\tif ((N&1) == 1) {\n\t\t\t\t\tfor (i = 0; i < M; i++) br.readLine();\n\t\t\t\t\tpw.println(0);\n\t\t\t\t} else {\n\t\t\t\t\tfor (n = 0, i = 0; i < M; i++) {\n\t\t\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\t\t\ta = Integer.parseInt(param[0]);\n\t\t\t\t\t\tb = Integer.parseInt(param[1]);\n\t\t\t\t\t\tif ((a+b&1)==1) AB[n++] = ((long)Math.min(a, b)<<16)|(Math.max(a, b));\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(AB, 0, n);\n\t\t\t\t\tfor (c = 0, i = 0; i < n; i++) {\n\t\t\t\t\t\tB[i] = (int)(AB[i]&65535);\n\t\t\t\t\t\ta = (int)(AB[i]>>>16);\n\t\t\t\t\t\tif (c < a) {\n\t\t\t\t\t\t\tfor (c = c+1; c < a; c++) A[c] = i;\n\t\t\t\t\t\t\tA[c] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (c = c+1; c < N+2; c++) A[c] = n;\n\t\t\t\t\tpw.println(analyze());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.close();\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tpublic static int analyze() {\n\t\thm.clear();\n\t\tint answer = 2;\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tanswer = (answer + 1 + check(i+1, B[j]-1) + check(B[j]+1, N)) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\t\n\tpublic static int check(int X, int Y) {\n\t\tif (X >= Y) return 0;\n\t\tInteger memo = hm.get((X<<16)|Y);\n\t\tif (memo != null) return memo.intValue(); \n\t\tint answer = 0;\n\t\tfor (int i = X; i < Y; i+=2) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tif (B[j]>Y) break;\n\t\t\t\tanswer = (answer + 1 + check(i+1, B[j]-1) + check(B[j]+1, Y)) % MOD;\n\t\t\t}\n\t\t}\n\t\thm.put((X<<16)|Y, answer);\n\t\treturn answer;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tint n, m;\n\tint[] a, b;\n\tArrayList<Integer>[] g;\n\tfinal long MODULO = 1000003;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif (n == 0 && m == 0)\n\t\t\t\tbreak;\n\t\t\ta = new int[m];\n\t\t\tb = new int[m];\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t\t--a[i];\n\t\t\t\t--b[i];\n\t\t\t\tg[Math.min(a[i], b[i])].add(Math.max(a[i], b[i]));\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tg[Math.min(i, (i + 1) % n)].add(Math.max(i, (i + 1) % n));\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tCollections.sort(g[i]);\n\t\t\t}\n\t\t\tSystem.out.println(f(0, n - 1)[0][0]);\n\t\t}\n\t}\n\n\tlong[][] f(int src, int dst) {\n\t\tlong[][] ret = new long[2][2];\n\t\tret[0][0] = 1;\n\t\tret[1][1] = 1;\n\t\tfor (int i = 0; i + 1 < g[src].size(); ++i) {\n\t\t\tret = merge(ret, f(g[src].get(i), g[src].get(i + 1)));\n\t\t\tret[0][0] = (ret[0][0] + ret[1][1]) % MODULO;\n\t\t}\n\t\tif (g[src].get(g[src].size() - 1) != dst) {\n\t\t\tret = merge(ret, f(g[src].get(g[src].size() - 1), dst));\n\t\t}\n\t\treturn ret;\n\t}\n\n\t// 0???true???1???false??¨?????????\n\tlong[][] merge(long[][] a, long[][] b) {\n\t\tlong[][] ret = new long[2][2];\n\t\tfor (int i = 0; i < 2; ++i) {\n\t\t\tfor (int j = 0; j < 2; ++j) {\n\t\t\t\tret[i][j] = (a[i][0] * b[1][j] + a[i][1] * b[0][j]) % MODULO;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate static void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\t\n\tpublic final static int MOD = 1000003;\n\tpublic static int N;\n\tpublic static int[] A = new int[50000+2];\n\tpublic static int[] B = new int[50000];\n\tpublic static boolean[] f = new boolean[50000+1];\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\t\tString[] param;\n\t\t\tint i, M, a, b, c, n;\n\t\t\tlong[] AB = new long[50000];\n\t\t\twhile (true) {\n\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\tN = Integer.parseInt(param[0]);\n\t\t\t\tM = Integer.parseInt(param[1]);\n\t\t\t\tif (N==0 && M==0) break;\n\t\t\t\tif ((N&1) == 1) {\n\t\t\t\t\tfor (i = 0; i < M; i++) br.readLine();\n\t\t\t\t\tpw.println(0);\n\t\t\t\t} else {\n\t\t\t\t\tfor (n = 0, i = 0; i < M; i++) {\n\t\t\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\t\t\ta = Integer.parseInt(param[0]);\n\t\t\t\t\t\tb = Integer.parseInt(param[1]);\n\t\t\t\t\t\tif ((a+b&1)==1) AB[n++] = ((long)Math.min(a, b)<<16)|(Math.max(a, b));\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(AB, 0, n);\n\t\t\t\t\tfor (c = 0, i = 0; i < n; i++) {\n\t\t\t\t\t\tB[i] = (int)(AB[i]&65535);\n\t\t\t\t\t\ta = (int)(AB[i]>>>16);\n\t\t\t\t\t\tif (c < a) {\n\t\t\t\t\t\t\tfor (c = c+1; c < a; c++) A[c] = i;\n\t\t\t\t\t\t\tA[c] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (c = c+1; c < N+2; c++) A[c] = n;\n\t\t\t\t\tpw.println(analyze());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.close();\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tpublic static int analyze() {\n\t\tint answer = 2;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tanswer = (answer + check(i, B[j])) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\t\n\tpublic static int check(int X, int Y) {\n\t\tf[Y] = true;\n\t\tint answer = 1;\n\t\tfor (int i = X+1; i <= N; i+=2) {\n\t\t\tif (f[i]) { i--; continue; }\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tif (f[B[j]]) continue;\n\t\t\t\tanswer = (answer + check(i, B[j])) % MOD;\n\t\t\t}\n\t\t}\n\t\tf[Y] = false;\n\t\treturn answer;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class Main {\n\t\n\tpublic final static int MOD = 1000003;\n\tpublic static int N;\n\tpublic static int[] A = new int[50000+2];\n\tpublic static int[] B = new int[50000];\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tPrintWriter pw = new PrintWriter(System.out);\n\n\t\t\tString[] param;\n\t\t\tint i, M, a, b, c, n;\n\t\t\tint[] AB = new int[50000];\n\t\t\twhile (true) {\n\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\tN = Integer.parseInt(param[0]);\n\t\t\t\tM = Integer.parseInt(param[1]);\n\t\t\t\tif (N==0 && M==0) break;\n\t\t\t\tif ((N&1) == 1) {\n\t\t\t\t\tfor (i = 0; i < M; i++) br.readLine();\n\t\t\t\t\tpw.println(0);\n\t\t\t\t} else {\n\t\t\t\t\tfor (n = 0, i = 0; i < M; i++) {\n\t\t\t\t\t\tparam = br.readLine().split(\" \");\n\t\t\t\t\t\ta = Integer.parseInt(param[0]);\n\t\t\t\t\t\tb = Integer.parseInt(param[1]);\n\t\t\t\t\t\tif ((a+b&1)==1) AB[n++] = (Math.min(a, b)<<16)|(Math.max(a, b));\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(AB, 0, n);\n\t\t\t\t\tfor (c = 0, i = 0; i < n; i++) {\n\t\t\t\t\t\tB[i] = AB[i]&65535;\n\t\t\t\t\t\ta = AB[i]>>>16;\n\t\t\t\t\t\tif (c < a) {\n\t\t\t\t\t\t\tfor (c = c+1; c < a; c++) A[c] = A[c-1];\n\t\t\t\t\t\t\tA[c] = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (c = c+1; c < N+2; c++) A[c] = n;\n\t\t\t\t\tpw.println(analyze());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpw.close();\n\t\t\tbr.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\treturn;\n\t\t}\n\t}\n\t\n\tpublic static int analyze() {\n\t\tint answer = 2;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tanswer = (answer + check(i, B[j])) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n\t\n\tpublic static int check(int X, int Y) {\n\t\tint answer = 1;\n\t\tfor (int i = X+1; i < Y; i+=2) {\n\t\t\tfor (int j = A[i]; j < A[i+1]; j++) {\n\t\t\t\tif (j>=Y) break;\n\t\t\t\tanswer += check(i, B[j]);\n\t\t\t}\n\t\t}\n\t\treturn answer;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing static System.Math;\nusing static System.Array;\nusing static AtCoder.Tool;\nnamespace AtCoder\n{\n    class AC\n    {\n        const int MOD = 1000000007;\n        const int INF = int.MaxValue / 2;\n        const long SINF = long.MaxValue / 2;\n        const double EPS = 1e-8;\n        static readonly int[] dI = { 0, 1, 0, -1 };\n        static readonly int[] dJ = { 1, 0, -1, 0 };\n        //static List<List<int>> G = new List<List<int>>();\n        //static List<List<Edge>>G = new List<List<Edge>>();\n        //static List<Edge> E = new List<Edge>();\n        static void Main(string[] args)\n        {\n            //var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            //Console.SetOut(sw);\n            var cin = new Scanner();\n           \n            const int mod = 1000003;\n            while (true)\n            {\n                var input = cin.ReadSplitInt();\n                int n = input[0];\n                int m = input[1];\n                if (n == 0) { return; }\n                if (n % 2 == 1) { Console.WriteLine(0);continue; }\n                var E = new List<Tuple<int, int>>();\n                for(var i = 0; i < m; i++)\n                {\n                    var p = cin.ReadSplitInt();\n                    p[0]--;p[1]--;\n                    if (Abs(p[0] - p[1]) % 2 == 0) { continue; }\n                    E.Add(new Tuple<int, int>(Min(p[0], p[1]), Abs(p[0] - p[1])));\n                }\n                E.Add(new Tuple<int, int>(0, n - 1));\n                E.Sort((x, y) =>\n                {\n                    long dif = x.Item2 - y.Item2;\n                    return dif == 0 ? 0 : (dif > 0 ? 1 : -1);\n                });\n                var dp = new Tuple<int, long>[n];\n                for (var i = 0; i < n - 1; i++)\n                {\n                    dp[i] = new Tuple<int, long>(i + 1, 1);\n                }\n                foreach(var e in E)\n                {\n                    int l = e.Item1;\n                    int r = e.Item1 + e.Item2;\n\n                    long sum = 0;\n                    long ad1 = 1;\n                    int nx = l + 1;\n                    while (nx < r - 1)\n                    {\n                        ad1 *= dp[nx].Item2;\n                        ad1 %= mod;\n                        nx = dp[nx].Item1 + 1;\n                    }\n                    sum += ad1;\n                    sum %= mod;\n\n                    nx = l;\n                    long ad2 = 1;\n                    while (nx < r)\n                    {\n                        ad2 *= dp[nx].Item2;\n                        ad2 %= mod;\n                        nx = dp[nx].Item1 + 1;\n                    }\n                    sum += ad2;\n                    sum %= mod;\n\n\n                    dp[l] = new Tuple<int, long>(r, sum);\n                }\n                Console.WriteLine(dp[0].Item2);\n            }\n\n            //Console.Out.Flush();\n        }\n        struct Edge\n        {\n            public int from;\n\n            public int to;\n            public long dist;\n            public Edge(int t, long c)\n            {\n                from = -1;\n                to = t;\n                dist = c;\n            }\n            public Edge(int f, int t, long c)\n            {\n                from = f;\n                to = t;\n                dist = c;\n            }\n\n        }\n    }\n    \n    public class Scanner\n    {\n        public int[] ReadSplitInt()\n        {\n            return ConvertAll(Console.ReadLine().Split(), int.Parse);\n        }\n        public long[] ReadSplitLong()\n        {\n            return ConvertAll(Console.ReadLine().Split(), long.Parse);\n        }\n        public double[] ReadSplit_Double()\n        {\n            return ConvertAll(Console.ReadLine().Split(), double.Parse);\n        }\n    }\n    public static class Tool\n    {\n        static public void Initialize<T>(ref T[] array, T initialvalue)\n        {\n            for (var i = 0; i < array.Length; i++)\n            {\n                array[i] = initialvalue;\n            }\n        }\n        static public void Swap<T>(ref T a, ref T b)\n        {\n            T keep = a;\n            a = b;\n            b = keep;\n        }\n\n        static public void Display<T>(T[,] array2d, int n, int m)\n        {\n            for (var i = 0; i < n; i++)\n            {\n                for (var j = 0; j < m; j++)\n                {\n                    Console.Write($\"{array2d[i, j]} \");\n                }\n                Console.WriteLine();\n            }\n        }\n\n        static public long LPow(int a, int b)\n        {\n            return (long)Pow(a, b);\n        }\n    }\n    class Modulo\n    {\n        private const int M = 1000000007;\n        private readonly int[] m_facs;\n        public int Mul(int a, int b)\n        {\n            return (int)(Math.BigMul(a, b) % M);\n        }\n        public Modulo(int n)\n        {\n            m_facs = new int[n + 1];\n            m_facs[0] = 1;\n            for (int i = 1; i <= n; ++i)\n            {\n                m_facs[i] = Mul(m_facs[i - 1], i);\n            }\n        }\n        public int Fac(int n)\n        {\n            return m_facs[n];\n        }\n        public int Pow(int a, int m)\n        {\n            switch (m)\n            {\n                case 0:\n                    return 1;\n                case 1:\n                    return a;\n                default:\n                    int p1 = Pow(a, m / 2);\n                    int p2 = Mul(p1, p1);\n                    return ((m % 2) == 0) ? p2 : Mul(p2, a);\n            }\n        }\n        public int Div(int a, int b)\n        {\n            return Mul(a, Pow(b, M - 2));\n        }\n        public int Ncr(int n, int r)\n        {\n            if (n < r) { return 0; }\n            if (n == r) { return 1; }\n            int res = Fac(n);\n            res = Div(res, Fac(r));\n            res = Div(res, Fac(n - r));\n            return res;\n        }\n        public Modulo() { }\n    }\n}\n\n"
  },
  {
    "language": "Python",
    "code": "mod = 10**6+3\ndef solve(left,right):\n    cnt = 1\n    while left < right:\n        cnt = cnt*dp[left][1]%mod\n        left = dp[left][0]+1\n    return cnt\n\nwhile True:\n    n,m = map(int, input().split())\n    if n == m == 0:\n        break\n    if n%2 == 1:\n        print(0)\n    else:\n        dp = [[0,0]] * n\n        brli = []\n        for i in range(n-1):\n            dp[i] = [i+1, 1]\n        for i in range(m):\n            a, b = map(int, input().split())\n            if a > b:\n                a, b = b, a\n            if (b-a)%2 == 1:\n                brli.append((a-1, b-1))\n        brli.append((0, n-1))\n        brli.sort(key=lambda x: x[1]-x[0])\n        for br in brli:\n            l, r = br[0], br[1]\n            dp[l+1] = [r-1, solve(l+1, r-1)]\n            dp[l] = [r,(dp[l+1][1]+dp[l][1]*solve(dp[l][0]+1, r))%mod]\n        print(dp[0][1])\n"
  }
]