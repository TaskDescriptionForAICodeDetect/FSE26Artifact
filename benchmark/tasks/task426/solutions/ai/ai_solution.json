[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000003\n\nint n, m;\nint adj[20][20];\nint dp[1 << 20];\n\nint solve(int mask) {\n    if (mask == (1 << n) - 1) return 1;\n    if (dp[mask] != -1) return dp[mask];\n    \n    int first = -1;\n    for (int i = 0; i < n; i++) {\n        if (!(mask & (1 << i))) {\n            first = i;\n            break;\n        }\n    }\n    \n    if (first == -1) return 0;\n    \n    int res = 0;\n    for (int j = first + 1; j < n; j++) {\n        if (!(mask & (1 << j)) && adj[first][j]) {\n            int new_mask = mask | (1 << first) | (1 << j);\n            res = (res + solve(new_mask)) % MOD;\n        }\n    }\n    \n    dp[mask] = res;\n    return res;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    memset(adj, 0, sizeof(adj));\n    \n    for (int i = 0; i < n; i++) {\n        adj[i][(i + 1) % n] = 1;\n        adj[(i + 1) % n][i] = 1;\n    }\n    \n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        adj[u][v] = adj[v][u] = 1;\n    }\n    \n    memset(dp, -1, sizeof(dp));\n    printf(\"%d\\n\", solve(0));\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:29:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\nconst int MOD = 1000003;\nint n, m;\nbool adj[20][20];\nlong long dp[1 << 20];\n\nint main() {\n    cin >> n >> m;\n    memset(adj, false, sizeof(adj));\n    for (int i = 0; i < n; ++i) {\n        adj[i][(i + 1) % n] = true;\n        adj[(i + 1) % n][i] = true;\n    }\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u][v] = adj[v][u] = true;\n    }\n    \n    memset(dp, 0, sizeof(dp));\n    dp[0] = 1;\n    for (int mask = 0; mask < (1 << n); ++mask) {\n        if (dp[mask] == 0) continue;\n        int first = -1;\n        for (int i = 0; i < n; ++i) {\n            if (!(mask & (1 << i))) {\n                first = i;\n                break;\n            }\n        }\n        if (first == -1) continue;\n        for (int j = first + 1; j < n; ++j) {\n            if (!(mask & (1 << j)) && !adj[first][j]) {\n                int new_mask = mask | (1 << first) | (1 << j);\n                dp[new_mask] = (dp[new_mask] + dp[mask]) % MOD;\n            }\n        }\n    }\n    \n    cout << dp[(1 << n) - 1] << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:30:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SisterPorts {\n    private static final int MOD = 1000003;\n    private boolean[][] road;\n    private int n;\n    private int[] dp;\n\n    public int solve(int n, int[][] roads) {\n        this.n = n;\n        road = new boolean[n][n];\n        for (int[] r : roads) {\n            int u = r[0], v = r[1];\n            road[u][v] = road[v][u] = true;\n        }\n        dp = new int[1 << n];\n        Arrays.fill(dp, -1);\n        return dfs(0);\n    }\n\n    private int dfs(int mask) {\n        if (mask == (1 << n) - 1) {\n            return 1;\n        }\n        if (dp[mask] != -1) {\n            return dp[mask];\n        }\n        int res = 0;\n        int first = -1;\n        for (int i = 0; i < n; i++) {\n            if ((mask & (1 << i)) == 0) {\n                first = i;\n                break;\n            }\n        }\n        if (first == -1) {\n            return 0;\n        }\n        for (int j = first + 1; j < n; j++) {\n            if ((mask & (1 << j)) == 0 && road[first][j]) {\n                int newMask = mask | (1 << first) | (1 << j);\n                res = (res + dfs(newMask)) % MOD;\n            }\n        }\n        dp[mask] = res;\n        return res;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int[][] roads = new int[m][2];\n        for (int i = 0; i < m; i++) {\n            roads[i][0] = sc.nextInt();\n            roads[i][1] = sc.nextInt();\n        }\n        SisterPorts solver = new SisterPorts();\n        System.out.println(solver.solve(n, roads));\n    }\n}",
    "timestamp": "2025-08-05 21:30:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SisterPorts {\n    public static int countSisterPortConfigurations(int n, List<int[]> internalRoads) {\n        final int MOD = 1000003;\n        \n        // Create adjacency matrix to represent roads\n        boolean[][] roads = new boolean[n][n];\n        for (int i = 0; i < n; i++) {\n            roads[i][(i + 1) % n] = true;\n            roads[(i + 1) % n][i] = true;\n        }\n        \n        // Add internal roads\n        for (int[] road : internalRoads) {\n            roads[road[0]][road[1]] = true;\n            roads[road[1]][road[0]] = true;\n        }\n        \n        // Track used ports\n        boolean[] used = new boolean[n];\n        \n        return countPairings(n, roads, used, 0);\n    }\n    \n    private static int countPairings(int n, boolean[][] roads, boolean[] used, int currentPort) {\n        // Base case: all ports paired\n        if (currentPort == n) {\n            return 1;\n        }\n        \n        // Skip already used ports\n        if (used[currentPort]) {\n            return countPairings(n, roads, used, currentPort + 1);\n        }\n        \n        int totalConfigurations = 0;\n        used[currentPort] = true;\n        \n        // Try pairing with other unused ports\n        for (int otherPort = currentPort + 1; otherPort < n; otherPort++) {\n            if (!used[otherPort] && !roads[currentPort][otherPort]) {\n                used[otherPort] = true;\n                totalConfigurations += countPairings(n, roads, used, currentPort + 1);\n                totalConfigurations %= 1000003;\n                used[otherPort] = false;\n            }\n        }\n        \n        used[currentPort] = false;\n        return totalConfigurations;\n    }\n    \n    public static void main(String[] args) {\n        int n = 6;\n        List<int[]> internalRoads = Arrays.asList(\n            new int[]{0, 2},\n            new int[]{1, 3},\n            new int[]{4, 5}\n        );\n        \n        System.out.println(countSisterPortConfigurations(n, internalRoads));\n    }\n}",
    "timestamp": "2025-08-05 21:30:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MOD 1000003\n\nint roads[100][100];\nint n, m;\nint used[100];\n\nlong long countPairings(int current) {\n    if (current >= n) return 1;\n    if (used[current]) return countPairings(current + 1);\n\n    long long total = 0;\n    used[current] = 1;\n\n    for (int j = current + 1; j < n; j++) {\n        if (!used[j]) {\n            int canPair = 1;\n            \n            // Check direct road constraint\n            if (abs(current - j) == 1 || abs(current - j) == n - 1) continue;\n            \n            // Check internal road constraint\n            if (roads[current][j]) continue;\n\n            used[j] = 1;\n            total += countPairings(current + 1);\n            used[j] = 0;\n        }\n    }\n\n    used[current] = 0;\n    return total % MOD;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < m; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        roads[x-1][y-1] = roads[y-1][x-1] = 1;\n    }\n\n    memset(used, 0, sizeof(used));\n    long long result = countPairings(0);\n\n    printf(\"%lld\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:30:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1000003;\n\nclass SisterPorts {\npublic:\n    int countConfigurations(int n, vector<vector<int>>& roads) {\n        vector<vector<bool>> graph(n, vector<bool>(n, false));\n        \n        // Add adjacent roads\n        for (int i = 0; i < n; i++) {\n            graph[i][(i+1)%n] = true;\n            graph[(i+1)%n][i] = true;\n        }\n        \n        // Add internal roads\n        for (auto& road : roads) {\n            graph[road[0]][road[1]] = true;\n            graph[road[1]][road[0]] = true;\n        }\n        \n        vector<bool> used(n, false);\n        return dfs(graph, used, 0);\n    }\n    \nprivate:\n    int dfs(vector<vector<bool>>& graph, vector<bool>& used, int curr) {\n        int n = graph.size();\n        \n        // All ports used, configuration found\n        if (curr == n) return 1;\n        \n        // Skip used ports\n        if (used[curr]) return dfs(graph, used, curr + 1);\n        \n        int total = 0;\n        used[curr] = true;\n        \n        // Try pairing with each possible sister port\n        for (int j = curr + 1; j < n; j++) {\n            if (!used[j] && !graph[curr][j]) {\n                used[j] = true;\n                total = (total + dfs(graph, used, curr + 1)) % MOD;\n                used[j] = false;\n            }\n        }\n        \n        used[curr] = false;\n        return total;\n    }\n};",
    "timestamp": "2025-08-05 21:30:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_sister_ports(n, m, internal_roads):\n    mod = 1000003\n\n    if n % 2 != 0:\n        return 0\n\n    from itertools import combinations\n    \n    roads = {i: [] for i in range(n)}\n    for u, v in internal_roads:\n        u -= 1\n        v -= 1\n        roads[u].append(v)\n        roads[v].append(u)\n    \n    for i in range(n):\n        roads[i].append((i + 1) % n)\n        roads[i].append((i - 1 + n) % n)\n    \n    def solve(graph):\n        visited = [False] * n\n        \n        def isValid(u, v):\n            if v in roads[u]:\n                return False\n            if visited[u] or visited[v]:\n                return False\n            visited[u] = visited[v] = True\n            return True\n\n        def countWays(pos):\n            if pos >= n:\n                return 1\n            if visited[pos]:\n                return countWays(pos + 1)\n\n            count = 0\n            for next_pos in range(pos + 1, n):\n                if isValid(pos, next_pos):\n                    count += countWays(pos + 1)\n                    count %= mod\n                    visited[pos] = visited[next_pos] = False\n            return count\n\n        return countWays(0) % mod\n\n    return solve(roads)\n\nn = 8\nm = 2\ninternal_roads = [(1, 4), (3, 8)]\nprint(find_sister_ports(n, m, internal_roads))",
    "timestamp": "2025-08-13 06:44:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SisterPorts {\n\n    private static final int MOD = 1000003;\n    private static List<Integer>[] adjList;\n    private static int[] match;\n    private static boolean[] visited;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        \n        adjList = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            adjList[i] = new ArrayList<>();\n            adjList[i].add((i + 1) % n); // adjacent\n            adjList[i].add((i + n - 1) % n); // adjacent\n        }\n\n        for (int i = 0; i < m; i++) {\n            int u = sc.nextInt() - 1;\n            int v = sc.nextInt() - 1;\n            adjList[u].add(v);\n            adjList[v].add(u);\n        }\n\n        match = new int[n];\n        Arrays.fill(match, -1);\n        visited = new boolean[n];\n\n        long totalMatchings = countMatchings(n);\n        System.out.println(totalMatchings % MOD);\n        sc.close();\n    }\n\n    private static long countMatchings(int n) {\n        if (n % 2 != 0) return 0; // Odd number of vertices, no perfect matching\n        long total = 1;\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(visited, false);\n            if (!dfs(i)) {\n                return 0;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (match[i] == -1) {\n                total = (total * (i + 1)) % MOD;\n            }\n        }\n        return total;\n    }\n\n    private static boolean dfs(int u) {\n        for (int v : adjList[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                if (match[v] == -1 || dfs(match[v])) {\n                    match[u] = v;\n                    match[v] = u;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}",
    "timestamp": "2025-08-13 06:44:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MOD 1000003\n\nint is_adjacent(int a, int b, int n) {\n    return (a == (b + 1) % n) || (b == (a + 1) % n);\n}\n\nint count_pairings(int n, int m, int internal_roads[][2]) {\n    int dp[n / 2 + 1][1 << n];\n    for (int i = 0; i <= n / 2; i++) {\n        for (int j = 0; j < (1 << n); j++) {\n            dp[i][j] = 0;\n        }\n    }\n    dp[0][0] = 1;\n\n    for (int mask = 0; mask < (1 << n); mask++) {\n        for (int i = 0; i < n; i++) {\n            if ((mask & (1 << i)) == 0) {\n                for (int j = i + 1; j < n; j++) {\n                    if ((mask & (1 << j)) == 0 && !is_adjacent(i, j, n)) {\n                        int valid = 1;\n                        for (int k = 0; k < m; k++) {\n                            int u = internal_roads[k][0];\n                            int v = internal_roads[k][1];\n                            if ((u == i && v == j) || (u == j && v == i)) {\n                                valid = 0;\n                                break;\n                            }\n                        }\n                        if (valid) {\n                            for (int pairs = 0; pairs <= n / 2; pairs++) {\n                                if (dp[pairs][mask]) {\n                                    dp[pairs + 1][mask | (1 << i) | (1 << j)] = \n                                        (dp[pairs + 1][mask | (1 << i) | (1 << j)] + dp[pairs][mask]) % MOD;\n                                }\n                            }\n                        }\n                    }\n                }\n                break;\n            }\n        }\n    }\n\n    return dp[n / 2][(1 << n) - 1];\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    int internal_roads[m][2];\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &internal_roads[i][0], &internal_roads[i][1]);\n    }\n\n    if (n % 2 != 0) {\n        printf(\"0\\n\");\n    } else {\n        printf(\"%d\\n\", count_pairings(n, m, internal_roads));\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 06:44:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_sister_port_configurations(n, roads):\n    def is_adjacent(a, b):\n        return abs(a - b) % n == 1 or abs(a - b) % n == n - 1\n\n    def dfs(used, current_pairing):\n        if len(used) == n:\n            return 1 if len(current_pairing) == n // 2 else 0\n\n        total_configs = 0\n        for i in range(n):\n            if i in used:\n                continue\n            \n            can_pair = True\n            for j in range(i + 1, n):\n                if j in used:\n                    continue\n                \n                # Check if ports can be paired\n                if j not in roads.get(i, set()) and not is_adjacent(i, j):\n                    used.add(i)\n                    used.add(j)\n                    current_pairing.append((i, j))\n                    \n                    total_configs += dfs(used, current_pairing)\n                    total_configs %= 1000003\n                    \n                    used.remove(i)\n                    used.remove(j)\n                    current_pairing.pop()\n        \n        return total_configs\n\n    # Convert roads to adjacency set\n    road_map = {}\n    for a, b in roads:\n        road_map.setdefault(a, set()).add(b)\n        road_map.setdefault(b, set()).add(a)\n\n    return dfs(set(), [])",
    "timestamp": "2025-08-13 06:44:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 1000003\n\ndef solve():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    n = int(input[ptr])\n    ptr += 1\n    m = int(input[ptr])\n    ptr += 1\n    \n    adj = [[False] * n for _ in range(n)]\n    for _ in range(m):\n        u = int(input[ptr]) - 1\n        ptr += 1\n        v = int(input[ptr]) - 1\n        ptr += 1\n        adj[u][v] = True\n        adj[v][u] = True\n    \n    # Precompute the adjacency for all pairs\n    # Now, we need to find the number of perfect matchings where no matched pair is connected by a road\n    # We can use DP on subsets, but n is up to 16, so it's manageable\n    \n    # dp[mask] = number of ways to pair the ports in mask\n    dp = [0] * (1 << n)\n    dp[0] = 1\n    \n    for mask in range(1, 1 << n):\n        # Find the first unpaired port\n        first = -1\n        for i in range(n):\n            if not (mask & (1 << i)):\n                first = i\n                break\n        if first == -1:\n            continue  # all ports are paired\n        \n        # Try to pair 'first' with another unpaired port j > first, and no road between them\n        res = 0\n        for j in range(first + 1, n):\n            if not (mask & (1 << j)) and not adj[first][j]:\n                new_mask = mask | (1 << first) | (1 << j)\n                res += dp[mask]\n                res %= MOD\n        dp[mask | (1 << first)] = res\n    \n    print(dp[(1 << n) - 1] % MOD)\n\nsolve()",
    "timestamp": "2025-08-13 06:44:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1000003;\n\ntypedef vector<vector<int>> Matrix;\n\n// Helper function to multiply two matrices modulo MOD\nMatrix multiply(const Matrix &a, const Matrix &b, int size) {\n    Matrix result(size, vector<int>(size, 0));\n    for (int i = 0; i < size; ++i) {\n        for (int j = 0; j < size; ++j) {\n            for (int k = 0; k < size; ++k) {\n                result[i][j] = (result[i][j] + a[i][k] * b[k][j]) % MOD;\n            }\n        }\n    }\n    return result;\n}\n\n// Helper function to perform matrix exponentiation\nMatrix matrix_exponentiation(const Matrix &a, int exp, int size) {\n    Matrix result(size, vector<int>(size, 0));\n    for (int i = 0; i < size; ++i) result[i][i] = 1;  // Identity matrix\n    \n    Matrix base = a;\n    while (exp > 0) {\n        if (exp % 2 == 1) result = multiply(result, base, size);\n        base = multiply(base, base, size);\n        exp /= 2;\n    }\n    return result;\n}\n\nint solve(int n, int m, vector<pair<int, int>> internal_roads) {\n    Matrix roads(n, vector<int>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        roads[i][(i+1)%n] = 1;\n        roads[(i+1)%n][i] = 1;\n    }\n\n    for (const auto &road : internal_roads) {\n        roads[road.first-1][road.second-1] = 1;\n        roads[road.second-1][road.first-1] = 1;\n    }\n\n    Matrix dp(n+1, vector<int>(n+1, 0));\n    dp[0][0] = 1;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j <= n; ++j) {\n            dp[i+1][j] = (dp[i+1][j] + dp[i][j]) % MOD;\n            if (j > 0 && roads[i][i] == 0) {\n                dp[i+1][j] = (dp[i+1][j] + dp[i][j-1] * roads[i][(i-j+1+n)%n]) % MOD;\n            }\n        }\n    }\n\n    return dp[n][n / 2];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    vector<pair<int, int>> internal_roads(m);\n    for (int i = 0; i < m; ++i) {\n        int u, v;\n        cin >> u >> v;\n        internal_roads[i] = {u, v};\n    }\n\n    cout << solve(n, m, internal_roads) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:33:56"
  }
]