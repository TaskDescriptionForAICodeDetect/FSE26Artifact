[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MOD 998244353\n#define MAX_N 200005\n\nlong long arr[MAX_N];\nint N, Q;\n\nvoid process_multiply_add(int l, int r, long long b, long long c) {\n    for (int i = l; i < r; i++) {\n        arr[i] = (b * arr[i] + c) % MOD;\n    }\n}\n\nlong long range_sum(int l, int r) {\n    long long sum = 0;\n    for (int i = l; i < r; i++) {\n        sum = (sum + arr[i]) % MOD;\n    }\n    return sum;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &Q);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%lld\", &arr[i]);\n    }\n    \n    while (Q--) {\n        int type, l, r;\n        scanf(\"%d %d %d\", &type, &l, &r);\n        \n        if (type == 0) {\n            long long b, c;\n            scanf(\"%lld %lld\", &b, &c);\n            process_multiply_add(l, r, b, c);\n        } else {\n            printf(\"%lld\\n\", range_sum(l, r));\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:25:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 998244353\n#define MAX_N 200000\n\ntypedef struct {\n    long long b, c;\n} LazyTag;\n\nlong long a[MAX_N];\nLazyTag lazy[4 * MAX_N];\nlong long sum[4 * MAX_N];\nint n;\n\nvoid build(int node, int l, int r) {\n    lazy[node].b = 1;\n    lazy[node].c = 0;\n    if (l == r - 1) {\n        sum[node] = a[l] % MOD;\n        return;\n    }\n    int mid = (l + r) / 2;\n    build(2 * node + 1, l, mid);\n    build(2 * node + 2, mid, r);\n    sum[node] = (sum[2 * node + 1] + sum[2 * node + 2]) % MOD;\n}\n\nvoid push(int node, int l, int r) {\n    if (lazy[node].b == 1 && lazy[node].c == 0) return;\n    sum[node] = (sum[node] * lazy[node].b + lazy[node].c * (r - l)) % MOD;\n    if (r - l > 1) {\n        int left = 2 * node + 1;\n        int right = 2 * node + 2;\n        lazy[left].b = (lazy[left].b * lazy[node].b) % MOD;\n        lazy[left].c = (lazy[left].c * lazy[node].b + lazy[node].c) % MOD;\n        lazy[right].b = (lazy[right].b * lazy[node].b) % MOD;\n        lazy[right].c = (lazy[right].c * lazy[node].b + lazy[node].c) % MOD;\n    }\n    lazy[node].b = 1;\n    lazy[node].c = 0;\n}\n\nvoid update(int node, int l, int r, int ql, int qr, long long b, long long c) {\n    push(node, l, r);\n    if (qr <= l || r <= ql) return;\n    if (ql <= l && r <= qr) {\n        lazy[node].b = b;\n        lazy[node].c = c;\n        push(node, l, r);\n        return;\n    }\n    int mid = (l + r) / 2;\n    update(2 * node + 1, l, mid, ql, qr, b, c);\n    update(2 * node + 2, mid, r, ql, qr, b, c);\n    sum[node] = (sum[2 * node + 1] + sum[2 * node + 2]) % MOD;\n}\n\nlong long query(int node, int l, int r, int ql, int qr) {\n    push(node, l, r);\n    if (qr <= l || r <= ql) return 0;\n    if (ql <= l && r <= qr) return sum[node];\n    int mid = (l + r) / 2;\n    long long left_sum = query(2 * node + 1, l, mid, ql, qr);\n    long long right_sum = query(2 * node + 2, mid, r, ql, qr);\n    return (left_sum + right_sum) % MOD;\n}\n\nint main() {\n    int q;\n    scanf(\"%d %d\", &n, &q);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lld\", &a[i]);\n    }\n    build(0, 0, n);\n    while (q--) {\n        int type;\n        scanf(\"%d\", &type);\n        if (type == 0) {\n            int l, r;\n            long long b, c;\n            scanf(\"%d %d %lld %lld\", &l, &r, &b, &c);\n            update(0, 0, n, l, r, b, c);\n        } else {\n            int l, r;\n            scanf(\"%d %d\", &l, &r);\n            printf(\"%lld\\n\", query(0, 0, n, l, r));\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:25:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int MAX_N = 1 << 18;\n\nstruct LazyNode {\n    long long b, c;\n    LazyNode() : b(1), c(0) {}\n    LazyNode(long long b, long long c) : b(b % MOD), c(c % MOD) {}\n    bool has_effect() const { return b != 1 || c != 0; }\n    void reset() { b = 1; c = 0; }\n};\n\nLazyNode combine_lazy(const LazyNode &parent, const LazyNode &child) {\n    return LazyNode(\n        (parent.b * child.b) % MOD,\n        (parent.b * child.c + parent.c) % MOD\n    );\n}\n\nstruct SegNode {\n    long long sum;\n    int len;\n    SegNode() : sum(0), len(0) {}\n    SegNode(long long sum, int len) : sum(sum % MOD), len(len) {}\n};\n\nSegNode combine_seg(const SegNode &left, const SegNode &right) {\n    return SegNode(\n        (left.sum + right.sum) % MOD,\n        left.len + right.len\n    );\n}\n\nSegNode apply_lazy(const SegNode &node, const LazyNode &lazy) {\n    return SegNode(\n        (node.sum * lazy.b + node.len * lazy.c) % MOD,\n        node.len\n    );\n}\n\nclass LazySegTree {\nprivate:\n    vector<SegNode> seg;\n    vector<LazyNode> lazy;\n    int n;\n\n    void push(int node, int l, int r) {\n        if (!lazy[node].has_effect()) return;\n        seg[node] = apply_lazy(seg[node], lazy[node]);\n        if (l != r) {\n            int mid = (l + r) / 2;\n            int left = 2 * node + 1;\n            int right = 2 * node + 2;\n            lazy[left] = combine_lazy(lazy[node], lazy[left]);\n            lazy[right] = combine_lazy(lazy[node], lazy[right]);\n        }\n        lazy[node].reset();\n    }\n\n    void build(int node, int l, int r, const vector<long long> &a) {\n        if (l == r) {\n            seg[node] = SegNode(a[l], 1);\n            return;\n        }\n        int mid = (l + r) / 2;\n        build(2 * node + 1, l, mid, a);\n        build(2 * node + 2, mid + 1, r, a);\n        seg[node] = combine_seg(seg[2 * node + 1], seg[2 * node + 2]);\n    }\n\n    void update_range(int node, int l, int r, int ql, int qr, const LazyNode &val) {\n        push(node, l, r);\n        if (qr < l || r < ql) return;\n        if (ql <= l && r <= qr) {\n            lazy[node] = combine_lazy(val, lazy[node]);\n            push(node, l, r);\n            return;\n        }\n        int mid = (l + r) / 2;\n        update_range(2 * node + 1, l, mid, ql, qr, val);\n        update_range(2 * node + 2, mid + 1, r, ql, qr, val);\n        seg[node] = combine_seg(seg[2 * node + 1], seg[2 * node + 2]);\n    }\n\n    SegNode query_range(int node, int l, int r, int ql, int qr) {\n        push(node, l, r);\n        if (qr < l || r < ql) return SegNode();\n        if (ql <= l && r <= qr) return seg[node];\n        int mid = (l + r) / 2;\n        return combine_seg(\n            query_range(2 * node + 1, l, mid, ql, qr),\n            query_range(2 * node + 2, mid + 1, r, ql, qr)\n        );\n    }\n\npublic:\n    LazySegTree(const vector<long long> &a) {\n        n = a.size();\n        seg.resize(4 * n);\n        lazy.resize(4 * n);\n        build(0, 0, n - 1, a);\n    }\n\n    void update(int l, int r, long long b, long long c) {\n        update_range(0, 0, n - 1, l, r, LazyNode(b, c));\n    }\n\n    long long query(int l, int r) {\n        return query_range(0, 0, n - 1, l, r).sum;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, Q;\n    cin >> N >> Q;\n    vector<long long> a(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> a[i];\n    }\n\n    LazySegTree seg(a);\n\n    while (Q--) {\n        int type;\n        cin >> type;\n        if (type == 0) {\n            int l, r;\n            long long b, c;\n            cin >> l >> r >> b >> c;\n            seg.update(l, r - 1, b, c);\n        } else {\n            int l, r;\n            cin >> l >> r;\n            cout << seg.query(l, r - 1) << '\\n';\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:26:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static final int MOD = 998244353;\n    static long[] a;\n    static long[] sum;\n    static long[] mul;\n    static long[] add;\n    static int n;\n\n    static void build(int node, int l, int r) {\n        mul[node] = 1;\n        add[node] = 0;\n        if (l == r - 1) {\n            sum[node] = a[l];\n        } else {\n            int mid = (l + r) >>> 1;\n            build(node * 2 + 1, l, mid);\n            build(node * 2 + 2, mid, r);\n            sum[node] = (sum[node * 2 + 1] + sum[node * 2 + 2]) % MOD;\n        }\n    }\n\n    static void push(int node, int l, int r) {\n        if (mul[node] == 1 && add[node] == 0) return;\n        int mid = (l + r) >>> 1;\n        sum[node * 2 + 1] = (sum[node * 2 + 1] * mul[node] + add[node] * (mid - l)) % MOD;\n        sum[node * 2 + 2] = (sum[node * 2 + 2] * mul[node] + add[node] * (r - mid)) % MOD;\n        mul[node * 2 + 1] = (mul[node * 2 + 1] * mul[node]) % MOD;\n        mul[node * 2 + 2] = (mul[node * 2 + 2] * mul[node]) % MOD;\n        add[node * 2 + 1] = (add[node * 2 + 1] * mul[node] + add[node]) % MOD;\n        add[node * 2 + 2] = (add[node * 2 + 2] * mul[node] + add[node]) % MOD;\n        mul[node] = 1;\n        add[node] = 0;\n    }\n\n    static void update(int node, int l, int r, int ql, int qr, long b, long c) {\n        if (qr <= l || r <= ql) return;\n        if (ql <= l && r <= qr) {\n            sum[node] = (sum[node] * b + c * (r - l)) % MOD;\n            mul[node] = (mul[node] * b) % MOD;\n            add[node] = (add[node] * b + c) % MOD;\n            return;\n        }\n        push(node, l, r);\n        int mid = (l + r) >>> 1;\n        update(node * 2 + 1, l, mid, ql, qr, b, c);\n        update(node * 2 + 2, mid, r, ql, qr, b, c);\n        sum[node] = (sum[node * 2 + 1] + sum[node * 2 + 2]) % MOD;\n    }\n\n    static long query(int node, int l, int r, int ql, int qr) {\n        if (qr <= l || r <= ql) return 0;\n        if (ql <= l && r <= qr) return sum[node];\n        push(node, l, r);\n        int mid = (l + r) >>> 1;\n        return (query(node * 2 + 1, l, mid, ql, qr) + query(node * 2 + 2, mid, r, ql, qr)) % MOD;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        n = Integer.parseInt(st.nextToken());\n        int q = Integer.parseInt(st.nextToken());\n        a = new long[n];\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < n; i++) {\n            a[i] = Long.parseLong(st.nextToken());\n        }\n        int size = 1;\n        while (size < n) size <<= 1;\n        sum = new long[2 * size];\n        mul = new long[2 * size];\n        add = new long[2 * size];\n        build(0, 0, n);\n        while (q-- > 0) {\n            st = new StringTokenizer(br.readLine());\n            int type = Integer.parseInt(st.nextToken());\n            if (type == 0) {\n                int l = Integer.parseInt(st.nextToken());\n                int r = Integer.parseInt(st.nextToken());\n                long b = Long.parseLong(st.nextToken());\n                long c = Long.parseLong(st.nextToken());\n                update(0, 0, n, l, r, b, c);\n            } else {\n                int l = Integer.parseInt(st.nextToken());\n                int r = Integer.parseInt(st.nextToken());\n                out.println(query(0, 0, n, l, r));\n            }\n        }\n        out.close();\n    }\n}",
    "timestamp": "2025-08-05 22:27:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    static final int MOD = 998244353;\n    static long[] arr;\n    static long[] segTree;\n    static long[] lazy;\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n\n        int N = Integer.parseInt(st.nextToken());\n        int Q = Integer.parseInt(st.nextToken());\n\n        arr = new long[N];\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < N; i++) {\n            arr[i] = Long.parseLong(st.nextToken());\n        }\n\n        int size = 1;\n        while (size < N) size *= 2;\n        segTree = new long[size * 2];\n        lazy = new long[size * 2];\n\n        buildTree(1, 0, N - 1);\n\n        while (Q-- > 0) {\n            st = new StringTokenizer(br.readLine());\n            int type = Integer.parseInt(st.nextToken());\n\n            if (type == 0) {\n                int l = Integer.parseInt(st.nextToken()) - 1;\n                int r = Integer.parseInt(st.nextToken()) - 1;\n                long b = Long.parseLong(st.nextToken());\n                long c = Long.parseLong(st.nextToken());\n                updateRange(1, 0, N - 1, l, r, b, c);\n            } else {\n                int l = Integer.parseInt(st.nextToken()) - 1;\n                int r = Integer.parseInt(st.nextToken()) - 1;\n                bw.write(query(1, 0, N - 1, l, r) + \"\\n\");\n            }\n        }\n\n        bw.flush();\n        bw.close();\n        br.close();\n    }\n\n    static void buildTree(int node, int start, int end) {\n        if (start == end) {\n            segTree[node] = arr[start];\n            return;\n        }\n        int mid = (start + end) / 2;\n        buildTree(node * 2, start, mid);\n        buildTree(node * 2 + 1, mid + 1, end);\n        segTree[node] = (segTree[node * 2] + segTree[node * 2 + 1]) % MOD;\n    }\n\n    static void propagate(int node, int start, int end) {\n        if (lazy[node] != 0) {\n            segTree[node] = (segTree[node] * lazy[node] + (end - start + 1) * (lazy[node + 1])) % MOD;\n            if (start != end) {\n                lazy[node * 2] = lazy[node];\n                lazy[node * 2 + 1] = lazy[node];\n            }\n            lazy[node] = 0;\n            lazy[node + 1] = 0;\n        }\n    }\n\n    static void updateRange(int node, int start, int end, int l, int r, long b, long c) {\n        propagate(node, start, end);\n        if (start > end || start > r || end < l) return;\n\n        if (l <= start && end <= r) {\n            lazy[node] = b;\n            lazy[node + 1] = c;\n            propagate(node, start, end);\n            return;\n        }\n\n        int mid = (start + end) / 2;\n        updateRange(node * 2, start, mid, l, r, b, c);\n        updateRange(node * 2 + 1, mid + 1, end, l, r, b, c);\n        segTree[node] = (segTree[node * 2] + segTree[node * 2 + 1]) % MOD;\n    }\n\n    static long query(int node, int start, int end, int l, int r) {\n        if (start > end || start > r || end < l) return 0;\n        propagate(node, start, end);\n\n        if (l <= start && end <= r) return segTree[node];\n\n        int mid = (start + end) / 2;\n        long left = query(node * 2, start, mid, l, r);\n        long right = query(node * 2 + 1, mid + 1, end, l, r);\n        return (left + right) % MOD;\n    }\n}",
    "timestamp": "2025-08-05 22:27:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconst int MOD = 998244353;\nconst int MAXN = 2e5 + 5;\n\nll a[MAXN];\nll tree[4*MAXN];\n\nvoid build(int node, int start, int end) {\n    if (start == end) {\n        tree[node] = a[start];\n        return;\n    }\n    int mid = (start + end) / 2;\n    build(2*node, start, mid);\n    build(2*node+1, mid+1, end);\n    tree[node] = (tree[2*node] + tree[2*node+1]) % MOD;\n}\n\nvoid update(int node, int start, int end, int l, int r, ll b, ll c) {\n    if (start > end || start > r || end < l) return;\n    \n    if (start >= l && end <= r) {\n        tree[node] = (b * tree[node] + c * (end - start + 1)) % MOD;\n        return;\n    }\n    \n    int mid = (start + end) / 2;\n    update(2*node, start, mid, l, r, b, c);\n    update(2*node+1, mid+1, end, l, r, b, c);\n    tree[node] = (tree[2*node] + tree[2*node+1]) % MOD;\n}\n\nll query(int node, int start, int end, int l, int r) {\n    if (start > end || start > r || end < l) return 0;\n    \n    if (start >= l && end <= r) return tree[node];\n    \n    int mid = (start + end) / 2;\n    ll left = query(2*node, start, mid, l, r);\n    ll right = query(2*node+1, mid+1, end, l, r);\n    return (left + right) % MOD;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int N, Q;\n    cin >> N >> Q;\n    \n    for (int i = 0; i < N; i++) {\n        cin >> a[i];\n    }\n    \n    build(1, 0, N-1);\n    \n    while (Q--) {\n        int type;\n        cin >> type;\n        \n        if (type == 0) {\n            int l, r;\n            ll b, c;\n            cin >> l >> r >> b >> c;\n            update(1, 0, N-1, l, r-1, b, c);\n        } else {\n            int l, r;\n            cin >> l >> r;\n            cout << query(1, 0, N-1, l, r-1) << '\\n';\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:27:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class SegmentTree:\n    def __init__(self, data, mod):\n        self.n = len(data)\n        self.mod = mod\n        self.data = data[:]\n        self.tree = [0] * (2 * self.n)\n        self.lazy_b = [1] * self.n\n        self.lazy_c = [0] * self.n\n        self.build()\n\n    def build(self):\n        for i in range(self.n):\n            self.tree[i + self.n] = self.data[i]\n        for i in range(self.n - 1, 0, -1):\n            self.tree[i] = (self.tree[i * 2] + self.tree[i * 2 + 1]) % self.mod\n\n    def apply(self, idx, b, c, length):\n        self.tree[idx] = (b * self.tree[idx] % self.mod + c * length % self.mod) % self.mod\n        if idx < self.n:\n            self.lazy_b[idx] = (self.lazy_b[idx] * b) % self.mod\n            self.lazy_c[idx] = (self.lazy_c[idx] * b + c) % self.mod\n\n    def push(self, idx):\n        k = 1\n        for i in range(self.height(), 0, -1):\n            idx >>= 1\n            if self.lazy_b[idx] != 1 or self.lazy_c[idx] != 0:\n                l, r = idx * 2, idx * 2 + 1\n                self.apply(l, self.lazy_b[idx], self.lazy_c[idx], k)\n                self.apply(r, self.lazy_b[idx], self.lazy_c[idx], k)\n                self.lazy_b[idx] = 1\n                self.lazy_c[idx] = 0\n            k *= 2\n\n    def height(self):\n        return self.n.bit_length()\n\n    def query_util(self, l, r):\n        self.push(l + self.n)\n        self.push(r + self.n - 1)\n        res = 0\n        l += self.n\n        r += self.n\n        while l < r:\n            if l & 1:\n                res = (res + self.tree[l]) % self.mod\n                l += 1\n            if r & 1:\n                r -= 1\n                res = (res + self.tree[r]) % self.mod\n            l >>= 1\n            r >>= 1\n        return res\n\n    def update_util(self, l, r, b, c):\n        l0, r0 = l + self.n, r + self.n\n        while l < r:\n            if l & 1:\n                self.apply(l, b, c, 1)\n                l += 1\n            if r & 1:\n                r -= 1\n                self.apply(r, b, c, 1)\n            l >>= 1\n            r >>= 1\n        self.push(l0)\n        self.push(r0 - 1)\n        while l0 > 1:\n            l0 >>= 1\n            r0 >>= 1\n            self.tree[l0] = (self.tree[l0 * 2] + self.tree[l0 * 2 + 1]) % self.mod\n            self.tree[r0] = (self.tree[r0 * 2] + self.tree[r0 * 2 + 1]) % self.mod\n\ndef process_queries(array, queries):\n    MOD = 998244353\n    st = SegmentTree(array, MOD)\n    result = []\n\n    for query in queries:\n        if query[0] == 0:\n            _, l, r, b, c = query\n            st.update_util(l, r, b, c)\n        elif query[0] == 1:\n            _, l, r = query\n            result.append(st.query_util(l, r))\n\n    return result",
    "timestamp": "2025-08-13 10:41:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class ArrayProcessor {\n\n    private static final int MODULO = 998244353;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int N = scanner.nextInt();\n        int Q = scanner.nextInt();\n        \n        long[] array = new long[N];\n        \n        for (int i = 0; i < N; i++) {\n            array[i] = scanner.nextLong();\n        }\n\n        for (int q = 0; q < Q; q++) {\n            int type = scanner.nextInt();\n            int l = scanner.nextInt();\n            int r = scanner.nextInt();\n            \n            if (type == 0) {\n                long b = scanner.nextLong();\n                long c = scanner.nextLong();\n                for (int i = l; i < r; i++) {\n                    array[i] = (b * array[i] + c) % MODULO;\n                }\n            } else if (type == 1) {\n                long sum = 0;\n                for (int i = l; i < r; i++) {\n                    sum = (sum + array[i]) % MODULO;\n                }\n                System.out.println(sum);\n            }\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 10:41:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MOD 998244353\n\nconst int MAXN = 100000;\nlong long arr[MAXN];\n\nvoid processQueries(int N, int Q) {\n    int query_type, l, r, b, c;\n    while (Q--) {\n        scanf(\"%d%d%d\", &query_type, &l, &r);\n        if (query_type == 0) {\n            scanf(\"%d%d\", &b, &c);\n            for (int i = l; i < r; i++) {\n                arr[i] = (b * arr[i] + c) % MOD;\n            }\n        } else if (query_type == 1) {\n            long long sum = 0;\n            for (int i = l; i < r; i++) {\n                sum = (sum + arr[i]) % MOD;\n            }\n            printf(\"%lld\\n\", sum);\n        }\n    }\n}\n\nint main() {\n    int N, Q;\n    scanf(\"%d%d\", &N, &Q);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lld\", &arr[i]);\n    }\n    processQueries(N, Q);\n    return 0;\n}",
    "timestamp": "2025-08-13 10:41:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class SegmentTree:\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.tree = [0] * (4 * self.n)\n        self.arr = arr\n        self.build(0, 0, self.n)\n\n    def build(self, node, start, end):\n        if start + 1 == end:\n            self.tree[node] = self.arr[start]\n            return\n        mid = (start + end) // 2\n        self.build(2 * node + 1, start, mid)\n        self.build(2 * node + 2, mid, end)\n        self.tree[node] = (self.tree[2 * node + 1] + self.tree[2 * node + 2]) % 998244353\n\n    def update(self, node, start, end, l, r, b, c):\n        if start >= r or end <= l:\n            return\n        if l <= start and end <= r:\n            self.tree[node] = (b * self.tree[node] + c * (end - start)) % 998244353\n            return\n        mid = (start + end) // 2\n        self.update(2 * node + 1, start, mid, l, r, b, c)\n        self.update(2 * node + 2, mid, end, l, r, b, c)\n        self.tree[node] = (self.tree[2 * node + 1] + self.tree[2 * node + 2]) % 998244353\n\n    def query(self, node, start, end, l, r):\n        if start >= r or end <= l:\n            return 0\n        if l <= start and end <= r:\n            return self.tree[node]\n        mid = (start + end) // 2\n        left_sum = self.query(2 * node + 1, start, mid, l, r)\n        right_sum = self.query(2 * node + 2, mid, end, l, r)\n        return (left_sum + right_sum) % 998244353\n\ndef main():\n    n, q = map(int, input().split())\n    arr = list(map(int, input().split()))\n    st = SegmentTree(arr)\n\n    for _ in range(q):\n        query = list(map(int, input().split()))\n        if query[0] == 0:\n            _, l, r, b, c = query\n            st.update(0, 0, n, l, r, b, c)\n        else:\n            _, l, r = query\n            print(st.query(0, 0, n, l, r))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 10:42:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\nMOD = 998244353\n\nclass LazySegmentTreeNode:\n    __slots__ = ['l', 'r', 'left', 'right', 'sum_val', 'b', 'c']\n    def __init__(self, l, r):\n        self.l = l\n        self.r = r\n        self.left = None\n        self.right = None\n        self.sum_val = 0\n        self.b = 1\n        self.c = 0\n    \n    def apply(self, b, c):\n        self.sum_val = (self.sum_val * b + c * (self.r - self.l)) % MOD\n        self.b = (self.b * b) % MOD\n        self.c = (self.c * b + c) % MOD\n    \n    def push_down(self):\n        if self.l < self.r and not (self.left and self.right):\n            mid = (self.l + self.r) // 2\n            self.left = LazySegmentTreeNode(self.l, mid)\n            self.right = LazySegmentTreeNode(mid, self.r)\n        if self.b != 1 or self.c != 0:\n            self.left.apply(self.b, self.c)\n            self.right.apply(self.b, self.c)\n            self.b = 1\n            self.c = 0\n\nclass LazySegmentTree:\n    def __init__(self, data):\n        self.n = len(data)\n        self.root = LazySegmentTreeNode(0, self.n)\n        self._build(self.root, data)\n    \n    def _build(self, node, data):\n        if node.r - node.l == 1:\n            node.sum_val = data[node.l] % MOD\n        else:\n            mid = (node.l + node.r) // 2\n            node.left = LazySegmentTreeNode(node.l, mid)\n            node.right = LazySegmentTreeNode(mid, node.r)\n            self._build(node.left, data)\n            self._build(node.right, data)\n            node.sum_val = (node.left.sum_val + node.right.sum_val) % MOD\n    \n    def update_range(self, l, r, b, c):\n        self._update_range(self.root, l, r, b, c)\n    \n    def _update_range(self, node, l, r, b, c):\n        if node.r <= l or node.l >= r:\n            return\n        if l <= node.l and node.r <= r:\n            node.apply(b, c)\n        else:\n            node.push_down()\n            self._update_range(node.left, l, r, b, c)\n            self._update_range(node.right, l, r, b, c)\n            node.sum_val = (node.left.sum_val + node.right.sum_val) % MOD\n    \n    def query_range(self, l, r):\n        return self._query_range(self.root, l, r)\n    \n    def _query_range(self, node, l, r):\n        if node.r <= l or node.l >= r:\n            return 0\n        if l <= node.l and node.r <= r:\n            return node.sum_val\n        node.push_down()\n        left_sum = self._query_range(node.left, l, r)\n        right_sum = self._query_range(node.right, l, r)\n        return (left_sum + right_sum) % MOD\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    Q = int(input[ptr])\n    ptr += 1\n    a = list(map(int, input[ptr:ptr+N]))\n    ptr += N\n    \n    st = LazySegmentTree(a)\n    \n    for _ in range(Q):\n        query = input[ptr]\n        ptr += 1\n        if query == '0':\n            l = int(input[ptr])\n            ptr += 1\n            r = int(input[ptr])\n            ptr += 1\n            b = int(input[ptr])\n            ptr += 1\n            c = int(input[ptr])\n            ptr += 1\n            st.update_range(l, r, b, c)\n        else:\n            l = int(input[ptr])\n            ptr += 1\n            r = int(input[ptr])\n            ptr += 1\n            res = st.query_range(l, r)\n            print(res % MOD)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 10:42:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst int MOD = 998244353;\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    vector<ll> a(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> a[i];\n    }\n    \n    while (Q--) {\n        int type;\n        cin >> type;\n        if (type == 0) {\n            int l, r, b, c;\n            cin >> l >> r >> b >> c;\n            for (int i = l; i < r; ++i) {\n                a[i] = (b * a[i] + c) % MOD;\n            }\n        } else if (type == 1) {\n            int l, r;\n            cin >> l >> r;\n            ll sum = 0;\n            for (int i = l; i < r; ++i) {\n                sum = (sum + a[i]) % MOD;\n            }\n            cout << sum << '\\n';\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:00:14"
  }
]