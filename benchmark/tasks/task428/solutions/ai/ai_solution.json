[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 20\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point pos;\n    int time;\n} Node;\n\nint rows, cols;\nchar grid[MAX_SIZE][MAX_SIZE];\nint dist[MAX_SIZE][MAX_SIZE];\nbool visited[MAX_SIZE][MAX_SIZE];\nPoint start, goal;\nPoint scrolls[MAX_SIZE * MAX_SIZE];\nint scroll_count = 0;\nint min_time = INT_MAX;\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nbool is_valid(int x, int y) {\n    return x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] != 'H';\n}\n\nint get_cost(int x, int y) {\n    int cost = 1;\n    for (int i = -1; i <= 1; ++i) {\n        for (int j = -1; j <= 1; ++j) {\n            int nx = x + i, ny = y + j;\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] == 'H') {\n                cost++;\n            }\n        }\n    }\n    return cost;\n}\n\nvoid bfs(Point start, Point end, int (*dist)[MAX_SIZE]) {\n    Node queue[MAX_SIZE * MAX_SIZE];\n    int front = 0, rear = 0;\n    \n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            dist[i][j] = INT_MAX;\n            visited[i][j] = false;\n        }\n    }\n    \n    queue[rear++] = (Node){start, 0};\n    dist[start.x][start.y] = 0;\n    visited[start.x][start.y] = true;\n    \n    while (front < rear) {\n        Node current = queue[front++];\n        if (current.pos.x == end.x && current.pos.y == end.y) {\n            return;\n        }\n        \n        for (int i = 0; i < 4; ++i) {\n            int nx = current.pos.x + dx[i];\n            int ny = current.pos.y + dy[i];\n            \n            if (is_valid(nx, ny) && !visited[nx][ny]) {\n                int cost = get_cost(nx, ny);\n                dist[nx][ny] = current.time + cost;\n                visited[nx][ny] = true;\n                queue[rear++] = (Node){(Point){nx, ny}, dist[nx][ny]};\n            }\n        }\n    }\n}\n\nvoid permute(int *order, int l, int r, int (*dist_scrolls)[MAX_SIZE], int (*dist_goal)[MAX_SIZE]) {\n    if (l == r) {\n        int total_time = dist_scrolls[start.x][start.y];\n        for (int i = 0; i < scroll_count - 1; ++i) {\n            int from = order[i];\n            int to = order[i + 1];\n            total_time += dist_scrolls[scrolls[from].x][scrolls[from].y];\n        }\n        total_time += dist_goal[scrolls[order[scroll_count - 1]].x][scrolls[order[scroll_count - 1]].y];\n        if (total_time < min_time) {\n            min_time = total_time;\n        }\n    } else {\n        for (int i = l; i <= r; ++i) {\n            int temp = order[l];\n            order[l] = order[i];\n            order[i] = temp;\n            \n            permute(order, l + 1, r, dist_scrolls, dist_goal);\n            \n            temp = order[l];\n            order[l] = order[i];\n            order[i] = temp;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &rows, &cols);\n    for (int i = 0; i < rows; ++i) {\n        scanf(\"%s\", grid[i]);\n        for (int j = 0; j < cols; ++j) {\n            if (grid[i][j] == 'S') {\n                start.x = i;\n                start.y = j;\n            } else if (grid[i][j] == 'G') {\n                goal.x = i;\n                goal.y = j;\n            } else if (grid[i][j] == 'R') {\n                scrolls[scroll_count].x = i;\n                scrolls[scroll_count].y = j;\n                scroll_count++;\n            }\n        }\n    }\n    \n    int dist_scrolls[MAX_SIZE][MAX_SIZE];\n    int dist_goal[MAX_SIZE][MAX_SIZE];\n    \n    bfs(start, goal, dist_scrolls);\n    for (int i = 0; i < scroll_count; ++i) {\n        bfs(scrolls[i], goal, dist_scrolls);\n    }\n    bfs(goal, start, dist_goal);\n    \n    if (scroll_count == 0) {\n        min_time = dist_scrolls[start.x][start.y];\n    } else {\n        int order[scroll_count];\n        for (int i = 0; i < scroll_count; ++i) {\n            order[i] = i;\n        }\n        permute(order, 0, scroll_count - 1, dist_scrolls, dist_goal);\n    }\n    \n    printf(\"%d\\n\", min_time);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:30:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <climits>\n#include <algorithm>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\nconst int dx[] = {-1, 1, 0, 0};\nconst int dy[] = {0, 0, -1, 1};\n\nstruct State {\n    int x, y;\n    int mask;\n    int time;\n    State(int x, int y, int mask, int time) : x(x), y(y), mask(mask), time(time) {}\n    bool operator>(const State& other) const {\n        return time > other.time;\n    }\n};\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<string> grid(H);\n    for (int i = 0; i < H; ++i) {\n        cin >> grid[i];\n    }\n\n    int start_x = -1, start_y = -1;\n    int goal_x = -1, goal_y = -1;\n    vector<pair<int, int>> scrolls;\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (grid[i][j] == 'S') {\n                start_x = i;\n                start_y = j;\n            } else if (grid[i][j] == 'G') {\n                goal_x = i;\n                goal_y = j;\n            } else if (grid[i][j] == 'R') {\n                scrolls.emplace_back(i, j);\n            }\n        }\n    }\n\n    int K = scrolls.size();\n    if (K == 0) {\n        vector<vector<int>> dist(H, vector<int>(W, INT_MAX));\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<>> pq;\n        dist[start_x][start_y] = 0;\n        pq.push({0, {start_x, start_y}});\n\n        while (!pq.empty()) {\n            auto current = pq.top();\n            pq.pop();\n            int current_time = current.first;\n            int x = current.second.first;\n            int y = current.second.second;\n\n            if (x == goal_x && y == goal_y) {\n                cout << current_time << endl;\n                return 0;\n            }\n\n            if (current_time > dist[x][y]) continue;\n\n            for (int d = 0; d < 4; ++d) {\n                int nx = x + dx[d];\n                int ny = y + dy[d];\n                if (nx < 0 || nx >= H || ny < 0 || ny >= W || grid[nx][ny] == 'H') continue;\n\n                int cost = 1;\n                for (int i = -1; i <= 1; ++i) {\n                    for (int j = -1; j <= 1; ++j) {\n                        if (i == 0 && j == 0) continue;\n                        int cx = nx + i;\n                        int cy = ny + j;\n                        if (cx >= 0 && cx < H && cy >= 0 && cy < W && grid[cx][cy] == 'H') {\n                            cost += 1;\n                        }\n                    }\n                }\n\n                if (dist[nx][ny] > current_time + cost) {\n                    dist[nx][ny] = current_time + cost;\n                    pq.push({dist[nx][ny], {nx, ny}});\n                }\n            }\n        }\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<vector<vector<int>>> dist(H, vector<vector<int>>(W, vector<int>(1 << K, INT_MAX)));\n    priority_queue<State, vector<State>, greater<>> pq;\n    dist[start_x][start_y][0] = 0;\n    pq.push(State(start_x, start_y, 0, 0));\n\n    while (!pq.empty()) {\n        State current = pq.top();\n        pq.pop();\n        int x = current.x;\n        int y = current.y;\n        int mask = current.mask;\n        int current_time = current.time;\n\n        if (x == goal_x && y == goal_y && mask == (1 << K) - 1) {\n            cout << current_time << endl;\n            return 0;\n        }\n\n        if (current_time > dist[x][y][mask]) continue;\n\n        for (int d = 0; d < 4; ++d) {\n            int nx = x + dx[d];\n            int ny = y + dy[d];\n            if (nx < 0 || nx >= H || ny < 0 || ny >= W || grid[nx][ny] == 'H') continue;\n\n            int new_mask = mask;\n            for (int i = 0; i < K; ++i) {\n                if (scrolls[i].first == nx && scrolls[i].second == ny) {\n                    new_mask |= (1 << i);\n                    break;\n                }\n            }\n\n            int cost = 1;\n            for (int i = -1; i <= 1; ++i) {\n                for (int j = -1; j <= 1; ++j) {\n                    if (i == 0 && j == 0) continue;\n                    int cx = nx + i;\n                    int cy = ny + j;\n                    if (cx >= 0 && cx < H && cy >= 0 && cy < W && grid[cx][cy] == 'H') {\n                        cost += 1;\n                    }\n                }\n            }\n\n            if (dist[nx][ny][new_mask] > current_time + cost) {\n                dist[nx][ny][new_mask] = current_time + cost;\n                pq.push(State(nx, ny, new_mask, dist[nx][ny][new_mask]));\n            }\n        }\n    }\n    cout << -1 << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:32:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Point {\n    int x, y;\n    Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Point point = (Point) o;\n        return x == point.x && y == point.y;\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y);\n    }\n}\n\nclass State {\n    Point pos;\n    Set<Point> collected;\n    int time;\n    \n    State(Point pos, Set<Point> collected, int time) {\n        this.pos = pos;\n        this.collected = new HashSet<>(collected);\n        this.time = time;\n    }\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        State state = (State) o;\n        return time == state.time && pos.equals(state.pos) && collected.equals(state.collected);\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(pos, collected, time);\n    }\n}\n\npublic class YayoiChallenge {\n    private static final int[] dx = {-1, 1, 0, 0};\n    private static final int[] dy = {0, 0, -1, 1};\n    \n    public static int solve(char[][] grid, Point start, Point goal, List<Point> scrolls) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        \n        // Precompute hole distances\n        int[][] holeDist = new int[rows][cols];\n        Queue<Point> holeQueue = new LinkedList<>();\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 'H') {\n                    holeQueue.offer(new Point(i, j));\n                    holeDist[i][j] = 0;\n                } else {\n                    holeDist[i][j] = Integer.MAX_VALUE;\n                }\n            }\n        }\n        \n        // BFS for hole distances\n        while (!holeQueue.isEmpty()) {\n            Point p = holeQueue.poll();\n            for (int d = 0; d < 4; d++) {\n                int nx = p.x + dx[d];\n                int ny = p.y + dy[d];\n                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && holeDist[nx][ny] > holeDist[p.x][p.y] + 1) {\n                    holeDist[nx][ny] = holeDist[p.x][p.y] + 1;\n                    holeQueue.offer(new Point(nx, ny));\n                }\n            }\n        }\n        \n        // Calculate move cost\n        int[][] moveCost = new int[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 'H') {\n                    moveCost[i][j] = Integer.MAX_VALUE;\n                } else {\n                    moveCost[i][j] = holeDist[i][j] == 0 ? Integer.MAX_VALUE : 1 + holeDist[i][j];\n                }\n            }\n        }\n        \n        PriorityQueue<State> pq = new PriorityQueue<>(Comparator.comparingInt(s -> s.time));\n        Set<State> visited = new HashSet<>();\n        Set<Point> initialCollected = new HashSet<>();\n        State initialState = new State(start, initialCollected, 0);\n        pq.offer(initialState);\n        \n        int totalScrolls = scrolls.size();\n        \n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            \n            if (current.pos.equals(goal) && current.collected.size() == totalScrolls) {\n                return current.time;\n            }\n            \n            if (visited.contains(current)) {\n                continue;\n            }\n            visited.add(current);\n            \n            for (int d = 0; d < 4; d++) {\n                int nx = current.pos.x + dx[d];\n                int ny = current.pos.y + dy[d];\n                \n                if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] != 'H') {\n                    Point newPos = new Point(nx, ny);\n                    Set<Point> newCollected = new HashSet<>(current.collected);\n                    if (scrolls.contains(newPos)) {\n                        newCollected.add(newPos);\n                    }\n                    \n                    int newTime = current.time + moveCost[nx][ny];\n                    State newState = new State(newPos, newCollected, newTime);\n                    \n                    if (!visited.contains(newState)) {\n                        pq.offer(newState);\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int rows = scanner.nextInt();\n        int cols = scanner.nextInt();\n        scanner.nextLine();\n        \n        char[][] grid = new char[rows][cols];\n        Point start = null;\n        Point goal = null;\n        List<Point> scrolls = new ArrayList<>();\n        \n        for (int i = 0; i < rows; i++) {\n            String line = scanner.nextLine();\n            for (int j = 0; j < cols; j++) {\n                grid[i][j] = line.charAt(j);\n                if (grid[i][j] == 'S') {\n                    start = new Point(i, j);\n                } else if (grid[i][j] == 'G') {\n                    goal = new Point(i, j);\n                } else if (grid[i][j] == 'R') {\n                    scrolls.add(new Point(i, j));\n                }\n            }\n        }\n        \n        int result = solve(grid, start, goal, scrolls);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 21:33:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    static final int[] dx = {0, 0, 1, -1};\n    static final int[] dy = {1, -1, 0, 0};\n\n    static class State {\n        int x, y, time, collected;\n        Set<Integer> scrolls;\n\n        State(int x, int y, int time, int collected, Set<Integer> scrolls) {\n            this.x = x;\n            this.y = y;\n            this.time = time;\n            this.collected = collected;\n            this.scrolls = new HashSet<>(scrolls);\n        }\n    }\n\n    public static int shortestTime(char[][] grid, int startX, int startY, int goalX, int goalY) {\n        int m = grid.length, n = grid[0].length;\n        int totalScrolls = countScrolls(grid);\n        \n        Queue<State> queue = new LinkedList<>();\n        Set<Integer> initialScrolls = new HashSet<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 'S') {\n                    initialScrolls.add(i * n + j);\n                }\n            }\n        }\n        \n        queue.offer(new State(startX, startY, 0, 0, initialScrolls));\n        Set<String> visited = new HashSet<>();\n        \n        while (!queue.isEmpty()) {\n            State curr = queue.poll();\n            \n            if (curr.x == goalX && curr.y == goalY && curr.collected == totalScrolls) {\n                return curr.time;\n            }\n            \n            String key = curr.x + \",\" + curr.y + \",\" + curr.collected;\n            if (visited.contains(key)) continue;\n            visited.add(key);\n            \n            for (int k = 0; k < 4; k++) {\n                int nx = curr.x + dx[k];\n                int ny = curr.y + dy[k];\n                \n                if (nx < 0 || nx >= m || ny < 0 || ny >= n || grid[nx][ny] == '#') continue;\n                \n                int moveCost = calculateMoveCost(grid, nx, ny);\n                int newCollected = curr.collected;\n                Set<Integer> newScrolls = new HashSet<>(curr.scrolls);\n                \n                if (grid[nx][ny] == 'S' && newScrolls.contains(nx * n + ny)) {\n                    newScrolls.remove(nx * n + ny);\n                    newCollected++;\n                }\n                \n                queue.offer(new State(nx, ny, curr.time + moveCost, newCollected, newScrolls));\n            }\n        }\n        \n        return -1;\n    }\n    \n    static int calculateMoveCost(char[][] grid, int x, int y) {\n        int m = grid.length, n = grid[0].length;\n        int holeCount = 0;\n        \n        for (int dx = -1; dx <= 1; dx++) {\n            for (int dy = -1; dy <= 1; dy++) {\n                int nx = x + dx, ny = y + dy;\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 'O') {\n                    holeCount++;\n                }\n            }\n        }\n        \n        return Math.max(1, holeCount);\n    }\n    \n    static int countScrolls(char[][] grid) {\n        int count = 0;\n        for (char[] row : grid) {\n            for (char c : row) {\n                if (c == 'S') count++;\n            }\n        }\n        return count;\n    }\n}",
    "timestamp": "2025-08-05 21:33:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n\n#define MAX_N 20\n#define MAX_SCROLL 10\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint N, M, K;\nchar grid[MAX_N][MAX_N];\nPoint scrolls[MAX_SCROLL];\nPoint start, goal;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint count_adjacent_holes(int x, int y) {\n    int count = 0;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (nx >= 0 && nx < N && ny >= 0 && ny < M && grid[nx][ny] == 'O') {\n            count++;\n        }\n    }\n    return count;\n}\n\nint calculate_move_time(int x, int y) {\n    int holes = count_adjacent_holes(x, y);\n    return 1 + holes;\n}\n\nint dfs(int x, int y, int collected_scrolls, int visited_scrolls, int total_time) {\n    if (collected_scrolls == K && x == goal.x && y == goal.y) {\n        return total_time;\n    }\n\n    int min_time = INT_MAX;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (nx >= 0 && nx < N && ny >= 0 && ny < M && grid[nx][ny] != 'X') {\n            int move_time = calculate_move_time(nx, ny);\n            int new_collected = collected_scrolls;\n            int new_visited = visited_scrolls;\n\n            for (int j = 0; j < K; j++) {\n                if (nx == scrolls[j].x && ny == scrolls[j].y && !(visited_scrolls & (1 << j))) {\n                    new_collected++;\n                    new_visited |= (1 << j);\n                }\n            }\n\n            int result = dfs(nx, ny, new_collected, new_visited, total_time + move_time);\n            if (result != -1) {\n                min_time = (min_time < result) ? min_time : result;\n            }\n        }\n    }\n\n    return (min_time == INT_MAX) ? -1 : min_time;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &K);\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%s\", grid[i]);\n        for (int j = 0; j < M; j++) {\n            if (grid[i][j] == 'S') {\n                start.x = i;\n                start.y = j;\n            } else if (grid[i][j] == 'E') {\n                goal.x = i;\n                goal.y = j;\n            } else if (grid[i][j] == 'C') {\n                scrolls[K].x = i;\n                scrolls[K].y = j;\n                K++;\n            }\n        }\n    }\n\n    int result = dfs(start.x, start.y, 0, 0, 0);\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:34:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <climits>\n\nusing namespace std;\n\nconst int MAX_N = 20;\nconst int dx[] = {0, 0, 1, -1};\nconst int dy[] = {1, -1, 0, 0};\n\nstruct State {\n    int x, y, collected_scrolls, time;\n    bool operator<(const State& other) const {\n        return time > other.time;\n    }\n};\n\nint N, M, K;\nchar grid[MAX_N][MAX_N];\nbool visited[MAX_N][MAX_N][1 << 10];\nvector<pair<int, int>> scrolls;\npair<int, int> start, goal;\n\nint count_nearby_holes(int x, int y) {\n    int count = 0;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (nx >= 0 && nx < N && ny >= 0 && ny < M && grid[nx][ny] == 'O') {\n            count++;\n        }\n    }\n    return count;\n}\n\nint solve() {\n    priority_queue<State> pq;\n    pq.push({start.first, start.second, 0, 0});\n    \n    while (!pq.empty()) {\n        State curr = pq.top();\n        pq.pop();\n        \n        if (curr.x == goal.first && curr.y == goal.second && curr.collected_scrolls == (1 << K) - 1) {\n            return curr.time;\n        }\n        \n        if (visited[curr.x][curr.y][curr.collected_scrolls]) continue;\n        visited[curr.x][curr.y][curr.collected_scrolls] = true;\n        \n        int scroll_index = -1;\n        for (int i = 0; i < K; i++) {\n            if (curr.x == scrolls[i].first && curr.y == scrolls[i].second) {\n                scroll_index = i;\n                break;\n            }\n        }\n        \n        int new_collected_scrolls = curr.collected_scrolls;\n        if (scroll_index != -1) {\n            new_collected_scrolls |= (1 << scroll_index);\n        }\n        \n        for (int i = 0; i < 4; i++) {\n            int nx = curr.x + dx[i], ny = curr.y + dy[i];\n            \n            if (nx >= 0 && nx < N && ny >= 0 && ny < M && grid[nx][ny] != 'O') {\n                int move_time = 1 + count_nearby_holes(nx, ny);\n                \n                pq.push({nx, ny, new_collected_scrolls, curr.time + move_time});\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    cin >> N >> M >> K;\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            cin >> grid[i][j];\n            \n            if (grid[i][j] == 'S') {\n                start = {i, j};\n            } else if (grid[i][j] == 'G') {\n                goal = {i, j};\n            } else if (grid[i][j] == 'A') {\n                scrolls.push_back({i, j});\n            }\n        }\n    }\n    \n    memset(visited, false, sizeof(visited));\n    \n    int result = solve();\n    \n    if (result == -1) {\n        cout << \"Impossible\" << endl;\n    } else {\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:34:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\nfrom collections import deque\n\ndef solve_room(grid, start, goal, scrolls):\n    def inside_grid(x, y):\n        return 0 <= x < n and 0 <= y < m\n    \n    def number_of_holes_around(x, y):\n        count = 0\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if inside_grid(nx, ny) and grid[nx][ny] == '#':\n                count += 1\n        return count\n\n    def calculate_cost(grid):\n        costs = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == '#':\n                    costs[i][j] = float('inf')\n                else:\n                    hole_count = number_of_holes_around(i, j)\n                    costs[i][j] = 1 + hole_count\n        return costs\n\n    def dijkstra(costs):\n        pq = [(0, start[0], start[1], frozenset())]\n        visited = {}\n        \n        while pq:\n            time, x, y, collected = heapq.heappop(pq)\n            \n            if (x, y, collected) in visited and visited[(x, y, collected)] <= time:\n                continue\n                \n            visited[(x, y, collected)] = time\n\n            if (x, y) == goal and collected == all_scrolls:\n                return time\n            \n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if inside_grid(nx, ny) and costs[nx][ny] != float('inf'):\n                    new_collected = collected\n                    if (nx, ny) in scroll_locations:\n                        new_collected = collected | frozenset([(nx, ny)])\n                        \n                    heapq.heappush(pq, (time + costs[nx][ny], nx, ny, new_collected))\n        \n        return -1\n\n    n, m = len(grid), len(grid[0])\n    all_scrolls = frozenset(scrolls)\n    scroll_locations = set(scrolls)\n    \n    costs = calculate_cost(grid)\n    return dijkstra(costs)\n\n# Example usage:\ngrid = [\n    ['.', '.', '.', '#', '.'],\n    ['.', '#', '.', '.', '.'],\n    ['.', '.', '#', '.', '.'],\n    ['#', '.', '.', '.', '#'],\n    ['.', '.', '.', '#', '.']\n]\n\nstart = (0, 0)\ngoal = (4, 4)\nscrolls = [(1, 2), (3, 2)]\n\nprint(solve_room(grid, start, goal, scrolls))",
    "timestamp": "2025-08-13 06:45:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\nclass TileChallenge {\n\n    private static final int[] ROW_DIRS = {-1, 0, 1, 0};\n    private static final int[] COL_DIRS = {0, 1, 0, -1};\n\n    static class State {\n        int row, col, time, scrollMask;\n\n        State(int row, int col, int time, int scrollMask) {\n            this.row = row;\n            this.col = col;\n            this.time = time;\n            this.scrollMask = scrollMask;\n        }\n    }\n\n    public static int shortestTime(char[][] room, int startX, int startY, int goalX, int goalY) {\n        int rows = room.length;\n        int cols = room[0].length;\n        int totalScrolls = 0;\n        Map<Integer, Integer> scrollPositionMap = new HashMap<>();\n        \n        // Calculate scroll mask details\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (room[r][c] == 'S') {\n                    scrollPositionMap.put(r * cols + c, totalScrolls);\n                    totalScrolls++;\n                }\n            }\n        }\n        \n        int allScrollsCollectedMask = (1 << totalScrolls) - 1;\n        PriorityQueue<State> pq = new PriorityQueue<>((a, b) -> Integer.compare(a.time, b.time));\n        pq.add(new State(startX, startY, 0, 0));\n        boolean[][][] visited = new boolean[rows][cols][allScrollsCollectedMask + 1];\n\n        while (!pq.isEmpty()) {\n            State current = pq.poll();\n            \n            if (current.row == goalX && current.col == goalY && current.scrollMask == allScrollsCollectedMask)\n                return current.time;\n            \n            if (visited[current.row][current.col][current.scrollMask]) \n                continue;\n            visited[current.row][current.col][current.scrollMask] = true;\n            \n            for (int dir = 0; dir < 4; dir++) {\n                int newRow = current.row + ROW_DIRS[dir];\n                int newCol = current.col + COL_DIRS[dir];\n                \n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && room[newRow][newCol] != 'H') {\n                    int newTime = current.time + calculateTime(room, newRow, newCol, rows, cols);\n                    int newScrollMask = current.scrollMask;\n                    \n                    if (room[newRow][newCol] == 'S') {\n                        int scrollIdx = scrollPositionMap.get(newRow * cols + newCol);\n                        newScrollMask |= (1 << scrollIdx);\n                    }\n                    \n                    if (!visited[newRow][newCol][newScrollMask]) {\n                        pq.add(new State(newRow, newCol, newTime, newScrollMask));\n                    }\n                }\n            }\n        }\n        return -1; // Impossible to complete the challenge\n    }\n\n    private static int calculateTime(char[][] room, int row, int col, int rows, int cols) {\n        int cost = 1;\n        for (int dr = -1; dr <= 1; dr++) {\n            for (int dc = -1; dc <= 1; dc++) {\n                int newRow = row + dr;\n                int newCol = col + dc;\n                if (!(dr == 0 && dc == 0) && newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && room[newRow][newCol] == 'H') {\n                    cost++;\n                }\n            }\n        }\n        return cost;\n    }\n\n    public static void main(String[] args) {\n        char[][] room = {\n            {'S', '0', '0', 'G'},\n            {'0', 'H', '0', '0'},\n            {'0', '0', 'S', '0'},\n            {'H', '0', '0', '0'}\n        };\n        System.out.println(shortestTime(room, 0, 0, 0, 3)); // Test case\n    }\n}",
    "timestamp": "2025-08-13 06:46:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point p;\n    int timeTaken, scrollsCollected;\n} State;\n\nint n, m;\nchar room[MAX_SIZE][MAX_SIZE];\nPoint start, goal;\nPoint scrolls[MAX_SIZE];\nint numScrolls = 0;\nint minTime[MAX_SIZE][MAX_SIZE][1 << MAX_SIZE];\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nint countHolesNearby(int x, int y) {\n    int count = 0;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (nx >= 0 && nx < n && ny >= 0 && ny < m && room[nx][ny] == 'H') {\n            count++;\n        }\n    }\n    return count;\n}\n\nint bfs() {\n    State queue[MAX_SIZE * MAX_SIZE * (1 << numScrolls)];\n    int front = 0, rear = 0;\n\n    State initial = {start, 0, 0};\n    queue[rear++] = initial;\n    minTime[start.x][start.y][0] = 0;\n\n    while (front < rear) {\n        State current = queue[front++];\n        int cx = current.p.x;\n        int cy = current.p.y;\n        int currentTime = current.timeTaken;\n        int collectedMask = current.scrollsCollected;\n\n        if (cx == goal.x && cy == goal.y && collectedMask == ((1 << numScrolls) - 1)) {\n            return currentTime;\n        }\n\n        int cost = 1 + countHolesNearby(cx, cy);\n\n        for (int i = 0; i < 4; i++) {\n            int nx = cx + dx[i];\n            int ny = cy + dy[i];\n\n            if (nx >= 0 && nx < n && ny >= 0 && ny < m && room[nx][ny] != 'H') {\n                int newMask = collectedMask;\n                for (int s = 0; s < numScrolls; s++) {\n                    if (scrolls[s].x == nx && scrolls[s].y == ny) {\n                        newMask |= (1 << s);\n                    }\n                }\n\n                if (currentTime + cost < minTime[nx][ny][newMask]) {\n                    minTime[nx][ny][newMask] = currentTime + cost;\n                    queue[rear++] = (State) {{nx, ny}, currentTime + cost, newMask};\n                }\n            }\n        }\n    }\n\n    return INT_MAX;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", room[i]);\n        for (int j = 0; j < m; j++) {\n            if (room[i][j] == 'S') {\n                start = (Point) {i, j};\n            } else if (room[i][j] == 'G') {\n                goal = (Point) {i, j};\n            } else if (room[i][j] == 'C') {\n                scrolls[numScrolls++] = (Point) {i, j};\n            }\n        }\n    }\n\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < m; j++)\n            for (int k = 0; k < (1 << numScrolls); k++)\n                minTime[i][j][k] = INT_MAX;\n\n    int result = bfs();\n\n    if (result == INT_MAX) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 06:46:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nfrom itertools import permutations\nimport heapq\n\ndef calculate_move_time(tile: Tuple[int, int], holes: List[Tuple[int, int]]) -> int:\n    nearby_holes = sum(1 for hole in holes if manhattan_distance(tile, hole) <= 2)\n    return max(1, 1 + nearby_holes)\n\ndef manhattan_distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> int:\n    return abs(point1[0] - point2[0]) + abs(point1[1] - point2[1])\n\ndef bfs_shortest_path(start: Tuple[int, int], end: Tuple[int, int], holes: List[Tuple[int, int]], grid_size: Tuple[int, int]) -> int:\n    rows, cols = grid_size\n    queue = [(0, start)]\n    visited = set()\n    \n    while queue:\n        time, current = heapq.heappop(queue)\n        \n        if current == end:\n            return time\n        \n        if current in visited:\n            continue\n        \n        visited.add(current)\n        \n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            next_tile = (current[0] + dx, current[1] + dy)\n            \n            if 0 <= next_tile[0] < rows and 0 <= next_tile[1] < cols and next_tile not in visited:\n                move_time = calculate_move_time(next_tile, holes)\n                heapq.heappush(queue, (time + move_time, next_tile))\n    \n    return float('inf')\n\ndef solve_challenge(start: Tuple[int, int], goal: Tuple[int, int], scrolls: List[Tuple[int, int]], holes: List[Tuple[int, int]], grid_size: Tuple[int, int]) -> int:\n    min_total_time = float('inf')\n    \n    for scroll_order in permutations(scrolls):\n        current_time = 0\n        current_pos = start\n        \n        for scroll in scroll_order:\n            path_time = bfs_shortest_path(current_pos, scroll, holes, grid_size)\n            \n            if path_time == float('inf'):\n                break\n            \n            current_time += path_time\n            current_pos = scroll\n        \n        path_time = bfs_shortest_path(current_pos, goal, holes, grid_size)\n        \n        if path_time != float('inf'):\n            current_time += path_time\n            min_total_time = min(min_total_time, current_time)\n    \n    return min_total_time if min_total_time != float('inf') else -1\n\n# Example usage\nstart = (0, 0)\ngoal = (4, 4)\nscrolls = [(1, 2), (3, 3)]\nholes = [(2, 2), (2, 3)]\ngrid_size = (5, 5)\n\nresult = solve_challenge(start, goal, scrolls, holes, grid_size)\nprint(result)",
    "timestamp": "2025-08-13 06:46:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    H = int(data[idx])\n    idx += 1\n    W = int(data[idx])\n    idx += 1\n    grid = []\n    holes = []\n    scrolls = []\n    start = None\n    goal = None\n    \n    for i in range(H):\n        row = data[idx]\n        idx += 1\n        grid_row = []\n        for j in range(W):\n            c = row[j]\n            if c == 'S':\n                start = (i, j)\n            elif c == 'G':\n                goal = (i, j)\n            elif c == 'H':\n                holes.append((i, j))\n            elif c == 'E':\n                scrolls.append((i, j))\n            grid_row.append(c)\n        grid.append(grid_row)\n    \n    # Precompute hole distances for each cell\n    hole_dist = [[float('inf')] * W for _ in range(H)]\n    if holes:\n        q = []\n        for hi, hj in holes:\n            hole_dist[hi][hj] = 0\n            q.append((hi, hj))\n        \n        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        while q:\n            new_q = []\n            for i, j in q:\n                for di, dj in dirs:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < H and 0 <= nj < W:\n                        if hole_dist[ni][nj] > hole_dist[i][j] + 1:\n                            hole_dist[ni][nj] = hole_dist[i][j] + 1\n                            new_q.append((ni, nj))\n            q = new_q\n    \n    # Determine the cost for each cell\n    cost_grid = [[1] * W for _ in range(H)]\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'H':\n                cost_grid[i][j] = float('inf')\n            else:\n                d = hole_dist[i][j]\n                if d == 0:\n                    cost_grid[i][j] = float('inf')\n                elif d == 1:\n                    cost_grid[i][j] = 2\n                elif d == 2:\n                    cost_grid[i][j] = 1\n    \n    # BFS with state (i, j, collected_scrolls_mask)\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    num_scrolls = len(scrolls)\n    target_mask = (1 << num_scrolls) - 1\n    INF = float('inf')\n    \n    # Initialize distance dictionary\n    dist = {}\n    si, sj = start\n    initial_mask = 0\n    dist[(si, sj, initial_mask)] = 0\n    heap = []\n    heapq.heappush(heap, (0, si, sj, initial_mask))\n    \n    found = False\n    answer = INF\n    \n    while heap:\n        current_dist, i, j, mask = heapq.heappop(heap)\n        if current_dist > dist.get((i, j, mask), INF):\n            continue\n        if mask == target_mask and (i, j) == goal:\n            answer = current_dist\n            break\n        for di, dj in dirs:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < H and 0 <= nj < W:\n                if cost_grid[ni][nj] == float('inf'):\n                    continue\n                new_mask = mask\n                # Check if (ni, nj) is a scroll\n                for k in range(num_scrolls):\n                    if (ni, nj) == scrolls[k] and not (mask & (1 << k)):\n                        new_mask |= (1 << k)\n                new_dist = current_dist + cost_grid[ni][nj]\n                if (ni, nj, new_mask) not in dist or new_dist < dist[(ni, nj, new_mask)]:\n                    dist[(ni, nj, new_mask)] = new_dist\n                    heapq.heappush(heap, (new_dist, ni, nj, new_mask))\n    \n    print(answer if answer != INF else -1)\n\nsolve()",
    "timestamp": "2025-08-13 06:46:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct State {\n    int x, y, collectedMask, timeCost;\n\n    bool operator<(const State& other) const {\n        return timeCost > other.timeCost;\n    }\n};\n\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\n\nint calculateTimeCost(int x, int y, const vector<vector<int>>& grid) {\n    int holesNearby = 0;\n    int n = grid.size();\n    \n    for (int i = 0; i < 4; ++i) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n\n        if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n            if (grid[nx][ny] == -1) {\n                ++holesNearby;\n            }\n        }\n    }\n    return 1 + holesNearby;\n}\n\nint shortestTimeToCollectAllScrolls(const vector<vector<int>>& grid, pair<int, int> start, pair<int, int> goal, vector<pair<int, int>>& scrolls) {\n    int n = grid.size();\n    int scrollCount = scrolls.size();\n    int allCollectedMask = (1 << scrollCount) - 1;\n    vector<vector<vector<int>>> dist(n, vector<vector<int>>(n, vector<int>(1 << scrollCount, INT_MAX)));\n    priority_queue<State> pq;\n\n    dist[start.first][start.second][0] = 0;\n    pq.push({start.first, start.second, 0, 0});\n\n    while (!pq.empty()) {\n        State current = pq.top();\n        pq.pop();\n\n        int x = current.x;\n        int y = current.y;\n        int collected = current.collectedMask;\n\n        if (x == goal.first && y == goal.second && collected == allCollectedMask) {\n            return current.timeCost;\n        }\n\n        if (current.timeCost > dist[x][y][collected]) {\n            continue;\n        }\n\n        for (int dir = 0; dir < 4; ++dir) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n\n            if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] != -1) {\n                int newCollected = collected;\n\n                for (int i = 0; i < scrollCount; ++i) {\n                    if (nx == scrolls[i].first && ny == scrolls[i].second) {\n                        newCollected |= (1 << i);\n                    }\n                }\n\n                int time = calculateTimeCost(nx, ny, grid);\n                if (current.timeCost + time < dist[nx][ny][newCollected]) {\n                    dist[nx][ny][newCollected] = current.timeCost + time;\n                    pq.push({nx, ny, newCollected, current.timeCost + time});\n                }\n            }\n        }\n    }\n\n    return -1; // If no solution is found\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<vector<int>> grid(n, vector<int>(n));\n    pair<int, int> start, goal;\n    vector<pair<int, int>> scrolls;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> grid[i][j];\n            if (grid[i][j] == 2) {\n                start = {i, j};\n            } else if (grid[i][j] == 3) {\n                goal = {i, j};\n            } else if (grid[i][j] == 4) {\n                scrolls.push_back({i, j});\n            }\n        }\n    }\n\n    int result = shortestTimeToCollectAllScrolls(grid, start, goal, scrolls);\n\n    cout << result << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:34:17"
  }
]