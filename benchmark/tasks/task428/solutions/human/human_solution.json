[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.{immutable, mutable}\nobject Main extends App {\n  import scala.io.StdIn._\n  val Array(width, height) = readLine.trim.split(' ').map(_.toInt)\n  val state = Array.fill(height){readLine.trim.toCharArray}\n  val moveCost = Array.fill(height){Array.fill(width){1}}\n  for (hole ← (0 until height).flatMap(y ⇒ (0 until width).map(Coordinate(_, y))) if state(hole) == '#') {\n    for (dx ← -3 to 3; dy ← -3 to 3; pos ← Some(hole + Coordinate(dx, dy)) if state.isDefinedAt(pos)) {\n      moveCost(pos) = math.max(moveCost(pos), 4 - math.max(dx.abs, dy.abs))\n    }\n  }\n  val paper = Array.fill(height){Array.fill(width){-1}}\n  val makimono = (0 until height).flatMap(y ⇒ (0 until width).collect { case x if state(y)(x) == 'M' ⇒ Coordinate(x, y) })\n  for ((p, i) ← makimono.zipWithIndex) {\n    paper(p) = i\n  }\n  val start = (0 until height).flatMap(y ⇒ (0 until width).collect { case x if state(y)(x) == 'S' ⇒ Coordinate(x, y) }).head\n  val goal = (0 until height).flatMap(y ⇒ (0 until width).collect { case x if state(y)(x) == 'G' ⇒ Coordinate(x, y) }).head\n  val minCost = Array.fill(height){Array.fill(width){Array.fill(1 << makimono.length){Int.MaxValue}}}\n  minCost(start)(0) = 0\n  val queue = mutable.PriorityQueue[((Coordinate, Int), Int)](((start, 0), 0))(Ordering.by[((Coordinate, Int), Int), Int](_._2).reverse)\n  while(queue.nonEmpty) {\n    val ((current, pat), cost) = queue.dequeue()\n    if (minCost(current)(pat) == cost){\n      for (next ← current.neighbors if paper.isDefinedAt(next) && state(next) != '#') {\n        paper(next) match {\n          case -1 ⇒\n            if (minCost(next)(pat) > cost + moveCost(current)) {\n              minCost(next)(pat) = cost + moveCost(current)\n              queue.enqueue(((next, pat), cost + moveCost(current)))\n            }\n          case m ⇒\n            if (minCost(next)(pat | (1 << m)) > cost + moveCost(current)) {\n              minCost(next)(pat | (1 << m)) = cost + moveCost(current)\n              queue.enqueue(((next, pat | (1 << m)), cost + moveCost(current)))\n            }\n        }\n      }\n    }\n  }\n  println(minCost(goal).last)\n  implicit class WrapArray[T](val array: Array[Array[T]]) extends AnyVal {\n    def isDefinedAt(coordinate: Coordinate): Boolean = array.indices.contains(coordinate.y) && array(coordinate.y).indices.contains(coordinate.x)\n    def apply(coordinate: Coordinate): T = array(coordinate.y)(coordinate.x)\n    def update(coordinate: Coordinate, value: T): Unit = array(coordinate.y)(coordinate.x) = value\n  }\n}\n\ncase class Coordinate(x: Int, y: Int) {\n  def neighbors: Iterable[Coordinate] = List(Coordinate(x + 1, y), Coordinate(x - 1, y), Coordinate(x, y + 1), Coordinate(x, y - 1))\n  def +(that: Coordinate): Coordinate = Coordinate(x + that.x, y + that.y)\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef pair<int,P> PP;\nint W,H,p[11][2],m=1,C[105][105],mv[5]={0,-1,0,1,0},G[2],T[9][9];\nchar M[105][105];\n\nvoid dbg()\n{\n\tfor(int i=0;i<H;i++,puts(\"\"))\n\t\tfor(int j=0;j<W;j++)\n\t\t\tprintf(\"%d \",C[i][j]);\n}\n\nint bfs(int sy,int sx,int gy,int gx)\n{\n\tint c[105][105]={0};\n\tmemset(c,0x7f,sizeof(c));\n\tpriority_queue<PP,vector<PP>,greater<PP> >Q;\n\tQ.push(make_pair(0,make_pair(sy,sx)));\n\tfor(;!Q.empty();)\n\t{\n\t\tPP tmp=Q.top();Q.pop();\n\t\tif(tmp.second.first==gy&&tmp.second.second==gx)\n\t\t\treturn tmp.first;\n\t\tif(tmp.first>c[tmp.second.first][tmp.second.second])\n\t\t\tcontinue;\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tint ny=tmp.second.first+mv[i];\n\t\t\tint nx=tmp.second.second+mv[i+1];\n\t\t\tif(M[ny][nx]=='#'||ny<0||ny>=H||nx<0||nx>=W)continue;\n\t\t\tif(tmp.first+C[tmp.second.first][tmp.second.second]<=c[ny][nx])\n\t\t\t{\n\t\t\t\tc[ny][nx]=tmp.first+C[tmp.second.first][tmp.second.second];\n\t\t\t\tQ.push(make_pair(tmp.first+C[tmp.second.first][tmp.second.second],make_pair(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\\n\",&W,&H);\n\tfor(int i=0;i<H;i++)\n\t\tfor(int j=0;j<W;j++)\n\t\t\tC[i][j]=1;\n\tfor(int i=0;i<H;i++)gets(M[i]);\n\tfor(int i=0;i<H;i++)\n\t\tfor(int j=0;j<W;j++)\n\t\t{\n\t\t\tif(M[i][j]=='S')\n\t\t\t\tp[0][0]=i,p[0][1]=j,M[i][j]='.';\n\t\t\telse if(M[i][j]=='G')\n\t\t\t\tG[0]=i,G[1]=j,M[i][j]='.';\n\t\t\telse if(M[i][j]=='M')\n\t\t\t{\n\t\t\t\tp[m][0]=i,p[m][1]=j,M[i][j]='.';\n\t\t\t\tm++;\n\t\t\t}\n\t\t\telse if(M[i][j]=='#')\n\t\t\t{\n\t\t\t\tfor(int h=max(0,i-2);h<min(H,i+3);h++)\n\t\t\t\t\tfor(int w=max(0,j-2);w<min(W,j+3);w++)\n\t\t\t\t\t\tC[h][w]=max(4-max(abs(i-h),abs(j-w)),C[h][w]);\n\t\t\t}\n\t\t}\n\tp[m][0]=G[0];\n\tp[m][1]=G[1];\n\tfor(int i=0;i<=m;i++)\n\t\tfor(int j=0;j<=m;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\tT[i][j]=bfs(p[i][0],p[i][1],p[j][0],p[j][1]);\n\t\t}\n\tint route[100],res=1000000000;\n\tif(m==1)\n\t{\n\t\tres=T[0][1];\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<=m;i++)\n\t\t\troute[i]=i;\n\t\tdo\n\t\t{\n\t\t\tint tmp=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t\ttmp+=T[route[i]][route[i+1]];\n\t\t\tres=min(res,tmp);\n\t\t}while(next_permutation(route+1,route+m));\n\t}\n\tprintf(\"%d\\n\",res);\n\t//dbg();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint H,W;\nint dist[MAX][MAX]; \nchar field[MAX][MAX];\nvector<P> M,Hole;\n\nstruct State{\n  int x,y,cost,m;\n  State(){}\n  State(int x,int y,int cost,int m) : x(x), y(y), cost(cost), m(m) {}\n};\n\nbool inField(int y,int x){\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nvoid init(){\n  fill(dist[0],dist[MAX],1);\n  const int dx[] = {-1,-1,-1,0,0,1,1,1};\n  const int dy[] = {-1,0,1,-1,1,-1,0,1};\n  for(int i = 0 ; i < (int)Hole.size() ; i++){\n    int x = Hole[i].first, y = Hole[i].second;\n    for(int j = 0 ; j < 8 ; j++){\n      int nx = x + dx[j];\n      int ny = y + dy[j];\n      if(!inField(ny,nx)) continue;\n      dist[ny][nx] = max(dist[ny][nx],3);\n      for(int k = 0 ; k < 8 ; k++){\n        int nnx = nx + dx[k];\n        int nny = ny + dy[k];\n        if(!inField(nny,nnx)) continue;\n        dist[nny][nnx] = max(dist[nny][nnx],2);\n      }\n    }\n  }\n}\n\nint bfs(int sx,int sy,int gx,int gy){\n  const int dx[] = {-1,0,0,1};\n  const int dy[] = {0,-1,1,0};\n  int d[MAX][MAX];\n  fill(d[0],d[MAX],INF);\n  d[sy][sx] = 0;\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(sx,sy)));\n\n  while(!Q.empty()){\n    PP p = Q.top(); Q.pop();\n    int x = p.second.first, y = p.second.second;\n    if(x == gx && y == gy) break;\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = x + dx[i];\n      int ny = y + dy[i];\n      if(!inField(ny,nx)) continue;\n      if(field[ny][nx] == '#') continue;\n      if(d[ny][nx] <= d[y][x] + dist[y][x]) continue;\n      Q.push(PP(p.first+dist[y][x],P(nx,ny)));\n      d[ny][nx] = p.first + dist[y][x];\n    }\n  }\n\n  return d[gy][gx];\n}\n\nvoid solve(int sx,int sy,int gx,int gy){\n  int len = M.size(),ans = INF;\n  int d[MAX][MAX][1<<5];\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      for(int k = 0 ; k < 1<<5 ; k++){\n        d[i][j][k] = INF;\n      }\n    }\n  }\n  d[sy][sx][0] = 0;\n  queue<State> Q;\n  Q.push(State(sx,sy,0,0));   \n  init();\n\n  while(!Q.empty()){\n    State S = Q.front(); Q.pop();\n    bool ok = true;\n    for(int i = 0 ; i < len ; i++){\n      if(!(S.m >> i & 1)){\n        ok = false; \n        break;\n      } \n    }\n    if(ok && S.x == gx && S.y == gy){\n      ans = min(ans,S.cost);\n      continue;\n    }\n    if(ok){\n      S.cost += bfs(S.x,S.y,gx,gy);\n      ans = min(ans,S.cost);   \n    }else{\n      for(int i = 0 ; i < len ; i++){\n        if(S.m >> i & 1) continue;\n        State next;\n        next.cost = S.cost + bfs(S.x,S.y,M[i].first,M[i].second);\n        next.m = S.m | 1<<i; next.x = M[i].first; next.y = M[i].second;\n        if(next.cost < d[next.y][next.x][next.m]){\n          d[next.y][next.x][next.m] = next.cost;\n          Q.push(next);\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\n\nint main(){\n  int sx,sy,gx,gy;\n  cin >> W >> H;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> field[i][j];\n      if(field[i][j] == 'S'){\n        sx = j; sy = i;\n      }else if(field[i][j] == 'G'){\n        gx = j; gy = i;\n      }else if(field[i][j] == 'M'){\n        M.push_back(P(j,i));\n      }else if(field[i][j] == '#'){\n        Hole.push_back(P(j,i));\n      }\n    }\n  }\n  solve(sx,sy,gx,gy);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n\n\tint w,h;\n\tconst int MAX=INT_MAX/10;\nstruct node{\n    int y,x,cost;\n    node(int y,int x,int cost):y(y),x(x),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n    }\n};\nconst int NONE=-1;\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint search(vs &field,vvi &time,pii start,pii goal){\n    priority_queue<node> q;\n\tq.push(node(start.first,start.second,0));\n    vvi cost(h,vi(w,MAX));\n    cost[start.first][start.second]=0;\n    while(!q.empty()){\n        node cnode=q.top();q.pop();\n\t\tif(cost[cnode.y][cnode.x]<cnode.cost){\n            continue;\n        }\n\t\tREP(d,4){\n\t\t\tint xx=cnode.x+dx[d];\n\t\t\tint yy=cnode.y+dy[d];\n\t\t\tif(xx>=0&&yy>=0&&xx<w&&yy<h&&field[yy][xx]!='#'){\n\t\t\t\tint newcost=cnode.cost+time[cnode.y][cnode.x];\n\t\t\t\tif(cost[yy][xx]>newcost){\n\t\t\t\t\tcost[yy][xx]=newcost;\n\t\t\t\t\tq.push(node(yy,xx,newcost));\n\t\t\t\t}\n            }\n        }\n    }\n\treturn cost[goal.first][goal.second];\n}\nint main(){\n\tcin>>w>>h;\n\tvs field(h);\n\tvector<pii> points;\n\tpii start,goal;\n\tREP(i,h){\n\t\tcin>>field[i];\n\t}\n\tREP(i,h){\n\t\tREP(j,w){\n\t\t\tif(field[i][j]=='M'){\n\t\t\t\tpoints.push_back(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,h){\n\t\tREP(j,w){\n\t\t\tif(field[i][j]=='S'){\n\t\t\t\tstart=make_pair(i,j);\n\t\t\t\tpoints.push_back(make_pair(i,j));\n\t\t\t}else if(field[i][j]=='G'){\n\t\t\t\tgoal=make_pair(i,j);\n\t\t\t\tpoints.push_back(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t}\n\n\tvvi time(h,vi(w,1));\n\tREP(i,h){\n\t\tREP(j,w){\n\t\t\tint nearest=MAX;\n\t\t\tFOR(x,-3,3+1){\n\t\t\t\tFOR(y,-3,3+1){\n\t\t\t\t\tif(x==0&&y==0)continue;\n\t\t\t\t\tint yy=i+y,xx=j+x;\n\t\t\t\t\tif(yy>=0&&xx>=0&&yy<h&&xx<w&&field[i+y][j+x]=='#'){\n\t\t\t\t\t\tnearest=min(nearest,max(abs(x),abs(y)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nearest!=MAX){\n\t\t\t\ttime[i][j]=4-nearest;\n\t\t\t}\n\t\t}\n\t}\n\tvvi dist(points.size(),vi(points.size()));\n\tREP(i,points.size()){\n\t\tREP(j,points.size()){\n\t\t\tif(i!=j){\n\t\t\t\tvvi visited(h,vi(w));\n\t\t\t\tdist[i][j]=search(field,time,points[i],points[j]);\n\t\t\t}\n\t\t}\n\t}\n\tvi order(points.size()-2);\n\tREP(i,order.size()){\n\t\torder[i]=i;\n\t}\n\tint ans=MAX;\n\tdo{\n\t\tint cost=0;\n\t\tcost+=dist[order.size()][order[0]];\n\t\tREP(i,order.size()-1){\n\t\t\tcost+=dist[order[i]][order[i+1]];\n\t\t}\n\t\tcost+=dist[order[order.size()-1]][order.size()+1];\n\t\tans=min(ans,cost);\n\t}while(next_permutation(ALL(order)));\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 28;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int ddx[] = {1, 1, 0, -1, -1, -1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2, 2};\nconst int ddy[] = {0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2, 2, 2, 2, 2, 1};\n\nint main()\n{\n  int W, H;\n  while (cin >> W >> H) {\n    vector<string> tile(H);\n    for (int i = 0; i < H; ++i)\n      cin >> tile[i];\n\n    int sx, sy, tx, ty;\n    vector<vector<int> > map(H, vector<int>(W, 1));\n    vector<pair<int, int> > m;\n    for (int y = 0; y < H; ++y) {\n      for (int x = 0; x < W; ++x) {\n        if (tile[y][x] == 'S') {\n          sx = x;\n          sy = y;\n        } else if (tile[y][x] == 'G') {\n          tx = x;\n          ty = y;\n        } else if (tile[y][x] == 'M') {\n          m.push_back(make_pair(x, y));\n        } else if (tile[y][x] == '#') {\n          map[y][x] = INF;\n        }\n      }\n    }\n\n    for (int y = 0; y < H; ++y) {\n      for (int x = 0; x < W; ++x) {\n        if (map[y][x] != INF)\n          continue;\n        for (int d = 0; d < 24; ++d) {\n          int xx = x + ddx[d];\n          int yy = y + ddy[d];\n          if (xx < 0 || xx >= W || yy < 0 || yy >= H)\n            continue;\n          if (d < 8)\n            map[yy][xx] = max(map[yy][xx], 3);\n          else\n            map[yy][xx] = max(map[yy][xx], 2);          \n        }\n      }\n    }\n\n    sort(m.begin(), m.end());\n    m.insert(m.begin(), make_pair(sx, sy));\n    m.push_back(make_pair(tx, ty));\n    vector<vector<int> > indexer(H, vector<int>(W));\n    for (int i = 0; i < (int)m.size(); ++i)\n      indexer[m[i].second][m[i].first] = i;\n\n    vector<vector<int> > cost(m.size(), vector<int>(m.size(), INF));\n    for (unsigned int i = 0; i < m.size(); ++i) {\n      for (unsigned int j = i+1; j < m.size(); ++j) {\n        queue<pair<int, int> > que;\n        que.push(m[i]);\n        vector<vector<int> > dp(H, vector<int>(W, INF));\n        dp[m[i].second][m[i].first] = 0;\n        while (!que.empty()) {\n          pair<int, int> p = que.front();\n          que.pop();\n          if (p == m[j]) {\n            cost[i][j] = cost[j][i] = dp[p.second][p.first];\n            break;\n          }\n\n          for (int d = 0; d < 4; ++d) {\n            int xx = p.first + dx[d];\n            int yy = p.second + dy[d];\n            if (xx < 0 || xx >= W || yy < 0 || yy >= H || map[p.second][p.first] == INF ||\n                dp[yy][xx] <= dp[p.second][p.first] + map[p.second][p.first])\n              continue;\n            dp[yy][xx] = dp[p.second][p.first] + map[p.second][p.first];\n            que.push(make_pair(xx, yy));\n          }\n        }\n      }\n    }\n    \n    int ans = INF;\n    do {\n      int ret = 0;\n      for (unsigned int i = 1; i < m.size(); ++i)\n        ret += cost[indexer[m[i-1].second][m[i-1].first]][indexer[m[i].second][m[i].first]];\n      ans = min(ans, ret);\n    } while (next_permutation(m.begin()+1, m.end()-1));\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint ijk[110][110][32];\nint v[110][110][32];\nint t[110][110];\nint ch[110][110];\nchar str[110][110];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint ABS(int a){return max(a,-a);}\nint main(){\n\tint a,b;scanf(\"%d%d\",&b,&a);\n\tfor(int i=0;i<a;i++)scanf(\"%s\",str[i]);\n\tint sz=0;\n\tint sr,sc,gr,gc;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)ch[i][j]=-1;\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++){\n\t\tt[i][j]=max(t[i][j],1);\n\t\tif(str[i][j]=='M')ch[i][j]=sz++;\n\t\tif(str[i][j]=='S'){\n\t\t\tsr=i;sc=j;\n\t\t}\n\t\tif(str[i][j]=='G'){\n\t\t\tgr=i;gc=j;\n\t\t}\n\t\tif(str[i][j]=='#'){\n\t\t\tfor(int k=0;k<a;k++)for(int l=0;l<b;l++){\n\t\t\t\tt[k][l]=max(t[k][l],4-max(ABS(k-i),ABS(l-j)));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)for(int k=0;k<(1<<sz);k++){\n\t\tijk[i][j][k]=999999999;\n\t}\n\tijk[sr][sc][0]=0;\n\tpriority_queue<pair<pair<int,int>,pair<int,int> > >Q;\n\tQ.push(make_pair(make_pair(0,0),make_pair(sr,sc)));\n\twhile(Q.size()){\n\t\tint cost=-Q.top().first.first;\n\t\tint bit=Q.top().first.second;\n\t\tint row=Q.top().second.first;\n\t\tint col=Q.top().second.second;\n\t\tQ.pop();\n\t\tif(v[row][col][bit])continue;\n\t\tv[row][col][bit]=1;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tif(row+dx[i]<0||row+dx[i]>=a||col+dy[i]<0||col+dy[i]>=b||str[row+dx[i]][col+dy[i]]=='#')continue;\n\t\t\tint tb=bit;\n\t\t\tif(~ch[row+dx[i]][col+dy[i]])tb|=(1<<ch[row+dx[i]][col+dy[i]]);\n\t\t\tif(!v[row+dx[i]][col+dy[i]][tb]&&ijk[row+dx[i]][col+dy[i]][tb]>cost+t[row][col]){\n\t\t\t\tijk[row+dx[i]][col+dy[i]][tb]=cost+t[row][col];\n\t\t\t\tQ.push(make_pair(make_pair(-cost-t[row][col],tb),make_pair(row+dx[i],col+dy[i])));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ijk[gr][gc][(1<<sz)-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\n\ntypedef pair <int, II> NODE1;\ntypedef priority_queue <NODE1, vector<NODE1>, greater<NODE1> > QUEUE1;\ntypedef pair <II, II> NODE;\ntypedef priority_queue <NODE, vector<NODE>, greater<NODE> > QUEUE;\nconst int SIZE = 101;\nconst char STATES = 1<<6;\nconst char START = 'S';\nconst char GOAL = 'G';\nconst char HOGE = 'M';\nconst char EMPTY = '.';\nconst char OBJ = '#';\nconst int dr1[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };\nconst int dc1[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\nconst int dr[4] = { 0, 0, 1, -1 };\nconst int dc[4] = { 1, -1, 0, 0 };\nint W, H;\nstring S[SIZE];\nint HR[STATES];\nint HC[STATES];\nint C[SIZE][SIZE];\nint MC[SIZE][SIZE][STATES];\nint hoges;\n\nint sr, sc;\nint gr, gc;\n\nbool input() {\n    if ( ! ( cin >> W >> H ) ) return false;\n    for ( int i = 0; i < H; ++ i ) cin >> S[i];\n    return true;\n}\n\nint calc_cost( int sr, int sc ) {\n    QUEUE1 Q;\n    Q.push( NODE1( 0, II( sr, sc ) ) );\n    bool V[SIZE][SIZE];\n    fill( (bool*)V, (bool*)V+SIZE*SIZE, false );\n    V[sr][sc] = true;\n    while ( ! Q.empty() ) {\n        NODE1 node = Q.top();\n        Q.pop();\n\n        int steps = node.first;\n        int r = node.second.first;\n        int c = node.second.second;\n\n        if ( S[r][c] == OBJ ) return steps > 3 ? 1 : 4 - steps;\n\n        for ( int i = 0; i < 8; ++ i ) {\n            int nr = r + dr1[i];\n            int nc = c + dc1[i];\n            if ( nr < 0 || nr >= H || nc < 0 || nc >= W ) continue;\n            if ( V[nr][nc] ) continue;\n            V[nr][nc] = true;\n            int nsteps = steps + 1;\n            Q.push( NODE1( nsteps, II( nr, nc ) ) );\n        }\n    }\n\n    return 1;\n}\n\nint calc_cost() {\n    QUEUE Q;\n    Q.push( NODE( II( 0, 0 ), II( sr, sc ) ) );\n    fill( (int*)MC, (int*)MC+SIZE*SIZE*STATES, INT_MAX );\n    \n    MC[sr][sc][0] = 0;\n    int goal_state = (1<<hoges) - 1;\n    while ( ! Q.empty() ) {\n        NODE node = Q.top();\n        Q.pop();\n\n        int steps = node.first.first;\n        int state = node.first.second;\n        int r = node.second.first;\n        int c = node.second.second;\n        int cost = C[r][c];\n\n        if ( r == gr && c == gc && state == goal_state ) {\n            return steps;\n        }\n\n        for ( int i = 0; i < 4; ++ i ) {\n            int nr = r + dr[i];\n            int nc = c + dc[i];\n            if ( nr < 0 || nr >= H || nc < 0 || nc >= W ) continue;\n            if ( S[nr][nc] == '#' ) continue;\n            int nsteps = steps + cost;\n            int nstate = state;\n            for ( int j = 0; j < hoges; ++ j ) {\n                if ( HR[j] == nr && HC[j] == nc ) {\n                    nstate |= ( 1 << j );\n                    break;\n                }\n            }\n            if ( nsteps >= MC[nr][nc][nstate] ) continue;\n            MC[nr][nc][nstate] = nsteps;\n            Q.push( NODE( II( nsteps, nstate ), II( nr, nc ) ) );\n        }\n    }\n\n    return -1;\n}\n\nint solve() {\n    hoges = 0;\n    for ( int i = 0; i < H; ++ i ) {\n        for ( int j = 0; j < W; ++ j ) {\n            if ( S[i][j] == START ) {\n                sr = i;\n                sc = j;\n                S[i][j] = EMPTY;\n            } else if ( S[i][j] == GOAL ) {\n                gr = i;\n                gc = j;\n                S[i][j] = EMPTY;\n            } else if ( S[i][j] == HOGE ) {\n                HR[hoges] = i;\n                HC[hoges] = j;\n                S[i][j] = EMPTY;\n                hoges ++;\n            }\n        }\n    }\n\n      for ( int i = 0; i < H; ++ i ) {\n      for ( int j = 0; j < W; ++ j ) {\n          C[i][j] = calc_cost( i, j );\n      }\n      }\n\n    return calc_cost();\n}\n\nint main() {\n    while ( input() ) {\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct S{\n  int y,x,m,t;\n  bool operator<(S s)const{\n    return t>s.t;\n  }\n};\n\nint W,H;\n\nbool inside(int y,int x){\n  return 0<=y&&y<H&&0<=x&&x<W;\n}\n\nint main(){\n  cin>>W>>H;\n  char g[100][101];\n  for(int i=0;i<H;i++){\n    cin>>g[i];\n  }\n  int d[100][100];\n  fill(d[0],d[100],1);\n  priority_queue<S> que;\n  int m[100][100];\n  int nm=0;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(g[i][j]=='S'){\n\tque.push({i,j,0,0});\n      }else if(g[i][j]=='M'){\n\tm[i][j]=nm++;\n      }else if(g[i][j]=='#'){\n\tfor(int k=i-3;k<=i+3;k++){\n\t  for(int l=j-3;l<=j+3;l++){\n\t    if(inside(k,l)){\n\t      d[k][l]=max(d[k][l],4-max(abs(i-k),abs(j-l)));\n\t    }\n\t  }\n\t}\n      }\n    }\n  }\n  bool p[100][100][1<<5]={};\n  for(;;){\n    S cs=que.top();\n    if(g[cs.y][cs.x]=='G'&&cs.m+1==1<<nm){\n      cout<<cs.t<<endl;\n      break;\n    }\n    que.pop();\n    if(p[cs.y][cs.x][cs.m]++)continue;\n    for(int i=0;i<4;i++){\n      static int dir[]={0,1,0,-1,0};\n      int ny=cs.y+dir[i];\n      int nx=cs.x+dir[i+1];\n      if(inside(ny,nx)&&g[ny][nx]!='#'){\n\tint nb=(g[ny][nx]=='M')?cs.m|1<<m[ny][nx]:cs.m;\n\tque.push({ny,nx,nb,cs.t+d[cs.y][cs.x]});\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx3[4] = {1, 0, -1, 0};\nint dy3[4] = {0, 1, 0, -1};\nint dx[8] = {1, 0, -1, -1, -1, 0, 1, 1};\nint dy[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nint dx2[16] = {0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1};\nint dy2[16] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2, 2};\nstruct state{\n  int x, y, S;\n  int c;\n  state() {}\n  state(int x, int y, int S, int c) : x(x), y(y), S(S), c(c) {}\n  bool operator < (const state& s) const {\n    return c > s.c; //rev\n  }\n};\n \nint main(){\n  int W, H;\n  while(cin>>W>>H && (W||H)){\n    vector<string> grid(H);\n    REP(y, H) cin>>grid[y];\n    int cnt = 0;\n    REP(y, H)REP(x, W)if(grid[y][x] == 'M'){\n      grid[y][x] = cnt + '0';\n      cnt++;\n    }\n    const int goalS = (1<<cnt) - 1;\n    int move[100][100] = {};\n    REP(y, H)REP(x, W) move[y][x] = 1;\n    REP(y, H)REP(x, W){\n      if(grid[y][x] == '#'){\n        REP(r, 8){\n          int nx = x + dx[r], ny = y + dy[r];\n          if(nx >= 0 && ny >= 0 && nx < W && ny < H){\n            move[ny][nx] = 3;\n          }\n        }\n        REP(r, 16){\n          int nx = x + dx2[r], ny = y + dy2[r];\n          if(nx >= 0 && ny >= 0 && nx < W && ny < H){\n            move[ny][nx] = max(move[ny][nx], 2);\n          }\n        }\n      }\n    }\n    int dist[1<<5][100][100];\n    priority_queue<state> que;\n    REP(y, H)REP(x, W)REP(i, 1<<5)dist[i][y][x] = INF;\n    REP(y, H)REP(x, W)if(grid[y][x] == 'S'){\n      dist[0][y][x] = 0;\n      que.push(state(x, y, 0, 0));\n    }\n    int ans = INF;\n    while(!que.empty()){\n      state s = que.top(); que.pop();\n      if(s.S == goalS && grid[s.y][s.x] == 'G'){\n        ans = s.c;\n        break;\n      }\n      REP(r, 4){\n        int nx = s.x + dx3[r];\n        int ny = s.y + dy3[r];\n        if(!(nx >= 0 && ny >= 0 && nx < W && ny < H)) continue;\n        if(grid[ny][nx] == '#') continue;\n        int nc = s.c + move[s.y][s.x];\n        int nS = s.S;\n        if(grid[ny][nx] <= '5' && grid[ny][nx] >= '0'){\n          nS = nS | (1<<(grid[ny][nx]-'0'));\n        }\n        if(dist[nS][ny][nx] > nc){\n          dist[nS][ny][nx] = nc;\n          que.push(state(nx, ny, nS, nc));\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef pair<int,P> PP;\nint W,H,p[20][2],m=1,C[105][105],mv[5]={0,-1,0,1,0},G[2],T[20][9];\nchar M[105][105];\n\nvoid dbg()\n{\n\tfor(int i=0;i<H;i++,puts(\"\"))\n\t\tfor(int j=0;j<W;j++)\n\t\t\tprintf(\"%d \",C[i][j]);\n}\n\nint bfs(int sy,int sx,int gy,int gx)\n{\n\tint c[105][105]={0};\n\tmemset(c,0x7f,sizeof(c));\n\tpriority_queue<PP,vector<PP>,greater<PP> >Q;\n\tQ.push(make_pair(0,make_pair(sy,sx)));\n\tfor(;!Q.empty();)\n\t{\n\t\tPP tmp=Q.top();Q.pop();\n\t\tif(tmp.second.first==gy&&tmp.second.second==gx)\n\t\t\treturn tmp.first;\n\t\tif(tmp.first>c[tmp.second.first][tmp.second.second])\n\t\t\tcontinue;\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tint ny=tmp.second.first+mv[i];\n\t\t\tint nx=tmp.second.second+mv[i+1];\n\t\t\tif(M[ny][nx]=='#'||ny<0||ny>=H||nx<0||nx>=W)continue;\n\t\t\tif(tmp.first+C[tmp.second.first][tmp.second.second]<c[ny][nx])\n\t\t\t{\n\t\t\t\tc[ny][nx]=tmp.first+C[tmp.second.first][tmp.second.second];\n\t\t\t\tQ.push(make_pair(tmp.first+C[tmp.second.first][tmp.second.second],make_pair(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\\n\",&W,&H);\n\tfor(int i=0;i<H;i++)\n\t\tfor(int j=0;j<W;j++)\n\t\t\tC[i][j]=1;\n\tfor(int i=0;i<H;i++)gets(M[i]);\n\tfor(int i=0;i<H;i++)\n\t\tfor(int j=0;j<W;j++)\n\t\t{\n\t\t\tif(M[i][j]=='S')\n\t\t\t\tp[0][0]=i,p[0][1]=j,M[i][j]='.';\n\t\t\telse if(M[i][j]=='G')\n\t\t\t\tG[0]=i,G[1]=j,M[i][j]='.';\n\t\t\telse if(M[i][j]=='M')\n\t\t\t{\n\t\t\t\tp[m][0]=i,p[m][1]=j,M[i][j]='.';\n\t\t\t\tm++;\n\t\t\t}\n\t\t\telse if(M[i][j]=='#')\n\t\t\t{\n\t\t\t\tfor(int h=max(0,i-2);h<min(H,i+3);h++)\n\t\t\t\t\tfor(int w=max(0,j-2);w<min(W,j+3);w++)\n\t\t\t\t\t\tC[h][w]=max(4-max(abs(i-h),abs(j-w)),C[h][w]);\n\t\t\t}\n\t\t}\n\tp[m][0]=G[0];\n\tp[m][1]=G[1];\n\tfor(int i=0;i<=m;i++)\n\t\tfor(int j=0;j<=m;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\tT[i][j]=bfs(p[i][0],p[i][1],p[j][0],p[j][1]);\n\t\t}\n\tint route[100],res=1000000000;\n\tif(m==1)\n\t{\n\t\tres=T[0][1];\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<=m;i++)\n\t\t\troute[i]=i;\n\t\tdo\n\t\t{\n\t\t\tint tmp=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t\ttmp+=T[route[i]][route[i+1]];\n\t\t\tres=min(res,tmp);\n\t\t}while(next_permutation(route+1,route+m));\n\t}\n\tprintf(\"%d\\n\",res);\n\t//dbg();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n \nint H,W;\nint dist[MAX][MAX]; \nchar field[MAX][MAX];\nvector<P> M,Hole;\n \nstruct State{\n    int x,y,cost,m;\n    State(){}\n    State(int x,int y,int cost,int m) : x(x), y(y), cost(cost), m(m) {}\n};\n \nbool inField(int y,int x){\n    return 0 <= y && y < H && 0 <= x && x < W;\n}\n \nvoid init(){\n    fill(dist[0],dist[MAX],1);\n    const int dx[] = {-1,-1,-1,0,0,1,1,1};\n    const int dy[] = {-1,0,1,-1,1,-1,0,1};\n    for(int i = 0 ; i < (int)Hole.size() ; i++){\n\tint x = Hole[i].first, y = Hole[i].second;\n\tfor(int j = 0 ; j < 8 ; j++){\n\t    int nx = x + dx[j];\n\t    int ny = y + dy[j];\n\t    if(!inField(ny,nx)) continue;\n\t    dist[ny][nx] = max(dist[ny][nx],3);\n\t    for(int k = 0 ; k < 8 ; k++){\n\t\tint nnx = nx + dx[k];\n\t\tint nny = ny + dy[k];\n\t\tif(!inField(nny,nnx)) continue;\n\t\tdist[nny][nnx] = max(dist[nny][nnx],2);\n\t    }\n\t}\n    }\n}\n \nint bfs(int sx,int sy,int gx,int gy){\n    const int dx[] = {-1,0,0,1};\n    const int dy[] = {0,-1,1,0};\n    int d[MAX][MAX];\n    fill(d[0],d[MAX],INF);\n    d[sy][sx] = 0;\n    priority_queue<PP,vector<PP>,greater<PP> > Q;\n    Q.push(PP(0,P(sx,sy)));\n \n    while(!Q.empty()){\n\tPP p = Q.top(); Q.pop();\n\tint x = p.second.first, y = p.second.second;\n\tif(x == gx && y == gy) break;\n\tfor(int i = 0 ; i < 4 ; i++){\n\t    int nx = x + dx[i];\n\t    int ny = y + dy[i];\n\t    if(!inField(ny,nx)) continue;\n\t    if(field[ny][nx] == '#') continue;\n\t    if(d[ny][nx] <= d[y][x] + dist[y][x]) continue;\n\t    Q.push(PP(p.first+dist[y][x],P(nx,ny)));\n\t    d[ny][nx] = p.first + dist[y][x];\n\t}\n    }\n \n    return d[gy][gx];\n}\n \nvoid solve(int sx,int sy,int gx,int gy){\n    int len = M.size(),ans = INF;\n    int d[MAX][MAX][1<<5];\n    for(int i = 0 ; i < H ; i++){\n\tfor(int j = 0 ; j < W ; j++){\n\t    for(int k = 0 ; k < 1<<5 ; k++){\n\t\td[i][j][k] = INF;\n\t    }\n\t}\n    }\n    d[sy][sx][0] = 0;\n    queue<State> Q;\n    Q.push(State(sx,sy,0,0));   \n    init();\n \n    while(!Q.empty()){\n\tState S = Q.front(); Q.pop();\n\tbool ok = true;\n\tfor(int i = 0 ; i < len ; i++){\n\t    if(!(S.m >> i & 1)){\n\t\tok = false; \n\t\tbreak;\n\t    } \n\t}\n\tif(ok && S.x == gx && S.y == gy){\n\t    ans = min(ans,S.cost);\n\t    continue;\n\t}\n\tif(ok){\n\t    S.cost += bfs(S.x,S.y,gx,gy);\n\t    ans = min(ans,S.cost);   \n\t}else{\n\t    for(int i = 0 ; i < len ; i++){\n\t\tif(S.m >> i & 1) continue;\n\t\tState next;\n\t\tnext.cost = S.cost + bfs(S.x,S.y,M[i].first,M[i].second);\n\t\tnext.m = S.m | 1<<i; next.x = M[i].first; next.y = M[i].second;\n\t\tif(next.cost < d[next.y][next.x][next.m]){\n\t\t    d[next.y][next.x][next.m] = next.cost;\n\t\t    Q.push(next);\n\t\t}\n\t    }\n\t}\n    }\n    cout << ans << endl;\n}\n \nint main(){\n    int sx,sy,gx,gy;\n    cin >> W >> H;\n    for(int i = 0 ; i < H ; i++){\n\tfor(int j = 0 ; j < W ; j++){\n\t    cin >> field[i][j];\n\t    if(field[i][j] == 'S'){\n\t\tsx = j; sy = i;\n\t    }else if(field[i][j] == 'G'){\n\t\tgx = j; gy = i;\n\t    }else if(field[i][j] == 'M'){\n\t\tM.push_back(P(j,i));\n\t    }else if(field[i][j] == '#'){\n\t\tHole.push_back(P(j,i));\n\t    }\n\t}\n    }\n    solve(sx,sy,gx,gy);\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<sstream>\n#include<climits>\n#include<cstdio>\n#include<cstdlib>\nusing namespace std;\n\nvector<vector<char> > f;\nvector<vector<int> > cost;\nvector<pair<int,int> > M;\nvector<pair<int,int> > hole;\npair<int,int> s,g;\nstruct S{\n  pair<int,int> pos;\n  int cost;\n  int get;\n};\nbool operator<(S a,S b){\n  return a.cost>b.cost;\n}\n\nconst int vx[]={0,0,1,-1};\nconst int vy[]={1,-1,0,0};\nbool all(int get){\n  return get==(1<<M.size())-1;\n}\nvector<map<pair<int,int>,int>> dp;\nint solve(){\n  priority_queue<S> que;\n  que.push(S{s,0,0});\n  dp.clear();\n  dp.resize(1<<M.size());\n  while(!que.empty()){\n    S now  = que.top();que.pop();\n    if(now.pos.first<0 || now.pos.first>=cost.size() || now.pos.second <0 || now.pos.second>= cost[0].size())continue;\n    if(dp[now.get][now.pos]==1)continue;\n    dp[now.get][now.pos]=1;\n    for(int i=0;i<M.size();i++){\n      if(M[i]==now.pos){\n        now.get = now.get | (1<<i);\n      }\n    }\n    if(all(now.get)&&g==now.pos){\n      return now.cost;\n    }\n    for(int i=0;i<4;i++){\n      S tmp = now;\n      tmp.pos.first += vx[i];\n      tmp.pos.second += vy[i];\n      tmp.cost += cost[now.pos.first][now.pos.second];\n      que.push(tmp);\n    }\n  }\n  return 0;\n}\nint main(){\n  int n,m;\n  while(cin>>n>>m){\n    f.clear();cost.clear();M.clear();hole.clear();\n    f.resize(m);\n    for(int i=0;i<m;i++){\n      for(int j=0;j<n;j++){\n        char tmp;\n        cin>>tmp;\n        f[i].push_back(tmp);\n      }\n    }\n    for(int i=0;i<f.size();i++){\n      for(int j=0;j<f[i].size();j++){\n        if(f[i][j]=='#'){\n          hole.push_back(make_pair(i,j));\n        }else if(f[i][j]=='M'){\n          M.push_back(make_pair(i,j));\n        }else if(f[i][j]=='S'){\n          s = make_pair(i,j);\n        }else if(f[i][j]=='G'){\n          g = make_pair(i,j);\n        }\n      }\n    }\n    cost.resize(f.size());\n    for(int i=0;i<f.size();i++){\n      for(int j=0;j<f[i].size();j++){\n        int tmp=1;\n        for(int k=0;k<hole.size();k++){\n          if(i==hole[k].first&&j==hole[k].second){\n            tmp = INT_MAX/2;\n          }else{\n            tmp = max(tmp,max(0,min(4-abs(i-hole[k].first),4-abs(j-hole[k].second))));\n          }\n        }\n        cost[i].push_back(tmp);\n      }\n    }\n\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n#define y first\n#define x second\ntypedef pair<int, int> P;\nconst int INF = 1e9;\n\nint my3[8] = {0, 0, 1, -1, 1, 1, -1, -1};\nint mx3[8] = {1, -1, 0, 0, -1, 1, 1, -1};\nint my2[16] = {-2, -2, -2, -2, -2, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1};\nint mx2[16] = {-2, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2};\nint my[4] = {0, 0, 1, -1};\nint mx[4] = {1, -1, 0, 0};\n\nint H, W;\n\nvoid dfs(int y, int x, vector< vector<int> > &v, vector< vector<int> > &step, int cnt){\n  step[y][x] = cnt;\n  REP(i, 4){\n    int ny = y + my[i], nx = x + mx[i];\n    if(ny >= 0 && nx >= 0 && ny < H && nx < W && v[ny][nx] != INF && step[ny][nx] > cnt + v[y][x]) dfs(ny, nx, v, step, cnt + v[y][x]);\n  }\n}\n\nint dist(P &a, P &b, vector< vector<int> > &v){\n  vector< vector<int> > step(H, vector<int>(W, INF));\n  dfs(a.y, a.x, v, step, 0);\n  return step[b.y][b.x];\n}\n\nint solve(vector< vector<int> > &d, int m, P &g, vector<P> &ms, vector< vector<int> > &v){\n  vector< vector<int> > dp((1 << m), vector<int>(m + 1, INF));\n  dp[0][0] = 0;\n  REP(i, (1 << m)){\n    REP(j, m + 1){\n      if(dp[i][j] == INF) continue;\n      REP(next, m){\n        if(((1 << next) & i) != 0) continue;\n        int c = d[j][next + 1], n = ((1 << next) | i);\n        dp[n][next + 1] = min(dp[n][next + 1], dp[i][j] + c);\n      }\n    }\n  }\n  int res = INF;\n  FOR(i, 1, m + 1) res = min(res, dp[(1 << m) - 1][i] + dist(ms[i - 1], g, v));\n  return res;\n}\n\nint main() {\n  cin >>W >>H;\n  vector<string> cv(H);\n  REP(i, H) cin >>cv[i];\n  vector< vector<int> > v(H, vector<int>(W, 1));\n  vector<P> ms;\n  P s, g;\n  REP(y, H){\n    REP(x, W){\n      if(cv[y][x] == 'M') ms.push_back(P(y, x));\n      if(cv[y][x] == 'S') s = P(y, x);\n      if(cv[y][x] == 'G') g = P(y, x);\n      if(cv[y][x] != '#') continue;\n      v[y][x] = INF;\n      REP(i, 8){\n        int ny = y + my3[i], nx = x + mx3[i];\n        if(ny >= 0 && nx >= 0 && ny < H && nx < W) v[ny][nx] = max(3, v[ny][nx]);\n      }\n      REP(i, 16){\n        int ny = y + my2[i], nx = x + mx2[i];\n        if(ny >= 0 && nx >= 0 && ny < H && nx < W) v[ny][nx] = max(2, v[ny][nx]);\n      }\n    }\n  }\n  int msl = ms.size();\n  vector< vector<int> > d(msl + 1, vector<int>(msl + 1, 0));\n  REP(i, msl) d[0][i + 1] = d[i + 1][0] = dist(s, ms[i], v);\n  REP(i, msl) FOR(j, i + 1, msl) d[i + 1][j + 1] = d[j + 1][i + 1] = dist(ms[i], ms[j], v);\n  cout <<solve(d, msl, g, ms, v) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\n#define INF 10000000\nint main()\n{\n  int w,h;\n  cin>>w>>h;\n  int maps[h][w];\n  pair<int,int>start;\n  pair<int,int>goal;\n  vector<pair<int,int> >m;\n  memset(maps,0,sizeof(maps));\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      {\n\tchar tmp;\n\tcin>>tmp;\n\tmaps[i][j]=max(maps[i][j],1);\n\tif(tmp=='S')\n\t    start=make_pair(i,j);\n\tif(tmp=='G')\n\t    goal=make_pair(i,j);\n\tif(tmp=='M')\n\t  m.push_back(make_pair(i,j));\n\tif(tmp=='#')\n\t  {\n\t    maps[i][j]=INF;\n\t    for(int ii=i-1;ii<i+2;ii++)\n\t      for(int jj=j-1;jj<j+2;jj++)\n\t\t{\n\t\tif(ii>=0 && ii<h &&\n\t\t   jj>=0 && jj<w )\n\t\t  maps[ii][jj]=max(maps[ii][jj],3);\n\t\t}\n\t    for(int ii=i-2;ii<i+3;ii++)\n\t      for(int jj=j-2;jj<j+3;jj++)\n\t\tif(ii>=0 && ii<h &&\n\t\t   jj>=0 && jj<w )\n\t\t  maps[ii][jj]=max(maps[ii][jj],2);\n\t  }\n      }\n/*\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      {\n\tif(maps[i][j]==INF)\n\t  cout<<'#';\n\t  else\n\t    cout<<maps[i][j];\n\tif(j==w-1)\n\t  cout<<endl;\n      }\n*/\n  //cnt,bit,<pos>;\n  priority_queue<pair<pair<int,int> ,pair<int,int> >,vector< pair<pair<int,int> ,pair<int,int> > > ,greater< pair<pair<int,int> ,pair<int,int>  > >  >qu;\n  qu.push(make_pair(make_pair(0,0),start));\n  int msize=m.size();\n  bool closed[h][w][1<<msize];\n  memset(closed,false,sizeof(closed));\n  int dx[]={1,-1,0,0};\n  int dy[]={0,0,1,-1};\n  while(!qu.empty())\n    {\n      int cnt=qu.top().first.first;\n      int bit=qu.top().first.second;\n      pair<int,int> pos=qu.top().second;\n      qu.pop();\n      for(int i=0;i<msize;i++)\n\t{\n\t  if(pos==m[i])\n\t    bit|=(1<<i);\n\t}\n      if(pos==goal && bit==(1<<msize)-1)\n\t{\n\t  cout<<cnt<<endl;\n\t  break;\n\t}\n      if(closed[pos.first][pos.second][bit])\n\tcontinue;\n      closed[pos.first][pos.second][bit]=true;\n      for(int i=0;i<4;i++)\n\t{\n\t  if(pos.first+dx[i]>=0 && pos.first+dx[i]<h &&\n\t     pos.second+dy[i]>=0 && pos.second+dy[i]<w  &&\n\t     !closed[pos.first+dx[i]][pos.second+dy[i]][bit]\n\t     )\n\t    qu.push(make_pair(make_pair(cnt+maps[pos.first][pos.second],bit),\n\t\t\t      make_pair(pos.first+dx[i],pos.second+dy[i])));\n\n\t}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <queue>\n#include <utility>\n\nusing namespace std;\ntypedef pair<int, int> pii;\nconst int INF = 1000000;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nbool between(int a, int b, int c){\n\treturn a <= b && b < c;\n}\n\nint search(const vector< vector<int> > &weight, int sx, int sy, int gx, int gy){\n\tint H = weight.size(), W = weight[0].size();\n\tpriority_queue< pii, vector<pii>, greater<pii> > pq;\n\tvector< vector<int> > mincost(H, vector<int>(W, INF));\n\tpq.push(pii(0, sx + sy * W));\n\tmincost[sy][sx] = 0;\n\twhile(!pq.empty()){\n\t\tpii p = pq.top();\n\t\tpq.pop();\n\t\tint cost = p.first, x = p.second % W, y = p.second / W;\n\t\tif(cost > mincost[y][x]){ continue; }\n\t\tif(x == gx && y == gy){ return cost; }\n\t\tfor(int i = 0; i < 4; ++i){\n\t\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\t\tif(!between(0, ny, H) || !between(0, nx, W)){ continue; }\n\t\t\tint nc = cost + weight[y][x];\n\t\t\tif(nc >= mincost[ny][nx]){ continue; }\n\t\t\tmincost[ny][nx] = nc;\n\t\t\tpq.push(pii(nc, nx + ny * W));\n\t\t}\n\t}\n\treturn INF;\n}\n\nint main(){\n\tint W, H;\n\tcin >> W >> H;\n\tvector<string> field(H);\n\tfor(int i = 0; i < H; ++i){ cin >> field[i]; }\n\tvector< vector<int> > weight(H, vector<int>(W, 1));\n\tint sx, sy, gx, gy;\n\tvector<int> mx, my;\n\tfor(int i = 0; i < H; ++i){\n\t\tfor(int j = 0; j < W; ++j){\n\t\t\tif(field[i][j] == 'S'){\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t}else if(field[i][j] == 'G'){\n\t\t\t\tgx = j;\n\t\t\t\tgy = i;\n\t\t\t}else if(field[i][j] == 'M'){\n\t\t\t\tmx.push_back(j);\n\t\t\t\tmy.push_back(i);\n\t\t\t}else if(field[i][j] == '#'){\n\t\t\t\tfor(int y = -2; y <= 2; ++y){\n\t\t\t\t\tfor(int x = -2; x <= 2; ++x){\n\t\t\t\t\t\tif(!between(0, i + y, H) || !between(0, j + x, W)){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint d = max(abs(y), abs(x));\n\t\t\t\t\t\tif(d == 0){\n\t\t\t\t\t\t\tweight[i + y][j + x] = INF;\n\t\t\t\t\t\t}else if(d == 1){\n\t\t\t\t\t\t\tweight[i + y][j + x] = max(weight[i + y][j + x], 3);\n\t\t\t\t\t\t}else if(d == 2){\n\t\t\t\t\t\t\tweight[i + y][j + x] = max(weight[i + y][j + x], 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint M = mx.size();\n\tvector<int> scost(M), gcost(M);\n\tvector< vector<int> > cmat(M, vector<int>(M, INF));\n\tfor(int i = 0; i < mx.size(); ++i){\n\t\tscost[i] = search(weight, sx, sy, mx[i], my[i]);\n\t\tgcost[i] = search(weight, mx[i], my[i], gx, gy);\n\t\tfor(int j = 0; j < mx.size(); ++j){\n\t\t\tcmat[i][j] = search(weight, mx[i], my[i], mx[j], my[j]);\n\t\t}\n\t}\n/*\nfor(int i = 0; i < M; ++i){ cout << scost[i] << \" \"; }\ncout << endl;\nfor(int i = 0; i < M; ++i){ cout << gcost[i] << \" \"; }\ncout << endl << endl;\nfor(int i = 0; i < M; ++i){\n\tfor(int j = 0; j < M; ++j){ cout << cmat[i][j] << \" \"; }\n\tcout << endl;\n}\n*/\n\tvector<int> perm(M);\n\tfor(int i = 0; i < M; ++i){ perm[i] = i; }\n\tint answer = INF;\n\tdo {\n\t\tint sum = scost[perm[0]] + gcost[perm[M - 1]];\n\t\tfor(int i = 1; i < M; ++i){\n\t\t\tsum += cmat[perm[i - 1]][perm[i]];\n\t\t}\n\t\tanswer = min(answer, sum);\n\t} while(next_permutation(perm.begin(), perm.end()));\n\tcout << answer << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst int INF = INT_MAX / 2;\n\nconst int dy[] = {0, 1, 0, -1};\nconst int dx[] = {1, 0, -1, 0};\n\nclass Data\n{\npublic:\n    int y, x;\n    bitset<5> bs;\n    Data(int y0, int x0, bitset<5> bs0){\n        y = y0;\n        x = x0;\n        bs = bs0;\n    }\n};\n\nint main()\n{\n    int h, w;\n    cin >> w >> h;\n\n    vector<string> s(h+4, string(w+4, '#'));\n    vector<vector<int> > fear(h+4, vector<int>(w+4, 1));\n    int sy, sx;\n    int n = 0;\n    for(int y=2; y<h+2; ++y){\n        for(int x=2; x<w+2; ++x){\n            cin >> s[y][x];\n            if(s[y][x] == 'S'){\n                sy = y;\n                sx = x;\n            }else if(s[y][x] == 'M'){\n                s[y][x] = '0' + n;\n                ++ n;\n            }else if(s[y][x] == '#'){\n                for(int i=-2; i<=2; ++i){\n                    for(int j=-2; j<=2; ++j){\n                        fear[y+i][x+j] = max(fear[y+i][x+j], 4 - max(abs(i), abs(j)));\n                    }\n                }\n            }\n        }\n    }\n    h += 4;\n    w += 4;\n\n    vector<vector<vector<int> > > dp(h, vector<vector<int> >(w, vector<int>(1<<n, INF)));\n    dp[sy][sx][0] = 0;\n    multimap<int, Data> mm;\n    mm.insert(make_pair(0, Data(sy, sx, 0)));\n\n    for(;;){\n        int cost0 = mm.begin()->first;\n        int y0 = mm.begin()->second.y;\n        int x0 = mm.begin()->second.x;\n        bitset<5> bs0 = mm.begin()->second.bs;\n        mm.erase(mm.begin());\n        if(cost0 > dp[y0][x0][bs0.to_ulong()])\n            continue;\n\n        if(s[y0][x0] == 'G' && bs0.count() == n){\n            cout << cost0 << endl;\n            return 0;\n        }\n\n        for(int i=0; i<4; ++i){\n            int cost = cost0 + fear[y0][x0];\n            int y = y0 + dy[i];\n            int x = x0 + dx[i];\n            bitset<5> bs = bs0;\n            if(s[y][x] == '#')\n                continue;\n            if(isdigit(s[y][x]))\n                bs[s[y][x]-'0'] = true;\n\n            if(cost < dp[y][x][bs.to_ulong()]){\n                dp[y][x][bs.to_ulong()] = cost;\n                mm.insert(make_pair(cost, Data(y, x, bs)));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint sp[111][111];\nint dp[111][111][1<<5];\nint w,h;\nint in(int y,int x){\n  return 0<=y&&y<h&&0<=x&&x<w;\n}\nstruct sta{\n  int y,x,b,d;\n  sta(){}\n  sta(int y,int x,int b,int d):y(y),x(x),b(b),d(d){}\n  bool operator<(const sta& a) const{\n    return d>a.d;\n  }\n};\ntypedef pair<int,int> P;\nint main(){\n  memset(sp,0,sizeof(sp));\n  memset(dp,-1,sizeof(dp));\n  cin>>w>>h;\n  string st[h];\n  for(int i=0;i<h;i++) cin>>st[i];\n  int sy,sx,gy,gx,n=0;\n  map<P,int> m;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      sp[i][j]=max(sp[i][j],1);\n      if(st[i][j]=='M') m[P(i,j)]=n++;\n      if(st[i][j]=='S') sy=i,sx=j;\n      if(st[i][j]=='G') gy=i,gx=j;\n      if(st[i][j]=='#'){\n\tfor(int k=1;k<=3;k++){\n\t  for(int a=-(4-k);a<=4-k;a++){\n\t    if(in(i-(4-k),j+a)) sp[i-(4-k)][j+a]=max(sp[i-(4-k)][j+a],k);\n\t    if(in(i+(4-k),j+a)) sp[i+(4-k)][j+a]=max(sp[i+(4-k)][j+a],k);\n\t    if(in(i+a,j-(4-k))) sp[i+a][j-(4-k)]=max(sp[i+a][j-(4-k)],k);\n\t    if(in(i+a,j+(4-k))) sp[i+a][j+(4-k)]=max(sp[i+a][j+(4-k)],k);\n\t  }\n\t}\n      }\n    }\n  }\n  /*//\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cout<<sp[i][j];\n    }\n    cout<<endl;\n  }\n  //*/\n  priority_queue<sta> q;\n  q.push(sta(sy,sx,0,0));\n  dp[sy][sx][0]=0;\n  int ax[]={1,-1,0,0};\n  int ay[]={0,0,1,-1};\n  while(!q.empty()){\n    sta s=q.top();q.pop();\n    if(dp[s.y][s.x][s.b]<s.d) continue;\n    //cout<<s.y<<\" \"<<s.x<<\" \"<<s.b<<\" \"<<s.d<<endl;\n    for(int k=0;k<4;k++){\n      int ny=s.y+ay[k],nx=s.x+ax[k],nb=s.b,nd=s.d+sp[s.y][s.x];\n      if(!in(ny,nx)) continue;\n      if(st[ny][nx]=='#') continue;\n      if(m.count(P(ny,nx))) nb|=1<<m[P(ny,nx)];\n      if(dp[ny][nx][nb]<0||dp[ny][nx][nb]>nd){\n\tdp[ny][nx][nb]=nd;\n\tq.push(sta(ny,nx,nb,nd));\n      }\n    }\n  }\n  cout<<dp[gy][gx][(1<<n)-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<tuple>\nusing namespace std;\nint H, W, x[102][102], sx, sy, gx, gy, dist[102][102][32];\nvector<pair<int, int>>vec;\nqueue<tuple<int, int, int>>Q;\nint main() {\n\tcin >> W >> H;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == '.')x[i][j] = 1;\n\t\t\tif (c == '#')x[i][j] = 114514;\n\t\t\tif (c == 'S') { x[i][j] = 1; sx = i; sy = j; }\n\t\t\tif (c == 'G') { x[i][j] = 1; gx = i; gy = j; }\n\t\t\tif (c == 'M') { x[i][j] = 1; vec.push_back(make_pair(i, j)); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (x[i][j] != 114514)continue;\n\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\tfor (int l = -2; l <= 2; l++) {\n\t\t\t\t\tint cx = i + k, cy = j + l;\n\t\t\t\t\tif (cx <= 0 || cx > H || cy <= 0 || cy > W)continue;\n\t\t\t\t\tx[i][j] = max(x[i][j], 4 - min(abs(k), abs(l)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 102; i++) { for (int j = 0; j < 102; j++) { for (int k = 0; k < 32; k++)dist[i][j][k] = 999999999; } }\n\tQ.push(make_tuple(sx, sy, 0)); dist[sx][sy][0] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = get<0>(Q.front()), a2 = get<1>(Q.front()), a3 = get<2>(Q.front()); Q.pop();\n\t\tint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint cx = a1 + dx[i], cy = a2 + dy[i];\n\t\t\tif (cx <= 0 || cx > H || cy <= 0 || cy > W)continue;\n\t\t\tif (x[cx][cy] == 114514)continue;\n\t\t\tint a4 = dist[a1][a2][a3] + x[a1][a2];\n\t\t\tint a5 = a3;\n\t\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\t\tif (vec[j].first == cx && vec[j].second == cy)a5 += (1 << j);\n\t\t\t}\n\t\t\tif (dist[cx][cy][a5] > a4) {\n\t\t\t\tdist[cx][cy][a5] = a4; Q.push(make_tuple(cx, cy, a5));\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[gx][gy][(1 << vec.size()) - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    const int INF = 1<<28;\n\n    int W, H;\n    vector<string> F;\n    void input() {\n        cin >> W >> H;\n        F.clear(); F.resize(H);\n        for (int i = 0; i < H; i++) {\n            cin >> F[i];\n        }\n    }\n\n    void find_pos(int& sy, int &sx, char c) {\n        sy = -1, sx = -1;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (F[i][j] == c) {\n                    sy = i;\n                    sx = j;\n                    return;\n                }\n            }\n        }\n        assert(false);\n    }\n\n    struct P {\n        int y, x, d;\n        P(int y, int x, int d) : y(y), x(x), d(d) {}\n    };\n\n    struct S {\n        int bit, y, x, d;\n        S(int bit, int y, int x, int d) : bit(bit), y(y), x(x), d(d) {}\n        bool operator<(const S& p) const {\n            return d > p.d;\n        }\n    };\n    ostream& operator<<(ostream& os, const S& s) {\n        return os << \"S(\" << s.bit << \" (\" << s.y << \",\" << s.x << \")\" << \" \" << s.d << \")\";\n    }\n\n    int construct_map(map< pair<int, int>, int >& M) {\n        int c = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (F[i][j] == 'M') {\n                    M[make_pair(i, j)] = c++;\n                }\n            }\n        }\n        return c;\n    }\n\n    const int dy[] = {-1, 0, 1, 0};\n    const int dx[] = {0, 1, 0, -1};\n\n    const int DY[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n    const int DX[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\n    vector< vector<int> > D;\n    void solve() {\n        D.clear(); D.resize(H, vector<int>(W, 1));\n        queue<P> Q;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (F[i][j] == '#') {\n                    D[i][j] = INF;\n                    Q.push(P(i, j, 4));\n                }\n            }\n        }\n        while (!Q.empty()) {\n            P c = Q.front(); Q.pop();\n            for (int i = 0; i < 8; i++) {\n                int ny = c.y + DY[i],\n                    nx = c.x + DX[i];\n                int nd = c.d - 1;\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (D[ny][nx] < nd) {\n                    D[ny][nx] = nd;\n                    Q.push(P(ny, nx, nd));\n                }\n            }\n        }\n\n        int sy, sx;\n        find_pos(sy, sx, 'S');\n\n        map< pair<int, int>, int > M;\n        int N = construct_map(M);\n\n        priority_queue<S> PQ;\n        static int X[1<<5][101][101];\n        for (int i = 0; i < 32; i++) for (int j = 0; j < 100; j++) for (int k = 0; k < 100; k++) {\n            X[i][j][k] = INF;\n        }\n        X[0][sy][sx] = 0;\n        PQ.push(S(0, sy, sx, 0));\n        while (!PQ.empty()) {\n            S c = PQ.top(); PQ.pop();\n            for (int i = 0; i < 4; i++) {\n                int ny = c.y + dy[i],\n                    nx = c.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                int nbit = c.bit;\n                if (F[ny][nx] == 'M') {\n                    nbit |= (1 << M[make_pair(ny, nx)]);\n                }\n                int nd = D[c.y][c.x] + c.d;\n                if (X[nbit][ny][nx] > nd) {\n                    X[nbit][ny][nx] = nd;\n                    PQ.push(S(nbit, ny, nx, nd));\n                }\n            }\n        }\n\n        int gy, gx;\n        find_pos(gy, gx, 'G');\n        cout << X[(1 << N) - 1][gy][gx] << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<cstring>\nusing namespace std;\ntypedef pair<int,int> Pt;\ntypedef pair<Pt,Pt> P;\n#define fr first\n#define sc second\nint h,w,sx,sy,gx,gy,d[]={0,1,0,-1},Time[101][101],cnt;\nbool used[101][101][1<<5];\nint ldx[]={-1,-1,-1,0,1,1,1,-1},ldy[]={-1,0,1,1,1,0,-1,-1};\nint sdx[]={-2,-2,-2,-2,-2,-1,0,1,2,2,2,2,2,1,0,-1};\nint sdy[]={-2,-1,0,1,2,2,2,2,2,1,0,-1,-2,-2,-2,-2};\nchar mas[101][101];\nvoid BAD(int,int);\nint bfs();\nbool judge(int x,int y){ return ((x>=0&&x<h&&y>=0&&y<w)? true : false); }\nint main(){\n  cin >> w >> h;\n  for(int i=0;i<h;i++) for(int j=0;j<w;j++) Time[i][j] = 1;\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> mas[i][j];\n      if(mas[i][j] == 'S') sx = i,sy = j;\n      else if(mas[i][j] == 'G') gx = i,gy = j;\n      else if(mas[i][j] == '#') BAD(i,j);\n      else if(mas[i][j] == 'M') mas[i][j] = cnt++;\n    }\n  }\n  cout << bfs() << endl;\n}\nint bfs(){\n  int mini = 10000000;\n  memset(used,false,sizeof(used));\n  priority_queue<P,vector<P>,greater<P> > que;\n  //時間 場所(x,y) BIT\n  que.push(P(Pt(0,sx),Pt(sy,0)));\n  used[sx][sy][0] = 0;\n  while(!que.empty()){\n    P p = que.top();\n    int t = p.fr.fr,px = p.fr.sc,py = p.sc.fr,BIT = p.sc.sc;\n    que.pop();\n    if(px == gx && py == gy && BIT ==(1<<cnt)-1 )mini = min(mini,t);\n    if(used[px][py][BIT]) continue;\n    used[px][py][BIT] = true;\n    for(int i=0;i<4;i++){\n      int nx = px + d[i],ny = py + d[3-i],bit = BIT;\n      if(!judge(nx,ny)) continue;\n      if(mas[nx][ny] == '#') continue;\n      if(mas[nx][ny]>=0&&mas[nx][ny]<=10) bit |= 1<<mas[nx][ny];\n      que.push(P(Pt(t+Time[nx][ny],nx),Pt(ny,bit)));\n    }\n  }\n  return mini;\n}\nvoid BAD(int x,int y){\n  for(int i=0;i<8;i++){\n    int nx=x+ldx[i],ny=y+ldy[i];\n    if(judge(nx,ny)) Time[nx][ny] = 3;\n  }\n  for(int i=0;i<16;i++){\n    int nx=x+sdx[i],ny=y+sdy[i];\n    if(judge(nx,ny)) Time[nx][ny] = max(Time[nx][ny],2);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, pair<ll, ll> > P3;\n\nconst ll MOD = ll(1e9 + 7);\nconst ll LLINF = LLONG_MAX;\nconst int IINF = INT_MAX;\nconst int MAX_N = int(1e5) + 5;\nconst double EPS = 1e-8;\nint dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define FOR(i, m, n) for (int i = m; i < n; i++)\n\nint h,w,si,sj,gi,gj;\nll cost[105][105];\nll dmin[10][105][105];\nstring s[105];\nvector<P> hole,m;\n\nvoid dijkstra(int i, int j, int k){\n    REP(i,h){\n        fill(dmin[k][i],dmin[k][i]+w,IINF);\n    }\n    dmin[k][i][j] = 0;\n    priority_queue<P3,vector<P3>,greater<P3> > que;\n    que.push({0,{i,j}});\n\n    while(!que.empty()){\n        P3 p = que.top();\n        que.pop();\n        int vi = p.second.first, vj = p.second.second;\n        if(dmin[k][vi][vj] < p.first)continue;\n        REP(t,4){\n            int ni = vi+dy[t], nj = vj+dx[t];\n            if(ni<0||ni>=h)continue;\n            if(nj<0||nj>=w)continue;\n            //cout << dmin[k][ni][nj]  << \" \" << dmin[k][vi][vj] + cost[vi][vj] << endl;\n            if(dmin[k][ni][nj] > dmin[k][vi][vj] + cost[vi][vj]){\n                dmin[k][ni][nj] = dmin[k][vi][vj] + cost[vi][vj];\n                que.push({dmin[k][ni][nj],{ni,nj}});\n            }\n        }\n    }\n}\n\n\nint main() {\n    cin >> w >> h;\n    REP(i,h)cin >> s[i];\n    REP(i,h){\n        REP(j,w){\n            if(s[i][j]=='S'){\n                si = i;\n                sj = j;\n            }\n            if(s[i][j]=='G'){\n                gi = i;\n                gj = j;\n            }\n            if(s[i][j]=='#'){\n                hole.push_back({i,j});\n            }\n            if(s[i][j]=='M'){\n                m.push_back({i,j});\n            }\n        }\n    }\n    REP(i,h){\n        fill(cost[i],cost[i]+w+1,1);\n    }\n    for(auto it:hole){\n        int pi = it.first, pj = it.second;\n        cost[pi][pj] = 99999999;\n        for(int i=-2;i<=2;i++){\n            for(int j=-2;j<=2;j++){\n                int ni = pi+i, nj = pj+j;\n                if(i==0&&j==0)continue;\n                if(ni<0||ni>=h)continue;\n                if(nj<0||nj>=w)continue;\n                if(max(abs(i),abs(j))==2){\n                    cost[ni][nj]=max(cost[ni][nj],2LL);\n                }\n                else{\n                    cost[ni][nj]=max(cost[ni][nj],3LL);\n                }\n            }\n        }\n    }\n    for(auto it:hole){\n        int pi = it.first, pj = it.second;\n        cost[pi][pj] = 99999999;\n    }\n    dijkstra(si,sj,0);\n    REP(i,m.size()){\n        dijkstra(m[i].first,m[i].second,i+1);\n    }\n    dijkstra(gi,gj,m.size()+1);\n    vector<int> ls;\n    REP(i,m.size())ls.push_back(i+1);\n    SORT(ls);\n    ll ans = LLINF;\n    while(1){\n        ll tmp = 0;\n        REP(i,m.size()-1){\n            tmp += dmin[ls[i]][m[ls[i+1]-1].first][m[ls[i+1]-1].second];\n\n        }\n        tmp += dmin[0][m[ls[0]-1].first][m[ls[0]-1].second];\n        tmp += dmin[ls[m.size()-1]][gi][gj];\n        ans = min(ans,tmp);\n        if(!next_permutation(ls.begin(),ls.end()))break;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <iostream>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\ntypedef long long LL;\nint W,H,T[100][101];\nchar room[100][101];\nint dist[10][100][101];\nvector<P> hole,point;\nvoid dijkstra(int p) {\n\tstatic int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\tpriority_queue<PP,vector<PP>,greater<PP> > Q;\n\tQ.push(PP(0,point[p]));\n\tdist[p][point[p].first][point[p].second]=0;\n\twhile(!Q.empty()) {\n\t\tPP pp=Q.top(); Q.pop();\n\t\tif(dist[p][pp.second.first][pp.second.second]<pp.first) continue;\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tint nx=pp.second.first+dx[i],ny=pp.second.second+dy[i];\n\t\t\tif(0>nx||nx>=W||0>ny||ny>=H||room[ny][nx]=='#') continue;\n\t\t\tint nd=pp.first+T[pp.second.first][pp.second.second];\n\t\t\tif(dist[p][nx][ny]>nd) {\n\t\t\t\tdist[p][nx][ny]=nd;\n\t\t\t\tQ.push(PP(nd,P(nx,ny)));\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint sx,sy,gx,gy;\n\tscanf(\"%d %d\",&W,&H);\n\tfor(int i=0;i<H;i++) {\n\t\tscanf(\"%s\",room[i]);\n\t\tfor(int j=0;j<W;j++) {\n\t\t\tT[j][i]=1;\n\t\t\tif(room[i][j]=='#') hole.push_back(P(j,i)),T[j][i]=1<<30;\n\t\t\telse if(room[i][j]=='M') point.push_back(P(j,i));\n\t\t\telse if(room[i][j]=='S') sx=j,sy=i;\n\t\t\telse if(room[i][j]=='G') gx=j,gy=i;\n\t\t}\n\t}\n\tpoint.insert(point.begin(),P(sx,sy));\n\tpoint.push_back(P(gx,gy));\n\tfor(int i=0;i<hole.size();i++) {\n\t\tfor(int dx=-2;dx<=2;dx++) {\n\t\t\tfor(int dy=-2;dy<=2;dy++) {\n\t\t\t\tint nx=hole[i].first+dx;\n\t\t\t\tint ny=hole[i].second+dy;\n\t\t\t\tif(0>nx||nx>=W||0>ny||ny>=H) continue;\n\t\t\t\tint k=max(abs(dx),abs(dy));\n\t\t\t\tif(k==1) {\n\t\t\t\t\tT[nx][ny]=max(T[nx][ny],3);\n\t\t\t\t}else if(k==2) {\n\t\t\t\t\tT[nx][ny]=max(T[nx][ny],2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfill((int*)dist,(int*)(dist+10),1<<30);\n\tfor(int i=0;i<point.size();i++) {\n\t\tdijkstra(i);\n\t}\n\tint perm[]={1,2,3,4,5};\n\tint ans=1<<30;\n\tdo {\n\t\tint sum=0,k=0;\n\t\tfor(int i=0;i<(point.size()-2);i++) {\n\t\t\tint idx=perm[i];\n\t\t\tsum+=dist[k][point[idx].first][point[idx].second];\n\t\t\tk=idx;\n\t\t}\n\t\tsum+=dist[k][point[point.size()-1].first][point[point.size()-1].second];\n\t\tans=min(ans,sum);\n\t}while(next_permutation(perm,perm+(point.size()-2)));\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <cstring>\n#include <algorithm>\n#include <cctype>\n#include <functional>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nchar fl[128][128];\nint tm[128][128];\n\nint main(){\n\tconst int INF = 1000000000;\n\tfill(*tm, *tm + sizeof(tm) / sizeof(int), INF);\n\n\tconst int dx[] = {-1, 0, 1, 0, -1, -1, 1, 1};\n\tconst int dy[] = {0, -1, 0, 1, -1, 1, -1, 1};\n\n\tint h, w;\n\tscanf(\"%d%d\", &w, &h);\n\n\tqueue<int> q;\n\tvector<int> ms(2);\n\tfor(int i = 1; i <= h; ++i){\n\t\tscanf(\" %s\", fl[i] + 1);\n\t\tfor(int j = 1; j <= w; ++j){\n\t\t\tif(fl[i][j] == '#'){\n\t\t\t\tq.push(i << 8 | j);\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttm[i][j] = 1;\n\n\t\t\t\tif(fl[i][j] == 'M'){\n\t\t\t\t\tfl[i][j] = '0' + ms.size();\n\t\t\t\t\tms.push_back(i << 8 | j);\n\t\t\t\t}\n\t\t\t\telse if(fl[i][j] == 'S'){\n\t\t\t\t\tms[0] = i << 8 | j;\n\t\t\t\t\tfl[i][j] = '0';\n\t\t\t\t}\n\t\t\t\telse if(fl[i][j] == 'G'){\n\t\t\t\t\tms[1] = i << 8 | j;\n\t\t\t\t\tfl[i][j] = '1';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tq.push(-1);\n\tint cnt = 3;\n\twhile(cnt > 1){\n\t\tif(q.front() == -1){\n\t\t\t--cnt;\n\t\t\tq.pop();\n\t\t\tq.push(-1);\n\t\t}\n\t\telse{\n\t\t\tint y = q.front() >> 8, x = q.front() & 0xff;\n\t\t\tq.pop();\n\t\t\tfor(int i = 0; i < 8; ++i){\n\t\t\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\t\t\tif(tm[ny][nx] < cnt){\n\t\t\t\t\ttm[ny][nx] = cnt;\n\t\t\t\t\tq.push(ny << 8 | nx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<pii> pq;\n\tvector<vector<int> > ds(ms.size(), vector<int>(ms.size()));\n\tfor(size_t m = 0; m < ms.size(); ++m){\n\t\tvector<int> md(1 << 16, INF);\n\t\tmd[ms[m]] = 0;\n\t\tpq.push(pii(0, ms[m]));\n\t\twhile(!pq.empty()){\n\t\t\tint d = -pq.top().first;\n\t\t\tint ps = pq.top().second;\n\t\t\tpq.pop();\n\t\t\tif(md[ps] != d){ continue; }\n\n\t\t\tint y = ps >> 8, x = ps & 0xff;\n\t\t\tif(isdigit(fl[y][x])){\n\t\t\t\tds[m][fl[y][x] - '0'] = d;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < 4; ++i){\n\t\t\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\t\t\tif(tm[ny][nx] == INF){ continue; }\n\t\t\t\tint nd = d + tm[y][x];\n\t\t\t\tint np = ny << 8 | nx;\n\t\t\t\tif(md[np] > nd){\n\t\t\t\t\tmd[np] = nd;\n\t\t\t\t\tpq.push(pii(-nd, np));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tconst int sz = 1 << ms.size();\n\tvector<vector<int> > dp(ms.size(), vector<int>(sz, INF));\n\tdp[0][1] = 0;\n\tfor(int S = 0; S < sz; ++S){\n\t\tfor(int i = ms.size(); i--; ){\n\t\t\tif(!(S >> i & 1)){ continue; }\n\t\t\tfor(int j = ms.size(); j--; ){\n\t\t\t\tif(S >> j & 1){ continue; }\n\t\t\t\tint &r = dp[j][S | 1 << j];\n\t\t\t\tr = min(r, dp[i][S] + ds[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", dp[1].back());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<deque>\n#include<cstdio>\n#include<climits>\n#include<numeric>\n#include<cassert>\n#include<functional>\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define fi(i,j,k) fill(i[0],i[0]+j*j,k)\n#define INF 1<<27\n#define F first\n#define S second\nstatic const double eps=1e-10;\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w;\nchar cmap[110][110];\nP pos[110];\nint index,matrix[110][110];\nint imap[110][110];\nstatic const int dx[4] = {0,1,0,-1};\nstatic const int dy[4] = {1,0,-1,0};\nstatic const int dx8[8] = {0,1,1,1,0,-1,-1,-1};\nstatic const int dy8[8] = {-1,-1,0,1,1,1,0,-1};\nstatic const int dx16[16] = {0,1,2,2,2,2,2,1,0,-1,-2,-2,-2,-2,-2,-1};\nstatic const int dy16[16] = {-2,-2,-2,-1,0,1,2,2,2,2,2,1,0,-1,-2,-2};\n \nint D[110][110];\nbool used[110][110];\n \nvoid bfs(P s,P g){\n  rep(i,h)rep(j,w){\n    D[i][j] = INF;\n    used[i][j] = false;\n  }\n  queue<P> que;\n  que.push(s);\n  D[s.S][s.F] = 0;\n  used[s.S][s.F] = true;\n \n  while(!que.empty()){\n    P p = que.front(); que.pop();\n \n    for(int i=0;i<4;i++){\n      int nx = p.F+dx[i],ny = p.S+dy[i];\n      if(0<= nx && nx < w && 0<= ny && ny < h && cmap[ny][nx] != '#' && D[ny][nx] > D[p.S][p.F] +imap[ny][nx]){\n    D[ny][nx] = min(D[p.S][p.F] + imap[ny][nx],D[ny][nx]);\n \n    que.push(P(nx,ny));\n      }\n    }\n  }\n}\n \nint main(){\n \n  scanf(\"%d %d\",&w,&h);\n    int sindex,lim = 1;\n    index = 1;\n   \n    rep(i,h)rep(j,w)imap[i][j] = 1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n    \n\tcin >> cmap[i][j];\n    matrix[i][j] = INF;\n    if(cmap[i][j] == 'S'){\n      lim++;\n    }\n    else if(cmap[i][j] == 'M')lim++;\n    else if(cmap[i][j] == 'G'){\n      pos[0] = P(j,i);\n    }\n      }\n    }\n  \n    rep(i,h){\n      rep(j,w){\n       \n    if(cmap[i][j] == 'S'){\n      pos[lim-1] = P(j,i);\n    }\n    else if(cmap[i][j] == 'M'){\n      assert(index != lim-1);\n      pos[index++] = P(j,i);\n    }\n    else if(cmap[i][j] == '#'){\n      for(int k=0;k<8;k++){\n       \n        int nx = j+dx8[k],ny = i+dy8[k];\n        if(0<=nx && nx<w && 0<=ny && ny <h && cmap[ny][nx] != '#'){\n          imap[ny][nx] = 3;\n        }\n      }\n      for(int k=0;k<16;k++){\n        int nx = j+dx16[k],ny = i+dy16[k];\n        if(0<=nx && nx<w && 0<=ny && ny <h && cmap[ny][nx] != '#'){\n          imap[ny][nx] = max(imap[ny][nx],2);\n        }\n      }\n    }\n      }\n    }\n \n \n    index = lim;\n \n    for(int i=0;i<index;i++){\n      rep(j,index){\n     \n    if(i == j){\n      matrix[i][j] = 0;\n      continue;\n    }\n    bfs(pos[i],pos[j]);\n    matrix[i][j] = D[pos[j].S][pos[j].F];\n      }\n    }\n    int per[110];\n    rep(i,index-1)per[i] = i+1;\n \n    int sum;\n    int ans=INF;\n    do{\n      sum=0;\n      sum+=matrix[0][per[0]];\n \n      int posi=-1;    \n      for(int i=1;i<index-1;i++){\n    if(i == index-2)posi = per[i];\n    sum+=matrix[per[i-1]][per[i]];\n      }\n     \n      if(posi != -1 && posi != lim-1)sum += matrix[posi][lim-1];\n     \n      ans=min(ans,sum);\n    }while(next_permutation(per,per+(index-1)));\n    printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx3[4] = {1, 0, -1, 0};\nint dy3[4] = {0, 1, 0, -1};\nint dx[8] = {1, 0, -1, -1, -1, 0, 1, 1};\nint dy[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\nint dx2[16] = {0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1};\nint dy2[16] = {2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2, 2};\nstruct state{\n  int x, y, S;\n  int c;\n  state() {}\n  state(int x, int y, int S, int c) : x(x), y(y), S(S), c(c) {}\n  bool operator < (const state& s) const {\n    return c > s.c; //rev\n  }\n};\n\nint main(){\n  int W, H;\n  while(cin>>W>>H && (W||H)){\n    vector<string> grid(H);\n    REP(y, H) cin>>grid[y];\n    int cnt = 0;\n    REP(y, H)REP(x, W)if(grid[y][x] == 'M'){\n      grid[y][x] = cnt + '0';\n      cnt++;\n    }\n    const int goalS = (1<<cnt) - 1;\n    int move[100][100] = {};\n    REP(y, H)REP(x, W) move[y][x] = 1;\n    REP(y, H)REP(x, W){\n      if(grid[y][x] == '#'){\n        REP(r, 8){\n          int nx = x + dx[r], ny = y + dy[r];\n          if(nx >= 0 && ny >= 0 && nx < W && ny < H){\n            move[ny][nx] = 3;\n          }\n        }\n        REP(r, 16){\n          int nx = x + dx2[r], ny = y + dy2[r];\n          if(nx >= 0 && ny >= 0 && nx < W && ny < H){\n            move[ny][nx] = max(move[ny][nx], 2);\n          }\n        }\n      }\n    }\n    int dist[1<<5][100][100];\n    priority_queue<state> que;\n    REP(y, H)REP(x, W)REP(i, 1<<5)dist[i][y][x] = INF;\n    REP(y, H)REP(x, W)if(grid[y][x] == 'S'){\n      dist[0][y][x] = 0;\n      que.push(state(x, y, 0, 0));\n    }\n    int ans = INF;\n    while(!que.empty()){\n      state s = que.top(); que.pop();\n      if(s.S == goalS && grid[s.y][s.x] == 'G'){\n        ans = s.c;\n        break;\n      }\n      REP(r, 4){\n        int nx = s.x + dx3[r];\n        int ny = s.y + dy3[r];\n        if(!(nx >= 0 && ny >= 0 && nx < W && ny < H)) continue;\n        if(grid[ny][nx] == '#') continue;\n        int nc = s.c + move[s.y][s.x];\n        int nS = s.S;\n        if(grid[ny][nx] <= '5' && grid[ny][nx] >= '0'){\n          nS = nS | (1<<(grid[ny][nx]-'0'));\n        }\n        if(dist[nS][ny][nx] > nc){\n          dist[nS][ny][nx] = nc;\n          que.push(state(nx, ny, nS, nc));\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <numeric>\n#include <queue>\n#include <cstring>\n#include <stdio.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long long ll;\ntypedef vector<ll> vll;\nconst int inf=10000000;\nint H,W,startx,starty,goalx,goaly;\nstring board[105];\nint cost[105][105];\nint d[105][105];\nbool visited[150][105];\nint dx8[]={-1,-1,0,1,1,1,0,-1};\nint dy8[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={0,1,0,-1};\nint dx[]={-1,0,1,0};\n\ntypedef pair<int,int> P;\ntypedef pair<int,pair<int,int> > PP;\n\nvoid costset(int sx,int sy,int times)\n{\n  if(times==2) return;\n  int nowx=sx;\n  int nowy=sy;\n  int cos=3-times;\n  for(int k=0;k<8;k++)\n    {\n      int nx=nowx+dx8[k];\n      int ny=nowy+dy8[k];\n      if(nx<0 || W<=nx || ny<0 || H<=ny) continue;\n      cost[ny][nx]=max(cost[ny][nx],cos);\n      costset(nx,ny,times+1);\n    }\n}\n\nint solve(int sx,int sy,int gx,int gy)\n{\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  d[i][j]=inf;\n\t}\n    }\n  d[sy][sx]=0;\n  priority_queue<PP,vector<PP> ,greater<PP>> p;\n  p.push(PP(0,P(sy,sx)));\n  int nowy,nowx;\n  while(!p.empty())\n    {\n      PP now=p.top();p.pop();\n      nowy=now.second.first;\n      nowx=now.second.second;\n      if(nowx==gx && nowy==gy) break;\n      for(int k=0;k<4;k++)\n\t{\n\t  int ny=nowy+dy[k];\n\t  int nx=nowx+dx[k];\n\t  if(ny<0 || H<=ny || nx<0 || W<=nx || board[ny][nx]=='#') continue;\n\t  if(d[nowy][nowx]+cost[nowy][nowx]>=d[ny][nx]) continue;\n\t  if(d[ny][nx]==inf || d[ny][nx]>d[nowy][nowx]+cost[nowy][nowx])\n\t    {\n\t      d[ny][nx]=d[nowy][nowx]+cost[nowy][nowx];\n\t      p.push(PP(d[ny][nx],P(ny,nx)));\n\t    }\n\t}\n    }\n  return d[gy][gx];\n}\n\nint main(int argc,char const* argv[])\n{\n  int ans=20000000;\n  int scroll=0;\n  int pat=1;\n  int graph[10][10];\n  for(int i=0;i<10;i++)\n    {\n      for(int j=0;j<10;j++)\n\t{\n\t  graph[i][j]=inf;\n\t}\n    }\n  vector<P> route;\n  cin >> W >> H;\n  for(int i=0;i<H;i++)\n    {\n      cin >> board[i];\n    }\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  cost[i][j]=1;\n\t  if(board[i][j]=='M') route.push_back(P(i,j));\n\t  if(board[i][j]=='G') {goaly=i;goalx=j;}\n\t  if(board[i][j]=='S') {starty=i;startx=j;}\n\t}\n    }\n  sort(route.begin(),route.end());\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  if(board[i][j]=='#')\n\t    {\n\t      costset(j,i,0);\n\t    }\n\t  if(board[i][j]=='M')\n\t    {\n\t      scroll++;\n\t    }\n\t}\n    }\n  for(int i=0;i<route.size();i++)\n    {\n      graph[0][i+1]=solve(startx,starty,route[i].second,route[i].first);\n      graph[i+1][6]=solve(route[i].second,route[i].first,goalx,goaly);\t\t\t\t\t      \n      for(int j=0;j<route.size();j++)\n\t{\n\t  if(i==j) continue;\n\t  int stx=route[i].second;\n\t  int sty=route[i].first;\n\t  int gox=route[j].second;\n\t  int goy=route[j].first;\n\t  graph[i+1][j+1]=solve(stx,sty,gox,goy);\n\t  graph[j+1][i+1]=graph[i+1][j+1];\n\t}\n    }\n   vector<int> walk(scroll);\n   iota(walk.begin(),walk.end(),1);\n   do\n     {\n       int tmp=0;\n       int prev=0;\n       int to=0;\n       for(auto x:walk) \n\t {\n\t   to=x;\n\t   tmp+=graph[prev][to];\n\t   prev=x;\n\t }\n       tmp+=graph[to][6];\n       ans=min(ans,tmp);\n     } while(next_permutation(walk.begin(),walk.end()));\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nbool check(int n,int m,int x,int y) {return x>=0&&x<n&&y>=0&&y<m;}\n\nint a[111][111],d[1<<5][111][111];\nmap<P,int> ma;\nint main() {\n  int n,m;\n  cin >> m >> n;\n  string s[n];\n  for(int i=0; i<n; i++) cin >> s[i];\n  priority_queue<PP,vector<PP>,greater<PP> > que;\n  for(int i=0; i<n; i++) {\n    for(int j=0; j<m; j++) {\n      a[i][j]=1;\n      for(int k=0; k<(1<<5); k++) d[k][i][j]=1<<29;\n      if(s[i][j]=='S') {\n        d[0][i][j]=0;\n        que.push(PP(P(0,0),P(i,j)));\n      }\n      if(s[i][j]=='M') {\n        int k=ma.size();\n        ma[P(i,j)]=k;\n      }\n      for(int k=-2; k<=2; k++) {\n        for(int l=-2; l<=2; l++) {\n          int x=i+k,y=j+l;\n          if(!check(n,m,x,y)||s[x][y]!='#') continue;\n          int d=max(abs(i-x),abs(j-y));\n          if(d==1) a[i][j]=max(a[i][j],3);\n          if(d==2) a[i][j]=max(a[i][j],2);\n        }\n      }\n    }\n  }\n  while(!que.empty()) {\n    PP p=que.top();que.pop();\n    int xx=p.second.first,yy=p.second.second,cc=p.first.first,tt=p.first.second;\n    if(s[xx][yy]=='G'&&tt==(1<<ma.size())-1) {\n      cout << d[tt][xx][yy] << endl;\n      return 0;\n    }\n    if(d[tt][xx][yy]<cc) continue;\n    for(int i=0; i<4; i++) {\n      int x=xx+dx[i],y=yy+dy[i];\n      int t=tt;\n      if(!check(n,m,x,y)||s[x][y]=='#') continue;\n      if(s[x][y]=='M') t|=1<<ma[P(x,y)];\n      if(d[t][x][y]<=d[tt][xx][yy]+a[xx][yy]) continue;\n      d[t][x][y]=d[tt][xx][yy]+a[xx][yy];\n      que.push(PP(P(d[t][x][y],t),P(x,y)));\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// tsukasa_diary's programing contest code template\n#include <bits/stdc++.h>\nusing namespace std;\n// define\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define for_rev(i,a,b) for(int i=a;i>=b;--i)\n#define allof(a) a.begin(),a.end()\n#define minit(a,b) memset(a,b,sizeof(a))\n#define size_of(a) (int)a.size()\n// typedef\ntypedef long long lint;\ntypedef double Double;\ntypedef pair<int, int> pii;\n//\ntypedef vector< int > Array;\ntypedef vector< Array > Matrix;\ntypedef vector< Double > DArray;\ntypedef vector< DArray > DMatrix;\ntypedef vector< string > SArray;\ntypedef vector< pii > PArray;\n// popcount\ninline int POPCNT(int _x) { return __builtin_popcount(_x); }\ninline int POPCNT(lint _x) { return __builtin_popcountll(_x); }\n// inf\nconst int iINF = 1L << 30;\nconst lint lINF = 1LL << 60;\n// eps\nDouble EPS = 1e-9;\n// in range\ninline bool in_range(int _v, int _mx, int _mi) { return _mi <= _v && _v < _mx; }\ninline bool in_range(Double _v, Double _mi, Double _mx) { return -EPS < _v - _mi && _v - _mx < EPS; }\ninline bool in_range(int _x, int _y, int _W, int _H) { return 0 <= _x && _x < _W && 0 <= _y && _y < _H; }\n// neighbor clockwise\nconst int DX[4] = {0,1,0,-1}, DY[4] = {-1,0,1,0};\nconst int DX_[8] = {0,1,1,1,0,-1,-1,-1}, DY_[8] = {-1,-1,0,1,1,1,0,-1};\n\nstruct State {\n\tint x, y, c;\n\tState(int _x, int _y, int _c) : x(_x), y(_y), c(_c) {}\n};\n\nbool operator > (const State& a, const State& b) { return a.c > b.c; }\n\nint W, H;\nstring grid[110];\n\nint sx, sy, gx, gy;\nPArray mvec;\nint c_grid[110][110];\n\nint cost[110][110];\n\nint cost_bet(int stx, int sty, int glx, int gly) {\n\tfor_(i,0,110) fill(cost[i], cost[i] + 110, iINF);\n\tpriority_queue< State, vector< State >, greater< State> > q;\n\tq.push(State(stx, sty, 0));\n\tcost[sty][stx] = 0;\n\t\n\twhile (!q.empty()) {\n\t\tState s = q.top(); q.pop();\n\t\t\n\t\tif (cost[s.y][s.x] < s.c) continue;\n\t\t\n\t\tif (s.x == glx && s.y == gly) return s.c;\n\t\t\n\t\tfor_(d,0,4) {\n\t\t\tint nx = s.x + DX[d], ny = s.y + DY[d];\n\t\t\tif (!in_range(nx, ny, W, H)) continue;\n\t\t\tif (grid[ny][nx] == '#') continue;\n\t\t\t\n\t\t\tint adc = c_grid[s.y][s.x];\n\t\t\tif (cost[ny][nx] > s.c + adc) {\n\t\t\t\tcost[ny][nx] = s.c + adc;\n\t\t\t\tq.push(State(nx, ny, s.c + adc));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn cost[gly][glx];\n}\n\nvoid calc_cost(int hx, int hy) {\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tint v = 4 - max( abs(hx - x), abs(hy - y) );\n\t\tv = max(v, 1);\n\t\tc_grid[y][x] = max(c_grid[y][x], v);\n\t}\n}\n\nint poyo[10][10];\n\nvoid solve() {\n\tfor_(y,0,H) for_(x,0,W) c_grid[y][x] = 1;\n\t\n\tmvec.clear();\n\tfor_(y,0,H) for_(x,0,W) {\n\t\tif (grid[y][x] == '#') calc_cost(x, y);\n\t\tif (grid[y][x] == 'M') mvec.push_back(pii(x, y));\n\t\tif (grid[y][x] == 'S') sx = x, sy = y;\n\t\tif (grid[y][x] == 'G') gx = x, gy = y;\n\t}\n\t\n\tint SS = 5, GG = 6;\n\t\n\tint m_size = size_of(mvec);\n\tfor_(i,0,m_size) {\n\t\tpii p = mvec[i];\n\t\t\n\t\tpoyo[SS][i] = cost_bet(sx, sy, p.first, p.second);\n\t\tpoyo[i][GG] = cost_bet(p.first, p.second, gx, gy);\n\t\t\n\t\tfor_(j,0,m_size) {\n\t\t\tpii pp = mvec[j];\n\t\t\tpoyo[i][j] = cost_bet(p.first, p.second, pp.first, pp.second);\n\t\t}\n\t}\n\t\n\tvector< int > perm(m_size, 0);\n\tfor_(i,0,m_size) perm[i] = i;\n\t\n\tint ans = iINF;\n\t\n\tdo {\n\t\tint pans = poyo[SS][ perm[0] ] + poyo[ perm[m_size - 1] ][GG];\n\t\tfor_(i,0,m_size - 1) pans += poyo[ perm[i] ][ perm[i + 1] ];\n\t\tans = min(ans, pans);\n\t} while (next_permutation(allof(perm)));\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin >> W >> H;\n\t\n\tfor_(i,0,H) cin >> grid[i];\n\t\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <cctype>\n#include <functional>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main(){\n\tint INF = (int)1e9;\n\n\tvector<vector<char> > field(108, vector<char>(108, '#') );\n\tvector<vector<int> > tm(108, vector<int>(108, 1) );\n\n\tint w, h;\n\tscanf(\"%d%d\", &w, &h);\n\tfor(int i = 0; i < h; ++i){\n\t\tscanf(\" %s\", &field[i + 3][3]);\n\t\tfield[i + 3][w + 3] = '#';\n\t}\n\n\tvector<pii> roll(2);\n\n\tqueue<pii> q;\n\tfor(int i = 3; i < h + 3; ++i){\n\t\tfor(int j = 3; j < w + 3; ++j){\n\t\t\tswitch( field[i][j] ){\n\t\t\t\tcase '#':\n\t\t\t\t\tfor(int y = i - 2; y <= i + 2; ++y)\n\t\t\t\t\tfor(int x = j - 2; x <= j + 2; ++x){\n\t\t\t\t\t\tint t = 4 - max(abs(y - i), abs(x - j));\n\t\t\t\t\t\ttm[y][x] = max(tm[y][x], t);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\troll[1] = pii(i, j);\n\t\t\t\t\tfield[i][j] = '1';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'G':\n\t\t\t\t\troll[0] = pii(i, j);\n\t\t\t\t\tfield[i][j] = '0';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\tfield[i][j] = '0' + roll.size();\n\t\t\t\t\troll.push_back( pii(i, j) );\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tint n = roll.size();\n\tvector<vector<int> > dist(n, vector<int>(n, INF) );\n\t\n\tfor(int i = 1; i < n; ++i){\n\t\tvector<vector<int> > d(102, vector<int>(102, INF) );\n\t\td[roll[i].first][roll[i].second] = 0;\n\t\t\n\t\tpriority_queue<pii,vector<pii>,greater<pii> > pq;\n\t\tpq.push( pii(0, roll[i].first * 1000 + roll[i].second) );\n\t\t\n\t\twhile( !pq.empty() ){\n\t\t\tpii p = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tint y = p.second / 1000;\n\t\t\tint x = p.second % 1000;\n\n\t\t\tif( isdigit( field[y][x] ) ){\n\t\t\t\tdist[i][field[y][x] - '0'] = p.first;\n\t\t\t}\n\n\t\t\tint c = p.first + tm[y][x];\n\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\tint ny = y + dy[j];\n\t\t\t\tint nx = x + dx[j];\n\t\t\t\t\n\t\t\t\tif( field[ny][nx] != '#' && d[ny][nx] > c ){\n\t\t\t\t\td[ny][nx] = c;\n\t\t\t\t\tpq.push( pii(c, ny * 1000 + nx) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tint last = 1 << n;\n\tvector<vector<int> > dp(n, vector<int>(last, INF) );\n\tdp[1][2] = 0;\n\n\tfor(int S = 0; S < last; ++S){\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif( S & 1 << i ){\n\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\tif( !(S & 1 << j) ){\n\t\t\t\t\t\tint next = S | 1 << j;\n\t\t\t\t\t\tdp[j][next] = min(dp[j][next], dp[i][S] + dist[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dp[0].back());\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Hole{\n\tint row,col;\n};\n\nstruct Info{\n\tInfo(int arg_row,int arg_col,int arg_state,int arg_total_cost){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\tstate = arg_state;\n\t\ttotal_cost = arg_total_cost;\n\t}\n\n\tint row,col,state,total_cost;\n};\n\nint H,W;\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tint POW[6];\n\n\tfor(int i = 0; i < 6; i++)POW[i] = pow(2,i);\n\n\tscanf(\"%d %d\",&W,&H);\n\n\tchar map[H][W+1];\n\n\tint hole_num = 0;\n\tHole hole[10000];\n\n\tint makimono_num = 0;\n\n\tint start_row,start_col,goal_row,goal_col;\n\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tswitch(map[i][k]){\n\t\t\tcase 'S':\n\t\t\t\tstart_row = i;\n\t\t\t\tstart_col = k;\n\t\t\t\tmap[i][k] = '.';\n\t\t\t\tbreak;\n\t\t\tcase 'G':\n\t\t\t\tgoal_row = i;\n\t\t\t\tgoal_col = k;\n\t\t\t\tmap[i][k] = '.';\n\t\t\t\tbreak;\n\t\t\tcase 'M':\n\t\t\t\tmap[i][k] = '0' + makimono_num;\n\t\t\t\tmakimono_num++;\n\t\t\t\tbreak;\n\t\t\tcase '#':\n\t\t\t\thole[hole_num].row = i;\n\t\t\t\thole[hole_num].col = k;\n\t\t\t\thole_num++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tint move_cost[H][W];\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++)move_cost[i][k] = 1;\n\t}\n\n\tfor(int i = 0; i < hole_num; i++){\n\t\tfor(int row = 0; row < H; row++){\n\t\t\tfor(int col = 0; col < W; col++){\n\t\t\t\tif(map[row][col] == '#')continue;\n\t\t\t\tmove_cost[row][col] = max(move_cost[row][col],4-max(abs(hole[i].row-row),abs(hole[i].col-col)));\n\t\t\t}\n\t\t}\n\t}\n\n\tint limit = POW[makimono_num];\n\n\tint dp[H][W][limit];\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 0; col < W; col++){\n\t\t\tfor(int state = 0; state < limit; state++)dp[row][col][state] = BIG_NUM;\n\t\t}\n\t}\n\n\tqueue<Info> Q;\n\n\tQ.push(Info(start_row,start_col,0,0));\n\n\tint next_row,next_col,next_state;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().state == limit-1 && Q.front().row == goal_row && Q.front().col == goal_col){\n\t\t\tQ.pop();\n\t\t}else if(Q.front().total_cost > dp[Q.front().row][Q.front().col][Q.front().state]){\n\t\t\tQ.pop();\n\t\t}else{\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tnext_row = Q.front().row + diff_row[i];\n\t\t\t\tnext_col = Q.front().col + diff_col[i];\n\n\t\t\t\tif(rangeCheck(next_row,next_col) == false || map[next_row][next_col] == '#')continue;\n\n\t\t\t\tnext_state = Q.front().state;\n\t\t\t\tif(map[next_row][next_col] >= '0' && map[next_row][next_col] <= '4'){\n\t\t\t\t\tif(!(Q.front().state & (1 << (map[next_row][next_col]-'0')))){\n\t\t\t\t\t\tnext_state += POW[map[next_row][next_col]-'0'];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(dp[next_row][next_col][next_state] > Q.front().total_cost+move_cost[Q.front().row][Q.front().col]){\n\t\t\t\t\tdp[next_row][next_col][next_state] = Q.front().total_cost+move_cost[Q.front().row][Q.front().col];\n\t\t\t\t\tQ.push(Info(next_row,next_col,next_state,dp[next_row][next_col][next_state]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",dp[goal_row][goal_col][limit-1]);\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n#define INF 1<<25\nusing namespace std;\nstring s[101];\ntypedef pair<int,int> P;\nint w,h,a[101][101],sx,sy,gx,gy;\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nint dx1[]={1,1,1,0,0,-1,-1,-1};\nint dy1[]={1,0,-1,1,-1,1,0,-1};\nint dx2[]={2,2,2,2,2,1,1,0,0,-1,-1,-2,-2,-2,-2,-2};\nint dy2[]={2,1,0,-1,-2,2,-2,2,-2,2,-2,2,1,0,-1,-2};\nvector<P>G[10001];\nvector<int>maki;\nvoid make_map(int y,int x){\n  a[y][x]=INF;\n  r(i,8){\n    int xx=x+dx1[i];\n    int yy=y+dy1[i];\n    if(xx<0||yy<0||yy>=h||xx>=w)continue;\n    if(a[yy][xx]<3)a[yy][xx]=3;\n  }\n  r(i,16){\n    int xx=x+dx2[i];\n    int yy=y+dy2[i];\n    if(xx<0||yy<0||yy>=h||xx>=w)continue;\n    if(a[yy][xx]<2)a[yy][xx]=2;\n  }\n}\nint d[10001];\nvoid dijkstra(int s){\n  priority_queue<P,vector<P>,greater<P> >que;\n  fill(d,d+10001,INF);\n  d[s]=0;\n  que.push(P(0,s));\n  while(!que.empty()){\n    P p=que.top();que.pop();\n    int v=p.second;\n    if(d[v]<p.first)continue;\n    for(int i=0;i<G[v].size();i++){\n      P e=G[v][i];\n      if(d[e.first]>d[v]+e.second){\n        d[e.first]=d[v]+e.second;\n        que.push(P(d[e.first],e.first));\n      }\n    }\n  }\n}\nint ans=INF,used[101]={},koko;\nint dis[101][101];\nvoid dfs(int depth,int dista,int cur){\n  if(depth==koko-1){\n    //cout<<dista<<endl;\n    ans=min(ans,dista);\n    return;\n  }\n  if(depth<koko-2){\n    for(int i=1;i<koko-1;i++)\n      if(!used[i]){\n      used[i]=1;\n      dfs(depth+1,dista+dis[cur][i],i);\n      used[i]=0;\n    }\n  }\n  else{\n    used[cur]=1;\n    dfs(depth+1,dista+dis[cur][koko-1],cur);\n    used[cur]=0;\n  }\n}\nmain(){\n  r(i,101)r(j,101)a[i][j]=1;\n  cin>>w>>h;\n  r(i,h)cin>>s[i];\n  r(i,h)r(j,w){\n    if(s[i][j]=='#')make_map(i,j);\n    if(s[i][j]=='S')sx=i*w+j;\n    if(s[i][j]=='G')gx=i*w+j;\n    if(s[i][j]=='M')maki.push_back(i*w+j);\n  }\n  r(i,h)r(j,w)r(k,4){\n    int xx=j+dx[k];\n    int yy=i+dy[k];\n    if(xx<0||yy<0||yy>=h||xx>=w)continue;\n    if(k==0)G[i*w+j].push_back(P(i*w+j+1,a[i][j]));\n    if(k==1)G[i*w+j].push_back(P(i*w+j-1,a[i][j]));\n    if(k==2)G[i*w+j].push_back(P(i*w+w+j,a[i][j]));\n    if(k==3)G[i*w+j].push_back(P(i*w-w+j,a[i][j]));\n  }\n  int num=maki.size()+2;\n  vector<int>ps;\n  ps.push_back(sx);\n  r(i,maki.size())ps.push_back(maki[i]);\n  ps.push_back(gx);\n  r(i,num){\n    dijkstra(ps[i]);\n    r(j,num)dis[i][j]=d[ps[j]];\n  }\n  koko=num;\n  used[0]=1;\n  dfs(0,0,0);\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\nusing namespace std;\nint w,h,p;\nchar f[111][111];\nint c[111][111];\nint d[111][111];\nint mx[11],my[111];\nint e[11][11];\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nint dp[11][1<<6];\nint solve(int n,int bit){\n  if(bit == (1<<p)-1){\n    return e[n][p];\n  }\n  if(dp[n][bit]) return dp[n][bit];\n  \n  int res = 1<<28;\n  for(int i = 1; i < p; i++){\n    if(bit & 1<<i) continue;\n    res = min(res,solve(i,bit | 1<<i) + e[n][i]);\n  }\n  return dp[n][bit] = res;\n}\n\nint main(void){\n  cin >> w >> h;\n  p = 1;\n  int gx,gy;\n  queue< pair<int,int> > que;\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      c[j][i] = 1;\n      cin >> f[j][i];\n      switch(f[j][i]){\n      case 'S': f[j][i] = '0'; mx[0] = j; my[0] = i; break;\n      case 'M': f[j][i] = p + '0'; mx[p] = j; my[p] = i; p++; break;\n      case 'G': gx = j; gy = i; break;\n      case '#': que.push( make_pair(j,i) ); break;\n      }\n    }\n  }\n  mx[p] = gx; \n  my[p] = gy; \n  f[gx][gy] = '0' + p;\n\n  while(!que.empty()){\n    int x = que.front().first;\n    int y = que.front().second;\n    que.pop();\n    for(int i = x - 2; i <= x + 2; i++){\n      for(int j = y - 2; j <= y + 2; j++){\n\tc[i][j] = max(c[i][j],4-max(abs(x-i),abs(y-j)));\n      }\n    }\n  }\n\n  for(int i = 0; i < p; i++){\n    priority_queue< pair<int, pair<int,int> >,vector< pair<int, pair<int,int> > >,\n\t\t    greater< pair<int, pair<int,int> > > > pque;\n    for(int j = 0; j < w; j++) fill(d[j],d[j]+h,1<<28);\n    d[mx[i]][my[i]] = 0;\n    pque.push( make_pair(0,make_pair(mx[i],my[i])) );\n    while(!pque.empty()){\n      int l = pque.top().first;\n      int x = pque.top().second.first;\n      int y = pque.top().second.second;\n      pque.pop();\n      if(d[x][y] < l) continue;\n      for(int j = 0; j < 4; j++){\n\tint nx = x + dx[j];\n\tint ny = y + dy[j];\n\tif(nx < 0 || w <= nx || ny < 0 || h <= ny || c[x][y] > 3 || d[nx][ny] <= d[x][y]+c[x][y]) continue;\n\td[nx][ny] = d[x][y] + c[x][y];\n\tpque.push( make_pair(d[nx][ny],make_pair(nx,ny)) );\n      }\n    }\n    for(int j = 0; j <= p; j++){\n      e[i][j] = d[mx[j]][my[j]];\n    }\n  }\n  memset(dp,0,sizeof(dp));\n  cout << solve(0,1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 100000\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<P,int> PI;\ntypedef pair<int,P> IP;\n\nconst int dy[4] = { -1, 0, 1, 0 };\nconst int dx[4] = {  0, 1, 0,-1 };\nconst int MAX_H = 100;\nconst int MAX_W = 100;\nconst int MAX_M = 5;\t\t// 巻物の最大数\nint H, W;\nchar f[MAX_H+1][MAX_W+1];\t// フィールド\nint  t[MAX_H+1][MAX_W+1];\t// フィールドを移動する時間、穴が近くにあると遅くなる\nint vis[MAX_H+1][MAX_W+1];\t// bfs 探索用\n\nint from_s[MAX_M+1], to_g[MAX_M+1], m2m[MAX_M+1][MAX_M+1]; // S から各巻物への距離、Gから各巻物への距離、各巻物の間の距離\n\nvoid output (void ){\n\t\n\trep (i, H ){\n\t\trep (j, W ){\n\t\t\tcout << f[i][j];\n\t\t} // end rep\n\t\tcout << endl;\n\t} // end rep\t\n}\nvoid output2 (void ){\n\t\n\trep (i, H ){\n\t\trep (j, W ){\n\t\t\tcout << (t[i][j] == -1 ? 4 : t[i][j] );\n\t\t} // end rep\n\t\tcout << endl;\n\t} // end rep\t\n}\n\nint bfs (int sx, int sy, int ex, int ey ){\n\n\tpriority_queue<IP, vector<IP>, greater<IP> > que;\n\tque.push (IP(0, P (sy, sx) ) );\n\tmemset (vis, -1, sizeof (vis ) );\n\tvis[sy][sx] = 0;\n\n\twhile (!que.empty() ){\n\t\tIP cur = que.top(); que.pop();\n\t\tint cn = cur.first;\n\t\tint cy = cur.second.first;\n\t\tint cx = cur.second.second;\n\t\tif (ex == cx && ey == cy ) return cn;\n\n\t\trep (k, 4 ){\n\t\t\tint ny = cy + dy[k];\n\t\t\tint nx = cx + dx[k];\n\t\t\tif (ny < 0 || ny >= H || nx < 0 || nx >= W || f[ny][nx] == '#' ) continue;\n\t\t\tif (vis[ny][nx] == -1 || vis[ny][nx] > cn + t[cy][cx] ){\n\t\t\t\tvis[ny][nx] = cn + t[cy][cx];\n\t\t\t\tque.push (IP(cn + t[cy][cx], P (ny, nx ) ) );\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end while\t\n\n\treturn INF;\n}\t\n\n\nint main()\n{\n\tmemset (f, 0, sizeof (f ) );\n\tmemset (from_s, 0, sizeof (from_s ) );\n\tmemset (to_g, 0, sizeof (to_g ) );\n\tfill (t[0], t[0] + MAX_H*MAX_W+1, 1 );\n\tfill (m2m[0], m2m[0] + MAX_M*MAX_M+1, INF );\n\tios_base::sync_with_stdio(0);\n\tcin >> W >> H;\n\trep (i, H ) rep (j, W ) cin >> f[i][j];\n\t\n\tint sx, sy, ex, ey;\t\t// S, G の位置\n\tvector<P> m; m.clear();\t// 巻物の位置\n\tvector<P> hole; hole.clear();\t// 穴の位置\n\trep (i, H ) rep (j, W ){\n\t\tif (f[i][j] == 'S' ) sy = i, sx = j;\n\t\tif (f[i][j] == 'G' ) ey = i, ex = j;\n\t\tif (f[i][j] == 'M' ) m.push_back (P (j, i ) );\n\t\tif (f[i][j] == '#' ) hole.push_back (P (i, j ) );\n\t} // end rep\t\n\t// 移動時間のマップを作成\n\trep (k, hole.size() ){\n\t\tint i = hole[k].first;\n\t\tint j = hole[k].second;\n\t\tfor (int row = max (i-2, 0 ); row <= min (i+2, H-1); row++ ){\n\t\t\tfor (int col = max (j-2, 0 ); col <= min (j+2, W-1 ); col++ ){\n\t\t\t\tif (row == i && col == j ){\n\t\t\t\t\tcontinue;\n\t\t\t\t} // end if\n\t\t\t\tt[row][col] = max (t[row][col], 2 );\n\t\t\t} // end for\n\t\t} // end for\n\t\tfor (int row = max (i-1, 0 ); row <= min (i+1, H-1); row++ ){\n\t\t\tfor (int col = max (j-1, 0 ); col <= min (j+1, W-1 ); col++ ){\n\t\t\t\tif (row == i && col == j ){\n\t\t\t\t\tcontinue;\n\t\t\t\t} // end if\n\t\t\t\tt[row][col] = max (t[row][col], 3 );\n\t\t\t} // end for\n\t\t} // end for\n\t} // end rep\t\n\trep (k, hole.size() ){\n\t\tint i = hole[k].first;\n\t\tint j = hole[k].second;\n\t\tt[i][j] = -1;\n\t} // end rep\n#if DEBUG\n\toutput ();\n\toutput2 ();\n#endif\n\t// S から 各巻物までの最短距離を求める\n\trep (i, m.size() ){\n\t\tfrom_s[i] = bfs (sx, sy, m[i].first, m[i].second );\n\t\tto_g[i]   = bfs (m[i].first, m[i].second, ex, ey );\n\t} // end rep\n\n\t// 各巻物間の最短距離を求める\n\tif (m.size() != 1 ){\n\t\trep (i, m.size() ){\n\t\t\trep (j, m.size() ){\n\t\t\t\tif (i == j ) continue;\n\t\t\t\tm2m[i][j] = bfs (m[i].first, m[i].second, m[j].first, m[j].second );\n\t\t\t\tm2m[j][i] = bfs (m[j].first, m[j].second, m[i].first, m[i].second );\n\t\t\t} // end rep\n\t\t} // end rep\n\t} // end if\n\t\n\tint res = INF;\n\tvector<int> a(m.size(), 0 );\n\trep (i, m.size() ) a[i] = i;\n\tdo{\n\t\tint curr = from_s[a[0]];\n\t\trep (i, m.size()-1 ){\n\t\t\tcurr += m2m[a[i]][a[i+1]];\n\t\t} // end rep\n\t\tcurr += to_g[a[m.size()-1]];\n\t\tres = min (res, curr );\n\t}while (next_permutation (ALL (a ) ) );\n\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\nconst int INF = (1<<25);\nconst int MAX = 100;\n\nstruct State{\n  int t,come,x,y;\n  State(){}\n  State(int t, int come, int x, int y):t(t),come(come),x(x),y(y){}\n  bool operator < (const State& s) const { return t > s.t;}\n};\ntypedef pair<int,int> P;\n\nint F[5][5] = {{2,2,2,2,2},\n\t       {2,3,3,3,2},\n\t       {2,3,INF,3,2},\n\t       {2,3,3,3,2},\n\t       {2,2,2,2,2}};\n\nint T[(1<<5)][MAX][MAX];\nchar M[MAX][MAX];\nint E[MAX][MAX];\nint w,h;\nint sx,sy,gx,gy;\nvector<P> V;\n\nbool isInside(int x, int y){return 0<=x&&x<w&&0<=y&&y<h;}\n\nvoid hole(int y, int x){\n  \n  for(int i = y-2; i <= y+2; i++)\n    for(int j = x-2; j <= x+2; j++)\n      if(isInside(j,i)) E[i][j] = max(E[i][j],F[i-y+2][j-x+2]);\n}\n\nvoid init(){\n  fill(T[0][0],T[0][0]+(1<<5)*MAX*MAX,INF);\n  for(int i = 0; i < MAX; i++) for(int j = 0; j < MAX; j++) E[i][j] = 1;\n}\n\nvoid input(){\n  cin >> w >> h;\n\n  for(int i = 0; i < h; i++)\n    for(int j = 0; j < w; j++){\n      cin >> M[i][j];\n      if(M[i][j] == 'S') sx=j,sy=i;\n      if(M[i][j] == 'G') gx=j,gy=i;\n      if(M[i][j] == 'M') V.push_back(P(i,j));\n      if(M[i][j] == '#') hole(i,j);\n    }\n}\n\nint getNum(int x, int y){\n  for(int i = 0; i < (int)V.size(); i++)\n    if(V[i].first == y && V[i].second == x) return i;\n  return -1;\n}\n\nvoid solve(){\n  \n  int dx[] = {1,-1,0,0};\n  int dy[] = {0,0,1,-1};\n  priority_queue<State> Q;\n  Q.push(State(0,0,sx,sy));\n  T[0][sy][sx] = 0;\n  \n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n    \n    for(int i = 0; i < 4; i++){\n      State nex = now;\n      nex.x += dx[i];\n      nex.y += dy[i];\n      nex.t += E[now.y][now.x];\n      if(!isInside(nex.x,nex.y)) continue;\n      \n      if(M[nex.y][nex.x] == 'M'){\n\tint num = getNum(nex.x,nex.y);\n\tnex.come |= (1<<num);\n      }\n\n      if(T[nex.come][nex.y][nex.x] > nex.t){\n\tT[nex.come][nex.y][nex.x] = nex.t;\n\tQ.push(nex);\n      }\n    }\n  }\n  cout << T[(1<<V.size())-1][gy][gx] << endl;\n}\n\n\nint main(){\n  init();\n  input();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<queue>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\n#define Y first\n#define X second\ntypedef pair<int,int> Point;\n\nstruct T{\n  int cost,scroll,y,x;\n  T(){}\n  T(int a, int b, int c, int d){cost=a;scroll=b;y=c;x=d;}\n};\nbool operator<(T a, T b){\n  if(a.cost!=b.cost)return a.cost<b.cost;\n  if(a.scroll!=b.scroll)return a.scroll>b.scroll;\n  if(a.y!=b.y)return a.y>b.y;\n  if(a.x!=b.x)return a.x>b.x;\n  return true;\n}\nbool operator==(T a, T b){\n  if(a.cost!=b.cost)return false;\n  if(a.scroll!=b.scroll)return false;\n  if(a.y!=b.y)return false;\n  if(a.x!=b.x)return false;\n  return true;\n}\n\nbool range(int x, int first, int last){return first<=x && x<=last;}\nint bitcount(int n){return n?(n&1)+bitcount(n>>1):0;}\n\nint main()\n{\n  int W, H;\n  string line;\n  Point start, goal;\n  vector<Point> scroll, holl;\n\n  cin>>W>>H;\n\n  vector< vector<int> > field(H, vector<int>(W, 1) );\n\n  for(int i=0; i<H; i++){\n    cin>>line;\n    for(int j=0; j<W; j++){\n      switch(line[j]){\n      case 'S':\n        start = Point(i,j);\n        break;\n      case 'G':\n        goal = Point(i,j);\n        break;\n      case 'M':\n        scroll.push_back( Point(i,j) );\n        break;\n      case '#':\n        holl.push_back( Point(i,j) );\n        for(int dy=-2; dy<=2; dy++){\n          for(int dx=-2; dx<=2; dx++){\n            int y=i+dy, x=j+dx;\n            if(!range(y,0,H-1))continue;\n            if(!range(x,0,W-1))continue;\n            if(dy==-2 || dy==2 || dx==-2 || dx==2)field[y][x]=max(2,field[y][x]);\n            else field[y][x]=3;\n          }\n        }\n        break;\n      case '.':\n        break;\n      default:\n        break;\n      }\n    }\n  }\n\n  int ans;\n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n  vector<T> visited;\n  priority_queue<T> q;\n  q.push( T(0, 0, start.Y, start.X) );\n  while(!q.empty()){\n    T now = q.top();\n    q.pop();\n\n    T v=now;\n    v.cost=0;\n    if(count(visited.begin(),visited.end(),v))continue;\n    visited.push_back(v);\n\n    if(now.y==goal.Y && now.x==goal.X){\n      if( bitcount(now.scroll) == scroll.size() ){\n        ans=-now.cost;\n        break;\n      }\n    }\n    for(int j=0; j<scroll.size(); j++){\n      if(now.y==scroll[j].Y && now.x==scroll[j].X){\n        if( (now.scroll>>j)&1 ){\n          break;\n        }else{\n          now.scroll ^= (1<<j);\n        }\n      }\n    }\n\n    bool ok=true;\n    for(int j=0; j<holl.size(); j++){\n      if(now.y==holl[j].Y && now.x==holl[j].X)ok=false;\n    }\n    if(!ok)continue;\n\n    for(int i=0; i<4; i++){\n      int y=now.y+dy[i], x=now.x+dx[i];\n      if(!range(y,0,H-1))continue;\n      if(!range(x,0,W-1))continue;\n      q.push( T(now.cost-field[now.y][now.x], now.scroll, y, x) );\n    }\n  }\n\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<climits>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<set>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\ntypedef pair<int,P> PP;\nint W,H,p[20][2],m=1,C[105][105],mv[5]={0,-1,0,1,0},G[2],T[20][9];\nchar M[105][105];\n\nvoid dbg()\n{\n\tfor(int i=0;i<H;i++,puts(\"\"))\n\t\tfor(int j=0;j<W;j++)\n\t\t\tprintf(\"%d \",C[i][j]);\n}\n\nint bfs(int sy,int sx,int gy,int gx)\n{\n\tint c[105][105]={0};\n\tmemset(c,0x7f,sizeof(c));\n\tpriority_queue<PP,vector<PP>,greater<PP> >Q;\n\tQ.push(make_pair(0,make_pair(sy,sx)));\n\tfor(;!Q.empty();)\n\t{\n\t\tPP tmp=Q.top();Q.pop();\n\t\tif(tmp.second.first==gy&&tmp.second.second==gx)\n\t\t\treturn tmp.first;\n\t\tif(tmp.first>c[tmp.second.first][tmp.second.second])\n\t\t\tcontinue;\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tint ny=tmp.second.first+mv[i];\n\t\t\tint nx=tmp.second.second+mv[i+1];\n\t\t\tif(M[ny][nx]=='#'||ny<0||ny>=H||nx<0||nx>=W)continue;\n\t\t\tif(tmp.first+C[tmp.second.first][tmp.second.second]<=c[ny][nx])\n\t\t\t{\n\t\t\t\tc[ny][nx]=tmp.first+C[tmp.second.first][tmp.second.second];\n\t\t\t\tQ.push(make_pair(tmp.first+C[tmp.second.first][tmp.second.second],make_pair(ny,nx)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d%d\\n\",&W,&H);\n\tfor(int i=0;i<H;i++)\n\t\tfor(int j=0;j<W;j++)\n\t\t\tC[i][j]=1;\n\tfor(int i=0;i<H;i++)gets(M[i]);\n\tfor(int i=0;i<H;i++)\n\t\tfor(int j=0;j<W;j++)\n\t\t{\n\t\t\tif(M[i][j]=='S')\n\t\t\t\tp[0][0]=i,p[0][1]=j,M[i][j]='.';\n\t\t\telse if(M[i][j]=='G')\n\t\t\t\tG[0]=i,G[1]=j,M[i][j]='.';\n\t\t\telse if(M[i][j]=='M')\n\t\t\t{\n\t\t\t\tp[m][0]=i,p[m][1]=j,M[i][j]='.';\n\t\t\t\tm++;\n\t\t\t}\n\t\t\telse if(M[i][j]=='#')\n\t\t\t{\n\t\t\t\tfor(int h=max(0,i-2);h<min(H,i+3);h++)\n\t\t\t\t\tfor(int w=max(0,j-2);w<min(W,j+3);w++)\n\t\t\t\t\t\tC[h][w]=max(4-max(abs(i-h),abs(j-w)),C[h][w]);\n\t\t\t}\n\t\t}\n\tp[m][0]=G[0];\n\tp[m][1]=G[1];\n\tfor(int i=0;i<=m;i++)\n\t\tfor(int j=0;j<=m;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\tT[i][j]=bfs(p[i][0],p[i][1],p[j][0],p[j][1]);\n\t\t}\n\tint route[100],res=1000000000;\n\tif(m==1)\n\t{\n\t\tres=T[0][1];\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<=m;i++)\n\t\t\troute[i]=i;\n\t\tdo\n\t\t{\n\t\t\tint tmp=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t\ttmp+=T[route[i]][route[i+1]];\n\t\t\tres=min(res,tmp);\n\t\t}while(next_permutation(route+1,route+m));\n\t}\n\tprintf(\"%d\\n\",res);\n\t//dbg();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> S;\n\nint w, h;\nP s, g;\nvector<P> m, a;\nchar c;\nint data[100][100], dy[] = {-1, 0, 1, 0, -1, 1, 1, -1}, dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nvoid dfs(int y, int x, int d){\n  if(d != 0) data[y][x] = 4 - d;\n  if(d < 2){\n    for(int i=0;i<8;i++){\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n      if(ny < 0 || ny >= h) continue;\n      if(nx < 0 || nx >= w) continue;\n      if(data[ny][nx] == -1) continue;\n      if(data[ny][nx] > 4 - (d + 1)) continue;\n      dfs(ny, nx, d + 1);\n    }\n  }\n}\n\nint dijkstra(){\n  int cost[100][100][1<<5];\n  fill(cost[0][0], cost[100][0], 100000000);\n  cost[s.first][s.second][0] = 0;\n  priority_queue<S> q;\n  S u = S(0, P(0, s.first * w + s.second));\n  q.push(u);\n  while(!q.empty()){\n    u = q.top();\n    q.pop();\n    if(cost[u.second.second/w][u.second.second%w][u.second.first] < u.first) continue;\n    for(int i=0;i<4;i++){\n      int ny = u.second.second / w + dy[i];\n      int nx = u.second.second % w + dx[i];\n      if(ny < 0 || ny >= h) continue;\n      if(nx < 0 || nx >= w) continue;\n      if(data[ny][nx] == -1) continue;\n      int tmp = u.first + data[u.second.second/w][u.second.second%w];\n      int tmp2 = u.second.first;\n      for(int i=0;i<m.size();i++) if(m[i].first == ny && m[i].second == nx) tmp2 |= (1<<i);\n      if(cost[ny][nx][tmp2] <= tmp) continue;\n      cost[ny][nx][tmp2] = tmp;\n      q.push(S(tmp, P(tmp2, ny * w + nx)));\n    }\n  }\n  return cost[g.first][g.second][(1<<((int)m.size()))-1];\n}\n\nmain(){\n  cin >> w >> h;\n  fill(data[0], data[100], 1);\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> c;\n      if(c == 'S'){\n        s.first = i;\n        s.second = j;\n      }\n      if(c == 'G'){\n        g.first = i;\n        g.second = j;\n      }\n      if(c == 'M') m.push_back(P(i, j));\n      if(c == '#'){\n        data[i][j] = -1;\n        a.push_back(P(i, j));\n      }\n    }\n  }\n  for(int i=0;i<a.size();i++) dfs(a[i].first, a[i].second, 0);\n  cout << dijkstra() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n#include<cassert>\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w;\nchar cmap[110][110];\nP pos[110];\nint index,matrix[110][110];\nint imap[110][110];\nstatic const int dx[4] = {0,1,0,-1};\nstatic const int dy[4] = {1,0,-1,0};\nstatic const int dx8[8] = {0,1,1,1,0,-1,-1,-1};\nstatic const int dy8[8] = {-1,-1,0,1,1,1,0,-1};\nstatic const int dx16[16] = {0,1,2,2,2,2,2,1,0,-1,-2,-2,-2,-2,-2,-1};\nstatic const int dy16[16] = {-2,-2,-2,-1,0,1,2,2,2,2,2,1,0,-1,-2,-2};\n \nint D[110][110];\n\n \nvoid bfs(P s,P g){\n  rep(i,h)rep(j,w){\n    D[i][j] = INF;\n  }\n  queue<P> que;\n  que.push(s);\n  D[s.S][s.F] = 0;\n\n \n  while(!que.empty()){\n    P p = que.front(); que.pop();\n \n    for(int i=0;i<4;i++){\n      int nx = p.F+dx[i],ny = p.S+dy[i];\n      if(0<= nx && nx < w && 0<= ny && ny < h && cmap[ny][nx] != '#' && D[ny][nx] > D[p.S][p.F] +imap[ny][nx]){\n    D[ny][nx] = min(D[p.S][p.F] + imap[ny][nx],D[ny][nx]);\n \n    que.push(P(nx,ny));\n      }\n    }\n  }\n}\n \nint main(){\n \n  scanf(\"%d %d\",&w,&h);\n    int sindex,lim = 1;\n    index = 1;\n   \n    rep(i,h)rep(j,w)imap[i][j] = 1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n    \n\tcin >> cmap[i][j];\n    matrix[i][j] = INF;\n    if(cmap[i][j] == 'S'){\n      lim++;\n    }\n    else if(cmap[i][j] == 'M')lim++;\n    else if(cmap[i][j] == 'G'){\n      pos[0] = P(j,i);\n    }\n      }\n    }\n  \n    rep(i,h){\n      rep(j,w){\n       \n    if(cmap[i][j] == 'S'){\n      pos[lim-1] = P(j,i);\n    }\n    else if(cmap[i][j] == 'M'){\n      assert(index != lim-1);\n      pos[index++] = P(j,i);\n    }\n    else if(cmap[i][j] == '#'){\n      for(int k=0;k<8;k++){\n       \n        int nx = j+dx8[k],ny = i+dy8[k];\n        if(0<=nx && nx<w && 0<=ny && ny <h && cmap[ny][nx] != '#'){\n          imap[ny][nx] = 3;\n        }\n      }\n      for(int k=0;k<16;k++){\n        int nx = j+dx16[k],ny = i+dy16[k];\n        if(0<=nx && nx<w && 0<=ny && ny <h && cmap[ny][nx] != '#'){\n          imap[ny][nx] = max(imap[ny][nx],2);\n        }\n      }\n    }\n      }\n    }\n \n \n    index = lim;\n \n    for(int i=0;i<index;i++){\n      rep(j,index){\n     \n    if(i == j){\n      matrix[i][j] = 0;\n      continue;\n    }\n    bfs(pos[i],pos[j]);\n    matrix[i][j] = D[pos[j].S][pos[j].F];\n      }\n    }\n    int per[110];\n    rep(i,index-1)per[i] = i+1;\n \n    int sum;\n    int ans=INF;\n    do{\n      sum=0;\n      sum+=matrix[0][per[0]];\n \n      int posi=-1;    \n      for(int i=1;i<index-1;i++){\n    if(i == index-2)posi = per[i];\n    sum+=matrix[per[i-1]][per[i]];\n      }\n     \n      if(posi != -1 && posi != lim-1)sum += matrix[posi][lim-1];\n     \n      ans=min(ans,sum);\n    }while(next_permutation(per,per+(index-1)));\n    printf(\"%d\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <deque>\n#include <tuple>\n#include <iostream>\nusing namespace std;\n\nconst int INF = 1 << 28;\nint H, W;\nint sx, sy, gx, gy;\nint board[110][110], dist[10][10], dp[1 << 10][10], rec[110][110];\n\nint nxt[] = {0, 1, 1, 2, 3};\nint dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nint ex[] = {0, 0, 1, -1};\nint ey[] = {1, -1, 0, 0};\n\nvoid get_board(deque< pair<int, int> > holes) {\n  int N = holes.size();\n\n  for(int i=0; i<N; i++) {\n    int ix = holes[i].first, iy = holes[i].second;\n    queue< pair<int, int> > que;\n    que.push(make_pair(ix, iy));\n\n    while(que.size()) {\n      int cx, cy; tie(cx, cy) = que.front(); que.pop();\n      for(int k=0; k<8; k++) {\n        int nx = cx + dx[k], ny = cy + dy[k];\n        if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n        if(board[nx][ny] == 4) continue;\n\n        int cst = nxt[ board[cx][cy] ];\n        if(cst > board[nx][ny]) {\n          board[nx][ny] = cst;\n          que.push(make_pair(nx, ny));\n        }\n      }\n    }\n  }\n}\n\nstruct Elem {\n  int x, y, cost;\n  bool operator<(const Elem &e) const {\n    return cost > e.cost;\n  }\n};\n\nvoid bfs(deque< pair<int, int> > treasures, int id) {\n  fill(rec[0], rec[110], INF);\n\n  int ix, iy; tie(ix, iy) = treasures[id];\n  priority_queue<Elem> que;\n  rec[ix][iy] = 0;\n  que.push(Elem{ix, iy, 0});\n\n  while(que.size()) {\n    Elem cur = que.top(); que.pop();\n    int x = cur.x, y = cur.y, cst = cur.cost;\n\n    for(int k=0; k<4; k++) {\n      int nx = x + ex[k], ny = y + ey[k];\n      if(nx < 0 || nx >= H || ny < 0 || ny >= W) continue;\n      if(board[nx][ny] == INF) continue;\n\n      int n_cost = cst + max(1, board[x][y]);\n      if(rec[nx][ny] > n_cost) {\n        rec[nx][ny] = n_cost;\n        que.push(Elem{nx, ny, n_cost});\n      }\n    }\n  }\n\n  int N = treasures.size();\n  for(int i=0; i<N; i++) {\n    int tx, ty; tie(tx, ty) = treasures[i];\n    // printf(\"tx = %d, ty = %d, cost = %d\\n\", tx, ty, rec[tx][ty]);\n    dist[id][i] = rec[tx][ty];\n  }\n}\n\nint main() {\n  cin >> W >> H;\n\n  deque< pair<int, int> > holes, treasures;\n  for(int i=0; i<H; i++) {\n    for(int j=0; j<W; j++) {\n      char c; cin >> c;\n      if(c == 'S') {\n        sx = i, sy = j;\n      }\n      else if(c == 'G') {\n        gx = i, gy = j;\n      }\n      else if(c == '#') {\n        holes.push_back(make_pair(i, j));\n        board[i][j] = 4;\n      }\n      else if(c == 'M') {\n        treasures.push_back(make_pair(i, j));\n      }\n    }\n  }\n\n  get_board(holes);\n  for(int i=0; i<holes.size(); i++) {\n    int x, y; tie(x, y) = holes[i];\n    board[x][y] = INF;\n  }\n\n\n  /*\n  // debug\n  for(int i=0; i<H; i++) {\n    for(int j=0; j<W; j++) {\n      cout << board[i][j];\n    }\n    cout << endl;\n  }\n  */\n  \n  \n  int N = treasures.size();\n  int si = 0, gi = N + 1;\n  treasures.push_front(make_pair(sx, sy));\n  treasures.push_back (make_pair(gx, gy));\n  N += 2;\n  \n  for(int i=0; i<N; i++) {\n    bfs(treasures, i);\n  }\n\n  /*\n  // debug\n  for(int i=0; i<N; i++) {\n    for(int j=0; j<N; j++) {\n      cout << dist[i][j] << \" \";\n    }\n    cout << endl;\n  }\n  */\n\n  int fullbit = (1<<N) - 1;\n\n  fill(dp[0], dp[1 << 10], INF);\n  dp[1][0] = 0;\n  for(int bit=0; bit<(1<<N); bit++) {\n    for(int i=0; i<N; i++) {\n      for(int k=0; k<N; k++) {\n        if(!(bit >> i & 1)) continue;\n        if(bit >> k & 1) continue;\n        int nbit = bit | (1 << k);\n        // if(k == N-1 && nbit != fullbit) continue;\n\n        int cost = dist[i][k];\n        dp[nbit][k] = min(dp[nbit][k], dp[bit][i] + cost);\n      }\n    }\n  }\n\n  int ans = dp[fullbit][N-1];\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define INF 1e9\nusing namespace std;\nstring mp[N];\n\n\n\nint D[101][101][1<<5];\nint used[101][101];\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint dx[] ={0,0,1,-1};\nint dy[] ={1,-1,0,0};\nint w,h;\n\nvoid bfs(){\n  memset(used,-1,sizeof(used));\n  queue<P> Q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)if(mp[i][j]=='#')Q.push(P(i,j)),used[i][j] = 0;\n  \n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    int y = t.first;\n    int x = t.second;\n    for(int i=-1;i<=1;i++)\n      for(int j=-1;j<=1;j++){\n\tif(i==0&&j==0)continue;\n\tint nx = x+i;\n\tint ny = y+j;\n      if(nx<0||ny<0||nx>=w||ny>=h||used[ny][nx]!=-1)continue;\n      used[ny][nx] = used[y][x] + 1;\n      Q.push(P(ny,nx));\n    }\n  }\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) used[i][j]=max(1,used[i][j]);\n  \n  \n} \n\n\nint dijkstra(int sy,int sx){\n  map<P,int> M;\n  int cnt=0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j] == 'M') M[P(i,j)] = cnt++;\n  \n  for(int i=0;i<101;i++)\n    for(int j=0;j<101;j++)\n      for(int k=0;k<(1<<5);k++) D[i][j][k] = INF; \n\n  priority_queue<PP,vector<PP>,greater<PP> >Q;  \n  Q.push(PP(P(0,sy),P(sx,0)));\n  D[sy][sx][0] = 0;\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first.first;\n    int y = t.first.second;\n    int x = t.second.first;\n    int bit = t.second.second;\n    if(mp[y][x] =='G' && bit==(1<<cnt)-1)return cost;\n    if(D[y][x][bit]<cost) continue;\n    \n    for(int i=0;i<4;i++){\n      int nx = x+dx[i];\n      int ny = y+dy[i];\n      int nbit = bit;\n      int ncost = cost+4-used[y][x];\n      if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx] == '#')continue;\n      if(D[ny][nx][nbit]<=ncost)continue;\n      if(mp[ny][nx] == 'M') nbit |= 1<<(M[P(ny,nx)]); \n      Q.push(PP(P(ncost,ny),P(nx,nbit)));\n      D[ny][nx][nbit] = ncost;\n    }\n  }\n  assert(0);\n}\n\n\nint main(){\n\n  cin>>w>>h;\n  for(int i=0;i<h;i++) cin>>mp[i];\n\n  bfs();\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j] == 'S') cout<<dijkstra(i,j)<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct P{\n\tint x, y;\n\tP(int x_, int y_){ x = x_; y = y_;}\n\tP(){}\n};\nstruct State{\n\tint t, x, y;\n\tState(int t_, int x_, int y_){ t = t_; x = x_; y = y_; }\n};\nbool operator<(const State& a, const State& b){\n\treturn a.t > b.t;\n}\n\nconst int INF = 1e+8;\nint w, h;\nint m[201][201];\nint G[20][20];\nint dx[4] = {0,0,1,-1};\nint dy[4] = {-1,1,0,0};\n\nint bfs(P s, P g){\n\tint d[201][201];\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\td[y][x] = INF;\n\t\t}\n\t}\n\td[s.y][s.x] = 0;\n\tpriority_queue<State> q;\n\tq.push( State(0,s.x,s.y) );\n\t\n\tint res=INF;\n\twhile( !q.empty() ){\n\t\tint t = q.top().t;\n\t\tint x = q.top().x;\n\t\tint y = q.top().y;\n\t\tq.pop();\n\t\t\n\t\tif( x == g.x && y == g.y ){\n\t\t\tres = t;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) continue;\n\t\t\tif( m[my][mx] == INF ) continue;\n\t\t\t\n\t\t\tif( t + m[y][x] < d[my][mx] ){\n\t\t\t\td[my][mx] = t + m[y][x];\n\t\t\t\tq.push( State( t + m[y][x] , mx , my ) );\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid hole(int ax, int ay){\n\tfor(int y = ay-2 ; y <= ay+2 ; y++ ){\n\t\tfor(int x = ax-2 ; x <= ax+2 ; x++ ){\n\t\t\tm[y][x] = max( m[y][x] , 2 );\n\t\t}\n\t}\n\tfor(int y = ay-1 ; y <= ay+1 ; y++ ){\n\t\tfor(int x = ax-1 ; x <= ax+1 ; x++ ){\n\t\t\tm[y][x] = max( m[y][x] , 3 );\n\t\t}\n\t}\n\tm[ay][ax] = INF;\n}\n\nint main(){\n\tcin >> w >> h;\n\tvector<string> s(h);\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tcin >> s[y];\n\t}\n\t\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tm[y][x] = 1;\n\t\t}\n\t}\n\tvector<P> v;\n\tint sx, sy, gx, gy;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( s[y][x] == 'S' ){\n\t\t\t\tsx = x; sy = y;\n\t\t\t\ts[y][x] = '.';\n\t\t\t}\n\t\t\tif( s[y][x] == 'G' ){\n\t\t\t\tgx = x; gy = y;\n\t\t\t\ts[y][x] = '.';\n\t\t\t}\n\t\t\tif( s[y][x] == 'M' ){\n\t\t\t\ts[y][x] = '.';\n\t\t\t\tv.push_back( P(x,y) );\n\t\t\t}\n\t\t\tif( s[y][x] == '#' ){\n\t\t\t\thole(x,y);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\tint cost = bfs( P(sx,sy) , v[i] );\n\t\tG[0][i+1] = cost;\n\t\tcost = bfs( v[i] , P(gx,gy) );\n\t\tG[i+1][v.size()+1] = cost;\n\t\tfor(int j=0 ; j < v.size() ; j++ ){\n\t\t\tcost = (i == j)? 0 : bfs( v[i] , v[j] );\n\t\t\tG[i+1][j+1] = cost;\n\t\t}\n\t}\n\t\n\tvector<int> a;\n\tfor(int i=0 ; i < v.size() ; i++ ) a.push_back(i);\n\tint ans = INF;\n\tdo{\n\t\tint cost = G[0][a[0]+1];\n\t\tfor(int i=1 ; i < a.size() ; i++ ){\n\t\t\tcost += G[a[i-1]+1][a[i]+1];\n\t\t}\n\t\tcost += G[a[a.size()-1]+1][a.size()+1];\n\t\tans = min( ans , cost );\n\t}while( next_permutation(a.begin(),a.end()) );\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000\n\nint di[4] = {0, -1, 0, 1};\nint dj[4] = {1, 0, -1, 0};\n\nvector<int> dijk(int s, int v, vector<vector<pair<int, int> > > adjlist){\n    \n    priority_queue <pair<int, int> > wait;\n    vector<int> result(v, INF);\n\n    //スタート地点を追加\n    result[s] = 0;\n    wait.push(make_pair(0, s));\n\n    //ダイクストラ本体\n    while(!wait.empty()){    //waitが空になるまで\n\n        int nowpoint = wait.top().second;\n        int nowcost = -wait.top().first;\n        wait.pop();\n\n        if(result[nowpoint] < nowcost) continue;\n\n\n        //今いる頂点と隣接しているすべての頂点をなめる\n        for(int i = 0; i < adjlist[nowpoint].size(); i++){\n\n            int nextpoint = adjlist[nowpoint][i].second;\n            int nextcost = nowcost + adjlist[nowpoint][i].first;\n            //現時点より安く到達できそうであれば、結果を更新して優先度付きキューに格納\n            if(result[nextpoint] > nextcost){\n                result[nextpoint] = nextcost;\n                wait.push(make_pair(-nextcost, nextpoint));\n            }\n        }\n    }\n    \n    return result;         //結果列を返す\n}\n\nint main(){\n\n    int h, w; cin >> w >> h;\n    int si, sj, gi, gj;\n    vector<vector<int> > gold(h + 2, vector<int> (w + 2, 0));\n    vector<vector<int> > canGo(h + 2, vector<int> (w + 2, 0));\n\n    int cnt = 0;\n    for(int i = 1; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            char in; cin >> in;\n            if(in == '#'){\n                canGo[i][j] = 4;\n            }else{\n                canGo[i][j] = 1;\n\n                if(in == 'S'){\n                    si = i;\n                    sj = j;\n                }\n\n                if(in == 'G'){\n                    gi = i;\n                    gj = j;\n                }\n\n                if(in == 'M'){\n                    cnt++;\n                    gold[i][j] = cnt;\n                }\n            }\n        }\n    }\n\n    int Map[110][110][(1 << 5)];\n\n    int node = 0;\n    for(int i = 1; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            for(int bit = 0; bit < (1 << 5); bit++){\n                Map[i][j][bit] = node;\n                node++;\n            }\n        }\n    }\n\n    //cout << cnt << \" \" << node << endl;\n\n    for(int i = 1; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n\n            //あなあなら\n            if(canGo[i][j] == 4){\n                \n\n                for(int k = i - 2; k <= i + 2; k++){\n                    for(int l = j - 2; l <= j + 2; l++){\n                        if(k < 1 || h < k || l < 1 || w < l) continue;\n\n                        canGo[k][l] = max(canGo[k][l], 2);\n                    }\n                }\n\n                for(int k = i - 1; k <= i + 1; k++){\n                    for(int l = j - 1; l <= j + 1; l++){\n                        if(k < 1 || h < k || l < 1 || w < l) continue;\n\n                        canGo[k][l] = max(canGo[k][l], 3);\n                    }\n                }\n            }\n        }\n    }\n\n    vector<vector<pair<int, int> > > adjlist(node);\n\n    for(int i = 1; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            for(int bit = 0; bit < (1 << 5); bit++){\n\n                //アナなら\n                if(canGo[i][j] == 4) continue;\n\n                int cost = canGo[i][j];\n                int now_node = Map[i][j][bit];\n\n                for(int h = 0; h < 4; h++){\n                    int ni = i + di[h];\n                    int nj = j + dj[h];\n\n                    if(canGo[ni][nj] == 4) continue;\n                    if(canGo[ni][nj] == 0) continue;\n\n                    int next_bit = bit;\n                    if(gold[ni][nj] != 0){\n                        int idx = gold[ni][nj] - 1;\n                        next_bit = next_bit & (~((1 << idx)));\n                    }\n\n                    int next_node = Map[ni][nj][next_bit];\n\n                    adjlist[now_node].push_back(make_pair(cost, next_node));\n                }\n            }\n        }\n    }\n\n    vector<int> result(node);\n    int S = Map[si][sj][(1 << cnt) - 1];\n    int G = Map[gi][gj][0];\n    result = dijk(S, node, adjlist);\n    cout << result[G] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n#define INF 1e9\n\n// splatoooooooooooooooooon\n\nint masu[100][100];\nint w,h;\nint pos(int y, int x){\n  return y*w+x;\n}\nint MAX_POS(){\n  return pos(h-1,w-1)+1;\n}\nint getx(int p){\n  return p%w;\n}\nint gety(int p){\n  return p/w;\n}\n\n// struct vertex{int dst,pre;};\nstruct edge{int from,to,w;};\nvi bf(vector<edge> es, int from){\n  vi dst(MAX_POS());\n  REP(i,MAX_POS()){\n    if(i==from){\n      dst[i] = 0;\n    }else{\n      dst[i] = INF;\n    }\n  }\n  REP(_,MAX_POS()){\n    REP(i,es.size()){\n      edge e = es[i];\n      dst[e.to] = min(dst[e.to], dst[e.from]+e.w);\n    }\n  }\n  return dst;\n}\n\nint main(){\n  cin >> w >> h;\n  vector<string> mp(h);\n  REP(i,h) cin >> mp[i];\n  REP(i,h)REP(j,w)masu[i][j]=1;\n  int start,goal;\n  vi ms;\n  REP(i,h)REP(j,w){\n    if(mp[i][j] == '#'){\n      // hole!\n      FOR(y,-3,4)FOR(x,-3,4){\n        int ny = i+y;\n        int nx = j+x;\n        if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n        masu[ny][nx] = max(masu[ny][nx],(int)(4-max(abs(y),abs(x))));\n      }\n      masu[i][j] = INF;\n    }\n    if(mp[i][j] == 'S')start = pos(i,j);\n    if(mp[i][j] == 'G')goal  = pos(i,j);\n    if(mp[i][j] == 'M')ms.push_back(pos(i,j));\n  }\n\n  vector<edge> es;\n  REP(i,h)REP(j,w){\n    if(i!=0){\n      es.push_back( (edge){pos(i,j),pos(i-1,j),masu[i][j]} );\n    }\n    if(i!=h-1){\n      es.push_back( (edge){pos(i,j),pos(i+1,j),masu[i][j]} );\n    }\n    if(j!=0){\n      es.push_back( (edge){pos(i,j),pos(i,j-1),masu[i][j]} );\n    }\n    if(j!=w-1){\n      es.push_back( (edge){pos(i,j),pos(i,j+1),masu[i][j]} );\n    }\n  }\n  int cnt = 1+1+ms.size();\n  int kyori[cnt][cnt];\n  REP(i,cnt)REP(j,cnt)kyori[i][j]=INF;\n  REP(i,cnt){\n    vi ret;\n    if(i==0)ret = bf(es,start);\n    else if(i==cnt-1)ret = bf(es,goal);\n    else ret = bf(es,ms[i-1]);\n    REP(j,cnt){\n      if(j==i)continue;\n      if(j==0)kyori[i][j] = ret[start];\n      else if(j==cnt-1)kyori[i][j] = ret[goal];\n      else kyori[i][j] = ret[ms[j-1]];\n    }\n  }\n  REP(k,cnt)REP(i,cnt)REP(j,cnt)kyori[i][j] = min(kyori[i][j],kyori[i][k]+kyori[k][j]);\n\n  vi perm(cnt-2);\n  REP(i,cnt-2)perm[i] = i+1;\n  int result = INF;\n  do{\n    int tmp = 0;\n    tmp += kyori[0][perm[0]];\n    REPR(i,cnt-2){\n      tmp += kyori[perm[i-1]][perm[i]];\n    }\n    tmp += kyori[perm[cnt-3]][cnt-1];\n    result = min(result,tmp);\n  }while(next_permutation(ALL(perm)));\n  cout << result << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<cstring>\nusing namespace std;\ntypedef pair<int,int> Pt;\ntypedef pair<Pt,Pt> P;\n#define fr first\n#define sc second\nint h,w,sx,sy,gx,gy,d[]={0,1,0,-1},Time[101][101],cnt;\nbool used[101][101][1<<5];\nint ldx[]={-1,-1,-1,0,1,1,1,0},ldy[]={-1,0,1,1,1,0,-1,-1};\nint sdx[]={-2,-2,-2,-2,-2,-1,0,1,2,2,2,2,2,1,0,-1};\nint sdy[]={-2,-1,0,1,2,2,2,2,2,1,0,-1,-2,-2,-2,-2};\nchar mas[101][101];\nvoid BAD(int,int);\nint bfs();\nbool judge(int x,int y){ return ((x>=0&&x<h&&y>=0&&y<w)? true : false); }\nint main(){\n  cin >> w >> h;\n  for(int i=0;i<h;i++) for(int j=0;j<w;j++) Time[i][j] = 1;\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> mas[i][j];\n      if(mas[i][j] == 'S') sx = i,sy = j;\n      else if(mas[i][j] == 'G') gx = i,gy = j;\n      else if(mas[i][j] == '#') BAD(i,j);\n      else if(mas[i][j] == 'M') mas[i][j] = cnt++;\n    }\n  }\n  cout << bfs() << endl;\n}\n\nint bfs(){\n  memset(used,false,sizeof(used));\n  priority_queue<P,vector<P>,greater<P> > que;\n  que.push(P(Pt(0,sx),Pt(sy,0)));\n  while(!que.empty()){\n    P p = que.top();\n    int t = p.fr.fr,px = p.fr.sc,py = p.sc.fr,BIT = p.sc.sc;\n    que.pop();\n    if(used[px][py][BIT])continue;\n    used[px][py][BIT] = true;\n    if(px == gx && py == gy && BIT ==(1<<cnt)-1 )return t;\n    for(int i=0;i<4;i++){\n      int nx = px + d[i],ny = py + d[3-i],bit = BIT;\n      if(!judge(nx,ny)) continue;\n      if(mas[nx][ny] == '#') continue;\n      if(mas[nx][ny]>=0&&mas[nx][ny]<=10) bit |= 1<<mas[nx][ny];\n      que.push(P(Pt(t+Time[px][py],nx),Pt(ny,bit)));\n    }\n  }\n}\nvoid BAD(int x,int y){\n  for(int i=0;i<8;i++){\n    int nx=x+ldx[i],ny=y+ldy[i];\n    if(judge(nx,ny)) Time[nx][ny] = 3;\n  }\n  for(int i=0;i<16;i++){\n    int nx=x+sdx[i],ny=y+sdy[i];\n    if(judge(nx,ny)) Time[nx][ny] = max(Time[nx][ny],2);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\ntypedef pair<int,pair<int,int> > pti;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\nconst double EPS = 1e-9;\n\n#define InRange(y,x) (0<=(y) and (y)<H and 0<=(x) and (x)<W)\n\nconst int INF = 1 << 30;\n\nint main(){\n    int W,H;\n    cin >> W >> H;\n    vector<string> field(H);\n    for(int i=0;i<H;i++){\n        cin >> field[i];\n    }\n    vector<vector<int> > goout(H,vector<int>(W,1));\n    pair<int,int> S,G;\n    vector<pair<int,int> > M;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(field[i][j] == '#'){\n                for(int k=-2;k<=2;k++){\n                    for(int l=-2;l<=2;l++){\n                        if(InRange(i+k,j+l)){\n                            int maxi = max(abs(k),abs(l));\n                            if(maxi == 0){\n                                goout[i+k][j+l] = max(goout[i+k][j+l],INF);\n                            }else if(maxi == 1){\n                                goout[i+k][j+l] = max(goout[i+k][j+l],3);\n                            }else{\n                                goout[i+k][j+l] = max(goout[i+k][j+l],2);\n                            }\n                        }\n                    }\n                }\n            }else if(field[i][j] == 'S'){\n                S = make_pair(i,j);\n            }else if(field[i][j] == 'G'){\n                G = make_pair(i,j);\n            }else if(field[i][j] == 'M'){\n                M.push_back(make_pair(i,j));\n            }\n        }\n    }\n\n    M.push_back(S);\n    M.push_back(G);\n\n    int makimono = M.size()-2;\n    vector<vector<int> > mdist(M.size(),vector<int>(M.size()));\n    for(int i=0;i<M.size();i++){\n        vector<vector<int> > dist(H,vector<int>(W));\n        vector<vector<char> > used(H,vector<char>(W,false));\n        priority_queue<pti,vector<pti>,greater<pti> > que;\n        que.push(make_pair(0,M[i]));\n        while(not que.empty()){\n            int cnt = que.top().first;\n            int y = que.top().second.first;\n            int x = que.top().second.second;\n            que.pop();\n            if(used[y][x]) continue;\n            dist[y][x] = cnt;\n            used[y][x] = true;\n            for(int j=0;j<4;j++){\n                int ny = y + dy[j];\n                int nx = x + dx[j];\n                if(InRange(ny,nx)){\n                    que.push(make_pair(cnt+goout[y][x],make_pair(ny,nx)));\n                }\n            }\n        }\n        for(int j=0;j<M.size();j++){\n            int y = M[j].first;\n            int x = M[j].second;\n            mdist[i][j] = dist[y][x];\n        }\n    }\n    int dp[1 << makimono][makimono];\n    for(int i=0;i<(1 << makimono);i++){\n        for(int j=0;j<makimono;j++){\n            dp[i][j] = INF;\n        }\n    }\n    for(int i=0;i<makimono;i++){\n        dp[1<<i][i] = mdist[makimono][i];\n    }\n    for(int i=0;i<(1<<makimono);i++){\n        for(int j=0;j<makimono;j++){\n            if(dp[i][j] == INF) continue;\n            for(int k=0;k<makimono;k++){\n                if(i & (1 << k)) continue;\n                dp[i | (1 << k)][k] = min(dp[i | (1 << k)][k],dp[i][j]+mdist[j][k]);\n            }\n        }\n    }\n    int ret = INF;\n    for(int i=0;i<makimono;i++){\n        ret = min(ret,dp[(1<<makimono)-1][i]+mdist[i][makimono+1]);\n    }\n    cout << ret << endl;\n    //M.pop_back();\n    //M.pop_back();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<deque>\n#include<climits>\n#include<numeric>\n#include<cassert>\n#include<functional>\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define fi(i,j,k) fill(i[0],i[0]+j*j,k)\n#define INF 1<<27\n#define F first\n#define S second\nstatic const double eps=1e-10;\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w;\nchar cmap[110][110];\nP pos[110];\nint index,matrix[110][110];\nint imap[110][110];\nstatic const int dx[4] = {0,1,0,-1};\nstatic const int dy[4] = {1,0,-1,0};\nstatic const int dx8[8] = {0,1,1,1,0,-1,-1,-1};\nstatic const int dy8[8] = {-1,-1,0,1,1,1,0,-1};\nstatic const int dx16[16] = {0,1,2,2,2,2,2,1,0,-1,-2,-2,-2,-2,-2,-1};\nstatic const int dy16[16] = {-2,-2,-2,-1,0,1,2,2,2,2,2,1,0,-1,-2,-2};\n\nint D[110][110];\nbool used[110][110];\n\nvoid bfs(P s,P g){\n  rep(i,h)rep(j,w){\n    D[i][j] = INF;\n    used[i][j] = false;\n  }\n  queue<P> que;\n  que.push(s);\n  D[s.S][s.F] = 0;\n  used[s.S][s.F] = true;\n\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n    //if(p == g)return D[g.S][g.F];\n\n    for(int i=0;i<4;i++){\n      int nx = p.F+dx[i],ny = p.S+dy[i];\n      if(0<= nx && nx < w && 0<= ny && ny < h && cmap[ny][nx] != '#' && /*!used[ny][nx]*/ D[ny][nx] > D[p.S][p.F] +imap[p.S][p.F]){\n\tD[ny][nx] = min(D[p.S][p.F] + imap[p.S][p.F],D[ny][nx]);\n\t//cout << \"nx = \" << nx << \", ny = \" << ny << \", D[ny][nx] =\" << D[ny][nx] << endl;  \n\t//used[ny][nx] = true;\n\tque.push(P(nx,ny));\n      }\n    }\n  }\n  //return INF;\n}\n\n\nvoid display(){\n  for(int i=0;i<h;i++)\n    {\n      rep(j,w){\n\tcout << cmap[i][j] << \" \";\n      }\n      cout<< endl;\n    }\n  cout << endl;\n  for(int i=0;i<h;i++)\n    {\n      rep(j,w){\n\tcout << imap[i][j] << \" \";\n      }\n      cout<< endl;\n    }\n  cout << endl;\n\n  rep(i,index){\n    rep(j,index){\n      cout << matrix[i][j] << \" \";\n    }\n    cout<< endl;\n  }\n  cout << endl;\n\n}\n\nint main(){\n  while(cin >> w >> h){\n  int sindex,lim = 1;\n  index = 1;\n  \n  rep(i,h)rep(j,w)imap[i][j] = 1;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> cmap[i][j];\n      matrix[i][j] = INF;\n      if(cmap[i][j] == 'S'){\n\tpos[0] = P(j,i);\n      }\n      else if(cmap[i][j] == 'M')lim++;\n      else if(cmap[i][j] == 'G'){\n\tlim++;\n      }\n    }\n  }\n \n  rep(i,h){\n    rep(j,w){\n      \n      if(cmap[i][j] == 'G'){\n\t pos[lim-1] = P(j,i);\n      }\n       else if(cmap[i][j] == 'M'){\n\t assert(index != lim-1);\n\tpos[index++] = P(j,i);\n      }\n      else if(cmap[i][j] == '#'){\n\tfor(int k=0;k<8;k++){\n\t  \n\t  int nx = j+dx8[k],ny = i+dy8[k];\n\t  if(0<=nx && nx<w && 0<=ny && ny <h && cmap[ny][nx] != '#'){\n\t    imap[ny][nx] = 3;\n\t  }\n\t}\n\tfor(int k=0;k<16;k++){\n\t  int nx = j+dx16[k],ny = i+dy16[k];\n\t  if(0<=nx && nx<w && 0<=ny && ny <h && cmap[ny][nx] != '#'){\n\t    imap[ny][nx] = max(imap[ny][nx],2);\n\t  }\n\t}\n      }\n    }\n  }\n\n  \n\n  //rep(i,h)rep(j,w)if(cmap[i][j] == 'G')imap[i][j] = 0;\n  \n\n  index = lim;\n\n  for(int i=0;i<index;i++){\n    rep(j,index){\n    \n      if(i == j){\n\tmatrix[i][j] = 0;\n\tcontinue;\n      }\nbfs(pos[i],pos[j]);\n matrix[i][j] = D[pos[j].S][pos[j].F];\n    }\n  }\n\n  //index--;\n\n  //display();\n  int per[110];\n  rep(i,index-1)per[i] = i+1;\n\n  int sum;\n  int ans=INF;\n  do{\n    sum=0;\n    sum+=matrix[0][per[0]];\n\n    int posi=-1;     \n    for(int i=1;i<index-1;i++){\n      if(i == index-2)posi = per[i];\n      sum+=matrix[per[i-1]][per[i]];\n    }\n    //assert(posi !=-1);\n    //if(posi != index-1){\n    //cout <<\"posi = \" << posi << \",index = \" << index-1 << \",presum = \" << sum << \", matrix[posi][lim-1] = \" << matrix[posi][lim-1] << endl;\n    if(posi != -1 && posi != lim-1)sum += matrix[posi][lim-1];\n    //}\n    ans=min(ans,sum);\n  }while(next_permutation(per,per+(index-1)));\n \n\n  cout << ans << endl;\n\n}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n#define min(...) min({__VA_ARGS__})\n#define max(...) max({__VA_ARGS__})\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int H, W;\n  char mas[101][101];\n  int sy, sx, gy, gx;\n  int delay[101][101] = {{}};\n  int maki = 0;\n  map<pint, int> mp;\n\n  auto in = [&](int y, int x) -> bool {\n    return 0 <= y && y < H && 0 <= x && x < W;\n  };\n\n  cin >> W >> H;\n  rep(i, H) rep(j, W) {\n    cin >> mas[i][j];\n    chmax(delay[i][j], 1);\n    if(mas[i][j] == 'S') sy = i, sx = j;\n    else if(mas[i][j] == 'G') gy = i, gx = j;\n    else if(mas[i][j] == 'M') mp[make_pair(i, j)] = maki++;\n    else if(mas[i][j] == '#') {\n      delay[i][j] = inf;\n      reps(k, 1, 4) {\n\treps(l, -4+k, 4-k+1) {\n\t  if(in(i-4+k, j+l)) chmax(delay[i-4+k][j+l], k);\n\t  if(in(i+4-k, j+l)) chmax(delay[i+4-k][j+l], k);\n\t  if(in(i+l, j-4+k)) chmax(delay[i+l][j-4+k], k);\n\t  if(in(i+l, j+4-k)) chmax(delay[i+l][j+4-k], k);\n\t}\n      }\n    }\n  }\n\n  struct state {\n    int y, x, bit, dist;\n    state(int y = 0, int x = 0, int bit = 0, int dist = 0)\n      :y(y), x(x), bit(bit), dist(dist){}\n    bool operator < (const state& s) const {\n      return dist > s.dist;\n    }\n  };\n\n  priority_queue<state> que;\n  int d[101][101][1<<5];\n  int dy[] = {1, 0, -1, 0};\n  int dx[] = {0, 1, 0, -1};\n\n  que.emplace(sy, sx, 0, 0);\n  rep(i, 101) rep(j, 101) rep(k, 1<<5) d[i][j][k] = inf;\n  d[sy][sx][0] = 0;\n  while(que.size()) {\n    state st = que.top(); que.pop();\n    int y = st.y, x = st.x, bit = st.bit, dist = st.dist;\n    if(y == gy && x == gx && bit == (1<<maki)-1) {\n      cout << dist << endl;\n      return 0;\n    }\n    if(d[y][x][bit] < dist) continue;\n    rep(i, 4) {\n      int ny = y + dy[i], nx = x + dx[i], nbit = bit;\n      if(!in(ny, nx) || mas[ny][nx] == '#') continue;\n      if(mas[ny][nx] == 'M') nbit |= 1<<(mp[make_pair(ny, nx)]);\n      if(dist + delay[y][x] < d[ny][nx][nbit]) {\n\td[ny][nx][nbit] = dist + delay[y][x];\n\tque.emplace(ny, nx, nbit, d[ny][nx][nbit]);\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n\n\tint w,h;\n\tconst int MAX=INT_MAX/10;\nstruct node{\n    int y,x,cost;\n    node(int y,int x,int cost):y(y),x(x),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n    }\n};\nconst int NONE=-1;\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint search(vs &field,vvi &time,pii start,pii goal){\n    priority_queue<node> q;\n\tq.push(node(start.first,start.second,0));\n    vvi cost(h,vi(w,MAX));\n    cost[start.first][start.second]=0;\n    while(!q.empty()){\n        node cnode=q.top();q.pop();\n\t\tif(cost[cnode.y][cnode.x]<cnode.cost){\n            continue;\n        }\n\t\tREP(d,4){\n\t\t\tint xx=cnode.x+dx[d];\n\t\t\tint yy=cnode.y+dy[d];\n\t\t\tif(xx>=0&&yy>=0&&xx<w&&yy<h&&field[yy][xx]!='#'){\n\t\t\t\tint newcost=cnode.cost+time[cnode.y][cnode.x];\n\t\t\t\tif(cost[yy][xx]>newcost){\n\t\t\t\t\tcost[yy][xx]=newcost;\n\t\t\t\t\tq.push(node(yy,xx,newcost));\n\t\t\t\t}\n            }\n        }\n    }\n\treturn cost[goal.first][goal.second];\n}\nint main(){\n\tcin>>w>>h;\n\tvs field(h);\n\tvector<pii> points;\n\tREP(i,h){\n\t\tcin>>field[i];\n\t}\n\tREP(i,h){\n\t\tREP(j,w){\n\t\t\tif(field[i][j]=='M'){\n\t\t\t\tpoints.push_back(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,h){\n\t\tREP(j,w){\n\t\t\tif(field[i][j]=='S'){\n\t\t\t\tpoints.push_back(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,h){\n\t\tREP(j,w){\n\t\t\tif(field[i][j]=='G'){\n\t\t\t\tpoints.push_back(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t}\n\n\tvvi time(h,vi(w,1));\n\tREP(i,h){\n\t\tREP(j,w){\n\t\t\tint nearest=MAX;\n\t\t\tFOR(x,-3,3+1){\n\t\t\t\tFOR(y,-3,3+1){\n\t\t\t\t\tif(x==0&&y==0)continue;\n\t\t\t\t\tint yy=i+y,xx=j+x;\n\t\t\t\t\tif(yy>=0&&xx>=0&&yy<h&&xx<w&&field[i+y][j+x]=='#'){\n\t\t\t\t\t\tnearest=min(nearest,max(abs(x),abs(y)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nearest!=MAX){\n\t\t\t\ttime[i][j]=4-nearest;\n\t\t\t}\n\t\t}\n\t}\n\tvvi dist(points.size(),vi(points.size()));\n\tREP(i,points.size()){\n\t\tREP(j,points.size()){\n\t\t\tif(i!=j){\n\t\t\t\tdist[i][j]=search(field,time,points[i],points[j]);\n\t\t\t}\n\t\t}\n\t}\n\tvi order(points.size()-2);\n\tREP(i,order.size()){\n\t\torder[i]=i;\n\t}\n\tint ans=MAX;\n\tdo{\n\t\tint cost=0;\n\t\tcost+=dist[order.size()][order[0]];\n\t\tREP(i,order.size()-1){\n\t\t\tcost+=dist[order[i]][order[i+1]];\n\t\t}\n\t\tcost+=dist[order[order.size()-1]][order.size()+1];\n\t\tans=min(ans,cost);\n\t}while(next_permutation(ALL(order)));\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint sp[111][111];\nint dp[111][111][1<<5];\nint w,h;\nint in(int y,int x){\n  return 0<=y&&y<h&&0<=x&&x<w;\n}\nstruct sta{\n  int y,x,b,d;\n  sta(){}\n  sta(int y,int x,int b,int d):y(y),x(x),b(b),d(d){}\n  bool operator<(const sta& a) const{\n    return d>a.d;\n  }\n};\ntypedef pair<int,int> P;\nint main(){\n  memset(sp,0,sizeof(sp));\n  memset(dp,-1,sizeof(dp));\n  cin>>w>>h;\n  string st[h];\n  for(int i=0;i<h;i++) cin>>st[i];\n  int sy,sx,gy,gx,n=0;\n  map<P,int> m;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      sp[i][j]=max(sp[i][j],1);\n      if(st[i][j]=='M') m[P(i,j)]=n++;\n      if(st[i][j]=='S') sy=i,sx=j;\n      if(st[i][j]=='G') gy=i,gx=j;\n      if(st[i][j]=='#'){\n    for(int k=1;k<=3;k++){\n      for(int a=-(4-k);a<=4-k;a++){\n        if(in(i-(4-k),j+a)) sp[i-(4-k)][j+a]=max(sp[i-(4-k)][j+a],k);\n        if(in(i+(4-k),j+a)) sp[i+(4-k)][j+a]=max(sp[i+(4-k)][j+a],k);\n        if(in(i+a,j-(4-k))) sp[i+a][j-(4-k)]=max(sp[i+a][j-(4-k)],k);\n        if(in(i+a,j+(4-k))) sp[i+a][j+(4-k)]=max(sp[i+a][j+(4-k)],k);\n      }\n    }\n      }\n    }\n  }\n  /*//\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cout<<sp[i][j];\n    }\n    cout<<endl;\n  }\n  //*/\n  priority_queue<sta> q;\n  q.push(sta(sy,sx,0,0));\n  dp[sy][sx][0]=0;\n  int ax[]={1,-1,0,0};\n  int ay[]={0,0,1,-1};\n  while(!q.empty()){\n    sta s=q.top();q.pop();\n    if(dp[s.y][s.x][s.b]<s.d) continue;\n    //cout<<s.y<<\" \"<<s.x<<\" \"<<s.b<<\" \"<<s.d<<endl;\n    for(int k=0;k<4;k++){\n      int ny=s.y+ay[k],nx=s.x+ax[k],nb=s.b,nd=s.d+sp[s.y][s.x];\n      if(!in(ny,nx)) continue;\n      if(st[ny][nx]=='#') continue;\n      if(m.count(P(ny,nx))) nb|=1<<m[P(ny,nx)];\n      if(dp[ny][nx][nb]<0||dp[ny][nx][nb]>nd){\n    dp[ny][nx][nb]=nd;\n    q.push(sta(ny,nx,nb,nd));\n      }\n    }\n  }\n  cout<<dp[gy][gx][(1<<n)-1]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define INF 1e9\nusing namespace std;\nstring mp[N];\nint D[101][101][1<<5];\nint used[101][101];\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint dx[] ={0,0,1,-1};\nint dy[] ={1,-1,0,0};\nint w,h;\n\nvoid bfs(){\n  memset(used,-1,sizeof(used));\n  queue<P> Q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)if(mp[i][j]=='#')Q.push(P(i,j)),used[i][j] = 0;\n  \n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    int y = t.first;\n    int x = t.second;\n    for(int i=-1;i<=1;i++)\n      for(int j=-1;j<=1;j++){\n\tif(i==0&&j==0)continue;\n\tint nx = x+i;\n\tint ny = y+j;\n\tif(nx<0||ny<0||nx>=w||ny>=h||used[ny][nx]!=-1)continue;\n\tused[ny][nx] = used[y][x] + 1;\n\tQ.push(P(ny,nx));\n      }\n  }\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) used[i][j]=max(1,used[i][j]);\n  \n  \n} \n\n\nint dijkstra(int sy,int sx){\n  map<P,int> M;\n  int cnt=0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)if(mp[i][j] == 'M') M[P(i,j)] = cnt++;\n  \n  for(int i=0;i<101;i++)\n    for(int j=0;j<101;j++)\n      for(int k=0;k<(1<<5);k++) D[i][j][k] = INF; \n  \n  priority_queue<PP,vector<PP>,greater<PP> >Q;  \n\n  Q.push(PP(P(0,sy),P(sx,0)));\n  D[sy][sx][0] = 0;\n  int visited[N][N][1<<5]={};\n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first.first;\n    int y = t.first.second;\n    int x = t.second.first;\n    int bit = t.second.second;\n    if(mp[y][x] =='G' && bit==(1<<cnt)-1)return cost;\n    if(D[y][x][bit]<cost||visited[y][x][bit]++) continue;\n    \n    for(int i=0;i<4;i++){\n      int nx = x+dx[i];\n      int ny = y+dy[i];\n      int nbit = bit;\n      int ncost = cost+4-used[y][x];\n      if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx] == '#')continue;\n      if(D[ny][nx][nbit]<=ncost||visited[ny][nx][nbit])continue;\n      if(mp[ny][nx] == 'M') nbit |= 1<<(M[P(ny,nx)]); \n      Q.push(PP(P(ncost,ny),P(nx,nbit)));\n      D[ny][nx][nbit] = ncost;\n    }\n  }\n  assert(0);\n}\n\n\nint main(){\n\n  cin>>w>>h;\n  for(int i=0;i<h;i++) cin>>mp[i];\n\n  bfs();\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j] == 'S') cout<<dijkstra(i,j)<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<queue>\nusing namespace std;\n\n#define INF (1<<29)\n\nint cost[102][102];\nchar g[102][102];\n\nint d[102][102][1<<5];\n\nint main(){\n\tint h,w;\n\tint sy,sx;\n\tint cnt=0;\n\tcin>>w>>h;\n\tfor(int i=0;i<=h+1;i++)\n\t\tfor(int j=0;j<=w+1;j++)\n\t\t\tcost[i][j]=1,g[i][j]='#';\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tcin>>g[i][j];\n\t\t\tif(g[i][j]=='#'){\n\t\t\t\tfor(int dy=-2;dy<=2;dy++){\n\t\t\t\t\tfor(int dx=-2;dx<=2;dx++){\n\t\t\t\t\t\tif(!dy&&!dx)continue;\n\t\t\t\t\t\tif(i+dy<1||h<i+dy||j+dx<1||w<j+dx)continue;\n\t\t\t\t\t\tcost[i+dy][j+dx]=max(cost[i+dy][j+dx],4-max(abs(dy),abs(dx)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(g[i][j]=='S'){\n\t\t\t\tsy=i;\n\t\t\t\tsx=j;\n\t\t\t}else if(g[i][j]=='M'){\n\t\t\t\tg[i][j]='0'+cnt++;\n\t\t\t}\n\t\t}\n\t}\n\tint dy[]={1,0,-1,0};\n\tint dx[]={0,1,0,-1};\n\tint ans=-1,qidx=0;\n\tqueue<pair<pair<int,int>,int> > q[4];\n\tq[0].push(make_pair(make_pair(sy,sx),0));\n\tfill((int*)d,(int*)(d+102),INF);\n\td[sy][sx][0]=0;\n\twhile(1){\n\t\twhile(q[qidx].empty())qidx=(qidx+1)&3;\n\t\tpair<pair<int,int>,int> a,b;\n\t\ta=q[qidx].front();\n\t\tq[qidx].pop();\n\t\tif(g[a.first.first][a.first.second]=='G'&&(1<<cnt)-1==a.second){\n\t\t\tans=d[a.first.first][a.first.second][a.second];\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tb=a;\n\t\t\tb.first.first+=dy[i];\n\t\t\tb.first.second+=dx[i];\n\t\t\tint y=b.first.first;\n\t\t\tint x=b.first.second;\n\t\t\tif(g[y][x]=='#')continue;\n\t\t\tif('0'<=g[y][x]&&g[y][x]<'5')b.second|=1<<g[y][x]-'0';\n\t\t\tint c=cost[a.first.first][a.first.second];\n\t\t\tif(d[a.first.first][a.first.second][a.second]+c<d[y][x][b.second]){\n\t\t\t\td[y][x][b.second]=d[a.first.first][a.first.second][a.second]+c;\n\t\t\t\tq[(qidx+c)&3].push(b);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef complex<double> P;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n#define INF 1e9\n\n// splatoooooooooooooooooon\n\nint masu[100][100];\nint w,h;\nint pos(int y, int x){\n  return y*w+x;\n}\nint MAX_POS(){\n  return pos(h-1,w-1)+1;\n}\nint getx(int p){\n  return p%w;\n}\nint gety(int p){\n  return p/w;\n}\n\n// struct vertex{int dst,pre;};\nstruct edge{int from,to,w;};\nbool operator < (const edge &e, const edge &f) {\n  return e.w != f.w ? e.w > f.w :\n    e.from != f.from ? e.from < f.from : e.to < f.to;\n}\nvi bf(vector<edge> es, int from){\n  vi dst(MAX_POS());\n  REP(i,MAX_POS()){\n    if(i==from){\n      dst[i] = 0;\n    }else{\n      dst[i] = INF;\n    }\n  }\n  REP(_,MAX_POS()){\n    REP(i,es.size()){\n      edge e = es[i];\n      dst[e.to] = min(dst[e.to], dst[e.from]+e.w);\n    }\n  }\n  return dst;\n}\n\n\n// http://www.prefield.com/algorithm/graph/dijkstra.html\nvi dijkstra(vector< vector<edge> > g, int s) {\n  vi dist(MAX_POS());\n  int n = g.size();\n  dist.assign(n, INF); dist[s] = 0;\n  priority_queue<edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n  for (Q.push((edge){-2, s, 0}); !Q.empty(); ) {\n    edge e = Q.top(); Q.pop();\n    // if (prev[e.to] != -1) continue;\n    REP(i,g[e.to].size()){\n      edge f = g[e.to][i];\n      if (dist[f.to] > e.w+f.w) {\n        dist[f.to] = e.w+f.w;\n        Q.push((edge){f.from, f.to, e.w+f.w});\n      }\n    }\n  }\n  return dist;\n}\n\nint main(){\n  cin >> w >> h;\n  vector<string> mp(h);\n  REP(i,h) cin >> mp[i];\n  REP(i,h)REP(j,w)masu[i][j]=1;\n  int start,goal;\n  vi ms;\n  REP(i,h)REP(j,w){\n    if(mp[i][j] == '#'){\n      // hole!\n      FOR(y,-3,4)FOR(x,-3,4){\n        int ny = i+y;\n        int nx = j+x;\n        if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n        masu[ny][nx] = max(masu[ny][nx],(int)(4-max(abs(y),abs(x))));\n      }\n      masu[i][j] = INF;\n    }\n    if(mp[i][j] == 'S')start = pos(i,j);\n    if(mp[i][j] == 'G')goal  = pos(i,j);\n    if(mp[i][j] == 'M')ms.push_back(pos(i,j));\n  }\n\n  vector< vector<edge> > es(MAX_POS());\n  REP(i,h)REP(j,w){\n    if(i!=0){\n      es[pos(i,j)].push_back( (edge){pos(i,j),pos(i-1,j),masu[i][j]} );\n    }\n    if(i!=h-1){\n      es[pos(i,j)].push_back( (edge){pos(i,j),pos(i+1,j),masu[i][j]} );\n    }\n    if(j!=0){\n      es[pos(i,j)].push_back( (edge){pos(i,j),pos(i,j-1),masu[i][j]} );\n    }\n    if(j!=w-1){\n      es[pos(i,j)].push_back( (edge){pos(i,j),pos(i,j+1),masu[i][j]} );\n    }\n  }\n  int cnt = 1+1+ms.size();\n  int kyori[cnt][cnt];\n  REP(i,cnt)REP(j,cnt)kyori[i][j]=INF;\n  REP(i,cnt){\n    vi ret;\n    if(i==0)ret = dijkstra(es,start);\n    else if(i==cnt-1)ret = dijkstra(es,goal);\n    else ret = dijkstra(es,ms[i-1]);\n    REP(j,cnt){\n      if(j==i)continue;\n      if(j==0)kyori[i][j] = ret[start];\n      else if(j==cnt-1)kyori[i][j] = ret[goal];\n      else kyori[i][j] = ret[ms[j-1]];\n    }\n  }\n  REP(k,cnt)REP(i,cnt)REP(j,cnt)kyori[i][j] = min(kyori[i][j],kyori[i][k]+kyori[k][j]);\n\n  vi perm(cnt-2);\n  REP(i,cnt-2)perm[i] = i+1;\n  int result = INF;\n  do{\n    int tmp = 0;\n    tmp += kyori[0][perm[0]];\n    REPR(i,cnt-2){\n      tmp += kyori[perm[i-1]][perm[i]];\n    }\n    tmp += kyori[perm[cnt-3]][cnt-1];\n    result = min(result,tmp);\n  }while(next_permutation(ALL(perm)));\n  cout << result << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<cstdlib>\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint w,h,sy,sx,gy,gx;\nstring room[110];\nint g[110][110];\nint d[110][110][20];\nint num;\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint main(){\n  cin >> w >> h;\n  for(int i=0;i<h;i++)cin >> room[i];\n    \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)g[i][j] = 1;\n\n  num = 0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(room[i][j] == '#'){\n\tfor(int k=-2;k<=2;k++){\n\t  for(int l=-2;l<=2;l++){\n\t    if(i+k<0 || j+l<0 || h<=i+k || w<=j+l)continue;\n\t    if(abs(k)<=1 && abs(l)<=1)g[i+k][j+l] = max(g[i+k][j+l],3);\n\t    else g[i+k][j+l] = max(g[i+k][j+l],2);\n\t  }\n\t}\n      }\n      if(room[i][j] == 'M'){\n\troom[i][j] = '0'+num;\n\tnum++;\n      }\n      if(room[i][j] == 'S'){ sy = i; sx = j;}\n      if(room[i][j] == 'G'){ gy = i; gx = j;}\n    }\n  }\n \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<(1<<num);k++)d[i][j][k] = 1<<25;\n\n  d[sy][sx][0] = 0;\n  priority_queue<P2,vector<P2>,greater<P2> > q;\n  q.push(P2(P(0,0),P(sy,sx)));\n\n  while(q.size()){\n    P2 p = q.top(); q.pop();\n    int dis = p.fs.fs, st = p.fs.sc, y = p.sc.fs, x = p.sc.sc;\n\n    if(gy == y && gx == x && st == (1<<num)-1){\n      cout << dis << endl;\n      return 0;\n    }\n\n    dis += g[y][x];\n    for(int i=0;i<4;i++){\n      int ty = y+dy[i], tx = x+dx[i], tst = st;\n      if(ty<0 || tx<0 || h<=ty || w<=tx)continue;\n      if(room[ty][tx] == '#')continue;\n      if('0' <= room[ty][tx] && room[ty][tx] <= '4'){\n\ttst |= 1<<(room[ty][tx]-'0');\n      }\n      if(d[ty][tx][tst] > dis){\n\td[ty][tx][tst] = dis;\n\tq.push(P2(P(dis,tst),P(ty,tx)));\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define  f first \n#define  s second \nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint w,h,c=1,sx,sy,gx,gy;\nchar mp[101][101];\nint bt[101][101];\nint cs[101][101];\nint nn[5][5]=\n  {{2,2,2,2,2},\n   {2,3,3,3,2},\n   {2,3,1e8,3,2},\n   {2,3,3,3,2},\n   {2,2,2,2,2}\n  };\nint used[100][101][101];\n\nvoid nu(int x,int y){\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++){\n      int nx=x+j-2,ny=y+i-2;\n      if(nx<0||w<=nx||ny<0||h<=ny)continue;\n      cs[ny][nx]=max(nn[i][j],cs[ny][nx]);\n    }\n}\n\nint cal(){\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(P(0,0),P(sx,sy)));\n  int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n  while(!Q.empty()){\n    PP p=Q.top();\n    Q.pop();\n    if(p.s.f==gx&&p.s.s==gy&&p.f.s==c-1)return p.f.f;\n    if(used[p.f.s][p.s.s][p.s.f]==1)continue;\n    used[p.f.s][p.s.s][p.s.f]=1;\n    for(int i=0;i<4;i++){\n      int nx=p.s.f+dx[i],ny=p.s.s+dy[i];\n      int ncs=p.f.f+cs[p.s.s][p.s.f],nbt=p.f.s|bt[p.s.s][p.s.f];\n      if(nx<0||w<=nx||ny<0||h<=ny)continue;\n      Q.push(PP(P(ncs,nbt),P(nx,ny)));\n    }\n  }\n}\n\n\nint main(){\n  cin>>w>>h;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      cin>>mp[i][j];\n      cs[i][j]=max(1,cs[i][j]);\n      if(mp[i][j]=='M')bt[i][j]=c,c*=2;\n      if(mp[i][j]=='#')nu(j,i);\n      if(mp[i][j]=='S')sx=j,sy=i;\n      if(mp[i][j]=='G')gx=j,gy=i;\n    }\n  cout<<cal()<<endl; \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2419.cc: Acrophobia\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_W = 100;\nconst int MAX_H = 100;\nconst int MAX_M = 5;\nconst int MBITS = 1 << MAX_M;\n\nconst int dxs[] = {1, 0, -1, 0}, dys[] = {0, -1, 0, 1};\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef pair<int,int> pii;\n\nstruct Stat {\n  int d, x, y, b;\n  Stat() {}\n  Stat(int _d, int _x, int _y, int _b): d(_d), x(_x), y(_y), b(_b) {}\n  bool operator<(const Stat &s) const { return d > s.d; }\n};\n\n/* global variables */\n\nstring flds[MAX_H];\nint ds[MAX_H][MAX_W], ms[MAX_H][MAX_W];\nint dists[MAX_H][MAX_W][MBITS];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int w, h;\n  cin >> w >> h;\n\n  for (int y = 0; y < h; y++)\n    for (int x = 0; x < w; x++)\n      ds[y][x] = 1, ms[y][x] = -1;\n\n  int sx, sy, gx, gy, m = 0;\n  \n  for (int y = 0; y < h; y++) {\n    cin >> flds[y];\n    for (int x = 0; x < w; x++) {\n      switch (flds[y][x]) {\n      case '#': ds[y][x] = 0; break;\n      case 'S': sx = x; sy = y; break;\n      case 'G': gx = x; gy = y; break;\n      case 'M': ms[y][x] = m++; break;\n      }\n    }\n  }\n\n  for (int y = 0; y < h; y++)\n    for (int x = 0; x < w; x++)\n      if (ds[y][x] == 0)\n\tfor (int y0 = y - 2; y0 <= y + 2; y0++)\n\t  for (int x0 = x - 2; x0 <= x + 2; x0++)\n\t    if (x0 >= 0 && x0 < w && y0 >= 0 && y0 < h && ds[y0][x0] > 0) {\n\t      int d = 4 - max(abs(x0 - x), abs(y0 - y));\n\t      if (ds[y0][x0] < d) ds[y0][x0] = d;\n\t    }\n\n  /*\n  for (int y = 0; y < h; y++) {\n    for (int x = 0; x < w; x++) printf(\"%d\", ds[y][x]);\n    putchar('\\n');\n  }\n  */\n  \n  int mbits = 1 << m;\n\n  for (int y = 0; y < h; y++)\n    for (int x = 0; x < w; x++)\n      for (int bits = 0; bits < mbits; bits++) dists[y][x][bits] = INF;\n  dists[sy][sx][0] = 0;\n\n  priority_queue<Stat> q;\n  q.push(Stat(0, sx, sy, 0));\n\n  while (! q.empty()) {\n    Stat u = q.top(); q.pop();\n    if (dists[u.y][u.x][u.b] != u.d) continue;\n    if (u.x == gx && u.y == gy && u.b == mbits - 1) break;\n\n    int vd = u.d + ds[u.y][u.x];\n\n    for (int di = 0; di < 4; di++) {\n      int vx = u.x + dxs[di], vy = u.y + dys[di];\n      if (vx >= 0 && vx < w && vy >= 0 && vy < h && ds[vy][vx]) {\n\tint vb = (ms[vy][vx] >= 0) ? u.b | (1 << ms[vy][vx]) : u.b;\n\tif (dists[vy][vx][vb] > vd) {\n\t  dists[vy][vx][vb] = vd;\n\t  q.push(Stat(vd, vx, vy, vb));\n\t}\n      }\n    }\n  }\n\n  printf(\"%d\\n\", dists[gy][gx][mbits - 1]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\n#include <cstdio>\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#include <set>\nusing namespace std;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\n\nchar g[128][128];\nint d[128][128];\n\nint memo[1 << 5][100][100];\nint m[100][100];\n\nint main(){\n  const int w = getInt();\n  const int h = getInt();\n\n  REP(i,h) scanf(\"%s\", g[i]);\n\n  REP(i,h) REP(j,w) d[i][j] = 1;\n  REP(i,h) REP(j,w) if(g[i][j] == '#'){\n    REP(ii,5) REP(jj, 5){\n      const int y = i + (ii - 2);\n      const int x = j + (jj - 2);\n      d[y][x] = max(d[y][x], 4 - max(abs(y - i), abs(x - j)));\n    }\n  }\n\n  memset(memo, -1, sizeof(memo));\n\n  typedef pair<int, pair<int, pair<int, int> > > data;\n\n  priority_queue<data, vector<data>, greater<data> > pq;\n  REP(i,h) REP(j,w) if(g[i][j] == 'S')\n    pq.push(make_pair(0, make_pair(0, make_pair(j, i))));\n\n  int cnt = 0;\n  REP(i,h) REP(j,w) if(g[i][j] == 'M'){\n    m[i][j] = cnt++;\n  }\n\n  while(pq.size()){\n    const data dt = pq.top(); pq.pop();\n    const int cost = dt.first;\n    const int maki = dt.second.first;\n\n    const int x = dt.second.second.first;\n    const int y = dt.second.second.second;\n    const int cc = cost + d[y][x];\n\n    if(maki == (1 << cnt) - 1 && g[y][x] == 'G'){\n      printf(\"%d\\n\", cost);\n      break;\n    }\n    if(memo[maki][y][x] != -1) continue;\n    memo[maki][y][x] = cost;\n\n    REP(i,4){\n      const int xx = x + _dx[i];\n      const int yy = y + _dy[i];\n\n      if(ISIN(xx, yy, w, h) && g[yy][xx] != '#'){\n\tint mm = maki;\n\tif(g[yy][xx] == 'M'){\n\t  mm |= (1 << m[yy][xx]);\n\t}\n\tif(memo[mm][yy][xx] == -1){\n\t  pq.push(make_pair(cc, make_pair(mm, make_pair(xx, yy))));\n\t}\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1 << 28;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int ddx[] = {1, 1, 0, -1, -1, -1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2, 2};\nconst int ddy[] = {0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2, 2, 2, 2, 2, 1};\n\nint main()\n{\n  int W, H;\n  while (cin >> W >> H) {\n    vector<string> tile(H);\n    for (int i = 0; i < H; ++i)\n      cin >> tile[i];\n\n    int sx, sy, tx, ty;\n    vector<vector<int> > map(H, vector<int>(W, 1));\n    vector<pair<int, int> > m;\n    for (int y = 0; y < H; ++y) {\n      for (int x = 0; x < W; ++x) {\n        if (tile[y][x] == 'S') {\n          sx = x;\n          sy = y;\n        } else if (tile[y][x] == 'G') {\n          tx = x;\n          ty = y;\n        } else if (tile[y][x] == 'M') {\n          m.push_back(make_pair(x, y));\n        } else if (tile[y][x] == '#') {\n          map[y][x] = INF;\n        }\n      }\n    }\n\n    for (int y = 0; y < H; ++y) {\n      for (int x = 0; x < W; ++x) {\n        if (map[y][x] != INF)\n          continue;\n        for (int d = 0; d < 24; ++d) {\n          int xx = x + ddx[d];\n          int yy = y + ddy[d];\n          if (xx < 0 || xx >= W || yy < 0 || yy >= H)\n            continue;\n          if (d < 8)\n            map[yy][xx] = max(map[yy][xx], 3);\n          else\n            map[yy][xx] = max(map[yy][xx], 2);          \n        }\n      }\n    }\n\n    sort(m.begin(), m.end());\n    m.insert(m.begin(), make_pair(sx, sy));\n    m.push_back(make_pair(tx, ty));\n    vector<vector<int> > indexer(H, vector<int>(W));\n    for (int i = 0; i < (int)m.size(); ++i)\n      indexer[m[i].second][m[i].first] = i;\n\n    vector<vector<int> > cost(m.size(), vector<int>(m.size(), INF));\n    for (unsigned int i = 0; i < m.size(); ++i) {\n      for (unsigned int j = 0; j < m.size(); ++j) {\n        queue<pair<int, int> > que;\n        que.push(m[i]);\n        vector<vector<int> > dp(H, vector<int>(W, INF));\n        dp[m[i].second][m[i].first] = 0;\n        while (!que.empty()) {\n          pair<int, int> p = que.front();\n          que.pop();\n          if (p == m[j]) {\n            cost[i][j] = dp[p.second][p.first];\n            break;\n          }\n\n          for (int d = 0; d < 4; ++d) {\n            int xx = p.first + dx[d];\n            int yy = p.second + dy[d];\n            if (xx < 0 || xx >= W || yy < 0 || yy >= H || map[yy][xx] == INF ||\n                dp[yy][xx] <= dp[p.second][p.first] + map[p.second][p.first])\n              continue;\n            dp[yy][xx] = dp[p.second][p.first] + map[p.second][p.first];\n            que.push(make_pair(xx, yy));\n          }\n        }\n      }\n    }\n    \n    int ans = INF;\n    do {\n      int ret = 0;\n      for (unsigned int i = 1; i < m.size(); ++i)\n        ret += cost[indexer[m[i-1].second][m[i-1].first]][indexer[m[i].second][m[i].first]];\n      ans = min(ans, ret);\n    } while (next_permutation(m.begin()+1, m.end()-1));\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define INF 1e9\nusing namespace std;\nstring mp[N];\nint D[101][101][1<<5];\nint used[101][101];\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint dx[] ={0,0,1,-1};\nint dy[] ={1,-1,0,0};\nint w,h;\n\nvoid bfs(){\n  memset(used,-1,sizeof(used));\n  queue<P> Q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)if(mp[i][j]=='#')Q.push(P(i,j)),used[i][j] = 0;\n  \n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    int y = t.first;\n    int x = t.second;\n    for(int i=-1;i<=1;i++)\n      for(int j=-1;j<=1;j++){\n\tif(i==0&&j==0)continue;\n\tint nx = x+i;\n\tint ny = y+j;\n\tif(nx<0||ny<0||nx>=w||ny>=h||used[ny][nx]!=-1)continue;\n\tused[ny][nx] = used[y][x] + 1;\n\tQ.push(P(ny,nx));\n      }\n  }\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) used[i][j]=max(1,used[i][j]);\n  \n  \n} \n\n\nint dijkstra(int sy,int sx){\n  map<P,int> M;\n  int cnt=0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)if(mp[i][j] == 'M') M[P(i,j)] = cnt++;\n  \n  for(int i=0;i<101;i++)\n    for(int j=0;j<101;j++)\n      for(int k=0;k<(1<<5);k++) D[i][j][k] = INF; \n  \n  //priority_queue<PP,vector<PP>,greater<PP> >Q;  \n  queue<PP> Q;\n  Q.push(PP(P(0,sy),P(sx,0)));\n  D[sy][sx][0] = 0;\n  while(!Q.empty()){\n    PP t = Q.front();Q.pop();\n    int cost = t.first.first;\n    int y = t.first.second;\n    int x = t.second.first;\n    int bit = t.second.second;\n    if(mp[y][x] =='G' && bit==(1<<cnt)-1)return cost;\n    if(D[y][x][bit]<cost) continue;\n    \n    for(int i=0;i<4;i++){\n      int nx = x+dx[i];\n      int ny = y+dy[i];\n      int nbit = bit;\n      int ncost = cost+4-used[y][x];\n      if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx] == '#')continue;\n      if(D[ny][nx][nbit]<=ncost)continue;\n      if(mp[ny][nx] == 'M') nbit |= 1<<(M[P(ny,nx)]); \n      Q.push(PP(P(ncost,ny),P(nx,nbit)));\n      D[ny][nx][nbit] = ncost;\n    }\n  }\n  assert(0);\n}\n\n\nint main(){\n\n  cin>>w>>h;\n  for(int i=0;i<h;i++) cin>>mp[i];\n\n  bfs();\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j] == 'S') cout<<dijkstra(i,j)<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n#define y first\n#define x second\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\nconst int INF = 1e9;\n\nint my3[8] = {0, 0, 1, -1, 1, 1, -1, -1};\nint mx3[8] = {1, -1, 0, 0, -1, 1, 1, -1};\nint my2[16] = {-2, -2, -2, -2, -2, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1};\nint mx2[16] = {-2, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2};\nint my[4] = {0, 0, 1, -1};\nint mx[4] = {1, -1, 0, 0};\n\nint H, W;\n\nint dist(P &a, P &b, vector< vector<int> > &v){\n  priority_queue<PP, vector<PP>, greater<PP> > open;\n  open.push(PP(0, P(a.y, a.x)));\n  vector< vector<int> > closed(H, vector<int>(W, INF));\n  while(!open.empty()){\n    PP tmp = open.top(); open.pop();\n    int s = tmp.first;\n    P now = tmp.second;\n    if(now == b) return s;\n    REP(i, 4){\n      int ny = now.y + my[i], nx = now.x + mx[i];\n      if(ny >= 0 && nx >= 0 && ny < H && nx < W && v[ny][nx] != INF && closed[ny][nx] > s + v[now.y][now.x]){\n        closed[ny][nx] = s + v[now.y][now.x];\n        open.push(PP(closed[ny][nx], P(ny, nx)));\n      }\n    }\n  }\n  return -1;\n}\n\nint solve(vector< vector<int> > &d, int m, P &s, P &g, vector<P> &ms, vector< vector<int> > &v){\n  vector< vector<int> > dp((1 << m), vector<int>(m, INF));\n  REP(i, m) dp[(1 << i)][i] = dist(s, ms[i], v);\n  REP(i, (1 << m)){\n    REP(j, m){\n      if(dp[i][j] == INF) continue;\n      REP(next, m){\n        if(((1 << next) & i) != 0) continue;\n        int c = d[j][next], n = ((1 << next) | i);\n        dp[n][next] = min(dp[n][next], dp[i][j] + c);\n      }\n    }\n  }\n  int res = INF;\n  REP(i, m) res = min(res, dp[(1 << m) - 1][i] + dist(ms[i], g, v));\n  return res;\n}\n\nint main() {\n  cin >>W >>H;\n  vector<string> cv(H);\n  REP(i, H) cin >>cv[i];\n  vector< vector<int> > v(H, vector<int>(W, 1));\n  vector<P> ms;\n  P s, g;\n  REP(y, H){\n    REP(x, W){\n      if(cv[y][x] == 'M') ms.push_back(P(y, x));\n      if(cv[y][x] == 'S') s = P(y, x);\n      if(cv[y][x] == 'G') g = P(y, x);\n      if(cv[y][x] != '#') continue;\n      v[y][x] = INF;\n      REP(i, 8){\n        int ny = y + my3[i], nx = x + mx3[i];\n        if(ny >= 0 && nx >= 0 && ny < H && nx < W) v[ny][nx] = max(3, v[ny][nx]);\n      }\n      REP(i, 16){\n        int ny = y + my2[i], nx = x + mx2[i];\n        if(ny >= 0 && nx >= 0 && ny < H && nx < W) v[ny][nx] = max(2, v[ny][nx]);\n      }\n    }\n  }\n  int msl = ms.size();\n  vector< vector<int> > d(msl, vector<int>(msl, 0));\n  REP(i, msl){\n    REP(j, msl) d[i][j] = dist(ms[i], ms[j], v);\n  }\n  cout <<solve(d, msl, s, g, ms, v) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <numeric>\n#include <queue>\n#include <cstring>\n#include <stdio.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long long ll;\ntypedef vector<ll> vll;\nconst int inf=10000000;\nint H,W,startx,starty,goalx,goaly;\nstring board[105];\nint cost[105][105];\nint d[105][105];\nbool visited[150][105];\nint dx8[]={-1,-1,0,1,1,1,0,-1};\nint dy8[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={0,1,0,-1};\nint dx[]={-1,0,1,0};\n\ntypedef pair<int,int> P;\ntypedef pair<int,pair<int,int> > PP;\n\nvoid costset(int sx,int sy,int times)\n{\n  if(times==2) return;\n  int nowx=sx;\n  int nowy=sy;\n  int cos=3-times;\n  for(int k=0;k<8;k++)\n    {\n      int nx=nowx+dx8[k];\n      int ny=nowy+dy8[k];\n      if(nx<0 || W<=nx || ny<0 || H<=ny) continue;\n      cost[ny][nx]=max(cost[ny][nx],cos);\n      costset(nx,ny,times+1);\n    }\n}\n\nint solve(int sx,int sy,int gx,int gy)\n{\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  d[i][j]=inf;\n\t}\n    }\n  d[sy][sx]=0;\n  priority_queue<PP,vector<PP> ,greater<PP>> p;\n  p.push(PP(0,P(sy,sx)));\n  int nowy,nowx;\n  while(!p.empty())\n    {\n      PP now=p.top();p.pop();\n      nowy=now.second.first;\n      nowx=now.second.second;\n      if(nowx==gx && nowy==gy) break;\n      for(int k=0;k<4;k++)\n\t{\n\t  int ny=nowy+dy[k];\n\t  int nx=nowx+dx[k];\n\t  if(ny<0 || H<=ny || nx<0 || W<=nx || board[ny][nx]=='#') continue;\n\t  if(d[nowy][nowx]+cost[nowy][nowx]>=d[ny][nx]) continue;\n\t  if(d[ny][nx]==inf || d[ny][nx]>d[nowy][nowx]+cost[nowy][nowx])\n\t    {\n\t      d[ny][nx]=d[nowy][nowx]+cost[nowy][nowx];\n\t      p.push(PP(d[ny][nx],P(ny,nx)));\n\t    }\n\t}\n    }\n  return d[gy][gx];\n}\n\nint main(int argc,char const* argv[])\n{\n  int ans=20000000;\n  int scroll=0;\n  int pat=1;\n  int graph[10][10];\n  for(int i=0;i<10;i++)\n    {\n      for(int j=0;j<10;j++)\n\t{\n\t  graph[i][j]=inf;\n\t}\n    }\n  vector<P> route;\n  cin >> W >> H;\n  for(int i=0;i<H;i++)\n    {\n      cin >> board[i];\n    }\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  cost[i][j]=1;\n\t  if(board[i][j]=='M') route.push_back(P(i,j));\n\t  if(board[i][j]=='G') {goaly=i;goalx=j;}\n\t  if(board[i][j]=='S') {starty=i;startx=j;}\n\t}\n    }\n  sort(route.begin(),route.end());\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  if(board[i][j]=='#')\n\t    {\n\t      costset(j,i,0);\n\t    }\n\t  if(board[i][j]=='M')\n\t    {\n\t      scroll++;\n\t    }\n\t}\n    }\n  for(int i=0;i<route.size();i++)\n    {\n      graph[0][i+1]=solve(startx,starty,route[i].second,route[i].first);\n      graph[i+1][6]=solve(route[i].second,route[i].first,goalx,goaly);\t\t\t\t\t      \n      for(int j=0;j<route.size();j++)\n\t{\n\t  if(i==j) continue;\n\t  int stx=route[i].second;\n\t  int sty=route[i].first;\n\t  int gox=route[j].second;\n\t  int goy=route[j].first;\n\t  graph[i+1][j+1]=solve(stx,sty,gox,goy);\n\t  graph[j+1][i+1]=graph[i+1][j+1];\n\t}\n    }\n   vector<int> walk(scroll);\n   iota(walk.begin(),walk.end(),1);\n   do\n     {\n       int tmp=0;\n       int prev=0;\n       int to=0;\n       for(auto x:walk) \n\t {\n\t   to=x;\n\t   tmp+=graph[prev][to];\n\t   prev=x;\n\t }\n       tmp+=graph[to][6];\n       ans=min(ans,tmp);\n     } while(next_permutation(walk.begin(),walk.end()));\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int dx2[] = {1,-1,-2,-2,-1,1,2,2};\nconst int dy2[] = {2,2,1,-1,-2,-2,-1,1};\nconst int INF = 1<<30;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\ntypedef pair<int,int> Pii;\ntypedef pair<Pii,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint T[128][128];\nint W,H;\nvector < Pii > target;\nchar stage[128][128];\nP s,g;\nint D[8][8];\nint dp[1<<8][8];\nstruct data\n{\n    Pii p;\n    int cost;\n    data(){}\n    data(Pii _p,int _cost){\n        p = _p;\n        cost = _cost;\n    }\n    bool operator<(const data &a)const{\n        return a.cost < cost;\n    }\n};\nvoid getPath(int a){\n    int m[128][128];\n    memset(m,-1,sizeof(m));    \n    priority_queue < data > PQ;\n    PQ.push(data(target[a],0));\n    while(!PQ.empty()){\n        data d = PQ.top();PQ.pop();\n        if(m[d.p.fr][d.p.sc] != -1)continue;\n        m[d.p.fr][d.p.sc] = d.cost;\n        rep(i,4){\n            int ny = d.p.fr + dy[i];\n            int nx = d.p.sc + dx[i];\n            if(ny < 0 || ny > H-1 || nx < 0 || nx > W-1)continue;\n            if(m[ny][nx] != -1 || stage[ny][nx] == '#')continue;\n            PQ.push(data(Pii(ny,nx),d.cost+T[d.p.fr][d.p.sc]));\n        }\n    }\n\n    rep(i,target.size()){\n        if(i == a)D[a][i] = 0;\n        D[a][i] = m[target[i].fr][target[i].sc];\n    }\n    return ;\n}\nint getMin(int bit,int prev){\n    if(dp[bit][prev] != -1)return dp[bit][prev];\n    int ret = INF;\n    rep(i,target.size()){\n        if(i == g.sc)continue;\n        if(!(1&(bit>>i))){\n            ret = min(ret,D[prev][i]+getMin(bit|1<<i,i));\n        }\n    }\n    if(ret == INF)ret = D[prev][g.sc];\n    return dp[bit][prev] = ret;\n}\nint main(){\n    scanf(\"%d%d\",&W,&H);\n    bool memo[128][128] = {{false}};\n    fill((int*)T,(int*)(T+lengthof(T)),1);\n    queue < P > Q;\n    rep(i,H){\n        scanf(\"%s\",&stage[i]);\n        rep(j,W){\n            if(stage[i][j] == 'S'){\n                s.fr.fr = i;\n                s.fr.sc = j;\n                s.sc = target.size();\n                target.PB(Pii(i,j));\n                stage[i][j] = '.';\n            }\n            if(stage[i][j] == 'G'){\n                g.fr.fr = i;\n                g.fr.sc = j;\n                g.sc = target.size();\n                target.PB(Pii(i,j));\n                stage[i][j] = '.';\n            }\n            if(stage[i][j] == '#'){\n                memo[i][j] = true;\n                T[i][j] = 0;\n                Q.push(P(Pii(i,j),3));\n            }\n            if(stage[i][j] == 'M'){\n                target.PB(Pii(i,j));\n            }\n        }\n    }\n    while(!Q.empty()){\n        P p = Q.front();Q.pop();\n        if(p.sc == 1)continue;\n        rep(i,8){\n            int ny = p.fr.fr + dy[i]*(4-p.sc);\n            int nx = p.fr.sc + dx[i]*(4-p.sc);\n            if(ny < 0 || ny > H-1 || nx < 0 || nx > W-1)continue;\n            if(memo[ny][nx]++)continue;\n            T[ny][nx] = p.sc;\n            Q.push(P(Pii(p.fr.fr,p.fr.sc),p.sc-1));\n        }\n        if(p.sc == 2){\n            rep(i,8){\n                int ny = p.fr.fr + dy2[i];\n                int nx = p.fr.sc + dx2[i];\n                if(ny < 0 || ny > H-1 || nx < 0 || nx > W-1)continue;\n                if(memo[ny][nx]++)continue;\n                T[ny][nx] = p.sc;\n                Q.push(P(Pii(p.fr.fr,p.fr.sc),p.sc-1));       \n            }\n        }\n    }\n    rep(i,target.size()){\n        getPath(i);\n    }\n    fill((int*)dp,(int*)(dp+lengthof(dp)),-1);\n    printf(\"%d\\n\",getMin(1<<(s.sc),s.sc));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<cmath>\n#include<map>\n#include<set>\n#include<climits>\n#include<ctime>\n#include<complex>\n#include<sstream>\n#include<cstring>\nusing namespace std;\ntypedef vector<string>vs;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\ntypedef vector<double>vd;\ntypedef pair<int,int>pii;\ntypedef long long ll;\ntypedef pair<ll,ll>pll;\ntypedef vector<ll>vl;\n#define rrep(i,x,n) for(int i=(x);i<(n);++i)\n#define rep(i,x) rrep(i,0,(x))\n#define fi first\n#define se second\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define maxs(a,b) (a)=max(a,b)\n#define mins(a,b) (a)=min(a,b)\ntypedef pair<int,pii>piii;\nint dx[]={-1,0,1,0};\nint dy[]={0,1,0,-1};\n\nint W,H,N;\nchar fld[100][100];\nint cost[100][100];\nint dist[7][7];\nvector<pii>pos;\n\nvoid prp(){\n    int dx1[]={-1,0,1,-1},dy1[]={-1,-1,-1,0};\n    int dx2[]={1,0,-1,1},dy2[]={1,1,1,0};\n\n    rep(i,H){\n        rep(j,W){\n            rep(k,4){\n                int ty=i+dy1[k],tx=j+dx1[k];\n                if(ty<0||tx<0)continue;\n                cost[i][j]=max(cost[i][j],cost[ty][tx]-1);\n            }\n        }\n    }\n\n    for(int i=H-1;i>=0;i--){\n        for(int j=W-1;j>=0;j--){\n            rep(k,4){\n                int ty=i+dy2[k],tx=j+dx2[k];\n                if(tx>=W||ty>=H)continue;\n                cost[i][j]=max(cost[i][j],max(cost[ty][tx]-1,1));\n            }\n        }\n    }\n}\n\nvoid bfs(int s){\n    priority_queue<piii,vector<piii>,greater<piii> >Q;\n    Q.push(piii(0,pii(pos[s].fi,pos[s].se)));\n    int D[100][100];fill_n(*D,10000,1e9);\n    while(!Q.empty()){\n        piii p=Q.top();Q.pop();\n        if(D[p.se.fi][p.se.se]<=p.fi)continue;\n        D[p.se.fi][p.se.se]=p.fi;\n\n        rep(i,4){\n            int ty=p.se.fi+dy[i],tx=p.se.se+dx[i];\n            if(ty<0||ty>=H||tx<0||tx>=W)continue;\n            if(cost[ty][tx]==4)continue;\n            Q.push(piii(p.fi+cost[p.se.fi][p.se.se],pii(ty,tx)));\n        }\n    }\n\n    rep(i,N){\n        dist[s][i]=D[pos[i].fi][pos[i].se];\n    }\n}\nint main(){\n    fill_n(*cost,100*100,1);\n    scanf(\"%d%d\",&W,&H);\n    rep(i,H)scanf(\"%s\",fld[i]);\n    pos.resize(1);\n    int sy,sx,gy,gx;\n    rep(i,H){\n        rep(j,W){\n            if(fld[i][j]=='S'){\n                sy=i;sx=j;\n                pos[0]=pii(i,j);\n            }\n            else if(fld[i][j]=='G'){\n                gy=i;gx=j;\n            }\n            else if(fld[i][j]=='#')cost[i][j]=4;\n            else if(fld[i][j]=='M'){\n                pos.pb(pii(i,j));\n            }\n        }\n    }\n    pos.pb(pii(gy,gx));\n\n    N=pos.size();\n\n    prp();\n\n    rep(i,N)bfs(i);\n\n    vi perm(N);rep(i,N)perm[i]=i;\n    int mi=INT_MAX;\n    do{\n        int sum=0;\n        rep(i,N-1)sum+=dist[perm[i]][perm[i+1]];\n        mi=min(mi,sum);\n\n    }while(next_permutation(perm.begin()+1,perm.end()-1));\n\n    printf(\"%d\\n\",mi);\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <stdio.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long long ll;\ntypedef vector<ll> vll;\nconst int inf=10000000;\nint H,W,startx,starty,goalx,goaly;\nstring board[105];\nint cost[105][105];\nint d[105][105];\nint dx8[]={-1,-1,0,1,1,1,0,-1};\nint dy8[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={0,1,0,-1};\nint dx[]={-1,0,1,0};\n\ntypedef pair<int,int> P;\nvector<P> route;\n\nvoid costset(int sx,int sy,int times)\n{\n  if(times==2) return;\n  int nowx=sx;\n  int nowy=sy;\n  int cos=3-times;\n  for(int k=0;k<8;k++)\n    {\n      int nx=nowx+dx8[k];\n      int ny=nowy+dy8[k];\n      if(nx<0 || W<=nx || ny<0 || H<=ny) continue;\n      cost[ny][nx]=max(cost[ny][nx],cos);\n      costset(nx,ny,times+1);\n    }\n}\n\nint solve(int sx,int sy,int gx,int gy)\n{\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  d[i][j]=inf;\n\t}\n    }\n  d[sy][sx]=0;\n  queue<P> p;\n  p.push(P(sy,sx));\n  int nowy,nowx;\n  while(!p.empty())\n    {\n      P now=p.front();p.pop();\n      nowy=now.first;\n      nowx=now.second;\n      if(nowx==gx && nowy==gy) break;\n      for(int k=0;k<4;k++)\n\t{\n\t  int ny=nowy+dy[k];\n\t  int nx=nowx+dx[k];\n\t  if(ny<0 || H<=ny || nx<0 || W<=nx || board[ny][nx]=='#') continue;\n\t  if(d[nowy][nowx]+cost[ny][nx]>d[ny][nx]) continue;\n\t  d[ny][nx]=d[nowy][nowx]+cost[nowy][nowx];\n\t  p.push(P(ny,nx));\n\t}\n    }\n  return d[gy][gx];\n}\n\nint main(int argc,char const* argv[])\n{\n  int ans=20000000;\n  int scroll=0;\n  int pat=1;\n  cin >> W >> H;\n  for(int i=0;i<H;i++)\n    {\n      cin >> board[i];\n    }\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  cost[i][j]=1;\n\t  if(board[i][j]=='M') route.push_back(P(i,j));\n\t  if(board[i][j]=='G') {goaly=i;goalx=j;}\n\t  if(board[i][j]=='S') {starty=i;startx=j;}\n\t}\n    }\n  sort(route.begin(),route.end());\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  if(board[i][j]=='#')\n\t    {\n\t      costset(j,i,0);\n\t    }\n\t  if(board[i][j]=='M')\n\t    {\n\t      scroll++;\n\t    }\n\t}\n    }\n   for(int i=1;i<=scroll;i++)\n     {\n       pat*=i;\n     }\n   for(int j=0;j<pat;j++)\n     {\n       vector<P> road;\n       vector<int> walk;\n       for(auto tmp:route) \n\t {\n\t   road.push_back(P(tmp.first,tmp.second));\n\t }\n      walk.push_back(solve(startx,starty,road[0].second,road[0].first));\n      for(int i=0;i<road.size()-1;i++)\n\t{\n\t  walk.push_back(solve(road[i].second,road[i].first,road[i+1].second,road[i+1].first));\n\t}\n      walk.push_back(solve(road[road.size()-1].second,road[road.size()-1].first,goalx,goaly));\n      int tmp=0;\n      for(int i=0;i<walk.size();i++)\n\t{\n\t  tmp+=walk[i];\n\t}\n      ans=min(ans,tmp);\n      next_permutation(route.begin(),route.end());\n    }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define  f first \n#define  s second \nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint w,h,c=1,sx,sy,gx,gy;\nchar mp[101][101];\nint bt[101][101];\nint cs[101][101];\nint nn[5][5]=\n  {{2,2,2,2,2},\n   {2,3,3,3,2},\n   {2,3,1e8,3,2},\n   {2,3,3,3,2},\n   {2,2,2,2,2}\n  };\nint used[100][101][101];\n \nvoid nu(int x,int y){\n  for(int i=0;i<5;i++)\n    for(int j=0;j<5;j++){\n      int nx=x+j-2,ny=y+i-2;\n      if(nx<0||w<=nx||ny<0||h<=ny)continue;\n      cs[ny][nx]=max(nn[i][j],cs[ny][nx]);\n    }\n}\n \nint cal(){\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(P(0,0),P(sx,sy)));\n  int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n  while(!Q.empty()){\n    PP p=Q.top();\n    Q.pop();\n    if(p.s.f==gx&&p.s.s==gy&&p.f.s==c-1)return p.f.f;\n    if(used[p.f.s][p.s.s][p.s.f]==1)continue;\n    used[p.f.s][p.s.s][p.s.f]=1;\n    for(int i=0;i<4;i++){\n      int nx=p.s.f+dx[i],ny=p.s.s+dy[i];\n      int ncs=p.f.f+cs[p.s.s][p.s.f],nbt=p.f.s|bt[p.s.s][p.s.f];\n      if(nx<0||w<=nx||ny<0||h<=ny)continue;\n      Q.push(PP(P(ncs,nbt),P(nx,ny)));\n    }\n  }\n}\n \n \nint main(){\n  cin>>w>>h;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++){\n      cin>>mp[i][j];\n      cs[i][j]=max(1,cs[i][j]);\n      if(mp[i][j]=='M')bt[i][j]=c,c*=2;\n      if(mp[i][j]=='#')nu(j,i);\n      if(mp[i][j]=='S')sx=j,sy=i;\n      if(mp[i][j]=='G')gx=j,gy=i;\n    }\n  cout<<cal()<<endl; \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <cctype>\n#include <functional>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main(){\n\tint INF = (int)1e9;\n\n\tvector<vector<char> > field(108, vector<char>(108, '#') );\n\tvector<vector<int> > tm(108, vector<int>(108, 1) );\n\n\tint w, h;\n\tscanf(\"%d%d\", &w, &h);\n\tfor(int i = 3; i < h + 3; ++i){\n\t\tscanf(\" %s\", &field[i][3]);\n\t\tfield[i][w + 3] = '#';\n\t}\n\n\tvector<pii> roll(2);\n\n\tqueue<pii> q;\n\tfor(int i = 3; i < h + 3; ++i){\n\t\tfor(int j = 3; j < w + 3; ++j){\n\t\t\tswitch( field[i][j] ){\n\t\t\t\tcase '#':\n\t\t\t\t\tfor(int y = i - 2; y <= i + 2; ++y)\n\t\t\t\t\tfor(int x = j - 2; x <= j + 2; ++x){\n\t\t\t\t\t\tint t = 4 - max(abs(y - i), abs(x - j));\n\t\t\t\t\t\ttm[y][x] = max(tm[y][x], t);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\troll[1] = pii(i, j);\n\t\t\t\t\tfield[i][j] = '1';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'G':\n\t\t\t\t\troll[0] = pii(i, j);\n\t\t\t\t\tfield[i][j] = '0';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\tfield[i][j] = '0' + roll.size();\n\t\t\t\t\troll.push_back( pii(i, j) );\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tint n = roll.size();\n\tvector<vector<int> > dist(n, vector<int>(n, INF) );\n\t\n\tfor(int i = 1; i < n; ++i){\n\t\tvector<vector<int> > d(108, vector<int>(108, INF) );\n\t\td[roll[i].first][roll[i].second] = 0;\n\t\t\n\t\tpriority_queue<pii,vector<pii>,greater<pii> > pq;\n\t\tpq.push( pii(0, roll[i].first * 1000 + roll[i].second) );\n\t\t\n\t\twhile( !pq.empty() ){\n\t\t\tpii p = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tint y = p.second / 1000;\n\t\t\tint x = p.second % 1000;\n\n\t\t\tif( d[y][x] != p.first ) continue;\n\n\t\t\tif( isdigit( field[y][x] ) ){\n\t\t\t\tdist[i][field[y][x] - '0'] = p.first;\n\t\t\t}\n\n\t\t\tint c = p.first + tm[y][x];\n\n\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\tint ny = y + dy[j];\n\t\t\t\tint nx = x + dx[j];\n\t\t\t\t\n\t\t\t\tif( field[ny][nx] != '#' && d[ny][nx] > c ){\n\t\t\t\t\td[ny][nx] = c;\n\t\t\t\t\tpq.push( pii(c, ny * 1000 + nx) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tint last = 1 << n;\n\tvector<vector<int> > dp(n, vector<int>(last, INF) );\n\tdp[1][2] = 0;\n\n\tfor(int S = 0; S < last; ++S){\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif( S & 1 << i ){\n\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\tif( !(S & 1 << j) ){\n\t\t\t\t\t\tint next = S | 1 << j;\n\t\t\t\t\t\tdp[j][next] = min(dp[j][next], dp[i][S] + dist[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dp[0].back());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint dx1[]={-1,0,1,-1,1,-1,0,1};\nint dy1[]={-1,-1,-1,0,0,1,1,1};\nint dx2[]={-2,-1,0,1,2,-2,2,-2,2,-2,2,-2,-1,0,1,2};\nint dy2[]={-2,-2,-2,-2,-2,-1,-1,0,0,1,1,2,2,2,2,2};\nint aa[110][110][1<<6]={-1};\nvoid mainmain(){\n\tint w,h;\n\tcin>>w>>h;\n\tvvint vv;\n\trep(i,110){\n\t\trep(j,110){\n\t\t\trep(k,1<<6) aa[i][j][k]=-1;\n\t\t}\n\t}\n\t// vvint aa;\n\tvvint mm;\n\tinitvv(vv,h,w,1);\n\t// initvv(aa,h,w,INF);\n\tinitvv(mm,h,w,-1);\n\tint M=0;\n\tpii S,G;\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tchar t;\n\t\t\tcin>>t;\n\t\t\tif(t=='S'){\n\t\t\t\tS=mkp(i,j);\n\t\t\t}\n\t\t\telse if(t=='G'){\n\t\t\t\tG=mkp(i,j);\n\t\t\t}\n\t\t\telse if(t=='M'){\n\t\t\t\tmm[i][j]=M++;\n\t\t\t}\n\t\t\telse if(t=='#'){\n\t\t\t\tvv[i][j]=-1;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tif(vv[i][j]==-1){\n\t\t\t\trep(k,8){\n\t\t\t\t\tif(0<=dx1[k]+j&&dx1[k]+j<w&&0<=dy1[k]+i&&dy1[k]+i<h){\n\t\t\t\t\t\tif(vv[dy1[k]+i][dx1[k]+j]==-1) continue;\n\t\t\t\t\t\tvv[dy1[k]+i][dx1[k]+j]=max(vv[dy1[k]+i][dx1[k]+j],3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(k,16){\n\t\t\t\t\tif(0<=dx2[k]+j&&dx2[k]+j<w&&0<=dy2[k]+i&&dy2[k]+i<h){\n\t\t\t\t\t\tif(vv[dy2[k]+i][dx2[k]+j]==-1) continue;\n\t\t\t\t\t\tvv[dy2[k]+i][dx2[k]+j]=max(vv[dy2[k]+i][dx2[k]+j],2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// rep(i,h){\n\t\t// rep(j,w){\n\t\t\t// printf(\"%2d\",vv[i][j]);\n\t\t\t// cout<<vv[i][j]<<\" \";\n\t\t// }\n\t\t// cout<<endl;\n\t// }\n\t// cout<<endl;\n\t// rep(i,h){\n\t\t// rep(j,w){\n\t\t\t// printf(\"%2d\",mm[i][j]);\n\t\t\t// cout<<vv[i][j]<<\" \";\n\t\t// }\n\t\t// cout<<endl;\n\t// }\n\t// cout<<endl;\n\tint dx[]={0,0,1,-1};\n\tint dy[]={1,-1,0,0};\n\tpriority_queue<pair<pii,pii> > pq;\n\tpq.push(mkp(mkp(0,0),S));\n\twhile(!pq.empty()){\n\t\tpair<pii,pii> top=pq.top();\n\t\tpq.pop();\n\t\t// bitset<6> tt=top.F.S;\n\t\tif(aa[top.S.F][top.S.S][top.F.S]>=0) continue;\n\t\t// cout<<top.S.F<<\" \"<<top.S.S<<\" \"<< tt.to_string() <<\" \"<<top.F.S<<\" \"<<-top.F.F<<endl;\n\t\taa[top.S.F][top.S.S][top.F.S]=-top.F.F;\n\t\tif(mm[top.S.F][top.S.S]!=-1){\n\t\t\ttop.F.S|=1<<mm[top.S.F][top.S.S];\n\t\t\t// if(aa[top.S.F][top.S.S][top.F.S]>=0) continue;\n\t\t}\n\t\taa[top.S.F][top.S.S][top.F.S]=-top.F.F;\n\t\tif(top.S==G&&top.F.S==(1<<M)-1) break;\n\t\trep(i,4){\n\t\t\tint y=top.S.F+dy[i],x=top.S.S+dx[i];\n\t\t\tif(0<=x&&x<w&&0<=y&&y<h){\n\t\t\t\tif(aa[y][x][top.F.S]==-1&&vv[y][x]!=-1){\n\t\t\t\t\t// if(x==5&&y==6&&top.F.S==5) cout<<-top.F.F<<\" hoge\\n\";\n\t\t\t\t\tpq.push(mkp(mkp(top.F.F-vv[top.S.F][top.S.S],top.F.S),mkp(y,x)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<aa[G.F][G.S][(1<<M)-1]<<endl;\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<tuple>\nusing namespace std;\nint H, W, x[102][102], sx, sy, gx, gy, dist[102][102][32];\nvector<pair<int, int>>vec;\nqueue<tuple<int, int, int>>Q;\nint main() {\n\tcin >> W >> H;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == '.')x[i][j] = 1;\n\t\t\tif (c == '#')x[i][j] = 114514;\n\t\t\tif (c == 'S') { x[i][j] = 1; sx = i; sy = j; }\n\t\t\tif (c == 'G') { x[i][j] = 1; gx = i; gy = j; }\n\t\t\tif (c == 'M') { x[i][j] = 1; vec.push_back(make_pair(i, j)); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (x[i][j] != 114514)continue;\n\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\tfor (int l = -2; l <= 2; l++) {\n\t\t\t\t\tint cx = i + k, cy = j + l;\n\t\t\t\t\tif (cx <= 0 || cx > H || cy <= 0 || cy > W)continue;\n\t\t\t\t\tx[cx][cy] = max(x[cx][cy], 4 - max(abs(k), abs(l)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 102; i++) { for (int j = 0; j < 102; j++) { for (int k = 0; k < 32; k++)dist[i][j][k] = 999999999; } }\n\tQ.push(make_tuple(sx, sy, 0)); dist[sx][sy][0] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = get<0>(Q.front()), a2 = get<1>(Q.front()), a3 = get<2>(Q.front()); Q.pop();\n\t\tint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint cx = a1 + dx[i], cy = a2 + dy[i];\n\t\t\tif (cx <= 0 || cx > H || cy <= 0 || cy > W)continue;\n\t\t\tif (x[cx][cy] == 114514)continue;\n\t\t\tint a4 = dist[a1][a2][a3] + x[a1][a2];\n\t\t\tint a5 = a3;\n\t\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\t\tif (vec[j].first == cx && vec[j].second == cy)a5 += (1 << j);\n\t\t\t}\n\t\t\tif (dist[cx][cy][a5] > a4) {\n\t\t\t\tdist[cx][cy][a5] = a4; Q.push(make_tuple(cx, cy, a5));\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[gx][gy][(1 << vec.size()) - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nconst int INF = 0xffffff;\n\nint w, h;\nint ans = INF;\npair<int, int> s, g;\nvector<pair<int, int> > m;\nvector<vector<int> > cost;\nconst int dx[4] = {0, 0, 1, -1};\nconst int dy[4] = {1, -1, 0, 0};\n\ntypedef pair<int, pair<int, int> > P;\n\nint dijkstra(pair<int, int> s, pair<int, int> t) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tvector<vector<int> > d(h, vector<int>(w, INF));\n\td[s.first][s.second] = 0;\n\tque.push(P(0, s));\n\t\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint x = p.second.second;\n\t\tint y = p.second.first;\n\n\t\tif(x == t.second && y == t.first)\n\t\t\treturn d[y][x];\n\n\t\tif(d[y][x] < p.first)\n\t\t\tcontinue;\n\n\t\tfor(int i = 0; i < 4; ++i) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif(nx < 0 || ny < 0 || nx >= w || ny >= h || cost[ny][nx] == INF)\n\t\t\t\tcontinue;\n\n\t\t\tif(d[ny][nx] > d[y][x] + cost[y][x]) {\n\t\t\t\td[ny][nx] = d[y][x] + cost[y][x];\n\t\t\t\tque.push(P(d[ny][nx], make_pair(ny, nx)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(pair<int, int> pos, int visited = 0, int dist = 0) {\n\tif(dist >= ans)\n\t\treturn;\n\n\tif(visited == (1 << m.size()) - 1) {\n\t\tans = min(ans, dist + dijkstra(pos, g));\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < m.size(); ++i) {\n\t\tint bit = (1 << i);\n\t\tif(visited & bit)\n\t\t\tcontinue;\n\n\t\tdfs(m[i], visited | bit, dist + dijkstra(pos, m[i]));\n\t}\n}\n\nint main() {\n\tcin.tie(false);\n\tios::sync_with_stdio(false);\n\n\tcin >> w >> h;\n\n\tvector<string> field(h);\n\tfor(int i = 0; i < h; ++i)\n\t\tcin >> field[i];\n\n\tcost.resize(h, vector<int>(w, 1));\n\n\tfor(int i = 0; i < h; ++i) {\n\t\tfor(int j = 0; j < w; ++j) {\n\t\t\tif(field[i][j] == 'S')\n\t\t\t\ts = make_pair(i, j);\n\n\t\t\telse if(field[i][j] == 'G')\n\t\t\t\tg = make_pair(i, j);\n\n\t\t\telse if(field[i][j] == 'M')\n\t\t\t\tm.push_back(make_pair(i, j));\n\n\t\t\telse if(field[i][j] == '#') {\n\t\t\t\tfor(int x = 2; x >= 1; --x)\n\t\t\t\t\tfor(int k = -x; k <= x; ++k) if(0 <= i + k && i + k < h)\n\t\t\t\t\t\tfor(int l = -x; l <= x; ++l) if(0 <= j + l && j + l < w)\n\t\t\t\t\t\t\tcost[i + k][j + l] = max(cost[i + k][j + l], 4 - x);\n\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\n\tdfs(s);\n\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 105\n#define INF (1<<29)\ntypedef pair<int,int> P;\n\nint H,W;\nint dist[MAX][MAX]; \nchar field[MAX][MAX];\nvector<P> M,Hole;\n\nstruct State{\n  int x,y,cost,m;\n  State(){}\n  State(int x,int y,int cost,int m) : x(x), y(y), cost(cost), m(m) {}\n};\n\nbool inField(int y,int x){\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nvoid init(){\n  fill(dist[0],dist[MAX],1);\n  const int dx[] = {-1,-1,-1,0,0,1,1,1};\n  const int dy[] = {-1,0,1,-1,1,-1,0,1};\n  for(int i = 0 ; i < (int)Hole.size() ; i++){\n    int x = Hole[i].first, y = Hole[i].second;\n    for(int j = 0 ; j < 8 ; j++){\n      int nx = x + dx[j];\n      int ny = y + dy[j];\n      if(!inField(ny,nx)) continue;\n      dist[ny][nx] = max(dist[ny][nx],3);\n      for(int k = 0 ; k < 8 ; k++){\n        int nnx = nx + dx[k];\n        int nny = ny + dy[k];\n        if(!inField(nny,nnx)) continue;\n        dist[nny][nnx] = max(dist[nny][nnx],2);\n      }\n    }\n  }\n}\n\nint bfs(int sx,int sy,int gx,int gy){\n  const int dx[] = {-1,0,0,1};\n  const int dy[] = {0,-1,1,0};\n  int d[MAX][MAX];\n  fill(d[0],d[MAX],INF);\n  d[sy][sx] = 0;\n  queue<P> Q;\n  Q.push(P(sx,sy));\n\n  while(!Q.empty()){\n    P p = Q.front(); Q.pop();\n    if(p.first == gx && p.second == gy) break;\n    for(int i = 0 ; i < 4 ; i++){\n      int nx = p.first + dx[i];\n      int ny = p.second + dy[i];\n      if(!inField(ny,nx)) continue;\n      if(field[ny][nx] == '#') continue;\n      if(d[ny][nx] < d[p.second][p.first] + dist[p.second][p.first]) continue;\n      Q.push(P(nx,ny));\n      d[ny][nx] = d[p.second][p.first] + dist[p.second][p.first];\n    }\n  }\n\n  return d[gy][gx];\n}\n\nvoid solve(int sx,int sy,int gx,int gy){\n  int len = M.size(),ans = INF;\n  int d[MAX][MAX][1<<5];\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      for(int k = 0 ; k < 1<<5 ; k++){\n        d[i][j][k] = INF;\n      }\n    }\n  }\n  d[sy][sx][0] = 0;\n  queue<State> Q;\n  Q.push(State(sx,sy,0,0));   \n  init();\n\n  while(!Q.empty()){\n    State S = Q.front(); Q.pop();\n    bool ok = true;\n    for(int i = 0 ; i < len ; i++){\n      if(!(S.m >> i & 1)){\n        ok = false; \n        break;\n      } \n    }\n    if(ok && S.x == gx && S.y == gy){\n      ans = min(ans,S.cost);\n      continue;\n    }\n    if(ok){\n      S.cost += bfs(S.x,S.y,gx,gy);\n      ans = min(ans,S.cost);   \n    }else{\n      for(int i = 0 ; i < len ; i++){\n        if(S.m >> i & 1) continue;\n        State next;\n        next.cost = S.cost + bfs(S.x,S.y,M[i].first,M[i].second);\n        next.m = S.m | 1<<i; next.x = M[i].first; next.y = M[i].second;\n        if(next.cost < d[next.y][next.x][next.m]){\n          d[next.y][next.x][next.m] = next.cost;\n          Q.push(next);\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n}\n\nint main(){\n  int sx,sy,gx,gy;\n  cin >> W >> H;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> field[i][j];\n      if(field[i][j] == 'S'){\n        sx = j; sy = i;\n      }else if(field[i][j] == 'G'){\n        gx = j; gy = i;\n      }else if(field[i][j] == 'M'){\n        M.push_back(P(j,i));\n      }else if(field[i][j] == '#'){\n        Hole.push_back(P(j,i));\n      }\n    }\n  }\n  solve(sx,sy,gx,gy);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n#include<cstdlib>\n#define fs first\n#define sc second\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<P,P> P2;\n\nint w,h,sy,sx,gy,gx;\nstring room[110];\nint g[110][110];\nint d[110][110][50];\nint num;\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint main(){\n  cin >> w >> h;\n  for(int i=0;i<h;i++)cin >> room[i];\n    \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)g[i][j] = 1;\n\n  num = 0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      if(room[i][j] == '#'){\n\tfor(int k=-2;k<=2;k++){\n\t  for(int l=-2;l<=2;l++){\n\t    if(i+k<0 || j+l<0 || h<=i+k || w<=j+l)continue;\n\t    if(abs(k)<=1 && abs(l)<=1)g[i+k][j+l] = max(g[i+k][j+l],3);\n\t    else g[i+k][j+l] = max(g[i+k][j+l],2);\n\t  }\n\t}\n      }\n      if(room[i][j] == 'M'){\n\troom[i][j] = '0'+num;\n\tnum++;\n      }\n      if(room[i][j] == 'S'){ sy = i; sx = j;}\n      if(room[i][j] == 'G'){ gy = i; gx = j;}\n    }\n  }\n \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      for(int k=0;k<(1<<num);k++)d[i][j][k] = 1<<30;\n\n  d[sy][sx][0] = 0;\n  priority_queue<P2,vector<P2>,greater<P2> > q;\n  q.push(P2(P(0,0),P(sy,sx)));\n\n  while(q.size()){\n    P2 p = q.top(); q.pop();\n    int dis = p.fs.fs, st = p.fs.sc, y = p.sc.fs, x = p.sc.sc;\n\n    if(gy == y && gx == x && st == (1<<num)-1){\n      cout << dis << endl;\n      return 0;\n    }\n\n    dis += g[y][x];\n    for(int i=0;i<4;i++){\n      int ty = y+dy[i], tx = x+dx[i], tst = st;\n      if(ty<0 || tx<0 || h<=ty || w<=tx)continue;\n      if(room[ty][tx] == '#')continue;\n      if('0' <= room[ty][tx] && room[ty][tx] <= '9'){\n\ttst |= 1<<(room[ty][tx]-'0');\n      }\n      if(d[ty][tx][tst] > dis){\n\td[ty][tx][tst] = dis;\n\tq.push(P2(P(dis,tst),P(ty,tx)));\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<tuple>\nusing namespace std;\nint H, W, x[102][102], sx, sy, gx, gy, dist[102][102][32];\nvector<pair<int, int>>vec;\nqueue<tuple<int, int, int>>Q;\nint main() {\n\tcin >> W >> H;\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tchar c; cin >> c;\n\t\t\tif (c == '.')x[i][j] = 1;\n\t\t\tif (c == '#')x[i][j] = 9;\n\t\t\tif (c == 'S') { x[i][j] = 1; sx = i; sy = j; }\n\t\t\tif (c == 'G') { x[i][j] = 1; gx = i; gy = j; }\n\t\t\tif (c == 'M') { x[i][j] = 1; vec.push_back(make_pair(i, j)); }\n\t\t}\n\t}\n\tfor (int i = 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W; j++) {\n\t\t\tif (x[i][j] != 9)continue;\n\t\t\tfor (int k = -2; k <= 2; k++) {\n\t\t\t\tfor (int l = -2; l <= 2; l++) {\n\t\t\t\t\tint cx = i + k, cy = j + l;\n\t\t\t\t\tif (cx <= 0 || cx > H || cy <= 0 || cy > W)continue;\n\t\t\t\t\tx[cx][cy] = max(x[cx][cy], 4 - max(abs(k), abs(l)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 102; i++) { for (int j = 0; j < 102; j++) { for (int k = 0; k < 32; k++)dist[i][j][k] = 999999999; } }\n\tQ.push(make_tuple(sx, sy, 0)); dist[sx][sy][0] = 0;\n\twhile (!Q.empty()) {\n\t\tint a1 = get<0>(Q.front()), a2 = get<1>(Q.front()), a3 = get<2>(Q.front()); Q.pop();\n\t\tint dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint cx = a1 + dx[i], cy = a2 + dy[i];\n\t\t\tif (cx <= 0 || cx > H || cy <= 0 || cy > W)continue;\n\t\t\tif (x[cx][cy] == 9)continue;\n\t\t\tint a4 = dist[a1][a2][a3] + x[a1][a2];\n\t\t\tint a5 = a3;\n\t\t\tfor (int j = 0; j < vec.size(); j++) {\n\t\t\t\tif (vec[j].first == cx && vec[j].second == cy && (a3 / (1 << j)) % 2 == 0)a5 += (1 << j);\n\t\t\t}\n\t\t\tif (dist[cx][cy][a5] > a4) {\n\t\t\t\tdist[cx][cy][a5] = a4; Q.push(make_tuple(cx, cy, a5));\n\t\t\t}\n\t\t}\n\t}\n\tcout << dist[gx][gy][(1 << vec.size()) - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)  \nusing namespace std;\ntypedef pair<int,int> pii;\n\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nint w,h;\nint g[110][110];\n\nint dijkstra(int s, int t){\n  vector<int> dis(h*w,1e8);\n  dis[s] = 0;\n  priority_queue< pii,vector<pii>,greater<pii> > q;\n  q.push(pii(0,s));\n  \n  while(q.size()){\n    pii cur = q.top(); q.pop();\n    int y = cur.second/w, x = cur.second%w, d = cur.first;\n    if(t == cur.second)return d;\n    if(dis[cur.second] < d)continue;\n\n    rep(dir,4){\n      int ny = y+dy[dir], nx = x+dx[dir];\n      if(range(ny,0,h) && range(nx,0,w) && g[ny][nx]!=4){\n\tint nxt = ny*w + nx, nd = dis[cur.second] + g[y][x];\n\tif(dis[nxt] > nd){\n\t  dis[nxt] = nd;\n\t  q.push(pii(nd, nxt));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin >> w >> h;\n  vector<string> s(h);\n  rep(i,h){\n    cin >> s[i];\n    rep(j,w)g[i][j] = 1;\n  }\n\n  int S,G;\n  vector<int> maki;\n  rep(i,h)rep(j,w){\n    if(s[i][j] == '#'){\n      for(int ii=-2;ii<=2;ii++)for(int jj=-2;jj<=2;jj++){\n\t  int ni = i+ii, nj = j+jj;\n\t  if(range(ni,0,h) && range(nj,0,w)){\n\t    int dif = max(abs(ii),abs(jj));\n\t    g[ni][nj] = max(g[ni][nj], 4-dif);\n\t  }\n\t}\n    }else if(s[i][j] == 'M')maki.push_back(i*w + j);\n    else if(s[i][j] == 'S')S = i*w + j;\n    else if(s[i][j] == 'G')G = i*w + j;\n  }\n\n  int K = maki.size();\n  int dis[10][10];\n  rep(i,K){\n    dis[0][i+1] = dijkstra(S,maki[i]);\n    dis[i+1][K+1] = dijkstra(maki[i],G);\n    rep(j,i){\n      dis[i+1][j+1] = dijkstra(maki[i], maki[j]);\n      dis[j+1][i+1] = dijkstra(maki[j], maki[i]);\n    }\n  }\n\n  vector<int> perm(K);\n  rep(i,K)perm[i] = i+1;\n  int ans = 1e8;\n  do{\n    int sum = dis[0][perm[0]] + dis[perm[K-1]][K+1];\n    for(int i=0;i<K-1;i++)sum += dis[perm[i]][perm[i+1]];\n    ans = min(ans, sum);\n  }while(next_permutation(perm.begin(),perm.end()));\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define range(x,l,r) (l<=x && x<r)  \nusing namespace std;\ntypedef pair<int,int> pii;\n\nconst int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\nint w,h;\nint g[110][110];\n\nint dijkstra(int s, int t){\n  vector<int> dis(h*w,1e8);\n  dis[s] = 0;\n  priority_queue< pii,vector<pii>,greater<pii> > q;\n  q.push(pii(0,s));\n  \n  while(q.size()){\n    pii cur = q.top(); q.pop();\n    int y = cur.second/w, x = cur.second%w, d = cur.first;\n    if(t == cur.second)return d;\n    if(dis[cur.second] < d)continue;\n\n    rep(dir,4){\n      int ny = y+dy[dir], nx = x+dx[dir];\n      if(range(ny,0,h) && range(nx,0,w) && g[ny][nx]!=4){\n\tint nxt = ny*w + nx, nd = dis[cur.second] + g[y][x];\n\tif(dis[nxt] > nd){\n\t  dis[nxt] = nd;\n\t  q.push(pii(nd, nxt));\n\t}\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  cin >> w >> h;\n  vector<string> s(h);\n  rep(i,h){\n    cin >> s[i];\n    rep(j,w)g[i][j] = 1;\n  }\n\n  int S,G;\n  vector<int> maki;\n  rep(i,h)rep(j,w){\n    if(s[i][j] == '#'){\n      for(int ii=-2;ii<=2;ii++)for(int jj=-2;jj<=2;jj++){\n\t  int ni = i+ii, nj = j+jj;\n\t  if(range(ni,0,h) && range(nj,0,w)){\n\t    int dif = max(abs(ii),abs(jj));\n\t    g[ni][nj] = max(g[ni][nj], 4-dif);\n\t  }\n\t}\n    }else if(s[i][j] == 'M')maki.push_back(i*w + j);\n    else if(s[i][j] == 'S')S = i*w + j;\n    else if(s[i][j] == 'G')G = i*w + j;\n  }\n\n  int K = maki.size();\n  int dis[10][10];\n  rep(i,K){\n    dis[0][i+1] = dijkstra(S,maki[i]);\n    dis[i+1][K+1] = dijkstra(maki[i],G);\n    rep(j,i){\n      dis[i+1][j+1] = dis[j+1][i+1] = dijkstra(maki[i], maki[j]);\n    }\n  }\n\n  vector<int> perm(K);\n  rep(i,K)perm[i] = i+1;\n  int ans = 1e8;\n  do{\n    int sum = dis[0][perm[0]] + dis[perm[K-1]][K+1];\n    for(int i=0;i<K-1;i++)sum += dis[perm[i]][perm[i+1]];\n    ans = min(ans, sum);\n  }while(next_permutation(perm.begin(),perm.end()));\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 101\n#define INF 1e9\nusing namespace std;\nstring mp[N];\nint D[101][101][1<<5];\nint used[101][101];\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint dx[] ={0,0,1,-1};\nint dy[] ={1,-1,0,0};\nint w,h;\n\nvoid bfs(){\n  memset(used,-1,sizeof(used));\n  queue<P> Q;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)if(mp[i][j]=='#')Q.push(P(i,j)),used[i][j] = 0;\n  \n  while(!Q.empty()){\n    P t = Q.front();Q.pop();\n    int y = t.first;\n    int x = t.second;\n    for(int i=-1;i<=1;i++)\n      for(int j=-1;j<=1;j++){\n\tif(i==0&&j==0)continue;\n\tint nx = x+i;\n\tint ny = y+j;\n\tif(nx<0||ny<0||nx>=w||ny>=h||used[ny][nx]!=-1)continue;\n\tused[ny][nx] = used[y][x] + 1;\n\tQ.push(P(ny,nx));\n      }\n  }\n\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)if(used[i][j] == -1) used[i][j]=INF;\n  \n} \n\n\nint visited[N][N][1<<5];\nint dijkstra(int sy,int sx){\n  map<P,int> M;\n  int cnt=0;\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)if(mp[i][j] == 'M') M[P(i,j)] = cnt++;\n  \n  for(int i=0;i<101;i++)\n    for(int j=0;j<101;j++)\n      for(int k=0;k<(1<<5);k++) D[i][j][k] = INF;\n  \n  priority_queue<PP,vector<PP>,greater<PP> >Q;  \n  Q.push(PP(P(0,sy),P(sx,0)));\n  D[sy][sx][0] = 0;\n \n  while(!Q.empty()){\n    PP t = Q.top();Q.pop();\n    int cost = t.first.first;\n    int y = t.first.second;\n    int x = t.second.first;\n    int bit = t.second.second;\n    if(mp[y][x] =='G' && bit==(1<<cnt)-1)return cost;\n    if(D[y][x][bit]<cost||visited[y][x][bit]++) continue;\n    \n    for(int i=0;i<4;i++){\n      int nx = x+dx[i];\n      int ny = y+dy[i];\n      int nbit = bit;\n      int ncost = cost+max(1,4-used[y][x]);\n      if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx] == '#')continue;\n      if(D[ny][nx][nbit]<=ncost||visited[ny][nx][nbit])continue;\n      if(mp[ny][nx] == 'M') nbit |= 1<<(M[P(ny,nx)]); \n      Q.push(PP(P(ncost,ny),P(nx,nbit)));\n      D[ny][nx][nbit] = ncost;\n    }\n  }\n  assert(0);\n}\n\n\nint main(){\n\n  cin>>w>>h;\n  for(int i=0;i<h;i++) cin>>mp[i];\n\n  bfs();\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j] == 'S') cout<<dijkstra(i,j)<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nstring ba[100];\nint dist[100][100][1<<5];\nint cost[100][100];\nint maki[100][100];\n\nstruct P {\n  int y, x, S, d;\n  P(int y, int x, int S, int d) : y(y),x(x),S(S),d(d) {}\n};\nbool operator<(const P &a, const P &b) {\n  return a.d > b.d;\n}\n\nint main() {\n  int h,w;\n  while(cin>>w>>h) {\n    REP(i,h)cin>>ba[i];\n    priority_queue<P> Q;\n    memset(dist,-1,sizeof(dist));\n    int num = 0;\n    REP(i,h)REP(j,w)cost[i][j]=1;\n    REP(i,h) {\n      REP(j,w) {\n        if (ba[i][j] == 'S') {\n          Q.push(P(i,j,0,0));\n          dist[i][j][0] = 0;\n        } else if(ba[i][j] == '#') {\n          for (int dx = -3; dx<=3; ++dx) {\n            for (int dy = -3; dy<=3; ++dy) {\n              int ii = i+dy;\n              int jj = j+dx;\n              if (ii<0||ii>=h||jj<0||jj>=w) continue;\n              cost[ii][jj] = max(cost[ii][jj], 4-max(abs(dx),abs(dy)));\n            }\n          }\n        } else if (ba[i][j] == 'M') {\n          maki[i][j] = num++;\n        }\n      }\n    }\n    const int dy[] = {-1,0,1,0};\n    const int dx[] = {0,1,0,-1};\n\n    int ans = -1;\n    // REP(i,h) {\n    //   REP(j,w)cout << cost[i][j];\n    //   cout << endl;\n    // }\n    \n    while(!Q.empty()) {\n      P p = Q.top(); Q.pop();\n      int S = p.S;\n\n      //cout << p.y << \" \" << p.x << \" \" <<  S << \" \" << p.d << endl;\n      \n      if (dist[p.y][p.x][S] < p.d) continue;\n      \n      if (ba[p.y][p.x] == 'G' && S == ((1<<num)-1)) {\n        ans = dist[p.y][p.x][S];\n        break;\n      }\n      REP(i,4) {\n        int yy = p.y + dy[i];\n        int xx = p.x + dx[i];\n\n        if (yy<0||yy>=h||xx<0||xx>=w) continue;\n        if (ba[yy][xx] == '#') continue;\n        int T = S;\n        if (ba[yy][xx] == 'M') T |= 1<<maki[yy][xx];\n        int dis = dist[p.y][p.x][S] + cost[p.y][p.x];\n        if (dist[yy][xx][T] == -1 || dist[yy][xx][T] > dis) {\n          dist[yy][xx][T] = dis;\n          Q.push(P(yy,xx,T,dis));\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\ntypedef pair<int,int> P; //x, y\n\nclass State{\npublic:\n  int x, y, bit, cost;\n\n  State(){}\n  State(int _x, int _y, int _bit, int _cost){\n    x = _x;\n    y = _y;\n    bit = _bit;\n    cost = _cost;\n  }\n\n  bool operator<(const State &st)const{\n    return cost > st.cost;\n  }\n};\n\nint w, h;\nint sx, sy, gx, gy;\nint cost[102][102];\nbool closed[102][102][1 << 5];\nchar t[102][102];\nvector<P> mv;\n\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\n\nvoid solve(){\n  priority_queue<State> open;\n  open.push(State(sx, sy, 0, 0));\n  memset(closed, 0, sizeof(closed));\n\n  while(!open.empty()){\n    State st = open.top();\n    open.pop();\n\n    if(closed[st.y][st.x][st.bit]) continue;\n    closed[st.y][st.x][st.bit] = true;\n\n    if(st.x == gx && st.y == gy && st.bit == (1 << mv.size()) - 1){\n      cout << st.cost << endl;\n      break;\n    }\n\n    for(int i = 0; i < 4; i++){\n      int nx = st.x + dx[i];\n      int ny = st.y + dy[i];\n      int nbit = st.bit;\n      if(nx < 0 || w <= nx || ny < 0 || h <= ny || t[ny][nx] == '#') continue;\n\n      int idx = find(mv.begin(), mv.end(), P(nx, ny)) - mv.begin();\n\n      if(idx < mv.size()){\n\tnbit |= (1 << idx);\n      }\n\n      open.push(State(nx, ny, nbit, st.cost + (t[st.y][st.x] - '0')));\n    }\n  }\n}\n\nvoid show(){\n  for(int i = 0; i < h; i++){\n    cout << t[i] << endl;\n  }\n}\n\nint main(){\n  while(cin >> w >> h){\n    mv.clear();\n\n    for(int i = 0; i < h; i++){\n      cin >> t[i];\n\n      for(int j = 0; j < w; j++){\n\tif(t[i][j] == 'S'){\n\t  sx = j;\n\t  sy = i;\n\t  t[i][j] = '.';\n\t}\n\telse if(t[i][j] == 'G'){\n\t  gx = j;\n\t  gy = i;\n\t  t[i][j] = '.';\n\t}\n\telse if(t[i][j] == 'M'){\n\t  mv.push_back(P(j, i));\n\t  t[i][j] = '.';\n\t}\n      }\n    }\n\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tif(t[i][j] == '.'){\n\t  t[i][j] = '1';\n\t}\n\telse if(t[i][j] == '#'){\n\t  for(int my = -2; my <= 2; my++){\n\t    for(int mx = -2; mx <= 2; mx++){\n\t      if(mx == 0 && my == 0) continue;\n\n\t      int cost = 4 - max(abs(mx), abs(my));\n\t      int x = j - mx;\n\t      int y = i - my;\n\n\t      if(x < 0 || w <= x || y < 0 || h <= y) continue;\n\n\t      if(t[y][x] == '.' || t[y][x] != '#' && cost + '0' > t[y][x]){\n\t\tt[y][x] = cost + '0';\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\nint W,H;\nchar field[101][101];\nint moveTime[101][101];\nint sy,sx,ey,ex;\nint d[101][101][1<<5];\nint maki=0;\ntypedef pair<int,pair<int,pii> > Sit;\nconst int INF=1<<30;\nint dijkstra(){\n  for(int i=0;i<101;i++)\n    for(int j=0;j<101;j++)\n      for(int k=0;k<(1<<5);k++)\n\td[i][j][k]=INF;\n  priority_queue<Sit,vector<Sit>,greater<Sit> > pq;\n  pq.push(make_pair(0,make_pair(0,pii(sy,sx))));\n  d[sy][sx][0]=0;\n  while(pq.size()){\n    Sit sit=pq.top();pq.pop();\n    int cy=sit.second.second.first;\n    int cx=sit.second.second.second;\n    int ccost=sit.first;\n    int cmask=sit.second.first;\n    for(int i=0;i<4;i++){\n      int ny=cy+dy[i];\n      int nx=cx+dx[i];\n      if(ny>=0&&nx>=0&&ny<H&&nx<W&&field[ny][nx]!='#'){\n\tint nmask=cmask;\n\tif(field[ny][nx]<maki){\n\t  nmask|=(1<<field[ny][nx]);\n\t}\n\tint ncost=ccost+moveTime[cy][cx];\n\tif(ncost<d[ny][nx][nmask]){\n\t  d[ny][nx][nmask]=ncost;\n\t  pq.push(make_pair(ncost,make_pair(nmask,pii(ny,nx))));\n\t}\n      }\n    }\n  }\n  return d[ey][ex][(1<<maki)-1];\n}\nint main(){\n  cin>>W>>H;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      moveTime[i][j]=1;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>field[i][j];\n      if(field[i][j]=='#'){\n\tfor(int k=0;k<H;k++){\n\t  for(int l=0;l<W;l++){\n\t    int s=max(abs(k-i),abs(l-j));\n\t    moveTime[k][l]=max(moveTime[k][l],4-s);\n\t  }\n\t}\n      }\n      else if(field[i][j]=='M'){\n\tfield[i][j]=maki;\n\tmaki++;\n      }\n      else if(field[i][j]=='S'){\n\tsy=i;\n\tsx=j;\n\tfield[i][j]='.';\n      }\n      else if(field[i][j]=='G'){\n\tey=i;\n\tex=j;\n\tfield[i][j]='.';\n      }\n    }\n  }\n  // for(int i=0;i<H;i++){\n  //   for(int j=0;j<W;j++){\n  //     cout<<moveTime[i][j]<<\" \";\n  //   }\n  //   cout<<endl;\n  // }\n  cout<<dijkstra()<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\n#define y first\n#define x second\ntypedef pair<int, int> P;\nconst int INF = 1e9;\n\nint my3[8] = {0, 0, 1, -1, 1, 1, -1, -1};\nint mx3[8] = {1, -1, 0, 0, -1, 1, 1, -1};\nint my2[16] = {-2, -2, -2, -2, -2, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1};\nint mx2[16] = {-2, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2};\nint my[4] = {0, 0, 1, -1};\nint mx[4] = {1, -1, 0, 0};\n\nint H, W;\n\nvoid dfs(int y, int x, vector< vector<int> > &v, vector< vector<int> > &step, int cnt){\n  step[y][x] = cnt;\n  REP(i, 4){\n    int ny = y + my[i], nx = x + mx[i];\n    if(ny >= 0 && nx >= 0 && ny < H && nx < W && v[ny][nx] != INF && step[ny][nx] > cnt + v[y][x]) dfs(ny, nx, v, step, cnt + v[y][x]);\n  }\n}\n\nint dist(P &a, P &b, vector< vector<int> > &v){\n  vector< vector<int> > step(H, vector<int>(W, INF));\n  dfs(a.y, a.x, v, step, 0);\n  return step[b.y][b.x];\n}\n\nint solve(vector< vector<int> > &d, int m, P &g, vector<P> &ms, vector< vector<int> > &v){\n  vector< vector<int> > dp((1 << m), vector<int>(m + 1, INF));\n  dp[0][0] = 0;\n  REP(i, (1 << m)){\n    REP(j, m + 1){\n      if(dp[i][j] == INF) continue;\n      bitset<4> bs(i);\n      REP(next, m){\n        if(((1 << next) & i) != 0) continue;\n        int c = d[j][next + 1], n = ((1 << next) | i);\n        dp[n][next + 1] = min(dp[n][next + 1], dp[i][j] + c);\n      }\n    }\n  }\n  int res = INF;\n  FOR(i, 1, m + 1) res = min(res, dp[(1 << m) - 1][i] + dist(ms[i - 1], g, v));\n  return res;\n}\n\nint main() {\n  cin >>W >>H;\n  vector<string> cv(H);\n  REP(i, H) cin >>cv[i];\n  vector< vector<int> > v(H, vector<int>(W, 1));\n  vector<P> ms;\n  P s, g;\n  REP(y, H){\n    REP(x, W){\n      if(cv[y][x] == 'M') ms.push_back(P(y, x));\n      if(cv[y][x] == 'S') s = P(y, x);\n      if(cv[y][x] == 'G') g = P(y, x);\n      if(cv[y][x] != '#') continue;\n      v[y][x] = INF;\n      REP(i, 8){\n        int ny = y + my3[i], nx = x + mx3[i];\n        if(ny >= 0 && nx >= 0 && ny < H && nx < W) v[ny][nx] = max(3, v[ny][nx]);\n      }\n      REP(i, 16){\n        int ny = y + my2[i], nx = x + mx2[i];\n        if(ny >= 0 && nx >= 0 && ny < H && nx < W) v[ny][nx] = max(2, v[ny][nx]);\n      }\n    }\n  }\n  int msl = ms.size();\n  vector< vector<int> > d(msl + 1, vector<int>(msl + 1, 0));\n  REP(i, msl) d[0][i + 1] = d[i + 1][0] = dist(s, ms[i], v);\n  REP(i, msl) FOR(j, i + 1, msl) d[i + 1][j + 1] = d[j + 1][i + 1] = dist(ms[i], ms[j], v);\n  cout <<solve(d, msl, g, ms, v) <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<cstring>\nusing namespace std;\ntypedef pair<int,int> Pt;\ntypedef pair<Pt,Pt> P;\n#define fr first\n#define sc second\nint h,w,sx,sy,gx,gy,d[]={0,1,0,-1},Time[101][101],cnt;\nbool used[101][101][1<<5];\nint ldx[]={-1,-1,-1,0,1,1,1,0},ldy[]={-1,0,1,1,1,0,-1,-1};\nint sdx[]={-2,-2,-2,-2,-2,-1,0,1,2,2,2,2,2,1,0,-1};\nint sdy[]={-2,-1,0,1,2,2,2,2,2,1,0,-1,-2,-2,-2,-2};\nchar mas[101][101];\nvoid BAD(int,int);\nint bfs();\nbool judge(int x,int y){ return ((x>=0&&x<h&&y>=0&&y<w)? true : false); }\nint main(){\n  cin >> w >> h;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> mas[i][j];\n      if(mas[i][j] == 'S') sx = i,sy = j;\n      else if(mas[i][j] == 'G') gx = i,gy = j;\n      else if(mas[i][j] == '#') BAD(i,j);\n      else if(mas[i][j] == 'M') mas[i][j] = cnt++;\n    }\n  }\n  cout << bfs() << endl;\n}\n \nint bfs(){\n  priority_queue<P,vector<P>,greater<P> > que;\n  que.push(P(Pt(0,sx),Pt(sy,0)));\n  while(!que.empty()){\n    P p = que.top();\n    int t = p.fr.fr,px = p.fr.sc,py = p.sc.fr,BIT = p.sc.sc;\n    que.pop();\n    if(used[px][py][BIT])continue;\n    used[px][py][BIT] = true;\n    if(px == gx && py == gy && BIT ==(1<<cnt)-1 )return t;\n    for(int i=0;i<4;i++){\n      int nx = px + d[i],ny = py + d[3-i],bit = BIT;\n      if(!judge(nx,ny)) continue;\n      if(mas[nx][ny] == '#') continue;\n      if(mas[nx][ny]>=0&&mas[nx][ny]<=10) bit |= 1<<mas[nx][ny];\n      que.push(P(Pt(t+Time[px][py]+1,nx),Pt(ny,bit)));\n    }\n  }\n}\nvoid BAD(int x,int y){\n  for(int i=0;i<8;i++){\n    int nx=x+ldx[i],ny=y+ldy[i];\n    if(judge(nx,ny)) Time[nx][ny] = 2;\n  }\n  for(int i=0;i<16;i++){\n    int nx=x+sdx[i],ny=y+sdy[i];\n    if(judge(nx,ny)) Time[nx][ny] = max(Time[nx][ny],1);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <numeric>\n#include <queue>\n#include <cstring>\n#include <stdio.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long long ll;\ntypedef vector<ll> vll;\nconst int inf=10000000;\nint H,W,startx,starty,goalx,goaly;\nstring board[105];\nint cost[105][105];\nint d[105][105];\nbool visited[150][105];\nint dx8[]={-1,-1,0,1,1,1,0,-1};\nint dy8[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={0,1,0,-1};\nint dx[]={-1,0,1,0};\n\ntypedef pair<int,int> P;\ntypedef pair<int,pair<int,int> > PP;\n\nvoid costset(int sx,int sy,int times)\n{\n  if(times==2) return;\n  int nowx=sx;\n  int nowy=sy;\n  int cos=3-times;\n  for(int k=0;k<8;k++)\n    {\n      int nx=nowx+dx8[k];\n      int ny=nowy+dy8[k];\n      if(nx<0 || W<=nx || ny<0 || H<=ny) continue;\n      cost[ny][nx]=max(cost[ny][nx],cos);\n      costset(nx,ny,times+1);\n    }\n}\n\nint solve(int sx,int sy,int gx,int gy)\n{\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  d[i][j]=inf;\n\t}\n    }\n  d[sy][sx]=0;\n  priority_queue<PP,vector<PP> ,greater<PP>> p;\n  p.push(PP(0,P(sy,sx)));\n  int nowy,nowx;\n  while(!p.empty())\n    {\n      PP now=p.top();p.pop();\n      nowy=now.second.first;\n      nowx=now.second.second;\n      if(nowx==gx && nowy==gy) break;\n      for(int k=0;k<4;k++)\n\t{\n\t  int ny=nowy+dy[k];\n\t  int nx=nowx+dx[k];\n\t  if(ny<0 || H<=ny || nx<0 || W<=nx || board[ny][nx]=='#') continue;\n\t  if(d[nowy][nowx]+cost[nowy][nowx]>=d[ny][nx]) continue;\n\t  if(d[ny][nx]==inf || d[ny][nx]>d[nowy][nowx]+cost[nowy][nowx])\n\t    {\n\t      d[ny][nx]=d[nowy][nowx]+cost[nowy][nowx];\n\t      p.push(PP(d[ny][nx],P(ny,nx)));\n\t    }\n\t}\n    }\n  return d[gy][gx];\n}\n\nint main(int argc,char const* argv[])\n{\n  int ans=20000000;\n  int scroll=0;\n  int pat=1;\n  int graph[10][10];\n  for(int i=0;i<10;i++)\n    {\n      for(int j=0;j<10;j++)\n\t{\n\t  graph[i][j]=inf;\n\t}\n    }\n  vector<P> route;\n  cin >> W >> H;\n  for(int i=0;i<H;i++)\n    {\n      cin >> board[i];\n    }\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  cost[i][j]=1;\n\t  if(board[i][j]=='M') route.push_back(P(i,j));\n\t  if(board[i][j]=='G') {goaly=i;goalx=j;}\n\t  if(board[i][j]=='S') {starty=i;startx=j;}\n\t}\n    }\n  sort(route.begin(),route.end());\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  if(board[i][j]=='#')\n\t    {\n\t      costset(j,i,0);\n\t    }\n\t  if(board[i][j]=='M')\n\t    {\n\t      scroll++;\n\t    }\n\t}\n    }\n  for(int i=0;i<route.size();i++)\n    {\n      graph[0][i+1]=solve(startx,starty,route[i].second,route[i].first);\n      graph[i+1][6]=solve(route[i].second,route[i].first,goalx,goaly);\t\t\t\t\t      \n      for(int j=0;j<route.size();j++)\n\t{\n\t  if(i==j) continue;\n\t  int stx=route[i].second;\n\t  int sty=route[i].first;\n\t  int gox=route[j].second;\n\t  int goy=route[j].first;\n\t  graph[i+1][j+1]=solve(stx,sty,gox,goy);\n\t  //graph[j+1][i+1]=graph[i+1][j+1];\n\t}\n    }\n   vector<int> walk(scroll);\n   iota(walk.begin(),walk.end(),1);\n   do\n     {\n       int tmp=0;\n       int prev=0;\n       int to=0;\n       for(auto x:walk) \n\t {\n\t   to=x;\n\t   tmp+=graph[prev][to];\n\t   prev=x;\n\t }\n       tmp+=graph[to][6];\n       ans=min(ans,tmp);\n     } while(next_permutation(walk.begin(),walk.end()));\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={-1,0,1,0,1,1,-1,-1};\nconst int dx2[] = {1,-1,-2,-2,-1,1,2,2};\nconst int dy2[] = {2,2,1,-1,-2,-2,-1,1};\nconst int INF = 1<<30;\nconst double EPS = 1e-8;\n#define PB push_back\n#define mk make_pair\n#define fr first\n#define sc second\n#define ll long long\n#define reps(i,j,k) for(int i = (j); i < (k); i++)\n#define rep(i,j) reps(i,0,j)\n#define MOD 1000000007\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\ntypedef pair<int,int> Pii;\ntypedef pair<Pii,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint T[128][128];\nint W,H;\nvector < Pii > target;\nchar stage[128][128];\nP s,g;\nint D[8][8];\nint dp[1<<6][8];\nstruct data\n{\n    Pii p;\n    int cost;\n    data(){}\n    data(Pii _p,int _cost){\n        p = _p;\n        cost = _cost;\n    }\n    bool operator<(const data &a)const{\n        return a.cost < cost;\n    }\n};\nvoid getPath(int a){\n    int m[128][128];\n    memset(m,-1,sizeof(m));    \n    priority_queue < data > PQ;\n    PQ.push(data(target[a],0));\n    while(!PQ.empty()){\n        data d = PQ.top();PQ.pop();\n        if(m[d.p.fr][d.p.sc] != -1)continue;\n        m[d.p.fr][d.p.sc] = d.cost;\n        rep(i,4){\n            int ny = d.p.fr + dy[i];\n            int nx = d.p.sc + dx[i];\n            if(ny < 0 || ny > H-1 || nx < 0 || nx > W-1)continue;\n            if(m[ny][nx] != -1 || stage[ny][nx] == '#')continue;\n            PQ.push(data(Pii(ny,nx),d.cost+T[d.p.fr][d.p.sc]));\n        }\n    }\n\n    rep(i,target.size()){\n        if(i == a)D[a][i] = 0;\n        D[a][i] = m[target[i].fr][target[i].sc];\n    }\n    return ;\n}\nint getMin(int bit,int prev){\n    if(bit+(1<<g.sc) == (1<<target.size())-1){\n        dp[bit][prev] = D[prev][g.sc];\n        //printf(\"%d\\n\",bit|(1<<g.sc));\n        return D[prev][g.sc];\n    }\n    if(dp[bit][prev] != -1)return dp[bit][prev];\n    int ret = INF;\n    rep(i,target.size()){\n        if(i == g.sc)continue;\n        if(!(1&bit>>i)){\n            ret = min(ret,D[prev][i]+getMin(bit|1<<i,i));\n        }\n    }\n    return dp[bit][prev] = ret;\n}\nint main(){\n    scanf(\"%d%d\",&W,&H);\n    bool memo[128][128] = {{false}};\n    fill((int*)T,(int*)(T+lengthof(T)),1);\n    queue < P > Q;\n    rep(i,H){\n        scanf(\"%s\",&stage[i]);\n        rep(j,W){\n            if(stage[i][j] == 'S'){\n                s.fr.fr = i;\n                s.fr.sc = j;\n                s.sc = target.size();\n                target.PB(Pii(i,j));\n                stage[i][j] = '.';\n            }\n            if(stage[i][j] == 'G'){\n                g.fr.fr = i;\n                g.fr.sc = j;\n                g.sc = target.size();\n                target.PB(Pii(i,j));\n                stage[i][j] = '.';\n            }\n            if(stage[i][j] == '#'){\n                memo[i][j] = true;\n                T[i][j] = INF;\n                Q.push(P(Pii(i,j),3));\n            }\n            if(stage[i][j] == 'M'){\n                target.PB(Pii(i,j));\n            }\n        }\n    }\n    while(!Q.empty()){\n        P p = Q.front();Q.pop();\n        if(p.sc == 1)continue;\n        rep(i,8){\n            int ny = p.fr.fr + dy[i]*(4-p.sc);\n            int nx = p.fr.sc + dx[i]*(4-p.sc);\n            if(ny < 0 || ny > H-1 || nx < 0 || nx > W-1)continue;\n            if(memo[ny][nx]++)continue;\n            T[ny][nx] = p.sc;\n            Q.push(P(Pii(p.fr.fr,p.fr.sc),p.sc-1));\n        }\n        if(p.sc == 2){\n            rep(i,8){\n                int ny = p.fr.fr + dy2[i];\n                int nx = p.fr.sc + dx2[i];\n                if(ny < 0 || ny > H-1 || nx < 0 || nx > W-1)continue;\n                if(memo[ny][nx]++)continue;\n                T[ny][nx] = p.sc;\n                Q.push(P(Pii(p.fr.fr,p.fr.sc),p.sc-1));       \n            }\n        }\n    }\n    rep(i,target.size()){\n        getPath(i);\n    }\n    fill((int*)dp,(int*)(dp+lengthof(dp)),-1);\n    printf(\"%d\\n\",getMin(1<<(s.sc),s.sc));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<tuple>\n#include<queue>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nenum{Y,X};\nenum{COST,SCROLL,I,J};\ntypedef tuple<int,int> Point;\ntypedef tuple<int,int,int,int> T;\n\nbool range(int x, int first, int last){return first<=x && x<=last;}\nint bitcount(int n){return n?(n&1)+bitcount(n>>1):0;}\n\nint main()\n{\n  int W, H;\n  string line;\n  Point start, goal;\n  vector<Point> scroll, holl;\n\n  cin>>W>>H;\n\n  vector< vector<int> > field(H, vector<int>(W, 1) );\n\n  for(int i=0; i<H; i++){\n    cin>>line;\n    for(int j=0; j<W; j++){\n      switch(line[j]){\n      case 'S':\n        start = Point(i,j);\n        break;\n      case 'G':\n        goal = Point(i,j);\n        break;\n      case 'M':\n        scroll.push_back( Point(i,j) );\n        break;\n      case '#':\n        holl.push_back( Point(i,j) );\n        for(int dy=-2; dy<=2; dy++){\n          for(int dx=-2; dx<=2; dx++){\n            int y=i+dy, x=j+dx;\n            if(!range(y,0,H-1))continue;\n            if(!range(x,0,W-1))continue;\n            if(dy==-2 || dy==2 || dx==-2 || dx==2)field[y][x]=max(2,field[y][x]);\n            else field[y][x]=3;\n          }\n        }\n        break;\n      case '.':\n        break;\n      default:\n        break;\n      }\n    }\n  }\n\n  int ans;\n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n\n  set<T> visited;\n  priority_queue<T> q;\n  q.push( T( 0, 0, get<Y>(start), get<X>(start) ) );\n  while(!q.empty()){\n    T now = q.top();\n    q.pop();\n\n    if( visited.count( T(0, get<SCROLL>(now), get<I>(now), get<J>(now)) ) )continue;\n    visited.insert( T(0, get<SCROLL>(now), get<I>(now), get<J>(now)) );\n\n    if(get<I>(now)==get<Y>(goal) && get<J>(now)==get<X>(goal)){\n      if( bitcount( get<SCROLL>(now) ) == scroll.size() ){\n        ans=-get<COST>(now);\n        break;\n      }\n    }\n    for(int j=0; j<scroll.size(); j++){\n      if(get<I>(now)==get<Y>(scroll[j]) && get<J>(now)==get<X>(scroll[j])){\n        if( (get<SCROLL>(now)>>j)&1 ){\n          break;\n        }else{\n          get<SCROLL>(now) ^= (1<<j);\n        }\n      }\n    }\n\n    bool ok=true;\n    for(int j=0; j<holl.size(); j++){\n      if(get<I>(now)==get<Y>(holl[j]) && get<J>(now)==get<X>(holl[j]))ok=false;\n    }\n    if(!ok)continue;\n\n    for(int i=0; i<4; i++){\n      int y=get<I>(now)+dy[i], x=get<J>(now)+dx[i];\n      if(!range(y,0,H-1))continue;\n      if(!range(x,0,W-1))continue;\n      q.push( T(get<COST>(now)-field[get<I>(now)][get<J>(now)], get<SCROLL>(now), y, x) );\n    }\n  }\n\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<deque>\n#include<climits>\n#include<numeric>\n#include<cassert>\n#include<functional>\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define fi(i,j,k) fill(i[0],i[0]+j*j,k)\n#define INF 1<<27\n#define F first\n#define S second\nstatic const double eps=1e-10;\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w;\nchar cmap[110][110];\nP pos[110];\nint index,matrix[110][110];\nint imap[110][110];\nstatic const int dx[4] = {0,1,0,-1};\nstatic const int dy[4] = {1,0,-1,0};\nstatic const int dx8[8] = {0,1,1,1,0,-1,-1,-1};\nstatic const int dy8[8] = {-1,-1,0,1,1,1,0,-1};\nstatic const int dx16[16] = {0,1,2,2,2,2,2,1,0,-1,-2,-2,-2,-2,-2,-1};\nstatic const int dy16[16] = {-2,-2,-2,-1,0,1,2,2,2,2,2,1,0,-1,-2,-2};\n\nint D[110][110];\nbool used[110][110];\n\nvoid bfs(P s,P g){\n  rep(i,h)rep(j,w){\n    D[i][j] = INF;\n    used[i][j] = false;\n  }\n  queue<P> que;\n  que.push(s);\n  D[s.S][s.F] = 0;\n  used[s.S][s.F] = true;\n\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n    //if(p == g)return D[g.S][g.F];\n\n    for(int i=0;i<4;i++){\n      int nx = p.F+dx[i],ny = p.S+dy[i];\n      if(0<= nx && nx < w && 0<= ny && ny < h && cmap[ny][nx] != '#' && /*!used[ny][nx]*/ D[ny][nx] > D[p.S][p.F] +imap[ny][nx]){\n\tD[ny][nx] = min(D[p.S][p.F] + imap[ny][nx],D[ny][nx]);\n\t//cout << \"nx = \" << nx << \", ny = \" << ny << \", D[ny][nx] =\" << D[ny][nx] << endl;  \n\t//used[ny][nx] = true;\n\tque.push(P(nx,ny));\n      }\n    }\n  }\n  //return INF;\n}\n\n\nvoid display(){\n  for(int i=0;i<h;i++)\n    {\n      rep(j,w){\n\tcout << cmap[i][j] << \" \";\n      }\n      cout<< endl;\n    }\n  cout << endl;\n  for(int i=0;i<h;i++)\n    {\n      rep(j,w){\n\tcout << imap[i][j] << \" \";\n      }\n      cout<< endl;\n    }\n  cout << endl;\n\n  rep(i,index){\n    rep(j,index){\n      cout << matrix[i][j] << \" \";\n    }\n    cout<< endl;\n  }\n  cout << endl;\n\n}\n\nint main(){\n  while(cin >> w >> h){\n  int sindex,lim = 1;\n  index = 1;\n  \n  rep(i,h)rep(j,w)imap[i][j] = 1;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> cmap[i][j];\n      matrix[i][j] = INF;\n      if(cmap[i][j] == 'S'){\n\t//pos[0] = P(j,i);\n\tlim++;\n      }\n      else if(cmap[i][j] == 'M')lim++;\n      else if(cmap[i][j] == 'G'){\n\tpos[0] = P(j,i);\n\t//lim++;\n      }\n    }\n  }\n \n  rep(i,h){\n    rep(j,w){\n      \n      if(cmap[i][j] == 'S'){\n\t pos[lim-1] = P(j,i);\n      }\n       else if(cmap[i][j] == 'M'){\n\t assert(index != lim-1);\n\tpos[index++] = P(j,i);\n      }\n      else if(cmap[i][j] == '#'){\n\tfor(int k=0;k<8;k++){\n\t  \n\t  int nx = j+dx8[k],ny = i+dy8[k];\n\t  if(0<=nx && nx<w && 0<=ny && ny <h && cmap[ny][nx] != '#'){\n\t    imap[ny][nx] = 3;\n\t  }\n\t}\n\tfor(int k=0;k<16;k++){\n\t  int nx = j+dx16[k],ny = i+dy16[k];\n\t  if(0<=nx && nx<w && 0<=ny && ny <h && cmap[ny][nx] != '#'){\n\t    imap[ny][nx] = max(imap[ny][nx],2);\n\t  }\n\t}\n      }\n    }\n  }\n\n  \n\n  //rep(i,h)rep(j,w)if(cmap[i][j] == 'G')imap[i][j] = 0;\n  \n\n  index = lim;\n\n  for(int i=0;i<index;i++){\n    rep(j,index){\n    \n      if(i == j){\n\tmatrix[i][j] = 0;\n\tcontinue;\n      }\nbfs(pos[i],pos[j]);\n matrix[i][j] = D[pos[j].S][pos[j].F];\n    }\n  }\n\n  //index--;\n\n  //display();\n  int per[110];\n  rep(i,index-1)per[i] = i+1;\n\n  int sum;\n  int ans=INF;\n  do{\n    sum=0;\n    sum+=matrix[0][per[0]];\n\n    int posi=-1;     \n    for(int i=1;i<index-1;i++){\n      if(i == index-2)posi = per[i];\n      sum+=matrix[per[i-1]][per[i]];\n    }\n    //assert(posi !=-1);\n    //if(posi != index-1){\n    //cout <<\"posi = \" << posi << \",index = \" << index-1 << \",presum = \" << sum << \", matrix[posi][lim-1] = \" << matrix[posi][lim-1] << endl;\n    if(posi != -1 && posi != lim-1)sum += matrix[posi][lim-1];\n    //}\n    ans=min(ans,sum);\n  }while(next_permutation(per,per+(index-1)));\n \n\n  cout << ans << endl;\n\n}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<deque>\n#include<climits>\n#include<numeric>\n#include<cassert>\n#include<functional>\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define fi(i,j,k) fill(i[0],i[0]+j*j,k)\n#define INF 1<<27\n#define F first\n#define S second\nstatic const double eps=1e-10;\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w;\nchar cmap[110][110];\nP pos[110];\nint index,matrix[110][110];\nint imap[110][110];\nstatic const int dx[4] = {0,1,0,-1};\nstatic const int dy[4] = {1,0,-1,0};\nstatic const int dx8[8] = {0,1,1,1,0,-1,-1,-1};\nstatic const int dy8[8] = {-1,-1,0,1,1,1,0,-1};\nstatic const int dx16[16] = {0,1,2,2,2,2,2,1,0,-1,-2,-2,-2,-2,-2,-1};\nstatic const int dy16[16] = {-2,-2,-2,-1,0,1,2,2,2,2,2,1,0,-1,-2,-2};\n\nint D[110][110];\nbool used[110][110];\n\nint bfs(P s,P g){\n  rep(i,h)rep(j,w){\n    D[i][j] = INF;\n    used[i][j] = false;\n  }\n  queue<P> que;\n  que.push(s);\n  D[s.S][s.F] = 0;\n  used[s.S][s.F] = true;\n\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n    if(p == g)return D[g.S][g.F];\n\n    for(int i=0;i<4;i++){\n      int nx = p.F+dx[i],ny = p.S+dy[i];\n      if(0<= nx && nx < w && 0<= ny && ny < h && cmap[ny][nx] != '#' && !used[ny][nx]){\n\tD[ny][nx] = D[p.S][p.F] + imap[ny][nx];\n\tused[ny][nx] = true;\n\tque.push(P(nx,ny));\n      }\n    }\n  }\n  return INF;\n}\n\n\nvoid display(){\n  for(int i=0;i<h;i++)\n    {\n      rep(j,w){\n\tcout << cmap[i][j] << \" \";\n      }\n      cout<< endl;\n    }\n  cout << endl;\n  for(int i=0;i<h;i++)\n    {\n      rep(j,w){\n\tcout << imap[i][j] << \" \";\n      }\n      cout<< endl;\n    }\n  cout << endl;\n\n  rep(i,index){\n    rep(j,index){\n      cout << matrix[i][j] << \" \";\n    }\n    cout<< endl;\n  }\n  cout << endl;\n\n}\n\nint main(){\n  int sindex,lim = 1;\n  index = 1;\n  cin >> w >> h;\n  rep(i,h)rep(j,w)imap[i][j] = 1;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> cmap[i][j];\n      matrix[i][j] = INF;\n      if(cmap[i][j] == 'S'){\n\tpos[0] = P(j,i);\n\t//lim++;\n      }\n      else if(cmap[i][j] == 'M')lim++;\n      else if(cmap[i][j] == 'G'){\n\t//pos[0] = P(j,i);\n\tlim++;\n}\n\n    }\n  }\n \n  rep(i,h){\n    rep(j,w){\n      \n      if(cmap[i][j] == 'G'){\n\t pos[lim-1] = P(j,i);\n      }\n       else if(cmap[i][j] == 'M'){\n\t assert(index != lim-1);\n\tpos[index++] = P(j,i);\n      }\n      else if(cmap[i][j] == '#'){\n\tfor(int k=0;k<8;k++){\n\t  \n\t  int nx = j+dx8[k],ny = i+dy8[k];\n\t  if(0<=nx && nx<w && 0<=ny && ny <h && cmap[ny][nx] != '#'){\n\t    imap[ny][nx] = 3;\n\t  }\n\t}\n\tfor(int k=0;k<16;k++){\n\t  int nx = j+dx16[k],ny = i+dy16[k];\n\t  if(0<=nx && nx<w && 0<=ny && ny <h && cmap[ny][nx] != '#'){\n\t    imap[ny][nx] = max(imap[ny][nx],2);\n\t  }\n\t}\n      }\n    }\n  }\n\n  \n\n  //rep(i,h)rep(j,w)if(cmap[i][j] == 'G')imap[i][j] = 0;\n  \n\n  index = lim;\n\n  for(int i=0;i<index;i++){\n    rep(j,index){\n    \n      if(i == j){\n\tmatrix[i][j] = 0;\n\tcontinue;\n      }\n      matrix[i][j] = bfs(pos[i],pos[j]);\n    }\n  }\n\n  //index--;\n\n  //display();\n  int per[110];\n  rep(i,index-1)per[i] = i+1;\n\n  int sum;\n  int ans=INF;\n  do{\n    sum=0;\n    sum+=matrix[0][per[0]];\n\n    int posi=-1;     \n    for(int i=1;i<index-1;i++){\n      if(i == index-2)posi = per[i];\n      sum+=matrix[per[i-1]][per[i]];\n    }\n    //assert(posi !=-1);\n    //if(posi != index-1){\n    //cout <<\"posi = \" << posi << \",index = \" << index-1 << \",presum = \" << sum << \", matrix[posi][lim-1] = \" << matrix[posi][lim-1] << endl;\n    if(posi != -1 && posi != lim-1)sum += matrix[posi][lim-1];\n    //}\n    ans=min(ans,sum);\n  }while(next_permutation(per,per+(index-1)));\n \n\n  cout << ans << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nconst int INF = 1 << 28;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nconst int ddx[] = {1, 1, 0, -1, -1, -1, 0, 1, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2, 2};\nconst int ddy[] = {0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2, 2, 2, 2, 2, 1};\n\nclass State\n{\npublic:\n  int x, y, m, c;\n  State(int _x, int _y, int _m, int _c)\n    :x(_x), y(_y), m(_m), c(_c) {}\n  bool operator < (const State& st) const\n  {\n    return this->c > st.c;\n  }\n};\n\nint main()\n{\n  int W, H;\n  while (cin >> W >> H) {\n    vector<string> tile(H);\n    for (int i = 0; i < H; ++i)\n      cin >> tile[i];\n\n    int sx, sy, tx, ty, M = 0;\n    vector<vector<int> > map(H, vector<int>(W, 1));\n    for (int y = 0; y < H; ++y) {\n      for (int x = 0; x < W; ++x) {\n        if (tile[y][x] == 'S') {\n          sx = x;\n          sy = y;\n          tile[y][x] = '.';\n        } else if (tile[y][x] == 'G') {\n          tx = x;\n          ty = y;\n          tile[y][x] = '.';\n        } else if (tile[y][x] == 'M') {\n          tile[y][x] = ('A' + M);\n          ++M;\n        } else if (tile[y][x] == '#') {\n          map[y][x] = INF;\n        }\n      }\n    }\n\n    for (int y = 0; y < H; ++y) {\n      for (int x = 0; x < W; ++x) {\n        if (map[y][x] != INF)\n          continue;\n        for (int d = 0; d < 24; ++d) {\n          int xx = x + ddx[d];\n          int yy = y + ddy[d];\n          if (xx < 0 || xx >= W || yy < 0 || yy >= H)\n            continue;\n          if (d < 8)\n            map[yy][xx] = max(map[yy][xx], 3);\n          else\n            map[yy][xx] = max(map[yy][xx], 2);          \n        }\n      }\n    }\n\n    priority_queue<State> que;\n    que.push(State(sx, sy, 0, 0));\n    vector<vector<vector<int> > > dp(H, vector<vector<int> >(W, vector<int>((1 << M), INF)));\n    while (!que.empty()) {\n      State st = que.top();\n      que.pop();\n      if (st.x == tx && st.y == ty && st.m == ((1 << M)-1)) {\n        cout << st.c << endl;\n        break;\n      }\n\n      if (dp[st.y][st.x][st.m] < st.c)\n        continue;\n      dp[st.y][st.x][st.m] = st.c;\n\n      if (isalpha(tile[st.y][st.x]))\n        st.m |= (1 << (tile[st.y][st.x] - 'A'));\n\n      for (int d = 0; d < 4; ++d) {\n        int xx = st.x + dx[d];\n        int yy = st.y + dy[d];\n        if (xx < 0 || xx >= W || yy < 0 || yy >= H ||\n            tile[yy][xx] == '#' || dp[yy][xx][st.m] <= st.c + map[st.y][st.x])\n          continue;\n\n        dp[yy][xx][st.m] = st.c + map[st.y][st.x];\n        que.push(State(xx, yy, st.m, dp[yy][xx][st.m]));\n      }\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <numeric>\n#include <queue>\n#include <cstring>\n#include <stdio.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long long ll;\ntypedef vector<ll> vll;\nconst int inf=10000000;\nint H,W,startx,starty,goalx,goaly;\nstring board[105];\nint cost[105][105];\nint d[105][105];\nint dx8[]={-1,-1,0,1,1,1,0,-1};\nint dy8[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={0,1,0,-1};\nint dx[]={-1,0,1,0};\n\ntypedef pair<int,int> P;\ntypedef pair<int,pair<int,int> > PP;\n\nvoid costset(int sx,int sy,int times)\n{\n  if(times==2) return;\n  int nowx=sx;\n  int nowy=sy;\n  int cos=3-times;\n  for(int k=0;k<8;k++)\n    {\n      int nx=nowx+dx8[k];\n      int ny=nowy+dy8[k];\n      if(nx<0 || W<=nx || ny<0 || H<=ny) continue;\n      cost[ny][nx]=max(cost[ny][nx],cos);\n      costset(nx,ny,times+1);\n    }\n}\n\nint solve(int sx,int sy,int gx,int gy)\n{\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  d[i][j]=inf;\n\t}\n    }\n  d[sy][sx]=0;\n  priority_queue<PP,vector<PP>,greater<PP> > p;\n  p.push(PP(0,P(sy,sx)));\n  int nowy,nowx;\n  while(!p.empty())\n    {\n      PP now=p.top();p.pop();\n      nowy=now.second.first;\n      nowx=now.second.second;\n      if(nowx==gx && nowy==gy) break;\n      for(int k=0;k<4;k++)\n\t{\n\t  int ny=nowy+dy[k];\n\t  int nx=nowx+dx[k];\n\t  if(ny<0 || H<=ny || nx<0 || W<=nx || board[ny][nx]=='#') continue;\n\t  if(d[nowy][nowx]+cost[nowy][nowx]>d[ny][nx]) continue;\n\t  d[ny][nx]=d[nowy][nowx]+cost[nowy][nowx];\n\t  p.push(PP(d[ny][nx],P(ny,nx)));\n\t}\n    }\n  return d[gy][gx];\n}\n\nint main(int argc,char const* argv[])\n{\n  int ans=20000000;\n  int scroll=0;\n  int pat=1;\n  int graph[10][10];\n  for(int i=0;i<10;i++)\n    {\n      for(int j=0;j<10;j++)\n\t{\n\t  graph[i][j]=inf;\n\t}\n    }\n  vector<P> route;\n  cin >> W >> H;\n  for(int i=0;i<H;i++)\n    {\n      cin >> board[i];\n    }\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  cost[i][j]=1;\n\t  if(board[i][j]=='M') route.push_back(P(i,j));\n\t  if(board[i][j]=='G') {goaly=i;goalx=j;}\n\t  if(board[i][j]=='S') {starty=i;startx=j;}\n\t}\n    }\n  sort(route.begin(),route.end());\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  if(board[i][j]=='#')\n\t    {\n\t      costset(j,i,0);\n\t    }\n\t  if(board[i][j]=='M')\n\t    {\n\t      scroll++;\n\t    }\n\t}\n    }\n  for(int i=0;i<route.size();i++)\n    {\n      graph[0][i+1]=solve(startx,starty,route[i].second,route[i].first);\n      graph[i+1][6]=solve(route[i].second,route[i].first,goalx,goaly);\t\t\t\t\t      \n      for(int j=0;j<route.size();j++)\n\t{\n\t  if(i==j) continue;\n\t  int stx=route[i].second;\n\t  int sty=route[i].first;\n\t  int gox=route[j].second;\n\t  int goy=route[j].first;\n\t  graph[i+1][j+1]=solve(stx,sty,gox,goy);\n\t}\n    }\n   for(int i=1;i<=scroll;i++)\n     {\n       pat*=i;\n     }\n   vector<int> walk(scroll);\n   iota(walk.begin(),walk.end(),1);\n   for(int j=0;j<pat;j++)\n     {\n       int tmp=0;\n       int prev=0;\n       int to=0;\n       for(auto x:walk) \n\t {\n\t   to=x;\n\t   tmp+=graph[prev][to];\n\t   prev=x;\t   \n\t }\n       tmp+=graph[to][6];\n       ans=min(ans,tmp);\n       next_permutation(walk.begin(),walk.end());\n     }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n#define C first.first\n#define F first.second\n#define X second.first\n#define Y second.second\n#define INF (1<<29)\nint W,H;\nchar fie[101][101];\nint mvc[101][101];\nint dmx[]={1,0,-1,0,1,-1,1,-1};\nint dmy[]={0,1,0,-1,1,-1,-1,1};\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint h[101][101][1<<5];\nint gx,gy;\nint MC;\nbool check(int x,int y){\n  if(x < 0 || y < 0 || x>=W || y>=H ) return true;\n  return false;\n}\nvoid printmv(){\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++)\n      printf(\"%2d \",mvc[j][i]);\n    puts(\"\");\n  }   \n}\nvoid printh(){\n  for(int k=0;k<(1<<MC);k++)\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n\tprintf(\"h[%d][%d][%d]=%d\\n\",j,i,k,h[j][i][k]);\n}\nint solve(int x,int y){\n  // printmv();\n  priority_queue<PP> q;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      for(int k=0;k<(1<<MC);k++)\n\th[j][i][k]=INF;\n  q.push(PP(P(0,0),P(x,y)));\n  h[x][y][0]=0;\n  while(!q.empty()){\n    PP p = q.top(); q.pop();\n    x = p.X; y = p.Y;\n    for(int i=0;i<4;i++){\n      int nx = x + dx[i], ny = y + dy[i];\n      if( check(nx,ny) ) continue;\n      if( fie[nx][ny] == '#') continue;\n      if( '0' <= fie[nx][ny] && fie[nx][ny] <= '5' ){\n\tint mc = fie[nx][ny]-'0';\n\tint st = (p.F | (1<<mc));\n\tif( h[nx][ny][st] > p.C + mvc[x][y] ){\n\t  h[nx][ny][st] = p.C + mvc[x][y];\n\t  q.push(PP(P(p.C+mvc[x][y],st),P(nx,ny)));\n\t}\n      } else {\n\tif( h[nx][ny][p.F] > p.C + mvc[x][y] ){\n\t  h[nx][ny][p.F] = p.C + mvc[x][y];\n\t  q.push(PP(P(p.C+mvc[x][y],p.F),P(nx,ny)));\n\t}\n      }\n    }\n  }\n  //  printh();\n  // cout << gx << \" \" << gy << \" \" << (1<<MC)-1 << \" \" << h[gx][gy][(1<<MC)-1]<<\"\\n\";\n  return h[gx][gy][(1<<MC)-1];\n}\nvoid mark(int x,int y,int c){\n  for(int i=0;i<8;i++){\n    int nx = x+dmx[i], ny = y + dmy[i];\n    if(check(nx,ny)) continue;\n    mvc[nx][ny]=max(mvc[nx][ny],c);\n  }\n  if(c==3){\n    for(int i=0;i<8;i++){\n      int nx = x+dmx[i], ny = y + dmy[i];\n      if(check(nx,ny)) continue;\n      mark(nx,ny,c-1);\n    }\n  }\n}\nint main(){\n  int sx,sy;\n  cin >> W >> H;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin >> fie[j][i];\n      mvc[j][i]=1;\n    }\n  }\n  MC=0;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(fie[j][i]=='#'){\n\tmark(j,i,3);\n      } else if(fie[j][i]=='S'){\n\tsx = j;\n\tsy = i;\n      } else if(fie[j][i]=='M'){\n\tfie[j][i]='0'+MC;\n\tMC++;\n      } else if(fie[j][i]=='G'){\n\tgx = j;\n\tgy = i;\n      }\n    }\n  }\n  cout << solve(sx,sy) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\nbool check(int n,int m,int x,int y) {return x>=0&&x<n&&y>=0&&y<m;}\n \nint a[111][111],d[55][111][111];\nmap<P,int> ma;\nint main() {\n  int n,m;\n  cin >> m >> n;\n  string s[n];\n  for(int i=0; i<n; i++) cin >> s[i];\n  priority_queue<PP,vector<PP>,greater<PP> > que;\n  for(int i=0; i<n; i++) {\n    for(int j=0; j<m; j++) {\n      a[i][j]=1;\n      for(int k=0; k<(1<<5); k++) d[k][i][j]=1<<29;\n      if(s[i][j]=='S') {\n        d[0][i][j]=0;\n        que.push(PP(P(0,0),P(i,j)));\n      }\n      if(s[i][j]=='M') {\n        int k=ma.size();\n        ma[P(i,j)]=k;\n      }\n      for(int k=-2; k<=2; k++) {\n        for(int l=-2; l<=2; l++) {\n          int x=i+k,y=j+l;\n          if(!check(n,m,x,y)||s[x][y]!='#') continue;\n          int d=max(abs(i-x),abs(j-y));\n          if(d==1) a[i][j]=max(a[i][j],3);\n          if(d==2) a[i][j]=max(a[i][j],2);\n        }\n      }\n    }\n  }\n  while(!que.empty()) {\n    PP p=que.top();que.pop();\n    int xx=p.second.first,yy=p.second.second,cc=p.first.first,tt=p.first.second;\n    if(s[xx][yy]=='G'&&tt==(1<<ma.size())-1) {\n      cout << d[tt][xx][yy] << endl;\n      return 0;\n    }\n    if(d[tt][xx][yy]<cc) continue;\n    for(int i=0; i<4; i++) {\n      int x=xx+dx[i],y=yy+dy[i];\n      int t=tt;\n      if(!check(n,m,x,y)||s[x][y]=='#') continue;\n      if(s[x][y]=='M') t|=1<<ma[P(x,y)];\n      if(d[t][x][y]<=d[tt][xx][yy]+a[xx][yy]) continue;\n      d[t][x][y]=d[tt][xx][yy]+a[xx][yy];\n      que.push(PP(P(d[t][x][y],t),P(x,y)));\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <stdio.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long long ll;\ntypedef vector<ll> vll;\nconst int inf=10000000;\nint H,W,startx,starty,goalx,goaly;\nstring board[105];\nint cost[105][105];\nint d[105][105];\nint dx8[]={-1,-1,0,1,1,1,0,-1};\nint dy8[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={0,1,0,-1};\nint dx[]={-1,0,1,0};\n\ntypedef pair<int,int> P;\ntypedef pair<int,pair<int,int> > PP;\n\nvoid costset(int sx,int sy,int times)\n{\n  if(times==2) return;\n  int nowx=sx;\n  int nowy=sy;\n  int cos=3-times;\n  for(int k=0;k<8;k++)\n    {\n      int nx=nowx+dx8[k];\n      int ny=nowy+dy8[k];\n      if(nx<0 || W<=nx || ny<0 || H<=ny) continue;\n      cost[ny][nx]=max(cost[ny][nx],cos);\n      costset(nx,ny,times+1);\n    }\n}\n\nint solve(int sx,int sy,int gx,int gy)\n{\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  d[i][j]=inf;\n\t}\n    }\n  d[sy][sx]=0;\n  priority_queue<PP,vector<PP>,greater<PP> > p;\n  p.push(PP(0,P(sy,sx)));\n  int nowy,nowx;\n  while(!p.empty())\n    {\n      PP now=p.top();p.pop();\n      nowy=now.second.first;\n      nowx=now.second.second;\n      if(nowx==gx && nowy==gy) break;\n      for(int k=0;k<4;k++)\n\t{\n\t  int ny=nowy+dy[k];\n\t  int nx=nowx+dx[k];\n\t  if(ny<0 || H<=ny || nx<0 || W<=nx || board[ny][nx]=='#') continue;\n\t  if(d[nowy][nowx]+cost[nowy][nowx]>d[ny][nx]) continue;\n\t  d[ny][nx]=d[nowy][nowx]+cost[nowy][nowx];\n\t  p.push(PP(d[ny][nx],P(ny,nx)));\n\t}\n    }\n  return d[gy][gx];\n}\n\nint main(int argc,char const* argv[])\n{\n  int ans=20000000;\n  int scroll=0;\n  int pat=1;\n  vector<P> route;\n  cin >> W >> H;\n  for(int i=0;i<H;i++)\n    {\n      cin >> board[i];\n    }\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  cost[i][j]=1;\n\t  if(board[i][j]=='M') route.push_back(P(i,j));\n\t  if(board[i][j]=='G') {goaly=i;goalx=j;}\n\t  if(board[i][j]=='S') {starty=i;startx=j;}\n\t}\n    }\n  sort(route.begin(),route.end());\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  if(board[i][j]=='#')\n\t    {\n\t      costset(j,i,0);\n\t    }\n\t  if(board[i][j]=='M')\n\t    {\n\t      scroll++;\n\t    }\n\t}\n    }\n   for(int i=1;i<=scroll;i++)\n     {\n       pat*=i;\n     }\n   for(int j=0;j<pat;j++)\n     {\n       vector<P> road;\n       vector<int> walk;\n       for(auto tmp:route) \n\t {\n\t   //cout << 'y x' << tmp.first << ' ' << tmp.second<< nedl;\n\t   road.push_back(P(tmp.first,tmp.second));\n\t }\n      walk.push_back(solve(startx,starty,road[0].second,road[0].first));\n      for(int i=0;i<road.size()-1;i++)\n\t{\n\t  walk.push_back(solve(road[i].second,road[i].first,road[i+1].second,road[i+1].first));\n\t}\n      walk.push_back(solve(road[road.size()-1].second,road[road.size()-1].first,goalx,goaly));\n      int tmp=0;\n      for(int i=0;i<walk.size();i++)\n\t{\n\t  tmp+=walk[i];\n\t}\n      ans=min(ans,tmp);\n      next_permutation(route.begin(),route.end());\n    }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<tuple>\n#include<queue>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\nenum{Y,X};\nenum{COST,SCROLL,I,J};\ntypedef tuple<int,int> Point;\ntypedef tuple<int,int,int,int> T;\n\nbool range(int x, int first, int last){return first<=x && x<=last;}\nint bitcount(int n){return n?(n&1)+bitcount(n>>1):0;}\n\nint main()\n{\n  int W, H;\n  string line;\n  Point start, goal;\n  vector<Point> scroll, holl;\n\n  cin>>W>>H;\n\n  vector< vector<int> > field(H, vector<int>(W, 1) );\n\n  for(int i=0; i<H; i++){\n    cin>>line;\n    for(int j=0; j<W; j++){\n      switch(line[j]){\n      case 'S':\n        start = Point(i,j);\n        break;\n      case 'G':\n        goal = Point(i,j);\n        break;\n      case 'M':\n        scroll.push_back( Point(i,j) );\n        break;\n      case '#':\n        holl.push_back( Point(i,j) );\n        for(int dy=-2; dy<=2; dy++){\n          for(int dx=-2; dx<=2; dx++){\n            int y=i+dy, x=j+dx;\n            if(!range(y,0,H-1))continue;\n            if(!range(x,0,W-1))continue;\n            if(dy==-2 || dy==2 || dx==-2 || dx==2)field[y][x]=max(2,field[y][x]);\n            else field[y][x]=3;\n          }\n        }\n        break;\n      case '.':\n        break;\n      default:\n        break;\n      }\n    }\n  }\n\n  int ans;\n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n\n  set<T> visited;\n  priority_queue<T> q;\n  q.push( T( 0, 0, get<Y>(start), get<X>(start) ) );\n  while(!q.empty()){\n    T now = q.top();\n    q.pop();\n\n    if( visited.count( T(0, get<SCROLL>(now), get<I>(now), get<J>(now)) ) )continue;\n    visited.insert( T(0, get<SCROLL>(now), get<I>(now), get<J>(now)) );\n\n    //    printf(\"cost=%d; scroll=%d; point=(%d, %d);   %d\\n\",get<COST>(now),get<SCROLL>(now),get<I>(now),get<J>(now),q.size());\n\n    if(get<I>(now)==get<Y>(goal) && get<J>(now)==get<X>(goal)){\n      if( bitcount( get<SCROLL>(now) ) == scroll.size() ){\n        ans=-get<COST>(now);\n        break;\n      }\n    }\n    for(int j=0; j<scroll.size(); j++){\n      if(get<I>(now)==get<Y>(scroll[j]) && get<J>(now)==get<X>(scroll[j])){\n        if( (get<SCROLL>(now)>>j)&1 ){\n          break;\n        }else{\n          get<SCROLL>(now) ^= (1<<j);\n        }\n      }\n    }\n\n    bool ok=true;\n    for(int j=0; j<holl.size(); j++){\n      if(get<I>(now)==get<Y>(holl[j]) && get<J>(now)==get<X>(holl[j]))ok=false;\n    }\n    if(!ok)continue;\n\n    for(int i=0; i<4; i++){\n      int y=get<I>(now)+dy[i], x=get<J>(now)+dx[i];\n      if(!range(y,0,H-1))continue;\n      if(!range(x,0,W-1))continue;\n      q.push( T(get<COST>(now)-field[get<I>(now)][get<J>(now)], get<SCROLL>(now), y, x) );\n    }\n  }\n\n  //  for(int i=0;i<H;i++,cout<<endl)for(int j=0;j<W;j++)cout<<\" \"<<field[i][j];\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint visited[102][102][1<<5];\nint co[102][102];\nchar f[102][102];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nclass state{\n\tpublic:\n\tint x,y,co,st;\n\t\n\tstate(){}\t\n\tstate(int _y, int _x, int _co, int _state){\n\t\tx = _x;\n\t\ty = _y;\n\t\tco = _co;\n\t\tst = _state;\n\t}\n};\n\nint main(){\n\tint w,h;\n\tint sx, sy, gx, gy;\n\tint m=0;\n\tmemset(co, -1 , sizeof(co));\n\tfill((int *)visited, (int *)visited+102*102*(1<<5), 1 << 29);\n\tcin >> w >> h;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tco[i][j] = 1;\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tcin >> f[i][j];\n\t\t\tif(f[i][j] == '#'){\n\t\t\t\tfor(int p=-2;p<=2;p++){\n\t\t\t\t\tfor(int q=-2;q<=2;q++){\n\t\t\t\t\t\tif(0 <= i+p && i+p <= h && 0 <= j+q && j+q <= w){\n\t\t\t\t\t\t\tif((p == 0 && q == 0) || co[i+p][j+q] == -1){\n\t\t\t\t\t\t\t\tco[i+p][j+q] = -1;\n\t\t\t\t\t\t\t}else if(max(abs(p), abs(q)) == 2){\n\t\t\t\t\t\t\t\tco[i+p][j+q] = max(co[i+p][j+q],2);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tco[i+p][j+q] = max(co[i+p][j+q],3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(f[i][j] == 'S'){\n\t\t\t\tsy = i;\n\t\t\t\tsx = j;\n\t\t\t}else if(f[i][j] == 'G'){\n\t\t\t\tgy = i;\n\t\t\t\tgx = j;\n\t\t\t}else if(f[i][j] == 'M'){\n\t\t\t\tf[i][j] = m + '0';\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t}\n\tdeque<state> q;\n\tstate st;\n\tint tx,ty,tco,tstate,nx,ny,nstate;\n\tq.push_back(state(sy,sx,0,0));\n\tvisited[sy][sx][0] = 0;\n\twhile(!q.empty()){\n\t\tst = q.front();\n\t\tq.pop_front();\n\t\ttx = st.x;\n\t\tty = st.y;\n\t\ttco = st.co;\n\t\ttstate = st.st;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tnx = tx + dx[i];\n\t\t\tny = ty + dy[i];\n\t\t\tif(co[ny][nx] == -1) continue;\n\t\t\tif('0' <= f[ny][nx] && f[ny][nx] <= '9'){\n\t\t\t\tnstate = tstate | (1 << (f[ny][nx] - '0'));\n\t\t\t\tif(visited[ny][nx][nstate] > tco + co[ty][tx]){\n\t\t\t\t\tvisited[ny][nx][nstate] = tco + co[ty][tx];\n\t\t\t\t\tq.push_back(state(ny,nx,tco+co[ty][tx],nstate));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(visited[ny][nx][tstate] > tco + co[ty][tx]){\n\t\t\t\t\tvisited[ny][nx][tstate] = tco + co[ty][tx];\n\t\t\t\t\tq.push_back(state(ny,nx,tco+co[ty][tx],tstate));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << visited[gy][gx][(1 << m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cstdlib>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct point{\n\tint x,y;\n\tbool operator<(const point &a)const{ return true; } // dummy\n};\n\nint main(){\n\tint w,h; scanf(\"%d%d\",&w,&h);\n\tchar B[100][101];\n\trep(i,h) scanf(\"%s\",B[i]);\n\n\tpoint s,g;\n\tvector<point> hole,maki;\n\trep(i,h) rep(j,w) {\n\t\tif(B[i][j]=='S') s=(point){j,i};\n\t\tif(B[i][j]=='G') g=(point){j,i};\n\t\tif(B[i][j]=='M') maki.push_back((point){j,i});\n\t\tif(B[i][j]=='#') hole.push_back((point){j,i});\n\t}\n\n\tstatic int d[100][100][1<<5];\n\trep(i,h) rep(j,w) rep(S,1<<maki.size()) d[i][j][S]=INF;\n\td[s.y][s.x][0]=0;\n\n\tpriority_queue< pair<int,pair<point,int> > > Q;\n\tQ.push(make_pair(0,make_pair(s,0)));\n\twhile(!Q.empty()){\n\t\tint d_now=-Q.top().first;\n\t\tpoint p=Q.top().second.first;\n\t\tint S=Q.top().second.second; Q.pop();\n\n\t\tif(d_now>d[p.y][p.x][S]) continue;\n\t\tif(p.x==g.x && p.y==g.y && S==(1<<maki.size())-1) break;\n\n\t\tint cost=1;\n\t\trep(i,hole.size()) cost=max(cost,max(4-max(abs(p.x-hole[i].x),abs(p.y-hole[i].y)),1));\n\n\t\trep(k,4){\n\t\t\tint xx=p.x+dx[k],yy=p.y+dy[k];\n\t\t\tif(0<=yy && yy<h && 0<=xx && xx<w && B[yy][xx]!='#'){\n\t\t\t\tint S2=S;\n\t\t\t\trep(i,maki.size()) if(xx==maki[i].x && yy==maki[i].y) S2|=1<<i;\n\n\t\t\t\tint d2=d[p.y][p.x][S]+cost;\n\t\t\t\tif(d[yy][xx][S2]>d2){\n\t\t\t\t\td[yy][xx][S2]=d2;\n\t\t\t\t\tQ.push(make_pair(-d[yy][xx][S2],make_pair((point){xx,yy},S2)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",d[g.y][g.x][(1<<maki.size())-1]);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <numeric>\n#include <queue>\n#include <cstring>\n#include <stdio.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef long long ll;\ntypedef vector<ll> vll;\nconst int inf=10000000;\nint H,W,startx,starty,goalx,goaly;\nstring board[105];\nint cost[105][105];\nint d[105][105];\nbool visited[150][105];\nint dx8[]={-1,-1,0,1,1,1,0,-1};\nint dy8[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={0,1,0,-1};\nint dx[]={-1,0,1,0};\n\ntypedef pair<int,int> P;\ntypedef pair<int,pair<int,int> > PP;\n\nvoid costset(int sx,int sy,int times)\n{\n  if(times==2) return;\n  int nowx=sx;\n  int nowy=sy;\n  int cos=3-times;\n  for(int k=0;k<8;k++)\n    {\n      int nx=nowx+dx8[k];\n      int ny=nowy+dy8[k];\n      if(nx<0 || W<=nx || ny<0 || H<=ny) continue;\n      cost[ny][nx]=max(cost[ny][nx],cos);\n      costset(nx,ny,times+1);\n    }\n}\n\nint solve(int sx,int sy,int gx,int gy)\n{\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  d[i][j]=inf;\n\t}\n    }\n  memset(visited,false,sizeof(visited));\n  d[sy][sx]=0;\n  priority_queue<PP,vector<PP>,greater<PP> > p;\n  p.push(PP(0,P(sy,sx)));\n  visited[sy][sx]=true;\n  int nowy,nowx;\n  while(!p.empty())\n    {\n      PP now=p.top();p.pop();\n      nowy=now.second.first;\n      nowx=now.second.second;\n      if(nowx==gx && nowy==gy) break;\n      for(int k=0;k<4;k++)\n\t{\n\t  int ny=nowy+dy[k];\n\t  int nx=nowx+dx[k];\n\t  if(ny<0 || H<=ny || nx<0 || W<=nx || board[ny][nx]=='#') continue;\n\t  if(d[nowy][nowx]+cost[nowy][nowx]>=d[ny][nx]) continue;\n\t  if(d[ny][nx]==inf || d[ny][nx]>d[nowy][nowx]+cost[nowy][nowx])\n\t    {\n\t      d[ny][nx]=d[nowy][nowx]+cost[nowy][nowx];\n\t      p.push(PP(d[ny][nx],P(ny,nx)));\n\t    }\n\t}\n    }\n  return d[gy][gx];\n}\n\nint main(int argc,char const* argv[])\n{\n  int ans=20000000;\n  int scroll=0;\n  int pat=1;\n  int graph[10][10];\n  for(int i=0;i<10;i++)\n    {\n      for(int j=0;j<10;j++)\n\t{\n\t  graph[i][j]=inf;\n\t}\n    }\n  vector<P> route;\n  cin >> W >> H;\n  for(int i=0;i<H;i++)\n    {\n      cin >> board[i];\n    }\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  cost[i][j]=1;\n\t  if(board[i][j]=='M') route.push_back(P(i,j));\n\t  if(board[i][j]=='G') {goaly=i;goalx=j;}\n\t  if(board[i][j]=='S') {starty=i;startx=j;}\n\t}\n    }\n  sort(route.begin(),route.end());\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  if(board[i][j]=='#')\n\t    {\n\t      costset(j,i,0);\n\t    }\n\t  if(board[i][j]=='M')\n\t    {\n\t      scroll++;\n\t    }\n\t}\n    }\n  for(int i=0;i<route.size();i++)\n    {\n      graph[0][i+1]=solve(startx,starty,route[i].second,route[i].first);\n      graph[i+1][6]=solve(route[i].second,route[i].first,goalx,goaly);\t\t\t\t\t      \n      for(int j=i+1;j<route.size();j++)\n\t{\n\t  if(i==j) continue;\n\t  int stx=route[i].second;\n\t  int sty=route[i].first;\n\t  int gox=route[j].second;\n\t  int goy=route[j].first;\n\t  graph[i+1][j+1]=solve(stx,sty,gox,goy);\n\t  graph[j+1][i+1]=graph[i+1][j+1];\n\t}\n    }\n  cout << \"route check\" << endl;\n   for(int i=1;i<=scroll;i++)\n     {\n       pat*=i;\n     }\n   vector<int> walk(scroll);\n   iota(walk.begin(),walk.end(),1);\n   for(int j=0;j<pat;j++)\n     {\n       int tmp=0;\n       int prev=0;\n       int to=0;\n       for(auto x:walk) \n\t {\n\t   to=x;\n\t   tmp+=graph[prev][to];\n\t   prev=x;\t   \n\t }\n       tmp+=graph[to][6];\n       ans=min(ans,tmp);\n       next_permutation(walk.begin(),walk.end());\n     }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\nstatic const ll MAX = 1e15;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nclass State{\npublic:\n  int x;\n  int y;\n  int cost;\n  int scrolling;\n  State(int _x,int _y,int _c,int _s) : x(_x),y(_y),cost(_c),scrolling(_s) {}\n  bool operator<(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator>(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nint main(){\n  int W,H;\n  while(~scanf(\"%d %d\",&W,&H)){\n    char stage[101][101];\n    int times[101][101];\n    int scrolling2idx[101][101];\n\n    vector<P> holes;\n\n    int sx,sy;\n    int gx,gy;\n    int scrolling_size = 0;\n    for(int y=0; y<H;y++){\n      char buf[128];\n      scanf(\"%s\",buf);\n      for(int x=0; x<W;x++){\n        stage[y][x] = buf[x];\n        if(buf[x] == '#'){\n          holes.push_back(P(x,y));\n        }\n        else if(buf[x] == 'M'){\n          scrolling2idx[y][x] = scrolling_size++;\n        }\n        else if(buf[x] == 'S'){\n          sy = y;\n          sx = x;\n        }\n        else if(buf[x] == 'G'){\n          gy = y;\n          gx = x;\n        }\n      }\n    }\n    for(int y=0; y<H;y++){\n      for(int x=0; x<W;x++){\n        int dist = INF;\n        for(int i=0;i<holes.size();i++){\n          dist = min(dist,max(abs(y - holes[i].second),abs(x - holes[i].first)));\n        }\n        times[y][x] = max(1,4-dist);\n      }\n    }\n\n    priority_queue<State,vector<State>,greater<State> > que;\n    que.push(State(sx,sy,0,0));\n\n    int dp[101][101][1<<5];\n    memset(dp,0x3f,sizeof(dp));\n\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      dp[s.x][s.y][s.scrolling] = s.cost;\n\n      for(int i=0;i<4;i++){\n        int dx = s.x + tx[i];\n        int dy = s.y + ty[i];\n        if(dx < 0 || dy < 0 || dx >= W || dy >=H ) continue;\n        if(stage[dy][dx] == '#') continue;\n\n        int next_scrolling = s.scrolling;\n        if(stage[dy][dx] == 'M'){\n           next_scrolling |= (1 << scrolling2idx[dy][dx]);\n        }\n        if(dp[dx][dy][next_scrolling] <= s.cost + times[s.y][s.x]) continue;\n        dp[dx][dy][next_scrolling] = s.cost + times[s.y][s.x];\n        que.push(State(dx,dy,s.cost + times[s.y][s.x],next_scrolling));\n      }\n    }\n    printf(\"%d\\n\",dp[gx][gy][(1<<scrolling_size)-1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<cstring>\nusing namespace std;\ntypedef pair<int,int> Pt;\ntypedef pair<Pt,Pt> P;\n#define fr first\n#define sc second\nint h,w,sx,sy,gx,gy,d[]={0,1,0,-1},Time[101][101],cnt;\nbool used[101][101][1<<5];\nint ldx[]={-1,-1,-1,0,1,1,1,-1},ldy[]={-1,0,1,1,1,0,-1,-1};\nint sdx[]={-2,-2,-2,-2,-2,-1,0,1,2,2,2,2,2,1,0,-1};\nint sdy[]={-2,-1,0,1,2,2,2,2,2,1,0,-1,-2,-2,-2,-2};\nchar mas[101][101];\nvoid BAD(int,int);\nint bfs();\nbool judge(int x,int y){ return ((x>=0&&x<h&&y>=0&&y<w)? true : false); }\nint main(){\n  cin >> w >> h;\n  for(int i=0;i<h;i++) for(int j=0;j<w;j++) Time[i][j] = 1;\n\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> mas[i][j];\n      if(mas[i][j] == 'S') sx = i,sy = j;\n      else if(mas[i][j] == 'G') gx = i,gy = j;\n      else if(mas[i][j] == '#') BAD(i,j);\n      else if(mas[i][j] == 'M') mas[i][j] = cnt++;\n    }\n  }\n  cout << bfs() << endl;\n}\nint bfs(){\n  int mini = 10000000;\n  memset(used,false,sizeof(used));\n  priority_queue<P,vector<P>,greater<P> > que;\n  //時間 場所(x,y) BIT\n  que.push(P(Pt(0,sx),Pt(sy,0)));\n  used[sx][sy][0] = 0;\n  while(!que.empty()){\n    P p = que.top();\n    int t = p.fr.fr,px = p.fr.sc,py = p.sc.fr,BIT = p.sc.sc;\n    que.pop();\n    if(px == gx && py == gy && BIT ==(1<<cnt)-1 )mini = min(mini,t);\n    if(used[px][py][BIT]) continue;\n    used[px][py][BIT] = true;\n    for(int i=0;i<4;i++){\n      int nx = px + d[i],ny = py + d[3-i],bit = BIT;\n      if(!judge(nx,ny)) continue;\n      if(mas[nx][ny] == '#') continue;\n      if(mas[nx][ny]>=0&&mas[nx][ny]<=10) bit |= 1<<mas[nx][ny];\n      que.push(P(Pt(t+Time[nx][ny],nx),Pt(ny,bit)));\n    }\n  }\n  return mini;\n}\nvoid BAD(int x,int y){\n  for(int i=0;i<8;i++){\n    int nx=x+ldx[i],ny=y+ldy[i];\n    if(judge(nx,ny)) Time[nx][ny] = 3;\n  }\n  for(int i=0;i<16;i++){\n    int nx=x+sdx[i],ny=y+sdy[i];\n    if(judge(nx,ny)) Time[nx][ny] = max(Time[nx][ny],2);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <cctype>\n#include <functional>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main(){\n\tint INF = (int)1e9;\n\n\tvector<vector<char> > field(108, vector<char>(108, '#') );\n\tvector<vector<int> > tm(108, vector<int>(108, 1) );\n\n\tint w, h;\n\tscanf(\"%d%d\", &w, &h);\n\tfor(int i = 3; i < h + 3; ++i){\n\t\tscanf(\" %s\", &field[i][3]);\n\t\tfield[i][w + 3] = '#';\n\t}\n\n\tvector<pii> roll(2);\n\n\tqueue<pii> q;\n\tfor(int i = 3; i < h + 3; ++i){\n\t\tfor(int j = 3; j < w + 3; ++j){\n\t\t\tswitch( field[i][j] ){\n\t\t\t\tcase '#':\n\t\t\t\t\tfor(int y = i - 2; y <= i + 2; ++y)\n\t\t\t\t\tfor(int x = j - 2; x <= j + 2; ++x){\n\t\t\t\t\t\tint t = 4 - max(abs(y - i), abs(x - j));\n\t\t\t\t\t\ttm[y][x] = max(tm[y][x], t);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\troll[1] = pii(i, j);\n\t\t\t\t\tfield[i][j] = '1';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'G':\n\t\t\t\t\troll[0] = pii(i, j);\n\t\t\t\t\tfield[i][j] = '0';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\tfield[i][j] = '0' + roll.size();\n\t\t\t\t\troll.push_back( pii(i, j) );\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tint n = roll.size();\n\tvector<vector<int> > dist(n, vector<int>(n, INF) );\n\t\n\tfor(int i = 1; i < n; ++i){\n\t\tvector<vector<int> > d(108, vector<int>(108, INF) );\n\t\td[roll[i].first][roll[i].second] = 0;\n\t\t\n\t\tpriority_queue<pii,vector<pii>,greater<pii> > pq;\n\t\tpq.push( pii(0, roll[i].first * 1000 + roll[i].second) );\n\t\t\n\t\twhile( !pq.empty() ){\n\t\t\tpii p = pq.top();\n\t\t\tpq.pop();\n\n\t\t\tint y = p.second / 1000;\n\t\t\tint x = p.second % 1000;\n\n\t\t\tif( isdigit( field[y][x] ) ){\n\t\t\t\tdist[i][field[y][x] - '0'] = p.first;\n\t\t\t}\n\n\t\t\tint c = p.first + tm[y][x];\n\n\t\t\tfor(int j = 0; j < 4; ++j){\n\t\t\t\tint ny = y + dy[j];\n\t\t\t\tint nx = x + dx[j];\n\t\t\t\t\n\t\t\t\tif( field[ny][nx] != '#' && d[ny][nx] > c ){\n\t\t\t\t\td[ny][nx] = c;\n\t\t\t\t\tpq.push( pii(c, ny * 1000 + nx) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n/*\nfor(int i=2;i<h+4;++i){\nfor(int j=2;j<w+4;++j)\nprintf(\"%c \",field[i][j]);\nputs(\"\");\n}puts(\"\");\n\nfor(int i=3;i<h+3;++i){\nfor(int j=3;j<w+3;++j)\nprintf(\"%d \",tm[i][j]);\nputs(\"\");\n}puts(\"\");\n\nfor(int i=1;i<n;++i){\nfor(int j=0;j<n;++j)\nprintf(\"%4d \",dist[i][j]);\nputs(\"\");\n}puts(\"\");\n*/\n\tint last = 1 << n;\n\tvector<vector<int> > dp(n, vector<int>(last, INF) );\n\tdp[1][2] = 0;\n\n\tfor(int S = 0; S < last; ++S){\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif( S & 1 << i ){\n\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\tif( !(S & 1 << j) ){\n\t\t\t\t\t\tint next = S | 1 << j;\n\t\t\t\t\t\tdp[j][next] = min(dp[j][next], dp[i][S] + dist[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dp[0].back());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<deque>\n#include<climits>\n#include<numeric>\n#include<cassert>\n#include<functional>\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define fi(i,j,k) fill(i[0],i[0]+j*j,k)\n#define INF 1<<27\n#define F first\n#define S second\nstatic const double eps=1e-10;\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w;\nchar cmap[110][110];\nP pos[110];\nint index,matrix[110][110];\nint imap[110][110];\nstatic const int dx[4] = {0,1,0,-1};\nstatic const int dy[4] = {1,0,-1,0};\nstatic const int dx8[8] = {0,1,1,1,0,-1,-1,-1};\nstatic const int dy8[8] = {-1,-1,0,1,1,1,0,-1};\nstatic const int dx16[16] = {0,1,2,2,2,2,2,1,0,-1,-2,-2,-2,-2,-2,-1};\nstatic const int dy16[16] = {-2,-2,-2,-1,0,1,2,2,2,2,2,1,0,-1,-2,-2};\n\nint D[110][110];\nbool used[110][110];\n\nvoid bfs(P s,P g){\n  rep(i,h)rep(j,w){\n    D[i][j] = INF;\n    used[i][j] = false;\n  }\n  queue<P> que;\n  que.push(s);\n  D[s.S][s.F] = 0;\n  used[s.S][s.F] = true;\n\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n\n    for(int i=0;i<4;i++){\n      int nx = p.F+dx[i],ny = p.S+dy[i];\n      if(0<= nx && nx < w && 0<= ny && ny < h && cmap[ny][nx] != '#' && D[ny][nx] > D[p.S][p.F] +imap[ny][nx]){\n\tD[ny][nx] = min(D[p.S][p.F] + imap[ny][nx],D[ny][nx]);\n\n\tque.push(P(nx,ny));\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin >> w >> h){\n    int sindex,lim = 1;\n    index = 1;\n  \n    rep(i,h)rep(j,w)imap[i][j] = 1;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> cmap[i][j];\n\tmatrix[i][j] = INF;\n\tif(cmap[i][j] == 'S'){\n\t  lim++;\n\t}\n\telse if(cmap[i][j] == 'M')lim++;\n\telse if(cmap[i][j] == 'G'){\n\t  pos[0] = P(j,i);\n\t}\n      }\n    }\n \n    rep(i,h){\n      rep(j,w){\n      \n\tif(cmap[i][j] == 'S'){\n\t  pos[lim-1] = P(j,i);\n\t}\n\telse if(cmap[i][j] == 'M'){\n\t  assert(index != lim-1);\n\t  pos[index++] = P(j,i);\n\t}\n\telse if(cmap[i][j] == '#'){\n\t  for(int k=0;k<8;k++){\n\t  \n\t    int nx = j+dx8[k],ny = i+dy8[k];\n\t    if(0<=nx && nx<w && 0<=ny && ny <h && cmap[ny][nx] != '#'){\n\t      imap[ny][nx] = 3;\n\t    }\n\t  }\n\t  for(int k=0;k<16;k++){\n\t    int nx = j+dx16[k],ny = i+dy16[k];\n\t    if(0<=nx && nx<w && 0<=ny && ny <h && cmap[ny][nx] != '#'){\n\t      imap[ny][nx] = max(imap[ny][nx],2);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n\n    index = lim;\n\n    for(int i=0;i<index;i++){\n      rep(j,index){\n    \n\tif(i == j){\n\t  matrix[i][j] = 0;\n\t  continue;\n\t}\n\tbfs(pos[i],pos[j]);\n\tmatrix[i][j] = D[pos[j].S][pos[j].F];\n      }\n    }\n    int per[110];\n    rep(i,index-1)per[i] = i+1;\n\n    int sum;\n    int ans=INF;\n    do{\n      sum=0;\n      sum+=matrix[0][per[0]];\n\n      int posi=-1;     \n      for(int i=1;i<index-1;i++){\n\tif(i == index-2)posi = per[i];\n\tsum+=matrix[per[i-1]][per[i]];\n      }\n    \n      if(posi != -1 && posi != lim-1)sum += matrix[posi][lim-1];\n    \n      ans=min(ans,sum);\n    }while(next_permutation(per,per+(index-1)));\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n#define C first.first\n#define F first.second\n#define X second.first\n#define Y second.second\n#define INF (1<<29)\nint W,H;\nchar fie[101][101];\nint mvc[101][101];\nint dmx[]={1,0,-1,0,1,-1,1,-1};\nint dmy[]={0,1,0,-1,1,-1,-1,1};\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint h[101][101][1<<5];\nint gx,gy;\nint MC;\nbool check(int x,int y){\n  if(x < 0 || y < 0 || x>=W || y>=H ) return true;\n  return false;\n}\nvoid printmv(){\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++)\n      printf(\"%2d \",mvc[j][i]);\n    puts(\"\");\n  }   \n}\nvoid printh(){\n  for(int k=0;k<(1<<MC);k++)\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n\tprintf(\"h[%d][%d][%d]=%d\\n\",j,i,k,h[j][i][k]);\n}\nint solve(int x,int y){\n  //   printmv();\n  priority_queue<PP> q;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      for(int k=0;k<(1<<5);k++)\n\th[j][i][k]=INF;\n  q.push(PP(P(0,0),P(x,y)));\n  h[x][y][0]=0;\n  while(!q.empty()){\n    PP p = q.top(); q.pop();\n    x = p.X; y = p.Y;\n    for(int i=0;i<4;i++){\n      int nx = x + dx[i], ny = y + dy[i];\n      if( check(nx,ny) ) continue;\n      if( fie[nx][ny] == '#') continue;\n      if( '0' <= fie[nx][ny] && fie[nx][ny] <= '5' ){\n\tint mc = fie[nx][ny]-'0';\n\tint st = (p.F | (1<<mc));\n\tif( h[nx][ny][st] > p.C + mvc[x][y] ){\n\t  h[nx][ny][st] = p.C + mvc[x][y];\n\t  q.push(PP(P(p.C+mvc[x][y],st),P(nx,ny)));\n\t}\n      } else {\n\tif( h[nx][ny][p.F] > p.C + mvc[x][y] ){\n\t  h[nx][ny][p.F] = p.C + mvc[x][y];\n\t  q.push(PP(P(p.C+mvc[x][y],p.F),P(nx,ny)));\n\t}\n      }\n    }\n  }\n  // printh();\n  return h[gx][gy][(1<<MC)-1];\n}\nvoid mark(int x,int y,int c){\n  for(int i=0;i<8;i++){\n    int nx = x+dmx[i], ny = y + dmy[i];\n    if(check(nx,ny)) continue;\n    mvc[nx][ny]=max(mvc[nx][ny],c);\n  }\n  if(c==3){\n    for(int i=0;i<8;i++){\n      int nx = x+dmx[i], ny = y + dmy[i];\n      if(check(nx,ny)) continue;\n      mark(nx,ny,c-1);\n    }\n  }\n}\nint main(){\n  int sx,sy;\n  cin >> W >> H;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin >> fie[j][i];\n      mvc[j][i]=1;\n    }\n  }\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(fie[j][i]=='#'){\n\tmark(j,i,3);\n      } else if(fie[j][i]=='S'){\n\tsx = j;\n\tsy = i;\n      } else if(fie[j][i]=='M'){\n\tfie[j][i]='0'+MC;\n\tMC++;\n      } else if(fie[j][i]=='G'){\n\tgx = j;\n\tgy = i;\n      }\n    }\n  }\n  cout << solve(sx,sy) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\n\n#define Y first\n#define X second\ntypedef pair<int,int> Point;\n\nstruct T{\n  int cost,scroll,y,x;\n  T(){}\n  T(int a, int b, int c, int d){cost=a;scroll=b;y=c;x=d;}\n};\nbool operator<(T a, T b){\n  if(a.cost!=b.cost)return a.cost<b.cost;\n  if(a.scroll!=b.scroll)return a.scroll>b.scroll;\n  if(a.y!=b.y)return a.y>b.y;\n  if(a.x!=b.x)return a.x>b.x;\n  return true;\n}\n\nbool range(int x, int first, int last){return first<=x && x<=last;}\nint bitcount(int n){return n?(n&1)+bitcount(n>>1):0;}\n\nint main()\n{\n  int W, H;\n  string line;\n  Point start, goal;\n  vector<Point> scroll, holl;\n\n  cin>>W>>H;\n\n  vector< vector<int> > field(H, vector<int>(W, 1) );\n\n  for(int i=0; i<H; i++){\n    cin>>line;\n    for(int j=0; j<W; j++){\n      switch(line[j]){\n      case 'S':\n        start = Point(i,j);\n        break;\n      case 'G':\n        goal = Point(i,j);\n        break;\n      case 'M':\n        scroll.push_back( Point(i,j) );\n        break;\n      case '#':\n        holl.push_back( Point(i,j) );\n        for(int dy=-2; dy<=2; dy++){\n          for(int dx=-2; dx<=2; dx++){\n            int y=i+dy, x=j+dx;\n            if(!range(y,0,H-1))continue;\n            if(!range(x,0,W-1))continue;\n            if(dy==-2 || dy==2 || dx==-2 || dx==2)field[y][x]=max(2,field[y][x]);\n            else field[y][x]=3;\n          }\n        }\n        break;\n      case '.':\n        break;\n      default:\n        break;\n      }\n    }\n  }\n\n  int ans;\n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n  vector<T> visited;\n  priority_queue<T> q;\n  q.push( T(0, 0, start.Y, start.X) );\n  while(!q.empty()){\n    T now = q.top();\n    q.pop();\n\n    bool f=true;\n    for(int j=0; j<visited.size(); j++){\n      if(visited[j].scroll==now.scroll && visited[j].y==now.y && visited[j].x==now.x)f=false;\n    }\n    if(!f)continue;\n    visited.push_back(now);\n\n    if(now.y==goal.Y && now.x==goal.X){\n      if( bitcount(now.scroll) == scroll.size() ){\n        ans=-now.cost;\n        break;\n      }\n    }\n    for(int j=0; j<scroll.size(); j++){\n      if(now.y==scroll[j].Y && now.x==scroll[j].X){\n        if( (now.scroll>>j)&1 ){\n          break;\n        }else{\n          now.scroll ^= (1<<j);\n        }\n      }\n    }\n\n    bool ok=true;\n    for(int j=0; j<holl.size(); j++){\n      if(now.y==holl[j].Y && now.x==holl[j].X)ok=false;\n    }\n    if(!ok)continue;\n\n    for(int i=0; i<4; i++){\n      int y=now.y+dy[i], x=now.x+dx[i];\n      if(!range(y,0,H-1))continue;\n      if(!range(x,0,W-1))continue;\n      q.push( T(now.cost-field[now.y][now.x], now.scroll, y, x) );\n    }\n  }\n\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nstruct state {\n\tint x, y, cost;\n};\nbool operator<(const state& s1, const state& s2) {\n\treturn s1.cost < s2.cost;\n}\nint dir[] = { 0, 1, 0, -1 };\nint W, H, a[109][109], x[9], y[9], cnt, dist[7][7], d[109][109], dp[9][135], popcount[135]; string s[109];\nint main() {\n\tfor (int i = 0; i < 7; i++) {\n\t\tfor (int j = 1 << i; j < 2 << i; j++) {\n\t\t\tpopcount[j] = popcount[j - (1 << i)] + 1;\n\t\t}\n\t}\n\tcin >> W >> H;\n\tfor (int i = 0; i < H; i++) fill(a[i], a[i] + W, 1);\n\tfor (int i = 0; i < H; i++) {\n\t\tcin >> s[i];\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] == 'S') x[0] = i, y[0] = j;\n\t\t\tif (s[i][j] == 'G') x[1] = i, y[1] = j;\n\t\t\tif (s[i][j] == 'M') x[cnt + 2] = i, y[cnt + 2] = j, cnt++;\n\t\t\tif (s[i][j] == '#') {\n\t\t\t\tfor (int dx = -2; dx <= 2; dx++) {\n\t\t\t\t\tfor (int dy = -2; dy <= 2; dy++) {\n\t\t\t\t\t\tint c = max(abs(dx), abs(dy));\n\t\t\t\t\t\tint tx = i + dx, ty = j + dy;\n\t\t\t\t\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W) {\n\t\t\t\t\t\t\tint r = 2;\n\t\t\t\t\t\t\tif (c == 0) r = 999999999;\n\t\t\t\t\t\t\tif (c == 1) r = 3;\n\t\t\t\t\t\t\ta[tx][ty] = max(a[tx][ty], r);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint p = cnt + 2;\n\tfor (int i = 0; i < p; i++) {\n\t\tfor (int j = 0; j < H; j++) fill(d[j], d[j] + W, 999999999);\n\t\td[x[i]][y[i]] = 0;\n\t\tpriority_queue<state> que; que.push(state{ x[i], y[i], 0 });\n\t\twhile (!que.empty()) {\n\t\t\tstate u = que.top(); que.pop();\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tint tx = u.x + dir[j], ty = u.y + dir[j ^ 1];\n\t\t\t\tint cost = d[u.x][u.y] + a[u.x][u.y];\n\t\t\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W && d[tx][ty] > cost) {\n\t\t\t\t\td[tx][ty] = cost;\n\t\t\t\t\tque.push(state{ tx, ty, -cost });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < p; j++) dist[i][j] = d[x[j]][y[j]];\n\t}\n\tfor (int i = 0; i < p; i++) fill(dp[i], dp[i] + (1 << p), 999999999);\n\tdp[0][1] = 0;\n\tfor (int i = 3; i < 1 << p; i += 2) {\n\t\tfor (int j = 0; j < p; j++) {\n\t\t\tif (!(i & (1 << j))) continue;\n\t\t\tint sub = i - (1 << j);\n\t\t\tfor (int k = 0; k < p; k++) {\n\t\t\t\tif (!(sub & (1 << k))) continue;\n\t\t\t\tint s = sub - (1 << (k - 1));\n\t\t\t\tdp[j][i] = min(dp[j][i], dp[k][sub] + dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[1][(1 << p) - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <deque>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint visited[102][102][1<<5];\nint co[102][102];\nchar f[102][102];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nclass state{\n\tpublic:\n\tint x,y,co,st;\n\t\n\tstate(){}\n\t\n\tstate(int _y, int _x, int _co, int _state){\n\t\tx = _x;\n\t\ty = _y;\n\t\tco = _co;\n\t\tst = _state;\n\t}\n};\n\nint main(){\n\tint w,h;\n\tint sx, sy, gx, gy;\n\tint m=0;\n\tchar c;\n\tmemset(co, -1 , sizeof(co));\n\tfill((int *)visited, (int *)visited+102*102*(1<<5), 1 << 29);\n\tcin >> w >> h;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tco[i][j] = 1;\n\t\t}\n\t}\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tcin >> f[i][j];\n\t\t\tif(f[i][j] == '#'){\n\t\t\t\tfor(int p=-2;p<=2;p++){\n\t\t\t\t\tfor(int q=-2;q<=2;q++){\n\t\t\t\t\t\tif(0 <= i+p && i+p <= h && 0 <= j+q && j+q <= w){\n\t\t\t\t\t\t\tif((p == 0 && q == 0) || co[i+p][j+q] == -1){\n\t\t\t\t\t\t\t\tco[i+p][j+q] = -1;\n\t\t\t\t\t\t\t}else if(max(abs(p), abs(q)) == 2){\n\t\t\t\t\t\t\t\tco[i+p][j+q] = max(co[i+p][j+q],2);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tco[i+p][j+q] = max(co[i+p][j+q],3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(f[i][j] == 'S'){\n\t\t\t\tsy = i;\n\t\t\t\tsx = j;\n\t\t\t}else if(f[i][j] == 'G'){\n\t\t\t\tgy = i;\n\t\t\t\tgx = j;\n\t\t\t}else if(f[i][j] == 'M'){\n\t\t\t\tf[i][j] = m + '0';\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tcout << f[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tcout << co[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\tdeque<state> q;\n\tstate st;\n\tint tx,ty,tco,tstate,nx,ny,nstate;\n\tq.push_back(state(sy,sx,0,0));\n\tvisited[sy][sx][0] = 0;\n\twhile(!q.empty()){\n\t\tst = q.front();\n\t\tq.pop_front();\n\t\ttx = st.x;\n\t\tty = st.y;\n\t\ttco = st.co;\n\t\ttstate = st.st;\n\t\t//printf(\"now (%d,%d) cost = %d, state = %d\\n\",ty,tx,tco,tstate);\n\t\tfor(int i=0;i<4;i++){\n\t\t\tnx = tx + dx[i];\n\t\t\tny = ty + dy[i];\n\t\t\tif(co[ny][nx] == -1) continue; //入れない場合\n\t\t\tif('0' <= f[ny][nx] && f[ny][nx] <= '9'){ //まきものの場合\n\t\t\t\tnstate = tstate | (1 << (f[ny][nx] - '0'));\n\t\t\t\tif(visited[ny][nx][nstate] > tco + co[ty][tx]){\n\t\t\t\t\tvisited[ny][nx][nstate] = tco + co[ty][tx];\n\t\t\t\t\tq.push_back(state(ny,nx,tco+co[ty][tx],nstate));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(visited[ny][nx][tstate] > tco + co[ty][tx]){\n\t\t\t\t\tvisited[ny][nx][tstate] = tco + co[ty][tx];\n\t\t\t\t\tq.push_back(state(ny,nx,tco+co[ty][tx],tstate));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << visited[gy][gx][(1 << m) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<functional>\nusing namespace std;\n\nint h,w;\nint cost[128][128];\nchar m[128][128];\n\nconst char FLOOR='.';\n\nstruct P{\n\tint x,y;\n\tP(int x,int y):x(x),y(y){}\n\tP(){}\n\tbool operator<(const P&)const{return false;}\n};\ntypedef pair<int,P>Pair;\t//cost,Pos\n\nint Cost(P s, P g)\n{\n\tconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1,};\n\tbool visited[128][128]={};\n\tpriority_queue<Pair,vector<Pair>,greater<Pair> >q;\n\tq.push(Pair(0,s));\n\twhile(!q.empty())\n\t{\n\t\tPair pa=q.top(); q.pop();\n\t\tP p=pa.second;\n\t\tif(visited[p.y][p.x]++)\n\t\t\tcontinue;\n\t\telse if(p.x==g.x && p.y==g.y)\n\t\t\treturn pa.first;\n\t\tfor(int i=0;i<4;++i)\n\t\t{\n\t\t\tint ax=p.x+dx[i];\n\t\t\tint ay=p.y+dy[i];\n\t\t\tif(m[ay][ax]!=FLOOR || visited[ay][ax])\n\t\t\t\tcontinue;\n\t\t\tq.push(Pair(pa.first+cost[p.y][p.x],P(ax,ay)));\n\t\t}\n\t}\n\treturn -1e9;\n}\n\nvoid AddCost(int x,int y)\n{\n\tfor(int dy=-2;dy<=2;++dy)\n\t{\n\t\tfor(int dx=-2;dx<=2;++dx)\n\t\t{\n\t\t\tint ax=x+dx;\n\t\t\tint ay=y+dy;\n\t\t\tif(1<=ax&&ax<=w&&1<=ay&&ay<=h)\n\t\t\t\tcost[ay][ax]=max(cost[ay][ax], 4-max(abs(dx),abs(dy)));\n\t\t}\n\t}\n}\n\nint main()\n{\n\tP s,g;\n\tvector<P>v;\n\tscanf(\"%d%d\",&w,&h);\n\n\tfill_n(&cost[0][0],128*128,1);\n\tmemset(m,'#',sizeof(m));\n\n\tint x,y;\n\tfor(y=1;y<=h;++y)\n\t\tscanf(\"%s\",&m[y][1]);\n\tfor(y=1;y<=h;++y)\n\t{\n\t\tfor(x=1;x<=w;++x)\n\t\t{\n\t\t\tswitch(m[y][x])\n\t\t\t{\n\t\t\tcase 'S':s=P(x,y);m[y][x]=FLOOR;break;\n\t\t\tcase 'G':g=P(x,y);m[y][x]=FLOOR;break;\n\t\t\tcase 'M':v.push_back(P(x,y));m[y][x]=FLOOR;break;\n\t\t\tcase '#':AddCost(x,y);break;\n\t\t\t}\n\t\t}\n\t}\n\tconst int n=v.size();\n\n\n\tv.insert(v.begin(),s);\n\tv.push_back(g);\n\tint edge[8][8];\n\tfor(int i=0;i<v.size();++i)\n\t{\n\t\tfor(int j=i+1;j<v.size();++j)\n\t\t{\n\t\t\tedge[i][j]=Cost(v[i],v[j]);\n\t\t\tedge[j][i]=Cost(v[j],v[i]);\n\t\t}\n\t}\n\tint a[]={1,2,3,4,5,6};\n\tint res = 1e9;\n\tdo\n\t{\n\t\tint temp=edge[0][a[0]]+edge[a[n-1]][n+1];\n\t\tfor(int i=0;i+1<n;++i)\n\t\t\ttemp+=edge[a[i]][a[i+1]];\n\t\tres = min(res,temp);\n\t}while(next_permutation(a,a+n));\n\tprintf(\"%d\\n\",res);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 100000\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<P,int> PI;\n\nconst int dy[4] = { -1, 0, 1, 0 };\nconst int dx[4] = {  0, 1, 0,-1 };\nconst int MAX_H = 100;\nconst int MAX_W = 100;\nconst int MAX_M = 5;\t\t// 巻物の最大数\nint H, W;\nchar f[MAX_H+1][MAX_W+1];\t// フィールド\nint  t[MAX_H+1][MAX_W+1];\t// フィールドを移動する時間、穴が近くにあると遅くなる\nint vis[MAX_H+1][MAX_W+1];\t// bfs 探索用\n\nint from_s[MAX_M+1], to_g[MAX_M+1], m2m[MAX_M+1][MAX_M+1]; // S から各巻物への距離、Gから各巻物への距離、各巻物の間の距離\n\nvoid output (void ){\n\t\n\trep (i, H ){\n\t\trep (j, W ){\n\t\t\tcout << f[i][j];\n\t\t} // end rep\n\t\tcout << endl;\n\t} // end rep\t\n}\nvoid output2 (void ){\n\t\n\trep (i, H ){\n\t\trep (j, W ){\n\t\t\tcout << (t[i][j] == INF ? 9 : t[i][j] );\n\t\t} // end rep\n\t\tcout << endl;\n\t} // end rep\t\n}\n\nint bfs (int sx, int sy, int ex, int ey ){\n\n\tqueue<PI> que;\n\tque.push (PI (P (sy, sx), 0 ) );\n\tmemset (vis, -1, sizeof (vis ) );\n\tvis[sy][sx] = 0;\n\n\twhile (!que.empty() ){\n\t\tPI cur = que.front(); que.pop();\n\t\tint cy = cur.first.first;\n\t\tint cx = cur.first.second;\n\t\tint cn = cur.second;\n\t\trep (k, 4 ){\n\t\t\tint ny = cy + dy[k];\n\t\t\tint nx = cx + dx[k];\n\t\t\tif (ny < 0 || ny >= H || nx < 0 || nx >= W || f[ny][nx] == '#' ) continue;\n\t\t\tif (vis[ny][nx] == -1 || vis[ny][nx] > cn + t[cy][cx] ){\n\t\t\t\tvis[ny][nx] = cn + t[cy][cx];\n\t\t\t\tque.push (PI (P (ny, nx ), cn + t[cy][cx] ) );\n\t\t\t} // end if\n\t\t} // end rep\n\t} // end while\t\n\n\treturn vis[ey][ex];\n}\t\n\nint res;\nvoid dfs (int ci, int sum, vector<bool> used ){\n\n\tint n = used.size();\n\tif ((int)count (ALL (used ), true ) == n ){\n\t\tint ans = sum + to_g[ci];\n\t\tres = min (res, ans );\n\t\treturn;\n\t} // end if\n\trep (i, n ){\n\t\tif (!used[i] && m2m[ci][i] != INF ){\n\t\t\tused[i] = true;\n\t\t\tdfs (i, m2m[ci][i] + sum, used );\n\t\t\tused[i] = false;\t\n\t\t} // end if\n\t} // end rep\n} \n\nint main()\n{\n\tmemset (f, 0, sizeof (f ) );\n\tmemset (from_s, 0, sizeof (from_s ) );\n\tmemset (to_g, 0, sizeof (to_g ) );\n\tfill (t[0], t[0] + MAX_H*MAX_W+1, 1 );\n\tfill (m2m[0], m2m[0] + MAX_M*MAX_M+1, INF );\n\tios_base::sync_with_stdio(0);\n\tcin >> W >> H;\n\trep (i, H ) rep (j, W ) cin >> f[i][j];\n\t\n\tint sx, sy, ex, ey;\t\t// S, G の位置\n\tvector<P> m; m.clear();\t// 巻物の位置\n\trep (i, H ) rep (j, W ){\n\t\tif (f[i][j] == 'S' ) sy = i, sx = j;\n\t\tif (f[i][j] == 'G' ) ey = i, ex = j;\n\t\tif (f[i][j] == 'M' ) m.push_back (P (j, i ) );\n\t\tif (f[i][j] == '#' ) t[i][j] = INF;\n\t} // end rep\t\n\t// 移動時間のマップを作成\n\trep (i, H ) rep (j, W ){\n\t\tif (t[i][j] == INF ){\n\t\t\tfor (int row = max (i - 3, 0 ); row <= min (i+3, H-1); row++ ){\n\t\t\t\tfor (int col = max (j - 3, 0 ); col <= min (j+3, W-1 ); col++ ){\n\t\t\t\t\tif (row == i && col == j ) continue;\n\t\t\t\t\tint cur = 4 - max (abs (row - i), abs (col - j ) );\n\t\t\t\t\tif (t[row][col] < cur ) t[row][col] = cur;\n\t\t\t\t} // end for\n\t\t\t} // end for\n\t\t} // end if\n\t} // end rep\n#if DEBUG\n\toutput ();\n#endif\n\t// S から 各巻物までの最短距離を求める\n\trep (i, m.size() ){\n\t\tfrom_s[i] = bfs (sx, sy, m[i].first, m[i].second );\n\t\tto_g[i]   = bfs (m[i].first, m[i].second, ex, ey );\n\t} // end rep\n\n\t// 各巻物間の最短距離を求める\n\tif (m.size() != 1 ){\n\t\trep (i, m.size() ){\n\t\t\trep (j, m.size() ){\n\t\t\t\tif (i == j ) continue;\n\t\t\t\tm2m[i][j] = bfs (m[i].first, m[i].second, m[j].first, m[j].second );\n\t\t\t\tm2m[j][i] = m2m[i][j];\n\t\t\t} // end rep\n\t\t} // end rep\n\t} // end if\n\t\n\tres = INF;\n\trep (i, m.size() ){\n\t\tvector<bool> used (m.size(), false );\n\t\tused[i] = true;\n\t\tdfs (i, from_s[i], used );\n\t} // end rep\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nstruct aa {\n\tint x;\n\tint y;\n\tbitset<5>gets;\n\tint cost;\n};\nclass Compare {\npublic:\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.cost>r.cost;\n\t}\n};\n\nint main() {\n\tint H,W;cin>>W>>H;\n\tvector<vector<int>>field(H,vector<int>(W,1));\n\tvector<pair<int,int>>makis;\n\tint sx, sy, gx, gy;\n\t{\n\t\tvector<pair<int, int>>holes;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tchar ch(st[j]);\n\t\t\t\tif (ch == 'S') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t}\n\t\t\t\telse if (ch == 'G') {\n\t\t\t\t\tgx = j;\n\t\t\t\t\tgy = i;\n\t\t\t\t}\n\t\t\t\telse if (ch == '#') {\n\t\t\t\t\tholes.push_back(make_pair(j, i));\n\t\t\t\t}\n\t\t\t\telse if (ch == 'M') {\n\t\t\t\t\tmakis.push_back(make_pair(j,i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (auto hole : holes) {\n\t\t\tfor (int y = 0; y < H; ++y) {\n\t\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\t\tint x_dis = abs(x - hole.first);\n\t\t\t\t\tint y_dis = abs(y - hole.second);\n\t\t\t\t\tint dis = max(x_dis, y_dis);\n\t\t\t\t\tif (dis == 0) {\n\t\t\t\t\t\tfield[y][x] = max(field[y][x],10000);\n\t\t\t\t\t}\n\t\t\t\t\telse if (dis <= 3) {\n\t\t\t\t\t\tfield[y][x] =max(field[y][x],4-dis);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpriority_queue<aa,vector<aa>,Compare>que;\n\n\tque.push(aa{ sx,sy,bitset<5>(),0 });\n\tvector<vector<vector<int>>>memo(W,vector<vector<int>>(H,vector<int>(32,1e9)));\n\tmemo[sx][sy][0]=0;\n\tint dx[4] = { -1,0,1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\tint ans=-1;\n\twhile (!que.empty()) {\n\t\tauto atop(que.top());\n\t\tconst int now_x=atop.x;\n\t\tconst int now_y=atop.y;\n\t\tconst bitset<5>gets(atop.gets);\n\t\tconst int now_cost=atop.cost;\n\n\t\tif (now_x == gx&&now_y == gy&&gets.count() == makis.size()) {\n\t\t\tans=now_cost;\n\t\t\tbreak;\n\t\t}\n\t\tque.pop();\n\t\tfor (int way = 0; way < 4; ++way) {\n\t\t\tconst int next_x=now_x+dx[way];\n\t\t\tconst int next_y=now_y+dy[way];\n\n\t\t\tif (0 <= next_x&&next_x < W&&next_y < H && 0 <= next_y) {\n\t\t\t\tconst int next_cost=now_cost+field[now_y][now_x];\n\t\t\t\tauto next_gets(gets);\n\t\t\t\tfor (int i = 0; i < makis.size(); ++i) {\n\t\t\t\t\tif (next_x == makis[i].first&&next_y == makis[i].second) {\n\t\t\t\t\t\tnext_gets[i]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (memo[next_x][next_y][next_gets.to_ulong()] > next_cost) {\n\t\t\t\t\tmemo[next_x][next_y][next_gets.to_ulong()]=next_cost;\n\t\t\t\t\tque.push(aa{ next_x,next_y,next_gets,next_cost });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<deque>\n#include<climits>\n#include<numeric>\n#include<cassert>\n#include<functional>\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define fi(i,j,k) fill(i[0],i[0]+j*j,k)\n#define INF 1<<27\n#define F first\n#define S second\nstatic const double eps=1e-10;\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w;\nchar cmap[110][110];\nP pos[110];\nint index,matrix[110][110];\nint imap[110][110];\nstatic const int dx[4] = {0,1,0,-1};\nstatic const int dy[4] = {1,0,-1,0};\nstatic const int dx8[8] = {0,1,1,1,0,-1,-1,-1};\nstatic const int dy8[8] = {-1,-1,0,1,1,1,0,-1};\nstatic const int dx16[16] = {0,1,2,2,2,2,2,1,0,-1,-2,-2,-2,-2,-2,-1};\nstatic const int dy16[16] = {-2,-2,-2,-1,0,1,2,2,2,2,2,1,0,-1,-2,-2};\n\nint D[110][110];\nbool used[110][110];\n\nint bfs(P s,P g){\n  rep(i,h)rep(j,w){\n    D[i][j] = INF;\n    used[i][j] = false;\n  }\n  queue<P> que;\n  que.push(s);\n  D[s.S][s.F] = 0;\n  used[s.S][s.F] = true;\n\n  while(!que.empty()){\n    P p = que.front(); que.pop();\n    if(p == g)return D[g.S][g.F];\n\n    for(int i=0;i<4;i++){\n      int nx = p.F+dx[i],ny = p.S+dy[i];\n      if(0<= nx && nx < w && 0<= ny && ny < h && cmap[ny][nx] != '#' && !used[ny][nx]){\n\tD[ny][nx] = D[p.S][p.F] + imap[ny][nx];\n\tused[ny][nx] = true;\n\tque.push(P(nx,ny));\n      }\n    }\n  }\n  return INF;\n}\n\n\nvoid display(){\n  for(int i=0;i<h;i++)\n    {\n      rep(j,w){\n\tcout << cmap[i][j] << \" \";\n      }\n      cout<< endl;\n    }\n  cout << endl;\n  for(int i=0;i<h;i++)\n    {\n      rep(j,w){\n\tcout << imap[i][j] << \" \";\n      }\n      cout<< endl;\n    }\n  cout << endl;\n\n  rep(i,index){\n    rep(j,index){\n      cout << matrix[i][j] << \" \";\n    }\n    cout<< endl;\n  }\n  cout << endl;\n\n}\n\nint main(){\n  int sindex,lim = 1;\n  index = 1;\n  cin >> w >> h;\n  rep(i,h)rep(j,w)imap[i][j] = 1;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      cin >> cmap[i][j];\n      matrix[i][j] = INF;\n      if(cmap[i][j] == 'S'){\n\t//pos[0] = P(j,i);\n\tlim++;\n      }\n      else if(cmap[i][j] == 'M')lim++;\n      else if(cmap[i][j] == 'G'){\n\tpos[0] = P(j,i);\n\t//lim++;\n}\n\n    }\n  }\n \n  rep(i,h){\n    rep(j,w){\n      \n      if(cmap[i][j] == 'S'){\n\t pos[lim-1] = P(j,i);\n      }\n       else if(cmap[i][j] == 'M'){\n\t assert(index != lim-1);\n\tpos[index++] = P(j,i);\n      }\n      else if(cmap[i][j] == '#'){\n\tfor(int k=0;k<8;k++){\n\t  \n\t  int nx = j+dx8[k],ny = i+dy8[k];\n\t  if(0<=nx && nx<w && 0<=ny && ny <h && cmap[ny][nx] != '#'){\n\t    imap[ny][nx] = 3;\n\t  }\n\t}\n\tfor(int k=0;k<16;k++){\n\t  int nx = j+dx16[k],ny = i+dy16[k];\n\t  if(0<=nx && nx<w && 0<=ny && ny <h && cmap[ny][nx] != '#'){\n\t    imap[ny][nx] = max(imap[ny][nx],2);\n\t  }\n\t}\n      }\n    }\n  }\n\n  \n\n  //rep(i,h)rep(j,w)if(cmap[i][j] == 'G')imap[i][j] = 0;\n  \n\n  index = lim;\n\n  for(int i=0;i<index;i++){\n    rep(j,index){\n    \n      if(i == j){\n\tmatrix[i][j] = 0;\n\tcontinue;\n      }\n      matrix[i][j] = bfs(pos[i],pos[j]);\n    }\n  }\n\n  //index--;\n\n  //display();\n  int per[110];\n  rep(i,index-1)per[i] = i+1;\n\n  int sum;\n  int ans=INF;\n  do{\n    sum=0;\n    sum+=matrix[0][per[0]];\n\n    int posi=-1;     \n    for(int i=1;i<index-1;i++){\n      if(i == index-2)posi = per[i];\n      sum+=matrix[per[i-1]][per[i]];\n    }\n    //assert(posi !=-1);\n    //if(posi != index-1){\n    //cout <<\"posi = \" << posi << \",index = \" << index-1 << \",presum = \" << sum << \", matrix[posi][lim-1] = \" << matrix[posi][lim-1] << endl;\n    if(posi != -1 && posi != lim-1)sum += matrix[posi][lim-1];\n    //}\n    ans=min(ans,sum);\n  }while(next_permutation(per,per+(index-1)));\n \n\n  cout << ans << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<20)\n\nstruct ST {\n    int x, y, k;\n    ST() {}\n    ST(int x, int y, int k) : x(x), y(y), k(k) {}\n};\nbool operator<(const ST& l, const ST& r) {\n    if (l.x != r.x) return l.x < r.x;\n    if (l.y != r.y) return l.y < r.y;\n    return l.k < r.k;\n}\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint n, m, K, a[128][128], of[128][128];\nint vis[128][128][1<<5];\nchar f[128][128];\n\nint solve() {\n    int gx = -1, gy = -1;\n    rep (i, n) rep (j, m) if (f[i][j] == 'G') gx = i+1, gy = j+1;\n    priority_queue<pair<int, ST> > q;\n    rep (i, n) rep (j, m) if (f[i][j] == 'S') q.push(mp(0, ST(i+1, j+1, 0)));\n    while (!q.empty()) {\n        const pair<int, ST> vv = q.top();\n        const ST cur = vv.second;\n        q.pop();\n        if (vis[cur.x][cur.y][cur.k]) continue;\n        vis[cur.x][cur.y][cur.k] = 1;\n        if (gx == cur.x && gy == cur.y && (1<<K)-1 == cur.k) return -vv.first;\n        rep (d, 4) {\n            const int x = cur.x+dx[d], y = cur.y+dy[d];\n            if (a[x][y] == INF) continue;\n            q.push(mp(vv.first-a[cur.x][cur.y], ST(x, y, cur.k|of[x][y])));\n        }\n    }\n    return 0;\n}\n\nint main() {\n    scanf(\"%d%d\", &m, &n);\n    rep (i, n) rep (j, m) scanf(\" %c\", f[i]+j);\n    rep (i, 128) rep (j, 128) a[i][j] = INF;\n    rep (i, n) rep (j, m) if (f[i][j] != '#') a[i+1][j+1] = 1;\n    rep (i, n) rep (j, m) if (f[i][j] == '#') {\n        for (int x = i-2; x <= i+2; x++) {\n            for (int y = j-2; y <= j+2; y++) {\n                a[x+1][y+1] = max(a[x+1][y+1], 4-max(abs(x-i), abs(y-j)));\n            }\n        }\n    }\n    rep (i, n) rep (j, m) if (f[i][j] == 'M') {\n        of[i+1][j+1] = 1<<K;\n        K++;\n    }\n    printf(\"%d\\n\", solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\n#define C first.first\n#define F first.second\n#define X second.first\n#define Y second.second\n#define INF (1<<29)\nint W,H;\nchar fie[101][101];\nint mvc[101][101];\nint dmx[]={1,0,-1,0,1,-1,1,-1};\nint dmy[]={0,1,0,-1,1,-1,-1,1};\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint h[101][101][1<<5];\nint gx,gy;\nint MC;\nbool check(int x,int y){\n  if(x < 0 || y < 0 || x>=W || y>=H ) return true;\n  return false;\n}\nvoid printmv(){\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++)\n      printf(\"%2d \",mvc[j][i]);\n    puts(\"\");\n  }   \n}\nvoid printh(){\n  for(int k=0;k<(1<<MC);k++)\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++)\n\tprintf(\"h[%d][%d][%d]=%d\\n\",j,i,k,h[j][i][k]);\n}\nint solve(int x,int y){\n  // printmv();\n  queue<PP> q;\n  for(int i=0;i<H;i++)\n    for(int j=0;j<W;j++)\n      for(int k=0;k<(1<<MC);k++)\n\th[j][i][k]=INF;\n  q.push(PP(P(0,0),P(x,y)));\n  h[x][y][0]=0;\n  while(!q.empty()){\n    PP p = q.front(); q.pop();\n    x = p.X; y = p.Y;\n    for(int i=0;i<4;i++){\n      int nx = x + dx[i], ny = y + dy[i];\n      if( check(nx,ny) ) continue;\n      if( fie[nx][ny] == '#') continue;\n      if( '0' <= fie[nx][ny] && fie[nx][ny] <= '5' ){\n\tint mc = fie[nx][ny]-'0';\n\tint st = (p.F | (1<<mc));\n\tif( h[nx][ny][st] > p.C + mvc[x][y] ){\n\t  h[nx][ny][st] = p.C + mvc[x][y];\n\t  q.push(PP(P(p.C+mvc[x][y],st),P(nx,ny)));\n\t}\n      } else {\n\tif( h[nx][ny][p.F] > p.C + mvc[x][y] ){\n\t  h[nx][ny][p.F] = p.C + mvc[x][y];\n\t  q.push(PP(P(p.C+mvc[x][y],p.F),P(nx,ny)));\n\t}\n      }\n    }\n  }\n  //  printh();\n  // cout << gx << \" \" << gy << \" \" << (1<<MC)-1 << \" \" << h[gx][gy][(1<<MC)-1]<<\"\\n\";\n  return h[gx][gy][(1<<MC)-1];\n}\nvoid mark(int x,int y,int c){\n  for(int i=0;i<8;i++){\n    int nx = x+dmx[i], ny = y + dmy[i];\n    if(check(nx,ny)) continue;\n    mvc[nx][ny]=max(mvc[nx][ny],c);\n  }\n  if(c==3){\n    for(int i=0;i<8;i++){\n      int nx = x+dmx[i], ny = y + dmy[i];\n      if(check(nx,ny)) continue;\n      mark(nx,ny,c-1);\n    }\n  }\n}\nint main(){\n  int sx,sy;\n  cin >> W >> H;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin >> fie[j][i];\n      mvc[j][i]=1;\n    }\n  }\n  MC=0;\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      if(fie[j][i]=='#'){\n\tmark(j,i,3);\n      } else if(fie[j][i]=='S'){\n\tsx = j;\n\tsy = i;\n      } else if(fie[j][i]=='M'){\n\tfie[j][i]='0'+MC;\n\tMC++;\n      } else if(fie[j][i]=='G'){\n\tgx = j;\n\tgy = i;\n      }\n    }\n  }\n  cout << solve(sx,sy) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint W, H, cost[102][102], N, hx[5], hy[5], sx, sy, gx, gy;\nstring grid[102];\n\nconst int dx[4] = {0,1,0,-1}, Dx[8] = {0,1,1,1,0,-1,-1,-1};\nconst int dy[4] = {1,0,-1,0}, Dy[8] = {1,1,0,-1,-1,-1,0,1};\nbool in_range(int x, int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\nvoid pre() {\n\tmemset(cost, -1, sizeof(cost));\n\t\n\tN = 0;\n\tfor (int y=0; y<H; ++y) for (int x=0; x<W; ++x) {\n\t\tif (grid[y][x] == '#') cost[y][x] = 100;\n\t\tif (grid[y][x] == 'M') {\n\t\t\thx[N] = x;\n\t\t\thy[N] = y;\n\t\t\t++N;\n\t\t}\n\t\tif (grid[y][x] == 'S') sx = x, sy = y;\n\t\tif (grid[y][x] == 'G') gx = x, gy = y;\n\t}\n\t\n\tfor (int y=0; y<H; ++y) for (int x=0; x<W; ++x) {\n\t\tif (cost[y][x] < 0) {\n\t\t\tbool hole_flag = false;\n\t\t\tfor (int d=0; d<8; ++d) {\n\t\t\t\tint nx = x + Dx[d], ny = y + Dy[d];\n\t\t\t\tif (!in_range(nx, ny)) continue;\n\t\t\t\thole_flag |= (grid[ny][nx] == '#');\n\t\t\t}\n\t\t\tif (hole_flag) cost[y][x] = 3;\n\t\t}\n\t}\n\t\n\tfor (int y=0; y<H; ++y) for (int x=0; x<W; ++x) {\n\t\tif (cost[y][x] < 0) {\n\t\t\tint max_c = -1;\n\t\t\tfor (int d=0; d<8; ++d) {\n\t\t\t\tint nx = x + Dx[d], ny = y + Dy[d];\n\t\t\t\tif (!in_range(nx, ny)) continue;\n\t\t\t\tmax_c = max(max_c, cost[ny][nx]);\n\t\t\t}\n\t\t\tcost[y][x] = max_c - 1;\n\t\t}\n\t}\n\t\n\tfor (int y=0; y<H; ++y) for (int x=0; x<W; ++x) if (cost[y][x] <= 0) cost[y][x] = 1;\n}\n\n\t\nstruct State {\n\tint x, y, c;\n\tbool operator > (const State& s) const { return c > s.c; }\n};\n\nint dst[102][102];\n\nint dijkstra(int ax, int ay, int bx, int by) {\n\tmemset(dst, -1, sizeof(dst));\n\t\n\tpriority_queue< State, vector< State >, greater< State > > que;\n\tque.push(State{ax, ay, 0});\n\tdst[ay][ax] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.top(); que.pop();\n\t\tif (dst[s.y][s.x] < s.c) continue;\n\t\tfor (int d=0; d<4; ++d) {\n\t\t\tint nx = s.x + dx[d], ny = s.y + dy[d], nc = s.c + cost[s.y][s.x];\n\t\t\tif (!in_range(nx, ny)) continue;\n\t\t\tif (grid[ny][nx] == '#') continue;\n\t\t\tif (dst[ny][nx] == -1 || dst[ny][nx] > nc) {\n\t\t\t\tdst[ny][nx] = nc;\n\t\t\t\tque.push(State{nx, ny, nc});\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn dst[by][bx];\n}\n\nint main() {\n\tcin >> W >> H;\n\tfor (int y=0; y<H; ++y) cin >> grid[y];\n\t\n\tpre();\n\t\n\tvector< int > order;\n\tfor (int i=0; i<N; ++i) order.push_back(i);\n\t\n\tint ans = 1L << 30;\n\tdo {\n\t\tint sum = dijkstra(sx, sy, hx[order[0]], hy[order[0]]);\n\t\tfor (int i=0; i<N-1; ++i) {\n\t\t\tint a = order[i], b = order[i+1];\n\t\t\tsum += dijkstra(hx[a], hy[a], hx[b], hy[b]);\n\t\t}\n\t\tsum += dijkstra(hx[order[N-1]], hy[order[N-1]], gx, gy);\n\t\tans = min(ans, sum);\n\t} while (next_permutation(order.begin(), order.end()));\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2419 Acrophobia\n// 2018.4.8 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 15000\ntypedef struct { char r, c, roll; short t; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int roll, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].roll = roll, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define ABS(a)   ((a)>=0?(a):-(a))\n#define INF  0x3030\nint   W, H;\nchar  map[103][103];\nchar  roll[103][103]; int sz;\nchar  cost[103][103];\nshort dist[103][103][1<<5];\nint   mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint dijkstra(int sr, int sc, int gr, int gc, int all)\n{\n\tint i, r, c, nr, nc, ro, t, nt, x;\n\n\tmemset(dist, INF, sizeof(dist));\n\tqsize = 0;\n\tenq(sr, sc, 0, 0);\n\twhile (qsize) {\n\t\tr = que[0].r, c = que[0].c, ro = que[0].roll, t = que[0].t, deq();\n\t\tif (r == gr && c == gc && ro == all) break;\n\t\tif (dist[r][c][ro] <= t) continue;\n\t\tdist[r][c][ro] = t;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\tif (nr < 0 || nr >= H || nc < 0 || nc >= W || map[nr][nc] == '#') continue;\n\t\t\tnt = t + cost[r][c];\n\t\t\tif (dist[nr][nc][x=(ro|roll[nr][nc])] <= nt) continue;\n\t\t\tenq(nr, nc, x, nt);\n\t\t}\n\t}\n\treturn t;\n}\n\nint main()\n{\n\tint r, c, d, nr, nc;\n\tint sr, sc, gr, gc;\n\tchar buf[20];\n\n\tfgets(buf, 20, stdin), sscanf(buf, \"%d%d\", &W, &H);\n\tsz = 0; for (r = 0; r < H; r++) {\n\t\tfgets(map[r], 103, stdin);\n\t\tfor (c = 0; c < W; c++) {\n\t\t\tif      (map[r][c] == 'S') sr = r, sc = c;\n\t\t\telse if (map[r][c] == 'G') gr = r, gc = c;\n\t\t\telse if (map[r][c] == 'M') roll[r][c] |= 1<<sz++;\n\t\t}\n\t}\n\tmemset(cost, 1, sizeof(cost));\n\tfor (r = 0; r < H; r++) for (c = 0; c < W; c++) if (map[r][c] == '#') {\n\t\tfor (nr = r-3; nr <= r+3; nr++) for (nc = c-3; nc <= c+3; nc++) {\n\t\t\tif (nr < 0 || nr >= H || nc < 0 || nc >= W) continue;\n\t\t\td = ABS(nr-r); if (d < ABS(nc-c)) d = ABS(nc-c);\n\t\t\td = 4-d;\n\t\t\tif (d > cost[nr][nc]) cost[nr][nc] = d;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dijkstra(sr, sc, gr, gc, (1<<sz)-1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DIJKSTRA_MAX_NODE 10000\n#define DIJKSTRA_MAX_EDGE 40000\n\ntypedef struct {\n\tint from,to;\n\tint cost;\n} dijkstra_edge_t;\n\ntypedef struct {\n\tint node;\n\tint cost;\n} dijkstra_node_t;\n\nint dijkstra_edge_num;\ndijkstra_edge_t dijkstra_edge[DIJKSTRA_MAX_EDGE];\nint dijkstra_node_edge[DIJKSTRA_MAX_NODE][2];\nint dijkstra_queue_num;\ndijkstra_node_t dijkstra_queue[DIJKSTRA_MAX_EDGE+1];\nint dijkstra_cost[DIJKSTRA_MAX_NODE];\nchar dijkstra_visited[DIJKSTRA_MAX_NODE];\n\nint dijkstra_comp(const void* x,const void* y) {\n\tconst dijkstra_edge_t* a=(const dijkstra_edge_t*)x;\n\tconst dijkstra_edge_t* b=(const dijkstra_edge_t*)y;\n\tif((a->from)>(b->from))return 1;\n\tif((a->from)<(b->from))return -1;\n\tif((a->to)>(b->to))return 1;\n\tif((a->to)<(b->to))return -1;\n\treturn 0;\n}\n\nvoid dijkstra_queue_adjust(int pos) {\n\tint min=pos;\n\tif(pos*2+1<dijkstra_queue_num &&\n\t\tdijkstra_queue[min].cost>dijkstra_queue[pos*2+1].cost)\n\t\t\tmin=pos*2+1;\n\tif(pos*2+2<dijkstra_queue_num &&\n\t\tdijkstra_queue[min].cost>dijkstra_queue[pos*2+2].cost)\n\t\t\tmin=pos*2+2;\n\tif(min!=pos) {\n\t\tdijkstra_node_t temp;\n\t\ttemp=dijkstra_queue[min];\n\t\tdijkstra_queue[min]=dijkstra_queue[pos];\n\t\tdijkstra_queue[pos]=temp;\n\t\tdijkstra_queue_adjust(min);\n\t} else if(pos>0)dijkstra_queue_adjust((pos-1)/2);\n}\n\nvoid dijkstra_queue_push(int node,int cost) {\n\tdijkstra_node_t topush;\n\ttopush.node=node;topush.cost=cost;\n\tdijkstra_queue[dijkstra_queue_num++]=topush;\n\tdijkstra_queue_adjust(dijkstra_queue_num-1);\n}\n\ndijkstra_node_t dijkstra_queue_pop(void) {\n\tdijkstra_node_t result=dijkstra_queue[0];\n\tif(dijkstra_queue_num>0) {\n\t\tdijkstra_queue[0]=dijkstra_queue[--dijkstra_queue_num];\n\t\tdijkstra_queue_adjust(0);\n\t}\n\treturn result;\n}\n\nvoid dijkstra_init(void) {\n\tdijkstra_edge_num=0;\n}\n\nvoid dijkstra_addedge(int from,int to,int cost) {\n\tdijkstra_edge[dijkstra_edge_num].from=from;\n\tdijkstra_edge[dijkstra_edge_num].to=to;\n\tdijkstra_edge[dijkstra_edge_num].cost=cost;\n\tdijkstra_edge_num++;\n}\n\nvoid dijkstra_setup(void) {\n\tint i;\n\tint prev;\n\tqsort(dijkstra_edge,dijkstra_edge_num,\n\t\tsizeof(dijkstra_edge_t),dijkstra_comp);\n\tprev=0;\n\tmemset(dijkstra_node_edge,0,sizeof(dijkstra_node_edge));\n\tdijkstra_node_edge[0][0]=0;\n\tfor(i=0;i<dijkstra_edge_num;i++) {\n\t\tif(dijkstra_edge[i].from!=dijkstra_edge[prev].from) {\n\t\t\tdijkstra_node_edge[dijkstra_edge[prev].from][1]=i;\n\t\t\tdijkstra_node_edge[dijkstra_edge[i].from][0]=i;\n\t\t\tprev=i;\n\t\t}\n\t}\n\tdijkstra_node_edge[dijkstra_edge[prev].from][1]=i;\n}\n\nint dijkstra_search(int from,int to) {\n\tint i;\n\tmemset(dijkstra_cost,0xFF,sizeof(dijkstra_cost));\n\tmemset(dijkstra_visited,0,sizeof(dijkstra_visited));\n\tdijkstra_queue_num=0;\n\tdijkstra_queue_push(from,0);\n\twhile(dijkstra_queue_num>0) {\n\t\tdijkstra_node_t nownode=dijkstra_queue_pop();\n\t\tif(!dijkstra_visited[nownode.node]) {\n\t\t\tdijkstra_visited[nownode.node]=1;\n\t\t\tdijkstra_cost[nownode.node]=nownode.cost;\n\t\t\tfor(i=dijkstra_node_edge[nownode.node][0];\n\t\t\t\t\ti<dijkstra_node_edge[nownode.node][1];i++) {\n\t\t\t\tif(!dijkstra_visited[dijkstra_edge[i].to] &&\n\t\t\t\t\t\t(dijkstra_cost[dijkstra_edge[i].to]<0 ||\n\t\t\t\t\t\tdijkstra_cost[dijkstra_edge[i].to]>nownode.cost+dijkstra_edge[i].cost)) {\n\t\t\t\t\tdijkstra_queue_push(\n\t\t\t\t\t\tdijkstra_edge[i].to,\n\t\t\t\t\t\tnownode.cost+dijkstra_edge[i].cost\n\t\t\t\t\t);\n\t\t\t\t\tdijkstra_cost[dijkstra_edge[i].to]=nownode.cost+dijkstra_edge[i].cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dijkstra_cost[to];\n}\n\nint zyunretu_num;\nint zyunretu[120][5];\n\nvoid make_zyunretu(int now,int max) {\n\tstatic int keiro[5];\n\tstatic int used[5];\n\tint i;\n\tif(now==0) {\n\t\tzyunretu_num=0;\n\t\tfor(i=0;i<5;i++)keiro[i]=used[i]=0;\n\t}\n\tif(now<max) {\n\t\tfor(i=0;i<max;i++) {\n\t\t\tif(!used[i]) {\n\t\t\t\tused[i]=1;\n\t\t\t\tkeiro[now]=i;\n\t\t\t\tmake_zyunretu(now+1,max);\n\t\t\t\tused[i]=0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor(i=0;i<max;i++) {\n\t\t\tzyunretu[zyunretu_num][i]=keiro[i];\n\t\t}\n\t\tzyunretu_num++;\n\t}\n}\n\nint width,height;\nchar map[200][200];\nchar speed[200][200];\nint sx,sy,dx,dy;\nint m_num;\nint mx[5],my[5];\n\nint getnodenum(int x,int y) {\n\treturn y*width+x;\n}\n\nint main(void) {\n\tint i,j;\n\tint result;\n\tscanf(\"%d%d\",&width,&height);\n\tfor(i=0;i<height;i++)scanf(\"%s\",map[i]);\n\tm_num=0;\n\tfor(i=0;i<height;i++) {\n\t\tfor(j=0;j<width;j++)speed[i][j]=1;\n\t}\n\tfor(i=0;i<height;i++) {\n\t\tfor(j=0;j<width;j++) {\n\t\t\tif(map[i][j]=='S') {\n\t\t\t\tsy=i;sx=j;\n\t\t\t} else if(map[i][j]=='G') {\n\t\t\t\tdy=i;dx=j;\n\t\t\t} else if(map[i][j]=='M') {\n\t\t\t\tmy[m_num]=i;mx[m_num]=j;\n\t\t\t\tm_num++;\n\t\t\t} else if(map[i][j]=='#') {\n\t\t\t\tint k,l;\n\t\t\t\tfor(k=-2;k<=2;k++) {\n\t\t\t\t\tfor(l=-2;l<=2;l++) {\n\t\t\t\t\t\tint kk,ll,s;\n\t\t\t\t\t\tkk=(k<0?-k:k);ll=(l<0?-l:l);\n\t\t\t\t\t\tif(kk<ll)kk=ll;\n\t\t\t\t\t\ts=4-kk;\n\t\t\t\t\t\tif(i+k>=0 && i+k<height && j+l>=0 && j+l<width &&\n\t\t\t\t\t\t\tspeed[i+k][j+l]<s)speed[i+k][j+l]=s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra_init();\n\tfor(i=0;i<height;i++) {\n\t\tfor(j=0;j<width;j++) {\n\t\t\tif(map[i][j]=='#')continue;\n\t\t\tif(i>0 && map[i-1][j]!='#') {\n\t\t\t\tdijkstra_addedge(\n\t\t\t\t\tgetnodenum(j,i),getnodenum(j,i-1),speed[i][j]\n\t\t\t\t);\n\t\t\t}\n\t\t\tif(j>0 && map[i][j-1]!='#') {\n\t\t\t\tdijkstra_addedge(\n\t\t\t\t\tgetnodenum(j,i),getnodenum(j-1,i),speed[i][j]\n\t\t\t\t);\n\t\t\t}\n\t\t\tif(i+1<height && map[i+1][j]!='#') {\n\t\t\t\tdijkstra_addedge(\n\t\t\t\t\tgetnodenum(j,i),getnodenum(j,i+1),speed[i][j]\n\t\t\t\t);\n\t\t\t}\n\t\t\tif(j+1<width && map[i][j+1]!='#') {\n\t\t\t\tdijkstra_addedge(\n\t\t\t\t\tgetnodenum(j,i),getnodenum(j+1,i),speed[i][j]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra_setup();\n\tmake_zyunretu(0,m_num);\n\tresult=0x7fffffff;\n\tfor(i=0;i<zyunretu_num;i++) {\n\t\tint nowresult=0;\n\t\tnowresult+=dijkstra_search(\n\t\t\tgetnodenum(sx,sy),getnodenum(\n\t\t\t\tmx[zyunretu[i][0]],my[zyunretu[i][0]]));\n\t\tfor(j=1;j<m_num;j++) {\n\t\t\tnowresult+=dijkstra_search(\n\t\t\t\tgetnodenum(mx[zyunretu[i][j-1]],my[zyunretu[i][j-1]]),\n\t\t\t\tgetnodenum(mx[zyunretu[i][j]],my[zyunretu[i][j]]));\n\t\t}\n\t\tnowresult+=dijkstra_search(\n\t\t\tgetnodenum(mx[zyunretu[i][m_num-1]],my[zyunretu[i][m_num-1]]),\n\t\t\tgetnodenum(dx,dy));\n\t\tif(nowresult<result)result=nowresult;\n\t}\n\tprintf(\"%d\\n\",result);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DIJKSTRA_MAX_NODE 10000\n#define DIJKSTRA_MAX_EDGE 40000\n\ntypedef struct {\n\tint from,to;\n\tint cost;\n} dijkstra_edge_t;\n\ntypedef struct {\n\tint node;\n\tint cost;\n} dijkstra_node_t;\n\nint dijkstra_edge_num;\ndijkstra_edge_t dijkstra_edge[DIJKSTRA_MAX_EDGE];\nint dijkstra_node_edge[DIJKSTRA_MAX_NODE][2];\nint dijkstra_queue_num;\ndijkstra_node_t dijkstra_queue[DIJKSTRA_MAX_EDGE+1];\nint dijkstra_cost[DIJKSTRA_MAX_NODE];\nchar dijkstra_visited[DIJKSTRA_MAX_NODE];\n\nint dijkstra_comp(const void* x,const void* y) {\n\tconst dijkstra_edge_t* a=(const dijkstra_edge_t*)x;\n\tconst dijkstra_edge_t* b=(const dijkstra_edge_t*)y;\n\tif((a->from)>(b->from))return 1;\n\tif((a->from)<(b->from))return -1;\n\tif((a->to)>(b->to))return 1;\n\tif((a->to)<(b->to))return -1;\n\treturn 0;\n}\n\nvoid dijkstra_queue_adjust(int pos) {\n\tint min=pos;\n\tif(pos*2+1<dijkstra_queue_num &&\n\t\tdijkstra_queue[min].cost>dijkstra_queue[pos*2+1].cost)\n\t\t\tmin=pos*2+1;\n\tif(pos*2+2<dijkstra_queue_num &&\n\t\tdijkstra_queue[min].cost>dijkstra_queue[pos*2+2].cost)\n\t\t\tmin=pos*2+2;\n\tif(min!=pos) {\n\t\tdijkstra_node_t temp;\n\t\ttemp=dijkstra_queue[min];\n\t\tdijkstra_queue[min]=dijkstra_queue[pos];\n\t\tdijkstra_queue[pos]=temp;\n\t\tdijkstra_queue_adjust(min);\n\t} else if(pos>0)dijkstra_queue_adjust((pos-1)/2);\n}\n\nvoid dijkstra_queue_push(int node,int cost) {\n\tdijkstra_node_t topush;\n\ttopush.node=node;topush.cost=cost;\n\tdijkstra_queue[dijkstra_queue_num++]=topush;\n\tdijkstra_queue_adjust(dijkstra_queue_num-1);\n}\n\ndijkstra_node_t dijkstra_queue_pop(void) {\n\tdijkstra_node_t result=dijkstra_queue[0];\n\tif(dijkstra_queue_num>0) {\n\t\tdijkstra_queue[0]=dijkstra_queue[--dijkstra_queue_num];\n\t\tdijkstra_queue_adjust(0);\n\t}\n\treturn result;\n}\n\nvoid dijkstra_init(void) {\n\tdijkstra_edge_num=0;\n}\n\nvoid dijkstra_addedge(int from,int to,int cost) {\n\tdijkstra_edge[dijkstra_edge_num].from=from;\n\tdijkstra_edge[dijkstra_edge_num].to=to;\n\tdijkstra_edge[dijkstra_edge_num].cost=cost;\n\tdijkstra_edge_num++;\n}\n\nvoid dijkstra_setup(void) {\n\tint i;\n\tint prev;\n\tqsort(dijkstra_edge,dijkstra_edge_num,\n\t\tsizeof(dijkstra_edge_t),dijkstra_comp);\n\tprev=0;\n\tmemset(dijkstra_node_edge,0,sizeof(dijkstra_node_edge));\n\tdijkstra_node_edge[0][0]=0;\n\tfor(i=0;i<dijkstra_edge_num;i++) {\n\t\tif(dijkstra_edge[i].from!=dijkstra_edge[prev].from) {\n\t\t\tdijkstra_node_edge[dijkstra_edge[prev].from][1]=i;\n\t\t\tdijkstra_node_edge[dijkstra_edge[i].from][0]=i;\n\t\t\tprev=i;\n\t\t}\n\t}\n\tdijkstra_node_edge[dijkstra_edge[prev].from][1]=i;\n}\n\nint dijkstra_search(int from,int to) {\n\tint i;\n\tmemset(dijkstra_cost,0xFF,sizeof(dijkstra_cost));\n\tmemset(dijkstra_visited,0,sizeof(dijkstra_visited));\n\tdijkstra_queue_num=0;\n\tdijkstra_queue_push(from,0);\n\twhile(dijkstra_queue_num>0) {\n\t\tdijkstra_node_t nownode=dijkstra_queue_pop();\n\t\tif(!dijkstra_visited[nownode.node]) {\n\t\t\tdijkstra_visited[nownode.node]=1;\n\t\t\tdijkstra_cost[nownode.node]=nownode.cost;\n\t\t\tfor(i=dijkstra_node_edge[nownode.node][0];\n\t\t\t\t\ti<dijkstra_node_edge[nownode.node][1];i++) {\n\t\t\t\tif(!dijkstra_visited[dijkstra_edge[i].to]) {\n\t\t\t\t\tdijkstra_queue_push(\n\t\t\t\t\t\tdijkstra_edge[i].to,\n\t\t\t\t\t\tnownode.cost+dijkstra_edge[i].cost\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dijkstra_cost[to];\n}\n\nint zyunretu_num;\nint zyunretu[120][5];\n\nvoid make_zyunretu(int now,int max) {\n\tstatic int keiro[5];\n\tstatic int used[5];\n\tint i;\n\tif(now==0) {\n\t\tzyunretu_num=0;\n\t\tfor(i=0;i<5;i++)keiro[i]=used[i]=0;\n\t}\n\tif(now<max) {\n\t\tfor(i=0;i<max;i++) {\n\t\t\tif(!used[i]) {\n\t\t\t\tused[i]=1;\n\t\t\t\tkeiro[now]=i;\n\t\t\t\tmake_zyunretu(now+1,max);\n\t\t\t\tused[i]=0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor(i=0;i<max;i++) {\n\t\t\tzyunretu[zyunretu_num][i]=keiro[i];\n\t\t}\n\t\tzyunretu_num++;\n\t}\n}\n\nint width,height;\nchar map[200][200];\nchar speed[200][200];\nint sx,sy,dx,dy;\nint m_num;\nint mx[5],my[5];\n\nint getnodenum(int x,int y) {\n\treturn y*width+x;\n}\n\nint main(void) {\n\tint i,j;\n\tint result;\n\tscanf(\"%d%d\",&width,&height);\n\tfor(i=0;i<height;i++)scanf(\"%s\",map[i]);\n\tm_num=0;\n\tfor(i=0;i<height;i++) {\n\t\tfor(j=0;j<width;j++)speed[i][j]=1;\n\t}\n\tfor(i=0;i<height;i++) {\n\t\tfor(j=0;j<width;j++) {\n\t\t\tif(map[i][j]=='S') {\n\t\t\t\tsy=i;sx=j;\n\t\t\t} else if(map[i][j]=='G') {\n\t\t\t\tdy=i;dx=j;\n\t\t\t} else if(map[i][j]=='M') {\n\t\t\t\tmy[m_num]=i;mx[m_num]=j;\n\t\t\t\tm_num++;\n\t\t\t} else if(map[i][j]=='#') {\n\t\t\t\tint k,l;\n\t\t\t\tfor(k=-2;k<=2;k++) {\n\t\t\t\t\tfor(l=-2;l<=2;l++) {\n\t\t\t\t\t\tint kk,ll,s;\n\t\t\t\t\t\tkk=(k<0?-k:k);ll=(l<0?-l:l);\n\t\t\t\t\t\tif(kk<ll)kk=ll;\n\t\t\t\t\t\ts=4-kk;\n\t\t\t\t\t\tif(i+k>=0 && i+k<height && j+l>=0 && j+l<width &&\n\t\t\t\t\t\t\tspeed[i+k][j+l]<s)speed[i+k][j+l]=s;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra_init();\n\tfor(i=0;i<height;i++) {\n\t\tfor(j=0;j<width;j++) {\n\t\t\tif(map[i][j]=='#')continue;\n\t\t\tif(i>0 && map[i-1][j]!='#') {\n\t\t\t\tdijkstra_addedge(\n\t\t\t\t\tgetnodenum(j,i),getnodenum(j,i-1),speed[i][j]\n\t\t\t\t);\n\t\t\t}\n\t\t\tif(j>0 && map[i][j-1]!='#') {\n\t\t\t\tdijkstra_addedge(\n\t\t\t\t\tgetnodenum(j,i),getnodenum(j-1,i),speed[i][j]\n\t\t\t\t);\n\t\t\t}\n\t\t\tif(i+1<height && map[i+1][j]!='#') {\n\t\t\t\tdijkstra_addedge(\n\t\t\t\t\tgetnodenum(j,i),getnodenum(j,i+1),speed[i][j]\n\t\t\t\t);\n\t\t\t}\n\t\t\tif(j+1<width && map[i][j+1]!='#') {\n\t\t\t\tdijkstra_addedge(\n\t\t\t\t\tgetnodenum(j,i),getnodenum(j+1,i),speed[i][j]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\tdijkstra_setup();\n\tmake_zyunretu(0,m_num);\n\tresult=0x7fffffff;\n\tfor(i=0;i<zyunretu_num;i++) {\n\t\tint nowresult=0;\n\t\tnowresult+=dijkstra_search(\n\t\t\tgetnodenum(sx,sy),getnodenum(\n\t\t\t\tmx[zyunretu[i][0]],my[zyunretu[i][0]]));\n\t\tfor(j=1;j<m_num;j++) {\n\t\t\tnowresult+=dijkstra_search(\n\t\t\t\tgetnodenum(mx[zyunretu[i][j-1]],my[zyunretu[i][j-1]]),\n\t\t\t\tgetnodenum(mx[zyunretu[i][j]],my[zyunretu[i][j]]));\n\t\t}\n\t\tnowresult+=dijkstra_search(\n\t\t\tgetnodenum(mx[zyunretu[i][m_num-1]],my[zyunretu[i][m_num-1]]),\n\t\t\tgetnodenum(dx,dy));\n\t\tif(nowresult<result)result=nowresult;\n\t}\n\tprintf(\"%d\\n\",result);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2419 Acrophobia\n// 2018.4.8 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 10000\ntypedef struct { char r, c, ro; short t; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int r, int c, int ro, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].r = r, que[i].c = c, que[i].ro = ro, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define ABS(a)   ((a)>=0?(a):-(a))\n#define INF  0x3030\nint   W, H;\nchar  map[103][105];\nchar  roll[103][103]; int sz;\nchar  cost[103][103];\nshort dist[103][103][1<<5];\nint   mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\nint dijkstra(int sr, int sc, int gr, int gc, int all)\n{\n\tint i, r, c, nr, nc, ro, t, nt, x;\n\n\tmemset(dist, INF, sizeof(dist));\n\tqsize = 0;\n\tenq(sr, sc, 0, 0);\n\twhile (qsize) {\n\t\tr = que[0].r, c = que[0].c, ro = que[0].ro, t = que[0].t, deq();\n\t\tif (r == gr && c == gc && ro == all) break;\n\t\tif (dist[r][c][ro] <= t) continue;\n\t\tdist[r][c][ro] = t;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tnr = r + mv[i][0], nc = c + mv[i][1];\n\t\t\tif (map[nr][nc] == '#') continue;\n\t\t\tnt = t + cost[r][c];\n\t\t\tif (dist[nr][nc][x=(ro|roll[nr][nc])] <= nt) continue;\n\t\t\tenq(nr, nc, x, nt);\n\t\t}\n\t}\n\treturn t;\n}\n\nint main()\n{\n\tint r, c, d, nr, nc;\n\tint sr, sc, gr, gc;\n\tchar buf[20];\n\n\tfgets(buf, 20, stdin), sscanf(buf, \"%d%d\", &W, &H);\n\tmemset(map, '#', sizeof(map));\n\tsz = 0; for (r = 1; r <= H; r++) {\n\t\tfgets(map[r]+1, 103, stdin);\n\t\tfor (c = 1; c <= W; c++) {\n\t\t\tif      (map[r][c] == 'S') sr = r, sc = c;\n\t\t\telse if (map[r][c] == 'G') gr = r, gc = c;\n\t\t\telse if (map[r][c] == 'M') roll[r][c] |= 1<<sz++;\n\t\t}\n\t\tmap[r][c] = '#';\n\t}\n\tmemset(cost, 1, sizeof(cost));\n\tfor (r = 1; r <= H; r++) for (c = 1; c <= W; c++) if (map[r][c] == '#') {\n\t\tfor (nr = r-3; nr <= r+3; nr++) for (nc = c-3; nc <= c+3; nc++) {\n\t\t\tif (nr < 1 || nr > H || nc < 1 || nc > W) continue;\n\t\t\td = ABS(nr-r); if (d < ABS(nc-c)) d = ABS(nc-c);\n\t\t\td = 4-d;\n\t\t\tif (d > cost[nr][nc]) cost[nr][nc] = d;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", dijkstra(sr, sc, gr, gc, (1<<sz)-1));\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tint w, h;\n\tint[][] map;\n\tP S, G;\n\tP[] M;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\tmap = new int[h+2][w+2];\n\t\tLinkedList<P> m = new LinkedList<P>();\n\t\tfor(int i=1;i<=h;i++) {\n\t\t\tString l = sc.next();\n\t\t\tfor(int j=0;j<w;j++) {\n\t\t\t\tmap[i][j+1] = max(map[i][j+1], 1);\n\t\t\t\tif(l.charAt(j) == 'G') G = new P(j+1, i);\n\t\t\t\tif(l.charAt(j) == 'S') S = new P(j+1, i);\n\t\t\t\tif(l.charAt(j) == 'M') m.add(new P(j+1, i));\n\t\t\t\tif(l.charAt(j) == '#') {\n\t\t\t\t\tfor(int x=-2;x<=2;x++) for(int y=-2;y<=2;y++) if((x|y)!=0) {\n\t\t\t\t\t\tif( j+x+1<1 || j+x+1>w || i+y<1 || i+y>h ) continue;\n\t\t\t\t\t\tmap[i+y][j+x+1] = max(map[i+y][j+x+1], 4-max(abs(y), abs(x)));\n\t\t\t\t\t}\n\t\t\t\t\tmap[i][j+1] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tm.addFirst(S); m.addLast(G);\n\t\tM = m.toArray(new P[]{});\n\t\tsolve();\n\t}\n\t\n\tint m;\n\tvoid solve() {\n\t\tm = M.length;\n\t\td = new int[m][m];\n//\t\tdebug(map);\n\t\tfor(int i=0;i<m;i++) for(int j=0;j<m;j++) {\n\t\t\td[i][j] = bfs(M[i], M[j]);\n\t\t}\n//\t\tdebug(d);\n\t\tmem = new int[1<<(m-1)][m];\n\t\tfor(int[] a: mem) fill(a, -1);\n\t\tSystem.out.println(dfs(1, 0));\n\t}\n\tint[][] d;\n\tint[][] mem;\n\tint dfs(int S, int p) {\n\t\tif(mem[S][p] >= 0) return mem[S][p];\n\t\tif( S == (1<<(m-1))-1) return mem[S][p] = d[p][m-1];\n\t\tint t = INF;\n\t\tfor(int i=0;i<m-1;i++) if(((S>>i)&1) == 0) {\n\t\t\tt = min(t, dfs(S|(1<<i), i)+d[p][i]);\n\t\t}\n\t\treturn mem[S][p] = t;\n\t}\n\t\n\tint[] dx = {-1, 0, 1, 0};\n\tint[] dy = {0, -1, 0, 1};\n\tint bfs(P s, P g) {\n\t\tboolean[][] visited = new boolean[h+2][w+2];\n\t\tPriorityQueue<P> q = new PriorityQueue<P>();\n\t\tq.add(s); visited[s.y][s.x] = true;\n\t\tfor(;!q.isEmpty();) {\n\t\t\tP cur = q.remove();\n\t\t\tif(cur.x == g.x && cur.y == g.y) return cur.t;\n\t\t\tif(map[cur.y][cur.x] == 0 || map[cur.y][cur.x] == INF) continue;\n\t\t\tfor(int i=0;i<4;i++) if(!visited[cur.y+dy[i]][cur.x+dx[i]]){\n\t\t\t\tvisited[cur.y+dy[i]][cur.x+dx[i]] = true;\n\t\t\t\tq.add(new P(cur.x+dx[i], cur.y+dy[i], cur.t+map[cur.y][cur.x]));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tclass P implements Comparable<P>{\n\t\tint x, y, t;\n\t\tP(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tt = 0;\n\t\t}\n\t\tP(int x, int y, int t) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn t-o.t;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint w, h, min;\n\tchar[][] cmap;\n\tint[][] imap, ncost;\n\tArrayList<int[]> list;\n\t\n\tint[] a = new int[]{0,0,1,-1};\n\tint[] b = new int[]{1,-1,0,0};\n\t\n\tvoid check(int[] perm){\n\t\tint[] perms = new int[list.size()];\n\t\tfor(int i=0;i<list.size()-2;i++){\n\t\t\tperms[i+1] = perm[i]+1;\n\t\t}\n\t\tperms[list.size()-1] = list.size()-1;\n\t\t\n\t\tint sum = 0;\n\t\tfor(int i=0;i<list.size()-1;i++){\n\t\t\tint cc = ncost[perms[i]][perms[i+1]];\n\t\t\tif(cc==0){\n\t\t\t\tcalcCost(perms[i], perms[i+1]);\n\t\t\t\tcc = ncost[perms[i]][perms[i+1]];\n\t\t\t}\n\t\t\tsum += cc;\n\t\t}\n\t\tmin = Math.min(min, sum);\n\t}\n\t\n\tvoid makeperm(int k, int[] perm, boolean[] flag){\n\t\tif(k==list.size()-2){\n\t\t\tcheck(perm);\n\t\t}else{\n\t\t\tfor(int i=0;i<list.size()-2;i++){\n\t\t\t\tif(flag[i]==true) continue;\n\t\t\t\tperm[k] = i;\n\t\t\t\tflag[i] = true;\n\t\t\t\tmakeperm(k+1, perm, flag);\n\t\t\t\tflag[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tvoid calcCost(int sid, int gid){\n\t\tArrayDeque<Integer> y = new ArrayDeque<Integer>();\n\t\tArrayDeque<Integer> x = new ArrayDeque<Integer>();\n\t\tint sy = list.get(sid)[0];\n\t\tint sx = list.get(sid)[1];\n\t\tint gy = list.get(gid)[0];\n\t\tint gx = list.get(gid)[1];\n\t\ty.offer(sy);\n\t\tx.offer(sx);\n\t\t\n\t\tint[][] cost = new int[h][w];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tcost[sy][sx] = 0;\n\t\twhile(!y.isEmpty()){\n\t\t\tint ty = y.poll();\n\t\t\tint tx = x.poll();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint ny = ty + a[i];\n\t\t\t\tint nx = tx + b[i];\n\t\t\t\tif(ny>=0 && ny<h && nx>=0 && nx<w && cmap[ny][nx]!='#'){\n\t\t\t\t\tif(cost[ny][nx] > cost[ty][tx]+imap[ty][tx]){\n\t\t\t\t\t\tcost[ny][nx] = cost[ty][tx]+imap[ty][tx];\n\t\t\t\t\t\ty.offer(ny);\n\t\t\t\t\t\tx.offer(nx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tncost[sid][gid] = cost[gy][gx];\n\t\tncost[gid][sid] = cost[gy][gx];\n\t}\n\t\n\tvoid mark(int y, int x){\n\t\tint ty = Math.max(0, y-2);\n\t\tint ey = Math.min(h-1, y+2);\n\t\tint tx = Math.max(0, x-2);\n\t\tint ex = Math.min(w-1, x+2);\n\t\t\n\t\tfor(int i=ty;i<=ey;i++){\n\t\t\tfor(int j=tx;j<=ex;j++){\n\t\t\t\timap[i][j] = Math.max(imap[i][j], 2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tty = Math.max(0, y-1);\n\t\tey = Math.min(h-1, y+1);\n\t\ttx = Math.max(0, x-1);\n\t\tex = Math.min(w-1, x+1);\n\t\tfor(int i=ty;i<=ey;i++){\n\t\t\tfor(int j=tx;j<=ex;j++){\n\t\t\t\timap[i][j] = 3;\n\t\t\t}\n\t\t}\n\t\t\n\t\timap[y][x] = 4;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tw = sc.nextInt();\n\t\th = sc.nextInt();\n\t\tcmap = new char[h][w];\n\t\timap = new int[h][w];\n\t\tlist = new ArrayList<int[]>();\n\t\tfor(int i=0;i<h;i++){\n\t\t\tString s = sc.next();\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar c = s.charAt(j);\n\t\t\t\tcmap[i][j] = c;\n\t\t\t\tif(c=='S'){\n\t\t\t\t\tlist.add(0, new int[]{i, j});\n\t\t\t\t}else if(c=='G'){\n\t\t\t\t\tlist.add(new int[]{i, j});\n\t\t\t\t}else if(c=='M'){\n\t\t\t\t\tif(list.size()==0)list.add(new int[]{i, j});\n\t\t\t\t\telse list.add(1, new int[]{i, j});\n\t\t\t\t}else if(c=='#'){\n\t\t\t\t\tmark(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(imap[i][j]==0) imap[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tncost = new int[list.size()][list.size()];\n\t\tmin = Integer.MAX_VALUE;\n\t\t\n\t\tmakeperm(0, new int[list.size()-2], new boolean[list.size()-2]);\n\t\t\n\t\tSystem.out.println(min);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tint INF = 1 << 24;\n\tint [][] cost;\n\tint w,h;\n\tint [] vx = {0,1,0,-1};\n\tint [] vy = {1,0,-1,0};\n\t\n\tclass State implements Comparable<State>{\n\t\tint nowx, nowy, cost, bit;\n\n\t\tpublic State(int nowx, int nowy, int cost, int bit) {\n\t\t\tthis.nowx = nowx;\n\t\t\tthis.nowy = nowy;\n\t\t\tthis.cost = cost;\n\t\t\tthis.bit = bit;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(State o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\t\t\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tchar [][] data = new char[h][w];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tdata[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tcost = new int[h][w];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tArrays.fill(cost[i], 1);\n\t\t\t}\n\t\t\tint sx = -1, sy = -1, countM = 0;\n\t\t\tHashMap<Integer, Integer> bitmap = new HashMap<Integer, Integer>();\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(data[i][j] == 'S'){\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\tdata[i][j] = ',';\n\t\t\t\t\t}\n\t\t\t\t\tif(data[i][j] == '#'){\n\t\t\t\t\t\tset(i, j);\n\t\t\t\t\t}\n\t\t\t\t\tif(data[i][j] == 'M'){\n\t\t\t\t\t\tbitmap.put(i * h + j, countM++);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<State> open = new PriorityQueue<Main.State>();\n\t\t\topen.add(new State(sx, sy, 0, 0));\n\t\t\tint [][][] close = new int[h][w][1 << countM];\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tArrays.fill(close[i][j], INF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose[sy][sx][0] = 0;\n\t\t\tint ans = -1;\n\t\t\twhile(! open.isEmpty()){\n\t\t\t\tState now = open.poll();\n\t\t\t\tif(data[now.nowy][now.nowx]== 'G' && now.bit == (1 << countM) -1){\n\t\t\t\t\tans = now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tint xx = now.nowx + vx[i];\n\t\t\t\t\tint yy = now.nowy + vy[i];\n\t\t\t\t\tint nextcost = now.cost + cost[now.nowy][now.nowx];\n\t\t\t\t\tint nextbit = now.bit;\n\t\t\t\t\tif(! isOK(xx, yy))continue;\n\t\t\t\t\tif(data[yy][xx] == 'M'){\n\t\t\t\t\t\tint ind = bitmap.get(yy * h + xx);\n\t\t\t\t\t\tnextbit = nextbit | (1 << ind); \n\t\t\t\t\t}\n\t\t\t\t\tif(close[yy][xx][nextbit] <= nextcost) continue;\n\t\t\t\t\topen.add(new State(xx, yy, nextcost, nextbit));\n\t\t\t\t\tclose[yy][xx][nextbit] = nextcost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate void set(int y, int x) {\n\t\tcost[y][x] = INF;\n\t\tfor(int i = -2; i <= 2; i++){\n\t\t\tfor(int j = -2; j <= 2; j++){\n\t\t\t\tint xx = x + j;\n\t\t\t\tint yy = y + i;\n\t\t\t\tif(! isOK(xx, yy)) continue;\n\t\t\t\tint res = Math.max(Math.abs(x - xx), Math.abs(y - yy));\n\t\t\t\tint dis = 4 - res;\n\t\t\t\tif(dis == 4) continue;\n\t\t\t\tcost[yy][xx] = Math.max(cost[yy][xx], dis);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isOK(int xx, int yy) {\n\t\tif(0 <= xx && xx < w && 0 <= yy && yy < h)return true;\n\t\treturn false;\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tfinal int MOD = 1000000007;\n\tint[] dx = { 1, 0, 0, -1 };\n\tint[] dy = { 0, 1, -1, 0 };\n\tint[] dx2 = { 1, 0, 0, -1, 1, -1, -1, 1 };\n\tint[] dy2 = { 0, 1, -1, 0, 1, 1, -1, -1 };\n\n\tvoid run() {\n\t\tint w = sc.nextInt();\n\t\tint h = sc.nextInt();\n\t\tchar[][] f = new char[h][w];\n\t\tint[][] hole = new int[h][w];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tArrays.fill(hole[i], 1);\n\t\t}\n\t\tint num = 0;\n\t\tint sh = 0;\n\t\tint sw = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tString in = sc.next();\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tf[i][j] = in.charAt(j);\n\t\t\t\tif (f[i][j] == 'S') {\n\t\t\t\t\tsh = i;\n\t\t\t\t\tsw = j;\n\t\t\t\t}\n\t\t\t\tif (f[i][j] == 'M') {\n\t\t\t\t\tf[i][j] = (char) (num++ + '0');\n\t\t\t\t}\n\t\t\t\tif (f[i][j] == '#') {\n\t\t\t\t\tLinkedList<Info> que = new LinkedList<Info>();\n\t\t\t\t\tque.add(new Info(0, i, j));\n\t\t\t\t\tint cost = 3;\n\t\t\t\t\twhile (cost != 0) {\n\t\t\t\t\t\tint s = que.size();\n\t\t\t\t\t\tfor (int k = 0; k < s; k++) {\n\t\t\t\t\t\t\tInfo now = que.poll();\n\t\t\t\t\t\t\tfor (int l = 0; l < 8; l++) {\n\t\t\t\t\t\t\t\tint nh = now.h + dy2[l];\n\t\t\t\t\t\t\t\tint nw = now.w + dx2[l];\n\t\t\t\t\t\t\t\tif (inner(nh, nw, h, w) && hole[nh][nw] < cost) {\n\t\t\t\t\t\t\t\t\thole[nh][nw] = cost;\n\t\t\t\t\t\t\t\t\tque.add(new Info(0, nh, nw));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcost--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tLinkedList<Info> que = new LinkedList<Info>();\n\t\tint[][][] cost = new int[1 << num][h][w];\n\t\tfor (int i = 0; i < 1 << num; i++) {\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tArrays.fill(cost[i][j], Integer.MAX_VALUE / 10);\n\t\t\t}\n\t\t}\n\t\tcost[0][sh][sw] = 0;\n\t\tque.add(new Info(0, sh, sw));\n\t\tint min = Integer.MAX_VALUE / 10;\n\t\twhile (!que.isEmpty()) {\n\t\t\tInfo now = que.poll();\n\t\t\tif (Character.isDigit(f[now.h][now.w])) {\n\t\t\t\tint m = Integer.valueOf(f[now.h][now.w] - '0');\n\t\t\t\tif (cost[now.num][now.h][now.w] < cost[now.num | (1 << m)][now.h][now.w]) {\n\t\t\t\t\tcost[now.num | (1 << m)][now.h][now.w] = cost[now.num][now.h][now.w];\n\t\t\t\t\tnow.num |= 1 << m;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f[now.h][now.w] == 'G' && now.num == (1 << num) - 1) {\n\t\t\t\tmin = Math.min(min, cost[(1 << num) - 1][now.h][now.w]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nh = now.h + dy[i];\n\t\t\t\tint nw = now.w + dx[i];\n\t\t\t\tif (inner(nh, nw, h, w) && f[nh][nw] != '#') {\n\t\t\t\t\tif (cost[now.num][now.h][now.w] + hole[now.h][now.w] < cost[now.num][nh][nw]) {\n\t\t\t\t\t\tcost[now.num][nh][nw] = cost[now.num][now.h][now.w] + hole[now.h][now.w];\n\t\t\t\t\t\tque.add(new Info(now.num, nh, nw));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(min);\n\t}\n\n\tclass Info {\n\t\tint num;\n\t\tint h;\n\t\tint w;\n\n\t\t/**\n\t\t * @param h\n\t\t * @param w\n\t\t */\n\t\tpublic Info(int num, int h, int w) {\n\t\t\tsuper();\n\t\t\tthis.num = num;\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tvoid debug3(int[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tboolean inner(int h, int w, int limH, int limW) {\n\t\treturn 0 <= h && h < limH && 0 <= w && w < limW;\n\t}\n\n\tvoid swap(int[] x, int a, int b) {\n\t\tint tmp = x[a];\n\t\tx[a] = x[b];\n\t\tx[b] = tmp;\n\t}\n\n\t// find minimum i (a[i] >= border)\n\tint lower_bound(int a[], int border) {\n\t\tint l = -1;\n\t\tint r = a.length;\n\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (l + r) / 2;\n\t\t\tif (border <= a[mid]) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\t// r = l + 1\n\t\treturn r;\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] in = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextInt();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tint[][] nextInt2dArray(int n, int m) {\n\t\t\tint[][] in = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] in = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextDouble();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] in = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tin[i] = nextLong();\n\t\t\t}\n\t\t\treturn in;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic MyScanner sc = new MyScanner();\n\tstatic int W, H, start, goal, n;\n\n\tpublic static void main(String[] args) {\n\t\tW = sc.nextInt();\n\t\tH = sc.nextInt();\n\t\tn = H * W;\n\t\tbyte[] cost = new byte[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcost[i] = 1;\n\t\t}\n\t\tArrayList<Integer> M = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tchar[] chs = sc.next().toCharArray();\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tchar ch = chs[j];\n\t\t\t\tswitch (ch) {\n\t\t\t\tcase 'S':\n\t\t\t\t\tstart = i * W + j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'G':\n\t\t\t\t\tgoal = i * W + j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\tM.add(i * W + j);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tfor (int ii = i - 2; ii <= i + 2; ii++) {\n\t\t\t\t\t\tfor (int jj = j - 2; jj <= j + 2; jj++) {\n\t\t\t\t\t\t\tif (0 <= ii && ii < H && 0 <= jj && jj < W) {\n\t\t\t\t\t\t\t\tif (cost[ii * W +jj] < 2) {\n\t\t\t\t\t\t\t\t\tcost[ii * W + jj] = 2;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int ii = i - 1; ii <= i + 1; ii++) {\n\t\t\t\t\t\tfor (int jj = j - 1; jj <= j + 1; jj++) {\n\t\t\t\t\t\t\tif (0 <= ii && ii < H && 0 <= jj && jj < W) {\n\t\t\t\t\t\t\t\tif (cost[ii * W +jj] < 3) {\n\t\t\t\t\t\t\t\t\tcost[ii * W + jj] = 3;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcost[i * W + j] = 127;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbyte[][] map = new byte[n][n];\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (j != 0) {\n\t\t\t\t\tmap[i * W + j][i * W + j - 1] = cost[i * W + j];\n\t\t\t\t}\n\t\t\t\tif (j != W - 1) {\n\t\t\t\t\tmap[i * W + j][i * W + j + 1] = cost[i * W + j];\n\t\t\t\t}\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tmap[i * W + j][(i - 1) * W + j] = cost[i * W + j];\n\t\t\t\t}\n\t\t\t\tif (i != H - 1) {\n\t\t\t\t\tmap[i * W + j][(i + 1) * W + j] = cost[i * W + j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint Msize = M.size();\n\t\tint[][] root = new int[Msize + 2][Msize + 2];\n\t\tint[] distance = new int[n];\n\t\tdijkstra(map, start, distance);\n\t\tfor (int i = 0; i < Msize; i++) {\n\t\t\troot[0][i + 1] = distance[M.get(i)];\n\t\t}\n\t\tfor (int i = 0; i < Msize; i++) {\n\t\t\tdijkstra(map, M.get(i), distance);\n\t\t\tfor (int j = 0; j < Msize; j++) {\n\t\t\t\troot[i + 1][j + 1] = distance[M.get(j)];\n\t\t\t}\n\t\t\troot[i + 1][Msize + 1] = distance[goal];\n\t\t}\n\n\t\tint[] perm = new int[Msize];\n\t\tfor (int i = 0; i < perm.length; i++) {\n\t\t\tperm[i] = i + 1;\n\t\t}\n\t\tint ans = 1000000000;\n\t\tdo {\n\t\t\tint time = 0;\n\t\t\ttime += root[0][perm[0]];\n\t\t\tfor (int i = 1; i < Msize; i++) {\n\t\t\t\ttime += root[perm[i - 1]][perm[i]];\n\t\t\t}\n\t\t\ttime += root[perm[Msize - 1]][Msize + 1];\n\t\t\tans = Math.min(ans, time);\n\t\t} while (nextPermutation(perm));\n\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tstatic void dijkstra(byte[][] map, int start, int[] distance) {\n\t\tboolean[] fixed = new boolean[n];\n\t\tArrays.fill(distance, 1000000000);\n\t\tdistance[start] = 0;\n\t\twhile (true) {\n\t\t\tint marked = minIndex(distance, fixed);\n\t\t\tif (marked < 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (distance[marked] == 1000000000) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfixed[marked] = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (map[marked][i] > 0 && !fixed[i]) {\n\t\t\t\t\tint newDistance = distance[marked] + map[marked][i];\n\t\t\t\t\tif (newDistance < distance[i]) {\n\t\t\t\t\t\tdistance[i] = newDistance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int minIndex(int[] distance, boolean[] fixed) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!fixed[i]) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (!fixed[j] && distance[j] < distance[i]) {\n\t\t\t\t\t\ti = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic boolean nextPermutation(int[] perm) {\n\t\tfor (int i = perm.length - 1; i > 0; --i) {\n\t\t\tif (perm[i - 1] < perm[i]) {\n\t\t\t\tint swapIndex = find(perm[i - 1], perm, i, perm.length - 1);\n\t\t\t\tint temp = perm[swapIndex];\n\t\t\t\tperm[swapIndex] = perm[i - 1];\n\t\t\t\tperm[i - 1] = temp;\n\t\t\t\tArrays.sort(perm, i, perm.length);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic int find(int dest, int[] perm, int s, int e) {\n\t\tif (s == e) {\n\t\t\treturn s;\n\t\t}\n\t\tint m = (s + e + 1) / 2;\n\t\treturn perm[m] <= dest ? find(dest, perm, s, m - 1) : find(dest, perm, m, e);\n\t}\n\n\tstatic class MyScanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\treturn buffer[ptr++];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(int c) {\n\t\t\treturn '!' <= c && c <= '~';\n\t\t}\n\n\t\tprivate void skipUnprintable() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskipUnprintable();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\tint n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint w, h, min;\n\tchar[][] cmap;\n\tint[][] imap, ncost;\n\tArrayList<int[]> list;\n\t\n\tint[] a = new int[]{0,0,1,-1};\n\tint[] b = new int[]{1,-1,0,0};\n\t\n\tvoid check(int[] perm){\n\t\tint[] perms = new int[list.size()];\n\t\tfor(int i=0;i<list.size()-2;i++){\n\t\t\tperms[i+1] = perm[i]+1;\n\t\t}\n\t\tperms[list.size()-1] = list.size()-1;\n\n\t\tint sum = 0;\n\t\tfor(int i=0;i<list.size()-1;i++){\n\t\t\tint cc = ncost[perms[i]][perms[i+1]];\n\t\t\tif(cc==0){\n\t\t\t\tcalcCost(perms[i], perms[i+1]);\n\t\t\t\tcc = ncost[perms[i]][perms[i+1]];\n\t\t\t}\n\t\t\tsum += cc;\n\t\t}\n\t\tmin = Math.min(min, sum);\n\t}\n\t\n\tvoid makeperm(int k, int[] perm, boolean[] flag){\n\t\tif(k==list.size()-2){\n\t\t\tcheck(perm);\n\t\t}else{\n\t\t\tfor(int i=0;i<list.size()-2;i++){\n\t\t\t\tif(flag[i]==true) continue;\n\t\t\t\tperm[k] = i;\n\t\t\t\tflag[i] = true;\n\t\t\t\tmakeperm(k+1, perm, flag);\n\t\t\t\tflag[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tvoid calcCost(int sid, int gid){\n\t\tArrayDeque<Integer> y = new ArrayDeque<Integer>();\n\t\tArrayDeque<Integer> x = new ArrayDeque<Integer>();\n\t\tint sy = list.get(sid)[0];\n\t\tint sx = list.get(sid)[1];\n\t\tint gy = list.get(gid)[0];\n\t\tint gx = list.get(gid)[1];\n\t\ty.offer(sy);\n\t\tx.offer(sx);\n\t\t\n\t\tint[][] cost = new int[h][w];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tcost[sy][sx] = 0;\n\t\twhile(!y.isEmpty()){\n\t\t\tint ty = y.poll();\n\t\t\tint tx = x.poll();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint ny = ty + a[i];\n\t\t\t\tint nx = tx + b[i];\n\t\t\t\tif(ny>=0 && ny<h && nx>=0 && nx<w && cmap[ny][nx]!='#'){\n\t\t\t\t\tif(cost[ny][nx] > cost[ty][tx]+imap[ty][tx]){\n\t\t\t\t\t\tcost[ny][nx] = cost[ty][tx]+imap[ty][tx];\n\t\t\t\t\t\ty.offer(ny);\n\t\t\t\t\t\tx.offer(nx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tncost[sid][gid] = cost[gy][gx];\n\t}\n\t\n\tvoid mark(int y, int x){\n\t\tint ty = Math.max(0, y-2);\n\t\tint ey = Math.min(h-1, y+2);\n\t\tint tx = Math.max(0, x-2);\n\t\tint ex = Math.min(w-1, x+2);\n\t\t\n\t\tfor(int i=ty;i<=ey;i++){\n\t\t\tfor(int j=tx;j<=ex;j++){\n\t\t\t\timap[i][j] = Math.max(imap[i][j], 2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tty = Math.max(0, y-1);\n\t\tey = Math.min(h-1, y+1);\n\t\ttx = Math.max(0, x-1);\n\t\tex = Math.min(w-1, x+1);\n\t\tfor(int i=ty;i<=ey;i++){\n\t\t\tfor(int j=tx;j<=ex;j++){\n\t\t\t\timap[i][j] = 3;\n\t\t\t}\n\t\t}\n\t\t\n\t\timap[y][x] = 4;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tw = sc.nextInt();\n\t\th = sc.nextInt();\n\t\tcmap = new char[h][w];\n\t\timap = new int[h][w];\n\t\tlist = new ArrayList<int[]>();\n\t\tfor(int i=0;i<h;i++){\n\t\t\tString s = sc.next();\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar c = s.charAt(j);\n\t\t\t\tcmap[i][j] = c;\n\t\t\t\tif(c=='S'){\n\t\t\t\t\tlist.add(0, new int[]{i, j});\n\t\t\t\t}else if(c=='G'){\n\t\t\t\t\tlist.add(new int[]{i, j});\n\t\t\t\t}else if(c=='M'){\n\t\t\t\t\tif(list.size()==0)list.add(new int[]{i, j});\n\t\t\t\t\telse list.add(1, new int[]{i, j});\n\t\t\t\t}else if(c=='#'){\n\t\t\t\t\tmark(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(imap[i][j]==0) imap[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tncost = new int[list.size()][list.size()];\n\t\tmin = Integer.MAX_VALUE;\n\t\t\n\t\tmakeperm(0, new int[list.size()-2], new boolean[list.size()-2]);\n\t\t\n\t\tSystem.out.println(min);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Acrophobia\npublic class Main{\n\n\tint w, h, si, sj, gi, gj, S, G, M, INF = 1<<29, res;\n\tint[][] adj;\n\tint[][] dist;\n\tint[][] d = {{-1,0},{0,1},{1,0},{0,-1}};\n\tboolean[] v;\n\tvoid f(int id, int sum){\n\t\tif(id==G){\n\t\t\tres = Math.min(res, sum); return;\n\t\t}\n\t\tif(res<=sum)return;\n\t\tboolean f = true;\n\t\tfor(int i=0;i<M;i++)if(i!=G && !v[i]){\n\t\t\tf = false;\n\t\t\tv[i] = true;\n\t\t\tf(i, sum+adj[id][i]);\n\t\t\tv[i] = false;\n\t\t}\n\t\tif(f)f(G, sum+adj[id][G]);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\tchar[][] m = new char[h][w];\n\t\tM = 0;\n\t\tint[][] cost = new int[h][w];\n\t\tint[][] id = new int[h][w];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tcost[i][j]=1;\n\t\t\tid[i][j] = -1;\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tm[i] = sc.next().toCharArray();\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(m[i][j]=='S'){\n\t\t\t\t\tm[i][j] = '.';\n\t\t\t\t\tsi = i; sj = j;\n\t\t\t\t\tS = M;\n\t\t\t\t\tid[i][j] = M++;\n\t\t\t\t}\n\t\t\t\tif(m[i][j]=='G'){\n\t\t\t\t\tm[i][j] = '.';\n\t\t\t\t\tgi = i; gj = j;\n\t\t\t\t\tG = M;\n\t\t\t\t\tid[i][j] = M++;\n\t\t\t\t}\n\t\t\t\tif(m[i][j]=='M'){\n\t\t\t\t\tm[i][j] = '.';\n\t\t\t\t\tid[i][j] = M++;\n\t\t\t\t}\n\t\t\t\tif(m[i][j]=='#'){\n\t\t\t\t\tfor(int y=i-2;y<=i+2;y++)for(int x=j-2;x<=j+2;x++){\n\t\t\t\t\t\tif(0<=y&&y<h&&0<=x&&x<w)cost[y][x] = Math.max(cost[y][x], 2);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int y=i-1;y<=i+1;y++)for(int x=j-1;x<=j+1;x++){\n\t\t\t\t\t\tif(0<=y&&y<h&&0<=x&&x<w)cost[y][x] = Math.max(cost[y][x], 3);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tadj = new int[M][M];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(id[i][j]!=-1){\n\t\t\tint now = id[i][j];\n\t\t\tdist = new int[h][w];\n\t\t\tfor(int[]d:dist)Arrays.fill(d, INF);\n\t\t\tdist[i][j] = 0;\n\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(h*w, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn dist[o1[0]][o1[1]] - dist[o2[0]][o2[1]];\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(new int[]{i, j});\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint[] V = q.poll();\n\t\t\t\tint pi = V[0], pj = V[1];\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint ni = pi+d[k][0], nj = pj+d[k][1];\n\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&m[ni][nj]!='#'){\n\t\t\t\t\t\tint w = dist[pi][pj] + cost[pi][pj];\n\t\t\t\t\t\tif(w < dist[ni][nj]){\n\t\t\t\t\t\t\tdist[ni][nj] = w; q.add(new int[]{ni, nj});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int y=0;y<h;y++)for(int x=0;x<w;x++)if(id[y][x]!=-1)adj[now][id[y][x]] = dist[y][x];\n\t\t}\n\t\tres = INF;\n\t\tv = new boolean[M];\n\t\tv[S] = true;\n\t\tf(S, 0);\n\t\tSystem.out.println(res);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int[][] move_dir = new int[][]{{1,0}, {-1,0}, {0, 1}, {0, -1}};\n\t\n\tpublic static boolean is_ok(int x, int y, int W, int H){\n\t\tif(x < 0 || y < 0 || x >= W || y >= H){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tpublic static class Walk implements Comparable<Walk>{\n\t\tint x;\n\t\tint y;\n\t\tint cost;\n\t\t\n\t\tpublic Walk(int x, int y, int cost) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk o) {\n\t\t\treturn this.cost - o.cost;\n\t\t}\n\t}\n\t\n\tpublic static void Dijstra(int[][] cost, int[][] dist, int s_x, int s_y, final int W, final int H){\n\t\tPriorityQueue<Walk> queue = new PriorityQueue<Main.Walk>();\n\t\tqueue.add(new Walk(s_x, s_y, 0));\n\t\t\n\t\twhile(!queue.isEmpty()){\n\t\t\tfinal Walk walk = queue.poll();\n\t\t\t\n\t\t\tif(cost[walk.y][walk.x] != Integer.MAX_VALUE){\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tcost[walk.y][walk.x] = walk.cost;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int[] move : move_dir){\n\t\t\t\tfinal int nx = walk.x + move[0];\n\t\t\t\tfinal int ny = walk.y + move[1];\n\t\t\t\t\n\t\t\t\tif(!is_ok(nx, ny, W, H)){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(dist[ny][nx] == 0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(cost[ny][nx] != Integer.MAX_VALUE){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int add_cost = dist[walk.y][walk.x] == 1 ? 3 :\n\t\t\t\t\t\t\t\t\t dist[walk.y][walk.x] == 2 ? 2 : 1;\n\t\t\t\t\n\t\t\t\tqueue.add(new Walk(nx, ny, walk.cost + add_cost));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static int dfs(int deep, boolean[] visited, int[][] adj, int cur_pos, int makimono_count){\n\t\tif(deep == makimono_count){\n\t\t\treturn adj[cur_pos][makimono_count + 1];\n\t\t}else{\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\t\n\t\t\tvisited[cur_pos] = true;\n\t\t\t\n\t\t\tfor(int next = 0; next <= makimono_count; next++){\n\t\t\t\tif(visited[next]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmin = Math.min(min, adj[cur_pos][next] + dfs(deep + 1, visited, adj, next, makimono_count));\n\t\t\t}\n\t\t\t\n\t\t\tvisited[cur_pos] = false;\n\t\t\t\n\t\t\treturn min;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int W = sc.nextInt();\n\t\tfinal int H = sc.nextInt();\n\t\t\n\t\tint[][] blank_dist = new int[H][W];\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tblank_dist[i][j] = Integer.MAX_VALUE / 2;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint makimono_count = 0;\n\t\tint[] makimono_x = new int[5];\n\t\tint[] makimono_y = new int[5];\n\t\t\n\t\tint s_x = -1, s_y = -1;\n\t\tint g_x = -1, g_y = -1;\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\t\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tif(input[j] == '#'){\n\t\t\t\t\tblank_dist[i][j] = 0;\n\t\t\t\t}else if(input[j] == 'S'){\n\t\t\t\t\ts_x = j;\n\t\t\t\t\ts_y = i;\n\t\t\t\t}else if(input[j] == 'G'){\n\t\t\t\t\tg_x = j;\n\t\t\t\t\tg_y = i;\n\t\t\t\t}else if(input[j] == 'M'){\n\t\t\t\t\tmakimono_x[makimono_count] = j;\n\t\t\t\t\tmakimono_y[makimono_count] = i;\n\t\t\t\t\tmakimono_count++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[] pur_x = new int[makimono_count + 2];\n\t\tint[] pur_y = new int[makimono_count + 2];\n\t\tpur_x[0] = s_x; pur_y[0] = s_y;\n\t\tfor(int i = 1; i <= makimono_count; i++){\n\t\t\tpur_x[i] = makimono_x[i - 1];\n\t\t\tpur_y[i] = makimono_y[i - 1];\n\t\t}\n\t\tpur_x[makimono_count + 1] = g_x;\n\t\tpur_y[makimono_count + 1] = g_y;\n\t\t\n\t\t\n\t\tfor(int y = 0; y < H; y++){\n\t\t\tfor(int x = 0; x < W; x++){\n\t\t\t\tif(y != 0){\n\t\t\t\t\tblank_dist[y][x] = Math.min(blank_dist[y][x], blank_dist[y-1][x] + 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(x != 0){\n\t\t\t\t\tblank_dist[y][x] = Math.min(blank_dist[y][x], blank_dist[y][x-1] + 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(x != 0 && y != 0){\n\t\t\t\t\tblank_dist[y][x] = Math.min(blank_dist[y][x], blank_dist[y-1][x-1] + 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(x != W - 1 && y != 0){\n\t\t\t\t\tblank_dist[y][x] = Math.min(blank_dist[y][x], blank_dist[y-1][x+1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int y = H - 1; y >= 0; y--){\n\t\t\tfor(int x = W - 1; x >= 0; x--){\n\t\t\t\tif(y != H - 1){\n\t\t\t\t\tblank_dist[y][x] = Math.min(blank_dist[y][x], blank_dist[y+1][x] + 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(x != W - 1){\n\t\t\t\t\tblank_dist[y][x] = Math.min(blank_dist[y][x], blank_dist[y][x+1] + 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(y != H - 1 && x != W - 1){\n\t\t\t\t\tblank_dist[y][x] = Math.min(blank_dist[y][x], blank_dist[y+1][x+1] + 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(y != H - 1 && x != 0){\n\t\t\t\t\tblank_dist[y][x] = Math.min(blank_dist[y][x], blank_dist[y+1][x-1] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tfor(int j = 0; j < W; j++){\n\t\t\t\tSystem.out.print(blank_dist[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t*/\n\t\t\n\t\tint[][] adj = new int[makimono_count + 2][makimono_count + 2];\n\t\tint[][] map = new int[H][W];\n\t\tfor(int i = 0; i < makimono_count + 2; i++){\n\t\t\tfor(int j = 0; j < H; j++){\n\t\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\t\tmap[j][k] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tDijstra(map, blank_dist, pur_x[i], pur_y[i], W, H);\n\t\t\t\n\t\t\tfor(int j = 0; j < makimono_count + 2; j++){\n\t\t\t\tadj[i][j] = map[pur_y[j]][pur_x[j]];\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tfor(int i = 0; i < makimono_count + 2; i++){\n\t\t\tfor(int j = 0; j < makimono_count + 2; j++){\n\t\t\t\tSystem.out.printf(\"%02d \", adj[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t*/\n\t\t\n\t\tboolean[] visited = new boolean[makimono_count + 2];\n\t\t\n\t\tSystem.out.println(dfs(0, visited, adj, 0, makimono_count));\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic MyScanner sc = new MyScanner();\n\tstatic int W, H, start, goal, n;\n\tstatic int[] cost;\n\tstatic int[][] map;\n\n\tpublic static void main(String[] args) {\n\t\tW = sc.nextInt();\n\t\tH = sc.nextInt();\n\t\tn = H * W;\n\t\tcost = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcost[i] = 1;\n\t\t}\n\t\tArrayList<Integer> M = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tchar[] chs = sc.next().toCharArray();\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tchar ch = chs[j];\n\t\t\t\tswitch (ch) {\n\t\t\t\tcase 'S':\n\t\t\t\t\tstart = i * W + j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'G':\n\t\t\t\t\tgoal = i * W + j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\tM.add(i * W + j);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tfor (int ii = i - 2; ii <= i + 2; ii++) {\n\t\t\t\t\t\tfor (int jj = j - 2; jj <= j + 2; jj++) {\n\t\t\t\t\t\t\tif (0 <= ii && ii < H && 0 <= jj && jj < W) {\n\t\t\t\t\t\t\t\tcost[ii * W + jj] = Math.max(cost[ii * W + jj], 2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int ii = i - 1; ii <= i + 1; ii++) {\n\t\t\t\t\t\tfor (int jj = j - 1; jj <= j + 1; jj++) {\n\t\t\t\t\t\t\tif (0 <= ii && ii < H && 0 <= jj && jj < W) {\n\t\t\t\t\t\t\t\tcost[ii * W + jj] = Math.max(cost[ii * W + jj], 3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcost[i * W + j] = 1000000000;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmap = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tmap[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (j != 0) {\n\t\t\t\t\tmap[i * W + j][i * W + j - 1] = cost[i * W + j];\n\t\t\t\t}\n\t\t\t\tif (j != W - 1) {\n\t\t\t\t\tmap[i * W + j][i * W + j + 1] = cost[i * W + j];\n\t\t\t\t}\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tmap[i * W + j][(i - 1) * W + j] = cost[i * W + j];\n\t\t\t\t}\n\t\t\t\tif (i != H - 1) {\n\t\t\t\t\tmap[i * W + j][(i + 1) * W + j] = cost[i * W + j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint Msize = M.size();\n\t\tint[][] root = new int[Msize + 2][Msize + 2];\n\t\tint[] distance = new int[n];\n\t\tdijkstra(map, start, distance);\n\t\tfor (int i = 0; i < Msize; i++) {\n\t\t\troot[0][i + 1] = distance[M.get(i)];\n\t\t}\n\t\tfor (int i = 0; i < Msize; i++) {\n\t\t\tdijkstra(map, M.get(i), distance);\n\t\t\tfor (int j = 0; j < Msize; j++) {\n\t\t\t\troot[i + 1][j + 1] = distance[M.get(j)];\n\t\t\t}\n\t\t\troot[i + 1][Msize + 1] = distance[goal];\n\t\t}\n\n\t\tint[] perm = new int[Msize];\n\t\tfor (int i = 0; i < perm.length; i++) {\n\t\t\tperm[i] = i + 1;\n\t\t}\n\t\tint ans = Integer.MAX_VALUE;\n\t\tdo {\n\t\t\tint time = 0;\n\t\t\ttime += root[0][perm[0]];\n\t\t\tfor (int i = 1; i < Msize; i++) {\n\t\t\t\ttime += root[perm[i - 1]][perm[i]];\n\t\t\t}\n\t\t\ttime += root[perm[Msize - 1]][Msize + 1];\n\t\t\tans = Math.min(ans, time);\n\t\t} while (nextPermutation(perm));\n\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tstatic void dijkstra(int[][] map, int start, int[] distance) {\n\t\tboolean[] fixed = new boolean[n];\n\t\tArrays.fill(distance, Integer.MAX_VALUE);\n\t\tdistance[start] = 0;\n\t\twhile (true) {\n\t\t\tint marked = minIndex(distance, fixed);\n\t\t\tif (marked < 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (distance[marked] == Integer.MAX_VALUE) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfixed[marked] = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (map[marked][i] > 0 && !fixed[i]) {\n\t\t\t\t\tint newDistance = distance[marked] + map[marked][i];\n\t\t\t\t\tif (newDistance < distance[i]) {\n\t\t\t\t\t\tdistance[i] = newDistance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int minIndex(int[] distance, boolean[] fixed) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!fixed[i]) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (!fixed[j] && distance[j] < distance[i]) {\n\t\t\t\t\t\ti = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic boolean nextPermutation(int[] perm) {\n\t\tfor (int i = perm.length - 1; i > 0; --i) {\n\t\t\tif (perm[i - 1] < perm[i]) {\n\t\t\t\tint swapIndex = find(perm[i - 1], perm, i, perm.length - 1);\n\t\t\t\tint temp = perm[swapIndex];\n\t\t\t\tperm[swapIndex] = perm[i - 1];\n\t\t\t\tperm[i - 1] = temp;\n\t\t\t\tArrays.sort(perm, i, perm.length);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic int find(int dest, int[] perm, int s, int e) {\n\t\tif (s == e) {\n\t\t\treturn s;\n\t\t}\n\t\tint m = (s + e + 1) / 2;\n\t\treturn perm[m] <= dest ? find(dest, perm, s, m - 1) : find(dest, perm, m, e);\n\t}\n\n\tstatic class MyScanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\treturn buffer[ptr++];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(int c) {\n\t\t\treturn '!' <= c && c <= '~';\n\t\t}\n\n\t\tprivate void skipUnprintable() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskipUnprintable();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\tint n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\tint w, h;\n\tint[][] map;\n\tP S, G;\n\tP[] M;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\tmap = new int[h+2][w+2];\n\t\tLinkedList<P> m = new LinkedList<P>();\n\t\tfor(int i=1;i<=h;i++) {\n\t\t\tString l = sc.next();\n\t\t\tfor(int j=0;j<w;j++) {\n\t\t\t\tmap[i][j+1] = max(map[i][j+1], 1);\n\t\t\t\tif(l.charAt(j) == 'G') G = new P(j+1, i);\n\t\t\t\tif(l.charAt(j) == 'S') S = new P(j+1, i);\n\t\t\t\tif(l.charAt(j) == 'M') m.add(new P(j+1, i));\n\t\t\t\tif(l.charAt(j) == '#') {\n\t\t\t\t\tfor(int x=-2;x<=2;x++) for(int y=-2;y<=2;y++) if((x|y)!=0) {\n\t\t\t\t\t\tif( j+x+1<1 || j+x+1>w || i+y<1 || i+y>h ) continue;\n\t\t\t\t\t\tmap[i+y][j+x+1] = max(map[i+y][j+x+1], 4-max(abs(y), abs(x)));\n\t\t\t\t\t}\n\t\t\t\t\tmap[i][j+1] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tm.addFirst(S); m.addLast(G);\n\t\tM = m.toArray(new P[]{});\n\t\tsolve();\n\t}\n\t\n\tint m;\n\tvoid solve() {\n\t\tm = M.length;\n\t\td = new int[m][m];\n//\t\tdebug(map);\n\t\tfor(int i=0;i<m;i++) for(int j=i+1;j<m;j++) {\n\t\t\td[i][j] = d[j][i] = bfs(M[i], M[j]);\n\t\t}\n//\t\tdebug(d);\n\t\tmem = new int[1<<(m-1)][m];\n\t\tfor(int[] a: mem) fill(a, -1);\n\t\tSystem.out.println(dfs(1, 0));\n\t}\n\tint[][] d;\n\tint[][] mem;\n\tint dfs(int S, int p) {\n\t\tif(mem[S][p] >= 0) return mem[S][p];\n\t\tif( S == (1<<(m-1))-1) return mem[S][p] = d[p][m-1];\n\t\tint t = INF;\n\t\tfor(int i=0;i<m-1;i++) if(((S>>i)&1) == 0) {\n\t\t\tt = min(t, dfs(S|(1<<i), i)+d[p][i]);\n\t\t}\n\t\treturn mem[S][p] = t;\n\t}\n\t\n\tint[] dx = {-1, 0, 1, 0};\n\tint[] dy = {0, -1, 0, 1};\n\tint bfs(P s, P g) {\n\t\tboolean[][] visited = new boolean[h+2][w+2];\n\t\tPriorityQueue<P> q = new PriorityQueue<P>();\n\t\tq.add(s); visited[s.y][s.x] = true;\n\t\tfor(;!q.isEmpty();) {\n\t\t\tP cur = q.remove();\n\t\t\tif(cur.x == g.x && cur.y == g.y) return cur.t;\n\t\t\tif(map[cur.y][cur.x] == 0 || map[cur.y][cur.x] == INF) continue;\n\t\t\tfor(int i=0;i<4;i++) if(!visited[cur.y+dy[i]][cur.x+dx[i]]){\n\t\t\t\tvisited[cur.y+dy[i]][cur.x+dx[i]] = true;\n\t\t\t\tq.add(new P(cur.x+dx[i], cur.y+dy[i], cur.t+map[cur.y][cur.x]));\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn -1;\n\t}\n\t\n\tclass P implements Comparable<P>{\n\t\tint x, y, t;\n\t\tP(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tt = 0;\n\t\t}\n\t\tP(int x, int y, int t) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn t-o.t;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tstatic MyScanner sc = new MyScanner();\n\tstatic int W, H, start, goal, n;\n\n\tpublic static void main(String[] args) {\n\t\tW = sc.nextInt();\n\t\tH = sc.nextInt();\n\t\tn = H * W;\n\t\tint[] cost = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcost[i] = 1;\n\t\t}\n\t\tArrayList<Integer> M = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tchar[] chs = sc.next().toCharArray();\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tchar ch = chs[j];\n\t\t\t\tswitch (ch) {\n\t\t\t\tcase 'S':\n\t\t\t\t\tstart = i * W + j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'G':\n\t\t\t\t\tgoal = i * W + j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\tM.add(i * W + j);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tfor (int ii = i - 2; ii <= i + 2; ii++) {\n\t\t\t\t\t\tfor (int jj = j - 2; jj <= j + 2; jj++) {\n\t\t\t\t\t\t\tif (0 <= ii && ii < H && 0 <= jj && jj < W) {\n\t\t\t\t\t\t\t\tcost[ii * W + jj] = Math.max(cost[ii * W + jj], 2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int ii = i - 1; ii <= i + 1; ii++) {\n\t\t\t\t\t\tfor (int jj = j - 1; jj <= j + 1; jj++) {\n\t\t\t\t\t\t\tif (0 <= ii && ii < H && 0 <= jj && jj < W) {\n\t\t\t\t\t\t\t\tcost[ii * W + jj] = Math.max(cost[ii * W + jj], 3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcost[i * W + j] = 1000000000;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint[][] map = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tmap[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (j != 0) {\n\t\t\t\t\tmap[i * W + j][i * W + j - 1] = cost[i * W + j];\n\t\t\t\t}\n\t\t\t\tif (j != W - 1) {\n\t\t\t\t\tmap[i * W + j][i * W + j + 1] = cost[i * W + j];\n\t\t\t\t}\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tmap[i * W + j][(i - 1) * W + j] = cost[i * W + j];\n\t\t\t\t}\n\t\t\t\tif (i != H - 1) {\n\t\t\t\t\tmap[i * W + j][(i + 1) * W + j] = cost[i * W + j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint Msize = M.size();\n\t\tint[][] root = new int[Msize + 2][Msize + 2];\n\t\tint[] distance = new int[n];\n\t\tdijkstra(map, start, distance);\n\t\tfor (int i = 0; i < Msize; i++) {\n\t\t\troot[0][i + 1] = distance[M.get(i)];\n\t\t}\n\t\tfor (int i = 0; i < Msize; i++) {\n\t\t\tdijkstra(map, M.get(i), distance);\n\t\t\tfor (int j = 0; j < Msize; j++) {\n\t\t\t\troot[i + 1][j + 1] = distance[M.get(j)];\n\t\t\t}\n\t\t\troot[i + 1][Msize + 1] = distance[goal];\n\t\t}\n\n\t\tint[] perm = new int[Msize];\n\t\tfor (int i = 0; i < perm.length; i++) {\n\t\t\tperm[i] = i + 1;\n\t\t}\n\t\tint ans = 1000000000;\n\t\tdo {\n\t\t\tint time = 0;\n\t\t\ttime += root[0][perm[0]];\n\t\t\tfor (int i = 1; i < Msize; i++) {\n\t\t\t\ttime += root[perm[i - 1]][perm[i]];\n\t\t\t}\n\t\t\ttime += root[perm[Msize - 1]][Msize + 1];\n\t\t\tans = Math.min(ans, time);\n\t\t} while (nextPermutation(perm));\n\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tstatic void dijkstra(int[][] map, int start, int[] distance) {\n\t\tboolean[] fixed = new boolean[n];\n\t\tArrays.fill(distance, 1000000000);\n\t\tdistance[start] = 0;\n\t\twhile (true) {\n\t\t\tint marked = minIndex(distance, fixed);\n\t\t\tif (marked < 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (distance[marked] == 1000000000) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfixed[marked] = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (map[marked][i] > 0 && !fixed[i]) {\n\t\t\t\t\tint newDistance = distance[marked] + map[marked][i];\n\t\t\t\t\tif (newDistance < distance[i]) {\n\t\t\t\t\t\tdistance[i] = newDistance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int minIndex(int[] distance, boolean[] fixed) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!fixed[i]) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (!fixed[j] && distance[j] < distance[i]) {\n\t\t\t\t\t\ti = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic boolean nextPermutation(int[] perm) {\n\t\tfor (int i = perm.length - 1; i > 0; --i) {\n\t\t\tif (perm[i - 1] < perm[i]) {\n\t\t\t\tint swapIndex = find(perm[i - 1], perm, i, perm.length - 1);\n\t\t\t\tint temp = perm[swapIndex];\n\t\t\t\tperm[swapIndex] = perm[i - 1];\n\t\t\t\tperm[i - 1] = temp;\n\t\t\t\tArrays.sort(perm, i, perm.length);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic int find(int dest, int[] perm, int s, int e) {\n\t\tif (s == e) {\n\t\t\treturn s;\n\t\t}\n\t\tint m = (s + e + 1) / 2;\n\t\treturn perm[m] <= dest ? find(dest, perm, s, m - 1) : find(dest, perm, m, e);\n\t}\n\n\tstatic class MyScanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte()) {\n\t\t\t\treturn buffer[ptr++];\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(int c) {\n\t\t\treturn '!' <= c && c <= '~';\n\t\t}\n\n\t\tprivate void skipUnprintable() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr])) {\n\t\t\t\tptr++;\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tskipUnprintable();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\tint n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint w, h, min;\n\tchar[][] cmap;\n\tint[][] imap, ncost;\n\tArrayList<int[]> list;\n\t\n\tint[] a = new int[]{0,0,1,-1};\n\tint[] b = new int[]{1,-1,0,0};\n\t\n\tvoid check(int[] perm){\n\t\tint[] perms = new int[list.size()];\n\t\tfor(int i=0;i<list.size()-2;i++){\n\t\t\tperms[i+1] = perm[i]+1;\n\t\t}\n\t\tperms[list.size()-1] = list.size()-1;\n\n\t\tint sum = 0;\n\t\tfor(int i=0;i<list.size()-1;i++){\n\t\t\tint cc = ncost[perms[i]][perms[i+1]];\n\t\t\tif(cc==0){\n\t\t\t\tcalcCost(perms[i], perms[i+1]);\n\t\t\t\tcc = ncost[perms[i]][perms[i+1]];\n\t\t\t}\n\t\t\tsum += cc;\n\t\t}\n\t\tmin = Math.min(min, sum);\n\t}\n\t\n\tvoid makeperm(int k, int[] perm, boolean[] flag){\n\t\tif(k==list.size()-2){\n\t\t\tcheck(perm);\n\t\t}else{\n\t\t\tfor(int i=0;i<list.size()-2;i++){\n\t\t\t\tif(flag[i]==true) continue;\n\t\t\t\tperm[k] = i;\n\t\t\t\tflag[i] = true;\n\t\t\t\tmakeperm(k+1, perm, flag);\n\t\t\t\tflag[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tvoid calcCost(int sid, int gid){\n\t\tArrayDeque<Integer> y = new ArrayDeque<Integer>();\n\t\tArrayDeque<Integer> x = new ArrayDeque<Integer>();\n\t\tint sy = list.get(sid)[0];\n\t\tint sx = list.get(sid)[1];\n\t\tint gy = list.get(gid)[0];\n\t\tint gx = list.get(gid)[1];\n\t\ty.offer(sy);\n\t\tx.offer(sx);\n\t\t\n\t\tint[][] cost = new int[h][w];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t}\n\t\t}\n\t\tcost[sy][sx] = 0;\n\t\twhile(!y.isEmpty()){\n\t\t\tint ty = y.poll();\n\t\t\tint tx = x.poll();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint ny = ty + a[i];\n\t\t\t\tint nx = tx + b[i];\n\t\t\t\tif(ny>=0 && ny<h && nx>=0 && nx<w && cmap[ny][nx]!='#'){\n\t\t\t\t\tif(cost[ny][nx] > cost[ty][tx]+imap[ty][tx]){\n\t\t\t\t\t\tcost[ny][nx] = cost[ty][tx]+imap[ty][tx];\n\t\t\t\t\t\ty.offer(ny);\n\t\t\t\t\t\tx.offer(nx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tncost[sid][gid] = cost[gy][gx];\n\t}\n\t\n\tvoid mark(int y, int x){\n\t\tint ty = Math.max(0, y-2);\n\t\tint ey = Math.min(h-1, y+2);\n\t\tint tx = Math.max(0, x-2);\n\t\tint ex = Math.min(w-1, x+2);\n\t\t\n\t\tfor(int i=ty;i<=ey;i++){\n\t\t\tfor(int j=tx;j<=ex;j++){\n\t\t\t\timap[i][j] = Math.max(imap[i][j], 2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tty = Math.max(0, y-1);\n\t\tey = Math.min(h-1, y+1);\n\t\ttx = Math.max(0, x-1);\n\t\tex = Math.min(w-1, x+1);\n\t\tfor(int i=ty;i<=ey;i++){\n\t\t\tfor(int j=tx;j<=ex;j++){\n\t\t\t\timap[i][j] = Math.max(imap[i][j], 3);\n\t\t\t}\n\t\t}\n\t\t\n\t\timap[y][x] = 4;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tw = sc.nextInt();\n\t\th = sc.nextInt();\n\t\tcmap = new char[h][w];\n\t\timap = new int[h][w];\n\t\tlist = new ArrayList<int[]>();\n\t\tint sy = -1;\n\t\tint sx = -1;\n\t\tint gy = -1;\n\t\tint gx = -1;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tString s = sc.next();\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar c = s.charAt(j);\n\t\t\t\tcmap[i][j] = c;\n\t\t\t\tif(c=='S'){\n\t\t\t\t\tsy = i;\n\t\t\t\t\tsx = j;\n\t\t\t\t}else if(c=='G'){\n\t\t\t\t\tgy = i;\n\t\t\t\t\tgx = j;\n\t\t\t\t}else if(c=='M'){\n\t\t\t\t\tlist.add(new int[]{i, j});\n\t\t\t\t}else if(c=='#'){\n\t\t\t\t\tmark(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlist.add(0, new int[]{sy,sx});\n\t\tlist.add(new int[]{gy,gx});\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(imap[i][j]==0) imap[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tncost = new int[list.size()][list.size()];\n\t\tmin = Integer.MAX_VALUE;\n\t\t\n\t\tmakeperm(0, new int[list.size()-2], new boolean[list.size()-2]);\n\t\t\n\t\tSystem.out.println(min);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int W, H, start, goal, n;\n\tstatic int[] cost;\n\tstatic int[][] map;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tW = sc.nextInt();\n\t\tH = sc.nextInt();\n\t\tn = H * W;\n\t\tcost = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcost[i] = 1;\n\t\t}\n\t\tArrayList<Integer> M = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tchar[] chs = sc.next().toCharArray();\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tchar ch = chs[j];\n\t\t\t\tswitch (ch) {\n\t\t\t\tcase 'S':\n\t\t\t\t\tstart = i * W + j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'G':\n\t\t\t\t\tgoal = i * W + j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\tM.add(i * W + j);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tfor (int ii = i - 2; ii <= i + 2; ii++) {\n\t\t\t\t\t\tfor (int jj = j - 2; jj <= j + 2; jj++) {\n\t\t\t\t\t\t\tif (0 <= ii && ii < H && 0 <= jj && jj < W) {\n\t\t\t\t\t\t\t\tcost[ii * W + jj] = Math.max(cost[ii * W + jj], 2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int ii = i - 1; ii <= i + 1; ii++) {\n\t\t\t\t\t\tfor (int jj = j - 1; jj <= j + 1; jj++) {\n\t\t\t\t\t\t\tif (0 <= ii && ii < H && 0 <= jj && jj < W) {\n\t\t\t\t\t\t\t\tcost[ii * W + jj] = Math.max(cost[ii * W + jj], 3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcost[i * W + j] = 1000000000;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\n\t\tmap = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tmap[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (j != 0) {\n\t\t\t\t\tmap[i * W + j][i * W + j - 1] = cost[i * W + j];\n\t\t\t\t}\n\t\t\t\tif (j != W - 1) {\n\t\t\t\t\tmap[i * W + j][i * W + j + 1] = cost[i * W + j];\n\t\t\t\t}\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tmap[i * W + j][(i - 1) * W + j] = cost[i * W + j];\n\t\t\t\t}\n\t\t\t\tif (i != H - 1) {\n\t\t\t\t\tmap[i * W + j][(i + 1) * W + j] = cost[i * W + j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint Msize = M.size();\n\t\tint[][] root = new int[Msize + 2][Msize + 2];\n\t\tint[] distance = new int[n];\n\t\tdijkstra(map, start, distance);\n\t\tfor (int i = 0; i < Msize; i++) {\n\t\t\troot[0][i + 1] = distance[M.get(i)];\n\t\t}\n\t\tfor (int i = 0; i < Msize; i++) {\n\t\t\tdijkstra(map, M.get(i), distance);\n\t\t\tfor (int j = 0; j < Msize; j++) {\n\t\t\t\troot[i + 1][j + 1] = distance[M.get(j)];\n\t\t\t}\n\t\t\troot[i + 1][Msize + 1] = distance[goal];\n\t\t}\n\n\t\tint[] perm = new int[Msize];\n\t\tfor (int i = 0; i < perm.length; i++) {\n\t\t\tperm[i] = i + 1;\n\t\t}\n\t\tint ans = Integer.MAX_VALUE;\n\t\tdo {\n\t\t\tint time = 0;\n\t\t\ttime += root[0][perm[0]];\n\t\t\tfor (int i = 1; i < Msize; i++) {\n\t\t\t\ttime += root[perm[i - 1]][perm[i]];\n\t\t\t}\n\t\t\ttime += root[perm[Msize - 1]][Msize + 1];\n\t\t\tans = Math.min(ans, time);\n\t\t} while (nextPermutation(perm));\n\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tstatic void dijkstra(int[][] map, int start, int[] distance) {\n\t\tboolean[] fixed = new boolean[n];\n\t\tArrays.fill(distance, Integer.MAX_VALUE);\n\t\tdistance[start] = 0;\n\t\twhile (true) {\n\t\t\tint marked = minIndex(distance, fixed);\n\t\t\tif (marked < 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (distance[marked] == Integer.MAX_VALUE) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfixed[marked] = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (map[marked][i] > 0 && !fixed[i]) {\n\t\t\t\t\tint newDistance = distance[marked] + map[marked][i];\n\t\t\t\t\tif (newDistance < distance[i]) {\n\t\t\t\t\t\tdistance[i] = newDistance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int minIndex(int[] distance, boolean[] fixed) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!fixed[i]) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (!fixed[j] && distance[j] < distance[i]) {\n\t\t\t\t\t\ti = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic boolean nextPermutation(int[] perm) {\n\t\tfor (int i = perm.length - 1; i > 0; --i) {\n\t\t\tif (perm[i - 1] < perm[i]) {\n\t\t\t\tint swapIndex = find(perm[i - 1], perm, i, perm.length - 1);\n\t\t\t\tint temp = perm[swapIndex];\n\t\t\t\tperm[swapIndex] = perm[i - 1];\n\t\t\t\tperm[i - 1] = temp;\n\t\t\t\tArrays.sort(perm, i, perm.length);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic int find(int dest, int[] perm, int s, int e) {\n\t\tif (s == e) {\n\t\t\treturn s;\n\t\t}\n\t\tint m = (s + e + 1) / 2;\n\t\treturn perm[m] <= dest ? find(dest, perm, s, m - 1) : find(dest, perm, m, e);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int W, H, start, goal, n;\n\tstatic int[][] cost, map;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tW = sc.nextInt();\n\t\tH = sc.nextInt();\n\t\tcost = new int[H][W];\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tcost[i][j] = 1;\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> M = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tchar[] chs = sc.next().toCharArray();\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tchar ch = chs[j];\n\t\t\t\tswitch (ch) {\n\t\t\t\tcase 'S':\n\t\t\t\t\tstart = i * W + j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'G':\n\t\t\t\t\tgoal = i * W + j;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\t\tM.add(i * W + j);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tfor (int ii = i - 2; ii <= i + 2; ii++) {\n\t\t\t\t\t\tfor (int jj = j - 2; jj <= j + 2; jj++) {\n\t\t\t\t\t\t\tif (0 <= ii && ii < H && 0 <= jj && jj < W) {\n\t\t\t\t\t\t\t\tcost[ii][jj] = Math.max(cost[ii][jj], 2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int ii = i - 1; ii <= i + 1; ii++) {\n\t\t\t\t\t\tfor (int jj = j - 1; jj <= j + 1; jj++) {\n\t\t\t\t\t\t\tif (0 <= ii && ii < H && 0 <= jj && jj < W) {\n\t\t\t\t\t\t\t\tcost[ii][jj] = Math.max(cost[ii][jj], 3);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcost[i][j] = 1000000000;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\n\t\tn = H * W;\n\t\tmap = new int[n][n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tmap[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (j != 0) {\n\t\t\t\t\tmap[i * W + j][i * W + j - 1] = cost[i][j];\n\t\t\t\t}\n\t\t\t\tif (j != W - 1) {\n\t\t\t\t\tmap[i * W + j][i * W + j + 1] = cost[i][j];\n\t\t\t\t}\n\t\t\t\tif (i != 0) {\n\t\t\t\t\tmap[i * W + j][(i - 1) * W + j] = cost[i][j];\n\t\t\t\t}\n\t\t\t\tif (i != H - 1) {\n\t\t\t\t\tmap[i * W + j][(i + 1) * W + j] = cost[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint Msize = M.size();\n\t\tint[][] root = new int[Msize + 2][Msize + 2];\n\t\tint[] distance = new int[n];\n\t\tdijkstra(map, start, distance);\n\t\tfor (int i = 0; i < Msize; i++) {\n\t\t\troot[0][i + 1] = distance[M.get(i)];\n\t\t}\n\t\tfor (int i = 0; i < Msize; i++) {\n\t\t\tdijkstra(map, M.get(i), distance);\n\t\t\tfor (int j = 0; j < Msize; j++) {\n\t\t\t\troot[i + 1][j + 1] = distance[M.get(j)];\n\t\t\t}\n\t\t\troot[i + 1][Msize + 1] = distance[goal];\n\t\t}\n\n\t\tint[] perm = new int[Msize];\n\t\tfor (int i = 0; i < perm.length; i++) {\n\t\t\tperm[i] = i + 1;\n\t\t}\n\t\tint ans = Integer.MAX_VALUE;\n\t\tdo {\n\t\t\tint time = 0;\n\t\t\ttime += root[0][perm[0]];\n\t\t\tfor (int i = 1; i < Msize; i++) {\n\t\t\t\ttime += root[perm[i - 1]][perm[i]];\n\t\t\t}\n\t\t\ttime += root[perm[Msize - 1]][Msize + 1];\n\t\t\tans = Math.min(ans, time);\n\t\t} while (nextPermutation(perm));\n\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tstatic void dijkstra(int[][] map, int start, int[] distance) {\n\t\tboolean[] fixed = new boolean[n];\n\t\tArrays.fill(distance, Integer.MAX_VALUE);\n\t\tdistance[start] = 0;\n\t\twhile (true) {\n\t\t\tint marked = minIndex(distance, fixed);\n\t\t\tif (marked < 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (distance[marked] == Integer.MAX_VALUE) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfixed[marked] = true;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (map[marked][i] > 0 && !fixed[i]) {\n\t\t\t\t\tint newDistance = distance[marked] + map[marked][i];\n\t\t\t\t\tif (newDistance < distance[i]) {\n\t\t\t\t\t\tdistance[i] = newDistance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic int minIndex(int[] distance, boolean[] fixed) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (!fixed[i]) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (!fixed[j] && distance[j] < distance[i]) {\n\t\t\t\t\t\ti = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic boolean nextPermutation(int[] perm) {\n\t\tfor (int i = perm.length - 1; i > 0; --i) {\n\t\t\tif (perm[i - 1] < perm[i]) {\n\t\t\t\tint swapIndex = find(perm[i - 1], perm, i, perm.length - 1);\n\t\t\t\tint temp = perm[swapIndex];\n\t\t\t\tperm[swapIndex] = perm[i - 1];\n\t\t\t\tperm[i - 1] = temp;\n\t\t\t\tArrays.sort(perm, i, perm.length);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tstatic int find(int dest, int[] perm, int s, int e) {\n\t\tif (s == e) {\n\t\t\treturn s;\n\t\t}\n\t\tint m = (s + e + 1) / 2;\n\t\treturn perm[m] <= dest ? find(dest, perm, s, m - 1) : find(dest, perm, m, e);\n\t}\n\n}"
  },
  {
    "language": "Ruby",
    "code": "w, h = gets.split.map(&:to_i)\n\na = (1..h).map{ gets.chomp.split(\"\") }\ncost = (1..h).map{ [1] * w }\n\nstart = goal = nil\ntargets = []\n(0..h-1).each{|i|\n\t(0..w-1).each{|j|\n\t\tstart = [i, j] if a[i][j] == 'S'\n\t\tgoal = [i, j] if a[i][j] == 'G'\n\t\ttargets << [i, j] if a[i][j] == 'M'\n\t\tif a[i][j] == '#'\n\t\t\t([0, i-2].max..[h-1, i+2].min).each{|y|\n\t\t\t\t([0, j-2].max..[w-1, j+2].min).each{|x|\n\t\t\t\t\tc = 4 - [(y-i).abs, (x-j).abs].max\n\t\t\t\t\tcost[y][x] = c if c > cost[y][x]\n\t\t\t\t}\n\t\t\t}\n\t\tend\n\t}\n}\n\nrequire 'set'\nclass BucketQueue\n\tdef initialize(max)\n\t\t@min = 0\n\t\t@loop = 0\n\t\t@mod = max + 1\n\t\t@count = 0\n\t\t@buckets = (0..max).map{ Set.new }\t\n\tend\n\n\tdef add(obj, key)\n\t\t@buckets[key % @mod] << obj\n\t\t@count += 1\n\tend\n\n\tdef del(obj, key)\n\t\t@buckets[key % @mod].delete(obj)\n\t\t@count -= 1\n\tend\n\n\tdef del_min\n\t\twhile @buckets[@min].empty?\n\t\t\t@min += 1\n\t\t\tif @min == @mod\n\t\t\t\t@min = 0\n\t\t\t\t@loop += 1\n\t\t\tend\n\t\tend\n\n\t\tmin_obj = nil\n\t\t@buckets[@min].each{|obj|\n\t\t\tmin_obj = obj\n\t\t\tbreak\n\t\t}\n\n\t\t@buckets[@min].delete(min_obj)\n\t\t@count -= 1\n\n\t\t[min_obj, @loop * @mod + @min]\n\tend\n\n\tdef empty?\n\t\t@count == 0\n\tend\nend\n\ndef min_dist(start, goals, cost)\n\tdist = (1..cost.size).map{ [Float::INFINITY] * cost[0].size }\n\n\tqueue = BucketQueue.new(3)\n\tqueue.add(start, 0)\n\tuntil queue.empty? \n\t\tv, key = queue.del_min\n\t\ty, x = v\n\t\tidx = goals.index(v)\n\n\t\t[[1,0],[-1,0],[0,1],[0,-1]].each{|dy, dx|\n\t\t\ti, j = y + dy, x + dx\n\t\t\tnext unless (0..cost.size-1) === i\n\t\t\tnext unless (0..cost[0].size-1) === j\n\t\t\tnext if cost[i][j] > 3\n\t\t\t\n\t\t\td = key + cost[y][x]\t\n\t\t\tif dist[i][j] == Float::INFINITY\n\t\t\t\tqueue.add([i, j], d)\n\t\t\t\tdist[i][j] = d\n\t\t\telsif d < dist[i][j]\n\t\t\t\tqueue.del([i, j], dist[i][j])\n\t\t\t\tqueue.add([i, j], d)\n\t\t\t\tdist[i][j] = d\n\t\t\tend\n\t\t}\n\tend\n\tgoals.map{|i, j| dist[i][j]}\nend\n\t\nfirst_dist = min_dist(start, targets, cost)\ndist = []\ntargets.each{|t|\n\tdist << min_dist(t, targets + [goal], cost)\n}\n\np (0..targets.size-1).to_a.permutation(targets.size).map{|perm|\n\ttotal_dist = first_dist[perm[0]]\n\tperm.each_cons(2){|i, j|\n\t\ttotal_dist += dist[i][j]\n\t}\n\ttotal_dist += dist[perm[-1]][-1]\n\ttotal_dist\n}.min"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\n\nlong INF = 10^^10;\nvoid main() {\n    string[] input = readln.split;\n    int W = input[0].to!int;\n    int H = input[1].to!int;\n    long[][] grid = new long[][](W, H);\n    foreach(int i; 0..W) grid[i][] = 1;\n    Point s, g;\n    Point[] m;\n    int[] vx = [ 1, 0,-1, 0];\n    int[] vy = [ 0, 1, 0,-1];\n    int[] vx1 = [ 1, 1, 0,-1,-1,-1, 0, 1];\n    int[] vy1 = [ 0, 1, 1, 1, 0,-1,-1,-1];\n    int[] vx2 = [ 2, 2, 2, 1, 0,-1,-2,-2,-2,-2,-2,-1, 0, 1, 2, 2];\n    int[] vy2 = [ 0, 1, 2, 2, 2, 2, 2, 1, 0,-1,-2,-2,-2,-2,-2,-1];\n    foreach(int y; 0..H) {\n        string str = readln.chomp;\n        foreach(int x; 0..W) {\n            switch(str[x]) {\n            case 'S': s = Point(x, y); break;\n            case 'G': g = Point(x, y); break;\n            case 'M': m ~= Point(x, y); break;\n            case '#':\n                grid[x][y] = INF;\n                for(int i=0; i<vx1.length; i++) {\n                    if (x+vx1[i]>=0 && x+vx1[i]<W && y+vy1[i]>=0 && y+vy1[i]<H) {\n                        grid[x+vx1[i]][y+vy1[i]] = max(3, grid[x+vx1[i]][y+vy1[i]]);\n                    }\n                }\n                for(int i=0; i<vx2.length; i++) {\n                    if (x+vx2[i]>=0 && x+vx2[i]<W && y+vy2[i]>=0 && y+vy2[i]<H) {\n                        grid[x+vx2[i]][y+vy2[i]] = max(2, grid[x+vx2[i]][y+vy2[i]]);\n                    }\n                }\n                break;\n            default:\n            }\n        }\n    }\n    Point[] points = s~m~g;\n\n    long[][] dist = new long[][](points.length, points.length);\n    for (int i=0; i<points.length; i++) {\n        Node[][] nodes = new Node[][](W, H);\n        foreach(int x; 0..W) foreach(int y; 0..H) {\n            nodes[x][y] = new Node(x, y, grid[x][y]);\n        }\n        nodes[points[i].x][points[i].y].value = 0;\n        nodes[points[i].x][points[i].y].contain = true;\n        Node[] _ary = [nodes[points[i].x][points[i].y]];\n        _ary.length = nodes.join.length;\n        auto queue = heapify!(\"a.value > b.value\")(_ary, 1);\n        while(!queue.empty) {\n            Node doneNode = queue.front;\n            queue.removeFront;\n            doneNode.done = true;\n            for (int j=0; j<vx.length; j++) {\n                if (doneNode.x+vx[j]>=0 && doneNode.x+vx[j]<W && doneNode.y+vy[j]>=0 && doneNode.y+vy[j]<H) {\n                    Node node = nodes[doneNode.x+vx[j]][doneNode.y+vy[j]];\n                    node.value = min(node.value, doneNode.value+doneNode.cost);\n                    if (!node.contain) {\n                        queue.insert(node);\n                        node.contain = true;\n                    }\n                }\n            }\n        }\n\n        for (int j=0; j<points.length; j++) {\n            dist[i][j] = nodes[points[j].x][points[j].y].value;\n        }\n    }\n\n    long min = INF;\n    auto ary = m.length.iota.map!(a=>a+1).array;\n    do {\n        auto _ary = 0~ary~(ary.length+1);\n        long sum = 0;\n        for (int i=1; i<_ary.length; i++) {\n            sum += dist[_ary[i-1]][_ary[i]];\n        }\n        if (sum<min) min = sum;\n    } while(nextPermutation(ary));\n    min.writeln;\n}\nstruct Point{\n    int x, y;\n    this(int x, int y) {\n        this.x = x; this.y = y;\n    }\n}\nclass Node{\n    long cost;\n    bool done = false;\n    bool contain = false;\n    long value;\n    int x, y;\n    this(int x, int y, long cost) {\n        this.x = x;\n        this.y = y;\n        this.cost = cost;\n        this.value = INF;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.typecons;\nimport std.algorithm;\nimport std.container;\n\nint x,y;\nint[] cost;\nint[][Tuple!(int,int)] dists;\n\nint dijkstra(Tuple!(int,int) s, Tuple!(int,int) g){\n\tint[]* p = s in dists;\n\tif(p){\n\t\treturn (*p)[g[0]+x*g[1]];\n\t}\n\tBinaryHeap!(Array!(Tuple!(int,Tuple!(int,int))), \"a[0] > b[0]\") que;\n\tque.insert(tuple(0, s));\n\tint[] dist = new int[](cost.length);\n\tdist[] = int.max;\n\twhile(!que.empty()){\n\t\tTuple!(int,Tuple!(int,int)) top = que.front();\n\t\tque.removeFront();\n\t\tif(cost[top[1][0]+x*top[1][1]] < int.max && dist[top[1][0]+x*top[1][1]] > top[0]){\n\t\t\tdist[top[1][0]+x*top[1][1]] = top[0];\n\t\t\tforeach(i; -1..2){\n\t\t\t\tforeach(j; -1..2){\n\t\t\t\t\tif((!i||!j) && i+top[1][0]>=0 && i+top[1][0]<x && j+top[1][1]>=0 && j+top[1][1]<y){\n\t\t\t\t\t\tque.insert(tuple(cost[top[1][0]+x*top[1][1]] + top[0], tuple(i+top[1][0], j+top[1][1])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tdists[s] = dist;\n\treturn dist[g[0]+x*g[1]];\n}\nint main(){\n\tscanf(\"%d %d\\n\", &y, &x);\n\tcost = new int[](x*y);\n\tcost[] = 1;\n\tTuple!(int, int)[] m;\n\tTuple!(int, int) s, g;\n\tforeach(i; 0..x){\n\t\tstring a = readln;\n\t\tforeach(j; 0..y){\n\t\t\tif(a[j]=='S') s = tuple(i, j);\n\t\t\telse if(a[j]=='G') g = tuple(i, j);\n\t\t\telse if(a[j]=='M') m ~= tuple(i, j);\n\t\t\telse if(a[j]=='#'){\n\t\t\t\tforeach(k; -2..3){\n\t\t\t\t\tforeach(l; -2..3){\n\t\t\t\t\t\tif(i+k>=0 && i+k<x && j+l>=0 && j+l<y){\n\t\t\t\t\t\t\tcost[i+k+x*(j+l)] = max(cost[i+k+x*(j+l)], (k==2||k==-2||l==2||l==-2 ? 2 : 3));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcost[i+x*j] = int.max;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = int.max;\n\tint[] pe;\n\tforeach(i; 0..m.length) pe ~= cast(int)(i);\n\tdo{\n\t\tint route = dijkstra(s, m[pe[0]]) + dijkstra(m[pe[pe.length-1]], g);\n\t\tfor(int i=1; ans>route && i<pe.length; i++){\n\t\t\troute += dijkstra(m[pe[i-1]], m[pe[i]]);\n\t\t}\n\t\tans = min(ans, route);\n\t}while(nextPermutation(pe));\n\tans.writeln;\n\treturn 0;\n}"
  },
  {
    "language": "D",
    "code": "import std.conv;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\nimport std.algorithm;\nimport std.container;\nimport std.functional;\n\nint x,y;\nint[] cost;\n\nint dijkstra(Tuple!(int, int) s, Tuple!(int, int) g){\n\tBinaryHeap!(Array!(Tuple!(int,Tuple!(int,int))), \"a[0]>=b[0]\") que;\n\tque.insert(tuple(0, s));\n\tint[] dist = new int[](cost.length);\n\tdist[] = int.max;\n\twhile(!que.empty()){\n\t\tTuple!(int,Tuple!(int,int)) top = que.front();\n\t\tque.removeFront();\n\t\tif(cost[top[1][0]+x*top[1][1]] < int.max && dist[top[1][0]+x*top[1][1]] > top[0]){\n\t\t\tdist[top[1][0]+x*top[1][1]] = top[0];\n\t\t\tforeach(i; -1..2){\n\t\t\t\tforeach(j; -1..2){\n\t\t\t\t\tif((i==0||j==0) && i+top[1][0]>=0 && i+top[1][0]<x && j+top[1][1]>=0 && j+top[1][1]<y){\n\t\t\t\t\t\tque.insert(tuple(cost[top[1][0]+x*top[1][1]] + top[0], tuple(i+top[1][0], j+top[1][1])));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn dist[g[0]+x*g[1]];\n}\nint main(){\n\tauto ln = map!(to!int)(readln.strip.split(\" \"));\n\tx = ln[1];\n\ty = ln[0];\n\tcost = new int[](x*y);\n\tcost[] = 1;\n\tTuple!(int, int)[] m;\n\tTuple!(int, int) s, g;\n\tforeach(i; 0..x){\n\t\tstring a = readln;\n\t\tforeach(j; 0..y){\n\t\t\tif(a[j]=='S') s = tuple(i, j);\n\t\t\telse if(a[j]=='G') g = tuple(i, j);\n\t\t\telse if(a[j]=='M') m ~= tuple(i, j);\n\t\t\telse if(a[j]=='#'){\n\t\t\t\tforeach(k; -2..3){\n\t\t\t\t\tforeach(l; -2..3){\n\t\t\t\t\t\tif(i+k>=0 && i+k<x && j+l>=0 && j+l<y){\n\t\t\t\t\t\t\tcost[i+k+x*(j+l)] = max(cost[i+k+x*(j+l)], (k==2||k==-2||l==2||l==-2 ? 2 : 3));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcost[i+x*j] = int.max;\n\t\t\t}\n\t\t}\n\t}\n\tint ans = int.max;\n\tint[] pe;\n\tforeach(i; 0..m.length) pe ~= cast(int)(i);\n\tdo{\n\t\tint route = memoize!(dijkstra)(s, m[pe[0]]) + memoize!(dijkstra)(m[pe[pe.length-1]], g);\n\t\tfor(int i=1; i<pe.length; i++){\n\t\t\troute += memoize!(dijkstra)(m[pe[i-1]], m[pe[i]]);\n\t\t}\n\t\tans = min(ans, route);\n\t}while(nextPermutation(pe));\n\tans.writeln;\n\treturn 0;\n}"
  },
  {
    "language": "Python",
    "code": "from itertools import permutations\nfrom collections import deque\n\nw, h = map(int, input().split())\nmp = [\"X\" * (w + 4)] * 2 + [\"XX\" + input() + \"XX\" for _ in range(h)] + [\"X\" * (w + 4)] * 2\nm_lst = []\nholes = []\nfor y in range(2, h + 2):\n  for x in range(2, w + 2):\n    if mp[y][x] == \"S\":\n      sx, sy = x, y\n    if mp[y][x] == \"G\":\n      gx, gy = x, y\n    if mp[y][x] == \"M\":\n      m_lst.append((x, y))\n    if mp[y][x] == \"#\":\n      holes.append((x, y))\n\nmove_costs = [[1] * (w + 4) for _ in range(h + 4)]\nfor x, y in holes:\n  for ny in range(y - 2, y + 3):\n    for nx in range(x - 2, x + 3):\n      move_costs[ny][nx] = max(2, move_costs[ny][nx])\n\n  for ny in range(y - 1, y + 2):\n    for nx in range(x - 1, x + 2):\n      move_costs[ny][nx] = 3\n\ndef shortest(x1, y1):\n  INF = 10 ** 20\n  vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n  costs = [[INF] * (w + 4) for _ in range(h + 4)]\n  costs[y1][x1] = 0\n  que = deque()\n  que.append((0, x1, y1))\n  while que:\n    score, x, y = que.popleft()\n    new_score = score + move_costs[y][x]\n    for dx, dy in vec:\n      nx, ny = x + dx, y + dy\n      if mp[ny][nx] in {\"S\", \"G\", \".\", \"M\"} and new_score < costs[ny][nx]:\n        costs[ny][nx] = new_score\n        que.append((new_score, nx, ny))\n  return costs\n\nedges = []\nfor x, y in m_lst:\n  costs = shortest(x, y)\n  edge = []\n  for x2, y2 in m_lst:\n    edge.append(costs[y2][x2])\n  edge.append(costs[gy][gx])\n  edges.append(edge)\n\nstart_cost = shortest(sx, sy)\ngoal_cost = shortest(gx, gy)\nans = 10 ** 20\nfor t in permutations(range(len(edges)), len(edges)):\n  lst = list(t)\n  score = 0\n  for i in range(len(edges) - 1):\n    score += edges[lst[i]][lst[i + 1]]\n  xs, ys = m_lst[lst[0]]\n  xf, yf = m_lst[lst[-1]]\n  score += start_cost[ys][xs]\n  score += edges[lst[-1]][-1]\n  ans = min(ans, score)\n\nprint(ans)\n"
  }
]