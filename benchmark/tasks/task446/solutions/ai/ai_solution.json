[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <math.h>\n\ntypedef struct {\n    int x1, y1, x2, y2;\n} Segment;\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    int x, y;\n} Valve;\n\ndouble min(double a, double b) {\n    return a < b ? a : b;\n}\n\ndouble distance(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nint orientation(Point p, Point q, Point r) {\n    int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0) return 0;\n    return (val > 0) ? 1 : 2;\n}\n\nint onSegment(Point p, Point q, Point r) {\n    if (q.x <= fmax(p.x, r.x) && q.x >= fmin(p.x, r.x) &&\n        q.y <= fmax(p.y, r.y) && q.y >= fmin(p.y, r.y))\n        return 1;\n    return 0;\n}\n\nint doIntersect(Segment s1, Segment s2) {\n    Point p1 = {s1.x1, s1.y1};\n    Point q1 = {s1.x2, s1.y2};\n    Point p2 = {s2.x1, s2.y1};\n    Point q2 = {s2.x2, s2.y2};\n\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    if (o1 != o2 && o3 != o4)\n        return 1;\n\n    if (o1 == 0 && onSegment(p1, p2, q1)) return 1;\n    if (o2 == 0 && onSegment(p1, q2, q1)) return 1;\n    if (o3 == 0 && onSegment(p2, p1, q2)) return 1;\n    if (o4 == 0 && onSegment(p2, q1, q2)) return 1;\n\n    return 0;\n}\n\nint isConnected(Segment s1, Segment s2) {\n    Point p1 = {s1.x1, s1.y1};\n    Point q1 = {s1.x2, s1.y2};\n    Point p2 = {s2.x1, s2.y1};\n    Point q2 = {s2.x2, s2.y2};\n\n    if (p1.x == p2.x && p1.y == p2.y) return 1;\n    if (p1.x == q2.x && p1.y == q2.y) return 1;\n    if (q1.x == p2.x && q1.y == p2.y) return 1;\n    if (q1.x == q2.x && q1.y == q2.y) return 1;\n\n    return 0;\n}\n\ndouble minimalPipeLength(Segment* segments, int segmentCount, Valve* valves, int valveCount, Point source, Point repair) {\n    double minLength = -1;\n    int* visited = (int*)calloc(segmentCount, sizeof(int));\n\n    for (int i = 0; i < segmentCount; ++i) {\n        if (visited[i]) continue;\n        visited[i] = 1;\n\n        Point p1 = {segments[i].x1, segments[i].y1};\n        Point p2 = {segments[i].x2, segments[i].y2};\n\n        if ((p1.x == source.x && p1.y == source.y) || (p2.x == source.x && p2.y == source.y)) {\n            double currentLength = distance(p1, p2);\n            for (int j = 0; j < segmentCount; ++j) {\n                if (i == j || visited[j]) continue;\n                if (isConnected(segments[i], segments[j])) {\n                    visited[j] = 1;\n                    Point p3 = {segments[j].x1, segments[j].y1};\n                    Point p4 = {segments[j].x2, segments[j].y2};\n                    currentLength += distance(p3, p4);\n                }\n            }\n            if (minLength == -1 || currentLength < minLength) {\n                minLength = currentLength;\n            }\n        }\n    }\n\n    free(visited);\n    return minLength;\n}\n\nint main() {\n    int segmentCount, valveCount;\n    scanf(\"%d %d\", &segmentCount, &valveCount);\n\n    Segment* segments = (Segment*)malloc(segmentCount * sizeof(Segment));\n    for (int i = 0; i < segmentCount; ++i) {\n        scanf(\"%d %d %d %d\", &segments[i].x1, &segments[i].y1, &segments[i].x2, &segments[i].y2);\n    }\n\n    Valve* valves = (Valve*)malloc(valveCount * sizeof(Valve));\n    for (int i = 0; i < valveCount; ++i) {\n        scanf(\"%d %d\", &valves[i].x, &valves[i].y);\n    }\n\n    Point source, repair;\n    scanf(\"%d %d\", &source.x, &source.y);\n    scanf(\"%d %d\", &repair.x, &repair.y);\n\n    double result = minimalPipeLength(segments, segmentCount, valves, valveCount, source, repair);\n    if (result == -1) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%.2f\\n\", result);\n    }\n\n    free(segments);\n    free(valves);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:35:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <unordered_map>\n#include <unordered_set>\n#include <limits>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    bool operator==(const Point& other) const {\n        return x == other.x && y == other.y;\n    }\n};\n\nnamespace std {\n    template<>\n    struct hash<Point> {\n        size_t operator()(const Point& p) const {\n            return hash<double>()(p.x) ^ hash<double>()(p.y);\n        }\n    };\n}\n\nstruct Segment {\n    Point a, b;\n    Segment(Point a, Point b) : a(a), b(b) {}\n};\n\nstruct Valve {\n    Point pos;\n    vector<Segment> connected;\n    Valve(Point pos) : pos(pos) {}\n};\n\ndouble distance(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nbool isPointOnSegment(const Point& p, const Segment& s) {\n    double cross = (s.b.x - s.a.x) * (p.y - s.a.y) - (s.b.y - s.a.y) * (p.x - s.a.x);\n    if (abs(cross) > 1e-12) return false;\n    double dot = (p.x - s.a.x) * (s.b.x - s.a.x) + (p.y - s.a.y) * (s.b.y - s.a.y);\n    if (dot < 0) return false;\n    double squaredLen = (s.b.x - s.a.x) * (s.b.x - s.a.x) + (s.b.y - s.a.y) * (s.b.y - s.a.y);\n    if (dot > squaredLen) return false;\n    return true;\n}\n\nvector<Segment> getSegmentsBetween(const Point& a, const Point& b, const vector<Segment>& segments) {\n    vector<Segment> result;\n    for (const Segment& s : segments) {\n        if (isPointOnSegment(a, s) && isPointOnSegment(b, s)) {\n            result.push_back(s);\n        }\n    }\n    return result;\n}\n\nunordered_map<Point, Valve> buildGraph(const vector<Segment>& segments, const vector<Point>& valves) {\n    unordered_map<Point, Valve> graph;\n    for (const Point& v : valves) {\n        graph[v] = Valve(v);\n    }\n    for (const Segment& s : segments) {\n        vector<Point> pointsOnSegment;\n        for (const auto& pair : graph) {\n            if (isPointOnSegment(pair.first, s)) {\n                pointsOnSegment.push_back(pair.first);\n            }\n        }\n        if (pointsOnSegment.size() < 2) continue;\n        for (size_t i = 0; i < pointsOnSegment.size(); ++i) {\n            for (size_t j = i + 1; j < pointsOnSegment.size(); ++j) {\n                Point a = pointsOnSegment[i];\n                Point b = pointsOnSegment[j];\n                vector<Segment> connectingSegments = getSegmentsBetween(a, b, segments);\n                if (!connectingSegments.empty()) {\n                    graph[a].connected.push_back(Segment(a, b));\n                    graph[b].connected.push_back(Segment(b, a));\n                }\n            }\n        }\n    }\n    return graph;\n}\n\ndouble dijkstra(const unordered_map<Point, Valve>& graph, const Point& source, const Point& target) {\n    unordered_map<Point, double> dist;\n    for (const auto& pair : graph) {\n        dist[pair.first] = numeric_limits<double>::infinity();\n    }\n    dist[source] = 0;\n    priority_queue<pair<double, Point>, vector<pair<double, Point>>, greater<pair<double, Point>>> pq;\n    pq.push({0, source});\n\n    while (!pq.empty()) {\n        double currentDist = pq.top().first;\n        Point current = pq.top().second;\n        pq.pop();\n\n        if (current == target) {\n            return currentDist;\n        }\n\n        if (currentDist > dist[current]) {\n            continue;\n        }\n\n        for (const Segment& seg : graph.at(current).connected) {\n            Point neighbor = seg.b;\n            double edgeLength = distance(seg.a, seg.b);\n            if (dist[neighbor] > dist[current] + edgeLength) {\n                dist[neighbor] = dist[current] + edgeLength;\n                pq.push({dist[neighbor], neighbor});\n            }\n        }\n    }\n    return -1;\n}\n\ndouble minimalPipeLengthToStop(const Point& source, const Point& repair, const vector<Segment>& segments, const vector<Point>& valves) {\n    unordered_map<Point, Valve> graph = buildGraph(segments, valves);\n    if (graph.find(source) == graph.end() || graph.find(repair) == graph.end()) {\n        return -1;\n    }\n    return dijkstra(graph, source, repair);\n}\n\nint main() {\n    Point source, repair;\n    cin >> source.x >> source.y;\n    cin >> repair.x >> repair.y;\n\n    int N, M;\n    cin >> N;\n    vector<Segment> segments;\n    for (int i = 0; i < N; ++i) {\n        Point a, b;\n        cin >> a.x >> a.y >> b.x >> b.y;\n        segments.emplace_back(a, b);\n    }\n\n    cin >> M;\n    vector<Point> valves;\n    for (int i = 0; i < M; ++i) {\n        Point v;\n        cin >> v.x >> v.y;\n        valves.push_back(v);\n    }\n\n    double result = minimalPipeLengthToStop(source, repair, segments, valves);\n    if (result == -1) {\n        cout << -1 << endl;\n    } else {\n        cout << result << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:36:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass PipeSegment {\n    int x1, y1, x2, y2;\n    PipeSegment(int x1, int y1, int x2, int y2) {\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n}\n\nclass Point {\n    int x, y;\n    Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Point point = (Point) o;\n        return x == point.x && y == point.y;\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y);\n    }\n}\n\nclass Solution {\n    private Map<Point, List<PipeSegment>> graph;\n    private Set<Point> visited;\n    private Point source;\n    private Point repair;\n    private double minLength;\n    \n    public double minimalPipeLengthToStop(PipeSegment[] pipes, Point[] valves, Point source, Point repair) {\n        this.source = source;\n        this.repair = repair;\n        this.graph = new HashMap<>();\n        this.visited = new HashSet<>();\n        this.minLength = Double.MAX_VALUE;\n        \n        // Build graph\n        for (PipeSegment pipe : pipes) {\n            Point p1 = new Point(pipe.x1, pipe.y1);\n            Point p2 = new Point(pipe.x2, pipe.y2);\n            graph.computeIfAbsent(p1, k -> new ArrayList<>()).add(pipe);\n            graph.computeIfAbsent(p2, k -> new ArrayList<>()).add(pipe);\n        }\n        \n        Set<Point> valveSet = new HashSet<>();\n        for (Point valve : valves) {\n            valveSet.add(valve);\n        }\n        \n        dfs(source, valveSet, 0.0);\n        \n        return minLength == Double.MAX_VALUE ? -1 : minLength;\n    }\n    \n    private void dfs(Point current, Set<Point> valves, double currentLength) {\n        if (current.equals(repair)) {\n            minLength = Math.min(minLength, currentLength);\n            return;\n        }\n        \n        if (visited.contains(current)) {\n            return;\n        }\n        \n        visited.add(current);\n        \n        for (PipeSegment pipe : graph.getOrDefault(current, new ArrayList<>())) {\n            Point next = new Point(pipe.x1, pipe.y1);\n            if (next.equals(current)) {\n                next = new Point(pipe.x2, pipe.y2);\n            }\n            \n            double segmentLength = Math.sqrt(Math.pow(pipe.x1 - pipe.x2, 2) + Math.pow(pipe.y1 - pipe.y2, 2));\n            if (valves.contains(current)) {\n                dfs(next, valves, currentLength);\n            } else {\n                dfs(next, valves, currentLength + segmentLength);\n            }\n        }\n        \n        visited.remove(current);\n    }\n}",
    "timestamp": "2025-08-05 21:37:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public double minPipeLength(int[][] pipeSegments, int[][] stopValves, int[] sourcePoint, int[] repairPoint) {\n        int n = pipeSegments.length;\n        Map<Integer, List<int[]>> graph = new HashMap<>();\n        \n        // Build graph\n        for (int[] segment : pipeSegments) {\n            int start = segment[0], end = segment[1];\n            graph.computeIfAbsent(start, k -> new ArrayList<>()).add(new int[]{end, segment[2]});\n            graph.computeIfAbsent(end, k -> new ArrayList<>()).add(new int[]{start, segment[2]});\n        }\n        \n        // Check if repairing point is reachable from source\n        Set<Integer> visited = new HashSet<>();\n        if (!isReachable(graph, sourcePoint[0], repairPoint[0], visited)) {\n            return -1;\n        }\n        \n        // Dijkstra's algorithm to find minimal path\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Double.compare(a[1], b[1]));\n        Map<Integer, Double> distances = new HashMap<>();\n        \n        pq.offer(new int[]{sourcePoint[0], 0});\n        distances.put(sourcePoint[0], 0.0);\n        \n        while (!pq.isEmpty()) {\n            int[] curr = pq.poll();\n            int node = curr[0];\n            double dist = curr[1];\n            \n            if (node == repairPoint[0]) {\n                return dist;\n            }\n            \n            if (dist > distances.getOrDefault(node, Double.MAX_VALUE)) {\n                continue;\n            }\n            \n            for (int[] neighbor : graph.getOrDefault(node, new ArrayList<>())) {\n                int nextNode = neighbor[0];\n                double newDist = dist + neighbor[1];\n                \n                if (newDist < distances.getOrDefault(nextNode, Double.MAX_VALUE)) {\n                    distances.put(nextNode, newDist);\n                    pq.offer(new int[]{nextNode, newDist});\n                }\n            }\n        }\n        \n        return -1;\n    }\n    \n    private boolean isReachable(Map<Integer, List<int[]>> graph, int start, int end, Set<Integer> visited) {\n        if (start == end) {\n            return true;\n        }\n        \n        visited.add(start);\n        \n        for (int[] neighbor : graph.getOrDefault(start, new ArrayList<>())) {\n            if (!visited.contains(neighbor[0])) {\n                if (isReachable(graph, neighbor[0], end, visited)) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n}",
    "timestamp": "2025-08-05 21:37:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <limits.h>\n\n#define MAX_NODES 1000\n#define INF 1e9\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint n, m;\nPoint source, repair;\nPoint segments[MAX_NODES];\nPoint valves[MAX_NODES];\n\ndouble distance(Point a, Point b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\nint is_line_intersect(Point p1, Point p2, Point p3, Point p4) {\n    double d1 = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x));\n    double d2 = ((p4.x - p3.x) * (p2.y - p3.y) - (p4.y - p3.y) * (p2.x - p3.x));\n    double d3 = ((p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x));\n    double d4 = ((p2.x - p1.x) * (p4.y - p1.y) - (p2.y - p1.y) * (p4.x - p1.x));\n\n    if (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) && \n        ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) {\n        return 1;\n    }\n    return 0;\n}\n\ndouble solve() {\n    double min_length = INF;\n\n    for (int i = 0; i < m; i++) {\n        int can_stop = 1;\n        double total_length = 0;\n\n        for (int j = 0; j < n; j++) {\n            if (is_line_intersect(source, valves[i], segments[j], repair)) {\n                can_stop = 0;\n                break;\n            }\n        }\n\n        if (can_stop) {\n            total_length = distance(source, valves[i]) + distance(valves[i], repair);\n            min_length = fmin(min_length, total_length);\n        }\n    }\n\n    return min_length == INF ? -1 : min_length;\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    \n    scanf(\"%d %d\", &source.x, &source.y);\n    scanf(\"%d %d\", &repair.x, &repair.y);\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &segments[i].x, &segments[i].y);\n    }\n\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &valves[i].x, &valves[i].y);\n    }\n\n    double result = solve();\n    printf(\"%.2f\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:37:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <limits>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    double minimumPipeLength(vector<vector<int>>& pipes, \n                              vector<vector<int>>& valves, \n                              vector<int>& source, \n                              vector<int>& repair) {\n        int n = pipes.size(), m = valves.size();\n        \n        // Build graph\n        vector<vector<pair<int, double>>> graph(n + m + 2);\n        for (int i = 0; i < pipes.size(); i++) {\n            double dist = sqrt(pow(pipes[i][0] - pipes[i][2], 2) + \n                               pow(pipes[i][1] - pipes[i][3], 2));\n            graph[i].push_back({n + m, dist});\n            graph[n + m].push_back({i, dist});\n        }\n        \n        // Connect valves to pipes\n        for (int i = 0; i < valves.size(); i++) {\n            for (int j = 0; j < pipes.size(); j++) {\n                double distToPipe = distanceToLine(valves[i][0], valves[i][1], \n                                                   pipes[j][0], pipes[j][1], \n                                                   pipes[j][2], pipes[j][3]);\n                if (distToPipe < 1e-6) {\n                    graph[n + i].push_back({j, 0});\n                    graph[j].push_back({n + i, 0});\n                }\n            }\n        }\n        \n        // Find shortest path to repair point\n        vector<double> dist(n + m + 2, numeric_limits<double>::max());\n        priority_queue<pair<double, int>, vector<pair<double, int>>, greater<>> pq;\n        \n        // Find source pipe/valve index\n        int sourceIndex = -1;\n        for (int i = 0; i < pipes.size(); i++) {\n            if (onLine(pipes[i][0], pipes[i][1], pipes[i][2], pipes[i][3], source[0], source[1])) {\n                sourceIndex = i;\n                break;\n            }\n        }\n        \n        if (sourceIndex == -1) {\n            for (int i = 0; i < valves.size(); i++) {\n                if (onLine(valves[i][0], valves[i][1], valves[i][0], valves[i][1], source[0], source[1])) {\n                    sourceIndex = n + i;\n                    break;\n                }\n            }\n        }\n        \n        if (sourceIndex == -1) return -1;\n        \n        dist[sourceIndex] = 0;\n        pq.push({0, sourceIndex});\n        \n        while (!pq.empty()) {\n            auto [d, u] = pq.top();\n            pq.pop();\n            \n            if (d > dist[u]) continue;\n            \n            for (auto [v, w] : graph[u]) {\n                if (dist[u] + w < dist[v]) {\n                    dist[v] = dist[u] + w;\n                    pq.push({dist[v], v});\n                }\n            }\n        }\n        \n        // Find repair pipe/valve index\n        int repairIndex = -1;\n        for (int i = 0; i < pipes.size(); i++) {\n            if (onLine(pipes[i][0], pipes[i][1], pipes[i][2], pipes[i][3], repair[0], repair[1])) {\n                repairIndex = i;\n                break;\n            }\n        }\n        \n        if (repairIndex == -1) {\n            for (int i = 0; i < valves.size(); i++) {\n                if (onLine(valves[i][0], valves[i][1], valves[i][0], valves[i][1], repair[0], repair[1])) {\n                    repairIndex = n + i;\n                    break;\n                }\n            }\n        }\n        \n        if (repairIndex == -1) return -1;\n        \n        return dist[repairIndex] == numeric_limits<double>::max() ? -1 : dist[repairIndex];\n    }\n    \nprivate:\n    bool onLine(int x1, int y1, int x2, int y2, int px, int py) {\n        return abs((y2 - y1) * px - (x2 - x1) * py + x2 * y1 - y2 * x1) / \n               sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2)) < 1e-6;\n    }\n    \n    double distanceToLine(int px, int py, int x1, int y1, int x2, int y2) {\n        double numerator = abs((y2 - y1) * px - (x2 - x1) * py + x2 * y1 - y2 * x1);\n        double denominator = sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2));\n        return denominator > 0 ? numerator / denominator : 0;\n    }\n};",
    "timestamp": "2025-08-05 21:38:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\ndef euclidean_distance(x1, y1, x2, y2):\n    return math.sqrt((x1 - x2)**2 + (y1 - y2)**2)\n\ndef pipe_network(n, pipe_segments, stop_valves, source, repairing_point):\n    graph = defaultdict(list)\n    \n    for x1, y1, x2, y2 in pipe_segments:\n        d = euclidean_distance(x1, y1, x2, y2)\n        graph[(x1, y1)].append(((x2, y2), d))\n        graph[(x2, y2)].append(((x1, y1), d))\n    \n    def dijkstra(source, target):\n        queue = [(0, source)]\n        visited = set()\n        distances = {source: 0}\n        \n        while queue:\n            cur_dist, current = heappop(queue)\n            \n            if current in visited:\n                continue\n            visited.add(current)\n            \n            if current == target:\n                return cur_dist\n            \n            for neighbor, weight in graph[current]:\n                if neighbor in stop_valves:\n                    continue\n                new_distance = cur_dist + weight\n                if neighbor not in distances or new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    heappush(queue, (new_distance, neighbor))\n        \n        return float('inf')\n    \n    possible_distance = dijkstra(source, repairing_point)\n    return possible_distance if possible_distance != float('inf') else -1\n\n# Example usage:\nn = 5\npipe_segments = [(0, 0, 1, 1), (1, 1, 2, 2), (2, 2, 3, 3), (3, 3, 4, 4)]\nstop_valves = {(1, 1), (4, 4)}\nsource = (0, 0)\nrepairing_point = (3, 3)\nprint(pipe_network(n, pipe_segments, stop_valves, source, repairing_point))",
    "timestamp": "2025-08-13 07:09:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class WaterPipeNetwork {\n\n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static class Pipe {\n        Point start, end;\n        Pipe(Point start, Point end) {\n            this.start = start;\n            this.end = end;\n        }\n    }\n\n    static class Valve {\n        Point location;\n        Valve(Point location) {\n            this.location = location;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Example data setup (replace with actual input parsing)\n        Point source = new Point(0, 0);\n        Point repairingPoint = new Point(5, 5);\n        List<Pipe> pipes = Arrays.asList(\n                new Pipe(new Point(0, 0), new Point(2, 2)),\n                new Pipe(new Point(2, 2), new Point(5, 5)),\n                new Pipe(new Point(2, 2), new Point(5, 0))\n        );\n        List<Valve> valves = Arrays.asList(\n                new Valve(new Point(2, 2))\n        );\n\n        int result = minimalPipeLengthToStop(source, repairingPoint, pipes, valves);\n        System.out.println(result);\n    }\n\n    private static int minimalPipeLengthToStop(Point source, Point repairingPoint, List<Pipe> pipes, List<Valve> valves) {\n        Map<Point, List<Pipe>> graph = buildGraph(pipes);\n        Set<Point> visited = new HashSet<>();\n        \n        for (Valve valve : valves) {\n            breadthFirstSearch(valve.location, repairingPoint, graph, visited);\n        }\n\n        if (!visited.contains(repairingPoint)) {\n            return calculatePipeLength(pipes);\n        }\n        return -1;\n    }\n\n    private static void breadthFirstSearch(Point start, Point target, Map<Point, List<Pipe>> graph, Set<Point> visited) {\n        Queue<Point> queue = new LinkedList<>();\n        queue.add(start);\n        visited.add(start);\n\n        while (!queue.isEmpty()) {\n            Point current = queue.poll();\n\n            if (current.equals(target)) {\n                continue;\n            }\n\n            for (Pipe pipe : graph.getOrDefault(current, Collections.emptyList())) {\n                Point neighbor = pipe.start.equals(current) ? pipe.end : pipe.start;\n                if (!visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    queue.add(neighbor);\n                }\n            }\n        }\n    }\n\n    private static Map<Point, List<Pipe>> buildGraph(List<Pipe> pipes) {\n        Map<Point, List<Pipe>> graph = new HashMap<>();\n\n        for (Pipe pipe : pipes) {\n            graph.computeIfAbsent(pipe.start, k -> new ArrayList<>()).add(pipe);\n            graph.computeIfAbsent(pipe.end, k -> new ArrayList<>()).add(pipe);\n        }\n\n        return graph;\n    }\n\n    private static int calculatePipeLength(List<Pipe> pipes) {\n        int totalLength = 0;\n        for (Pipe pipe : pipes) {\n            totalLength += distance(pipe.start, pipe.end);\n        }\n        return totalLength;\n    }\n\n    private static int distance(Point a, Point b) {\n        return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);\n    }\n}",
    "timestamp": "2025-08-13 07:09:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_POINTS 100\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point start, end;\n    int length;\n} Pipe;\n\nint n, m;\nPipe pipes[MAX_POINTS];\nPoint valves[MAX_POINTS];\nPoint source, repairing;\nint visited[MAX_POINTS];\nint minLength = INT_MAX;\n\nint distance(Point a, Point b) {\n    return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nvoid dfs(Point current, int totalLength) {\n    if (current.x == repairing.x && current.y == repairing.y) {\n        if (totalLength < minLength) {\n            minLength = totalLength;\n        }\n        return;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        Pipe pipe = pipes[i];\n        if (visited[i]) continue;\n        \n        if ((current.x == pipe.start.x && current.y == pipe.start.y) ||\n            (current.x == pipe.end.x && current.y == pipe.end.y)) {\n            Point next = (current.x == pipe.start.x && current.y == pipe.start.y) ? pipe.end : pipe.start;\n            visited[i] = 1;\n            dfs(next, totalLength + pipe.length);\n            visited[i] = 0;\n        }\n    }\n\n    for (int j = 0; j < m; j++) {\n        Point valve = valves[j];\n        if (current.x == valve.x && current.y == valve.y) continue;\n        dfs(valve, totalLength);\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    scanf(\"%d %d\", &source.x, &source.y);\n    scanf(\"%d %d\", &repairing.x, &repairing.y);\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d %d\", &pipes[i].start.x, &pipes[i].start.y, &pipes[i].end.x, &pipes[i].end.y);\n        pipes[i].length = distance(pipes[i].start, pipes[i].end);\n    }\n    \n    for (int j = 0; j < m; j++) {\n        scanf(\"%d %d\", &valves[j].x, &valves[j].y);\n    }\n\n    dfs(source, 0);\n    printf(\"%d\\n\", minLength == INT_MAX ? -1 : minLength);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:09:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nimport heapq\nimport math\n\ndef min_pipe_length(segments: List[Tuple[int, int, int, int]], \n                    valves: List[Tuple[int, int]], \n                    source: Tuple[int, int], \n                    repair_point: Tuple[int, int]) -> int:\n    \n    def distance(p1, p2):\n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n    \n    def point_on_segment(point, seg):\n        x1, y1, x2, y2 = seg\n        px, py = point\n        \n        # Check if point is on the line segment\n        cross_product = (py - y1) * (x2 - x1) - (px - x1) * (y2 - y1)\n        if abs(cross_product) > 1e-9:\n            return False\n        \n        # Check if point is within segment bounds\n        dot_product = (px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)\n        length_squared = (x2 - x1)**2 + (y2 - y1)**2\n        \n        return 0 <= dot_product <= length_squared\n    \n    # Build graph of connections\n    graph = {}\n    \n    # Add valves and source/repair to graph\n    all_points = valves + [source, repair_point]\n    for point in all_points:\n        graph[point] = []\n    \n    # Connect points via pipe segments\n    for seg in segments:\n        x1, y1, x2, y2 = seg\n        p1, p2 = (x1, y1), (x2, y2)\n        \n        for point in all_points:\n            if point_on_segment(point, seg):\n                graph[point].append((p1, distance(point, p1)))\n                graph[point].append((p2, distance(point, p2)))\n    \n    # Dijkstra's algorithm to find minimal pipe length\n    def dijkstra(start, end):\n        distances = {p: float('inf') for p in graph}\n        distances[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            curr_dist, curr_point = heapq.heappop(pq)\n            \n            if curr_point == end:\n                return curr_dist\n            \n            if curr_dist > distances[curr_point]:\n                continue\n            \n            for neighbor, weight in graph[curr_point]:\n                dist = curr_dist + weight\n                if dist < distances[neighbor]:\n                    distances[neighbor] = dist\n                    heapq.heappush(pq, (dist, neighbor))\n        \n        return -1\n    \n    # Check reachability from source to repair point\n    min_length = dijkstra(source, repair_point)\n    return min_length",
    "timestamp": "2025-08-13 07:10:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef minimal_pipe_length_to_stop(source, repairing_point, pipes, valves):\n    graph = {}\n    points = set()\n    points.add(source)\n    points.add(repairing_point)\n    for pipe in pipes:\n        points.add(pipe[0])\n        points.add(pipe[1])\n    for valve in valves:\n        points.add(valve)\n    \n    point_list = list(points)\n    point_to_index = {point: idx for idx, point in enumerate(point_list)}\n    n = len(point_list)\n    \n    adj = [[] for _ in range(n)]\n    for pipe in pipes:\n        u, v, length = pipe\n        u_idx = point_to_index[u]\n        v_idx = point_to_index[v]\n        adj[u_idx].append((v_idx, length))\n        adj[v_idx].append((u_idx, length))\n    \n    src_idx = point_to_index[source]\n    repair_idx = point_to_index[repairing_point]\n    \n    heap = []\n    heapq.heappush(heap, (0, src_idx))\n    dist = [float('inf')] * n\n    dist[src_idx] = 0\n    \n    while heap:\n        current_dist, u = heapq.heappop(heap)\n        if u == repair_idx:\n            break\n        if current_dist > dist[u]:\n            continue\n        for v, length in adj[u]:\n            if point_list[v] in valves and v != repair_idx:\n                continue\n            if dist[v] > dist[u] + length:\n                dist[v] = dist[u] + length\n                heapq.heappush(heap, (dist[v], v))\n    \n    if dist[repair_idx] == float('inf'):\n        return -1\n    \n    heap = []\n    heapq.heappush(heap, (0, repair_idx))\n    dist_reverse = [float('inf')] * n\n    dist_reverse[repair_idx] = 0\n    \n    while heap:\n        current_dist, u = heapq.heappop(heap)\n        if current_dist > dist_reverse[u]:\n            continue\n        for v, length in adj[u]:\n            if point_list[v] in valves and v != src_idx:\n                continue\n            if dist_reverse[v] > dist_reverse[u] + length:\n                dist_reverse[v] = dist_reverse[u] + length\n                heapq.heappush(heap, (dist_reverse[v], v))\n    \n    critical_pipes = []\n    for pipe in pipes:\n        u, v, length = pipe\n        u_idx = point_to_index[u]\n        v_idx = point_to_index[v]\n        if dist[u_idx] + length + dist_reverse[v_idx] == dist[repair_idx] or dist[v_idx] + length + dist_reverse[u_idx] == dist[repair_idx]:\n            critical_pipes.append(length)\n    \n    if not critical_pipes:\n        return -1\n    \n    return min(critical_pipes)",
    "timestamp": "2025-08-13 07:10:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <limits>\n\nstruct Point {\n    int x, y;\n};\n\nstruct Pipe {\n    Point start, end;\n    double length;\n\n    Pipe(Point s, Point e) : start(s), end(e) {\n        length = std::sqrt((s.x - e.x) * (s.x - e.x) + (s.y - e.y) * (s.y - e.y));\n    }\n};\n\nbool isReachable(Point a, Point b, std::vector<Point>& valves) {\n    for (const auto& valve : valves) {\n        if ((a.x == valve.x && a.y == valve.y) || (b.x == valve.x && b.y == valve.y)) {\n            return false;\n        }\n    }\n    return true;\n}\n\ndouble minimizePipeLength(std::vector<Pipe>& pipes, Point source, Point repairingPoint, std::vector<Point>& valves) {\n    std::priority_queue<std::pair<double, Point>, std::vector<std::pair<double, Point>>, std::greater<>> pq;\n    std::unordered_map<int, double> minDistance;\n    std::unordered_map<int, Point> parent;\n    \n    minDistance[source.x * 1000 + source.y] = 0.0;\n    pq.push({0.0, source});\n    \n    while (!pq.empty()) {\n        auto [currLength, currPoint] = pq.top(); pq.pop();\n        int currKey = currPoint.x * 1000 + currPoint.y;\n        \n        if (currPoint.x == repairingPoint.x && currPoint.y == repairingPoint.y) {\n            return currLength;\n        }\n        \n        for (const auto& pipe : pipes) {\n            int nextKey = pipe.end.x * 1000 + pipe.end.y;\n            if (!isReachable(currPoint, pipe.end, valves)) continue;\n            \n            double newLength = currLength + pipe.length;\n            if (newLength < minDistance[nextKey]) {\n                minDistance[nextKey] = newLength;\n                pq.push({newLength, pipe.end});\n                parent[nextKey] = currPoint;\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<Pipe> pipes;\n    std::vector<Point> valves;\n    Point source, repairingPoint;\n    \n    for (int i = 0; i < n; ++i) {\n        int xs, ys, xe, ye;\n        std::cin >> xs >> ys >> xe >> ye;\n        pipes.emplace_back(Point{xs, ys}, Point{xe, ye});\n    }\n\n    int v;\n    std::cin >> v;\n    for (int i = 0; i < v; ++i) {\n        int xv, yv;\n        std::cin >> xv >> yv;\n        valves.emplace_back(Point{xv, yv});\n    }\n\n    int xs, ys, xr, yr;\n    std::cin >> xs >> ys >> xr >> yr;\n    source = Point{xs, ys};\n    repairingPoint = Point{xr, yr};\n\n    double minLengthPipes = minimizePipeLength(pipes, source, repairingPoint, valves);\n    std::cout << minLengthPipes << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:36:17"
  }
]