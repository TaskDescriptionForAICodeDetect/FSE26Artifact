[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n\t ps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<pair<int, double> > > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++){\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n\tls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n      sort(ls.begin(),ls.end());\n      for(int j=0;j+1<(int)ls.size();j++){\n\tint a=ls[j].second,b=ls[j+1].second;\n\tG[a].emplace_back(b,abs(ps[a]-ps[b]));\n\tG[b].emplace_back(a,abs(ps[a]-ps[b]));\n      }\n    }\n  }\n  for(int i=0;i<(int)ps.size();i++){\n    sort(G[i].begin(),G[i].end());\n    G[i].erase(unique(G[i].begin(),G[i].end(),\n\t\t      [](auto a,auto b){return a.first==b.first;}),\n\t       G[i].end());\n  }\n  return G;\n}\n\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  vector<Segment> ss(n);\n  Polygon ps(m);\n  for(int i=0;i<n;i++) cin>>ss[i];\n  for(int i=0;i<m;i++) cin>>ps[i];\n  map<Point, int> mp;\n  for(int i=0;i<m;i++) mp[ps[i]]=i;\n  Point s,g;\n  cin>>s>>g;\n  ps.emplace_back(s);\n  ps.emplace_back(g);\n\n  auto G=segmentArrangement(ss,ps);\n  if(0){\n    int k=G.size();\n    for(int i=0;i<k;i++){\n      cout<<i<<\":\"<<ps[i]<<endl;\n      for(auto p:G[i]) cout<<p.first<<\" \"<<p.second<<endl;\n    }\n  }\n\n  double ans=0,tmp=0;\n  for(int i=0;i<n;i++) ans+=abs(ss[i].p1-ss[i].p2);\n\n  vector<int> used(G.size(),0);\n  queue<int> q;\n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==g) {used[i]=1;q.emplace(i);}\n\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    if(ps[v]==s){\n      cout<<(int)-1<<endl;\n      return 0;\n    }\n    if(mp.count(ps[v])) continue;\n    for(auto &e:G[v]){\n      int u=e.first;\n      if(!used[u]){\n\tused[u]=1;\n\tq.emplace(u);\n      }\n    }\n  }\n  //cout<<ans<<endl;\n  //for(int i=0;i<(int)G.size();i++) cout<<i<<\":\"<<used[i]<<endl;\n  \n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==s) q.emplace(i);\n  \n  while(!q.empty()){\n    int v=q.front();q.pop();\n    //cout<<v<<endl;\n    for(auto &e:G[v]){\n      int u=e.first;\n      double &c=e.second;\n      if(used[v]&&used[u]) continue;\n      if(c==0) continue;\n      tmp+=c;c=0;\n      q.emplace(u);\n    }\n  }\n  tmp/=2;\n  \n  cout<<ans-tmp<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nbool equals(double a, double b) {\n  return abs(a - b) < eps;\n}\n\nnamespace std {\n  bool operator < (const P &a, const P &b) {\n    if(!equals(a.real(), b.real())) return a.real() < b.real();\n    if(!equals(a.imag(), b.imag())) return a.imag() < b.imag();\n    return false;\n  }\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nbool isParallel(P a, P b) {\n  return equals(cross(a, b), 0.0);\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a, b) > eps) return 1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a, b) < -eps) return 2;\n  if(norm(b) - norm(a) > eps) return -2;\n  return 0;\n}\n\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t   ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1) / cross(b, a);\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nstruct Edge {\n  int to; double w;\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nint getId(P p, map<P, int> &m) {\n  if(!m.count(p)) {\n    int tmp = m.size();\n    m[p] = tmp;\n  }\n  return m[p];\n}\n\nint getId(P p, map<P, int> &m, map<int, P> &r) {\n  r[getId(p, m)] = p;\n  return m[p];\n}\n\nvoid dfs(int v, const Graph &g, vector<int> &vis) {\n  vis[v] = 1;\n  for(int i = 0; i < g[v].size(); ++i) {\n    int nv = g[v][i].to;\n    if(vis[nv]) continue;\n    dfs(nv, g, vis);\n  }\n}\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  vector<P> X(N), Y(N), Z(M);\n  P src, dst;\n  map<P, int> id;\n  map<int, P> rid;\n\n  for(int i = 0; i < N; ++i) {\n    cin >> X[i].real() >> X[i].imag() >> Y[i].real() >> Y[i].imag();\n    getId(X[i], id, rid);\n    getId(Y[i], id, rid);\n  }\n  for(int i = 0; i < M; ++i) {\n    cin >> Z[i].real() >> Z[i].imag();\n    getId(Z[i], id, rid);\n  }\n  cin >> src.real() >> src.imag();\n  getId(src, id, rid);\n  cin >> dst.real() >> dst.imag();\n  getId(dst, id, rid);\n\n  for(int i = 0; i < N; ++i) {\n    for(int j = i+1; j < N; ++j) {\n      if(isParallel(X[i] - Y[i], X[j] - Y[j])) {\n\t//\n      } else if(isIntersect(X[i], Y[i], X[j], Y[j])) {\n\tP p = getCrossP(X[i], Y[i], X[j], Y[j]);\n\tgetId(p, id, rid);\n      }\n    }\n  }\n\n  int V = id.size();\n  Graph G(V);\n\n  for(int i = 0; i < N; ++i) {\n    set<P> s;\n    vector<pair<double, P> > v;\n    s.insert(X[i]);\n    s.insert(Y[i]);\n    v.push_back(make_pair(0.0, X[i]));\n    v.push_back(make_pair(norm(Y[i] - X[i]), Y[i]));\n    for(int j = 0; j < N; ++j) {\n      if(isParallel(X[i] - Y[i], X[j] - Y[j])) {\n\t//\n      } else if(isIntersect(X[i], Y[i], X[j], Y[j])) {\n\tP p = getCrossP(X[i], Y[i], X[j], Y[j]);\n\tif(s.count(p)) continue;\n\ts.insert(p);\n\tv.push_back(make_pair(norm(p - X[i]), p));\n      }\n    }\n    for(int j = 0; j < M; ++j) {\n      if(ccw(X[i], Y[i], Z[j]) == 0 && !s.count(Z[j])) {\n\ts.insert(Z[j]);\n\tv.push_back(make_pair(norm(Z[j] - X[i]), Z[j]));\n      }\n    }\n\n    if(ccw(X[i], Y[i], src) == 0 && !s.count(src)) {\n      s.insert(src);\n      v.push_back(make_pair(norm(src - X[i]), src));\n    }\n    if(ccw(X[i], Y[i], dst) == 0 && !s.count(dst)) {\n      s.insert(dst);\n      v.push_back(make_pair(norm(dst - X[i]), dst));\n    }\n    sort(v.begin(), v.end());\n    for(int j = 0; j+1 < v.size(); ++j) {\n      int a = getId(v[j].second, id);\n      int b = getId(v[j+1].second, id);\n      double w = abs(v[j].second - v[j+1].second);\n      G[a].push_back((Edge){b, w});\n      G[b].push_back((Edge){a, w});\n    }\n  }\n  if(1){\n    vector<int> vis(V);\n    int res = 0;\n    for(int i = 0; i < V; ++i) {\n      if(!vis[i]) {\n\tdfs(i, G, vis);\n\t++res;\n      }\n    }\n    assert(res == 1);\n  }\n\n  if(0) {\n  cout << V << endl;\n  for(int i = 0; i < V; ++i) {\n    cout << rid[i] << \":\";\n    for(int j = 0; j < G[i].size(); ++j) {\n      if(j) cout << \",\";\n      cout << rid[G[i][j].to];\n    }\n    cout << endl;\n  }\n  }\n\n  try {\n    vector<int> F(V), F2(V);\n    for(int i = 0; i < M; ++i) {\n      F[getId(Z[i], id)] = 1;\n    }\n    set<pair<int, int> > vis;\n    queue<int> que;\n    \n    que.push(getId(dst, id));\n    int isrc = getId(src, id);\n    while(que.size()) {\n      int v = que.front();\n      que.pop();\n      for(int i = 0; i < G[v].size(); ++i) {\n\tint nv = G[v][i].to;\n\tif(nv == isrc) throw 0;\n\tif(vis.count(make_pair(nv, v))) continue;\n\tvis.insert(make_pair(nv, v));\n\tvis.insert(make_pair(v, nv));\n\tif(F[nv]) {\n\t  F2[nv] = 1;\n\t  continue;\n\t}\n\tque.push(nv);\n      }\n    }\n    double res = 0;\n    que.push(isrc);\n    while(que.size()) {\n      int v = que.front();\n      que.pop();\n      for(int i = 0; i < G[v].size(); ++i) {\n\tint nv = G[v][i].to;\n\tif(vis.count(make_pair(nv, v))) continue;\n\tvis.insert(make_pair(nv, v));\n\tvis.insert(make_pair(v, nv));\n\tres += G[v][i].w;\n\tif(F2[nv]) continue;\n\tque.push(nv);\n      }\n    }\n    res = -res;\n    for(int i = 0; i < N; ++i) {\n      res += abs(X[i] - Y[i]);\n    }\n    printf(\"%.10f\\n\", res);\n  } catch(...) {\n    printf(\"-1\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define MAX 100010\n#define eps (1e-6)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool isParallel(Segment s,Segment t){\n    return equals(cross(s.p1-s.p2,t.p1-t.p2),0.0);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\ntypedef vector<vector<pair<int,double> > > Graph;\n\nGraph SegmentArrangement(vector<Segment> v,vector<Point> &ps){\n  for(int i=0;i<v.size();i++){\n    ps.push_back(v[i].p1);\n    ps.push_back(v[i].p2);\n    for(int j=i+1;j<v.size();j++){\n      if(intersect(v[i],v[j]))ps.push_back(getCrossPointLL(v[i],v[j]));\n    }\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n  Graph g(ps.size());\n  for(int i=0;i<v.size();i++){\n    vector<pair<double,int> > list;\n    for(int j=0;j<ps.size();j++)\n      if(ccw(v[i].p1,v[i].p2,ps[j])==0)\n        list.push_back(mp(norm(v[i].p1-ps[j]),j));\n    sort(list.begin(),list.end());\n    for(int j=0;j<list.size()-1;j++){\n      int a=list[j].s,b=list[j+1].s;\n      g[a].push_back(mp(b,abs(ps[b]-ps[a])));\n      g[b].push_back(mp(a,abs(ps[a]-ps[b])));\n    }\n  }\n  return g;\n}\n\nint n,m;\nvector<Segment> vs;\nvector<Point> vp;\nset<Point> st;\nPoint s,t;\nint c,d;\nGraph g;\nbool checked[MAX]={};\nbool visited[MAX]={};\nbool valve[MAX]={};\n\nvoid dfs(int v){ \n  checked[v]=true;\n  if(valve[v])return;\n  for(int i=0;i<g[v].size();i++){\n    pair<int,double> next=g[v][i];\n    if(!checked[next.f]){\n      dfs(next.f);\n    }\n  }\n  return;\n}\n\ndouble bfs(int v){\n  double res=0.0;\n  queue<int> q;\n  q.push(v);\n  while(q.size()){\n    int u=q.front();\n    q.pop();\n    if(visited[u])continue;\n    visited[u]=true;\n    for(int i=0;i<g[u].size();i++){\n      pair<int,double> next=g[u][i];\n      if(checked[next.f])res+=next.s;\n      else if(!visited[next.f]){\n        res+=next.s;\n        q.push(next.f);\n      }\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    vs.push_back(Segment(Point(a,b),Point(c,d)));\n  }\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    vp.push_back(Point(a,b));\n    st.insert(Point(a,b));\n  }\n  cin>>s.x>>s.y>>t.x>>t.y;\n  vp.push_back(s);\n  vp.push_back(t);\n  g=SegmentArrangement(vs,vp);\n  for(int i=0;i<vp.size();i++){\n    if(st.find(vp[i])!=st.end())valve[i]=true;\n    if(vp[i]==s)c=i;\n    if(vp[i]==t)d=i;\n  }\n  dfs(d);\n  if(checked[c])cout<<-1<<endl;\n  else {\n    double ans=0.0;\n    for(int i=0;i<g.size();i++){\n      for(int j=0;j<g[i].size();j++)ans+=g[i][j].s/2.0;\n    }\n    ans-=bfs(c);\n    printf(\"%.10f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct segment{ point<T> a,b; };\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<double> &S,const point<double> &p){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\npoint<double> get_intersect(const segment<double> &S1,const segment<double> &S2){\n\tdouble a1=cross(S1.b-S1.a,S2.b-S2.a);\n\tdouble a2=cross(S1.b-S1.a,S1.b-S2.a);\n\tif(abs(a1)<EPS){\n\t\tif(cover(S1,S2.a)) return S2.a;\n\t\tif(cover(S1,S2.b)) return S2.b;\n\t\tif(cover(S2,S1.a)) return S1.a;\n\t\treturn S1.b;\n\t}\n\treturn S2.a+a2/a1*(S2.b-S2.a);\n}\n\n// 追加で頂点集合を指定できるように書き換え\nvoid arrangement(const vector< segment<double> > &S,const vector< point<double> > &plus,vector< point<double> > &P,vector<int> *G){\n\tint n=S.size();\n\tP=plus;\n\trep(i,n){\n\t\tP.push_back(S[i].a);\n\t\tP.push_back(S[i].b);\n\t\trep(j,i) if(intersect(S[i],S[j])) P.push_back(get_intersect(S[i],S[j]));\n\t}\n\tsort(P.begin(),P.end());\n\tP.erase(unique(P.begin(),P.end()),P.end());\n\n\trep(i,n){\n\t\tvector<int> on;\n\t\trep(u,P.size()) if(cover(S[i],P[u])) on.push_back(u);\n\t\trep(j,(int)on.size()-1){\n\t\t\tint u=on[j],v=on[j+1];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tvector< segment<double> > pipe(n);\n\trep(i,n) scanf(\"%lf%lf%lf%lf\",&pipe[i].a.x,&pipe[i].a.y,&pipe[i].b.x,&pipe[i].b.y);\n\tvector< point<double> > stop(m);\n\trep(i,m) scanf(\"%lf%lf\",&stop[i].x,&stop[i].y);\n\tpoint<double> s,t;\n\tscanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&t.x,&t.y);\n\n\t// 追加の頂点集合\n\tvector< point<double> > plus=stop;\n\tplus.push_back(s);\n\tplus.push_back(t);\n\n\tvector< point<double> > P;\n\tstatic vector<int> G[100000];\n\tarrangement(pipe,plus,P,G);\n\n\tint N=P.size();\n\tstatic bool isstop[100000];\n\trep(i,m) rep(u,N) if(P[u]==stop[i]) isstop[u]=true;\n\n\tint s_id=find(P.begin(),P.end(),s)-P.begin();\n\tint t_id=find(P.begin(),P.end(),t)-P.begin();\n\n\t// t から stop をまたがずに行ける場所を見つける\n\tstatic bool vis[100000];\n\tvis[t_id]=true;\n\tqueue<int> Q; Q.push(t_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=true;\n\t\t\t\tif(!isstop[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(vis[s_id]){ puts(\"-1\"); return 0; }\n\n\tdouble ans=0;\n\trep(i,n) ans+=dist(pipe[i].a,pipe[i].b);\n\n\t// s から vis を通らずに行ける場所を見つける\n\tstatic bool vis2[100000];\n\tvis2[s_id]=true;\n\tQ.push(s_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v]=true;\n\t\t\t\tif(!vis[v]) Q.push(v);\n\t\t\t}\n\t\t\tif(vis[v]) ans-=dist(P[u],P[v]);   // 一回カウントされる\n\t\t\telse       ans-=dist(P[u],P[v])/2; // 二回カウントされる\n\t\t}\n\t}\n\tprintf(\"%.9f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-7;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a,b;\n\toperator line<T>()const{ return (line<T>){a,b}; }\n};\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<double> &S,const point<double> &p){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\n// 追加で頂点集合を指定できるように書き換え\nvoid arrangement(const vector< segment<double> > &S,const vector< point<double> > &plus,vector< point<double> > &P,vector<int> *G){\n\tint n=S.size();\n\tP=plus;\n\trep(i,n){\n\t\tP.push_back(S[i].a);\n\t\tP.push_back(S[i].b);\n\t\trep(j,i) if(intersect(S[i],S[j])) P.push_back(get_intersect(S[i],S[j]));\n\t}\n\tsort(P.begin(),P.end());\n\tP.erase(unique(P.begin(),P.end()),P.end());\n\n\trep(i,n){\n\t\tvector<int> on;\n\t\trep(u,P.size()) if(cover(S[i],P[u])) on.push_back(u);\n\t\trep(j,(int)on.size()-1){\n\t\t\tint u=on[j],v=on[j+1];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tvector< segment<double> > pipe(n);\n\trep(i,n) scanf(\"%lf%lf%lf%lf\",&pipe[i].a.x,&pipe[i].a.y,&pipe[i].b.x,&pipe[i].b.y);\n\tvector< point<double> > stop(m);\n\trep(i,m) scanf(\"%lf%lf\",&stop[i].x,&stop[i].y);\n\tpoint<double> s,t;\n\tscanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&t.x,&t.y);\n\n\t// 追加の頂点集合\n\tvector< point<double> > plus=stop;\n\tplus.push_back(s);\n\tplus.push_back(t);\n\n\tvector< point<double> > P;\n\tstatic vector<int> G[100000];\n\tarrangement(pipe,plus,P,G);\n\n\tint N=P.size();\n\tstatic bool isstop[100000];\n\trep(i,m) rep(u,N) if(P[u]==stop[i]) isstop[u]=true;\n\n\tint s_id=find(P.begin(),P.end(),s)-P.begin();\n\tint t_id=find(P.begin(),P.end(),t)-P.begin();\n\n\t// t から stop をまたがずに行ける場所を見つける\n\tstatic bool vis[100000];\n\tvis[t_id]=true;\n\tqueue<int> Q; Q.push(t_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=true;\n\t\t\t\tif(!isstop[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(vis[s_id]){ puts(\"-1\"); return 0; }\n\n\t// s から vis を通らずに行ける場所を見つける\n\tstatic bool vis2[100000];\n\tvis2[s_id]=true;\n\tQ.push(s_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v]=true;\n\t\t\t\tif(!vis[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans=0;\n\trep(i,n) ans+=dist(pipe[i].a,pipe[i].b);\n\trep(u,N) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tif(u<v && vis2[u] && vis2[v] && !(vis[u] && vis[v])) ans-=dist(P[u],P[v]);\n\t}\n\tprintf(\"%.9f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define double long double\n\n// using ll = long long;\nusing ll = __int128;\n\nll ABS(ll x){\n    if(x<0) return -x;\n    return x;\n}\n\nusing F = pair<ll,ll>;\nusing Point = pair<F,F>;\nusing Line = pair<Point,Point>;\n\n#define X first\n#define Y second\n\nF ADD_F(F p, F q, int m){\n    ll aa = p.fi*q.se + m*q.fi*p.se;\n    ll bb = p.se*q.se;\n\n    ll G = __gcd(ABS(aa),bb);\n    aa /= G;\n    bb /= G;\n    return {aa,bb};\n}\n\nF MUL_F(F p, F q){\n    ll aa = p.fi*q.fi;\n    ll bb = p.se*q.se;\n\n    ll G = __gcd(ABS(aa),bb);\n    aa /= G;\n    bb /= G;\n    return {aa,bb};\n}\n\nint COMP_F(F p, F q){\n    ll res = p.fi*q.se - q.fi*p.se;\n    if(res==0) return 0;\n    if(res<0) return 1; // p<q\n    return -1; // p>q\n}\n\nnamespace std {\n    bool operator<(const Point a, const Point b) {\n        return COMP_F(a.X,b.X)!=0 ? COMP_F(a.X,b.X)==1 : COMP_F(a.Y,b.Y)==1;\n    }\n}\n\nPoint ADD_P(Point a, Point b, int m){\n    return {ADD_F(a.X,b.X,m), ADD_F(a.Y,b.Y,m)};\n}\n\nPoint MUL_P(Point a, F mul){\n    return {MUL_F(a.X,mul), MUL_F(a.Y,mul)};\n}\n\n// 内積　dot(a,b) = |a||b|cosθ\nF dot(Point a, Point b) {\n    return ADD_F( MUL_F(a.X,b.X), MUL_F(a.Y,b.Y), 1);\n}\n\n// 外積　cross(a,b) = |a||b|sinθ\nF cross(Point a, Point b) {\n    return ADD_F( MUL_F(a.X,b.Y), MUL_F(a.Y,b.X), -1);\n}\n\nF norm(Point a){\n    return ADD_F( MUL_F(a.X,a.X), MUL_F(a.Y,a.Y), 1);\n}\n\nint ccw(Point a, Point b, Point c) {\n    b = ADD_P(b,a,-1);\n    c = ADD_P(c,a,-1);\n    if (cross(b,c).fi >  0) return +1;  // counter clockwise\n    if (cross(b,c).fi <  0) return -1;  // clockwise\n    if (dot(b,c).fi   <  0) return +2;  // c--a--b on line\n    if (COMP_F(norm(b),norm(c)) == 1) return -2;  // a--b--c on line or a==b\n    return 0;                          // a--c--b on line or a==c or b==c\n}\n\n// 線分と線分\nbool isecSS(Point a1, Point a2, Point b1, Point b2) {\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n  ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\n\n// 線分と点\nbool isecSP(Point a1, Point a2, Point b) {\n  return !ccw(a1, a2, b);\n}\n\n// 2直線の交点\nPoint crosspointLL(Point a1, Point a2, Point b1, Point b2) {\n    F d1 = cross( ADD_P(b2,b1,-1), ADD_P(b1,a1,-1) );\n    F d2 = cross( ADD_P(b2,b1,-1), ADD_P(a2,a1,-1) );\n    if (d1.fi==0 && d2.fi==0) return a1;  // same line\n    assert(d2.se!=0); // 交点がない\n\n    if(d2.fi<0){\n        d2.fi *= -1;\n        d2.se *= -1;\n    }\n    swap(d2.fi, d2.se);\n\n    F pp = d1;\n    pp = MUL_F(d1,d2);\n\n    return ADD_P(a1, MUL_P(ADD_P(a2,a1,-1), pp), 1);\n}\n\nPoint READ_P(){\n    int x,y;\n    cin >>x >>y;\n    return {{x,1},{y,1}};\n}\n\nusing pi = pair<int,int>;\n\ndouble sq(double x){\n    return x*x;\n}\n\nint main(){\n    int n,m;\n    cin >>n >>m;\n\n    double U = 0;\n    vector<Line> pipe(n);\n    rep(i,n){\n        pipe[i].fi = READ_P();\n        pipe[i].se = READ_P();\n\n        U += sqrt( sq(pipe[i].fi.X.fi - pipe[i].se.X.fi) + sq(pipe[i].fi.Y.fi - pipe[i].se.Y.fi) );\n    }\n\n    vector<Point> valve(m);\n    map<Point,int> v2id;\n    rep(i,m){\n        valve[i] = READ_P();\n        v2id[valve[i]] = i;\n    }\n\n    Point source = READ_P(), repair = READ_P();\n\n    vector<vector<Point>> seg(n);\n    rep(i,n){\n        seg[i].pb(pipe[i].fi);\n        seg[i].pb(pipe[i].se);\n\n        if(isecSP(pipe[i].fi, pipe[i].se, source)) seg[i].pb(source);\n        if(isecSP(pipe[i].fi, pipe[i].se, repair)) seg[i].pb(repair);\n        rep(j,m){\n            if(isecSP(pipe[i].fi, pipe[i].se, valve[j])) seg[i].pb(valve[j]);\n        }\n    }\n\n    map<Point,pi> intersection;\n    rep(i,n)rep(j,i){\n        if(isecSS(pipe[i].fi,pipe[i].se,pipe[j].fi,pipe[j].se)){\n            Point cp = crosspointLL(pipe[i].fi,pipe[i].se,pipe[j].fi,pipe[j].se);\n\n            seg[i].pb(cp);\n            seg[j].pb(cp);\n            intersection[cp] = {j,i};\n        }\n    }\n\n    vector<vector<bool>> vis(n);\n    vector<int> sz(n);\n    rep(i,n){\n        sort(all(seg[i]));\n        seg[i].erase(unique(all(seg[i])), seg[i].end());\n        sz[i] = seg[i].size();\n        vis[i] = vector<bool>(sz[i],false);\n    }\n\n    auto is_valve = [&](Point p){\n        return v2id.count(p);\n    };\n\n    // 締めるべきバルブを決定\n    queue<pi> que;\n    rep(i,n){\n        int idx = lower_bound(all(seg[i]), repair) - seg[i].begin();\n        if(idx < sz[i] && seg[i][idx] == repair){\n            vis[i][idx] = true;\n            que.push({i,idx});\n        }\n    }\n\n    vector<bool> stop(m);\n    while(!que.empty()){\n        pi now = que.front();\n        que.pop();\n        int pid = now.fi;\n\n        Point ppp = seg[now.fi][now.se];\n\n\n        if(is_valve(ppp)){\n            stop[v2id[ppp]] = true;\n            continue;\n        }\n\n        // 違うパイプへ\n        if(intersection.count(ppp)){\n            pi I = intersection[ppp];\n            int npid = I.fi + I.se - pid;\n            int nidx = lower_bound(all(seg[npid]),ppp) - seg[npid].begin();\n            if(!vis[npid][nidx]){\n                vis[npid][nidx] = true;\n                que.push({npid,nidx});\n            }\n        }\n\n        // 隣へ\n        for(int i:{-1,1}){\n            int nx = now.se + i;\n            if(0<=nx && nx<sz[pid] && !vis[pid][nx]){\n                vis[pid][nx] = true;\n                que.push({pid,nx});\n            }\n        }\n    }\n\n\n    // 水の到達箇所をチェック\n    // initialize\n    rep(i,n) vis[i] = vector<bool>(sz[i],false);\n\n    rep(i,n){\n        int idx = lower_bound(all(seg[i]), source) - seg[i].begin();\n        if(idx < sz[i] && seg[i][idx] == source){\n            vis[i][idx] = true;\n            que.push({i,idx});\n        }\n    }\n    while(!que.empty()){\n        pi now = que.front();\n        que.pop();\n        int pid = now.fi;\n\n        Point ppp = seg[now.fi][now.se];\n\n        // fail\n        if(ppp == repair){\n            printf(\"-1\\n\");\n            return 0;\n        }\n\n        if(is_valve(ppp) && stop[v2id[ppp]]) continue;\n\n        // 違うパイプへ\n        if(intersection.count(ppp)){\n            pi I = intersection[ppp];\n            int npid = I.fi + I.se - pid;\n            int nidx = lower_bound(all(seg[npid]),ppp) - seg[npid].begin();\n            if(!vis[npid][nidx]){\n                vis[npid][nidx] = true;\n                que.push({npid,nidx});\n            }\n        }\n\n        // 隣へ\n        for(int i:{-1,1}){\n            int nx = now.se + i;\n            if(0<=nx && nx<sz[pid] && !vis[pid][nx]){\n                vis[pid][nx] = true;\n                que.push({pid,nx});\n            }\n        }\n    }\n\n    double sub = 0;\n    rep(i,n){\n        rep(j,sz[i]-1){\n            if(vis[i][j] && vis[i][j+1]){\n                Point vec = ADD_P(seg[i][j],seg[i][j+1],-1);\n\n                F vx = vec.X, vy = vec.Y;\n\n                double dx = (double)vx.fi/vx.se;\n                double dy = (double)vy.fi/vy.se;\n\n                sub += sqrt( sq(dx) + sq(dy));\n            }\n        }\n    }\n    printf(\"%.10Lf\\n\", U - sub);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef complex<double> V;\ntypedef vector<P> vecP;\ntypedef pair<P,P> L;\ntypedef pair<P,P> S;\ntypedef pair<P,double> C;\nconst double eps=1e-8;\nconst double PI=acos(-1);\nconst double PI2=PI*2.0;\n \nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.real()!=b.real()?\n            a.real() <b.real():\n            a.imag() <b.imag());\n  }\n};\n \nV normal(V a){\n  assert( abs(a)>0 );\n  return a/abs(a);\n}\n \ndouble Sqrt( double x ){\n  if(x<0)return 0;\n  else return sqrt(x);\n}\n \nP Vector(L a){\n  return a.second-a.first;\n}\n \nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n \nbool eq(P a,P b){\n  return ( eq(a.real(),b.real()) && eq(a.imag(),b.imag()) );\n}\n \ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n \ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n \ndouble getArg(P a,P b){\n  return arg(b*conj(a));\n}\n \ndouble getTime(V a,V b){\n  assert( eq(cross(a,b),0) );\n  return ( dot(a,b) < 0 ? -1.0 : 1.0 ) * abs(b) / abs(a);\n}\n \n \nP project(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*real(c/b);\n}\n \nP reflect(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*conj(c/b);\n}\n \nint ccw(P a,P b,P c){\n  P ab=b-a,ac=c-a;\n  P k=ac*conj(ab);\n  if(k.imag()>0)return 1;\n  if(k.imag()<0)return -1;\n  if(k.real()<0)return 2;\n  if(abs(ab)<abs(ac))return -2;\n  return 0;\n}\n \nbool isParallel(P a,P b){\n  return eq(0, cross(a,b));\n}\n \nbool isParallel(S a,S b){\n  return eq(0, cross( Vector(a) , Vector(b) ) );\n}\n \nbool onLP(L l,P p){\n  P a=l.first, b=l.second;\n  return eq(0, cross(b-a,p-a));\n}\n \nbool onSP(S s,P p){\n  P a=s.first, b=s.second;\n  return eq( abs(b-a) , abs(a-p)+abs(b-p) );\n}\n \nbool isCrossSS(S s0,S s1){\n  P a=s0.first, b=s0.second;\n  P c=s1.first, d=s1.second;\n  int f0 = ccw(a,b,c) * ccw(a,b,d);\n  int f1 = ccw(c,d,a) * ccw(c,d,b);\n  return (f0<=0 && f1<=0);\n}\n \nbool isCrossLS(L l,S s){\n  P a=l.first, b=l.second;\n  P c=s.first, d=s.second;\n  return ( ccw(a,b,c) * ccw(a,b,d) <= 0 );\n}\n \ndouble distLP(L l,P p){\n  P a=l.first, b=l.second;\n  double res = cross(b-a,p-a) / abs(b-a);\n  return abs(res);\n}\n \ndouble distSP(S s,P p){\n  P a=s.first, b=s.second;\n  if( dot(b-a,p-a) < eps )return abs(p-a);\n  if( dot(a-b,p-b) < eps )return abs(p-b);\n  return distLP(s,p);\n}\n \ndouble distSS(S s0,S s1){\n  if( isCrossSS(s0,s1) )return 0;\n  double res0 = min( distSP( s0, s1.first ) , distSP(s0, s1.second) );\n  double res1 = min( distSP( s1, s0.first ) , distSP(s1, s0.second) );\n  return min(res0,res1);\n}\n \nP getCrossLL(L l0,L l1){\n  P a=l0.first, b=l0.second;\n  P c=l1.first, d=l1.second;\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n \n \n  \nint inPolygon(vecP &t,P p){\n  int n=t.size();\n  double sum=0;\n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p)==0 )return 1;\n    sum+= getArg(a-p,b-p);\n  }\n  if( abs(sum) < eps )return 0;\n  else return 2;\n}\n\n\nstruct edge{\n  int to;\n  double cost;\n};\n\ntypedef vector<edge> Node;\ntypedef vector<Node> Graph;\nGraph G;\nmap<int,bool> isB;\nvector< P > points;\n\nvoid segments2graph( vector<S> segments ,vector<P> b ){\n\n  int n=segments.size();\n\n  sort(b.begin(),b.end());\n  \n  for(int i=0;i<(int)b.size();i++){\n    points.push_back(b[i]);\n  }\n  \n  for(int i=0;i<n;i++){\n    S si=segments[i];\n    points.push_back( si.first );\n    points.push_back( si.second );\n    for(int j=0;j<i;j++){\n      S sj=segments[j];\n      if( isCrossSS( si , sj ) && !isParallel( si, sj ) ){\n        points.push_back( getCrossLL(si,sj) );\n      }\n    }\n  }\n \n  sort(points.begin(), points.end());\n  points.erase( unique( points.begin(), points.end() ) , points.end() );\n   \n  G.resize(points.size());\n  \n  for(int i=0;i<(int)points.size();i++){\n    P p=points[i];\n    isB[i] = binary_search(b.begin(),b.end(), p);\n  }\n  \n  typedef pair< double , int > Pair;\n     \n  for(int i=0;i<n;i++){\n    S si=segments[i];\n    P sf=si.first, se=si.second;\n    vector< Pair > targets;\n    for(int j=0;j<(int)points.size();j++){\n      P pj=points[j];\n      // if( ccw( si.first, si.second, pj ) == 0 ){\n      if( onSP( si, pj ) ){\n        targets.push_back( Pair(getTime(se-sf ,pj-sf ), j ) );\n      }\n    }\n    /*\n    for(int j=0;j<(int)targets.size();j++){\n      for(int k=0;k<j;k++){\n        Pair a=targets[j];\n        Pair b=targets[k];\n        P ap=points[ a.second ];\n        P bp=points[ b.second ];\n        G[a.second].push_back( (edge){ b.second , getArg(ap,bp) } );\n        G[b.second].push_back( (edge){ a.second , getArg(bp,ap) } );\n      }\n    }\n    */\n \n    sort( targets.begin(), targets.end() );\n    for(int j=0;j+1<(int)targets.size();j++){\n      Pair a=targets[j];\n      Pair b=targets[j+1];\n      P ap=points[ a.second ];\n      P bp=points[ b.second ];\n      \n      G[a.second].push_back( (edge){ b.second , abs(ap-bp) } );\n      G[b.second].push_back( (edge){ a.second , abs(bp-ap) } );\n    }\n \n  }\n\n}\n\nP input(){\n  double x,y;\n  cin>>x>>y;\n  return P(x,y);\n}\n\n\nmap<int,bool> visited;\ndouble total=0;\n\nmap< P , bool > counted;\n\nvoid dfs(int pos){\n  \n  if( isB[pos] )return;\n  if(visited[pos])return;\n  visited[pos]=true;\n  \n  for(int i=0;i<(int)G[pos].size();i++){\n    edge e=G[pos][i];\n    if( visited[e.to] || isB[e.to] )total+=e.cost;\n    else total += e.cost/2.0;\n  }\n  \n  for(int i=0;i<(int)G[pos].size();i++){\n    edge e=G[pos][i];\n    dfs(e.to);\n  }\n}\n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  vector< S > segments;\n  vector< P > bs;\n\n  double ans = 0;\n  \n  for(int i=0;i<N;i++){\n    P a=input();\n    P b=input();\n    segments.push_back( S(a,b) );\n    ans+= abs(a-b);\n  }\n  \n  for(int i=0;i<M;i++)bs.push_back( input() );\n  \n  P si,ti;\n  si=input();\n  ti=input();\n  points.push_back(si);\n  points.push_back(ti);\n  \n  segments2graph(segments,bs);\n\n  \n  int ex = lower_bound( points.begin(), points.end() , si ) - points.begin();\n  int root = lower_bound( points.begin(), points.end() , ti ) - points.begin();\n  \n  while( ex == (int)points.size() || root == (int)points.size() ){\n\n  }\n  \n  dfs(root);\n  \n  if( visited[ex] ){\n    cout<<\"-1\"<<endl;\n    return 0;\n  }\n  \n  total = 0;\n  dfs( ex );\n  printf(\"%.10f\\n\",ans-total);\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define MAX 200010\n#define eps (1e-6)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool isParallel(Segment s,Segment t){\n    return equals(cross(s.p1-s.p2,t.p1-t.p2),0.0);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\nbool merge_if_able(Segment &s,Segment t) {\n  if(!isParallel(s,t))return false;\n  if(ccw(s.p1,t.p1,s.p2)==1 ||\n     ccw(s.p1,t.p1,s.p2)==-1)return false;\n  if(ccw(s.p1,s.p2,t.p1)==-2 ||\n     ccw(t.p1,t.p2,s.p1)==-2)return false;\n  s=Segment(min(s.p1,t.p1),max(s.p2,t.p2));\n  return true;\n}\n\nvoid merge(vector<Segment>& v) {\n  for(int i=0;i<v.size();i++){\n    if(v[i].p2<v[i].p1)swap(v[i].p2,v[i].p1);\n  }\n  for(int i=0;i<v.size();i++)\n    for(int j=i+1;j<v.size();j++)\n      if(merge_if_able(v[i],v[j]))\n        v[j--]=v.back(),v.pop_back();\n}\n\ntypedef vector<vector<pair<int,double> > > Graph;\n\nGraph SegmentArrangement(vector<Segment> v,vector<Point> &ps){\n  for(int i=0;i<v.size();i++){\n    ps.push_back(v[i].p1);\n    ps.push_back(v[i].p2);\n    for(int j=i+1;j<v.size();j++){\n      if(intersect(v[i],v[j]))ps.push_back(getCrossPointLL(v[i],v[j]));\n    }\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n  Graph g(ps.size());\n  for(int i=0;i<v.size();i++){\n    vector<pair<double,int> > list;\n    for(int j=0;j<ps.size();j++)\n      if(ccw(v[i].p1,v[i].p2,ps[j])==0)\n        list.push_back(mp(norm(v[i].p1-ps[j]),j));\n    sort(list.begin(),list.end());\n    for(int j=0;j<list.size()-1;j++){\n      int a=list[j].s,b=list[j+1].s;\n      g[a].push_back(mp(b,abs(ps[b]-ps[a])));\n      g[b].push_back(mp(a,abs(ps[a]-ps[b])));\n    }\n  }\n  return g;\n}\n\nint n,m;\nvector<Segment> vs;\nvector<Point> vp;\nset<Point> st;\nPoint s,t;\nint c,d;\nGraph g;\nbool checked[MAX]={};\nbool visited[MAX]={};\nbool valve[MAX]={};\n\nvoid dfs(int v){ \n  checked[v]=true;\n  if(valve[v])return;\n  for(int i=0;i<g[v].size();i++){\n    pair<int,double> next=g[v][i];\n    if(!checked[next.f]){\n      dfs(next.f);\n    }\n  }\n  return;\n}\n\ndouble bfs(int v){\n  double res=0.0;\n  queue<int> q;\n  q.push(v);\n  while(q.size()){\n    int u=q.front();\n    q.pop();\n    if(visited[u])continue;\n    visited[u]=true;\n    for(int i=0;i<g[u].size();i++){\n      pair<int,double> next=g[u][i];\n      if(checked[next.f])res+=next.s;\n      else if(!visited[next.f]){\n        res+=next.s;\n        q.push(next.f);\n      }\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    vs.push_back(Segment(Point(a,b),Point(c,d)));\n  }\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    vp.push_back(Point(a,b));\n    st.insert(Point(a,b));\n  }\n  cin>>s.x>>s.y>>t.x>>t.y;\n  vp.push_back(s);\n  vp.push_back(t);\n  //merge(vs);\n  g=SegmentArrangement(vs,vp);\n  for(int i=0;i<vp.size();i++){\n    if(st.find(vp[i])!=st.end())valve[i]=true;\n    if(vp[i]==s)c=i;\n    if(vp[i]==t)d=i;\n  }\n  dfs(d);\n  if(checked[c])cout<<-1<<endl;\n  else {\n    double ans=0.0;\n    for(int i=0;i<g.size();i++){\n      for(int j=0;j<g[i].size();j++)ans+=g[i][j].s/2.0;\n    }\n    ans-=bfs(c);\n    printf(\"%.10f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\n\nconst double INF = 1e100;\nconst double EPS = 1e-12;\ntypedef complex<double> P; \ntypedef pair<P,P> L; \n\nnamespace std{ \n  bool operator < (const P& a, const P& b){ \n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b); \n  } \n} \ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1; //テ・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ?\n  if(cross(b,c) < -EPS) return -1; // テヲツ卍づィツィツ暗・ツ崢榲」ツつ?\n  if(dot(b,c) < -EPS) return 2; // c -- a -- b テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n  if(norm(b) < norm(c)) return -2; // a -- b -- c テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n  return 0; // a -- c -- b テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n}\n\nbool isIntersect(L s1, L s2){\n    if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nstruct edge{\n  int to,r;\n  double c;\n};\n\nmap<P,int> mf;\nint flag[150000];\nvector<vector<edge> > G;\nvoid segmentArrangement(const vector<L> &ss,vector<P> &ps){ \n  for(int i=0;i<ss.size();i++){ \n    ps.push_back(ss[i].first); \n    ps.push_back(ss[i].second); \n    for(int j=i+1;j<ss.size();j++) \n      if(isIntersect(ss[i],ss[j])) \n        ps.push_back(crossPoint(ss[i],ss[j])); \n  } \n  sort(ps.begin(),ps.end()); \n  ps.erase(unique(ps.begin(),ps.end()), ps.end()); \n  G = vector<vector<edge> >(ps.size());\n  for(int i=0;i<(int)ps.size();i++){\n    flag[i] = mf[ps[i]];\n  }\n  for(int i=0;i<ss.size();i++){ \n    vector<pair<double,int> > list; \n    for(int j=0;j<ps.size();j++) \n      if(isIntersectSP(ss[i],ps[j]))  \n        list.push_back(make_pair(norm(ss[i].first-ps[j]), j)); \n    sort(list.begin(),list.end()); \n    for(int j=0;j<list.size()-1;j++){ \n      int a = list[j].second; \n      int b = list[j+1].second; \n      G[a].push_back( (edge){b,  G[b].size(),abs(ps[a] - ps[b])} ); \n      G[b].push_back( (edge){a,G[a].size()-1,abs(ps[a] - ps[b])} );       \n    } \n  } \n\n} \n \nvector<L> ss;\nvector<P> ps;\nvector<vector<int> > mem;\ndouble solve(){\n  int s,t;\n  queue<int> q;\n  vector<int> used;\n  int sum = 0;\n  used = vector<int>(G.size(),0);\n  mem = vector<vector<int> >(G.size());\n  for(int i=0;i<(int)G.size();i++){\n    if(flag[i] == 2 ) s = i;\n    if(flag[i] == 3 ) t = i;   \n    mem[i] = vector<int>(G[i].size(),0);\n    sum += G[i].size();\n    /*\n    cout << \"node \" << i << endl;\n    for(int j=0;j<(int)G[i].size();j++){\n      cout << \" = > \" << G[i][j].to<< \" \"<< G[i][j].c << endl;\n    }\n    */\n  }\n  // cout << sum << endl;\n  q.push( t );\n  used[t] = 1;\n  double res = 0.0;\n  while( !q.empty() ){\n    int p = q.front(); q.pop();\n    //     cout << p << endl;\n    if( flag[p] == 1) continue;\n    if( p == s ) return -1.0;\n    for(int i=0;i<(int)G[p].size();i++){\n      int to = G[p][i].to;\n      if( used[to] ) continue;\n      used[to] = 1;\n      q.push( to );\n    }\n  }\n\n  q.push( s );\n  used[s] = 1;\n  while( !q.empty() ){\n    int p = q.front(); q.pop();\n    for(int i=0;i<(int)G[p].size();i++){\n      edge e = G[p][i];\n      if(mem[p][i]) continue;\n      res -= e.c;\n      mem[p][i] = 1;\n      mem[e.to][e.r]  = 1;\n      if( used[e.to] ) continue;\n      used[e.to] = 1;\n      q.push( e.to );\n    }\n  }\n  for(int i=0;i<N;i++) res += abs(ss[i].first-ss[i].second);\n\n  return res;\n}\n\nint main(){\n  cin >> N >> M;\n  for(int i=0;i<N;i++){\n    int x1,y1,x2,y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    ss.push_back( L(P(x1,y1),P(x2,y2)) );\n  }\n  for(int i=0;i<M;i++){\n    P a; cin >> a.real() >> a.imag();\n    ps.push_back( a );\n    mf[a] = 1;\n  }\n  P c,d;\n  cin >> c.real() >> c.imag();\n  cin >> d.real() >> d.imag();\n  int s,t;\n  mf[c] = 2;\n  mf[d] = 3;\n  ps.push_back(c);\n  ps.push_back(d);\n \n  segmentArrangement(ss,ps);\n\n  double res = solve();\n  if( res < -EPS ) cout << -1 << endl;\n  else printf(\"%.10lf\\n\",res);\n\n}"
  },
  {
    "language": "C++",
    "code": " #include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\n\nconst double INF = 1e100;\nconst double EPS = 1e-8;\ntypedef complex<double> P; \ntypedef pair<P,P> L; \n\nnamespace std{ \n  bool operator < (const P& a, const P& b){ \n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b); \n  } \n} \ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1; //テ・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ?\n  if(cross(b,c) < -EPS) return -1; // テヲツ卍づィツィツ暗・ツ崢榲」ツつ?\n  if(dot(b,c) < -EPS) return 2; // c -- a -- b テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n  if(norm(b) < norm(c)) return -2; // a -- b -- c テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n  return 0; // a -- c -- b テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n}\n\nbool isIntersect(L s1, L s2){\n    if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nstruct edge{\n  int to,r;\n  double c;\n};\n\nmap<P,int> mf;\nint flag[150000];\nvector<vector<edge> > G;\nvoid segmentArrangement(const vector<L> &ss,vector<P> &ps){ \n  for(int i=0;i<ss.size();i++){ \n    ps.push_back(ss[i].first); \n    ps.push_back(ss[i].second); \n    for(int j=i+1;j<ss.size();j++) \n      if(isIntersect(ss[i],ss[j])) \n        ps.push_back(crossPoint(ss[i],ss[j])); \n  } \n  sort(ps.begin(),ps.end()); \n  ps.erase(unique(ps.begin(),ps.end()), ps.end()); \n  G = vector<vector<edge> >(ps.size());\n  for(int i=0;i<(int)ps.size();i++){\n    flag[i] = mf[ps[i]];\n  }\n  for(int i=0;i<ss.size();i++){ \n    vector<pair<double,int> > list; \n    for(int j=0;j<ps.size();j++) \n      if(isIntersectSP(ss[i],ps[j]))  \n        list.push_back(make_pair(norm(ss[i].first-ps[j]), j)); \n    sort(list.begin(),list.end()); \n    for(int j=0;j<list.size()-1;j++){ \n      int a = list[j].second; \n      int b = list[j+1].second; \n      G[a].push_back( (edge){b,  G[b].size(),abs(ps[a] - ps[b])} ); \n      G[b].push_back( (edge){a,G[a].size()-1,abs(ps[a] - ps[b])} );       \n    } \n  } \n\n} \n \nvector<L> ss;\nvector<P> ps;\nvector<vector<int> > mem;\ndouble solve(){\n  int s,t;\n  queue<int> q;\n  vector<int> used;\n  int sum = 0;\n  used = vector<int>(G.size());\n  mem = vector<vector<int> >(G.size());\n  for(int i=0;i<(int)G.size();i++){\n    if(flag[i] == 2 ) s = i;\n    if(flag[i] == 3 ) t = i;   \n    mem[i] = vector<int>(G[i].size());\n    sum += G[i].size();\n    /*\n    cout << \"node \" << i << endl;\n    for(int j=0;j<(int)G[i].size();j++){\n      cout << \" = > \" << G[i][j].to<< \" \"<< G[i][j].c << endl;\n    }\n    */\n  }\n  // cout << sum << endl;\n  q.push( t );\n  used[t] = true;\n  double res = 0.0;\n  while( !q.empty() ){\n    int p = q.front(); q.pop();\n    //     cout << p << endl;\n    if( flag[p] == 1) continue;\n    if( p == s ) return -1.0;\n    for(int i=0;i<(int)G[p].size();i++){\n      int to = G[p][i].to;\n      if( used[to] ) continue;\n      used[to] = true;\n      q.push( to );\n    }\n  }\n\n  q.push( s );\n  used[s] = true;\n  while( !q.empty() ){\n    int p = q.front(); q.pop();\n    for(int i=0;i<(int)G[p].size();i++){\n      edge e = G[p][i];\n      if(mem[p][i]) continue;\n      res -= e.c;\n      mem[p][i] = true;\n      mem[e.to][e.r]  = true;\n      if( used[e.to] ) continue;\n      used[e.to] = true;\n      q.push( e.to );\n    }\n  }\n  for(int i=0;i<N;i++) res += abs(ss[i].first-ss[i].second);\n\n  return res;\n}\n\nint main(){\n  cin >> N >> M;\n  for(int i=0;i<N;i++){\n    int x1,y1,x2,y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    ss.push_back( L(P(x1,y1),P(x2,y2)) );\n  }\n  for(int i=0;i<M;i++){\n    P a; cin >> a.real() >> a.imag();\n    ps.push_back( a );\n    mf[a] = 1;\n  }\n  P c,d;\n  cin >> c.real() >> c.imag();\n  cin >> d.real() >> d.imag();\n  int s,t;\n  mf[c] = 2;\n  mf[d] = 3;\n  ps.push_back(c);\n  ps.push_back(d);\n \n  segmentArrangement(ss,ps);\n\n  double res = solve();\n  if( res < -EPS ) cout << -1 << endl;\n  else printf(\"%.10lf\\n\",res);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<unordered_map>\n#include<utility>\n\nusing namespace std;\n\nmultimap<int,int> g;\nset<int> valves;\nint xb,yb,xc,yc;\nconst int O=1234;\nset<int> stopped,u;\n\nint gcd(int a,int b){\n  return b?gcd(b,a%b):a;\n}\n\nint enc(int x,int y){\n  return (x+O<<16)+y+O;\n}\n\npair<int,int> dec(int x){\n  return make_pair((x>>16)-O,(x&(1<<16)-1)-O);\n}\n\nvoid stop(int v){\n  if(!u.insert(v).second)return;\n  if(valves.count(v)){\n    stopped.insert(v);\n    return;\n  }else{\n    auto p=dec(v);\n    int x=p.first,y=p.second;\n    if(y==yb&&x==xb)throw 0;\n    auto c=g.equal_range(v);\n    for(auto it=c.first;it!=c.second;it++){\n      if(u.count(it->second))continue;\n      stop(it->second);\n    }\n  }\n}\n\ndouble rec(int v,int p){\n  if(!u.insert(v).second)return 0;\n  if(stopped.count(v))return 0;\n  auto pr=dec(v);\n  int x=pr.first,y=pr.second;\n  auto c=g.equal_range(v);\n  double r=0;\n  for(auto it=c.first;it!=c.second;it++){\n    if(it->second==p)continue;\n    int ny,nx;\n    tie(nx,ny)=dec(it->second);\n    r+=hypot(ny-y,nx-x)+rec(it->second,v);\n  }\n  return r;\n}\n\nvoid add_edge(pair<int,int> a,pair<int,int> b){\n  g.insert(make_pair(enc(a.first,a.second),enc(b.first,b.second)));\n}\n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  double len=0;\n  for(int i=0;i<N;i++){\n    int xs,ys,xd,yd;\n    cin>>xs>>ys>>xd>>yd;\n    len+=hypot(xs-xd,ys-yd);\n    vector<pair<int,int> > v;\n    if(xs==xd||ys==yd){\n      if(xs>xd){\n\tswap(xs,xd);\n      }\n      if(ys>yd){\n\tswap(ys,yd);\n      }\n      for(int x=xs,y=ys;x<=xd&&y<=yd;x+=xs!=xd,y+=ys!=yd){\n\tv.emplace_back(x,y);\n      }\n    }else{\n      if(xd<xs){\n\tswap(xs,xd);\n\tswap(ys,yd);\n      }\n      int m=gcd(xd-xs,abs(yd-ys));\n      for(int y=ys,x=xs;x<=xd;x+=(xd-xs)/m,y+=(yd-ys)/m){\n\tv.emplace_back(x,y);\n      }\n    }\n    for(int i=0;i<v.size()-1;i++){\n      add_edge(v[i],v[i+1]);\n      add_edge(v[i+1],v[i]);\n    }\n  }\n  for(int i=0;i<M;i++){\n    int xv,yv;\n    cin>>xv>>yv;\n    valves.insert(enc(xv,yv));\n  }\n  cin>>xb>>yb>>xc>>yc;\n  try{\n    stop(enc(xc,yc));\n    u.clear();\n    cout<<fixed<<len-rec(enc(xb,yb),-1)<<endl;\n  }catch(...){\n    cout<<-1<<endl;\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-12, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n// 点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef double Weight;\n\nstruct Edge { int from, to; Weight weight;\nint id;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight,const int id) {\n\tg[from].push_back(Edge{ from, to, weight,id});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<pair<Point,bool>> &p) {\n\tint n = p.size(), m = s.size();\n\tint id = 0;\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j].first))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j].first), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from].first - p[to].first), id);\n\t\t\tadd_edge(g, to, from, abs(p[from].first - p[to].first), id++);\n\t\t}\n\t}\n\treturn g;\n}\n\n//Graph sennbunn_arrangement(const vector<Line>&s) {\n//\tvector<Point>crss;\n//\tfor (int i = 0; i < s.size(); ++i) {\n//\t\tfor (int j = i + 1; j < s.size(); ++j) {\n//\t\t\tif (isis_ss( s[i],  s[j])) {\n//\t\t\t\tcrss.push_back(is_ll( s[i],  s[j]));\n//\t\t\t}\n//\t\t}\n//\t}\n//\tfor (int i = 0; i <s.size(); ++i) {\n//\t\tcrss.push_back( s[i][0]);\n//\t\tcrss.push_back( s[i][1]);\n//\t}\n//\treturn segment_arrangement(s, crss);\n//}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nint startid;\nint goalid;\nbool dfs0(const Graph&g,const int now, vector<bool>&came, vector<bool>&close,const vector<bool>&bulbs) {\n\tcame[now] = true;\n\tfor (auto e : g[now]) {\n\t\tif (!came[e.to]) {\n\t\t\tif (e.to == startid)return false;\n\t\t\telse {\n\t\t\t\tif (bulbs[e.to]) {\n\t\t\t\t\tclose[e.to] = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!dfs0(g, e.to, came, close, bulbs)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ndouble dfs1(const Graph&g, const int now, vector<bool>&came,vector<bool>&useedges, const vector<bool>&close) {\n\tcame[now] = true;\n\tdouble ans = 0;\n\tfor (auto e : g[now]) {\n\t\tif (!useedges[e.id]) {\n\t\t\tans += e.weight;\n\t\t\tuseedges[e.id] = true;\n\t\t\tif (close[e.to])continue;\n\t\t\telse {\n\t\t\t\tif(!came[e.to])ans += dfs1(g, e.to, came,useedges, close);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tdouble sum = 0;\n\tGraph g;\n\tint sx, sy, gx, gy;\n\tPoint start;\n\tPoint goal;\n\tvector<pair<Point, bool>>crss;\n\tvector<bool>bulbs;\n\t{\n\t\tint N, M; cin >> N >> M;\n\t\tvector<Line>ls;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint asx, asy, dx, dy; cin >> asx >> asy >> dx >> dy;\n\t\t\tls.push_back(Line(Point(asx, asy), Point(dx, dy)));\n\t\t\tsum += (abs(Point(asx, asy) - Point(dx, dy)));\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < ls.size(); ++j) {\n\t\t\t\tbool ok = false;\n\t\t\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\t\t\tif (ls[i][k] == ls[j][l]) {\n\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\tcrss.push_back(make_pair(ls[i][k], false));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif (ok)break;\n\t\t\t\t}\n\t\t\t\tif (!ok&&isis_ss(ls[i], ls[j])) {\n\t\t\t\t\tcrss.push_back(make_pair(is_ll(ls[i], ls[j]), false));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < ls.size(); ++i) {\n\t\t\tcrss.push_back(make_pair(ls[i][0], false));\n\t\t\tcrss.push_back(make_pair(ls[i][1], false));\n\t\t}\n\t\t\n\t\tvector<Point >bs;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tPoint p(x, y);\n\t\t\tbs.push_back(p);\n\t\t}\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tstart = Point(sx, sy);\n\t\tgoal = Point(gx, gy);\t\n\t\tcrss.push_back(make_pair(start, false));\n\t\tcrss.push_back(make_pair(goal, false));\n\t\tsort(crss.begin(), crss.end());\n\t\tcrss.erase(unique(crss.begin(), crss.end()), crss.end());\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tauto it = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == bs[i]; });\n\t\t\tif (it == crss.end()) {\n\t\t\t\tcrss.push_back(make_pair(bs[i], true));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(*it).second = true;\n\t\t\t}\n\t\t}\n\n\n\t\tfor (int i = 0; i < crss.size(); ++i) {\n\t\t\tbulbs.push_back(crss[i].second);\n\t\t}\n\t\tg= segment_arrangement(ls, crss);\n\t}\n\tauto startit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == start; });\n\tstartid = startit - crss.begin();\n\tauto goalit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == goal; });\n\tgoalid = goalit - crss.begin();\n\tvector<bool>close(crss.size(),false);\n\tvector<bool>came(crss.size(), false);\n\tif (dfs0(g, goalid, came, close, bulbs)) {\n\t\tvector<bool>acame(crss.size(), false);\n\t\tvector<bool>useedges(80000, false);\n\t\tdouble ans = dfs1(g, startid, acame, useedges,close);\n\t\tcout <<fixed<<setprecision(10)<< sum-ans << endl;\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef complex<double> P;\n \nconst double eps = 1e-8;\n \nbool equals(double a, double b) {\n  return abs(a - b) < eps;\n}\n \nnamespace std {\n  bool operator < (const P &a, const P &b) {\n    if(a.real() != b.real()) return a.real() < b.real();\n    else return a.imag() < b.imag();\n  }\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n \ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n \nbool isParallel(P a, P b) {\n  return equals(cross(a, b), 0.0);\n}\n \nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a, b) > eps) return 1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a, b) < -eps) return 2;\n  if(norm(b) - norm(a) > eps) return -2;\n  return 0;\n}\n \nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n       ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1) / cross(b, a);\n}\n\nstruct Edge {\n  int to; double w;\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nGraph segmentArrangement(const vector<P> &s1, const vector<P> &s2,\n                         vector<P> &ps) {\n  int m = s1.size();\n  for(int i = 0; i < m; ++i) {\n    ps.push_back(s1[i]);\n    ps.push_back(s2[i]);\n    for(int j = i+1; j < m; ++j) {\n      if(equals(cross(s1[i] - s2[i], s1[j] - s2[j]), 0.0)) continue;\n      if(!isIntersect(s1[i], s2[i], s1[j], s2[j])) continue;\n      ps.push_back(getCrossP(s1[i], s2[i], s1[j], s2[j]));\n    }\n  }\n  sort(ps.begin(), ps.end());\n  ps.erase(unique(ps.begin(), ps.end()), ps.end());\n  \n  int n = ps.size();\n  Graph g(n);\n  for(int i = 0; i < m; ++i) {\n    vector<pair<double, int> > v;\n    for(int j = 0; j < n; ++j) {\n      if(!ccw(s1[i], s2[i], ps[j])) {\n        v.push_back(make_pair(norm(s1[i] - ps[j]), j));\n      }\n    }\n    sort(v.begin(), v.end());\n    for(int j = 0; j+1 < v.size(); ++j) {\n      int a = v[j].second, b = v[j+1].second;\n      double w = abs(ps[a] - ps[b]);\n      g[a].push_back((Edge){b, w});\n      g[b].push_back((Edge){a, w});\n    }\n  }\n  return g;\n}\n\n///////////////////////////////////////////////////////////////////////////\n \nint main() {\n  int N, M; cin >> N >> M;\n  vector<P> X(N), Y(N), Z(M);\n  \n  P src, dst;\n  for(int i = 0; i < N; ++i) {\n    cin >> X[i].real() >> X[i].imag() >> Y[i].real() >> Y[i].imag();\n  }\n  for(int i = 0; i < M; ++i) {\n    cin >> Z[i].real() >> Z[i].imag();\n  }\n  cin >> src.real() >> src.imag();\n  cin >> dst.real() >> dst.imag();\n\n  vector<P> ps = Z;\n  ps.push_back(src);\n  ps.push_back(dst);\n  Graph G = segmentArrangement(X, Y, ps);\n  int V = G.size();\n\n  map<P, int> id;\n  for(int i = 0; i < ps.size(); ++i) {\n    id[ps[i]], id[ps[i]] = id.size() - 1;\n  }\n  \n  vector<int> F(V);\n  for(int j = 0; j < M; ++j) F[id[Z[j]]] = 1;\n  \n  try {\n    vector<int> F2(V);\n    set<pair<int, int> > vis;\n    queue<int> que;\n    que.push(id[dst]);\n    int isrc = id[src];\n    while(que.size()) {\n      int v = que.front();\n      que.pop();\n      for(int i = 0; i < G[v].size(); ++i) {\n        int nv = G[v][i].to;\n        if(nv == isrc) throw 0;\n        if(vis.count(make_pair(nv, v))) continue;\n        vis.insert(make_pair(nv, v));\n        vis.insert(make_pair(v, nv));\n        if(F[nv]) {\n          F2[nv] = 1;\n          continue;\n        }\n        que.push(nv);\n      }\n    }\n    double res = 0;\n    que.push(isrc);\n    while(que.size()) {\n      int v = que.front();\n      que.pop();\n      for(int i = 0; i < G[v].size(); ++i) {\n        int nv = G[v][i].to;\n        if(vis.count(make_pair(nv, v))) continue;\n        vis.insert(make_pair(nv, v));\n        vis.insert(make_pair(v, nv));\n        res += G[v][i].w;\n        if(F2[nv]) continue;\n        que.push(nv);\n      }\n    }\n    res = -res;\n    for(int i = 0; i < N; ++i) {\n      res += abs(X[i] - Y[i]);\n    }\n    printf(\"%.10f\\n\", res);\n  } catch(...) {\n    printf(\"-1\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-8\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<double,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\ntypedef complex<double> C;\n\nconst double PI = 4*atan(1.0);\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n    bool operator > (const C a, const C b) {\n        return a.real() != b.real() ? a.real() > b.real() : a.imag() > b.imag();\n    }\n    //点をsetとかmapにつめたいとき(誤差を1e-10とか厳しくし過ぎるとバグる)\n    // bool operator<(const C a, const C b){\n    //     return abs(a.real()-b.real())>EPS ? a.real()<b.real()-EPS : a.imag()<b.imag()-EPS;\n    // }\n    bool operator==(const C a, const C b){\n        return (eq(a.real(),b.real()) && eq(a.imag(),b.imag()));\n    }\n    bool operator!=(const C a, const C b){\n        return !(a == b);\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(){}\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\n//条件付きsqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//正規化\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//角度(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//外積\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//内積\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nC rot(C c,double th)\n{\n    return c * C(cos(th),sin(th));\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\n//直線どうしの交差判定(同一直線はTrue)\nbool intersectLL(const L& l, const L& m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//直線と線分の交差判定(一点共有も交差と判定)\nbool intersectLS(const L& l, const L& s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//直線と点の交差(共有)判定\nbool intersectLP(const L& l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//線分どうしの交差判定(一点共有も交差と判定)\nbool intersectSS(const L& s, const L& t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//線分と点の交差(共有)判定\nbool intersectSP(const L& s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//直線および線分の交点\nC crosspointLL(const L& l, const L& m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //同一直線のとき\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//点pを直線l上に射影\nC projection(const L& l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//crosspointCLに使用する関数(命名が謎です)\ndouble gettime(C c1,C c2)\n{\n    return (dot(c1,c2) < 0 ? -1.0 : 1.0 ) * abs(c2) / abs(c1);\n}\n//円と直線の交点\nvector<C> crosspointCL(C c1,double r1,const L& l)\n{\n    C a=l[0], b=l[1];\n    vector<C> res;\n    C base=b-a,  target=projection(L(a,b),c1);\n    double length=abs(base), h=abs(c1-target);\n    base/=length;\n    if(r1+EPS<h)    return res;\n    double w=Sqrt(r1*r1-h*h);\n    double LL=gettime(normalize(b-a),target-a)-w,RR=LL+w*2.0;\n    res.push_back(a+base*LL);\n    if(eq(LL,RR))   return res;\n    res.push_back(a+base*RR);\n    return res;\n}\n\n//円と線分の交点\nvector<C> crosspointCS(C c1,double r1,const L& s)\n{\n    vector<C> tmp=crosspointCL(c1,r1,s);\n    vector<C> res;\n    rep(i,tmp.size()){\n        if(abs(s[1]-s[0]) == abs(s[0]-tmp[i])+abs(s[1]-tmp[i])){\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n//円どうしの交点\nL crosspointCC(const C c1, const double r1, const C c2, const double r2)\n{\n    C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n    C d = b*b-4.0*a*c;\n    C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n    return L(z1, z2);\n}\n//点pを直線lを軸として対称移動\nC reflection(const L &l, const C p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//点と直線の距離\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n//直線と直線の距離\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//直線と線分の距離\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//線分と点の距離\ndouble distanceSP(const L &s, const C p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//線分と線分の距離\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\ndouble getarea(C c1,double r1,C a,C b)\n{\n    C va=c1-a,vb=c1-b;\n    double A=abs(va),B=abs(vb);\n    double f=cross(va,vb),d=distanceSP(L(a,b),c1),res=0;\n    if(eq(f,0.0))   return 0;\n    if(A < r1+EPS && B < r1+EPS)    return f*0.5;\n    if(d>r1-EPS)    return r1*r1*M_PI*getarg(va,vb)/(2.0*M_PI);\n    vector<C> u=crosspointCS(c1,r1,L(a,b));\n    u.insert(u.begin(),a),u.push_back(b);\n    for(int i=0;i+1<(int)u.size();i++){\n        res+=getarea(c1,r1,u[i],u[i+1]);\n    }\n    return res;\n}\n//円と多角形の共通部分の面積\ndouble getcrossarea(const vector<C>& t,C c1,double r1)\n{\n    int n = (int)t.size();\n    if(n<3) return 0;\n    double res=0;\n    rep(i,n){\n      C a=t[i], b=t[(i+1)%n];\n      res += getarea(c1,r1,a,b);\n    }\n    return res;\n}\n//凸包を求める(O(nlogn))\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = (int)ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//凸性判定\nbool isconvex(const vector<C>& ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//多角形の符号付き面積(左回りが正)\ndouble area(const vector<C>& ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//凸多角形を直線で切断した時の左側の図形\nvector<C> convex_cut(const vector<C>& ps, const L& l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(L(A, B),l));\n    }\n    return Q;\n}\n//垂直二等分線\nL bisector(C a, C b){\n    C A = (a + b) * C(0.5, 0);\n    return L(A, A + rot(b - a, PI/2));\n}\n//ボロノイ図(正確にはvoronoi_cellを求める)\n//愚直であるため1つのvoronoi_cellを求めるのにかかる計算量がO(n^2)\nvector<C> voronoi(vector<C> poly, vector<C>& p, int s){\n    rep(i,(int)p.size()){\n        if (i != s){\n            poly = convex_cut(poly, bisector(p[s], p[i]));\n        }\n    }\n    return poly;\n}\n//点が多角形に包含されているか(0は含まれない,1は辺上,2は含まれる)\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//凸多角形の交差\nvector<C> convex_intersection(const vector<C>& ps,const vector<C>& qs)\n{\n\tvector<C> rs;\n\tint a = ps.size(),b = qs.size();\n\trep(i,a){\n        if(contains(qs,ps[i])){\n            rs.push_back(ps[i]);\n        }\n    }\n\trep(i,b){\n        if(contains(ps,qs[i])){\n            rs.push_back(qs[i]);\n        }\n    }\n    rep(i,a){\n        rep(j,b){\n            L l1(ps[i],ps[(i+1)%a]),l2(qs[j],qs[(j+1)%b]);\n\t\t    if(intersectSS(l1,l2)){\n                rs.push_back(crosspointLL(l1,l2));\n            }\n        }\n\t}\n\tsort(rs.begin(),rs.end());\n\trs.erase(unique(rs.begin(),rs.end()),rs.end());\n\tif(rs.size() <= 1){\n        return rs;\n    }\n\treturn convex_hull(rs);\n}\n//凸多角形の直径を求める(キャリパー法)\n//maxi,maxjが最遠点対となる\ndouble convex_diameter(const vector<C>& ps)\n{\n    const int n = (int)ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nbool compyx(C c1,C c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\ndouble closest_pair(C* a, int n)\n{\n    if(n<=1) return 1e100;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compyx);\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n//最近点対を求める\ndouble compute_shortest(C* a,int n)\n{\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n//2円の位置関係を示す(返り値は2円の間の共通接線の数)\nint getstateCC(C c1,double r1,C c2,double r2)\n{\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)return 4;\n    if(d>r1+r2-EPS)return 3;\n    if(d>abs(r1-r2)+EPS)return 2;\n    if(d>abs(r1-r2)-EPS)return 1;\n    return 0;\n}\n//点から円へ接線を引いた時の接点\nC gettangentCP_(C c1,double r1,C p,int flg){\n    C base=c1-p;\n    double w=Sqrt(norm(base)-r1*r1);\n    C s=p+base*C(w,r1 * flg)/norm(base)*w;\n    return s;\n}\n//点から円への接線\nvector<L> gettangentCP(C c1,double r1,C p){\n    vector<L> res;\n    C s=gettangentCP_(c1,r1,p,1);\n    C t=gettangentCP_(c1,r1,p,-1);\n    //点が円の周上にある場合\n    if(s == t){\n        res.push_back(L(s,s+(c1-p)*C(0,1)));\n    }else{\n        res.push_back(L(p,s));\n        res.push_back(L(p,t));\n    }\n    return res;\n}\n\n//2円の共通内接線を求める\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2円の共通外接線を求める\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2円の共通接線を求める(各直線の２点はそれぞれの円の接点)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\n\nstruct edge\n{\n    int to;\n    double cost;\n};\n\nmap<C,int> mp;\nvector<C> point;\nvector<vector<edge> > G;\nbool stop[MAX_N];\nbool used[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    vector<L> line(n);\n    rep(i,n){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        if(C(c,d) < C(a,b)) swap(a,c),swap(b,d);\n        line[i] = L(C(a,b),C(c,d));\n        if(mp.find(C(a,b)) == mp.end()){\n            mp[C(a,b)] = len(point);\n            point.pb(C(a,b));\n        }\n        if(mp.find(C(c,d)) == mp.end()){\n            mp[C(c,d)] = len(point);\n            point.pb(C(c,d));\n        }\n    }\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        if(mp.find(C(a,b)) == mp.end()){\n            mp[C(a,b)] = len(point);\n            point.pb(C(a,b));\n        }\n        stop[mp[C(a,b)]] = true;\n    }\n    int a,b,c,d;\n    cin >> a >> b >> c >> d;\n    if(mp.find(C(a,b)) == mp.end()){\n        mp[C(a,b)] = len(point);\n        point.pb(C(a,b));\n    }\n    if(mp.find(C(c,d)) == mp.end()){\n        mp[C(c,d)] = len(point);\n        point.pb(C(c,d));\n    }\n    int s = mp[C(a,b)], t = mp[C(c,d)];\n    int V = len(point);\n    G.resize(len(point));\n    double al = 0;\n    rep(i,n){\n        vector<C> ten = line[i];\n        rep(j,len(point)){\n            if(intersectSP(line[i],point[j])){\n                ten.pb(point[j]);\n            }\n        }\n        zip(ten);\n        vi val(len(ten));\n        rep(j,len(ten)){\n            val[j] = mp[ten[j]];\n        }\n        rep(j,len(ten)-1){\n            double dir = abs(ten[j+1]-ten[j]);\n            al += dir;\n            G[val[j]].pb((edge){val[j+1],dir}),G[val[j+1]].pb((edge){val[j],dir});\n        }\n    }\n    vd dist(V,INF);\n    priority_queue<P,vp,greater<P> > que;\n    que.push(P(0,t));\n    while(!que.empty()){\n        P p = que.top();\n        que.pop();\n        if(dist[p.se] < p.fi) continue;\n        if(stop[p.se]){\n            used[p.se] = true;\n            continue;\n        }\n        if(s == p.se){\n            printf(\"-1\\n\");\n            return 0;\n        }\n        each(e,G[p.se]){\n            if(dist[e.to] > p.fi+e.cost){\n                dist[e.to] = p.fi+e.cost;\n                que.push(P(dist[e.to],e.to));\n            }\n        }\n    }\n    vector<bool> visit(V,false);\n    queue<int> q;\n    q.push(s);\n    visit[s] = true;\n    double stream = 0;\n    while(!q.empty()){\n        int p = q.front();\n        q.pop();\n        visit[p] = true;\n        each(e,G[p]){\n            if(used[e.to]){\n                visit[e.to] = true;\n                stream += e.cost;\n            }else if(!visit[e.to]){\n                visit[e.to] = true;\n                stream += e.cost;\n                q.push(e.to);\n            }\n        }\n    }\n    printf(\"%.12lf\\n\",al-stream);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-8\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<double,int> P;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\ntypedef complex<double> C;\n\nconst double PI = 4*atan(1.0);\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n    bool operator > (const C a, const C b) {\n        return a.real() != b.real() ? a.real() > b.real() : a.imag() > b.imag();\n    }\n    //点をsetとかmapにつめたいとき(誤差を1e-10とか厳しくし過ぎるとバグる)\n    // bool operator<(const C a, const C b){\n    //     return abs(a.real()-b.real())>EPS ? a.real()<b.real()-EPS : a.imag()<b.imag()-EPS;\n    // }\n    bool operator==(const C a, const C b){\n        return (eq(a.real(),b.real()) && eq(a.imag(),b.imag()));\n    }\n    bool operator!=(const C a, const C b){\n        return !(a == b);\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(){}\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\n//条件付きsqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//正規化\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//角度(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//外積\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//内積\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nC rot(C c,double th)\n{\n    return c * C(cos(th),sin(th));\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\n//直線どうしの交差判定(同一直線はTrue)\nbool intersectLL(const L& l, const L& m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//直線と線分の交差判定(一点共有も交差と判定)\nbool intersectLS(const L& l, const L& s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//直線と点の交差(共有)判定\nbool intersectLP(const L& l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//線分どうしの交差判定(一点共有も交差と判定)\nbool intersectSS(const L& s, const L& t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//線分と点の交差(共有)判定\nbool intersectSP(const L& s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//直線および線分の交点\nC crosspointLL(const L& l, const L& m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //同一直線のとき\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//点pを直線l上に射影\nC projection(const L& l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//crosspointCLに使用する関数(命名が謎です)\ndouble gettime(C c1,C c2)\n{\n    return (dot(c1,c2) < 0 ? -1.0 : 1.0 ) * abs(c2) / abs(c1);\n}\n//円と直線の交点\nvector<C> crosspointCL(C c1,double r1,const L& l)\n{\n    C a=l[0], b=l[1];\n    vector<C> res;\n    C base=b-a,  target=projection(L(a,b),c1);\n    double length=abs(base), h=abs(c1-target);\n    base/=length;\n    if(r1+EPS<h)    return res;\n    double w=Sqrt(r1*r1-h*h);\n    double LL=gettime(normalize(b-a),target-a)-w,RR=LL+w*2.0;\n    res.push_back(a+base*LL);\n    if(eq(LL,RR))   return res;\n    res.push_back(a+base*RR);\n    return res;\n}\n\n//円と線分の交点\nvector<C> crosspointCS(C c1,double r1,const L& s)\n{\n    vector<C> tmp=crosspointCL(c1,r1,s);\n    vector<C> res;\n    rep(i,tmp.size()){\n        if(abs(s[1]-s[0]) == abs(s[0]-tmp[i])+abs(s[1]-tmp[i])){\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n//円どうしの交点\nL crosspointCC(const C c1, const double r1, const C c2, const double r2)\n{\n    C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n    C d = b*b-4.0*a*c;\n    C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n    return L(z1, z2);\n}\n//点pを直線lを軸として対称移動\nC reflection(const L &l, const C p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//点と直線の距離\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n//直線と直線の距離\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//直線と線分の距離\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//線分と点の距離\ndouble distanceSP(const L &s, const C p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//線分と線分の距離\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\ndouble getarea(C c1,double r1,C a,C b)\n{\n    C va=c1-a,vb=c1-b;\n    double A=abs(va),B=abs(vb);\n    double f=cross(va,vb),d=distanceSP(L(a,b),c1),res=0;\n    if(eq(f,0.0))   return 0;\n    if(A < r1+EPS && B < r1+EPS)    return f*0.5;\n    if(d>r1-EPS)    return r1*r1*M_PI*getarg(va,vb)/(2.0*M_PI);\n    vector<C> u=crosspointCS(c1,r1,L(a,b));\n    u.insert(u.begin(),a),u.push_back(b);\n    for(int i=0;i+1<(int)u.size();i++){\n        res+=getarea(c1,r1,u[i],u[i+1]);\n    }\n    return res;\n}\n//円と多角形の共通部分の面積\ndouble getcrossarea(const vector<C>& t,C c1,double r1)\n{\n    int n = (int)t.size();\n    if(n<3) return 0;\n    double res=0;\n    rep(i,n){\n      C a=t[i], b=t[(i+1)%n];\n      res += getarea(c1,r1,a,b);\n    }\n    return res;\n}\n//凸包を求める(O(nlogn))\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = (int)ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//凸性判定\nbool isconvex(const vector<C>& ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//多角形の符号付き面積(左回りが正)\ndouble area(const vector<C>& ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//凸多角形を直線で切断した時の左側の図形\nvector<C> convex_cut(const vector<C>& ps, const L& l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(L(A, B),l));\n    }\n    return Q;\n}\n//垂直二等分線\nL bisector(C a, C b){\n    C A = (a + b) * C(0.5, 0);\n    return L(A, A + rot(b - a, PI/2));\n}\n//ボロノイ図(正確にはvoronoi_cellを求める)\n//愚直であるため1つのvoronoi_cellを求めるのにかかる計算量がO(n^2)\nvector<C> voronoi(vector<C> poly, vector<C>& p, int s){\n    rep(i,(int)p.size()){\n        if (i != s){\n            poly = convex_cut(poly, bisector(p[s], p[i]));\n        }\n    }\n    return poly;\n}\n//点が多角形に包含されているか(0は含まれない,1は辺上,2は含まれる)\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//凸多角形の交差\nvector<C> convex_intersection(const vector<C>& ps,const vector<C>& qs)\n{\n\tvector<C> rs;\n\tint a = ps.size(),b = qs.size();\n\trep(i,a){\n        if(contains(qs,ps[i])){\n            rs.push_back(ps[i]);\n        }\n    }\n\trep(i,b){\n        if(contains(ps,qs[i])){\n            rs.push_back(qs[i]);\n        }\n    }\n    rep(i,a){\n        rep(j,b){\n            L l1(ps[i],ps[(i+1)%a]),l2(qs[j],qs[(j+1)%b]);\n\t\t    if(intersectSS(l1,l2)){\n                rs.push_back(crosspointLL(l1,l2));\n            }\n        }\n\t}\n\tsort(rs.begin(),rs.end());\n\trs.erase(unique(rs.begin(),rs.end()),rs.end());\n\tif(rs.size() <= 1){\n        return rs;\n    }\n\treturn convex_hull(rs);\n}\n//凸多角形の直径を求める(キャリパー法)\n//maxi,maxjが最遠点対となる\ndouble convex_diameter(const vector<C>& ps)\n{\n    const int n = (int)ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nbool compyx(C c1,C c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\ndouble closest_pair(C* a, int n)\n{\n    if(n<=1) return 1e100;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compyx);\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n//最近点対を求める\ndouble compute_shortest(C* a,int n)\n{\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n//2円の位置関係を示す(返り値は2円の間の共通接線の数)\nint getstateCC(C c1,double r1,C c2,double r2)\n{\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)return 4;\n    if(d>r1+r2-EPS)return 3;\n    if(d>abs(r1-r2)+EPS)return 2;\n    if(d>abs(r1-r2)-EPS)return 1;\n    return 0;\n}\n//点から円へ接線を引いた時の接点\nC gettangentCP_(C c1,double r1,C p,int flg){\n    C base=c1-p;\n    double w=Sqrt(norm(base)-r1*r1);\n    C s=p+base*C(w,r1 * flg)/norm(base)*w;\n    return s;\n}\n//点から円への接線\nvector<L> gettangentCP(C c1,double r1,C p){\n    vector<L> res;\n    C s=gettangentCP_(c1,r1,p,1);\n    C t=gettangentCP_(c1,r1,p,-1);\n    //点が円の周上にある場合\n    if(s == t){\n        res.push_back(L(s,s+(c1-p)*C(0,1)));\n    }else{\n        res.push_back(L(p,s));\n        res.push_back(L(p,t));\n    }\n    return res;\n}\n\n//2円の共通内接線を求める\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2円の共通外接線を求める\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2円の共通接線を求める(各直線の２点はそれぞれの円の接点)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\n\nstruct edge\n{\n    int to;\n    double cost;\n};\n\nmap<C,int> mp;\nvector<C> point;\nvector<vector<edge> > G;\nbool stop[MAX_N], visit[MAX_N];\nint prv[MAX_N], used[MAX_N];\nmap<pii,double> kp;\nmap<pii,double> cs;\n\nvoid dfs(int u){\n    visit[u] = true;\n    if(used[u] >= 0){\n        each(e,G[u]){\n            if(e.to != used[u]){\n                kp[pii(min(u,e.to),max(u,e.to))] = e.cost;\n                if(!visit[e.to]){\n                    dfs(e.to);\n                }\n            }\n        }\n    }else{\n        each(e,G[u]){\n            kp[pii(min(u,e.to),max(u,e.to))] = e.cost;\n            if(!visit[e.to]){\n                dfs(e.to);\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    vector<L> line(n);\n    rep(i,n){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        if(C(c,d) < C(a,b)) swap(a,c),swap(b,d);\n        line[i] = L(C(a,b),C(c,d));\n        if(mp.find(C(a,b)) == mp.end()){\n            mp[C(a,b)] = len(point);\n            point.pb(C(a,b));\n        }\n        if(mp.find(C(c,d)) == mp.end()){\n            mp[C(c,d)] = len(point);\n            point.pb(C(c,d));\n        }\n    }\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        if(mp.find(C(a,b)) == mp.end()){\n            mp[C(a,b)] = len(point);\n            point.pb(C(a,b));\n        }\n        stop[mp[C(a,b)]] = true;\n    }\n    int a,b,c,d;\n    cin >> a >> b >> c >> d;\n    if(mp.find(C(a,b)) == mp.end()){\n        mp[C(a,b)] = len(point);\n        point.pb(C(a,b));\n    }\n    if(mp.find(C(c,d)) == mp.end()){\n        mp[C(c,d)] = len(point);\n        point.pb(C(c,d));\n    }\n    int s = mp[C(a,b)], t = mp[C(c,d)];\n    int V = len(point);\n    vector<pii> ch;\n    G.resize(len(point));\n    double al = 0,stream = 0;\n    rep(i,n){\n        vector<C> ten = line[i];\n        rep(j,len(point)){\n            if(intersectSP(line[i],point[j])){\n                ten.pb(point[j]);\n            }\n        }\n        rep(j,n){\n            if(j != i && intersectSS(line[i],line[j])){\n                ten.pb(crosspointLL(line[i],line[j]));\n            }\n        }\n        zip(ten);\n        vi val(len(ten));\n        rep(j,len(ten)){\n            val[j] = mp[ten[j]];\n        }\n        rep(j,len(ten)-1){\n            ch.pb(pii(min(val[j],val[j+1]),max(val[j],val[j+1])));\n            cs[pii(min(val[j],val[j+1]),max(val[j],val[j+1]))] = abs(ten[j+1]-ten[j]);\n        }\n    }\n    zip(ch);\n    rep(i,len(ch)){\n        double val = cs[ch[i]];\n        al += val;\n        G[ch[i].fi].pb((edge){ch[i].se,val}),G[ch[i].se].pb((edge){ch[i].fi,val});\n    }\n    rep(i,V){\n        used[i] = -1;\n    }\n    vd dist(V,INF);\n    priority_queue<P,vp,greater<P> > que;\n    que.push(P(0,t));\n    while(!que.empty()){\n        P p = que.top();\n        que.pop();\n        if(dist[p.se] < p.fi) continue;\n        if(stop[p.se]){\n            used[p.se] = prv[p.se];\n            continue;\n        }\n        if(s == p.se){\n            printf(\"-1\\n\");\n            return 0;\n        }\n        each(e,G[p.se]){\n            if(dist[e.to] > p.fi+e.cost){\n                prv[e.to] = p.se;\n                dist[e.to] = p.fi+e.cost;\n                que.push(P(dist[e.to],e.to));\n            }\n        }\n    }\n    dfs(s);\n    each(it,kp){\n        stream += it.se;\n    }\n    printf(\"%.12lf\\n\",al-stream);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-12)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{  return equals(x,p.x) && equals(y,p.y); }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\ndouble abs(Point a){ return sqrt(norm(a)); }\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\n\nbool intersectSP(Line s, Point p) { return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; }\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\n\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    return vec[1];\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\nstruct Edge {\n  int from,to;\n  double cost;\n  Edge(int from=0,int to=0,double cost=0):from(from),to(to),cost(cost){}\n  bool operator < (const Edge& a)const { return !equals(cost,a.cost) && cost < a.cost; }\n};\n\nvector<vector<Edge> > segmentArrangement(vector<Segment> vs,vector<Point> &ps) {\n  rep(i,vs.size()) REP(j,i+1,vs.size()) if(intersectSS(vs[i],vs[j])) ps.push_back(Point(crosspoint(vs[i],vs[j])));\n\n  sort(ps.begin(),ps.end());  \n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<Edge> > ret(ps.size());\n\n  for(int i=0;i<vs.size();i++){\n    vector<pair<double,int> > list;\n    rep(j,ps.size()) if(intersectSP(vs[i],ps[j]))list.push_back(pair<double,int>(norm(vs[i].p1-ps[j]),j));\n    sort(list.begin(),list.end());\n    for(int j=0;j+1<list.size();++j) {\n      int from = list[j].second, to = list[j+1].second;\n      double cost = abs(ps[from]-ps[to]);\n      ret[from].push_back(Edge(from,to,cost));\n      ret[to].push_back(Edge(to,from,cost));\n    }\n  }  \n  return ret;\n}\n\nint N,M;\nvector<Segment> segs;\nvector<Point> stop;\nPoint source,repairing;\n\nvoid compute(){\n  double total = 0;\n  vector<Point> ps = stop;\n  ps.push_back(source);\n  ps.push_back(repairing);\n  rep(i,(int)segs.size()) ps.push_back(segs[i].p1), ps.push_back(segs[i].p2),\n    total += abs(segs[i].p1-segs[i].p2);\n  vector<vector<Edge> > G = segmentArrangement(segs,ps);\n\n  int sp = -1, rp = -1;\n  rep(i,ps.size()) {\n    if( source == ps[i] ) sp = i;\n    if( repairing == ps[i] ) rp = i;\n  }\n  \n  sort(stop.begin(),stop.end());\n  vector<bool> stopper(ps.size(),false);\n  rep(i,stop.size()) {\n    int position = lower_bound(ps.begin(),ps.end(),stop[i]) - ps.begin();\n    assert( position < ps.size() );\n    stopper[position] = true;\n  }\n\n  deque<int> deq;\n  vector<bool> out(ps.size(),false);\n  deq.push_back(rp);\n  out[rp] = true;\n  while( !deq.empty() ){\n    int cur = deq.front(); deq.pop_front();\n    rep(i,(int)G[cur].size()) {\n      int to = G[cur][i].to;\n      if( out[to] ) continue;\n      out[to] = true;\n      if( stopper[to] ) continue;\n      deq.push_back(to);\n    }\n  }\n\n  if( out[sp] ) { puts(\"-1\"); return; }\n  \n  double reach = 0;\n\n  typedef pair<int,int> ii;\n  set<ii> added,used;\n  assert( deq.empty() );\n  deq.push_back(sp);\n  while( !deq.empty() ){\n    int cur = deq.front(); deq.pop_front();\n    rep(i,(int)G[cur].size()){\n      int to = G[cur][i].to;\n      ii data = ii(min(cur,to),max(cur,to));\n      if( !added.count(data) ) {\n        added.insert(data);\n        reach += abs(ps[cur]-ps[to]);\n      }   \n      if( out[to] ) continue;\n      if( used.count( ii(cur,to) ) ) continue;\n      used.insert(ii(cur,to));\n      deq.push_back(to);\n    }\n  }\n  printf(\"%.10f\\n\",total-reach);\n}\n\nint main(){\n  scanf(\"%d %d\",&N,&M);\n  segs.clear(), stop.clear();\n  segs.resize(N), stop.resize(M);\n  rep(i,N) cin >> segs[i].p1.x >> segs[i].p1.y >> segs[i].p2.x >> segs[i].p2.y;\n  rep(i,M) cin >> stop[i].x >> stop[i].y;\n  cin >> source.x >> source.y;\n  cin >> repairing.x >> repairing.y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n// 点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight;\nint id;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight,const int id) {\n\tg[from].push_back(Edge{ from, to, weight,id});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<pair<Point,bool>> &p) {\n\tint n = p.size(), m = s.size();\n\tint id = 0;\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j].first))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j].first), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from].first - p[to].first), id);\n\t\t\tadd_edge(g, to, from, abs(p[from].first - p[to].first), id++);\n\t\t}\n\t}\n\treturn g;\n}\n\n//Graph sennbunn_arrangement(const vector<Line>&s) {\n//\tvector<Point>crss;\n//\tfor (int i = 0; i < s.size(); ++i) {\n//\t\tfor (int j = i + 1; j < s.size(); ++j) {\n//\t\t\tif (isis_ss( s[i],  s[j])) {\n//\t\t\t\tcrss.push_back(is_ll( s[i],  s[j]));\n//\t\t\t}\n//\t\t}\n//\t}\n//\tfor (int i = 0; i <s.size(); ++i) {\n//\t\tcrss.push_back( s[i][0]);\n//\t\tcrss.push_back( s[i][1]);\n//\t}\n//\treturn segment_arrangement(s, crss);\n//}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nint startid;\nint goalid;\nbool dfs0(const Graph&g,const int now, vector<bool>&came, vector<bool>&close,const vector<bool>&bulbs) {\n\tcame[now] = true;\n\tfor (auto e : g[now]) {\n\t\tif (!came[e.to]) {\n\t\t\tif (e.to == startid)return false;\n\t\t\telse {\n\t\t\t\tif (bulbs[e.to]) {\n\t\t\t\t\tclose[e.to] = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!dfs0(g, e.to, came, close, bulbs)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ndouble dfs1(const Graph&g, const int now, vector<bool>&came,vector<bool>useedges, const vector<bool>&close) {\n\tcame[now] = true;\n\tdouble ans = 0;\n\tfor (auto e : g[now]) {\n\t\tif (!useedges[e.id]) {\n\t\t\tans += e.weight;\n\t\t\tuseedges[e.id] = true;\n\t\t\tif (close[e.to])continue;\n\t\t\telse {\n\t\t\t\tif(!came[e.to])ans += dfs1(g, e.to, came,useedges, close);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tdouble sum = 0;\n\tGraph g;\n\tint sx, sy, gx, gy;\n\tPoint start;\n\tPoint goal;\n\tvector<pair<Point, bool>>crss;\n\tvector<bool>bulbs;\n\t{\n\t\tint N, M; cin >> N >> M;\n\t\tvector<Line>ls;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint asx, asy, dx, dy; cin >> asx >> asy >> dx >> dy;\n\t\t\tls.push_back(Line(Point(asx, asy), Point(dx, dy)));\n\t\t\tsum += (abs(Point(asx, asy) - Point(dx, dy)));\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < ls.size(); ++j) {\n\t\t\t\tif (isis_ss(ls[i], ls[j])) {\n\t\t\t\t\tcrss.push_back(make_pair(is_ll(ls[i], ls[j]),false));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < ls.size(); ++i) {\n\t\t\tcrss.push_back(make_pair(ls[i][0], false));\n\t\t\tcrss.push_back(make_pair(ls[i][1], false));\n\t\t}\n\t\t\n\t\tvector<Point >bs;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tPoint p(x, y);\n\t\t\tbs.push_back(p);\n\t\t}\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tstart = Point(sx, sy);\n\t\tgoal = Point(gx, gy);\t\n\t\tcrss.push_back(make_pair(start, false));\n\t\tcrss.push_back(make_pair(goal, false));\n\t\tsort(crss.begin(), crss.end());\n\t\tcrss.erase(unique(crss.begin(), crss.end()), crss.end());\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tauto it = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == bs[i]; });\n\t\t\tif (it == crss.end()) {\n\t\t\t\tcrss.push_back(make_pair(bs[i], true));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(*it).second = true;\n\t\t\t}\n\t\t}\n\n\n\t\tfor (int i = 0; i < crss.size(); ++i) {\n\t\t\tbulbs.push_back(crss[i].second);\n\t\t}\n\t\tg= segment_arrangement(ls, crss);\n\t}\n\tauto startit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == start; });\n\tstartid = startit - crss.begin();\n\tauto goalit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == goal; });\n\tgoalid = goalit - crss.begin();\n\tvector<bool>close(crss.size(),false);\n\tvector<bool>came(crss.size(), false);\n\tif (dfs0(g, goalid, came, close, bulbs)) {\n\t\tvector<bool>acame(crss.size(), false);\n\t\tvector<bool>useedges(10000, false);\n\t\tdouble ans = dfs1(g, startid, acame, useedges,close);\n\t\tcout <<fixed<<setprecision(10)<< sum-ans << endl;\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<unordered_map>\n#include<utility>\n#include<complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps=1e-9;\n\nmultimap<int,pair<int,double> > g;\nset<int> valves;\nint xb,yb,xc,yc;\nconst int O=1234;\nset<int> stopped,u;\n\nint gcd(int a,int b){\n  return b?gcd(b,a%b):a;\n}\n\nint enc(int x,int y){\n  return (x+O<<16)+y+O;\n}\n\npair<int,int> dec(int x){\n  return make_pair((x>>16)-O,(x&(1<<16)-1)-O);\n}\n\nvoid stop(int v){\n  if(!u.insert(v).second)return;\n  if(valves.count(v)){\n    stopped.insert(v);\n    return;\n  }else{\n    auto p=dec(v);\n    int x=p.first,y=p.second;\n    if(y==yb&&x==xb)throw 0;\n    auto c=g.equal_range(v);\n    for(auto it=c.first;it!=c.second;it++){\n      if(u.count(it->second.first))continue;\n      stop(it->second.first);\n    }\n  }\n}\n\ndouble rec(int v,int p){\n  if(!u.insert(v).second)return 0;\n  if(stopped.count(v))return 0;\n  auto pr=dec(v);\n  int x=pr.first,y=pr.second;\n  auto c=g.equal_range(v);\n  double r=0;\n  for(auto it=c.first;it!=c.second;it++){\n    if(it->second.first==p)continue;\n    auto pr=dec(it->second.first);\n    int nx=pr.first,ny=pr.second;\n    r+=it->second.second+rec(it->second.first,v);\n  }\n  return r;\n}\n\nvoid add_edge(pair<int,int> a,pair<int,int> b){\n  g.insert(make_pair(enc(a.first,a.second),make_pair(enc(b.first,b.second),hypot(a.first-b.first,a.second-b.second))));\n}\n\nvoid add_edge(int x1,int y1,int x2,int y2,P p){\n  g.insert(make_pair(enc(x1,y1),make_pair(enc(x2,y2),abs(p-P(x1,y1))+abs(p-P(x2,y2)))));\n}\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nbool intersects(P a1,P a2,P b1,P b2){\n  P a=a1-a2;\n  P b=b1-b2;\n  return cross(b1-a2,a)*cross(b2-a2,a)<=0&&cross(a1-b2,b)*cross(a2-b2,b)<=0;\n}\n\n//line,line\nP intersection(P a1,P a2,P b1,P b2){\n  P a=a2-a1;\n  P b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\nvoid set_near(int x1,int x2,int &dx1,int &dx2,int m,double d){\n  int r=(x2-x1)/m;\n  dx1=int((d-x1)/r)*r+x1;\n  dx2=dx1+r;\n}\n\nvoid set_lattice(int x1,int y1,int x2,int y2,int &dx1,int &dy1,int &dx2,int &dy2,P p){\n  if(x1==x2){\n    dx1=dx2=x1;\n    dy1=p.imag();\n    dy2=dy1+1;\n  }else if(y1==y2){\n    dy1=dy2=y1;\n    dx1=p.real();\n    dx2=dx1+1;\n  }else{\n    if(x1>x2){\n      swap(x1,x2);\n      swap(y1,y2);\n    }\n    int m=gcd(x2-x1,abs(y2-y1));\n    set_near(x1,x2,dx1,dx2,m,p.real());\n    set_near(y1,y2,dy1,dy2,m,p.real());\n  }\n}\n\n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  double len=0;\n  int xss[323],yss[323],xds[323],yds[323];\n  for(int i=0;i<N;i++){\n    int xs,ys,xd,yd;\n    cin>>xs>>ys>>xd>>yd;\n    xss[i]=xs;\n    yss[i]=ys;\n    xds[i]=xd;\n    yds[i]=yd;\n    len+=hypot(xs-xd,ys-yd);\n    vector<pair<int,int> > v;\n    if(xs==xd||ys==yd){\n      if(xs>xd){\n\tswap(xs,xd);\n      }\n      if(ys>yd){\n\tswap(ys,yd);\n      }\n      for(int x=xs,y=ys;x<=xd&&y<=yd;x+=xs!=xd,y+=ys!=yd){\n\tv.emplace_back(x,y);\n      }\n    }else{\n      if(xd<xs){\n\tswap(xs,xd);\n\tswap(ys,yd);\n      }\n      int m=gcd(xd-xs,abs(yd-ys));\n      for(int y=ys,x=xs;x<=xd;x+=(xd-xs)/m,y+=(yd-ys)/m){\n\tv.emplace_back(x,y);\n      }\n    }\n    for(int i=0;i<v.size()-1;i++){\n      add_edge(v[i],v[i+1]);\n      add_edge(v[i+1],v[i]);\n    }\n  }\n  for(int i=0;i<N;i++){\n    P si=P(xss[i],yss[i]),ti=P(xds[i],yds[i]);\n    for(int j=i+1;j<N;j++){\n      P sj=P(xss[j],yss[j]),tj=P(xds[j],yds[j]);\n      if(intersects(si,ti,sj,tj)){\n\tP p=intersection(si,ti,sj,tj);\n\tP n=P(round(p.real()),round(p.imag()));\n\tif(abs(n-p)>eps){\n\t  int xs1,ys1,xt1,yt1,xs2,ys2,xt2,yt2;\n\t  set_lattice(xss[i],yss[i],xds[i],yds[i],xs1,ys1,xs1,ys1,p);\n\t  set_lattice(xss[j],yss[j],xds[j],yds[j],xs2,ys2,xs2,ys2,p);\n\t  add_edge(xs1,ys1,xs2,ys2,p);\n\t  add_edge(xs1,ys1,xt2,yt2,p);\n\t  add_edge(xt1,yt1,xs2,ys2,p);\n\t  add_edge(xt1,yt1,xt2,yt2,p);\n\t  add_edge(xs2,ys2,xs1,ys1,p);\n\t  add_edge(xs2,ys2,xt1,yt1,p);\n\t  add_edge(xt2,yt2,xs1,ys1,p);\n\t  add_edge(xt2,yt2,xt1,yt1,p);\n\t}\n      }\n    }\n  }\n  for(int i=0;i<M;i++){\n    int xv,yv;\n    cin>>xv>>yv;\n    valves.insert(enc(xv,yv));\n  }\n  cin>>xb>>yb>>xc>>yc;\n  try{\n    stop(enc(xc,yc));\n    u.clear();\n    cout.precision(9);\n    cout<<fixed<<len-rec(enc(xb,yb),-1)<<endl;\n  }catch(...){\n    cout<<-1<<endl;\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-7;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct segment{ point<T> a,b; };\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<double> &S,const point<double> &p){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\npoint<double> get_intersect(const segment<double> &S1,const segment<double> &S2){\n\tdouble a1=cross(S1.b-S1.a,S2.b-S2.a);\n\tdouble a2=cross(S1.b-S1.a,S1.b-S2.a);\n\tif(abs(a1)<EPS){\n\t\tif(cover(S1,S2.a)) return S2.a;\n\t\tif(cover(S1,S2.b)) return S2.b;\n\t\tif(cover(S2,S1.a)) return S1.a;\n\t\treturn S1.b;\n\t}\n\treturn S2.a+a2/a1*(S2.b-S2.a);\n}\n\n// 追加で頂点集合を指定できるように書き換え\nvoid arrangement(const vector< segment<double> > &S,const vector< point<double> > &plus,vector< point<double> > &P,vector<int> *G){\n\tint n=S.size();\n\tP=plus;\n\trep(i,n){\n\t\tP.push_back(S[i].a);\n\t\tP.push_back(S[i].b);\n\t\trep(j,i) if(intersect(S[i],S[j])) P.push_back(get_intersect(S[i],S[j]));\n\t}\n\tsort(P.begin(),P.end());\n\tP.erase(unique(P.begin(),P.end()),P.end());\n\n\trep(i,n){\n\t\tvector<int> on;\n\t\trep(u,P.size()) if(cover(S[i],P[u])) on.push_back(u);\n\t\trep(j,(int)on.size()-1){\n\t\t\tint u=on[j],v=on[j+1];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tvector< segment<double> > pipe(n);\n\trep(i,n) scanf(\"%lf%lf%lf%lf\",&pipe[i].a.x,&pipe[i].a.y,&pipe[i].b.x,&pipe[i].b.y);\n\tvector< point<double> > stop(m);\n\trep(i,m) scanf(\"%lf%lf\",&stop[i].x,&stop[i].y);\n\tpoint<double> s,t;\n\tscanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&t.x,&t.y);\n\n\t// 追加の頂点集合\n\tvector< point<double> > plus=stop;\n\tplus.push_back(s);\n\tplus.push_back(t);\n\n\tvector< point<double> > P;\n\tstatic vector<int> G[100000];\n\tarrangement(pipe,plus,P,G);\n\n\tint N=P.size();\n\tstatic bool isstop[100000];\n\trep(i,m) rep(u,N) if(P[u]==stop[i]) isstop[u]=true;\n\n\tint s_id=find(P.begin(),P.end(),s)-P.begin();\n\tint t_id=find(P.begin(),P.end(),t)-P.begin();\n\n\t// t から stop をまたがずに行ける場所を見つける\n\tstatic bool vis[100000];\n\tvis[t_id]=true;\n\tqueue<int> Q; Q.push(t_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=true;\n\t\t\t\tif(!isstop[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(vis[s_id]){ puts(\"-1\"); return 0; }\n\n\tdouble ans=0;\n\trep(i,n) ans+=dist(pipe[i].a,pipe[i].b);\n\n\t// s から vis を通らずに行ける場所を見つける\n\tstatic bool vis2[100000];\n\tvis2[s_id]=true;\n\tQ.push(s_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v]=true;\n\t\t\t\tif(!vis[v]) Q.push(v);\n\t\t\t}\n\t\t\tif(vis[v]) ans-=dist(P[u],P[v]);   // 一回カウントされる\n\t\t\telse       ans-=dist(P[u],P[v])/2; // 二回カウントされる\n\t\t}\n\t}\n\tprintf(\"%.9f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-8\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<double,int> P;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\ntypedef complex<double> C;\n\nconst double PI = 4*atan(1.0);\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n    bool operator > (const C a, const C b) {\n        return a.real() != b.real() ? a.real() > b.real() : a.imag() > b.imag();\n    }\n    //点をsetとかmapにつめたいとき(誤差を1e-10とか厳しくし過ぎるとバグる)\n    // bool operator<(const C a, const C b){\n    //     return abs(a.real()-b.real())>EPS ? a.real()<b.real()-EPS : a.imag()<b.imag()-EPS;\n    // }\n    bool operator==(const C a, const C b){\n        return (eq(a.real(),b.real()) && eq(a.imag(),b.imag()));\n    }\n    bool operator!=(const C a, const C b){\n        return !(a == b);\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(){}\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\n//条件付きsqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//正規化\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//角度(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//外積\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//内積\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nC rot(C c,double th)\n{\n    return c * C(cos(th),sin(th));\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\n//直線どうしの交差判定(同一直線はTrue)\nbool intersectLL(const L& l, const L& m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//直線と線分の交差判定(一点共有も交差と判定)\nbool intersectLS(const L& l, const L& s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//直線と点の交差(共有)判定\nbool intersectLP(const L& l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//線分どうしの交差判定(一点共有も交差と判定)\nbool intersectSS(const L& s, const L& t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//線分と点の交差(共有)判定\nbool intersectSP(const L& s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//直線および線分の交点\nC crosspointLL(const L& l, const L& m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //同一直線のとき\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//点pを直線l上に射影\nC projection(const L& l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//crosspointCLに使用する関数(命名が謎です)\ndouble gettime(C c1,C c2)\n{\n    return (dot(c1,c2) < 0 ? -1.0 : 1.0 ) * abs(c2) / abs(c1);\n}\n//円と直線の交点\nvector<C> crosspointCL(C c1,double r1,const L& l)\n{\n    C a=l[0], b=l[1];\n    vector<C> res;\n    C base=b-a,  target=projection(L(a,b),c1);\n    double length=abs(base), h=abs(c1-target);\n    base/=length;\n    if(r1+EPS<h)    return res;\n    double w=Sqrt(r1*r1-h*h);\n    double LL=gettime(normalize(b-a),target-a)-w,RR=LL+w*2.0;\n    res.push_back(a+base*LL);\n    if(eq(LL,RR))   return res;\n    res.push_back(a+base*RR);\n    return res;\n}\n\n//円と線分の交点\nvector<C> crosspointCS(C c1,double r1,const L& s)\n{\n    vector<C> tmp=crosspointCL(c1,r1,s);\n    vector<C> res;\n    rep(i,tmp.size()){\n        if(abs(s[1]-s[0]) == abs(s[0]-tmp[i])+abs(s[1]-tmp[i])){\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n//円どうしの交点\nL crosspointCC(const C c1, const double r1, const C c2, const double r2)\n{\n    C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n    C d = b*b-4.0*a*c;\n    C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n    return L(z1, z2);\n}\n//点pを直線lを軸として対称移動\nC reflection(const L &l, const C p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//点と直線の距離\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n//直線と直線の距離\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//直線と線分の距離\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//線分と点の距離\ndouble distanceSP(const L &s, const C p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//線分と線分の距離\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\ndouble getarea(C c1,double r1,C a,C b)\n{\n    C va=c1-a,vb=c1-b;\n    double A=abs(va),B=abs(vb);\n    double f=cross(va,vb),d=distanceSP(L(a,b),c1),res=0;\n    if(eq(f,0.0))   return 0;\n    if(A < r1+EPS && B < r1+EPS)    return f*0.5;\n    if(d>r1-EPS)    return r1*r1*M_PI*getarg(va,vb)/(2.0*M_PI);\n    vector<C> u=crosspointCS(c1,r1,L(a,b));\n    u.insert(u.begin(),a),u.push_back(b);\n    for(int i=0;i+1<(int)u.size();i++){\n        res+=getarea(c1,r1,u[i],u[i+1]);\n    }\n    return res;\n}\n//円と多角形の共通部分の面積\ndouble getcrossarea(const vector<C>& t,C c1,double r1)\n{\n    int n = (int)t.size();\n    if(n<3) return 0;\n    double res=0;\n    rep(i,n){\n      C a=t[i], b=t[(i+1)%n];\n      res += getarea(c1,r1,a,b);\n    }\n    return res;\n}\n//凸包を求める(O(nlogn))\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = (int)ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//凸性判定\nbool isconvex(const vector<C>& ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//多角形の符号付き面積(左回りが正)\ndouble area(const vector<C>& ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//凸多角形を直線で切断した時の左側の図形\nvector<C> convex_cut(const vector<C>& ps, const L& l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(L(A, B),l));\n    }\n    return Q;\n}\n//垂直二等分線\nL bisector(C a, C b){\n    C A = (a + b) * C(0.5, 0);\n    return L(A, A + rot(b - a, PI/2));\n}\n//ボロノイ図(正確にはvoronoi_cellを求める)\n//愚直であるため1つのvoronoi_cellを求めるのにかかる計算量がO(n^2)\nvector<C> voronoi(vector<C> poly, vector<C>& p, int s){\n    rep(i,(int)p.size()){\n        if (i != s){\n            poly = convex_cut(poly, bisector(p[s], p[i]));\n        }\n    }\n    return poly;\n}\n//点が多角形に包含されているか(0は含まれない,1は辺上,2は含まれる)\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//凸多角形の交差\nvector<C> convex_intersection(const vector<C>& ps,const vector<C>& qs)\n{\n\tvector<C> rs;\n\tint a = ps.size(),b = qs.size();\n\trep(i,a){\n        if(contains(qs,ps[i])){\n            rs.push_back(ps[i]);\n        }\n    }\n\trep(i,b){\n        if(contains(ps,qs[i])){\n            rs.push_back(qs[i]);\n        }\n    }\n    rep(i,a){\n        rep(j,b){\n            L l1(ps[i],ps[(i+1)%a]),l2(qs[j],qs[(j+1)%b]);\n\t\t    if(intersectSS(l1,l2)){\n                rs.push_back(crosspointLL(l1,l2));\n            }\n        }\n\t}\n\tsort(rs.begin(),rs.end());\n\trs.erase(unique(rs.begin(),rs.end()),rs.end());\n\tif(rs.size() <= 1){\n        return rs;\n    }\n\treturn convex_hull(rs);\n}\n//凸多角形の直径を求める(キャリパー法)\n//maxi,maxjが最遠点対となる\ndouble convex_diameter(const vector<C>& ps)\n{\n    const int n = (int)ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nbool compyx(C c1,C c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\ndouble closest_pair(C* a, int n)\n{\n    if(n<=1) return 1e100;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compyx);\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n//最近点対を求める\ndouble compute_shortest(C* a,int n)\n{\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n//2円の位置関係を示す(返り値は2円の間の共通接線の数)\nint getstateCC(C c1,double r1,C c2,double r2)\n{\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)return 4;\n    if(d>r1+r2-EPS)return 3;\n    if(d>abs(r1-r2)+EPS)return 2;\n    if(d>abs(r1-r2)-EPS)return 1;\n    return 0;\n}\n//点から円へ接線を引いた時の接点\nC gettangentCP_(C c1,double r1,C p,int flg){\n    C base=c1-p;\n    double w=Sqrt(norm(base)-r1*r1);\n    C s=p+base*C(w,r1 * flg)/norm(base)*w;\n    return s;\n}\n//点から円への接線\nvector<L> gettangentCP(C c1,double r1,C p){\n    vector<L> res;\n    C s=gettangentCP_(c1,r1,p,1);\n    C t=gettangentCP_(c1,r1,p,-1);\n    //点が円の周上にある場合\n    if(s == t){\n        res.push_back(L(s,s+(c1-p)*C(0,1)));\n    }else{\n        res.push_back(L(p,s));\n        res.push_back(L(p,t));\n    }\n    return res;\n}\n\n//2円の共通内接線を求める\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2円の共通外接線を求める\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2円の共通接線を求める(各直線の２点はそれぞれの円の接点)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\n\nstruct edge\n{\n    int to;\n    double cost;\n};\n\nmap<C,int> mp;\nvector<C> point;\nvector<vector<edge> > G;\nmap<pii,int> prv;\nbool stop[MAX_N], visit[MAX_N];\nmap<pii,double> kp;\nmap<pii,double> cs;\n\nvoid dfs(int u){\n    visit[u] = true;\n    each(e,G[u]){\n        if(!prv[P(min(u,e.to),max(u,e.to))]){\n            kp[pii(min(u,e.to),max(u,e.to))] = e.cost;\n            if(!visit[e.to]){\n                dfs(e.to);\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    vector<L> line(n);\n    rep(i,n){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        if(C(c,d) < C(a,b)) swap(a,c),swap(b,d);\n        line[i] = L(C(a,b),C(c,d));\n        if(mp.find(C(a,b)) == mp.end()){\n            mp[C(a,b)] = len(point);\n            point.pb(C(a,b));\n        }\n        if(mp.find(C(c,d)) == mp.end()){\n            mp[C(c,d)] = len(point);\n            point.pb(C(c,d));\n        }\n    }\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        if(mp.find(C(a,b)) == mp.end()){\n            mp[C(a,b)] = len(point);\n            point.pb(C(a,b));\n        }\n        stop[mp[C(a,b)]] = true;\n    }\n    int a,b,c,d;\n    cin >> a >> b >> c >> d;\n    if(mp.find(C(a,b)) == mp.end()){\n        mp[C(a,b)] = len(point);\n        point.pb(C(a,b));\n    }\n    if(mp.find(C(c,d)) == mp.end()){\n        mp[C(c,d)] = len(point);\n        point.pb(C(c,d));\n    }\n    int s = mp[C(a,b)], t = mp[C(c,d)];\n    rep(i,n){\n        rep(j,n){\n            if(j != i && intersectSS(line[i],line[j])){\n                C res = crosspointLL(line[i],line[j]);\n                if(mp.find(res) != mp.end()){\n                    mp[res] = len(point);\n                    point.pb(res);\n                }\n            }\n        }\n    }\n    int V = len(point);\n    vector<pii> ch;\n    G.resize(len(point));\n    double al = 0,stream = 0;\n    rep(i,n){\n        vector<C> ten = line[i];\n        rep(j,V){\n            if(intersectSP(line[i],point[j])){\n                ten.pb(point[j]);\n            }\n        }\n        zip(ten);\n        vi val(len(ten));\n        rep(j,len(ten)){\n            val[j] = mp[ten[j]];\n        }\n        rep(j,len(ten)-1){\n            ch.pb(pii(min(val[j],val[j+1]),max(val[j],val[j+1])));\n            cs[pii(min(val[j],val[j+1]),max(val[j],val[j+1]))] = abs(ten[j+1]-ten[j]);\n        }\n    }\n    zip(ch);\n    rep(i,len(ch)){\n        double val = cs[ch[i]];\n        al += val;\n        G[ch[i].fi].pb((edge){ch[i].se,val}),G[ch[i].se].pb((edge){ch[i].fi,val});\n    }\n    queue<int> que;\n    visit[t] = true;\n    que.push(t);\n    while(!que.empty()){\n        int p = que.front();\n        que.pop();\n        if(stop[p]) continue;\n        if(s == p){\n            printf(\"-1\\n\");\n            return 0;\n        }\n        each(e,G[p]){\n            prv[pii(min(p,e.to),max(p,e.to))] = 1;\n            if(!visit[e.to]){\n                visit[e.to] = true;\n                que.push(e.to);\n            }\n        }\n    }\n    fill(visit,visit+V,false);\n    dfs(s);\n    each(it,kp){\n        stream += it.se;\n    }\n    printf(\"%.12lf\\n\",al-stream);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconstexpr double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\texplicit point(double x_ = 0.0, double y_ = 0.0):x(x_), y(y_) {}\n\tpoint(const point &p):x(p.x), y(p.y) {}\n\n\tpoint operator+(const point &p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator-(const point &p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator*(double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tbool operator<(const point &p) const {\n\t\treturn x + EPS < p.x || (abs(x - p.x) < EPS && y + EPS < p.y);\n\t}\n\n\tbool operator==(const point &p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ndouble norm(const point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ndouble abs(const point &p) {\n\treturn sqrt(norm(p));\n}\n\ndouble dot(const point &a, const point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const point &a, const point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nstruct segment {\n\tpoint a, b;\n\tsegment(const point &a_, const point &b_):a(a_), b(b_){}\n};\n\nint ccw(const point &a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\nbool intersect(const segment &s, const segment &t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n\t\t&& ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\nbool intersect(const segment &s, const point &p) {\n\treturn ccw(s.a, s.b, p) == 0;\n}\n\n// 先にintersectで交差判定をすること\npoint crosspoint(const segment &s, const segment &t) {\n\tconst double tmp = cross(s.b - s.a, t.b - t.a);\n\tif(abs(tmp) < EPS) { // 一直線上\n\t\tif(intersect(s, t.a)) return t.a;\n\t\tif(intersect(s, t.b)) return t.b;\n\t\tif(intersect(t, s.a)) return s.a;\n\t\treturn s.b;\n\t}\n\treturn t.a + (t.b - t.a) * (cross(s.b - s.a, s.b - t.a) / tmp);\n}\n\nstruct edge {\n\tint to;\n\tdouble cost;\n\tedge(int to_, double cost_):to(to_), cost(cost_) {}\n};\n\nvoid merge(vector<segment> &segments) {\n    for(int i = 0; i < static_cast<int>(segments.size());) {\n        const auto &s1 = segments[i];\n        bool ok = true;\n        for(int j = i + 1; j < static_cast<int>(segments.size()); ++j) {\n            const auto &s2 = segments[j];\n \n            if(intersect(s1, s2) && abs(cross(s1.a - s1.b, s2.a - s2.b)) < EPS) {\n\t\t\t\tconst auto a = min({s1.a, s1.b, s2.a, s2.b});\n\t\t\t\tconst auto b = max({s1.a, s1.b, s2.a, s2.b});\n                segments.emplace_back(a, b);\n \n                segments.erase(segments.begin() + j);\n                segments.erase(segments.begin() + i);\n                ok = false;\n                break;\n            }\n        }\n        if(ok) ++i;\n    }\n}\n\nvector<vector<edge>> arrangement(vector<segment> &segments, vector<point> &points) {\n\tmerge(segments);\n\tconst int n = segments.size();\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tconst auto &s1 = segments[i];\n\t\tpoints.emplace_back(s1.a);\n\t\tpoints.emplace_back(s1.b);\n\n\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\tconst auto &s2 = segments[j];\n\t\t\tif(intersect(s1, s2)) {\n\t\t\t\tpoints.emplace_back(crosspoint(s1, s2));\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(points.begin(), points.end());\n\tpoints.erase(unique(points.begin(), points.end()), points.end());\n\n\tconst int V = points.size();\n\tvector<vector<edge>> G(V);\n\n\tfor(const auto &s : segments) {\n\t\tvector<pair<double, int>> vs;\n\t\tfor(int i = 0; i < V; ++i) {\n\t\t\tif(intersect(s, points[i])) {\n\t\t\t\tvs.emplace_back(abs(s.a - points[i]), i);\n\t\t\t}\n\t\t}\n\n\t\tsort(vs.begin(), vs.end());\n\t\tfor(int i = 1; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tconst int v = vs[i].second;\n\t\t\tconst int u = vs[i - 1].second;\n\t\t\tconst double d = vs[i].first - vs[i - 1].first;\n\t\t\tG[v].emplace_back(u, d);\n\t\t\tG[u].emplace_back(v, d);\n\t\t}\n\t}\n\n\treturn G;\n}\n\ninline int get_index(const point &p, const vector<point> &points) {\n\treturn lower_bound(begin(points), end(points), p) - begin(points);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<segment> segments;\n\tsegments.reserve(n);\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tsegments.emplace_back(point(x1, y1), point(x2, y2));\n\t}\n\n\tvector<point> stop;\n\tstop.reserve(m + 2);\n\n\tfor(int i = 0; i < m; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tstop.emplace_back(x, y);\n\t}\n\n\tpoint source, repair;\n\tcin >> source.x >> source.y;\n\tcin >> repair.x >> repair.y;\n\n\tvector<point> points(stop);\n\tpoints.emplace_back(source);\n\tpoints.emplace_back(repair);\n\n\tconst auto G = arrangement(segments, points);\n\tconst int V = G.size();\n\n\tvector<bool> is_stop(V, false);\n\tfor(const auto &p : stop) {\n\t\tis_stop[get_index(p, points)] = true;\n\t}\n\n\tvector<bool> visited(V, false);\n\tqueue<int> que;\n\n\tconst int s = get_index(source, points);\n\tconst int r = get_index(repair, points);\n\tvisited[r] = true;\n\tque.push(r);\n\n\twhile(!que.empty()) {\n\t\tconst int v = que.front();\n\t\tque.pop();\n\n\t\tif(v == s) {\n\t\t\tcout << \"-1\" << endl;\n\t\t\treturn EXIT_SUCCESS;\n\t\t}\n\n\t\tfor(const auto &e : G[v]) {\n\t\t\tif(!visited[e.to] && !is_stop[e.to]) {\n\t\t\t\tvisited[e.to] = true;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans = 0.0;\n\tfor(const auto &seg : segments) ans += abs(seg.a - seg.b);\n\t\n\tvector<bool> used(V, false);\n\tused[s] = true;\n\tque.push(s);\n\n\twhile(!que.empty()) {\n\t\tconst int v = que.front();\n\t\tque.pop();\n\n\t\tif(visited[v]) continue;\n\n\t\tfor(const auto &e : G[v]) {\n\t\t\tif(visited[e.to]) continue;\n\n\t\t\tans -= e.cost * 0.5;\n\t\t\t\n\t\t\tif(!used[e.to]) {\n\t\t\t\tused[e.to] = true;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-12)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{  return equals(x,p.x) && equals(y,p.y); }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool TLE(double a,double b) { return equals(a,b) || a < b; }\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev から cur へ行って next へ行く際の角度を求める\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\n\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\n\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    return vec[1];\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\nstruct Edge {\n  int from,to;\n  double cost;\n  Edge(int from=0,int to=0,double cost=0):from(from),to(to),cost(cost){}\n  bool operator < (const Edge& a)const { return !equals(cost,a.cost) && cost < a.cost; }\n};\n\nvector<vector<Edge> > segmentArrangement(vector<Segment> vs,vector<Point> &ps) {\n  rep(i,vs.size())\n    REP(j,i+1,vs.size())\n    if(intersectSS(vs[i],vs[j]))\n      ps.push_back(Point(crosspoint(vs[i],vs[j])));\n\n  sort(ps.begin(),ps.end());  \n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<Edge> > ret(ps.size());\n\n  for(int i=0;i<vs.size();i++){\n    vector<pair<double,int> > list;\n    rep(j,ps.size()) if(intersectSP(vs[i],ps[j]))list.push_back(pair<double,int>(norm(vs[i].p1-ps[j]),j));\n    sort(list.begin(),list.end());\n    for(int j=0;j+1<list.size();++j) {\n      int from = list[j].second, to = list[j+1].second;\n      double cost = abs(ps[from]-ps[to]);\n      ret[from].push_back(Edge(from,to,cost));\n      ret[to].push_back(Edge(to,from,cost));\n    }\n  }  \n  return ret;\n}\n\nint N,M;\nvector<Segment> segs;\nvector<Point> stop;\nPoint source,repairing;\n\nvoid compute(){\n  double total = 0;\n  vector<Point> ps = stop;\n  ps.push_back(source);\n  ps.push_back(repairing);\n  rep(i,(int)segs.size()) ps.push_back(segs[i].p1), ps.push_back(segs[i].p2),\n    total += abs(segs[i].p1-segs[i].p2);\n  vector<vector<Edge> > G = segmentArrangement(segs,ps);\n\n  int sp = -1, rp = -1;\n  rep(i,ps.size()) {\n    if( source == ps[i] ) sp = i;\n    if( repairing == ps[i] ) rp = i;\n  }\n  assert( sp != -1 && rp != -1 );\n  \n  sort(stop.begin(),stop.end());\n  vector<bool> stopper(ps.size(),false);\n  rep(i,stop.size()) {\n    int position = lower_bound(ps.begin(),ps.end(),stop[i]) - ps.begin();\n    assert( position < ps.size() );\n    stopper[position] = true;\n  }\n\n  deque<int> deq;\n  vector<bool> out(ps.size(),false);\n  deq.push_back(rp);\n  out[rp] = true;\n  while( !deq.empty() ){\n    int cur = deq.front(); deq.pop_front();\n    rep(i,(int)G[cur].size()) {\n      int to = G[cur][i].to;\n      if( out[to] ) continue;\n      out[to] = true;\n      if( stopper[to] ) continue;\n      deq.push_back(to);\n    }\n  }\n\n  if( out[sp] ) { puts(\"-1\"); return; }\n  \n  double reach = 0;\n\n  typedef pair<int,int> ii;\n  set<ii> added,used;\n  assert( deq.empty() );\n  deq.push_back(sp);\n  while( !deq.empty() ){\n    int cur = deq.front(); deq.pop_front();\n    rep(i,(int)G[cur].size()){\n      int to = G[cur][i].to;\n      ii data = ii(min(cur,to),max(cur,to));\n      if( !added.count(data) ) {\n        added.insert(data);\n        reach += abs(ps[cur]-ps[to]);\n      }   \n      if( out[to] ) continue;\n      if( used.count( ii(cur,to) ) ) continue;\n      used.insert(ii(cur,to));\n      deq.push_back(to);\n    }\n  }\n  //cout << \"total = \" << total << endl;\n  //cout << \"reach = \" << reach << endl;\n  printf(\"%.10f\\n\",total-reach);\n  \n}\n\nint main(){\n  scanf(\"%d %d\",&N,&M);\n  segs.clear();\n  segs.resize(N);\n  stop.clear();\n  stop.resize(M);\n  rep(i,N) cin >> segs[i].p1.x >> segs[i].p1.y >> segs[i].p2.x >> segs[i].p2.y;\n  rep(i,M) cin >> stop[i].x >> stop[i].y;\n  cin >> source.x >> source.y;\n  cin >> repairing.x >> repairing.y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\n#define tpl(...) make_tuple(__VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T>ostream&operator<<(ostream &o,const vector<T>&t){o<<'[';FOR(i,t){if(i!=t.begin())o<<',';o<<*i;}return o<<']';}\ntemplate<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}\ntemplate<int N,class Tp>void output(ostream&,const Tp&){}\ntemplate<int N,class Tp,class,class ...Ts>void output(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);output<N+1,Tp,Ts...>(o,t);}\ntemplate<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';output<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}\ntemplate<class T>void output(T t,char z=10){if(t<0)t=-t,putchar(45);int c[20];\nint k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;)putchar(c[--k]^48);putchar(z);}\ntemplate<class T>void outputs(T t){output(t);}\ntemplate<class S,class ...T>void outputs(S a,T...t){output(a,32);outputs(t...);}\ntemplate<class T>void output(T *a,int n){REP(i,n)cout<<a[i]<<(i!=n-1?',':'\\n');}\ntemplate<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}\ntemplate<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);\nif(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());)t=10*t+c-48;t=n?-t:t;return 1;}\ntemplate<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}\n\ntemplate<class T>\nstruct Pt {\n  T x,y;\n  Pt(T x=T(), T y=T()) :x(x),y(y) {}\n  bool operator<(const Pt &p) const { return x!=p.x?x<p.x:y<p.y; }\n  bool operator==(const Pt &p) const { return x==p.x&&y==p.y; }\n  Pt operator+=(const Pt &p) { x+=p.x, y+=p.y; return *this; }\n  Pt operator-=(const Pt &p) { x-=p.x, y-=p.y; return *this; }\n  Pt operator*=(const Pt &p) { T t=x;x=x*p.x-y*p.y,y=t*p.y+y*p.x; return *this;}\n  Pt operator*=(const T &v) { x*=v; y*=v; return *this;}\n  friend ostream& operator<<(ostream& os, const Pt &p) {return os<<'('<<p.x<<','<<p.y<<')';}\n  friend istream& operator>>(istream& is, Pt &p) {return is>>p.x>>p.y;}\n\n  Pt operator+(const Pt &p) const { return Pt(*this)+=p; }\n  Pt operator-(const Pt &p) const { return Pt(*this)-=p; }\n  Pt operator*(const Pt &p) const { return Pt(*this)*=p; }\n  Pt operator*(const T &v) const { return Pt(*this)*=v; }\n  friend Pt operator*(const T &v, const Pt &p) { return p*v; }\n  bool operator!=(const Pt &p) const { return !(*this == p); }\n\n  T abs() const { return hypot(x,y); }\n  T norm() const { return x*x+y*y; }\n  T arg() const { return atan2(y,x); }\n  T dot(const Pt &p) const { return x*p.x+y*p.y; }\n  T det(const Pt &p) const { return x*p.y-y*p.x; }\n  friend T abs(const Pt &p) { return p.abs(); }\n  friend T norm(const Pt &p) { return p.norm(); }\n  friend T arg(const Pt &p) { return p.arg(); }\n  friend T dot(const Pt &p, const Pt &q) { return p.dot(q); }\n  friend T det(const Pt &p, const Pt &q) { return p.det(q); }\n};\n\nint sig(double r) {return r<-EPS?-1:r>EPS?1:0;}\nint sig(ll r) {return r<0?-1:r>0?1:0;}\nbool eq(double a, double b) {return sig(a-b)==0;}\nbool eq(ll a, ll b) {return a==b;}\n\ntemplate<class T>int ccw(Pt<T> a, Pt<T> b, Pt<T> c); // 2(c--a--b), -2(a--b--c), 0(a=-c-=b)\n\ntemplate<> int ccw(Pt<ll> a, Pt<ll> b, Pt<ll> c) {\n  b -= a; c -= a;\n  return det(b,c) ? sig(det(b,c)) : dot(b,c)<0 ? 2 : (0<b.norm()&&b.norm()<c.norm()) ? -2 : 0;\n}\ntemplate<> int ccw(Pt<double> a, Pt<double> b, Pt<double> c) {\n  b -= a; c -= a;\n  if (det(b,c)) return sig(det(b,c));\n  if (sig(dot(b, c)) == -1) return +2; // c--a--b\n  if (EPS < b.norm() && b.norm() < c.norm()-EPS) return -2; // a--b--c\n  return 0;\n}\n\ntypedef Pt<double> P;\n\nclass L {\n  vector<P> v;\npublic:\n  L(const P &a, const P &b) : v({a,b,b-a}) {}\n  const P operator[](int i) const { return v[i]; }\n  void sub(const P&p) { v[0] -= p; v[1] -= p; }\n  friend ostream &operator<<(ostream &os, const L &l) {\n    return os << l[0] << \"->\" << l[1];\n  }\n};\n\nbool iSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool iSP(const L &s, const P &p) {\n\n  return sig(abs(s[0]-p)+abs(s[1]-p)-abs(s[2])) <= 0;\n};\n\nP crosspoint(const L &l, const L &m) {\n  auto A = det(l[2],m[2]);\n  auto B = det(l[2],l[1]-m[0]);\n  if (!sig(A) && !sig(B)) return m[0];// same line\n  if (!sig(A)) assert(0); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B/A*m[2];\n}\n\ntypedef vector<int> Edges;\ntypedef vector<Edges> Graph;\n\nGraph segmentArrangement(const vector<L> &ss, vector<P> &ps) {\n  int n = ss.size();\n  REP(i,n) {\n    ps.push_back( ss[i][0] );\n    ps.push_back( ss[i][1] );\n    for (int j = i+1; j < n; ++j)\n      if (iSS(ss[i], ss[j]))\n        ps.push_back( crosspoint(ss[i], ss[j]) );\n  }\n  sort(ALL(ps)); ps.erase(unique(ALL(ps)), ps.end());\n  Graph g(ps.size());\n  REP(i,ss.size()) {\n    vector<pair<double,int> > v;\n    REP(j,ps.size()) if (iSP(ss[i], ps[j])) {\n      v.emplace_back(norm(ss[i][0]-ps[j]), j);\n    }\n    sort(ALL(v));\n    REP(j,(int)v.size()-1) {\n      int a = v[j].second, b = v[j+1].second;\n      g[a].push_back(b); g[b].push_back(a);\n    }\n  }\n  return g;\n}\n\n\nint main() {\n  int n,m;\n  while(input(n,m)) {\n    vector<L> ss;\n    double sum = 0;\n    REP(i,n) {\n      P a,b; cin >> a >> b;\n      ss.emplace_back(a,b);\n      sum += (a-b).abs();\n    }\n    vector<P> ps(m+2);\n    REP(i,m+2) cin >> ps[i];\n    vector<P> p(ps);\n    Graph g = segmentArrangement(ss,ps);\n    vector<int> p2ps(m+2,-1);\n    vector<int> ps2p(ps.size(),-1);\n    REP(i,m+2) {\n      REP(j,ps.size())\n        if (norm(p[i]-ps[j]) < EPS) {\n          assert(p2ps[i] == -1);\n          assert(ps2p[j] == -1);\n          p2ps[i] = j;\n          ps2p[j] = i;\n        }\n    }\n\n    vector<bool> fg(ps.size()), fs(ps.size());\n    {\n      queue<int> Q;\n      Q.push(p2ps[m+1]);\n      bool ng = 0;\n      fg[p2ps[m+1]] = 1;\n      while(!Q.empty()) {\n        int v = Q.front(); Q.pop();\n        if (ps2p[v] != -1 && ps2p[v] < m) continue;\n        if (ps2p[v] == m) {\n          ng = 1;\n          break;\n        }\n        FOR(it, g[v]) if (!fg[*it]) {\n          fg[*it] = 1;\n          Q.push(*it);\n        }\n      }\n      if (ng) {\n        puts(\"-1\");\n        continue;\n      }\n    }\n    double ans = 0;\n    {\n      queue<int> Q;\n      Q.push(p2ps[m]);\n      fs[p2ps[m]] = 1;\n      while(!Q.empty()) {\n        int v = Q.front(); Q.pop();\n        // cout << ps2p[v] << \" \" << ps[v] << \" \" << g[v].size() << endl;\n\n        FOR(it, g[v]) {\n          if (!fg[v] || !fg[*it])\n            ans += abs(ps[v] - ps[*it]);\n          if (!fs[*it] && !fg[v]) {\n            fs[*it] = 1;\n            Q.push(*it);\n          }\n        }\n      }\n    }\n    ans = sum - ans / 2;\n    printf(\"%.10f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n\tps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<pair<int, double> > > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++)\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n\tls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n      \n    sort(ls.begin(),ls.end());\n    for(int j=0;j+1<(int)ls.size();j++){\n      int a=ls[j].second,b=ls[j+1].second;\n      G[a].emplace_back(b,abs(ps[a]-ps[b]));\n      G[b].emplace_back(a,abs(ps[a]-ps[b]));\n    }\n  }\n  for(int i=0;i<(int)G.size();i++){\n    sort(G[i].begin(),G[i].end());\n    G[i].erase(unique(G[i].begin(),G[i].end(),\n\t\t      [](auto a,auto b){return a.first==b.first;}),\n\t       G[i].end());\n  }\n  return G;\n}\n\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  vector<Segment> ss(n);\n  Polygon ps(m);\n  for(int i=0;i<n;i++) cin>>ss[i];\n  for(int i=0;i<m;i++) cin>>ps[i];\n  map<Point, int> mp;\n  for(int i=0;i<m;i++) mp[ps[i]]=i;\n  Point s,g;\n  cin>>s>>g;\n  ps.emplace_back(s);\n  ps.emplace_back(g);\n\n  auto G=segmentArrangement(ss,ps);\n  if(0){\n    int k=G.size();\n    for(int i=0;i<k;i++){\n      cout<<i<<\":\"<<ps[i]<<endl;\n      for(auto p:G[i]) cout<<p.first<<\" \"<<p.second<<endl;\n    }\n  }\n\n  double ans=0,tmp=0;\n  for(int i=0;i<n;i++) ans+=abs(ss[i].p1-ss[i].p2);\n\n  vector<int> visit(G.size(),0);\n  queue<int> q;\n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==g) {visit[i]=1;q.emplace(i);}\n\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    if(ps[v]==s){\n      cout<<(int)-1<<endl;\n      return 0;\n    }\n    if(mp.count(ps[v])) continue;\n    for(auto &e:G[v]){\n      int u=e.first;\n      if(!visit[u]){\n\tvisit[u]=1;\n\tq.emplace(u);\n      }\n    }\n  }\n  //cout<<ans<<endl;\n  //for(int i=0;i<(int)G.size();i++) cout<<i<<\":\"<<visit[i]<<endl;\n  \n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==s) q.emplace(i);\n\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    //cout<<v<<endl;\n    for(auto &e:G[v]){\n      int u=e.first;\n      double &c=e.second;\n      if(visit[v]&&visit[u]) continue;\n      if(c==0) continue;\n      tmp+=c;c=0;\n      q.emplace(u);\n    }\n  }\n  tmp/=2;\n  \n  cout<<ans-tmp<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n// 点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight;\nint id;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight,const int id) {\n\tg[from].push_back(Edge{ from, to, weight,id});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<pair<Point,bool>> &p) {\n\tint n = p.size(), m = s.size();\n\tint id = 0;\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j].first))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j].first), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from].first - p[to].first), id);\n\t\t\tadd_edge(g, to, from, abs(p[from].first - p[to].first), id++);\n\t\t}\n\t}\n\treturn g;\n}\n\n//Graph sennbunn_arrangement(const vector<Line>&s) {\n//\tvector<Point>crss;\n//\tfor (int i = 0; i < s.size(); ++i) {\n//\t\tfor (int j = i + 1; j < s.size(); ++j) {\n//\t\t\tif (isis_ss( s[i],  s[j])) {\n//\t\t\t\tcrss.push_back(is_ll( s[i],  s[j]));\n//\t\t\t}\n//\t\t}\n//\t}\n//\tfor (int i = 0; i <s.size(); ++i) {\n//\t\tcrss.push_back( s[i][0]);\n//\t\tcrss.push_back( s[i][1]);\n//\t}\n//\treturn segment_arrangement(s, crss);\n//}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nint startid;\nint goalid;\nbool dfs0(const Graph&g,const int now, vector<bool>&came, vector<bool>&close,const vector<bool>&bulbs) {\n\tcame[now] = true;\n\tfor (auto e : g[now]) {\n\t\tif (!came[e.to]) {\n\t\t\tif (e.to == startid)return false;\n\t\t\telse {\n\t\t\t\tif (bulbs[e.to]) {\n\t\t\t\t\tclose[e.to] = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!dfs0(g, e.to, came, close, bulbs)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ndouble dfs1(const Graph&g, const int now, vector<bool>&came,vector<bool>useedges, const vector<bool>&close) {\n\tcame[now] = true;\n\tdouble ans = 0;\n\tfor (auto e : g[now]) {\n\t\tif (!useedges[e.id]) {\n\t\t\tans += e.weight;\n\t\t\tuseedges[e.id] = true;\n\t\t\tif (close[e.to])continue;\n\t\t\telse {\n\t\t\t\tif(!came[e.to])ans += dfs1(g, e.to, came,useedges, close);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tdouble sum = 0;\n\tGraph g;\n\tint sx, sy, gx, gy;\n\tPoint start;\n\tPoint goal;\n\tvector<pair<Point, bool>>crss;\n\tvector<bool>bulbs;\n\t{\n\t\tint N, M; cin >> N >> M;\n\t\tvector<Line>ls;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint asx, asy, dx, dy; cin >> asx >> asy >> dx >> dy;\n\t\t\tls.push_back(Line(Point(asx, asy), Point(dx, dy)));\n\t\t\tsum += (abs(Point(asx, asy) - Point(dx, dy)));\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < ls.size(); ++j) {\n\t\t\t\tif (isis_ss(ls[i], ls[j])) {\n\t\t\t\t\tcrss.push_back(make_pair(is_ll(ls[i], ls[j]),false));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < ls.size(); ++i) {\n\t\t\tcrss.push_back(make_pair(ls[i][0], false));\n\t\t\tcrss.push_back(make_pair(ls[i][1], false));\n\t\t}\n\t\t\n\t\tvector<Point >bs;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tPoint p(x, y);\n\t\t\tbs.push_back(p);\n\t\t}\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tstart = Point(sx, sy);\n\t\tgoal = Point(gx, gy);\t\n\t\tcrss.push_back(make_pair(start, false));\n\t\tcrss.push_back(make_pair(goal, false));\n\t\tsort(crss.begin(), crss.end());\n\t\tcrss.erase(unique(crss.begin(), crss.end()), crss.end());\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tauto it = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == bs[i]; });\n\t\t\tif (it == crss.end()) {\n\t\t\t\tcrss.push_back(make_pair(bs[i], true));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(*it).second = true;\n\t\t\t}\n\t\t}\n\n\n\t\tfor (int i = 0; i < crss.size(); ++i) {\n\t\t\tbulbs.push_back(crss[i].second);\n\t\t}\n\t\tg= segment_arrangement(ls, crss);\n\t}\n\tauto startit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == start; });\n\tstartid = startit - crss.begin();\n\tauto goalit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == goal; });\n\tgoalid = goalit - crss.begin();\n\tvector<bool>close(crss.size(),false);\n\tvector<bool>came(crss.size(), false);\n\tif (dfs0(g, goalid, came, close, bulbs)) {\n\t\tvector<bool>acame(crss.size(), false);\n\t\tvector<bool>useedges(40000, false);\n\t\tdouble ans = dfs1(g, startid, acame, useedges,close);\n\t\tcout <<fixed<<setprecision(10)<< sum-ans << endl;\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nconst double pi  = M_PI;\nconst double inf = 1e10;\nconst double eps = 1e-10;\ntypedef complex<double> point;\n\nstruct line : public vector<point> {\n\tline(const point& a, const point& b) { push_back(a); push_back(b); }\n};\n\nnamespace std {\n\tbool operator<(const point& a, const point& b) {\n\t\tif(abs(a.real() - b.real()) > eps) return a.real() < b.real();\n\t\tif(abs(a.imag() - b.imag()) > eps) return a.imag() < b.imag();\n\t\treturn false;\n\t}\n}\n\npoint  vec  (const line&  l)                 { return l[1]-l[0]; }\ndouble dot  (const point& a, const point& b) { return (a*conj(b)).real(); }\ndouble cross(const point& a, const point& b) { return (conj(a)*b).imag(); }\n\nint ccw(const point& a, const point& b, const point& c)\n{\n\tpoint u=b-a, v=c-a;\n\tif(cross(u,v) > 0 ) return +1;\n\tif(cross(u,v) < 0 ) return -1;\n\tif(  dot(u,v) < 0 ) return +2;\n\tif(abs(u) < abs(v)) return -2;\n\treturn 0;\n}\n\nint ccw(const line& s, const point& p) {\n\treturn ccw(s[0], s[1], p);\n}\n\nbool intersectSP(const line& s, const point& p) {\n\treturn abs(s[0]-p)+abs(s[1]-p) < abs(s[1]-s[0])+eps;\n}\n\nbool intersectSS(const line& s, const line& t) {\n\treturn ccw(s,t[0])*ccw(s,t[1]) <= 0\n\t\t&& ccw(t,s[0])*ccw(t,s[1]) <= 0;\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tdouble A = cross(vec(l), vec(m));\n\tdouble B = cross(vec(l), l[1]-m[0]);\n\tif(abs(A) < eps) return m[0];\n\treturn m[0] + B/A*vec(m);\n}\n\nenum ntype{ NONE, VALVE, SOURCE, REPAIR };\n\nstruct node\n{\n\tpoint pos;\n\tntype type;\n\tvector<int> to;\n\n\tnode(const point& p, ntype t) : pos(p), type(t) {}\n};\n\nvector<node> seg_arr(const vector<line>& lines, const vector<point>& points)\n{\n\tmap<point, ntype> p;\n\tfor(int i=0; i<points.size(); i++) {\n\t\tntype type = VALVE;\n\t\tif(i == points.size()-2) { type = SOURCE; }\n\t\tif(i == points.size()-1) { type = REPAIR; }\n\n\t\tp.insert( make_pair(points[i],type) );\n\t}\n\n\tfor(int i=0; i<lines.size(); i++) {\n\t\tp.insert( make_pair(lines[i][0],NONE) );\n\t\tp.insert( make_pair(lines[i][1],NONE) );\n\t\tfor(int j=i+1; j<lines.size(); j++) {\n\t\t\tif(intersectSS(lines[i], lines[j])) {\n\t\t\t\tpoint cp = crosspoint(lines[i], lines[j]);\n\t\t\t\tp.insert( make_pair(cp,NONE) );\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<node> graph;\n\tfor(map<point,ntype>::iterator it=p.begin(); it!=p.end(); it++) {\n\t\tgraph.push_back( node(it->first,it->second) );\n\t}\n\n\tfor(int i=0; i<lines.size(); i++) {\n\t\tvector<pair<double,int> > online;\n\t\tfor(int j=0; j<graph.size(); j++) {\n\t\t\tif(intersectSP(lines[i], graph[j].pos)) {\n\t\t\t\tonline.push_back( pair<double,int>(abs(lines[i][0]-graph[j].pos), j) );\n\t\t\t}\n\t\t}\n\n\t\tsort(online.begin(), online.end());\n\t\tfor(int j=1; j<online.size(); j++) {\n\t\t\tint a = online[j-1].second;\n\t\t\tint b = online[j  ].second;\n\t\t\tgraph[a].to.push_back(b);\n\t\t\tgraph[b].to.push_back(a);\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nint main()\n{\n\tint N,M;\n\tcin >> N >> M;\n\n\tvector<line>  lines;\n\tvector<point> points;\n\n\tint x1,y1,x2,y2;\n\tfor(int i=0; i<N; i++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tlines.push_back( line(point(x1,y1), point(x2,y2)) );\n\t}\n\tfor(int i=0; i<M+2; i++) {\n\t\tcin >> x1 >> y1;\n\t\tpoints.push_back( point(x1,y1) );\n\t}\n\n\tint source,repair;\n\tvector<node> graph = seg_arr(lines,points);\n\tfor(int i=0; i<graph.size(); i++) {\n\t\tif(graph[i].type == SOURCE) { source = i; }\n\t\tif(graph[i].type == REPAIR) { repair = i; }\n\t}\n\n\tvector<bool> v(graph.size(), 0);\n\n\tqueue<int> q;\n\tq.push(repair);\n\tv[repair] = 1;\n\twhile(!q.empty())\n\t{\n\t\tint t=q.front(); q.pop();\n\n\t\tif(graph[t].type == VALVE) continue;\n\t\tif(graph[t].type == SOURCE) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor(int i=0; i<graph[t].to.size(); i++) {\n\t\t\tint s = graph[t].to[i];\n\t\t\tif(v[s]) continue;\n\t\t\tv[s] = 1;\n\t\t\tq.push(s);\n\t\t}\n\t}\n\n\tdouble wl = 0;\n\tset<pair<int,int> > ve;\n\tq.push(source);\n\tv[source] = 1;\n\twhile(!q.empty())\n\t{\n\t\tint t=q.front(); q.pop();\n\n\t\tfor(int i=0; i<graph[t].to.size(); i++) {\n\t\t\tint s = graph[t].to[i];\n\n\t\t\tif(ve.insert(make_pair(min(t,s),max(t,s))).second) {\n\t\t\t\twl += abs(graph[t].pos - graph[s].pos);\n\t\t\t}\n\n\t\t\tif(v[s]) continue;\n\t\t\tv[s] = 1;\n\t\t\tq.push(s);\n\t\t}\n\t}\n\n\n\tdouble al = 0;\n\tve.clear();\n\tfor(int i=0; i<graph.size(); i++)\n\tfor(int j=0; j<graph[i].to.size(); j++) {\n\t\tint t=i, s=graph[i].to[j];\n\t\tif(ve.insert(make_pair(min(t,s),max(t,s))).second) {\n\t\t\tal += abs(graph[t].pos - graph[s].pos);\n\t\t}\n\t}\n\tprintf(\"%.9lf\\n\", al-wl);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a,b;\n\toperator line<T>()const{ return (line<T>){a,b}; }\n};\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<double> &S,const point<double> &p){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\nvoid arrangement(const vector< segment<double> > &S,const vector< point<double> > &plus,vector< point<double> > &P,vector<int> *G){\n\tint n=S.size();\n\tP=plus;\n\trep(i,n){\n\t\tP.push_back(S[i].a);\n\t\tP.push_back(S[i].b);\n\t\trep(j,i) if(intersect(S[i],S[j])) P.push_back(get_intersect(S[i],S[j]));\n\t}\n\tsort(P.begin(),P.end());\n\tP.erase(unique(P.begin(),P.end()),P.end());\nif(P.size()>2000) for(;;);\n\n\trep(i,n){\n\t\tvector<int> on;\n\t\trep(u,P.size()) if(cover(S[i],P[u])) on.push_back(u);\n\t\trep(j,(int)on.size()-1){\n\t\t\tint u=on[j],v=on[j+1];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tvector< segment<double> > pipe(n);\n\trep(i,n) scanf(\"%lf%lf%lf%lf\",&pipe[i].a.x,&pipe[i].a.y,&pipe[i].b.x,&pipe[i].b.y);\n\tvector< point<double> > stop(m);\n\trep(i,m) scanf(\"%lf%lf\",&stop[i].x,&stop[i].y);\n\tpoint<double> s,t;\n\tscanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&t.x,&t.y);\n\n\t// 追加の頂点集合\n\tvector< point<double> > plus=stop;\n\tplus.push_back(s);\n\tplus.push_back(t);\n\n\tvector< point<double> > P;\n\tvector<int> G[2000];\n\tarrangement(pipe,plus,P,G);\n\n\tint N=P.size();\n\tbool isstop[2000]={};\n\trep(i,m) rep(j,N) if(P[j]==stop[i]) isstop[j]=true;\n\n\tint s_id=find(P.begin(),P.end(),s)-P.begin();\n\tint t_id=find(P.begin(),P.end(),t)-P.begin();\n\n\t// t から stop をまたがずに行ける場所を見つける\n\tbool vis[2000]={};\n\tvis[t_id]=true;\n\tqueue<int> Q; Q.push(t_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=true;\n\t\t\t\tif(!isstop[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(vis[s_id]){ puts(\"-1\"); return 0; }\n\n\t// s から vis を通らずに行ける場所を見つける\n\tbool vis2[2000]={};\n\tvis2[s_id]=true;\n\tQ.push(s_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v]=true;\n\t\t\t\tif(!vis[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans=0;\n\trep(i,n) ans+=dist(pipe[i].a,pipe[i].b);\n\trep(u,N) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tif(u<v && vis2[u] && vis2[v]) ans-=dist(P[u],P[v]);\n\t}\n\tprintf(\"%.9f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nint n, m, np, l, idx[100011], cl, q[100011], v, s, t;\ndouble ans, eps = 1e-10;\nbool f[100011], isstop[100011], mark[100011], flag;\nstruct recedge\n{\n\tint y, nxt;\n} edge[2000011];\nvoid build(int x, int y)\n{\n\tedge[++l].y = y;\n\tedge[l].nxt = idx[x];\n\tidx[x] = l;\n}\nstruct couple\n{\n\tdouble x, y;\n\tcouple(){};\n\tcouple(const double & _a, const double & _b) : x(_a), y(_b){}\n\tdouble len()\n\t{\n\t\treturn sqrt(x * x + y * y);\n\t}\n} b[1111], cp, points[100011];\nbool equal(const double  & a, const double & b)\n{\n\treturn fabs(a - b) < eps;\n}\nbool les(const double & a, const double & b)\n{\n\treturn a + eps < b;\n}\nbool operator < (const couple & a, const couple & b)\n{\n\treturn les(a.x, b.x) or equal(a.x, b.x) and les(a.y, b.y);\n}\nbool operator == (const couple & a, const couple & b)\n{\n\treturn equal(a.x, b.x) and equal(a.y, b.y);\n}\nmap<couple, int> mp;\nvector<couple> vec[311];\ncouple operator - (const couple & a, const couple & b)\n{\n\treturn couple(a.x - b.x, a.y - b.y);\n}\ncouple operator + (const couple & a, const couple & b)\n{\n\t\treturn couple(a.x + b.x, a.y + b.y);\n}\n\ncouple operator * (const double & lambda, const couple & a)\n{\n\treturn couple(lambda * a.x, lambda * a.y);\n}\ndouble operator * (const couple & a, const couple & b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\ndouble operator % (const couple & a, const couple & b)\n{\n\treturn a.x * b.x + a.y * b.y;\n}\nstruct reca\n{\n\tcouple a, b;\n} a[311];\nbool cross(int i, int j)\n{\n\tif((a[i].b - a[i].a) * (a[j].b - a[j].a) == 0)\n\t{\n\t\tif(a[i].b == a[j].a or a[i].b == a[j].b)\n\t\t{\n\t\t\tcp = a[i].b;\n\t\t\treturn true;\n\t\t}else if(a[i].a == a[j].a  or a[i].a == a[j].b)\n\t\t{\n\t\t\tcp = a[i].a;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}else if(((a[j].a - a[i].a) * (a[i].b - a[i].a)) * ((a[j].b - a[i].a) * (a[i].b - a[i].a)) <= 0 and ((a[i].a - a[j].a) * (a[j].b - a[j].a))*((a[i].b - a[j].a) * (a[j].b - a[j].a)) <= 0)\n\t{\n\t\tdouble lambda = (a[j].a - a[i].a) * (a[j].b - a[j].a) / ((a[i].b - a[i].a) * (a[j].b - a[j].a));\n\t\tcp = a[i].a + lambda * (a[i].b - a[i].a);\n\t\treturn true;\n\t}else return false;\n}\nbool on(int i, int j)\n{\n\treturn (a[j].a - b[i]) * (a[j].b - b[i]) == 0 and (a[j].a - b[i]) % (a[j].b - b[i]) <= 0;\n}\ndouble dis(int i, int j)\n{\n\treturn sqrt((points[i].x - points[j].x) * (points[i].x - points[j].x) + (points[i].y - points[j].y) * (points[i].y - points[j].y));\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%lf%lf%lf%lf\", &a[i].a.x, &a[i].a.y, &a[i].b.x, &a[i].b.y);\n\t\tif(a[i].a.x == a[i].b.x and a[i].a.y == a[i].b.y)\n\t\t{\n\t\t\tf[i] = false;\n\t\t}else f[i] = true;\n\t\tans = ans + (a[i].b - a[i].a).len();\n\t}\n\tint n1 = 0;\n\tfor(int i = 1; i <= n; i++) if(f[i]) a[++n1] = a[i];\n\tn = n1;\n\tfor(int i = 1; i <= m + 2; i++)\n\t{\n\t\tscanf(\"%lf%lf\", &b[i].x, &b[i].y);\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tvec[i].clear();\n\t\tvec[i].push_back(a[i].a);\n\t\tvec[i].push_back(a[i].b);\n\t\tmp[a[i].a] = 0;\n\t\tmp[a[i].b] = 0;\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = i + 1; j <= n; j++)\n\t\t\tif(cross(i, j))\n\t\t\t{\n\t\t\t\tvec[i].push_back(cp);\n\t\t\t\tvec[j].push_back(cp);\n\t\t\t\tmp[cp] = 0;\n\t\t\t}\n\tfor(int i = 1; i <= m + 2; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t\tif(on(i, j))\n\t\t\t{\n\t\t\t\tvec[j].push_back(b[i]);\n\t\t\t\tmp[b[i]] = 0;\n\t\t\t}\n\tnp = 0;\n\tfor(map<couple, int>::iterator it = mp.begin(); it != mp.end(); it++) \n\t{\n\t\tit->second = ++np;\n\t\tpoints[np] = it->first;\n\t}\n\tl = 1;\n\tmemset(idx, 0, sizeof(idx));\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tsort(vec[i].begin(), vec[i].end());\n\t\tvec[i].resize(unique(vec[i].begin(), vec[i].end()) - vec[i].begin());\n\t\tfor(int j = 0; j < vec[i].size() - 1; j++)\n\t\t{\n\t\t\tbuild(mp[vec[i][j]], mp[vec[i][j + 1]]);\n\t\t\tbuild(mp[vec[i][j + 1]], mp[vec[i][j]]);\n\t\t}\n\t\t//for(int j = 0; j < vec[i].size(); j++) printf(\"%d \", mp[vec[i][j]]);\n\t\t//printf(\"\\n\");\n\t}\n\tmemset(isstop, 0, sizeof(isstop));\n\tmemset(mark, 0, sizeof(mark));\n\tmemset(f, true, sizeof(f));\n\ts = mp[b[m + 1]];\n\tt = mp[b[m + 2]];\n\tfor(int i = 1; i <= m; i++) isstop[mp[b[i]]] = true;\n\tq[cl = 1] = t;\n\tflag = true;\n\tf[t] = false;\n\tfor(int op = 1; op <= cl; op++)\n\t{\n\t\t//printf(\"%d\\n\", q[op]);\n\t\tfor(int p = idx[v = q[op]]; p; p = edge[p].nxt) if(f[edge[p].y] == true)\n\t\t{\n\t\t\tif(edge[p].y == s)\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}else\n\t\t\t{\n\t\t\t\tif(isstop[edge[p].y] == true)\n\t\t\t\t{\n\t\t\t\t\tmark[edge[p].y] = true;\n\t\t\t\t\t//printf(\"mark %d\\n\", edge[p].y);\n\t\t\t\t}else\n\t\t\t\t{\n\t\t\t\t\tq[++cl] = edge[p].y;\n\t\t\t\t\tf[edge[p].y] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag == false) break;\n\t}\n\tif(flag == false)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tq[cl = 1] = s;\n\tmemset(f, true, sizeof(f));\n\tf[s] = false;\n\tfor(int op = 1; op <= cl; op++)\n\t{\n\t\tfor(int p = idx[v = q[op]]; p; p = edge[p].nxt)\n\t\t{\n\t\t\tans -= dis(v, edge[p].y) / 2;\n\t\t\tif(mark[edge[p].y] == true)\n\t\t\t\tans -= dis(v, edge[p].y) / 2;\n\t\t\telse if(f[edge[p].y])\n\t\t\t{\n\t\t\t\tf[edge[p].y] = false;\n\t\t\t\tq[++cl] = edge[p].y;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", ans);\n\tfclose(stdin);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef complex<double> V;\ntypedef vector<P> vecP;\ntypedef pair<P,P> L;\ntypedef pair<P,P> S;\ntypedef pair<P,double> C;\nconst double eps=1e-8;\nconst double PI=acos(-1);\nconst double PI2=PI*2.0;\n \nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.real()!=b.real()?\n            a.real() <b.real():\n            a.imag() <b.imag());\n  }\n};\n \nV normal(V a){\n  assert( abs(a)>0 );\n  return a/abs(a);\n}\n \ndouble Sqrt( double x ){\n  if(x<0)return 0;\n  else return sqrt(x);\n}\n \nP Vector(L a){\n  return a.second-a.first;\n}\n \nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n \nbool eq(P a,P b){\n  return ( eq(a.real(),b.real()) && eq(a.imag(),b.imag()) );\n}\n \ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n \ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n \ndouble getArg(P a,P b){\n  return arg(b*conj(a));\n}\n \ndouble getTime(V a,V b){\n  assert( eq(cross(a,b),0) );\n  return ( dot(a,b) < 0 ? -1.0 : 1.0 ) * abs(b) / abs(a);\n}\n \n \nP project(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*real(c/b);\n}\n \nP reflect(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*conj(c/b);\n}\n \nint ccw(P a,P b,P c){\n  P ab=b-a,ac=c-a;\n  P k=ac*conj(ab);\n  if(k.imag()>0)return 1;\n  if(k.imag()<0)return -1;\n  if(k.real()<0)return 2;\n  if(abs(ab)<abs(ac))return -2;\n  return 0;\n}\n \nbool isParallel(P a,P b){\n  return eq(0, cross(a,b));\n}\n \nbool isParallel(S a,S b){\n  return eq(0, cross( Vector(a) , Vector(b) ) );\n}\n \nbool onLP(L l,P p){\n  P a=l.first, b=l.second;\n  return eq(0, cross(b-a,p-a));\n}\n \nbool onSP(S s,P p){\n  P a=s.first, b=s.second;\n  return eq( abs(b-a) , abs(a-p)+abs(b-p) );\n}\n \nbool isCrossSS(S s0,S s1){\n  P a=s0.first, b=s0.second;\n  P c=s1.first, d=s1.second;\n  int f0 = ccw(a,b,c) * ccw(a,b,d);\n  int f1 = ccw(c,d,a) * ccw(c,d,b);\n  return (f0<=0 && f1<=0);\n}\n \nbool isCrossLS(L l,S s){\n  P a=l.first, b=l.second;\n  P c=s.first, d=s.second;\n  return ( ccw(a,b,c) * ccw(a,b,d) <= 0 );\n}\n \ndouble distLP(L l,P p){\n  P a=l.first, b=l.second;\n  double res = cross(b-a,p-a) / abs(b-a);\n  return abs(res);\n}\n \ndouble distSP(S s,P p){\n  P a=s.first, b=s.second;\n  if( dot(b-a,p-a) < eps )return abs(p-a);\n  if( dot(a-b,p-b) < eps )return abs(p-b);\n  return distLP(s,p);\n}\n \ndouble distSS(S s0,S s1){\n  if( isCrossSS(s0,s1) )return 0;\n  double res0 = min( distSP( s0, s1.first ) , distSP(s0, s1.second) );\n  double res1 = min( distSP( s1, s0.first ) , distSP(s1, s0.second) );\n  return min(res0,res1);\n}\n \nP getCrossLL(L l0,L l1){\n  P a=l0.first, b=l0.second;\n  P c=l1.first, d=l1.second;\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n \n \n  \nint inPolygon(vecP &t,P p){\n  int n=t.size();\n  double sum=0;\n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p)==0 )return 1;\n    sum+= getArg(a-p,b-p);\n  }\n  if( abs(sum) < eps )return 0;\n  else return 2;\n}\n\n\nstruct edge{\n  int to;\n  double cost;\n};\n\ntypedef vector<edge> Node;\ntypedef vector<Node> Graph;\nGraph G;\nmap<int,bool> isB;\nvector< P > points;\n\nvoid segments2graph( vector<S> segments ,vector<P> b ){\n\n  int n=segments.size();\n\n  sort(b.begin(),b.end());\n  \n  for(int i=0;i<(int)b.size();i++){\n    points.push_back(b[i]);\n  }\n  \n  for(int i=0;i<n;i++){\n    S si=segments[i];\n    points.push_back( si.first );\n    points.push_back( si.second );\n    for(int j=0;j<i;j++){\n      S sj=segments[j];\n      if( isCrossSS( si , sj ) && !isParallel( si, sj ) ){\n        points.push_back( getCrossLL(si,sj) );\n      }\n    }\n  }\n \n  sort(points.begin(), points.end());\n  points.erase( unique( points.begin(), points.end() ) , points.end() );\n   \n  G.resize(points.size());\n  \n  for(int i=0;i<(int)points.size();i++){\n    P p=points[i];\n    isB[i] = binary_search(b.begin(),b.end(), p);\n  }\n  \n  typedef pair< double , int > Pair;\n     \n  for(int i=0;i<n;i++){\n    S si=segments[i];\n    P sf=si.first, se=si.second;\n    vector< Pair > targets;\n    for(int j=0;j<(int)points.size();j++){\n      P pj=points[j];\n      // if( ccw( si.first, si.second, pj ) == 0 ){\n      if( onSP( si, pj ) ){\n        targets.push_back( Pair(getTime(se-sf ,pj-sf ), j ) );\n      }\n    }\n    /*\n    for(int j=0;j<(int)targets.size();j++){\n      for(int k=0;k<j;k++){\n        Pair a=targets[j];\n        Pair b=targets[k];\n        P ap=points[ a.second ];\n        P bp=points[ b.second ];\n        G[a.second].push_back( (edge){ b.second , getArg(ap,bp) } );\n        G[b.second].push_back( (edge){ a.second , getArg(bp,ap) } );\n      }\n    }\n    */\n \n    sort( targets.begin(), targets.end() );\n    for(int j=0;j+1<(int)targets.size();j++){\n      Pair a=targets[j];\n      Pair b=targets[j+1];\n      P ap=points[ a.second ];\n      P bp=points[ b.second ];\n      \n      G[a.second].push_back( (edge){ b.second , abs(ap-bp) } );\n      G[b.second].push_back( (edge){ a.second , abs(bp-ap) } );\n    }\n \n  }\n\n}\n\nP input(){\n  double x,y;\n  cin>>x>>y;\n  return P(x,y);\n}\n\n\nmap<int,bool> visited;\ndouble total=0;\n\nmap< P , bool > counted;\n\nvoid dfs(int pos){\n  if( isB[pos] )return;\n  if(visited[pos])return;\n  visited[pos]=true;\n  \n  for(int i=0;i<(int)G[pos].size();i++){\n    edge e=G[pos][i];\n    if( visited[e.to] || isB[e.to] )total+=e.cost;\n    else total += e.cost/2.0;\n  }\n  \n  for(int i=0;i<(int)G[pos].size();i++){\n    edge e=G[pos][i];\n    dfs(e.to);\n  }\n}\n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  vector< S > segments;\n  vector< P > bs;\n\n  double ans = 0;\n  \n  for(int i=0;i<N;i++){\n    P a=input();\n    P b=input();\n    segments.push_back( S(a,b) );\n    ans+= abs(a-b);\n  }\n  \n  for(int i=0;i<M;i++)bs.push_back( input() );\n  \n  P si,ti;\n  si=input();\n  ti=input();\n  points.push_back(si);\n  points.push_back(ti);\n  \n  segments2graph(segments,bs);\n\n  \n  int ex = lower_bound( points.begin(), points.end() , si ) - points.begin();\n  int root = lower_bound( points.begin(), points.end() , ti ) - points.begin();\n  \n  dfs(root);\n  if( visited[ex] ){\n    cout<<\"-1\"<<endl;\n    return 0;\n  }\n  \n  total = 0;\n  dfs( ex );\n  printf(\"%.10f\\n\",ans-total);\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a,b;\n\toperator line<T>()const{ return (line<T>){a,b}; }\n};\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<double> &S,const point<double> &p){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\n// 追加で頂点集合を指定できるように書き換え\nvoid arrangement(const vector< segment<double> > &S,const vector< point<double> > &plus,vector< point<double> > &P,vector<int> *G){\n\tint n=S.size();\n\tP=plus;\n\trep(i,n){\n\t\tP.push_back(S[i].a);\n\t\tP.push_back(S[i].b);\n\t\trep(j,i) if(intersect(S[i],S[j])) P.push_back(get_intersect(S[i],S[j]));\n\t}\n\tsort(P.begin(),P.end());\n\tP.erase(unique(P.begin(),P.end()),P.end());\n\n\trep(i,n){\n\t\tvector<int> on;\n\t\trep(u,P.size()) if(cover(S[i],P[u])) on.push_back(u);\n\t\trep(j,(int)on.size()-1){\n\t\t\tint u=on[j],v=on[j+1];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tvector< segment<double> > pipe(n);\n\trep(i,n) scanf(\"%lf%lf%lf%lf\",&pipe[i].a.x,&pipe[i].a.y,&pipe[i].b.x,&pipe[i].b.y);\n\tvector< point<double> > stop(m);\n\trep(i,m) scanf(\"%lf%lf\",&stop[i].x,&stop[i].y);\n\tpoint<double> s,t;\n\tscanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&t.x,&t.y);\n\n\t// 追加の頂点集合\n\tvector< point<double> > plus=stop;\n\tplus.push_back(s);\n\tplus.push_back(t);\n\n\tvector< point<double> > P;\n\tstatic vector<int> G[100000];\n\tarrangement(pipe,plus,P,G);\n\n\tint N=P.size();\n\tstatic bool isstop[100000];\n\trep(i,m) rep(j,N) if(P[j]==stop[i]) isstop[j]=true;\n\n\tint s_id=find(P.begin(),P.end(),s)-P.begin();\n\tint t_id=find(P.begin(),P.end(),t)-P.begin();\n\n\t// t から stop をまたがずに行ける場所を見つける\n\tstatic bool vis[100000];\n\tvis[t_id]=true;\n\tqueue<int> Q; Q.push(t_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=true;\n\t\t\t\tif(!isstop[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(vis[s_id]){ puts(\"-1\"); return 0; }\n\n\t// s から vis を通らずに行ける場所を見つける\n\tstatic bool vis2[100000];\n\tvis2[s_id]=true;\n\tQ.push(s_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v]=true;\n\t\t\t\tif(!vis[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans=0;\n\trep(i,n) ans+=dist(pipe[i].a,pipe[i].b);\n\trep(u,N) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tif(u<v && vis2[u] && vis2[v]) ans-=dist(P[u],P[v]);\n\t}\n\tprintf(\"%.9f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-6;\n\nbool equals(double a, double b) {\n  return abs(a - b) < eps;\n}\n\nnamespace std {\n  bool operator < (const P &a, const P &b) {\n    if(!equals(a.real(), b.real())) return a.real() < b.real();\n    if(!equals(a.imag(), b.imag())) return a.imag() < b.imag();\n    return false;\n  }\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nbool isParallel(P a, P b) {\n  return equals(cross(a, b), 0.0);\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a, b) > eps) return 1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a, b) < -eps) return 2;\n  if(norm(b) - norm(a) > eps) return -2;\n  return 0;\n}\n\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t   ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1) / cross(b, a);\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nstruct Edge {\n  int to; double w;\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nint getId(P p, map<P, int> &m) {\n  if(!m.count(p)) {\n    int tmp = m.size();\n    m[p] = tmp;\n  }\n  return m[p];\n}\n\nint getId(P p, map<P, int> &m, map<int, P> &r) {\n  r[getId(p, m)] = p;\n  return m[p];\n}\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  vector<P> X(N), Y(N), Z(M);\n  P src, dst;\n  map<P, int> id;\n  map<int, P> rid;\n\n  for(int i = 0; i < N; ++i) {\n    cin >> X[i].real() >> X[i].imag() >> Y[i].real() >> Y[i].imag();\n    getId(X[i], id, rid);\n    getId(Y[i], id, rid);\n  }\n  for(int i = 0; i < M; ++i) {\n    cin >> Z[i].real() >> Z[i].imag();\n    getId(Z[i], id, rid);\n  }\n  cin >> src.real() >> src.imag();\n  getId(src, id, rid);\n  cin >> dst.real() >> dst.imag();\n  getId(dst, id, rid);\n\n  for(int i = 0; i < N; ++i) {\n    for(int j = i+1; j < N; ++j) {\n      if(isParallel(X[i] - Y[i], X[j] - Y[j])) {\n\t//\n      } else if(isIntersect(X[i], Y[i], X[j], Y[j])) {\n\tP p = getCrossP(X[i], Y[i], X[j], Y[j]);\n\tgetId(p, id, rid);\n      }\n    }\n  }\n\n  int V = id.size();\n  Graph G(V);\n\n  for(int i = 0; i < N; ++i) {\n    set<P> s;\n    vector<pair<double, P> > v;\n    s.insert(X[i]);\n    s.insert(Y[i]);\n    v.push_back(make_pair(0.0, X[i]));\n    v.push_back(make_pair(norm(Y[i] - X[i]), Y[i]));\n    for(int j = i+1; j < N; ++j) {\n      if(isParallel(X[i] - Y[i], X[j] - Y[j])) {\n\t//\n      } else if(isIntersect(X[i], Y[i], X[j], Y[j])) {\n\tP p = getCrossP(X[i], Y[i], X[j], Y[j]);\n\tif(s.count(p)) continue;\n\ts.insert(p);\n\tv.push_back(make_pair(norm(p - X[i]), p));\n      }\n    }\n    for(int j = 0; j < M; ++j) {\n      if(ccw(X[i], Y[i], Z[j]) == 0 && !s.count(Z[j])) {\n\ts.insert(Z[j]);\n\tv.push_back(make_pair(norm(Z[j] - X[i]), Z[j]));\n      }\n    }\n\n    if(ccw(X[i], Y[i], src) == 0 && !s.count(src)) {\n      s.insert(src);\n      v.push_back(make_pair(norm(src - X[i]), src));\n    }\n    if(ccw(X[i], Y[i], dst) == 0 && !s.count(dst)) {\n      s.insert(dst);\n      v.push_back(make_pair(norm(dst - X[i]), dst));\n    }\n    sort(v.begin(), v.end());\n    for(int j = 0; j+1 < v.size(); ++j) {\n      int a = getId(v[j].second, id);\n      int b = getId(v[j+1].second, id);\n      double w = abs(v[j].second - v[j+1].second);\n      G[a].push_back((Edge){b, w});\n      G[b].push_back((Edge){a, w});\n    }\n  }\n  if(0) {\n  cout << V << endl;\n  for(int i = 0; i < V; ++i) {\n    cout << rid[i] << \":\";\n    for(int j = 0; j < G[i].size(); ++j) {\n      if(j) cout << \",\";\n      cout << rid[G[i][j].to];\n    }\n    cout << endl;\n  }\n  }\n\n  try {\n    vector<int> F(V), F2(V);\n    for(int i = 0; i < M; ++i) {\n      F[getId(Z[i], id)] = 1;\n    }\n    set<pair<int, int> > vis;\n    queue<int> que;\n    \n    que.push(getId(dst, id));\n    int isrc = getId(src, id);\n    while(que.size()) {\n      int v = que.front();\n      que.pop();\n      for(int i = 0; i < G[v].size(); ++i) {\n\tint nv = G[v][i].to;\n\tif(nv == isrc) throw 0;\n\tif(vis.count(make_pair(nv, v))) continue;\n\tvis.insert(make_pair(nv, v));\n\tvis.insert(make_pair(v, nv));\n\tif(F[nv]) {\n\t  F2[nv] = 1;\n\t  continue;\n\t}\n\tque.push(nv);\n      }\n    }\n    double res = 0;\n    que.push(isrc);\n    while(que.size()) {\n      int v = que.front();\n      que.pop();\n      for(int i = 0; i < G[v].size(); ++i) {\n\tint nv = G[v][i].to;\n\tif(vis.count(make_pair(nv, v))) continue;\n\tvis.insert(make_pair(nv, v));\n\tvis.insert(make_pair(v, nv));\n\tres += G[v][i].w;\n\tif(F2[nv]) continue;\n\tque.push(nv);\n      }\n    }\n    res = -res;\n    for(int i = 0; i < N; ++i) {\n      res += abs(X[i] - Y[i]);\n    }\n    printf(\"%.10f\\n\", res);\n  } catch(...) {\n    printf(\"-1\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// a => prev, b => cur, c=> next\n// prev から cur へ行って next へ行く際の角度を求める\ndouble getArg(Point a,Point b,Point c){\n  double arg1 = atan2(b.y-a.y,b.x-a.x);\n  double arg2 = atan2(c.y-b.y,c.x-b.x);\n  double arg = fabs( arg1 - arg2 );\n  while( arg > M_PI ) arg -= 2.0 * M_PI;\n  return fabs(arg);\n}\n\n\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //同じセグメントかもよ\n    return vec[1];\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\nstruct Edge {\n  int from,to;\n  double cost;\n  Edge(int from=0,int to=0,double cost=0):from(from),to(to),cost(cost){}\n  bool operator < (const Edge& a)const { return !equals(cost,a.cost) && cost < a.cost; }\n};\n\nvector<vector<Edge> > segmentArrangement(vector<Segment> vs,vector<Point> &ps) {\n/*\n端点もいれたいなら\nここであらかじめ端点だけpsにいれる\n*/\n  rep(i,vs.size())\n    REP(j,i+1,vs.size())\n    if(intersectSS(vs[i],vs[j]))\n      ps.push_back(Point(crosspoint(vs[i],vs[j])));\n\n  sort(ps.begin(),ps.end());  \n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<Edge> > ret(ps.size());\n\n  for(int i=0;i<vs.size();i++){\n    vector<pair<double,int> > list;\n    rep(j,ps.size()) if(intersectSP(vs[i],ps[j]))list.push_back(pair<double,int>(norm(vs[i].p1-ps[j]),j));\n    sort(list.begin(),list.end());\n    for(int j=0;j+1<list.size();++j) {\n      int from = list[j].second, to = list[j+1].second;\n      double cost = abs(ps[from]-ps[to]);\n      ret[from].push_back(Edge(from,to,cost));\n      ret[to].push_back(Edge(to,from,cost));\n    }\n  }  \n  return ret;\n}\n\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n  \n\nbool isConvex(vector<Point> p) {\n  int sz = (int)p.size();\n  if(sz < 3)return false;//boundary case, we treat a point or a line as not convex\n  bool isLeft = ccwtest(p[0],p[1],p[2]);\n  for(int i=1; i<(int)p.size();i++)\n    if(ccwtest(p[i],p[(i+1)%sz],p[(i+2)%sz]) != isLeft) return false;\n  return true;\n}\n\n\ndouble angle(Point a,Point b,Point c) {\n  double ux = b.x - a.x, uy = b.y - a.y;\n  double vx = c.x - a.x, vy = c.y - a.y;\n  return acos((ux*vx + uy*vy)/sqrt((ux*ux + uy*uy) * (vx*vx + vy*vy)));\n}  \n  \n//多角形poly内（線分上も含む）に点pが存在するかどうは判定する  \nbool inPolygon(Polygon poly,Point p){\n  if((int)poly.size() == 0)return false;\n  rep(i,poly.size()) if(onSegment(poly[i],poly[(i+1)%poly.size()],p))return true;\n  double sum = 0;\n  for(int i=0; i < (int)poly.size() ;i++) {\n    if( equals(cross(poly[i]-p,poly[(i+1)%poly.size()]-p),0.0) ) continue; // ３点が平行だとangleがnanを返しsumがnanになり死ぬ\n    if( cross3p(p,poly[i],poly[(i+1)%poly.size()]) < 0 ) sum -= angle(p,poly[i],poly[(i+1)%poly.size()]);\n    else                                                 sum += angle(p,poly[i],poly[(i+1)%poly.size()]);\n  }\n  // あまり誤差を厳しくしすぎると良くないので以下のほうが良い \n  const double eps = 1e-5;\n  return (fabs(sum - 2*M_PI) < eps || fabs(sum + 2*M_PI) < eps);\n}  \n\nint N,M;\nvector<Segment> segs;\nvector<Point> stop;\nPoint source,repairing;\n\nvoid compute(){\n  double total = 0;\n  vector<Point> ps = stop;\n  ps.push_back(source);\n  ps.push_back(repairing);\n  rep(i,(int)segs.size()) ps.push_back(segs[i].p1), ps.push_back(segs[i].p2),\n    total += abs(segs[i].p1-segs[i].p2);\n  vector<vector<Edge> > G = segmentArrangement(segs,ps);\n  int sp = -1, rp = -1;\n  rep(i,ps.size()) {\n    if( source == ps[i] ) sp = i;\n    if( repairing == ps[i] ) rp = i;\n  }\n  assert( sp != -1 && rp != -1 );\n  \n  sort(stop.begin(),stop.end());\n  vector<bool> stopper(ps.size(),false);\n  rep(i,stop.size()) {\n    int position = lower_bound(ps.begin(),ps.end(),stop[i]) - ps.begin();\n    assert( position < ps.size() );\n    stopper[position] = true;\n  }\n\n  deque<int> deq;\n  vector<bool> out(ps.size(),false);\n  deq.push_back(rp);\n  out[rp] = true;\n  while( !deq.empty() ){\n    int cur = deq.front(); deq.pop_front();\n    rep(i,(int)G[cur].size()) {\n      int to = G[cur][i].to;\n      if( out[to] ) continue;\n      out[to] = true;\n      if( stopper[to] ) continue;\n      deq.push_back(to);\n    }\n  }\n\n  if( out[sp] ) { puts(\"-1\"); return; }\n  \n  double reach = 0;\n\n  typedef pair<int,int> ii;\n  set<ii> added,used;\n  assert( deq.empty() );\n  deq.push_back(sp);\n  while( !deq.empty() ){\n    int cur = deq.front(); deq.pop_front();\n    rep(i,(int)G[cur].size()){\n      int to = G[cur][i].to;\n      ii data = ii(min(cur,to),max(cur,to));\n      if( !added.count(data) ) {\n        added.insert(data);\n        reach += abs(ps[cur]-ps[to]);\n      }   \n      if( out[to] ) continue;\n      if( used.count( ii(cur,to) ) ) continue;\n      used.insert(ii(cur,to));\n      deq.push_back(to);\n    }\n  }\n  //cout << \"total = \" << total << endl;\n  //cout << \"reach = \" << reach << endl;\n  printf(\"%.10f\\n\",total-reach);\n  \n}\n\nint main(){\n  scanf(\"%d %d\",&N,&M);\n  segs.clear();\n  segs.resize(N);\n  stop.clear();\n  stop.resize(M);\n  rep(i,N) cin >> segs[i].p1.x >> segs[i].p1.y >> segs[i].p2.x >> segs[i].p2.y;\n  rep(i,M) cin >> stop[i].x >> stop[i].y;\n  cin >> source.x >> source.y;\n  cin >> repairing.x >> repairing.y;\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<unordered_map>\n\nusing namespace std;\n\nmap<int,vector<int> > g;\n\nint main(){\n  for(int i=0;i<300;i++){\n    for(int j=-1000;j<=1000;j++){\n      g[(i<<16)+j].push_back(j);\n      g[(i<<16)+j].push_back(j);\n    }\n  }\n  int N,M;\n  cin>>N>>M;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<unordered_map>\n#include<utility>\n\nusing namespace std;\n\nmultimap<int,int> g;\nset<int> valves;\nint xb,yb,xc,yc;\nconst int O=1234;\nset<int> stopped,u;\n\nint gcd(int a,int b){\n  return b?gcd(b,a%b):a;\n}\n\nint enc(int x,int y){\n  return (x+O<<16)+y+O;\n}\n\npair<int,int> dec(int x){\n  return make_pair((x>>16)-O,(x&(1<<16)-1)-O);\n}\n\nvoid stop(int v){\n  if(!u.insert(v).second)return;\n  if(valves.count(v)){\n    stopped.insert(v);\n    return;\n  }else{\n    auto p=dec(v);\n    int x=p.first,y=p.second;\n    if(y==yb&&x==xb)throw 0;\n    auto c=g.equal_range(v);\n    for(auto it=c.first;it!=c.second;it++){\n      if(u.count(it->second))continue;\n      stop(it->second);\n    }\n  }\n}\n\ndouble rec(int v,int p){\n  if(!u.insert(v).second)return 0;\n  if(stopped.count(v))return 0;\n  auto pr=dec(v);\n  int x=pr.first,y=pr.second;\n  auto c=g.equal_range(v);\n  double r=0;\n  for(auto it=c.first;it!=c.second;it++){\n    if(it->second==p)continue;\n    auto pr=dec(it->second);\n    int nx=pr.first,ny=pr.second;\n    r+=hypot(ny-y,nx-x)+rec(it->second,v);\n  }\n  return r;\n}\n\nvoid add_edge(pair<int,int> a,pair<int,int> b){\n  g.insert(make_pair(enc(a.first,a.second),enc(b.first,b.second)));\n}\n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  double len=0;\n  for(int i=0;i<N;i++){\n    int xs,ys,xd,yd;\n    cin>>xs>>ys>>xd>>yd;\n    len+=hypot(xs-xd,ys-yd);\n    vector<pair<int,int> > v;\n    if(xs==xd||ys==yd){\n      if(xs>xd){\n\tswap(xs,xd);\n      }\n      if(ys>yd){\n\tswap(ys,yd);\n      }\n      for(int x=xs,y=ys;x<=xd&&y<=yd;x+=xs!=xd,y+=ys!=yd){\n\tv.emplace_back(x,y);\n      }\n    }else{\n      if(xd<xs){\n\tswap(xs,xd);\n\tswap(ys,yd);\n      }\n      int m=gcd(xd-xs,abs(yd-ys));\n      for(int y=ys,x=xs;x<=xd;x+=(xd-xs)/m,y+=(yd-ys)/m){\n\tv.emplace_back(x,y);\n      }\n    }\n    for(int i=0;i<v.size()-1;i++){\n      add_edge(v[i],v[i+1]);\n      add_edge(v[i+1],v[i]);\n    }\n  }\n  for(int i=0;i<M;i++){\n    int xv,yv;\n    cin>>xv>>yv;\n    valves.insert(enc(xv,yv));\n  }\n  cin>>xb>>yb>>xc>>yc;\n  try{\n    stop(enc(xc,yc));\n    u.clear();\n    cout.precision(9);\n    cout<<fixed<<len-rec(enc(xb,yb),-1)<<endl;\n  }catch(...){\n    cout<<-1<<endl;\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps);\n  \nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  return getDistanceSP(s,c.c)<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  for(int k=0;k<2;k++){\n    if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1; \n    if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;\n    swap(s1,s2);\n  }\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n\tps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<pair<int, double> > > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++)\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n\tls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n      \n    sort(ls.begin(),ls.end());\n    for(int j=0;j+1<(int)ls.size();j++){\n      int a=ls[j].second,b=ls[j+1].second;\n      G[a].emplace_back(b,abs(ps[a]-ps[b]));\n      G[b].emplace_back(a,abs(ps[a]-ps[b]));\n    }\n  }\n  return G;\n}\n\t\t\t\t\t\t       \n\n//END CUT HERE\n\n//Segment Arrangement\nsigned AOJ_2454(){\n  int n,m;\n  cin>>n>>m;\n  vector<Segment> ss(n);\n  Polygon ps(m);\n  for(int i=0;i<n;i++) cin>>ss[i];\n  for(int i=0;i<m;i++) cin>>ps[i];\n  map<Point, int> mp;\n  for(int i=0;i<m;i++) mp[ps[i]]=i;\n  Point s,g;\n  cin>>s>>g;\n  ps.emplace_back(s);\n  ps.emplace_back(g);\n\n  auto G=segmentArrangement(ss,ps);\n  \n  double ans=0,tmp=0;\n  for(int i=0;i<n;i++) ans+=abs(ss[i].p1-ss[i].p2);\n\n  vector<int> used(G.size(),0);\n  queue<int> q;\n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==g) {used[i]=1;q.emplace(i);}\n\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    if(ps[v]==s){\n      cout<<(int)-1<<endl;\n      return 0;\n    }\n    if(mp.count(ps[v])) continue;\n    for(auto &e:G[v]){\n      int u=e.first;\n      if(!used[u]){\n\tused[u]=1;\n\tq.emplace(u);\n      }\n    }\n  }\n  \n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==s) q.emplace(i);\n\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(auto &e:G[v]){\n      int u=e.first;\n      double &c=e.second;\n      if(used[v]&&used[u]) continue;\n      if(c==0) continue;\n      tmp+=c;c=0;\n      q.emplace(u);\n    }\n  }\n  tmp/=2;\n  \n  cout<<fixed<<setprecision(12)<<ans-tmp<<endl;\n  return 0;\n}\n/*\nverified on 2018/01/27\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2454\n*/\n\n\nsigned main(){\n  //AOJ_CGL1A();\n  //AOJ_CGL1B();\n  //AOJ_CGL1C();\n\n  //AOJ_CGL2A();\n  //AOJ_CGL2B();\n  //AOJ_CGL2C();\n  //AOJ_CGL2D();\n  \n  //AOJ_CGL3A();\n  //AOJ_CGL3B();\n  //AOJ_CGL3C();\n  \n  //AOJ_CGL4A();\n  //AOJ_CGL4B();\n  //AOJ_CGL4C();\n  \n  //AOJ_CGL5A();\n  \n  //AOJ_CGL7A();\n  //AOJ_CGL7D();\n  //AOJ_CGL7E();\n  //AOJ_CGL7F();\n  //AOJ_CGL7G();\n\n  //AOJ_2572();\n  AOJ_2454();\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n\tps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<pair<int, double> > > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++)\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n\tls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n      \n    sort(ls.begin(),ls.end());\n    for(int j=0;j+1<(int)ls.size();j++){\n      int a=ls[j].second,b=ls[j+1].second;\n      G[a].emplace_back(b,abs(ps[a]-ps[b]));\n      G[b].emplace_back(a,abs(ps[a]-ps[b]));\n    }\n  }\n  for(int i=0;i<(int)G.size();i++){\n    sort(G[i].begin(),G[i].end());\n    G[i].erase(unique(G[i].begin(),G[i].end(),\n\t\t      [](pair<int,double> a,pair<int,double> b){\n\t\t\treturn a.first==b.first;}),\n\t       G[i].end());\n  }\n  return G;\n}\n\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  vector<Segment> ss(n);\n  Polygon ps(m);\n  for(int i=0;i<n;i++) cin>>ss[i];\n  for(int i=0;i<m;i++) cin>>ps[i];\n  map<Point, int> mp;\n  for(int i=0;i<m;i++) mp[ps[i]]=i;\n  Point s,g;\n  cin>>s>>g;\n  ps.emplace_back(s);\n  ps.emplace_back(g);\n\n  auto G=segmentArrangement(ss,ps);\n  if(0){\n    int k=G.size();\n    for(int i=0;i<k;i++){\n      cout<<i<<\":\"<<ps[i]<<endl;\n      for(auto p:G[i]) cout<<p.first<<\" \"<<p.second<<endl;\n    }\n  }\n\n  double ans=0,tmp=0;\n  for(int i=0;i<n;i++) ans+=abs(ss[i].p1-ss[i].p2);\n\n  vector<int> visit(G.size(),0);\n  queue<int> q;\n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==g) {visit[i]=1;q.emplace(i);}\n\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    if(ps[v]==s){\n      cout<<(int)-1<<endl;\n      return 0;\n    }\n    if(mp.count(ps[v])) continue;\n    for(auto &e:G[v]){\n      int u=e.first;\n      if(!visit[u]){\n\tvisit[u]=1;\n\tq.emplace(u);\n      }\n    }\n  }\n  //cout<<ans<<endl;\n  //for(int i=0;i<(int)G.size();i++) cout<<i<<\":\"<<visit[i]<<endl;\n  \n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==s) q.emplace(i);\n\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    //cout<<v<<endl;\n    for(auto &e:G[v]){\n      int u=e.first;\n      double &c=e.second;\n      if(visit[v]&&visit[u]) continue;\n      if(c==0) continue;\n      tmp+=c;c=0;\n      q.emplace(u);\n    }\n  }\n  tmp/=2;\n  \n  cout<<ans-tmp<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-12, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n// 点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef double Weight;\n\nstruct Edge { int from, to; Weight weight;\nint id;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight,const int id) {\n\tg[from].push_back(Edge{ from, to, weight,id});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<pair<Point,bool>> &p) {\n\tint n = p.size(), m = s.size();\n\tint id = 0;\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j].first))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j].first), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from].first - p[to].first), id);\n\t\t\tadd_edge(g, to, from, abs(p[from].first - p[to].first), id++);\n\t\t}\n\t}\n\treturn g;\n}\n\n//Graph sennbunn_arrangement(const vector<Line>&s) {\n//\tvector<Point>crss;\n//\tfor (int i = 0; i < s.size(); ++i) {\n//\t\tfor (int j = i + 1; j < s.size(); ++j) {\n//\t\t\tif (isis_ss( s[i],  s[j])) {\n//\t\t\t\tcrss.push_back(is_ll( s[i],  s[j]));\n//\t\t\t}\n//\t\t}\n//\t}\n//\tfor (int i = 0; i <s.size(); ++i) {\n//\t\tcrss.push_back( s[i][0]);\n//\t\tcrss.push_back( s[i][1]);\n//\t}\n//\treturn segment_arrangement(s, crss);\n//}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nint startid;\nint goalid;\nbool dfs0(const Graph&g,const int now, vector<bool>&came, vector<bool>&close,const vector<bool>&bulbs) {\n\tcame[now] = true;\n\tfor (auto e : g[now]) {\n\t\tif (!came[e.to]) {\n\t\t\tif (e.to == startid)return false;\n\t\t\telse {\n\t\t\t\tif (bulbs[e.to]) {\n\t\t\t\t\tclose[e.to] = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!dfs0(g, e.to, came, close, bulbs)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ndouble dfs1(const Graph&g, const int now, vector<bool>&came,vector<bool>&useedges, const vector<bool>&close) {\n\tcame[now] = true;\n\tdouble ans = 0;\n\tfor (auto e : g[now]) {\n\t\tif (!useedges[e.id]) {\n\t\t\tans += e.weight;\n\t\t\tuseedges[e.id] = true;\n\t\t\tif (close[e.to])continue;\n\t\t\telse {\n\t\t\t\tif(!came[e.to])ans += dfs1(g, e.to, came,useedges, close);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tdouble sum = 0;\n\tGraph g;\n\tint sx, sy, gx, gy;\n\tPoint start;\n\tPoint goal;\n\tvector<pair<Point, bool>>crss;\n\tvector<bool>bulbs;\n\t{\n\t\tint N, M; cin >> N >> M;\n\t\tvector<Line>ls;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint asx, asy, dx, dy; cin >> asx >> asy >> dx >> dy;\n\t\t\tls.push_back(Line(Point(asx, asy), Point(dx, dy)));\n\t\t\tsum += (abs(Point(asx, asy) - Point(dx, dy)));\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < ls.size(); ++j) {\n\t\t\t\tif (isis_ss(ls[i], ls[j])) {\n\t\t\t\t\tcrss.push_back(make_pair(is_ll(ls[i], ls[j]),false));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < ls.size(); ++i) {\n\t\t\tcrss.push_back(make_pair(ls[i][0], false));\n\t\t\tcrss.push_back(make_pair(ls[i][1], false));\n\t\t}\n\t\t\n\t\tvector<Point >bs;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tPoint p(x, y);\n\t\t\tbs.push_back(p);\n\t\t}\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tstart = Point(sx, sy);\n\t\tgoal = Point(gx, gy);\t\n\t\tcrss.push_back(make_pair(start, false));\n\t\tcrss.push_back(make_pair(goal, false));\n\t\tsort(crss.begin(), crss.end());\n\t\tcrss.erase(unique(crss.begin(), crss.end()), crss.end());\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tauto it = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == bs[i]; });\n\t\t\tif (it == crss.end()) {\n\t\t\t\tcrss.push_back(make_pair(bs[i], true));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(*it).second = true;\n\t\t\t}\n\t\t}\n\n\n\t\tfor (int i = 0; i < crss.size(); ++i) {\n\t\t\tbulbs.push_back(crss[i].second);\n\t\t}\n\t\tg= segment_arrangement(ls, crss);\n\t}\n\tauto startit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == start; });\n\tstartid = startit - crss.begin();\n\tauto goalit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == goal; });\n\tgoalid = goalit - crss.begin();\n\tvector<bool>close(crss.size(),false);\n\tvector<bool>came(crss.size(), false);\n\tif (dfs0(g, goalid, came, close, bulbs)) {\n\t\tvector<bool>acame(crss.size(), false);\n\t\tvector<bool>useedges(80000, false);\n\t\tdouble ans = dfs1(g, startid, acame, useedges,close);\n\t\tcout <<fixed<<setprecision(10)<< sum-ans << endl;\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a,b;\n\toperator line<T>()const{ return (line<T>){a,b}; }\n};\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<double> &S,const point<double> &p){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\nvoid arrangement(const vector< segment<double> > &S,const vector< point<double> > &plus,vector< point<double> > &P,vector<int> *G){\n\tint n=S.size();\n\tP=plus;\n\trep(i,n){\n\t\tP.push_back(S[i].a);\n\t\tP.push_back(S[i].b);\n\t\trep(j,i) if(intersect(S[i],S[j])) P.push_back(get_intersect(S[i],S[j]));\n\t}\n\tsort(P.begin(),P.end());\n\tP.erase(unique(P.begin(),P.end()),P.end());\n\n\trep(i,n){\n\t\tvector<int> on;\n\t\trep(u,P.size()) if(cover(S[i],P[u])) on.push_back(u);\n\t\trep(j,(int)on.size()-1){\n\t\t\tint u=on[j],v=on[j+1];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tvector< segment<double> > pipe(n);\n\trep(i,n) scanf(\"%lf%lf%lf%lf\",&pipe[i].a.x,&pipe[i].a.y,&pipe[i].b.x,&pipe[i].b.y);\n\tvector< point<double> > stop(m);\n\trep(i,m) scanf(\"%lf%lf\",&stop[i].x,&stop[i].y);\n\tpoint<double> s,t;\n\tscanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&t.x,&t.y);\n\n\t// 追加の頂点集合\n\tvector< point<double> > plus=stop;\n\tplus.push_back(s);\n\tplus.push_back(t);\n\n\tvector< point<double> > P;\n\tvector<int> G[10000];\n\tarrangement(pipe,plus,P,G);\n\n\tint N=P.size();\n\tbool isstop[10000]={};\n\trep(i,m) rep(j,N) if(P[j]==stop[i]) isstop[j]=true;\n\n\tint s_id=find(P.begin(),P.end(),s)-P.begin();\n\tint t_id=find(P.begin(),P.end(),t)-P.begin();\n\n\t// t から stop をまたがずに行ける場所を見つける\n\tbool vis[10000]={};\n\tvis[t_id]=true;\n\tqueue<int> Q; Q.push(t_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=true;\n\t\t\t\tif(!isstop[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(vis[s_id]){ puts(\"-1\"); return 0; }\n\n\t// s から vis を通らずに行ける場所を見つける\n\tbool vis2[10000]={};\n\tvis2[s_id]=true;\n\tQ.push(s_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v]=true;\n\t\t\t\tif(!vis[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans=0;\n\trep(i,n) ans+=dist(pipe[i].a,pipe[i].b);\n\trep(u,N) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tif(vis2[u] && vis2[v]) ans-=dist(P[u],P[v])/2; // 二回カウントされるので半分\n\t}\n\tprintf(\"%.9f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<unordered_map>\n\nusing namespace std;\n\nmap<int,vector<int> > g;\n\nint main(){\n  for(int i=0;i<300;i++){\n    for(int j=-1000;j<=1000;j++){\n      g[(i<<16)+j].push_back(j);\n      g[(i<<16)+j].push_back(j);\n    }\n  }\n  int N,M;\n  cin>>N>>M;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-7;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct segment{ point<T> a,b; };\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<double> &S,const point<double> &p){\n\treturn abs(cross(S.a-p,S.b-p))<EPS && dot(S.a-p,S.b-p)<EPS;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\npoint<double> get_intersect(const segment<double> &S1,const segment<double> &S2){\n\tdouble a1=cross(S1.b-S1.a,S2.b-S2.a);\n\tdouble a2=cross(S1.b-S1.a,S1.b-S2.a);\n\tif(abs(a1)<EPS){\n\t\tif(cover(S1,S2.a)) return S2.a;\n\t\tif(cover(S1,S2.b)) return S2.b;\n\t\tif(cover(S2,S1.a)) return S1.a;\n\t\treturn S1.b;\n\t}\n\treturn S2.a+a2/a1*(S2.b-S2.a);\n}\n\n// 追加で頂点集合を指定できるように書き換え\nvoid arrangement(const vector< segment<double> > &S,const vector< point<double> > &plus,vector< point<double> > &P,vector<int> *G){\n\tint n=S.size();\n\tP=plus;\n\trep(i,n){\n\t\tP.push_back(S[i].a);\n\t\tP.push_back(S[i].b);\n\t\trep(j,i) if(intersect(S[i],S[j])) P.push_back(get_intersect(S[i],S[j]));\n\t}\n\tsort(P.begin(),P.end());\n\tP.erase(unique(P.begin(),P.end()),P.end());\n\n\trep(i,n){\n\t\tvector<int> on;\n\t\trep(u,P.size()) if(cover(S[i],P[u])) on.push_back(u);\n\t\trep(j,(int)on.size()-1){\n\t\t\tint u=on[j],v=on[j+1];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tvector< segment<double> > pipe(n);\n\trep(i,n) scanf(\"%lf%lf%lf%lf\",&pipe[i].a.x,&pipe[i].a.y,&pipe[i].b.x,&pipe[i].b.y);\n\tvector< point<double> > stop(m);\n\trep(i,m) scanf(\"%lf%lf\",&stop[i].x,&stop[i].y);\n\tpoint<double> s,t;\n\tscanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&t.x,&t.y);\n\n\t// 追加の頂点集合\n\tvector< point<double> > plus=stop;\n\tplus.push_back(s);\n\tplus.push_back(t);\n\n\tvector< point<double> > P;\n\tstatic vector<int> G[100000];\n\tarrangement(pipe,plus,P,G);\n\n\tint N=P.size();\n\tstatic bool isstop[100000];\n\trep(i,m) rep(u,N) if(P[u]==stop[i]) isstop[u]=true;\n\n\tint s_id=find(P.begin(),P.end(),s)-P.begin();\n\tint t_id=find(P.begin(),P.end(),t)-P.begin();\n\n\t// t から stop をまたがずに行ける場所を見つける\n\tstatic bool vis[100000];\n\tvis[t_id]=true;\n\tqueue<int> Q; Q.push(t_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=true;\n\t\t\t\tif(!isstop[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(vis[s_id]){ puts(\"-1\"); return 0; }\n\n\tdouble ans=0;\n\trep(i,n) ans+=dist(pipe[i].a,pipe[i].b);\n\n\t// s から vis を通らずに行ける場所を見つける\n\tstatic bool vis2[100000];\n\tvis2[s_id]=true;\n\tQ.push(s_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v]=true;\n\t\t\t\tif(!vis[v]) Q.push(v);\n\t\t\t}\n\t\t\tif(vis[v]) ans-=dist(P[u],P[v]);   // 一回カウントされる\n\t\t\telse       ans-=dist(P[u],P[v])/2; // 二回カウントされる\n\t\t}\n\t}\n\tprintf(\"%.9f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<unordered_map>\n#include<utility>\n\nusing namespace std;\n\nmultimap<int,int> g;\nset<int> valves;\nint xb,yb,xc,yc;\nconst int O=1234;\nset<int> stopped,u;\n\nint gcd(int a,int b){\n  return b?gcd(b,a%b):a;\n}\n\nint enc(int x,int y){\n  return (x+O<<16)+y+O;\n}\n\npair<int,int> dec(int x){\n  return make_pair((x>>16)-O,(x&(1<<16)-1)-O);\n}\n\nvoid stop(int v){\n  if(!u.insert(v).second)return;\n  if(valves.count(v)){\n    stopped.insert(v);\n    return;\n  }else{\n    int y,x;\n    tie(x,y)=dec(v);\n    if(y==yb&&x==xb)throw 0;\n    auto c=g.equal_range(v);\n    for(auto it=c.first;it!=c.second;it++){\n      if(u.count(it->second))continue;\n      stop(it->second);\n    }\n  }\n}\n\ndouble rec(int v,int p){\n  if(!u.insert(v).second)return 0;\n  if(stopped.count(v))return 0;\n  int y,x;\n  tie(x,y)=dec(v);\n  auto c=g.equal_range(v);\n  double r=0;\n  for(auto it=c.first;it!=c.second;it++){\n    if(it->second==p)continue;\n    int ny,nx;\n    tie(nx,ny)=dec(it->second);\n    r+=hypot(ny-y,nx-x)+rec(it->second,v);\n  }\n  return r;\n}\n\nvoid add_edge(pair<int,int> a,pair<int,int> b){\n  g.insert(make_pair(enc(a.first,a.second),enc(b.first,b.second)));\n}\n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  double len=0;\n  for(int i=0;i<N;i++){\n    int xs,ys,xd,yd;\n    cin>>xs>>ys>>xd>>yd;\n    len+=hypot(xs-xd,ys-yd);\n    vector<pair<int,int> > v;\n    if(xs==xd||ys==yd){\n      if(xs>xd){\n\tswap(xs,xd);\n      }\n      if(ys>yd){\n\tswap(ys,yd);\n      }\n      for(int x=xs,y=ys;x<=xd&&y<=yd;x+=xs!=xd,y+=ys!=yd){\n\tv.emplace_back(x,y);\n      }\n    }else{\n      if(xd<xs){\n\tswap(xs,xd);\n\tswap(ys,yd);\n      }\n      int m=gcd(xd-xs,abs(yd-ys));\n      for(int y=ys,x=xs;x<=xd;x+=(xd-xs)/m,y+=(yd-ys)/m){\n\tv.emplace_back(x,y);\n      }\n    }\n    for(int i=0;i<v.size()-1;i++){\n      add_edge(v[i],v[i+1]);\n      add_edge(v[i+1],v[i]);\n    }\n  }\n  for(int i=0;i<M;i++){\n    int xv,yv;\n    cin>>xv>>yv;\n    valves.insert(enc(xv,yv));\n  }\n  cin>>xb>>yb>>xc>>yc;\n  try{\n    stop(enc(xc,yc));\n    u.clear();\n    cout<<fixed<<len-rec(enc(xb,yb),-1)<<endl;\n  }catch(...){\n    cout<<-1<<endl;\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    // if (abs(a-b)<EPS) return 0;\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L() {}\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ntypedef int Weight;\nstruct Edge {\n  int dst;\n  Weight weight;\n  Edge(int dst, Weight weight) :\n    dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nGraph segmentArrangement(const vector<L> &ss, vector<P> &ps) {\n  for (int i = 0; i < ss.size(); ++i) { // O(n^2)\n    ps.push_back( ss[i][0] );\n    ps.push_back( ss[i][1] );\n    for (int j = i+1; j < ss.size(); ++j)\n      if (intersectSS(ss[i], ss[j])) {\n        ps.push_back( crosspoint(ss[i], ss[j]) );\n      }\n  }\n  sort(ALL(ps)); ps.erase(unique(ALL(ps)), ps.end());\n\n  Graph g(ps.size());\n  for (int i = 0; i < ss.size(); ++i) {\n    vector< pair<double, int> > list;\n    for (int j = 0; j < ps.size(); ++j)\n      if (intersectSP(ss[i], ps[j]))\n        list.push_back(make_pair(norm(ss[i][0]-ps[j]), j));\n    sort(ALL(list));\n    for (int j = 0; j+1 < list.size(); ++j) {\n      int a = list[j].second, b = list[j+1].second;\n      g[a].push_back( Edge(b, abs(ps[a]-ps[b])) );\n      g[b].push_back( Edge(a, abs(ps[a]-ps[b])) );\n    }\n  }\n  return g;\n}\n\nint pp[1002];\nint rp[100000];\n\nbool flag[1000];\nbool visited[100000];\nint xv[1000],yv[1000];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<L> ss;\n  double sum = 0;\n  REP(i,n) {\n    int x1,y1,x2,y2;\n    cin>>x1>>y1>>x2>>y2;\n    ss.push_back(L(P(x1,y1),P(x2,y2)));\n    sum += abs(P(x1,y1)-P(x2,y2));\n  }\n  vector<P> ps;\n  REP(i,m) {\n    cin >> xv[i] >> yv[i];\n  }\n  cin>>xv[m]>>yv[m]>>xv[m+1]>>yv[m+1];\n  REP(i,m+2) {\n    ps.push_back(P(xv[i],yv[i]));\n  }\n  Graph g = segmentArrangement(ss,ps);\n  memset(rp,-1,sizeof(rp));\n  REP(i,m+2) {\n    REP(j,ps.size()) {\n      if (abs(P(xv[i],yv[i]) - ps[j]) < EPS) {\n        pp[i] = j;\n        rp[j] = i;\n        break;\n      }\n    }\n  }\n  queue<int> Q;\n  Q.push(pp[m+1]);\n  while(!Q.empty()) {\n    int now = Q.front(); Q.pop();\n    visited[now] = 1;\n\n    //cout << now << \" \" << ps[now] << endl;\n    \n    if (rp[now] != -1 && rp[now] < m) {\n      flag[rp[now]] = 1;\n      continue;\n    }\n    if (rp[now] == m) {\n      puts(\"-1\");\n      return 0;\n    }\n    FOR(it, g[now]) {\n      //cout << \" \" << it->dst << endl;\n      if (!visited[it->dst]) {\n        Q.push(it->dst);\n      }\n    }\n  }\n  memset(visited,0,sizeof(visited));\n  Q.push(pp[m]);\n  map<pii,bool> mp;\n  double ans = 0;\n  while(!Q.empty()) {\n    int now = Q.front(); Q.pop();\n    visited[now] = 1;\n    if (rp[now]!=-1 && rp[now]<m && flag[rp[now]]) continue;\n    FOR(it, g[now]) {\n      int a = min(now,it->dst);\n      int b = max(now, it->dst);\n      if (!mp.count(pii(a,b))) {\n        mp[pii(a,b)] = 1;\n        ans += it->weight;\n      }\n      if (!visited[it->dst]) {\n        Q.push(it->dst);\n      }\n    }\n  }\n  printf(\"%.10f\\n\", sum-ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n\t ps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<pair<int, double> > > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++){\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n\tls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n      sort(ls.begin(),ls.end());\n      for(int j=0;j+1<(int)ls.size();j++){\n\tint a=ls[j].second,b=ls[j+1].second;\n\tG[a].emplace_back(b,abs(ps[a]-ps[b]));\n\tG[b].emplace_back(a,abs(ps[a]-ps[b]));\n      }\n    }\n  }\n  for(int i=0;i<(int)ps.size();i++){\n    sort(G[i].begin(),G[i].end());\n    G[i].erase(unique(G[i].begin(),G[i].end(),\n\t\t      [](auto a,auto b){return a.first==b.first;}),\n\t       G[i].end());\n  }\n  return G;\n}\n\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  vector<Segment> ss(n);\n  Polygon ps(m);\n  for(int i=0;i<n;i++) cin>>ss[i];\n  for(int i=0;i<m;i++) cin>>ps[i];\n  map<Point, int> mp;\n  for(int i=0;i<m;i++) mp[ps[i]]=i;\n  Point s,g;\n  cin>>s>>g;\n  ps.emplace_back(s);\n  ps.emplace_back(g);\n\n  auto G=segmentArrangement(ss,ps);\n  if(0){\n    int k=G.size();\n    for(int i=0;i<k;i++){\n      cout<<i<<\":\"<<ps[i]<<endl;\n      for(auto p:G[i]) cout<<p.first<<\" \"<<p.second<<endl;\n    }\n  }\n\n  double ans=0,tmp=0;\n  for(int i=0;i<n;i++) ans+=abs(ss[i].p1-ss[i].p2);\n\n  vector<int> used(G.size(),0);\n  queue<int> q;\n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==g) {used[i]=1;q.emplace(i);}\n\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    if(ps[v]==s){\n      cout<<(int)-1<<endl;\n      return 0;\n    }\n    if(mp.count(ps[v])) continue;\n    for(auto &e:G[v]){\n      int u=e.first;\n      if(!used[u]){\n\tused[u]=1;\n\tq.emplace(u);\n      }\n    }\n  }\n  //cout<<ans<<endl;\n  //for(int i=0;i<(int)G.size();i++) cout<<i<<\":\"<<used[i]<<endl;\n  \n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==s) q.emplace(i);\n  \n  while(!q.empty()){\n    int v=q.front();q.pop();\n    //cout<<v<<endl;\n    for(auto &e:G[v]){\n      int u=e.first;\n      double &c=e.second;\n      if(used[v]&&used[u]) continue;\n      if(c==0) continue;\n      tmp+=c;c=0;\n      q.emplace(u);\n    }\n  }\n  tmp/=2;\n  \n  cout<<ans-tmp<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\n#define tpl(...) make_tuple(__VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nconst long double EPS = 1e-12;\n#define double long double\nconst double PI = acos(-1);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T>ostream&operator<<(ostream &o,const vector<T>&t){o<<'[';FOR(i,t){if(i!=t.begin())o<<',';o<<*i;}return o<<']';}\ntemplate<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}\ntemplate<int N,class Tp>void output(ostream&,const Tp&){}\ntemplate<int N,class Tp,class,class ...Ts>void output(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);output<N+1,Tp,Ts...>(o,t);}\ntemplate<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';output<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}\ntemplate<class T>void output(T t,char z=10){if(t<0)t=-t,putchar(45);int c[20];\nint k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;)putchar(c[--k]^48);putchar(z);}\ntemplate<class T>void outputs(T t){output(t);}\ntemplate<class S,class ...T>void outputs(S a,T...t){output(a,32);outputs(t...);}\ntemplate<class T>void output(T *a,int n){REP(i,n)cout<<a[i]<<(i!=n-1?',':'\\n');}\ntemplate<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}\ntemplate<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);\nif(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());)t=10*t+c-48;t=n?-t:t;return 1;}\ntemplate<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}\n\ntemplate<class T>\nstruct Pt {\n  T x,y;\n  Pt(T x=T(), T y=T()) :x(x),y(y) {}\n  bool operator<(const Pt &p) const { return x!=p.x?x<p.x:y<p.y; }\n  bool operator==(const Pt &p) const { return x==p.x&&y==p.y; }\n  Pt operator+=(const Pt &p) { x+=p.x, y+=p.y; return *this; }\n  Pt operator-=(const Pt &p) { x-=p.x, y-=p.y; return *this; }\n  Pt operator*=(const Pt &p) { T t=x;x=x*p.x-y*p.y,y=t*p.y+y*p.x; return *this;}\n  Pt operator*=(const T &v) { x*=v; y*=v; return *this;}\n  friend ostream& operator<<(ostream& os, const Pt &p) {return os<<'('<<p.x<<','<<p.y<<')';}\n  friend istream& operator>>(istream& is, Pt &p) {return is>>p.x>>p.y;}\n\n  Pt operator+(const Pt &p) const { return Pt(*this)+=p; }\n  Pt operator-(const Pt &p) const { return Pt(*this)-=p; }\n  Pt operator*(const Pt &p) const { return Pt(*this)*=p; }\n  Pt operator*(const T &v) const { return Pt(*this)*=v; }\n  friend Pt operator*(const T &v, const Pt &p) { return p*v; }\n  bool operator!=(const Pt &p) const { return !(*this == p); }\n\n  T abs() const { return hypot(x,y); }\n  T norm() const { return x*x+y*y; }\n  T arg() const { return atan2(y,x); }\n  T dot(const Pt &p) const { return x*p.x+y*p.y; }\n  T det(const Pt &p) const { return x*p.y-y*p.x; }\n  friend T abs(const Pt &p) { return p.abs(); }\n  friend T norm(const Pt &p) { return p.norm(); }\n  friend T arg(const Pt &p) { return p.arg(); }\n  friend T dot(const Pt &p, const Pt &q) { return p.dot(q); }\n  friend T det(const Pt &p, const Pt &q) { return p.det(q); }\n};\n\nint sig(double r) {return r<-EPS?-1:r>EPS?1:0;}\nint sig(ll r) {return r<0?-1:r>0?1:0;}\nbool eq(double a, double b) {return sig(a-b)==0;}\nbool eq(ll a, ll b) {return a==b;}\n\ntemplate<class T>int ccw(Pt<T> a, Pt<T> b, Pt<T> c); // 2(c--a--b), -2(a--b--c), 0(a=-c-=b)\n\ntemplate<> int ccw(Pt<ll> a, Pt<ll> b, Pt<ll> c) {\n  b -= a; c -= a;\n  return det(b,c) ? sig(det(b,c)) : dot(b,c)<0 ? 2 : (0<b.norm()&&b.norm()<c.norm()) ? -2 : 0;\n}\ntemplate<> int ccw(Pt<double> a, Pt<double> b, Pt<double> c) {\n  b -= a; c -= a;\n  if (det(b,c)) return sig(det(b,c));\n  if (sig(dot(b, c)) == -1) return +2; // c--a--b\n  if (EPS < b.norm() && b.norm() < c.norm()-EPS) return -2; // a--b--c\n  return 0;\n}\n\ntypedef Pt<double> P;\n\nclass L {\n  vector<P> v;\npublic:\n  L(const P &a, const P &b) : v({a,b,b-a}) {}\n  const P operator[](int i) const { return v[i]; }\n  void sub(const P&p) { v[0] -= p; v[1] -= p; }\n  friend ostream &operator<<(ostream &os, const L &l) {\n    return os << l[0] << \"->\" << l[1];\n  }\n};\n\nbool iSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool iSP(const L &s, const P &p) {\n\n  return sig(abs(s[0]-p)+abs(s[1]-p)-abs(s[2])) <= 0;\n};\n\nP crosspoint(const L &l, const L &m) {\n  auto A = det(l[2],m[2]);\n  auto B = det(l[2],l[1]-m[0]);\n  if (!sig(A) && !sig(B)) return m[0];// same line\n  if (!sig(A)) assert(0); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B/A*m[2];\n}\n\ntypedef vector<int> Edges;\ntypedef vector<Edges> Graph;\n\nGraph segmentArrangement(const vector<L> &ss, vector<P> &ps) {\n  int n = ss.size();\n  REP(i,n) {\n    ps.push_back( ss[i][0] );\n    ps.push_back( ss[i][1] );\n    for (int j = i+1; j < n; ++j)\n      if (iSS(ss[i], ss[j]))\n        ps.push_back( crosspoint(ss[i], ss[j]) );\n  }\n  sort(ALL(ps)); ps.erase(unique(ALL(ps)), ps.end());\n  Graph g(ps.size());\n  REP(i,ss.size()) {\n    vector<pair<double,int> > v;\n    REP(j,ps.size()) if (iSP(ss[i], ps[j])) {\n      v.emplace_back(norm(ss[i][0]-ps[j]), j);\n    }\n    sort(ALL(v));\n    REP(j,(int)v.size()-1) {\n      int a = v[j].second, b = v[j+1].second;\n      g[a].push_back(b); g[b].push_back(a);\n    }\n  }\n  return g;\n}\n\n\nint main() {\n  int n,m;\n  while(input(n,m)) {\n    vector<L> ss;\n    double sum = 0;\n    REP(i,n) {\n      P a,b; cin >> a >> b;\n      ss.emplace_back(a,b);\n      sum += (a-b).abs();\n    }\n    vector<P> ps(m+2);\n    REP(i,m+2) cin >> ps[i];\n    vector<P> p(ps);\n    Graph g = segmentArrangement(ss,ps);\n    vector<int> p2ps(m+2,-1);\n    vector<int> ps2p(ps.size(),-1);\n    REP(i,m+2) {\n      REP(j,ps.size())\n        if (norm(p[i]-ps[j]) < EPS) {\n          assert(p2ps[i] == -1);\n          assert(ps2p[j] == -1);\n          p2ps[i] = j;\n          ps2p[j] = i;\n        }\n    }\n\n    vector<bool> fg(ps.size()), fs(ps.size());\n    {\n      queue<int> Q;\n      Q.push(p2ps[m+1]);\n      bool ng = 0;\n      fg[p2ps[m+1]] = 1;\n      while(!Q.empty()) {\n        int v = Q.front(); Q.pop();\n        if (ps2p[v] != -1 && ps2p[v] < m) continue;\n        if (ps2p[v] == m) {\n          ng = 1;\n          break;\n        }\n        FOR(it, g[v]) if (!fg[*it]) {\n          fg[*it] = 1;\n          Q.push(*it);\n        }\n      }\n      if (ng) {\n        puts(\"-1\");\n        continue;\n      }\n    }\n    double ans = 0;\n    {\n      queue<int> Q;\n      Q.push(p2ps[m]);\n      fs[p2ps[m]] = 1;\n      while(!Q.empty()) {\n        int v = Q.front(); Q.pop();\n        // cout << ps2p[v] << \" \" << ps[v] << \" \" << g[v].size() << endl;\n\n        FOR(it, g[v]) {\n          if (!fg[v] || !fg[*it])\n            ans += abs(ps[v] - ps[*it]);\n          if (!fs[*it] && !fg[v]) {\n            fs[*it] = 1;\n            Q.push(*it);\n          }\n        }\n      }\n    }\n    ans = sum - ans / 2;\n    printf(\"%.10Lf\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-6;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a,b;\n\toperator line<T>()const{ return (line<T>){a,b}; }\n};\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<double> &S,const point<double> &p){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\n// 追加で頂点集合を指定できるように書き換え\nvoid arrangement(const vector< segment<double> > &S,const vector< point<double> > &plus,vector< point<double> > &P,vector<int> *G){\n\tint n=S.size();\n\tP=plus;\n\trep(i,n){\n\t\tP.push_back(S[i].a);\n\t\tP.push_back(S[i].b);\n\t\trep(j,i) if(intersect(S[i],S[j])) P.push_back(get_intersect(S[i],S[j]));\n\t}\n\tsort(P.begin(),P.end());\n\tP.erase(unique(P.begin(),P.end()),P.end());\nif(P.size()>10000) for(;;);\n\n\trep(i,n){\n\t\tvector<int> on;\n\t\trep(u,P.size()) if(cover(S[i],P[u])) on.push_back(u);\n\t\trep(j,(int)on.size()-1){\n\t\t\tint u=on[j],v=on[j+1];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tvector< segment<double> > pipe(n);\n\trep(i,n) scanf(\"%lf%lf%lf%lf\",&pipe[i].a.x,&pipe[i].a.y,&pipe[i].b.x,&pipe[i].b.y);\n\tvector< point<double> > stop(m);\n\trep(i,m) scanf(\"%lf%lf\",&stop[i].x,&stop[i].y);\n\tpoint<double> s,t;\n\tscanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&t.x,&t.y);\n\n\t// 追加の頂点集合\n\tvector< point<double> > plus=stop;\n\tplus.push_back(s);\n\tplus.push_back(t);\n\n\tvector< point<double> > P;\n\tvector<int> G[2000];\n\tarrangement(pipe,plus,P,G);\n\n\tint N=P.size();\n\tbool isstop[2000]={};\n\trep(i,m) rep(j,N) if(P[j]==stop[i]) isstop[j]=true;\n\n\tint s_id=find(P.begin(),P.end(),s)-P.begin();\n\tint t_id=find(P.begin(),P.end(),t)-P.begin();\n\n\t// t から stop をまたがずに行ける場所を見つける\n\tbool vis[2000]={};\n\tvis[t_id]=true;\n\tqueue<int> Q; Q.push(t_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=true;\n\t\t\t\tif(!isstop[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(vis[s_id]){ puts(\"-1\"); return 0; }\n\n\t// s から vis を通らずに行ける場所を見つける\n\tbool vis2[2000]={};\n\tvis2[s_id]=true;\n\tQ.push(s_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v]=true;\n\t\t\t\tif(!vis[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans=0;\n\trep(i,n) ans+=dist(pipe[i].a,pipe[i].b);\n\trep(u,N) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tif(u<v && vis2[u] && vis2[v]) ans-=dist(P[u],P[v]);\n\t}\n\tprintf(\"%.9f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nint n, m, np, l, idx[100011], cl, q[100011], v, s, t;\ndouble ans, eps = 1e-10;\nbool f[100011], isstop[100011], mark[100011], flag;\nstruct recedge\n{\n\tint y, nxt;\n} edge[2000011];\nvoid build(int x, int y)\n{\n\tedge[++l].y = y;\n\tedge[l].nxt = idx[x];\n\tidx[x] = l;\n}\nstruct couple\n{\n\tdouble x, y;\n\tcouple(){};\n\tcouple(const double & _a, const double & _b) : x(_a), y(_b){}\n\tdouble len()\n\t{\n\t\treturn sqrt(x * x + y * y);\n\t}\n} b[1111], cp, points[100011];\nbool equal(const double  & a, const double & b)\n{\n\treturn fabs(a - b) < eps;\n}\nbool les(const double & a, const double & b)\n{\n\treturn a + eps < b;\n}\nbool operator < (const couple & a, const couple & b)\n{\n\treturn les(a.x, b.x) or equal(a.x, b.x) and les(a.y, b.y);\n}\nbool operator == (const couple & a, const couple & b)\n{\n\treturn equal(a.x, b.x) and equal(a.y, b.y);\n}\nmap<couple, int> mp;\nvector<couple> vec[111];\ncouple operator - (const couple & a, const couple & b)\n{\n\treturn couple(a.x - b.x, a.y - b.y);\n}\ncouple operator + (const couple & a, const couple & b)\n{\n\t\treturn couple(a.x + b.x, a.y + b.y);\n}\n\ncouple operator * (const double & lambda, const couple & a)\n{\n\treturn couple(lambda * a.x, lambda * a.y);\n}\ndouble operator * (const couple & a, const couple & b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\ndouble operator % (const couple & a, const couple & b)\n{\n\treturn a.x * b.x + a.y * b.y;\n}\nstruct reca\n{\n\tcouple a, b;\n} a[111];\nbool cross(int i, int j)\n{\n\tif((a[i].b - a[i].a) * (a[j].b - a[j].a) == 0)\n\t{\n\t\tif(a[i].b == a[j].a or a[i].b == a[j].b)\n\t\t{\n\t\t\tcp = a[i].b;\n\t\t\treturn true;\n\t\t}else if(a[i].a == a[j].a  or a[i].a == a[j].b)\n\t\t{\n\t\t\tcp = a[i].a;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}else if(((a[j].a - a[i].a) * (a[i].b - a[i].a)) * ((a[j].b - a[i].a) * (a[i].b - a[i].a)) <= 0 and ((a[i].a - a[j].a) * (a[j].b - a[j].a))*((a[i].b - a[j].a) * (a[j].b - a[j].a)) <= 0)\n\t{\n\t\tdouble lambda = (a[j].a - a[i].a) * (a[j].b - a[j].a) / ((a[i].b - a[i].a) * (a[j].b - a[j].a));\n\t\tcp = a[i].a + lambda * (a[i].b - a[i].a);\n\t\treturn true;\n\t}else return false;\n}\nbool on(int i, int j)\n{\n\treturn (a[j].a - b[i]) * (a[j].b - b[i]) == 0 and (a[j].a - b[i]) % (a[j].b - b[i]) <= 0;\n}\ndouble dis(int i, int j)\n{\n\treturn sqrt((points[i].x - points[j].x) * (points[i].x - points[j].x) + (points[i].y - points[j].y) * (points[i].y - points[j].y));\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%lf%lf%lf%lf\", &a[i].a.x, &a[i].a.y, &a[i].b.x, &a[i].b.y);\n\t\tans = ans + (a[i].b - a[i].a).len();\n\t}\n\tfor(int i = 1; i <= m + 2; i++)\n\t{\n\t\tscanf(\"%lf%lf\", &b[i].x, &b[i].y);\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tvec[i].clear();\n\t\tvec[i].push_back(a[i].a);\n\t\tvec[i].push_back(a[i].b);\n\t\tmp[a[i].a] = 0;\n\t\tmp[a[i].b] = 0;\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = i + 1; j <= n; j++)\n\t\t\tif(cross(i, j))\n\t\t\t{\n\t\t\t\tvec[i].push_back(cp);\n\t\t\t\tvec[j].push_back(cp);\n\t\t\t\tmp[cp] = 0;\n\t\t\t}\n\tfor(int i = 1; i <= m + 2; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t\tif(on(i, j))\n\t\t\t{\n\t\t\t\tvec[j].push_back(b[i]);\n\t\t\t\tmp[b[i]] = 0;\n\t\t\t}\n\tnp = 0;\n\tfor(map<couple, int>::iterator it = mp.begin(); it != mp.end(); it++) \n\t{\n\t\tit->second = ++np;\n\t\tpoints[np] = it->first;\n\t}\n\tl = 1;\n\tmemset(idx, 0, sizeof(idx));\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tsort(vec[i].begin(), vec[i].end());\n\t\tvec[i].resize(unique(vec[i].begin(), vec[i].end()) - vec[i].begin());\n\t\tfor(int j = 0; j < vec[i].size() - 1; j++)\n\t\t{\n\t\t\tbuild(mp[vec[i][j]], mp[vec[i][j + 1]]);\n\t\t\tbuild(mp[vec[i][j + 1]], mp[vec[i][j]]);\n\t\t}\n\t\t//for(int j = 0; j < vec[i].size(); j++) printf(\"%d \", mp[vec[i][j]]);\n\t\t//printf(\"\\n\");\n\t}\n\tmemset(isstop, 0, sizeof(isstop));\n\tmemset(mark, 0, sizeof(mark));\n\tmemset(f, true, sizeof(f));\n\ts = mp[b[m + 1]];\n\tt = mp[b[m + 2]];\n\tfor(int i = 1; i <= m; i++) isstop[mp[b[i]]] = true;\n\tq[cl = 1] = t;\n\tflag = true;\n\tf[t] = false;\n\tfor(int op = 1; op <= cl; op++)\n\t{\n\t\t//printf(\"%d\\n\", q[op]);\n\t\tfor(int p = idx[v = q[op]]; p; p = edge[p].nxt) if(f[edge[p].y] == true)\n\t\t{\n\t\t\tif(edge[p].y == s)\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}else\n\t\t\t{\n\t\t\t\tif(isstop[edge[p].y] == true)\n\t\t\t\t{\n\t\t\t\t\tmark[edge[p].y] = true;\n\t\t\t\t\t//printf(\"mark %d\\n\", edge[p].y);\n\t\t\t\t}else\n\t\t\t\t{\n\t\t\t\t\tq[++cl] = edge[p].y;\n\t\t\t\t\tf[edge[p].y] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag == false) break;\n\t}\n\tif(flag == false)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tq[cl = 1] = s;\n\tmemset(f, true, sizeof(f));\n\tf[s] = false;\n\tfor(int op = 1; op <= cl; op++)\n\t{\n\t\tfor(int p = idx[v = q[op]]; p; p = edge[p].nxt)\n\t\t{\n\t\t\tans -= dis(v, edge[p].y) / 2;\n\t\t\tif(mark[edge[p].y] == true)\n\t\t\t\tans -= dis(v, edge[p].y) / 2;\n\t\t\telse if(f[edge[p].y])\n\t\t\t{\n\t\t\t\tf[edge[p].y] = false;\n\t\t\t\tq[++cl] = edge[p].y;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", ans);\n\tfclose(stdin);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define MAX 200010\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\ntypedef vector<vector<pair<int,double> > > Graph;\n\nGraph SegmentArrangement(vector<Segment> v,vector<Point> &ps){\n  for(int i=0;i<v.size();i++){\n    ps.push_back(v[i].p1);\n    ps.push_back(v[i].p2);\n    for(int j=i+1;j<v.size();j++){\n      if(intersect(v[i],v[j]))ps.push_back(getCrossPointLL(v[i],v[j]));\n    }\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n  Graph g(ps.size());\n  for(int i=0;i<v.size();i++){\n    vector<pair<double,int> > list;\n    for(int j=0;j<ps.size();j++)\n      if(ccw(v[i].p1,v[i].p2,ps[j])==0)\n        list.push_back(mp(norm(v[i].p1-ps[j]),j));\n    sort(list.begin(),list.end());\n    for(int j=0;j<list.size()-1;j++){\n      int a=list[j].s,b=list[j+1].s;\n      g[a].push_back(mp(b,abs(ps[b]-ps[a])));\n      g[b].push_back(mp(a,abs(ps[a]-ps[b])));\n    }\n  }\n  return g;\n}\n\nint n,m;\nvector<Segment> vs;\nvector<Point> vp;\nset<Point> st;\nPoint s,t;\nint c,d;\nGraph g;\nbool checked[MAX]={};\nbool visited[MAX]={};\nbool valve[MAX]={};\n\nvoid dfs(int v){\n  checked[v]=true;\n  if(valve[v])return;\n  for(int i=0;i<g[v].size();i++){\n    pair<int,double> next=g[v][i];\n    if(!checked[next.f])dfs(next.f);\n  }\n  return;\n}\n\ndouble dfs2(int v){\n  if(checked[v])return 0.0;\n  visited[v]=true;\n  double res=0.0;\n  for(int i=0;i<g[v].size();i++){\n    pair<int,double> next=g[v][i];\n    if(!visited[next.f])res+=dfs2(next.f)+next.s;\n  }\n  checked[v]=true;\n  return res;\n}\n\nint main()\n{\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    vs.push_back(Segment(Point(a,b),Point(c,d)));\n  }\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    vp.push_back(Point(a,b));\n    st.insert(Point(a,b));\n  }\n  cin>>s.x>>s.y>>t.x>>t.y;\n  vp.push_back(s);\n  vp.push_back(t);\n  g=SegmentArrangement(vs,vp);\n  for(int i=0;i<vp.size();i++){\n    //printf(\"%.10f %.10f\\n\",vp[i].x,vp[i].y);\n    if(st.find(vp[i])!=st.end())valve[i]=true;\n    if(vp[i]==s)c=i;\n    if(vp[i]==t)d=i;\n  }\n  dfs(d);\n  if(checked[c])cout<<-1<<endl;\n  else {\n    double ans=0.0;\n    for(int i=0;i<g.size();i++){\n      for(int j=0;j<g[i].size();j++)ans+=g[i][j].s/2.0;\n    }\n    ans-=dfs2(c);\n    printf(\"%.10f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define MAX 200010\n#define eps (1e-10)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool isParallel(Segment s,Segment t){\n    return equals(cross(s.p1-s.p2,t.p1-t.p2),0.0);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\nbool merge_if_able(Segment &s,Segment t) {\n  if(!isParallel(s,t))return false;\n  if(ccw(s.p1,t.p1,s.p2)==1 ||\n     ccw(s.p1,t.p1,s.p2)==-1)return false;\n  if(ccw(s.p1,s.p2,t.p1)==-2 ||\n     ccw(t.p1,t.p2,s.p1)==-2)return false;\n  s=Segment(min(s.p1,t.p1),max(s.p2,t.p2));\n  return true;\n}\n\nvoid merge(vector<Segment>& v) {\n  for(int i=0;i<v.size();i++){\n    if(v[i].p2<v[i].p1)swap(v[i].p2,v[i].p1);\n  }\n  for(int i=0;i<v.size();i++)\n    for(int j=i+1;j<v.size();j++)\n      if(merge_if_able(v[i],v[j]))\n        v[j--]=v.back(),v.pop_back();\n}\n\ntypedef vector<vector<pair<int,double> > > Graph;\n\nGraph SegmentArrangement(vector<Segment> v,vector<Point> &ps){\n  for(int i=0;i<v.size();i++){\n    ps.push_back(v[i].p1);\n    ps.push_back(v[i].p2);\n    for(int j=i+1;j<v.size();j++){\n      if(intersect(v[i],v[j]))ps.push_back(getCrossPointLL(v[i],v[j]));\n    }\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n  Graph g(ps.size());\n  for(int i=0;i<v.size();i++){\n    vector<pair<double,int> > list;\n    for(int j=0;j<ps.size();j++)\n      if(ccw(v[i].p1,v[i].p2,ps[j])==0)\n        list.push_back(mp(norm(v[i].p1-ps[j]),j));\n    sort(list.begin(),list.end());\n    for(int j=0;j<list.size()-1;j++){\n      int a=list[j].s,b=list[j+1].s;\n      g[a].push_back(mp(b,abs(ps[b]-ps[a])));\n      g[b].push_back(mp(a,abs(ps[a]-ps[b])));\n    }\n  }\n  return g;\n}\n\nint n,m;\nvector<Segment> vs;\nvector<Point> vp;\nset<Point> st;\nPoint s,t;\nint c,d;\nGraph g;\nbool checked[MAX]={};\nbool visited[MAX]={};\nbool valve[MAX]={};\n\nvoid dfs(int v){ \n  checked[v]=true;\n  if(valve[v])return;\n  for(int i=0;i<g[v].size();i++){\n    pair<int,double> next=g[v][i];\n    if(!checked[next.f]){\n      dfs(next.f);\n    }\n  }\n  return;\n}\n\ndouble bfs(int v){\n  double res=0.0;\n  queue<int> q;\n  q.push(v);\n  while(q.size()){\n    int u=q.front();\n    q.pop();\n    if(visited[u])continue;\n    visited[u]=true;\n    for(int i=0;i<g[u].size();i++){\n      pair<int,double> next=g[u][i];\n      if(checked[next.f])res+=next.s;\n      else if(!visited[next.f]){\n        res+=next.s;\n        q.push(next.f);\n      }\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    vs.push_back(Segment(Point(a,b),Point(c,d)));\n  }\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    vp.push_back(Point(a,b));\n    st.insert(Point(a,b));\n  }\n  cin>>s.x>>s.y>>t.x>>t.y;\n  vp.push_back(s);\n  vp.push_back(t);\n  merge(vs);\n  g=SegmentArrangement(vs,vp);\n  for(int i=0;i<vp.size();i++){\n    if(st.find(vp[i])!=st.end())valve[i]=true;\n    if(vp[i]==s)c=i;\n    if(vp[i]==t)d=i;\n  }\n  dfs(d);\n  if(checked[c])cout<<-1<<endl;\n  else {\n    double ans=0.0;\n    for(int i=0;i<g.size();i++){\n      for(int j=0;j<g[i].size();j++)ans+=g[i][j].s/2.0;\n    }\n    ans-=bfs(c);\n    printf(\"%.10f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\nnamespace Geometry{\n    typedef long double D;\n    typedef complex<long double> P;\n    typedef pair<P,D> C;\n    \n    const D EPS=1e-9;\n    const D PI=asin(1)*2;\n    const D INF=1e18;\n    \n    const static bool comp(const P &p1,const P &p2){return p1.real()==p2.real()?p1.imag()<p2.imag():p1.real()<p2.real();}\n    \n    static bool comp_y(const P &p1,const P &p2){return p1.imag()==p2.imag()?p1.real()<p2.real():p1.imag()<p2.imag();}\n    \n    static bool eqls(const P &p1,const P &p2){return abs(p1-p2)<EPS;}\n    \n    D dot(P p1,P p2){return p1.real()*p2.real()+p1.imag()*p2.imag();}\n    \n    D cross(P p1,P p2){return p1.real()*p2.imag()-p1.imag()*p2.real();}\n    \n    P project(P vec,P x){return vec*(x/vec).real();}\n    \n    P project(P p1,P p2,P x){return p1+project(p2-p1,x-p1);}\n    \n    P reflect(P vec,P x){return vec*conj(x/vec);}\n    \n    P reflect(P p1,P p2,P x){return p1+reflect(p2-p1,x-p1);}\n    \n    bool intersectSL(P p1,P p2,P vec){vec/=abs(vec); p1/=vec; p2/=vec; return (p1.imag()<EPS && p2.imag()>-EPS) || (p1.imag()>-EPS && p2.imag()<EPS);}\n    \n    bool intersectSL(P p1,P p2,P p3,P p4){return intersectSL(p1-p4,p2-p4,p3-p4);}\n    \n    bool intersectSS(P p1,P p2,P p3,P p4){return (dot(p2-p1,p3-p1)<-EPS && dot(p2-p1,p4-p1)<-EPS) || (dot(p1-p2,p3-p2)<-EPS && dot(p1-p2,p4-p2)<-EPS)?false:intersectSL(p1,p2,p3,p4) && intersectSL(p3,p4,p1,p2);}\n    \n    D distLP(P vec,P x){return abs((x/vec).imag())*abs(vec);}\n    \n    D distLP(P p1,P p2,P x){return distLP(p2-p1,x-p1);}\n    \n    D distSP(P p1,P p2,P x){return dot(p2-p1,x-p1)<-EPS?abs(x-p1):dot(p1-p2,x-p2)<-EPS?abs(x-p2):distLP(p1,p2,x);}\n    \n    D distSS(P p1,P p2,P p3,P p4){return intersectSS(p1,p2,p3,p4)?0.0:min(min(distSP(p1,p2,p3),distSP(p1,p2,p4)),min(distSP(p3,p4,p1),distSP(p3,p4,p2)));}\n    \n    P crosspointLL(P p1,P p2,P vec){return abs(cross(p2-p1,vec))<EPS?vec:vec*cross(p2-p1,p2)/cross(p2-p1,vec);}\n    \n    P crosspointLL(P p1,P p2,P p3,P p4){return p4+crosspointLL(p1-p4,p2-p4,p3-p4);}\n    \n    P crosspointSS(P p1,P p2,P p3,P p4){return distSP(p1,p2,p3)<EPS?p3:distSP(p1,p2,p4)<EPS?p4:crosspointLL(p1,p2,p3,p4);}\n    \n    bool intersectShL(P p1,P p2,P vec){vec/=abs(vec); return intersectSL(p1,p2,vec) && crosspointLL(p1/vec,p2/vec,vec/vec).real()>-EPS;}\n    \n    bool intersectShL(P p1,P p2,P p3,P p4){return intersectShL(p1-p3,p2-p3,p4-p3);}\n    \n    //1::in,0::on edge,-1::out\n    int contain(const vector<P> &poly,const P &p){\n        vector<P> A={{65537,96847},{-24061,6701},{56369,-86509},{-93763,-78049},{56957,10007}};\n        vector<bool> cnt(5,false);\n        for(int i=1;i<=poly.size();i++){\n            if(distSP(poly[i-1],poly[i%poly.size()],p)<EPS){return 0;}\n            for(int j=0;j<5;j++){\n                if(intersectShL(poly[i-1],poly[i%poly.size()],p,p+A[j])){cnt[j]=!cnt[j];}\n            }\n        }\n        int in=0;\n        for(int j=0;j<5;j++){if(cnt[j]){in++;}}\n        return in>=3?1:-1;\n    }\n    \n    vector<P> convexcut(const vector<P> &poly,P p1,P p2){\n        vector<P> ret;\n        for(int i=1;i<=poly.size();i++){\n            if(cross(p2-p1,poly[i-1]-p1)>-EPS){ret.push_back(poly[i-1]);}\n            if(intersectSL(poly[i-1],poly[i%poly.size()],p1,p2) && distLP(p1,p2,poly[i-1])>EPS && distLP(p1,p2,poly[i%poly.size()])>EPS){ret.push_back(crosspointLL(poly[i-1],poly[i%poly.size()],p1,p2));}\n        }\n        return ret;\n    }\n    \n    D area(const vector<P> &poly){\n        D ans=0;\n        for(int i=2;i<poly.size();i++){ans+=cross(poly[i-1]-poly[0],poly[i]-poly[0]);}\n        return abs(ans)/2;\n    }\n    \n    vector<P> convexhull(vector<P> pts){\n        vector<P> ret;\n        sort(pts.begin(),pts.end(),comp);\n        for(auto &I:pts){\n            if(!ret.empty() && I==ret.back()){continue;}\n            while(ret.size()>=2 && cross(ret.back()-ret[ret.size()-2],I-ret.back())<-EPS){ret.pop_back();}\n            ret.push_back(I);\n        }\n        reverse(pts.begin(),pts.end());\n        for(auto &I:pts){\n            if(!ret.empty() && I==ret.back()){continue;}\n            while(ret.size()>=2 && cross(ret.back()-ret[ret.size()-2],I-ret.back())<-EPS){ret.pop_back();}\n            ret.push_back(I);\n        }\n        if(ret[0]==ret.back()){ret.pop_back();}\n        return ret;\n    }\n    \n    //4::seperate,3::circumscribe,2::intersect,1::inscribe,0::contain,-1::same\n    int intersectCC(C c1,C c2){\n        D d=abs(c1.F-c2.F),r=c1.S+c2.S,dif=abs(c2.S-c1.S);\n        if(d<EPS && dif<EPS){return -1;}\n        if(d-r>EPS){return 4;}\n        if(d-r>-EPS){return 3;}\n        if(d-dif>EPS){return 2;}\n        if(d-dif>-EPS){return 1;}\n        return 0;\n    }\n    \n    vector<P> crosspointLC(P p1,P p2,C c){\n        vector<P> ret;\n        P pr=project(p1,p2,c.F);\n        D d=distLP(p1,p2,c.F);\n        if(d-c.S>EPS){return ret;}\n        if(d-c.S>-EPS){ret.push_back(pr); return ret;}\n        P vec=p2-p1; vec*=sqrt(c.S*c.S-d*d)/abs(vec);\n        ret.push_back(pr-vec);\n        ret.push_back(pr+vec);\n        return ret;\n    }\n    \n    vector<P> crosspointSC(P p1,P p2,C c){\n        vector<P> ret;\n        for(auto &I:crosspointLC(p1,p2,c)){if(distSP(p1,p2,I)<EPS){ret.push_back(I);}}\n        return ret;\n    }\n    \n    vector<P> crosspointCC(C c1,C c2){\n        vector<P> ret;\n        P vec=c2.F-c1.F;\n        D base=(c1.S*c1.S+norm(vec)-c2.S*c2.S)/(2*abs(vec));\n        D h=sqrt(c1.S*c1.S-base*base);\n        vec/=abs(vec);\n        ret.push_back(c1.F+vec*P(base,-h));\n        ret.push_back(c1.F+vec*P(base,h));\n        return ret;\n    }\n    \n    vector<P> tangentCP(C c,P p){return crosspointCC(c,C(p,sqrt(norm(c.F-p)-c.S*c.S)));}\n    \n    vector<pair<P,P>> tangentCC(C c1,C c2){\n        vector<pair<P,P>> ret;\n        P d=c2.F-c1.F;\n        for(D i:{-1,1}){\n            D r=c1.S+c2.S*i;\n            if(intersectCC(c1,c2)>i+1){\n                for(P s:{-1i,1i}){\n                    P p=r+s*sqrt(norm(d)-norm(r));\n                    ret.push_back({c1.F+d*c1.S/norm(d)*p,c2.F-d*i*c2.S/norm(d)*p});\n                }\n            }\n        }\n        return ret;\n    }\n    \n    D area(const vector<P> &poly,C c){\n        D ret=0;\n        for(int i=0;i<poly.size();i++){\n            P a=poly[i]-c.F,b=poly[(i+1)%poly.size()]-c.F;\n            if(abs(a)<c.S+EPS && abs(b)<c.S+EPS){ret+=cross(a,b);}\n            else{\n                vector<P> A=crosspointSC(a,b,{0,c.S});\n                if(A.empty()){ret+=c.S*c.S*arg(b/a);}\n                else{\n                    ret+=(abs(a)<c.S?cross(a,A[0]):c.S*c.S*arg(A[0]/a));\n                    ret+=(abs(b)<c.S?cross(A.back(),b):c.S*c.S*arg(b/A.back()));\n                    ret+=cross(A[0],A.back());\n                }\n            }\n        }\n        return abs(ret)/2;\n    }\n    \n    //反時計回り\n    D diameter(const vector<P> &poly){\n        D ret=0;\n        ll l=0,r=0,n=poly.size();\n        if(n==2){return abs(poly[0]-poly[1]);}\n        for(int i=0;i<n;i++){\n            if(comp(poly[l],poly[i])){l=i;}\n            if(comp(poly[i],poly[r])){r=i;}\n        }\n        ll sl=r,sr=l;\n        while(sl!=l || sr!=r){\n            ret=max(ret,abs(poly[r]-poly[l]));\n            if(cross(poly[(l+1)%n]-poly[l],poly[(r+1)%n]-poly[r])<0){(++l)%=n;}\n            else{(++r)%=n;}\n        }\n        return ret;\n    }\n    \n    D closestpair(vector<P> pt){\n        sort(pt.begin(),pt.end(),comp);\n        D ret=INF;\n        for(ll i=1;i<pt.size();i<<=1){\n            for(ll j=0;i+j<pt.size();j+=i*2){\n                ll m=i+j;\n                vector<P> R;\n                D l=-INF,r=INF;\n                for(ll k=j;k<m;k++){l=max(l,pt[k].real());}\n                for(ll k=0;m+k<pt.size() && k<i;k++){r=min(r,pt[m+k].real());}\n                for(ll k=0;m+k<pt.size() && k<i;k++){if(pt[m+k].real()-l<ret){R.push_back(pt[m+k]);}}\n                ll idx=0;\n                for(ll k=j;k<m;k++){\n                    if(r-pt[k].real()>ret){continue;}\n                    while(idx<R.size() && pt[k].imag()-R[idx].imag()>ret){idx++;}\n                    for(ll n=idx;n<R.size() && R[n].imag()-pt[k].imag()<ret;n++){ret=min(ret,abs(R[n]-pt[k]));}\n                }\n                inplace_merge(pt.begin()+j,pt.begin()+m,j+i*2<pt.size()?pt.begin()+j+2*i:pt.end(),comp_y);\n            }\n        }\n        return ret;\n    }\n    \n    P centerofgravity(const vector<P> &pt){\n        P ret(0,0);\n        D wt=0;\n        for(int i=2;i<pt.size();i++){\n            D w2=cross(pt[i-1]-pt[0],pt[i]-pt[0]);\n            P p=(pt[0]+pt[i-1]+pt[i])/(D)3;\n            wt+=w2;\n            ret+=p*w2;\n        }\n        return ret/wt;\n    }\n    \n    void segment_arrangement(const vector<pair<P,P>> &L,vector<pair<int,int>> &seg,vector<P> &pt){\n        int N=(int)L.size();\n        for(int i=0;i<N;i++){\n            pt.push_back(L[i].F);\n            pt.push_back(L[i].S);\n            for(int j=i+1;j<N;j++){\n                if(intersectSS(L[i].F,L[i].S,L[j].F,L[j].S)){\n                    pt.push_back(crosspointSS(L[i].F,L[i].S,L[j].F,L[j].S));\n                }\n            }\n        }\n        auto le=[](P a,P b){return eqls(a,b)?false:comp(a,b);};\n        sort(pt.begin(),pt.end(),le);\n        pt.erase(unique(pt.begin(),pt.end(),eqls),pt.end());\n        for(auto &I:L){\n            vector<pair<D,int>> on;\n            for(int j=0;j<(int)pt.size();j++){\n                if(distSP(I.F,I.S,pt[j])<EPS){\n                    on.emplace_back(abs(pt[j]-I.F),j);\n                }\n            }\n            sort(on.begin(),on.end());\n            for(int j=1;j<(int)on.size();j++){\n                seg.emplace_back(on[j-1].S,on[j].S);\n            }\n        }\n        sort(seg.begin(),seg.end());\n        seg.erase(unique(seg.begin(),seg.end()),seg.end());\n    }\n    \n    vector<P> convex_of_segments(const vector<pair<P,P>> &L){\n        vector<pair<int,int>> seg;\n        vector<P> pt;\n        segment_arrangement(L,seg,pt);\n        vector<vector<int>> edge(pt.size());\n        for(auto &I:seg){\n            edge[I.F].push_back(I.S);\n            edge[I.S].push_back(I.F);\n        }\n        vector<P> ret;\n        function<void(int,int)> dfs=[&](int v,int pre){\n            if(pre!=-1 && v==0){return;}\n            ret.push_back(pt[v]);\n            vector<pair<D,int>> nx;\n            for(auto &u:edge[v]){\n                D a=arg((pt[u]-pt[v])/(pre==-1 || eqls(pt[v],pt[pre])?P(1):pt[v]-pt[pre]));\n                if(abs(a+PI)<EPS){a=PI;}\n                nx.emplace_back(a,u);\n            }\n            sort(nx.begin(),nx.end());\n            dfs(nx[0].S,v);\n        };\n        dfs(0,-1);\n        return ret;\n    }\n    \n    istream & operator >> (istream &i,P &p){D x,y; i>>x>>y; p={x,y}; return i;}\n    istream & operator >> (istream &i,C &p){D x,y; i>>x>>y>>p.S; p.F={x,y}; return i;}\n};\n\nusing namespace Geometry;\n\n\n\nint main(){\n    cout<<fixed<<setprecision(15);\n    ll N,M;\n    cin>>N>>M;\n    vector<pair<P,P>> A(N);\n    cin>>A;\n    vector<P> B(M);\n    cin>>B;\n    P s,t;\n    cin>>s>>t;\n    vector<P> pt=B;\n    pt.push_back(s);\n    pt.push_back(t);\n    vector<pair<int,int>> seg;\n    segment_arrangement(A,seg,pt);\n    vector<vector<int>> edge(pt.size());\n    for(auto &I:seg){\n        edge[I.F].push_back(I.S);\n        edge[I.S].push_back(I.F);\n    }\n    vector<bool> used(pt.size(),false);\n    vector<bool> closed(pt.size(),false);\n    vector<bool> bulb(pt.size(),false);\n    for(auto &I:B){\n        for(int j=0;j<pt.size();j++){\n            if(abs(I-pt[j])<EPS){bulb[j]=true;}\n        }\n    }\n    function<void(int)> dfs=[&](int v){\n        if(bulb[v]){closed[v]=true; return;}\n        for(auto &u:edge[v]){\n            if(!used[u]){\n                used[u]=true;\n                dfs(u);\n            }\n        }\n    };\n    for(int i=0;i<pt.size();i++){\n        if(abs(pt[i]-t)<EPS){dfs(i);}\n    }\n    for(int i=0;i<pt.size();i++){\n        if(abs(pt[i]-s)<EPS && used[i]){\n            cout<<-1<<endl;\n            return 0;\n        }\n    }\n    for(int i=0;i<pt.size();i++){used[i]=false;}\n    function<void(int)> dfs2=[&](int v){\n        if(closed[v]){used[v]=false; return;}\n        for(auto &u:edge[v]){\n            if(!used[u]){\n                used[u]=true;\n                dfs2(u);\n            }\n        }\n    };\n    for(int i=0;i<pt.size();i++){\n        if(abs(pt[i]-s)<EPS){used[i]=true; dfs2(i);}\n    }\n    D sum=0;\n    for(auto &I:seg){\n        if(!used[I.F] && !used[I.S]){sum+=abs(pt[I.F]-pt[I.S]);}\n    }\n    cout<<sum<<endl;\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nconst double pi  = M_PI;\nconst double inf = 1e10;\nconst double eps = 1e-10;\ntypedef complex<double> point;\n\nstruct line : public vector<point> {\n\tline(const point& a, const point& b) { push_back(a); push_back(b); }\n};\n\nnamespace std {\n\tbool operator<(const point& a, const point& b) {\n\t\tif(abs(a.real() - b.real()) > eps) return a.real() < b.real();\n\t\tif(abs(a.imag() - b.imag()) > eps) return a.imag() < b.imag();\n\t\treturn false;\n\t}\n}\n\npoint  vec  (const line&  l)                 { return l[1]-l[0]; }\ndouble dot  (const point& a, const point& b) { return (a*conj(b)).real(); }\ndouble cross(const point& a, const point& b) { return (conj(a)*b).imag(); }\n\nint ccw(const point& a, const point& b, const point& c)\n{\n\tpoint u=b-a, v=c-a;\n\tif(cross(u,v) > 0 ) return +1;\n\tif(cross(u,v) < 0 ) return -1;\n\tif(  dot(u,v) < 0 ) return +2;\n\tif(abs(u) < abs(v)) return -2;\n\treturn 0;\n}\n\nint ccw(const line& s, const point& p) {\n\treturn ccw(s[0], s[1], p);\n}\n\nbool intersectSP(const line& s, const point& p) {\n\treturn abs(s[0]-p)+abs(s[1]-p) < abs(s[1]-s[0])+eps;\n}\n\nbool intersectSS(const line& s, const line& t) {\n\treturn ccw(s,t[0])*ccw(s,t[1]) <= 0\n\t\t&& ccw(t,s[0])*ccw(t,s[1]) <= 0;\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tdouble A = cross(vec(l), vec(m));\n\tdouble B = cross(vec(l), l[1]-m[0]);\n\tif(abs(A) < eps) return m[0];\n\treturn m[0] + B/A*vec(m);\n}\n\nenum ntype{ NONE, VALVE, SOURCE, REPAIR };\n\nstruct node\n{\n\tpoint pos;\n\tntype type;\n\tvector<int> to;\n\n\tnode(const point& p, ntype t) : pos(p), type(t) {}\n};\n\nvector<node> seg_arr(const vector<line>& lines, const vector<point>& points)\n{\n\tmap<point, ntype> p;\n\tfor(int i=0; i<points.size(); i++) {\n\t\tntype type = VALVE;\n\t\tif(i == points.size()-2) { type = SOURCE; }\n\t\tif(i == points.size()-1) { type = REPAIR; }\n\n\t\tp.insert( make_pair(points[i],type) );\n\t}\n\n\tfor(int i=0; i<lines.size(); i++) {\n\t\tp.insert( make_pair(lines[i][0],NONE) );\n\t\tp.insert( make_pair(lines[i][1],NONE) );\n\t\tfor(int j=i+1; j<lines.size(); j++) {\n\t\t\tif(intersectSS(lines[i], lines[j])) {\n\t\t\t\tpoint cp = crosspoint(lines[i], lines[j]);\n\t\t\t\tp.insert( make_pair(cp,NONE) );\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<node> graph;\n\tfor(map<point,ntype>::iterator it=p.begin(); it!=p.end(); it++) {\n\t\tgraph.push_back( node(it->first,it->second) );\n\t}\n\n\tfor(int i=0; i<lines.size(); i++) {\n\t\tvector<pair<double,int> > online;\n\t\tfor(int j=0; j<graph.size(); j++) {\n\t\t\tif(intersectSP(lines[i], graph[j].pos)) {\n\t\t\t\tonline.push_back( pair<double,int>(abs(lines[i][0]-graph[j].pos), j) );\n\t\t\t}\n\t\t}\n\n\t\tsort(online.begin(), online.end());\n\t\tfor(int j=1; j<online.size(); j++) {\n\t\t\tint a = online[j-1].second;\n\t\t\tint b = online[j  ].second;\n\t\t\tgraph[a].to.push_back(b);\n\t\t\tgraph[b].to.push_back(a);\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nint main()\n{\n\tint N,M;\n\tcin >> N >> M;\n\n\tvector<line>  lines;\n\tvector<point> points;\n\n\tint x1,y1,x2,y2;\n\tfor(int i=0; i<N; i++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tlines.push_back( line(point(x1,y1), point(x2,y2)) );\n\t}\n\tfor(int i=0; i<M+2; i++) {\n\t\tcin >> x1 >> y1;\n\t\tpoints.push_back( point(x1,y1) );\n\t}\n\n\tint source,repair;\n\tvector<node> graph = seg_arr(lines,points);\n\tfor(int i=0; i<graph.size(); i++) {\n\t\tif(graph[i].type == SOURCE) { source = i; }\n\t\tif(graph[i].type == REPAIR) { repair = i; }\n\t}\n\n\n/*\n\tprintf(\"%d -> %d\\n\", source, repair);\n\tfor(int i=0; i<graph.size(); i++) {\n\t\tprintf(\"%2i : (%3lf,%3lf)\\t%d [ \", i, graph[i].pos.real(), graph[i].pos.imag(), graph[i].type);\n\t\tfor(int j=0; j<graph[i].to.size(); j++) {\n\t\t\tprintf(\"%2d \", graph[i].to[j]);\n\t\t}\n\t\tprintf(\"]\\n\");\n\t}\n*/\n\n\tvector<bool> v(graph.size(), 0);\n\n\tqueue<int> q;\n\tq.push(repair);\n\tv[repair] = 1;\n\twhile(!q.empty())\n\t{\n\t\tint t=q.front(); q.pop();\n\n\t\tif(graph[t].type == VALVE) continue;\n\t\tif(graph[t].type == SOURCE) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor(int i=0; i<graph[t].to.size(); i++) {\n\t\t\tint s = graph[t].to[i];\n\t\t\tif(v[s]) continue;\n\t\t\tv[s] = 1;\n\t\t\tq.push(s);\n\t\t}\n\t}\n\n\tdouble wl = 0;\n\tset<pair<int,int> > ve;\n\tq.push(source);\n\tv[source] = 1;\n\twhile(!q.empty())\n\t{\n\t\tint t=q.front(); q.pop();\n\n\t\tfor(int i=0; i<graph[t].to.size(); i++) {\n\t\t\tint s = graph[t].to[i];\n\n\t\t\tif(ve.insert(make_pair(min(t,s),max(t,s))).second) {\n\t\t\t\twl += abs(graph[t].pos - graph[s].pos);\n\t\t\t}\n\n\t\t\tif(v[s]) continue;\n\t\t\tv[s] = 1;\n\t\t\tq.push(s);\n\t\t}\n\t}\n\n\n\tdouble al = 0;\n\tve.clear();\n\tfor(int i=0; i<graph.size(); i++)\n\tfor(int j=0; j<graph[i].to.size(); j++) {\n\t\tint t=i, s=graph[i].to[j];\n\t\tif(ve.insert(make_pair(min(t,s),max(t,s))).second) {\n\t\t\tal += abs(graph[t].pos - graph[s].pos);\n\t\t}\n\t}\n\tprintf(\"%.9lf\\n\", al-wl);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\ntypedef double Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight != rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid PrintMatrix(const Matrix &matrix) {\n  for (int y = 0; y < (int)matrix.size(); y++) {\n    for (int x = 0; x < (int)matrix[y].size(); x++) {\n      printf(\"%.2lf \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\n#include <complex>\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nstatic const double INF = 1e+10;\n\n#define CURR(P, i) (P[i])\n#define NEXT(P, i) (P[(i + 1) % P.size()])\n\nstruct Line : public vector<Point> {\n  Line() {;}\n  Line(Point a, Point b) { push_back(a); push_back(b); }\n};\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (fabs(lhs.real() - rhs.real()) < EPS * 10 &&\n        fabs(lhs.imag() - rhs.imag()) < EPS * 10) { return false; }\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n  }\n}\n\ninline double cross(const Point &a, const Point &b) {\n  return imag(conj(a) * b);\n}\n\ninline double dot(const Point &a, const Point &b) {\n  return real(conj(a) * b);\n}\n\ninline int ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) { return 1; }\n  if (cross(b, c) < 0) { return -1; }\n  if (dot(b, c) < 0) { return 2; }\n  if (norm(b) < norm(c)) { return -2; }\n  return 0;\n}\n\n\nbool intersectLL(const Line &l, const Line &m) {\n  return abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n    abs(cross(l[1] - l[0], m[0] - l[0])) < EPS;\n}\n\nbool intersectLS(const Line &l, const Line &s) {\n  return cross(l[1] - l[0], s[0] - l[0]) *\n    cross(l[1] - l[0], s[1] - l[0]) < EPS;\n}\n\nbool intersectLP(const Line &l, const Point &p) {\n  return abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool intersectSP(const Line &s, const Point &p) {\n  return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n}\n\nPoint crosspointSS(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) {\n    //assert(false);\n    if (intersectSP(l, m[0])) { return m[0]; }\n    if (intersectSP(l, m[1])) { return m[1]; }\n    if (intersectSP(m, l[0])) { return l[0]; }\n    if (intersectSP(m, l[1])) { return l[1]; }\n    return m[0];\n  }\n  if (abs(A) < EPS) { assert(false); }\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble Area(const Polygon &p) {\n  double ret = 0;\n  for (int i = 0; i < (int)p.size(); i++) {\n    ret += cross(CURR(p, i), NEXT(p, i));\n  }\n  //cout << ret / 2.0 << endl;\n  assert(ret > -EPS);\n  return ret / 2.0;\n}\n\n\nstruct ArrangmentEdge {\n  int src;\n  int dest;\n  Weight weight;\n  ArrangmentEdge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const ArrangmentEdge &rhs) const {\n    return dest < rhs.dest;\n  }\n};\nstruct ArrangmentData {\n  vector<Point> ps;\n  map<Point, int> mapto;\n  Graph g;\n};\nArrangmentData Arrangment(const vector<Line> &ls, const vector<Point> &ps) {\n  {\n    // TODO Check\n    // Set Weight double check\n    Weight w = 0.5;\n    assert(w == 0.5);\n  }\n\n  int l = ls.size();\n  int n = 0;\n  ArrangmentData ret;\n  for (int i = 0; i < l; i++) {\n    REP(j, 2) {\n      if (ret.mapto.count(ls[i][j])) { continue; }\n      ret.ps.push_back(ls[i][j]);\n      ret.mapto[ls[i][j]] = n++;\n    }\n  }\n  for (int i = 0; i < (int)ps.size(); i++) {\n    if (ret.mapto.count(ps[i])) { continue; }\n    ret.ps.push_back(ps[i]);\n    ret.mapto[ps[i]] = n++;\n  }\n\n  for (int i = 0; i < l; i++) {\n    for (int j = i + 1; j < l; j++) {\n      Line s1 = ls[i];\n      Line s2 = ls[j];\n      if (intersectSS(s1, s2)) {\n        Point p = crosspointSS(s1, s2);\n        if (ret.mapto.count(p)) { continue; }\n        ret.ps.push_back(p);\n        ret.mapto[p] = n++;\n      }\n    }\n  }\n  vector<set<ArrangmentEdge> > tempG(n);\n  for (int i = 0; i < l; i++) {\n    Line s = ls[i];\n    vector<pair<double, int> > onLine;\n    for (int j = 0; j < n; j++) {\n      if (intersectSP(s, ret.ps[j])) {\n        onLine.push_back(make_pair(abs(ret.ps[j] - s[0]), j));\n      }\n    }\n    sort(onLine.begin(), onLine.end());\n    for (int j = 0; j < (int)onLine.size() - 1; j++) {\n      int from = onLine[j].second;\n      int to = onLine[j + 1].second;\n      double dist = fabs(onLine[j].first - onLine[j + 1].first);\n      tempG[from].insert(ArrangmentEdge(from, to, dist));\n      tempG[to].insert(ArrangmentEdge(to, from, dist));\n      //cout << from << \" \" << to << \" \" << ret.ps[from] << \" \" << ret.ps[to] << endl;\n    }\n  }\n  ret.g = Graph(n);\n  for (int i = 0; i < n; i++) {\n    for (set<ArrangmentEdge>::iterator it = tempG[i].begin(); it != tempG[i].end(); it++) {\n      ret.g[i].push_back(Edge(it->src, it->dest, it->weight));\n    }\n  }\n  return ret;\n}\n\n//============================================================\n\nint n, m;\nvector<Line> ls;\nvector<Point> stop;\nGraph g;\nbool isstop[200000];\nbool visited[2][200000];\n\ndouble Bfs(int start, int state) {\n  double ret = 0.0;\n  queue<int> que;\n  que.push(start);\n  while (!que.empty()) {\n    int from = que.front();\n    que.pop();\n    if (visited[state][from]) { continue; }\n    if (state == 1 && visited[0][from]) { continue; }\n    visited[state][from] = true;\n    if (state == 0 && isstop[from]) { continue; }\n    //cout << start << \" \" << from << endl;\n    FORIT(it, g[from]) {\n      int to = it->dest;\n      if (visited[state][to]) { continue; }\n      //cout << from << \" \" << to << \" \" << state << endl;\n      ret += it->weight;\n      que.push(to);\n    }\n  }\n  return ret;\n}\n\n\nint main() {\n  while (scanf(\"%d %d\", &n, &m) > 0) {\n    MEMSET(isstop, false);\n    MEMSET(visited, false);\n    Point start;\n    Point end;\n    // Init & Input\n    ls = vector<Line>(n);\n    stop = vector<Point>(m);\n    REP(i, n) {\n      double x1, y1, x2, y2;\n      scanf(\"%lf %lf %lf %lf\", &x1, &y1, &x2, &y2);\n      ls[i] = Line(Point(x1, y1), Point(x2, y2));\n    }\n    REP(i, m) {\n      double x, y;\n      scanf(\"%lf %lf\", &x, &y);\n      stop[i] = Point(x, y);\n    }\n    {\n      double x1, y1, x2, y2;\n      scanf(\"%lf %lf %lf %lf\", &x1, &y1, &x2, &y2);\n      start = Point(x1, y1);\n      end = Point(x2, y2);\n    }\n    stop.push_back(start);\n    stop.push_back(end);\n    ArrangmentData data = Arrangment(ls, stop);\n    stop.pop_back();\n    stop.pop_back();\n    g = data.g;\n    int s = data.mapto[start];\n    int t = data.mapto[end];\n    isstop[s] = true;\n    FORIT(it, stop) {\n      isstop[data.mapto[*it]] = true;\n    }\n    double ans = 0.0;\n    REP(i, g.size()) {\n      FORIT(it, g[i]) {\n        ans += it->weight / 2.0;\n      }\n    }\n    Bfs(t, 0);\n    if (visited[0][s]) {\n      puts(\"-1\");\n      continue;\n    }\n    ans -= Bfs(s, 1);\n    printf(\"%.8f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <algorithm>\n\nclass point2d {\npublic:\n\tdouble x, y;\n\tpoint2d() : x(0), y(0) {};\n\tpoint2d(double x_, double y_) : x(x_), y(y_) {};\n\tbool operator==(const point2d& p) { return x == p.x && y == p.y; }\n\tbool operator!=(const point2d& p) { return x != p.x || y != p.y; }\n\tpoint2d& operator+=(const point2d& p) { x += p.x; y += p.y; return *this; }\n\tpoint2d& operator-=(const point2d& p) { x -= p.x; y -= p.y; return *this; }\n\tpoint2d& operator*=(const double v) { x *= v; y *= v; return *this; }\n\tpoint2d operator+(const point2d& p) const { return point2d(*this) += p; }\n\tpoint2d operator-(const point2d& p) const { return point2d(*this) -= p; }\n\tpoint2d operator*(const double v) const { return point2d(*this) *= v; }\n\tdouble norm() const { return x * x + y * y; }\n\tdouble abs() const { return std::sqrt(x * x + y * y); }\n\tdouble dot(const point2d& p) const { return x * p.x + y * p.y; }\n\tdouble cross(const point2d& p) const { return x * p.y - y * p.x; }\n\tint ccw(const point2d& p1, const point2d& p2) const {\n\t\t// RETURNS: P0 -> P1 -> P2 IS COLLINEAR --> ((P0, P1, P2) IS CENTER --> (2, -2, 0)), COUNTER-CLOCKWISE --> 1, CLOCKWISE --> -1\n\t\tpoint2d pr1 = p1 - point2d(*this);\n\t\tpoint2d pr2 = p2 - point2d(*this);\n\t\tif (pr1.cross(pr2) != 0) return pr1.cross(pr2) > 0 ? 1 : -1;\n\t\tif (pr1.dot(pr2) < 0) return 2;\n\t\treturn pr1.norm() < pr2.norm() ? -2 : 0;\n\t}\n};\nclass segment2d {\npublic:\n\tpoint2d p1, p2;\n\tsegment2d() : p1(point2d()), p2(point2d()) {};\n\tsegment2d(const point2d& p1_, const point2d& p2_) : p1(p1_), p2(p2_) {};\n\tdouble norm() const { return (p1 - p2).norm(); }\n\tdouble abs() const { return (p1 - p2).abs(); }\n};\n\nbool intersect(const segment2d& s1, const segment2d& s2) {\n\treturn s1.p1.ccw(s1.p2, s2.p1) * s1.p1.ccw(s1.p2, s2.p2) <= 0 && s2.p1.ccw(s2.p2, s1.p1) * s2.p1.ccw(s2.p2, s1.p2) <= 0;\n}\npoint2d intersect_point(const segment2d& s1, const segment2d& s2) {\n\tpoint2d base = s2.p2 - s2.p1;\n\tdouble d1 = std::abs(base.cross(s1.p1 - s2.p1));\n\tdouble d2 = std::abs(base.cross(s1.p2 - s2.p1));\n\treturn s1.p1 + (s1.p2 - s1.p1) * (d1 / (d1 + d2));\n}\ndouble distance(const point2d& p, const segment2d& s) {\n\tdouble d1 = (p - s.p1).norm();\n\tdouble d2 = (p - s.p2).norm();\n\tdouble d0 = s.norm();\n\tif (d0 + d1 < d2 || d0 + d2 < d1) return std::sqrt(std::min(d1, d2));\n\treturn std::abs((p - s.p1).cross(s.p2 - s.p1)) / std::sqrt(d0);\n}\n\n#include <queue>\n#include <iostream>\n#include <functional>\nusing namespace std;\nstruct edge {\n\tint to, id;\n};\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<segment2d> seg(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> seg[i].p1.x >> seg[i].p1.y >> seg[i].p2.x >> seg[i].p2.y;\n\t}\n\tvector<point2d> valve(M);\n\tfor (int i = 0; i < M; ++i) {\n\t\tcin >> valve[i].x >> valve[i].y;\n\t}\n\tpoint2d src, dst;\n\tcin >> src.x >> src.y >> dst.x >> dst.y;\n\tvector<vector<int> > cardinals(N);\n\tvector<point2d> pts;\n\tvector<int> ptstype;\n\tfunction<int(point2d)> next_ptr = [&](point2d p) {\n\t\tfor (int i = 0; i < pts.size(); ++i) {\n\t\t\tif ((p - pts[i]).abs() < 1.0e-8) return i;\n\t\t}\n\t\treturn int(pts.size());\n\t};\n\tfor (int i = 0; i < N; ++i) {\n\t\tint p1ptr = next_ptr(seg[i].p1);\n\t\tif (p1ptr == pts.size()) pts.push_back(seg[i].p1), ptstype.push_back(0);\n\t\tcardinals[i].push_back(p1ptr);\n\t\tptstype[p1ptr] |= 1;\n\t\tint p2ptr = next_ptr(seg[i].p2);\n\t\tif (p2ptr == pts.size()) pts.push_back(seg[i].p2), ptstype.push_back(0);\n\t\tcardinals[i].push_back(p2ptr);\n\t\tptstype[p1ptr] |= 1;\n\t}\n\tfor (int i = 0; i < M; ++i) {\n\t\tint ptr = next_ptr(valve[i]);\n\t\tif (ptr == pts.size()) pts.push_back(valve[i]), ptstype.push_back(0);\n\t\tptstype[ptr] |= 2;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (distance(valve[i], seg[j]) < 1.0e-8) {\n\t\t\t\tcardinals[j].push_back(ptr);\n\t\t\t}\n\t\t}\n\t}\n\tint srcptr = next_ptr(src);\n\tif (srcptr == pts.size()) pts.push_back(src), ptstype.push_back(0);\n\tptstype[srcptr] |= 4;\n\tint dstptr = next_ptr(dst);\n\tif (dstptr == pts.size()) pts.push_back(dst), ptstype.push_back(0);\n\tptstype[dstptr] |= 8;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (distance(src, seg[i]) < 1.0e-8) {\n\t\t\tcardinals[i].push_back(srcptr);\n\t\t}\n\t\tif (distance(dst, seg[i]) < 1.0e-8) {\n\t\t\tcardinals[i].push_back(dstptr);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = i + 1; j < N; ++j) {\n\t\t\tif (intersect(seg[i], seg[j])) {\n\t\t\t\tpoint2d crp = intersect_point(seg[i], seg[j]);\n\t\t\t\tint ptr = next_ptr(crp);\n\t\t\t\tif (ptr == pts.size()) pts.push_back(crp), ptstype.push_back(0);\n\t\t\t\tptstype[ptr] |= 16;\n\t\t\t\tcardinals[i].push_back(ptr);\n\t\t\t\tcardinals[j].push_back(ptr);\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<edge> > G(pts.size());\n\tint cnt = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tsort(cardinals[i].begin(), cardinals[i].end(), [&](int j, int k) { return abs(pts[j].x - pts[k].x) > 1.0e-8 ? pts[j].x < pts[k].x : pts[j].y < pts[k].y; });\n\t\tcardinals[i].erase(unique(cardinals[i].begin(), cardinals[i].end()), cardinals[i].end());\n\t\tfor (int j = 1; j < cardinals[i].size(); ++j) {\n\t\t\tG[cardinals[i][j]].push_back(edge{ cardinals[i][j - 1], cnt });\n\t\t\tG[cardinals[i][j - 1]].push_back(edge{ cardinals[i][j], cnt });\n\t\t\t++cnt;\n\t\t}\n\t}\n\tqueue<int> que;\n\tque.push(dstptr);\n\tvector<bool> used(pts.size());\n\tused[dstptr] = true;\n\twhile (!que.empty()) {\n\t\tint u = que.front(); que.pop();\n\t\tif (ptstype[u] & 2) continue;\n\t\tfor (edge &e : G[u]) {\n\t\t\tif (!used[e.to]) {\n\t\t\t\tused[e.to] = true;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\tvector<bool> pass(pts.size());\n\tvector<bool> usededge(cnt);\n\tque.push(srcptr);\n\tpass[srcptr] = true;\n\twhile (!que.empty()) {\n\t\tint u = que.front(); que.pop();\n\t\tif ((ptstype[u] & 2) && used[u]) continue;\n\t\tfor (edge& e : G[u]) {\n\t\t\tusededge[e.id] = true;\n\t\t\tif (!pass[e.to]) {\n\t\t\t\tpass[e.to] = true;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\tif (pass[dstptr]) cout << -1 << endl;\n\telse {\n\t\tdouble sum = 0.0;\n\t\tfor (int i = 0; i < pts.size(); ++i) {\n\t\t\tfor (edge e : G[i]) {\n\t\t\t\tif (!usededge[e.id]) {\n\t\t\t\t\tsum += (pts[i] - pts[e.to]).abs();\n\t\t\t\t\tusededge[e.id] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout.precision(15);\n\t\tcout << fixed << sum << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-9;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a,b;\n\toperator line<T>()const{ return (line<T>){a,b}; }\n};\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<double> &S,const point<double> &p){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\n// 追加で頂点集合を指定できるように書き換え\nvoid arrangement(const vector< segment<double> > &S,const vector< point<double> > &plus,vector< point<double> > &P,vector<int> *G){\n\tint n=S.size();\n\tP=plus;\n\trep(i,n){\n\t\tP.push_back(S[i].a);\n\t\tP.push_back(S[i].b);\n\t\trep(j,i) if(intersect(S[i],S[j])) P.push_back(get_intersect(S[i],S[j]));\n\t}\n\tsort(P.begin(),P.end());\n\tP.erase(unique(P.begin(),P.end()),P.end());\n\n\trep(i,n){\n\t\tvector<int> on;\n\t\trep(u,P.size()) if(cover(S[i],P[u])) on.push_back(u);\n\t\trep(j,(int)on.size()-1){\n\t\t\tint u=on[j],v=on[j+1];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tvector< segment<double> > pipe(n);\n\trep(i,n) scanf(\"%lf%lf%lf%lf\",&pipe[i].a.x,&pipe[i].a.y,&pipe[i].b.x,&pipe[i].b.y);\n\tvector< point<double> > stop(m);\n\trep(i,m) scanf(\"%lf%lf\",&stop[i].x,&stop[i].y);\n\tpoint<double> s,t;\n\tscanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&t.x,&t.y);\n\n\t// 追加の頂点集合\n\tvector< point<double> > plus=stop;\n\tplus.push_back(s);\n\tplus.push_back(t);\n\n\tvector< point<double> > P;\n\tstatic vector<int> G[100000];\n\tarrangement(pipe,plus,P,G);\n\n\tint N=P.size();\n\tstatic bool isstop[100000];\n\trep(i,m) rep(j,N) if(P[j]==stop[i]) isstop[j]=true;\n\n\tint s_id=find(P.begin(),P.end(),s)-P.begin();\n\tint t_id=find(P.begin(),P.end(),t)-P.begin();\n\n\t// t から stop をまたがずに行ける場所を見つける\n\tstatic bool vis[100000];\n\tvis[t_id]=true;\n\tqueue<int> Q; Q.push(t_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=true;\n\t\t\t\tif(!isstop[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(vis[s_id]){ puts(\"-1\"); return 0; }\n\n\t// s から vis を通らずに行ける場所を見つける\n\tstatic bool vis2[100000];\n\tvis2[s_id]=true;\n\tQ.push(s_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v]=true;\n\t\t\t\tif(!vis[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans=0;\n\trep(i,n) ans+=dist(pipe[i].a,pipe[i].b);\n\trep(u,N) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tif(u<v && vis2[u] && vis2[v]) ans-=dist(P[u],P[v]);\n\t}\n\tprintf(\"%.9f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef complex<double> V;\ntypedef vector<P> vecP;\ntypedef pair<P,P> L;\ntypedef pair<P,P> S;\ntypedef pair<P,double> C;\nconst double eps=1e-8;\nconst double PI=acos(-1);\nconst double PI2=PI*2.0;\n \nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.real()!=b.real()?\n            a.real() <b.real():\n            a.imag() <b.imag());\n  }\n};\n \nV normal(V a){\n  assert( abs(a)>0 );\n  return a/abs(a);\n}\n \ndouble Sqrt( double x ){\n  if(x<0)return 0;\n  else return sqrt(x);\n}\n \nP Vector(L a){\n  return a.second-a.first;\n}\n \nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n \nbool eq(P a,P b){\n  return ( eq(a.real(),b.real()) && eq(a.imag(),b.imag()) );\n}\n \ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n \ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n \ndouble getArg(P a,P b){\n  return arg(b*conj(a));\n}\n \ndouble getTime(V a,V b){\n  assert( eq(cross(a,b),0) );\n  return ( dot(a,b) < 0 ? -1.0 : 1.0 ) * abs(b) / abs(a);\n}\n \n \nP project(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*real(c/b);\n}\n \nP reflect(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*conj(c/b);\n}\n \nint ccw(P a,P b,P c){\n  P ab=b-a,ac=c-a;\n  P k=ac*conj(ab);\n  if(k.imag()>0)return 1;\n  if(k.imag()<0)return -1;\n  if(k.real()<0)return 2;\n  if(abs(ab)<abs(ac))return -2;\n  return 0;\n}\n \nbool isParallel(P a,P b){\n  return eq(0, cross(a,b));\n}\n \nbool isParallel(S a,S b){\n  return eq(0, cross( Vector(a) , Vector(b) ) );\n}\n \nbool onLP(L l,P p){\n  P a=l.first, b=l.second;\n  return eq(0, cross(b-a,p-a));\n}\n \nbool onSP(S s,P p){\n  P a=s.first, b=s.second;\n  return eq( abs(b-a) , abs(a-p)+abs(b-p) );\n}\n \nbool isCrossSS(S s0,S s1){\n  P a=s0.first, b=s0.second;\n  P c=s1.first, d=s1.second;\n  int f0 = ccw(a,b,c) * ccw(a,b,d);\n  int f1 = ccw(c,d,a) * ccw(c,d,b);\n  return (f0<=0 && f1<=0);\n}\n \nbool isCrossLS(L l,S s){\n  P a=l.first, b=l.second;\n  P c=s.first, d=s.second;\n  return ( ccw(a,b,c) * ccw(a,b,d) <= 0 );\n}\n \ndouble distLP(L l,P p){\n  P a=l.first, b=l.second;\n  double res = cross(b-a,p-a) / abs(b-a);\n  return abs(res);\n}\n \ndouble distSP(S s,P p){\n  P a=s.first, b=s.second;\n  if( dot(b-a,p-a) < eps )return abs(p-a);\n  if( dot(a-b,p-b) < eps )return abs(p-b);\n  return distLP(s,p);\n}\n \ndouble distSS(S s0,S s1){\n  if( isCrossSS(s0,s1) )return 0;\n  double res0 = min( distSP( s0, s1.first ) , distSP(s0, s1.second) );\n  double res1 = min( distSP( s1, s0.first ) , distSP(s1, s0.second) );\n  return min(res0,res1);\n}\n \nP getCrossLL(L l0,L l1){\n  P a=l0.first, b=l0.second;\n  P c=l1.first, d=l1.second;\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n \n \n  \nint inPolygon(vecP &t,P p){\n  int n=t.size();\n  double sum=0;\n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p)==0 )return 1;\n    sum+= getArg(a-p,b-p);\n  }\n  if( abs(sum) < eps )return 0;\n  else return 2;\n}\n\n\nstruct edge{\n  int to;\n  double cost;\n};\n\ntypedef vector<edge> Node;\ntypedef vector<Node> Graph;\nGraph G;\nmap<int,bool> isB;\nvector< P > points;\n\nvoid segments2graph( vector<S> segments ,vector<P> b ){\n\n  int n=segments.size();\n\n  sort(b.begin(),b.end());\n  \n  for(int i=0;i<(int)b.size();i++){\n    points.push_back(b[i]);\n  }\n  \n  for(int i=0;i<n;i++){\n    S si=segments[i];\n    points.push_back( si.first );\n    points.push_back( si.second );\n    for(int j=0;j<i;j++){\n      S sj=segments[j];\n      if( isCrossSS( si , sj ) && !isParallel( si, sj ) ){\n        points.push_back( getCrossLL(si,sj) );\n      }\n    }\n  }\n \n  sort(points.begin(), points.end());\n  points.erase( unique( points.begin(), points.end() ) , points.end() );\n   \n  G.resize(points.size());\n  \n  for(int i=0;i<(int)points.size();i++){\n    P p=points[i];\n    isB[i] = binary_search(b.begin(),b.end(), p);\n  }\n  \n  typedef pair< double , int > Pair;\n     \n  for(int i=0;i<n;i++){\n    S si=segments[i];\n    P sf=si.first, se=si.second;\n    vector< Pair > targets;\n    for(int j=0;j<(int)points.size();j++){\n      P pj=points[j];\n      // if( ccw( si.first, si.second, pj ) == 0 ){\n      if( onSP( si, pj ) ){\n        targets.push_back( Pair(getTime(se-sf ,pj-sf ), j ) );\n      }\n    }\n\n    for(int j=0;j<(int)targets.size();j++){\n      for(int k=0;k<j;k++){\n        Pair a=targets[j];\n        Pair b=targets[k];\n        P ap=points[ a.second ];\n        P bp=points[ b.second ];\n        G[a.second].push_back( (edge){ b.second , abs(ap-bp) } );\n        G[b.second].push_back( (edge){ a.second , abs(bp-ap) } );\n      }\n    }\n\n    /* \n    sort( targets.begin(), targets.end() );\n    for(int j=0;j+1<(int)targets.size();j++){\n      Pair a=targets[j];\n      Pair b=targets[j+1];\n      P ap=points[ a.second ];\n      P bp=points[ b.second ];\n      \n      G[a.second].push_back( (edge){ b.second , abs(ap-bp) } );\n      G[b.second].push_back( (edge){ a.second , abs(bp-ap) } );\n    }\n    */\n    \n  }\n\n}\n\nP input(){\n  double x,y;\n  cin>>x>>y;\n  return P(x,y);\n}\n\n\nmap<int,bool> visited;\ndouble total=0;\n\nmap< P , bool > counted;\n\nvoid dfs(int pos){\n  \n  if( isB[pos] )return;\n  if(visited[pos])return;\n  visited[pos]=true;\n  \n  for(int i=0;i<(int)G[pos].size();i++){\n    edge e=G[pos][i];\n    if( visited[e.to] || isB[e.to] )total+=e.cost;\n    else total += e.cost/2.0;\n  }\n  \n  for(int i=0;i<(int)G[pos].size();i++){\n    edge e=G[pos][i];\n    dfs(e.to);\n  }\n}\n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  vector< S > segments;\n  vector< P > bs;\n\n  double ans = 0;\n  \n  for(int i=0;i<N;i++){\n    P a=input();\n    P b=input();\n    segments.push_back( S(a,b) );\n    ans+= abs(a-b);\n  }\n  \n  for(int i=0;i<M;i++){\n    P a=input();\n    bs.push_back( b );\n  }\n  \n  P si,ti;\n  si=input();\n  ti=input();\n  points.push_back(si);\n  points.push_back(ti);\n  \n  segments2graph(segments,bs);\n\n  \n  int ex = lower_bound( points.begin(), points.end() , si ) - points.begin();\n  int root = lower_bound( points.begin(), points.end() , ti ) - points.begin();\n  \n  dfs(root);\n  \n  if( visited[ex] ){\n    cout<<\"-1\"<<endl;\n    return 0;\n  }\n  \n  total = 0;\n  dfs( ex );\n  printf(\"%.10f\\n\",ans-total);\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nconst double pi  = M_PI;\nconst double inf = 1e10;\nconst double eps = 1e-10;\ntypedef complex<double> point;\n\nstruct line : public vector<point> {\n\tline(const point& a, const point& b) { push_back(a); push_back(b); }\n};\n\nnamespace std {\n\tbool operator<(const point& a, const point& b) {\n\t\tif(abs(a.real() - b.real()) > eps) return a.real() < b.real();\n\t\tif(abs(a.imag() - b.imag()) > eps) return a.imag() < b.imag();\n\t\treturn false;\n\t}\n}\n\npoint  vec  (const line&  l)                 { return l[1]-l[0]; }\ndouble dot  (const point& a, const point& b) { return (a*conj(b)).real(); }\ndouble cross(const point& a, const point& b) { return (conj(a)*b).imag(); }\n\nint ccw(const point& a, const point& b, const point& c)\n{\n\tpoint u=b-a, v=c-a;\n\tif(cross(u,v) > 0 ) return +1;\n\tif(cross(u,v) < 0 ) return -1;\n\tif(  dot(u,v) < 0 ) return +2;\n\tif(abs(u) < abs(v)) return -2;\n\treturn 0;\n}\n\nint ccw(const line& s, const point& p) {\n\treturn ccw(s[0], s[1], p);\n}\n\nbool intersectSP(const line& s, const point& p) {\n\treturn abs(s[0]-p)+abs(s[1]-p) < abs(s[1]-s[0])+eps;\n}\n\nbool intersectSS(const line& s, const line& t) {\n\treturn ccw(s,t[0])*ccw(s,t[1]) <= 0\n\t\t&& ccw(t,s[0])*ccw(t,s[1]) <= 0;\n}\n\npoint crosspoint(const line& l, const line& m) {\n\tdouble A = cross(vec(l), vec(m));\n\tdouble B = cross(vec(l), l[1]-m[0]);\n\tif(abs(A) < eps) return m[0];\n\treturn m[0] + B/A*vec(m);\n}\n\nenum ntype{ NONE, VALVE, SOURCE, REPAIR };\n\nstruct node\n{\n\tpoint pos;\n\tntype type;\n\tvector<int> to;\n\n\tnode(const point& p, ntype t) : pos(p), type(t) {}\n};\n\nvector<node> seg_arr(const vector<line>& lines, const vector<point>& points)\n{\n\tmap<point, ntype> p;\n\tfor(int i=0; i<points.size(); i++) {\n\t\tntype type = VALVE;\n\t\tif(i == points.size()-2) { type = SOURCE; }\n\t\tif(i == points.size()-1) { type = REPAIR; }\n\n\t\tp.insert( make_pair(points[i],type) );\n\t}\n\n\tfor(int i=0; i<lines.size(); i++) {\n\t\tp.insert( make_pair(lines[i][0],NONE) );\n\t\tp.insert( make_pair(lines[i][1],NONE) );\n\t\tfor(int j=i+1; j<lines.size(); j++) {\n\t\t\tif(intersectSS(lines[i], lines[j])) {\n\t\t\t\tpoint cp = crosspoint(lines[i], lines[j]);\n\t\t\t\tp.insert( make_pair(cp,NONE) );\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<node> graph;\n\tfor(map<point,ntype>::iterator it=p.begin(); it!=p.end(); it++) {\n\t\tgraph.push_back( node(it->first,it->second) );\n\t}\n\n\tfor(int i=0; i<lines.size(); i++) {\n\t\tvector<pair<double,int> > online;\n\t\tfor(int j=0; j<graph.size(); j++) {\n\t\t\tif(intersectSP(lines[i], graph[j].pos)) {\n\t\t\t\tonline.push_back( pair<double,int>(abs(lines[i][0]-graph[j].pos), j) );\n\t\t\t}\n\t\t}\n\n\t\tsort(online.begin(), online.end());\n\t\tfor(int j=1; j<online.size(); j++) {\n\t\t\tint a = online[j-1].second;\n\t\t\tint b = online[j  ].second;\n\t\t\tgraph[a].to.push_back(b);\n\t\t\tgraph[b].to.push_back(a);\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nint main()\n{\n\tint N,M;\n\tcin >> N >> M;\n\n\tvector<line>  lines;\n\tvector<point> points;\n\n\tint x1,y1,x2,y2;\n\tfor(int i=0; i<N; i++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tlines.push_back( line(point(x1,y1), point(x2,y2)) );\n\t}\n\tfor(int i=0; i<M+2; i++) {\n\t\tcin >> x1 >> y1;\n\t\tpoints.push_back( point(x1,y1) );\n\t}\n\n\tint source,repair;\n\tvector<node> graph = seg_arr(lines,points);\n\tfor(int i=0; i<graph.size(); i++) {\n\t\tif(graph[i].type == SOURCE) { source = i; }\n\t\tif(graph[i].type == REPAIR) { repair = i; }\n\t}\n\n\n/*\n\tprintf(\"%d -> %d\\n\", source, repair);\n\tfor(int i=0; i<graph.size(); i++) {\n\t\tprintf(\"%2i : (%3lf,%3lf)\\t%d [ \", i, graph[i].pos.real(), graph[i].pos.imag(), graph[i].type);\n\t\tfor(int j=0; j<graph[i].to.size(); j++) {\n\t\t\tprintf(\"%2d \", graph[i].to[j]);\n\t\t}\n\t\tprintf(\"]\\n\");\n\t}\n*/\n\n\tvector<bool> v(graph.size(), 0);\n\n\tqueue<int> q;\n\tq.push(repair);\n\tv[repair] = 1;\n\twhile(!q.empty())\n\t{\n\t\tint t=q.front(); q.pop();\n\n\t\tif(graph[t].type == VALVE) continue;\n\t\tif(graph[t].type == SOURCE) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor(int i=0; i<graph[t].to.size(); i++) {\n\t\t\tint s = graph[t].to[i];\n\t\t\tif(v[s]) continue;\n\t\t\tv[s] = 1;\n\t\t\tq.push(s);\n\t\t}\n\t}\n\n\tdouble wl = 0;\n\tset<pair<int,int> > ve;\n\tq.push(source);\n\tv[source] = 1;\n\twhile(!q.empty())\n\t{\n\t\tint t=q.front(); q.pop();\n\n\t\tfor(int i=0; i<graph[t].to.size(); i++) {\n\t\t\tint s = graph[t].to[i];\n\n\t\t\tif(ve.insert(make_pair(min(t,s),max(t,s))).second) {\n\t\t\t\twl += abs(graph[t].pos - graph[s].pos);\n\t\t\t}\n\n\t\t\tif(v[s]) continue;\n\t\t\tv[s] = 1;\n\t\t\tq.push(s);\n\t\t}\n\t}\n\n\n\tdouble al = 0;\n\tfor(int i=0; i<graph.size(); i++)\n\tfor(int j=0; j<graph[i].to.size(); j++) {\n\t\tal += abs(graph[i].pos - graph[graph[i].to[j]].pos);\n\t}\n\tprintf(\"%.9lf\\n\", al/2-wl);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-7;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a,b;\n\toperator line<T>()const{ return (line<T>){a,b}; }\n};\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<double> &S,const point<double> &p){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\n// 追加で頂点集合を指定できるように書き換え\nvoid arrangement(const vector< segment<double> > &S,const vector< point<double> > &plus,vector< point<double> > &P,vector<int> *G){\n\tint n=S.size();\n\tP=plus;\n\trep(i,n){\n\t\tP.push_back(S[i].a);\n\t\tP.push_back(S[i].b);\n\t\trep(j,i) if(intersect(S[i],S[j])) P.push_back(get_intersect(S[i],S[j]));\n\t}\n\tsort(P.begin(),P.end());\n\tP.erase(unique(P.begin(),P.end()),P.end());\n\n\trep(i,n){\n\t\tvector<int> on;\n\t\trep(u,P.size()) if(cover(S[i],P[u])) on.push_back(u);\n\t\trep(j,(int)on.size()-1){\n\t\t\tint u=on[j],v=on[j+1];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tvector< segment<double> > pipe(n);\n\trep(i,n) scanf(\"%lf%lf%lf%lf\",&pipe[i].a.x,&pipe[i].a.y,&pipe[i].b.x,&pipe[i].b.y);\n\tvector< point<double> > stop(m);\n\trep(i,m) scanf(\"%lf%lf\",&stop[i].x,&stop[i].y);\n\tpoint<double> s,t;\n\tscanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&t.x,&t.y);\n\n\t// 追加の頂点集合\n\tvector< point<double> > plus=stop;\n\tplus.push_back(s);\n\tplus.push_back(t);\n\n\tvector< point<double> > P;\n\tstatic vector<int> G[100000];\n\tarrangement(pipe,plus,P,G);\n\n\tint N=P.size();\n\tstatic bool isstop[100000];\n\trep(i,m) rep(u,N) if(P[u]==stop[i]) isstop[u]=true;\n\n\tint s_id=find(P.begin(),P.end(),s)-P.begin();\n\tint t_id=find(P.begin(),P.end(),t)-P.begin();\n\n\t// t から stop をまたがずに行ける場所を見つける\n\tstatic bool vis[100000];\n\tvis[t_id]=true;\n\tqueue<int> Q; Q.push(t_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=true;\n\t\t\t\tif(!isstop[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(vis[s_id]){ puts(\"-1\"); return 0; }\n\n\tdouble ans=0;\n\trep(i,n) ans+=dist(pipe[i].a,pipe[i].b);\n\n\t// s から vis を通らずに行ける場所を見つける\n\tstatic bool vis2[100000];\n\tvis2[s_id]=true;\n\tQ.push(s_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v]=true;\n\t\t\t\tif(!vis[v]) Q.push(v);\n\t\t\t}\n\t\t\tif(vis[v]) ans-=dist(P[u],P[v]);\n\t\t\telse       ans-=dist(P[u],P[v])/2;\n\t\t}\n\t}\n\tprintf(\"%.9f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double eps = 1e-8;\n#define eq(a, b) (fabs((a)-(b)) < eps)\n#define lt(a, b) ((a)-(b) < -eps)\n\nstruct Point {\n  double x, y;\n  Point(double x=0, double y=0):x(x), y(y){}\n  Point operator+(Point p) {return Point(x+p.x, y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x, y-p.y);}\n  Point operator*(double a) {return Point(x*a, y*a);}\n  Point operator/(double a) {return Point(x/a, y/a);}\n  bool operator<(const Point& p) const {return x!=p.x?x<p.x:y<p.y;}\n  bool operator==(const Point& p) const {return eq(x, p.x)&&eq(y, p.y);}\n};\nusing Vector = Point;\n\ndouble dot(Vector a, Vector b) {return a.x*b.x+a.y*b.y;}\ndouble cross(Vector a, Vector b) {return a.x*b.y-a.y*b.x;}\ndouble norm(Vector a) {return dot(a, a);}\ndouble abs(Vector a) {return sqrt(norm(a));}\n\nconst int CCW = 1;\nconst int CW = -1;\nconst int BCK = 2;\nconst int FNT = -2;\nconst int ON = 0;\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a, b) > eps) return CCW;\n  if(cross(a, b) < -eps) return CW;\n  if(dot(a, b) < -eps) return BCK;\n  if(norm(a) < norm(b)) return FNT;\n  return ON;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\ndouble distance(Point a, Point b) {return abs(a-b);}\n\nstruct Segment {\n  Point s, t;\n  Segment(Point s=Point(), Point t=Point()):s(s), t(t){}\n};\nusing Line = Segment;\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.s, s1.t, s2.s, s2.t);\n}\nbool intersect(Segment s, Point p) {\n  return abs(s.s-p)+abs(s.t-p)-abs(s.t-s.s) < eps;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(cross(l.t-l.s, p-l.s)/abs(l.t-l.s));\n}\ndouble distanceSP(Segment s, Point p) {\n  if(dot(s.t-s.s, p-s.s) < 0) return abs(p-s.s);\n  if(dot(s.s-s.t, p-s.t) < 0) return abs(p-s.t);\n  return distanceLP(s, p);\n}\ndouble distance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0;\n  return min(min(distanceSP(s1, s2.s), distanceSP(s1, s2.t)),\n\t     min(distanceSP(s2, s1.s), distanceSP(s2, s1.t)));\n}\nPoint crossPoint(Segment s1, Segment s2) {\n  Vector base = s2.t-s2.s;\n  double d1 = abs(cross(base, s1.s-s2.s));\n  double d2 = abs(cross(base, s1.t-s2.s));\n  double t = d1/(d1+d2);\n  return s1.s+(s1.t-s1.s)*t;\n}\n\nbool merge(Segment& s1, Segment s2) {\n  if(abs(cross(s1.t-s1.s, s2.t-s2.s)) > eps) return false;\n  if(ccw(s1.s, s2.s, s1.t) == CCW ||\n     ccw(s1.s, s2.s, s1.t) == CW) return false;\n  if(ccw(s1.s, s1.t, s2.s) == FNT ||\n     ccw(s2.s, s2.t, s1.s) == FNT) return false;\n  s1 = Segment(min(s1.s, s2.s), max(s1.t, s2.t));\n  return true;\n}\nvoid mergeSegments(vector<Segment>& segs) {\n  for(int i = 0; i < (int)segs.size(); ++i) {\n    if(segs[i].t < segs[i].s) swap(segs[i].s, segs[i].t);\n  }\n  for(int i = 0; i < (int)segs.size(); ++i) {\n    for(int j = i+1; j < (int)segs.size(); ++j) {\n      if(merge(segs[i], segs[j])) {\n\tsegs[j--] = segs.back();\n\tsegs.pop_back();\n      }\n    }\n  }\n}\n\nstruct edge {\n  int to;\n  double cost;\n  int id;\n  edge(){}\n  edge(int to, double cost, int id):to(to), cost(cost), id(id){}\n  bool operator<(const edge& e) {return lt(cost, e.cost);}\n};\nusing Graph = vector<vector<edge> >;\n\nvector<int> type;\nmap<Point, int> mp;\nint id = 0;\ndouble sum = 0;\n\nGraph segmentArrangement(vector<Segment>& segs, vector<Point>& ps) {\n  for(int i = 0; i < (int)segs.size(); ++i) {\n    ps.push_back(segs[i].s);\n    ps.push_back(segs[i].t);\n    for(int j = i+1; j < (int)segs.size(); ++j) {\n      if(intersect(segs[i], segs[j])) ps.push_back(crossPoint(segs[i], segs[j]));\n    }\n  }\n  sort(ps.begin(), ps.end());\n  ps.erase(unique(ps.begin(), ps.end()), ps.end());\n  //cout<<\"AFTER\"<<endl;\n  //for(int i = 0; i < (int)ps.size(); ++i) cout<<mp[ps[i]]<<\" \"<<ps[i].x<<\" \"<<ps[i].y<<endl;\n  for(int i = 0; i < (int)ps.size(); ++i) type.push_back(mp[ps[i]]);\n  Graph graph(ps.size());\n  for(int i = 0; i < (int)segs.size(); ++i) {\n    vector<pair<double, int> > ls;\n    for(int j = 0; j < (int)ps.size(); ++j) {\n      if(intersect(segs[i], ps[j])) {\n\tls.emplace_back(distance(segs[i], ps[j]), j);\n      }\n    }\n    sort(ls.begin(), ls.end());\n    for(int j = 0; j+1 < (int)ls.size(); ++j) {\n      int u = ls[j].second, v = ls[j+1].second;\n      graph[u].emplace_back(v, distance(ps[u], ps[v]), id);\n      graph[v].emplace_back(u, distance(ps[u], ps[v]), id);\n      ++id;\n      //sum += distance(ps[u], ps[v]);\n    }\n    sum += distance(segs[i].s, segs[i].t);\n  }\n  return graph;\n}\n\nint main() {\n  int N, M;\n  vector<Segment> segs;\n  vector<Point> ps;\n\n  cin >> N >> M;\n  for(int i = 0; i < N; ++i) {\n    Point s, t;\n    cin >> s.x >> s.y >> t.x >> t.y;\n    segs.emplace_back(s, t);\n  }\n  for(int i = 0; i < M+2; ++i) {\n    Point p;\n    cin >> p.x >> p.y;\n    ps.push_back(p);\n    if(i == M) mp[p] = 1;\n    else if(i == M+1) mp[p] = 2;\n    else mp[p] = 3;\n  }\n  //cout<<\"BEFORE\"<<endl;\n  //for(auto& p : mp) cout << p.second<<\" \"<<p.first.x<<\" \"<<p.first.y<<endl;\n  mergeSegments(segs);\n  Graph graph = segmentArrangement(segs, ps);\n  int s = -1, t = -1;\n  for(int i = 0; i < (int)graph.size(); ++i) {\n    if(type[i] == 1) s = i;\n    else if(type[i] == 2) t = i;\n  }\n  assert(~s && ~t);\n\n  queue<int> que;\n  vector<bool> used(graph.size(), false);\n  que.push(t);\n  used[t] = true;\n  //cout<<s<<\" \"<<t<<endl;\n  while(!que.empty()) {\n    int v = que.front(); que.pop();\n    //cout<<v<<endl;\n    if(v == s) {\n      cout << -1 << endl;\n      return 0;\n    }\n    if(type[v] == 3) continue;\n    for(edge e : graph[v]) {\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      que.push(e.to);\n    }\n  }\n  vector<bool> usedEdge(id, false);\n  que.push(s);\n  used[s] = true;\n  while(!que.empty()) {\n    int v = que.front(); que.pop();\n    for(edge e : graph[v]) {\n      if(usedEdge[e.id]) continue;\n      sum -= e.cost;\n      usedEdge[e.id] = true;\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      que.push(e.to);\n    }\n  }\n  printf(\"%.12f\\n\", sum);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-6;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a,b;\n\toperator line<T>()const{ return (line<T>){a,b}; }\n};\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<double> &S,const point<double> &p){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\n// 追加で頂点集合を指定できるように書き換え\nvoid arrangement(const vector< segment<double> > &S,const vector< point<double> > &plus,vector< point<double> > &P,vector<int> *G){\n\tint n=S.size();\n\tP=plus;\n\trep(i,n){\n\t\tP.push_back(S[i].a);\n\t\tP.push_back(S[i].b);\n\t\trep(j,i) if(intersect(S[i],S[j])) P.push_back(get_intersect(S[i],S[j]));\n\t}\n\tsort(P.begin(),P.end());\n\tP.erase(unique(P.begin(),P.end()),P.end());\n\n\trep(i,n){\n\t\tvector<int> on;\n\t\trep(u,P.size()) if(cover(S[i],P[u])) on.push_back(u);\n\t\trep(j,(int)on.size()-1){\n\t\t\tint u=on[j],v=on[j+1];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tvector< segment<double> > pipe(n);\n\trep(i,n) scanf(\"%lf%lf%lf%lf\",&pipe[i].a.x,&pipe[i].a.y,&pipe[i].b.x,&pipe[i].b.y);\n\tvector< point<double> > stop(m);\n\trep(i,m) scanf(\"%lf%lf\",&stop[i].x,&stop[i].y);\n\tpoint<double> s,t;\n\tscanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&t.x,&t.y);\n\n\t// 追加の頂点集合\n\tvector< point<double> > plus=stop;\n\tplus.push_back(s);\n\tplus.push_back(t);\n\n\tvector< point<double> > P;\n\tstatic vector<int> G[100000];\n\tarrangement(pipe,plus,P,G);\n\n\tint N=P.size();\n\tstatic bool isstop[100000];\n\trep(i,m) rep(j,N) if(P[j]==stop[i]) isstop[j]=true;\n\n\tint s_id=find(P.begin(),P.end(),s)-P.begin();\n\tint t_id=find(P.begin(),P.end(),t)-P.begin();\n\n\t// t から stop をまたがずに行ける場所を見つける\n\tstatic bool vis[100000];\n\tvis[t_id]=true;\n\tqueue<int> Q; Q.push(t_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=true;\n\t\t\t\tif(!isstop[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(vis[s_id]){ puts(\"-1\"); return 0; }\n\n\t// s から vis を通らずに行ける場所を見つける\n\tstatic bool vis2[100000];\n\tvis2[s_id]=true;\n\tQ.push(s_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v]=true;\n\t\t\t\tif(!vis[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans=0;\n\trep(i,n) ans+=dist(pipe[i].a,pipe[i].b);\n\trep(u,N) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tif(u<v && vis2[u] && vis2[v]) ans-=dist(P[u],P[v]);\n\t}\n\tprintf(\"%.9f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\n\nconst double INF = 1e100;\nconst double EPS = 1e-8;\ntypedef complex<double> P; \ntypedef pair<P,P> L; \n\nnamespace std{ \n  bool operator < (const P& a, const P& b){ \n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b); \n  } \n} \ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1; //テ・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ?\n  if(cross(b,c) < -EPS) return -1; // テヲツ卍づィツィツ暗・ツ崢榲」ツつ?\n  if(dot(b,c) < -EPS) return 2; // c -- a -- b テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n  if(norm(b) < norm(c)) return -2; // a -- b -- c テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n  return 0; // a -- c -- b テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n}\n\nbool isIntersect(L s1, L s2){\n    if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nmap<P,int> mf;\nint flag[1500];\nvector<vector<double> > G;\nvoid segmentArrangement(vector<L> ss,vector<P> &ps){ \n  for(int i=0;i<ss.size();i++){ \n    ps.push_back(ss[i].first); \n    ps.push_back(ss[i].second); \n    for(int j=i+1;j<ss.size();j++) \n      if(isIntersect(ss[i],ss[j])) \n        ps.push_back(crossPoint(ss[i],ss[j])); \n  } \n  sort(ps.begin(),ps.end()); \n  ps.erase(unique(ps.begin(),ps.end()), ps.end()); \n \n  G = vector<vector<double> >(ps.size(),vector<double>(ps.size(),INF)); \n  for(int i=0;i<(int)ps.size();i++){\n    flag[i] = mf[ps[i]];\n  }\n  for(int i=0;i<ss.size();i++){ \n    vector<pair<double,int> > list; \n    for(int j=0;j<ps.size();j++) \n      if(isIntersectSP(ss[i],ps[j]))  \n        list.push_back(make_pair(norm(ss[i].first-ps[j]), j)); \n    sort(list.begin(),list.end()); \n    for(int j=0;j<list.size()-1;j++){ \n      int a = list[j].second; \n      int b = list[j+1].second; \n      G[a][b] = abs(ps[a] - ps[b]); \n      G[b][a] = abs(ps[a] - ps[b]); \n    } \n  } \n} \n \nbool mem[1500][1500];\ndouble solve(){\n  int s,t;\n  queue<int> q;\n  int used[1500]={};\n  for(int i=0;i<(int)G.size();i++){\n    if(flag[i] == 2 ) s = i;\n    if(flag[i] == 3 ) t = i;   \n  }\n  q.push( t );\n  used[t] = true;\n  double res = 0.0;\n  while( !q.empty() ){\n    int p = q.front(); q.pop();\n    //       cout << p << endl;\n    if( flag[p] == 1) continue;\n    if( p == s ) return -1.0;\n    for(int i=0;i<(int)G[p].size();i++){\n      if( G[p][i] > INF/10 ) continue;\n      if( used[i] ) continue;\n      used[i] = true;\n      q.push( i );\n    }\n  }\n\n  q.push( s );\n  used[s] = true;\n  while( !q.empty() ){\n    int p = q.front(); q.pop();\n    for(int i=0;i<(int)G[p].size();i++){\n      if( G[p][i] > INF/10 ) continue;\n      if(mem[p][i]) continue;\n      res -= G[p][i];\n      mem[p][i] = true;\n      mem[i][p]  = true;\n      if( used[i] ) continue;\n      used[i] = true;\n      q.push( i );\n    }\n  }\n  for(int i=0;i<(int)G.size();i++)\n    for(int j=i+1;j<(int)G[i].size();j++)\n      if( G[i][j] < INF/10 ) res += G[i][j];\n\n  return res;\n}\n\nint main(){\n  vector<L> ss;\n  vector<P> ps;\n  cin >> N >> M;\n  for(int i=0;i<N;i++){\n    int x1,y1,x2,y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    ss.push_back( L(P(x1,y1),P(x2,y2)) );\n  }\n  for(int i=0;i<M;i++){\n    P a; cin >> a.real() >> a.imag();\n    ps.push_back( a );\n    mf[a] = 1;\n  }\n  P c,d;\n  cin >> c.real() >> c.imag();\n  cin >> d.real() >> d.imag();\n  int s,t;\n  mf[c] = 2;\n  mf[d] = 3;\n  ps.push_back(c);\n  ps.push_back(d);\n \n  segmentArrangement(ss,ps);\n\n  double res = solve();\n  if( res < -EPS ) cout << -1 << endl;\n  else printf(\"%.10lf\\n\",res);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-3;\n\nbool equals(double a, double b) {\n  return abs(a - b) < eps;\n}\n\nnamespace std {\n  bool operator < (const P &a, const P &b) {\n    if(!equals(a.real(), b.real())) return a.real() < b.real();\n    if(!equals(a.imag(), b.imag())) return a.imag() < b.imag();\n    return false;\n  }\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nbool isParallel(P a, P b) {\n  return equals(cross(a, b), 0.0);\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a, b) > eps) return 1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a, b) < -eps) return 2;\n  if(norm(b) - norm(a) > eps) return -2;\n  return 0;\n}\n\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t   ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1) / cross(b, a);\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nstruct Edge {\n  int to; double w;\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nint getId(P p, map<P, int> &m) {\n  if(!m.count(p)) {\n    int tmp = m.size();\n    m[p] = tmp;\n  }\n  return m[p];\n}\n\nint getId(P p, map<P, int> &m, map<int, P> &r) {\n  r[getId(p, m)] = p;\n  return m[p];\n}\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  vector<P> X(N), Y(N), Z(M);\n  P src, dst;\n  map<P, int> id;\n  map<int, P> rid;\n\n  for(int i = 0; i < N; ++i) {\n    cin >> X[i].real() >> X[i].imag() >> Y[i].real() >> Y[i].imag();\n    getId(X[i], id, rid);\n    getId(Y[i], id, rid);\n  }\n  for(int i = 0; i < M; ++i) {\n    cin >> Z[i].real() >> Z[i].imag();\n    getId(Z[i], id, rid);\n  }\n  cin >> src.real() >> src.imag();\n  getId(src, id, rid);\n  cin >> dst.real() >> dst.imag();\n  getId(dst, id, rid);\n\n  for(int i = 0; i < N; ++i) {\n    for(int j = i+1; j < N; ++j) {\n      if(isParallel(X[i] - Y[i], X[j] - Y[j])) {\n\t//\n      } else if(isIntersect(X[i], Y[i], X[j], Y[j])) {\n\tP p = getCrossP(X[i], Y[i], X[j], Y[j]);\n\tgetId(p, id, rid);\n      }\n    }\n  }\n\n  int V = id.size();\n  Graph G(V);\n\n  for(int i = 0; i < N; ++i) {\n    set<P> s;\n    vector<pair<double, P> > v;\n    s.insert(X[i]);\n    s.insert(Y[i]);\n    v.push_back(make_pair(0.0, X[i]));\n    v.push_back(make_pair(norm(Y[i] - X[i]), Y[i]));\n    for(int j = i+1; j < N; ++j) {\n      if(isParallel(X[i] - Y[i], X[j] - Y[j])) {\n\t//\n      } else if(isIntersect(X[i], Y[i], X[j], Y[j])) {\n\tP p = getCrossP(X[i], Y[i], X[j], Y[j]);\n\tif(s.count(p)) continue;\n\ts.insert(p);\n\tv.push_back(make_pair(norm(p - X[i]), p));\n      }\n    }\n    for(int j = 0; j < M; ++j) {\n      if(ccw(X[i], Y[i], Z[j]) == 0 && !s.count(Z[j])) {\n\ts.insert(Z[j]);\n\tv.push_back(make_pair(norm(Z[j] - X[i]), Z[j]));\n      }\n    }\n\n    if(ccw(X[i], Y[i], src) == 0 && !s.count(src)) {\n      s.insert(src);\n      v.push_back(make_pair(norm(src - X[i]), src));\n    }\n    if(ccw(X[i], Y[i], dst) == 0 && !s.count(dst)) {\n      s.insert(dst);\n      v.push_back(make_pair(norm(dst - X[i]), dst));\n    }\n    sort(v.begin(), v.end());\n    for(int j = 0; j+1 < v.size(); ++j) {\n      int a = getId(v[j].second, id);\n      int b = getId(v[j+1].second, id);\n      double w = abs(v[j].second - v[j+1].second);\n      G[a].push_back((Edge){b, w});\n      G[b].push_back((Edge){a, w});\n    }\n  }\n  if(0) {\n  cout << V << endl;\n  for(int i = 0; i < V; ++i) {\n    cout << rid[i] << \":\";\n    for(int j = 0; j < G[i].size(); ++j) {\n      if(j) cout << \",\";\n      cout << rid[G[i][j].to];\n    }\n    cout << endl;\n  }\n  }\n\n  try {\n    vector<int> F(V), F2(V);\n    for(int i = 0; i < M; ++i) {\n      F[getId(Z[i], id)] = 1;\n    }\n    set<pair<int, int> > vis;\n    queue<int> que;\n    \n    que.push(getId(dst, id));\n    int isrc = getId(src, id);\n    while(que.size()) {\n      int v = que.front();\n      que.pop();\n      for(int i = 0; i < G[v].size(); ++i) {\n\tint nv = G[v][i].to;\n\tif(nv == isrc) throw 0;\n\tif(vis.count(make_pair(nv, v))) continue;\n\tvis.insert(make_pair(nv, v));\n\tvis.insert(make_pair(v, nv));\n\tif(F[nv]) {\n\t  F2[nv] = 1;\n\t  continue;\n\t}\n\tque.push(nv);\n      }\n    }\n    double res = 0;\n    que.push(isrc);\n    while(que.size()) {\n      int v = que.front();\n      que.pop();\n      for(int i = 0; i < G[v].size(); ++i) {\n\tint nv = G[v][i].to;\n\tif(vis.count(make_pair(nv, v))) continue;\n\tvis.insert(make_pair(nv, v));\n\tvis.insert(make_pair(v, nv));\n\tres += G[v][i].w;\n\tif(F2[nv]) continue;\n\tque.push(nv);\n      }\n    }\n    res = -res;\n    for(int i = 0; i < N; ++i) {\n      res += abs(X[i] - Y[i]);\n    }\n    printf(\"%.10f\\n\", res);\n  } catch(...) {\n    printf(\"-1\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-8\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<double,int> P;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\ntypedef complex<double> C;\n\nconst double PI = 4*atan(1.0);\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n    bool operator > (const C a, const C b) {\n        return a.real() != b.real() ? a.real() > b.real() : a.imag() > b.imag();\n    }\n    //点をsetとかmapにつめたいとき(誤差を1e-10とか厳しくし過ぎるとバグる)\n    // bool operator<(const C a, const C b){\n    //     return abs(a.real()-b.real())>EPS ? a.real()<b.real()-EPS : a.imag()<b.imag()-EPS;\n    // }\n    bool operator==(const C a, const C b){\n        return (eq(a.real(),b.real()) && eq(a.imag(),b.imag()));\n    }\n    bool operator!=(const C a, const C b){\n        return !(a == b);\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(){}\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\n//条件付きsqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//正規化\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//角度(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//外積\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//内積\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nC rot(C c,double th)\n{\n    return c * C(cos(th),sin(th));\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\n//直線どうしの交差判定(同一直線はTrue)\nbool intersectLL(const L& l, const L& m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//直線と線分の交差判定(一点共有も交差と判定)\nbool intersectLS(const L& l, const L& s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//直線と点の交差(共有)判定\nbool intersectLP(const L& l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//線分どうしの交差判定(一点共有も交差と判定)\nbool intersectSS(const L& s, const L& t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//線分と点の交差(共有)判定\nbool intersectSP(const L& s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//直線および線分の交点\nC crosspointLL(const L& l, const L& m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //同一直線のとき\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//点pを直線l上に射影\nC projection(const L& l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//crosspointCLに使用する関数(命名が謎です)\ndouble gettime(C c1,C c2)\n{\n    return (dot(c1,c2) < 0 ? -1.0 : 1.0 ) * abs(c2) / abs(c1);\n}\n//円と直線の交点\nvector<C> crosspointCL(C c1,double r1,const L& l)\n{\n    C a=l[0], b=l[1];\n    vector<C> res;\n    C base=b-a,  target=projection(L(a,b),c1);\n    double length=abs(base), h=abs(c1-target);\n    base/=length;\n    if(r1+EPS<h)    return res;\n    double w=Sqrt(r1*r1-h*h);\n    double LL=gettime(normalize(b-a),target-a)-w,RR=LL+w*2.0;\n    res.push_back(a+base*LL);\n    if(eq(LL,RR))   return res;\n    res.push_back(a+base*RR);\n    return res;\n}\n\n//円と線分の交点\nvector<C> crosspointCS(C c1,double r1,const L& s)\n{\n    vector<C> tmp=crosspointCL(c1,r1,s);\n    vector<C> res;\n    rep(i,tmp.size()){\n        if(abs(s[1]-s[0]) == abs(s[0]-tmp[i])+abs(s[1]-tmp[i])){\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n//円どうしの交点\nL crosspointCC(const C c1, const double r1, const C c2, const double r2)\n{\n    C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n    C d = b*b-4.0*a*c;\n    C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n    return L(z1, z2);\n}\n//点pを直線lを軸として対称移動\nC reflection(const L &l, const C p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//点と直線の距離\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n//直線と直線の距離\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//直線と線分の距離\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//線分と点の距離\ndouble distanceSP(const L &s, const C p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//線分と線分の距離\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\ndouble getarea(C c1,double r1,C a,C b)\n{\n    C va=c1-a,vb=c1-b;\n    double A=abs(va),B=abs(vb);\n    double f=cross(va,vb),d=distanceSP(L(a,b),c1),res=0;\n    if(eq(f,0.0))   return 0;\n    if(A < r1+EPS && B < r1+EPS)    return f*0.5;\n    if(d>r1-EPS)    return r1*r1*M_PI*getarg(va,vb)/(2.0*M_PI);\n    vector<C> u=crosspointCS(c1,r1,L(a,b));\n    u.insert(u.begin(),a),u.push_back(b);\n    for(int i=0;i+1<(int)u.size();i++){\n        res+=getarea(c1,r1,u[i],u[i+1]);\n    }\n    return res;\n}\n//円と多角形の共通部分の面積\ndouble getcrossarea(const vector<C>& t,C c1,double r1)\n{\n    int n = (int)t.size();\n    if(n<3) return 0;\n    double res=0;\n    rep(i,n){\n      C a=t[i], b=t[(i+1)%n];\n      res += getarea(c1,r1,a,b);\n    }\n    return res;\n}\n//凸包を求める(O(nlogn))\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = (int)ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//凸性判定\nbool isconvex(const vector<C>& ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//多角形の符号付き面積(左回りが正)\ndouble area(const vector<C>& ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//凸多角形を直線で切断した時の左側の図形\nvector<C> convex_cut(const vector<C>& ps, const L& l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(L(A, B),l));\n    }\n    return Q;\n}\n//垂直二等分線\nL bisector(C a, C b){\n    C A = (a + b) * C(0.5, 0);\n    return L(A, A + rot(b - a, PI/2));\n}\n//ボロノイ図(正確にはvoronoi_cellを求める)\n//愚直であるため1つのvoronoi_cellを求めるのにかかる計算量がO(n^2)\nvector<C> voronoi(vector<C> poly, vector<C>& p, int s){\n    rep(i,(int)p.size()){\n        if (i != s){\n            poly = convex_cut(poly, bisector(p[s], p[i]));\n        }\n    }\n    return poly;\n}\n//点が多角形に包含されているか(0は含まれない,1は辺上,2は含まれる)\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//凸多角形の交差\nvector<C> convex_intersection(const vector<C>& ps,const vector<C>& qs)\n{\n\tvector<C> rs;\n\tint a = ps.size(),b = qs.size();\n\trep(i,a){\n        if(contains(qs,ps[i])){\n            rs.push_back(ps[i]);\n        }\n    }\n\trep(i,b){\n        if(contains(ps,qs[i])){\n            rs.push_back(qs[i]);\n        }\n    }\n    rep(i,a){\n        rep(j,b){\n            L l1(ps[i],ps[(i+1)%a]),l2(qs[j],qs[(j+1)%b]);\n\t\t    if(intersectSS(l1,l2)){\n                rs.push_back(crosspointLL(l1,l2));\n            }\n        }\n\t}\n\tsort(rs.begin(),rs.end());\n\trs.erase(unique(rs.begin(),rs.end()),rs.end());\n\tif(rs.size() <= 1){\n        return rs;\n    }\n\treturn convex_hull(rs);\n}\n//凸多角形の直径を求める(キャリパー法)\n//maxi,maxjが最遠点対となる\ndouble convex_diameter(const vector<C>& ps)\n{\n    const int n = (int)ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nbool compyx(C c1,C c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\ndouble closest_pair(C* a, int n)\n{\n    if(n<=1) return 1e100;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compyx);\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n//最近点対を求める\ndouble compute_shortest(C* a,int n)\n{\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n//2円の位置関係を示す(返り値は2円の間の共通接線の数)\nint getstateCC(C c1,double r1,C c2,double r2)\n{\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)return 4;\n    if(d>r1+r2-EPS)return 3;\n    if(d>abs(r1-r2)+EPS)return 2;\n    if(d>abs(r1-r2)-EPS)return 1;\n    return 0;\n}\n//点から円へ接線を引いた時の接点\nC gettangentCP_(C c1,double r1,C p,int flg){\n    C base=c1-p;\n    double w=Sqrt(norm(base)-r1*r1);\n    C s=p+base*C(w,r1 * flg)/norm(base)*w;\n    return s;\n}\n//点から円への接線\nvector<L> gettangentCP(C c1,double r1,C p){\n    vector<L> res;\n    C s=gettangentCP_(c1,r1,p,1);\n    C t=gettangentCP_(c1,r1,p,-1);\n    //点が円の周上にある場合\n    if(s == t){\n        res.push_back(L(s,s+(c1-p)*C(0,1)));\n    }else{\n        res.push_back(L(p,s));\n        res.push_back(L(p,t));\n    }\n    return res;\n}\n\n//2円の共通内接線を求める\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2円の共通外接線を求める\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2円の共通接線を求める(各直線の２点はそれぞれの円の接点)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\n\nstruct edge\n{\n    int to;\n    double cost;\n};\n\nmap<C,int> mp;\nvector<C> point;\nvector<vector<edge> > G;\nmap<pii,int> prv;\nbool stop[MAX_N], visit[MAX_N];\nmap<pii,double> kp;\nmap<pii,double> cs;\n\nvoid dfs(int u){\n    visit[u] = true;\n    each(e,G[u]){\n        if(!prv[P(min(u,e.to),max(u,e.to))]){\n            kp[pii(min(u,e.to),max(u,e.to))] = e.cost;\n            if(!visit[e.to]){\n                dfs(e.to);\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    vector<L> line(n);\n    rep(i,n){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        if(C(c,d) < C(a,b)) swap(a,c),swap(b,d);\n        line[i] = L(C(a,b),C(c,d));\n        if(mp.find(C(a,b)) == mp.end()){\n            mp[C(a,b)] = len(point);\n            point.pb(C(a,b));\n        }\n        if(mp.find(C(c,d)) == mp.end()){\n            mp[C(c,d)] = len(point);\n            point.pb(C(c,d));\n        }\n    }\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        if(mp.find(C(a,b)) == mp.end()){\n            mp[C(a,b)] = len(point);\n            point.pb(C(a,b));\n        }\n        stop[mp[C(a,b)]] = true;\n    }\n    int a,b,c,d;\n    cin >> a >> b >> c >> d;\n    if(mp.find(C(a,b)) == mp.end()){\n        mp[C(a,b)] = len(point);\n        point.pb(C(a,b));\n    }\n    if(mp.find(C(c,d)) == mp.end()){\n        mp[C(c,d)] = len(point);\n        point.pb(C(c,d));\n    }\n    int s = mp[C(a,b)], t = mp[C(c,d)];\n    int V = len(point);\n    vector<pii> ch;\n    G.resize(len(point));\n    double al = 0,stream = 0;\n    rep(i,n){\n        vector<C> ten = line[i];\n        rep(j,len(point)){\n            if(intersectSP(line[i],point[j])){\n                ten.pb(point[j]);\n            }\n        }\n        rep(j,n){\n            if(j != i && intersectSS(line[i],line[j])){\n                ten.pb(crosspointLL(line[i],line[j]));\n            }\n        }\n        zip(ten);\n        vi val(len(ten));\n        rep(j,len(ten)){\n            val[j] = mp[ten[j]];\n        }\n        rep(j,len(ten)-1){\n            ch.pb(pii(min(val[j],val[j+1]),max(val[j],val[j+1])));\n            cs[pii(min(val[j],val[j+1]),max(val[j],val[j+1]))] = abs(ten[j+1]-ten[j]);\n        }\n    }\n    zip(ch);\n    rep(i,len(ch)){\n        double val = cs[ch[i]];\n        al += val;\n        G[ch[i].fi].pb((edge){ch[i].se,val}),G[ch[i].se].pb((edge){ch[i].fi,val});\n    }\n    queue<int> que;\n    visit[t] = true;\n    que.push(t);\n    while(!que.empty()){\n        int p = que.front();\n        que.pop();\n        if(stop[p]) continue;\n        if(s == p){\n            printf(\"-1\\n\");\n            return 0;\n        }\n        each(e,G[p]){\n            prv[pii(min(p,e.to),max(p,e.to))] = 1;\n            if(!visit[e.to]){\n                visit[e.to] = true;\n                que.push(e.to);\n            }\n        }\n    }\n    fill(visit,visit+V,false);\n    dfs(s);\n    each(it,kp){\n        stream += it.se;\n    }\n    printf(\"%.12lf\\n\",al-stream);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst long double EPS=1e-8;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\nbool operator<(const point<long double> &a,const point<long double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\nbool operator==(const point<long double> &a,const point<long double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\nlong double abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a,b;\n\toperator line<T>()const{ return (line<T>){a,b}; }\n};\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<long double> &a,const point<long double> &b,const point<long double> &c){\n\tlong double rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\ntemplate<class T>\nlong double dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<long double> &S,const point<long double> &p){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\nbool intersect(const segment<long double> &S1,const segment<long double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\npoint<long double> get_intersect(const line<long double> &L1,const line<long double> &L2){\n\tlong double a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tlong double a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\n// 追加で頂点集合を指定できるように書き換え\nvoid arrangement(const vector< segment<long double> > &S,const vector< point<long double> > &plus,vector< point<long double> > &P,vector<int> *G){\n\tint n=S.size();\n\tP=plus;\n\trep(i,n){\n\t\tP.push_back(S[i].a);\n\t\tP.push_back(S[i].b);\n\t\trep(j,i) if(intersect(S[i],S[j])) P.push_back(get_intersect(S[i],S[j]));\n\t}\n\tsort(P.begin(),P.end());\n\tP.erase(unique(P.begin(),P.end()),P.end());\n\n\trep(i,n){\n\t\tvector<int> on;\n\t\trep(u,P.size()) if(cover(S[i],P[u])) on.push_back(u);\n\t\trep(j,(int)on.size()-1){\n\t\t\tint u=on[j],v=on[j+1];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tvector< segment<long double> > pipe(n);\n\trep(i,n) scanf(\"%Lf%Lf%Lf%Lf\",&pipe[i].a.x,&pipe[i].a.y,&pipe[i].b.x,&pipe[i].b.y);\n\tvector< point<long double> > stop(m);\n\trep(i,m) scanf(\"%Lf%Lf\",&stop[i].x,&stop[i].y);\n\tpoint<long double> s,t;\n\tscanf(\"%Lf%Lf%Lf%Lf\",&s.x,&s.y,&t.x,&t.y);\n\n\t// 追加の頂点集合\n\tvector< point<long double> > plus=stop;\n\tplus.push_back(s);\n\tplus.push_back(t);\n\n\tvector< point<long double> > P;\n\tstatic vector<int> G[100000];\n\tarrangement(pipe,plus,P,G);\n\n\tint N=P.size();\n\tstatic bool isstop[100000];\n\trep(i,m) rep(u,N) if(P[u]==stop[i]) isstop[u]=true;\n\n\tint s_id=find(P.begin(),P.end(),s)-P.begin();\n\tint t_id=find(P.begin(),P.end(),t)-P.begin();\n\n\t// t から stop をまたがずに行ける場所を見つける\n\tstatic bool vis[100000];\n\tvis[t_id]=true;\n\tqueue<int> Q; Q.push(t_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=true;\n\t\t\t\tif(!isstop[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(vis[s_id]){ puts(\"-1\"); return 0; }\n\n\t// s から vis を通らずに行ける場所を見つける\n\tstatic bool vis2[100000];\n\tvis2[s_id]=true;\n\tQ.push(s_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v]=true;\n\t\t\t\tif(!vis[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tlong double ans=0;\n\trep(i,n) ans+=dist(pipe[i].a,pipe[i].b);\n\trep(u,N) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tif(u<v && vis2[u] && vis2[v]) ans-=dist(P[u],P[v]);\n\t}\n\tprintf(\"%.9Lf\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<cstdio>\n#include<vector>\n#include<complex>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nconst int NODE = 300 * 300 + 10;\ntypedef struct {int t;double cost;}Edge;\nvector<Edge> edge[NODE];\nbool          ben[NODE];\n\nconst double eps = 1e-10;\ntypedef complex<double> P;\ntypedef pair<P,P>       Line;\n\nnamespace std{\n  bool operator==(const P &a,const P & b){\n    if (abs(a.real()-b.real()) < 1e-10 && abs(a.imag()-b.imag())<eps)return true;\n    return false;\n  }\n  bool operator<(const P &a,const P & b){\n    if (abs(a.real()-b.real()) > 1e-10)return a.real() < b.real();\n    return a.imag() < b.imag();\n  }\n};\n\ndouble cross(P a,P b){\n return ( a.real()*b.imag() - a.imag()*b.real());\n}\n\nbool is_point_online(P a,P b,P c){\n return ( abs(a-c)+abs(b-c) < abs(a-b)+eps);\n}\n\nbool is_intersected_ls(P a1,P a2,P b1,P b2){\n if ( is_point_online(a1,a2,b1))return true;\n if ( is_point_online(a1,a2,b2))return true;\n if ( is_point_online(b1,b2,a1))return true;\n if ( is_point_online(b1,b2,a2))return true;\n if (  ( cross(a2-a1,b1-a1) * cross(a2-a1,b2-a1)<eps ) && \n    ( cross(b2-b1,a1-b1)*cross(b2-b1,a2-b1)<eps))return true;\n else return false;\n}\n\nP intersection_ls(P a1,P a2,P b1,P b2){\n P b = b2-b1;\n double d1=abs(cross(b,a1-b1));\n double d2=abs(cross(b,a2-b1));\n double t = d1/(d1+d2);\n return a1+(a2-a1)*t;\n}\n\n\n\npair<int,int> makegraph(vector<Line> &in,vector<P> & stop,P &s,P &t,int &n){\n  vector<P> a=stop;\n  \n  a.push_back(s);\n  a.push_back(t);\n  for(int i=0;i<(int)in.size();i++){\n    a.push_back(in[i].first);\n    a.push_back(in[i].second);\n    for(int j=i+1;j<(int)in.size();j++){\n      \n      if (is_intersected_ls(in[i].first,in[i].second,in[j].first,in[j].second)){\n\ta.push_back(intersection_ls(in[i].first,in[i].second,in[j].first,in[j].second));\n      }\n    }\n  }\n  sort(a.begin(),a.end());\n  a.erase(unique(a.begin(),a.end()),a.end());\n  /*\n  for(int i=0;i<a.size();i++){\n    cout << a[i] <<\" \" ;\n  }\n  cout << endl;\n  */\n  n = a.size();\n  for(int i=0;i<(int)in.size();i++){\n    \n    vector<pair<P,int> > cand;\n    for(int j=0;j<(int)a.size();j++){\n      if (is_point_online(in[i].first,in[i].second,a[j]))cand.push_back(make_pair(a[j],j));\n    }\n    sort(cand.begin(),cand.end());\n    /*\n    for(int j=0;j<cand.size();j++){\n      cout << cand[j].second <<\" \" << cand[j].first << endl;\n    }\n    cout << endl;\n    */\n    for(int j=1;j<(int)cand.size();j++){\n      int f = cand[j-1].second;\n      int t = cand[j ].second;\n      double len = abs(cand[j-1].first - cand[j].first);\n      edge[f].push_back((Edge){t,len});\n      edge[t].push_back((Edge){f,len});\n    }\n  }\n  \n  pair<int,int> ret;\n  for(int i=0;i<(int)a.size();i++){\n    if (abs(s-a[i]) < eps)ret.first = i;\n    if (abs(t-a[i]) < eps)ret.second = i;\n  }\n  \n  for(int i=0;i<(int)stop.size();i++){\n    for(int j=0;j<(int)a.size();j++){\n      if (abs(stop[i]-a[j]) < eps)ben[j] = true;\n    }\n  }\n  return ret;\n}\n\nbool neighbor[NODE];\nbool vis[NODE];\nset<pair<int,int> > S;\nvoid dfs(int now,double &a){\n  if (vis[now])return;\n  vis[now] = true;\n  if (ben[now])return;\n  for(int i=0;i<(int)edge[now].size();i++){\n    int next =edge[now][i].t;\n    double cost = edge[now][i].cost;\n    int ta=now,tb=next;\n    if (ta > tb)swap(ta,tb);\n    if (S.count(make_pair(ta,tb)) == 0){\n      a += cost,S.insert(make_pair(ta,tb));\n    }\n    dfs(next,a);\n  }\n}\ndouble bfs(int s){\n  queue<int> Q;\n  double ret = 0;\n  Q.push(s);\n  vis[s] = true;\n  while(!Q.empty()){\n    int now = Q.front();Q.pop();\n    for(int i=0;i<(int)edge[now].size();i++){\n      int next = edge[now][i].t;\n      int ta = now,tb = next;\n      if (ta > tb)swap(ta,tb);\n      if (S.count(make_pair(ta,tb)) == 0){\n\tret += edge[now][i].cost;\n\tS.insert(make_pair(ta,tb));\n      }\n      if (vis[next] || neighbor[next])continue;\n      if (!vis[next] && !neighbor[next]){\n\tQ.push(next);\n\tvis[next] = true;\n      }\n    }\n  }\n  return ret;\n}\n\ndouble solve(int n,int s,int t,double sum){\n  double ta = 0;\n  S.clear();\n  for(int i=0;i<n;i++){\n    vis[i] =false;\n  }\n  \n  dfs(t,ta);\n  if (vis[s]){\n    return -1;\n  }\n  for(int i=0;i<n;i++){\n    neighbor[i] = vis[i];\n  }\n  \n  for(int i=0;i<n;i++){\n    vis[i] =false;\n  }\n  S.clear();\n  double tb = bfs(s);\n  double tmp = sum;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<edge[i].size();j++){\n      int now =i,next=edge[i][j].t;\n      if (now > next)continue;\n      if (S.count(make_pair(now,next)) == 0){\n\ttmp -= edge[i][j].cost;\n      }\n    }\n  }\n  \n  return sum - tmp;\n}\n\nint main(){\n  int n,m;\n  while(cin>>n>>m && n){\n    P s,t;\n    double sum = 0;\n    for(int i=0;i<NODE;i++){\n      edge[i].clear();\n      ben[i] = false;\n    }\n    vector<Line> in(n);\n    vector<P> stop(m);\n    for(int i=0;i<n;i++){\n      cin>>in[i].first.real()>>in[i].first.imag();\n      cin>>in[i].second.real()>>in[i].second.imag();\n      sum += abs(in[i].first-in[i].second);\n    }\n    for(int j=0;j<m;j++){\n      cin>>stop[j].real()>>stop[j].imag();\n    }\n    cin>>s.real()>>s.imag();\n    cin>>t.real()>>t.imag();\n    int node;\n    pair<int,int> tmp = makegraph(in,stop,s,t,node);\n    /*\n    for(int i=0;i<node;i++){\n      cout << i <<\" is ben? \" << ben[i] << endl;\n      for(int j=0;j<edge[i].size();j++){\n\tcout << i <<\" \" << edge[i][j].t << \" \" << edge[i][j].cost << endl;\n      }\n      cout <<\"-\"<<endl;\n    }\n    cout << \"----------------------------\" << endl;\n    */\n    \n    printf(\"%.10lf\\n\",solve(node,tmp.first,tmp.second,sum));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-5;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a,b;\n\toperator line<T>()const{ return (line<T>){a,b}; }\n};\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<double> &S,const point<double> &p){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\n// 追加で頂点集合を指定できるように書き換え\nvoid arrangement(const vector< segment<double> > &S,const vector< point<double> > &plus,vector< point<double> > &P,vector<int> *G){\n\tint n=S.size();\n\tP=plus;\n\trep(i,n){\n\t\tP.push_back(S[i].a);\n\t\tP.push_back(S[i].b);\n\t\trep(j,i) if(intersect(S[i],S[j])) P.push_back(get_intersect(S[i],S[j]));\n\t}\n\tsort(P.begin(),P.end());\n\tP.erase(unique(P.begin(),P.end()),P.end());\n\n\trep(i,n){\n\t\tvector<int> on;\n\t\trep(u,P.size()) if(cover(S[i],P[u])) on.push_back(u);\n\t\trep(j,(int)on.size()-1){\n\t\t\tint u=on[j],v=on[j+1];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tvector< segment<double> > pipe(n);\n\trep(i,n) scanf(\"%lf%lf%lf%lf\",&pipe[i].a.x,&pipe[i].a.y,&pipe[i].b.x,&pipe[i].b.y);\n\tvector< point<double> > stop(m);\n\trep(i,m) scanf(\"%lf%lf\",&stop[i].x,&stop[i].y);\n\tpoint<double> s,t;\n\tscanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&t.x,&t.y);\n\n\t// 追加の頂点集合\n\tvector< point<double> > plus=stop;\n\tplus.push_back(s);\n\tplus.push_back(t);\n\n\tvector< point<double> > P;\n\tstatic vector<int> G[100000];\n\tarrangement(pipe,plus,P,G);\n\n\tint N=P.size();\n\tstatic bool isstop[100000];\n\trep(i,m) rep(j,N) if(P[j]==stop[i]) isstop[j]=true;\n\n\tint s_id=find(P.begin(),P.end(),s)-P.begin();\n\tint t_id=find(P.begin(),P.end(),t)-P.begin();\n\n\t// t から stop をまたがずに行ける場所を見つける\n\tstatic bool vis[100000];\n\tvis[t_id]=true;\n\tqueue<int> Q; Q.push(t_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=true;\n\t\t\t\tif(!isstop[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(vis[s_id]){ puts(\"-1\"); return 0; }\n\n\t// s から vis を通らずに行ける場所を見つける\n\tstatic bool vis2[100000];\n\tvis2[s_id]=true;\n\tQ.push(s_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v]=true;\n\t\t\t\tif(!vis[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans=0;\n\trep(i,n) ans+=dist(pipe[i].a,pipe[i].b);\n\trep(u,N) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tif(u<v && vis2[u] && vis2[v]) ans-=dist(P[u],P[v]);\n\t}\n\tprintf(\"%.9f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-12, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n// 点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef double Weight;\n\nstruct Edge { int from, to; Weight weight;\nint id;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight,const int id) {\n\tg[from].push_back(Edge{ from, to, weight,id});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<pair<Point,bool>> &p) {\n\tint n = p.size(), m = s.size();\n\tint id = 0;\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j].first))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j].first), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from].first - p[to].first), id);\n\t\t\tadd_edge(g, to, from, abs(p[from].first - p[to].first), id++);\n\t\t}\n\t}\n\treturn g;\n}\n\n//Graph sennbunn_arrangement(const vector<Line>&s) {\n//\tvector<Point>crss;\n//\tfor (int i = 0; i < s.size(); ++i) {\n//\t\tfor (int j = i + 1; j < s.size(); ++j) {\n//\t\t\tif (isis_ss( s[i],  s[j])) {\n//\t\t\t\tcrss.push_back(is_ll( s[i],  s[j]));\n//\t\t\t}\n//\t\t}\n//\t}\n//\tfor (int i = 0; i <s.size(); ++i) {\n//\t\tcrss.push_back( s[i][0]);\n//\t\tcrss.push_back( s[i][1]);\n//\t}\n//\treturn segment_arrangement(s, crss);\n//}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nint startid;\nint goalid;\nbool dfs0(const Graph&g,const int now, vector<bool>&came, vector<bool>&close,const vector<bool>&bulbs) {\n\tcame[now] = true;\n\tfor (auto e : g[now]) {\n\t\tif (!came[e.to]) {\n\t\t\tif (e.to == startid)return false;\n\t\t\telse {\n\t\t\t\tif (bulbs[e.to]) {\n\t\t\t\t\tclose[e.to] = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!dfs0(g, e.to, came, close, bulbs)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ndouble dfs1(const Graph&g, const int now, vector<bool>&came,vector<bool>&useedges, const vector<bool>&close) {\n\tcame[now] = true;\n\tdouble ans = 0;\n\tfor (auto e : g[now]) {\n\t\tif (!useedges[e.id]) {\n\t\t\tans += e.weight;\n\t\t\tuseedges[e.id] = true;\n\t\t\tif (close[e.to])continue;\n\t\t\telse {\n\t\t\t\tif(!came[e.to])ans += dfs1(g, e.to, came,useedges, close);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tdouble sum = 0;\n\tGraph g;\n\tint sx, sy, gx, gy;\n\tPoint start;\n\tPoint goal;\n\tvector<pair<Point, bool>>crss;\n\tvector<bool>bulbs;\n\t{\n\t\tint N, M; cin >> N >> M;\n\t\tvector<Line>ls;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint asx, asy, dx, dy; cin >> asx >> asy >> dx >> dy;\n\t\t\tls.push_back(Line(Point(asx, asy), Point(dx, dy)));\n\t\t\tsum += (abs(Point(asx, asy) - Point(dx, dy)));\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < ls.size(); ++j) {\n\t\t\t\tif (isis_ss(ls[i], ls[j])) {\n\t\t\t\t\tcrss.push_back(make_pair(is_ll(ls[i], ls[j]),false));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < ls.size(); ++i) {\n\t\t\tcrss.push_back(make_pair(ls[i][0], false));\n\t\t\tcrss.push_back(make_pair(ls[i][1], false));\n\t\t}\n\t\t\n\t\tvector<Point >bs;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tPoint p(x, y);\n\t\t\tbs.push_back(p);\n\t\t}\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tstart = Point(sx, sy);\n\t\tgoal = Point(gx, gy);\t\n\t\tcrss.push_back(make_pair(start, false));\n\t\tcrss.push_back(make_pair(goal, false));\n\t\tsort(crss.begin(), crss.end());\n\t\tcrss.erase(unique(crss.begin(), crss.end()), crss.end());\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tauto it = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == bs[i]; });\n\t\t\tif (it == crss.end()) {\n\t\t\t\tcrss.push_back(make_pair(bs[i], true));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(*it).second = true;\n\t\t\t}\n\t\t}\n\n\n\t\tfor (int i = 0; i < crss.size(); ++i) {\n\t\t\tbulbs.push_back(crss[i].second);\n\t\t}\n\t\tg= segment_arrangement(ls, crss);\n\t}\n\tauto startit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == start; });\n\tstartid = startit - crss.begin();\n\tauto goalit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == goal; });\n\tgoalid = goalit - crss.begin();\n\tvector<bool>close(crss.size(),false);\n\tvector<bool>came(crss.size(), false);\n\tif (dfs0(g, goalid, came, close, bulbs)) {\n\t\tvector<bool>acame(crss.size(), false);\n\t\tvector<bool>useedges(40000, false);\n\t\tdouble ans = dfs1(g, startid, acame, useedges,close);\n\t\tcout <<fixed<<setprecision(10)<< sum-ans << endl;\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-6;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a,b;\n\toperator line<T>()const{ return (line<T>){a,b}; }\n};\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<double> &S,const point<double> &p){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\n// 追加で頂点集合を指定できるように書き換え\nvoid arrangement(const vector< segment<double> > &S,const vector< point<double> > &plus,vector< point<double> > &P,vector<int> *G){\n\tint n=S.size();\n\tP=plus;\n\trep(i,n){\n\t\tP.push_back(S[i].a);\n\t\tP.push_back(S[i].b);\n\t\trep(j,i) if(intersect(S[i],S[j])) P.push_back(get_intersect(S[i],S[j]));\n\t}\n\tsort(P.begin(),P.end());\n\tP.erase(unique(P.begin(),P.end()),P.end());\nif(P.size()>2000) for(;;);\n\n\trep(i,n){\n\t\tvector<int> on;\n\t\trep(u,P.size()) if(cover(S[i],P[u])) on.push_back(u);\n\t\trep(j,(int)on.size()-1){\n\t\t\tint u=on[j],v=on[j+1];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tvector< segment<double> > pipe(n);\n\trep(i,n) scanf(\"%lf%lf%lf%lf\",&pipe[i].a.x,&pipe[i].a.y,&pipe[i].b.x,&pipe[i].b.y);\n\tvector< point<double> > stop(m);\n\trep(i,m) scanf(\"%lf%lf\",&stop[i].x,&stop[i].y);\n\tpoint<double> s,t;\n\tscanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&t.x,&t.y);\n\n\t// 追加の頂点集合\n\tvector< point<double> > plus=stop;\n\tplus.push_back(s);\n\tplus.push_back(t);\n\n\tvector< point<double> > P;\n\tvector<int> G[2000];\n\tarrangement(pipe,plus,P,G);\n\n\tint N=P.size();\n\tbool isstop[2000]={};\n\trep(i,m) rep(j,N) if(P[j]==stop[i]) isstop[j]=true;\n\n\tint s_id=find(P.begin(),P.end(),s)-P.begin();\n\tint t_id=find(P.begin(),P.end(),t)-P.begin();\n\n\t// t から stop をまたがずに行ける場所を見つける\n\tbool vis[2000]={};\n\tvis[t_id]=true;\n\tqueue<int> Q; Q.push(t_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=true;\n\t\t\t\tif(!isstop[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(vis[s_id]){ puts(\"-1\"); return 0; }\n\n\t// s から vis を通らずに行ける場所を見つける\n\tbool vis2[2000]={};\n\tvis2[s_id]=true;\n\tQ.push(s_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v]=true;\n\t\t\t\tif(!vis[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans=0;\n\trep(i,n) ans+=dist(pipe[i].a,pipe[i].b);\n\trep(u,N) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tif(u<v && vis2[u] && vis2[v]) ans-=dist(P[u],P[v]);\n\t}\n\tprintf(\"%.9f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) cin>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  for(int k=0;k<2;k++){\n    if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1; \n    if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;\n    swap(s1,s2);\n  }\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<pair<int, double> > >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n\tps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<pair<int, double> > > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++)\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n\tls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n      \n    sort(ls.begin(),ls.end());\n    for(int j=0;j+1<(int)ls.size();j++){\n      int a=ls[j].second,b=ls[j+1].second;\n      G[a].emplace_back(b,abs(ps[a]-ps[b]));\n      G[b].emplace_back(a,abs(ps[a]-ps[b]));\n    }\n  }\n  for(int i=0;i<(int)G.size();i++){\n    sort(G[i].begin(),G[i].end());\n    G[i].erase(unique(G[i].begin(),G[i].end(),\n\t\t      [](pair<int,double> a,pair<int,double> b){\n\t\t\treturn a.first==b.first;}),\n\t       G[i].end());\n  }\n  return G;\n}\n\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  vector<Segment> ss(n);\n  Polygon ps(m);\n  for(int i=0;i<n;i++) cin>>ss[i];\n  for(int i=0;i<m;i++) cin>>ps[i];\n  map<Point, int> mp;\n  for(int i=0;i<m;i++) mp[ps[i]]=i;\n  Point s,g;\n  cin>>s>>g;\n  ps.emplace_back(s);\n  ps.emplace_back(g);\n\n  auto G=segmentArrangement(ss,ps);\n  if(0){\n    int k=G.size();\n    for(int i=0;i<k;i++){\n      cout<<i<<\":\"<<ps[i]<<endl;\n      for(auto p:G[i]) cout<<p.first<<\" \"<<p.second<<endl;\n    }\n  }\n\n  double ans=0,tmp=0;\n  for(int i=0;i<n;i++) ans+=abs(ss[i].p1-ss[i].p2);\n\n  vector<int> used(G.size(),0);\n  queue<int> q;\n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==g) {used[i]=1;q.emplace(i);}\n\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    if(ps[v]==s){\n      cout<<(int)-1<<endl;\n      return 0;\n    }\n    if(mp.count(ps[v])) continue;\n    for(auto &e:G[v]){\n      int u=e.first;\n      if(!used[u]){\n\tused[u]=1;\n\tq.emplace(u);\n      }\n    }\n  }\n  \n  //cout<<ans<<endl;\n  //for(int i=0;i<(int)G.size();i++) cout<<i<<\":\"<<ps[i]<<\":\"<<used[i]<<endl;\n  \n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==s) q.emplace(i);\n\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    //cout<<v<<endl;\n    for(auto &e:G[v]){\n      int u=e.first;\n      double &c=e.second;\n      if(used[v]&&used[u]) continue;\n      if(c==0) continue;\n      tmp+=c;c=0;\n      q.emplace(u);\n    }\n  }\n  tmp/=2;\n  \n  cout<<ans-tmp<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef complex<double> V;\ntypedef vector<P> vecP;\ntypedef pair<P,P> L;\ntypedef pair<P,P> S;\ntypedef pair<P,double> C;\nconst double eps=1e-8;\nconst double PI=acos(-1);\nconst double PI2=PI*2.0;\n \nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.real()!=b.real()?\n            a.real() <b.real():\n            a.imag() <b.imag());\n  }\n};\n \nV normal(V a){\n  assert( abs(a)>0 );\n  return a/abs(a);\n}\n \ndouble Sqrt( double x ){\n  if(x<0)return 0;\n  else return sqrt(x);\n}\n \nP Vector(L a){\n  return a.second-a.first;\n}\n \nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n \nbool eq(P a,P b){\n  return ( eq(a.real(),b.real()) && eq(a.imag(),b.imag()) );\n}\n \ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n \ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n \ndouble getArg(P a,P b){\n  return arg(b*conj(a));\n}\n \ndouble getTime(V a,V b){\n  assert( eq(cross(a,b),0) );\n  return ( dot(a,b) < 0 ? -1.0 : 1.0 ) * abs(b) / abs(a);\n}\n \n \nP project(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*real(c/b);\n}\n \nP reflect(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*conj(c/b);\n}\n \nint ccw(P a,P b,P c){\n  P ab=b-a,ac=c-a;\n  P k=ac*conj(ab);\n  if(k.imag()>0)return 1;\n  if(k.imag()<0)return -1;\n  if(k.real()<0)return 2;\n  if(abs(ab)<abs(ac))return -2;\n  return 0;\n}\n \nbool isParallel(P a,P b){\n  return eq(0, cross(a,b));\n}\n \nbool isParallel(S a,S b){\n  return eq(0, cross( Vector(a) , Vector(b) ) );\n}\n \nbool onLP(L l,P p){\n  P a=l.first, b=l.second;\n  return eq(0, cross(b-a,p-a));\n}\n \nbool onSP(S s,P p){\n  P a=s.first, b=s.second;\n  return eq( abs(b-a) , abs(a-p)+abs(b-p) );\n}\n \nbool isCrossSS(S s0,S s1){\n  P a=s0.first, b=s0.second;\n  P c=s1.first, d=s1.second;\n  int f0 = ccw(a,b,c) * ccw(a,b,d);\n  int f1 = ccw(c,d,a) * ccw(c,d,b);\n  return (f0<=0 && f1<=0);\n}\n \nbool isCrossLS(L l,S s){\n  P a=l.first, b=l.second;\n  P c=s.first, d=s.second;\n  return ( ccw(a,b,c) * ccw(a,b,d) <= 0 );\n}\n \ndouble distLP(L l,P p){\n  P a=l.first, b=l.second;\n  double res = cross(b-a,p-a) / abs(b-a);\n  return abs(res);\n}\n \ndouble distSP(S s,P p){\n  P a=s.first, b=s.second;\n  if( dot(b-a,p-a) < eps )return abs(p-a);\n  if( dot(a-b,p-b) < eps )return abs(p-b);\n  return distLP(s,p);\n}\n \ndouble distSS(S s0,S s1){\n  if( isCrossSS(s0,s1) )return 0;\n  double res0 = min( distSP( s0, s1.first ) , distSP(s0, s1.second) );\n  double res1 = min( distSP( s1, s0.first ) , distSP(s1, s0.second) );\n  return min(res0,res1);\n}\n \nP getCrossLL(L l0,L l1){\n  P a=l0.first, b=l0.second;\n  P c=l1.first, d=l1.second;\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n \n \n  \nint inPolygon(vecP &t,P p){\n  int n=t.size();\n  double sum=0;\n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p)==0 )return 1;\n    sum+= getArg(a-p,b-p);\n  }\n  if( abs(sum) < eps )return 0;\n  else return 2;\n}\n\n\nstruct edge{\n  int to;\n  double cost;\n};\n\ntypedef vector<edge> Node;\ntypedef vector<Node> Graph;\nGraph G;\nmap<int,bool> isB;\nvector< P > points;\n\nvoid segments2graph( vector<S> segments ,vector<P> b ){\n\n  int n=segments.size();\n\n  sort(b.begin(),b.end());\n  \n  for(int i=0;i<(int)b.size();i++){\n    points.push_back(b[i]);\n  }\n  \n  for(int i=0;i<n;i++){\n    S si=segments[i];\n    points.push_back( si.first );\n    points.push_back( si.second );\n    for(int j=0;j<i;j++){\n      S sj=segments[j];\n      if( isCrossSS( si , sj ) && !isParallel( si, sj ) ){\n        points.push_back( getCrossLL(si,sj) );\n      }\n    }\n  }\n \n  sort(points.begin(), points.end());\n  points.erase( unique( points.begin(), points.end() ) , points.end() );\n   \n  G.resize(points.size());\n  \n  for(int i=0;i<(int)points.size();i++){\n    P p=points[i];\n    isB[i] = binary_search(b.begin(),b.end(), p);\n  }\n  \n  typedef pair< double , int > Pair;\n     \n  for(int i=0;i<n;i++){\n    S si=segments[i];\n    P sf=si.first, se=si.second;\n    vector< Pair > targets;\n    for(int j=0;j<(int)points.size();j++){\n      P pj=points[j];\n      // if( ccw( si.first, si.second, pj ) == 0 ){\n      if( onSP( si, pj ) ){\n        targets.push_back( Pair(getTime(se-sf ,pj-sf ), j ) );\n      }\n    }\n\n    for(int j=0;j<(int)targets.size();j++){\n      for(int k=0;k<j;k++){\n        Pair a=targets[j];\n        Pair b=targets[k];\n        P ap=points[ a.second ];\n        P bp=points[ b.second ];\n        G[a.second].push_back( (edge){ b.second , abs(ap-bp) } );\n        G[b.second].push_back( (edge){ a.second , abs(bp-ap) } );\n      }\n    }\n\n    /* \n    sort( targets.begin(), targets.end() );\n    for(int j=0;j+1<(int)targets.size();j++){\n      Pair a=targets[j];\n      Pair b=targets[j+1];\n      P ap=points[ a.second ];\n      P bp=points[ b.second ];\n      \n      G[a.second].push_back( (edge){ b.second , abs(ap-bp) } );\n      G[b.second].push_back( (edge){ a.second , abs(bp-ap) } );\n    }\n    */\n    \n  }\n\n}\n\nP input(){\n  double x,y;\n  cin>>x>>y;\n  return P(x,y);\n}\n\n\nmap<int,bool> visited;\ndouble total=0;\n\nmap< P , bool > counted;\n\nvoid dfs(int pos){\n  \n  if( isB[pos] )return;\n  if(visited[pos])return;\n  visited[pos]=true;\n  \n  for(int i=0;i<(int)G[pos].size();i++){\n    edge e=G[pos][i];\n    if( visited[e.to] || isB[e.to] )total+=e.cost;\n    else total += e.cost/2.0;\n  }\n  \n  for(int i=0;i<(int)G[pos].size();i++){\n    edge e=G[pos][i];\n    dfs(e.to);\n  }\n}\n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  vector< S > segments;\n  vector< P > bs;\n\n  double ans = 0;\n  \n  for(int i=0;i<N;i++){\n    P a=input();\n    P b=input();\n    segments.push_back( S(a,b) );\n    ans+= abs(a-b);\n  }\n  \n  for(int i=0;i<M;i++){\n    P a=input();\n    bs.push_back( a );\n  }\n  \n  P si,ti;\n  si=input();\n  ti=input();\n  points.push_back(si);\n  points.push_back(ti);\n  \n  segments2graph(segments,bs);\n\n  \n  int ex = lower_bound( points.begin(), points.end() , si ) - points.begin();\n  int root = lower_bound( points.begin(), points.end() , ti ) - points.begin();\n  \n  dfs(root);\n  \n  if( visited[ex] ){\n    cout<<\"-1\"<<endl;\n    return 0;\n  }\n  \n  total = 0;\n  dfs( ex );\n  printf(\"%.10f\\n\",ans-total);\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nbool equals(double a, double b) {\n  return abs(a - b) < eps;\n}\n\nnamespace std {\n  bool operator < (const P &a, const P &b) {\n    if(!equals(a.real(), b.real())) return a.real() < b.real();\n    if(!equals(a.imag(), b.imag())) return a.imag() < b.imag();\n    return false;\n  }\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nbool isParallel(P a, P b) {\n  return equals(cross(a, b), 0.0);\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a, b) > eps) return 1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a, b) < -eps) return 2;\n  if(norm(b) - norm(a) > eps) return -2;\n  return 0;\n}\n\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t   ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1) / cross(b, a);\n}\n\n///////////////////////////////////////////////////////////////////////////\n\nstruct Edge {\n  int to; double w;\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nint getId(P p, map<P, int> &m) {\n  if(!m.count(p)) {\n    int tmp = m.size();\n    m[p] = tmp;\n  }\n  return m[p];\n}\n\nint getId(P p, map<P, int> &m, map<int, P> &r) {\n  r[getId(p, m)] = p;\n  return m[p];\n}\n\nint main() {\n  int N, M;\n  cin >> N >> M;\n  vector<P> X(N), Y(N), Z(M);\n  P src, dst;\n  map<P, int> id;\n  map<int, P> rid;\n\n  for(int i = 0; i < N; ++i) {\n    cin >> X[i].real() >> X[i].imag() >> Y[i].real() >> Y[i].imag();\n    getId(X[i], id, rid);\n    getId(Y[i], id, rid);\n  }\n  for(int i = 0; i < M; ++i) {\n    cin >> Z[i].real() >> Z[i].imag();\n    getId(Z[i], id, rid);\n  }\n  cin >> src.real() >> src.imag();\n  getId(src, id, rid);\n  cin >> dst.real() >> dst.imag();\n  getId(dst, id, rid);\n\n  for(int i = 0; i < N; ++i) {\n    for(int j = i+1; j < N; ++j) {\n      if(isIntersect(X[i], Y[i], X[j], Y[j]) &&\n\t !isParallel(X[i] - Y[i], X[j] - Y[j])) {\n\tP p = getCrossP(X[i], Y[i], X[j], Y[j]);\n\tgetId(p, id, rid);\n      }\n    }\n  }\n\n  int V = id.size();\n  Graph G(V);\n\n  for(int i = 0; i < N; ++i) {\n    set<P> s;\n    vector<pair<double, P> > v;\n    s.insert(X[i]);\n    s.insert(Y[i]);\n    v.push_back(make_pair(0.0, X[i]));\n    v.push_back(make_pair(norm(Y[i] - X[i]), Y[i]));\n    for(int j = i+1; j < N; ++j) {\n      if(isIntersect(X[i], Y[i], X[j], Y[j]) &&\n\t !isParallel(X[i] - Y[i], X[j] - Y[j])) {\n\tP p = getCrossP(X[i], Y[i], X[j], Y[j]);\n\tif(s.count(p)) continue;\n\ts.insert(p);\n\tv.push_back(make_pair(norm(p - X[i]), p));\n      }\n    }\n    for(int j = 0; j < M; ++j) {\n      if(ccw(X[i], Y[i], Z[j]) == 0 && !s.count(Z[j])) {\n\ts.insert(Z[j]);\n\tv.push_back(make_pair(norm(Z[j] - X[i]), Z[j]));\n      }\n    }\n\n    if(ccw(X[i], Y[i], src) == 0 && !s.count(src)) {\n      s.insert(src);\n      v.push_back(make_pair(norm(src - X[i]), src));\n    }\n    if(ccw(X[i], Y[i], dst) == 0 && !s.count(dst)) {\n      s.insert(dst);\n      v.push_back(make_pair(norm(dst - X[i]), dst));\n    }\n    sort(v.begin(), v.end());\n    for(int j = 0; j+1 < v.size(); ++j) {\n      int a = getId(v[j].second, id);\n      int b = getId(v[j+1].second, id);\n      double w = abs(v[j].second - v[j+1].second);\n      G[a].push_back((Edge){b, w});\n      G[b].push_back((Edge){a, w});\n    }\n  }\n  if(0) {\n  cout << V << endl;\n  for(int i = 0; i < V; ++i) {\n    cout << rid[i] << \":\";\n    for(int j = 0; j < G[i].size(); ++j) {\n      if(j) cout << \",\";\n      cout << rid[G[i][j].to];\n    }\n    cout << endl;\n  }\n  }\n\n  try {\n    vector<int> F(V), F2(V);\n    for(int i = 0; i < M; ++i) {\n      F[getId(Z[i], id)] = 1;\n    }\n    set<pair<int, int> > vis;\n    queue<pair<int, int> > que;\n    \n    double res = 0;\n    que.push(make_pair(getId(dst, id), -1));\n    int isrc = getId(src, id);\n    while(que.size()) {\n      pair<int, int> p = que.front();\n      que.pop();\n      int v = p.first;\n      int prev = p.second;\n      for(int i = 0; i < G[v].size(); ++i) {\n\tpair<int, int> np(G[v][i].to, v);\n\tif(np.first == isrc) throw 0;\n\tif(vis.count(np)) continue;\n\tres += G[v][i].w;\n\tvis.insert(np);\n\tswap(np.first, np.second);\n\tvis.insert(np);\n\tswap(np.first, np.second);\n\tif(F[np.first]) {\n\t  F2[np.first] = 1;\n\t  continue;\n\t}\n\tque.push(np);\n      }\n    }\n    double res2 = 0;\n    que.push(make_pair(isrc, -1));\n    while(que.size()) {\n      pair<int, int> p = que.front();\n      que.pop();\n      int v = p.first;\n      int prev = p.second;\n      for(int i = 0; i < G[v].size(); ++i) {\n\tpair<int, int> np(G[v][i].to, v);\n\tif(vis.count(np)) continue;\n\tres2 += G[v][i].w;\n\tvis.insert(np);\n\tswap(np.first, np.second);\n\tvis.insert(np);\n\tswap(np.first, np.second);\n\tif(F2[np.first]) continue;\n\tque.push(np);\n      }\n    }\n    res2 = -res2;\n    for(int i = 0; i < N; ++i) {\n      res2 += abs(X[i] - Y[i]);\n    }\n    printf(\"%.10f\\n\", res2);\n  } catch(...) {\n    printf(\"-1\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    // if (abs(a-b)<EPS) return 0;\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L() {}\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nGraph segmentArrangement(const vector<L> &ss, vector<P> &ps) {\n  for (int i = 0; i < ss.size(); ++i) { // O(n^2)\n    ps.push_back( ss[i][0] );\n    ps.push_back( ss[i][1] );\n    for (int j = i+1; j < ss.size(); ++j)\n      if (intersectSS(ss[i], ss[j])) {\n        ps.push_back( crosspoint(ss[i], ss[j]) );\n      }\n  }\n  sort(ALL(ps)); ps.erase(unique(ALL(ps)), ps.end());\n\n  Graph g(ps.size());\n  for (int i = 0; i < ss.size(); ++i) {\n    vector< pair<double, int> > list;\n    for (int j = 0; j < ps.size(); ++j)\n      if (intersectSP(ss[i], ps[j]))\n        list.push_back(make_pair(norm(ss[i][0]-ps[j]), j));\n    sort(ALL(list));\n    for (int j = 0; j+1 < list.size(); ++j) {\n      int a = list[j].second, b = list[j+1].second;\n      g[a].push_back( Edge(a, b, abs(ps[a]-ps[b])) );\n      g[b].push_back( Edge(b, a, abs(ps[a]-ps[b])) );\n    }\n  }\n  return g;\n}\n\nint pp[1002];\nint rp[1000000];\n\nbool flag[1000];\nbool visited[1000000];\nint xv[1000],yv[1000];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<L> ss;\n  double sum = 0;\n  REP(i,n) {\n    int x1,y1,x2,y2;\n    cin>>x1>>y1>>x2>>y2;\n    ss.push_back(L(P(x1,y1),P(x2,y2)));\n    sum += abs(P(x1,y1)-P(x2,y2));\n  }\n  vector<P> ps;\n  REP(i,m) {\n    cin >> xv[i] >> yv[i];\n  }\n  cin>>xv[m]>>yv[m]>>xv[m+1]>>yv[m+1];\n  REP(i,m+2) {\n    ps.push_back(P(xv[i],yv[i]));\n  }\n  Graph g = segmentArrangement(ss,ps);\n  memset(rp,-1,sizeof(rp));\n  REP(i,m+2) {\n    REP(j,ps.size()) {\n      if (abs(P(xv[i],yv[i]) - ps[j]) < EPS) {\n        pp[i] = j;\n        rp[j] = i;\n        break;\n      }\n    }\n  }\n  queue<int> Q;\n  Q.push(pp[m+1]);\n  while(!Q.empty()) {\n    int now = Q.front(); Q.pop();\n    visited[now] = 1;\n\n    //cout << now << \" \" << ps[now] << endl;\n    \n    if (rp[now] != -1 && rp[now] < m) {\n      flag[rp[now]] = 1;\n      continue;\n    }\n    if (rp[now] == m) {\n      puts(\"-1\");\n      return 0;\n    }\n    FOR(it, g[now]) {\n      //cout << \" \" << it->dst << endl;\n      if (!visited[it->dst]) {\n        Q.push(it->dst);\n      }\n    }\n  }\n  memset(visited,0,sizeof(visited));\n  Q.push(pp[m]);\n  map<pii,bool> mp;\n  double ans = 0;\n  while(!Q.empty()) {\n    int now = Q.front(); Q.pop();\n    visited[now] = 1;\n    if (rp[now]!=-1 && rp[now]<m && flag[rp[now]]) continue;\n    FOR(it, g[now]) {\n      int a = min(now,it->dst);\n      int b = max(now, it->dst);\n      if (!mp.count(pii(a,b))) {\n        mp[pii(a,b)] = 1;\n        ans += it->weight;\n      }\n      if (!visited[it->dst]) {\n        Q.push(it->dst);\n      }\n    }\n  }\n  printf(\"%.10f\\n\", sum-ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\n#include <map>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return !EQ(a.X,b.X) ? a.X<b.X : a.Y+EPS<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\nbool intersectSS(const L& a, const L& b){\n    return ( ccw(a[0],a[1],b[0]) *ccw(a[0],a[1],b[1]) <= 0 ) &&\n        ( ccw(b[0],b[1],a[0]) *ccw(b[0],b[1],a[1]) <= 0 );\n}\nbool intersectSP(const L& s, const P &p){\n    return abs(cross(s[0]-p, s[1]-p))<EPS  && dot(s[0]-p, s[1]-p)<EPS;\n}\n\nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\n\npair<vector<vector<int> >, VP> arrangement(const vector<L> &l, const VP &p){\n    vector<VP> cp(l.size());\n    VP plist = p;\n    for(int i=0; i<(int)l.size(); i++){\n        for(int j=i+1; j<(int)l.size(); j++){\n            if(!isParallel(l[i], l[j]) && intersectSS(l[i], l[j])){\n                P cpij = crosspointLL(l[i], l[j]);\n                cp[i].push_back(cpij);\n                cp[j].push_back(cpij);\n                plist.push_back(cpij);\n            }\n        }\n        for(int j=0; j<(int)p.size(); j++){\n            if(intersectSP(l[i], p[j])){\n                cp[i].push_back(p[j]);\n            }\n        }\n        cp[i].push_back(l[i][0]);\n        cp[i].push_back(l[i][1]);\n        plist.push_back(l[i][0]);\n        plist.push_back(l[i][1]);\n        sort(cp[i].begin(), cp[i].end());\n        cp[i].erase(unique(cp[i].begin(), cp[i].end()), cp[i].end());\n    }\n    sort(plist.begin(), plist.end());\n    plist.erase(unique(plist.begin(), plist.end()), plist.end());\n\n    int n = plist.size();\n    map<P, int> conv;\n    for(int i=0; i<n; i++){\n        conv[plist[i]] = i;\n    }\n    vector<vector<int> > adj(n);\n    for(int i=0; i<(int)cp.size(); i++){\n        for(int j=0; j<(int)cp[i].size()-1; j++){\n            int jidx = conv[cp[i][j]];\n            int jp1idx = conv[cp[i][j+1]];\n            adj[jidx].push_back(jp1idx);\n            adj[jp1idx].push_back(jidx);\n        }\n    }\n    for(int i=0; i<n; i++){\n        sort(adj[i].begin(), adj[i].end());\n        adj[i].erase(unique(adj[i].begin(), adj[i].end()), adj[i].end());\n    }\n    return make_pair(adj, plist);\n}\n\nvoid dfs(int pos, int sidx, vector<bool> &used, vector<vector<int> > &adj, VP &plist, VP &v){\n    if(used[pos]) return;\n    used[pos] = true;\n    if(pos == sidx) return;\n    auto itr = lower_bound(v.begin(), v.end(), plist[pos]);\n    if(itr!=v.end() && *itr==plist[pos]) return;\n    for(int next: adj[pos]){\n        dfs(next, sidx, used, adj, plist, v);\n    }\n}\n\nvoid solve(int pos, vector<bool> &used, vector<vector<int> > &adj, VP &plist, vector<L> &llist){\n    if(used[pos]) return;\n    used[pos] = true;\n    for(int next: adj[pos]){\n        solve(next, used, adj, plist, llist);\n        P p=plist[pos], q=plist[next];\n        if(q < p) swap(p, q);\n        llist.push_back(L(p, q));\n    }\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<L> ls(n);\n    double totallength = 0;\n    for(int i=0; i<n; i++){\n        double xs,ys,xt,yt;\n        cin >> xs >> ys >> xt >> yt;\n        ls[i] = L(P(xs, ys), P(xt, yt));\n        totallength += abs(ls[i][1] -ls[i][0]);\n    }\n    VP v(m);\n    for(int i=0; i<m; i++){\n        double x,y;\n        cin >> x >> y;\n        v[i] = P(x, y);\n    }\n    sort(v.begin(), v.end());\n    double sx,sy,rx,ry;\n    cin >> sx >> sy >> rx >> ry;\n    P source(sx, sy), repair(rx, ry);\n\n    VP ps = v;\n    ps.push_back(source);\n    ps.push_back(repair);\n    pair<vector<vector<int> >, VP> ret = arrangement(ls, ps);\n    vector<vector<int> > &adj = ret.first;\n    VP &plist = ret.second;\n    int sidx=-1,ridx=-1;\n    for(int i=0; i<(int)plist.size(); i++){\n        if(plist[i] == source) sidx = i;\n        if(plist[i] == repair) ridx = i;\n    }\n    vector<bool> used(plist.size(), false);\n    dfs(ridx, sidx, used, adj, plist, v);\n    if(used[sidx]){\n        cout << -1 << endl;\n    }else{\n        vector<L> llist;\n        solve(sidx, used, adj, plist, llist);\n        sort(llist.begin(), llist.end());\n        llist.erase(unique(llist.begin(), llist.end()), llist.end());\n        double ans = totallength;\n        for(int i=0; i<(int)llist.size(); i++){\n            ans -= abs(llist[i][1] -llist[i][0]);\n        }\n        cout << fixed << setprecision(10);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nconstexpr int INF = 1e9;\nusing ld = long double;\nusing weight = ld;\n\nstruct edge {\n    int from, to;\n    weight cost;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nvoid add_edge(graph& g, int from, int to, weight cost) {\n    g[from].push_back(edge{from, to, cost});\n    g[to].push_back(edge{to, from, cost});\n}\n\nusing ld = long double;\n\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = std::acos(-1.0);\n\n\nnamespace geometry2d {\n\n\nusing point = std::complex<long double>;\nusing polygon = std::vector<point>;\n\n\nbool eq(long double a, long double b) {\n    return (std::abs(a-b) < eps);\n}\n\nlong double dot(point a, point b) {\n    return std::real(std::conj(a) * b);\n}\n\nlong double cross(point a, point b) {\n    return std::imag(std::conj(a) * b);\n}\n\n\nclass segment {\npublic:\n    segment()\n        : a(point(0, 0)),\n          b(point(0, 0))\n    {}\n    segment(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n\n    point a, b;\n};\n\nclass line {\npublic:\n    line()\n        : a(point(0, 0)), b(point(0, 0))\n    {}\n    line(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n    line(segment s)\n        : a(s.a), b(s.b)\n    {}\n\n    point a, b;\n};\n\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps)           return 1;  // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps)          return -1; // a -> b -> c : clockwise\n    if(dot(b, c) < 0)               return 2;  // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\n\nbool isis_ll(line l, line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(line l, point p) {\n    return (std::abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\npoint is_ss(segment s1, segment s2) {\n    assert(isis_ss(s1, s2));\n    point sv = s1.b - s1.a, tv = s2.b - s2.a;\n    if(cross(sv, tv) == 0) {\n        if(std::abs(s1.a - s2.a) < eps || std::abs(s1.a - s2.b) < eps) {\n            return s1.a;\n        } else {\n            return s1.b;\n        }\n    } else {\n        return is_ll(line(s1), line(s2));\n    }\n}\n\nlong double dist_lp(line l, point p) {\n    return std::abs(p - proj(l, p));\n}\n\nlong double dist_ll(line l, line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nlong double dist_ls(line l, segment s) {\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nlong double dist_sp(segment s, point p) {\n    point r = proj(line(s), p);\n    return isis_sp(s, r) ? std::abs(r - p) : std::min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nlong double dist_ss(segment s, segment t) {\n    if(isis_ss(s, t)) return 0;\n    long double d1 = std::min(dist_sp(s, t.a), dist_sp(s, t.b));\n    long double d2 = std::min(dist_sp(t, s.a), dist_sp(t, s.b));\n    return std::min(d1, d2);\n}\n\nstd::vector<point> unique(std::vector<point> ps) {\n    std::sort(std::begin(ps), std::end(ps), [](auto const& a, auto const& b) -> bool {\n        return (std::real(a - b) * 1.347589 + std::imag(a - b)) > 0;\n    });\n    std::vector<point> res;\n    for(auto& p : ps) {\n        if(res.empty() || abs(res.back() - p) > eps) {\n            res.push_back(p);\n        }\n    }\n    return res;\n}\n\ngraph segment_arrangement(std::vector<segment> const& s, std::vector<point> const& p) {\n    int m = s.size();\n    int n = p.size();\n    graph g(n);\n    for(int i = 0; i < m; ++i) {\n        std::vector<pair<ld, int>> v;\n        for(int j = 0; j < n; ++j) {\n            if(isis_sp(s[i], p[j])) {\n                v.emplace_back(std::abs(s[i].a - p[j]), j);\n            }\n        }\n        std::sort(std::begin(v), std::end(v));\n        for(int j = 0; j < (int)v.size() - 1; ++j) {\n            int src = v[j].second, dest = v[j + 1].second;\n            add_edge(g, src, dest, std::abs(p[src] - p[dest]));\n        }\n    }\n    return g;\n}\n\n} // namespace geometry2d\n\nusing namespace geometry2d;\n\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<segment> s(N);\n    ld res = 0;\n    for(int i = 0; i < N; ++i) {\n        ld x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        s[i].a = point(x1, y1);\n        s[i].b = point(x2, y2);\n        res += abs(s[i].a - s[i].b);\n    }\n\n    vector<point> sp;\n    vector<point> p;\n    for(int i = 0; i < M; ++i) {\n        ld x, y;\n        cin >> x >> y;\n        sp.emplace_back(x, y);\n        p.emplace_back(x, y);\n    }\n    for(int i = 0; i < N; ++i) {\n        p.push_back(s[i].a);\n        p.push_back(s[i].b);\n        for(int j = i + 1; j < N; ++j) {\n            if(isis_ss(s[i], s[j])) {\n                p.push_back(is_ss(s[i], s[j]));\n            }\n        }\n    }\n    ld sx, sy, rx, ry;\n    cin >> sx >> sy >> rx >> ry;\n    p.emplace_back(sx, sy);\n    p.emplace_back(rx, ry);\n    p = unique(p);\n    vector<bool> stop(p.size());\n    int source, dest;\n    for(int i = 0; i < (int)p.size(); ++i) {\n        for(int j = 0; j < (int)sp.size(); ++j) {\n            if(abs(p[i] - sp[j]) < eps) {\n                stop[i] = true;\n            }\n        }\n        if(abs(p[i] - point(sx, sy)) < eps) {\n            source = i;\n        }\n        if(abs(p[i] - point(rx, ry)) < eps) {\n            dest = i;\n        }\n    }\n    auto g = segment_arrangement(s, p);\n    queue<int> que;\n    que.push(dest);\n    vector<int> vis(p.size());\n    vis[dest] = 1;\n    while(!que.empty()) {\n        int v = que.front();\n        que.pop();\n        for(auto& e : g[v]) {\n            if(vis[e.to]) {\n                continue;\n            }\n            vis[e.to] = 1;\n            if(!stop[e.to]) {\n                que.push(e.to);\n            }\n        }\n    }\n    if(vis[source]) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    que.push(source);\n    vis[source] = 2;\n    set<pii> used;\n    while(!que.empty()) {\n        int v = que.front();\n        que.pop();\n        for(auto& e : g[v]) {\n            assert(0 <= e.to && e.to < g.size());\n            if(used.count(make_pair(v, e.to)) == 0) {\n                res -= e.cost;\n                used.insert(make_pair(v, e.to));\n                used.insert(make_pair(e.to, v));\n            }\n            if(vis[e.to]) {\n                continue;\n            }\n            vis[e.to] = 2;\n            que.push(e.to);\n        }\n    }\n    cout << fixed << setprecision(10) << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// implement 43min\n// debug 17min\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\ntypedef double Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight != rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid PrintMatrix(const Matrix &matrix) {\n  for (int y = 0; y < (int)matrix.size(); y++) {\n    for (int x = 0; x < (int)matrix[y].size(); x++) {\n      printf(\"%.2lf \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\n#include <complex>\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nstatic const double INF = 1e+10;\n\n#define CURR(P, i) (P[i])\n#define NEXT(P, i) (P[(i + 1) % P.size()])\n\nstruct Line : public vector<Point> {\n  Line() {;}\n  Line(Point a, Point b) { push_back(a); push_back(b); }\n};\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (fabs(lhs.real() - rhs.real()) < EPS * 10 &&\n        fabs(lhs.imag() - rhs.imag()) < EPS * 10) { return false; }\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag() : lhs.real() < rhs.real();\n  }\n}\n\ninline double cross(const Point &a, const Point &b) {\n  return imag(conj(a) * b);\n}\n\ninline double dot(const Point &a, const Point &b) {\n  return real(conj(a) * b);\n}\n\ninline int ccw(Point a, Point b, Point c) {\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) { return 1; }\n  if (cross(b, c) < 0) { return -1; }\n  if (dot(b, c) < 0) { return 2; }\n  if (norm(b) < norm(c)) { return -2; }\n  return 0;\n}\n\n\nbool intersectLL(const Line &l, const Line &m) {\n  return abs(cross(l[1] - l[0], m[1] - m[0])) > EPS ||\n    abs(cross(l[1] - l[0], m[0] - l[0])) < EPS;\n}\n\nbool intersectLS(const Line &l, const Line &s) {\n  return cross(l[1] - l[0], s[0] - l[0]) *\n    cross(l[1] - l[0], s[1] - l[0]) < EPS;\n}\n\nbool intersectLP(const Line &l, const Point &p) {\n  return abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\n\nbool intersectSS(const Line &s, const Line &t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n\nbool intersectSP(const Line &s, const Point &p) {\n  return abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS;\n}\n\nPoint crosspointSS(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) {\n    //assert(false);\n    if (intersectSP(l, m[0])) { return m[0]; }\n    if (intersectSP(l, m[1])) { return m[1]; }\n    if (intersectSP(m, l[0])) { return l[0]; }\n    if (intersectSP(m, l[1])) { return l[1]; }\n    return m[0];\n  }\n  if (abs(A) < EPS) { assert(false); }\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble Area(const Polygon &p) {\n  double ret = 0;\n  for (int i = 0; i < (int)p.size(); i++) {\n    ret += cross(CURR(p, i), NEXT(p, i));\n  }\n  //cout << ret / 2.0 << endl;\n  assert(ret > -EPS);\n  return ret / 2.0;\n}\n\n\nstruct ArrangmentEdge {\n  int src;\n  int dest;\n  Weight weight;\n  ArrangmentEdge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const ArrangmentEdge &rhs) const {\n    return dest < rhs.dest;\n  }\n};\nstruct ArrangmentData {\n  vector<Point> ps;\n  map<Point, int> mapto;\n  Graph g;\n};\nArrangmentData Arrangment(const vector<Line> &ls, const vector<Point> &ps) {\n  // Constraint Check\n  {\n    // Weight should be double\n    Weight w = 0.5;\n    assert(w == 0.5);\n    // near Point should be used as same point\n    Point p1(0, 0);\n    Point p2(EPS, EPS);\n    assert(!(p1 < p2) && !(p2 < p1));\n  }\n\n  int l = ls.size();\n  int n = 0;\n  ArrangmentData ret;\n  // Push Point\n  for (int i = 0; i < l; i++) {\n    REP(j, 2) {\n      if (ret.mapto.count(ls[i][j])) { continue; }\n      ret.ps.push_back(ls[i][j]);\n      ret.mapto[ls[i][j]] = n++;\n    }\n  }\n  for (int i = 0; i < (int)ps.size(); i++) {\n    if (ret.mapto.count(ps[i])) { continue; }\n    ret.ps.push_back(ps[i]);\n    ret.mapto[ps[i]] = n++;\n  }\n\n  // Crosspoint Push\n  for (int i = 0; i < l; i++) {\n    for (int j = i + 1; j < l; j++) {\n      Line s1 = ls[i];\n      Line s2 = ls[j];\n      if (intersectSS(s1, s2)) {\n        Point p = crosspointSS(s1, s2);\n        if (ret.mapto.count(p)) { continue; }\n        ret.ps.push_back(p);\n        ret.mapto[p] = n++;\n      }\n    }\n  }\n\n  // Make Graph\n  vector<set<ArrangmentEdge> > tempG(n);\n  for (int i = 0; i < l; i++) {\n    Line s = ls[i];\n    vector<pair<double, int> > onLine;\n    for (int j = 0; j < n; j++) {\n      if (intersectSP(s, ret.ps[j])) {\n        onLine.push_back(make_pair(abs(ret.ps[j] - s[0]), j));\n      }\n    }\n    sort(onLine.begin(), onLine.end());\n    for (int j = 0; j < (int)onLine.size() - 1; j++) {\n      int from = onLine[j].second;\n      int to = onLine[j + 1].second;\n      double dist = fabs(onLine[j].first - onLine[j + 1].first);\n      tempG[from].insert(ArrangmentEdge(from, to, dist));\n      tempG[to].insert(ArrangmentEdge(to, from, dist));\n      //cout << from << \" \" << to << \" \" << ret.ps[from] << \" \" << ret.ps[to] << endl;\n    }\n  }\n\n  // Convert Graph\n  ret.g = Graph(n);\n  for (int i = 0; i < n; i++) {\n    for (set<ArrangmentEdge>::iterator it = tempG[i].begin(); it != tempG[i].end(); it++) {\n      ret.g[i].push_back(Edge(it->src, it->dest, it->weight));\n    }\n  }\n  return ret;\n}\n\n//============================================================\n\nint n, m;\nvector<Line> ls;\nvector<Point> stop;\nGraph g;\nbool isstop[200000];\nbool visited[2][200000];\n\ndouble Bfs(int start, int state) {\n  double ret = 0.0;\n  queue<int> que;\n  que.push(start);\n  while (!que.empty()) {\n    int from = que.front();\n    que.pop();\n    if (visited[state][from]) { continue; }\n    if (state == 1 && visited[0][from]) { continue; }\n    visited[state][from] = true;\n    if (state == 0 && isstop[from]) { continue; }\n    //cout << start << \" \" << from << endl;\n    FORIT(it, g[from]) {\n      int to = it->dest;\n      if (visited[state][to]) { continue; }\n      //cout << from << \" \" << to << \" \" << state << endl;\n      ret += it->weight;\n      que.push(to);\n    }\n  }\n  return ret;\n}\n\n\nint main() {\n  while (scanf(\"%d %d\", &n, &m) > 0) {\n    MEMSET(isstop, false);\n    MEMSET(visited, false);\n    Point start;\n    Point end;\n    // Init & Input\n    ls = vector<Line>(n);\n    stop = vector<Point>(m);\n    REP(i, n) {\n      double x1, y1, x2, y2;\n      scanf(\"%lf %lf %lf %lf\", &x1, &y1, &x2, &y2);\n      ls[i] = Line(Point(x1, y1), Point(x2, y2));\n    }\n    REP(i, m) {\n      double x, y;\n      scanf(\"%lf %lf\", &x, &y);\n      stop[i] = Point(x, y);\n    }\n    {\n      double x1, y1, x2, y2;\n      scanf(\"%lf %lf %lf %lf\", &x1, &y1, &x2, &y2);\n      start = Point(x1, y1);\n      end = Point(x2, y2);\n    }\n    stop.push_back(start);\n    stop.push_back(end);\n    ArrangmentData data = Arrangment(ls, stop);\n    stop.pop_back();\n    stop.pop_back();\n    g = data.g;\n    int s = data.mapto[start];\n    int t = data.mapto[end];\n    isstop[s] = true;\n    FORIT(it, stop) {\n      isstop[data.mapto[*it]] = true;\n    }\n    double ans = 0.0;\n    REP(i, g.size()) {\n      FORIT(it, g[i]) {\n        ans += it->weight / 2.0;\n      }\n    }\n    Bfs(t, 0);\n    if (visited[0][s]) {\n      puts(\"-1\");\n      continue;\n    }\n    ans -= Bfs(s, 1);\n    printf(\"%.8f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef complex<double> V;\ntypedef vector<P> vecP;\ntypedef pair<P,P> L;\ntypedef pair<P,P> S;\ntypedef pair<P,double> C;\nconst double eps=1e-8;\nconst double PI=acos(-1);\nconst double PI2=PI*2.0;\n \nnamespace std{\n  bool operator < (const P &a,const P &b){\n    return (a.real()!=b.real()?\n            a.real() <b.real():\n            a.imag() <b.imag());\n  }\n};\n \nV normal(V a){\n  assert( abs(a)>0 );\n  return a/abs(a);\n}\n \ndouble Sqrt( double x ){\n  if(x<0)return 0;\n  else return sqrt(x);\n}\n \nP Vector(L a){\n  return a.second-a.first;\n}\n \nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n \nbool eq(P a,P b){\n  return ( eq(a.real(),b.real()) && eq(a.imag(),b.imag()) );\n}\n \ndouble dot(P a,P b){\n  return real(b*conj(a));\n}\n \ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n \ndouble getArg(P a,P b){\n  return arg(b*conj(a));\n}\n \ndouble getTime(V a,V b){\n  assert( eq(cross(a,b),0) );\n  return ( dot(a,b) < 0 ? -1.0 : 1.0 ) * abs(b) / abs(a);\n}\n \n \nP project(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*real(c/b);\n}\n \nP reflect(P a,P b,P c){\n  b-=a,c-=a;\n  return a+b*conj(c/b);\n}\n \nint ccw(P a,P b,P c){\n  P ab=b-a,ac=c-a;\n  P k=ac*conj(ab);\n  if(k.imag()>0)return 1;\n  if(k.imag()<0)return -1;\n  if(k.real()<0)return 2;\n  if(abs(ab)<abs(ac))return -2;\n  return 0;\n}\n \nbool isParallel(P a,P b){\n  return eq(0, cross(a,b));\n}\n \nbool isParallel(S a,S b){\n  return eq(0, cross( Vector(a) , Vector(b) ) );\n}\n \nbool onLP(L l,P p){\n  P a=l.first, b=l.second;\n  return eq(0, cross(b-a,p-a));\n}\n \nbool onSP(S s,P p){\n  P a=s.first, b=s.second;\n  return eq( abs(b-a) , abs(a-p)+abs(b-p) );\n}\n \nbool isCrossSS(S s0,S s1){\n  P a=s0.first, b=s0.second;\n  P c=s1.first, d=s1.second;\n  int f0 = ccw(a,b,c) * ccw(a,b,d);\n  int f1 = ccw(c,d,a) * ccw(c,d,b);\n  return (f0<=0 && f1<=0);\n}\n \nbool isCrossLS(L l,S s){\n  P a=l.first, b=l.second;\n  P c=s.first, d=s.second;\n  return ( ccw(a,b,c) * ccw(a,b,d) <= 0 );\n}\n \ndouble distLP(L l,P p){\n  P a=l.first, b=l.second;\n  double res = cross(b-a,p-a) / abs(b-a);\n  return abs(res);\n}\n \ndouble distSP(S s,P p){\n  P a=s.first, b=s.second;\n  if( dot(b-a,p-a) < eps )return abs(p-a);\n  if( dot(a-b,p-b) < eps )return abs(p-b);\n  return distLP(s,p);\n}\n \ndouble distSS(S s0,S s1){\n  if( isCrossSS(s0,s1) )return 0;\n  double res0 = min( distSP( s0, s1.first ) , distSP(s0, s1.second) );\n  double res1 = min( distSP( s1, s0.first ) , distSP(s1, s0.second) );\n  return min(res0,res1);\n}\n \nP getCrossLL(L l0,L l1){\n  P a=l0.first, b=l0.second;\n  P c=l1.first, d=l1.second;\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n \n \n  \nint inPolygon(vecP &t,P p){\n  int n=t.size();\n  double sum=0;\n  for(int i=0;i<n;i++){\n    P a=t[i],b=t[(i+1==n?0:i+1)];\n    if( ccw(a,b,p)==0 )return 1;\n    sum+= getArg(a-p,b-p);\n  }\n  if( abs(sum) < eps )return 0;\n  else return 2;\n}\n\n\nstruct edge{\n  int to;\n  double cost;\n};\n\ntypedef vector<edge> Node;\ntypedef vector<Node> Graph;\nGraph G;\nmap<int,bool> isB;\nvector< P > points;\n\nvoid segments2graph( vector<S> segments ,vector<P> b ){\n\n  int n=segments.size();\n\n  sort(b.begin(),b.end());\n  \n  for(int i=0;i<(int)b.size();i++){\n    points.push_back(b[i]);\n  }\n  \n  for(int i=0;i<n;i++){\n    S si=segments[i];\n    points.push_back( si.first );\n    points.push_back( si.second );\n    for(int j=0;j<i;j++){\n      S sj=segments[j];\n      if( isCrossSS( si , sj ) && !isParallel( si, sj ) ){\n        points.push_back( getCrossLL(si,sj) );\n      }\n    }\n  }\n \n  sort(points.begin(), points.end());\n  points.erase( unique( points.begin(), points.end() ) , points.end() );\n   \n  G.resize(points.size());\n  \n  for(int i=0;i<(int)points.size();i++){\n    P p=points[i];\n    isB[i] = binary_search(b.begin(),b.end(), p);\n  }\n  \n  typedef pair< double , int > Pair;\n     \n  for(int i=0;i<n;i++){\n    S si=segments[i];\n    P sf=si.first, se=si.second;\n    vector< Pair > targets;\n    for(int j=0;j<(int)points.size();j++){\n      P pj=points[j];\n      // if( ccw( si.first, si.second, pj ) == 0 ){\n      if( onSP( si, pj ) ){\n        targets.push_back( Pair(getTime(se-sf ,pj-sf ), j ) );\n      }\n    }\n\n    for(int j=0;j<(int)targets.size();j++){\n      for(int k=0;k<j;k++){\n        Pair a=targets[j];\n        Pair b=targets[k];\n        P ap=points[ a.second ];\n        P bp=points[ b.second ];\n        G[a.second].push_back( (edge){ b.second , abs(ap-bp) } );\n        G[b.second].push_back( (edge){ a.second , abs(bp-ap) } );\n      }\n    }\n\n    /* \n    sort( targets.begin(), targets.end() );\n    for(int j=0;j+1<(int)targets.size();j++){\n      Pair a=targets[j];\n      Pair b=targets[j+1];\n      P ap=points[ a.second ];\n      P bp=points[ b.second ];\n      \n      G[a.second].push_back( (edge){ b.second , abs(ap-bp) } );\n      G[b.second].push_back( (edge){ a.second , abs(bp-ap) } );\n    }\n    */\n    \n  }\n\n}\n\nP input(){\n  double x,y;\n  cin>>x>>y;\n  return P(x,y);\n}\n\n\nmap<int,bool> visited;\ndouble total=0;\n\nmap< P , bool > counted;\n\nvoid dfs(int pos){\n  \n  if( isB[pos] )return;\n  if(visited[pos])return;\n  visited[pos]=true;\n  \n  for(int i=0;i<(int)G[pos].size();i++){\n    edge e=G[pos][i];\n    if( visited[e.to] || isB[e.to] )total+=e.cost;\n    else total += e.cost/2.0;\n  }\n  \n  for(int i=0;i<(int)G[pos].size();i++){\n    edge e=G[pos][i];\n    dfs(e.to);\n  }\n}\n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  vector< S > segments;\n  vector< P > bs;\n\n  double ans = 0;\n  \n  for(int i=0;i<N;i++){\n    P a=input();\n    P b=input();\n    segments.push_back( S(a,b) );\n    ans+= abs(a-b);\n  }\n  \n  for(int i=0;i<M;i++){\n    P a=input();\n    bs.push_back( b );\n  }\n  \n  P si,ti;\n  si=input();\n  ti=input();\n  points.push_back(si);\n  points.push_back(ti);\n  \n  segments2graph(segments,bs);\n\n  \n  int ex = lower_bound( points.begin(), points.end() , si ) - points.begin();\n  int root = lower_bound( points.begin(), points.end() , ti ) - points.begin();\n  \n  dfs(root);\n  \n  if( visited[ex] ){\n    cout<<\"-1\"<<endl;\n    return 0;\n  }\n  \n  total = 0;\n  dfs( ex );\n  printf(\"%.10f\\n\",ans-total);\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-8\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<double,int> P;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\ntypedef complex<double> C;\n\nconst double PI = 4*atan(1.0);\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n    bool operator > (const C a, const C b) {\n        return a.real() != b.real() ? a.real() > b.real() : a.imag() > b.imag();\n    }\n    //点をsetとかmapにつめたいとき(誤差を1e-10とか厳しくし過ぎるとバグる)\n    // bool operator<(const C a, const C b){\n    //     return abs(a.real()-b.real())>EPS ? a.real()<b.real()-EPS : a.imag()<b.imag()-EPS;\n    // }\n    bool operator==(const C a, const C b){\n        return (eq(a.real(),b.real()) && eq(a.imag(),b.imag()));\n    }\n    bool operator!=(const C a, const C b){\n        return !(a == b);\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(){}\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\n//条件付きsqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//正規化\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//角度(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//外積\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//内積\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nC rot(C c,double th)\n{\n    return c * C(cos(th),sin(th));\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\n//直線どうしの交差判定(同一直線はTrue)\nbool intersectLL(const L& l, const L& m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//直線と線分の交差判定(一点共有も交差と判定)\nbool intersectLS(const L& l, const L& s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//直線と点の交差(共有)判定\nbool intersectLP(const L& l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//線分どうしの交差判定(一点共有も交差と判定)\nbool intersectSS(const L& s, const L& t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//線分と点の交差(共有)判定\nbool intersectSP(const L& s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//直線および線分の交点\nC crosspointLL(const L& l, const L& m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //同一直線のとき\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//点pを直線l上に射影\nC projection(const L& l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//crosspointCLに使用する関数(命名が謎です)\ndouble gettime(C c1,C c2)\n{\n    return (dot(c1,c2) < 0 ? -1.0 : 1.0 ) * abs(c2) / abs(c1);\n}\n//円と直線の交点\nvector<C> crosspointCL(C c1,double r1,const L& l)\n{\n    C a=l[0], b=l[1];\n    vector<C> res;\n    C base=b-a,  target=projection(L(a,b),c1);\n    double length=abs(base), h=abs(c1-target);\n    base/=length;\n    if(r1+EPS<h)    return res;\n    double w=Sqrt(r1*r1-h*h);\n    double LL=gettime(normalize(b-a),target-a)-w,RR=LL+w*2.0;\n    res.push_back(a+base*LL);\n    if(eq(LL,RR))   return res;\n    res.push_back(a+base*RR);\n    return res;\n}\n\n//円と線分の交点\nvector<C> crosspointCS(C c1,double r1,const L& s)\n{\n    vector<C> tmp=crosspointCL(c1,r1,s);\n    vector<C> res;\n    rep(i,tmp.size()){\n        if(abs(s[1]-s[0]) == abs(s[0]-tmp[i])+abs(s[1]-tmp[i])){\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n//円どうしの交点\nL crosspointCC(const C c1, const double r1, const C c2, const double r2)\n{\n    C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n    C d = b*b-4.0*a*c;\n    C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n    return L(z1, z2);\n}\n//点pを直線lを軸として対称移動\nC reflection(const L &l, const C p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//点と直線の距離\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n//直線と直線の距離\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//直線と線分の距離\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//線分と点の距離\ndouble distanceSP(const L &s, const C p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//線分と線分の距離\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\ndouble getarea(C c1,double r1,C a,C b)\n{\n    C va=c1-a,vb=c1-b;\n    double A=abs(va),B=abs(vb);\n    double f=cross(va,vb),d=distanceSP(L(a,b),c1),res=0;\n    if(eq(f,0.0))   return 0;\n    if(A < r1+EPS && B < r1+EPS)    return f*0.5;\n    if(d>r1-EPS)    return r1*r1*M_PI*getarg(va,vb)/(2.0*M_PI);\n    vector<C> u=crosspointCS(c1,r1,L(a,b));\n    u.insert(u.begin(),a),u.push_back(b);\n    for(int i=0;i+1<(int)u.size();i++){\n        res+=getarea(c1,r1,u[i],u[i+1]);\n    }\n    return res;\n}\n//円と多角形の共通部分の面積\ndouble getcrossarea(const vector<C>& t,C c1,double r1)\n{\n    int n = (int)t.size();\n    if(n<3) return 0;\n    double res=0;\n    rep(i,n){\n      C a=t[i], b=t[(i+1)%n];\n      res += getarea(c1,r1,a,b);\n    }\n    return res;\n}\n//凸包を求める(O(nlogn))\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = (int)ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//凸性判定\nbool isconvex(const vector<C>& ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//多角形の符号付き面積(左回りが正)\ndouble area(const vector<C>& ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//凸多角形を直線で切断した時の左側の図形\nvector<C> convex_cut(const vector<C>& ps, const L& l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(L(A, B),l));\n    }\n    return Q;\n}\n//垂直二等分線\nL bisector(C a, C b){\n    C A = (a + b) * C(0.5, 0);\n    return L(A, A + rot(b - a, PI/2));\n}\n//ボロノイ図(正確にはvoronoi_cellを求める)\n//愚直であるため1つのvoronoi_cellを求めるのにかかる計算量がO(n^2)\nvector<C> voronoi(vector<C> poly, vector<C>& p, int s){\n    rep(i,(int)p.size()){\n        if (i != s){\n            poly = convex_cut(poly, bisector(p[s], p[i]));\n        }\n    }\n    return poly;\n}\n//点が多角形に包含されているか(0は含まれない,1は辺上,2は含まれる)\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//凸多角形の交差\nvector<C> convex_intersection(const vector<C>& ps,const vector<C>& qs)\n{\n\tvector<C> rs;\n\tint a = ps.size(),b = qs.size();\n\trep(i,a){\n        if(contains(qs,ps[i])){\n            rs.push_back(ps[i]);\n        }\n    }\n\trep(i,b){\n        if(contains(ps,qs[i])){\n            rs.push_back(qs[i]);\n        }\n    }\n    rep(i,a){\n        rep(j,b){\n            L l1(ps[i],ps[(i+1)%a]),l2(qs[j],qs[(j+1)%b]);\n\t\t    if(intersectSS(l1,l2)){\n                rs.push_back(crosspointLL(l1,l2));\n            }\n        }\n\t}\n\tsort(rs.begin(),rs.end());\n\trs.erase(unique(rs.begin(),rs.end()),rs.end());\n\tif(rs.size() <= 1){\n        return rs;\n    }\n\treturn convex_hull(rs);\n}\n//凸多角形の直径を求める(キャリパー法)\n//maxi,maxjが最遠点対となる\ndouble convex_diameter(const vector<C>& ps)\n{\n    const int n = (int)ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nbool compyx(C c1,C c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\ndouble closest_pair(C* a, int n)\n{\n    if(n<=1) return 1e100;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compyx);\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n//最近点対を求める\ndouble compute_shortest(C* a,int n)\n{\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n//2円の位置関係を示す(返り値は2円の間の共通接線の数)\nint getstateCC(C c1,double r1,C c2,double r2)\n{\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)return 4;\n    if(d>r1+r2-EPS)return 3;\n    if(d>abs(r1-r2)+EPS)return 2;\n    if(d>abs(r1-r2)-EPS)return 1;\n    return 0;\n}\n//点から円へ接線を引いた時の接点\nC gettangentCP_(C c1,double r1,C p,int flg){\n    C base=c1-p;\n    double w=Sqrt(norm(base)-r1*r1);\n    C s=p+base*C(w,r1 * flg)/norm(base)*w;\n    return s;\n}\n//点から円への接線\nvector<L> gettangentCP(C c1,double r1,C p){\n    vector<L> res;\n    C s=gettangentCP_(c1,r1,p,1);\n    C t=gettangentCP_(c1,r1,p,-1);\n    //点が円の周上にある場合\n    if(s == t){\n        res.push_back(L(s,s+(c1-p)*C(0,1)));\n    }else{\n        res.push_back(L(p,s));\n        res.push_back(L(p,t));\n    }\n    return res;\n}\n\n//2円の共通内接線を求める\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2円の共通外接線を求める\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2円の共通接線を求める(各直線の２点はそれぞれの円の接点)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\n\nstruct edge\n{\n    int to;\n    double cost;\n};\n\nmap<C,int> mp;\nvector<C> point;\nvector<vector<edge> > G;\nbool stop[MAX_N], visit[MAX_N];\nint prv[MAX_N], used[MAX_N];\nmap<pii,double> kp;\n\nvoid dfs(int u){\n    visit[u] = true;\n    if(used[u] >= 0){\n        each(e,G[u]){\n            if(e.to != used[u]){\n                kp[pii(min(u,e.to),max(u,e.to))] = e.cost;\n                if(!visit[e.to]){\n                    dfs(e.to);\n                }\n            }\n        }\n    }else{\n        each(e,G[u]){\n            kp[pii(min(u,e.to),max(u,e.to))] = e.cost;\n            if(!visit[e.to]){\n                dfs(e.to);\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    vector<L> line(n);\n    rep(i,n){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        if(C(c,d) < C(a,b)) swap(a,c),swap(b,d);\n        line[i] = L(C(a,b),C(c,d));\n        if(mp.find(C(a,b)) == mp.end()){\n            mp[C(a,b)] = len(point);\n            point.pb(C(a,b));\n        }\n        if(mp.find(C(c,d)) == mp.end()){\n            mp[C(c,d)] = len(point);\n            point.pb(C(c,d));\n        }\n    }\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        if(mp.find(C(a,b)) == mp.end()){\n            mp[C(a,b)] = len(point);\n            point.pb(C(a,b));\n        }\n        stop[mp[C(a,b)]] = true;\n    }\n    int a,b,c,d;\n    cin >> a >> b >> c >> d;\n    if(mp.find(C(a,b)) == mp.end()){\n        mp[C(a,b)] = len(point);\n        point.pb(C(a,b));\n    }\n    if(mp.find(C(c,d)) == mp.end()){\n        mp[C(c,d)] = len(point);\n        point.pb(C(c,d));\n    }\n    int s = mp[C(a,b)], t = mp[C(c,d)];\n    int V = len(point);\n    G.resize(len(point));\n    double al = 0,stream = 0;\n    rep(i,n){\n        vector<C> ten = line[i];\n        rep(j,len(point)){\n            if(intersectSP(line[i],point[j])){\n                ten.pb(point[j]);\n            }\n        }\n        rep(j,n){\n            if(j != i && intersectSS(line[i],line[j])){\n                ten.pb(crosspointLL(line[i],line[j]));\n            }\n        }\n        zip(ten);\n        vi val(len(ten));\n        rep(j,len(ten)){\n            val[j] = mp[ten[j]];\n        }\n        rep(j,len(ten)-1){\n            double dir = abs(ten[j+1]-ten[j]);\n            al += dir;\n            G[val[j]].pb((edge){val[j+1],dir}),G[val[j+1]].pb((edge){val[j],dir});\n        }\n    }\n    rep(i,V){\n        used[i] = -1;\n    }\n    vd dist(V,INF);\n    priority_queue<P,vp,greater<P> > que;\n    que.push(P(0,t));\n    while(!que.empty()){\n        P p = que.top();\n        que.pop();\n        if(dist[p.se] < p.fi) continue;\n        if(stop[p.se]){\n            used[p.se] = prv[p.se];\n            continue;\n        }\n        if(s == p.se){\n            printf(\"-1\\n\");\n            return 0;\n        }\n        each(e,G[p.se]){\n            if(dist[e.to] > p.fi+e.cost){\n                prv[e.to] = p.se;\n                dist[e.to] = p.fi+e.cost;\n                que.push(P(dist[e.to],e.to));\n            }\n        }\n    }\n    dfs(s);\n    each(it,kp){\n        stream += it.se;\n    }\n    printf(\"%.12lf\\n\",al-stream);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1), INF = 1e9;\n\ninline bool eq(double a, double b)\n{\n  return abs(b - a) < EPS;\n}\n\nstruct Point\n{\n  double x, y;\n\n  Point() {};\n\n  Point(double x, double y) : x(x), y(y) {};\n\n  Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n  Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n  Point operator*(const double b) const { return Point(x * b, y * b); }\n\n  Point operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n  Point operator/(const double b) const { return Point(x / b, y / b); }\n\n  bool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n  bool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n  double norm() { return x * x + y * y; }\n\n  double arg() { return atan2(x, y); }\n\n  double abs() { return sqrt(norm()); }\n\n  Point rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n  Point rotate90() { return Point(-y, x); }\n\n  friend ostream &operator<<(ostream &os, Point &p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n\n  friend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n};\n\n\ndouble cross(const Point &a, const Point &b)\n{\n  return a.x * b.y - a.y * b.x;\n}\n\ndouble dot(const Point &a, const Point &b)\n{\n  return a.x * b.x + a.y * b.y;\n}\n\nint ccw(const Point &a, Point b, Point c)\n{\n  b = b - a, c = c - a;\n  if(cross(b, c) > EPS) return +1;\n  if(cross(b, c) < -EPS) return -1;\n  if(dot(b, c) < 0) return +2;\n  if(b.norm() < c.norm()) return -2;\n  return 0;\n}\n\nstruct Segment\n{\n  Point a, b;\n\n  Segment() {};\n\n  Segment(Point a, Point b) : a(a), b(b) {};\n\n  friend ostream &operator<<(ostream &os, Segment &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n  friend istream &operator>>(istream &is, Segment &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n};\n\nbool Intersect(const Segment &s, const Point &p)\n{\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool Intersect(const Segment &s, const Segment &t)\n{\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n         ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nPoint Crosspoint(const Segment &l, const Segment &m)\n{\n  double A = cross(l.b - l.a, m.b - m.a);\n  double B = cross(l.b - l.a, l.b - m.a);\n  if(abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n  return m.a + (m.b - m.a) * B / A;\n}\n\nvector< vector< int > > SegmentArrangement(vector< Segment > &segs, vector< Point > &ps)\n{\n  vector< vector< int > > g;\n  const int N = (int) segs.size();\n  for(int i = 0; i < N; i++) {\n    ps.emplace_back(segs[i].a);\n    ps.emplace_back(segs[i].b);\n    for(int j = i + 1; j < N; j++) {\n      const Point p1 = segs[i].b - segs[i].a;\n      const Point p2 = segs[j].b - segs[j].a;\n      if(cross(p1, p2) == 0) continue;\n      if(Intersect(segs[i], segs[j])) {\n        ps.emplace_back(Crosspoint(segs[i], segs[j]));\n      }\n    }\n  }\n  sort(begin(ps), end(ps));\n  ps.erase(unique(begin(ps), end(ps)), end(ps));\n\n  const int M = (int) ps.size();\n  g.resize(M);\n  for(int i = 0; i < N; i++) {\n    vector< int > vec;\n    for(int j = 0; j < M; j++) {\n      if(Intersect(segs[i], ps[j])) {\n        vec.emplace_back(j);\n      }\n    }\n    for(int j = 1; j < vec.size(); j++) {\n      g[vec[j - 1]].push_back(vec[j]);\n      g[vec[j]].push_back(vec[j - 1]);\n    }\n  }\n  return (g);\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N, M;\n  cin >> N >> M;\n  vector< Segment > segs(N);\n  for(auto &s : segs) cin >> s;\n  vector< Point > stop(M);\n  for(auto &p : stop) cin >> p;\n  Point s, t;\n  cin >> s >> t;\n  vector< Point > ps(stop);\n  ps.emplace_back(s);\n  ps.emplace_back(t);\n  auto g = SegmentArrangement(segs, ps);\n\n  queue< int > que;\n  vector< bool > v(g.size(), false), u(g.size(), false), isstop(g.size(), false);\n  for(auto &p : stop) {\n    isstop[lower_bound(begin(ps), end(ps), p) - begin(ps)] = true;\n  }\n  int S = lower_bound(begin(ps), end(ps), s) - begin(ps);\n  int T = lower_bound(begin(ps), end(ps), t) - begin(ps);\n  que.emplace(T);\n  v[T] = true;\n\n  while(!que.empty()) {\n    int p = que.front();\n    que.pop();\n    if(p == S) {\n      cout << -1 << endl;\n      return (0);\n    }\n    for(auto &to : g[p]) {\n      if(v[to] || isstop[to]) continue;\n      v[to] = true;\n      que.emplace(to);\n    }\n  }\n\n  que.emplace(S);\n  u[S] = true;\n  double ret = 0.0;\n\n  while(!que.empty()) {\n    int p = que.front();\n    que.pop();\n    for(auto &to : g[p]) {\n      if(v[to]) continue;\n      ret -= (ps[to] - ps[p]).abs();\n      if(u[to]) continue;\n      que.emplace(to);\n      u[to] = true;\n    }\n  }\n  ret *= 0.5;\n  for(auto &seg : segs) ret += (seg.a - seg.b).abs();\n  cout << fixed << setprecision(12) << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a,b;\n\toperator line<T>()const{ return (line<T>){a,b}; }\n};\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<double> &S,const point<double> &p){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\n// 追加で頂点集合を指定できるように書き換え\nvoid arrangement(const vector< segment<double> > &S,const vector< point<double> > &plus,vector< point<double> > &P,vector<int> *G){\n\tint n=S.size();\n\tP=plus;\n\trep(i,n){\n\t\tP.push_back(S[i].a);\n\t\tP.push_back(S[i].b);\n\t\trep(j,i) if(intersect(S[i],S[j])) P.push_back(get_intersect(S[i],S[j]));\n\t}\n\tsort(P.begin(),P.end());\n\tP.erase(unique(P.begin(),P.end()),P.end());\nif(P.size()>100000) for(;;);\n\n\trep(i,n){\n\t\tvector<int> on;\n\t\trep(u,P.size()) if(cover(S[i],P[u])) on.push_back(u);\n\t\trep(j,(int)on.size()-1){\n\t\t\tint u=on[j],v=on[j+1];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tvector< segment<double> > pipe(n);\n\trep(i,n) scanf(\"%lf%lf%lf%lf\",&pipe[i].a.x,&pipe[i].a.y,&pipe[i].b.x,&pipe[i].b.y);\n\tvector< point<double> > stop(m);\n\trep(i,m) scanf(\"%lf%lf\",&stop[i].x,&stop[i].y);\n\tpoint<double> s,t;\n\tscanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&t.x,&t.y);\n\n\t// 追加の頂点集合\n\tvector< point<double> > plus=stop;\n\tplus.push_back(s);\n\tplus.push_back(t);\n\n\tvector< point<double> > P;\n\tstatic vector<int> G[100000];\n\tarrangement(pipe,plus,P,G);\n\n\tint N=P.size();\n\tstatic bool isstop[100000];\n\trep(i,m) rep(j,N) if(P[j]==stop[i]) isstop[j]=true;\n\n\tint s_id=find(P.begin(),P.end(),s)-P.begin();\n\tint t_id=find(P.begin(),P.end(),t)-P.begin();\n\n\t// t から stop をまたがずに行ける場所を見つける\n\tstatic bool vis[100000];\n\tvis[t_id]=true;\n\tqueue<int> Q; Q.push(t_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=true;\n\t\t\t\tif(!isstop[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(vis[s_id]){ puts(\"-1\"); return 0; }\n\n\t// s から vis を通らずに行ける場所を見つける\n\tstatic bool vis2[100000];\n\tvis2[s_id]=true;\n\tQ.push(s_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v]=true;\n\t\t\t\tif(!vis[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans=0;\n\trep(i,n) ans+=dist(pipe[i].a,pipe[i].b);\n\trep(u,N) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tif(u<v && vis2[u] && vis2[v]) ans-=dist(P[u],P[v]);\n\t}\n\tprintf(\"%.9f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\n\nconst double INF = 1e100;\nconst double EPS = 1e-8;\ntypedef complex<double> P; \ntypedef pair<P,P> L; \n\nnamespace std{ \n  bool operator < (const P& a, const P& b){ \n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b); \n  } \n} \ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1; //テ・ツ渉催ヲツ卍づィツィツ暗・ツ崢榲」ツつ?\n  if(cross(b,c) < -EPS) return -1; // テヲツ卍づィツィツ暗・ツ崢榲」ツつ?\n  if(dot(b,c) < -EPS) return 2; // c -- a -- b テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n  if(norm(b) < norm(c)) return -2; // a -- b -- c テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n  return 0; // a -- c -- b テ」ツ?ョテ、ツクツ?ァツ崢エテァツキツ?\n}\n\nbool isIntersect(L s1, L s2){\n    if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nmap<P,int> mf;\nint flag[1500];\nvector<vector<double> > segmentArrangement(vector<L> ss,vector<P> &ps){ \n  for(int i=0;i<ss.size();i++){ \n    ps.push_back(ss[i].first); \n    ps.push_back(ss[i].second); \n    for(int j=i+1;j<ss.size();j++) \n      if(isIntersect(ss[i],ss[j])) \n        ps.push_back(crossPoint(ss[i],ss[j])); \n  } \n  sort(ps.begin(),ps.end()); \n  ps.erase(unique(ps.begin(),ps.end()), ps.end()); \n \n  vector<vector<double> > G(ps.size(),vector<double>(ps.size(),INF)); \n  for(int i=0;i<(int)ps.size();i++){\n    flag[i] = mf[ps[i]];\n  }\n  for(int i=0;i<ss.size();i++){ \n    vector<pair<double,int> > list; \n    for(int j=0;j<ps.size();j++) \n      if(isIntersectSP(ss[i],ps[j]))  \n        list.push_back(make_pair(norm(ss[i].first-ps[j]), j)); \n    sort(list.begin(),list.end()); \n    for(int j=0;j<list.size()-1;j++){ \n      int a = list[j].second; \n      int b = list[j+1].second; \n      G[a][b] = abs(ps[a] - ps[b]); \n      G[b][a] = abs(ps[a] - ps[b]); \n    } \n  } \n  return G; \n} \n \nbool mem[1500][1500];\ndouble solve(const vector<vector<double> >& G){\n  int s,t;\n  queue<int> q;\n  int used[1500]={};\n  for(int i=0;i<(int)G.size();i++){\n    if(flag[i] == 2 ) s = i;\n    if(flag[i] == 3 ) t = i;   \n  }\n  q.push( t );\n  used[t] = true;\n  double res = 0.0;\n  while( !q.empty() ){\n    int p = q.front(); q.pop();\n    //       cout << p << endl;\n    if( flag[p] == 1) continue;\n    if( p == s ) return -1.0;\n    for(int i=0;i<(int)G[p].size();i++){\n      if( G[p][i] > INF/10 ) continue;\n      if( used[i] ) continue;\n      used[i] = true;\n      q.push( i );\n    }\n  }\n\n  q.push( s );\n  used[s] = true;\n  while( !q.empty() ){\n    int p = q.front(); q.pop();\n    for(int i=0;i<(int)G[p].size();i++){\n      if( G[p][i] > INF/10 ) continue;\n      if(mem[p][i]) continue;\n      res -= G[p][i];\n      mem[p][i] = true;\n      mem[i][p]  = true;\n      if( used[i] ) continue;\n      used[i] = true;\n      q.push( i );\n    }\n  }\n  for(int i=0;i<(int)G.size();i++)\n    for(int j=i+1;j<(int)G[i].size();j++)\n      if( G[i][j] < INF/10 ) res += G[i][j];\n\n  return res;\n}\n\nint main(){\n  vector<L> ss;\n  vector<P> ps;\n  cin >> N >> M;\n  for(int i=0;i<N;i++){\n    int x1,y1,x2,y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    ss.push_back( L(P(x1,y1),P(x2,y2)) );\n  }\n  for(int i=0;i<M;i++){\n    P a; cin >> a.real() >> a.imag();\n    ps.push_back( a );\n    mf[a] = 1;\n  }\n  P c,d;\n  cin >> c.real() >> c.imag();\n  cin >> d.real() >> d.imag();\n  int s,t;\n  mf[c] = 2;\n  mf[d] = 3;\n  ps.push_back(c);\n  ps.push_back(d);\n \n  vector<vector<double> > G = segmentArrangement(ss,ps);\n\n  double res = solve(G);\n  if( res < -EPS ) cout << -1 << endl;\n  else printf(\"%.10lf\\n\",res);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\ntypedef ld Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p)\n{\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m)\n\t{\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1)\n\t\t{\n\t\t\tint src = vec[j].second, dest = vec[j + 1].second;\n\t\t\tadd_edge(g, src, dest, abs(p[src] - p[dest]));\n\t\t\tadd_edge(g, dest, src, abs(p[src] - p[dest]));\n\t\t}\n\t}\n\treturn g;\n}\n\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tvector<Line> pipe;  vector<Point> valve;\n\tREP(i, n)\n\t{\n\t\tld x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tpipe.push_back(Line(x1, y1, x2, y2));\n\t}\n\tREP(i, m)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tvalve.emplace_back(Point(x, y));\n\t}\n\tPoint src, repair;\n\tld x, y; \n\tcin >> x >> y;\n\tsrc = Point(x, y);\n\tcin >> x >> y;\n\trepair = Point(x, y);\n\tvector<Point> ps;\n\tps.emplace_back(src);\n\tps.emplace_back(repair);\n\tps.insert(ps.end(),ALL(valve));\n\tREP(i, n)\n\t{\n\t\tps.emplace_back(pipe[i].a);\n\t\tps.emplace_back(pipe[i].b);\n\t}\n\tREP(i, n)REP(j, i)\n\t{\n\t\tif (isis_ss(pipe[i], pipe[j])) ps.emplace_back(is_ll(pipe[i], pipe[j]));\n\t}\n\n\tGraph g = segment_arrangement(pipe, ps);\n\tvector<bool> f(m, true);\n\tqueue<int> que; que.push(1);\n\tset<int> st; st.insert(1);\n\twhile (que.size())\n\t{\n\t\tint t = que.front();\n\t\tque.pop();\n\t\tREP(i, g[t].size())\n\t\t{\n\t\t\tint nx = g[t][i].to;\n\t\t\tif (st.count(nx)) continue;\n\t\t\tst.insert(nx);\n\t\t\tif (nx == 0)\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (nx > 1 && nx < m + 2) f[nx - 2] = false;\n\t\t\telse que.push(nx);\n\t\t}\n\t}\n\twhile (que.size()) que.pop();\n\tst.clear();\n\tque.push(0); st.insert(0);\n\twhile (que.size())\n\t{\n\t\tint t = que.front();\n\t\tque.pop();\n\t\tREP(i, g[t].size())\n\t\t{\n\t\t\tint nx = g[t][i].to;\n\t\t\tif (st.count(nx)) continue;\n\t\t\tst.insert(nx);\n\t\t\tif (nx > 1 && nx < m + 2 && f[nx - 2] == false) continue;\n\t\t\tque.push(nx);\n\t\t}\n\t}\n\tld ans = 0;\n\tREP(i, g.size())REP(j, g[i].size())\n\t{\n\t\tif (st.count(g[i][j].from) && st.count(g[i][j].to)) ans += g[i][j].cost;\n\t}\n\tld sum = 0;\n\tREP(i, g.size())REP(j, g[i].size()) sum += g[i][j].cost;\n\tcout << D10 << sum/2 - ans/2 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define MAX 100010\n#define eps (1e-6)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n \nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n \n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n \n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n \nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n \ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n \nbool isParallel(Segment s,Segment t){\n    return equals(cross(s.p1-s.p2,t.p1-t.p2),0.0);\n}\n \nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n \nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n \nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n \nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n \ntypedef vector<vector<pair<int,double> > > Graph;\n \nGraph SegmentArrangement(vector<Segment> v,vector<Point> &ps){\n  for(int i=0;i<v.size();i++){\n    ps.push_back(v[i].p1);\n    ps.push_back(v[i].p2);\n    for(int j=i+1;j<v.size();j++){\n      if(intersect(v[i],v[j]))ps.push_back(getCrossPointLL(v[i],v[j]));\n    }\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n  Graph g(ps.size());\n  for(int i=0;i<v.size();i++){\n    vector<pair<double,int> > list;\n    for(int j=0;j<ps.size();j++)\n      if(ccw(v[i].p1,v[i].p2,ps[j])==0)\n        list.push_back(mp(norm(v[i].p1-ps[j]),j));\n    sort(list.begin(),list.end());\n    for(int j=0;j<list.size()-1;j++){\n      int a=list[j].s,b=list[j+1].s;\n      g[a].push_back(mp(b,abs(ps[b]-ps[a])));\n      g[b].push_back(mp(a,abs(ps[a]-ps[b])));\n    }\n  }\n  return g;\n}\n \nint n,m;\nvector<Segment> vs;\nvector<Point> vp;\nset<Point> st;\nPoint s,t;\nint c,d;\nGraph g;\nbool checked[MAX]={};\nbool visited[MAX]={};\nbool valve[MAX]={};\n \nvoid dfs(int v){ \n  checked[v]=true;\n  if(valve[v])return;\n  for(int i=0;i<g[v].size();i++){\n    pair<int,double> next=g[v][i];\n    if(!checked[next.f]){\n      dfs(next.f);\n    }\n  }\n  return;\n}\n \ndouble bfs(int v){\n  double res=0.0;\n  queue<int> q;\n  q.push(v);\n  while(q.size()){\n    int u=q.front();\n    q.pop();\n    if(visited[u])continue;\n    visited[u]=true;\n    for(int i=0;i<g[u].size();i++){\n      pair<int,double> next=g[u][i];\n      if(checked[next.f])res+=next.s;\n      else if(!visited[next.f]){\n        res+=next.s;\n        q.push(next.f);\n      }\n    }\n  }\n  return res;\n}\n \nint main()\n{\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    vs.push_back(Segment(Point(a,b),Point(c,d)));\n  }\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    vp.push_back(Point(a,b));\n    st.insert(Point(a,b));\n  }\n  cin>>s.x>>s.y>>t.x>>t.y;\n  vp.push_back(s);\n  vp.push_back(t);\n  g=SegmentArrangement(vs,vp);\n  for(int i=0;i<vp.size();i++){\n    if(st.find(vp[i])!=st.end())valve[i]=true;\n    if(vp[i]==s)c=i;\n    if(vp[i]==t)d=i;\n  }\n  dfs(d);\n  if(checked[c])cout<<-1<<endl;\n  else {\n    double ans=0.0;\n    for(int i=0;i<g.size();i++){\n      for(int j=0;j<g[i].size();j++)ans+=g[i][j].s/2.0;\n    }\n    ans-=bfs(c);\n    printf(\"%.10f\\n\",ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nint n, m, np, l, idx[100011], cl, q[100011], v, s, t;\ndouble ans, eps = 1e-10;\nbool f[100011], isstop[100011], mark[100011], flag;\nstruct recedge\n{\n\tint y, nxt;\n} edge[2000011];\nvoid build(int x, int y)\n{\n\tedge[++l].y = y;\n\tedge[l].nxt = idx[x];\n\tidx[x] = l;\n}\nstruct couple\n{\n\tdouble x, y;\n\tcouple(){};\n\tcouple(const double & _a, const double & _b) : x(_a), y(_b){}\n\tdouble len()\n\t{\n\t\treturn sqrt(x * x + y * y);\n\t}\n} b[1111], cp, points[100011];\nbool equal(const double  & a, const double & b)\n{\n\treturn fabs(a - b) < eps;\n}\nbool les(const double & a, const double & b)\n{\n\treturn a + eps < b;\n}\nbool operator < (const couple & a, const couple & b)\n{\n\treturn les(a.x, b.x) or equal(a.x, b.x) and les(a.y, b.y);\n}\nbool operator == (const couple & a, const couple & b)\n{\n\treturn equal(a.x, b.x) and equal(a.y, b.y);\n}\nmap<couple, int> mp;\nvector<couple> vec[111];\ncouple operator - (const couple & a, const couple & b)\n{\n\treturn couple(a.x - b.x, a.y - b.y);\n}\ncouple operator + (const couple & a, const couple & b)\n{\n\t\treturn couple(a.x + b.x, a.y + b.y);\n}\n\ncouple operator * (const double & lambda, const couple & a)\n{\n\treturn couple(lambda * a.x, lambda * a.y);\n}\ndouble operator * (const couple & a, const couple & b)\n{\n\treturn a.x * b.y - a.y * b.x;\n}\ndouble operator % (const couple & a, const couple & b)\n{\n\treturn a.x * b.x + a.y * b.y;\n}\nstruct reca\n{\n\tcouple a, b;\n} a[311];\nbool cross(int i, int j)\n{\n\tif((a[i].b - a[i].a) * (a[j].b - a[j].a) == 0)\n\t{\n\t\tif(a[i].b == a[j].a or a[i].b == a[j].b)\n\t\t{\n\t\t\tcp = a[i].b;\n\t\t\treturn true;\n\t\t}else if(a[i].a == a[j].a  or a[i].a == a[j].b)\n\t\t{\n\t\t\tcp = a[i].a;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}else if(((a[j].a - a[i].a) * (a[i].b - a[i].a)) * ((a[j].b - a[i].a) * (a[i].b - a[i].a)) <= 0 and ((a[i].a - a[j].a) * (a[j].b - a[j].a))*((a[i].b - a[j].a) * (a[j].b - a[j].a)) <= 0)\n\t{\n\t\tdouble lambda = (a[j].a - a[i].a) * (a[j].b - a[j].a) / ((a[i].b - a[i].a) * (a[j].b - a[j].a));\n\t\tcp = a[i].a + lambda * (a[i].b - a[i].a);\n\t\treturn true;\n\t}else return false;\n}\nbool on(int i, int j)\n{\n\treturn (a[j].a - b[i]) * (a[j].b - b[i]) == 0 and (a[j].a - b[i]) % (a[j].b - b[i]) <= 0;\n}\ndouble dis(int i, int j)\n{\n\treturn sqrt((points[i].x - points[j].x) * (points[i].x - points[j].x) + (points[i].y - points[j].y) * (points[i].y - points[j].y));\n}\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%lf%lf%lf%lf\", &a[i].a.x, &a[i].a.y, &a[i].b.x, &a[i].b.y);\n\t\tans = ans + (a[i].b - a[i].a).len();\n\t}\n\tfor(int i = 1; i <= m + 2; i++)\n\t{\n\t\tscanf(\"%lf%lf\", &b[i].x, &b[i].y);\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tvec[i].clear();\n\t\tvec[i].push_back(a[i].a);\n\t\tvec[i].push_back(a[i].b);\n\t\tmp[a[i].a] = 0;\n\t\tmp[a[i].b] = 0;\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = i + 1; j <= n; j++)\n\t\t\tif(cross(i, j))\n\t\t\t{\n\t\t\t\tvec[i].push_back(cp);\n\t\t\t\tvec[j].push_back(cp);\n\t\t\t\tmp[cp] = 0;\n\t\t\t}\n\tfor(int i = 1; i <= m + 2; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t\tif(on(i, j))\n\t\t\t{\n\t\t\t\tvec[j].push_back(b[i]);\n\t\t\t\tmp[b[i]] = 0;\n\t\t\t}\n\tnp = 0;\n\tfor(map<couple, int>::iterator it = mp.begin(); it != mp.end(); it++) \n\t{\n\t\tit->second = ++np;\n\t\tpoints[np] = it->first;\n\t}\n\tl = 1;\n\tmemset(idx, 0, sizeof(idx));\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tsort(vec[i].begin(), vec[i].end());\n\t\tvec[i].resize(unique(vec[i].begin(), vec[i].end()) - vec[i].begin());\n\t\tfor(int j = 0; j < vec[i].size() - 1; j++)\n\t\t{\n\t\t\tbuild(mp[vec[i][j]], mp[vec[i][j + 1]]);\n\t\t\tbuild(mp[vec[i][j + 1]], mp[vec[i][j]]);\n\t\t}\n\t\t//for(int j = 0; j < vec[i].size(); j++) printf(\"%d \", mp[vec[i][j]]);\n\t\t//printf(\"\\n\");\n\t}\n\tmemset(isstop, 0, sizeof(isstop));\n\tmemset(mark, 0, sizeof(mark));\n\tmemset(f, true, sizeof(f));\n\ts = mp[b[m + 1]];\n\tt = mp[b[m + 2]];\n\tfor(int i = 1; i <= m; i++) isstop[mp[b[i]]] = true;\n\tq[cl = 1] = t;\n\tflag = true;\n\tf[t] = false;\n\tfor(int op = 1; op <= cl; op++)\n\t{\n\t\t//printf(\"%d\\n\", q[op]);\n\t\tfor(int p = idx[v = q[op]]; p; p = edge[p].nxt) if(f[edge[p].y] == true)\n\t\t{\n\t\t\tif(edge[p].y == s)\n\t\t\t{\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}else\n\t\t\t{\n\t\t\t\tif(isstop[edge[p].y] == true)\n\t\t\t\t{\n\t\t\t\t\tmark[edge[p].y] = true;\n\t\t\t\t\t//printf(\"mark %d\\n\", edge[p].y);\n\t\t\t\t}else\n\t\t\t\t{\n\t\t\t\t\tq[++cl] = edge[p].y;\n\t\t\t\t\tf[edge[p].y] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(flag == false) break;\n\t}\n\tif(flag == false)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tq[cl = 1] = s;\n\tmemset(f, true, sizeof(f));\n\tf[s] = false;\n\tfor(int op = 1; op <= cl; op++)\n\t{\n\t\tfor(int p = idx[v = q[op]]; p; p = edge[p].nxt)\n\t\t{\n\t\t\tans -= dis(v, edge[p].y) / 2;\n\t\t\tif(mark[edge[p].y] == true)\n\t\t\t\tans -= dis(v, edge[p].y) / 2;\n\t\t\telse if(f[edge[p].y])\n\t\t\t{\n\t\t\t\tf[edge[p].y] = false;\n\t\t\t\tq[++cl] = edge[p].y;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", ans);\n\tfclose(stdin);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-12, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\n//　重なってる部分あるとassert(false)\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 線分と線分の交点\n//　重なってる部分あるとassert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s,t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l]) {\n\t\t\t\t\treturn s[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0,0);\n\t}\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n// 点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef double Weight;\n\nstruct Edge { int from, to; Weight weight;\nint id;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight,const int id) {\n\tg[from].push_back(Edge{ from, to, weight,id});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<pair<Point,bool>> &p) {\n\tint n = p.size(), m = s.size();\n\tint id = 0;\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j].first))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j].first), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from].first - p[to].first), id);\n\t\t\tadd_edge(g, to, from, abs(p[from].first - p[to].first), id++);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nint startid;\nint goalid;\nbool dfs0(const Graph&g,const int now, vector<bool>&came, vector<bool>&close,const vector<bool>&bulbs) {\n\tcame[now] = true;\n\tfor (auto e : g[now]) {\n\t\tif (!came[e.to]) {\n\t\t\tif (e.to == startid)return false;\n\t\t\telse {\n\t\t\t\tif (bulbs[e.to]) {\n\t\t\t\t\tclose[e.to] = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!dfs0(g, e.to, came, close, bulbs)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ndouble dfs1(const Graph&g, const int now, vector<bool>&came,vector<bool>&useedges, const vector<bool>&close) {\n\tcame[now] = true;\n\tdouble ans = 0;\n\tfor (auto e : g[now]) {\n\t\tif (!useedges[e.id]) {\n\t\t\tans += e.weight;\n\t\t\tuseedges[e.id] = true;\n\t\t\tif (close[e.to])continue;\n\t\t\telse {\n\t\t\t\tif(!came[e.to])ans += dfs1(g, e.to, came,useedges, close);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tdouble sum = 0;\n\tGraph g;\n\tint sx, sy, gx, gy;\n\tPoint start;\n\tPoint goal;\n\tvector<pair<Point, bool>>crss;\n\tvector<bool>bulbs;\n\t{\n\t\tint N, M; cin >> N >> M;\n\t\tvector<Line>ls;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint asx, asy, dx, dy; cin >> asx >> asy >> dx >> dy;\n\t\t\tls.push_back(Line(Point(asx, asy), Point(dx, dy)));\n\t\t\tsum += (abs(Point(asx, asy) - Point(dx, dy)));\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < ls.size(); ++j) {\n\t\t\t\tisis_ss(ls[i], ls[j]) {\n\t\t\t\t\tcrss.push_back(make_pair(is_ss(ls[i], ls[j]), false));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < ls.size(); ++i) {\n\t\t\tcrss.push_back(make_pair(ls[i][0], false));\n\t\t\tcrss.push_back(make_pair(ls[i][1], false));\n\t\t}\n\t\t\n\t\tvector<Point >bs;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tPoint p(x, y);\n\t\t\tbs.push_back(p);\n\t\t}\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tstart = Point(sx, sy);\n\t\tgoal = Point(gx, gy);\t\n\t\tcrss.push_back(make_pair(start, false));\n\t\tcrss.push_back(make_pair(goal, false));\n\t\tsort(crss.begin(), crss.end());\n\t\tcrss.erase(unique(crss.begin(), crss.end()), crss.end());\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tauto it = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == bs[i]; });\n\t\t\tif (it == crss.end()) {\n\t\t\t\tcrss.push_back(make_pair(bs[i], true));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(*it).second = true;\n\t\t\t}\n\t\t}\n\n\n\t\tfor (int i = 0; i < crss.size(); ++i) {\n\t\t\tbulbs.push_back(crss[i].second);\n\t\t}\n\t\tg= segment_arrangement(ls, crss);\n\t}\n\tauto startit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == start; });\n\tstartid = startit - crss.begin();\n\tauto goalit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == goal; });\n\tgoalid = goalit - crss.begin();\n\tvector<bool>close(crss.size(),false);\n\tvector<bool>came(crss.size(), false);\n\tif (dfs0(g, goalid, came, close, bulbs)) {\n\t\tvector<bool>acame(crss.size(), false);\n\t\tvector<bool>useedges(80000, false);\n\t\tdouble ans = dfs1(g, startid, acame, useedges,close);\n\t\tcout <<fixed<<setprecision(10)<< sum-ans << endl;\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double eps = 1e-8;\n#define eq(a, b) (fabs((a)-(b)) < eps)\n#define lt(a, b) ((a)-(b) < -eps)\n\nstruct Point {\n  double x, y;\n  Point(double x=0, double y=0):x(x), y(y){}\n  Point operator+(Point p) {return Point(x+p.x, y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x, y-p.y);}\n  Point operator*(double a) {return Point(x*a, y*a);}\n  Point operator/(double a) {return Point(x/a, y/a);}\n  bool operator<(const Point& p) const {return x!=p.x?x<p.x:y<p.y;}\n  bool operator==(const Point& p) const {return eq(x, p.x)&&eq(y, p.y);}\n};\nusing Vector = Point;\n\ndouble dot(Vector a, Vector b) {return a.x*b.x+a.y*b.y;}\ndouble cross(Vector a, Vector b) {return a.x*b.y-a.y*b.x;}\ndouble norm(Vector a) {return dot(a, a);}\ndouble abs(Vector a) {return sqrt(norm(a));}\n\nconst int CCW = 1;\nconst int CW = -1;\nconst int BCK = 2;\nconst int FNT = -2;\nconst int ON = 0;\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a, b) > eps) return CCW;\n  if(cross(a, b) < -eps) return CW;\n  if(dot(a, b) < -eps) return BCK;\n  if(norm(a) < norm(b)) return FNT;\n  return ON;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\ndouble distance(Point a, Point b) {return abs(a-b);}\n\nstruct Segment {\n  Point s, t;\n  Segment(Point s=Point(), Point t=Point()):s(s), t(t){}\n};\nusing Line = Segment;\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.s, s1.t, s2.s, s2.t);\n}\nbool intersect(Segment s, Point p) {\n  return abs(s.s-p)+abs(s.t-p)-abs(s.t-s.s) < eps;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(cross(l.t-l.s, p-l.s)/abs(l.t-l.s));\n}\ndouble distanceSP(Segment s, Point p) {\n  if(dot(s.t-s.s, p-s.s) < 0) return abs(p-s.s);\n  if(dot(s.s-s.t, p-s.t) < 0) return abs(p-s.t);\n  return distanceLP(s, p);\n}\ndouble distance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0;\n  return min(min(distanceSP(s1, s2.s), distanceSP(s1, s2.t)),\n\t     min(distanceSP(s2, s1.s), distanceSP(s2, s1.t)));\n}\nPoint crossPoint(Segment s1, Segment s2) {\n  Vector base = s2.t-s2.s;\n  double d1 = abs(cross(base, s1.s-s2.s));\n  double d2 = abs(cross(base, s1.t-s2.s));\n  double t = d1/(d1+d2);\n  return s1.s+(s1.t-s1.s)*t;\n}\n\nbool merge(Segment& s1, Segment s2) {\n  if(abs(cross(s1.t-s1.s, s2.t-s2.s)) > eps) return false;\n  if(ccw(s1.s, s2.s, s1.t) == CCW ||\n     ccw(s1.s, s2.s, s1.t) == CW) return false;\n  if(ccw(s1.s, s1.t, s2.s) == FNT ||\n     ccw(s2.s, s2.t, s1.s) == FNT) return false;\n  s1 = Segment(min(s1.s, s2.s), max(s1.t, s2.t));\n  return true;\n}\nvoid mergeSegments(vector<Segment>& segs) {\n  for(int i = 0; i < (int)segs.size(); ++i) {\n    if(segs[i].t < segs[i].s) swap(segs[i].s, segs[i].t);\n  }\n  for(int i = 0; i < (int)segs.size(); ++i) {\n    for(int j = i+1; j < (int)segs.size(); ++j) {\n      if(merge(segs[i], segs[j])) {\n\tsegs[j--] = segs.back();\n\tsegs.pop_back();\n      }\n    }\n  }\n}\n\nstruct edge {\n  int to;\n  double cost;\n  int id;\n  edge(){}\n  edge(int to, double cost, int id):to(to), cost(cost), id(id){}\n  bool operator<(const edge& e) {return lt(cost, e.cost);}\n};\nusing Graph = vector<vector<edge> >;\n\nvector<int> type;\nmap<Point, int> mp;\nint id = 0;\ndouble sum = 0;\n\nGraph segmentArrangement(vector<Segment>& segs, vector<Point>& ps) {\n  for(int i = 0; i < (int)segs.size(); ++i) {\n    ps.push_back(segs[i].s);\n    ps.push_back(segs[i].t);\n    for(int j = i+1; j < (int)segs.size(); ++j) {\n      if(intersect(segs[i], segs[j])) ps.push_back(crossPoint(segs[i], segs[j]));\n    }\n  }\n  sort(ps.begin(), ps.end());\n  ps.erase(unique(ps.begin(), ps.end()), ps.end());\n  //cout<<\"AFTER\"<<endl;\n  //for(int i = 0; i < (int)ps.size(); ++i) cout<<mp[ps[i]]<<\" \"<<ps[i].x<<\" \"<<ps[i].y<<endl;\n  for(int i = 0; i < (int)ps.size(); ++i) type.push_back(mp[ps[i]]);\n  Graph graph(ps.size());\n  for(int i = 0; i < (int)segs.size(); ++i) {\n    vector<pair<double, int> > ls;\n    for(int j = 0; j < (int)ps.size(); ++j) {\n      if(intersect(segs[i], ps[j])) {\n\tls.emplace_back(distance(segs[i], ps[j]), j);\n      }\n    }\n    sort(ls.begin(), ls.end());\n    for(int j = 0; j+1 < (int)ls.size(); ++j) {\n      int u = ls[j].second, v = ls[j+1].second;\n      graph[u].emplace_back(v, distance(ps[u], ps[v]), id);\n      graph[v].emplace_back(u, distance(ps[u], ps[v]), id);\n      ++id;\n      sum += distance(ps[u], ps[v]);\n    }\n  }\n  return graph;\n}\n\nint main() {\n  int N, M;\n  vector<Segment> segs;\n  vector<Point> ps;\n\n  cin >> N >> M;\n  for(int i = 0; i < N; ++i) {\n    Point s, t;\n    cin >> s.x >> s.y >> t.x >> t.y;\n    segs.emplace_back(s, t);\n  }\n  for(int i = 0; i < M+2; ++i) {\n    Point p;\n    cin >> p.x >> p.y;\n    ps.push_back(p);\n    if(i == M) mp[p] = 1;\n    else if(i == M+1) mp[p] = 2;\n    else mp[p] = 3;\n  }\n  //cout<<\"BEFORE\"<<endl;\n  //for(auto& p : mp) cout << p.second<<\" \"<<p.first.x<<\" \"<<p.first.y<<endl;\n  mergeSegments(segs);\n  Graph graph = segmentArrangement(segs, ps);\n  int s = -1, t = -1;\n  for(int i = 0; i < (int)graph.size(); ++i) {\n    if(type[i] == 1) s = i;\n    else if(type[i] == 2) t = i;\n  }\n  assert(~s && ~t);\n\n  queue<int> que;\n  vector<bool> used(graph.size(), false);\n  que.push(t);\n  used[t] = true;\n  //cout<<s<<\" \"<<t<<endl;\n  while(!que.empty()) {\n    int v = que.front(); que.pop();\n    //cout<<v<<endl;\n    if(v == s) {\n      cout << -1 << endl;\n      return 0;\n    }\n    if(type[v] == 3) continue;\n    for(edge e : graph[v]) {\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      que.push(e.to);\n    }\n  }\n  vector<bool> usedEdge(id, false);\n  que.push(s);\n  used[s] = true;\n  while(!que.empty()) {\n    int v = que.front(); que.pop();\n    for(edge e : graph[v]) {\n      if(usedEdge[e.id]) continue;\n      sum -= e.cost;\n      usedEdge[e.id] = true;\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      que.push(e.to);\n    }\n  }\n  printf(\"%.12f\\n\", sum);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n// 点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight;\nint id;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight,const int id) {\n\tg[from].push_back(Edge{ from, to, weight,id});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<pair<Point,bool>> &p) {\n\tint n = p.size(), m = s.size();\n\tint id = 0;\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j].first))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j].first), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from].first - p[to].first), id);\n\t\t\tadd_edge(g, to, from, abs(p[from].first - p[to].first), id++);\n\t\t}\n\t}\n\treturn g;\n}\n\n//Graph sennbunn_arrangement(const vector<Line>&s) {\n//\tvector<Point>crss;\n//\tfor (int i = 0; i < s.size(); ++i) {\n//\t\tfor (int j = i + 1; j < s.size(); ++j) {\n//\t\t\tif (isis_ss( s[i],  s[j])) {\n//\t\t\t\tcrss.push_back(is_ll( s[i],  s[j]));\n//\t\t\t}\n//\t\t}\n//\t}\n//\tfor (int i = 0; i <s.size(); ++i) {\n//\t\tcrss.push_back( s[i][0]);\n//\t\tcrss.push_back( s[i][1]);\n//\t}\n//\treturn segment_arrangement(s, crss);\n//}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nint startid;\nint goalid;\nbool dfs0(const Graph&g,const int now, vector<bool>&came, vector<bool>&close,const vector<bool>&bulbs) {\n\tcame[now] = true;\n\tfor (auto e : g[now]) {\n\t\tif (!came[e.to]) {\n\t\t\tif (e.to == startid)return false;\n\t\t\telse {\n\t\t\t\tif (bulbs[e.to]) {\n\t\t\t\t\tclose[e.to] = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!dfs0(g, e.to, came, close, bulbs)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ndouble dfs1(const Graph&g, const int now, vector<bool>&came,vector<bool>useedges, const vector<bool>&close) {\n\tcame[now] = true;\n\tdouble ans = 0;\n\tfor (auto e : g[now]) {\n\t\tif (!useedges[e.id]) {\n\t\t\tans += e.weight;\n\t\t\tuseedges[e.id] = true;\n\t\t\tif (close[e.to])continue;\n\t\t\telse {\n\t\t\t\tif(!came[e.to])ans += dfs1(g, e.to, came,useedges, close);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tdouble sum = 0;\n\tGraph g;\n\tint sx, sy, gx, gy;\n\tPoint start;\n\tPoint goal;\n\tvector<pair<Point, bool>>crss;\n\tvector<bool>bulbs;\n\t{\n\t\tint N, M; cin >> N >> M;\n\t\tvector<Line>ls;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint asx, asy, dx, dy; cin >> asx >> asy >> dx >> dy;\n\t\t\tls.push_back(Line(Point(asx, asy), Point(dx, dy)));\n\t\t\tsum += (abs(Point(asx, asy) - Point(dx, dy)));\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < ls.size(); ++j) {\n\t\t\t\tif (isis_ss(ls[i], ls[j])) {\n\t\t\t\t\tcrss.push_back(make_pair(is_ll(ls[i], ls[j]),false));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < ls.size(); ++i) {\n\t\t\tcrss.push_back(make_pair(ls[i][0], false));\n\t\t\tcrss.push_back(make_pair(ls[i][1], false));\n\t\t}\n\t\t\n\t\tvector<Point >bs;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tPoint p(x, y);\n\t\t\tbs.push_back(p);\n\t\t}\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tstart = Point(sx, sy);\n\t\tgoal = Point(gx, gy);\t\n\t\tcrss.push_back(make_pair(start, false));\n\t\tcrss.push_back(make_pair(goal, false));\n\t\tsort(crss.begin(), crss.end());\n\t\tcrss.erase(unique(crss.begin(), crss.end()), crss.end());\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tauto it = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == bs[i]; });\n\t\t\tif (it == crss.end()) {\n\t\t\t\tcrss.push_back(make_pair(bs[i], true));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(*it).second = true;\n\t\t\t}\n\t\t}\n\n\n\t\tfor (int i = 0; i < crss.size(); ++i) {\n\t\t\tbulbs.push_back(crss[i].second);\n\t\t}\n\t\tg= segment_arrangement(ls, crss);\n\t}\n\tauto startit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == start; });\n\tstartid = startit - crss.begin();\n\tauto goalit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == goal; });\n\tgoalid = goalit - crss.begin();\n\tvector<bool>close(crss.size(),false);\n\tvector<bool>came(crss.size(), false);\n\tif (dfs0(g, goalid, came, close, bulbs)) {\n\t\tvector<bool>acame(crss.size(), false);\n\t\tvector<bool>useedges(20000, false);\n\t\tdouble ans = dfs1(g, startid, acame, useedges,close);\n\t\tcout <<fixed<<setprecision(10)<< sum-ans << endl;\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a,b;\n\toperator line<T>()const{ return (line<T>){a,b}; }\n};\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<double> &S,const point<double> &p){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\nvoid arrangement(const vector< segment<double> > &S,const vector< point<double> > &plus,vector< point<double> > &P,vector<int> *G){\n\tint n=S.size();\n\tP=plus;\n\trep(i,n){\n\t\tP.push_back(S[i].a);\n\t\tP.push_back(S[i].b);\n\t\trep(j,i) if(intersect(S[i],S[j])) P.push_back(get_intersect(S[i],S[j]));\n\t}\n\tsort(P.begin(),P.end());\n\tP.erase(unique(P.begin(),P.end()),P.end());\n\n\trep(i,n){\n\t\tvector<int> on;\n\t\trep(u,P.size()) if(cover(S[i],P[u])) on.push_back(u);\n\t\trep(j,(int)on.size()-1){\n\t\t\tint u=on[j],v=on[j+1];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tvector< segment<double> > pipe(n);\n\trep(i,n) scanf(\"%lf%lf%lf%lf\",&pipe[i].a.x,&pipe[i].a.y,&pipe[i].b.x,&pipe[i].b.y);\n\tvector< point<double> > stop(m);\n\trep(i,m) scanf(\"%lf%lf\",&stop[i].x,&stop[i].y);\n\tpoint<double> s,t;\n\tscanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&t.x,&t.y);\n\n\t// 追加の頂点集合\n\tvector< point<double> > plus=stop;\n\tplus.push_back(s);\n\tplus.push_back(t);\n\n\tvector< point<double> > P;\n\tvector<int> G[2000];\n\tarrangement(pipe,plus,P,G);\n\n\tint N=P.size();\n\tbool isstop[2000]={};\n\trep(i,m) rep(j,N) if(P[j]==stop[i]) isstop[j]=true;\n\n\tint s_id=find(P.begin(),P.end(),s)-P.begin();\n\tint t_id=find(P.begin(),P.end(),t)-P.begin();\n\n\t// t から stop をまたがずに行ける場所を見つける\n\tbool vis[2000]={};\n\tvis[t_id]=true;\n\tqueue<int> Q; Q.push(t_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=true;\n\t\t\t\tif(!isstop[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(vis[s_id]){ puts(\"-1\"); return 0; }\n\n\t// s から vis を通らずに行ける場所を見つける\n\tbool vis2[2000]={};\n\tvis2[s_id]=true;\n\tQ.push(s_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v]=true;\n\t\t\t\tif(!vis[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans=0;\n\trep(i,n) ans+=dist(pipe[i].a,pipe[i].b);\n\trep(u,N) rep(i,G[u].size()) {\n\t\tint v=G[u][i];\n\t\tif(vis2[u] && vis2[v]) ans-=dist(P[u],P[v])/2; // 二回カウントされるので半分\n\t}\n\tprintf(\"%.9f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    // if (abs(a-b)<EPS) return 0;\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L() {}\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ntypedef int Weight;\nstruct Edge {\n  int dst;\n  Weight weight;\n  Edge(int dst, Weight weight) :\n    dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nGraph segmentArrangement(const vector<L> &ss, vector<P> &ps) {\n  for (int i = 0; i < ss.size(); ++i) { // O(n^2)\n    ps.push_back( ss[i][0] );\n    ps.push_back( ss[i][1] );\n    for (int j = i+1; j < ss.size(); ++j)\n      if (intersectSS(ss[i], ss[j])) {\n        ps.push_back( crosspoint(ss[i], ss[j]) );\n      }\n  }\n  sort(ALL(ps)); ps.erase(unique(ALL(ps)), ps.end());\n\n  Graph g(ps.size());\n  for (int i = 0; i < ss.size(); ++i) {\n    vector< pair<double, int> > list;\n    for (int j = 0; j < ps.size(); ++j)\n      if (intersectSP(ss[i], ps[j]))\n        list.push_back(make_pair(norm(ss[i][0]-ps[j]), j));\n    sort(ALL(list));\n    for (int j = 0; j+1 < list.size(); ++j) {\n      int a = list[j].second, b = list[j+1].second;\n      g[a].push_back( Edge(b, abs(ps[a]-ps[b])) );\n      g[b].push_back( Edge(a, abs(ps[a]-ps[b])) );\n    }\n  }\n  return g;\n}\n\nint pp[1002];\nint rp[100000];\n\nbool flag[1000];\nbool visited[100000];\nint xv[1000],yv[1000];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<L> ss;\n  double sum = 0;\n  REP(i,n) {\n    int x1,y1,x2,y2;\n    cin>>x1>>y1>>x2>>y2;\n    ss.push_back(L(P(x1,y1),P(x2,y2)));\n    sum += abs(P(x1,y1)-P(x2,y2));\n  }\n  vector<P> ps;\n  REP(i,m) {\n    cin >> xv[i] >> yv[i];\n  }\n  cin>>xv[m]>>yv[m]>>xv[m+1]>>yv[m+1];\n  REP(i,m+2) {\n    ps.push_back(P(xv[i],yv[i]));\n  }\n  Graph g = segmentArrangement(ss,ps);\n  return 0;\n  memset(rp,-1,sizeof(rp));\n  REP(i,m+2) {\n    REP(j,ps.size()) {\n      if (abs(P(xv[i],yv[i]) - ps[j]) < EPS) {\n        pp[i] = j;\n        rp[j] = i;\n        break;\n      }\n    }\n  }\n  queue<int> Q;\n  Q.push(pp[m+1]);\n  while(!Q.empty()) {\n    int now = Q.front(); Q.pop();\n    visited[now] = 1;\n\n    //cout << now << \" \" << ps[now] << endl;\n    \n    if (rp[now] != -1 && rp[now] < m) {\n      flag[rp[now]] = 1;\n      continue;\n    }\n    if (rp[now] == m) {\n      puts(\"-1\");\n      return 0;\n    }\n    FOR(it, g[now]) {\n      //cout << \" \" << it->dst << endl;\n      if (!visited[it->dst]) {\n        Q.push(it->dst);\n      }\n    }\n  }\n  memset(visited,0,sizeof(visited));\n  Q.push(pp[m]);\n  map<pii,bool> mp;\n  double ans = 0;\n  while(!Q.empty()) {\n    int now = Q.front(); Q.pop();\n    visited[now] = 1;\n    if (rp[now]!=-1 && rp[now]<m && flag[rp[now]]) continue;\n    FOR(it, g[now]) {\n      int a = min(now,it->dst);\n      int b = max(now, it->dst);\n      if (!mp.count(pii(a,b))) {\n        mp[pii(a,b)] = 1;\n        ans += it->weight;\n      }\n      if (!visited[it->dst]) {\n        Q.push(it->dst);\n      }\n    }\n  }\n  printf(\"%.10f\\n\", sum-ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n//#define EPS 0.0000001\n#define NUM 305\n\nstruct Point{\n\tPoint(double arg_x,double arg_y){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\n\tPoint(){\n\t\tx = y = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){ return Point(a*x,a*y); }\n\tPoint operator / (double a){ return Point(x/a,y/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator<(const Point &p) const{\n\t\treturn fabs(x-p.x) > EPS? x < p.x: y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n\n\tdouble x,y;\n};\ntypedef Point Vector;\n\nstruct Line{\npublic:\n\tPoint p[2];\n\tLine(Point p1,Point p2){\n\t\tp[0] = p1;\n\t\tp[1] = p2;\n\t}\n\tLine(){\n\t}\n};\n\nstruct Info{\n\tInfo(Point arg_cross_point,int arg_index){\n\n\t\tcross_point.x = arg_cross_point.x;\n\t\tcross_point.y = arg_cross_point.y;\n\t\tindex = arg_index;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn cross_point < arg.cross_point;\n\t}\n\tbool operator==(const struct Info &arg) const{\n\t\treturn cross_point == arg.cross_point;\n\t}\n\n\tPoint cross_point;\n\tint index;\n};\n\nstruct Edge{\n\tEdge(int arg_to, double arg_cost){\n\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to;\n\tdouble cost;\n};\n\nint N,M;\nint num_nodes;\nint start_index = -1,repair_index = -1;\nvector<Info> on_segment[NUM];\nvector<Point> NODES,STOP_VALVE;\nPoint start,goal;\nLine water_pipe[NUM];\nvector<Edge> G[NUM*NUM];\nmap<int,bool> IS_STOP;\nmap<pair<int,int>,bool> MAP;\nmap<pair<int,int>,bool> USED;\n\n\n//交点を求める関数\nPoint calc_Cross_Point(double x1,double x2,double x3,double x4,double y1,double y2,double y3,double y4){\n\tPoint ret;\n\tret.x = ((x2-x1)*(y3*(x4-x3)+x3*(y3-y4))-(x4-x3)*(y1*(x2-x1)+x1*(y1-y2)))/((y2-y1)*(x4-x3)-(y4-y3)*(x2-x1));\n\tif(x1 != x2){\n\t\tret.y = ((y2-y1)*ret.x+y1*(x2-x1)+x1*(y1-y2))/(x2-x1);\n\t}else{\n\t\tret.y = ((y4-y3)*ret.x+y3*(x4-x3)+x3*(y3-y4))/(x4-x3);\n\t}\n\treturn ret;\n}\n\n//インタフェース関数\nPoint calc_Cross_Point(Point a,Point b,Point c,Point d){\n\treturn calc_Cross_Point(a.x,b.x,c.x,d.x,a.y,b.y,c.y,d.y);\n}\n\nPoint calc_Cross_Point(Line A,Line B){\n\n\treturn calc_Cross_Point(A.p[0],A.p[1],B.p[0],B.p[1]);\n}\n\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\n\n//★★直線ではなく、線分の交差判定★★\nbool is_Cross(Line a,Line b){\n\n\tif(func(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[0].x,b.p[0].y)*\n\t\t\tfunc(a.p[0].x,a.p[0].y,a.p[1].x,a.p[1].y,b.p[1].x,b.p[1].y) <= 0 &&\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[0].x,a.p[0].y)*\n\t\t\tfunc(b.p[0].x,b.p[0].y,b.p[1].x,b.p[1].y,a.p[1].x,a.p[1].y) <= 0){\n\t\treturn true;\n\t}\n\treturn false;\n}\n\ndouble calc_dist(Point A,Point B){\n\n\treturn sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));\n}\n\nPoint calc_minus(Point a,Point b){\n    Point ret;\n\n    ret.x = a.x-b.x;\n    ret.y = a.y-b.y;\n\n    return ret;\n}\n\ndouble calc_len(Vector a){\n    return sqrt(a.x*a.x+a.y*a.y);\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble calc_slope(Line A){\n\n\tif(fabs(A.p[0].x-A.p[1].x) < EPS){\n\n\t\treturn DBL_MAX;\n\n\t}else if(fabs(A.p[0].y-A.p[1].y) < EPS){\n\n\t\treturn 0;\n\n\t}else{\n\n\t\treturn (A.p[0].y-A.p[1].y)/(A.p[0].x-A.p[1].x);\n\t}\n}\n\ndouble norm(Vector a){\n\treturn a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n\n\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(calc_minus(l.p[1],l.p[0]),calc_minus(p,l.p[0]))/calc_len(calc_minus(l.p[1],l.p[0])));\n}\n\n//★★点と線分の距離★★\ndouble getDistanceSP(Line l,Point p){\n\tif(dot(l.p[1]-l.p[0],p-l.p[0]) < 0.0) return abs(p-l.p[0]);\n\tif(dot(l.p[0]-l.p[1],p-l.p[1]) < 0.0) return abs(p-l.p[1]);\n\treturn getDistanceLP(l,p);\n}\n\nint main(){\n\n\n\tscanf(\"%d %d\",&N,&M);\n\n\tnum_nodes = 0;\n\n\tint x1,y1,x2,y2;\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n\n\t\twater_pipe[i].p[0].x = x1;\n\t\twater_pipe[i].p[0].y = y1;\n\t\twater_pipe[i].p[1].x = x2;\n\t\twater_pipe[i].p[1].y = y2;\n\n\t\tauto at = MAP.find(make_pair(x1,y1));\n\t\tif(at == MAP.end()){\n\t\t\tNODES.push_back(Point(water_pipe[i].p[0]));\n\t\t\tMAP[make_pair(x1,y1)] = true;\n\t\t}\n\n\t\tat = MAP.find(make_pair(x2,y2));\n\t\tif(at == MAP.end()){\n\t\t\tNODES.push_back(Point(water_pipe[i].p[1]));\n\t\t\tMAP[make_pair(x2,y2)] = true;\n\t\t}\n\n\t\tNODES.push_back(Point(water_pipe[i].p[1]));\n\t}\n\n\n\tint x,y;\n\n\t//止水バルブの取得\n\n\tfor(int i = 0; i < M; i++){\n\n\t\tscanf(\"%d %d\",&x,&y);\n\n\t\tSTOP_VALVE.push_back(Point(x,y));\n\n\t\tNODES.push_back(Point(x,y));\n\n\t}\n\n\tint start_x,start_y;\n\n\tscanf(\"%d %d\",&start_x,&start_y);\n\tNODES.push_back(Point(start_x,start_y));\n\n\n\tint repair_x,repair_y;\n\n\tscanf(\"%d %d\",&repair_x,&repair_y);\n\tNODES.push_back(Point(repair_x,repair_y));\n\n\t//パイプとパイプの交点ノードの座標を求める\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int k = i+1; k < N; k++){\n\t\t\tif(!is_Cross(water_pipe[i],water_pipe[k]))continue;\n\n\t\t\tif(water_pipe[i].p[0] == water_pipe[k].p[0] || water_pipe[i].p[0] == water_pipe[k].p[1] || //計算不要なのでSKIP\n\t\t\t\t\twater_pipe[i].p[1] == water_pipe[k].p[0] || water_pipe[i].p[1] == water_pipe[k].p[1])continue;\n\n\t\t\tPoint tmp_point = calc_Cross_Point(water_pipe[i],water_pipe[k]);\n\n\t\t\tbool FLG = false;\n\t\t\tfor(int a = 0; a < NODES.size(); a++){\n\n\t\t\t\tif(NODES[a] == tmp_point){\n\t\t\t\t\tFLG = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(FLG)continue;\n\n\t\t\tNODES.push_back(tmp_point);\n\n\t\t}\n\t}\n\n\tsort(NODES.begin(),NODES.end());\n\tNODES.erase(unique(NODES.begin(),NODES.end()),NODES.end());\n\n\t//線分と接触しているノードを線分に所属させる\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < NODES.size(); k++){\n\t\t\tif(NODES[k] == water_pipe[i].p[0] || NODES[k] == water_pipe[i].p[1]){ //計算するとnanになる\n\t\t\t\ton_segment[i].push_back(Info(NODES[k],k));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(getDistanceSP(water_pipe[i],NODES[k]) > EPS)continue;\n\n\t\t\ton_segment[i].push_back(Info(NODES[k],k));\n\t\t}\n\t}\n\n\t//止水バルブのインデックスを求める\n\tfor(int i = 0; i < STOP_VALVE.size(); i++){\n\n\t\tfor(int k = 0; k < NODES.size(); k++){\n\t\t\tif(NODES[k] == STOP_VALVE[i]){\n\t\t\t\tIS_STOP[k] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\t//スタートノードのインデックスを求める\n\tPoint start_point = Point(start_x,start_y);\n\n\tfor(int k = 0; k < NODES.size(); k++){\n\t\tif(NODES[k] == start_point){\n\t\t\tstart_index = k;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//修理ポイントのインデックスを求める\n\tPoint repair_point = Point(repair_x,repair_y);\n\n\tfor(int k = 0; k < NODES.size(); k++){\n\t\tif(NODES[k] == repair_point){\n\t\t\trepair_index = k;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdouble total_length = 0;\n\n\t//グラフを作成\n\tfor(int i = 0; i < N; i++){\n\n\t\tsort(on_segment[i].begin(),on_segment[i].end());\n\t\ton_segment[i].erase(unique(on_segment[i].begin(),on_segment[i].end()),on_segment[i].end());\n\n\t\tfor(int k = 1; k < on_segment[i].size(); k++){\n\n\t\t\tint from = on_segment[i][k-1].index;\n\t\t\tint to = on_segment[i][k].index;\n\n\t\t\tdouble tmp_dist = calc_dist(on_segment[i][k-1].cross_point,on_segment[i][k].cross_point);\n\n\t\t\ttotal_length += tmp_dist;\n\n\t\t\tG[from].push_back(Edge(to,tmp_dist));\n\t\t\tG[to].push_back(Edge(from,tmp_dist));\n\t\t}\n\t}\n\n\tdouble must_stop = 0;\n\n\t//修理ポイントから、止水バルブを通らずに行ける範囲の距離を求める[★必ず止める★]\n\tqueue<int> Q;\n\tQ.push(repair_index);\n\n\twhile(!Q.empty()){\n\n\t\tint tmp_node = Q.front();\n\t\tQ.pop();\n\n\t\tauto at = IS_STOP.find(tmp_node);\n\n\t\tif(at != IS_STOP.end()){ //tmp_nodeは止水バルブ\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 0; i < G[tmp_node].size(); i++){\n\n\t\t\tint next_node = G[tmp_node][i].to;\n\n\t\t\tauto at = USED.find(make_pair(tmp_node,next_node));\n\n\t\t\tif(at != USED.end())continue; //エッジを通過済み\n\n\t\t\tif(next_node == start_index){\n\n\t\t\t\tprintf(\"-1\\n\"); //水源から修理点までの間に止水バルブがないので不可\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tUSED[make_pair(tmp_node,next_node)] = true;\n\t\t\tUSED[make_pair(next_node,tmp_node)] = true;\n\n\t\t\tmust_stop += G[tmp_node][i].cost;\n\n\t\t\tQ.push(next_node);\n\t\t}\n\t}\n\n\t//水源から、水を停めた範囲を通らずに、水を供給できる範囲を求める\n\tdouble can_supply = 0;\n\n\tQ.push(start_index);\n\n\twhile(!Q.empty()){\n\n\t\tint tmp_node = Q.front();\n\t\tQ.pop();\n\n\t\tfor(int i = 0; i < G[tmp_node].size(); i++){\n\n\t\t\tint next_node = G[tmp_node][i].to;\n\n\t\t\tauto at = USED.find(make_pair(tmp_node,next_node));\n\t\t\tif(at != USED.end())continue; //エッジを通過済み\n\n\t\t\tcan_supply += G[tmp_node][i].cost;\n\n\t\t\tUSED[make_pair(tmp_node,next_node)] = true;\n\t\t\tUSED[make_pair(next_node,tmp_node)] = true;\n\n\t\t\tQ.push(next_node);\n\t\t}\n\t}\n\tprintf(\"%.10lf\\n\",total_length-can_supply);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-8\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<double,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\ntypedef complex<double> C;\n\nconst double PI = 4*atan(1.0);\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n    bool operator > (const C a, const C b) {\n        return a.real() != b.real() ? a.real() > b.real() : a.imag() > b.imag();\n    }\n    //点をsetとかmapにつめたいとき(誤差を1e-10とか厳しくし過ぎるとバグる)\n    // bool operator<(const C a, const C b){\n    //     return abs(a.real()-b.real())>EPS ? a.real()<b.real()-EPS : a.imag()<b.imag()-EPS;\n    // }\n    bool operator==(const C a, const C b){\n        return (eq(a.real(),b.real()) && eq(a.imag(),b.imag()));\n    }\n    bool operator!=(const C a, const C b){\n        return !(a == b);\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(){}\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\n//条件付きsqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//正規化\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//角度(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//外積\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//内積\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nC rot(C c,double th)\n{\n    return c * C(cos(th),sin(th));\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\n//直線どうしの交差判定(同一直線はTrue)\nbool intersectLL(const L& l, const L& m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//直線と線分の交差判定(一点共有も交差と判定)\nbool intersectLS(const L& l, const L& s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//直線と点の交差(共有)判定\nbool intersectLP(const L& l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//線分どうしの交差判定(一点共有も交差と判定)\nbool intersectSS(const L& s, const L& t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//線分と点の交差(共有)判定\nbool intersectSP(const L& s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//直線および線分の交点\nC crosspointLL(const L& l, const L& m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //同一直線のとき\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//点pを直線l上に射影\nC projection(const L& l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//crosspointCLに使用する関数(命名が謎です)\ndouble gettime(C c1,C c2)\n{\n    return (dot(c1,c2) < 0 ? -1.0 : 1.0 ) * abs(c2) / abs(c1);\n}\n//円と直線の交点\nvector<C> crosspointCL(C c1,double r1,const L& l)\n{\n    C a=l[0], b=l[1];\n    vector<C> res;\n    C base=b-a,  target=projection(L(a,b),c1);\n    double length=abs(base), h=abs(c1-target);\n    base/=length;\n    if(r1+EPS<h)    return res;\n    double w=Sqrt(r1*r1-h*h);\n    double LL=gettime(normalize(b-a),target-a)-w,RR=LL+w*2.0;\n    res.push_back(a+base*LL);\n    if(eq(LL,RR))   return res;\n    res.push_back(a+base*RR);\n    return res;\n}\n\n//円と線分の交点\nvector<C> crosspointCS(C c1,double r1,const L& s)\n{\n    vector<C> tmp=crosspointCL(c1,r1,s);\n    vector<C> res;\n    rep(i,tmp.size()){\n        if(abs(s[1]-s[0]) == abs(s[0]-tmp[i])+abs(s[1]-tmp[i])){\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n//円どうしの交点\nL crosspointCC(const C c1, const double r1, const C c2, const double r2)\n{\n    C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n    C d = b*b-4.0*a*c;\n    C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n    return L(z1, z2);\n}\n//点pを直線lを軸として対称移動\nC reflection(const L &l, const C p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//点と直線の距離\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n//直線と直線の距離\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//直線と線分の距離\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//線分と点の距離\ndouble distanceSP(const L &s, const C p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//線分と線分の距離\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\ndouble getarea(C c1,double r1,C a,C b)\n{\n    C va=c1-a,vb=c1-b;\n    double A=abs(va),B=abs(vb);\n    double f=cross(va,vb),d=distanceSP(L(a,b),c1),res=0;\n    if(eq(f,0.0))   return 0;\n    if(A < r1+EPS && B < r1+EPS)    return f*0.5;\n    if(d>r1-EPS)    return r1*r1*M_PI*getarg(va,vb)/(2.0*M_PI);\n    vector<C> u=crosspointCS(c1,r1,L(a,b));\n    u.insert(u.begin(),a),u.push_back(b);\n    for(int i=0;i+1<(int)u.size();i++){\n        res+=getarea(c1,r1,u[i],u[i+1]);\n    }\n    return res;\n}\n//円と多角形の共通部分の面積\ndouble getcrossarea(const vector<C>& t,C c1,double r1)\n{\n    int n = (int)t.size();\n    if(n<3) return 0;\n    double res=0;\n    rep(i,n){\n      C a=t[i], b=t[(i+1)%n];\n      res += getarea(c1,r1,a,b);\n    }\n    return res;\n}\n//凸包を求める(O(nlogn))\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = (int)ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//凸性判定\nbool isconvex(const vector<C>& ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//多角形の符号付き面積(左回りが正)\ndouble area(const vector<C>& ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//凸多角形を直線で切断した時の左側の図形\nvector<C> convex_cut(const vector<C>& ps, const L& l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(L(A, B),l));\n    }\n    return Q;\n}\n//垂直二等分線\nL bisector(C a, C b){\n    C A = (a + b) * C(0.5, 0);\n    return L(A, A + rot(b - a, PI/2));\n}\n//ボロノイ図(正確にはvoronoi_cellを求める)\n//愚直であるため1つのvoronoi_cellを求めるのにかかる計算量がO(n^2)\nvector<C> voronoi(vector<C> poly, vector<C>& p, int s){\n    rep(i,(int)p.size()){\n        if (i != s){\n            poly = convex_cut(poly, bisector(p[s], p[i]));\n        }\n    }\n    return poly;\n}\n//点が多角形に包含されているか(0は含まれない,1は辺上,2は含まれる)\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//凸多角形の交差\nvector<C> convex_intersection(const vector<C>& ps,const vector<C>& qs)\n{\n\tvector<C> rs;\n\tint a = ps.size(),b = qs.size();\n\trep(i,a){\n        if(contains(qs,ps[i])){\n            rs.push_back(ps[i]);\n        }\n    }\n\trep(i,b){\n        if(contains(ps,qs[i])){\n            rs.push_back(qs[i]);\n        }\n    }\n    rep(i,a){\n        rep(j,b){\n            L l1(ps[i],ps[(i+1)%a]),l2(qs[j],qs[(j+1)%b]);\n\t\t    if(intersectSS(l1,l2)){\n                rs.push_back(crosspointLL(l1,l2));\n            }\n        }\n\t}\n\tsort(rs.begin(),rs.end());\n\trs.erase(unique(rs.begin(),rs.end()),rs.end());\n\tif(rs.size() <= 1){\n        return rs;\n    }\n\treturn convex_hull(rs);\n}\n//凸多角形の直径を求める(キャリパー法)\n//maxi,maxjが最遠点対となる\ndouble convex_diameter(const vector<C>& ps)\n{\n    const int n = (int)ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nbool compyx(C c1,C c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\ndouble closest_pair(C* a, int n)\n{\n    if(n<=1) return 1e100;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compyx);\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n//最近点対を求める\ndouble compute_shortest(C* a,int n)\n{\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n//2円の位置関係を示す(返り値は2円の間の共通接線の数)\nint getstateCC(C c1,double r1,C c2,double r2)\n{\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)return 4;\n    if(d>r1+r2-EPS)return 3;\n    if(d>abs(r1-r2)+EPS)return 2;\n    if(d>abs(r1-r2)-EPS)return 1;\n    return 0;\n}\n//点から円へ接線を引いた時の接点\nC gettangentCP_(C c1,double r1,C p,int flg){\n    C base=c1-p;\n    double w=Sqrt(norm(base)-r1*r1);\n    C s=p+base*C(w,r1 * flg)/norm(base)*w;\n    return s;\n}\n//点から円への接線\nvector<L> gettangentCP(C c1,double r1,C p){\n    vector<L> res;\n    C s=gettangentCP_(c1,r1,p,1);\n    C t=gettangentCP_(c1,r1,p,-1);\n    //点が円の周上にある場合\n    if(s == t){\n        res.push_back(L(s,s+(c1-p)*C(0,1)));\n    }else{\n        res.push_back(L(p,s));\n        res.push_back(L(p,t));\n    }\n    return res;\n}\n\n//2円の共通内接線を求める\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2円の共通外接線を求める\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2円の共通接線を求める(各直線の２点はそれぞれの円の接点)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\n\nstruct edge\n{\n    int to;\n    double cost;\n};\n\nmap<C,int> mp;\nvector<C> point;\nvector<vector<edge> > G;\nbool stop[MAX_N];\nbool used[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    vector<L> line(n);\n    rep(i,n){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        if(C(c,d) < C(a,b)) swap(a,c),swap(b,d);\n        line[i] = L(C(a,b),C(c,d));\n        if(mp.find(C(a,b)) == mp.end()){\n            mp[C(a,b)] = len(point);\n            point.pb(C(a,b));\n        }\n        if(mp.find(C(c,d)) == mp.end()){\n            mp[C(c,d)] = len(point);\n            point.pb(C(c,d));\n        }\n    }\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        if(mp.find(C(a,b)) == mp.end()){\n            mp[C(a,b)] = len(point);\n            point.pb(C(a,b));\n        }\n        stop[mp[C(a,b)]] = true;\n    }\n    int a,b,c,d;\n    cin >> a >> b >> c >> d;\n    if(mp.find(C(a,b)) == mp.end()){\n        mp[C(a,b)] = len(point);\n        point.pb(C(a,b));\n    }\n    if(mp.find(C(c,d)) == mp.end()){\n        mp[C(c,d)] = len(point);\n        point.pb(C(c,d));\n    }\n    int s = mp[C(a,b)], t = mp[C(c,d)];\n    int V = len(point);\n    G.resize(len(point));\n    double al = 0;\n    rep(i,n){\n        vector<C> ten = line[i];\n        rep(j,len(point)){\n            if(intersectSP(line[i],point[j])){\n                ten.pb(point[j]);\n            }\n        }\n        rep(j,n){\n            if(j != i && intersectSS(line[i],line[j])){\n                ten.pb(crosspointLL(line[i],line[j]));\n            }\n        }\n        zip(ten);\n        vi val(len(ten));\n        rep(j,len(ten)){\n            val[j] = mp[ten[j]];\n        }\n        rep(j,len(ten)-1){\n            double dir = abs(ten[j+1]-ten[j]);\n            al += dir;\n            G[val[j]].pb((edge){val[j+1],dir}),G[val[j+1]].pb((edge){val[j],dir});\n        }\n    }\n    double stream = 0;\n    vd dist(V,INF);\n    priority_queue<P,vp,greater<P> > que;\n    que.push(P(0,t));\n    while(!que.empty()){\n        P p = que.top();\n        que.pop();\n        if(dist[p.se] < p.fi) continue;\n        if(stop[p.se]){\n            used[p.se] = true;\n            continue;\n        }\n        if(s == p.se){\n            printf(\"-1\\n\");\n            return 0;\n        }\n        each(e,G[p.se]){\n            if(dist[e.to] > p.fi+e.cost){\n                dist[e.to] = p.fi+e.cost;\n                stream += e.cost;\n                que.push(P(dist[e.to],e.to));\n            }\n        }\n    }\n    // vector<bool> visit(V,false);\n    // queue<int> q;\n    // q.push(s);\n    // visit[s] = true;\n    // double stream = 0;\n    // while(!q.empty()){\n    //     int p = q.front();\n    //     q.pop();\n    //     visit[p] = true;\n    //     each(e,G[p]){\n    //         if(used[e.to]){\n    //             visit[e.to] = true;\n    //             stream += e.cost;\n    //         }else if(!visit[e.to]){\n    //             visit[e.to] = true;\n    //             stream += e.cost;\n    //             q.push(e.to);\n    //         }\n    //     }\n    // }\n    printf(\"%.12lf\\n\",stream);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n    //grid-point only\n    //return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nstruct EndPoint{\n  Point p;\n  int seg,st;\n  EndPoint(){}\n  EndPoint(Point p,int seg,int st):p(p),seg(seg),st(st){}\n  bool operator<(const EndPoint &ep)const{\n    if(p.y==ep.p.y) return st<ep.st;\n    return p.y<ep.p.y;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nistream &operator >> (istream &is,Polygon &p){\n  for(int i=0;i<(int)p.size();i++) is>>p[i];\n  return is;\n}\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nPoint orth(Point p){return Point(-p.y,p.x);}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nbool intersectPS(Polygon p,Segment l);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\nvector< vector<int> >\nsegmentArrangement(vector<Segment> &ss, Polygon &ps);\n  \nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool intersectPS(Polygon p,Segment l){\n  int n=p.size();\n  for(int i=0;i<n;i++)\n    if(intersectSS(Segment(p[i],p[(i+1)%n]),l)) return 1;\n  return 0;\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  return getDistanceSP(s,c.c)<=c.r;\n}\n\nint intersectCS(Circle c,Segment s){\n  if(norm(project(s,c.c)-c.c)-c.r*c.r>EPS) return 0;\n  double d1=abs(c.c-s.p1),d2=abs(c.c-s.p2);\n  if(d1<c.r+EPS&&d2<c.r+EPS) return 0;\n  if((d1<c.r-EPS&&d2>c.r+EPS)||(d1>c.r+EPS&&d2<c.r-EPS)) return 1;\n  Point h=project(s,c.c);\n  if(dot(s.p1-h,s.p2-h)<0) return 2;\n  return 0;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n             min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  for(int k=0;k<2;k++){\n    if(getDistanceSP(s1,s2.p1)<EPS) return s2.p1; \n    if(getDistanceSP(s1,s2.p2)<EPS) return s2.p2;\n    swap(s1,s2);\n  }\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon ps;\n  Point pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  if(equals(getDistanceLP(l,c.c),c.r)){\n    ps.emplace_back(pr);\n    return ps;\n  }\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  ps.emplace_back(pr+e*base);\n  ps.emplace_back(pr-e*base);\n  return ps;\n}\n\nPolygon getCrossPointCS(Circle c,Segment s){\n  Line l(s);\n  Polygon res=getCrossPointCL(c,l);\n  if(intersectCS(c,s)==2) return res;\n  if(res.size()>1u){\n    if(dot(l.p1-res[0],l.p2-res[0])>0) swap(res[0],res[1]);\n    res.pop_back();\n  }\n  return res;\n}\n\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return res;\n}\n\ndouble area(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  if(c1.r+c2.r<=d+EPS) return 0;\n  if(d<=abs(c1.r-c2.r)){\n    double r=min(c1.r,c2.r);\n    return PI*r*r;\n  }\n  double rc=(d*d+c1.r*c1.r-c2.r*c2.r)/(2*d);\n  double th=acos(rc/c1.r);\n  double ph=acos((d-rc)/c2.r);\n  return c1.r*c1.r*th+c2.r*c2.r*ph-d*c1.r*sin(th);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nvector<Line> tangent(Circle c1,Circle c2){\n  vector<Line> ls;\n  if(c1.r<c2.r) swap(c1,c2);\n  double g=norm(c1.c-c2.c);\n  if(equals(g,0)) return ls;\n  Point u=(c2.c-c1.c)/sqrt(g);\n  Point v=orth(u);\n  for(int s=1;s>=-1;s-=2){\n    double h=(c1.r+s*c2.r)/sqrt(g);\n    if(equals(1-h*h,0)){\n      ls.emplace_back(c1.c+u*c1.r,c1.c+(u+v)*c1.r);\n    }else if(1-h*h>0){\n      Point uu=u*h,vv=v*sqrt(1-h*h);\n      ls.emplace_back(c1.c+(uu+vv)*c1.r,c2.c-(uu+vv)*c2.r*s);\n      ls.emplace_back(c1.c+(uu-vv)*c1.r,c2.c-(uu-vv)*c2.r*s);\n    }\n  }\n  \n  return ls;\n}\n\ndouble closest_pair(Polygon &a,int l=0,int r=-1){\n  if(r<0){\n    r=a.size();\n    sort(a.begin(),a.end(),sort_x);\n  }\n  if(r-l<=1) return abs(a[0]-a[1]);\n  int m=(l+r)>>1;\n  double x=a[m].x;\n  double d=min(closest_pair(a,l,m),closest_pair(a,m,r));\n  inplace_merge(a.begin()+l,a.begin()+m,a.begin()+r,sort_y);\n\n  Polygon b;\n  for(int i=l;i<r;i++){\n    if(fabs(a[i].x-x)>=d) continue;\n    for(int j=0;j<(int)b.size();j++){\n      double dy=a[i].y-next(b.rbegin(),j)->y;\n      if(dy>=d) break;\n      d=min(d,abs(a[i]-*next(b.rbegin(),j)));\n    }\n    b.emplace_back(a[i]);\n  }\n  return d;\n}\n\nvector<vector<int> > \nsegmentArrangement(vector<Segment> &ss, Polygon &ps){\n  int n=ss.size();\n  for(int i=0;i<n;i++){\n    ps.emplace_back(ss[i].p1);\n    ps.emplace_back(ss[i].p2);\n    for(int j=i+1;j<n;j++)\n      if(intersectSS(ss[i],ss[j]))\n        ps.emplace_back(getCrossPointSS(ss[i],ss[j]));\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n\n  vector<vector<int> > G(ps.size());\n  for(int i=0;i<n;i++){\n    vector<pair<double,int> > ls;\n    for(int j=0;j<(int)ps.size();j++)\n      if(getDistanceSP(ss[i],ps[j])<EPS)\n        ls.emplace_back(make_pair(norm(ss[i].p1-ps[j]),j));\n      \n    sort(ls.begin(),ls.end());\n    for(int j=0;j+1<(int)ls.size();j++){\n      int a=ls[j].second,b=ls[j+1].second;\n      G[a].emplace_back(b);\n      G[b].emplace_back(a);\n    }\n  }  \n  for(auto &v:G){\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());    \n  }\n  return G;\n}\n\nint manhattanIntersection(vector<Segment> ss,const int INF){\n  const int BTM = 0;\n  const int LFT = 1;\n  const int RGH = 2;\n  const int TOP = 3;\n  \n  int n=ss.size();\n  vector<EndPoint> ep;\n  for(int i=0;i<n;i++){\n    if(ss[i].p1.y==ss[i].p2.y){\n      if(ss[i].p1.x>ss[i].p2.x) swap(ss[i].p1,ss[i].p2);\n      ep.emplace_back(ss[i].p1,i,LFT);\n      ep.emplace_back(ss[i].p2,i,RGH);\n    }else{\n      if(ss[i].p1.y>ss[i].p2.y) swap(ss[i].p1,ss[i].p2);      \n      ep.emplace_back(ss[i].p1,i,BTM);\n      ep.emplace_back(ss[i].p2,i,TOP);\n    }    \n  }   \n  sort(ep.begin(),ep.end());\n\n  set<int> bt;\n  bt.insert(INF);\n  \n  int cnt=0;\n  for(int i=0;i<n*2;i++){\n    if(ep[i].st==TOP){\n      bt.erase(ep[i].p.x);\n    }else if(ep[i].st==BTM){\n      bt.emplace(ep[i].p.x);\n    }else if(ep[i].st==LFT){\n      auto b=bt.lower_bound(ss[ep[i].seg].p1.x);\n      auto e=bt.upper_bound(ss[ep[i].seg].p2.x);\n      cnt+=distance(b,e);\n    }    \n  }\n  \n  return cnt;\n}\n\ndouble area(Polygon ps,Circle c){\n  if(ps.size()<3u) return 0;\n  function<double(Circle, Point, Point)> dfs=\n    [&](Circle c,Point a,Point b){\n      Vector va=c.c-a,vb=c.c-b;\n      double f=cross(va,vb),res=0;\n      if(equals(f,0.0)) return res;\n      if(max(abs(va),abs(vb))<c.r+EPS) return f;\n      Vector d(dot(va,vb),cross(va,vb));\n      if(getDistanceSP(Segment(a,b),c.c)>c.r-EPS)\n        return c.r*c.r*atan2(d.y,d.x);\n      auto u=getCrossPointCS(c,Segment(a,b));\n      if(u.empty()) return res;\n      if(u.size()>1u&&dot(u[1]-u[0],a-u[0])>0) swap(u[0],u[1]);\n      u.emplace(u.begin(),a);\n      u.emplace_back(b);\n      for(int i=1;i<(int)u.size();i++)\n        res+=dfs(c,u[i-1],u[i]);\n      return res;\n    };\n  double res=0;\n  for(int i=0;i<(int)ps.size();i++)\n    res+=dfs(c,ps[i],ps[(i+1)%ps.size()]);\n  return res/2;\n}\n\n//END CUT HERE\n\n//Projection\nsigned AOJ_CGL1A(){\n  Point p1,p2;\n  cin>>p1>>p2;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p;\n    cin>>p;\n    cout<<project(Line(p1,p2),p)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A&lang=jp\n*/\n\n//Reflect\nsigned AOJ_CGL1B(){\n  Point p1,p2;\n  cin>>p1>>p2;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p;\n    cin>>p;\n    cout<<reflect(Line(p1,p2),p)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B&lang=jp\n*/\n\n//CCW\nsigned AOJ_CGL1C(){\n  Point p0,p1;\n  cin>>p0>>p1;\n  int q;\n  cin>>q;\n  while(q--){\n    Point p2;\n    cin>>p2;\n    int t=ccw(p0,p1,p2);\n    if(t==CCW_COUNTER_CLOCKWISE) cout<<\"COUNTER_CLOCKWISE\"<<endl;\n    if(t==CCW_CLOCKWISE) cout<<\"CLOCKWISE\"<<endl;\n    if(t==CCW_ONLINE_BACK) cout<<\"ONLINE_BACK\"<<endl;\n    if(t==CCW_ONLINE_FRONT) cout<<\"ONLINE_FRONT\"<<endl;\n    if(t==CCW_ON_SEGMENT) cout<<\"ON_SEGMENT\"<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=jp\n*/\n\n//Parallel / Orthogonal\nsigned AOJ_CGL2A(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    if(isParallel(Line(p0,p1),Line(p2,p3))) cout<<2<<endl;\n    else if(isOrthogonal(Line(p0,p1),Line(p2,p3))) cout<<1<<endl;\n    else cout<<0<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A&lang=jp\n*/\n\n//intersectSS\nsigned AOJ_CGL2B(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    cout<<(intersectSS(Segment(p0,p1),Segment(p2,p3)))<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B&lang=jp\n*/\n\n//cross point\nsigned AOJ_CGL2C(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    cout<<getCrossPointSS(Segment(p0,p1),Segment(p2,p3))<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C&lang=jp\n*/\n\n//distanceSS\nsigned AOJ_CGL2D(){\n  int q;\n  cin>>q;\n  while(q--){\n    Point p0,p1,p2,p3;\n    cin>>p0>>p1>>p2>>p3;\n    printf(\"%.12f\\n\",getDistanceSS(Segment(p0,p1),Segment(p2,p3)));\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D&lang=jp\n*/\n\n//area of Polygon\nsigned AOJ_CGL3A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.1f\\n\",area(p));\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A&lang=jp\n*/\n\n\n//isConvex\nsigned AOJ_CGL3B(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  cout<<isConvex(p)<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B&lang=jp\n*/\n\n\n\n//contains\nsigned AOJ_CGL3C(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  int q;\n  cin>>q;\n  while(q--){\n    Point r;\n    cin>>r;\n    cout<<contains(p,r)<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C\n*/\n\n\n//convex hull\nsigned AOJ_CGL4A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  Polygon q=convex_hull(p);\n  cout<<q.size()<<endl;\n  for(Point v:q) cout<<v.x<<\" \"<<v.y<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A&lang=jp\n*/\n\n//diameter of Polygon\nsigned AOJ_CGL4B(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  printf(\"%.12f\\n\",diameter(p));\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B&lang=jp\n*/\n\n//convexCut:\nsigned AOJ_CGL4C(){\n  int n;\n  cin>>n;\n  Polygon g(n);\n  for(int i=0;i<n;i++) cin>>g[i];\n  Polygon p=andrewScan(g);\n  int q;\n  cin>>q;\n  while(q--){\n    Line l;\n    cin>>l.p1>>l.p2;\n    printf(\"%.12f\\n\",area(convexCut(p,l)));\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C&lang=jp\n*/\n\n//closest pair:\nsigned AOJ_CGL5A(){\n  int n;\n  cin>>n;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  cout<<fixed<<setprecision(12)<<closest_pair(p)<<endl;\n  return 0;\n}\n/*\n  verified on 2018/01/04\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A&lang=jp\n*/\n\n//manhattanIntersection:\nsigned AOJ_CGL6A(){\n  int n;\n  cin>>n;\n  vector<Segment> ss(n);\n  for(int i=0;i<n;i++) cin>>ss[i];\n  //for(int i=0;i<n;i++) cout<<ss[i].p1<<\":\"<<ss[i].p2<<endl;\n  cout<<manhattanIntersection(ss,1e9+10)<<endl;\n  return 0;\n}\n/*\n  verified on 2018/06/18\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_6_A&lang=jp\n*/\n\n//intersectCC\nsigned AOJ_CGL7A(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  cout<<intersectCC(c1,c2)<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&lang=jp\n*/\n\n\n//getCrossPointCL\nsigned AOJ_CGL7D(){\n  Circle c;\n  int q;\n  cin>>c>>q;\n  while(q--){\n    Line l;\n    cin>>l;\n    auto pp=getCrossPointCL(c,l);\n    if(pp.size()==1u) pp.emplace_back(pp[0]);\n    if(pp[1]<pp[0]) swap(pp[0],pp[1]);\n    cout<<pp[0]<<\" \"<<pp[1]<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D&lang=jp\n*/\n\n//intersectCC\nsigned AOJ_CGL7E(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  auto pp=getCrossPointCC(c1,c2);\n  if(pp.size()==1u) pp.emplace_back(pp[0]);\n  if(pp[1]<pp[0]) swap(pp[0],pp[1]);\n  cout<<pp[0]<<\" \"<<pp[1]<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E&lang=jp\n*/\n\n//tangent to a Circle\nsigned AOJ_CGL7F(){\n  Point p;\n  Circle c;\n  cin>>p>>c;\n  auto pp=tangent(c,p);\n  for(auto p:pp) cout<<p<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F&lang=jp\n*/\n\n//Common Tangent\nsigned AOJ_CGL7G(){\n  Circle c1,c2;\n  cin>>c1>>c2;\n  auto ls=tangent(c1,c2);\n  Polygon ps;\n  for(auto l:ls) ps.emplace_back(getCrossPointCL(c1,l)[0]);\n  sort(ps.begin(),ps.end());\n  for(auto p:ps) cout<<p<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge//description.jsp?id=CGL_7_G&lang=jp\n*/\n\n//Intersection of a Circle and a Polygon\nsigned AOJ_CGL7H(){\n  int n;\n  double r;\n  cin>>n>>r;\n  Circle c(Point(0,0),r);\n  Polygon ps(n);\n  for(int i=0;i<n;i++) cin>>ps[i];\n  cout<<fixed<<setprecision(12)<<area(ps,c)<<endl;\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge//description.jsp?id=CGL_7_G&lang=jp\n*/\n\n//area of 2 circles' intersection\nsigned AOJ_2572(){\n  double uw,uh,a,b,ab;\n  while(cin>>uw>>uh>>a>>b>>ab,uw!=0){\n    Circle c1(Point(0,0),sqrt(a/PI));\n    Circle c2(Point(0,0),sqrt(b/PI));\n    bool f=0;\n    if(c1.r<=c2.r) swap(c1,c2),f=1;\n    double l=max(0.0,c1.r-c2.r),r=c1.r+c2.r+EPS;\n    for(int k=0;k<100;k++){\n      double m=(l+r)/2;\n      c2.c.x=m;\n      //cout<<area(c1,c2)<<endl;\n      if(area(c1,c2)<=ab) r=m;\n      else l=m;\n    }\n    c2.c.x=l;\n    \n    double EPS3=1e-4;\n    assert(abs(area(c1,c2)-ab)<=EPS3);\n\n    l=0,r=PI/2;\n    for(int k=0;k<200;k++){\n      double m=(l+r)/2;\n      Circle t=c2;\n      t.c=translate(c2.c,m);\n      if(c1.r+max(c1.r,t.c.x+t.r)<=uw) r=m;\n      else l=m;\n    }\n    c2.c=translate(c2.c,r);\n    //cout<<c1.c<<\"/\"<<c2.c<<endl;\n    \n    Vector v(c1.r,c1.r);\n    c1.c=c1.c+v;\n    c2.c=c2.c+v;\n    \n    //cout<<c1.c<<\"/\"<<c2.c<<endl;\n\n    if(f) swap(c1,c2);\n    f=1;\n    f&=(c1.c.x-c1.r>=-EPS3);\n    f&=(c1.c.x+c1.r<=uw+EPS3);\n    f&=(c1.c.y-c1.r>=-EPS3);\n    f&=(c1.c.y+c1.r<=uh+EPS3);\n    f&=(c2.c.x-c2.r>=-EPS3);\n    f&=(c2.c.x+c2.r<=uw+EPS3);\n    f&=(c2.c.y-c2.r>=-EPS3);\n    f&=(c2.c.y+c2.r<=uh+EPS3);\n    if(f) cout<<c1.c<<\" \"<<c1.r<<\" \"<<c2.c<<\" \"<<c2.r<<endl;\n    else cout<<\"impossible\"<<endl;\n    //else cout<<c1.c<<\" \"<<c1.r<<\"/\"<<c2.c<<\" \"<<c2.r<<endl;\n  }\n  return 0;\n}\n/*\n  verified on 2017/12/31\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2572\n*/\n\n//Segment Arrangement\nsigned AOJ_2454(){\n  int n,m;\n  cin>>n>>m;\n  vector<Segment> ss(n);\n  Polygon ps(m);\n  for(int i=0;i<n;i++) cin>>ss[i];\n  for(int i=0;i<m;i++) cin>>ps[i];\n  map<Point, int> mp;\n  for(int i=0;i<m;i++) mp[ps[i]]=i;\n  Point s,g;\n  cin>>s>>g;\n  ps.emplace_back(s);\n  ps.emplace_back(g);\n\n  auto H=segmentArrangement(ss,ps);\n  vector<vector<pair<int, double> > > G(H.size());\n  for(int i=0;i<(int)H.size();i++)\n    for(int j:H[i]) G[i].emplace_back(j,abs(ps[i]-ps[j]));\n  \n  double ans=0,tmp=0;\n  for(int i=0;i<n;i++) ans+=abs(ss[i].p1-ss[i].p2);\n\n  vector<int> used(G.size(),0);\n  queue<int> q;\n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==g) {used[i]=1;q.emplace(i);}\n\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    if(ps[v]==s){\n      cout<<(int)-1<<endl;\n      return 0;\n    }\n    if(mp.count(ps[v])) continue;\n    for(int u:H[v]){\n      if(!used[u]){\n        used[u]=1;\n        q.emplace(u);\n      }\n    }\n  }\n  \n  for(int i=0;i<(int)G.size();i++)\n    if(ps[i]==s) q.emplace(i);\n\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(auto &e:G[v]){\n      int u=e.first;\n      double &c=e.second;\n      if(used[v]&&used[u]) continue;\n      if(c==0) continue;\n      tmp+=c;c=0;\n      q.emplace(u);\n    }\n  }\n  tmp/=2;\n  \n  cout<<fixed<<setprecision(12)<<ans-tmp<<endl;\n  return 0;\n}\n/*\n  verified on 2018/01/27\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2454\n*/\n\n\n\nsigned main(){\n  //AOJ_CGL1A();\n  //AOJ_CGL1B();\n  //AOJ_CGL1C();\n\n  //AOJ_CGL2A();\n  //AOJ_CGL2B();\n  //AOJ_CGL2C();\n  //AOJ_CGL2D();\n  \n  //AOJ_CGL3A();\n  //AOJ_CGL3B();\n  //AOJ_CGL3C();\n  \n  //AOJ_CGL4A();\n  //AOJ_CGL4B();\n  //AOJ_CGL4C();\n  \n  //AOJ_CGL5A();\n\n  //AOJ_CGL6A();\n  \n  //AOJ_CGL7A();\n  //AOJ_CGL7D();\n  //AOJ_CGL7E();\n  //AOJ_CGL7F();\n  //AOJ_CGL7G();\n  //AOJ_CGL7H();\n\n  //AOJ_2572();\n  AOJ_2454();\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-12, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\n//　重なってる部分あるとassert(false)\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 線分と線分の交点\n//　重なってる部分あるとassert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s,t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l]) {\n\t\t\t\t\treturn s[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0,0);\n\t}\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n// 点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef double Weight;\n\nstruct Edge { int from, to; Weight weight;\nint id;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight,const int id) {\n\tg[from].push_back(Edge{ from, to, weight,id});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<pair<Point,bool>> &p) {\n\tint n = p.size(), m = s.size();\n\tint id = 0;\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j].first))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j].first), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from].first - p[to].first), id);\n\t\t\tadd_edge(g, to, from, abs(p[from].first - p[to].first), id++);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nint startid;\nint goalid;\nbool dfs0(const Graph&g,const int now, vector<bool>&came, vector<bool>&close,const vector<bool>&bulbs) {\n\tcame[now] = true;\n\tfor (auto e : g[now]) {\n\t\tif (!came[e.to]) {\n\t\t\tif (e.to == startid)return false;\n\t\t\telse {\n\t\t\t\tif (bulbs[e.to]) {\n\t\t\t\t\tclose[e.to] = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!dfs0(g, e.to, came, close, bulbs)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ndouble dfs1(const Graph&g, const int now, vector<bool>&came,vector<bool>&useedges, const vector<bool>&close) {\n\tcame[now] = true;\n\tdouble ans = 0;\n\tfor (auto e : g[now]) {\n\t\tif (!useedges[e.id]) {\n\t\t\tans += e.weight;\n\t\t\tuseedges[e.id] = true;\n\t\t\tif (close[e.to])continue;\n\t\t\telse {\n\t\t\t\tif(!came[e.to])ans += dfs1(g, e.to, came,useedges, close);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tdouble sum = 0;\n\tGraph g;\n\tint sx, sy, gx, gy;\n\tPoint start;\n\tPoint goal;\n\tvector<pair<Point, bool>>crss;\n\tvector<bool>bulbs;\n\t{\n\t\tint N, M; cin >> N >> M;\n\t\tvector<Line>ls;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint asx, asy, dx, dy; cin >> asx >> asy >> dx >> dy;\n\t\t\tls.push_back(Line(Point(asx, asy), Point(dx, dy)));\n\t\t\tsum += (abs(Point(asx, asy) - Point(dx, dy)));\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < ls.size(); ++j) {\n\t\t\t\tif(isis_ss(ls[i], ls[j])) {\n\t\t\t\t\tcrss.push_back(make_pair(is_ss(ls[i], ls[j]), false));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < ls.size(); ++i) {\n\t\t\tcrss.push_back(make_pair(ls[i][0], false));\n\t\t\tcrss.push_back(make_pair(ls[i][1], false));\n\t\t}\n\t\t\n\t\tvector<Point >bs;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tPoint p(x, y);\n\t\t\tbs.push_back(p);\n\t\t}\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tstart = Point(sx, sy);\n\t\tgoal = Point(gx, gy);\t\n\t\tcrss.push_back(make_pair(start, false));\n\t\tcrss.push_back(make_pair(goal, false));\n\t\tsort(crss.begin(), crss.end());\n\t\tcrss.erase(unique(crss.begin(), crss.end()), crss.end());\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tauto it = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == bs[i]; });\n\t\t\tif (it == crss.end()) {\n\t\t\t\tcrss.push_back(make_pair(bs[i], true));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(*it).second = true;\n\t\t\t}\n\t\t}\n\n\n\t\tfor (int i = 0; i < crss.size(); ++i) {\n\t\t\tbulbs.push_back(crss[i].second);\n\t\t}\n\t\tg= segment_arrangement(ls, crss);\n\t}\n\tauto startit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == start; });\n\tstartid = startit - crss.begin();\n\tauto goalit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == goal; });\n\tgoalid = goalit - crss.begin();\n\tvector<bool>close(crss.size(),false);\n\tvector<bool>came(crss.size(), false);\n\tif (dfs0(g, goalid, came, close, bulbs)) {\n\t\tvector<bool>acame(crss.size(), false);\n\t\tvector<bool>useedges(80000, false);\n\t\tdouble ans = dfs1(g, startid, acame, useedges,close);\n\t\tcout <<fixed<<setprecision(10)<< sum-ans << endl;\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    if (fabs(a.real() - b.real()) < EPS * 10 &&\n        fabs(a.imag() - b.imag()) < EPS * 10) { return false; }\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L() {}\n};\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ntypedef int Weight;\nstruct Edge {\n  int dst;\n  Weight weight;\n  Edge(int dst, Weight weight) :\n    dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nGraph segmentArrangement(const vector<L> &ss, vector<P> &ps) {\n  for (int i = 0; i < ss.size(); ++i) { // O(n^2)\n    ps.push_back( ss[i][0] );\n    ps.push_back( ss[i][1] );\n    for (int j = i+1; j < ss.size(); ++j)\n      if (intersectSS(ss[i], ss[j])) {\n        ps.push_back( crosspoint(ss[i], ss[j]) );\n      }\n  }\n  sort(ALL(ps)); ps.erase(unique(ALL(ps)), ps.end());\n\n  Graph g(ps.size());\n  for (int i = 0; i < ss.size(); ++i) {\n    vector< pair<double, int> > list;\n    for (int j = 0; j < ps.size(); ++j)\n      if (intersectSP(ss[i], ps[j]))\n        list.push_back(make_pair(norm(ss[i][0]-ps[j]), j));\n    sort(ALL(list));\n    for (int j = 0; j+1 < list.size(); ++j) {\n      int a = list[j].second, b = list[j+1].second;\n      g[a].push_back( Edge(b, abs(ps[a]-ps[b])) );\n      g[b].push_back( Edge(a, abs(ps[a]-ps[b])) );\n    }\n  }\n  return g;\n}\n\nbool visited[2][200000];\nP p[1002];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<L> ss;\n  double sum = 0;\n  REP(i,n) {\n    int x1,y1,x2,y2;\n    cin>>x1>>y1>>x2>>y2;\n    ss.push_back(L(P(x1,y1),P(x2,y2)));\n    sum += abs(P(x1,y1)-P(x2,y2));\n  }\n  vector<P> ps;\n  REP(i,m+2) {\n    cin >> p[i].real() >> p[i].imag();\n    ps.push_back(p[i]);\n  }\n  Graph g = segmentArrangement(ss,ps);\n  map<P,int> mp;\n  map<P,pii> mp2;\n  REP(i,ps.size()) {\n    mp[ps[i]] = i;\n  }\n  REP(i,m+2) {\n    mp2[p[i]] = pii(mp[p[i]],i);\n  }\n  queue<int> Q;\n  Q.push(mp[p[m+1]]);\n  while(!Q.empty()) {\n    int now = Q.front(); Q.pop();\n    visited[0][now] = 1;\n    if (mp2.count(ps[now]) && mp2[ps[now]].second < m) continue;\n    FOR(it, g[now]) {\n      if (!visited[0][it->dst]) {\n        Q.push(it->dst);\n      }\n    }\n  }\n  if (visited[0][mp[p[m]]]) {\n    puts(\"-1\");\n    return 0;\n  }\n  Q.push(mp[p[m]]);\n  double ans = 0;\n  while(!Q.empty()) {\n    int now = Q.front(); Q.pop();\n\n    if (visited[0][now]) continue;\n    visited[1][now] = 1;\n    \n    FOR(it, g[now]) {\n      int a = min(now,it->dst);\n      int b = max(now, it->dst);\n      if (!visited[1][it->dst]) {\n        ans += it->weight;\n        Q.push(it->dst);\n      }\n    }\n  }\n  printf(\"%.10f\\n\", sum-ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double eps = 1e-8;\n#define eq(a, b) (fabs((a)-(b)) < eps)\n#define lt(a, b) ((a)-(b) < -eps)\n\nstruct Point {\n  double x, y;\n  Point(double x=0, double y=0):x(x), y(y){}\n  Point operator+(Point p) {return Point(x+p.x, y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x, y-p.y);}\n  Point operator*(double a) {return Point(x*a, y*a);}\n  Point operator/(double a) {return Point(x/a, y/a);}\n  bool operator<(const Point& p) const {return x!=p.x?x<p.x:y<p.y;}\n  bool operator==(const Point& p) const {return eq(x, p.x)&&eq(y, p.y);}\n};\nusing Vector = Point;\n\ndouble dot(Vector a, Vector b) {return a.x*b.x+a.y*b.y;}\ndouble cross(Vector a, Vector b) {return a.x*b.y-a.y*b.x;}\ndouble norm(Vector a) {return dot(a, a);}\ndouble abs(Vector a) {return sqrt(norm(a));}\n\nconst int CCW = 1;\nconst int CW = -1;\nconst int BCK = 2;\nconst int FNT = -2;\nconst int ON = 0;\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a, b) > eps) return CCW;\n  if(cross(a, b) < -eps) return CW;\n  if(dot(a, b) < -eps) return BCK;\n  if(norm(a) < norm(b)) return FNT;\n  return ON;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\ndouble distance(Point a, Point b) {return abs(a-b);}\n\nstruct Segment {\n  Point s, t;\n  Segment(Point s=Point(), Point t=Point()):s(s), t(t){}\n};\nusing Line = Segment;\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.s, s1.t, s2.s, s2.t);\n}\nbool intersect(Segment s, Point p) {\n  return abs(s.s-p)+abs(s.t-p)-abs(s.t-s.s) < eps;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(cross(l.t-l.s, p-l.s)/abs(l.t-l.s));\n}\ndouble distanceSP(Segment s, Point p) {\n  if(dot(s.t-s.s, p-s.s) < 0) return abs(p-s.s);\n  if(dot(s.s-s.t, p-s.t) < 0) return abs(p-s.t);\n  return distanceLP(s, p);\n}\ndouble distance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0;\n  return min(min(distanceSP(s1, s2.s), distanceSP(s1, s2.t)),\n\t     min(distanceSP(s2, s1.s), distanceSP(s2, s1.t)));\n}\nPoint crossPoint(Segment s1, Segment s2) {\n  Vector base = s2.t-s2.s;\n  double d1 = abs(cross(base, s1.s-s2.s));\n  double d2 = abs(cross(base, s1.t-s2.s));\n  double t = d1/(d1+d2);\n  return s1.s+(s1.t-s1.s)*t;\n}\n\nbool merge(Segment& s1, Segment s2) {\n  if(abs(cross(s1.t-s1.s, s2.t-s2.s)) > eps) return false;\n  if(ccw(s1.s, s2.s, s1.t) == CCW ||\n     ccw(s1.s, s2.s, s1.t) == CW) return false;\n  if(ccw(s1.s, s1.t, s2.s) == FNT ||\n     ccw(s2.s, s2.t, s1.s) == FNT) return false;\n  s1 = Segment(min(s1.s, s2.s), max(s1.t, s2.t));\n  return true;\n}\nvoid mergeSegments(vector<Segment>& segs) {\n  for(int i = 0; i < (int)segs.size(); ++i) {\n    if(segs[i].t < segs[i].s) swap(segs[i].s, segs[i].t);\n  }\n  for(int i = 0; i < (int)segs.size(); ++i) {\n    for(int j = i+1; j < (int)segs.size(); ++j) {\n      if(merge(segs[i], segs[j])) {\n\tsegs[j--] = segs.back();\n\tsegs.pop_back();\n      }\n    }\n  }\n}\n\nstruct edge {\n  int to;\n  double cost;\n  int id;\n  edge(){}\n  edge(int to, double cost, int id):to(to), cost(cost), id(id){}\n  bool operator<(const edge& e) {return lt(cost, e.cost);}\n};\nusing Graph = vector<vector<edge> >;\n\nvector<int> type;\nmap<Point, int> mp;\nint id = 0;\ndouble sum = 0;\n\nGraph segmentArrangement(vector<Segment>& segs, vector<Point>& ps) {\n  for(int i = 0; i < (int)segs.size(); ++i) {\n    ps.push_back(segs[i].s);\n    ps.push_back(segs[i].t);\n    for(int j = i+1; j < (int)segs.size(); ++j) {\n      if(intersect(segs[i], segs[j])) ps.push_back(crossPoint(segs[i], segs[j]));\n    }\n  }\n  sort(ps.begin(), ps.end());\n  ps.erase(unique(ps.begin(), ps.end()), ps.end());\n  //cout<<\"AFTER\"<<endl;\n  //for(int i = 0; i < (int)ps.size(); ++i) cout<<mp[ps[i]]<<\" \"<<ps[i].x<<\" \"<<ps[i].y<<endl;\n  for(int i = 0; i < (int)ps.size(); ++i) type.push_back(mp[ps[i]]);\n  Graph graph(ps.size());\n  for(int i = 0; i < (int)segs.size(); ++i) {\n    vector<pair<double, int> > ls;\n    for(int j = 0; j < (int)ps.size(); ++j) {\n      if(intersect(segs[i], ps[j])) {\n\tls.emplace_back(norm(segs[i].s-ps[j]), j);\n      }\n    }\n    sort(ls.begin(), ls.end());\n    for(int j = 0; j+1 < (int)ls.size(); ++j) {\n      int u = ls[j].second, v = ls[j+1].second;\n      graph[u].emplace_back(v, distance(ps[u], ps[v]), id);\n      graph[v].emplace_back(u, distance(ps[u], ps[v]), id);\n      ++id;\n      sum += distance(ps[u], ps[v]);\n    }\n    //sum += distance(segs[i].s, segs[i].t);\n  }\n  //cout<<sum<<endl;\n  return graph;\n}\n\nint main() {\n  int N, M;\n  vector<Segment> segs;\n  vector<Point> ps;\n\n  cin >> N >> M;\n  for(int i = 0; i < N; ++i) {\n    Point s, t;\n    cin >> s.x >> s.y >> t.x >> t.y;\n    segs.emplace_back(s, t);\n  }\n  for(int i = 0; i < M+2; ++i) {\n    Point p;\n    cin >> p.x >> p.y;\n    ps.push_back(p);\n    if(i == M) mp[p] = 1;\n    else if(i == M+1) mp[p] = 2;\n    else mp[p] = 3;\n  }\n  //cout<<\"BEFORE\"<<endl;\n  //for(auto& p : mp) cout << p.second<<\" \"<<p.first.x<<\" \"<<p.first.y<<endl;\n  mergeSegments(segs);\n  Graph graph = segmentArrangement(segs, ps);\n  int s = -1, t = -1;\n  for(int i = 0; i < (int)graph.size(); ++i) {\n    if(type[i] == 1) s = i;\n    else if(type[i] == 2) t = i;\n  }\n  assert(~s && ~t);\n\n  queue<int> que;\n  vector<bool> used(graph.size(), false);\n  que.push(t);\n  used[t] = true;\n  //cout<<s<<\" \"<<t<<endl;\n  while(!que.empty()) {\n    int v = que.front(); que.pop();\n    //cout<<v<<endl;\n    if(v == s) {\n      cout << -1 << endl;\n      return 0;\n    }\n    if(type[v] == 3) continue;\n    for(edge e : graph[v]) {\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      que.push(e.to);\n    }\n  }\n  vector<bool> usedEdge(id, false);\n  que.push(s);\n  used[s] = true;\n  while(!que.empty()) {\n    int v = que.front(); que.pop();\n    for(edge e : graph[v]) {\n      if(usedEdge[e.id]) continue;\n      sum -= e.cost;\n      usedEdge[e.id] = true;\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      que.push(e.to);\n    }\n  }\n  printf(\"%.12f\\n\", sum);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<unordered_map>\n\nusing namespace std;\n\nunordered_map<int,vector<int> > g;\n\nint main(){\n  for(int i=0;i<300;i++){\n    for(int j=-1000;j<=1000;j++){\n      g[(i<<16)+j].push_back(j);\n      g[(i<<16)+j].push_back(j);\n    }\n  }\n  int N,M;\n  cin>>N>>M;\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-6;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct segment{ point<T> a,b; };\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<double> &S,const point<double> &p){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\npoint<double> get_intersect(const segment<double> &S1,const segment<double> &S2){\n\tdouble a1=cross(S1.b-S1.a,S2.b-S2.a);\n\tdouble a2=cross(S1.b-S1.a,S1.b-S2.a);\n\tif(abs(a1)<EPS){\n\t\tif(cover(S1,S2.a)) return S2.a;\n\t\tif(cover(S1,S2.b)) return S2.b;\n\t\tif(cover(S2,S1.a)) return S1.a;\n\t\treturn S1.b;\n\t}\n\treturn S2.a+a2/a1*(S2.b-S2.a);\n}\n\n// 追加で頂点集合を指定できるように書き換え\nvoid arrangement(const vector< segment<double> > &S,const vector< point<double> > &plus,vector< point<double> > &P,vector<int> *G){\n\tint n=S.size();\n\tP=plus;\n\trep(i,n){\n\t\tP.push_back(S[i].a);\n\t\tP.push_back(S[i].b);\n\t\trep(j,i) if(intersect(S[i],S[j])) P.push_back(get_intersect(S[i],S[j]));\n\t}\n\tsort(P.begin(),P.end());\n\tP.erase(unique(P.begin(),P.end()),P.end());\n\n\trep(i,n){\n\t\tvector<int> on;\n\t\trep(u,P.size()) if(cover(S[i],P[u])) on.push_back(u);\n\t\trep(j,(int)on.size()-1){\n\t\t\tint u=on[j],v=on[j+1];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tvector< segment<double> > pipe(n);\n\trep(i,n) scanf(\"%lf%lf%lf%lf\",&pipe[i].a.x,&pipe[i].a.y,&pipe[i].b.x,&pipe[i].b.y);\n\tvector< point<double> > stop(m);\n\trep(i,m) scanf(\"%lf%lf\",&stop[i].x,&stop[i].y);\n\tpoint<double> s,t;\n\tscanf(\"%lf%lf%lf%lf\",&s.x,&s.y,&t.x,&t.y);\n\n\t// 追加の頂点集合\n\tvector< point<double> > plus=stop;\n\tplus.push_back(s);\n\tplus.push_back(t);\n\n\tvector< point<double> > P;\n\tstatic vector<int> G[100000];\n\tarrangement(pipe,plus,P,G);\n\n\tint N=P.size();\n\tstatic bool isstop[100000];\n\trep(i,m) rep(u,N) if(P[u]==stop[i]) isstop[u]=true;\n\n\tint s_id=find(P.begin(),P.end(),s)-P.begin();\n\tint t_id=find(P.begin(),P.end(),t)-P.begin();\n\n\t// t から stop をまたがずに行ける場所を見つける\n\tstatic bool vis[100000];\n\tvis[t_id]=true;\n\tqueue<int> Q; Q.push(t_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis[v]){\n\t\t\t\tvis[v]=true;\n\t\t\t\tif(!isstop[v]) Q.push(v);\n\t\t\t}\n\t\t}\n\t}\n\n\tif(vis[s_id]){ puts(\"-1\"); return 0; }\n\n\tdouble ans=0;\n\trep(i,n) ans+=dist(pipe[i].a,pipe[i].b);\n\n\t// s から vis を通らずに行ける場所を見つける\n\tstatic bool vis2[100000];\n\tvis2[s_id]=true;\n\tQ.push(s_id);\n\twhile(!Q.empty()){\n\t\tint u=Q.front(); Q.pop();\n\t\trep(i,G[u].size()){\n\t\t\tint v=G[u][i];\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v]=true;\n\t\t\t\tif(!vis[v]) Q.push(v);\n\t\t\t}\n\t\t\tif(vis[v]) ans-=dist(P[u],P[v]);   // 一回カウントされる\n\t\t\telse       ans-=dist(P[u],P[v])/2; // 二回カウントされる\n\t\t}\n\t}\n\tprintf(\"%.9f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<unordered_map>\n#include<utility>\n\nusing namespace std;\n\nmultimap<int,int> g;\nset<int> valves;\nint xb,yb,xc,yc;\nconst int O=1234;\nset<int> stopped,u;\n\nint gcd(int a,int b){\n  return b?gcd(b,a%b):a;\n}\n\nint enc(int x,int y){\n  return (x+O<<16)+y+O;\n}\n\npair<int,int> dec(int x){\n  return make_pair((x>>16)-O,(x&(1<<16)-1)-O);\n}\n\nvoid stop(int v){\n  if(!u.insert(v).second)return;\n  if(valves.count(v)){\n    stopped.insert(v);\n    return;\n  }else{\n    auto p=dec(v);\n    int x=p.first,y=p.second;\n    if(y==yb&&x==xb)throw 0;\n    auto c=g.equal_range(v);\n    for(auto it=c.first;it!=c.second;it++){\n      if(u.count(it->second))continue;\n      stop(it->second);\n    }\n  }\n}\n\ndouble rec(int v,int p){\n  if(!u.insert(v).second)return 0;\n  if(stopped.count(v))return 0;\n  auto pr=dec(v);\n  int x=pr.first,y=pr.second;\n  auto c=g.equal_range(v);\n  double r=0;\n  for(auto it=c.first;it!=c.second;it++){\n    if(it->second==p)continue;\n    auto pr=dec(it->second);\n    int nx=pr.first,ny=pr.second;\n    r+=hypot(ny-y,nx-x)+rec(it->second,v);\n  }\n  return r;\n}\n\nvoid add_edge(pair<int,int> a,pair<int,int> b){\n  g.insert(make_pair(enc(a.first,a.second),enc(b.first,b.second)));\n}\n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  double len=0;\n  for(int i=0;i<N;i++){\n    int xs,ys,xd,yd;\n    cin>>xs>>ys>>xd>>yd;\n    len+=hypot(xs-xd,ys-yd);\n    vector<pair<int,int> > v;\n    if(xs==xd||ys==yd){\n      if(xs>xd){\n\tswap(xs,xd);\n      }\n      if(ys>yd){\n\tswap(ys,yd);\n      }\n      for(int x=xs,y=ys;x<=xd&&y<=yd;x+=xs!=xd,y+=ys!=yd){\n\tv.emplace_back(x,y);\n      }\n    }else{\n      if(xd<xs){\n\tswap(xs,xd);\n\tswap(ys,yd);\n      }\n      int m=gcd(xd-xs,abs(yd-ys));\n      for(int y=ys,x=xs;x<=xd;x+=(xd-xs)/m,y+=(yd-ys)/m){\n\tv.emplace_back(x,y);\n      }\n    }\n    for(int i=0;i<v.size()-1;i++){\n      add_edge(v[i],v[i+1]);\n      add_edge(v[i+1],v[i]);\n    }\n  }\n  for(int i=0;i<M;i++){\n    int xv,yv;\n    cin>>xv>>yv;\n    valves.insert(enc(xv,yv));\n  }\n  cin>>xb>>yb>>xc>>yc;\n  try{\n    stop(enc(xc,yc));\n    u.clear();\n    cout<<fixed<<len-rec(enc(xb,yb),-1)<<endl;\n  }catch(...){\n    cout<<-1<<endl;\n  }\n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define bcnt __builtin_popcountll\n\ntypedef long double D;\ntypedef complex<D> P;\n\n#define X real()\n#define Y imag()\n\nconst D eps=1e-12;\nconst D inf=1e12;\nconst D PI=acos(-1);\n\nbool cmp_x(const P& a,const P& b){ return a.X==b.X?a.Y<b.Y:a.X<b.X; }\nbool cmp_y(const P& a,const P& b){ return a.Y==b.Y?a.X<b.X:a.Y<b.Y; }\nbool cmp_a(const P& a,const P& b){ return arg(a)==arg(b)?norm(a)<norm(b):arg(a)<arg(b); }\nD cross(P a,P b){ return (conj(a)*b).Y; }\nD dot(P a,P b){ return (conj(a)*b).X; }\nD toRag(D deg){ return deg*PI/180.0; }\nP rot(P base,P a,D theta){ return base+polar(abs(a-base),arg(a-base)+theta); }\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\nP crosspoint(L l,L m) {\n  D A=cross(l[1]-l[0],m[1]-m[0]);\n  D B=cross(l[1]-l[0],l[1]-m[0]);\n  if (abs(A)<eps&&abs(B)<eps) return m[0]; // same line\n  if (abs(A)<eps) return P(-100000,-100000);\n  return m[0]+B/A*(m[1]-m[0]);\n}\nbool intersectSP(L s,P p){\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0])<eps;\n}\n\nint N,M;\nP sp,tp;\nvector<L> ls;\nvector<P> ps;\nstruct edge{\n  int u,v;\n  D cost;\n};\nvector<int> g[100010];\nvector<edge> es;\nbool vis[2][100010];\n\nbool exist(P p){\n  rep(i,ps.size())if(abs(p-ps[i])<eps)return true;\n  return false;\n}\n\nint main(){\n  cin>>N>>M;\n  rep(i,N){\n    int x0,y0,x1,y1;\n    cin>>x0>>y0>>x1>>y1;\n    ls.push_back(L(P(x0,y0),P(x1,y1)));\n  }\n  rep(i,M){\n    int x,y;\n    cin>>x>>y;\n    ps.push_back(P(x,y));\n  }\n  {\n    int x,y;\n    cin>>x>>y;\n    sp=P(x,y);\n    cin>>x>>y;\n    tp=P(x,y);\n  }\n\n  ps.push_back(sp); ps.push_back(tp);\n\n  rep(i,N){\n    if(!exist(ls[i][0]))ps.push_back(ls[i][0]);\n    if(!exist(ls[i][1]))ps.push_back(ls[i][1]);\n    rep(j,i){\n      P cp=crosspoint(ls[i],ls[j]);\n      if(cp==P(-100000,-100000))continue;\n      D x0=max(min(ls[i][0].X,ls[i][1].X),min(ls[j][0].X,ls[j][1].X));\n      D x1=min(max(ls[i][0].X,ls[i][1].X),max(ls[j][0].X,ls[j][1].X));\n      D y0=max(min(ls[i][0].Y,ls[i][1].Y),min(ls[j][0].Y,ls[j][1].Y));\n      D y1=min(max(ls[i][0].Y,ls[i][1].Y),max(ls[j][0].Y,ls[j][1].Y));\n      if(cp.X<x0||cp.X>x1||cp.Y<y0||cp.Y>y1)continue;\n      if(!exist(cp))ps.push_back(cp);\n    }\n  }\n\n  D sum=0;\n  rep(i,N){\n    vector<int> idxs;\n    rep(j,ps.size()){\n      if(intersectSP(ls[i],ps[j]))idxs.push_back(j);\n    }\n    sort(all(idxs),[=](const int& a,const int& b){ return cmp_x(ps[a],ps[b]); });\n    rep(j,idxs.size()-1){\n      es.push_back((edge){idxs[j],idxs[j+1],abs(ps[idxs[j]]-ps[idxs[j+1]])});\n      sum+=abs(ps[idxs[j]]-ps[idxs[j+1]]);\n      g[idxs[j]].push_back(idxs[j+1]);\n      g[idxs[j+1]].push_back(idxs[j]);\n    }\n  }\n\n  {\n    queue<int> que;\n    que.push(M+1); vis[0][M+1]=true;\n    while(que.size()){\n      int v=que.front(); que.pop();\n      if(v<M)continue;\n      for(int nv : g[v]){\n        if(vis[0][nv])continue;\n        vis[0][nv]=true;\n        que.push(nv);\n      }\n    }\n  }\n  if(vis[0][M]){\n    printf(\"-1\\n\");\n    return 0;\n  }\n\n  {\n    queue<int> que;\n    que.push(M); vis[1][M]=true;\n    while(que.size()){\n      int v=que.front(); que.pop();\n      if(v<M&&vis[0][v])continue;\n      for(int nv : g[v]){\n        if(vis[1][nv])continue;\n        vis[1][nv]=true;\n        que.push(nv);\n      }\n    }\n  }\n\n  D res=sum;\n  rep(i,es.size()){\n    if(vis[1][es[i].u]&&vis[1][es[i].v]){\n      res-=es[i].cost;\n    }\n  }\n  printf(\"%.10Lf\\n\", res);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-8\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<double,int> P;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 2005;\n\ntypedef complex<double> C;\n\nconst double PI = 4*atan(1.0);\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n    bool operator > (const C a, const C b) {\n        return a.real() != b.real() ? a.real() > b.real() : a.imag() > b.imag();\n    }\n    //点をsetとかmapにつめたいとき(誤差を1e-10とか厳しくし過ぎるとバグる)\n    // bool operator<(const C a, const C b){\n    //     return abs(a.real()-b.real())>EPS ? a.real()<b.real()-EPS : a.imag()<b.imag()-EPS;\n    // }\n    bool operator==(const C a, const C b){\n        return (eq(a.real(),b.real()) && eq(a.imag(),b.imag()));\n    }\n    bool operator!=(const C a, const C b){\n        return !(a == b);\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(){}\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\n//条件付きsqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//正規化\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//角度(rad)\ndouble getarg(C a,C b){\n    return arg(b*conj(a));\n}\n\n//外積\ndouble cross(const C a, const C b)\n{\n    return imag(conj(a)*b);\n}\n//内積\ndouble dot(const C a, const C b)\n{\n    return real(conj(a)*b);\n}\n\nC rot(C c,double th)\n{\n    return c * C(cos(th),sin(th));\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if(cross(b, c) > 0)   return +1;       // counter clockwise\n    if(cross(b, c) < 0)   return -1;       // clockwise\n    if(dot(b, c) < 0)     return +2;       // c--a--b on line\n    if(norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;   //b--a--c on line\n}\n//直線どうしの交差判定(同一直線はTrue)\nbool intersectLL(const L& l, const L& m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//直線と線分の交差判定(一点共有も交差と判定)\nbool intersectLS(const L& l, const L& s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//直線と点の交差(共有)判定\nbool intersectLP(const L& l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//線分どうしの交差判定(一点共有も交差と判定)\nbool intersectSS(const L& s, const L& t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//線分と点の交差(共有)判定\nbool intersectSP(const L& s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//直線および線分の交点\nC crosspointLL(const L& l, const L& m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //同一直線のとき\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//点pを直線l上に射影\nC projection(const L& l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//crosspointCLに使用する関数(命名が謎です)\ndouble gettime(C c1,C c2)\n{\n    return (dot(c1,c2) < 0 ? -1.0 : 1.0 ) * abs(c2) / abs(c1);\n}\n//円と直線の交点\nvector<C> crosspointCL(C c1,double r1,const L& l)\n{\n    C a=l[0], b=l[1];\n    vector<C> res;\n    C base=b-a,  target=projection(L(a,b),c1);\n    double length=abs(base), h=abs(c1-target);\n    base/=length;\n    if(r1+EPS<h)    return res;\n    double w=Sqrt(r1*r1-h*h);\n    double LL=gettime(normalize(b-a),target-a)-w,RR=LL+w*2.0;\n    res.push_back(a+base*LL);\n    if(eq(LL,RR))   return res;\n    res.push_back(a+base*RR);\n    return res;\n}\n\n//円と線分の交点\nvector<C> crosspointCS(C c1,double r1,const L& s)\n{\n    vector<C> tmp=crosspointCL(c1,r1,s);\n    vector<C> res;\n    rep(i,tmp.size()){\n        if(abs(s[1]-s[0]) == abs(s[0]-tmp[i])+abs(s[1]-tmp[i])){\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n//円どうしの交点\nL crosspointCC(const C c1, const double r1, const C c2, const double r2)\n{\n    C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n    C d = b*b-4.0*a*c;\n    C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n    return L(z1, z2);\n}\n//点pを直線lを軸として対称移動\nC reflection(const L &l, const C p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//点と直線の距離\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n//直線と直線の距離\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//直線と線分の距離\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//線分と点の距離\ndouble distanceSP(const L &s, const C p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//線分と線分の距離\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\ndouble getarea(C c1,double r1,C a,C b)\n{\n    C va=c1-a,vb=c1-b;\n    double A=abs(va),B=abs(vb);\n    double f=cross(va,vb),d=distanceSP(L(a,b),c1),res=0;\n    if(eq(f,0.0))   return 0;\n    if(A < r1+EPS && B < r1+EPS)    return f*0.5;\n    if(d>r1-EPS)    return r1*r1*M_PI*getarg(va,vb)/(2.0*M_PI);\n    vector<C> u=crosspointCS(c1,r1,L(a,b));\n    u.insert(u.begin(),a),u.push_back(b);\n    for(int i=0;i+1<(int)u.size();i++){\n        res+=getarea(c1,r1,u[i],u[i+1]);\n    }\n    return res;\n}\n//円と多角形の共通部分の面積\ndouble getcrossarea(const vector<C>& t,C c1,double r1)\n{\n    int n = (int)t.size();\n    if(n<3) return 0;\n    double res=0;\n    rep(i,n){\n      C a=t[i], b=t[(i+1)%n];\n      res += getarea(c1,r1,a,b);\n    }\n    return res;\n}\n//凸包を求める(O(nlogn))\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = (int)ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//凸性判定\nbool isconvex(const vector<C>& ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//多角形の符号付き面積(左回りが正)\ndouble area(const vector<C>& ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//凸多角形を直線で切断した時の左側の図形\nvector<C> convex_cut(const vector<C>& ps, const L& l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(L(A, B),l));\n    }\n    return Q;\n}\n//垂直二等分線\nL bisector(C a, C b){\n    C A = (a + b) * C(0.5, 0);\n    return L(A, A + rot(b - a, PI/2));\n}\n//ボロノイ図(正確にはvoronoi_cellを求める)\n//愚直であるため1つのvoronoi_cellを求めるのにかかる計算量がO(n^2)\nvector<C> voronoi(vector<C> poly, vector<C>& p, int s){\n    rep(i,(int)p.size()){\n        if (i != s){\n            poly = convex_cut(poly, bisector(p[s], p[i]));\n        }\n    }\n    return poly;\n}\n//点が多角形に包含されているか(0は含まれない,1は辺上,2は含まれる)\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//凸多角形の交差\nvector<C> convex_intersection(const vector<C>& ps,const vector<C>& qs)\n{\n\tvector<C> rs;\n\tint a = ps.size(),b = qs.size();\n\trep(i,a){\n        if(contains(qs,ps[i])){\n            rs.push_back(ps[i]);\n        }\n    }\n\trep(i,b){\n        if(contains(ps,qs[i])){\n            rs.push_back(qs[i]);\n        }\n    }\n    rep(i,a){\n        rep(j,b){\n            L l1(ps[i],ps[(i+1)%a]),l2(qs[j],qs[(j+1)%b]);\n\t\t    if(intersectSS(l1,l2)){\n                rs.push_back(crosspointLL(l1,l2));\n            }\n        }\n\t}\n\tsort(rs.begin(),rs.end());\n\trs.erase(unique(rs.begin(),rs.end()),rs.end());\n\tif(rs.size() <= 1){\n        return rs;\n    }\n\treturn convex_hull(rs);\n}\n//凸多角形の直径を求める(キャリパー法)\n//maxi,maxjが最遠点対となる\ndouble convex_diameter(const vector<C>& ps)\n{\n    const int n = (int)ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nbool compyx(C c1,C c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\ndouble closest_pair(C* a, int n)\n{\n    if(n<=1) return 1e100;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compyx);\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\n//最近点対を求める\ndouble compute_shortest(C* a,int n)\n{\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n//2円の位置関係を示す(返り値は2円の間の共通接線の数)\nint getstateCC(C c1,double r1,C c2,double r2)\n{\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)return 4;\n    if(d>r1+r2-EPS)return 3;\n    if(d>abs(r1-r2)+EPS)return 2;\n    if(d>abs(r1-r2)-EPS)return 1;\n    return 0;\n}\n//点から円へ接線を引いた時の接点\nC gettangentCP_(C c1,double r1,C p,int flg){\n    C base=c1-p;\n    double w=Sqrt(norm(base)-r1*r1);\n    C s=p+base*C(w,r1 * flg)/norm(base)*w;\n    return s;\n}\n//点から円への接線\nvector<L> gettangentCP(C c1,double r1,C p){\n    vector<L> res;\n    C s=gettangentCP_(c1,r1,p,1);\n    C t=gettangentCP_(c1,r1,p,-1);\n    //点が円の周上にある場合\n    if(s == t){\n        res.push_back(L(s,s+(c1-p)*C(0,1)));\n    }else{\n        res.push_back(L(p,s));\n        res.push_back(L(p,t));\n    }\n    return res;\n}\n\n//2円の共通内接線を求める\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2円の共通外接線を求める\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2円の共通接線を求める(各直線の２点はそれぞれの円の接点)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\n\nstruct edge\n{\n    int to;\n    double cost;\n};\n\nmap<C,int> mp;\nvector<C> point;\nvector<vector<edge> > G;\nmap<pii,int> prv;\nbool stop[MAX_N], visit[MAX_N];\nmap<pii,double> kp;\nmap<pii,double> cs;\n\nvoid dfs(int u){\n    visit[u] = true;\n    each(e,G[u]){\n        if(!prv[P(min(u,e.to),max(u,e.to))]){\n            kp[pii(min(u,e.to),max(u,e.to))] = e.cost;\n            if(!visit[e.to]){\n                dfs(e.to);\n            }\n        }\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    vector<L> line(n);\n    rep(i,n){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        if(C(c,d) < C(a,b)) swap(a,c),swap(b,d);\n        line[i] = L(C(a,b),C(c,d));\n        if(mp.find(C(a,b)) == mp.end()){\n            mp[C(a,b)] = len(point);\n            point.pb(C(a,b));\n        }\n        if(mp.find(C(c,d)) == mp.end()){\n            mp[C(c,d)] = len(point);\n            point.pb(C(c,d));\n        }\n    }\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        if(mp.find(C(a,b)) == mp.end()){\n            mp[C(a,b)] = len(point);\n            point.pb(C(a,b));\n        }\n        stop[mp[C(a,b)]] = true;\n    }\n    int a,b,c,d;\n    cin >> a >> b >> c >> d;\n    if(mp.find(C(a,b)) == mp.end()){\n        mp[C(a,b)] = len(point);\n        point.pb(C(a,b));\n    }\n    if(mp.find(C(c,d)) == mp.end()){\n        mp[C(c,d)] = len(point);\n        point.pb(C(c,d));\n    }\n    int s = mp[C(a,b)], t = mp[C(c,d)];\n    int V = len(point);\n    vector<pii> ch;\n    G.resize(len(point));\n    double al = 0,stream = 0;\n    rep(i,n){\n        vector<C> ten = line[i];\n        rep(j,len(point)){\n            if(intersectSP(line[i],point[j])){\n                ten.pb(point[j]);\n            }\n        }\n        rep(j,n){\n            if(j != i && intersectSS(line[i],line[j])){\n                ten.pb(crosspointLL(line[i],line[j]));\n            }\n        }\n        zip(ten);\n        vi val(len(ten));\n        rep(j,len(ten)){\n            val[j] = mp[ten[j]];\n        }\n        rep(j,len(ten)-1){\n            ch.pb(pii(min(val[j],val[j+1]),max(val[j],val[j+1])));\n            cs[pii(min(val[j],val[j+1]),max(val[j],val[j+1]))] = abs(ten[j+1]-ten[j]);\n        }\n    }\n    zip(ch);\n    rep(i,len(ch)){\n        double val = cs[ch[i]];\n        al += val;\n        G[ch[i].fi].pb((edge){ch[i].se,val}),G[ch[i].se].pb((edge){ch[i].fi,val});\n    }\n    queue<int> que;\n    visit[t] = true;\n    que.push(t);\n    while(!que.empty()){\n        int p = que.front();\n        que.pop();\n        if(stop[p]) continue;\n        if(s == p){\n            printf(\"-1\\n\");\n            return 0;\n        }\n        each(e,G[p]){\n            prv[pii(min(p,e.to),max(p,e.to))] = 1;\n            if(!visit[e.to]){\n                visit[e.to] = true;\n                que.push(e.to);\n            }\n        }\n    }\n    fill(visit,visit+V,false);\n    dfs(s);\n    each(it,kp){\n        stream += it.se;\n    }\n    printf(\"%.12lf\\n\",al-stream);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-12, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n// 点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef double Weight;\n\nstruct Edge { int from, to; Weight weight;\nint id;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight,const int id) {\n\tg[from].push_back(Edge{ from, to, weight,id});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<pair<Point,bool>> &p) {\n\tint n = p.size(), m = s.size();\n\tint id = 0;\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j].first))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j].first), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from].first - p[to].first), id);\n\t\t\tadd_edge(g, to, from, abs(p[from].first - p[to].first), id++);\n\t\t}\n\t}\n\treturn g;\n}\n\n//Graph sennbunn_arrangement(const vector<Line>&s) {\n//\tvector<Point>crss;\n//\tfor (int i = 0; i < s.size(); ++i) {\n//\t\tfor (int j = i + 1; j < s.size(); ++j) {\n//\t\t\tif (isis_ss( s[i],  s[j])) {\n//\t\t\t\tcrss.push_back(is_ll( s[i],  s[j]));\n//\t\t\t}\n//\t\t}\n//\t}\n//\tfor (int i = 0; i <s.size(); ++i) {\n//\t\tcrss.push_back( s[i][0]);\n//\t\tcrss.push_back( s[i][1]);\n//\t}\n//\treturn segment_arrangement(s, crss);\n//}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nint startid;\nint goalid;\nbool dfs0(const Graph&g,const int now, vector<bool>&came, vector<bool>&close,const vector<bool>&bulbs) {\n\tcame[now] = true;\n\tfor (auto e : g[now]) {\n\t\tif (!came[e.to]) {\n\t\t\tif (e.to == startid)return false;\n\t\t\telse {\n\t\t\t\tif (bulbs[e.to]) {\n\t\t\t\t\tclose[e.to] = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!dfs0(g, e.to, came, close, bulbs)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ndouble dfs1(const Graph&g, const int now, vector<bool>&came,vector<bool>&useedges, const vector<bool>&close) {\n\tcame[now] = true;\n\tdouble ans = 0;\n\tfor (auto e : g[now]) {\n\t\tif (!useedges[e.id]) {\n\t\t\tans += e.weight;\n\t\t\tuseedges[e.id] = true;\n\t\t\tif (close[e.to])continue;\n\t\t\telse {\n\t\t\t\tif(!came[e.to])ans += dfs1(g, e.to, came,useedges, close);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tdouble sum = 0;\n\tGraph g;\n\tint sx, sy, gx, gy;\n\tPoint start;\n\tPoint goal;\n\tvector<pair<Point, bool>>crss;\n\tvector<bool>bulbs;\n\t{\n\t\tint N, M; cin >> N >> M;\n\t\tvector<Line>ls;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint asx, asy, dx, dy; cin >> asx >> asy >> dx >> dy;\n\t\t\tls.push_back(Line(Point(asx, asy), Point(dx, dy)));\n\t\t\tsum += (abs(Point(asx, asy) - Point(dx, dy)));\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < ls.size(); ++j) {\n\t\t\t\tbool ok = false;\n\t\t\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\t\t\tif (ls[i][k] == ls[j][l]) {\n\t\t\t\t\t\t\tok = true;\n\t\t\t\t\t\t\tcrss.push_back(make_pair(is_ll(ls[i], ls[j]), false));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tif (ok)break;\n\t\t\t\t}\n\t\t\t\tif (!ok&&isis_ss(ls[i], ls[j])) {\n\t\t\t\t\tcrss.push_back(make_pair(is_ll(ls[i], ls[j]), false));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < ls.size(); ++i) {\n\t\t\tcrss.push_back(make_pair(ls[i][0], false));\n\t\t\tcrss.push_back(make_pair(ls[i][1], false));\n\t\t}\n\t\t\n\t\tvector<Point >bs;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tPoint p(x, y);\n\t\t\tbs.push_back(p);\n\t\t}\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tstart = Point(sx, sy);\n\t\tgoal = Point(gx, gy);\t\n\t\tcrss.push_back(make_pair(start, false));\n\t\tcrss.push_back(make_pair(goal, false));\n\t\tsort(crss.begin(), crss.end());\n\t\tcrss.erase(unique(crss.begin(), crss.end()), crss.end());\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tauto it = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == bs[i]; });\n\t\t\tif (it == crss.end()) {\n\t\t\t\tcrss.push_back(make_pair(bs[i], true));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(*it).second = true;\n\t\t\t}\n\t\t}\n\n\n\t\tfor (int i = 0; i < crss.size(); ++i) {\n\t\t\tbulbs.push_back(crss[i].second);\n\t\t}\n\t\tg= segment_arrangement(ls, crss);\n\t}\n\tauto startit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == start; });\n\tstartid = startit - crss.begin();\n\tauto goalit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == goal; });\n\tgoalid = goalit - crss.begin();\n\tvector<bool>close(crss.size(),false);\n\tvector<bool>came(crss.size(), false);\n\tif (dfs0(g, goalid, came, close, bulbs)) {\n\t\tvector<bool>acame(crss.size(), false);\n\t\tvector<bool>useedges(80000, false);\n\t\tdouble ans = dfs1(g, startid, acame, useedges,close);\n\t\tcout <<fixed<<setprecision(10)<< sum-ans << endl;\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double eps = 1e-8;\n#define eq(a, b) (fabs((a)-(b)) < eps)\n#define lt(a, b) ((a)-(b) < -eps)\n\nstruct Point {\n  double x, y;\n  Point(double x=0, double y=0):x(x), y(y){}\n  Point operator+(Point p) {return Point(x+p.x, y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x, y-p.y);}\n  Point operator*(double a) {return Point(x*a, y*a);}\n  Point operator/(double a) {return Point(x/a, y/a);}\n  bool operator<(const Point& p) const {return x!=p.x?x<p.x:y<p.y;}\n  bool operator==(const Point& p) const {return eq(x, p.x)&&eq(y, p.y);}\n};\nusing Vector = Point;\n\ndouble dot(Vector a, Vector b) {return a.x*b.x+a.y*b.y;}\ndouble cross(Vector a, Vector b) {return a.x*b.y-a.y*b.x;}\ndouble norm(Vector a) {return dot(a, a);}\ndouble abs(Vector a) {return sqrt(norm(a));}\n\nconst int CCW = 1;\nconst int CW = -1;\nconst int BCK = 2;\nconst int FNT = -2;\nconst int ON = 0;\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a, b) > eps) return CCW;\n  if(cross(a, b) < -eps) return CW;\n  if(dot(a, b) < -eps) return BCK;\n  if(norm(a) < norm(b)) return FNT;\n  return ON;\n}\n\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3)*ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1)*ccw(p3, p4, p2) <= 0);\n}\ndouble distance(Point a, Point b) {return abs(a-b);}\n\nstruct Segment {\n  Point s, t;\n  Segment(Point s=Point(), Point t=Point()):s(s), t(t){}\n};\nusing Line = Segment;\n\nbool intersect(Segment s1, Segment s2) {\n  return intersect(s1.s, s1.t, s2.s, s2.t);\n}\nbool intersect(Segment s, Point p) {\n  return abs(s.s-p)+abs(s.t-p)-abs(s.t-s.s) < eps;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(cross(l.t-l.s, p-l.s)/abs(l.t-l.s));\n}\ndouble distanceSP(Segment s, Point p) {\n  if(dot(s.t-s.s, p-s.s) < 0) return abs(p-s.s);\n  if(dot(s.s-s.t, p-s.t) < 0) return abs(p-s.t);\n  return distanceLP(s, p);\n}\ndouble distance(Segment s1, Segment s2) {\n  if(intersect(s1, s2)) return 0;\n  return min(min(distanceSP(s1, s2.s), distanceSP(s1, s2.t)),\n\t     min(distanceSP(s2, s1.s), distanceSP(s2, s1.t)));\n}\nPoint crossPoint(Segment s1, Segment s2) {\n  Vector base = s2.t-s2.s;\n  double d1 = abs(cross(base, s1.s-s2.s));\n  double d2 = abs(cross(base, s1.t-s2.s));\n  double t = d1/(d1+d2);\n  return s1.s+(s1.t-s1.s)*t;\n}\n\nbool merge(Segment& s1, Segment s2) {\n  if(abs(cross(s1.t-s1.s, s2.t-s2.s)) > eps) return false;\n  if(ccw(s1.s, s2.s, s1.t) == CCW ||\n     ccw(s1.s, s2.s, s1.t) == CW) return false;\n  if(ccw(s1.s, s1.t, s2.s) == FNT ||\n     ccw(s2.s, s2.t, s1.s) == FNT) return false;\n  s1 = Segment(min(s1.s, s2.s), max(s1.t, s2.t));\n  return true;\n}\nvoid mergeSegments(vector<Segment>& segs) {\n  for(int i = 0; i < (int)segs.size(); ++i) {\n    if(segs[i].t < segs[i].s) swap(segs[i].s, segs[i].t);\n  }\n  for(int i = 0; i < (int)segs.size(); ++i) {\n    for(int j = i+1; j < (int)segs.size(); ++j) {\n      if(merge(segs[i], segs[j])) {\n\tsegs[j--] = segs.back();\n\tsegs.pop_back();\n      }\n    }\n  }\n}\n\nstruct edge {\n  int to;\n  double cost;\n  int id;\n  edge(){}\n  edge(int to, double cost, int id):to(to), cost(cost), id(id){}\n  bool operator<(const edge& e) {return lt(cost, e.cost);}\n};\nusing Graph = vector<vector<edge> >;\n\nvector<int> type;\nmap<Point, int> mp;\nint id = 0;\ndouble sum = 0;\n\nGraph segmentArrangement(vector<Segment>& segs, vector<Point>& ps) {\n  for(int i = 0; i < (int)segs.size(); ++i) {\n    ps.push_back(segs[i].s);\n    ps.push_back(segs[i].t);\n    for(int j = i+1; j < (int)segs.size(); ++j) {\n      if(intersect(segs[i], segs[j])) ps.push_back(crossPoint(segs[i], segs[j]));\n    }\n  }\n  sort(ps.begin(), ps.end());\n  ps.erase(unique(ps.begin(), ps.end()), ps.end());\n  //cout<<\"AFTER\"<<endl;\n  //for(int i = 0; i < (int)ps.size(); ++i) cout<<mp[ps[i]]<<\" \"<<ps[i].x<<\" \"<<ps[i].y<<endl;\n  for(int i = 0; i < (int)ps.size(); ++i) type.push_back(mp[ps[i]]);\n  Graph graph(ps.size());\n  for(int i = 0; i < (int)segs.size(); ++i) {\n    vector<pair<double, int> > ls;\n    for(int j = 0; j < (int)ps.size(); ++j) {\n      if(intersect(segs[i], ps[j])) {\n\tls.emplace_back(norm(distance(segs[i], ps[j])), j);\n      }\n    }\n    sort(ls.begin(), ls.end());\n    for(int j = 0; j+1 < (int)ls.size(); ++j) {\n      int u = ls[j].second, v = ls[j+1].second;\n      graph[u].emplace_back(v, distance(ps[u], ps[v]), id);\n      graph[v].emplace_back(u, distance(ps[u], ps[v]), id);\n      ++id;\n      sum += distance(ps[u], ps[v]);\n    }\n    //sum += distance(segs[i].s, segs[i].t);\n  }\n  //cout<<sum<<endl;\n  return graph;\n}\n\nint main() {\n  int N, M;\n  vector<Segment> segs;\n  vector<Point> ps;\n\n  cin >> N >> M;\n  for(int i = 0; i < N; ++i) {\n    Point s, t;\n    cin >> s.x >> s.y >> t.x >> t.y;\n    segs.emplace_back(s, t);\n  }\n  for(int i = 0; i < M+2; ++i) {\n    Point p;\n    cin >> p.x >> p.y;\n    ps.push_back(p);\n    if(i == M) mp[p] = 1;\n    else if(i == M+1) mp[p] = 2;\n    else mp[p] = 3;\n  }\n  //cout<<\"BEFORE\"<<endl;\n  //for(auto& p : mp) cout << p.second<<\" \"<<p.first.x<<\" \"<<p.first.y<<endl;\n  mergeSegments(segs);\n  Graph graph = segmentArrangement(segs, ps);\n  int s = -1, t = -1;\n  for(int i = 0; i < (int)graph.size(); ++i) {\n    if(type[i] == 1) s = i;\n    else if(type[i] == 2) t = i;\n  }\n  assert(~s && ~t);\n\n  queue<int> que;\n  vector<bool> used(graph.size(), false);\n  que.push(t);\n  used[t] = true;\n  //cout<<s<<\" \"<<t<<endl;\n  while(!que.empty()) {\n    int v = que.front(); que.pop();\n    //cout<<v<<endl;\n    if(v == s) {\n      cout << -1 << endl;\n      return 0;\n    }\n    if(type[v] == 3) continue;\n    for(edge e : graph[v]) {\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      que.push(e.to);\n    }\n  }\n  vector<bool> usedEdge(id, false);\n  que.push(s);\n  used[s] = true;\n  while(!que.empty()) {\n    int v = que.front(); que.pop();\n    for(edge e : graph[v]) {\n      if(usedEdge[e.id]) continue;\n      sum -= e.cost;\n      usedEdge[e.id] = true;\n      if(used[e.to]) continue;\n      used[e.to] = true;\n      que.push(e.to);\n    }\n  }\n  printf(\"%.12f\\n\", sum);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-12, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(nb, nc) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(nb, nc) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\n//　重なってる部分あるとassert(false)\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 線分と線分の交点\n//　重なってる部分あるとassert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s,t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l]) {\n\t\t\t\t\treturn s[k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0,0);\n\t}\n}\n\n// 直線と点の距離\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//直線と直線の二等分線のベクトル\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0]))<eps ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0]))<eps ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//円の内外判定2　高速\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// 凸包\n// 点や線を返すことも有り得るので注意\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef double Weight;\n\nstruct Edge { int from, to; Weight weight;\nint id;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight,const int id) {\n\tg[from].push_back(Edge{ from, to, weight,id});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<pair<Point,bool>> &p) {\n\tint n = p.size(), m = s.size();\n\tint id = 0;\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j].first))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j].first), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from].first - p[to].first), id);\n\t\t\tadd_edge(g, to, from, abs(p[from].first - p[to].first), id++);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, angle * c[i].r);\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nint startid;\nint goalid;\nbool dfs0(const Graph&g,const int now, vector<bool>&came, vector<bool>&close,const vector<bool>&bulbs) {\n\tcame[now] = true;\n\tfor (auto e : g[now]) {\n\t\tif (!came[e.to]) {\n\t\t\tif (e.to == startid)return false;\n\t\t\telse {\n\t\t\t\tif (bulbs[e.to]) {\n\t\t\t\t\tclose[e.to] = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!dfs0(g, e.to, came, close, bulbs)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\ndouble dfs1(const Graph&g, const int now, vector<bool>&came,vector<bool>&useedges, const vector<bool>&close) {\n\tcame[now] = true;\n\tdouble ans = 0;\n\tfor (auto e : g[now]) {\n\t\tif (!useedges[e.id]) {\n\t\t\tans += e.weight;\n\t\t\tuseedges[e.id] = true;\n\t\t\tif (close[e.to])continue;\n\t\t\telse {\n\t\t\t\tif(!came[e.to])ans += dfs1(g, e.to, came,useedges, close);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tdouble sum = 0;\n\tGraph g;\n\tint sx, sy, gx, gy;\n\tPoint start;\n\tPoint goal;\n\tvector<pair<Point, bool>>crss;\n\tvector<bool>bulbs;\n\t{\n\t\tint N, M; cin >> N >> M;\n\t\tvector<Line>ls;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint asx, asy, dx, dy; cin >> asx >> asy >> dx >> dy;\n\t\t\tls.push_back(Line(Point(asx, asy), Point(dx, dy)));\n\t\t\tsum += (abs(Point(asx, asy) - Point(dx, dy)));\n\t\t}\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = i + 1; j < ls.size(); ++j) {\n\t\t\t\tisis_ss(ls[i], ls[j])) {\n\t\t\t\t\tcrss.push_back(make_pair(is_ss(ls[i], ls[j]), false));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < ls.size(); ++i) {\n\t\t\tcrss.push_back(make_pair(ls[i][0], false));\n\t\t\tcrss.push_back(make_pair(ls[i][1], false));\n\t\t}\n\t\t\n\t\tvector<Point >bs;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tPoint p(x, y);\n\t\t\tbs.push_back(p);\n\t\t}\n\t\tcin >> sx >> sy >> gx >> gy;\n\t\tstart = Point(sx, sy);\n\t\tgoal = Point(gx, gy);\t\n\t\tcrss.push_back(make_pair(start, false));\n\t\tcrss.push_back(make_pair(goal, false));\n\t\tsort(crss.begin(), crss.end());\n\t\tcrss.erase(unique(crss.begin(), crss.end()), crss.end());\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tauto it = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == bs[i]; });\n\t\t\tif (it == crss.end()) {\n\t\t\t\tcrss.push_back(make_pair(bs[i], true));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t(*it).second = true;\n\t\t\t}\n\t\t}\n\n\n\t\tfor (int i = 0; i < crss.size(); ++i) {\n\t\t\tbulbs.push_back(crss[i].second);\n\t\t}\n\t\tg= segment_arrangement(ls, crss);\n\t}\n\tauto startit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == start; });\n\tstartid = startit - crss.begin();\n\tauto goalit = find_if(crss.begin(), crss.end(), [=](const pair<Point, bool>&a) {return a.first == goal; });\n\tgoalid = goalit - crss.begin();\n\tvector<bool>close(crss.size(),false);\n\tvector<bool>came(crss.size(), false);\n\tif (dfs0(g, goalid, came, close, bulbs)) {\n\t\tvector<bool>acame(crss.size(), false);\n\t\tvector<bool>useedges(80000, false);\n\t\tdouble ans = dfs1(g, startid, acame, useedges,close);\n\t\tcout <<fixed<<setprecision(10)<< sum-ans << endl;\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define MAX 200010\n#define eps (1e-10)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool isParallel(Segment s,Segment t){\n    return equals(cross(s.p1-s.p2,t.p1-t.p2),0.0);\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return 1;\n  if(cross(a,b)<-eps)return -1;\n  if(dot(a,b)<-eps)return 2;\n  if(a.norm()<b.norm())return -2;\n  return 0;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n          ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps || abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n\nbool merge_if_able(Segment &s,Segment t) {\n  if(!isParallel(s,t))return false;\n  if(ccw(s.p1,t.p1,s.p2)==1 ||\n     ccw(s.p1,t.p1,s.p2)==-1)return false;\n  if(ccw(s.p1,s.p2,t.p1)==-2 ||\n     ccw(t.p1,t.p2,s.p1)==-2)return false;\n  s=Segment(min(s.p1,t.p1),max(s.p2,t.p2));\n  return true;\n}\n\nvoid merge(vector<Segment>& v) {\n  for(int i=0;i<v.size();i++){\n    if(v[i].p2<v[i].p1)swap(v[i].p2,v[i].p1);\n  }\n  for(int i=0;i<v.size();i++)\n    for(int j=i+1;j<v.size();j++)\n      if(merge_if_able(v[i],v[j]))\n        v[j--]=v.back(),v.pop_back();\n}\n\ntypedef vector<vector<pair<int,double> > > Graph;\n\nGraph SegmentArrangement(vector<Segment> v,vector<Point> &ps){\n  for(int i=0;i<v.size();i++){\n    ps.push_back(v[i].p1);\n    ps.push_back(v[i].p2);\n    for(int j=i+1;j<v.size();j++){\n      if(intersect(v[i],v[j]))ps.push_back(getCrossPointLL(v[i],v[j]));\n    }\n  }\n  sort(ps.begin(),ps.end());\n  ps.erase(unique(ps.begin(),ps.end()),ps.end());\n  Graph g(ps.size());\n  for(int i=0;i<v.size();i++){\n    vector<pair<double,int> > list;\n    for(int j=0;j<ps.size();j++)\n      if(ccw(v[i].p1,v[i].p2,ps[j])==0)\n        list.push_back(mp(norm(v[i].p1-ps[j]),j));\n    sort(list.begin(),list.end());\n    for(int j=0;j<list.size()-1;j++){\n      int a=list[j].s,b=list[j+1].s;\n      g[a].push_back(mp(b,abs(ps[b]-ps[a])));\n      g[b].push_back(mp(a,abs(ps[a]-ps[b])));\n    }\n  }\n  return g;\n}\n\nint n,m;\nvector<Segment> vs;\nvector<Point> vp;\nset<Point> st;\nPoint s,t;\nint c,d;\nGraph g;\nbool checked[MAX]={};\nbool visited[MAX]={};\nbool valve[MAX]={};\n\nvoid dfs(int v){ \n  checked[v]=true;\n  if(valve[v])return;\n  for(int i=0;i<g[v].size();i++){\n    pair<int,double> next=g[v][i];\n    if(!checked[next.f]){\n      dfs(next.f);\n    }\n  }\n  return;\n}\n\ndouble bfs(int v){\n  double res=0.0;\n  queue<int> q;\n  q.push(v);\n  while(q.size()){\n    int u=q.front();\n    q.pop();\n    if(visited[u])continue;\n    visited[u]=true;\n    for(int i=0;i<g[u].size();i++){\n      pair<int,double> next=g[u][i];\n      if(checked[next.f])res+=next.s;\n      else if(!visited[next.f]){\n        res+=next.s;\n        q.push(next.f);\n      }\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    vs.push_back(Segment(Point(a,b),Point(c,d)));\n  }\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin>>a>>b;\n    vp.push_back(Point(a,b));\n    st.insert(Point(a,b));\n  }\n  cin>>s.x>>s.y>>t.x>>t.y;\n  vp.push_back(s);\n  vp.push_back(t);\n  //merge(vs);\n  g=SegmentArrangement(vs,vp);\n  for(int i=0;i<vp.size();i++){\n    if(st.find(vp[i])!=st.end())valve[i]=true;\n    if(vp[i]==s)c=i;\n    if(vp[i]==t)d=i;\n  }\n  dfs(d);\n  if(checked[c])cout<<-1<<endl;\n  else {\n    double ans=0.0;\n    for(int i=0;i<g.size();i++){\n      for(int j=0;j<g[i].size();j++)ans+=g[i][j].s/2.0;\n    }\n    ans-=bfs(c);\n    printf(\"%.10f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "D",
    "code": "import core.stdc.stdio;\nimport std.typecons;\nimport std.algorithm;\nimport std.range;\nimport std.math;\nimport std.stdio;\n\nvoid main(){\n\talias Tuple!(int,\"x\",int,\"y\") pos;\n\talias Tuple!(int,\"a\",int,\"b\",int,\"c\",pos,\"s\",pos,\"t\",double,\"len\") line;\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tline[] ls = new line[n];\n\tforeach(ref l;ls){\n\t\tscanf(\"%d%d%d%d\",&l.s.x,&l.s.y,&l.t.x,&l.t.y);\n\t\tl.a=l.s.y-l.t.y;\n\t\tl.b=l.t.x-l.s.x;\n\t\tl.c=l.s.x*l.t.y-l.t.x*l.s.y;\n\t\tl.len = sqrt(cast(double)((l.t.x-l.s.x)*(l.t.x-l.s.x)+(l.t.y-l.s.y)*(l.t.y-l.s.y)));\n\t}\n\tpos[] vlv = new pos[m];\n\tforeach(ref v;vlv)\n\t\tscanf(\"%d%d\",&v.x,&v.y);\n\tpos src,rep;\n\tscanf(\"%d%d%d%d\",&src.x,&src.y,&rep.x,&rep.y);\n\talias Tuple!(double,\"len\",int,\"idx\") li;\n\tli[][] q=new li[][n];\n\tstatic immutable double eps=1e-9;\n\tforeach(i,ref l;ls){\n\t\tforeach(int j,d;ls)\n\t\t\tif(i!=j){\n\t\t\t\tint w=l.a*d.b-l.b*d.a;\n\t\t\t\tif(w){\n\t\t\t\t\tdouble x=cast(double)(l.b*d.c-l.c*d.b)/w;\n\t\t\t\t\tdouble y=cast(double)(l.c*d.a-l.a*d.c)/w;\n\t\t\t\t\tdouble len = sqrt((x-l.s.x)*(x-l.s.x)+(y-l.s.y)*(y-l.s.y));\n\t\t\t\t\tif(0<=len&&len<=l.len)\n\t\t\t\t\t\tq[i]~=li(len,j);\n\t\t\t\t}\n\t\t\t}\n\t\tforeach(j,v;vlv)\n\t\t\tif(l.a*v.x+l.b*v.y+l.c==0){\n\t\t\t\tdouble len = sqrt(cast(double)((l.s.x-v.x)*(l.s.x-v.x)+(l.s.y-v.y)*(l.s.y-v.y)));\n\t\t\t\tif(0<=len&&len<=l.len){\n\t\t\t\t\tq[i]~=li(len,-1919);\n\t\t\t\t\tq[i]~=li(len,1919);\n\t\t\t\t}\n\t\t\t}\n\t\tif(l.a*src.x+l.b*src.y+l.c==0){\n\t\t\tdouble len = sqrt(cast(double)((l.s.x-src.x)*(l.s.x-src.x)+(l.s.y-src.y)*(l.s.y-src.y)));\n\t\t\tif(0<=len&&len<=l.len)\n\t\t\t\tq[i]~=li(len,114514);\n\t\t}\n\t}\n\tbool[][] used =new bool[][n];\n\tforeach(i,ref u;used)\n\t\tu=new bool[q[i].length+1];\n\talias Tuple!(int,\"i\",int,\"j\") ij;\n\tij[] r=new ij[1919893];\n\tint rc;\n\tint[][] sc = new int[][](n,n);\n\tforeach(int i,ref l;ls){\n\t\tsort(q[i]);\n//\t\tq[i].writeln;\n\t\tforeach(int j,v;q[i])\n\t\t\tif(0<=v.idx&&v.idx<n)\n\t\t\t\tsc[v.idx][i]=j;\n\t\tif(l.a*rep.x+l.b*rep.y+l.c==0){\n\t\t\tdouble len = sqrt(cast(double)((l.s.x-rep.x)*(l.s.x-rep.x)+(l.s.y-rep.y)*(l.s.y-rep.y)));\n\t\t\tif(0<=len&&len<=l.len){\n\t\t\t\tint j=cast(int)q[i].assumeSorted.lowerBound(li(len,-114514)).length;\n\t\t\t\tr[rc++]=ij(i,j);\n\t\t\t\tused[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint ri;\n\twhile(ri<rc){\n\t\tij fr = r[ri++];\n\t\twith(fr){\n\t\t\tassert(used[i][j]);\n\t\t\tif(j<q[i].length){\n\t\t\t\tif(q[i][j].idx==114514){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(0<=q[i][j].idx&&q[i][j].idx<n){\n\t\t\t\t\tif(!used[i][j+1]){\n\t\t\t\t\t\tused[i][j+1]=true;\n\t\t\t\t\t\tr[rc++]=ij(i,j+1);\n\t\t\t\t\t}\n\t\t\t\t\tif(!used[q[i][j].idx][sc[i][q[i][j].idx]]){\n\t\t\t\t\t\tused[q[i][j].idx][sc[i][q[i][j].idx]]=true;\n\t\t\t\t\t\tr[rc++]=ij(q[i][j].idx,sc[i][q[i][j].idx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(0<j){\n\t\t\t\tif(q[i][j-1].idx==114514){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(0<=q[i][j-1].idx&&q[i][j-1].idx<n){\n\t\t\t\t\tif(!used[i][j-1]){\n\t\t\t\t\t\tused[i][j-1]=true;\n\t\t\t\t\t\tr[rc++]=ij(i,j-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(!used[q[i][j-1].idx][sc[i][q[i][j-1].idx]]){\n\t\t\t\t\t\tused[q[i][j-1].idx][sc[i][q[i][j-1].idx]]=true;\n\t\t\t\t\t\tr[rc++]=ij(q[i][j-1].idx,sc[i][q[i][j-1].idx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans=0;\n\tforeach(l;ls)\n\t\tans+=l.len;\n\tri=0,rc=0;\n//\tforeach(u;used)\n//\t\tu.writeln;\n\tforeach(i,vs;q){\n\t\tforeach(j;1..q[i].length)\n\t\t\tif(vs[j].len-vs[j-1].len<eps&&used[i][j-1])\n\t\t\t\tused[i][j]=true;\n\t\tforeach_reverse(j;1..q[i].length)\n\t\t\tif(vs[j].len-vs[j-1].len<eps&&used[i][j+1])\n\t\t\t\tused[i][j]=true;\n\t}\n//\tforeach(u;used)\n//\t\tu.writeln;\n\tforeach(int i,vs;q)\n\t\tforeach(int j,v;vs)\n\t\t\tif(v.idx==114514){\n\t\t\t\tr[rc++]=ij(i,j);\n\t\t\t\tused[i][j]=true;\n\t\t\t}\n\twhile(ri<rc){\n\t\tij fr = r[ri++];\n\t\twith(fr){\n\t\t\tassert(used[i][j]);\n//\t\t\twriteln(i,\" \",j);\n\t\t\tif(j==0)\n\t\t\t\tans-=q[i][j].len;\n\t\t\telse if(j==q[i].length)\n\t\t\t\tans-=ls[i].len-q[i][j-1].len;\n\t\t\telse\n\t\t\t\tans-=q[i][j].len-q[i][j-1].len;\n\t\t\tif(j<q[i].length){\n\t\t\t\tif(0<=q[i][j].idx&&q[i][j].idx<n){\n\t\t\t\t\tif(!used[q[i][j].idx][sc[i][q[i][j].idx]]&&!used[q[i][j].idx][sc[i][q[i][j].idx]+1]&&!used[i][j+1]){\n\t\t\t\t\t\tused[q[i][j].idx][sc[i][q[i][j].idx]]=true;\n\t\t\t\t\t\tr[rc++]=ij(q[i][j].idx,sc[i][q[i][j].idx]);\n\t\t\t\t\t\tused[q[i][j].idx][sc[i][q[i][j].idx]+1]=true;\n\t\t\t\t\t\tr[rc++]=ij(q[i][j].idx,sc[i][q[i][j].idx]+1);\n\t\t\t\t\t\tused[i][j+1]=true;\n\t\t\t\t\t\tr[rc++]=ij(i,j+1);\n\t\t\t\t\t}\n\t\t\t\t}else if(!used[i][j+1]){\n\t\t\t\t\tused[i][j+1]=true;\n\t\t\t\t\tr[rc++]=ij(i,j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(0<j){\n\t\t\t\tif(0<=q[i][j-1].idx&&q[i][j-1].idx<n){\n\t\t\t\t\tif(!used[q[i][j-1].idx][sc[i][q[i][j-1].idx]]&&!used[q[i][j-1].idx][sc[i][q[i][j-1].idx]+1]&&!used[i][j-1]){\n\t\t\t\t\t\tused[q[i][j-1].idx][sc[i][q[i][j-1].idx]]=true;\n\t\t\t\t\t\tr[rc++]=ij(q[i][j-1].idx,sc[i][q[i][j-1].idx]);\n\t\t\t\t\t\tused[q[i][j-1].idx][sc[i][q[i][j-1].idx]+1]=true;\n\t\t\t\t\t\tr[rc++]=ij(q[i][j-1].idx,sc[i][q[i][j-1].idx]+1);\n\t\t\t\t\t\tused[i][j-1]=true;\n\t\t\t\t\t\tr[rc++]=ij(i,j-1);\n\t\t\t\t\t}\n\t\t\t\t}else if(!used[i][j-1]){\n\t\t\t\t\tused[i][j-1]=true;\n\t\t\t\t\tr[rc++]=ij(i,j-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.8lf\\n\",ans);\n}"
  },
  {
    "language": "D",
    "code": "import core.stdc.stdio;\nimport std.typecons;\nimport std.algorithm;\nimport std.range;\nimport std.math;\nimport std.stdio;\n\nvoid main(){\n\talias Tuple!(int,\"x\",int,\"y\") pos;\n\talias Tuple!(int,\"a\",int,\"b\",int,\"c\",pos,\"s\",pos,\"t\",double,\"len\") line;\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tline[] ls = new line[n];\n\tforeach(ref l;ls){\n\t\tscanf(\"%d%d%d%d\",&l.s.x,&l.s.y,&l.t.x,&l.t.y);\n\t\tl.a=l.s.y-l.t.y;\n\t\tl.b=l.t.x-l.s.x;\n\t\tl.c=l.s.x*l.t.y-l.t.x*l.s.y;\n\t\tl.len = sqrt(cast(double)((l.t.x-l.s.x)*(l.t.x-l.s.x)+(l.t.y-l.s.y)*(l.t.y-l.s.y)));\n\t}\n\tpos[] vlv = new pos[m];\n\tforeach(ref v;vlv)\n\t\tscanf(\"%d%d\",&v.x,&v.y);\n\tpos src,rep;\n\tscanf(\"%d%d%d%d\",&src.x,&src.y,&rep.x,&rep.y);\n\talias Tuple!(double,\"len\",int,\"idx\") li;\n\tli[][] q=new li[][n];\n\tstatic immutable double eps=1e-9;\n\tforeach(i,ref l;ls){\n\t\tforeach(j,d;ls)\n\t\t\tif(i!=j){\n\t\t\t\tint w=l.a*d.b-l.b*d.a;\n\t\t\t\tif(w){\n\t\t\t\t\tdouble x=cast(double)(l.b*d.c-l.c*d.b)/w;\n\t\t\t\t\tdouble y=cast(double)(l.c*d.a-l.a*d.c)/w;\n\t\t\t\t\tdouble len = sqrt((x-l.s.x)*(x-l.s.x)+(y-l.s.y)*(y-l.s.y));\n\t\t\t\t\tif(0<=len&&len<=l.len)\n\t\t\t\t\t\tq[i]~=li(len,j);\n\t\t\t\t}\n\t\t\t}\n\t\tforeach(j,v;vlv)\n\t\t\tif(l.a*v.x+l.b*v.y+l.c==0){\n\t\t\t\tdouble len = sqrt(cast(double)((l.s.x-v.x)*(l.s.x-v.x)+(l.s.y-v.y)*(l.s.y-v.y)));\n\t\t\t\tif(0<=len&&len<=l.len){\n\t\t\t\t\tq[i]~=li(len,-1919);\n\t\t\t\t\tq[i]~=li(len,1919);\n\t\t\t\t}\n\t\t\t}\n\t\tif(l.a*src.x+l.b*src.y+l.c==0){\n\t\t\tdouble len = sqrt(cast(double)((l.s.x-src.x)*(l.s.x-src.x)+(l.s.y-src.y)*(l.s.y-src.y)));\n\t\t\tif(0<=len&&len<=l.len)\n\t\t\t\tq[i]~=li(len,114514);\n\t\t}\n\t}\n\tbool[][] used =new bool[][n];\n\tforeach(i,ref u;used)\n\t\tu=new bool[q[i].length+1];\n\talias Tuple!(int,\"i\",int,\"j\") ij;\n\tij[] r=new ij[1919893];\n\tint rc;\n\tint[][] sc = new int[][](n,n);\n\tforeach(i,ref l;ls){\n\t\tsort(q[i]);\n//\t\tq[i].writeln;\n\t\tforeach(j,v;q[i])\n\t\t\tif(0<=v.idx&&v.idx<n)\n\t\t\t\tsc[v.idx][i]=j;\n\t\tif(l.a*rep.x+l.b*rep.y+l.c==0){\n\t\t\tdouble len = sqrt(cast(double)((l.s.x-rep.x)*(l.s.x-rep.x)+(l.s.y-rep.y)*(l.s.y-rep.y)));\n\t\t\tif(0<=len&&len<=l.len){\n\t\t\t\tint j=cast(int)q[i].assumeSorted.lowerBound(li(len,-114514)).length;\n\t\t\t\tr[rc++]=ij(i,j);\n\t\t\t\tused[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint ri;\n\twhile(ri<rc){\n\t\tij fr = r[ri++];\n\t\twith(fr){\n\t\t\tassert(used[i][j]);\n\t\t\tif(j<q[i].length){\n\t\t\t\tif(q[i][j].idx==114514){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(0<=q[i][j].idx&&q[i][j].idx<n){\n\t\t\t\t\tif(!used[i][j+1]){\n\t\t\t\t\t\tused[i][j+1]=true;\n\t\t\t\t\t\tr[rc++]=ij(i,j+1);\n\t\t\t\t\t}\n\t\t\t\t\tif(!used[q[i][j].idx][sc[i][q[i][j].idx]]){\n\t\t\t\t\t\tused[q[i][j].idx][sc[i][q[i][j].idx]]=true;\n\t\t\t\t\t\tr[rc++]=ij(q[i][j].idx,sc[i][q[i][j].idx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(0<j){\n\t\t\t\tif(q[i][j-1].idx==114514){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(0<=q[i][j-1].idx&&q[i][j-1].idx<n){\n\t\t\t\t\tif(!used[i][j-1]){\n\t\t\t\t\t\tused[i][j-1]=true;\n\t\t\t\t\t\tr[rc++]=ij(i,j-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(!used[q[i][j-1].idx][sc[i][q[i][j-1].idx]]){\n\t\t\t\t\t\tused[q[i][j-1].idx][sc[i][q[i][j-1].idx]]=true;\n\t\t\t\t\t\tr[rc++]=ij(q[i][j-1].idx,sc[i][q[i][j-1].idx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans=0;\n\tforeach(l;ls)\n\t\tans+=l.len;\n\tri=0,rc=0;\n//\tforeach(u;used)\n//\t\tu.writeln;\n\tforeach(i,vs;q){\n\t\tforeach(j;1..q[i].length)\n\t\t\tif(vs[j].len-vs[j-1].len<eps&&used[i][j-1])\n\t\t\t\tused[i][j]=true;\n\t\tforeach_reverse(j;1..q[i].length)\n\t\t\tif(vs[j].len-vs[j-1].len<eps&&used[i][j+1])\n\t\t\t\tused[i][j]=true;\n\t}\n//\tforeach(u;used)\n//\t\tu.writeln;\n\tforeach(i,vs;q)\n\t\tforeach(j,v;vs)\n\t\t\tif(v.idx==114514){\n\t\t\t\tr[rc++]=ij(i,j);\n\t\t\t\tused[i][j]=true;\n\t\t\t}\n\twhile(ri<rc){\n\t\tij fr = r[ri++];\n\t\twith(fr){\n\t\t\tassert(used[i][j]);\n//\t\t\twriteln(i,\" \",j);\n\t\t\tif(j==0)\n\t\t\t\tans-=q[i][j].len;\n\t\t\telse if(j==q[i].length)\n\t\t\t\tans-=ls[i].len-q[i][j-1].len;\n\t\t\telse\n\t\t\t\tans-=q[i][j].len-q[i][j-1].len;\n\t\t\tif(j<q[i].length){\n\t\t\t\tif(0<=q[i][j].idx&&q[i][j].idx<n){\n\t\t\t\t\tif(!used[q[i][j].idx][sc[i][q[i][j].idx]]&&!used[q[i][j].idx][sc[i][q[i][j].idx]+1]&&!used[i][j+1]){\n\t\t\t\t\t\tused[q[i][j].idx][sc[i][q[i][j].idx]]=true;\n\t\t\t\t\t\tr[rc++]=ij(q[i][j].idx,sc[i][q[i][j].idx]);\n\t\t\t\t\t\tused[q[i][j].idx][sc[i][q[i][j].idx]+1]=true;\n\t\t\t\t\t\tr[rc++]=ij(q[i][j].idx,sc[i][q[i][j].idx]+1);\n\t\t\t\t\t\tused[i][j+1]=true;\n\t\t\t\t\t\tr[rc++]=ij(i,j+1);\n\t\t\t\t\t}\n\t\t\t\t}else if(!used[i][j+1]){\n\t\t\t\t\tused[i][j+1]=true;\n\t\t\t\t\tr[rc++]=ij(i,j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(0<j){\n\t\t\t\tif(0<=q[i][j-1].idx&&q[i][j-1].idx<n){\n\t\t\t\t\tif(!used[q[i][j-1].idx][sc[i][q[i][j-1].idx]]&&!used[q[i][j-1].idx][sc[i][q[i][j-1].idx]+1]&&!used[i][j-1]){\n\t\t\t\t\t\tused[q[i][j-1].idx][sc[i][q[i][j-1].idx]]=true;\n\t\t\t\t\t\tr[rc++]=ij(q[i][j-1].idx,sc[i][q[i][j-1].idx]);\n\t\t\t\t\t\tused[q[i][j-1].idx][sc[i][q[i][j-1].idx]+1]=true;\n\t\t\t\t\t\tr[rc++]=ij(q[i][j-1].idx,sc[i][q[i][j-1].idx]+1);\n\t\t\t\t\t\tused[i][j-1]=true;\n\t\t\t\t\t\tr[rc++]=ij(i,j-1);\n\t\t\t\t\t}\n\t\t\t\t}else if(!used[i][j-1]){\n\t\t\t\t\tused[i][j-1]=true;\n\t\t\t\t\tr[rc++]=ij(i,j-1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.8lf\\n\",ans);\n}"
  },
  {
    "language": "D",
    "code": "import core.stdc.stdio;\nimport std.typecons;\nimport std.algorithm;\nimport std.range;\nimport std.math;\nimport std.stdio;\n\nvoid main(){\n\talias Tuple!(int,\"x\",int,\"y\") pos;\n\talias Tuple!(int,\"a\",int,\"b\",int,\"c\",pos,\"s\",pos,\"t\",double,\"len\") line;\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tline[] ls = new line[n];\n\tforeach(ref l;ls){\n\t\tscanf(\"%d%d%d%d\",&l.s.x,&l.s.y,&l.t.x,&l.t.y);\n\t\tl.a=l.s.y-l.t.y;\n\t\tl.b=l.t.x-l.s.x;\n\t\tl.c=l.s.x*l.t.y-l.t.x*l.s.y;\n\t\tl.len = sqrt(cast(double)((l.t.x-l.s.x)*(l.t.x-l.s.x)+(l.t.y-l.s.y)*(l.t.y-l.s.y)));\n\t}\n\tpos[] vlv = new pos[m];\n\tforeach(ref v;vlv)\n\t\tscanf(\"%d%d\",&v.x,&v.y);\n\tpos src,rep;\n\tscanf(\"%d%d%d%d\",&src.x,&src.y,&rep.x,&rep.y);\n\talias Tuple!(double,\"len\",int,\"idx\") li;\n\tli[][] q=new li[][n];\n\tstatic immutable double eps=1e-9;\n\tforeach(i,ref l;ls){\n\t\tforeach(int j,d;ls)\n\t\t\tif(i!=j){\n\t\t\t\tint w=l.a*d.b-l.b*d.a;\n\t\t\t\tif(w){\n\t\t\t\t\tdouble x=cast(double)(l.b*d.c-l.c*d.b)/w;\n\t\t\t\t\tdouble y=cast(double)(l.c*d.a-l.a*d.c)/w;\n\t\t\t\t\tdouble len = sqrt((x-l.s.x)*(x-l.s.x)+(y-l.s.y)*(y-l.s.y));\n\t\t\t\t\tif(0<=len&&len<=l.len)\n\t\t\t\t\t\tq[i]~=li(len,j);\n\t\t\t\t}\n\t\t\t}\n\t\tforeach(j,v;vlv)\n\t\t\tif(l.a*v.x+l.b*v.y+l.c==0){\n\t\t\t\tdouble len = sqrt(cast(double)((l.s.x-v.x)*(l.s.x-v.x)+(l.s.y-v.y)*(l.s.y-v.y)));\n\t\t\t\tif(0<=len&&len<=l.len){\n\t\t\t\t\tq[i]~=li(len,-1919);\n\t\t\t\t\tq[i]~=li(len,1919);\n\t\t\t\t}\n\t\t\t}\n\t\tif(l.a*src.x+l.b*src.y+l.c==0){\n\t\t\tdouble len = sqrt(cast(double)((l.s.x-src.x)*(l.s.x-src.x)+(l.s.y-src.y)*(l.s.y-src.y)));\n\t\t\tif(0<=len&&len<=l.len)\n\t\t\t\tq[i]~=li(len,114514);\n\t\t}\n\t}\n\tbool[][] used =new bool[][n];\n\tforeach(i,ref u;used)\n\t\tu=new bool[q[i].length+1];\n\talias Tuple!(int,\"i\",int,\"j\") ij;\n\tij[] r=new ij[1919893];\n\tint rc;\n\tint[][] sc = new int[][](n,n);\n\tforeach(int i,ref l;ls){\n\t\tsort(q[i]);\n//\t\tq[i].writeln;\n\t\tforeach(int j,v;q[i])\n\t\t\tif(0<=v.idx&&v.idx<n)\n\t\t\t\tsc[v.idx][i]=j;\n\t\tif(l.a*rep.x+l.b*rep.y+l.c==0){\n\t\t\tdouble len = sqrt(cast(double)((l.s.x-rep.x)*(l.s.x-rep.x)+(l.s.y-rep.y)*(l.s.y-rep.y)));\n\t\t\tif(0<=len&&len<=l.len){\n\t\t\t\tint j=cast(int)q[i].assumeSorted.lowerBound(li(len,-114514)).length;\n\t\t\t\tr[rc++]=ij(i,j);\n\t\t\t\tused[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tint ri;\n\twhile(ri<rc){\n\t\tij fr = r[ri++];\n\t\twith(fr){\n\t\t\tassert(used[i][j]);\n\t\t\tif(j<q[i].length){\n\t\t\t\tif(q[i][j].idx==114514){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(0<=q[i][j].idx&&q[i][j].idx<n){\n\t\t\t\t\tif(!used[i][j+1]){\n\t\t\t\t\t\tused[i][j+1]=true;\n\t\t\t\t\t\tr[rc++]=ij(i,j+1);\n\t\t\t\t\t}\n\t\t\t\t\tif(!used[q[i][j].idx][sc[i][q[i][j].idx]]){\n\t\t\t\t\t\tused[q[i][j].idx][sc[i][q[i][j].idx]]=true;\n\t\t\t\t\t\tr[rc++]=ij(q[i][j].idx,sc[i][q[i][j].idx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(0<j){\n\t\t\t\tif(q[i][j-1].idx==114514){\n\t\t\t\t\tprintf(\"-1\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(0<=q[i][j-1].idx&&q[i][j-1].idx<n){\n\t\t\t\t\tif(!used[i][j-1]){\n\t\t\t\t\t\tused[i][j-1]=true;\n\t\t\t\t\t\tr[rc++]=ij(i,j-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(!used[q[i][j-1].idx][sc[i][q[i][j-1].idx]]){\n\t\t\t\t\t\tused[q[i][j-1].idx][sc[i][q[i][j-1].idx]]=true;\n\t\t\t\t\t\tr[rc++]=ij(q[i][j-1].idx,sc[i][q[i][j-1].idx]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble ans=0;\n\tforeach(l;ls)\n\t\tans+=l.len;\n\tri=0,rc=0;\n//\tforeach(u;used)\n//\t\tu.writeln;\n\tforeach(i,vs;q){\n\t\tforeach(j;1..q[i].length)\n\t\t\tif(vs[j].len-vs[j-1].len<eps&&used[i][j-1])\n\t\t\t\tused[i][j]=true;\n\t\tforeach_reverse(j;1..q[i].length)\n\t\t\tif(vs[j].len-vs[j-1].len<eps&&used[i][j+1])\n\t\t\t\tused[i][j]=true;\n\t}\n//\tforeach(u;used)\n//\t\tu.writeln;\n\tbool[][] vis =new bool[][n];\n\tforeach(i,ref v;vis)\n\t\tv=new bool[q[i].length+1];\n\tforeach(int i,vs;q)\n\t\tforeach(int j,v;vs)\n\t\t\tif(v.idx==114514){\n\t\t\t\tr[rc++]=ij(i,j);\n\t\t\t\tvis[i][j]=true;\n\t\t\t}\n\twhile(ri<rc){\n\t\tij fr = r[ri++];\n\t\twith(fr){\n\t\t\tassert(vis[i][j]);\n//\t\t\twriteln(i,\" \",j);\n\t\t\tif(j==0)\n\t\t\t\tans-=q[i][j].len;\n\t\t\telse if(j==q[i].length)\n\t\t\t\tans-=ls[i].len-q[i][j-1].len;\n\t\t\telse\n\t\t\t\tans-=q[i][j].len-q[i][j-1].len;\n\t\t\tif(j<q[i].length){\n\t\t\t\tif(0<=q[i][j].idx&&q[i][j].idx<n){\n\t\t\t\t\tif(!used[q[i][j].idx][sc[i][q[i][j].idx]]&&!used[q[i][j].idx][sc[i][q[i][j].idx]+1]&&!used[i][j+1]){\n\t\t\t\t\t\tif(!vis[q[i][j].idx][sc[i][q[i][j].idx]]){\n\t\t\t\t\t\t\tvis[q[i][j].idx][sc[i][q[i][j].idx]]=true;\n\t\t\t\t\t\t\tr[rc++]=ij(q[i][j].idx,sc[i][q[i][j].idx]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!vis[q[i][j].idx][sc[i][q[i][j].idx]+1]){\n\t\t\t\t\t\t\tvis[q[i][j].idx][sc[i][q[i][j].idx]+1]=true;\n\t\t\t\t\t\t\tr[rc++]=ij(q[i][j].idx,sc[i][q[i][j].idx]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!vis[i][j+1]){\n\t\t\t\t\t\t\tvis[i][j+1]=true;\n\t\t\t\t\t\t\tr[rc++]=ij(i,j+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(!used[i][j+1]){\n\t\t\t\t\tif(!vis[i][j+1]){\n\t\t\t\t\t\tvis[i][j+1]=true;\n\t\t\t\t\t\tr[rc++]=ij(i,j+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(0<j){\n\t\t\t\tif(0<=q[i][j-1].idx&&q[i][j-1].idx<n){\n\t\t\t\t\tif(!used[q[i][j-1].idx][sc[i][q[i][j-1].idx]]&&!used[q[i][j-1].idx][sc[i][q[i][j-1].idx]+1]&&!used[i][j-1]){\n\t\t\t\t\t\tif(!vis[q[i][j-1].idx][sc[i][q[i][j-1].idx]]){\n\t\t\t\t\t\t\tvis[q[i][j-1].idx][sc[i][q[i][j-1].idx]]=true;\n\t\t\t\t\t\t\tr[rc++]=ij(q[i][j-1].idx,sc[i][q[i][j-1].idx]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!vis[q[i][j-1].idx][sc[i][q[i][j-1].idx]+1]){\n\t\t\t\t\t\t\tvis[q[i][j-1].idx][sc[i][q[i][j-1].idx]+1]=true;\n\t\t\t\t\t\t\tr[rc++]=ij(q[i][j-1].idx,sc[i][q[i][j-1].idx]+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!vis[i][j-1]){\n\t\t\t\t\t\t\tvis[i][j-1]=true;\n\t\t\t\t\t\t\tr[rc++]=ij(i,j-1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(!used[i][j-1]){\n\t\t\t\t\tif(!vis[i][j-1]){\n\t\t\t\t\t\tvis[i][j-1]=true;\n\t\t\t\t\t\tr[rc++]=ij(i,j-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.8lf\\n\",ans);\n}"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef dot3(O, A, B):\n    ox, oy = O; ax, ay = A; bx, by = B\n    return (ax - ox) * (bx - ox) + (ay - oy) * (by - oy)\ndef cross3(O, A, B):\n    ox, oy = O; ax, ay = A; bx, by = B\n    return (ax - ox) * (by - oy) - (bx - ox) * (ay - oy)\ndef dist2(A, B):\n    ax, ay = A; bx, by = B\n    return (ax - bx) ** 2 + (ay - by) ** 2\ndef is_intersection(L1, L2):\n    P0 = L1[:2]; P1 = L1[2:]\n    Q0 = L2[:2]; Q1 = L2[2:]\n    C0 = cross3(P0, P1, Q0)\n    C1 = cross3(P0, P1, Q1)\n    D0 = cross3(Q0, Q1, P0)\n    D1 = cross3(Q0, Q1, P1)\n    if C0 == C1 == 0:\n        return False\n    return C0 * C1 <= 0 and D0 * D1 <= 0\ndef cross_point(L1, L2):\n    x0, y0, x1, y1 = L1\n    x2, y2, x3, y3 = L2\n    dx0 = x1 - x0\n    dy0 = y1 - y0\n    dx1 = x3 - x2\n    dy1 = y3 - y2\n\n    s = (y0-y2)*dx1 - (x0-x2)*dy1\n    sm = dx0*dy1 - dy0*dx1\n    if s < 0:\n        s = -s\n        sm = -sm\n    if s == 0:\n        x = x0; y = y0\n    elif s == sm:\n        x = x1; y = y1\n    else:\n        x = x0 + s*dx0/sm; y = y0 + s*dy0/sm\n    return x, y\ndef solve():\n    N, M = map(int, readline().split())\n    ps = set()\n    mp = {}\n    LS = []\n    for i in range(N):\n        x1, y1, x2, y2 = map(int, readline().split())\n        mp[x1, y1] = 0\n        mp[x2, y2] = 0\n        LS.append((x1, y1, x2, y2))\n    for i in range(N):\n        L1 = LS[i]\n        for j in range(i+1, N):\n            L2 = LS[j]\n            if is_intersection(L1, L2):\n                x, y = cross_point(L1, L2)\n                mp[x, y] = 0\n\n    for i in range(M):\n        x, y = map(int, readline().split())\n        mp[x, y] = 1\n    xb, yb = map(int, readline().split())\n    mp[xb, yb] = 2\n    xc, yc = map(int, readline().split())\n    mp[xc, yc] = 2\n\n    *ps1, = mp.keys()\n    ps1.sort(key = lambda x: (x[0], x[1]))\n    mv = {e: i for i, e in enumerate(ps1)}\n    *ps2, = mp.keys()\n    ps2.sort(key = lambda x: (x[1], x[0]))\n\n    ES = []\n    ms = list(map(mv.__getitem__, ps2))\n    ks = list(map(mp.__getitem__, ps1))\n    K = len(ps1)\n    G = [[] for i in range(K)]\n    for x1, y1, x2, y2 in LS:\n        vs = []\n        if x1 != x2:\n            if not x1 <= x2:\n                x1, y1, x2, y2 = x2, y2, x1, y1\n            for k, (x, y) in enumerate(ps1):\n                if x1 <= x <= x2 and abs((x - x1)*(y2 - y1) - (y - y1)*(x2 - x1)) < 1e-6:\n                    vs.append(k)\n        else:\n            if not y1 <= y2:\n                y1, y2 = y2, y1\n            for k, (x, y) in zip(ms, ps2):\n                if y1 <= y <= y2 and abs((x - x1)*(y2 - y1) - (y - y1)*(x2 - x1)) < 1e-6:\n                    vs.append(k)\n        for i in range(len(vs)-1):\n            k1 = vs[i]; k2 = vs[i+1]\n            G[k1].append(k2)\n            G[k2].append(k1)\n            ES.append((k1, k2) if k1 <= k2 else (k2, k1))\n    s = mv[xc, yc]; t = mv[xb, yb]\n    que = deque([s])\n    used = [0]*K\n    used[s] = 1\n    e_used = set()\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            if w == t:\n                write(\"-1\\n\")\n                return\n            e_used.add((v, w) if v <= w else (w, v))\n            if not used[w] and ks[w] != 1:\n                que.append(w)\n            used[w] = 1\n    que.append(t)\n    e_used1 = set()\n    used = [0]*K\n    used[t] = 1\n    while que:\n        v = que.popleft()\n        for w in G[v]:\n            e = (v, w) if v <= w else (w, v)\n            if e in e_used:\n                continue\n            e_used1.add(e)\n            if not used[w]:\n                que.append(w)\n                used[w] = 1\n    ans = 0\n    for k1, k2 in ES:\n        if (k1, k2) in e_used1:\n            continue\n        x1, y1 = ps1[k1]; x2, y2 = ps1[k2]\n        ans += ((x1 - x2)**2 + (y1 - y2)**2)**.5\n    write(\"%.16f\\n\" % ans)\nsolve()\n"
  }
]